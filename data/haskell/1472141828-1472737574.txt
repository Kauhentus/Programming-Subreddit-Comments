[removed]
Late response: `Type` is already in [`Data.Kind`](https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Kind.html) regardless of my proposal. The name ‘*type*’ is fluid, you might call `'True` a type but you can also reserve that name for something that can classify terms (there are no inhabitants of `'True`), calling `'True` a type constant, type constructor or “type-level value” instead... Some references: &gt; The level of **types** contains **proper types** like `Nat`, `Nat → Nat`, `Pair Nat Bool` and `∀X. X → X`, which classify terms, &gt; &gt; *[…]* &gt; &gt; as well as *type operators* like `Pair` and `λX. X → X` that do not themselves classify terms but that can be applied to type arguments to form type expressions like `(λX. X → X) Nat` that do classify terms. (We use the word “types” to include both proper types and type operators.) &gt; &gt; *[…]* &gt; &gt; Proper types are classified by the kind `*`, pronounced “kind type” or just “type.” Type operators are classified by more complex kinds, such as `* ⇒ *` and `* ⇒ * ⇒ *`. &gt; &gt; —*Types and Programming Languages* and &gt; I am careful to use the word ‘type’ to mean only those type-level forms which can have expression-level inhabitants. &gt; &gt; — [*Kleisli arrows of outrageous fortune*](https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf) ---- **Edit** &gt; Some of us use "type" to mean exclusively "thing of kind `*`". Some of us use "type" to mean "thing of any kind". Many of us vacillate between these positions without warning, thus adding to the amount of confusion in the universe &gt; &gt; —Conor McBride [strikes again](http://stackoverflow.com/questions/37367390/do-all-type-classes-in-haskell-have-a-category-theoretic-analogue#comment62249710_37368048)
I've literally spent the past couple of days trying to figure out how to best setup nvim for haskell. This'll make things a lot easier, thanks!
But there is still the “hell” of binary compatibility, right? Even if X-2.0 is fully backwards compatible with X-1.0 on the API level, A needs to be rebuilt when upgrading from X-1.0 to X-2.0.
I'd really like to use this (I'm using ghcid already), but `:Ghcid` does the initial load, then the quickfix window disappears and nothing happens anymore. Running `:GhcidKill` says `Ghcid: Not running`.
Yes, but that's the package manager's job. cabal new-build does a pretty good job at this IMO.
How was the interview? More job-related, to the point or Google-like CS puzzles?
`:messages` produces this: "Database/Query.hs" 620L, 24305C "ghcid" line 1 of 10 --10%-- col 1 "Database/Query.hs" 620L, 24306C written nvim version: nvim --version NVIM 0.1.5 Build type: RelWithDebInfo ... Optional features included (+) or not (-): +acl +iconv +jemalloc +tui EDIT: `ghcid` runs fine, yes!
The [network-simple](http://hackage.haskell.org/package/network-simple-0.4.0.5/docs/Network-Simple-TCP.html#g:3) library does what you want out of the box. There's [client support](http://hackage.haskell.org/package/network-simple-0.4.0.5/docs/Network-Simple-TCP.html#g:2) as well.
If you want to handle it before you pass it in, you also wouldn't need exceptions...
But on the other hand one record solution that fits all might be just hard to come by, after all, records might be used for: * representing some well defined structure (let's say a point with X Y components) * representing a structure that is mapped to database (something like in example from the original post) * being wrapped in newtype producing 'unwrapping' accessor - various runXXX, unXXX idioms It's not like the fragmentation is good, what's good is language expressive enough that users can explore on their own, without being forced to use what's been designed for them.
 clean ::: None -- means that *clean* isn't source of any error *1 spoiled ::: (Error =&gt; e) e -- means that *spoiled* could be source of some error *2 function ::: a -&gt; a -- is source of an error iff you pass spoiled into it *3 -- therefore (repeat undefined) ::: Undefined -- because repeat is *3 and undefined is *2 (w = w) ::: a -- anything, cannot be decided at compile time -- furthermore (if x then clean else spoiled) ::: (Error =&gt; e) e -- you always expect the worst Note that: Error signature tells you that `x` CAN be source of error, not that it WILL be
what do I want?
I meant that adding the flag, while perhaps ideal, might possibly have enough cost to not be worth it. I don't expect that's the case, but I'd definitely leave that call to those more involved. Presumably changing the warning to an error should have negligible cost in development or maintenance of the compiler, which is what I had in mind. If it imposes an undue burden on those of us trying to keep our code compiling, that's... interesting.
With Maybe/Either, you handle the error **after** it has occurred, which is too late in some cases. With types like NonEmpty / NonZero, you have to convert between types every time. I don't like either of these solutions. I want to decide myself the input is safe enough to be used as an argument to function because I am smarter than the compiler. Error signature simplifies this work immensely.
&gt; apart from this particular case, the way to build broken things is as you said to use -fdefer-type-errors There are a lot of broken things that I build by turning off -Werror. There are a lot of errors that I would prefer never to bother building with outside extreme situations.
Sure -- so ghcid is running now and the ghcid window is updated on every save (with the correct ghcid output). However, no line markers are created and the quickfix window doesn't show up (should it?) Is it possible that you depend on a newer ghcid version? I'm running 0.5.1, but the error messages come from GHC anyway, right?
Ok great, the only thing that might be causing a problem when the ghcid window closes is if you don't have `set hidden`, which would mean the buffer is destroyed as soon as it closes. Could that be the case? The quickfix window isn't supposed to open automatically, but if you run `:clist` you should see errors that ghcid reports, and if you run `:cc` it should jump to the first error. EDIT: I tried ghcid-0.5.1, it won't work because the plugin depends on the "All good" status message that the newer versions give.
Very nice. Once Vim 8 arrives, there will be the possibility of doing something like this in Vim + tmux.
This is beautiful :D :D :D
Ok, I think the GHC8 error messages are slightly different to 7.x in that there's "error:" at the end of the header line, I've removed that from the regex, if you want to give it another try. Thanks for bearing with me :D
&gt; With Maybe/Either, you handle the error after it has occurred, which is too late in some cases. Do you have any examples of times Either wouldn't work but an exception would? 
Great! I'm actually working to fix that right now, seems that the second error only shows up half the time :S
Agreed. And it will encourage the use of out-of-date packages, or potentially even buggy code. 
Nope. Maybe when it has more than 18 commits it'll be *something*.
Awesome! :)
I'm definitely going to try to support vim8 when it lands, although the lack of terminal buffer makes things more complicated!
Thanks!
So this is a web development methodology that only works if you can express your entire webapp in javascript, where all server-side stuff is made by other people?
From what I see here, this is exactly the same information that the Either monad would give you. 
Also try this nice plug in for Atom https://atom.io/packages/ide-haskell
Y U SCREENCAP AND NOT USE LPASTE http://lpaste.net/
I could see using HaskellR if you wanted to wrap statistical models in a robust Haskell app (for example, to run some data analysis or statistical modeling within a haskell website). Exception handling and being confident in any runtime guarantees in R is really difficult beyond very small scripts or apps.
By that logic is `repeat ()` also a potential source of error? Because you could call `length` on it? Because then `take 5 $ repeat ()` is "spoiled" even though it is just `[(), (), (), (), ()]`. Also so is `zip [1 ..]` because of the `[1..]`. Either that or you have to keep track of finiteness alongside bottom values.
When this happens usually you probably want to check to see if you have any tabs being expanded in the file to some number other than 8 characters due to the configuration of your editor. When in doubt move stuff directly after the 'do' to a new line: eval env (App e1 e2) = do val1 &lt;- eval env e1 val2 &lt;- eval env e2 case val1 of FunVal env' n e -&gt; return $ eval (Map.insert n val2 env') e However, in this case, the error is actually on the next line. The case should be outdented to match `val2` not `eval`. GHC is rejecting the program because the last statement in a do block can't have an &lt;- in it as there is no subsequent statement to accept the variables you are binding. Your function is being parsed as eval env (App e1 e2) = do { val1 &lt;- eval env e1; val2 &lt;- eval env e2 case val1 of { FunVal env' n e -&gt; ... } } not what you expect. `do x &lt;- y; z` gets turned into `y &gt;&gt;= \x -&gt; z`, but this requires a subsequent statement (`z` in this case).
I mostly agree with the benefits listed in the article. Haskell is great. &gt; The programs are lightning fast, because they’re compiled and because Haskell has lots of optimizations, like laziness. They are fast, but to be fair, GHC's GC leaves quite a bit to be desired. Namely latency, parallelism, and the handling of large working sets (compact regions only partially address this). And laziness... some people swear by it, others consider it a bad default... in either case I wouldn't call it an optimization. Also, partially on the topic of "delivering features faster", sometimes you're thinking of making a change that involves making a function `IO`, or involves adding something to its `State`. If everything was strict, you could quickly hack a solution with `unsafePerformIO` to test the idea. And laziness makes debugging harder, and the layout rule is awkward, and... okay, nuff ranting. These are my only major complaints about Haskell.
Is the example project for the shareable api available somewhere so I could play with it? Or is there another public (sample) project that uses `Spock-api-ghcjs`?
Plenty of nice features, but not so complex I can't understand it. 
`const (const True)` is an equivalence relation though. It's the one where every element is equivalent to every other element.
With exceptions, you also handle errors after they occur (that is actually a pretty important aspect of exceptions). I could be mistaken, but it sounds to me like you actually don't want exceptions either since it seems like you don't want to do any checking in the code itself. I'm not aware of a language where you have a fourth option in addition to: 1. Handling errors before they happen (checking with `if`, pattern matching, etc before passing the argument in) 2. Handling errors after they happen (exceptions, `Maybe`, `Either`, etc) 3. Not handling errors at all, letting failures happen at runtime (possibly with compiler warnings about these potential runtime errors). Haskell does allow partial functions and partial pattern matching, which is what it sounds (to me) like what you want. If you have safeDiv :: Int -&gt; Int -&gt; Maybe Int safeDiv _ 0 = Nothing safeDiv x y = Just (x `div` y) You could define `unsafeDiv` using `safeDiv`: unsafeDiv :: Int -&gt; Int -&gt; Int unsafeDiv x y = case safeDiv x y of Just r -&gt; r If you enable warnings, GHC will warn you about all of these partial `case` matches too.
What does this have to do with Haskell? 
This is either a joke or the author is a narcissist bursting with the Dunning-Kruger effect--or your fave theory on such behaviour. 
Oh I don't think I would in that case. Using the core combinators from Functor/Applicative/Monad is what I consider the best practice. I just tend to avoid creating *new* functions/combinators that take `Maybe` as a parameter, because usually the core combinators do it better.
Oh I see what you mean.
lots of data science-y posts on /r/haskell recently, that's good :-)
This is a quote from the author of Keras, a popular deep learning framework. On [this page](https://www.quora.com/What-are-some-important-engineering-and-design-decisions-you-made-in-creating-Keras/answer/François-Chollet) he elaborates further on why he thinks FP is unsuitable but OOP is. I think his criticism is more an issue of where he's most experienced but am interested in what people here have to say.
A Haskell function `f` of type `A -&gt; B` is given as its denotational semantics a mathematical function `f'` of type `(⊥ ∪ A) -&gt; (⊥ ∪ B)`. ⊥ is a mathematical value, not a Haskell value. Laziness makes `undefined` look like a Haskell value corresponding to ⊥, because we can assign a reference to `undefined`, we can return it, we can put it in a list, all manipulations which we can usually only do with values. But of course, we don't store the value `undefined`, we store a thunk which, when forced, throws an exception instead of evaluating to a value. Similarly, we can store the expression `True || False` into a list etc., but that doesn't make `True || False` a value distinct from `True`: it is simply a thunk, which hasn't yet reduced to a value.
Given these Haskell functions: f1 :: A -&gt; B f1 = undefined f2 :: A -&gt; A f2 = mapException $ const undefined ...what are the corresponding mathematical functions `f1'`, `f2'`? Which of the following are (i.e., evaluate to) values? * `undefined` * `Just undefined` * `const undefined` Note: from the Haskell Report 2010, sec 1.3: &gt; An expression evaluates to a value and has a static type.
Vinyl records have an extra parameter that books do not. `Rec :: (k -&gt; *) -&gt; [k] -&gt; *` vs `Book :: [*] -&gt; *`. Functions like `rmap` are are defined for transformations of that parameter `rmap :: (forall x. f x -&gt; g x) -&gt; Rec f rs -&gt; Rec g rs`. I think it's a very natural parameter for use cases for heterogeneous collections. For records you could have `f ~ Tagged Symbol`, or for a database edsl you can have `f ~ SQLValue` vs `f ~ SQLType` vs `f ~ SQLExpression` where each is a GADT embedding the sql value/type/expression's type in Haskell and statically ensuring that e.g. rows (collections of values) match schemas (collections of types).
Near-impossible to compete with the established deep learning code bases, but a monster? If deep learning started [here](https://idontgetoutmuch.wordpress.com/2013/10/13/backpropogation-is-just-steepest-descent-with-automatic-differentiation-2/), it would cut a lot of sloppy thinking out of the hype.
I'm no expert, but my first reaction is that his criticism is specifically of the naive functional approach. The complaint, basically, is that there's enough auxiliary state and such surrounding the flow of pure values that the simplistic view of a computation graph as a composition of functions isn't implementable as-is. Okay, true. But what you get from a powerful functional language is a set of tools for building abstractions for situations like this, and working with them in a way that keeps the bookkeeping out of view and focuses on the core of what's happening. For an analogous situation, look at functional reactive programming. There, as well, there were some ideas that nicely capture the core of what's going on, but are not easily implementable as is. (For example, `type Behavior a = Time -&gt; a` is a semantic model that's insufficient for an implementation.) But rather than saying "Oh well, we'll just build another OO GUI toolkit", people asked how they could build types and combinators that *do* capture the simple semantic notions, but are not implemented in a naive way.
Well, that's *annoying*, sure. But at least it's a problem the tools warn you about loudly and in advance. So I'm not sure I'd call that hell (compared to chasing arbitrary unknown issues). If anyone knew how to solve that, we'd be a lot further in solving packaging in general.
&gt; The functional approach would have implied layers as functions which would create weights when being called, and would store them in global name-indexed collections (this is the approach taken by TensorFlow-Slim, for instance). This means that many operations (model loading, accessing an existing weight tensor) must be done by name-matching, so you need to give carefully names to every tensor you create rather than relying on auto-generated names. And of course there is a constant risk of name collision, which typically prevents from being able to manipulating multiple independent models in a single session. To me, this looks a lot like an anti-pattern. The object-oriented approach is cleaner and scales better. https://www.quora.com/What-are-some-important-engineering-and-design-decisions-you-made-in-creating-Keras/answer/Fran%C3%A7ois-Chollet A very odd assertion. In short, this guy is probably a genius at deep learning but knows nothing about FP design.
&gt; Note that * itself is a type, with * :: *. So what are the values of *? Just bottom: Quoting @pigworker from a [SO comment](http://stackoverflow.com/questions/38146693/what-is-the-type-of-a-kind/38148977#comment63767011_38148977): &gt; The type Type does not currently have inhabitants in the term language. Rather, a singleton encoding is used to fake them up. In the future, though, the adoption of pi-types, abstracting over the things which may safely live both in types and at run time, would make it possible, sensible and useful to add run time types. Moreover, the parametricity of forall-types would persist. 
I'm curious what the non-naive approach might look like. I want to implement machine learning algorithms in Haskell and I'd love to understand the problems and potential solutions better. Do you have ideas (or links) about this?
&gt; (4) There's a type `Any :: forall (t :: *). t` &gt; &gt; This means types-as-kinds are not closed in the way you'd expect: No, `Any` is an empty closed type family, not a constructor. `Any :: Bool` no more makes the `Bool` kind open than `undefined :: Bool` makes the `Bool` type open. (This wasn't always the case, which was a design mistake, and it was changed a release or two ago. See [Trac #9097](https://ghc.haskell.org/trac/ghc/ticket/9097))
I'm sorry but there is no actual argument there. Also, I (and maybe others?) have been working on exactly this, with no problem so far =)
A non-naive approach would definitely involve a lot of `ST` monad under some more useful abstractions. There's really very little you can do with OOP that you can't do with lenses and `ST`.
You are right, you can always transform a program that doesn't type check in one that doesn't terminate. That doesn't mean it's a good thing. What I mean is we already have undefined (or equivalent) and we can't indeed do anything about it. But that should be it. There is no need to new runtime errors especially when they could be easily prevented.
Infinite loop / list is not an error.
`undefined` is not an exception and you shouldn't think of it that way. You should only use it in areas of the program that will never be reached, but whose inaccessibility you cannot 'prove' to the compiler through the use of stricter types, etc. As you know, there will always be times when the compiler cannot prove that a section of code is unreachable in the execution of a program. This is because of the halting problem, and there is no way around this. In order to get programs that compile and can compute the same functions as a turing machine, we need to be able to express `undefined`. `error` and `undefined` are really the same thing, except `error` gives a nice name to the exception thrown at run-time. The use of `undefined` as a 'return value' in certain partial `Prelude` functions (such as `head` and `tail`) is widely regarded as a mishap, and these functions are only kept around to make old code work. You should use safer variants or direct pattern matching instead.
To be fair, back propagation is not the essence of deep learning, it is the essence of neural networks, which have been around for decades. "Deep learning" implies the use of novel bio-inspired techniques such as Convolutional Neural Networks - so, there actually is something new. 
Nope, sorry.
Currently there is not, but I will provide one. I'll be at MuniHac ( http://munihac.de/ ) next week and try to put something in place.
I would think that FP would be a great venue for specifying numerical computations. The important part is that it is used for specification, e.g. it would be mapped onto an underlying runtime system like TF/Theano. I'm not familiar with the depth of DL frameworks, but I don't see a difference between OO languages like Python and FP languages like Haskell if this is true. The high-level frameworks would ultimately serve only to compose these computations, which I would figure is particularly suited to Haskell. I don't think I understand the author's point about the applicability of functional paradigms to this; after all, you can emulate OO in Haskell (and I don't think it would be unusually bad looking in this case). I am especially interested in the applications of Idris, for its dependent types, to this subject. As advertised, it should be a natural vehicle for cleanly building DSLs within the language - I think this would be immensely powerful. I've been thinking about demonstrating a simple static type system for matrix computations, which would be particularly good at rejecting runtime errors like incompatible matrix dimensions that you see often in MATLAB. 
Yeah, will look into that. Currently only tested on stack projects.
I'd like to be able to write numerical computations regardless of how they're going to be executed, at a high level. And then be able to run them on CPU or GPU, without changing the code. This is all motivated by how annoying it's been for me in the past to port statistical learning algorithms I wrote on top of say hmatrix to run on GPU. One of the models was a really dummy deep neural net. IIRC there is one or two implementations of those on github (in Haskell, that is).
thanks :)
Exactly. Only vinyl has both an inductive definition and the functor paramater. Writing extremely generic functions (like `rmap`, or `rfold`) is pretty easy. `ElField (s,a)` is like `Tagged Symbol a`. 
Another advantage of `f`, the original motivation: f ~ Const String f ~ Maybe f ~ Identity 1. Get a row of strings, `Rec (Const String) [Int,Bool]` 2. Try to parse and validate each (with `String -&gt; Maybe a`), `Rec Maybe [Int,Bool]` 3. "sequence" it, which succeeds if every row succeeded, `Maybe (Rec Identity [Int,Bool])` `rtraverse` can do 2 and 3. or `rapply`a record of validators to a record of strings-to-be-validated https://hackage.haskell.org/package/vinyl-0.5.2/docs/Data-Vinyl-Core.html#v:rtraverse https://hackage.haskell.org/package/vinyl-0.5.2/docs/Data-Vinyl-Core.html#v:rapply 
IMHO it is a matter of using a monad with extensible state, that may handle parallelism and distributed computing. I think that the state, the parallelism and the distribution of resources necessary for a reimplementation of TensorFlow in Haskell can be made with elegant functional composability using [transient](http://github.com/agocorona/transient). Distributed map-reduce is already implemented in transient and many deep learning algorithms are implemented over map-reduce. I wrote something about this here: https://www.reddit.com/r/haskell/comments/3t5722/why_does_the_tensorflow_paper_sound_suspiciously/cx3b20r 
It might be worth looking at [hsnippet](https://bitbucket.org/mightybyte/hsnippet/) for ideas - it uses Snap for the backend, reflex for the frontend, and has some common data types in between. It should also be possible to write the backend logic using reflex...
Another thing to look at is using electron. [Here](https://kritzcreek.github.io/posts/2016-07-05-purescript-electron.html)'s an article about how to start using electron with purescript.
Ah dangit. `const (const False)` then.
Currently a mirror is uploading, but the main docs are already up: https://spockdocs.s3.eu-central-1.amazonaws.com/Spock-0.11.0.0/Web-Spock.html . I will link them everywhere asap
It definitely takes a lot of time. One piece of advice (as the original author of the servant tutorial), if I may: start small. Just write down something that explains the basics, with the main use cases in mind. This shouldn't take more than a couple of hours. It won't be perfect, people will complain that there are many undocumented things but at least it'll be a good starting point and there will be a lot less to figure out at once for newcomers. That's how we did it for servant and we got a lot of good feedback even if the tutorial doesn't cover as much as I want it to.
Far from it.
Hoes does it compare to the RRB vector performance-wise?
Yeah, I didn't know that about vinyl in particular, but that approach is what I had in mind when I referenced `generic-sop` (e.g. [`NP`](https://hackage.haskell.org/package/generics-sop-0.2.2.0/docs/Generics-SOP.html#t:NP))
&gt; ...what are the corresponding mathematical functions `f1'`, `f2'`? I'm not familiar with `mapException`, but it should be easy to figure out the answer by simply evaluating those functions on a few different inputs. data A = A deriving Show data B = B deriving Show -- | -- &gt;&gt;&gt; f1 A -- *** Exception: Prelude.undefined -- ... -- &gt;&gt;&gt; f1 undefined -- *** Exception: Prelude.undefined -- ... f1 :: A -&gt; B f1 = undefined Clearly `f1' _ = ⊥`. I'd try `f2` next, but it doesn't type check because [`mapException`](http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception-Base.html#v:mapException) needs two concrete exception types `e1` and `e2` in order to figure out which instance of the `Exception` type class to use. Let's pick two exceptions which are easy to trigger: -- | -- &gt;&gt;&gt; f2 A -- A -- &gt;&gt;&gt; f2 undefined -- *** Exception: Prelude.undefined -- ... -- &gt;&gt;&gt; f2 ((1 `div` 0) `seq` A) -- *** Exception: *** Exception: Prelude.undefined -- ... -- &gt;&gt;&gt; f2 (assert False A) -- *** Exception: Assertion failed -- ... f2 :: A -&gt; A f2 = mapException (const undefined :: ArithException -&gt; AssertionFailed) Clearly, `f2' A = A` and `f2' ⊥ = ⊥`. Note that Haskell's usual denotational semantics does *not* distinguish between different kinds of exceptions (nor between exceptions and non-termination), so if you want to use denotational semantics to say something interesting about the way in which `mapException` transforms exceptions, you'll have to use a more precise denotational semantics than the usual one. As a side note: why do we get this weirdly doubled `*** Exception: *** Exception: Prelude.undefined` output? I think it's because the arithmetic exception is thrown, then `mapException` lazily transforms the exception into an assertion exception, then the exception reaches the top of the stack, it starts being printed as `*** Exception:`, now the exception-printing machinery needs to force the exception's thunk in order to know what to print, but the thunk itself throws an exception (`undefined` is not a value of type `AssertionFailed`, an example value would be `AssertionFailed "foo"`), so the exception-printing machinery aborts, we reach the top of the stack again, and `*** Exception: Prelude.undefined` is printed. **edit**: I also plan to address the `Just undefined` part, but it's since it's taking me a while to write my reply I will add it as a separate comment later.
An expression can never evaluate "to" bottom by Haskell's evaluation rules, though, so bottom is not in the set of Haskell values. Rather, it's part of the denotational semantics of Haskell expressions. undefined does not evaluate to a WHNF value, but its denotation is bottom. Edit: For what it's worth, I don't really care for this overloaded meaning for "value" (operational vs. denotational), but the only way I see to really avoid confusion would be to come up with alternative words for both meanings. I have the words "denotation" or "meaning" for one of the meanings, but am not sure what to call the other.
Ah well too bad, it would have been too good to be true :)
[Common Lisp's conditions/restarts](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) are maybe a fourth option; in effect, you're handling errors *as they happen* so the function that threw the error can continue to execute. Here is a [bit of discussion](https://mail.haskell.org/pipermail/haskell-cafe/2014-February/112709.html) on Haskell-cafe about what Lisp-style restarts could look like in Haskell. 
&gt; RRB Vector. The RRB-Vector [14] uses a balanced tree to represent immutable vectors, focusing on practical issues such as parallel performance and cache locality. These performance considerations are outside the scope of our current work, but are interesting for future work.
Thanks. I had seen this paragraph but it doesn't really answer my question, that's why I asked here.
I wrote a [similar plugin](https://github.com/saep/nvim-hs-ghcid) about a year ago. It uses a [haskell plugin wrapper](https://github.com/neovimhaskell/nvim-hs), so it might be a bit harder to setup.
I'm pretty sure it's because `Yesod` isn't doing content-type negotiation. E.g., try sending a request with "Accept: text-html" to the yesod endpoint. I'm willing to bet fewer than 10% of the applications in the TechEmpower benchmarks are doing content-type negotiation. It annoys me a little that we'd get penalized for that. It also annoyed me a little to have to remove `charset` from the `text/html` response for performance, resulting in longer code; if someone looks at the `servant` example, they'll think it's more verbose than it really is, simply because it's more verbose to do the wrong thing. I'm definitely not going to put in time to write a combinator without the content-type check just for TechEmpower.
How about using unsafePerformIO, and then hiding the internal structure behind a module? (Also, possibly dumb idea: how about having each value carry a random seed, with a fixed random seed baked in the code for the empty sequence?)
40 minutes of introduction.
I would love to see the changes caused if TechEmpower benchmarks change to handle content-type negotiation, perhaps a few other common headers, and just generally tried to enforce that folks do the right thing. Maybe a test suite that runs against the program prior to it being benchmarked. I have no idea what kind of effect it would have, but there's a chance it would be fascinating to watch.
Ah very nice.. I was thinking of doing that but wasn't sure how much control over vim you would have from haskell. How did it turn out?
In my understanding, the idea is not to serve both HTML and JSON, but to only return JSON if the client actually accepts it - which is the correct behavior. Checking that has a non-zero cost.
&gt; I don't think I understand the author's point about the applicability of functional paradigms to this; after all, you can emulate OO in Haskell (and I don't think it would be unusually bad looking in this case). OO can be emulated iin haskell and many designs that do not optimaly use Haskell are done that way consciously or unconsciously. What the author supposes (IMHO) is a proper use of functional language, and this means some kind of composability that model the problem at a high level despite the presence of impure effects
Thanks for that explanation :) Is this the reason for the 8-15% performance penalty? A header lookup and an if-condition? 
No, it's quite a bit more complicated. There are wildcards, in type and subtype, there are parameters, there are quality factors. See the [RFC](https://tools.ietf.org/html/rfc7231#section-5.3). Also, it's only as high as 15% because in this case the handler basically doesn't do anything. 
Seeing so much Go-lang on top makes me very happy to se Haskell at the bottom. Just basic inference I guess ...
Again, I'm not an expert in machine learning. But this seems reminiscent of FRP in many ways, actually. In FRP, you have a changing environment of events and behaviors coming from a user, and want to wire them together in a graph with your own events and behaviors that depend on those. In a deep learning scenario, you have a changing environment of activations and weights, and you similarly want to wire them together in a graph with your own activation functions. I suspect someone with deeper knowledge of the challenges of designing a machine learning framework would benefit from studying the FRP landscape in some detail.
If you don't need a client + server architecture, don't design it that way. Changing something from being a standalone application to being a client that communicates with a server is likely to require some substantial changes to your application regardless of what it was originally built with. That aside, I've used GHCJS with reflex. I think that reflex is a good FRP solution, and I would recommend it. However, I have never seen any solutions for doing interop between reflex-dom and native javascript libraries. Purescript's community seems to be much more focused on address this issue. For example, there are decent react bindings for purescript.
Because I know that is the case. That is like the core principle behind undefined. Every type is inhabited by non-termination because of Turing completeness. So "undefined" is a runtime-friendly way of using that non-termination. Because for all intents and purpose undefined does not terminate, in the sense that no further code is run after a bottom value is reached, just like non-termination. 
I didn't want to name names, but I'm coming from doing mostly Ruby and Rails development; I suppose that explains a lot :-)
I absolutely love Bartosz Blog posts about Cat. Theory for Programmers. Would love to see him unpack more of those in video! https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
To be fair, major packages like Tensorflow use automatic differentiation and Theano uses symbolic differentiation to compute derivatives in a style similar to automatic differentiation.
The inspiration of convolutional nets goes back to the 60s/70s and the general design has been around since at least the 80s. I'd characterize deep learning as the set of tricks to get many layered networks to train. This includes the use of GPU but also ideas like batch normalization, relus, drop out, gates, residual connections, gradient tricks like RMSprop and so on. So I'd say backpropogation is the essence of deep learning.
But it's the same as the original algorithm from a semantic standpoint. Undefined is semantically non-termination. Like within pure Haskell code it is impossible to distinguish undefined from a true infinite loop. Only OUTSIDE your Haskell code (your terminal / runtime) can you see the difference. In fact: undefined :: a undefined = undefined Is a perfectly valid way to define undefined as far as the official language specification is concerned. Look into (Google) the reasoning behind undefined, it's all about Turing completeness and non termination. Not being able to distinguish nontermination from some sort of "error that somehow inhabits every type implicitly" is a pretty big part of the theory of Haskell as well as a good practical measure to make people use Maybe instead of having nulls hiding and sometimes needing to be caught.
So what? They are "productive" infinite loops, as in they aren't just stuck. We are talking specifically about "unproductive" infinite loops. "[1 ..]" is productive (not what we are talking about), but "length [1 ..]" is not.
what do you think of the fact that Yesod test is basically dropping down to the WAI level?
I'm glad to see that's been fixed. I was a bit horrified by `Any` when I came across it.
OK, so, I'm using "value" in the same sense as the Haskell 2010 report. For example, from sec 3.1: &gt; Since Haskell is a non-strict language, all Haskell types include ⊥. That is, a value of any type may be bound to a computation that, when demanded, results in an error.
Finally I get, what udefined actually is. But I still don't get, why Prelude exports this ugly type. Why does Haskell promote using it? Shouldn't we make it "hard" to pass `bottom` around? 
I'm glad you're looking into this. As bad as the TechEmpower benchmarks may be at actually judging performance, they offer a valuable "marketing" strategy. If that's all they offer, I still think it's worth some investment from the community. Ruby's community has a tremendous amount of "marketing" force behind it, which I think ultimately has a positive effect on its plausibility in production.
Might still be worth noting it/bringing it to public attention. Maybe it will be fixed in the long term.
It can be quite useful, because sometimes you want to: Make a partial function (e.g a function with preconditions that can't be proven by the compiler, such as '!!' having to be given an integer within the range of the list), but with a nice error message for when you call it wrong: head :: [a] -&gt; a head (x : xs) = x Is worse than the real head function because it just gives "pattern match failure" rather than "Prelude.head: empty list" Make your partially written function typecheck, in case you are part way through making it and want to see if the types match up so far. Along those lines also situations where you want to build from the top down but want to check the types sometimes, because before you have written the lower functions the top function cannot typecheck, but throw in an undefined and you can find out for sure. On top of that it is because otherwise people would just be writing "let x = x in x" or "undefined = undefined" wherever needed in there code, which just makes things harder because pseudo-termination given by undefined is much more friendly to work with than true nontermination. Particularly if your function or program takes a while to produce output. When part way through making my own programs I do the latter (partially made function type checking) fairly frequently, as I find that sometimes top down is easier, as you don't have to try and think ahead to which low level functions you will need nor do you have to context-switch as much, whenever you are missing a function you want to write just temporarily stub it out using undefined and get back to what you were doing. The former I do less as I try to avoid intentionally making partial functions, but with that said I often use partial functions (perhaps more than I should) within my own functions where I know (or at least think) that it is safe to do so.
&gt; GHC's GC leaves quite a bit to be desired So far as I can tell the only people hitting this limit are folks doing *very* low latency applications and working with *very* large working sets. This is not an issue that the average Haskell app runs into. My only point is that when you're dealing with really tight constraints, few systems out there make you happy. It's just hard.
I would suggest to add a README (even if it is just to add a link to the haddock). Many people might look for one and dismiss without realizing there is some valuable help content available. 
Indeed. The haddock tutorial is really impressive! I almost didn't bother digging that far, glad I did.
Hmm, good point, maybe the denotational semantics of a function of type `A -&gt; B` should be a mathematical value of type `⊥ ∪ ((⊥ ∪ A) -&gt; (⊥ ∪ B))` then? This is getting messy...
And `⊥` is more than one value. For your amusement, try this in ghci: let e = error e in e
I literally googled "finite field Haskell": https://hackage.haskell.org/package/finite-field
A Google search turned up: - https://github.com/rcallahan/Galois - https://groups.google.com/forum/#!topic/flint-devel/KBIzH5Gp53k - Code in the [HaskellForMaths][1] package which implements F16: https://hackage.haskell.org/package/HaskellForMaths-0.4.8/docs/src/Math-Core-Field.html#F16 This can give you some ideas of how to implement F(2^16) yourself. [1]: https://hackage.haskell.org/package/HaskellForMaths 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/reflexfrp] [reflex-dom CofreeT Syntax Tree builder • \/r\/haskell](https://np.reddit.com/r/reflexfrp/comments/4zqoxq/reflexdom_cofreet_syntax_tree_builder_rhaskell/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I tend to take the TechEmpower benchmarks as more like car racing: some of that code is so finely tuned that it looks unlike what most practitioners are going to use in practice. Is this representative? Maybe.
&gt; You have to understand the abstractions used in the code in order to understand the code ish, but the most direct alternative is that you have to understand the abstractions used in a code which are not actually wrapped up in language-level abstractions. In that case you get the worst of both worlds.
Position Dev is small potatoes in comparison... :'(
Brush up on your math mate: https://en.wikipedia.org/wiki/Finite_field?wprov=sfla1
Nah, he's not a genius. He's a software engineer at Google working on Keras, a high-level wrapper over TensorFlow. No papers, nothing indicating expertise.
Eh very embarrassing, sorry for that. I've actually worked with finite fields in pure maths a lot. I guess I just didn't expect the less obvious ones to show up here. What do you need them for?
Good idea! README should be visible on both GitHub and hackage now.
I don't have the answers for you, but a few things jumped out at me after a quick look. - There _is_ a Comonad instance for CofreeT, which might be worth having a look at for ideas. - Do you need memoExtend? I can see how you would if you were going to allow external folks to pass functions to it. If it's just for you, couldn't you just use extend and only pass it functions that work to a certain depth? Either way, I'd be interested to see what happens if you swapped `memoExtendCofreeT` for `extend` on line 56.
Although not an orthodox solution by any means, I recently added [Webkit](https://github.com/deech/webkitfltkhs) support to [FLTKHS](http://hackage.haskell.org/package/fltkhs) which allows you to run arbitrary JS in a Webkit window and listen for DOM events natively. Seems like it might be a good bridge between two worlds. Although I haven't tried it I don't see why you wouldn't be able to use PureScript/GHCJS to generate the JS.
Are you looking for something specific? I care only about the `stack` ones... I could try to build a given `lts` snapshot if you want.
[ghcjs-hplay/transient](https://github.com/agocorona/transient/wiki/Transient-tutorial#transient-in-the-web-browser) permits you to code the client and the server in a single and seamless haskell program without explicitly needing to manage websocket communications, callbacks etc. it is fully reactive in the browser and the server. You can control the server from the browser or viceversa. Events from the server can propagate to the browser and viceversa. And is composable: you can componentize the application, add or remove widgets using standard haskell combinators like &gt;&gt;= &lt;|&gt; &lt;*&gt; etc. This is important for an IDE . You can also decide which part of the code will run in the server or in the browser and change that easily Only it is necessary to compile the same program with ghcjs and ghc: https://github.com/agocorona/transient/wiki/Transient-tutorial#transient-in-the-web-browser
Wait until you see people making love to stuff like this all throughout their code: https://hackage.haskell.org/package/lens#readme Come back then and tell me how easy it is to read other's code. Go deep enough down the rabbit hole with Haskell and you will start to cultivate a distate for a simple imperative programs that loop over a collection of characters and counts specific occurances. https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf of course you need special abstractions to make a simple loop more modular (where "modular" in the paper above is used in a very specific sense). Is it easier to understand someone else's code when using Haskell? It depends on whom that someone else happens to be; which is generally the case for any programming language. If a programmer is accustomed to large Rails applications then know that almost anything otherwise will make it easier to understand someone else's code. Ruby and Rails is write optimized not read. I actually think that most of the code I write is clearest when I find myself using a functional style in an imprative (non OO) language with smart looping contructs and a decent type system (GoLang). Note that I love Haskell and have been doing it for years but lately I've been moving toward Idris as my "nobody sane uses it" language of choice.
I've always liked the graph [in the middle of this article](http://www.aosabook.org/en/posa/warp.html) for performance-based marketing.
eg: resolver: lts-6.13 compiler: ghcjs-0.2.0.9006013_ghc-7.10.3 compiler-check: match-exact setup-info: ghcjs: source: ghcjs-0.2.0.9006013_ghc-7.10.3: url: "https://tolysz.org/ghcjs/lts-6.13-9006013.tar.gz" sha1: "7ae7c6571e0fc7642701af3d8a63739369e0f6e8"
I take it [this](https://github.com/commercialhaskell/stack/issues/2364) is fixed on node 6.4?
I would think so. I build it on 2 machines with node6.4 (and yes it was not building earlier :) )
To my knowledge, /u/tolysz's posts are the closest thing we have to a real release system with GHCJS. I think a proper release system just isn't a priority right now, though maybe it should be
This is fantastic! This is the most complete and user-friendly approach I've seen yet. With a library like this in place, I think the "records problem" has received the mortal wound. With enough time GHC 8 will be the norm and we need to get some sort of "consensus" on which approach to use so APIs can start talking the same language. 
Indeed. There is a unique finite field for every prime power. Since each is a field extension of the prime subfield F_p (the field of p elements), it is also a vectorspace over F_p. This means each F_p^(n) has the additive group structure of n copies of F_p: Z/pZ ⊕ Z/pZ ⊕ .... ⊕ Z/pZ (n copies).
&gt; Keras, a high-level wrapper It's a *wrapper*? It would be even easier to come up with a competing version in Haskell then.
`String` is a basically a type alias for `[Char]`, a list of 32 bit Unicode `Char`. `ByteString.Char8` is an array on 8 bit bytes (basically the same as an `char` array in C). 
This is rather interesting! Do you know how one would lift the restriction that the same program is run on the browser and the server? They might have different capabilities, such as the server linking with native libraries.
A Haskell `Char` is not a byte. It's a Unicode character. There's a decoding step from bytes to characters. See example below. "测试→" is typed in. Prelude&gt; import qualified Data.ByteString as B Prelude B&gt; getLine 测试→ "\27979\35797\8594" Prelude B&gt; B.getLine 测试→ "\230\181\139\232\175\149\226\134\146" 
Does the StrictData pragma still work as expected (switching declarations to be strict by default) ?
I believe it just wraps over TensorFlow, Theano or other "automatic differentiation" engines when defining neural networks and uses them to optimize.
[removed]
&gt; I actually think that most of the code I write is clearest when I find myself using a functional style in an imprative (non OO) language with smart looping contructs and a decent type system (GoLang). This is quite an.. exciting observation that you made here about Go. So far I've heard nothing but bad things about it..
I guess the type the function returns has a Show instance, which basically means that when you press "enter" on the REPL it calls "show" on it, and you see a string. So it's part of the library design, not the REPL itself. Maybe HaskellR docs aren't comprehensive?
I will certainly take a look at this, thanks!
I'm still at the planning phase, so I have the choice. I will probably want to make a web app if it works as I wish. The kind of Javascript libraries I would like to use are like Ace, Pdf.js, etc... which are really different in scope from JQuery, for example. Do you think that just making bindings for these would be feasible?
Thanks for the reference! Now I have both the Purescript and Haskell references for using Electron, amazing! In the beginning you say the people used statically compiled Haskell executables, do you do the same? Is that necessary? I had lots of problems trying to compile statically things in Haskell...
Thanks for the reference!
I guess to me it looked like your objections to Behaviors have very little relation to the reality of Behaviors in some of the existing event-and-behavior FRP libraries. To me, that kind of undermines your challenge to their status quo. I figured rather than jumping in with an "I disagree!" on the fly, I'd try to give an alternative presentation of Behaviors (and some of the other bits in your post) derived from spending a bit of time with these libraries. Personally I think that FRP is easy to use and understand, but woefully underdocumented, but that could just be me :)
Proof by beautiful diagrams
&gt; I guess to me it looked like your objections to Behaviors have very little relation to the reality of Behaviors in some of the existing event-and-behavior FRP libraries. Can you expand upon why you think that, as I see it behaviors requires both stepper and switcher, which makes them obtuse. As I see it you only helped to strengthen my argument. &gt; I figured rather than jumping in with an "I disagree!" on the fly, I'd try to give an alternative presentation of Behaviors (and some of the other bits in your post) derived from spending a bit of time with these libraries. Yes you clearly gave a more in depth description of Behaviors, however by presenting your view in opposition to me, and then continued to provide a bunch of true statements, that neither went against or for my arguments, you've seems (maybe unintentionally?) committed the Red herring(or Chewbacca defense :P) Fallacy. 
I might be considered part of your target audience for this change, as someone who's still wrapping his head around FRP. I find that Sample is more difficult to understand than Behavior. To my mind, (Time -&gt; a) is fairly simple to relate to the real world: given the current time, what should the Behavior's value be? But Sample seems to imply that the Sample's value should be different for different values of Period.initial. Life only gives you Period.final, though, so... what now? I suppose what you're saying is that you want Behavior to be a state monad of some kind, always, so you can keep track of Period.initial. I can see how that could be useful in certain contexts, but why must that be the rule for all contexts? And given that we're not really operating within a list of time values, I don't understand how you're improving on "switcher". Ideally, I suppose you can just say "if time is in this range, do this, otherwise do that", but again, that doesn't seem realistic. You don't know ahead of time when, say, the player is going to hit the fire button. So you still have to change what a Sample does based on an Event. How does Period.initial make that any easier? What if Period.initial is before the fire event, but Period.final (i.e. the current time) is after it? Doesn't that just describe an invalid Sample? Your example in the linked tutorial doesn't help much. If you want an interval of 1, but occasionally processing takes longer than 1, don't you get something like this? [b(0), b(1), b(3), ...] And wouldn't that still be correct, within the limits of the degraded resolution we're getting? Unless you're saying that Sample could "fill in" the missing b(2), which might be important because our behavior is monadic and we need every calculation in order. Again, I can see how that would be useful in some contexts, but I don't see why it's needed in all contexts. I suppose I'm assuming monadic Behaviors are something you can easily do. Having never tried, I have a vague idea that it seems doable, but certainly could be wrong about that. In which case, monadic Behavior with something like the Identity monad for simple cases would be advantageous, admittedly. If Sample is important because implementation detail, then OK, I could get behind that, but in that case I'd need more explanation before I could get behind its conceptual simplicity over Behavior. 
I'm not really clear on what you're proposing. The `Behavior` type is pretty easy to find in common problems. For example, it's quite easy to understand what `mousePosition :: Behavior (Int, Int)` means. Can you give some concrete examples of your `Sample` type, and how it models things of interest in reactive programming?
Prediction: it will turn out that FRP in the narrow sense is a complete waste of time and many Haskellers will run aground on this rocky, barren, island.
&gt;to write numerical computations regardless of how they're going to be executed, at a high level. And then be able to run them on CPU or GPU, without changing the code. Doesn't accelerate already do part of this? It's a work in progress but I've used it and I like it. Also the things allowed on a GPU are limited (e.g. minimize conditionals) so isn't it possible that some code would be just plain faster on the CPU that wouldn't run on the GPU?
Now we only need some syntactic sugar like type User = { foo :: Int, bar :: String } -- is equiv to: type User = R ( "foo" := Int, "bar" := String ) :-)
this was my line of reasoning, albeit I'm still learning CT
It that is not so problematic, then why do you think that there are no libraries for manipulating exceptions or concurrency, streaming web servers and communications managed trough events derived out from behaviours?
I would defer that question to Conal. :)
&gt; To my mind, (Time -&gt; a) is fairly simple to relate to the real world: given the current time, what should the Behavior's value be? I would agree with you on this point however that because it only works as a theoretical model for the real world the type just isn't sufficient adding all kinds of complexity thus ending it up making it much hard to understand. I mean if you read the haskell Frp wiki it even says so "This is only a theoretical model, because a time-varying value can represent something impure like the content of an edit widget, the current value of a database entry as well as the system clock's current time." &gt; I suppose what you're saying is that you want Behavior to be a state monad of some kind, always, so you can keep track of Period.initial. I can see how that could be useful in certain contexts, but why must that be the rule for all contexts? Good observation ^ ^ but no, I initially did a lot of experimentation with mixing in a state-monad but that turned out to be totally fruitless. For instance it had no composability as having different states was very difficult to move between. &gt; Your example in the linked tutorial doesn't help much. If you want an interval of 1, but occasionally processing takes longer than 1, don't you get something like this? [b(0), b(1), b(3), ...] And wouldn't that still be correct, within the limits of the degraded resolution we're getting? Unless you're saying that Sample could "fill in" the missing b(2), which might be important because our behavior is monadic and we need every calculation in order. Again, I can see how that would be useful in some contexts, but I don't see why it's needed in all contexts. First off it wouldn't be correct, but first let me try to explain how an interval one would work. Imagine the current time 10.5, and I said I want a list of events with an interval of 1 second, then given that I know that the last event happend at 10, then 9, then 8, then 7 etc... This can be done with any initial time and any interval. It requires no outside mutation, meaning it's a pure function. Given that lazy list is just a head with a function as a tail I can always get a lazy list providing me this event interval. Thus an event is never skipped. With the Sample type I have both an final and initial. Meaning I can always correctly sample over this lazy list. For instance. Final time = 10.5 Initial time(Last sampling time) = 8.5 Lazy list as function applied with the final time (10.5) gives me [10, 9, 8, ...] In my library this function is called pulse (https://github.com/jannickj/Freckle/blob/master/src/Freckle/Feed.fs#L236) then as I have both initial and final I simply do [(t, a) | (t, a) &lt;- lazy list, t &gt; initial, t &lt;= final] == [(10, b(10)), (9, b(9)] from there we just fold from the back (i.e. foldp) and we get our new state. Nothing is ever skipped and if our final time is increased so would the pulses in the lazy list i.e. if final was 15.7 then lazy list would just give us [15, 14, 13, 12, 11, 10, 9, 8 ....] Going back to your other points it's very important that something isn't skipped because if that happens then it delays your entire program imagine if you were counting seconds and it goes 13.. 14.. 16, that can't happen which is why it's important to guarantee events aren't skipped. 
&gt; less magically encapsulated state might be an interesting approach to investigate for functional programming. I completely agree with you, and it is also my problem with elm, which was why I tried to avoid that by using a state folding function (guaranteeing no space leaks in the process)
Actually it is very worthwhile, and making this library have made me much better at understanding the problems that might also occur when writing imperative code.
I can think of lots of reasons, but none of them seem relevant to this discussion: everyone's too busy, everyone likes wai/pipes/whatever, there is one over yonder, FRP is too new, etc. Do you have a better one? If it helps, I don't mind being pointed to a discussion about this problem somewhere else. I'm quite happy to be told I'm ignorant, as long as I'm also told how to become not-ignorant. 
Thanks for responding. Although `CofreeT` does have a `Comonad` instance, it cannot be used since it has the form: instance (Functor f, Comonad w) =&gt; Comonad (CofreeT f w) I instatiate `w` to `DynamicM`, which does not have a `Comonad` instance. Consequently, I cannot use the `Comonad` instance for `CofreeT`. I do not actually use `memoExtend`, but I left it in there to try to communicate where `memoExtendCofreeT` comes from. I am not able to see how `extend` could be used in its place. Consider the type signatures: extend :: (Cofree f b -&gt; a) -&gt; Cofree f b -&gt; Cofree f a memoExtend :: (b -&gt; f a -&gt; a) -&gt; Cofree f b -&gt; Cofree f a The functions passed as the first argument to each are very different. Notably, the function passed to `memoExtend` takes an `f a`. &gt; If it's just for you, couldn't you just use extend and only pass it functions that work to a certain depth? Unfortunately, no, since the `Cofree f b` argument in the function passed to `extend` does not have any values of type `f a` in it. 
Thanks for replying. That's a good bit to think about. If you don't mind me thinking aloud a little bit more... I suppose my use of the term "state monad" was a little too specific. I'm more thinking of Sample as a "monadic Behavior" in that there is a definite order, and the value for time X in the series is always dependent on the value for the time X-1. That implies that there is no such thing as a "pure Behavior", where the value of the Behavior is only dependent on pure values plus the current time. I'm thinking of something here like a tone generator, where the proper state of the speaker is dependent only on the initial sine function parameters and the current time. In that model, if our latency is too high at some point, we might get a bit of distortion in our tone, but the algorithm can recover on its own when the latency returns to spec. And if our latency is out of spec, I'm not sure Sample performs any better than Behavior. In fact, I could see how Sample would essentially devolve to Behavior in a sane implementation; since our function doesn't need it, the initial time just gets ignored. I can see, though, how a tone generator might be one of those theoretical models that doesn't do too well in practical use cases. In particular, tone generators can afford to be lossy. Thanks again, and I wish you the best of luck exploring these ideas. 
&gt; In fact, I could see how Sample would essentially devolve to Behavior in a sane implementation; since our function doesn't need it, the initial time just gets ignored. Yeah I mean if think about it Sample is just Sample a = Time -&gt; Behavior a &gt; I can see, though, how a tone generator might be one of those theoretical models that doesn't do too well in practical use cases. In particular, tone generators can afford to be lossy. Ye if all you want to do is make tone generators then Behavior absolutely will suffice, however if you want to model something with state(99% of programs), then you need functions such as foldp, and for that you need to know how far to go back in time to fold from.
I thought your "at work" was in financial things?
Replace Golang with any language that meets the criteria in the sentence preceeding the flame war bait that snagged you.
I've made a pass at part of the airlock code to reactive-banana [here](https://gist.github.com/dalaing/c4c48aeff051d2049e4bd1a5be05797d), if anyone is interested. I haven't compiled it, and I haven't had a coffee yet, so it might do bad things. There's a Behavior in there to keep track of the airlock state, and the commented version of `doubleClick` is an attempt to show what I like about passing Behaviors around to get constants / settings into place. This kind of stuff really shines when you start breaking things apart for reuse or testing, but that'd take a bit more time to demonstrate than I have right now :)
Yes. Good examples for our team to read and emulate.
Do you happen to know of anyone using reflex for a non-web application? I am way behind schedule in doing this myself, and would like to take a look at what others have done.
I found [this post by Stephen Diehl](http://www.stephendiehl.com/posts/adjunctions.html) to be particularly good. Tom Murphy's [Modal Types for Mobile Code](https://www.cs.cmu.edu/~tom7/papers/modal-types-for-mobile-code.pdf) explores a type system based on modal logic for distributed computation. The type signatures for the modal primitives he gives correspond with the primitive functions described in the initial Cloud Haskell paper. You can get a categorical interpretation for S4 modal logic by giving a comonad for box and a monad for diamond. To extend that to the S5 modal logic in Murphy's work, you need to get the monad and comonad from a [triple of adjoint functors](http://comonad.com/reader/2016/adjoint-triples/). Now, what's interesting is that the *comonad* corresponding to the logic in Tom Murphy's paper is *compilation*: `unstatic :: Static a -&gt; a` takes a static (eg compile-time value) and makes it a runtime value. Meanwhile, the `ProcessM` (?) monad is the diamond in Tom Murphy's logic. I have no idea if the Cloud Haskell folks knew about Tom Murphy's work, but that the implementation/types in Haskell line up so nicely with the logically sound system that he created is extremely pleasing theoretically. I wrote my [undergraduate thesis](https://github.com/parsonsmatt/modalities/raw/master/paper/paper.md.pdf) on exactly this topic, if you're interested in more detail and references.
Also, think on [this notion of coeffects](http://tomasp.net/coeffects/) which is based on the idea of an indexed comonad providing application resources and environment, and we get this very nice idea of: 1. A comonad representing the *environment* that our code/application lives in 2. Pure code, representing the transformations that take place internally 3. A monad representing the effects that our code has on the outside world.
Because Haskell is sensitive to indentation, GHC considers tabs to be as wide as eight spaces. Your editor likely displays tabs with a different width, so while the two versions of your program may look the same in your editor, they are being interpreted differently by the compiler.
Sure, that's Mon, but it's not represented in Haskell in any meaningful sense.
I read s big post about why indentation in Haskell is hard. Is it not the case with VIM? I had gotten used to the fact that pressing tab will cycle between all possible indentations, and I'll have to make a decision about which one is right. 
To remove some of the mystery: The common case where `Data.ByteString.Char8` is sometimes a good choice is when you are working with a network protocol or binary file format which contains 7-bit-ASCII-encoded human-readable English text.
There's also hindent, the utility and the elisp package by the same author. It binds to M-q and indents the form to one of several indenting styles. If you really want you can customize the rules as well.
If you're okay with 3D rendering instead of 2D you should try not-gloss. It's pretty simple like gloss and already has a built in [function](https://hackage.haskell.org/package/not-gloss-0.7.7.0/docs/Vis.html#v:visMovie) to save to a file. But then again if you already have something you want to save it's probably not a good solution. Good luck!
As I understand it, Conal's formulation provides no way for events and behaviours to come in and out of existence, and therefore provides no way for GUI widgets to come in and out of existence. Since Reflex provides the latter (I assume) it's not FRP in that sense.
What's with the Haskell.org people's predilection towards mailing lists? I know I virtually never use mailing lists compared to other forms of communication.
[removed]
Because https://github.com/haskell-infra/hl/pull/130
Small technicality: Tabs are not 8 spaces. They "indent to next multiple of 8", which is only relevant if you mix tabs and spaces, in which case there's a special hell for you anyway, but wanted to point that out ;)
TIL antiunification
Just for the record, Haskell-community is way too obscure of a mailing list for any kind of community decision making to be made with it. For instance: [Here's haskell.org](https://www.haskell.org/mailing-lists) [And HaskellWiki](https://wiki.haskell.org/Mailing_lists) [And haskell-lang.org](https://haskell-lang.org/mailing-lists) As far as I can tell, the fastest way to subscribe to Haskell-community is through the "Other mailing lists" section on the website, [stare down this list](https://mail.haskell.org/mailman/listinfo), and then pick Haskell-community out of it because clearly it's still actively used. That's pretty inaccessible, especially for something that's supposed to represent the community. I'm saying this because the vote on the Download page of the website took place on said mailing list and if you weren't subscribed to what seemed to be an insignificant and inactive mailing list, then you missed out.
&gt; find all the equivalence classes of pseudo-free C values which are supposed to be equal according to the laws, and make them equal somehow. This sounds more promising than my previous strategy (stare at the definitions of the free monad and free applicative, and hope they spontaneously merge into something coherent). Thank you. As far as laws go, I suspect it is enough to remove `(&lt;*&gt;) = ap` and keep everything else. I'll see how it goes...
The four components of the evil cabal are: - Hackage, replaced by the FP Complete mirror and Stackage. - cabal-install, replaced by Stack. - Haskell Platform, replaced by Stackage resolvers like LTS and nightly. - haskell.org, replaced by haskell-lang.org. I think Michael *is* focusing on technical issues. He shows how the existing Haskell toolset is deficient. He also shows how the new Stack toolset is better. Then he shows that the committee in charge of the existing toolset rejects Stack for basically no reason. 
So, I mostly stay out of the whole stack/cabal fight because a) it's not like my opinion's important and 2) I haven't really been able to really come up with a good reason for why I sort of dislike stack. But today it finally came to me. All the FP-complete tools feel really "webdev-y". I really don't like webdev-y stuff, and using it makes me feel uncomfortable, like using ruby tools.
He could have done that without referring to people as liars and oligarchs guilty of nepotism.
I can't see how there can be any doubt here. Reading the github issue raised for the change in the downloads section of the website, Snoyman repeatedly backs his arguments up with links to actual discussions. I see no such evidence from the haskell.org committee representative, despite repeatedly saying that he is simply following the wishes of the community. Moreover, the opinions expressed by Snoyman are also the opinions I see in the parts of the Haskell community that I move around in. I remember that when I was a beginner, I thought that the people behind the haskell.org website were the "official Haskell committee people" -- I hadn't given much thought to it, to be honest. In reality, I just assumed that the site had some authority on Haskell matters, and I believe this is an important point: This is basically what beginners think. Beginners will assume that whatever the haskell.org website says is the right thing to do, which is clearly not true anymore. I don't know if these guys are just reluctant to give up some of the control over something that has been their "thing" for a while. I'd understand that sentiment, anyway. But it simply can't be avoided: people who are voting on those polls aren't random people voting on things they don't know anything about. They are the people actually using Haskell. The committee should take a backseat here and let the webpage be the voice of the community. 
Do you think that he's wrong? Or do you think that he shouldn't have called a spade a spade? 
The story he presents is very convincing though. I've been getting a lot more mileage out of my Haskell development by replacing these "community" tools by FPC's alternatives one by one. At first I was pretty skeptical, and tried to avoid doing so as much as possible, but now I look forward to what will FPC replace next.
I feel like Snoyman would get a lot further if he more consistently applied the [principle of charity](https://en.wikipedia.org/wiki/Principle_of_charity). He can respond with arguments and links all he wants, but when he doesn't charitably interpret his opponents, it looks biased and petty.
[removed]
I won't speak as to whether he applies this principle or not, but a number of times he summarizes the opposing arguments and asks if he understood it correctly. Seems like those are most often just ignored, but his summaries were exactly the way I understood the arguments from the committee. 
Hm, can you elaborate on this long-awaited enlightenment that finally came to you? "Feels really 'webdev-y'" just doesn't make enough sense to me.
[removed]
&gt; I think that Ruby's Bundler generally deals with dependencies well, web dev or not. Bundler fucks up in the most amazing ways, from somehow using the wrong copy of ruby to installing gems in the wrong place for no reason, and because it's ruby the error messages it gives you are less than helpful. I can't really describe it, that's why I used the word "feel". But part of it is a sort of design where it's more important to deal with little niggles people run into initially when they're totally new *instead* of dealing with actual problems in real-sized projects. For instance all stack really does that couldn't easily be added to cabal or just made a script, is manage ghc versions for you. Pegging all your libraries to a stackage version is nice when you're starting a project, but then you have to upgrade everything in lockstep (which is bad because it can force you to deal with API changes in libs A B and C when all you wanted was faster performance from D) or specify versions anyway, so you don't really gain anything in the long run. But you don't need to type `cabal sandbox init`.
I think it's obvious that all the stuff Stack doesn't can't be easily added to cabal-install. Otherwise it would be there already. The `new-build` stuff is part of 1.24, which came out in May. That's almost a year after Stack. And it's still ["beta"](http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/). Also, I think dealing with the small problems new people run into is extremely important. Why should someone stick with a toolchain if they immediately run into problems? If you want to update a single package, it's the same amount of difficulty to do it with Stack or cabal-install. With either one you need to specify the new version of the package you want. I don't find that to be a compelling argument against Stack. 
or subscribe to his channel
&gt; He shows how the existing Haskell toolset is deficient. He also shows how the new Stack toolset is better. Plus he's arguing that the community prefer stack to the minimal and platform. This isn't just a technical argument, it's also "we should be telling newcomers to use what most developers are using"
Emacs indentation handling is one of the reasons I hardly ever use Emacs. Frustrating as all hell.
I remember the author of [vivid](http://hackage.haskell.org/package/vivid) wrote a small reactive command line demo with reflex that somehow turned your keyboard into kind of a piano like device for producing sound, but I don't know if the code was ever made public.
But when someone thinks they're not a spade, they're just not gonna listen to you telling them they are. The point of the principle of charity isn't to think of an incorrect thing as correct. The point is that it helps you work *with* the opposing argument.
Is the record problem really slowing down adoption? It doesn't affect me much in my day to day Haskelling. When I need this sort of thing, `declareFields` solves the problem much more nicely than eg Purescript or Elms record systems.
You prefer to use tabs... in Haskell?!? I really hope none of your projects are open source.
If I may play the devil's advocate, https://haskell-lang.org/get-started presents `stack` as the unique way to get started with Haskell (while it could be equally pleasant to do so in `nix` without stack for instance). I do love `stack` and consider it as a superior tool but I can't help feeling this kind of unilateral presentation is well a bit biased ;-) 
I may be inside the Stack echo chamber, but what future options does cabal-install provide that Stack does not? 
Is reddit that Stack echo chamber? Is there a large active Haskell community outside of reddit? If so what do they think, how do we reach them to ask them for feedback? In any case, it's not likely to be the mailinglists, apparently only 5 people voted on a pretty important topic there, while on here at this point 20 people upvoted your comment that's been made just 45 minutes ago. You need not necessarily be saddened, in any organic transition there has to be some point of maximum polarity where 50% is on one side and 50% is on the other. I *feel* we have gone past that point some time ago and there's not that much polarity, just a couple guys that are a little more stuck on their positions than the rest.
I don't know why this is bad - if you look at rust for example, there's also only one way how to get going in the "getting started" part of the docs: https://doc.rust-lang.org/book/getting-started.html Why should a newcomer care about other options? They just want to get started and not have to make a decision what works best (which they logically can't even make yet!).
Meanwhile https://www.haskell.org/downloads lists three ways to get started with Haskell. Beginners are the least qualified to make a decision about the "right" way. By presenting only one option, they can immediately get going. By the time they might hit some limitations of that option, they will hopefully know about others. 
The problem here is that newcomers don't know what's going on. If you're new to Haskell and you get a bad taste in your mouth because you started on the wrong website or with the wrong tools and nothing worked, then it's hard to recover. If you care about growing the community, then ignoring the wreckage and taking your toys elsewhere isn't a solution. 
&gt; We should submit proposals (like requesting the use of Reddit over a mailing list) I wonder what ever could go wrong when basing decisions on reddit discussions... OTOH, we'd have the big benefit of getting the valuable opinion of less known reddit accounts who'd floo... erm... chime in on /r/haskell on such special occasions when there's something to decide...
I think Stack is the solution that "just works". I have been using it for almost a year on a wide variety of projects and I have no complaints. 
I think this senseless yelling comes after months of trying to work with the committee. 
Sure, just posting on reddit and nothing else would obviously be a mistake. But the point is that we need to open up more channels of communication if we want more communication.
There are Linux distributions that use cabal to manage haskell packages, like NixOS.
I think that fundamentally the management of a coherent set of packages is as much a social issue as it is a technical one. It is also a space where there is no clear "best" way of doing things, otherwise we would have e.g. only one Linux distribution. In terms of stack/stackage and cabal-install/hackage, each is taking a different approach to the problem. Stack is using the "standard" model of having a blessed set of packages, managed via a central build bot and social structure. Hackage/cabal-install is taking a different approach, which can allow for more flexible constraint satisfaction, and has a different social model about ensuring coherence. It is a harder problem, but in the spirit of Haskell the solution should be more durable, when it eventually stabilises. In my view, the point of collision is the upper bounds stored in the cabal file. Historically there was only Hackage/cabal-install, so this was never a problem. We now have a space where we have at least two alternate models, and the storage of "convention defined" upper bounds is problematic. I would argue that we all support PVP as a signalling mechanism, but differ on where the upper bounds belong. In my view they are part of a social ecosystem, and we need to set things up so that competing ecosystems can co-exist, using the common substrate provided by Cabal the library and GHC. Sorry, you asked, I have been wanted to dump my thoughts for a while. 
Doesn't stack fully support hackage? If so, then what you're saying sounds to me like stackage vs. hackage (and one is built on top of the other), not stack vs. cabal-install.
Easy to find via Google: https://wiki.haskell.org/Haskell.org_committee IMHO the lists aren't obscure. The fact that mailing lists are used for much of discussions might be obscure for beginners as the mailing lists aren't the most hip thing nowadays. Yet thru https://wiki.haskell.org/Mailing_lists you get onto https://mail.haskell.org/mailman/listinfo where the `haskell-community` is listed with "haskell.org community list" description. It's also worth remembering that for some people Reddit is the obscure channel.
Great, as if the word "cabal" wasn't overloaded enough already...
I'm a bit slow on the uptake, so what's wrong with the Haskell Platform now that it includes stack? I don't think HP+stack offers much over stack at this point, but there are still some beginner UX issues better done with the (Windows) HP installer: * Makes shortcuts to a ghci window and WinGHCi (this latter one is surprisingly "nicer" than ghci because you can browse the buttons for common actions rather than having to type :? (if you even notice that) and going through a whole ton of less common actions) * Comes with documentation, not so much the GHC documentation, but API documentation for some subset of Haskell libraries These are actual beginner-beginner issues though, not things that would actually concern experienced devs who happen to be beginners to Haskell. With that said, the download page on haskell.org as it is is unhelpful, and the haskell-lang.org one is better since it doesn't have irrelevant choices that don't make sense to someone that isn't already familiar with the situation. (But what really caught my eye was that intero demo. I had heard of it before but didn't care about it or know that I wanted it, but now I do.)
Fair point! There is another comment in this thread about NixOS. I don't use NixOS so I don't have any first-hand experience there. It looks to me like the Stack maintainers are aware of the problem and are trying to fix it. 
We have cabal-the-library, cabal-the-executable, and [cabal-the-word](https://en.wiktionary.org/wiki/cabal#Noun). &gt; A usually secret exclusive organization of individuals gathered for a political purpose.
That sounds good. I haven't quite had that experience. I think a *unified* solution where the default prevents and can automatically resolve typical conflicts is really important. If that is just stack then great. It should just be one standard solution that works for 95% of users. The current situation is fairly confusing and this community might not be large enough yet to support two options IMHO. Forcing end users to figure it out wastes time and potential. Just to give you an example, I found reconfiguring a project to do profiling to be quite problematic, enough that I haven't gotten it to work and have moved to other tasks until I build up the energy to try again. There are users like myself who I think would gladly pay to bypass these difficulties and focus on coding in Haskell, not on configuring build tools.
Fair enough. Michael didn't list that wiki page in his post, which might be misleading. However I think it's telling that one of the first threads on the haskell-community mailing list was [a request to stop linking people to the Haskell Platform](https://mail.haskell.org/pipermail/haskell-community/2015-September/000014.html). I am not familiar with mailing lists. Now that I have subscribed to haskell-community, how can I cast a vote in [this poll](https://mail.haskell.org/pipermail/haskell-community/2016-August/000118.html)? 
In my experience, Stack and Stackage completely resolved the conflicts I typically got with cabal-install and Hackage. Obviously I can't say if that experience is universal. For profiling, `stack build --profile` has always worked for me. 
This is an absurd thread
In my experience, if I start an important discussion on: * reddit -&gt; there will be people who say it should be on a mailing list. * a mailing list -&gt; there will be people who say it should be on twitter or reddit * on twitter -&gt; it's very difficult to communicate effectively, and people will ask for reddit or mailing list Even though I'm ostensibly on each of the above, there is a ton of traffic I miss. My conclusion? It's not possible to please everyone :) 
Stubborn community leaders don't realize the damage they cause.
As somebody that tried getting started with Haskell I can say that the Haskell Platform and the experience of Cabal-install are the reasons for why I couldn't get into Haskell, because every time I tried to start something, it would fail installing popular packages that I was interested in, being a huge turnoff. I don't know what disadvantage Stack has, but it is very beginner friendly, I could finally get started and I like that you can use specific GHC versions for your project. I also had a good experience with Intero, the Emacs plugin that's integrated with Stack. Again, I was pleasantly surprised to have it installed and working. Maybe cabal-install does some things better, but IMHO the whole concept behind Haskell Platform is flawed. From what I understand it's an installer that ships with curated packages such that beginners don't necessarily have to install anything else. But then those packages come in conflict with the packages that you want to install yourself and it becomes a mess. Plus, this whole "batteries included" notion is only appealing for platforms without good dependency management. The more people insist on it, the clearer it is that package management is a mess. That said the attitude in this blog post is a little toxic. If a fork has to happen, so be it, but it could be handled more gallantly I think.
Note that one of the people there who's got his setup working isn't using Nixpkgs for haskell packages, just for system dependencies: https://github.com/commercialhaskell/stack/issues/2130#issuecomment-234960535 If @pyow_pyow is set on using Nixpkgs' binary cache he's going to need to do something different. This may be hard though since Nixpkgs has removed support for stackage snapshots. Personally, I'm fine with using the setup I linked to in the first paragraph. It gives a pure Nix environment with only the dependencies listed in `shell.nix`, so I don't have to worry that I'm releasing code that accidentally depends on something I have installed locally on my own computer. And missing Nixpkgs cache for haskell packages isn't a big deal for me, YMMV.
But what about this part? &gt; the "evil cabal of Haskell" (referring to the nepotism which exists amongst Hackage, cabal-install, haskell.org, and the Haskell Platform) So, the "evil cabal" is *both* the tooling and the evil actions of the people on the committee.
&gt;Haskell is already at least an order (sometimes two) faster than PHP/Ruby/JS/Python/etc. Performance is likely a concern for some settings but web development is not one of them. Haskell web framework benchmarks should be at the very least faster than all of the Ruby/JS/Python web framework benchmarks easily then, shouldn't they? In the Tech empower benchmarks as well as my own personal benchmarks this hasn't been the case. &gt;The real blockers around Haskell adoption are unfamiliarity, tooling, and library availability. It's hard to sell Haskell to interact with eg. Amazon MWS when there's already a PHP, Java, and C# client library for it/ Those are big blockers, but as you probably know Haskell just being fast enough to solve the problem at hand would be enough to convince some organisations to use it, for better or worse.
I am really sick and tired of FP Complete trying to do a hostile takeover of the Haskell community's infrastructure just because their lead engineer developed Stackage and it's good. I don't care how much better Stackage is than `cabal install`. This is incredibly unprofessional behavior. This has not been a polite quarrel over technical merits and bringing words like "evil" into this is by far the most childish bullshit I've ever seen in an open software community. Hey, color me naive. I usually avoid quarrelsome people with an end in view. Don't act like you've been completely diplomatic this entire time; you've alienated a lot of us. Your initial unilateral attempts to force stackage as the blessed build infrastructure were not well received for a good reason. You've certainly alienated me and I've been here forever. This is the first time I've ever seen a disagreement used so forcefully as a wedge to gain political leverage in the Haskell community. I don't want anything to do with this community any more if this is the kind of conduct that's acceptable. And not to single out Snoyman here. There are a lot of people who are overzealous about adopting Stackage and I am disappointed in most of you. Trying to pick a fight in the court of public opinion? Public opinion *on Reddit and Twitter of all things*? I should stop talking right now before I say anything too blunt.
Yeah, that indentation problem had been annoying me forever in spacemacs. I'm not sure if it's even considered a bug anymore.
&gt; I don't want anything to do with this community any more if this is the kind of conduct that's acceptable. :(
I read that to mean that there is nepotism among those tools; they all favor each other. But it's definitely ambiguous and it's reasonable to interpret that as nepotism among the people that maintain those tools. 
I would like to respond to that thread but I honestly [don't know how](https://www.reddit.com/r/haskell/comments/4zzmoa/haskellorg_and_the_evil_cabal/d706g9b). Also, Michael's post argues (and I agree) that the Haskell committee seeks feedback in venues that much of the community doesn't use. 
I've pushed the code that generalizes `Lens' s a` to `Lens s t a b` to GitHub, and now I also have a working prototype that treats all non-existent fields as having type `Void` so that rat :: Proxy l -&gt; Lens s t a b is a lens that upserts or removes the field at label `l` depending on whether `b` is `Void`. With the helper pattern `X` to construct a value of type `Void` (yes, this is essentially allowing users to play with fire): pattern X :: Void pattern X &lt;- (absurd -&gt; ()) where X = undefined You can now write: &gt;&gt;&gt; R () &amp; rat #a .~ True R ( a := True ) &gt;&gt;&gt; R ( #a := True ) &amp; rat #a .~ X R () &gt;&gt;&gt; R ( #a := (1 :: Int) ) &amp; rat #a .~ True R ( a := 1 ) Adding a field that already exists will replace the value and removing a non-existent field is no-op, so the lens laws will hold fine: &gt;&gt;&gt; R ( #a := True ) &amp; rat #a .~ X &amp; rat #a .~ X R () I'm not sure if this should be the default though, as the user can now easily get hold of a bottom: &gt;&gt;&gt; :t R () ^. rat #a Void -- Oops! and I don't think this has more benefit than simply providing: addField :: Proxy l -&gt; s -&gt; b -&gt; t delField :: Proxy l -&gt; s -&gt; t which is essentially what `rat` uses under the hood: -- If b ~ Void: rat l f s = const (delField l s) &lt;$&gt; f (getField l s) -- Otherwise: rat l f s = addField l s &lt;$&gt; f (getField l s) with some typeclass-based polymorphism layered on top. EDIT: `rat` is now available at [wip-rat](https://github.com/PkmX/rawr/commit/ab0c948c56b06d900e8f15cbd84082d12ad6c1ce) branch.
If you've ever sat in on a group of these particular people discussing community issues you would take a long pause at the accusation that they're liars and oligarchic. A lot of people who only see this conflict through the lens of PR, blog posts, and social media are getting a very polarizing and agitated view of the situation. It's much more boring than you'd ever imagine. FP Complete and their supporters are the ones accusing the "other side" of acting in bad faith. And throwing around words like "evil"? Seriously I'm too old for this nonsense. One thing I'm sure of: Snoyman is picking a fight with honest people who have legitimate concerns who are acting in good faith, and he is the one who has been burning bridges all this time.
Oh, nope, after a second reading I think you're right. No mention of people in there, I just haven't ever heard the term nepotism used in this way before.
[removed]
NB: The Haskell Platform ships with Stack included. 
I'll give it a shot that we can perhaps build on later, please let me know if there are any inaccuracies. ## Intro There are basically three different ways to do package management: directly installing, solving, or using some global set of pinned packages. cabal-install defaults to solving while stack defaults to Stackage's globally pinned packages (no one in the Haskell community is suggesting direct installing Golang style, thank goodness). ## cabal-install Local dependency solving is the most useful and flexible way to install software. Admittedly this is a hard problem, but with accurate Hackage bounds (including on past releases) it should function smoothly. Because local solving depends on so many variables (such as the last time you ran `cabal update`) local pinning is also an option. Though it isn't done by default, it may be useful for applications (not libraries) to make sure they install the same way every time. ## stack Following a global set of pinned packages is the correct default. This makes getting software to build much easier since the entire focus of the community can be on one particular set of packages at a time (or a few dozen sets if we include historical releases), not the millions of possible combinations that result from a solver. Let's take a short tutorial script as an example of how this works. The Stack attitude is that a tutorial should be pinned -- "bitrot" shouldn't be an issue here. And by pinning to a Stackage LTS release instead of the result of local dependency solving there's a good chance the user will already have everything cached and won't have to install a bunch of new versions of libraries just to run a short script. Because most people will be using Stackage instead of doing solving themselves, having perfect dependency bounds in each library is less important, and we can remove some of the burden from library maintainers over time. E.g. we can ease up on making them exclude packages in their upper bounds that haven't even been released yet. ## Finally Is this a fair summary of both sides? If so I have some thoughts on synthesis, but there's no point writing them up if my foundation's bad.
Hey babe I didn't mean nothin' by it. I'm still here for u.
while that's true, I think that if the community really wants to be heard on the matter, it's easy enough to do so with the mailing list. The refusal to respond to a mailing list is kinda silly. And besides that, I'd strongly advocate a petition *on the mailing list* to move discussion to a more popular medium like Reddit.
I'm not refusing to respond to the mailing list. I actively want to respond on the mailing list but I don't know how. 
Nixpkgs doesn't have a good enough UI to replace language-specific package managers. If you use the naive Nixpkgs packages you're stuck to a global pin like Stackage, but unlike Stackage it's one that only other Nixpkgs users know about, and there may not be any community buy-in at all (I know a few people use Nixpkgs for haskell dev, but they're the minority). If you start generating your own package descriptions based on your project you free yourself from the Nixpkgs pin, but at the cost of a lot of complication and bleeding-edge pain. I don't think this will be worth it for most people. To be clear, I really like NixOS and love being able to build pure dev environments with it, but I think it's important not to oversell it. EDIT: I wrote this assuming you were talking about managing language specific packages with Nixpkgs and already know about stack's `Nix: enable: true` setting. If you were only talking about non-language specific packages then we already have the things you're saying we should have more interest in.
I'm having a hard time understanding this sentence. I think you're saying that the current state is not where the committee wants it to be. The desired end state is a single option that downloads the Haskell Platform and includes Stack. Is that correct? 
I'm not sure, but I think it just pushes the problem farther down the line. Instead of offering two *download* options (Platform vs. Stack), it offers two *run-time* options (`ghc`/`cabal` vs `stack`). Once someone downloads the Haskell Platform with Stack, what's the recommended way to build a Haskell project? Do you use `ghc`, `cabal`, or `stack`? 
I second this. Especially the feeling that I "don't want anything to do with this community any more if this is the kind of conduct that's acceptable." The rift is really much greater than a discussion about technical details.
Well, the rant that got this whole thread started was Snoyman going on in part about the evils of the Haskell Platform which he's replaced with Stackage in his mind, while on the other hand the Haskell Platform incorporates his solution out of the box. The Haskell Platform isn't `cabal-install` and out of the "four evils" Snoyman wants to slay is sadly the one closest to giving him what he wants. It just happens to also include `cabal-install` and a command line runnable `ghc`.
That's more or less what I do but, based on your previous comment, it's not fun. :-) I wonder if this approach doesn't make sense in general. It seems like the root of all this is version numbers that are supposed to mean something but don't have to. Funny that a language with such a smart type system would end up in stuck in the same corner as everyone else. I would would prefer to have a compiler and/or a set of tests running on a build system tell me which commit hash is safe to use. 
To respond to an existing mailing list thread, go to its archive page ([here, for example](https://mail.haskell.org/pipermail/haskell-community/2016-August/000118.html)), and click on the sender's email address line (dagitj at gmail.com, in this case). That's a mailto: link that will let you respond to the thread
I know, and I've replied elsewhere about that. But the point is that too many people aren't willing to use the mailing list, even though it's currently the best avenue to getting something done.
Nobody likes the current download page. They just disagree on what should be on it, which is precisely how we got saddled with it in the first place. At the time the Platform didn't incorporate `stack`, and there were problems with the minimal installer on some platforms, so there were really 3 different major audiences. &gt; The desired end state is a single option that downloads the Haskell Platform and includes Stack. Is that correct? Not to put words in his mouth, but I believe that would be at least Gershom's preferred outcome, yes.
Drama like this is the reason I'm currently writing C++.
I bet Duncan is wishing he chose a friendlier name.
I shall have a play with this, but at first glance this is almost exactly what I'm looking for! Thank you. (I say almost because it distinguishes between the main `pure` and the auxiliary `pure`, but presumably I can get round that by removing `Pure` from `Free` and changing `Free`'s instances to refer to the free applicative's notion of `pure` instead.) As you seem to believe that what I want is not possible, I should explain more clearly that I see it being used in two distinct cases: 1. In conjunction with `ApplicativeDo`: I understand that `ApplicativeDo` is intended for types where `(&lt;*&gt;)` is more efficient than `ap`, but they give indistinguishable results. I expect the interpreter to uphold this; personally I don't count the fact that the interpreter can observe the difference in structure to violate the principle. 2. With a newtype or differently named operator providing access to the auxiliary Applicative instance. This is for when the auxiliary Applicative instance gives results different from the main Applicative instance. I expect the main Applicative instance to have `pure = return` and `(&lt;*&gt;) = ap`. Again, thank you :-)
Oh the horrors of c++ build systems and dependency management is the reason I never criticised haskell packages infrastructure.
To be more precise, that is the proposal first made jointly by Michael Snoyman and Mark Lentczner in July of last year: http://projects.haskell.org/pipermail/haskell-platform/2015-July/003129.html At the time everybody endorsed it and agreed on it as a desired end goal. At this point, the committee is just trying to navigate these fraught waters in a way that satisfies everyone as best as possible while being technically sound. The best way to participate in those discussions is to join the -community mailing list and help think these issues through.
Thanks. Assumptions correct.
Ok thanks, I'll re-explore that option. 
&gt; What future options does cabal-install provide that stack does not? Keep in mind, `cabal-install` is used by stack under the hood. Cabal development hasn't been quiet over the last few years. Notably the way package management is done has changed considerably under the hood, towards getting us a more nix like package store for `new-build`. Internally things switched from raw version numbers to hash based package keys, etc. around ghc 7.10, which was a huge change. Folks have been pushing for this for several years. Yes, `stack` has duct-taped a similar system on top, but having it down in a lower level is potentially a good thing and could some day be exploited by `stack` for cheaper builds. `cabal` also provides a large part of the story about how Ed Yang's work on backpack will eventually integrate. Perhaps most of those changes will be through cabal the library, but they integrate with a lot of the package management bits that are still in `cabal-install`. Progress on the cabal the library and cabal-install the tool front has developed fairly apace behind the scenes for the last few GHC releases. For the most part, because `stack` piggybacks on top of these advances a rising tide raises all boats. The fact remains that most of the work done in the Cabal library is done with an eye towards cabal-install as a veneer. Could all the cabal developers switch to working on cabal-the-library underneath stack? Move the rest or all of the guts of `cabal-install` into the library alone and just cede the desktop tooling to `stack`? It's a pretty damn hard sell to say they should give up their independent agency and go give control over that whole tooling to the very guy calling them evil for working on pieces his solution incorporates, while at the same time he's calling the Platform evil for incorporating his own solution.
I don't really want to recapitulate the whole timeline of events because I'll get the details wrong. However, take this into consideration: Creating haskell-lang.org is a flagrantly hostile move. It is saying "This community established infrastructure is illegitimate, we are going to replace you by force now". If you do not understand this then we do not even see eye to eye on how a community based on volunteer contributions, consensus, and collective conflict resolution should work so I suppose we will just disagree.
I definitely agree. I think nothing of depending transitively on 80 fine-grained packages in Haskell using either `cabal` or `stack` it "just works." It is pulling teeth to depend on 5 packages at exact version numbers in C++ across platforms. Sure, everyone has their own build system, but they at least don't demonize the others.
&gt; (I say almost because it distinguishes between the main `pure` and the auxiliary `pure`, but presumably I can get round that by removing `Pure` from `Free` and changing `Free`'s instances to refer to the free applicative's notion of `pure` instead.) Actually, I thought about this too, and no, you can't. It would break the monad law `return a &gt;&gt;= k = k a` data Free f a = Pure (f a) | Free (f (Free a)) instance Functor f =&gt; Functor (Free f) where fmap f (Pure a) = Pure (fmap f a) fmap f (Free a) = Free $ fmap (fmap f) a instance Applicative f =&gt; Applicative (Free f) where pure = Pure . pure Free f &lt;*&gt; Free a = Free $ (&lt;*&gt;) &lt;$&gt; f &lt;*&gt; a Free f &lt;*&gt; Pure a = Free $ (\f' a' -&gt; fmap ($ a') f') &lt;$&gt; f &lt;*&gt; a Pure f &lt;*&gt; Pure a = Pure $ f &lt;*&gt; a Pure f &lt;*&gt; Free a = Free $ fmap &lt;$&gt; f &lt;*&gt; a instance Applicative f =&gt; Monad (Free f) where Pure a &gt;&gt;= k = Free $ fmap k a -- LAW BREAKING Free a &gt;&gt;= k = Free $ fmap (&gt;&gt;= k) a You can see how `return a &gt;&gt;= k` will become `Free $ pure (k a)`, which is distinct from `k a`. You could argue that the semantics of `pure` make it semantically the same, but that would be a weak argument. Anyway, the rest of your use-case sounds identical to [`fraxl`](https://github.com/ElvishJerricco/fraxl), and I follow the same reasoning. Fraxl treats `(&lt;*&gt;)` as just a more efficient version of `ap` and simply asks that users provide law abiding interpreters.
This. Oh, how the goal posts slide. =(
&gt; Drama like this is the reason I'm currently writing C++. Really ? That seems crazy enough. 
I think that [it wasn't him](https://www.haskell.org/cabal/proposal/pkg-spec.pdf) who chose that name.
To me it seems that a good way forward is to do a crowd-sourced page about the benefits of using either `ghci` or `stack ghci` and then summarize that page on a page of rule-of-thumbs on when to use one over the other. Then, we can have only one download option which is the best of both worlds, HP with stacks (the current one).
Good to know.
Go for it. =)
Saying that NixOS doesn't conform to someone's expectations is a bit of understatement: $ ls /bin sh $ ls /usr bin $ ls /usr/bin env Last time I tried, stack worked well on Fedora and Debian. I encountered same issue with libz on NixOS, but I assumed that there is something wrong with my setting because I don't understand NixOS well enough yet.
Definitely. In this case, though, I create the vector up front and it has a fixed size.
&gt; It hasn't mattered yet. Yes it has. We have successfully gotten stack in the haskell platform. That's quite a success if you ask me. That said, I agree that we should transition to something other than the mailing list, but I just think we don't have to be so adversarial about it.
I appreciate the work everyone has done for the Haskell community. For the first 3 or 4 years of using Haskell, I used the Haskell Platform and cabal. In the last year I have been using stack and my Haskell programming life has been easier. Personally, I would advise newcomers to use stack.
I would do a strictness analysis. If your code is really lazy then there's a chance you will just benefit from having lists. I ran into this in the exact same scenario actually and my analysis showed that is was asymptotically superior to use the lists. That being said I was using an infinite board so it was streams not lists but the principle is similar 
[removed]
I know, right? I can't decide what's more tiring to keep abreast of, Haskell Platform drama or the US election.
&gt; Yes it has. We have successfully gotten stack in the haskell platform. That's quite a success if you ask me. It's a success in the sense that something happened. I don't think it solves the problem, which is the *presence* of the platform and the way it pollutes the global package db. &gt; I just think we don't have to be so adversarial about it. I don't think it has to *start* adversarially, nor did it. This is after a long (we're talking on the order of years, not months/weeks) patient effort by the people that bothered to sign up for the poorly-discoverable lists and have dealt with the poorly-argued dismissals of popular opinion so far. I don't hate the committee or anything. I don't know any of them personally, I just think that they are really *really* tone deaf and possibly don't share the same goals as everyone else. That's bad, in my opinion.
Do you have more information about the postgres problem? I've been using NixOS+Stack together fine, but I haven't used postgres recently. That's going to change though and I'd rather any issues get fixed before it does=) (I ask because I can only find one mention of "postgres" in that thread, so whatever problem with postgres that's coming up isn't getting communicated clearly there)
I'm not sure of what the record problem exactly is. There is obviously the problem of name overloading but it seems solved. Then there extensible records and anymous one. I've been missing extensible records, trying to rewrite some code written original in R. In R dataframes allow to easily add new fields in a way similar to how you would add columns with intermediate result in a Excel spreadsheet. Not being able to do that in Haskell forced to find other way, and now, I'm not sure If still need and want extensible records. Maybe being able to do in R is what convinced me to rewrite it all in Haskell ...
If there is one package in my dependencies that requires a modification to it's .cabal file in order to compile (in my case OpenCL). How would I download an modify it and make that package part of my stack dependencies? 
Yep.
No more information than this: https://github.com/commercialhaskell/stack/search?q=postgres&amp;type=Issues
Clearly including `sh` and `env` is a bridge too far. I think you should complain.
Download it from GitHub, make your changes locally, then add it as [another package](https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location) to your `stack.yaml`. packages: - . - extra-dep: true location: path/to/your/opencl Or you can fork it on GitHub and make your changes there. Adding a Git package to your `stack.yaml` is pretty much the same as a local package. Forking has the added benefit of making it easy to open a pull request with your changes. 
Ah ok, thanks. I think the pull request I need is already on the github for OpenCL in the develop branck (it's just a change to the compile parameters for OSX) just not in any of the build plans that stack is searching. Do you have a moment to explain how I would link to say the develop branch on github? https://github.com/IFCA/opencl/tree/develop
Sure fam whatchu need?
Right now I need some popcorn. Haskell drama woo!
In my estimation, - reddit -&gt; some small percentage of people will say you should use a mailing list instead - mailing list -&gt; some large percentage of a much smaller group will say you should use reddit instead - twitter -&gt; why the hell would you try to have an open discussion on twitter
I have a really hard time believing that the right way to model a mini language that is literally a DSL for destructively updating a fixed size array is via lazy lists, but I guess it's possible. It's still very very slow however. Slow and leaky enough that many of sample programs simply can't be run. I have a rust implementation that takes a different approach instead of AST + evaluator and it has no trouble :( At the end of the day, I guess I'm trying to understand how to write Haskell that isn't slow and leaky by default.
That we have to debate what he may or may not have meant is already a sign that the principle of clarity has been violated. Searching for evil cabal in his tweets turned up [this gem](https://twitter.com/snoyberg/status/758696327207354368). So do you still believe he doesn't mean to also refer to people ?
The reason we're reaching this drama, is why people are not using haskell for professional stuff.
Hi everyone: Haskell.org committee member here -- although I'm not writing this as a representative of the committee. I just wanted to share a few of my own thoughts, since some of you might wonder what other people on the committee think about all this. There are, perhaps, a few exaggerations being made about what exactly the committee does, and how we do it. I personally talk to other committee members -- as a committee -- a few times a year. Every once in a while, we vote on a mailing list about decisions that affect the public. That's all. The rest of our business pretty much proceeds unattended, except when questions arise about the legality of students who want to participate in the Summer of Code, or financial questions about receiving donations. I agree that mailing lists are becoming too narrow a medium; at the same time, it's hard to find something truly representative. Some of you may know I'm also the Emacs maintainer, and we use mailing lists there too -- and receive many of the same complaints about inaccessibility, and too much inward-focus. Yet there are several influential people in our community who aren't accessible by anything but e-mail (our beloved SPJ is neither a Twitter nor a Reddit user!), so a true medium for collaboration would need to take place on many channels simultaneously. This sounds like an interesting technical and social problem to solve, especially as the number of mechanisms for communication continues to proliferate (many of my friends use apps I hadn't even heard of until recently). I love the Haskell language, and its excellent blending of theory and practice, and I also enjoy nearly all the Haskellers I've met over the years, including Michael Snoyman, a former co-worker of mine. It saddens me to see disputes of this kind, no matter who they're from, or why. It also surprises me to be thought of as evil, in any respect. All I can do is continue to serve the interests of the wider Haskell community as best I can, no matter what happens. If you all want me removed to make way for a braver new world, that's OK too. There are always other interesting things to do. I hope everyone will take some time to remember why we're doing this together in the first place. We love this technology, we love its promise and potential, we love the learning attitudes it engenders, and the way it embraces ideas as far afield as REST APIs and the lambda calculus. I think it's here that we can find a better path forward, rather than getting caught up in who said what when.
Yeah, the reason it was better for me is that I was using an "infinite" array. If you're using a finite grid (which is how the language is actually defined) then my result wouldn't hold. You get really good sharing of data structures that way as well, the other way you really can't avoid the massive pauses to reconstruct the whole array (again, it was infinite).
Sure! You need two things for a Git dependency in Stack: the repository's URL and the commit hash you want to use. The current head of the develop branch is [7b1307a](https://github.com/IFCA/opencl/commit/7b1307a9e1b967d2a7f08411f70618dd9b9a976c), so your `stack.yaml` would look something like this: packages: - . - extra-dep: true location: git: git@github.com:IFCA/opencl.git commit: 7b1307a9e1b967d2a7f08411f70618dd9b9a976c
Maybe he does! I don't know, only he can say. 
https://www.reddit.com/r/haskell/comments/4zzmoa/haskellorg_and_the_evil_cabal/d70dw9y
You're awesome John. Please stay awesome.
[removed]
 type MRam s = STRef s (UM.MVector s MemWord) Is there a reason for wrapping an `MVector` behind an `STRef`? Your code creates the `MVector` exactly once at the beginning of the program. It remains the same `MVector` over the course of the program, so you could get away with just: type MRam s = UM.MVector s MemWord That would remove one layer of indirection. It might also help to make your data structures more strict (e.g. in `MWorld`) and add `UNPACK` where possible.
Yup. Works a lot nicer than mangling the field names, though it also strips out the record constructor so you can't do `RecordWildcards` shenanigans.
[removed]
Whatever the motivation, the conflation seems to have occurred [accidentally on purpose.](https://www.youtube.com/watch?v=Go0KC65ciXk)
For a concise package please see https://github.com/benl23x5/gloss/pull/23 Ben decided this functionality would fit better outside of Gloss. Not arguing with Ben, but I do think this code should live somewhere in a packaged form eventually. I'm lost time an interest since the last time the topic came up, but its a really simple job and great for anyone who is trying to contribute.
What does the profiler say? Also I seem to remember that mutable references are really slow if you update them more than once. It might be worth trying a singleton mutable vector instead.
&gt; If you all want me removed to make way for a braver new world, that's OK too. How dare you. How dare you? --- Seriously though I do have a request. I would love it if we would strive for a higher standard of excellence in the `.cabal` file format. There is information in it like `other-extensions` which can be purely derived from the source code of the project. I don't believe in acting as a human compiler (not because my time's valuable -- just because I'm more likely to mess this up than a computer), and purely derivable info has no place in a human edited config file. Stuff like this pushes me over to the Stack side of things, because I get the (perhaps false) impression they care more about removing any burdens possible from library maintainers. --- EDIT: Just to preempt any confusion from other readers, `other-extensions` is completely separate from `default-extensions`. The latter turns on extensions throughout the project and is a great setting to have, the former is just a list of all the extensions that are declared in the project's source code.
The Random Access Zipper: Simple, Purely-Functional Sequences Kyle Headley, Matthew A. Hammer (Submitted on 21 Aug 2016) https://arxiv.org/abs/1608.06009
I'm not really interested in your low-effort shit-posts. For the sake of everyone else, the *original* state was that new users were going down in flames because they were installing the platform and trying to deal with the associated problems. This was true before FPComplete was formed or I'd ever heard of Snoyman.
I think this is vestigial. At one point there was an intermediate `MPtr` that held the vector and cursor and constant replacing that in the `MWorld` was causing a lot of allocation. I'll try to remove this and see how we do.
Unfortunately, in the presence of CPP you can't derive `other-extensions` that easily from the source. The cabal solver (since 1.24) uses that field to make sure to pick install-plans where your currently selected compiler provides the features declared by `other-extensions` (and `default-extensions`). There's also a clever way to use `other-extensions: TemplateHaskell` to toggle a cabal flag, based on the availability of TH in your current GHC (note that TH is not available on all platforms for which GHC is available). EDIT: I forgot that even without CPP, in order to know the set of required extensions may require to run `TemplateHaskell` code.
Sounds pretty cool. Is this on hackage somewhere?
Having mentioned my prior poor experience earlier, I figured what the heck, I should try again, right? If only to have a really, _really_ defensible position from which to be annoyed. :) Unfortunately for my opportunity to be annoyed, things seem to be going fine this time. The problems I was having before seem to have, uh, evaporated. I don't know *why* things are different, which I have to say leaves me with a certain concern about the possibility of the other shoe dropping. And I feel like I need to write up a couple of small decisions I made in the hopes they will make things easier for others. But hey, I've stripped everything but stack from my main nix environment, and everything is working, up to and including intero. So, you know, success!
&gt; Unfortunately, in the presence of CPP you can't derive other-extensions that easily from the source. Oh dang. I hope that wasn't mentioned in the GitHub issue, if it was I feel bad for forgetting it. Perhaps if `other-extensions` is required in the future it could stay optional if CPP isn't being used? Regardless now that I understand the reasoning this is no longer an issue that I feel like is important enough to need answers on this thread -- if a discussion of enforcing `other-extensions` comes up on GitHub will you link me to it?
There's also `cabal new-build` which is a fundamental departure in how dependencies are managed. It's currently being provisionally deployed to the community -- http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
I'm very much in favour of people coming up with opinionated ways about how things should work and promoting them aggresively. I don't see why this has to involve open criticism of others though. Michael is surely on to something good with Stack and Stackage. Why not make them, promote them, say they are better than haskell.org and encourage new users to use them, without openly criticising anyone from the Haskell committee? Who cares what the Haskell committee do or say? Just build your own better software and infrastructure.
Thanks. Please link me to it when you do.
[removed]
That may well address my moment to moment workflow. I simply haven't had enough of an issue with what I do now to have to change.
If I were to look at Haskell today and judge it solely on the relative volume of the participants, I'd stay away. A large part of why I got into Haskell in the first place was the congeniality and intelligence of folks in the #haskell channel. The language itself eventually rocked my world, but the first two months of lurking were almost entirely on the strength of the community. That said, the uptake of Haskell in the commercial world is happening in places where Haskell is well suited. Complex web services deploy easily with haskell and docker, today. Places where a lot of computation has to happen otherwise disconnected from the rest of the ecosystem are well suited.
&gt; If you actually go and read the mailing lists it's pretty impressive how much restraint has been shown already. Someone writes a long essay on why the HP is harmful and the response is generally, "OK but we're not going to change that." Is this an accurate, representative summary of what happened?
You mean Windows and Mac?
To be honest, the whole issue with `cabal-install` vs. `stack` seems to me about backend-oriented vs. frontend-oriented people. The `cabal-install` people are spending their cycles to solve fundamental problems by the means of `new-build` and `backpack`. The frontend folks are trying to make everyone's experience seamless on the user-facing side. Ideally, the two groups would be working together, but alas..
I didn't even realize the manual recommended it. That line of docs dates back to 2010. I think it's just an oversight it's there: https://github.com/haskell/cabal/pull/3726
&gt; I find that I agree with the committee very infrequently. Given that they make decisions very infrequently that seems about right. ;) We meet maybe once a year. Snoyman rants about the shady actions of the committee about 12x as often as we actually even talk about anything! The only things I can think of that was decided by the committee that is remotely user facing is the contested text on the download page, and adopting Chris Done's layout for haskell.org. What other decisions have we made that you are disaffected by? The choice of CDN to use? Democratizing access to the haskell infrastructure so the servers don't go down all the time and we have more maintainers? Did we pick the wrong projects for the Summer of Haskell? Or not ask Google for enough slots for GSoC each year? 99.9% of the work of the committee has nothing to do with the download page. At the risk of over-simplifying his position, Michael feels strongly enough about that issue to fork the entire site and try to fork /r/haskell into /r/haskell_lang. Meanwhile, most of the committee reaction is simple bewilderment over the scale of the reaction and annoyance that efforts to implement his own proposed compromise are now seen as attempts to compete and contest the "will of the community." I write haskell to build cool things with people I like to work with; I'm not enjoying this atmosphere at all. Every time I tune in the world is ending. If I wanted to fight with people I could go hack on the linux kernel and get paid for my headaches.
There's also the `backpack` integration in the pipeline, from the same people who make `cabal new-build`. It's another fundamental departure -- this time in the very notion of what a module are and how they are composed. I'm not exactly sure how exactly it affects `cabal-install`, but that's where one would expect the user-facing changes to land first.
I've stopped trying to go fast. If I can get to the point where it runs in constant memory I'll call it finished and move on to the next part.
For me, it's pretty simple: I want to control my dependencies myself, with Nix. As far as I can tell, cabal-install manages this nicely whereas stack insists on doing everything itself. I'd love to support stack (for, ie, intero-mode) while managing everything—including Haskell packages—with Nix, but I haven't been able to find a nice way to do this. There's a larger philosophical problem here: the stack world seems pretty dead set on an Apple-esque design philosophy of limited configuration and increased centralization. That's definitely not what I want from the infrastructure *for a whole language*.
There is a number of reasons to prefer mailing lists to the more ephemeral mediums. Those immediately coming to mind are: - slower pacing positively affects elaboration of thought - real names nudge towards responsibility - well-tuned tools to deal with long, complex conversations - a non-ephemeral paper-trail that can be dealt with at one's own pace - absence of distracting noise like "thumbs up" buttons
The discussion has come to the realisation that the original post is a false dichotomy. The solution proposed by the committee is to have *both* stack and the minimal HP. And it's the same solution that was actually proposed by Michael himself. The whole issue seems extremely contrived at this point.
https://mail.haskell.org/pipermail/haskell-community/2015-September/000034.html There was a short addendum email later that added this: &gt; while beginners may go to the page to look for “what first,” experienced users are accustomed to go there as well to look for the latest versions of things — and many of them still want/prefer the platform but otherwise yes. The irony to me is that the platform *never* has the latest version of things. Even when it's newly released it's typically behind in some way or another. That's besides the point though. The point is that after writing several pages of justification and explanation for why it's harmful etc, this is the kind of response that came back. If I was up against this for a year I'd probably start yelling about it too. That's all I'm saying here. That mailing list is just the same few topics over and over it seems, among the same four or five people, with the occasional outsider popping in to say "Hey the downloads section sucks" or something similar to kick it all off again. Honestly this whole thing could just go away if it were clear why things happen the way they do. Many people have said this, not just Snoyman. Even committee members on that list bring up that it's too opaque.
This. Throughout my tenure in Haskell, Snoyman has always attacked and denigrated any infrastructure that is not of his own design and control; and most of these attacks have been phrased in similarly hyperbolic terms as the post above. Whether you prefer the standard tools or Snoyman's tools is your business, but make no bones about it: the whole "dispute" comes from Snoyman's attempt to make a powerplay.
fight me
how's your TV doing, ed?
Typical committee response. ----- ^(^Just ^in ^case... ^this ^is ^a ^joke.)
Good points (both this and your adjacent one about backpack). Can someone more familiar with stack chip in about how it's caching is different than `cabal new-build` and about backpack support? I'm not very familiar with either situation.
https://github.com/commercialhaskell/stack/issues/2282 It just doesn't reference pgsql in the subject.
&gt; Not really as stack is using cabal-install under the hood to deal with package management. I was under the impression that Stack only used cabal-install for solving dependencies. For everything else it uses the Cabal library. Is that incorrect? 
Well while you were busy being disappointed in us we were busy building applications in haskell and driving adoption. 
Is this kind of back-and-forth that unusual? Seems like tempers run high in lots of O/S projects. I don't like this article but I would probably just file it in the "haters gonna hate" category ...
Then why not changing cabal/stack or creating a new (haskell) package manager that follows nix philosophy and gives a nice UX for haskell beginners? Is this possible? 
And I would assume someday -- GHC replaced by FPCHC. 
Maybe I'm just biased in that I managed to go a good decade in the Haskell ecosystem without it, so it is jarring to me now.
That is accurate to my knowledge.
Agreed. My (almost) completely useless [acme-http]( http://hackage.haskell.org/package/acme-http) has over 1000 downloads -- 24 in the last 30 days. It was an april fools joke that doesn't do anything useful, yet somehow gets downloaded almost every day... 
Afaik there is work being done on `cabal` to achieve this. The new `cabal new-install` for example is a step towards that goal
&gt; It's also worth remembering that for some people Reddit is the obscure channel. And, in fact, most of those mailing lists are older than reddit.
Yeah the drastically lower rate of burnout in beginners I work with due to Stack is just an illusion. Okay.
I don't think so, the argument isn't really about performance or something where everyone agrees what objective yardstick to use. Inevitably, data ⊂ opinions.
It's just the preferred (only?) indentation mode in haskell-mode. I think magic that doesn't work is a bad default, but I don't really understand the emacs mentality.
I kind of doubt this would be your problem, but the use of `unsafeFreeze` seems pretty sketchy to me. It at least contradicts what the documentation says you must do: if you `unsafeFreeze` a vector, according to the docs, you cannot use the original mutable vector again. "*Unsafe convert a mutable vector to an immutable one without copying.* ***The mutable vector may not be used after this operation.***" Slightly more to the point: since you said it seemed to leak space, what I would probably do is start by adding a bunch of strictness annotations and remove indirection whenever you can. The smarter way to do it (I'm not smart) would be to use GHC's heap profiling settings/tools, that way you could tell fairly specifically what was using memory and how. The space leak issue is probably a symptom of laziness.
Signed up cause it costs me nothing, but I'm wondering what the format is. Any details?
&gt; I agree that mailing lists are becoming too narrow a medium I don't. Twitter and Reddit both expect you to have an email before you sign up for their service, so their reach must *by their own restrictions* be smaller than an email. Mailing lists are neither hard to join, read, nor contribute to.
The committee is documented at: https://wiki.haskell.org/Haskell.org_committee The page itself just points to the github trac, which is as good an avenue as any to file tickets against, but its not a bad idea to link to the committee page more directly too. Now that I think about it, we should probably also have a direct link to admin@h.org around somewhere prominent to, as that's a clearinghouse for any infrastructure administration problems. I hadn't seen the bsd page -- that's a good idea, centralizing like that. I agree it would be good to fine a nice place to put something similar.
You should be able to use a newer `c2hs` (built against a newer `language-c`) to avoid that particular problem with `OpenCL`! Of course, if sufficiently new versions of them aren't in your resolver, the fix will be similar.
John, you're fantastic, please don't look for a sword to fall on. Regarding email, can I float the possibly unpopular suggestion that holding up better community support just for SPJ is not a good strategy? If we have thousands of people actively using the wider Haskell ecosystem, why cater to the needs of one person who works on one project? If need be, let someone like BenG relay Simon's thoughts on things if it gets to the point where his decision making power is needed. You can't please everyone (reddit? twitter? GitHub?), but aiming to please one person who doesn't actually participate very much in issues such as this seems to be specifically choosing the worst option.
I'm not the final word here but I've worked with other reading groups and advised Syrek on how I'd recommend he conduct this, so I shouldn't be too far off. It'll meet a bit like a reading group, you'll (probably) do one chapter a week. The objective is to do as much of the chapter (exercises and all) as possible independently, skipping and writing down which exercises/passages either didn't make sense or that you got stuck on. At the weekly meeting, people help each other understand (coteach) or go through the trickier exercises as a group.
Very sad and understandable. Thanks for your great work!
&gt;WriterT Don't.
You have to go to a site and sign up for both mailing lists and Reddit. The mailing list software stores your password in plain text and sends it to your all the time which is not a great look. I disagree about mailing lists being easy to use. For years I stayed away from them because I didn't understand how they worked. Now I stay away from them because I find them really unpleasant to use and outdated. You can try to apply logical reasoning as to why they should be better on paper but the traffic probably tells a different story.
Most likely we'll plan to work through a chapter a week and break out into smaller study groups depending on who needs help with what. I'll have more details soon, though. Chris, the author, has given me advice on what's worked for him, so I intend to follow his lead. And yeah, the only cost is the book itself and your MetroCard!
I've shaved about 35% off the Evaluating/bottles runtime with a single pragma. This also dropped a hot spot on the profile. I'm going to kick it around more but your main problem is excessive ornament.
Just wanted to pile on here and say how much I appreciate the immense gift of your time and energy to the Haskell community. It's really truly remarkable how much you've contributed, in both technical and social terms, to Haskell. I shudder to think where we'd be if you had not been roped in... I understand you're doing what you need to do, but please don't let yourself feel like your efforts aren't appreciated. They are.
If you're going to use a concrete monad stack, don't lift everything manually in your actions. Mnemonic: `lift`ing in my handler code is `fail`ure :)
Thanks, Edward, for all the work you've put in. Your work on summers of code will be very hard to replace, but I'm sure we'll find a way. A number of committee terms are up in October and we'll put out a call for new applicants. I hope others are inspired to step up and volunteer and get involved. Summers of code have produced a lot of important contributions in the past, and coordinating those and other projects really has a huge multiplier effect in terms of payoff for everyone.
Got it working. And stack build --profile works like a charm. You made my day. :)
I'm relieved Edward isn't leaving the community entirely. That was my first fear when I saw the post. On filling shoes: Don't try to. Take the responsibilities, roles, and positive querks of the departing person and fill those - often with multiple people. If people are puzzle pieces then you won't ever find one that fits the hole of a missing piece, but you might find a collection of new parts that can add the same value and mesh well with the remaining structure.
Edward, Haskell is more to me because of you.
I have a Nix file which uses `cabal2nix` to read my .cabal file and figure out what dependencies it needs. Nix can then install all my Haskell dependencies (as well as non-Haskell dependencies like Cairo or glpk). Once it's ready, I run `cabal configure` from a Nix shell and then use cabal as normal, without worrying about sandboxing (`cabal build`, `cabal install` and so on). `cabal2nix` happens to be the way my Nix file reads my .cabal file, but that's not the important part. Rather, the important part is that all my packages are built with Nix including binary caching and whatever local modifications I want using Nix's overriding facilities. I would love to be able to just run stack from a Nix shell the same way and have it use the packages Nix built, but I couldn't figure out how to do that. To be clear: this took a bit of effort to set up. The Nix ecosystem is not quite at the point where it's great for beginners, especially on OS X. But now that I have it working it's powerful, flexible and self-contained.
&gt; Just a general response Yeah, sure=) &gt; If you want changes in Cabal, a good place to discuss them would be the cabal-devel mailing list. Sorry! &gt; The cabal file format is actually mostly orthogonal to this discussion anyway, as it's a deeper piece of infrastructure upon which all of the tools we're discussing here are built. IMO it's not totally orthogonal. I think a lot of the acrimony that's been building up has to do with sharing `.cabal` files (witness all the PVP upper bounds stuff), and so improving `.cabal` files could improve the overall situation.
How does one not? I didn't really choose to sprinkle lift everywhere, it was mostly just chasing down type errors. I found it pretty ugly.
Mailing lists don't guarantee real names. Long, complex conversations are actually horrid on mailing lists because branching by subject line doesn't usually work well. Other tools have a paper trail as well, and "thumbs up" buttons are certainly better than a host of "+1" and "-1" emails.
Then what on earth are we still arguing about?
In our book, we have chapters on Reader and State. We explain ReaderT and StateT. Guess what we don't cover because it's a bloody trap?
Re the freezing, yes you're right. If you use unsafe* all bets are off and you're on your own to make sure you don't do anything crazy. In this particular case, I know for certain that I don't need to use both the mutabled and frozen version at the same time. I'm freezing it in place just to get access to elemIndex, then dropping it on the floor and hanging on to my mutable reference. As for the profiling, I'm working on that now. Reading core to figure out why runLoop allocates so much is non-trivial. I have at least discovered that WriterT is a big hairy disaster that shouldn't exist.
Uhhh, I use mtl-style but for what you're doing you can centralize and prelift "runners". It's 0115, best way to backtrack on this idea is to search (on this reddit and elsewhere) for people saying not to use lift. Should include more detailed examples. I'm surprised you gave up on making it fast. The time profiles I had on my `watch cat` were giving me relatively good hot-spots. What remains in my version is mostly the compress function (run, go, foldr, fix) eating you alive. Possible it gets more diffuse after that.
The prime example is the ongoing saga of determining Stack's prominence on the Haskell.org downloads page (latest installment here: https://www.reddit.com/r/haskell/comments/4zzmoa/haskellorg_and_the_evil_cabal/). Similar dynamics arose around the edges of the Foldable/Traversable Prelude debate last year, but those did not directly concern Haskell.org committee business. And it seems that, in no small part thanks to Edward's communication efforts, the core libraries committee has managed to keep subsequent discussions of similar breaking changes cordial and professional.
I see. Thank you for the prompt response.
Edward, thank you so much for having kept up for so long despite the [toxic behavior of a few individuals to get their way](https://twitter.com/snoyberg/status/770089276264546304). Besides your time, your health is the most precious resource and you need to safeguard it, so I fully understand and encourage you not to risk it over such ultimately insignificant controversies. Please, people let's get all back to coding in Haskell, the one thing that Haskell was known to be fun for. 
&gt; Not really as stack is using cabal-install under the hood to deal with package management. Only the `stack solver` command. If cabal-install is unavailable it will install it.
Thank you so much for your work on the committee, Edward, and your work on GSoC in particular. My first “real” interaction with a Haskeller was when I was seated next to you at the Google Summer of Code Mentor Summit in 2011. I read “Haskell.org” on your badge and started asking you about the language. Before then I had only had played around with Haskell a little bit in my spare time as an “interesting, but probably not ‘real world’ language”, but meeting you (and later Eric Kow) was the real catalyst that led me to really learning the language that I still use almost every day.
Makes sense. Seems like the leak was WriterT if that's the only issue you're concerned with for now. At least in my heap profile, possible I'm missing something.
Although Stack is more like multirust, you can switch compiler versions easily with Stack.
So you're not using WriterT? Are you just stuffing the output back into the State?
Haskell does allow that. When you encounter a `where` that isn't followed by a `{`, the next non-whitespace character determines the anchor column for that layout block. If it's on the next line indented the same amount as the `where` keyword, then that's your anchor. The only time that wouldn't work is if it breaks some containing layout context. As far as I can tell, it's impossible that indenting the same amount as `where` can do that. (It is possible this is a problem with `let` or `\case`, however, since they can occur at the beginning of an expression`.
It's entirely possible adopt layout styles where this isn't a problem. As others have pointed out, it's really only a problem when you anchor a layout block somewhere other than the left-most non-tab character on a line. If you adopt a convention of always beginning a new line for every layout context, then consistently indenting with tabs works fine. That said, though, I think spaces are still the wiser choice. I used to be a big fan of tab characters early in my programming life, but that changed when I started working with others, and realized that they cannot follow the same strict rules about choice of whitespace characters that I had made for myself! :)
Really interesting that both of you make sense to me. I think it really comes down to execution (i.e. how the community uses the tool). This depends on community habits, mores, etc.
You make it sound like the only reason for including stack was to shut him up. I don't think this is right.
&gt; Why not make them, promote them, say they are better than haskell.org and encourage new users to use them I think he's doing that. And he's not alone at it. &gt; without openly criticising anyone from the Haskell committee? Who cares what the Haskell committee do or say? Just build your own better software and infrastructure. Well. According to many (including myself) Stack/Stackage is an enormous improvement in tooling over Cabal/Hackage (not even to mention the hours I wasted on HP, before *read* somewhere its not used by anyone who already settled is Haskell land and thus merely traps new comers). If said committee keeps pushing tools that are (a) not the mainstream and (b) not new comer friendly; while also saying that (a) converging the community and (b) being new comer friendly is high on the agenda. In that case I think some criticism is deserved. *edit 1:* I want to clear up that I did not knew HP now includes Stack when I wrote this comment. Since it currently includes Stack it is not much different from just telling people to use Stack. Personally I'll do just that, but if we want to point new comers in the HP direction that will not do much harm in the new situation I guess.
Instead of Void you should use (), because () is the type that contains no information (it's morally correct not to count the bottom).
`stack ghci Test.hs` fails miserably when `ghci Test.hs` lets me load the file (even if it does not exist yet), interact with it and edit it using `:e`. I don't understand how comes that `stack` is advertised as being ideal for newcomers when you can't even write one line of code without having to start a whole project first.
Re. Stack+Nix, recent developments have improved it. We're waiting for a new release. https://github.com/commercialhaskell/stack/issues/2472 
What I meant was that if things like this where x = ... y = ... and this let x = ... y = ... and this do x y and so on weren't allowed, then using tabs for indentation would be perfectly fine. I think...
**None** of the people using Stack/nix integration are using nixpkgs for haskell packages. That's beyond the point. See https://docs.haskellstack.org/en/stable/nix_integration/
&gt; If said committee keeps pushing tools that are (a) not the mainstream and (b) not new comer friendly; while also saying that (a) converging the community and (b) being new comer friendly is high on the agenda. In that case I think some criticism is deserved. But who care if the "committee" keeps pushing anything? The "committee" has absolutely no significance other than controlling the "haskell.org" domain. Ignore them.
[removed]
You're a big part of the reason I use Haskell. You've often been an accidental ad-hoc mentor to me, responding to my threads here on /r/Haskell. I'm sorry this situation was so much more stressful than it needed to be.
We could make a petition to force SPJ to get himself a reddit-handle. That'll teach him. ;)
There is always an adjunction into the Kleisli category and into the Eilenberg-Moore category for whatever monad you want to work with. They are initial/terminal however, so they are never terribly informative.
I would love to make another release of optparse-applicative soon (changing the `str` to return any `fromString` and related changes), but to me it seems that stack has encouraged some poor behaviour on the part of the pvp, and their rather slow process for updates encourages some perverse incentives which makes the hackage maintainers job more difficult. So I'm holding off, I don't think this is "the right thing", but it's a pressure one feels.
He has one, just rarely uses it.
+1/-1 puts consensus in place of search for objective truth. That's what echo chambers are made of.
I was thinking why this had never been done, but I think I just underestimated lens. This should have more advertising!
Thank you Edward for your many contributions! I hope to still see you at the occasional hackathon :-)
[removed]
Changing name or type for the sake of deprecation is quite heavy. Fixing a downstream code is probably about the same amount of work, as using the new/non-deprecated API.. *EDIT* OTOH this could be applied to e.g. *unsafe* stuff. :)
[removed]
No. I'm talking about the many part of the overall language that are too amateurish to use in company settings (example: cabal-install), and not improving overall (e.g. HP being kept alive and distributed as a valid option); that lead to this drama, but also lots of people staying away from Haskell (e.g. first experience of haskell through HP is a disaster for many people)
&gt; A large part of why I got into Haskell in the first place was the congeniality and intelligence of folks in the #haskell channel. The language itself eventually rocked my world, but the first two months of lurking were almost entirely on the strength of the community. &gt; This cut both ways though; I don't have enough fingers to count how many time I heard that the Haskell community is just an elitist bunch of people on their high horse not interested in any real world stuff but discussing abstract stuff and making fun of the people not using the right stuff/abstraction/categorytheory/purity/etc.
Not in a free monad, but happily, parallel execution using the ApplicativeDo extension has been done in an extensible monad for general purpose: [transient](http://github.com/agocorona/transient). It's so general purpose that some people may feel tired of watching me write about it on every topic. It is the only implementation of this functionality that I know. *Haxl* is Domain Specific, and *concurrently* has no monad. In the TransIO monad, the ApplicativeDo extension parallelize any asynchronous operation that does not depend on the result of others: {-# LANGUAGE ApplicativeDo #-} import Transient.Base main= keep $ do x &lt;- async foo y &lt;- async bar async baz liftIO $ print (x,y) foo,bar, and baz are IO computations. with ApplicativeDo enabled, the three operations are executed in parallel since the expression is transformed into an Applicative, which executes in parallel under the TransIO Applicative instance. (There's no `wait` primitive in transient since it uses true continuations under the hood) But this is too much parallelization in some cases, since may be necessary to force a sequencing of async operations with (&gt;&gt;) and the applicativeDo does not permit so. For example, "baz" can be there to wait for some keyboard input or some button pressed before presenting the result. There is an library that allows the use of the applicativeDo effect locally: https://hackage.haskell.org/package/applicative-quoters-0.1.0.8/docs/Control-Applicative-QQ-ADo.html main= keep $ do (x,y) &lt;- [$ado | x &lt;- async foo; y async &lt;- bar; (x,y)] option "result" "see the result" print (x,y) Here `foo` and `bar` are executed in parallel. Option, which uses async, is honored and wait for "result" input from the keyboard before printing the result. 
On the other hand `stack ghci` followed by `:l Test` (or `:e Test.hs` and then the load) works. No need to have a project.
&gt; As far as I'm concerned, the committee has two options: &gt; &gt; - Listen to the voices of the community and make Stack the primary option on haskell.org. &gt; &gt; - Ignore the community voices and put the Haskell Platform at the top of the page, thus confirming my claims of an oligarchy. On top of claiming to know exactly what the voices of the community are based on some anonymous Twitter poll, this sounds like a [false dilemma](https://en.wikipedia.org/wiki/False_dilemma) to me, and also a lot like a "do as I tell you, or else..."-threat. &gt; That said, I do believe that there were bad actions taken by individuals involved, and I've called some of those out. There's a much longer backstory here of the nepotism I refer to, starting at least at ICFP 2014 and GPS Haskell, but that's a story I'm not getting into right now. Sure, let's just leave some vague allegation out there. Either name specific incidents so people can actually decide for themselves if there's any merit to the allegations, or even better yet, please stop spreading FUD. You've already driven away one committee member, do you want the other ones gone as well? &gt; I'm claiming that Stack is by far the best option for the vast majority of new users. The committee has never to my knowledge argued publicly against that. Could this be because you prejudge the discussion outcome ("though I don't expect my opinion to actually be considered") when you comment on those discussions? 
Now tell me which of those don't apply equally to Usenet, which was solidly established before there was a Haskell. :/
I keep on asking: why not Usenet? It's as venerable and proven as email, it's actually intended for the purpose, and Google Groups makes it basically as friendly as reddit.
I would happily discuss things on services for which I already have accounts and don't affect my email inbox, for example: Reddit itself or GitHub. These are things I am using anyway.
My concern is the same as with any code involving Unicode : How the f*ck do I know how to type this shitty operator ? ;-)
&gt; If Snoyman was so concerned about "choice confusion" ... ...and not to mention the irony that the first thing new users interested in learning about Haskell now get confused about is whether haskell.org or haskell-lang.org is the *real* Haskell site 
I can't agree more
&gt; To me however it appears like his interests in making this page user friendly only goes to the extends of putting Stack front and center. Why do you think that ? The whole purpose of Stack is to get things started easier. It shows how to write a Hello world code and execute it using Stack. &gt; If Snoyman was so concerned about "choice confusion" why didn't they do anything about making choice easier on the documentation page? What choice confusion ? The list of tutorials cover various different topics. The list of books is ordered in a prioritized manner. If you feel something can be improved, feel free to open issues in the github tracker. &gt; I don't think its a coincidence that the only editor-plugin mentioned has relations to FP Complete. https://github.com/haskell-lang/haskell-lang/issues/85 . You are welcome to contribute in the [proposed gist](https://github.com/haskell-lang/haskell-lang/issues/85#issuecomment-243056864) there.
&gt;The inclusion of stack in HP is misdirection designed to shut down precisely this kind of thread and you and the other committee members have made a significant fraction of your replies along these lines. Take a step back and think about what you're saying (e.g. can you read minds?) and who you're saying it to. We really don't need comments like this one, especially directed to someone who has given so much to the community.
Can you expand on how you think Stack encourages poor behavior with respect to the PVP? Stack added the [`--pvp-bounds`](https://www.fpcomplete.com/blog/2015/09/stack-pvp) flag to `stack upload` last year. 
I say let the mailing list discussion decide the outcome of this and if you want to have any say in the matter, then subscribe to it and say something. I don't think the committee should be responsible for representing users across all mediums - they should just limit themselves to the noise of that one medium that they've designated for just this situation. Mailing lists are pretty clunky and off the beaten path, but at this point everyone who's paying attention to this drama knows the list exists and that there's a discussion taking place on it. So if you care, subscribe, cast your vote and/or say something, and move on. Twitter polls have no meaning here, either its on the mailing list or its not.
Except that was how long ago..
&gt; We can trivially put up a Google Form or similar and link to it from all media. We did this just fine with the FTP debate. Yeah, [a clear path forward](http://www.yesodweb.com/blog/2015/02/awesome-haskell-community). Nothing have changed.
Thanks for the answer. I wonder what other have users of Haskell are using for indentation. Tabstops?
[removed]
There seems to be this sentiment that Stack is the tool that always works while cabal is broken in endless ways. For me it's the other way around. Any time I tried to use Stack, I had to fight the automatisms like it trying to grab and run a GHC binary that wouldn't run on my Linux distro or BSD version anyway, or doing other automatic operations I had not insight into. I never got past that because cabal works and I've been successfully using sandboxes and new-build for complicated cases, with GHC builds that are not available from the distro repository or haskell.org. It's natural that some users prefer the stack automatisms, but the insistence on selecting one tool and presenting it as the primary option for new users makes no sense in the context of Haskell. Haskell is not a tool like Manuel's Haskell for Mac, which has every intention to be very user friendly and thus needs to be opinionated and work with many limitations. In contrast, going to haskell.org means one wants to write general haskell programs and doing that means you may use Emacs, Vim, Yi, Atom, VS Code, whatever, and just want a list of links to programming modes plus ways to get the toolchain. One cannot decide for users that they shouldn't use a distro GHC package. Users will choose what they're most comfortable with, and instead of making everything work with one tool that has you download binaries from a single party (no trusted distro packages, not always running binaries on local platform), they will select what works best for them. I mean, it's totally fine to list the options and let the user select. Believing users cannot make that decision makes too many assumptions and may even be disrespectful to some. So, as a general Haskell users, this whole debate doesn't make sense at all. All it does is scare away new users who see the debates and are confused. At best those will start with the tool used by a project they are getting involved in or proposed by a trusted friend. Just as vi and Emacs are different ways to edit text, it's okay for cabal-install and stack to coexist and be used by different people.
True or not, it's hard to imagine what would be bad in giving people who have a clear pragmatic track record of engineering successes keys to infrastructure. And it's a bit worrying that you might see Haskell community infrastructure as something assaulted for power control. Dude, it's infrastructure. The only criteria should be what works best, and we have a winner here so let's celebrate and help..
Ok, I think this is the right example, but I'd have to check with some other people to be sure. Suppose you have at the top level package A and it depends on B and P. It depends on B publicly and depends on P privately. Now suppose that via a chain of intermediate dependencies it turns out that B also depends on P publicly. Now because all of A's visible deps have to be consistent then we have to pick the same instance of P in both places (remember that P is visible to A since it depends on it directly, and it's a public dep of B). So while we initially hoped that P might be a private dep of A, it turns out it's actually a public dep of A and discovering this was a non-local operation.
Yup. That's the challenge. But there seems to be minefields of harmed ego, vested interests of some sort, well meaning people, and combination thereof, along the way. All this for infrastructure :)))
&gt; Your echo chamber of twitter followers is not the voice of the community. From the initial blog post of Snoyman: &gt;&gt; Decide that my poll is invalid for some reason, and do a proper poll of the community, with proper advertisement on Reddit, Twitter, the more popular mailing lists, etc
Me too, I panic-clicked. A Haskell without Edward Kmett is a completely different language. Even if they'd quit programming today, I still wouldn't have been able to thank them enough. Prelude&gt; repeat "thank you" ["thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank you","thank yoInterrupted. 
This is indeed mostly about newcomers, but the downloads page is just the most clear indication of a deeper rooted problem with hidden procedures and echo chambers. We all want to make Haskell as accessible as possible, especially since a lot of us has coworkers both now and in the future that will most likely have to learn it. You'd want the on-boarding process in your company to be as smooth as possible, so there are as few arguments against picking/switching to Haskell. Now, when you are a new user you'll most likely go to the languages download page to find the information you are looking for. A newcomer is then presented with several choices in a non-opinionated way - but this is absolutely the worst way to welcome someone new to the language, tooling and community. Far too many times have I started a new framework or language, and the first thing you want to find out is what is the right tool/library to use for the various things I'm going to do, instead of wasting weeks with something and then only to learn it was solved somewhere else. You might then think, well perhaps we should just help the new user as much as we can and point them to what is surely a well working tool, instead of not only having them learn the language but also wade through zillions of discussions based on technical merits they can't possibly know yet. Now could this have been handled better? Probably, but Michael has in no way not been trying to be patient (for well over a year he has been trying), and honestly, I'd rather we crack a few eggs and get out of this god damn stagnating approach which has seen so common in the Haskell community. "We are planning to release that in the next version of x"[0], when x is half a year or more away... What kind of answer is that to a concern that is immediately addressable, and seems like a we-don't-really-care-that-much-about-this-problem attitude. [0] A general response, but for a specific example take a look at the much linked GH pull request #130 linked somewhere else in all these discussions.
You avoid 99% of the problem. the purist says it not enough so we need to use the broken, global mutable state approach. But at some point it's actually good to have vetted versions. It's like gardening. You let nature evolve. But you trim it too. Both are needed..
That's a great question. Maybe it's worth having a new Reddit post asking users of various editors to describe how indentation works for them and how they like it.
Can we... not? If you want to respond to comments do it... in the comments. Or else create /r/haskell_blogwars and do post as many response, follow-ups, conclusions, reports and rants as you want.
Oh, I should stop procrastinating and try one BSD or another sometimes. I keep delaying this experiment for years :( Isn't Cabal the lower-level tech though? Stack is based on Cabal after-all.
&gt; I mean, it's totally fine to list the options and let the user select. Believing users cannot make that decision makes too many assumptions and may even be disrespectful to some. I think the current page is very good at explaining the difference between all options. However, I think that: * most beginner don't want to be faced with a wall of text when they just want to try a new language * most beginners will be unable to make an informed choice between cabal or stack style package management. They need a bit of experience to know which workflow suits them best For these reasons I feel like the committee should commit to a "one true way" for beginners, and perhaps link to something that looks like the current page for those that want to take the time to make an informed decision.
I really like what you've done with your Travis set-up. Did you ever resolve the static linking issue?
It breaks my heart to see our community breaking apart for such a silly matter (though a great misunderstanding). Edward, I deeply value and respect you, I think your talks were the final impulse I needed to finally start studying CS in my University. I remember thinking "this solves so many problems so elegantly, yet I have no f*ing idea what this guy is talking about!?". It's truly sad to see you leave like this, because of both a malfunctioning committee and a frustrated developer. Yes stack is better we know, but it's definitely not worth to attack people ("PHP" is an attack) because it's not on top of a website! Has anyone done the analytics? Who would start learning a language by blindly downloading the first option on a website and, without looking at any material, poking around endlessly? Let's hope this makes everyone realise that to continue this argument is to destroy the Haskell community, and everything that's so great and beautiful about it.
You want to promote 'consensus' and 'conflict resolution' and 'attract volunteer' ? Well then promote tools that works, where problems have been ironed out collectively !!! You want to *say* you promote 'consensus' and other niceties and be seen as a good person. Well then go on with raising against evil, denounce political leverage and talk about how good your ethic is. The rest of us just enjoy a practical and **very** welcoming tool ecosystem which saved the day and eradicated hours of bullshit headache with global state non reproducible builds.
&gt; Can't people just give factual opinion about why this is better than this for newbies? Maybe a 'download' and a 'get started' page serve different purposes? Why should they be one and the same thing?
&gt;This subreddit is becoming a cesspool of angry persons. I know that haters gotta hate, but this is becoming a bit extreme to me. Indeed, these last two threads has been very devoid from technical discussion of the changes :( &gt;Can't people just give factual opinion about why this is better than this for newbies? I understand that many people are angry about him or stack, but please don't share your anger. Having had the problem many times with un-opinionated introductions to frameworks and languages, I strongly favor the approach of the haskell-lang.org download page. You might think you are doing your users a favor by being non-biased towards a solution/tooling/library, but all you are doing is offloading all that work to the user which has the least qualified opinion of what to use. They not only are in doubt of their choice, but also have to sift through tons of internet discussions on which tool to use, and it's pretty hard to judge what is factual and what is trolling from time to time. In my opinion a language page, and in general any introductory sauce, should guide the user towards getting up and running quickly and correctly in a way that'll benefit them most in the long term. In this specific instance my vote is on that being Stack (preferably) or HP+Stack (without the global libraries), since that to me is more or less the same. As a recent example I had to learn React-Native for a project and I think half the time I spent on sorting out what libraries to use for the various things, since there were a ton of half-abandoned libraries, and the official documentation points nowhere on most aspects that you'll encounter, while being comprehensive on other points.
Well change do not come out of ether, mind you. Even very obvious ideas have to be sustained by actual people to become a reality. So let's not blame the messengers and thank them instead
Video please !
&gt; I was almost assaulted on IRC for using conduit (because true haskellers use pipe). Since IRC channels are logged, can you provide a link to that assault? 
Will the talks be on youtube or the slides made available - I'm particularly interested in Finlay's talk on cloud haskell: http://www.composeconference.org/2016-melbourne/day-one-program/#t-1300
Yes, I understand that. And I tend agree. Personally I have limited experience with stack, but find it very good in most cases. And yes, the procedures are terrible, we are making silly decisions often, we don't account all stakeholders, etc. But IMO you are overestimating the importance of the issue in question. You can crack eggs, but the cost is high. FTP egg damaged "the awesome Haskell community" for little benefits, now you are going to make even more damage for unknown benefits (how many newcomers we lose every day because of bad landing page? 1? 100? 1000?). But if you have long term roadmap (do you?) to fix the procedures, then it could be beneficial to crack a few eggs, I don't know. Note that I'm not trying to argue here because I don't know easy way to estimate damage and gain. I just want to emphasize that people has different understanding of the tradeoff. I see why you may prefer to crack eggs, but do you see why other people don't want? I can't neither agree no disagree with "We all want to make Haskell as accessible as possible" statement unless I know costs. 
I have some questions about the technical discussion raised before I'd like to vote &gt; There is no clear "getting started" guide for new users. Giving someone a download is only half the battle. If they don't know where to go next, the download it useless. (Compare with haskell-lang's getting started.) How is this related to HP-minimal vs. stack as a download option? Obviously it seems like a good thing to add in any case. &gt; Choice confusion: saying "HP vs Stack" is actually misleading. The real question is "HP+cabal-install vs HP+Stack vs Stack". A new user is not in a strong enough position to make this decision. If I understand correctly, HP-minimal is ghc + ghci + stack + cabal, right? Then it would be "Stack + (Nothing vs ghc/ghci/cabal)". &gt; Stack will select the appropriate version of GHC to be used based on the project the user is working on. Bundling GHC with Stack insists on a specific GHC version. (I'm not arguing that there's no benefit to including GHC in the installer, but there are definitely downsides too.) Does stack not work if there is a specific version installed globally? &gt; The HP release process has historically been very slow, whereas the Stack release process is a well oiled machine. I have major concerns about users being stuck with out-of-date Stack executables by using the HP and running into already fixed bugs. This isn't hypothetical: GHC for Mac OS X shipped an old Stack version for a while resulting in many bug reports. (This is an example of haskell.org download page decisions causing extra work for the Stack team.) Stack has an upgrade option, right? Perhaps this action could be included in the installer? As far as I can tell the version of stack binary &gt; Bonus point (not on Twitter): Stack on its own is very well tested. We have little experience in the wild of HP+Stack. Just assuming it will work is scary, and goes against the history of buggy Haskell Platform releases. That seems fair. However, if it's just a set of binaries being placed on a machine I'm not too afraid. These are sincere questions. I'm a happy cabal user and I just don't know stack very well. I think an informed discussion and voting process would be more useful than quick polls/vote mailings.
[removed]
The naming here is terribly confusing; strictly speaking the two options being discussed here are Stack and `cabal-install` (which is the package that provides the `cabal` executable). Indeed both build upon the `Cabal` library, but do so in very different ways.
That's because it turned out the issue is very small and unimportant, after Snoyman had inflated it to matters of good and evil. I really don't think all this is worth it if the only difference it could make is whether the download page includes cabal or not. We already have Stack in the platform, there's not much reason to stir up such heated debate about this.
&gt;How is this related to HP-minimal vs. stack as a download option? Obviously it seems like a good thing to add in any case. Mostly in the sense that providing multiple options to a user instead of clearly stating "here, use this". If you take a look at the "Get Started" page on haskell-lang.org, it is quite a lot simpler and easier to follow than the "Downloads" page on haskell.org, which is a bit overwhelming for a new user. There could perhaps be a very brief text mentioning alternatives, but one would have to be carefull not to destroy the point of the new page, and going back to confusing users. &gt;If I understand correctly, HP-minimal is ghc + ghci + stack + cabal, right? Then it would be "Stack + (Nothing vs ghc/ghci/cabal)". I came to understand it that the HP+Stack is GHC/GHCi/Stack, so both GHC and GHCi exist globally without needing to run `stack setup` first to download the compiler. &gt;Does stack not work if there is a specific version installed globally? It does, and IIRC it'll default to the system installed GHC if it fits the constraints (someone correct me if that is not the behaviour anymore). &gt;Stack has an upgrade option, right? Perhaps this action could be included in the installer? As far as I can tell the version of stack binary Yes, you can upgrade it independently of whatever GHC was globally installed. Running upgrade on first launch might actually be a very good approach (or prompting for it when stack is run the first time), since I think Snoyman's concern was that users with an outdated stack that was bundled with HP has historically been an issue, because of things having been fixed in later versions. &gt;That seems fair. However, if it's just a set of binaries being placed on a machine I'm not too afraid. Indeed, I'd almost say that during the migration phase from cabal-intsall to stack a ton of users would have had GHC and GHCi (heck I still have) installed globally, so I'm not much too afraid either :)
I'm unreasonably excited about this. I hope the Haskell community can rally behind `hindent` and format everything the same way. 
&gt;You've already driven away one committee member, do you want the other ones gone as well? It would seem to me that that is the intent.
&gt;his claim that his opinion is the voice of the community It certainly is more representing than a mailing list of 5 people.. Perhaps a more constructive approach would be to come up with a proposal for how we could gauge what the community would like to happen. My only suggestion for that is a coordinated effort of cross posting a link to a form that will be posted on the different venues (reddit, twitter, mailing lists).
Thanks! &gt; Mostly in the sense that providing multiple options to a user instead of clearly stating "here, use this". If you take a look at the "Get Started" page on haskell-lang.org, it is quite a lot simpler and easier to follow than the "Downloads" page on haskell.org, which is a bit overwhelming for a new user. I certainly agree that the download page of haskell-lang.org is much more clear and simple and haskell.org should take an example. But that does not really make any technical difference for putting stack or hp as default download. &gt; I came to understand it that the HP+Stack is GHC/GHCi/Stack, so both GHC and GHCi exist globally without needing to run stack setup first to download the compiler. According to [this](https://mail.haskell.org/pipermail/haskell-community/2016-August/000127.html) its ghc+ghci+stack+cabal+alex+happy 
Eh, honestly if it weren't for stack I wouldn't even use Haskell at all and I wouldn't recommend it to anyone else either outside of hobby projects. It's okay to acknowledge other approaches and admit that they might be appropriate for some users, but in general it's pretty vital that newcomers be directed specifically towards stack. I understand your complaint, but I think Haskell tooling pre-stack is a pretty serious problem that has kept countless people from even learning the language. I'm not the only person who feels this way. I have a few coworkers who all told me that they gave up on learning Haskell because of cabal. From the perspective of an outsider, I feel like the Haskell community should be collectively jumping for joy that something like stack now exists.
hmm. it should not mess the layout :( (you need to add `--` inside the list to keep the format) exceptions = [ InvalidStatusCode , MissingContentHeader , InternalServerError ] -- hident --&gt; exceptions = [InvalidStatusCode, MissingContentHeader, InternalServerError]
Thanks! We also use Nix and Haskell at work, but up until now we had used Nix primarily for deploying to production and not for local development because we thought Nix couldn't handle incremental builds. However, we never thought to use a Nix shell combined with Cabal for local development like you suggest and we're going to give that a try. Thanks for the tip!
I think this is a feature, not a bug. The same AST should produce the same output, regardless of the input format. 
Sounds good. I've already got the book and breezed through the first couple of chapters. The biggest value for me will be talking to other students and teachers. I'm looking forward to it!
So, ghcjs --interactive doesn't work w/ ghcjs-8.0? 
[removed]
EDIT: I guess the [style-guide it's based on](https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md) does alignment in a bunch of the examples, but the tool does not. Great! I think one style is great, and I'm really glad that this exists now. My main hesitation is with vertical alignment. This creates really destructive diffs, because unchanged code gets changed by alignment. Say you have myFun x y | test x y = foo | otherTest x y = bar And you change this to myFun x y | test x y = foo | yetAnotherTest x y = bar Now your diff shows the `foo` case as changed, when it isn't. Looking at the diff doesn't make it obvious where the meaningful change happened, so it's harder to track down bugs. Your diff is just... messier. I'd much rather see something like Elm's style come to Haskell, but even if it doesn't, I think there's a lot of benefits to removing vertical alignment from the current format.
About a week ago I updated optparse[1], adding `Semigroup` instances to a bunch of `Monoid` data types. It was a good thing, but lead to a necessary breaking change regarding an exported `(&lt;&gt;)` from `Data.Monoid` (which is a synonym for `mappend`). This should be fine. But it wasn't, arguments ensued on PRs adding upper bounds or imports, and stack/stackage was a big reason given for why things either wouldn't be or shouldn't be updated. I commented on haskell infra that "I think I have broken the world here"; but the more accurate (and apparently prophetic) phrase I had used in the office was "I thing I have pulled the scab off a wound here". Regarding explicit examples I would prefer to not. [1] Not just me, great folks submitted PRs and offered advice.
`hindent` doesn't do vertical alignment. myFun x y | test x y = foo | yetAnotherTest x y = bar
Huh, the [style guide it's based on](https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md) does. I'll have to download it and try it out more.
I use 2 pretty religiously even outside of haskell. That said want a standard more than I want it to be 2.
You can try it out without downloading anything! http://chrisdone.com/hindent/
TIL I've been coding pretty much the Tibell style this entire time. WOT!
I have started to build `nightly` via `cron`: http://tolysz.org/ghcjs/untested I have not implemented automatic tests to see if they would build a sample app via multiple `node` versions.
The [linked style guide](https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md) does in a bunch of places: * Aligning the `::` in records * Aligning the `=` in `filter` * Aligning the `[` `,` `]` in `directions` * Aligning the `if/else/then` based on the length of the variable
this blog is a real "are we the baddies?" moment for fpcomplete isn't it? it really doesn't reflect well on him personally or them. I dunno, it's probably all just cultural differences, i'm a Brit after all but _shrug_ I find this post shameless and disgusting. We use stack extensively at work, and do think it is great, but wouldn't think twice about ripping it out if I saw more of this. Anecdotally, in the various different companies I've worked at I've spoken to various non-engineering teams such as the data science teams and asked them why they use the languages they do. All of them, at each company, would point to some downloadable package of common libraries that they needed, with an IDE, that would do everything and not require them to get involved in package management or ever download a library. Without fail, that was what turned all these teams onto the languages they chose. If Haskell wants to be adopted more widely it needs the same story. The Haskell platform in it's current form may not be adequate at that, but (whilst i use stack almost exclusively now) stack is *definitely not* that. So for the haskell-lang site to only push stack would only serve to limit haskell adoption more widely in my opinion. Haskell needs a data-science suite that installs without ever needing once to use stack to install other libs. I think the haskell.org download page reads well, gives options, and--just reading it now--actually treats stack preferentially in its wording which was quite a shock having read this blogpost first. 
Derp, missed that. You're right, the tool doesn't align a bunch of things that the examples in the guide do align.
Hahaha. Come on guys, take a joke. 5 space indent FTW!
I mean, it looks like the tool is following the old guide, so you weren't wrong...
He's clearly not a good politician either then, and rather than trying to unite the community by providing a welcoming discussion climate, the room gets filled with tension as soon as he starts speaking. The fact is, he seems to be at the center of each controversy. Is he really the victim here getting shit from everyone and forced to defend himself, or is he failing at communicating effectively?
Sure thing, the style guide format lists differently... why they can not look the same as the samples of good formatting? exceptions = [InvalidStatusCode, MissingContentHeader, InternalServerError] exceptions = [ InvalidStatusCode , MissingContentHeader , InternalServerError -- ] directions = [ North -- , East , South , West] http://tinyurl.com/z8zhfuy
I was just about to correct my post here. I've gone over the the documentation and indeed saw that `isHexDigit` is what I'm looking for.
&gt; Wow I'm very surprised by that. I honestly feel like I've never seen 4-space indentation in Haskell. A while ago, I was surprised to learn that a substantial portion of the top authors use the Tibell style which mandates 4 spaces. Well Typed's style is similar to Tibell's, the `time` package is 4-space, as is `base`, `text` (Bryan O'Sullivan) is 4-space, `judy` and `json` (Galois and Don Stewart) is 4-space, `Cabal` (Thomas Schilling and Isaac Jones) is 4-spaces, `integer-gmp` (Herbert Valerio Riedel), Michael Snoyman follows this tradition with Yesod and his other packages, and our Stack codebase is the same. So I pretty much already assumed more people use 4-spaces than I had assumed. I just looked at Hackage to confirm my suspicion. For me it's pretty arbitrary which one you pick. When things are arbitrary, you might as well go with what everyone else is doing. Most _other_ languages out there do some multiple of 4, too. You can always specify `--tab-size 2` if you _really_ can't abide 4 spaces. I plan on adding a `.hindent` type of file for stuff like that. &gt; How exactly was that survey done? I just unpacked the top 1000 packages, grepped for declarations which line-break and continue into a 4-space or 2-space indentation, then counted them all. The number with the most occurrences wins for a file, then the number with the most for each file wins for a project. [Here are the results](https://gist.github.com/chrisdone/72b8458a16359fdb251ed86f34c2163d). 
Wait till you see 6.5 space tabstop replacements for tabs, it's the only way to hack.
`hindent`'s style is based on Johan Tibell's style, but I guess they're not the same. For what it's worth, the README doesn't link to Tibell's guide. 
While this is generally great, and the output of hindent looks very consistent, I think there's one aspect where this would make code less readable. If you have a longer chain of function applications or operators (like with lens, especially when working on a tree-like structure), it will try to fit as much as possible into a single line. At least when I'm writing such code, I usually line break (or even line break and indent) it in logical units. hindent doesn't keep them though. It seems like rustfmt for example tries to keep such additional line breaks, would seem like a useful feature for hindent too
TIL I've been coding 80% Tibell-compliant Haskell without having read the document.
Good point, the Tibell style does suggest to align. Perhaps we could convince /u/tibbe to reconsider (or reword) those particular parts, as with any alignment it creates dependency, similar to function-argument alignment. HIndent doesn't do that, so that diffs are less noisy. Johan contributed to [a discussion](https://github.com/chrisdone/hindent/issues/67#issuecomment-70495995) like this a while back and seemed sympathetic to the argument. E.g. foobles bar mu vs foobles bar mu The latter has no dependency.
You're not resigning from all your packages like `lens`, phew! `lens` is brilliant and lets me do things I couldn't do otherwise. I'm glad you are letting the webpage go. It will sort itself out. Spend your Haskell time on stuff you like!
I mostly use Tibell style already, but with 2-space tabs. *That said* A formatting tool that enforces only one style isn't a formatter, it's a linter with a formatting script. It's fine to have a single default style, but it should be possible to override it on a per-project basis. It *is* easy to switch styles, that's why it's silly to enforce a single one globally.
I love the idea of typing without caring about formatting and then doing it in a consistent way with a single key press. It's one of the things I really miss from C#. However I'm not really pleased with some of the results I'm getting. For example code like this main :: IO () main = do pool &lt;- createPostgresqlPool (toS databaseConnectionString) 10 initiate $ \chan -&gt; forever $ do flip runDbConn pool $ do makeSureQueueIsFull chan void $ liftBaseOpDiscard (consumeMsgs chan responseQueue Ack) (uncurry processMsg) threadDelay 1000000 gets turned into main :: IO () main = do pool &lt;- createPostgresqlPool (toS databaseConnectionString) 10 initiate $ \chan -&gt; forever $ do flip runDbConn pool $ do makeSureQueueIsFull chan void $ liftBaseOpDiscard (consumeMsgs chan responseQueue Ack) (uncurry processMsg) threadDelay 1000000
His communication is clearly failing, given how polarized people are. I usually find his proposals reasonable, so I have a hard time understanding why. The last message was quite adversarial, but I can see where this comes from.
The idea is that every (or at least most) projects would use a single community style. That would make contributing to different projects easier because you wouldn't have to understand their style and try to match it. Other languages have this too, like [gofmt](https://golang.org/cmd/gofmt/), [rustfmt](https://github.com/rust-lang-nursery/rustfmt), and [elm-format](https://github.com/avh4/elm-format). 
About the year that it took to implement.
The Haskell world has a different problem because of stuff like the network package which are hard to build on platforms like Windows. As a result you more or less need to install *some* packages along with the compiler if you don't want people to think your programming language is only good for playing with infinite lists in the REPL. 
Ah, I see. I misread your "if Haskell only allowed", and thought you'd meant "if only Haskell allowed"... and confusion followed.
&gt; It is as meaningless as FTP discussion was. FTP has hugely influenced my Haskell work. It has eliminated a pile of imports from the top of my modules and now functions like `sequence` are not arbitrarily limited to lists. Before, I had to make sure I imported the right thing when working on a `Seq` rather than a list. Now the same functions work on both. Yeah, I know I could always just type `import Data.Traversable` or whatever...I know that because that's exactly what I said in the FTP debate, and that's why I was opposed to the changes. But now I think it was a great idea and cannot imagine going back to the illogical mess we had. It's the same with a download page. These small things make a big difference. To tell a newcomer "go to Haskell.org, download, get going" is much easier than "there is a Haskell.org, but don't go there, go over here instead, because the Haskell.org has the wrong way to do things." The difference between the two of these is sometimes going to be the difference between someone trying the language and someone rolling their eyes because why would they try a language that can't even have a good download page? These little things matter immensely so neither FTP nor download pages are meaningless discussions.
I fail to see what's wrong with an official language implementation suit which include ghc, ghci, cabal-install and stack.
Yes I got that, but I meant that, ignoring seq, nobody would ever notice anything amiss when they tried to use a field with type () - they'd always get out a () indistinguishable from the one they put in. () is the type with that characteristic property, which is why it should be used.
What's the most common kind of build errors you had to help fix?
I don't know about the others, but you can specify styles per-project for `rustfmt`, and it's pretty common to do so. In fact I don't think there is a single preferred style for rust as of yet. If a person is using a formatter then the cost to use a project's style that's different from their preferred style *is already zero*. If the project isn't specifying a stylesheet, then they're probably not using hindent and so it's not particularly likely they conform to it's idea of Tibell style *anyway*.
Guilty parties after the changes I made above: compress.run Brnfckr.Eval 11.0 9.4 compressGo.go Brnfckr.Eval 7.1 11.3 (I split out `go` from compress)
No real need for me to echo how great it is that Ed is (still) interested in Haskell. Being on a non-profit board or committee can be both a joy and pain. When there is no longer a good fit, it's a good idea to move on and focus on what brings you more joy. Resigning also serves to remind those who remain to check their own agendas and make sure the shared work remains collegial and helps the organization's goals. I once served on the board of a non-profit for nearly four years. Nobody ever moved on voluntarily, and that was hurting the organization. I resigned, partly to set an example, and within a year the entire board turned over. The non-profit is better off for it in the end. I don't know if relationships on the committee can be repaired but here are a couple of suggestions to avoid problems on committees like this. 1) Meet in person, or at least by video. Don't decide things over email. Email can be inhuman, especially in the hands of humans. 2) If you are part of a team, don't set up competing efforts. 3) If you are compelled to compete, which can happen, then don't leave yourself in a conflicted position. Instead resign and compete. People respect competitors. 4) Ad hominem is always bad look. Always be about the work and only bitch at home. When your spouse gets tired of hearing it you will know what to do. 
Good to hear. After you've called `cabal configure`, it works with the Emacs mode interaction without any additional configuration. I believe this is because `cabal configure` learns absolute paths. The one useful trick I've picked up is having a `shell.nix` that calls `cabal2nix` for you, so that you don't have to call it yourself each time you add a dependency. I don't know if this scales to more complex examples—although I don't see why not—but it's been working for me. [Here's an example file][example] that shows how to do two things: add a project from GitHub and call cabal2nix on your file automatically (so that you don't have to do it each time you add a dependency). [example]: https://gist.github.com/TikhonJelvis/be42400fc31bac0cd1736740fe5eb83b
Nah, unexpected but documented behavior is still something worth bringing up :) 
No, but I really should. It's definitely on my list of things to write about!
"Note: This blog does not get updated very often." Now, watch me update my blog, often, to continue my one-sided screed against volunteers in an open-source community.
The same thing apply to Leiningen in any industrial clojure applications, but why the builder of Leiningen doesn't have any problem with the fact that clojure official site's download link simply provide a `clojure.jar`? No matter how hard problem solved by stack, we should not forget it's build on top of something much more fundamental, and on a official site of such piece of fundamental tech, we should not just simply put a build tool, no matter how excellent it is.
I didn't care for the Clojure core team's mismanagement either. That was, at the time I was in the community, fairly well known and I knew plenty of others that felt similarly.
My recollection is that the Platform wanted to ship with the GHC 8 and aims for releases every 6 months, but Mark quit, the old minimal installer had some issue where it wasn't optimal on all platforms, and GHC 8 took a few months longer to release than folks had planned. It shipped the moment 8 was stable despite those factors.
We clearly don't see eye-to-eye on what the community is and what it's values are. Snoyman is willing to split the community completely in order to force his solution on everyone else. Even after it was included in the Haskell Platform. Just because stack is a good tool doesn't mean Snoyman can force everyone else to adopt things *his* way. Again, again, again stack is part of the Haskell Platform. That's not enough for him even though he agreed to that arrangement as adequate. He is the one constantly accusing others of treating him maliciously. When people treat you charitably, take your grievances in good faith and try to reach a compromise that meets everyone's needs and then you turn around and accuse them of being evil, nepotistic, and oligarchic, then *you are being a shit person*. This has never been a technical dispute.
Clearly we need to build an abstraction over the various communication mediums we are using.
The Haskell Platform. That's it full stop. The other choices are there because they are *legitimate choices*. Not everyone who visits a downloads page is a brand new user who needs to be guided on the rails, good grief. The whole conflict Snoyman has with the committee is that there are any download links on that page besides stack. Look at this page and tell me what the issue is that is so terribly awful that it warrants forking the community with haskell-lang.org: https://www.haskell.org/downloads
I understand what you wrote, and I agree[1]. FTP was mostly about saving keystrokes to import everything by hands, but sometimes keystrokes count. But do you remember waves of "resignations" after FTP and MFP? Don't you see the new wave started already? [2] I'd personally prefer to type `import Data.Traversable` 20 time per day. [1] Except that I try to avoid polymorphic functions in monomorphic context because it often breaks the "if it compiles then it works rule". So I have everything imported qualified anyway, and use `Vector.forM_`, `List.forM_`, `Foldable.forM_`, etc. [2] Note that the same person belongs to "winners" in one fight and to "losers" in other one. So with enough number of cracked eggs everyone will be a "loser" at least once. It will radicalize and eventually kill the community. That's what I said in the FTP debate.
People make value judgements, when a tool "makes a value judgement" it's just the tool author. Chris is not my coworker, and frankly I don't care what his preferred style is. I don't like that auto-formatting is now being conflated with people's opinions about which format is "better" when the two are entirely orthogonal.
Some functions are intuitive, others not, but I think what the community needs is someone to admit that bad inconsistent naming that can mislead is a bug in cases like this. The misleading behavior cannot be swept under the rug by being just documented in my opinion. In other words: you wouldn't for example have a bug that crashes your app every Wednesday, then say you've now fixed the bug by simply documenting this behavior.
`cabal new-build` isn't here, the Cabal team hasn't done a great job making forward progress on other fronts, and there's no guarantee it'll actually work well. I've tried getting things fixed in `cabal-install` before, it's like pulling teeth for the _simplest_ things. With Stack, all I have to do is report the issue and much of the time it'll get fixed *quickly* without my having to lift a finger. The difference in community attitude, norms, and productivity is stark. Further, `cabal new-build` solves one of the many problems with `cabal-install`, Stack has fixed nearly all of them. `cabal-install` had years to gets it act together. So to summarize, &gt;will be on par with Stack once it gets out of beta, no? No. That is not the case. I wish it was.
*tooling state was really pathetic before those projects* Looks like an extreme exaggeration — I guess (I'm guessing because I've never ever used stack/stackage in my 12 years with Haskell) all stack/stackage thingy is mostly important for absolute beginners.
I can see what you mean. However, that would also mean that we lose the ability to test the membership of a label since `R ( #a := () )` will be equivalent to `R ()`, while in Haskell `data A = A { a :: () }` is definitely different from `data B = B` even though both only have exactly one habitant. I don't think there are anything fundamentally wrong with either approach, though the former should be more elegant in theory.
Because once a beginner graduates to experienced user, they obviously want em to keep using what is currently being sold as beginner-friendly tooling. And as a professional Haskell coder, `haskell-beginners.org` is not the domain name you'd want your boss or customer to notice while he's looking over your shoulder...
Thanks Ed for all the work you've put in on the committee.
I replied to you originally because you were using my work to argue for things I don't agree with, I'm not here to have a referendum on a language community whose language I don't use any more.
So use a diff that ignores whitspace? I know whitespace has semantic content in Haskell, but that answer gets you 95% of the way to what you want.
I favor prominently featuring stack on haskell.org for its merits, but I'm afraid that now it is going to be more difficult to disentangle and endorsement for stack from and endorsement for the things Snoyman has said. I think these blog posts are more likely to sway the overall sentiment away from the outcome it was written for than toward it.
[removed]
Can you do that on GitHub? i.e. where 99% of people will view diffs?
You can't for version control. The patch stored has to contain the change in indentation, and now the line is marked as changed. Commands like `annotate` or `blame` will show the line changed by you even though all you did was reformat. Sometimes it's unavoidable, but you want to minimise how often you need to reformat code. 
With Git, you can use `--word-diff` to show diffs on a word-by-word basis instead of marking entire lines as changed. It will mark the whitespace as changed and the actual content as untouched. Many diff viewers (including those on GitHub and GitLab) now show an overlay of the word diff, with the line diff faded in the background. This also makes things like trailing commas less of an issue. There is also the `--ignore-all-space` flag to ignore whitespace when computing the diff.
The area I struggle with is formatting lists without aligning in Haskell. Comma first layout seems prevalent, but this only works when the first item is on the same line as the bracket. That normally puts the first item at the end of the line opening the list, which then puts all items at some code dependent indentation. 
&gt; It is true that text uses a lot of 4 spacing, but it also uses a lot of 2 spacing. Remember thought that text was first written by Tom Harper; other O'Sullivan packages, like criterion, statistics &amp; wreq, seem to use 2 spaces. [criterion is 4 spaces](http://hackage.haskell.org/package/criterion-1.1.1.0/docs/src/Criterion-Types.html#Config) and so does [wreq](http://hackage.haskell.org/package/wreq-0.4.1.0/docs/src/Network-Wreq-Internal-Types.html#Options). Always go for the types module because that's the one that's least-changed by contributors. &gt; Also, I wonder about the measurements: you count the streaming library as 4 spaced, but it's unrelentingly 2 spaced. That's correct, my script was bias to 4 spaces in the event of a draw. I updated my script to return `?` for each and it's a 50-50 split: https://gist.github.com/chrisdone/e3d1796d8f5df717b91db54aae36c440 So thus far the only data I have says if I pick one number I'll annoy half of the community. For now I'll pass responsibility to Johan Tibell. Perhaps we can poll the community? http://doodle.com/poll/82xf854t9mmuv22h#table
I only have one suggestion for multi-constructor data types to be formatted like so: data MyType = MyTypeCons1 { field1 :: T1 , .... } | MyTypeCons2 { field2 :: T2 , .... } deriving (....) instead of data Person = Person { firstName :: !String -- ^ First name , lastName :: !String -- ^ Last name , age :: !Int -- ^ Age } deriving (Eq, Show) 
So that they have all the tools necessary to follow any tutorial out there rather than just ones oriented toward stack and so that they can learn the tools that stack relies on (cabal is used under the hood) if they so wish. I am always skeptical of the claim that haskell's package management is horrible. It used to be really bad, but even then it was far better than most language's dependency management. I don't know how much experience the average new user has but serious dependency management in most other languages makes cabal hell look like a stroll on the beach. There are good reasons why a more experienced developer would want to forego stack. The conversation is very centered around absolute beginners but the downloads page is for everyone. Snoyman's demands and the escalating tactics he's used are unreasonable.
&gt; Look at this page and tell me what the issue is that is so terribly awful that it warrants forking the community with haskell-lang.org I don't think it's fair to say the download page is the only issue; [this page](http://chrisdone.com/posts/haskell-lang) that Google dates to 2014 may be the first mention of haskell-lang.org and it says nothing about the download page. That said, I do think the download page is that bad. It presents three choices to new users--the exact people who are not equipped to make a choice. It says &gt; To avoid these conflicts, each option has a lightweight sandboxing feature that creates largely self-contained, per-project environments. With Minimal you can optionally sandbox the libraries, avoiding most conflicts. Stack sandboxes the compiler, tools and libraries, so avoids nearly all kinds of conflicts between projects. With Platform you can also optionally sandbox libraries, but not the globally installed platform libraries. Huh? Why should a new user have to pick between these? This download page was obviously written to make a bunch of warring factions happy.
&gt; The classic example is "yesod can't install without errors" which was true for me when I tried it. Funny, I share that experience. The packages typically breaking Cabal are authored by... wait for it... Michael Snoyman! For me, Cabal works fine. It broke a few times in the past, and I did have to work around a few badly specified dependencies. All of that was possible once I could reproduce the problem. But the moment I needed anything related to conduit, there was no solution. (There was also a conflict between newer 'containers' and 'template-haskell', but that's GHC's fault, not Cabal's.) Regarding the HP, my major grief with it is that it requires OpenGL, so usually wouldn't install easily on machines where I'm not root. Therefore, my recommendation to newcomers is: use the minimal install (GHC+Cabal), DO NOT USE yesod, but if you must, install it in a Cabal sandbox. 
True, but one should fix the tools.
Mailing lists are not controlled by a commercial third-party which could disappear or change terms of service without warning.
 myFun x y | test x y = foo | otherTest x y = bar
You want an IDE, and neither Stack nor HP is that. The only mature option (I hear) is http://haskellformac.com/, which isn't free.
I think you might indirectly be asking: who came from "C, C++, Java" (4) and who came from "Python, Ruby, JS" (2). 
Yeah, that would be fine, because you're aligning based on the nesting structure, not based on the length of variable names.
I don't see as there's anything to fix. The tool is telling you the truth. It can't know that this whitespace change is insignificant, especially in Haskell where some whitespace changes are. 
You could ask what type a label has, where the default answer is ().
I, of course, have a hard time believing that anyone would find the second version more readable, but I guess that's simply inherent to subjective matters like this.
The minimal HP gives you ghc, cabal, and stack. So, they're done with one installer and can follow whichever workflow they need.
And that's also probably why "one style to rule them all" is never really going to be a thing.
&gt; The packages typically breaking Cabal are authored by... wait for it... Michael Snoyman! It didn't work for Accelerate either. &gt;I did have to work around a few badly specified dependencies. All of that was possible once I could reproduce the problem. I was able to fix issues too, it was just a massive pain and it required going on stack exchange to find out how to remove a version of ghc. If a package needs a different version of base, then cabal doesn't work. As for the issue of "embarrassment" a lot of newcomers ask legitimate questions but veterans deflect to "you should've used sandboxes" (to excuse the fact that cabal can't uninstall) or "it's a build tool not a package manager" (when the wiki even says cabal is the easiest way to install packages). Cabal makes it easy to make mistakes when you expect it to work like tools for other languages (or when you use your distro's cabal). 
[Python is 4](https://www.python.org/dev/peps/pep-0008/#indentation)
There should be equivalents taking `base` eg. `isDigitBase` should take base as its 1st argument, as should `digitToIntBase` or even List of valid symbols...
That looks like an invitation to ask you about your opinion on the paper, which I will gladly do! Could you elaborate? (IMHO, the introductory/motivational section seemed relatively thin and theoretic for such a proposal, but I may be spoiled by SPJ's style)
To me 4 spaces are much more readable and as such I won't be using 2 spaces for my own projects regardless of what style guides recommend. Ideally we'd all be using tabs and then everyone could set his own preferred width but that's just not how things are in Haskell.
&gt; For these reasons I feel like the committee should commit to a "one true way" for beginners, Wouldn't that be the role of a tutorial writer? I don't see why the committee should make opinionated decisions imposing a point of view over an other. One could argue that it is, ironically, the best way to get people opposing that point of view riled up. Real World OCaml for instance dedicates [a small subsection](https://realworldocaml.org/v1/en/html/prologue.html#installation-instructions) to installation instructions and [redirects to an online, detailed, wiki page](http://realworldocaml.org/install) explaining in details what to do to get started. They don't tell INRIA that opam should be front and center on the download page and no other alternative should be listed for fear of confusing beginners.
Michael, please stop this. I love Stack and I like the work you've done with Conduit, but I have to be honest: if it really came down to it, and the community must lose either you or Edward, I'd rather see you go. I feel like your strength is that you attack problems and come up with a solution. But there are many people who could do that, realistically. I don't think there are nearly as many people who could fill Edward's shoes if we lost him. So don't make it a choice. Get back to what you do best and quit with this unnecessary hostility, please.
Look, if you take 10 haskell pros and put them in a room and tell them to come up with ways that a beginner should learn Haskell, they'll come back out with 11 proposals. Haskell has seen amazing growth over the years and yet if you read many sentiments in these discussions you'd get the idea that it was literally impossible before stack became a thing. I think stack is a good tool. I don't think it should monopolize the downloads page. I think the committee has been diligent in communicating and compromising with Snoyman. I think using beginners' experiences as a rhetorical device is unproductive. I think Snoyman has attacked the people who should be his colleagues and accused them of acting in bad faith over a relatively trivial issue. I think the people behind haskell-lang.org are trying to fork the community infrastructure over a minor issue. Maybe this issue really *is* so important to Snoyman that he's willing to burn all these bridges and polarize the community to the point of bitterness. I think the cost he's imposing on the rest of us is too high. stack is conspicuously provided on haskell.org. This isn't enough for Snoyman. Everyone should take pause and wonder why he refuses to play nice and what the cost of that is.
I think 'newcomer' is a sufficiently vague idea that you could impose any sort of behavior on the 'newcomer' to suit your views. Newcomers are also going to be confused by the first GHC error they encounter. Newcomers are going to be confused. Being confused is part of learning. the existence of 3 command line tools, each of which is clearly documented is *too much for beginners*? Again, one can impose arbitrarily high levels of cluelessness on the 'newcomer' to suit one's rhetoric. It's a purely hypothetical device that is ultimately unproductive. I think newcomers are competent enough to spend 5 minutes reading about their new tools. Otherwise they'll probably give up on the first """indentation""" error ghc spits out. They are not helpless puppies.
Why are there no comments on so many bugs filed against 8.0.1 yet? e.g.: https://ghc.haskell.org/trac/ghc/ticket/12490 Two weeks and no response from anyone is not a good sign. I am loathe to say it, but this simply adds credence to the controversy currently going on in the Haskell community. 
One great thing about go is gofmt erasing any discussions about formatting and goimports erasing almost all thinking about imports.
[removed]
I'm sorry but, WHAT? Can't this idea that stack is just automatically better for a new user just die? I mean, if I'm a new user and I want to write my 3 line fibbonachi program for my university class, am I really meant to start up a new project to get "the correct ghc version"?! I mean seriously, the most intuitive thing for a new user is surely to just run ghci from anywhere on their machineand get going?! This is getting stupid.
I do agree that there is a profound difference between the two but at the same time wonder whether having any other page than the "download" one makes sense: "get started"... with what? Is it not the job of the tutorial writer to direct the user to the tools they are going to use in their tutorial? Or if a colleague or a friend is offering support then surely they can suggest which method to use (the one they will feel most comfortable helping with for instance)? Oh, or I guess some newcomers arrive via stackoverflow for instance and just want to copy / paste some code and play with it? Okay, maybe that'd be a use case for a getting started page.
Actually, I think the main reazon is that I looked at at the code on a mobile phone. When there are not enough columns, the extra line-wrapping makes version 1 look much worse. With a wide enough screen, it's fine. Not sure how important readability on narrow screens is.
I'm saying the tooling is language agnostic, and making it language aware is impractical, possibly even undesirable. Your tooling shouldn't dictate how you write your code, and it doesn't (no vital aspect breaks), but coding styles can include allowances which makes the tools more useful. 
Could you please elaborate why this is a bad idea?
It's a ApplicativeDo bug, so it's squarely in Simon Marlow's ballpark. Him being on vacation seems like a very reasonable reason for there having been no response yet.
While I prefer 2 spaces in general (not just Haskell), I have a question about hindent. What happens to this example under a 2 space scheme? sayHello = do name &lt;- getLine putStrLn $ greeting name where greeting name = "Hello, " ++ name ++ "!" The where block belongs to sayHello and not any of the expressions inside the do block, so it should be indented less than the do block (in this case, 2 for where vs 4 for do). Under the 2 space scheme, would you indent where by 1 space instead? Is there a formatting style in which where can be indented the same amount as every other layout keyword while everything still works as it should?
I like half-indenting `where` to 1-space. I think I'm a minority in that regard.
&gt; I would still use haskell were it not for stack As a toy language? Yes. As a *work* language? *Heeeeelllll* no. Even simple university assignments fell into cabal hell frequently. 
[removed]
I care a lot about developer UX, and that's why this issue matters to me. As an example, I really like how Elixir is presented: http://elixir-lang.org/ Its high-quality build tool (mix) is presented as a selling point of the language right on the home page. There's no compromise here. mix is the best way to use Elixir, and it's the only way that's even presented. The official Getting Started tutorials prominently advertise, explain, and use mix: http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html It's used all throughout the remaining 8 sections of the tutorial focusing on building a simple distributed key-value store. To me, this is the standard for modern programming languages. We've reached a point where it's expected that languages have great developer UX, and when they do that's a major selling point. In my opinion, stack is a pretty good developer experience, far better than any other option for Haskell, and it's a mistake not to embrace it to a similar degree. As such, Haskell *could* now be presented as a language that has good developer UX. That's just my opinion, and I won't defend it to the death as I've personally got no stake in this. But I don't really see the sense in presenting users with three options, when in the majority of cases two of those options are more or less just the wrong choice. As for Snoyman's alleged penchant for drama, I lack the context to really comment on any of this. But you very well may be right on that, and I don't approve of that sort of toxic, controlling personality. I don't want my support for stack to be misconstrued as support for this sort of drama.
Of course! I didn't mean to imply any negligence.
i do that as well sometimes. i also write 4 2 4 at other times. i haven't decided yet.
What a remarkably non-constructive comment :)
https://www.youtube.com/watch?v=hIZxTQP1ifo Reddit Discussion: https://www.reddit.com/r/haskell/comments/2w4ctt/boston_haskell_edward_kmett_type_classes_vs_the/ There are a few dozen other reddit threads I've been dragged into on precisely this topic. Wadler &amp; Blott's original paper talks about why local instances lose you principal types, now 'when' you typecheck a thing changes where the instances come from. This does nothing to address their concern.
&gt;[**Edward Kmett - Type Classes vs. the World [102:53]**](http://youtu.be/hIZxTQP1ifo) &gt;&gt;Boston Haskell Meetup - January 21, 2015 &gt; [*^Boston ^Haskell*](https://www.youtube.com/channel/UCUCpgCWjaniUkX88wZrK_Ig) ^in ^Science ^&amp; ^Technology &gt;*^12,210 ^views ^since ^Feb ^2015* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
See the video I linked above.
I've [spoken](https://www.reddit.com/r/haskell/comments/2w4ctt/boston_haskell_edward_kmett_type_classes_vs_the/) at length on the topic of why just "upgrading" type classes to the power of Scala implicits is a bad idea in terms of actually being able to reason about, refactor and reuse code. I maintain the `reflection` library to derive the pragmatic benefits of such without having to deal with incoherent instances. The comment was a short hand reference from someone very tired, and not particularly keen to dive into yet another argument just because someone else is wrong on the internet. Take that as non-constructive if you will.
Hmm. I've literally never needed or wanted more than 1 where block per function case, but I guess that makes sense if you do.
We're doing a poll now.
[removed]
That's a problem with your diff tool, not your code style. I personally find aligned code *much* easier to read and do not think we should compromise on readability just to make (bad) diff tools behave better.
[removed]
I occasionally joke about using a negative tab width. Doesn't work in indentation sensitive languages like Haskell, but...
I indent each line such that taken all together, the file's indentation levels form a hailstone sequence.
Or ... foo a b = bar c where c = d d = a + b
The function is more defined than you expect, but this doesn't actually cause any pain for the digit based workflow. if isDigit x then Just (digitToInt x) else Nothing and if isHexDigit x then Just (digitToInt x) else Nothing both operate and get to share a combinator under the current scheme. If anything it is surprising that the folks who wrote that combinator in the first place didn't extend it to the full base-36 range. =) A whole lot of code has been written out there over the last umpteen years since that combinator was added, having it be "too defined" is by far the lesser of evils compared to breaking code that relies on documented behavior, just to take a new combinator name with the current behavior, particularly when nobody gains any utility from the less defined function.
It's amusing to note that the article's argument for using one style is *also* just as a good an argument that it doesn't matter if different projects use different styles.
I understand why WriterT with [Word8] here is bad because List mappend is atrocious. But if the Monoid instance for the Writer is okay, is WriterT then okay? Trying to understand what exactly is bad about it.
That is what I use for short bodies `bar c`. Otherwise foo a b = let c = d d = a + b in bar c or foo a b = do let c = d d = a + b bar c (this works fine for non-monadic values)
Oh cool! This might make me reconsider cabal. 
Sorry for missing this and the late reply. TIL about `objcopy --prefix-symbols`! However, my main concern is it seems slightly magical and this isn't really going to work with any kind of dynamic resolution, right? So C code that works with/without `--prefix-symbols` would break if you turned it on/off. But in some cases, yeah, something like that could work. But it feels like something you'd have to enforce very specifically, vs making every piece of code in the wild understand this exception.
For what it's worth, mgsloan and snoyberg have commit bits on Cabal/cabal-install.
Not that differently. To actually build packages, Stack still calls the Setup interface exposed by Cabal. It only uses Cabal as a library to parse package descriptions, but it certainly relies on the command line interface to a heavy degree.
I can imagine! I really, really hope they update the documentation to make this the default choice from now on. 
&gt; I've been successfully using sandboxes and new-build for complicated cases Tbh this thread has been opening my eyes to the new-build functionality. If [cabal's documentation](https://www.haskell.org/cabal/users-guide/installing-packages.html#installing-packages-from-hackage) were more consistent and clear, and championed new-build as *the* way to build packages, I will absolutely consider it as a build tool. &gt;I mean, it's totally fine to list the options and let the user select. Believing users cannot make that decision makes too many assumptions and may even be disrespectful to some. I don't think being opinionated with new users is a problem. In [my case](https://www.reddit.com/r/haskell/comments/504de5/follow_up_haskellorg_and_the_evil_cabal/d71e6yu), it would have saved me many hours of frustration. I definitely believe you when you say you had problems with BSD, but it is going to be less common. &gt;So, as a general Haskell users, this whole debate doesn't make sense at all. All it does is scare away new users who see the debates and are confused. Well, the animosity certainly may, but the "downloads" page is already confusing. As is the cabal documentation which basically lets you get into cabal hell. 
More infos: https://github.com/sjsyrek/study-haskell-nyc
Like you, I don't have a dog in this fight. And like you, I have a similar background. A couple years back, I stumbled upon Haskell while learning F#. I really liked what i saw in Yesod, etc. Like you, I couldn't get a working Haskell Platform and dependency management with cabal was a nightmare. I gave up for a while, came back to find Stack, and now I am working to become proficient in Haskell. As others have noted, the barrier to entry to even get a development environment setup is too much. With Docker and Stack, this has changed quite a bit.
*TRIGGER WARNING* ^(Why not use tabs to indent so that everyone can configure their editor to display them as wide as they please) *END OF TRIGGER WARNING* :)
&gt;Cabal is different in that the project doesn't get rushed and prefers to collaborate with GHC to implement long-term solutions that are here to stay. I think that skirts most of the criticisms of cabal, though. People have a lot of strong feelings about cabal, and a lot of bad experiences (I've spent &gt;7 hours trying to install accelerate-cuda). It was simply unworkable (to me) before the new-build functionality. People have *given up on haskell* because of cabal!
Looks good. I have a doubt about "cabal new-freeze". Will it work more or less like the current "cabal freeze", fixing the dependencies for a particular project, only now using the global package database instead of a sandbox? Another doubt: I sometimes create a sandbox and install some set of packages without bothering to create a .cabal file. Even without the cabal file, I can run cabal exec and have access to the installed packages. Will the new version of Cabal support a similar workflow?
Without question. Remember that time we crashed on Ed's couch for ICFP 2013, and coded late into the night? Those were some good times. Note: I do not recommend letting Ed keep you up late programming because you'll never really end up stopping, I've found.
&gt; Wouldn't that be the role of a tutorial writer? I don't see why the committee should make opinionated decisions imposing a point of view over an other. I've become more sympathetic to the cabal case after hearing about new-build, but from my vantage point, cabal was simply unusable as software. I wasted many, many hours installing accelerate-cuda. And I followed a book. Cabal documentation also needs to make it *totally clear* how to avoid cabal hell, and in particular it should tell you NOT to run cabal install.
[removed]
A comment like this would be extremely helpful in response to the bug report! I have no idea how to contribute a patch, and I don't know how I was supposed to know any of these things. I saw that it was assigned to someone, but how am I supposed to know any of this?
Looks great! I use Nix + cabal-install, and this looks like it will make a good thing even better.
&gt; "are we the baddies?" https://www.youtube.com/watch?v=hn1VxaMEjRU for the uninitiated.
You might be interested in this ticket! https://github.com/haskell/cabal/issues/3651
[removed]
&gt; Agreed. The fact that there is no "cabal uninstall" command says volumes about how much they care about user input. What volumes does it speak about the Stack team that there is no proper `stack uninstall` command? &gt; Pretty much! Now they're introducing all the features they should have eons ago because of pressure from stack. And people somehow are still getting mad at stack. Maybe they shouldn't get mad at inanimate tools though
Honestly, do you even know who's on the committee's side? Who's on the other side?
GHC mandates 8-character tabs and Haskell cares about column alignment. If people use different editors with different tab stops, actual tab characters can wind up breaking said alignment, especially if there are any spaces invisibly mixed in. I believe having any tabs in a file actually generates a warning, these days.
Single biggest gripe: where foo = bar -- legal baz = quux where -- legal foo = bar baz = quux where foo = bar -- illegal baz = quux (Likewise for `let` in `do` blocks.)
Thanks for doing this! This is much needed. Does it work with curly brace, semi-colon syntax or a mix of the two?
It's already happening to c++ with the clang formatter as well.
&gt; Is it not the job of the tutorial writer to direct the user to the tools they are going to use in their tutorial? Haskell moves very quickly and I'm not sure this is 100% feasible. I started learning with LYAH, and then read Simon Marlow's *Parallel and Concurrent Programming in Haskell*, which directed me to use cabal to install packages and ghc to compile code. 
Talk about code smell...
&gt; Another pain point is that there are lots of places where bad information exists and it's tough to know who to talk to get it fixed Definitely. Do you know who runs the cabal user guide on haskell.org? I had used documentation [here](https://www.haskell.org/cabal/users-guide/installing-packages.html#installing-packages-from-hackage) and I think it could be clearer about how to avoid cabal hell (e.g. via sandboxes). &gt;Yes, would you like to help review the full docs for nix-local-build we're working on? https://github.com/haskell/cabal/pull/3727 I'll have a look now!
It's part of the release process, which I don't participate in. I opened a ticket about it here https://github.com/haskell/cabal/issues/3733 . See also https://github.com/haskell/cabal/issues/3605 The illustrious Mikhail did set up a continuous deploy of our Haddock documentation at http://haskell.github.io/cabal-website/doc/html/Cabal/ and it would be pretty cool if we also had the manual on CI as well. Should just be some messing about Travis scripts...
[removed]
I read your experiences. I think your experiences are legitimate, I also vividly remember my times as a beginner. stack is a good tool. The issue isn't whether or not stack should be provided to beginners or that it's good for beginners. The world is already in a state where a beginner can use stack from the get-go. What do you think the nature of this conflict is?
I've been using Haskell for over 5 year (not 12, mind you, but I'm not an "absolute beginner"). I remember the time before `cabal-dev` let alone `cabal-sandbox` A project I spent most of that time working on abandoned Haskell, in significant part due to difficulties getting consistent builds across time and operating systems. I use `stack` for all my current little projects. I am excited for new `cabal` features, but for now, I think `stack` is the better choice for most projects and developers.
&gt; converted me I think you mean 'coerced' you :p. Comma-first is an abomination that we do because we have to.
[removed]
Since my name is being thrown around so much, I'd rather be explicit than have my intention reverse-engineered from reading code :-) I generally like to use 4 spaces for functional code and 2 for monadic code, but I don't apply this consistently, because I honestly don't care too much. If I'm writing a patch against someone else's code, it's way more important to me to figure out and match their style than to impose my own opinion. In years of reading GitHub pull requests, I'm in a dramatic minority here, which I find kind of amazing. Most people will just chuck whatever they thought of at you instead of making it fit in, which they somehow don't recognise is the open source equivalent of coming into someone else's living room wearing muddy boots and lighting a cigarette :-)
&gt; Not sure how important readability on narrow screens is. All the joys of responsive web design, in your source code!
What I'm saying is it doesn't matter because the users of software aren't going to listen to anybody, they're just going to choose the software.
That's cool, this conflict has never been about whether or not stack is meritorious software. In fact, you can download stack *right now* as part of the Haskell Platform or on its own right off the haskell.org downloads page. What do you think is the nature of this conflict?
I call this 2-space style, but with judicious use of nested blocks. `c = a + b` is nested inside the `where` block, which is indented inside the definition of `foo`. I've started to use this style personally, as it keeps everything very predictable.
What's wrong with sayHello = do name &lt;- getLine putStrLn $ greeting name where greeting name = "Hello, " ++ name ++ "!" 
&gt; I sometimes create a sandbox and install some set of packages without bothering to create a .cabal file. Even without the cabal file, I can run cabal exec and have access to the installed packages. Will the new version of Cabal support a similar workflow? This is something I do all the time with nix, so much so that I wrote a [silly little wrapper](https://github.com/rowanblush/ghcsh) for it.
&gt; There is not presently a mechanism for removing packages besides deleting your store (.cabal/store), but it is worth noting that deleting your store is a completely safe operation: How do you add packages to the store? I had to make a change to executable-path for it to run on PC-BSD 10 with ghc-8.0.1 for a leksah build but I can't figure out how to install the new package into the store/make it available to the leksah build. Using *--package-db* didn't seem to work either - the build failed as executable-path could not be resolved. 
My understanding of the conflict is that Snoyman wants every download option removed except for `stack` on the Haskell.org downloads page and has escalated this conflict at every turn while accusing the committee members of acting in bad faith. It is important to keep in mind that removing all the options but stack was his first proposal and he has rejected every compromise since that was rejected, even the one involving the Haskell Platform which he agreed to when it was proposed.
[removed]
Many years ago the Burroughs operating system release notes reviewed all the trouble tickets and closed one with the statement "works as implemented."
As an aside for tab-lovers, I messed around with elastic tabstops in Atom using this plugin: https://atom.io/packages/elastic-tabstops. I loved it for Haskell! alas - no one else does =(
Sorry, I should have said "you talk about users that want an IDE". No offense intended. Other points stand.
I was just responding to the idea that "newcomers" are a vague idea. I think that in this case, there is a concrete, easy answer: cabal took a lot of my time and stack worked brilliantly the first time! I am really hopeful that new-build will make cabal into a competitor for stack, but I also think it's pretty clear what is good for newcomers in the meantime. 
Haskell isn't Go. A lot.
Yes. With a fallback string mode that, ideally, shouldn't come up often. It's no more unreasonable than expecting my editor to highlight code in every computer language—especially since a parser for diffing can be closer in fidelity to one for syntax highlighting than one for compiling.
I would normally put banana on the same line, but I've changed my mind. I think it's easier to read on its own line, you can read the code by going diagonally, less jumping back and forth. 
Wasn't it the other way around? :-) Values are functions as well!
https://github.com/junegunn/vim-emoji and https://github.com/mrowa44/emojify look promising :-)
True, but you are welcome any time.
I got to Georgia Tech and am an amateur Haskeller
This is actually not true in Haskell. Many values in Haskell are not functions. Examples are values of type `()`, `Int`, and `Bool`. See: ["Everything is a function" in Haskell?](http://conal.net/blog/posts/everything-is-a-function-in-haskell)
Is `new-install` going to be a command in the next version? Thanks for the great work on cabal-install.
&gt; My understanding of the conflict is that Snoyman wants every download option removed except for stack on the Haskell.org downloads page.... I believe that is a misunderstanding. From his original [PR](https://github.com/haskell-infra/hl/pull/130) that started all this, he simply wanted to make stack the _primary_ option out of all of them.
Four, as spaces, not hard tabs. I (possibly uniquely) also prefer braces &amp; semicolons, since that means never being surprised by the layout rules.
Aw, man... no Control.Arrow for that sweet `(&amp;&amp;&amp;)` goodness? Well, I guess there's always `((&lt;*&gt;).((,).))`...
That's a nice way to _reduce_ imports to the minimal set, but it's not the same magic as, say, IntelliJ automatically _adding_ an import line when you type some class name. I think this is pretty achievable in `vim-ghcmod`, some command `:GhcAutoImport` to look up the symbol under the cursor with `ghc find`, and to add the first module to the import list; polish it by recognising `T.foo` as a request to import qualified. edit: [proof of concept](https://gist.github.com/codebje/5b66b318a65797196b4a4beabbf86d02) with a few glaring flaws, but nevertheless functional at a basic level.
Thanks for all your efforts over the years :)
Spread the good news!
Grammatically, nothing. Aesthetically, I temporarily get confused by the where lining up with the rest of the do block's lines, but that's the fault of my simplified mental model of how layout ought to work (indent less/equal to end/continue) not aligning exactly with how it actually works (there's also a rule about inserting a closing brace if it otherwise wouldn't parse).
This is great! One of the things I like of Scala is Scalariform. 
Short answer? We can get SPJ to use them.
It accepts any mixture but only outputs without curly/semi. If needed we might be able to implement "explicit mode" for a use-case that I think you're working on.
Wow. Removing WriterT is night and day. What a piece of garbage. 
[removed]
Believe me, I'm not happy the ecosystem is littered with beartraps that should essentially never get used and only get used by people not forewarned.
I am--I can't write much Haskell, but I'm interested in functional programming (and programming languages in general).
Definitely an exaggeration. Sure, the tools used to be worse than they are now. And the way they are now is worse than where they will be soon. Most of these improvements have been planned long before stack or stackage came about, and cabal new-build now solves problems that stack doesn't even attempt. And it's been a bit frustrating to see good people's real work on solving problems in the core tools consistently ignored in a marketing campaign for a wholesale replacement. We used to talk about specific tangible problems with Haskell's build tools. We talked about the need for multiple versions of indirect dependencies. We talked about needing to freeze dependencies. We talked about needing completely reproducible builds based on hashes of the whole dependency tree ("nix-like", back before anyone had heard of nix). And people worked on those problems, and have been steadily solving them. The other side of the discussion has been a lot less productive. It is frustrating to work in an environment where the rhetoric is actually aimed at confusing issues. Where "cabal hell", which used to mean a specific problem with conflicting indirect dependencies, has long since lost any real meaning in a lot of current rhetoric, and feels like it is intentionally kept ill-defined so as to collect everyone's difficulties into one umbrella term. Useful for spreading doubt about tools; not so useful for actually breaking down the problems and fixing them. There's nothing anyone can do at this point to address the perception of "cabal hell", because it doesn't even *mean* anything any longer, and every new Haskell programmer who makes any kind of mistake installing a package now thinks they've run into a fundamental pain point of Haskell, and there's a movement waiting to use that as a wedge to promote their alternative tools, whether they solve that problem or not. Okay, a little less diplomatic than I should be... consider this blowing off steam, and I'll get back to trying to build things.
[removed]
It works great when the One True Format has been enforced since the inception of the language. I don't think it's gonna happen anytime soon in a &gt;20 years old language.
Can I ask a different question? What role do Haskell Platform maintainers see for the the "Full" variant, going forward? Is it just there as a shim until everyone has transitioned to a different workflow, or is there a continuing use for it? It seems increasingly obvious to me that the *old* Haskell platform (i.e., Full) is solving a problem that just no longer exists, as both stack and cabal-install, as well as the various core libraries themselves, have progressed beyond the need to lock anyone into fixed blessed versions to resolve most configuration and installation issues. (OpenGL excluded... but honestly, isn't OpenGL only part of the platform because it was grandfathered in by historical accident, anyway?) Not trying to be *too* provocative. I just wonder what the reasoning is there.
Oh hmm. Interesting points. I'll leave myself a note there to investigate this. Thanks!
This part of `where` annoys me so much that I have stopped using it. I indent Haskell like I do Python. foo a b = let c = a + b in bar c Lots of air!
What about. this? foo a b = bar c where c = a + b Would you still claim it's two?
[removed]
It isn't, I agree (though the tone of the comment is unbecoming). However not having to worry about formatting is a universal "weight off your shoulders, focus on the problem at hand" improvement.
See this [comment](https://www.reddit.com/r/haskell/comments/5059gm/hindent_5_one_style_to_rule_them_all/d71vht5) which talks about the clang formatter becoming popular with C++ despite it also being an old language. C++ is also much more widely used. If C++ can do it, so can Haskell.
Just want to thank /u/ezyang for the tireless brilliant work on Cabal *et al.* Greatly appreciated. 
I can't vote: I use 3.
That's what I use for the same reason.
Thanks for the response, the only thing I can find in the [stack docs](https://docs.haskellstack.org/en/stable/yaml_configuration/) is &gt; Note: When stack is invoked outside a stack project it will source project specific options from ~/.stack/global/stack.yaml. Options in this file will be ignored for a project with its own &lt;project dir&gt;/stack.yaml. But I think that’s basically all there is to say. The configuration format is exactly the same. Note that stack allows you to run `stack build packagename` to build a package and make it available in your project which is how I install packages in the global project (I don’t think I’ve ever used that command somewhere else).
&gt; The same thing apply to Leiningen in any industrial clojure applications, but why the builder of Leiningen doesn't have any problem with the fact that clojure official site's download link simply provide a clojure.jar? Just my 2c, but when I tried Clojure I didn't think it had a good onboarding story. A language that has great onboarding (from my POV) is Elm, and it ships with its own package management facilities. 
While I find the effort very important, I think there'll be problems with one style ruling. For instance, I disagree with something like 90% of Johan's style. It doesn't necessarily mean that any of us is wrong (although I do have plenty of arguments for why I disagree), but it means that I won't be using a tool pushing it for that reason. There's too many ambiguous points in Haskell style for a specific one to be pushed on all people. That is why I believe it would be much more viable to have a highly tuneable formatter, which could support all kinds of variations of styles. Would be really nice if your development turned out to be a major step in that direction. Thanks for it, of course, either way!
Nullary function symbols.
Honestly that's a big understatement to how that was not working for me. Agreed it was when I staterted Haskell. But it was questionnning what on earth Haskell dev were thinking. A mutable global store ? how many hours on 'it works here not there..' Now having said that, I reckon that cabal and co were a huge step. So I really don't want to point fingers, that would be stupid and I am totally appreciative of people who started those. But it comes down to expectation to have something packaged versus a project always in the move and sometimes holes.
What about including a link to a usage questionnaire to GHC itself? I think this would help reduce the sampling bias of all these separate channels, e.g. mailing list, reddit, twitter etc.
Look, using mutable state is evil. That's what was the case. What's not an exaggeration is being on the verge of not using Haskell because to see people were ok with that was plain scary and unconditionally mad. It might not be a problem now but it was until very recently, *among other problems* and arcane command and an unintuitive workflow. It was not marketing. It was wasted hours of useless 'work' and frustration recovered.
I just recently tried to build GHC from source on a fresh Debian machine. I recall that the build process needed to have the full platform installed. Which was annoying, given that what you get by `apt-get install haskell-platform` is outdated (7.4, 7.8 even with backports) and conflicts with more recent GHC installations, provided by backports of `apt-get install ghc`, for example. I managed to install a GHC-8 platform through the generic Linux option. What I'm trying to say is: The full platform is at least required in the (make-based) GHC build, but installing the right thing is a pain for a sporadic Debian user like me.
Please note that, apparently, anonymous users can delete comments and edit and delete existing entries. I can change my own entry that I created yesterday on a separate system. I responded in haskell-cafe, but I'll also copied my message here.
Sure but the Haskell platform was an idea pushed when? 2013 ? And he has to push for stack to be in.... in July 2015. I feel bad there is no modus operandi, but we are on different time scale and planet here. If it's never been a technical dispute, then it well appear as such. He has made an awesome tool and it seems all he gets is pushback and tepid support. He might be a god, but he is also a human who came to save us. And many praise his name and believe in his message. --- Speaking of technical, if we want to have more harmony, we have to anticipate. The line of fracture (and of opportunity actually) is on those global version/local version. Both have value, the first one forcing us collectively to make sure stuff works maximally, the second allow freedom to break away. I would be so glad to see the "group level" work done to strategically anticipate those fracture line.
Under Gentoo that's no problem. Also the Haskell overlay has pretty big number of packages.
I seems to me that its goals are intermediary between [base-prelude](https://hackage.haskell.org/package/base-prelude), which tries to import as much as possible from `base`, and [rebase](http://hackage.haskell.org/package/rebase) which tries to import as much as possible that is considered standard in modern Haskell practice. Both consists of just imports, so they are compatible with the standard Prelude.
Huh, talk about having the rug pulled out from under you to realise that there is a second rug, the same rug, underneath it.
It talks about it. But it does not make any effort to give a reason why it can't be a function. In logic named values are nullary function symbols. There is no conflict here.
Woah, new-build has progressed more than I assumed. Is there a comparison of Stack vs new-build somewhere that shows what the commonalities are what each tool does differently?
It may well, but I haven't encountered such a situation yet.
Huh. I didn't have to install Platform to compile GHC on Windows. (I'm not saying you're mistaken, I'm just saying that's weird.)
If you're looking at [cabal new-build](http://blog.ezyang.com/2016/08/cabal-new-build-is-a-package-manager/), that's pretty much what I was thinking about. You get automatically sandbox like behaviour and sharing of build libraries. It's the best of both worlds. If you have the same library version with the same version of all dependencies, than you can share the build libraries for all projects for all the different build profiles. In the worst case you're using the same amount of memory cargo currently uses, by building each library for each project separately. 
I don't think that you need the full platform to build GHC from source. All you should need is a bootstrapping compiler.
rust is `cabal sandbox` + `cabal freeze`, and `cabal new-build` is even better by having sandbox like behaviour and reusing of library builds across all projects. That's just awesome! 
Yes indeed; I've been a Haskell beginner for at least five years and never had the need to use stack or anything from the [Fpcomplete] (https://www.fpcomplete.com) stable and I have at least a dozen active projects with a myriad of dependencies all happily built and maintained using cabal sandboxes. Personally I'd like to see discussions on making Haskell (ghc) in terms of e.g FFI/llvm and other efforts to actually make the language (compiler and outputs) more useful/stable on the platforms it supports/targets instead of generating a schism around mere tooling. IMO this focus addresses the issues of an more engineering oriented user base more keenly than installer tools. Get the real stuff right (runtime, library APIs, ABI, memory management etc., etc.).
Too true -- a few years with cmake/jam/autotools... and integrating boost libraries into language of choice (not c++) would cure anyone of thinking that cabal-install is not doing a job!
That might be the case. I just went with what the wiki said, and I recall that what I had prior to that in path (GHC-7.10 + `cabal` + `happy` + `alex`) didn't seem to work. Also, I didn't just build GHC but also ran the benchmarks, so that might be what was complaining about missing `vector` libraries and such... Maybe I should just retry some time. Thanks anyway for the feedback!
Of course all new users are going to gravitate to the "full platform". How would they know not to? That would be like asking "do you want python without batteries included?" or "do you want C++ without the standard library?" as far as a new user is concerned. That should not be taken as a signal that people seem to "want it".
Can we... Not start with novelty smarmy XSucks user names? This situation needs to diffuse, not escalate, and thus sub needs professionalism, not trolls. EDIT: I guess they had the name before the most recent flamewar, my bad.
"How would they know not to?" At the top of the platform page there's text that reads: &gt; Note: as of 8.0.1 there are two download options available — minimal and full. The minimal option is currently the generally recommended one. It does not include any additional global libraries beyond those packaged with ghc, though it does include all tools. This ensures maximal compatibility with a variety of library sets. The full option is useful for those who prefer the "classic" platform behavior with a broader set of preinstalled libraries, and especially serves those well who want full-featured installers in situations where network connectivity should not be taken for granted." So that attempts to steer people towards minimal, in fact noting that it is the recommended way to do things. It may not be worded correctly, or maybe other things could be done to make this more clear.
I am in principle very much in favor of automatic formatting, and I hope that a tool like `hindent` will eventually be better at formatting code than a human. But it currently is not there yet. Code is literature meant to be read, and good code goes at length to be easily readable, and formatting can carry semantic information. The Haskell syntax was (at least I get that impression) designed to allow the authors to write nicely looking, easy to understand code. One important tool here is vertical alignment of corresponding concepts on different lines. Compare maze :: Integer -&gt; Integer -&gt; Integer maze x y | abs x &gt; 4 || abs y &gt; 4 = 0 | abs x == 4 || abs y == 4 = 1 | x == 2 &amp;&amp; y &lt;= 0 = 1 | x == 3 &amp;&amp; y &lt;= 0 = 3 | x &gt;= -2 &amp;&amp; y == 0 = 4 | otherwise = 2 with maze :: Integer -&gt; Integer -&gt; Integer maze x y | abs x &gt; 4 || abs y &gt; 4 = 0 | abs x == 4 || abs y == 4 = 1 | x == 2 &amp;&amp; y &lt;= 0 = 1 | x == 3 &amp;&amp; y &lt;= 0 = 3 | x &gt;= -2 &amp;&amp; y == 0 = 4 | otherwise = 2 The former is a quick to grasp specification, the latter (the output of `hindent`) is a desert of numbers and operators. I see two ways forward: * Tools like `hindent` get improved to the point that they are able to detect such patterns, and indent it properly (which would be great, but very tricky, and probably never complete) or * We give the user a way to indicate intentional alignment in a non-obtrusive way that gets detected and preserved by the tool. What could such ways be? * For guards, it could simply detect that within one function definitions, there are multiple `|` on the same column, and keep them aligned. * More general, one could take the approach `lhs2Tex` (which, IMHO, with careful input, a proportional font and with the great `polytable` LaTeX backend, produces the most pleasing code listings) takes. There, two spaces or more indicate an alignment point, and if two such alignment points are in the same column, their alignment is preserved – even if there are lines in between! With the latter approach, the code up there would be written maze :: Integer -&gt; Integer -&gt; Integer maze x y | abs x &gt; 4 || abs y &gt; 4 = 0 | abs x == 4 || abs y == 4 = 1 | x == 2 &amp;&amp; y &lt;= 0 = 1 | x == 3 &amp;&amp; y &lt;= 0 = 3 | x &gt;= -2 &amp;&amp; y == 0 = 4 | otherwise = 2 And the intended alignment would be explicit.
I used to be part of the GaTech OMSCS program, but I got sort of demotivated, and haven't signed up for courses this semester.
The lack of cabal new-install has blocked me from using cabal new-build on several occasions. I'm testing some code locally, it depends on some package, and I just want to install the package. The code I'm testing is just a bare .hs file, or maybe I want to fire up GHCi and look up some types or something. I mean, how hard can it be? cabal new-build already does it for dependencies, so why do I have to make a whole new .cabal file with a build-depends just to install a package? I know about the problems that can arise when there are conflicts in the database and it's not obvious which packages to make visible in GHCi, but I know what I'm doing dammit, just install the package for me!
IIUC mailing lists can also be mirrored there—see Haskell-cafe. (I find Google Groups bad, but I agree it's much more accessible than having to subscribe to an ML before a conversation starts).
I'm with you. I also only half-indent my case clauses (to match my switch/case style in C/Java).
&gt; Ideally we'd all be using tabs And we'd go back to having GHC not warn about them by default!
&gt; I (possibly uniquely) also prefer braces &amp; semicolons I think SPJ used to use them a LOT, though with a semicolons-first style like: do { statement ; ref &lt;- exprStmt ; return $ fn ref }
/u/StackSucks is often pro-Stack.
Yes it was! Sean Seefried ran a workshop on games-programming for Android in Haskell: https://www.eventbrite.com.au/e/workshop-on-writing-games-for-android-in-haskell-compose-conference-melbourne-tickets-26997773066#
We had a videographer record all the talks. We're estimating about a month before publication.
Fair enough. The bikeshedding over the "minimal" name may help some. Better suggestions on clarifying the text are absolutely welcome here!
This is one discussion https://mail.haskell.org/pipermail/libraries/2012-October/018599.html https://mail.haskell.org/pipermail/libraries/2013-March/019528.html One writer-as-state implementation on hackage is http://hackage.haskell.org/package/stateWriter https://github.com/bartavelle/stateWriter 
They do and since they don't allow users to install their own package it is the best option they could have come with to ensure that as many packages as possible are available. Sadly, the codingame Haskell Platform is from 2014.
Seriously thanks. But to me you're confirming the committee doesn't talk enough (as alleged), and maybe it should. How is your message and Gershom's coming from the same committee? I can't believe Gershom's that naive to describe this drama as a modest discussion: https://mail.haskell.org/pipermail/haskell-community/2016-August/000147.html The best I can imagine is the following: - he knows the committee couldn't progress as it's doing if discussions happened elsewhere (TRUE); - he thinks haskell.org should continue on the current general trajectory, lest other things be disrupted. I disagree, but that's a honest, informed and consistent position, unlike that mail. For completeness: the thread continues, but he still ends up sticking to "this ML is good". Just two emails and I have to believe Snoyman's claims much more. Or can somebody explain that thread otherwise?
&gt; I really am not trying to start a new fight, ... Do we really have to devolve to title edits and shifting blame here? ... *sigh*
I'm sorry to hear that! Well, I'm an undergraduate at campus and I'm not sure if graduate students would be interested. I will look into the possibility of video for meetups, it would be really cool to have you. Keep on learning!
There are still technical concerns, but I'll agree Snoyman did a bad job there at explaining them: http://www.snoyman.com/blog/2016/08/follow-up-haskell-org-evil-cabal Incidentally, shortly afterwards, Snoyman discovered the HP on Windows currently doesn't work out of the box (and gbaz agreed), see report on the ML.
PhD student here. Ranted against cabal in 2012 on the ML, and the answer I got (IIRC) was basically "sorry, you're right". I think the rant was against `cabal upgrade` so that was easy. I've totally learned to use cabal and prevent it from breaking packages, but boy was it tons of work. (And I don't find sandboxes' compile times acceptable, but that at least approaches safety).
&gt; If I'm writing a patch against someone else's code, it's way more important to me to figure out and match their style than to impose my own opinion. This is great and I wish more people would do it. Even better if the project has a style guide, although that's overkill for most projects.
I've been doing this as well. Something like: foo x y = [ 1 , 2 , 3 ] This has indentation that doesn't depend on the function and argument names, although switching out the first argument is still harder than the rest. If only leading and trailing commas were allowed in lists...
I'm not defending HP but I remember using it when I start playing with Haskell therefore there is a use case for it. I think it took me a few years before creating my own cabal file. I just created some files in a `haskell` directory and ran them with `ghci` or `runghc`. The thing is : real beginners don't want to have to faff with cabal or stack. They need to be able to toy around without having to create a "project" and don't have a workflow as such. Once you've passed this stage and are ready to create a cabal file, running `cabal install --dep; cabal build` or `stack build` doesn't make much of a difference. Having said that, the ability to install and use different versions of GHC with stack is awesome.
This would be true if `digitToInt` was returning a `Maybe` or something, but the actual behaviour throw an error suggesting that it's input should actually been check for validity.
HP turned out to have a serious bug that Snoyman discovered (reported on the ML)—that is, they can't provide sufficient testing. Even just packaging an installer is tricky. Overall: the point is IMHO simply to have quality standards for what's offered on the homepage. AFAICS, the HP team appears to refuse to guarantee those standards because it's unreasonable for volunteers. Hence removing them from control is sensible. Now I disagree with Snoyman's approach, but I value it more after 2 emails with Gershom. BTW: I think some volunteer teams could provide the required quality—HP's track record shows it's just not that team. EDIT: conversely, Cabal with ezyang might prove in the future to be as good—at least, I have high hopes.
Why not maze :: Integer -&gt; Integer -&gt; Integer maze x y | abs x &gt; 4 || abs y &gt; 4 = 0 | abs x == 4 || abs y == 4 = 1 | x == 2 &amp;&amp; y &lt;= 0 = 1 | x == 3 &amp;&amp; y &lt;= 0 = 3 | x &gt;= -2 &amp;&amp; y == 0 = 4 | otherwise = 2
Yes, that’s also a nice way.
It's a date. =)
Aww. Thank you for all you have done, Edward. I am a perpetual Haskell newbie, but I miss Haskell from the time all the Haskellers I got to meet were kind people. While Stack is certainly very nice, I don't mind having to deal with some Cabal hell again if we can have that back. The current hullabaloo seems to be about what's good for beginners, so let me lay this out here: as a beginner, it was primarily the people that got me hooked to Haskell, not its technical merits. Where would I go if that order is reversed?
Almost :) I don't like how the curly braces with the fields are indented so much. In my example, they are indented just by one level from the '='. 
This turns out to not be a bug in the platform. This is a known bug in stack dating back to January (https://github.com/commercialhaskell/stack/issues/1714). It hadn't affected our platform tests because we weren't testing against a stack 8 distribution (since we were testing with prerelease ghc 8). I've been nothing but helpful on that thread trying to find a workaround. The issue will arise if you have a system ghc and attempt to install network via stack and using that ghc regardless of if you've used a platform installer or not. (Unless, of course, you've placed all the msys tools on your path directly, which many users don't want. For example, for me, that means it disrupts my cygwin setup). The HP team does not refuse to guarantee any standards. Work has been done diligently to improve and test the platform, and I don't understand why you would want to claim otherwise. If more people want to volunteer to test things and submit patches that would however be great! edit: As for the "two emails" all I can find are: https://mail.haskell.org/pipermail/haskell-community/2016-August/000147.html where I tried to answer some questions and https://mail.haskell.org/pipermail/haskell-community/2016-August/000158.html where I thanked you for your input. I genuinely want to communicate, and I don't know what went wrong here.
Thanks! 
Yeah I've been using new build for my dev for a few months now. Still a preview release but it's been super duper nice.
Semi related: I don't know if technically feasible at all, but instead of the full version containing the packages in global scope, could they be included somehow as if they had been built with cabal-install/stack? As in bootstrapping the two tools. Both could be included if the size isn't that big.
That seems like a desired path once new-build becomes "real build" -- but we'll always need to be in an intermediate state to somewhere, so we have to figure out how to keep things manageable in the meantime.
The [async-pool](http://hackage.haskell.org/package/async-pool) library also provides a `Task` applicative/monad that executes independent tasks auto-concurrently without requiring explicit control from the user. In other words, you build up a computation in `Task` and it creates a dependency graph behind the scenes to determine how much concurrency to use. Also, tasks are governed by a worker pool, in order to limit the number of threads created at any one time.
But sometimes dying is useful, so that you can go back and fix your program.
C'mon - Clang's formatter is *nowhere near* universal. Every Go programmer uses `gofmt`, probably a fraction of actual C/C++ programmers use `clang-format` by comparison. And it does not enforce a single style -- it allows extensive customization. It ships with 5 major different style settings, baked in!
Regarding the bug, in fairness, there's no consensus on how to fix it among the two teams. The conversation was more productive than I could expect. There's still an integration bug between the platform and stack. Whatever the reason, clearly automated testing failed to catch it. Regarding our emails, I think Wigley's perspective in the brother thread is significantly different from what you offer (even though he's not speaking for the committee there), and makes my points better. But basically, "the committee is empowered to act" doesn't cut it. https://www.reddit.com/r/haskell/comments/4zzmoa/haskellorg_and_the_evil_cabal/d70ed6q I also analyzed your email in a reply there—that might be overly harsh if you're honestly trying. If there was a misunderstanding, I suspect you were more subtle (and ambiguous) than I appreciate. Is "poor signal/noise ratio" code "the committee can't discuss among this drama"? I'll quote Torvalds: "On the Internet, nobody can hear you being subtle". Torvalds is abusive, but there's a middle ground. &gt; The HP team does not refuse to guarantee any standards. Work has been done diligently to improve and test the platform, and I don't understand why you would want to claim otherwise. I might have overgeneralized from comments in other contexts (and frankly, from other people). But when I did use it (before stack), it always had integration issues (the same ones for which HP Full is now in decline).
I'm sympathetic, and maybe my transition I'm making to the new hindent will prove too painful, but if not... Never worrying about formatting again will be a great thing. I do worry it could take away some of Haskell's beauty, but that is but one consideration.
[It wouldn't work](https://www.reddit.com/r/haskell/comments/4zxqu1/compiles_with_tabs_but_not_with_spaces/d706lfi). That's why I said "that's just not how things are in Haskell". And I should probably accept things as they are instead of continuing to bring this up.
I think that it's named `cabal.project.freeze` because the format is exactly the same as a project file (and we also have cabal.project.local).
done
It really shouldn't be that hard. (See also https://github.com/haskell/cabal/issues/3737) It just needs to be implemented!
Although cabal new-build doesn't install GHC versions for you, it's multi-GHC version is pretty good, and got even better in HEAD; you can transparently have several builds of a project with different versions of GHC in the same project; just set `-w ...` appropriately.
I'm glad that little piece of discourse ended swiftly and easily, but it definitely *seemed* like he was trying to start a fight. That's the kind of thing that just didn't need to be said.
What about http://tweag.github.io/HaskellR/ ?
First, on platform stuff: I absolutely agree that the HP before minimal had known problems, and there was a plan to fix them, and we did fix them :-) It took longer than some people liked, but that's the worst I can say about it. I do agree that if it was the HP as a stagnant version of what it was in 2012 then we'd be having a different conversation. Getting out the message that things really _are_ different and better is hard. You'll find that the committee agreed that the HP installers before minimal shouldn't be the recommended method, and that's why in the last discussion it was agreed that the minimal installers should go first. You've asked "how can you say the discussion is modest"? Well, because the real meat of the discussion, as people realized on some of these threads, really is a very mild proposal to swap the older minimals for the new minimals, which happen to be with the platform. Just because lots of people want to post about something on reddit doesn't make it more or less of a big deal in reality -- which is something the reddit discussions themselves came around to. I agree that automated testing failed to catch the bug. But the bug was a known stack bug going back 6 mos. I don't think there's disagreement that stack should fix this -- it occurs with or without the platform. In the meantime, we'll try to adapt the platform to work around this. Second: Vis a vis the email list question "Poor signal/noise ratio" isn't "the committee can't discuss among the drama" its just that literally some mediums have better signal to noise ratios than others. Haskell-cafe is a big freewheeling place. I only read it once in a blue moon even though I never unsubscribed. There's too many discussions of all sorts going on. Discussing committee stuff there means that its likely to drown in all sorts of other stuff. Having a lower-traffic list on a dedicated topic is kinder to people who care about that topic, and also to all the -cafe people who may have no interest in that topic. And if I want to find "emails related to committee discussions" now I have to search the whole of -cafe, which is... big. We have special-purpose mailinglists for all sorts of topics and I don't see why a special purpose one for the committee is any different or a break from tradition?
You're going to think I'm just saying this to be argumentative, but I really dislike blocks of code that are aligned like this. All my eye sees is an ASCII art box, and not a piece of code to understand. I mentally have to *break* the layer of the box to see what's inside. Without the alignment I see and read code. It's a bit like flicking through a book and getting distracted by the pictures, rather than reading the words. 
I tend to end up using the best tools I can regardless of the language they are written in. I have some machine learning stuff in haskell that wraps some underlying C ML libs. I did implement some nice cross-validation stuff in haskell. We use TensorFlow for deep learning stuff. I don't think its realistic for haskell to build a tensorflow competitor given the size of their team. I also do a lot of spark with scala. I don't know that haskell is going to be able to effective in competing with the spark/scala stack, although there is https://github.com/tweag/sparkle. Haskell definitely has a was to go catch up in this area. But here are a couple of things to check out: https://github.com/gibiansky/IHaskell https://hackage.haskell.org/package/statistics https://github.com/mikeizbicki/HLearn
I thought about it, but in the end I'll just use R instead of Haskell. I'm thinking about using that for doing some wrapper libraries, or not, idk
It seems like Scala is really popular among people using Apache Spark if you're interested in big data, though I'm aware "love Scala" was no part of that story. I don't know too much about Incanter, and nothing really about Flambo, but they could be ways to try data science with Clojure.
I'm not really a fan of Spark, because nowadays everyone tells you "I have big data, can you do X with it?" and then handles you a flash drive. I had used Incanter and saw Flambo, but I still think that Haskell is superior (just my opinion)
I really wanna make a Haskell Data Science open source team, with a Slack channel and all that stuff so everyone who would like to contribute would be welcome. Making a site to make the org more appealing. Add a Trello board with pending tasks, etc... I agree 100% with you about guiding people in. I always wanted to start a data science initiative but alone I was not really confident.
The JVM is in an odd state when it comes to data analysis. There's very large-scale tools like Spark, Hadoop, and libraries built on top, but there's very little support for small or medium-sized data. I think even something basic like charting doesn't yet have a standard solution. There's been recent work on providing linear algebra and numerical array support, but nothing like numpy, matplotlib, scipy, etc. In Clojure there's Incanter, but I'm not sure it's actively developed anymore.
&gt; If I'm writing a patch against someone else's code, it's way more important to me to figure out and match their style than to impose my own opinion. Amen. I prefer using actual tabs, but if the file already as 4-character (or 2, or 8, or 3, or 5.5) spacing, I use that. I wish other programmers would be as considerate when they modify my tabbed code -- mixing styles is ugly and much harder to read.
The goal would be making a good environment for data science in Haskell. Things like Pandas, Numpy, SKLearn, etc... So a data scientist could start working right away if he knows Haskell. I'll make a new thread so people can vote for the organization name. I can't come up with anything good :)
&gt; actual tab characters can wind up breaking said alignment Not if used correctly. You can take all my Haskell code, and replace tab with 2, 4, 8, or 3 spaces and it still compiles and has your chosen amount of horizontal whitespace. It's not even that *hard* to do. If you want to use tabs in the middle of a line, it's more difficult, so I generally just tell people to always put tabs before any other character, and to increase/decrease the number of tabs at the beginning of a line (vs. the previous line) only if you are also increasing/decreasing the layout nesting.
I'm in although I'm not sure how much use I'll be. 
&gt; Edit: It's also embarrassing to explain that cabal has no "uninstall" command. How embarrassing is it to explain that Stack hasn't one either?
&gt; Not if used correctly. Yes! Tabs are basically the same as pervasive nulls, manual memory management, or implicit string coercion. At a fundamental level, we agree! :)
&gt; I don't really know how cabal freeze works, but what new-freeze does is just force the solver to use particular versions. All of these are installed to the global database and can be reused across projects. In case anyone is interested, `cabal freeze` runs the solver and writes the returned dependency constraints to a configuration file. Other commands, such as `cabal install` read the contents of that file and pass the constraints to the solver, forcing the solver to use particular versions. 
And I have witnesses. ;)
That makes sense! I haven't used `cabal new-build` yet so I wasn't familiar with `cabal.project`s. Now that I've seen them `cabal.project`s look awesome too, glad there's a declarative way to specify local dependencies!
If it's a problem you often encounter, try using a variable-width font. I find them much easier to read, and they completely mess up typewriter formatting as an added bonus.
This looks awesome! Anyone using it in anger?
LambData kinda sounds like Big Data applied to the cattle industry. How about "Fold" or "FoldData" or "DataFold"? It conveys the general idea of reducing a number of data inputs into a summary value. Inspired by [this](http://www.johndcook.com/blog/2016/06/08/computing-higher-moments-with-a-fold/) John D. Cook post.
I was a little confused between `Concurrently`, that has no monad and `Task`, which has one. Apparently Concurrently does not need a monad because it does not use task pooling, since it uses as much threads as he needs , while Task do uses task pooling so he must "transport" pool state in a monad. However `Task` is enigmatic for me. I do not know usage examples. Any link? Transient also does task pooling: threads 2 $ do pages &lt;- (,,) &lt;$&gt; async (getUrl url1) &lt;*&gt; async (getUrl url2) &lt;*&gt; async (getUrl url3) ..... will execute all the do block with two threads so only two async's are executed in parallel. let choose list = mapM (async . return) list in choose [1 ... 1000] would produce 1000 threads. x &lt;- threads 1 $ choose [1.. 1000:: Int] liftIO $ print x would print them ordered in a loop. But internally are different. async-pool uses futures while transient uses continuations. the first uses a master thread that wait for auxiliary threads. The `Control.Distributed.Process.Async.Task` monad seems to delay the `wait` as much as possible until the data is needed. In transient there is no master thread and no wait since each single thread continues all the rest of the whole computation until there is some `stop` or the threads "collide" concurrently with `collect`-the opposite of `choose`- or `&lt;*&gt;`. (Edited for errors &amp; clarifications)
FoldData or Fold is awesome in my opinion!
&gt; As it stands: tabs are ambiguous in editors, spaces are not. Therefore spaces are simply safer for a language with syntactically significant indentation. Oh waow I knew it has been the case for years but I thought that ambiguity would have been solved by now (well no apparently). 
It might be a good idea if at some point it is necessary :)
Maybe give Scala a try. From a language perspective there are pros and cons (Haskell has better type inference, Scala has better typeclasses), but from the tooling perspective Scala wins by a large margin. Great IDE and editor support, a huge library ecosystem and a stable and working way to manage dependencies instead of ever-changing half-working tools that are not cool anymore next week. It also has a JavaScript back end that actually works and a native back end in development.
How are tabs ambiguous?
Sounds like a consultancy name for me, lol
Did not try it thoroughly, but reading some posts people say it is not very complete and the same thing as you
HaskellData. It won't get old/out of flavour that way.
That was part of it. I know cabal doesn't help you choose the ghc. The other part was that every time I installed a new ghc or a new cabal, I had to completely scrub the old one - and there was no documentation of how to do so. Basically if you made a mistake (in my case, downloading the ghc from my distro or downloading the current HP) you were set back many hours. Also cabal didn't give me any nice error messages - it just said "you have the wrong base" and mentioned nothing about ghc. Even when I *did* get the write distro working, building accelerate failed on many different occasions, and I ended up typing something like 31 commands to do build my project because it was breaking halfway through. 
FoldData is nice, but FP outsiders will have no idea what that means. My vote would be for HaskellData or HaskData. To all - if you're interested in this effort, there's a few of us working on a plotly binding for data visualization. If you're interested let me know and I'll add you to the project / repo.
Enter the Fold. / Welcome to the Fold. Starts to get eerie.
what happened to IHaskell? https://begriffs.com/posts/2016-01-20-ihaskell-notebook.html
Posted this in the vote thread, but I'll mention here as well: There's a few of us working on a plotly binding for data visualization. If you're interested let me know and I'll add you to the project / repo. 
Right. There's no need for cutesy names when you can say what you mean.
This is not a question with a definite answer since there are different ways to implement Haskell overloading. 
HasData
there are a few bindings, including the relatively recent hblas work https://github.com/wellposed/hblas its documentation could use some love though.
how about "DataMorphism"
&gt; a lot of people get scared when they hear Category Theory terms I don't care whether you call it that or not, but I doubt anyone who sees that term and is scared of category theory will associate it with categories at all. They will assume it's a play on "polymorphism", which has long since entered the programming vernacular.
If someone's really angry about a missing feature in Emacs then perhaps.
I've been on the mailing list for a couple of years now and generally keep an eye on the issues, and I think I'm mostly across a lot of the other relevant mailing lists / keep an eye on the issue trackers. Part of the above - the rough dev/feature alignment comes from my memories of a discussion from either the mailing list or the IRC channel. I've seen plenty of stuff get stalled, but I usually assumed that part of that was through a lot of the Cabal devs not being sure if they were the ones who should be saying "yes" to a change and/or having zero bandwidth besides for their feature. It could be much worse than what I'm seeing though :/ Edit: Also seems kind of ironic that we've taken different things from the same source of information, given that various dramas :)
Yeah, it's much needed. I would love to contribute but it depends on available time.
Yes. It needs to be understandable, nothing too cryptic, but also easily searchable.
I used to find HP really useful to cross-build windows executables under wine. I don't know if that's possible for stack.
I think above all there needs to be a big ol' checklist, first and foremost, saying what libraries are missing, who would be or is working on them, how to contact them, the site of development for those libraries, and explanations of why they are needed. That would make it very clear what directions to take for new and existing projects.
DataHaskell or DataHask as in, data as an adjective to Haskell. EDIT: /u/nSeagull thanks!
&gt; then the obvious (and reasonable) reaction will be "why are you letting me download something that is known to have these problems?" If that's how people react when duly forewarned, then it's an important warning! &gt; Also "what the hell is a sandbox"? Hyperlink it
The Spark mllib machine learning library is quite good when used with Scala. Here are my book examples using mllib from Java https://github.com/mark-watson/power-java If you have Java 7 or 8 and maven installed, you can try the examples in a few minutes.
I laughed so hard at safePerformIO :: IO a -&gt; IO a safePerformIO ioa = ioa &gt;&gt;= return
That’s cool! (Although more limited than what `lhs2tex` does, where the alignment can be interrupted and does not have to nest the way it does with elastic tabstops).
I use Haskell to run the more intense I/O for jupyter notebooks at my work. It can do parallel hits to our REST APIs written in Java. It makes a really nice segmentation of duties. Eventually I'd tend to moving towards more automated C compiling/FFI than moving the data science into Haskell. The graphing utility of jupyter can't be over stated.
This is nuts. I am very excited for spacemacs to become stable with emacs 25.
&gt; But to me you're confirming the committee doesn't talk enough (as alleged), and maybe it should. How is your message and Gershom's coming from the same committee? Under normal circumstances, the types of decisions the committee is responsible for don't call for synchronous communication with the other members. Asynchronous emails and IRC pings are sufficient to handle the rest, and so as volunteers with many kinds of time pressures, we find that works well. So from my view, John and Gershom's messages are well-aligned. &gt; he knows the committee couldn't progress as it's doing if discussions happened elsewhere (TRUE); &gt; he thinks haskell.org should continue on the current general trajectory, lest other things be disrupted. I disagree, but that's a honest, informed and consistent position, unlike that mail. These are just bizarre statements that sound more like a conspiracy theory than an actual attempt to collaborate and reach understanding with the volunteers on the other side of the wires. The committee created this mailing list in direct response to frustrations people had from poor visibility into the committee's decision-making process at the suggestion of some of those frustrated people. As has been demonstrated in this thread and others, no single venue is going to please everyone, so we make do by choosing the venue that we judge to have the lowest barrier to entry (technically and socially). I'm at a loss as to how reiterating these points is dishonest, uninformed, or inconsistent, and saying that it is is frankly insulting.
Interestingly enough, python's canonical style guide recommends the second choice. Personally, I agree with it.
GotData? :P
Perhaps the "Implementing a minimal version of haskell-servant" [article](https://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/) by Andres Löh.
First of all I'd like to say that even after six and a half years of full-time professional Haskell development, I would like to second this sentiment. I have also found it difficult to apply advanced type-level features to real world problems. I'm not exactly sure what factors contribute to this in my case. I'm sure it's probably a combination of a complex array of characteristics relating to the way my brain works, the projects I've worked on, etc. But suffice it to say that I have felt similar to the OP. Secondly, I think it's worth pointing out that the majority of the problems I've encountered (a lot of them also related to web apps) don't seem to require advanced type system features to achieve elegant solutions that are much safer than the alternatives. And it's important to keep in mind that just using advanced type level features is not necessarily always the best thing when you're talking about production code. Even with an advanced language like Haskell, the [KISS principle](https://en.wikipedia.org/wiki/KISS_principle) is still very important in the real world. This means that maybe the question shouldn't always be "how can I leverage fancy type system features for this?", but rather "how can I solve this problem elegantly with the simplest type system features?". For example, I suspect that the first three of the architectural patterns mentioned by the OP have pretty good solutions simply by leveraging purity, smart constructors, and encapsulation via the module system. Smart constructors and encapsulation alone can solve a surprisingly large number of problems. I talked about this a little in [this presentation](https://github.com/mightybyte/modules-and-types). This second point doesn't nullify the first point. You can't make good decisions about when and when not to use fancy type system features without understanding those features. So I'm still interested in the tools for learning them. It just says that along with those tools maybe we should also talk about good rules of thumb for categorizing language extensions and assessing them for approachability. I actually had a conversation along these lines within the past week about which language extensions should be considered for best practice readable and maintainable code. I personally would put them into the following groups of increasing sophistication/complexity/advancedness or whatever other term you want to use: * MultiParamTypeClasses, FunctionalDependencies * Type Families * GADTs * DataKinds I'd say that the first two groups are fairly standard and frequently used in my experience. The third, GADTs is a little less common, but still appears on a semi-regular basis. And DataKinds would be one of the newest and most advanced extensions. I would probably lean towards avoiding DataKinds a little more unless my organization has a compelling reason to use it. Compelling reasons for DataKinds (or any other arbitrary level of sophistication one might argue should be avoided) I can think of could be one or more of the following: * The organization has a good depth of people with that level of expertise. * The solution much more elegantly solves a problem that is important to the organization. * The solution forms a strong and not very leaky abstraction that won't impact much of the rest of the code base. I'm very curious to hear how other people might categorize these (and other) language extensions and other best practice suggestions on guidelines for their use. A third minor point that I think is worth thinking about is the potential problems with too many language extensions. I've heard a number of people express dislike for C++ because it is too huge a language to use effectively. It seems that every organization usually standardizes on some subset of the language, and each chooses a different subset. This point also probably applies to Scala as well. I don't think we're at that point with Haskell yet, but I think if we continue to add more and more advanced language extensions, we will probably need to think about this more seriously at some point in the future. It could be that the fact that we're using language extensions solves the problem for us because any organization can simply state what extensions are allowed in code they maintain. But I don't know. Do other people think this could become an issue for Haskell?
&gt; It also generally helps to go through the literature and read the papers that motivate/introduce the extensions. Non-exhaustive list of conferences to look at: ICFP, PLDI, PADL This is a good point. But it's something that may be quite a bit easier for people with a more academic/theory heavy background and harder for those missing it. Maybe someone should do the literature search once and compile all this information into one convenient place with all the recommended papers indexed by the language extension(s) they apply to (if that hasn't already been done).
&gt; When your spouse gets tired of hearing it you will know what to do. Resign? ;)
What's the difference between https://github.com/mightybyte/modules-and-types/blob/master/modules-and-types.md#solution-smart-constructor-pattern **and** https://github.com/mightybyte/modules-and-types/blob/master/modules-and-types.md#solution-smart-constructor-pattern-1
A very nice and much needed initiative. How about HasData? It is also a bit punny. Edit: others have already suggested this. 
Interesting, but what an untyped mess. 
Wrt to the [Security related section](https://github.com/mightybyte/modules-and-types/blob/master/modules-and-types.md#securet): * Nitpick: `runSecureT :: SecureT m a -&gt; User -&gt; m a` vs `runSecureT :: User -&gt; SecureT m a -&gt; m a` ? * Should the return type of `runSecureT :: SecureT m a -&gt; User -&gt; m a` be an Either? Or at least `m` should be constrained to to a `MonadCatch`? * Would `mkSecureAction` be a better name for `liftChecked`? * The way to use this would be to wrap each function of the entire domain API in the `SecureT` monad, and export only the secure versions, right? 
Any way to use lenses to avoid this boilerplate? Or would that also export the getter/setter, both? 
How about `strictId !x = x`?
Yes, there are many papers with variable-width font for code as well. Editor support for proper layout would be great, so people wouldn't have to resort to "my first Word document"-style formatting using the space bar.
Isn't that basically ``x `seq` x``?
This is one way it could be done: data EqD a = EqD { eqEq :: a -&gt; a -&gt; Bool , neqEq :: a -&gt; a -&gt; Bool} defaultEqD :: (EqD a -&gt; EqD a) -&gt; EqD a defaultEqD f = d where d = f (default_ d) default_ d = EqD { eqEq = \x y -&gt; not (neqEq d x y) , neqEq = \x y -&gt; not (eqEq d x y) } data A = A Int instanceEqD :: EqD A instanceEqD = defaultEqD (\d -&gt; d { eqEq = \(A x) (A y) -&gt; x == y }) example :: Bool example = neqEq instanceEqD (A 1) (A 1) -- &gt;&gt;&gt; example -- False 
That's exactly what it is.
AbstractConcreteHaskellDataScienceToolsetProviderImpl ?
It could just be how my brain works, but I completely switch-off when something is being explained in purely theoretical terms. A practical use-case helps me remain motivated to trod through the theoretical mumbo-jumbo. That's my reward at the end of the tunnel. If you don't talk about the reward at all, I lose motivation.
I've been looking for a natural way to express machine learning algorithms in Haskell for a long time as well. One thing that really bugs me when trying to make a nice interface is that Num stole a bunch of great operators but also has a bunch of nonsense operators which make it horrid to implement for anything that isn't literally a number or some information being tracked alongside a number.
But isn't that just `x`? I mean, that really seems [completely pointless](http://pointless-haskell.tumblr.com/post/149738739292/strictid-a-a-strictid-x-x-from).
At the time I opened the site, this was the topmost entry and I assumed this was all about useful, point*free* combinators. Then I read the other entries and reconsidered.
Is your `x` too thunky? Force it with this one weird `strictId` function.
Snoyman's recent behavior reminds me of Thunderf00t from the old Youtube days. Having been through that, it pains me to see how much benefit of the doubt is being given. I've seen this game of "well I didn't *actually say* they were evil" enough that I have no patience left for it.
I have a nix shell I use to run Jupyter + IHaskell over here if anyone is looking for an alternative: https://github.com/rehno-lindeque/nix-jupyter-env Fair warning, I don't work very hard to maintain it.
Wow. These use-cases sound really interesting. What would it take for you guys to take a webinar on this? I'm fine even if it's a paid one.
Great! many thanks to everyone that contributed to it :)
Send bgamari a note about it. Maybe some other project has a MADV_FREE autogoo blob which we can swizzle in? (It seems doubtful we'll take orion's patch, it is clearly not the right thing to do.)
What are the ways other than dictionary passing?
I rescinded my "conspiracy theory" a bit upthread. https://www.reddit.com/r/haskell/comments/4zzmoa/haskellorg_and_the_evil_cabal/d73s5xh &gt; I'm at a loss as to how reiterating these points is dishonest, uninformed, or inconsistent, and saying that it is is frankly insulting. I retracted those points. But if you wonder why I said it: "we prefer the ML" is not the problem. I was at a loss specifically about calling the topic "a modest discussion", not "a discussion that should be modest"—as if it was in fact uncontroversial, which it clearly isn't. Probably I shouldn't have suggested ill will, but I find it a pretty serious slip, especially when the argument was kind-of "this is a modest discussion that needs no special consultation" (or that's how I understand part of the email—I think it's close enough but that's not how it's stated). No topic is worth of insults, but I still think the initial experience for newcomers is an important topic.
I'm resisting the urge to up vote this - made me laugh but don't want any of these.
Paging /u/davidfeuer
The bullet points in this post are great. But where can I find out how to use `new-build`, starting from scratch? In my own case, "starting from scratch" means starting as an experienced and fluent user of cabal sandboxes. Of course, it would also be useful to know where to find out how to use `new-build` as someone who knows only stack, or as a complete newbie.
I think http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/ is the most complete resource today. There's probably different flavors of tutorial that could be written though, but haven't been. This PR has the in progress manual addition for it https://github.com/haskell/cabal/pull/3727/files
Ah, this is what I get for skimming! More specifically, log n * log m is for the algorithm's span , the total work is really m * log (n/m+1) for both union and difference. I guess the reason for differenceWith and Key being difference is a typo then?
If this is a common occurrence for you, you need to be introduced to the term "Medium Data": http://www.tableau.com/medium-data Enjoy =)
Thanks! :)
My scattered philosophical thoughts about FRP in general: * Events and Behaviours are mathematically dual, in the sense that you can take sums of events and products of behaviours, but not the opposite. So I believe they are equally important. * Continuous Behaviours are basically impossibly to implement in general, except for very specific domains. So I would seriously restrict that in a general-purpose implementation (I want to allow a linear "time", explicit functions of time, and combining those with step-function behaviours, but probably not much more than that) * I don't think FRP as a *concept* scales up to large programs, at least not with the current formulations * Signals are bad (unmodular, etc). Signal *transformers* are much better. Unfortunately arrow-based FRP limits the notion of "signal transformer" so much it's becomes basically unusable (an arrow always has only *one* input, in a conceptual sense) * FRP is mostly about state management * being explicit about the state is probably better. There was a (now sadly abandoned) attempt to do explicit-state-style FRP called ["lensref"](https://github.com/divipp/lensref) and a GUI framework based on it called ["lgtk"](https://lgtk.wordpress.com/), which from a superficial study I feel is actually more promising than any of the "classic FRP"
A small editorial note: why not merge the `Haskell and..` section into the Libraries one, and give the latter more prominence?
Makes sense.
&gt; May be the message is yet still not sharp enough ?? We really don't need more escalation, do we? And it does appear as if the cabal devs have heard the message and they seem to be finally on track with fixing those pain points you mention. Better late than never. What else do you want from them?
But few that have vertical alignment beyond the initial indentation of the line.
Could you elaborate ? I think that [unordered-containers](https://hackage.haskell.org/package/unordered-containers) fills that purpose.
I usually end up copypasting the content of `data-memocombinators`, which is terse enough. I am not really good at that competitive thing though.
Thanks, I appreciate the clarification.
In my opinion getting some initial minimal version of `new-build` documentation out there via this PR should have higher priority than any other work on `new-build` at this point.
In the Haskell like language I've started designing tabs aren't interpreted as multiple spaces: you can indent with either but any given block has to maintain the same whitespace
You can export a `Getter` only lens, but that's _more_ boilerplate, not less.
How dare you interrupt! We'll need to embed some widget in reddit that keeps printing.
&gt; Expose several internal modules through Cabal (as requested by Edward Kmett). These remain completely unsupported. I see a lot of new modules (Data.Utils.*, Data.Map.Base, etc), but only a few of them follow the convention that internal modules are suffixed with `.Internal`. Are these other modules' APIs public, then?
/u/nSeagull , after the majority voted for `HaskellData`, you pick `DataHaskell` ? 
I haven't read these tutorials in particular, but learning dependent type theory (System F, Barendregt's cube, Pure Type Systems, etc.) was indeed an eye-opener. Many Haskell type-level features can be seen as instances of what can be done in a general dependently-typed language, with restrictions to ensure the typechecker can do its job.
Tableau definitely needs "medium data", considering their software cannot really handle more than a few thousand data points...
For known breakage, properly specified bounds do guarantee that the breakage will be avoided. For new breakage, reasonable upper bounds greatly reduce the chance that you'll hit the breakage. If you did hit a new breakage - usually just after the release of a new version of a dependency - it's easy to work around it for the short term using build tool settings. And package authors are usually helpful about adding the required bounds. This workflow works well if you stay reasonably up-to-date with compiler and package releases, up to about six months to a year. If you fall further behind than that, projects with large dependency sets start becoming harder to build. You get many more combinations of old and new package versions among your dependencies, and often stray into uncharted waters where no one has gone before and build failures are more common. If you need to be that far behind, you are better off using a curated package set like Stackage LTS.
I interpreted that like everyone voted for an obvious name. The name is not a problem for me, I'd not like to break a community that is not yet made just because of a naming thing. I thought that order does not matter much here. Also, it could be confused with http://haskelldata.com/
Check out sparkle from tweag. Spark in Haskell.
Cool, i tried something similar recently with dependent types where the matrixes and the neural network had their size in the types. Unfortunately that made implementing backpropagation more difficult because type inference isn't that great once you try to reverse a neural network...
what about creating a Slack channel for us to follow developments on this?
The team on Slack is created, let me make the landing site on GH pages so everyone can join right away without me sending the emails manually :)
The embodiment of good Haskell style? 
You're right that the empirical data is very lacking -- we only have word of mouth, download counts, and bug reports to go by. On those criteria things seem... fine? The one main surprise we've had so far has been that the silent install feature on windows is used a lot, and its been harder to keep consistently working than one might hope -- we already had a point release on windows to clear that up, and it appears it hasn't been sufficient. So that's ongoing work. It would be very good to get more volunteers and feedback on the windows installer. (And of course we have the recent report on stack and msys issues, which also needs to be a priority). Outside of that -- there have been a good number of downloads and very few bug reports, which is a good sign. And word of mouth has been good. But that's just my word for it, and its partial. So distributing a survey on the user experience to get more feedback sounds like a great idea.
I probably work in an area where these things come up more often but I've learned about a lot of features by thinking "omg, I have this issue and if the type system just did X it'd fix my issue". Then low and behold a extension existed. I also like studying type theory so a lot of my usage is attempting to apoximate what I might do with dependent types. I don't learn by deliberately trying, I learn by needing. So perhaps don't try and learn extensions just keep in mind "could I do more" and then look up to see if an extension exists.
If there was no special support for that behavior in the native signal handler the RTS installs, then I doubt you can exactly implement kill's guarantee - but I would suggest bringing it up on one of the GHC mailing lists. I asume the native handler just schedules a Haskell thread for later execution. If you don't have RTS support to know whether or not you recieved any signals during the syscall, I don't see how anything you could do with Haskell code in signal handlers and wrapped around kill could distinguish the case where you didn't end up signaling yourself and your kill wrapper shouldn't block, from the case where you did signal yourself but your Haskell handler code hasn't been scheduled yet, and kill should yield and block until it runs. Do you have a solution for the threaded runtime? I don't see how that could possibly help, so if you do I may be missing something important.
Windows support is annoying so I understand, but with the new Windows VMs the basics have become much easier. (I never use Windows for real, but managed to fix a number of bugs that way). On the other hand most users are there, so it matters. Regarding user experience. This might have been reported, but the current https://www.haskell.org/downloads page still suggests non-sandboxed installations first: &gt; You can install a package using cabal by running: $ cabal update $ cabal install the-package I've seen the warning afterwards, but that's too late. Usability-wise that's still a trap for new users. Should I file an issue somewhere?
That's a very good point! Since we're discussing the whole page and language for it on: https://github.com/haskell-infra/hl/issues/176 Then adding a point there seems appropriate as it should be addressed in whatever the result of that is.
 Control.Monad.Trans.Writer.Lazy Control.Monad.Trans.Writer.Strict Control.Monad.Trans.Writer.Stricter 
`Control.Monad.Trans.Writer.Strictest`?
Concerning the name - what about calling it Control.Monad.Trans.Writer.CPS? Are there better suggestions? I guess we should also add a module to mtl for the MonadReader, MonadWriter and MonadState instances. We could also make a package providing Control.Monad.Writer.CPS and Control.Monad.Trans.Writer.CPS as a first step and it could be integrated into mtl and transformers after that.
Wouldn't this new one replace the current "strict but not strict enough" variant.
Good luck, I am looking forward to what comes out 
I'm very interested in this initiative (read both your posts yesterday), although I consider myself a beginner in both fields. But maybe a first step would include identifying solutions/resources (good or bad) that already exist in the ecosystem?
The best time to begin fixing something is years ago. The second best time is today
Awesome ! I'd be interested in helping out.
xmonad.org
I would assume that Haskell is far too abstract to write something as low-level as a window manager. No one has ever written a window manager in Haskell. It's just not possible. There are no window managers written in Haskell. Don't even bother googling "Haskell window manager" because you won't find anything.
Ryan Scott has already opened a [pull request](https://github.com/ekmett/lens/pull/673) for `lens`. Unfortunately, the argument order was pretty much forced by pre-existing conventions in the package. Wren Romano and I both concluded that making the argument order `lens`-correct would be too confusing. The implementation for `IntMap` is boring because finding a key in an `IntMap` is blazing fast; I don't see any way to make any "place-holding" mechanism faster than just finding it again.
I'm not quite sure what you're getting at, but maybe I can guess. `differenceWith` advertises a looser bound than `difference` because Blelloch et al proved that `difference` has that tight bound, but no one (to the best of my knowledge) has performed any similar analysis of `differenceWith`. `intersectionWith` and `unionWith` can advertise tight bounds because the proofs for `intersection` and `union` carry over in entirely straightforward ways. `differenceWith` is considerably wilder than either of those.
No. They are very much internal, and very thoroughly unsupported. They will be renamed in the next version (even if it's a minor version) with more appropriate names.
The damn slack link keeping jumping around the GitHub.io site on mobile. Fix pls. I don't have my laptop on me and I want to see the discussion 
Go, DataHaskell, Go! I'm not a data scientist, but I have enough interest, and also love Haskell, so count me in too! Also, nice landing page!
This seems quite thoroughly off-topic for this thread. The `containers` package has *never* had hash tables, hash maps, hash sets, or anything of the like.
Thanks! 
I'd have to debug that and that stuff, you can use http://datahaskell-slack.herokuapp.com meanwhile :)
You can probably use XMonad's core for that, so you don't have to deal with the small details.
http://i.imgur.com/BbgL7x3.gifv ;)
This is impressive, shame you stopped developing it. If I cleaned up the code would you be interested in continuing development?
It took me a minute... 
EDIT: [redirect](https://www.reddit.com/r/haskell/comments/50dqto/pointless_haskell/d74m5b1) ------ &gt; {-# LANGUAGE UndecidableSuperClasses #-} &gt; class x (Fix x) =&gt; Fix x &gt; instance x (Fix x) =&gt; Fix x Hmm, this is intriguing. Is it *completely* useless? No possible use case whatsoever? (Like, does it get into an infinite constraint solver loop no matter what?) 
Couldn't Python &lt;-&gt; Haskell interoperability be a goal? By this I mean being able to use Python libraries in Haskell and maybe the other way around. Also, speaking of Haskell-like language, some started an effort to get a Python back-end for PureScript. Unfortunately, he didn't get very far.
Because if you change the length of one line, you'll have to change other lines to keep things aligned.
Nice! I'll try to be a part of this when I can. Not much data science ATM but hope to do some soon.
&gt; This is not a subtle point. Data center energy is on track to become the most significant energy use on the planet, bigger than cities, transportation, and agriculture. You imply this means prices will rise. I only see them falling, so far. A higher percentage of global energy usage coming from data centers does not translate into a higher price per VM instance. I think the focus on performance misses the issue entirely. Adding a new server is like $20/month. How much code can a developer write for $20? Developer productivity is the bottleneck, not server costs. Haskell increases developer productivity by removing whole classes of bugs, and making code easier to reason about. Also, what makes you say JavaScript is inefficient? A lot of money has been poured into developing fast JS engines. What makes GHC inherently better at emitting efficient bytecode than Chrome's V8 JavaScript engine (compiler)? 
Well, hopefully, there'd only be one or two string types that you actually end up using in practice?
I like that naming scheme a lot.
[Yi?](https://www.youtube.com/watch?v=Q3LE15AyT5g)
When everything fails, compiling from source is the way to go. The new- cabal commands install everything in nix-style, where libraries and executables of different versions can live together, identified by their hash. But you'll still need to install GHC and cabal, so there'll be a lot of things installed system-wide - besides, compiling cabal from source isn't easy at all.
I (or more generally, we at Well-Typed) semi-regularly teach a course on GHC Type System extensions. The next course is in London on 5 October, right before the Haskell eXchange. More information here: https://skillsmatter.com/courses/504-well-typed-s-guide-to-the-haskell-type-system The course is driven by real-world experience, and while the examples are still small, they're certainly more concrete than just peano numbers. There's a blog post by Oliver Charles describing how he experienced the course: https://ocharles.org.uk/blog/posts/2014-05-02-well-typed-guide-haskell-type-system.html I've also given several talks about generics-sop (and will again do so at ICFP in a few weeks), a library that uses many advanced GHC type system features. It probably doesn't qualify as practical according to the criteria mentioned in the post, but there's at least some material available trying to motivate many of the concepts and their use without being overly theoretical: https://github.com/kosmikus/SSGEP/raw/master/LectureNotes.pdf A blog post by me on Servant has already been mentioned, but I think the Servant paper may also be interesting: https://www.andres-loeh.de/Servant/servant-wgp.pdf
Same here!
 Control.Monad.Trans.Writer.Lazy Control.Monad.Trans.Writer.Strict Control.Monad.Trans.Writer.Stricter Control.Monad.Trans.Writer.ReallyStrict Control.Monad.Trans.Writer.Strict2 Control.Monad.Trans.Writer.Strict20160901 Control.Monad.Trans.Writer.StrictNew Control.Monad.Trans.Writer.Strictest Control.Monad.Trans.Writer.CopyOfStrictest Control.Monad.Trans.Writer.StrictFinalVer Control.Monad.Trans.Writer.StrictReallyFinalVersion Control.Monad.Trans.Writer.SttictReallyFinalVer2
Inverse of monotone. See https://mail.haskell.org/pipermail/libraries/2011-December/017270.html
&gt; {-# LANGUAGE UndecidableSuperClasses #-} &gt; class x (Fix x) =&gt; Fix x &gt; instance x (Fix x) =&gt; Fix x Hmm, this is intriguing. Is it *completely* useless? No possible use case whatsoever? (Like, does it get into an infinite constraint solver loop no matter what?) 
Yes, I knew about these two things :) But as you've read, I did it yesterday at 4am and it was like: - Think about "DataHaskell" - Image of 3D pie chart with a lambda comes to mind instantly So I made it, and went off to sleep :) We can do some voting in the future if the people don't like the logo, but right now people seem to have a nice acceptation of it :D PS: You cannot imagine the time I spent yesterday on how was "pie chart" in english. I searched for "cheese chart", "cake chart", "cheese graph", "cake plot" and all unimaginable permutation of those words lol
No worries, it happens to everyone. I'm pretty sure I did the same thing last month in a different /r/haskell thread =)
ok thanks.
It's definitely a sensible question. I didn't try to reproduce your problem or understand whether the C code depends on that special guarantee from kill. But however that may be, kill definitely gives a guarantee that isn't documented for Haskell, and I trust your glance at the RTS code enough to worry that you won't have that guarantee for signal handlers written in Haskell.
well... apparently repo was updated 17 days ago
True, but then again nobody's actually *using* WriterT, right? (Because it's 'broken' for most purposes.)
oh sorry my bad, umatrix being a little to paranoid.
Sat down with a pen and paper to work this out, and holy shit it works. I love it!
To clarify things strict bytestring has a bug, due to which `foldl' plus 0` is slower than `foldl' plus 0 . map id`
&gt; PS: You cannot imagine the time I spent yesterday on how was "pie chart" in english. I searched for "cheese chart", "cake chart", "cheese graph", "cake plot" and all unimaginable permutation of those words lol camembert chart!
Haha I learned it from pointfree.io, but I had to work it out too before I got it. The entire (-&gt;) r Functor Applicative Monad hierarchy is so weird 
`Control.Monad.Trans.Writer.PaulsStrictVersionDoNotEdit`
Implementing the client side of the X protocol in Haskell would be possible, just not a good use of time.
Anyone know the scoop on this? Did Haskell play any positive/negative role in this? Will Haskell continue to play a role in the future?
I've used it before ( quite a bit before I understood the problem it has with leaking space), but all of my uses of it were in applications that I wrote, not in libraries that I published. I know that yesod-form uses the strict variant of RWST. I doubt that anyone has ever noticed the space leak there, because if you write a formal big enough for the space leak to be noticeable, then you have much bigger problems with your webpage. I cannot think of anything else that uses them, but I still think that deprecation and do the addition of a new module would be the safest path forward.
That's interesting considering you just said [this](https://www.reddit.com/r/haskell/comments/4zzmoa/haskellorg_and_the_evil_cabal/d70cr75): &gt; Snoyman and FP Complete want exclusive administrative control over key parts of the Haskell community infrastructure and they're willing to go as far as establish haskell-lang.org to get their way. The fact that they even have to pretend to play nice with the rest of the community is a bridge too far. The reality is that there is no question that [this](https://haskell-lang.org/get-started) is superior to [this](https://www.haskell.org/downloads). The latter exists only because some people are too stubborn to acknowledge that technical superiority ought to determine the issue -- rather than paranoid delusions about FP Complete seizing the kingdom or sentimental attachment to obsolete pet projects. It doesn't matter, because the "administrative control" you're talking about is going to end up determined by which site the stack tool uses as its default upstream.
Basically hmatrix is close to a numpy/scipy-lite being pretty batteries included and also binding to blas for speed. However, some complain that the API ux is klunky by virtue of modeling itself after numpy/matlab workflows. Nevertheless, for just getting a few numerics implemented out and out the door it's probably the best option at the moment repa and accelerate were touted as being next-gen approaches, with accelerate focusing on gpu and repa focusing on parallelism. I haven't tried accelerate but I did try repa. My first impression of repa was that it's powerful but the developer ergonomics aren't there yet, particularly for interactive workflows. My wake up call was when I tried to print a matrix to the screen and realized I had to write a pretty printer from scratch to print one matrix row per line. Easy to do, but coming from luxuries of python it's somewhat raw. I also found repa's syntax to be a bit verbose for rapid development. I didn't try it for that long and it's been a while though, so maybe things have improved. There's numerical haskell which is on its way that could be a strong foundation, however carter is also busy man with many obligations in the meantime.
Dinner and a movie: mission accomplished! 
Depends on if you are used to something like haskell-mode or vi+ghci. Yi seemed to be more geared toward the vin workflow. I want a spacemacs workflow but using Yi. I started by trying to make a small helm equivalent with Yi but had more pressing issues to attend to and spacemacs was good enough even though it still freezes up on me for silly things. I still believe in a Yi powered spacemacs clone, hopefully someone in a better position to develop it exists and sees this.
From Oliver Charles' experience report, this course seems to be exactly what I'm looking for. Although, I feel one day can be too short to absorb so much information meaningfully. For people who can't make it to Haskell Exchange, is it possible to pester you to conduct a longer version of this on any MOOC platform?
How about not using named fields with sum types at all?
https://atom.io/packages/atom-beautify The list is long. The more common languages won't have a unified style because they let the community fracture, and there's too many people using them to force everyone to one way. The goal is to avoid that.
I am new to the world of haskell programming, but I have always been very interested in it and have begun learning it over the past month and a half. I have also been very interested in data science and statistics in general so I am very interested in this project and would like to contribute in any way that could be of help! 
This is available : https://hackage.haskell.org/package/stateWriter-0.2.8/docs/Control-Monad-Trans-RSS-Strict.html
As Spacemacs clone do you means with layers and the default Helm, etc? That would be awesome.
Yes, me too XD
I'm glad for people like Fuuzetsu being one of the reviving forced behind Yi. I use it occasionally. My biggest complaint is the missing comfort in the fuzzy selection extension. I'm just to used to ido-mode and XMonad.Prompt that the currently inferior fuzzy selector makes it hard.
It will be interesting to see if Emacs 25's dynamic native extension support will lead to more native parser integrations (libclang, ghc-src-ext) or my personal preference for Yi or https://github.com/aryx/fork-efuns to become more practically useful. fork-efuns can directly leverage Pfft for access to more parsers that don't need to be written, but Haskell is equally if not more capable to provide a better basis for writing random language parsers for use in an editor.
Yi works but needs some love to soften the usability edges. It builds and works though and doesn't just crash or hang up.
Not really, I’m pretty happy with i3 and there is a clone for wayland so there is little incentive for me to work on a wm. Sorry about that. That said I’d be happy to give you commit access or you could just make your own project based on my code. Let me give you a few points to consider if you want to pickup the codebase: * I think using reflex was a mistake. This is not because reflex is bad but the benefits of FRP are very small if you have only discrete events. This is made worse by the fact that the [wlc](https://github.com/Cloudef/wlc) C library wants to callback into your code so you end up having to convert these callbacks into reflex events. I started [rewriting](https://github.com/cocreature/reactand/tree/mvc) the wm to use [mvc](https://hackage.haskell.org/package/mvc) instead (note that this package has little to do with the mvc you might be used to) which seems a lot simpler for this usecase. * The wlc bindings are also written by me and sadly I’ve also abandoned them. Somebody else has since written their [own set of wlc bindings](https://hackage.haskell.org/package/bindings-wlc) which seem a bit better maintained. Again if you want to pick up my bindings (I haven’t looked too deeply into the other bindings) I’m happy to give you commit access. Godo luck!
Mature data science packages in Haskell would be a great boon for the industry I'm working in. I also think Haskell has a lot to offer for expressing your problems in a more direct style than competitors. (Working with OpenCV in C++ recently reminded me that even simple, higher order functions is a wonderful thing that I've come to take for granted.) One aspect I'd like to see people focus on more is iteration speed. I've worked with IHaskell, but occasionally you need to rebuild the packages you depend on or you have to restart the notebook from scratch and then things quickly devolve into a compilation exercise. Perhaps GHCi could offer a tighter loop if the tools were built around it? I agree with another poster that lack of pretty printing instances and the like (as well as the sheer amount of cruft that you need to import to get started) is also pain point when you're experimenting. In any case, I mostly just wanted to express my appreciation for this effort. I think it's a huge benefit to all of us that there are enthusiastic people inside the community willing to band together in this way and work towards a goal.
Wow, that is a really short dealine...
not on windows ;D
Thanks for the links! I'm going to read them *now*.
The Core indicates that the optimized one is working in terms of unboxed values, whereas the original isn't: a1_s7LB = \ (z_a4FW :: Int) (p_a4FX :: GHC.Ptr.Ptr Word8) (q_a4FY :: GHC.Ptr.Ptr Word8) (eta_B1 [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) -&gt; case z_a4FW of z1_a4FZ { GHC.Types.I# ipv_s7L6 -&gt; case p_a4FX of _ [Occ=Dead] { GHC.Ptr.Ptr ipv1_a4G7 -&gt; case q_a4FY of q1_a4G9 { GHC.Ptr.Ptr ipv2_a4Gd -&gt; case GHC.Prim.tagToEnum# @ Bool (GHC.Prim.eqAddr# ipv1_a4G7 ipv2_a4Gd) of _ [Occ=Dead] { False -&gt; case GHC.Prim.readWord8OffAddr# @ GHC.Prim.RealWorld ipv1_a4G7 0 eta_B1 of _ [Occ=Dead] { (# ipv3_a5qz, ipv4_a5qA #) -&gt; a1_s7LB (GHC.Types.I# (GHC.Prim.+# ipv_s7L6 (GHC.Prim.word2Int# ipv4_a5qA))) (GHC.Ptr.Ptr @ Word8 (GHC.Prim.plusAddr# ipv1_a4G7 1)) q1_a4G9 ipv3_a5qz }; True -&gt; (# eta_B1, z1_a4FZ #) vs $wa1_s7Hu = \ (ww5_s7Hk :: GHC.Prim.Int#) (ww6_s7Ho :: GHC.Prim.Addr#) (ww7_s7Hs :: GHC.Prim.Addr#) (w_s7Hh [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) -&gt; case GHC.Prim.tagToEnum# @ Bool (GHC.Prim.&gt;=# ww5_s7Hk ww4_s7HS) of _ [Occ=Dead] { False -&gt; case GHC.Prim.readWord8OffAddr# @ GHC.Prim.RealWorld (GHC.Prim.plusAddr# ww6_s7Ho ww5_s7Hk) 0 w_s7Hh of _ [Occ=Dead] { (# ipv_a5o5, ipv1_a5o6 #) -&gt; case GHC.Prim.writeWord8OffAddr# @ GHC.Prim.RealWorld (GHC.Prim.plusAddr# ww7_s7Hs ww5_s7Hk) 0 ipv1_a5o6 ipv_a5o5 of s2_a5ot [OS=OneShot] { __DEFAULT -&gt; $wa1_s7Hu (GHC.Prim.+# ww5_s7Hk 1) ww6_s7Ho ww7_s7Hs s2_a5ot } }; True -&gt; (# w_s7Hh, GHC.Tuple.() #) Otherwise they look like the same algorithm to me.
Ideally there shouldn't be. `cabal-install` is currently expected to support GHCs back till at least GHC 7.0. As a data-point, http://matrix.hackage.haskell.org uses `cabal-install-1.22` for building with GHC 7.0.4 (it's not using 1.24 yet, but I'm working on it) If you notice incompats with e.g. `cabal-install-1.24` and GHC 7.0.4, it's currently considered a bug that we'll try our best to fix. I haven't yet noticed ones myself, but I haven't tested it thoroughly enough to say with confidence there aren't.
Since you are using `vector` already, take a look at [hmatrix's Static module](http://hackage.haskell.org/package/hmatrix-0.17.0.2/docs/Numeric-LinearAlgebra-Static.html)
Thanks for hosting so many SF Haskell Meetups! Best wishes!
OK, this might be too late, but from what you've got, my proposal pretty much boils down to changing the kind of `TyCon`: data TyCon (a :: k) instance TestEquality TyCon data TypeRep (a :: k) where TrTyCon :: !Fingerprint -&gt; !(TyCon a) -&gt; TypeRep k -&gt; TypeRep (a :: k) TrApp :: forall k1 k2 (a :: k1 -&gt; k2) (b :: k1). !Fingerprint -&gt; TypeRep (a :: k1 -&gt; k2) -&gt; TypeRep (b :: k1) -&gt; TypeRep (a b) instance TestEquality TypeRep where testEquality (TrTyCon _ tc1 tk1) (TrTyCon _ tc2 tk2) = do Refl &lt;- testEquality tk1 tk2 Refl &lt;- testEquality tc1 tc2 return Refl testEquality (TrApp _ ta1 tb1) (TrApp _ ta2 tb2) = do Refl &lt;- testEquality ta1 ta2 Refl &lt;- testEquality tb1 tb2 return Refl testEquality _ _ = Nothing ...plus allowing some mechanism for generating them: genTyCon :: forall k (a::k). IO (TyCon a) or tycon :: TypeQ -&gt; Q Exp myTyCon1 :: TyCon MyType myTyCon1 = $(tycon[t|MyType|]) myTyCon2 :: TyCon MyType myTyCon2 = $(tycon[t|MyType|]) etc.
I don't think so, but there was a [link](https://www.reddit.com/r/haskell/comments/50iauw/podcast_software_engineering_daily_haskell_in/) to an interview with the same guy and topic in *Software Engineering Daily*.
I agree with /u/alien_at_work about having a proper IDE with import management. One project could be building something like Jupyter but for Haskell with all these features
We might do it! Just come to Slack and propose it! :)
I'm confused, are you at the same time recommending npm model to Haskell and acknowledging that is doesn't even work for node ???
Ah, it looks like you'll need heterogenous equality rather than `TestEquality`.
In general, we're open to the possibility of giving courses on-demand and also remotely. Why don't you send me an email, and then we can explore options?
I think GHC had HashTables before version 7.0, link: https://downloads.haskell.org/~ghc/6.0/docs/html/base/Data.HashTable.html
Yes, and I have used it, but there is no import management. It feels like writing Python on Haskell sometimes
I'm not usually a prescriptivist when it comes to words, but if we are going to let everything lose its meaning, we can no longer have sensible conversations. 
Brilliant, I didn't know about Github Pages. I used the `master/docs` method and it's working now. :-)
Ew, ugly. Looks OK to me on Firefox and Chrome on a Mac, Edge on a phone and Chrome and Safari on an iPad. Maybe you can use another user agent?
The discussion was moved to https://www.reddit.com/r/haskell/comments/50mhru/backpack_and_separate_compilation/
&gt; "Haskell has a higher initial price tag but lower total-cost-of-ownership." even the Pointy-Haired Boss will understand this one.
Makes sense—we want to prevent the scenario you describe. Here's an idea: overall, GHC and the PVP should ensure private dependencies can't leak, no matter what Cabal picks—adding a public dependency should be a breaking change re PVP for packages opting in. Here's a conservative check that I conjecture works. Let's take again the current example from upthread. A depends on B publicly and P privately, and this works, but a new version of B depends on P publicly. Let's ensure this is an API change in the PVP sense, so that A won't use the new B until the combination is tested. 1. GHC could learn what private dependencies are, and could ensure they don't leak through the interface. But what about public dependencies (above, B)? They'd also need an explicit interface that encapsulates their API and prevents further dependencies from leaking. If any public dependency of A lacks such an interface, you can't have any private dependencies. 2. The new version of B with a new public dependency doesn't conform to the same explicit interface. So an (amended) PVP would require a version bump. We could also change the PVP to require a version bump whenever you add a non-private dependency, but I assume this is too restrictive; but we can say packages specifying an interface are opting in to this new regime. Moreover, once you have an explicit interface, it seems any additional dependency must be private unless it actually adds to the API. (This might in fact be true without explicit interfaces, not sure). Positive: - beyond solving the problem, I like tying the PVP with actual interfaces, getting a statically typed PVP. Negative: - this might require more maintenance work for dependencies. In an ideal work with tool support for automating the task, this would mean tool support would need to do more. In today's work, the extra restrictions might be unacceptable. - this might also require more version breaks and introduce more compile errors. And that's only if you use private dependencies, even though it'd be good to encourage them.
Yeah, it's definitely still being worked on, I just don't often see people talking about it.
Well, the package name is terrible!