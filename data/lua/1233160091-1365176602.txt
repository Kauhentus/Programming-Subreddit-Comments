Well, I hope they don't name it mod_luau. Ugly.
The library described in the paper was released [here](http://luaforge.net/projects/luaproc/).
Is there a page with more info on the new mod_lua? It looks like there's some docs in svn but that's all I've found.
apache 2.4 still has quite some way to go I suppose...
This is awesome. I was about to build the same thing, but I think I'll just contribute to this instead. It might be nice to add a more idiomatic Lua layer on top, too. I'm not saying I know what it looks like, but I just have a feeling that it could make things really elegant.
Small, like Lua! Bad joke... I know. Maybe a series of blags or something would help? I think people who use Lua are generally doing things their own way, since it's such a flexible language that tends to get crammed into odd spaces.
Here's an idea -- I'm a relative lua noob. Why not post a series of introductory Lua tutorials to this subreddit, then make a post to proggit saying "Wanna learn Lua? Now's yer chance." and link it to r/lua. I think it'd be a great way to both engage those of us who are here and bring in some fresh blood!
I've been posting links as I run across them. I'd post more, but I don't run across good ones all that often. I'm expecting that anyone reading this subreddit is familiar with the [Lua wiki](http://lua-users.org/wiki/), so if is already there (and easy to find) then I won't post it here. Though if there is a juicy bit posted on the mailing list, I may post the link here too. I've been [blogging](http://partiallyappliedlife.blogspot.com) about Lua a bit. For example, [Resource Cleanup in Lua](http://partiallyappliedlife.blogspot.com/2009/08/resource-cleanup-in-lua.html) is an article with some examples on how to use John Belmonte's scope() function. I've also been slowly working my way through Haskell's Data.List library, and implementing the useful functions in Lua. I'm quite pleased so far with how the code is turning out. Maybe not as terse as Haskell (no point-free notation in Lua), but my versions are ending up to be fairly concise none the less. It is a credit to the Scheme-like nature of Lua.
I'll admit I'm connected with the project, but since the Lua subreddit is calling for interesting links, I figured I'd chime in.
That's entirely fine. I'm of the general opinion that you're allowed to post about your own work here as long as it's actually your work, and it's [at least somewhat] interesting, and this seems to fit the bill.
&gt;Why not post a series of introductory Lua tutorials to this subreddit, then make a post to proggit saying "Wanna learn Lua? Now's yer chance." and link it to r/lua. I think it'd be a cool idea, though I don't have much time these days to write tutorials (maybe over Christmas). ansible seems like the dude to talk to, though.
No need to write them -- I'm sure there are plenty of good introductory materials out there already. You'd only need to hunt a few down and post them here.
After reading this piece I have decided to completely open source my application server the next release (as opposed to mostly open source). He makes a great point about the broken IP system and patents that can send you into litigation hell. My app server uses Lua for scripting so I am definitely going to try the JIT, performance of Lua is quite good for a scripting language, but JIT will make it even better.
I'm an embedded developer too, so it is definitely of interest in my line of work.
It's a great project. but it really needs good documentation. I can't stress this enough.
Hey thanks for the link to your blog. You have some interesting stuff there. I've just started playing with lua a bit.
This is a fantastic post, but I think it's already been on Proggit two or three times in the last week.
[List of changes](http://luajit.org/changes.html)
I don't have enough experience in Lua to answer that, but I'd be interested to hear from somebody who does.
Yeah, it's an issue to be concerned about. In general, the programmer is injecting an unknown amount of other stuff into the global namespace every time a module is imported. As long as all the modules are well-behaved, it probably won't be an issue in practice. But if one module redefines a global function, then you can have all kinds of exciting bugs crop up. And by 'exciting' I mean unpleasant and nasty. There's no harm in just doing what the wiki article prescribes with putting all the public API functions in the 'M' or '_M' table and returning that. When there is a nicer syntax for that later you can switch over to it. And that won't change how you use modules with something like 'local foo = require "foo"'.
The [tutorial](http://luaforge.net/docman/view.php/505/5768/LuaPiTut.pdf) ([gview link](http://docs.google.com/viewer?url=http%3A%2F%2Fhasthebailoutfixedtheeconomy.110mb.com%2FLuaPiTut.pdf)) is pretty interesting.
I am by no means an expert on lua, but even in my limited experience the module function is a bit unnerving and has caused me a fair bit of grief in naive implementations. I've since found methods that work but they feel kludgey and no where near as robust as other languages package management functions. There's also the issue of modules written by other people using a different standard and causing odd behavior.
(Take note that I don't really do webdev, I do physics research. Totally opposite disciplines there. I thought it'd be helpful to list the major projects, though.) [Orbit](http://orbit.luaforge.net/) is the major (only?) lua web development framework. It's part of the [Kepler Project](http://keplerproject.org/), which has good parts and bad parts. There's a discussion about Kepler [here](http://www.reddit.com/r/programming/comments/6o234/kepler_11_is_out_a_luabased_web_development/), and I think I'll defer to that. [LuaRocks](http://luaforge.net/projects/luarocks/) is kind of a port of RubyGems. Aside from Kepler, there's work done by ezombie aka Stefan Peters, which includes [luapgsql](http://wiki.github.com/STPeters/luapgsql) and [luafcgid](http://wiki.github.com/STPeters/luafcgid). They're intended to be light and fast, though if you don't use Postgres they're not really an option. I think you could use luapgsql to replace luasql in a Kepler application so as to cover Kepler's most obvious deficiency, though. Also, it's used for web development in embedded systems--that web page that you configure your router with could well be [lua server pages](http://barracudaserver.com/Lua-Server-Pages.html) or [LuCI](http://luci.freifunk-halle.net/). lighttpd integrates [mod_magnet](http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs:ModMagnet), which isn't strictly web development but *is* [pretty useful](http://redmine.lighttpd.net/wiki/1/AbsoLUAtion). 
This is really a very nice library. Many thanks to Alexandre Becoulet and everyone else who contributed to its creation.
Thanks for taking the time to respond even though our disciplines are not the same. Thanks for the link to the discussion Kepler - I was aware the project existed but that kind of candid conversation is really what I was looking for. I wasn't really thrilled by what I saw and the feedback there seems to kind of close off that particular avenue. Maybe I should roll my own - I wrote a framework in PHP once but it wasn't super great. I have used MySQL in the past but am migrating current projects to Postgres and all future projects planned will be in Postgres also. However, I wouldn't be super comfortable being locked into a single RDBMS even though it is currently the one I choose. I will keep looking and researching, but at this point it doesn't look like there are mature libraries in place...
Embedding. I've embedded it in my norton commander clone (linux+windows) and I use it to drive my classic CRPG (Ultima IV cross with Pool of Radiance).
I use it to burn up a decent workday or two and most of a weekend trying to cram it into an existing iPhone app, first with a custom Lua&lt;-&gt;ObjC bridge framework (I got pretty close, actually) and then with iPhone Wax. Sorry, it was a rough few days of hacking.
Text processing powers!
atara_x_ia wrote a lot that I might have said. Also, there was some previous [discussion of Kepler on Proggit](http://www.reddit.com/r/programming/comments/6o234/kepler_11_is_out_a_luabased_web_development/). In particular, MarshallBananna was not at all happy with the current state of luasql, and resistance to SQL injection attack. I haven't investigated luapgsql, but I assume it is better in that regard. We're using LuCI for an embedded project. The documentation is far from complete, which has slowed us down some. However, there isn't much else we could use on our platform. That's coming along though, and maybe we'll end up creating a tutorial out of our experience. As a general comment, if you've got performance problems with an existing web framework, Your time might be better spent on just trying to fix that, rather than bring Lua into the mix. Maybe you can add in some caching, optimize the SQL, etc. As a last resort you can also look into Psyco or something like that. I think Lua is a fantastic language. But it is not a premier web development platform. At least not yet. I might try it for a small-scale experiment project, but I wouldn't choose it for a production website.
I use it for personal programming projects in AI and functional programming. We're also using it at work for embedded scripting (ARM-based systems).
Scripting games: I embedded it in the [Playground SDK](https://developer.playfirst.com), which is primarily used for writing casual games. Mostly people tell me that they love using Lua to write their games; a minority are set in their ways and go to great lengths to avoid using Lua, though, which always boggles me.
A web application (survey tool - including homegrown database), and related code to output nice data from that.
In my experience with Lua, if [Rici](http://lua-users.org/wiki/RiciLake) thinks it's a good idea then it is.
Hi - I'm also new to Lua but love what I see so far. In order to learn Lua I'm rolling my own framework and whilst it is still very early days I've not come across any significant stumbling blocks.
Interesting. Like some of the other approaches, it uses Lua bytecode, and the interpreter is written in Java. I'd like to see someone try compiling to JVM byte code, which you'd think would be somewhat faster. For those that don't follow the mailing list, [here's the start of the thread on lua-users](http://news.gmane.org/find-root.php?message_id=%3cA19E8247%2d4F12%2d44A7%2d8198%2dDFE4DDB40D6C%40ravenbrook.com%3e).
FWIW, here are the competing .Net implementations: Lua bytecode, with .net interpreter, like jillcode http://luaforge.net/projects/luainterface/ Lua compiler to CLR bytecode http://www.lua.inf.puc-rio.br/luanet/lua2il/ (discontinued?) 
yep, now that i think about it, i havent seen many blogs on lua... perhaps a couple, but not a whole lot that i know of
Like you (presumably) I've always found Rici's opinions informative and intelligent. However I haven't heard from him in in a long time. His homepage has been off line as well lately.
I think most people who strive for a clean design of their code hate the fact that `package.seeall` makes your module tables shadow the entire global state. I sure did when I first learned about it. Nowadays I explicitly import any dependencies in locals and then seal off my environment using `module((...))` without `package.seeall`. Another solution is to separate module environments from module tables, but that requires another table for each module, which I personally wouldn't mind but probably won't be incorporated into the built-in `module()` function anytime soon...
 Rici is still around from what I hear. I have some friends that work at Google. I heard Rici also works there and that they've been keeping him very busy. 
Looks interesting. Anybody has experience with this and can chime in?
I haven't personally used it, mainly because I'm using Lua on embedded devices where RAM is a at a premium. This said, I've not heard anything bad about Penlight. To me, it falls somewhat short of being "Batteries Included" because it's mainly adding language/data structure features. Python's standard library does a lot of additional integration with facilities provided by various C libraries (some included with python, some provided by the OS). I think I would use Lua more in a desktop context if it weren't necessary to download so many dependencies. OTOH, if those things were standard they would be a pain for embedded (no-OS) targets, and Lua would be bigger. What might be nice would be a standard Lua "Extras" that included this type of functionality.
Thanks.
&gt; For various legal and administrative reasons I cannot accept funds from individuals. That's a pity. :(
I still hope they decide not to remove set/getfenv(). in ENV would be a worthy addition, but not at all a replacement.
hmm I was hoping for some more syntactic sugar like "x += 3" and its friends. :( I also don't think adding a bit library is a good thing when 99% of the time the default type is a double. 
Yeah, if you follow the thread, Mike Pall had a few not-so-nice things to say about the implementation. Here's his approach for dealing with that situation: http://bitop.luajit.org/semantics.html I don't know what they did for the 5.2 alpha, but bitop requires double-precision floats to work with floating point types, and does a conversion to an integer based on having enough precision in the double type (53 bits). I'd say that still feels a bit odd though.
I suppose we could suggest they redirect the forum users to /r/lua, too.
ah yes sry about that, first timer here
What's the pros / cons of IUP vs. wxLua?
IMHO IUP was built with Lua in mind while wxLua was made as a lib for wxWidgets. I personally find that getting a GUI up and running with IUP is so much easier than wxLua.
Anyone know how this compares to Luaj?
Brilliant! It sounds like it is influenced by emacs, but using lua instead of elisp.
We've implemented something pretty much like Python's module system - you import modules, modules go in their own namespace, you can explicitly pull symbols from a namespace into your own. It works very well, no global pollution, easy to see dependencies.
I've gotta say, as much as proggit hates on blogs, sometimes it'd be nice to have some more lua discussion. I kinda wish the comment threads 'round these parts were more... existent. Because, in the end, even if a lot of it is people saying random stuff that doesn't matter, that stuff that doesn't matter can lead to useful discussion. Hell, that's the entire *premise* of reddit, and that's why it works despite the puns. I think that's kind of what's missing from lua-l and Lua in general, which is kinda funny. Remember how scientists discovered that junk DNA was useful even though it didn't code anything? 'course, I'm high, so let there be grains of salt.
I would be content to more posts in /r/lua
Are you allowed to describe your embedded scripting soft in more details?
I can't describe things in much detail. Mainly, we wanted a high level programming language that would fit on small platforms. Many of the systems we develop for have very limited RAM and Flash for storage. So bringing in something like Python or Ruby is not feasible. We're using Lua for high-level application control, as well as command language parsing, system configuration, and more. Lua fits into these requirements better than anything else available, and has good performance to boot. I find it a pleasure to write code with Lua.
I'd like to see Google up there too. Especially since they sponsored Mike Pall's LuaJIT project.
I hope Lua doesn't get all bloated and subsequently worthless like Perl, which used to be a nice little text processing language.
oh shutup
Originally submitted to [Proggit](http://www.reddit.com/r/programming/comments/be0iz/potential_lua_implementation_for_guile/), thought it might be relevant here as well.
I first got interested in FRP from my Haskell days, so it was nice to see someone doing it for Lua too. Haskell links: [Yampa](http://www.haskell.org/yampa/), [Field Trip](http://haskell.org/haskellwiki/FieldTrip), [Reactive](http://haskell.org/haskellwiki/Reactive).
The original post is a little old, does anyone know if the author has any released code ?
Well, some people on the Guile list seem to think it is a good idea, but I don't really get the point. Lua already provides great support for the developer to embed it into another C or C++ project. The standard interpreter is plenty fast enough for most applications, and you've got the phenom work done by the LuaJIT folks if you need even more speed. AFAICS, Guile is a decent Scheme implementation, and it is easier to embed than the many, many other Scheme implementations out there. But if you want Lua, just use Lua. If they want easier interop between Lua and Guile... well, that's a head scratcher.
There is very little chance of that happening. The Lua guys (RI, LHF, WC) are good engineers, not just good academics. They are all very committed to keeping the core language and libraries as small and portable as possible. You can look at the way new features are hashed out on the mailing list.
For what it's worth, you can probably still pull it off with [bin2c](http://lua-users.org/wiki/BinToCee) but it's a serious risk now.
bin2c is definitely not allowed. ಠ_ಠ
Steve hates developers.
For anyone interested, there was considerable discussion of this on the [mailing list](http://thread.gmane.org/gmane.comp.lang.lua.general/64711/focus=64720).
If only Lua has built in support for unicode... (and lpeg supported unicode)
I wonder if that's really a critical item for inclusion in certain games. Do any of the games like WoW handle unicode w/ Lua? I don't know if it's an amazing thing for Lua or not, it certainly reinforces the value of its use in triple-A gaming titles if it happens.
Lua is used in World of Warcraft so its hardly a newcomer to major games.
lpeg matches bytestrings to bytestrings so it could work just as well with UTF-8. There may be a few edge cases I'm forgetting, though. The main hassles with Lua and unicode that spring to mind are string literals and string indexing.
http://en.wikipedia.org/wiki/Category:Lua-scripted_video_games ^should give some idea of how ubiquitous it really is.
Have you found it to need optimizing?
The interpreter touches a lot of diverse RAM which is fine on x86, because those processors come with a lot of cache memory. Mostly because of this, when you run Lua on a console I've found it to be about four times slower than on the PC even though processor clock frequency is comparable. We execute enough Lua per frame for this to be a significant impact. (Other reasons are 1) consoles can't pipeline as well because they are in-order, 2) consoles have poor branch prediction hardware.)
This is REALLY neat, thanks :D
Google progresses with NaCl, its system to safely run native code in the browser. Not only can it run the Lua interpreter, but they already did the porting! Porting LuaJIT will probably prove tricky, if not impossible, but it's already closer than most would have expected possible to Lua on web apps' client side. 
Yes, but can you run NaCl in NaCl?
I demand a walkthrough.
I wonder about this. I've not dug through NaCL to understand what additional constraints they impose on processes, but it might not be that tricky?
For more detailed information on Lua 5.2, see [A look at Lua 5.2-work3](http://www.corsix.org/content/look-lua-52-work3).
I've downloaded it, but haven't used it much, yet. I'm interested in how the new environment setting can help with safely running code in a sandbox.
There's some ASM code checking in NaCl, and they had to patch GCC code generator to make it produce code which passes the code checker. LuaJIT has parts of its interpreter written in custom ASM, and of course the JIT produces ASM code on the fly. Therefore it's unlikely to be recognized as valid by NaCl ASM checker.
I am waiting for the official release. I would love some added functionalities in the spirit of the addition of the bit lib.
If ipairs is really so much slower than a numeric for loop that they are deprecating it, I think they should perhaps bite the bullet and separate tables and arrays into separate types. They aren't the same, it's costly on performance, and it complicates the C implementation of tables.
The new environment rules don't really provide any new features (you could already create sandboxes with setfenv). Rather, I think they are making the changes for future performance reasons. From what I've been given to understand, most people that were using setfenv were using to emulate Python-style imports. For that, the new implementation is sufficient.
NO NO NO pls dont take the Lua tables away!
Right, um, I'm not suggesting anyone take Lua tables away. I'm suggesting that the metaphor that arrays are just tables with numeric indices perhaps doesn't 100% work out in practice, and that we should consider adding an array type.
I don't think creating a new array basic type is the best solution. For me, one of the defining features of Lua is that it has only one built-in data structure, which can be used for nearly anything. The main issue with ipairs() is really that there are conflicting notions of length. And what should happen in the presence of a hole (an index with 'nil' value). Once there is a clearer consensus about that, I think everything will settle down. At any rate, it is easy enough to write a pure-Lua replacement for ipairs(). I've run into a slight hiccup with this though, which I'll be discussing on the mailing list. Edit: Just for hysterical reference, [this is the native-Lua code version of ipairs\(\) for Lua 5.2](http://article.gmane.org/gmane.comp.lang.lua.general/66009).
Don't get me wrong. Overall, I think the array-is-table metaphor works pretty well. Off the top of my head, there are two issues with conflating table and arrays: * Conflating tables and arrays comes with a performance overhead because of extra branching, memory space overhead and an extra memory touch. * The user has to know and specify whether the table is an array or not when she wants to iterate the container (using ipairs/pairs). Separating the two would allow python-style for loops, eg: for i, v in array_var do &gt; And what should happen in the presence of a hole (an index with 'nil' value) Even with Lua's currently very weak guarantees, it's surprisingly hard to come up with an efficient implementation of the table length operator because of this.
Looks like they've had some sort of Lua API for a bit, however what's new here is that it's now more general purpose? Anyone have any luck trying this out on OS X? It doesn't seem to show up in the UI anywhere even with the latest nightly builds..
As long as the array has a metatable I'd be fine with it.
[tolua++](http://www.codenix.com/~tolua/) works pretty well, although it can barf on complex template types - it is not a true c++ parser. I [managed to bind](http://irrlua.sourceforge.net/) most of the [Irrlicht rendering engine](http://irrlicht.sourceforge.net/) using it. 
Sweet!
Great! Lua needed something like that. :) Bare in mind the Lua colors are blue, white, grey. Pink/Magenta seems to work though ;)
so cute
I started looking into Prosody because someone was talking about high memory consumption for XMPP servers, like 200Mbytes minimum (apparently at startup?). I'm not deeply familiar with the protocol, but that seemed really high to me. So I started looking around and found Prosody. Looks neat so far, but I haven't really dug into it yet to see how well it works. It is impressive that it is being used by xmpp.org.
I'm just starting (read: Actually doing more than a "Hello World" program) programming for the first time since I sat down and thought I could teach myself C++ overnight. I've been having a lot of fun with Lua because it was easy to pickup and seems to do everything I would want it to do. I see the power of the language and was very surprised to see that there wasn't a mass of comments going on about Lua. I remember the Ruby hype that went on forever (might still be), and was just surprised to see the Lua community appear nearly dead because no one was posting anything. Oh well, work tomorrow. G2G
And in case you don't subscribe to the mailing list, Pete has created [Semantic highlighting for Lua in Vim](http://peterodding.com/code/vim/lua-inspect/). There is some assembly required at this point, but it is worth a try if you like this sort of thing. Have fun!
Here is from a quick google: http://www.tecgraf.puc-rio.br/iup/ (IUP) http://www.tecgraf.puc-rio.br/~celes/tklua/ (TK) http://lua-fltk.sourceforge.net/ (FLTK) Now, none of these specifically target OS X, but these are portable libraries, and should work on it.
&gt; I'd like to write programs (including a GUI) for both Windows and MacOSX using LUA. wxWidgets is probably your best bet for cross-platform UIs. It's also the most simple of the UI toolkits. Outside of that, you've got GTK and Qt. You can also go the route of a JVM-based Lua and harness the many libraries provided by the JDK to create a UI. The choice of which route to go will depend on what your goals ultimately are. &gt; The more capabilities that interact with the operating system itself the better. For all functionality outside of wxWidgets, you're going to have to find libraries that provide them. [LuaForge.net](http://luaforge.net) is the primary central location for many libraries. If you're on Windows, get [Lua for Windows](http://code.google.com/p/luaforwindows/) as it provides many of the most common libraries, including wxWidget. It also has quite a few examples of the various libraries. In order to actually get going, you're going to have to learn to read documentation. Start with wxWidget and making basic windows, then build up from that. You're not going to hack together an app as fast as you'd like without any prior UI programming knowledge. Sorry--you gotta' start small like everyone else.
Interesting. I tried playing with wxLua in the past, but found that getting it going on Mac OS X 10.6 was not quite fully baked (something to do w/ 32/64-bit and/or whether it was using Carbon or Cocoa), or at least easy to get going. I believe it works if one builds out a 32-bit only Lua, and various dependencies. I'd never thought about using Lua on the JVM though. I suppose there are a few Lua for JVM implementations out there. Do any provide a fairly lua-esque interface for doing GUIs? Also, has anyone out there built any Lua apps using any of these GUI frameworks? I get the sense that there are plenty of applications out there that have a GUI and include Lua, but not a whole lot that drive the GUI using Lua.
I've not worked with Lua on OSX, but I've seen various scripted wxWidget apps on OSX work just fine--so that was kinda' an assumption on my part. Didn't even think about the whole 32/64-bit split. &gt; Do any provide a fairly lua-esque interface for doing GUIs? I don't think there are any Lua-fied JVM UI libraries. From the looks of it, Khalua/LuaJ just provide access to the JVM and nothing more. The reason I've mentioned wxWidget to the OP is I've seen many example wxWidget Lua projects (via Lua for Windows) and they look quite native and powerful. There's a full text editor with tabs and syntax highlighting written in Lua in the example code; it's quite impressive for the amount of code that went into it. Actually, found [the source code][editor]. [editor]: http://www.koders.com/lua/fid8C113F9F80EA1C645BE2A66295772D6DFE1642AC.aspx
Let me enforce the iuplua movement :)
Neat. Thanks! I'm going to check up on what the state of wx, Lua &amp; OS X are shortly. wx has certainly been nice to work with under Python in the past.
Well, you might take a look at http://www.murga-projects.com/murgaLua/index.html which contains an fltk binding for a gui, and a whole lot more (basic cryptography, sqlite, luasocket, xml parsing, some windows specific stuff, interfacing to libraries with alien, audio, ... ), and everything packs into a +- 500Kb executable. The most recent beta you can find here: http://jpjacobs.ulyssis.org/progs/murgaLua-snapshot.tar.gz
Thanks for posting a link to my plug-in. Since that mailing list post I've published [a number of bug fixes and improvements](http://www.vim.org/scripts/script.php?script_id=3169). The latest download on that page (version 0.4) is a self contained ZIP archive which you can just unzip in your `~/.vim` directory (`%USERPROFILE%\vimfiles` on Windows) to install the plug-in and its dependencies (so no more assembly required).
mmm, iup.
There was [a post by lhf](http://marc.info/?l=lua-l&amp;m=128221976616701&amp;w=2) on the mailing list recently (2010-08-19) about planned downtime: &gt; Pepperfish is moving their servers later today and Lua.org will probably be down for a short while. If you cannot reach lua.org, try the mirror site: &gt; http://www.tecgraf.puc-rio.br/lua/mirror/ &gt; We're sorry for the inconvenience. &gt; --lhf I suppose this is related.
It's unrelated because the mailing list is hosted at Conectiva. The Lua folks at PUC Rio are aware of the situation, it's now mentioned on [lua.org](http://www.lua.org/lua-l.html). I guess we just have to wait a bit.
Okay thanks for the correction. Indeed I wasn't sure whether it was related but it seemed such a coincidence that lua.org, lua-users.org and lua-l all have connectivity problems in the last two weeks (I haven't had a reliable connection to lua-users.org since the Pepperfish server migration).
Thanks, man! I was just thinking about making my own Lua live-coding environment, and - viola! - here it is. Planning on playing around with it and modifying it for 2D/Cairo drawing.
We used Lua on the first Mercenaries (for PlayStation 2 and Xbox). The main use was as a scripting language for mission flow, and high level game flow. That in itself is not very CPU intensive, and even then we were careful to avoid giving lua a per-frame update. Everything in our mission scripts were call back based. That is, the scripts would do things like ask the C++ side to "tell me when the player had died". So, in a sense, our main optimization was to not use lua in constant runtime situations. The other two optimizations I can think of are 1) we recompiled lua to use floats rather than doubles. and 2) we attached lua to a custom "small memory allocator", which was separate from the game's main memory manager.
Zed mentions a problem with coroutines being able to scale up. The obvious solution is to serialize them, but he says that this apparently doesn't work. [Pluto](http://lua-users.org/wiki/PlutoLibrary) can [allegedly](http://forum.unity3d.com/threads/26199-Saving-and-loading-a-coroutine-state?p=172329&amp;viewfull=1#post172329) do this now. Has any one else tried this? What might the problems be? Is it possible to serialize a coroutine, and then load it up in another Lua state? Can this be done with [Lua Lanes](http://kotisivu.dnainternet.net/askok/bin/lanes/index.html)?
I'm not really sure what to make of this. If this isn't a fluke, it represents a major change in policy for Apple. Here's to hoping they'll allow more like this.
Yes. There was a major change a while back. They decided to open up iOS development to any language that you care to make work on the platform. That includes Lua, Smalltalk, Scheme, C#, etc. so far.
With the caveat that the code isn't downloaded. 
Right: 3.3.2 An Application may not download or install executable code. Interpreted code may only be used in an Application if all scripts, code and interpreters are packaged in the Application and not downloaded. The only exception to the foregoing is scripts and code downloaded and run by Apple’s built-in WebKit framework.
Lua is designed as an embedded language and lacks access into the OS unless exposed by the execution engine. This is ideal when letting people run whatever code they want. Many MMOs are using Lua as a script to allow custom client side behavior and UI and it has worked great. I think the worst case scenario the CPU is maxed out on the iPhone either due to bad code or overuse of the memory (it is GC based). The best part of lua is that the script can be executed as a coroutine (a lightweight thread that can be limited in how much it can consume). Lua is a great little language for devices really.
Here's something similar though more extensive [Lua Short Reference](http://lua-users.org/wiki/LuaShortReference)
Last time I looked at Love it was really primitive. The new physics engine and particle system are a blast. I started playing around with it last night, and my 10 year old came over and started directing. "OK, give that a laser beam. No, it's gotta come from his forehead. Cool! Now make it break boxes. No, it's gotta go through all of them. Let's get a better explosion sound. Can you make it so if you 'butt stomp' the ground all the boxes go flying around? We should be able to butt stomp boxes, too." So on and so forth. About an hour of coding and searching online for free sounds and sprites, and we'd created "Box Stomper" (which barely qualifies as a game, but it *does* have [StrongBad](http://www.homestarrunner.com/sbemail94.html) blowing shit up with a forehead laser). Fun stuff. 
I found the code interesting, though I don't usually want to do currying in that style. Note that the reverse arguments function isn't terribly efficient because there is a lot of closure creation. People may not realize this, but unpack() takes index arguments, you can do something like this instead: function reverse(tbl, force_length) local new_tbl = {} local tbl_len = force_length or #tbl if not tbl then return nil end for i = 1, tbl_len do new_tbl[tbl_len + 1 - i] = tbl[i] end return new_tbl end function reverse_args(...) local n = select('#', ...) return unpack(reverse({...}, n), 1, n) end So that can handle the case where some arguments are nil at the beginning, middle, or end of the argument list. This is part of the functional library for Lua I'm working on. Edit: minor code fix.
i don't understand his rant. he bashes the common curry1/curry implementation because it's a closure, and then writes a bunch of bloated code and hides his closure wrapping in the argtrace function -- he's still building up a huge nested closure. what's so special about it?
Give me REAL link. Not just screen-shot.
http://www.lua.org/demo.html
Very neat. It would also be cool to be able to tie something like this in with tab autocompletion.
Looks nice. I know it's only small, but it would be great if you could add a license (MIT?) so people know what terms they may use it under.
Well, it doesn't look so interactive.
Oh, yea. Oops. You are quite right. At least it's web-based...? :P
It sorely needs some kind of guided tutorial. In most REPLs I can do things like: &gt; 1 + 1 And I'll see the result "2" printed. But Lua doesn't work like that, so I think most people would be at a loss.
I remember when I first looked at logo, I had already used Lisp extensively. So, I sat down &amp; started a Logo instance: &gt; ? 1 + 1 &gt; You don't say what to do with '2' Couldn't you, just, y'know, print that '2'? I've always felt the same way about Lua; I don't think it would change the semantics of the language for the worse, and it would only require a few top-level changes, for what I think would be a great addition wrt experimentation. Just my $0.02. 
Yeah, I'm not sure if there is any deep underlying reason why expressions can't be evaluated that way. In my Lua REPLs I've simply added an implicit "return " to the beginning of certain expressions read from the prompt.
&gt; Yeah, I'm not sure if there is any deep underlying reason why expressions can't be evaluated that way. I've never seen one expressed, though there might be some reason. As a heavy Scheme programmer (and user of quite a few REPLs), I don't see any reason not to though. &gt; In my Lua REPLs I've simply added an implicit "return " to the beginning of certain expressions read from the prompt. That's a good idea, though I'm loathe to modify anything more than I have to, since I use Lua under somewhat silly constraints, and would have to "prove" that my changes didn't break anything that we're relying on (even though I'm the only one who uses Lua). 
 ... attempt to call global 'setmetatable' (a nil value) &gt; for i,v in pairs (_G) do print (i,v) end bad argument #1 to 'pairs' (table expected, got nil) &gt; wtf = true nil &gt; print(wtf == true) true 
_G now returns the sand boxed environment. setmetatable is not provided in the sand box.
 &gt;for i,v in pairs(_G) do print(i,v) end string table: 0x81c297e0 xpcall function: 0x7d4c9b00 tostring function: 0x7d4c9aa0 print function: 0x81c29700 unpack function: 0x7d4c9b40 math table: 0x81c29920 pcall function: 0x7d4c99a0 type function: 0x7d4c96c0 pairs function: 0x7d4c9c80 next function: 0x7d4c9840 select function: 0x7d4c9b80 assert function: 0x7d4c9740 ipairs function: 0x7d4c9d60 _G table: 0x81c29800 table table: 0x81c295e0 coroutine table: 0x81c298e0 _VERSION Lua 5.1 error function: 0x7d4c9400 tonumber function: 0x7d4c9460 &gt; sweet thanks
It's true; you'll want to type &gt; =1 + 1 instead.
Is setmetatable dangerous? Oh, I suppose if you can setmetatable on things that mediate access between the sandbox and the rest of the world...
This needs a library that allows manipulation of the current page's DOM. It would be awesome to get access to a canvas tag, for example. That probably needs browser support though. Maybe you can do some javascript interop to make it work, who knows. I'm thinking lua implemented in javascript would be painfully slow though.
 You should be able to implement a sandboxed setmetatable that checks what they are setting, and then call the original setmetatable if it's OK.
Maybe something akin to JSONP? Return Lua's data in Padded JSON, and have hooks on the web page to access this data (canvas tag, "terminal output" div, whatever). Might be interesting.
That may not have been part of calminfenro's "minimal viable product", though. The E and Joule and Caja and KeyKOS folks have spent some time figuring out how to implement things like setmetatable in a deeply sandboxed environment (where every object is a separate sandbox, in fact.) I think there are basically two approaches they came up with, although someone should probably go read the papers. Approach #1 is "brands": when you create an object, the object is "branded" with the name of its maker. The maker object has the power to do things like setmetatable on the object, and as long as you don't let a reference to the maker of your object slip into the sandbox, nobody in the sandbox can setmetatable your object. Things inside the sandbox can magic up their own makers so that they can create objects and setmetatable the objects they created, but not the objects from other makers. In Lua, perhaps each sandbox would have a separate getmetatable and setmetatable, and they could only get and set the metatable for objects created inside that sandbox. Approach #2 is "facets": when you create an object, you receive references to a public facet and a private facet. The public facet allows you to do things like call methods on the object; the private facet allows you to do more intrusive things. This more or less mirrors the Lua distinction between the "normal" interface and the metatable. Of course you can combine the two approaches — perhaps what the maker object gives you is merely access to the private facet — but it's not necessary.
[W7](http://fare.tunes.org/tmp/emergent/secureos.htm) is a neat idea also; I've implemented it in my Scheme-dialect, and am quite fond of it in general.
What's your Scheme-dialect called? Is it documented in English or at least in German?
It's called Digamma; I've not yet made a public release, but I've a small [blog](http://corescheme.blogspot.com) about it where I infrequently post. I'm hoping to get everything together &amp; get permission to release in the first quarter of 2011. 
It looks exciting! Good luck!
Thanks. It's been quite a bit of fun, as well as enlightening (like when you discover a bug in the reader, and you're working on a major project :D). Luckily, the main C interpreter has been stable for some time, as has the restricted compiler. I'm working on a full compiler as well as a JIT'd interpreter, so I've my hands full. Totally fun though.
I've gone ahead and add {get,set}metatable to the sandbox. I don't think it will have any side effects but we will see.
&gt; =1+1 Try These: http://lua-users.org/wiki/TutorialDirectory
Now with examples! If anyone is interested, I just added all the examples from the official Lua demo to trylua.org. Clicking on the various examples populate the interactive console.
This is quite improved from the 0.5.0 versions I was bitching and moaning about.
This is just a quick ping... you are aware of the __metatable key that you can put in an object's metatable, and that will prevent anyone else from changing that object's metatable, right?
The lua code that runs the sandbox is not a long running process, it remembers state based on a db backend. You can only break your own session. Refreshing the page creates a new session every time.
I love LOVE. Yeah, my jokes are that hokey.
I make LÖVE. (seriously, I do)
It's a fun little game engine system. I've started messing around with my take on a RTS-type game. What even made it possible is that LÖVE bundles in a bunch of functionality. If I'd had to integrate my own physics engine (for example) I'd never have even started the project... I just don't have that kind of free time.
Thanks for the framebuffers. I can't wait to play around with them!
Hi Reddit! I've just published the first release of [LXSH](http://peterodding.com/code/lua/lxsh/), a library of lexers and syntax highlighters for Lua and C source code. The syntax highlighters generate HTML designed to be easily embedded in web pages, support three color schemes out of the box and transform standard library identifiers into documentation hyper links. For installation instructions (including a rockspec) and downloads please see [the homepage](http://peterodding.com/code/lua/lxsh/) or [GitHub project](https://github.com/xolox/lua-lxsh). If you're curious what the generated HTML looks like please see the introductory paragraph on the homepage or GitHub project page for examples.
LuaJIT for ARM? Wow, if it could be used with Corona SDK or Android then it has a huge potential. FFI looks fantastic, too. Too bad it won't be available to standard Lua, since it is implemented in the compiler. Mike Pall is the 2nd big thing to happen to Lua (after Lua itself, of course).
[Gosu](http://libgosu.org) for Ruby is better (the internals are better too, have you looked at the C++ in love ? it's written by people who don't seem to be very good at C++)
I do not know Gosu, so please forgive my ignorance, but: * What is done better in Gosu than it is in LÖVE? * Why do you think LÖVE is written by C++ novices?
Gosu looks cool, except for the part where you use Ruby.
&gt; Most of the people dislike the syntax of Obj-C and it does slow down development. This is just the blogger's opinion, and not true at all for those of us that have been using it long before iOS.
You can set a ['count' hook](http://www.lua.org/manual/5.1/manual.html#lua_sethook) that's called every N bytecode instructions, HOWEVER this doesn't give you a failsafe sandbox; the standard library contains functions (especially the string functions) which don't count as bytecode instructions but can be made to take a long time and consume large amounts of memory. [A recent post by Mike Pall](http://lua-users.org/lists/lua-l/2011-02/msg01595.html) on lua-l demonstrates this: string.find(string.rep("a", 50), string.rep("a?", 50)..string.rep("a", 50)) The standard solution to this kind of nastiness is `ulimit` but of course that has its own drawbacks (only works on UNIX, only applies to processes which may be too heavyweight). **Edit:** I'm not specifically trying to discourage you, so for some more constructive feedback try looking through any of the Lua sandboxes that allow people to execute Lua code from a web page, for example [Try Lua on lua.org](http://www.lua.org/demo.html) ([source here](http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/#demo)).
xolox's count hook will work great if you disallow C functions from being called. So don't call luaL_openlibs(). Then the only code in the VM will be interpreted code, so the hook will work. Then you just need to make sure that your own engine binding code is robust against malicious scripts.
No, thank you, this seems nearly, if not exactly, what I was looking for. As marcomorain points out, perhaps the way is to enable the count hook to limit the script and only allow outside library calls to those that you know are safe...
You should use [lua environments](http://lua-users.org/wiki/SandBoxes) to sandbox the scripts, and use timers to make sure scripts execute within a certain amount of time.
Another problem is that luarocks isn't all that generalized - it's not a "describe the lua module and then it figures out how to install it" system, it's a "provide a makefile and it runs that" system. I've had to modify rocks to get them working on Cygwin.
Luarocks, has the name implies, is about software that's written at least partly in Lua. The question of the implementation language(s) doesn't interest anyone but developpers, so it's bound to be that way. As a user, I'm ready to discriminate by OS, not by implementation details, so I don't want anything but "apt-get install"; I'm willing to compromize and accept "./configure; make; sudo make install" if the dependencies arer trivial, but nothing more. What I want is an automated luarock-&gt;dpkg converter. Not for me to use, for deceloppers to provide an acceptable experience. 
I hope I'm not misrepresenting someone, but AFAIK the LuaRocks authors specifically dislike rockspecs that depend on makefiles because it significantly reduces LuaRocks' portability and it's generally very hard to write truly portable makefiles (irrespective of whether LuaRocks is used).
I guess [checkinstall](http://en.wikipedia.org/wiki/CheckInstall) doesn't count? I've been using it for [the Lua/APR binding](http://peterodding.com/code/lua/apr/) and it seems to work fairly well AFAIK (I'm fairly new to creating my own `*.DEB` packages). Here's the relevant bit from the [Makefile](https://github.com/xolox/lua-apr/blob/a47a3205e2affae474fdf5c4eb3bf07cfa6a7b75/Makefile#L202): # Create a Debian package using "checkinstall". deb_package: package_prerequisites @echo "Lua/APR is a binding to the Apache Portable Runtime (APR) library." &gt; description-pak @echo "APR powers software such as the Apache webserver and Subversion and" &gt;&gt; description-pak @echo "Lua/APR makes the APR operating system interfaces available to Lua." &gt;&gt; description-pak checkinstall \ --default \ --backup=no \ --type=debian \ --pkgname=lua-apr \ --pkgversion=$(VERSION) \ --pkgrelease=$(RELEASE) \ --pkglicense=MIT \ --pkggroup=interpreters \ '--requires=libapr1,libaprutil1,libaprutil1-dbd-sqlite3,libapreq2' \ '--maintainer="Peter Odding &lt;peter@peterodding.com&gt;"' \ make install LUA_DIR=/usr @rm -R description-pak doc-pak/
That may be, but dislike or not, it happens, and it causes portability problems.
Lua tables can hold functions as values. This can be used to implement construct similar to switch-case. Let us first create the table that holds the functions: local actions = {} -- Table creation actions["double"] = function(n) return 2 * n end -- Add first function (first "case") actions["triple"] = function(n) return 3 * n end -- Add second function (second "case") Now we can pass objects to the table as keys and some parameters and get the value: print(actions["double"](10)) --&gt; 20 print(actions["triple"](10)) --&gt; 30 print(actions["double"](10)) --&gt; 20
Awesome, thanks heaps.
Is it common lua style to indent so deeply? I found it kind of hard to follow... Will cut n paste and have a look later though!
I don't think I've ever ran across a lua style for anonymous functions yet. I've seen people indent based on nested level (this is usually what I do) and others who match up the indents with the beginning of the function, which is what the author did, for readability's sake I suppose and to highlight the fact that we're not allowed to bind to some hypothetical toplevel/global scope (even if that's ultimately inevitable)
Also is this the best method to use? It seems the most readable to me, and I'm used to using case/switch instead of multiple nested if statements.
Just to expand on ponzao's post, you can use just about anything for the table keys. Also, you can set a metatable for your actions table, and let the __index metamethod handle the default case where the key does not match a pre-defined value. After getting used to the idea of no switch/case in Lua, using a table instead has further benefits. Maybe different modules of your code add their own entries, for example.
See you just fired that far off into the distance of "no idea what you're on about land". Might have to dumb it down a bit for me to share your enthusiasm :)
What @ansible means with the __index metamethod is that in case you are trying to access a key that is not available in the table you can do custom error handling. I will give an example: We have defined the table as before. Now we are trying to access a function that is not available: actions.quadruple(10) -- actions.quadruple is a syntactic sugar for actions["quadruple"] --&gt; attempt to call field 'quadruple' (a nil value) There is no such key defined in our table so an error is thrown. The error is not desired in this case, we would just like to return 0, so we set a metatable for actions: setmetatable(actions, { __index = function(t, k) -- t will be our actions -table, -- k is the key we are accessing. return function(n) -- We return a function that takes one argument, -- could be less, could be more. return 0 -- We just return 0. end end }) After defining the metamethod we can try the quadruple key again: actions.quadruple(10) --&gt; 0
Lua's adversity towards terseness can cause problems when you want to `return function (...)`. The most effective way to preserve the look of the code is to start a new line: function foo(n) local i = 0 return function () i = i + n return i end end This runs fine and looks okay, though it does take up even more screen space.
Nice. Thanks!
Sorry, maintaining a WoW addon needs more than just Lua knowledge. WoW is a massive framework in and of itself, and you need to know that framework in order to work with addons. There is a reason that there is a 1,440 page book (wowprogramming.com) that just describes this framework. Sorry, you're really not looking for a Lua expert, you're looking for a WoW addon author. They are not the same thing.
I came here to post this same thing. Addon writing is less knowing Lua and more having a grasp on the (immense) WoW api. I'd recommend you pick up the book and run through some of the basics. I own it and it's a wonderful and fun intro to programming.
Pretty much. Being an expert in one does not mean that you are an expert in the other.
Also, read [the associated post on Hacker News](http://news.ycombinator.com/item?id=2490068) for comments.
Disclaimer: I don't have specific experience with any of the three tools you mention but I do have quite a lot of experience with Lua and have been following the mailing list for quite a while so I know about all three tools and a bit about how they interact. [Metalua](http://metalua.luaforge.net/) generates Lua 5.1 compatible byte code (see note below) and AFAIK [LÖVE](http://love2d.org/) is "just a bunch of Lua libraries/modules" so you should be able to combine the two without any problems. Unfortunately LuaJIT doesn't support Lua 5.1 byte code so you can't combine Metalua and LuaJIT. Also it looks like LuaJIT won't gain support for plain Lua 5.1 byte code (any time soon) because of technical difficulties. However I think I've read that Fabien (creator of Metalua) is considering a source-to-source compiler which would alleviate this problem. Note about Metalua compatibility with plain Lua byte code: Quoting the [Metalua homepage](http://metalua.luaforge.net/index.html): &gt; Full compatibility with Lua 5.1 sources and bytecode: clean, elegant semantics and syntax, amazing expressive power, good performances, near-universal portability. **Edit:** After rereading your question it seems you were already aware that Metalua generates plain Lua 5.1 byte code. Sorry I can't be of any more help.
&gt; ... but it lacks support for (for instance) forms which bind variables monadically (rather than in the identity monad). I've got some previous Haskell experience, but didn't quite understand this bit. Do you have an example of what you'd want to accomplish but can't seem to with the base Lua semantics? While being previously quite enamored with the ideas underlying Haskell, I've drifted away from purity and laziness. I had a hard time to learn how to re-compose problems to suite the natural structure of Haskell code. And, actually, dealing with state in video games. It seemed most practical solution was to conglomerate all the state together, and keep passing that through to the next iteration of the main loop. I did look at [FRP](http://www.haskell.org/haskellwiki/Functional_Reactive_Programming) as well, but had issues with that. &gt; Is there an s-expression front end for lua which would dispense with these concerns (besides the one I am writing, which is 60% done)? I haven't heard of anything like that. I'd guess that most of the people who would have wanted that were instead diverted to Metalua and its macro system instead. At any rate, xolox's reply below should be some help, and I second what was said there. It might be possible to re-compile LÖVE to use Metalua (if that can be a regular dynamic library). Combining those with LuaJIT is definitely not going to happen in the near term. Otherwise, I agree that source-to-source translation would be the best way forward.
&gt; I've got some previous Haskell experience, but didn't quite understand this bit. Do you have an example of what you'd want to accomplish but can't seem to with the base Lua semantics? Do notation, essentially. In lisp it is easy to add a form which behaves just like Haskell's do notation, threading a computation through a specified monad's bind operation and then executing a body. Parser combinators are one such monad example which are not easy to use in a language like lua exactly because the syntax is missing.
Metalua is compatible with LuaJIT 1 (which runs Lua bytecode) but not with LuaJIT 2 (which runs Lua source using a novel bytecode). LOVE is compatible with pretty much anything.
Yeah. I've been doing a little reading about this in the last week. Monads in Scheme, Lua and other dynamically typed languages don't seem to work as well as in Haskell. Actually, there are a whole bunch of things that don't work as well as they do in Haskell (and to a lesser extent Scala) when it comes to this sort of stuff. I'd actually been meaning to look at that stuff again and see how well (if at all) Monads work in Lua. That, and maybe some kind of support for complex numbers and multi-dimensional arrays. I'm reluctant to make (or even try to propose) an large scale changes to the syntax and semantics. But it may be possible to shoehorn in support for that sort of stuff without disturbing things too much. In general though, please feel free to ask us here, or on the lua-l mailing list if you're having problems implementing something elegantly. Maybe not using monads or parser combinators, but there may be other approaches which can work well, and still be maintainable.
One way of thinking about monads is that they are all about binding. Most dynamic languages (but not lisp) are pretty sloppy about what binding means, and so its a little hard to imagine extending the semantics of binding in a meaningful way. However, if you have an expression like `let*` you can extend that expression to handle monadic binding, and then you have a significant amount of the utility of monads. I used monads in Emacs Lisp, Clojure and Scheme all the time exactly this way. Hence my interest in metalua. If I could add a "monadlic-let" expression, I'd be a huge amount of the way there.
As per: "You should cross post to /r/lua as well, we're dying for some submissions over there :)"
Thanks for posting this. It reminds me a great deal of all C++ frameworks like [Cinder](http://libcinder.org/) and [openFrameworks](http://www.openframeworks.cc/). If I could afford to be retired, these are the things I would be playing with for months at a time. 
oh hella damn. this is awesome. I already have my own one of these sitting on top of openframeworks, but this has a few bindings I wish I had.
Reminds me of processing.org, which is clearly more mature. I hope to see this project grow though, since it fits my code background like a glove (C++/Lua).
Nice! It's not my fav language, but it's always good to see languages you know well gain relevancy. 
Where is all the jobs in Lua then?! :( I saw jobs in Erlang, jobs in Scala, but where is Lua?
[Apparently, they're here.](http://www.indeed.com/jobtrends?q=erlang%2C+scala%2C+Lua&amp;l=)
*We're number 10! We're number 10!* Just doesn't have the same 'ring' to it. Still cool, and certainly well-deserved. With LuaJIT-ARM out now, I think we'll see even further gains.
Thumb sores. 
Nice, but....Nokia? Why not, you know, Android and iPhone, to hit like 99% of the smart phone market?
IPhone has iluabox
The Scripting Layer for Android includes a Lua interpreter: http://code.google.com/p/android-scripting/
The official announcement for Beta RC1 is at http://lua-users.org/lists/lua-l/2011-06/msg00515.html
Sure, fair enough. If you look around you might find a good deal on an old Droid (from Verizon in the US -- or the Milestone everywhere else) which has a decent keyboard. Something I heard recently was that a huge percentage of people who buy Android phones do so because they hate Apple or the iPhone in particular. So you're in good company. :)
I've previously been doing nerdy things with my HTC Dream (T-Mobile G1): http://www.reddit.com/r/programming/comments/cd6lx/writing_code_on_handhelds_using_an_android_phone/ I've given up on writing code directly on the phone though. I just log into a server I've setup that is visible to the Internet. With GNU screen, I can keep the context of what I was working on. I just change the keybindings for screen a little bit when I'm using the phone. ----------------------- So, anyway, If you do want to pick up an Android phone with a great keyboard, I recommend the G1. You can probably pick one up cheap these days, just because it is low on memory and processor speed compared to current releases. However, I haven't seen one that had a better keyboard. The overall layout is very good, and all symbols are easily accessible. 
https://gist.github.com/1035809 FTFY
TILed
It is generally a bad practice to touch standard Lua namespaces (like you do with `table`). Please consider following established practice and moving your stuff to a separate namespace with unique name that matches the name of your `require`.
I'll totally take that under consideration.
I second what Alexander said. I also use the module definition format proposed by David Manura here (about 2/3rd down the page): http://lua-users.org/wiki/LuaModuleFunctionCritiqued That way I can import the module, and call it whatever I like. I personally tend to use short initialisms like this: local FL = require "functional.list" ... result = FL.map(summation, {1, 2, 3}, {4, 5, 6}) When reading the code, the initialism usually provides enough context to remember where the 'map' function came from, and you can always look at the top of the file to then know exactly.
[Penlight](http://penlight.luaforge.net/) implements some of this functionality and a lot more of "bateries" (it borrows a lot from Python's libraries). However it's API and code base is much bigger than yours (about 200kb). If someone wants a smaler/leaner library, yours is an interesting choice. I'd suggest you to keep it like that way; lean and small has been a successfull strategy for Lua.
[Deep copy](http://lua-users.org/wiki/CopyTable) the _G table and you're done. 
It seems like you've already got a solution to a problem in mind, but just wasn't sure how to implement it. However, it would probably be useful for you to describe what the original problem is, we may be able to propose a better and more elegant solution.
Fair enough. The two methods I thought about doing this. (and I started implementing each, but decided to stop and get some advice) 1. in Lua, iterate over the _G table, finding all vars and calling back into C to build up a dictionary of the stuff (Calling this from Objective-C for an iOS engine). I was poking at a variant of http://lua-users.org/wiki/SaveTableToFile to accomplish this, but the idea of calling into Lua to have it call back into C to build the table felt cumbersome to me. 2. In the C side, use a variant of this: http://cdry.wordpress.com/2010/06/26/how-to-save-global-variables-using-the-lua-c-api/ adding support for tables, and then doing this over the entire _G table, building the dictionary from the vars and subdictionaries from nested tables, etc. From there, the Dictionary can easily be serialized as a .plist file, or brought back in, and then just iterated over to restore the Lua content. One thought i had early on was for the C-side of this to register a list of which variables are to be saved. This was a naive thought before I learned that I could simplify and just save the whole _G table. :) I think the first one would make more sense if the core of my engine were in Lua, with C for support, but it's really the other way around, C/Obj-C as the controlling stuff, which calls event handlers in Lua (Swipe, button click, "scene should start" etc), using Lua as support, and for game data files. So i think that a variant of the latter is more apropos. I literally started poking at this last night, but realized that rather than driving down the street for a while, it made more sense to pick the brains of some Lua experts who might have already gone down this road. 
I was unclear in my question. I want to save the contents of all variables and tables to a file, to be restored later... not just make a backup copy in memory.
I guess I was also asking if there was an established way to do this that my Google-fu was failing to find...
[Here](http://the-color-black.net/blog/article/LuaTablePersistence) is a reasonably good Lua serialization codebase, I've used it in several places myself. Point that at _G and you'll get a stringized snapshot of the world. Note that this will not preserve metatables or C functions. Modifying it to handle metatables would be icky but possible. C functions, however, will prove effectively impossible - you'll need to deal with those separately. Alternatively, you can check out the Lua Pluto library, which is a C-side library that does a bunch of extremely deep work to serialize everything possible. That said, I'm not personally convinced this is a good idea - serializing *everything* means that you'll have major problems deserializing after version changes, for example. I personally prefer a more explicit hands-on serialization process. 
Understood. Yeah, the state machine that wraps this sets up all of the c functions, and supporting functions. I just need this to save vars and tables so that state of the game can be completely restored. This method looks like a good way to go. Thanks! Also looking into Pluto as well. :)
That's a potential tricky question, depending on how much you want to save and restore. The ultimate library to do that is Pluto. Whatever you want to do, it can most likely do it. If what you want is fairly basic, it might not be the simplest adequate solution to your problem.
Excellent thanks. Looking into it!
I guess I was also somewhat unclear. Let's try again... Why do you want to save all the globals in the first place? Is this something where you need to suspend the application, or something like that? Or is this just saving the game state when the user clicks 'save game'? So do you just need to save some tables? Or more state than that? Doing this naively may result in unexpected bad behavior. Things that can trip you up upon attempting to restore the system state include: Did you load all the modules you were using before the suspend? Or are you saving the functions too? Do you need to capture any upvalues for functions? For example: local x = 33 local function foo(y) return x + y end Function foo() has x as part of its closure. Even if you have a reference to function foo(), and you save the compiled function, you also need to worry about x. So do you really need to save everything in globals? You may be picking up stuff you don't really want to save anyway. There are also various modules to save and restore Lua objects of varying complexity and completeness. [Table Serialization](http://lua-users.org/wiki/TableSerialization) discusses some of the trade-offs between the different implementations. I suggest taking a close look at Pluto on that page. 
Food for thought, it's also possible to serialize functions via their bytecode. The glaring problem to this approach however is the impossibility of gaining access to the upvalues and restoring them properly. However, if we dump the global variable, then we can safely assume that global functions have upvalues derived from the globals and all subsequently nested functions from the locals+upvalues of their parent functions. I'm gonna go experiment now
For what it's worth, this is what I went with: - (void) saveVarsTo:(NSString*)filename { // build the variables into a .plist i think NSLog( @"Save Lua state to %@", filename ); // ref: http://cdry.wordpress.com/2010/06/26/how-to-save-global-variables-using-the-lua-c-api/ NSMutableString * savedata = [[NSMutableString alloc] initWithCapacity:1024]; // give it some space to start [savedata appendFormat:@"--\n-- BLuebird Save file\n--\n\n"]; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@"y-MM-dd HH:mm:ss"]; [savedata appendFormat:@"saveMeta = {\n date=\"%@\",\n version=\"1.0\",\n};\n\n", [dateFormatter stringFromDate:[NSDate date]]]; [savedata appendFormat:@"-- save content follows:\n"]; // [self callFunction:@"saveVars" withStringParam:filename]; // push the first key (nil = beginning of table) lua_pushnil( hLua ); // lua_next will: // 1 - pop the key // 2 - push the next key // 3 - push the value at that key // ... so the key will be at index -2 and the value at index -1 while (lua_next(hLua, LUA_GLOBALSINDEX) != 0) { // get type of key and value int key_type = lua_type(hLua, -2); int value_type = lua_type(hLua, -1); // support only string keys // globals aren't likely to have a non-string key, but just to be certain ... if (key_type != LUA_TSTRING) { lua_pop(hLua, 1); // pop the value so that the top contains the key for the next iteration continue; } // support only number, boolean and string values if (value_type != LUA_TNUMBER &amp;&amp; value_type != LUA_TBOOLEAN &amp;&amp; value_type != LUA_TSTRING &amp;&amp; value_type != LUA_TTABLE ) { lua_pop(hLua, 1); // again, pop the value before going to the next loop iteration continue; } // get the key as a string const char * key_string = lua_tostring(hLua, -2); // no copy required - we already know this is a string // do not support variables that start with '_' // lua has some predefined values like _VERSION. They all start with underscore // NSLog( @"ks %s %s", key_string, (value_type==LUA_TTABLE)?"table":(value_type==LUA_TBOOLEAN)?"bool": // (value_type==LUA_TNUMBER)?"number":(value_type==LUA_TSTRING)?"string":"unk"); if (!strlen( key_string )) { // this again is highly unlikely, but still ... lua_pop(hLua, 1); continue; } if (key_string[0] == '_') { lua_pop(hLua, 1); continue; } // other heuristics if( !strcmp( "coroutine", key_string )) // don't want these { lua_pop( hLua, 1 ); continue; } if( !strcmp( "saveMeta", key_string )) // we're overwriting this one { lua_pop( hLua, 1 ); continue; } // convert the value to a string. This depends on its type switch (value_type) { case LUA_TTABLE: [savedata appendFormat:@"%s = {\n", key_string]; // now, we need a subiterator on this thing to fill it all in lua_getglobal( hLua, key_string ); lua_pushnil(hLua); // loop over the tablezor while( lua_next( hLua, -2 ) != 0 ) { // -2 is key string, [number] // -1 is value "string", number, boolean // type checks first. int tkeytype = lua_type( hLua, -2 ); if( tkeytype != LUA_TSTRING &amp;&amp; tkeytype != LUA_TNUMBER ) { NSLog( @"unknown key type in table %s (%d)", key_string, tkeytype ); lua_pop( hLua, 1 ); continue; } int tvaltype = lua_type( hLua, -1 ); if( tvaltype != LUA_TNUMBER &amp;&amp; tvaltype != LUA_TSTRING &amp;&amp; tvaltype != LUA_TBOOLEAN ) { NSLog( @"unknown value type in table %s (%d)", key_string, tvaltype ); lua_pop( hLua, 1 ); continue; } // okay. we're this far. therefore stuff on both sides of the = are valid... switch( tkeytype ) { case( LUA_TSTRING ): [savedata appendFormat:@" %s = ", lua_tostring( hLua, -2 )]; break; case( LUA_TNUMBER ): // note, if you do tostring, it corrupts the stack for lua_next lua_pushnumber( hLua, lua_tonumber( hLua, -2 ) ); [savedata appendFormat:@" [%s] = ", lua_tostring( hLua, -1 )]; lua_pop( hLua, 1 ); break; default: [savedata appendFormat:@" -- ?? = "]; break; } switch( tvaltype ) { case( LUA_TSTRING ): [savedata appendFormat:@"\"%s\",\n", lua_tostring( hLua, -1 )]; break; case( LUA_TNUMBER ): // note, if you do tostring, it corrupts the stack for next lua_pushnumber( hLua, lua_tonumber( hLua, -1 ) ); [savedata appendFormat:@"%s,\n", lua_tostring( hLua, -1 )]; lua_pop( hLua, 1 ); break; case( LUA_TBOOLEAN ): [savedata appendFormat:@"%s,\n", (lua_toboolean( hLua, -1 ) == 0)?"false":"true"]; break; default: [savedata appendFormat:@"-9999.9,\n"]; break; } lua_pop( hLua, 1 ); } lua_pop( hLua, 1 ); [savedata appendFormat:@"};\n"]; break; case LUA_TSTRING: //lua_pushvalue(hLua, -1); [savedata appendFormat:@"%s = \"%s\";\n", key_string, lua_tostring(hLua, -1) ]; //lua_pop(hLua, 1); break; case LUA_TNUMBER: // numbers can be converted to strings // get the value as a string (this requires a copy because traversing tables // uses the top of the stack as an index. If conversion from a number to string // happens, the top of the stack will be altered and the table index will become invalid) lua_pushvalue(hLua, -1); [savedata appendFormat:@"%s = %s;\n", key_string, lua_tostring(hLua, -1) ]; lua_pop(hLua, 1); break; case LUA_TBOOLEAN: [savedata appendFormat:@"%s = %s;\n", key_string, lua_toboolean(hLua, -1) == 0 ? "false" : "true" ]; break; } lua_pop(hLua, 1); } [savedata writeToFile:filename atomically:YES encoding:[NSString defaultCStringEncoding] error:nil]; } 
I don't have time to really go through the file itself right now, but I wanted to say that this is very cool! I was actually looking for something along these lines -- type safe and lightweight, but none of the libraries I found really met my criteria. I'm assuming since you're only really "wrapping" the core Lua API that this should work just fine with LuaJIT too, which is not possible with LuaBind without cutting out exceptions. Very cool!
This should work just fine with LuaJIT. I'm currently not using it in my project, but only because I had trouble with some linker or compiler issue and it was more convenient at the time to just use regular Lua (and I'm just too lazy to go back and figure out what the problem was), but I see no reason why it would be a problem. 
Looks nice! How does your implementation compare to [lunar.h](http://lua-users.org/wiki/CppBindingWithLunar)? This is what I'm currently using in my own code. Haven't looked at your code in detail and I'm not really an expert in the Lua C API, but I might try out your code as it seems to have a few extra handy functions. Thanks for sharing anyways! 
Just glancing at the lunar.h code, I got the same impression you did: it looks like this guy had a similar idea to what I wanted to do, but I think I fleshed out the concept a bit more and added a few extra features. 
Thanks for posting the code, I'll take a look at it. When you feel comfortable enough, please consider also posting a message to the main lua mailing list, and also updating the lua-users.org wiki.
I've though about that, but I wanted to get some feedback before posting it more widely (that's why I started on the code review sites before posting it to a wider audience). There are a few things that need some tweaking (and I just noticed some comments that need fixing) before I think it's 'done'. 
Yes - I think that adding this to the lua-users wiki is a very good idea. That's a place where you could reach most of the users that are potentially interested in this. I mean that's where I found lunar.h, and I find that code to be very useful.
Is the any special etiquette when adding stuff there, or do I just go in and add a link and description? (I'll probably make some quick changes to some comments in the code, and add a README file and look into adding it when I get home after work tonight)
No, I'm not aware of any specific guidelines on what the pages should look like, but surely some sample usage code would be nice. I believe the [Sample Code](http://lua-users.org/wiki/SampleCode) section would be a good place to add a link to your code (possibly under "Lua C API samples" &gt; "C++"). Good luck, and thanks again!
I spent some time doing some updates to the documentation in the header as well as writing up a README file containing a bunch more information. Once all that was in I sent a message to the lua mailing list and put a link up to it on the lua-users.org wiki. If you have any feedback let me know :)
http://www.lua.org/manual/5.1/manual.html#2.5.5 "If the array has "holes" (that is, nil values between other non-nil values), then #t can be any of the indices that directly precedes a nil value (that is, it may consider any such nil value as the end of the array)." Basically, the length operator is useless on an array with holes. You're better off iterating the table with pairs to determine the number of entries.
For sequential indexing tables with integers (for the lack of a better descriptive term) it fills up the gaps with nils. So you have {1, 2, nil, 3}.
The length operator does return the number of entries. Nil is a valid entry.
Assigning a value to an index greater than the length of a table increases the length of the table. If it didn't, the first two lines would be an error. a = {}; -- #a returns 0 a[1] = 1 -- if #a is 0, how are you indexing to 1? Lua adjusts the table size dynamically when you do this. Unlike C arrays, Lua table indexes start at 1, which is why print(#a) in your code returns 4. Check out PIL [19.1 - Array Size](http://www.lua.org/pil/19.1.html) for more information. 
And there is a hole at an index if its value is `nil`, even if you've explicitly assigned `nil` to this position. So in the example, there is a hole at index 3. If you set `a` to `{1, 2, nil, 4}`, there is still a hole at this position, and `#a` can be 2 or 4.
[Explain this, then](http://codepad.org/3Njo74tq).
4 is the number of entries, but 2 isn't, and the operator may return either.
I admit I was unclear about the definition of a table's length. I haven't touched Lua since 5.0, and things have changed. Here is the exact definition: &gt;The length of a table t is defined to be any integer index n such that t[n] is not nil and t[n+1] is nil; moreover, if t[1] is nil, n can be zero. For a regular array, with non-nil values from 1 to a given n, its length is exactly that n, the index of its last value. If the array has "holes" (that is, nil values between other non-nil values), __then #t can be any of the indices that directly precedes a nil value__ (that is, it may consider any such nil value as the end of the array). For arrays with holes, the # operator is not predictable. It can return any value preceding a nil entry. This works, btw: local x = {} x[10000] = 5 print(table.maxn(x)) 
If you haven't used Lua since the now ancient 5.0 versions then anyyhing you say here is bound to be incorrect and/or misleading. Just saying... 
Yeah, I started reading through the source of the [table code](http://www.lua.org/source/5.1/ltablib.c.html) and was confused why the setn in [tinsert](http://www.lua.org/source/5.1/ltablib.c.html#tinsert) didn't seem to be doing what one would expect. Only later today did I get back around to this and recalled that setn is deprecated and getn now behaves like #. When you call getn, it actually uses [luaL_getn](http://www.lua.org/source/5.1/lauxlib.c.html#luaL_getn) which in turn calls [lua_objlen](http://www.lua.org/source/5.1/lapi.c.html#lua_objlen), which calls [luaH_getn](http://www.lua.org/source/5.1/ltable.c.html#luaH_getn) to get the length. That function does something rather interesting, which explains the varied behavior one gets for getn on arrays with holes.. Without digging much further, it appears that it does a binary search of the pre-allocated space for the array using an interesting binary search, which looks for a boundary (nil next to non-nil), which is why one gets interesting stuff like [this](http://codepad.org/C3gWDsyW) In short, while it _is_ actually predictable from the sources of a given version, but it's not something to rely on for arrays with holes. Lua has quite a few interesting facets like this where they've made a performance decision that affects the behavior of the language. They always clearly document it, but it can certainly trip up new users. Edit: I suppose also that the answer to "what is the length?" for an array that contains nil values (sparse in concept, but I bet for these numerical key tables Lua allocates the full length?) isn't a completely simple one and in such conditions the user should probably ask for exactly what they want (maximum index, number of non-nil elements, etc..) 
Yes, basically if you want a sparse array, there are several definitions of 'length' that may be valid depending on the use case. A sparse array is a different data structure than a Lua table. You can build that using a Lua table of course.
You need to [load the lua standard libraries](http://heavycoder.com/tutorials/lua_embed.php) from inside your embedded lua before the 'require' function is available.
Thank you for the reply. this looks like a new site I can read. I'll try this. 
What I have found in embedding Lua is that I need to register all my libs, here is a sample from my app server which embeds lua: stuff from header: /*! Binary map of libraries to load */ enum LuaLibrary { LUALIB_NONE = 0x0000, //!&lt; Mask to load no libraries LUALIB_BASE = 0x0001, //!&lt; print() modified to write to ALuaEmbed output buffer LUALIB_TABLE = 0x0002, //!&lt; Tables LUALIB_STRING = 0x0004, //!&lt; String manipulation LUALIB_MATH = 0x0008, //!&lt; Math LUALIB_DEBUG = 0x0010, //!&lt; Debugging //LUALIB_OS = 0x0020, //!&lt; Not supported (security) //LUALIB_PACKAGE = 0x0100, //!&lt; Not supported (security) //LUALIB_IO = 0x0200, //!&lt; Not supported (security) LUALIB_ALL_SAFE = 0x000f, //!&lt; All web safe libraries (no OS access) LUALIB_ALL = 0xffff //!&lt; Mask to load all libraries }; typedef int (LUA_OPENLIBRARY_FUNCTION)(lua_State *); typedef LUA_OPENLIBRARY_FUNCTION* LUA_OPENLIBRARY_FPTR; stuff from source: void ALuaEmbed::_init(u4 maskLibrariesToLoad) { mp_LuaState = lua_open(); AASSERT(NULL, mp_LuaState); lua_atpanic(mp_LuaState, ALuaEmbed::callbackPanic); // Explicit NONE selected, no libraries loaded if (LUALIB_NONE == maskLibrariesToLoad) return; // Load ALibrary based functions (NOT part of Lua) luaopen_alibrary(mp_LuaState); // load ALibrary functions first (and override print() to use output) luaopen_base(mp_LuaState); // load base Lua functions used by ALibrary luaopen_web(mp_LuaState); // load web functions luaopen_objects(mp_LuaState); // load objects functions luaopen_model(mp_LuaState); // load model functions // Optional Lua libraries if (LUALIB_TABLE &amp; maskLibrariesToLoad) luaopen_table(mp_LuaState); // opens the table library if (LUALIB_STRING &amp; maskLibrariesToLoad) luaopen_string(mp_LuaState); // opens the string lib if (LUALIB_MATH &amp; maskLibrariesToLoad) luaopen_math(mp_LuaState); // opens the math lib if (LUALIB_DEBUG &amp; maskLibrariesToLoad) luaopen_debug(mp_LuaState); // opens the debug lib // Following are not supported due to security concerns while being embedded, but can be uncommented if needed at your own risk // if (LUALIB_OS &amp; maskLibrariesToLoad) luaopen_os(mp_LuaState); // opens the OS lib // if (LUALIB_PACKAGE &amp; maskLibrariesToLoad) luaopen_package(mp_LuaState); // opens the package lib // if (LUALIB_IO &amp; maskLibrariesToLoad) luaopen_io(mp_LuaState); // opens the I/O library lua_gc(mp_LuaState, LUA_GCSETPAUSE, 120); lua_gc(mp_LuaState, LUA_GCSETSTEPMUL, 400); } void ALuaEmbed::loadUserLibrary(LUA_OPENLIBRARY_FPTR fptr) { fptr(mp_LuaState); } I can put the rest of the code if you want, but I think this demostrates how they get initialized.
You may also want to kill the bytecode-import feature of loadstring, as that can be a security risk as well.
Thanks, will do.
This is just great, nice to see Minecraft getting some Lua love. Just note that there is an official site: http://www.luaserver.org
Nice. Looks interesting. I've been using tolua++, and it's been terrible for me -- it wasn't designed to use smart pointers, and so I hacked them in, and...well, the code is a mess, and pretty fragile, so while it's WORKING, I'd like to pull it from my code and rewrite it with something that works. Looking at it more closely...there are no examples of how to bind member functions. Specifically, it would be great to have template-based helper functions that automatically bind member functions to create the tables/metatables for the class. In tolua++ right now I have over a thousand lines of bindings to various classes and class members (a binding to a member function or member variable is typically is one line in a tolua++ spec file). I'm not really eager to write all of those bindings by hand. :)
Oh, and by the way -- I looked into LuaBind as well, and decided against it in part because I helped port a project that ended up with a HUGE executable because of LuaBind. Not to mention the extremely long build and link times...
I keep meaning to write some sample code to show how it works, but I keep getting busy with other stuff. Maybe I can find time for it this week. The aim of this was not to automate the binding of lua functions to C++ functions, it was just to provide typesafe template functions to get and set lua userdata. If I did decide to try to automate that, I'd probably put it in a separate project that builds on this code rather than mix it in here. I think what you're asking for is more difficult than you think anyway, and I don't really have any desire to write such functionality at the moment. It would take quite a bit of ugly template metaprogramming, something I was trying to avoid. (If I wanted to do metaprogramming, I would do it with a tool outside the language. C++ templates are not well designed for metaprogramming) I find that when I write my Lua functions, they don't map directly to the function signature of what they're wrapping around anyway; I often allow for alternate or optional parameters, and it's easier to just write that yourself than try to automate that. For the functions that are just straight wrappers, I just have some snippets in my editor (I use snipmate on vim, but any snippet tool should be able to handle it) to make generating a lua function possible with just a few keystrokes. 
Well, I know it's possible, having used several such template metaprogramming approaches in the past -- and that it's a PITA. Even a "few keystrokes" per bound function would mean several thousand keystrokes, and a heck of a lot of opportunity for error. Which is why I want it automated. I'm also considering an approach that uses Doxygen XML output, or a custom Clang backend -- the "tool outside of C++" approach you mention. And I know someone at a local company who has done almost exactly what I want, so I'm also working on his company to open source it. :)
So everything seems to be going fine so far. I can connect to reddit, pull down the json and decode it fine. I'm hitting a bit of a roadblock in my understanding - maybe its something fundamental about Lua? Anyway when I run the "update" function, it dies on trying to print "data["has_mail"]". The error is odd to me, it says lua: reddit.lua:29: attempt to concatenate field 'has_mail' (a function value) Why does it think this is a function? Shouldn't it be an null value (assuming I have no mail at the moment)? Thank you in advance 
Have you tried calling it as a function? e.g. print( data["has_mail"] ) function (0x12345678) print( data["has_mail"]() ) false I haven't used the libraries you are using, but I doubt it's anything fundamental with Lua. It seems like the issue is with the json lib.
I don't know what luaj is but have you investigated luasocket?
The thing is that luasockets is written in C.
My guess is you would use Java's networking libraries. 
Yes that was the backup plan, I was hoping there would be something ready for this ;)
I found a solution for the sockets thing.... infact, I figured that luaj has a mechanism for accessing Java classes from lua scripts. Check out this: jURL = luajava.newInstance("java.net.URL", "http://downloads.luaserver.org/version.php") jBufferedReader = luajava.newInstance("java.io.BufferedReader", luajava.newInstance("java.io.InputStreamReader", jURL:openStream() ) ) local str = jBufferedReader:readLine() while( str ) do print(str) str = jBufferedReader:readLine() end should print '24' in the server output as it would when you would visit "http://downloads.luaserver.org/version.php"
If you still care, I just put up a really quick example project on bit bucket that shows basic library usage. it can be found here [here](https://bitbucket.org/alexames/luawrapperexample)
Cool, thanks. Again, too much work for my project without a code generator, but I do like the underlying code, so I may use that when I get around to redoing the bindings.
Very cool! I'll keep this in mind to try to lure my friends who worship at the alter of Python's significant whitespace into Lua. I, on the other hand, like my whitespace to remain insignificant, so I'll stick with normal Lua. :)
I've had the exact same thought before. I don't believe there is, but there should be.
What is turtle?
This would not be difficult to do at all. 
Y'all mean [logo](http://en.wikipedia.org/wiki/Logo_(programming_language\)).
It is actually more like [Coco](https://github.com/satyr/coco) a fork of CoffeeScript that aims to break semantic compatibility with regular JavaScript. I will have to check if everything is an expression like CoffeeScript. The addition of comprehensions is a nice touch for Lua, but afaik MetaLua provides those.
love 2d would be super easy to do this with. Corona is another one that has nice drawing functions, but it is mostly for ios / android dev.
Love2d with [Debug](http://love2d.org/forums/viewtopic.php?f=5&amp;t=2473)
Why use Lua for such a simple thing though? Lua is far more powerful and since the purpose of the "turtle" is to tech the basics of algorithms and procedural programming, better use Logo instead of Lua.
Corona? Wow that looks amazing! But the price is to high. $200+/year? Seriously? That's the first SDK with a sibscription I've ever seen.
Hey, this will make the clue c compiler for higher level languages perform better. Right now it runs slowly for lua because they have to implement goto to be fully compatible with C. http://cluecc.sourceforge.net/
if you are making a bunch of games with it, I think it is pretty fair. They let you use it for free as well, you just need to pay the extra money to publish with it. Although, I will agree, I like the pricing on udk and unity a bunch better.
Yeah, "I was in the top 8 of my class" really means "I'm number 8". Everybody always is trying to skew their scores.
I would kill for a good lua autocomplete. I would even happily give up some of the features of the language to have it.
I have just started writing one for the love2d 0.8 (upcoming version), but it is not finished yet. So yes, the love2d engine is the way to go. If/when I finish it, it will be announced on the loved2 forum.
Lanes is very nice to work with
 The comments section is missing block comments. 
&gt;can you point me to some exemplary lua projects that I could read? [tir](http://tir.mongrel2.org/) comes first to mind.
Neither am I, and I've been doing Lua since it was first included in Garrys Mod. This is IMO one of the few problems with Lua (or one of it's strength, it's a matter of perspective you see). It's easy to get lost in the myriad of ways to do something.
It's mostly a rebranded Lua, with a couple of patches and libs bundled in. The fact that the "author" decided to rename it hasn't been well perceived in the Lua community. What would be the interest of a rebranded Lua? It would be interesting if it came with an editorial line, bold/intelligible/consistent political choices, and a community building interesting libs and practices around it. In a nutshell, if the fork comes with the equivalent of a Guido van Rossum, then it adds value. Here, the people skills of the author haven't excatly proved amazing--if I remember his attitude when confronted about the renaming, he essentially answered "fuck you bitches, I'm legally allowed to do as I want"--, and indeed he hasn't built the slightest beginning of momentum around his initiative; it doesn't even look like he tried, actually. So if you consider that programming languages/platforms primarily are social phenomena, then Idle is clinically dead. If you consider them to be technical artifacts, then Idle is just Lua, minus source code availability. In both cases, I can't think of a reason why you could be interested in it.
Would a good contrast to this be 'Love'?
Definitely! You know why you should (or shouldn't) pick Löve, there's no mystery that this is plain Lua + awesome libs, you get the sources, and you get a community which knows what ties it together.
I view Löve in the company of Processing. I program stuff in Processing quickly and port it to iOS and it is quicker than doing the direct route. I suspect I could do the same with Löve.
Don't you mean why does GOOGLE keep designing ugly languages? Go and Dart are both Google-developed, after all. Not that I think Go or Dart are particularly ugly, and I get where each are coming from. Go is actually very much like Lua, only with static checking that finds bugs at build time -- and I think it would be easier to write tools for it as a result. Dart is nice, but very bulky; only useful if you are writing a big web app. Lua can't help there, since only JavaScript runs in the browser; you'd need a Lua-&gt;JavaScript compiler.
There is [Emscripten](http://syntensity.com/static/lua.html). However, I think it's actually converting the C of the Lua sources into JavaScript and the resulting code is horrendously large (hence the load time).
&gt; I am a Python Programmer, knows C, PHP and Ruby, doing mostly of my work on &gt; the web. Anyone has a comment about why would be good to me to learn Lua? Lua is designed to be easily embedded and extended. If you need an extension language for a C app, you'd be hard pressed to do better. It's written in portable ANSI C, it's tiny and fast (much faster than Ruby or Python), which is why it's so popular in game development. For general scripting, don't bother. Your needs are more than covered by Python and Ruby. 
&gt; Why do **I love** the freedom Lua and **Javascript** gives to the programmer while so many people try to avoid them? **Death to the curly braces!** Wait.. what? Javascript is one of the languages that look like Java and C++ you were complaining about, and it's full of curly braces. Lua uses it's share of curly braces, too, given that all data structuring is based on tables. Anyway, Go and Lua cover radically different domains. Go is a *systems level* language, designed as a sane replacement for C or C++ for systems programming. It's the kind of language you would write something like Lua *in*.
And to that, Hate. 
Yeah, I don't think that counts. It shouldn't be that much of a problem to convert from Lua code to JavaScript directly, but there would be a zillion pitfalls, and I don't feel compelled enough to write client-side browser Lua to take on the project myself. :)
Yeah, his readiness to fork lua disturbs me as well. Surely he could have done most of those things without making a "new" scripting language.
Probably not too terribly hard to write a lua bytecode interpreter in Javascript, however slow that'll be.
That's what you get with Emscripten, effectively. It would be far better to do a "compile" from Lua to equivalent JavaScript, since the languages are so similar. Variable scoping would be one of the hardest things to get right, but other than that, it shouldn't be too hard. It just will take time.
Dr. Norman Ramsey had a good answer on stack overflow as to why Lua is an interesting language from a language standpoint: http://stackoverflow.com/questions/2100902/is-lua-interesting-from-a-programming-language-design-perspective/2102399#2102399 If you're asking why you should use Lua instead of Python or Ruby or PHP for web development for purely practical purposes, then the answer is that you probably shouldn't. You should learn it if you have something to do in its problem domain.
Hi /r/lua. I build a website that allows you to develop mobile adventures with lua. Lua runs on the server side and controls the user interface and game logic. Players can use a normal browser (on their phones) to play. There can be multiple players in one game. Players can be guided to locations or interact with the environment or other players by scanning qr codes. I tried to make it easy for programmers to get started: There is lots of executable example code available on the [documentation page](http://geolua.com/doc). I'd like to hear your feedback. Thanks!
That sounds cool -- the developer side looks nice. The player side is kind of bare. There are two adventures, both in German, with no real description. I don't really get a good idea of the gameplay from looking at the website.
Thanks for your feedback. You're right. Player content is missing at the moment. That's where developers come in :-) There is a third ["adventure"](http://geolua.com/adventure/widget-gallery-132), showing all available widgets. Of cource that's not gameplay, but you might get an idea of what's possible.
This looks like a nice idea, love the API. I'd love to make some things for this but I have a problem of lacks (motivation(hopefully dealing with this soon), test subjects, working phone). I was thinking maybe something along the lines of a capture the flags type thing, and maybe the flags could be booby trapped. My suggestion to you is maybe find some creative types to pitch this to.
Capture the flag is on my list of things i'll try to implement as a proof of concept. I'm not sure yet if the precision of GPS in a city is good enough for this type of gameplay. We'll see. Thanks for your feedback. 
Tried to use it, but: &gt; require ("lua-enumerable") &gt; local test = {1,2,3} &gt; table.each(test, function (x) print (x) end) ./lua-enumerable.lua:26: bad argument #1 to 'ipairs' (table expected, got nil) stack traceback: [C]: in function 'ipairs' ./lua-enumerable.lua:26: in function 'each' stdin:1: in main chunk [C]: ? Lua 5.1.4'ism?
I only do objects when I really need them for something that couldn't be easily done without objects. I almost never needed subclassing. I mainly use metatables for clever tables that calculate data and store them into them when needed. I also mostly write all my code in a single file and only break it up in more files if I need sections of the code to be written by the users (scripting). Most people would tell you to break up your code in many files, which is probably better if you work on it at the same time with other people, but I usually don't and I really prefer it in one file. In the end I don't think there is a universally good way to structure your programs and that's why I love Lua more than other languages. Because it lets you structure it however it comes in your mind. Algorithms come into my mind like a series of functions that process data and pass them on to other functions, so I dislike remodeling that process into objects that process objects (which is why I never choose Java or C++ for my projects). How does an algorithm come to your mind? If I told you to solve a problem in an algorithmic way, would you refer to objects?
Good then just make global functions for every kind of processing and make them take and return lua tables. Lua tables are associative so creating them and filling them with data should be pretty straightforward. (I am not sure what you mean "have to type info")
just what I always say: it's not significant whitespace, it's significant indentation. Then ask the programmer if they think indentation is important in C/Lua/C++ or which it is.
Problem is, I like to use tabs, but other people like to use spaces. The standard religious response is "Use a better editor!", but the problem runs deeper than that. My editor is great, and can force the use of tabs or spaces or whatever I tell it to. But a huge motivation to use Lua is that non-programmers can edit it. And non-programmers will often end up in Notepad or equivalent, even if you give them an editor and tell them to use it instead, and then you'll have spaces mixed with tabs before you know it. I've encountered the problem when my editor -- configured to use tabs -- edited a Python file that used spaces, and suddenly the file breaks. Completely invisibly (until I enabled visible whitespace, but I certainly don't want to code with all that noise on the screen -- I'd much rather put up with brackets). And how big are those tab stops really? Mine are typically 4 spaces, but Notepad will treat them as 8, and sometimes I've seen 2 or 3 spaces per indent... In general I feel the "Use THIS editor and the language is decent!!" answer is weak, especially on teams where multiple people might have different preferences. If someone uses the "wrong" indentation style in Lua or C or C++ or whatever and I edit their code, I don't have to worry about whether my editor might break the build because of some setting that (most of the time) is invisible. Even if you tell me I SHOULD be using spaces and not tabs...well, then the reverse can certainly happen, where I start editing someone else's code who DIDN'T listen to you...
You are right, it's a potential trap for unsuspecting newcomers. There are enough python "compatible" editors out there so that you will have ample choice though. (A good one is Geany, which also doesn't leave tabs invisible.) Most python coders should also be using 4-space indents as that is the recommendation from the python community. (Sure enough, my project uses tabs... )
http://lua-users.org/wiki/SerialCommunication There you go.
librs232lua should work on both.
Has it been changed to not use immediate mode yet?
It'll have to if it's gonna be on Android, since OpenGL ES doesn't support immediate mode. EDIT: If you were asking if the desktop implementation has, then no, they're still using immediate mode.
No problem. You can just define some very simple protocol to use to talk between them, depending on what kind of things you want to do (reply-answer, streaming, ...) etc, but note that it can be a bit tricky to get the whole thing to work reliably (e.g. if you want something like a daemon that listens for arduinos connecting/connected to the system and then starts to talk with them), so you can expect a bit of debugging to go into it. You might also be interested to know that you can reset the arduino by pulling the DTR line high for a few milliseconds, which will cause the arduino to reboot. librs232lua probably has a way to do that, if not you can do it with ioctl non-portably (or use https://github.com/Amadiro/arduino-reset/blob/master/arduino-reset.c ). To get reliable communication, first thing I do when I detect an arduino having connected is to reset it, then I wait a few seconds for it to settle and then I start talking to it (with a simple handshake-protocol to verify they're in sync, have the same version number and all that). On linux, the arduino may also automatically reset if you open a serial terminal to it (e.g. you start reading from the serial terminal by opening the device file). If you require your setup to work so that the arduino can never be (accidentially/at all) reset via USB by the host computer, you might need to do some hardware modifications to the arduino. Also, on highest baud rate, the transfer rate is something like 14KiB/s.
I am actually starting to write a 2d scene graph library for opengl 3.2 (mac at this point) because I haven't found anything else that does drawing stuff and using 2d drawing command equivalents in a modern opengl wouldn't make much performance sense (creation and destroying of buffers is expensive like glbegin is).
Saw this on HN and thought it was awesome! As a side note, astonished by how courteous the lua mailing list is. 
VBO's have been in love for quite some time in the form of spritebatches. 0.8.0 will move nearly all of the code away from glBegin/glEnd in favour of plain vertex arrays where applicable. 0.8.0 will also include fragment shader support in the form of PixelEffects.
It's worth noting that this is an unofficial port and the people doing it are rewriting the whole backend in Java rather than using the existing C++ codebase.
link?
Works well, a couple of bugs making games behave differently on Android, but performs pretty well. Wish github would let me upload my demos though :|
The present code is a heavily modified code I found on a mailing list. What it does is draw a triangle and saves to a file. There is no GUI. But right now it is mac only. I want to extend this to be on Windows eventually. I am very close to starting general scene graph stuff. The work has been to go from NSOpenGLContext and glBegin stuff to CGL and vaos. Right now everything is mostly abstracted and rough. The original code is the second commit, and the commit message says where it came from. Always welcome thoughts on it. https://github.com/iaefai/GrapheinPure
I don't think there is a hard way.
Some people are just too clever for their own good.
[It was](http://pastebin.com/S8CwrjKF) :)
&gt; I'm pretty sure this code to list directories and their file numbers constitutes an assault on ~~the~~ language I think that's a little closer to the mark.
&gt; The second phase of the work will allow direct generation of native object files with embedded bytecode. These can be linked against an application or put into shared libraries. Work for this feature is scheduled for Q3/2011. isn't that HUGE? ABI compatability with c ?Now I could write parts in Lua and link with c applications. That gives a *lot* of new possibilities. Personally, I would instantly use it for regex calls. I don't know lua well, but it just has to be a million times better and easier than the pcre c library.
I don't get it. Lua is a really nice, simple, easy to learn language. You can implement the concept of classes and objects within Lua. Someone tell me what I'm missing.
http://i364.photobucket.com/albums/oo90/Darksilverstar/Gifs/Random%20gifs/8a83ded1.gif Are you putting it in the android market soon?
Win32 binary: http://rghost.ru/35123231 Win64 binary: http://rghost.ru/35123391 VS10 solution: http://rghost.ru/35123681 **The "download" button is the large black button under file name.**
Instead of just a link it to a bin, how about link to a changelog to open up discussion on how we will be using Lua differently.
* [Google cache of the work readme](http://webcache.googleusercontent.com/search?q=cache:W2JHlaEIdiUJ:www.lua.org/work/doc/+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us#changes) * [List of incompatibilities from refman](http://www.lua.org/manual/5.2/manual.html#8)
This is very cool. It's a pity I have no use for a web server, but if I ever need one I am so using this.
Goto is the best and bravest thing that ever got into Lua... :-D
&gt;Equality between function values has changed. Now, a function definition may not create a new value; it may reuse some previous value if there is no observable difference to the new function. What's that supposed to mean?
Supposed you define a function in another function. function foo() local x = 3 return function(y) return x + y end end Every time you run foo(), you get back the function which adds x to its argument. With Lua 5.1, you would always get a newly created closure: &gt; = foo() function: 0x1fe8a40 &gt; = foo() function: 0x1fea3e0 And so on. With Lua 5.2, if the upvalues haven't changed (x is always 3 in this example), it may return the exact same function again, instead of creating a new closure. This can save a lot memory for some applications. Edit: Possibly incorrect, see my comment below.
What about this: function foo2() local x = 3 return function(y) x=x+1 return x + y end end Will foo2()==foo2() but a,b=foo2(),foo2() a() a~=b I guess I'll compile my lua binaries and try that later.
As I understand it, that should generate a new closure every time. Because 'x' is a new and different every time. Actually, I think my example is incorrect. If 'x' was a global, then 5.2 may return the same closure twice.
Yeap got it. In your example x is discarded every time foo ends (as far as a new execution of foo is concerned) but it is captured in the anonymous function's closure so every time it's a different closure. But if the closures are tha same every time the old function is returned. Thanks!
The label syntax is fugly, though. 
If you mean the ::example:: syntax then yes. It's not like Lua at all. But I can't think of another way. Well something like return would make sense though. label example goto examlpe for example.
Equality between two functions in Lua is (like tables) defined as the equality of the references to each of those functions. That is not new. In Lua 5.2, however, a second function definition may evaluate to a reference to an existing function (reusing the bytecode), as long as the implementation can determine that the two functions are equivalent (same computations, same upvalues, etc.). From a programmer's point of view, if you defined two functions in 5.1, `f` and `g`, `f == g` would *always* evaluate to `false`. In 5.2, this is not necessarily the case: `f == g` could *potentially* evaluate to `true` if the implementation determined that `f` and `g` are equivalent. Here's an example: t = {} for _, v in ipairs{'f', 'g'} do -- t.f and t.g are the same function t[v] = function(x) return x; end end -- prints false in 5.1, true in 5.2 print(t.f == t.g) On the one hand, it's a reasonable optimization. On the other hand, we have to be more careful about function equality now (although I doubt there ever was a lot of code that relied on it).
IIRC strings do that thing too. If you reuse the same string (let's say you let the user type it 100 times) then all references will point to the same "global" object no extra copies of the string will appear in the memory. And for that reason string equality operations in Lua are lightning fast since you compare the hashes and not the string actually. So I guess what you mean is that as long as the bytecodes hash into the same value, no new copy of the bytecode will be created and the old one will be reused. Either that or that was already happening in 5.1 but for some reason functions never had the same bytecode (which seems strange so I suppose it's the first case and not this one).
Right, for strings, the process is called [interning](http://en.wikipedia.org/wiki/String_interning). For functions, it gets a little more complicated than strings. As far as I can tell, the only time you'll get the same reference is when the function definition occurs in a loop, a closure, or a coroutine. Function definitions at top level seem to always generate a new function. I'm not a fan of the new behavior, but we'll see how it plays out :) Edit: Actually, the more I think about it, the more I welcome it. The only times you'd get this kind of behavior are times you probably want it (inside object constructors, for example). I haven't had a chance to look at the source yet, but note that you wouldn't need to hash or even compare bytecode to do this: the compiler could do it by examining the environment of the function definition.
The lua-users wiki explores some practical uses for goto: http://lua-users.org/wiki/GotoStatement
You may have more luck simply using the Lua C API. Check out [this](http://www.lua.org/pil/24.1.html) simple Lua interpreter. You could then link in LuaSocket directly, or at runtime with the require() function in your script. 
To be honest I do not know how to code in C, although I'm planning on learning it soon, so this is a possibility.
you'll need to: * recompile and statically link the DLLs with the interpreter; * register them in C in package.preload; * embed and preload Lua scripts as C data (I guess that's what srlua does). To sum up, what you're trying to do requires a good mastery of C and of the linker; I don't know of any utility which would make it easy, I'm not even sure it's possible to make one. You might want to have a look at Love2D.org though, I believe they have interesting packaging abilities.
Thanks. I'm using Love2d for the client, but I was trying to keep the server as a standalone (for no real reason). In the end, wrapping my main loop in a `love.run()` function and packaging with Love2d is probably the simplest route for me to take.
You're not missing anything. Moonscript just isn't for you. It tries to express things in a different form. Some might like the new form, you might find it awkward. That's just the way it is. One thing is for sure: leafo (the Moonscript creator) will learn A LOT implementing this language. 
Then who is moonscript for? Or is it mainly for leafo?
Don't post this here. It has nothing to do with lua. /r/gamedev /r/ludology But before you go post there let me give some advice. Just make it.
I don't know, maybe it is only for leafo. Maybe if leafo keeps pushing, others will join. Only time will tell. 
Sorry
No reason for apologising. We have all been there. GameDev is really exciting. May I suggest rather than programming this you simply grab a deck of cards and give someone a game. Also a spreadsheet would be helpful. Try calculating all the risk/reward probabilities. Good card games are about creating interesting risk decisions.
Depending on how your game is structured, that could actually work out OK. If you are using the physics engine, you could run that on the server, but just not display anything, and compute updates in the love.update() function. I've been thinking about making a client-server game using Love2D as well as [ZeroMQ](http://www.zeromq.org). This library (which has a good Lua binding) makes network communications a lot easier. I haven't tried to bring that into a Love2D project yet.
I assume the thing you're really asking is "why isn't lua implemented in browsers" or "why isn't lua a webstandard" -- To which I can give a few reasons, but none of them would be particularly impossible to overcome. Mainly, lua doesn't have the DOM or a similar model, so something like that would need to be created first. Then you'd need to convince the browser developers to maintain an additional language implementation, and then the W3C to officially include it into their webstandards. The latter two would probably pose the largest difficulties of the three, as probably neither the browser developers nor the W3C feel a need to do so, as well as added difficulties for turning lua into a web-standard, since lua is not actually standardized in any way, nor is it under the control of the W3C or any other such standard committee.
So, would bringing Lua to a browser be worth it in your opinion?
Sharing the same paradigm probably doesn't help that much - CoffeeScript and Dart for example both try to make JS look more like Ruby or Java respectively. Another problem I think is political. Javascript is run by committee now, whereas Lua is rather tightly controlled and conservatively changed, and I'm not sure that the Brazilians would like to open up Lua to input from 5 different implementors on things like a DOM API nor do I think Apple/Google/MS/Mozilla would like to use the reference implementation and therefore be held hostage to some external entity.
If lua as well as possibly its instruction set was standardized, I think it'd be very nice, so I guess that's a "yes". Until that happens (if ever) I think the best solution is to just compile it down to javascript or interpret it, which shouldn't be too bad either. It can also serve as a fall-back for browsers that do not have lua support yet, once browsers have started to implement it natively (e.g. a &lt;script language="text/lua"&gt; tag or so, and if the browser doesn't interpret it natively, some javascript compiler can extract all those tags and interpret it)
What it misses is a market for non-javascript: JS kind of sucks, but not to the point of unusability. What people really do want, however, is compatibility with 90% of deployed browsers. There are three ways to do that: * cook up a language whose main feature is to compile into readable JS. That's the CoffeeScript route, but the resulting language can only be marginally better than JS. * being as big as Google, and spend millions pushing your language down everyone's throat. That means getting the engine accepted in webkit, including Apple's flavor. It's the Dart way, which is acknowledged as a high risk, high reward bet by Google (they also keep a close eye on Ecmascript evolutions, in case Dart doesn't take over the world). Moreover, Dart is optimized for programming-at-large, so its niche isn't exactly JS's. It would be even harder to impose a language which is merely a marginally better JS, such as Lua: the improvement wouldn't be worth a revolution. * stay with JS, a.k.a. the choice of the 99%. As an individual hacker, you want a pleasant language to work with. But most critical code is written while on payroll: the one giving order doesn't care much about the fun of hacking. He cares about reasonably priced, reasonably replaceable workforce; he also cares about minimizing technological risk he doesn't fully understand. From his point of view, JS is much better than funding a Lua revolution.
Wouldn't the DOM be more like a library? If the browser implementors could agree on an API, it wouldn't affect the VM standards, would it? And they could just make a bytecode-compatible fork anyway, right? I thought JS was already embedded in browsers in pretty much the same ways that Lua is embedded in anything else.
5.2 has continuations??? Or is it just planned for the future? Because it sounds really fun.
No, I don't think so. Unless I misunderstood 5.2 has `goto`, and continuations were mentioned there. The point was that people pick on `goto` but love continuations, even though in Ierusalimschy's opinion "continuations are much worse". Maybe I'm confused though.
I see you mentioned love2d, you might be interested in checking out our newly active subreddit for it: [r/love2d](http://reddit.com/r/love2d)
Already subbed ;)
Awesome! Thanks :)
That was his point indeed, it was made clear(er) in the oral presentation: "give me a break with your self-righteous _goto considered harmful_ posture, it makes you sound phony, not competent" (it was said much more politely though).
Renoise has had a Lua scripting API since ~November 2010. I learned Lua using the Renoise API. I wasn't familiar with Lua before. Found this subreddit today, subscribed, and am wondering if any other Renoise users are in here? Good times. 
I'm a very casual Renoise user, although being a programmer myself of course I find the Lua aspect very intriguing :)
Ok, so maybe this isn't the place to start this discussion, but - I recently started a little 2d tiles-based RPG game project in Lua and was looking for libraries to help out. My only requirement is that it has to be cross-platform deployable (Win, OS X, Linux, and iOS - bonus points for Android &amp; Console options). I came across Love (of course) but the necessity to embed the LOVE application seems prohibitive to this requirement - is there a way around that?
I crossed out the ones that aren't relevant to a cross compiler: It shares the same paradigm. ~~It's highly embeddable.~~ ~~Sandbox-able.~~ ~~Fast.~~ ~~Stable.~~ Well-documented ~~and maintained.~~ 
I was thinking of reasons (other than political) why Lua couldn't be a native client side replacement. Cross compiled solutions are always going to lose the battle long run because when they break you still need to know javascript, and they will always run slower that properly written native. 
I've written a fairly complex binding for the [Irrlicht](http://irrlicht.sourceforge.net/) rendering engine called [IrrLua](http://irrlua.sourceforge.net/). It has not been updated in 6 years, but I'm familiar with binding c++ to lua. From what I remember, [SWiG](http://www.swig.org/) had the best support for c++ features, as it uses a real c++ parser. Luabind is also good, but you must write interface classes to use it. [tolua++](http://www.codenix.com/~tolua/) is probably the worst. It's based on tolua which binds to C, but C++ is a different beast all together. Basing tolua++ on tolua was a mistake IMO. The bindings it generates are good, but it has a hard time parsing some c++ constructs. 
Thanks for your authoritative information. I wonder if things have changes respect to 6 years ago. I'm not an expert of SWIG, but as far as I remember, you have to write your own interfaces, didn't you? I'll take a look to SWIG and Luabind, though :)
I suspect that the name is very appropriate. But it is always interesting when people do these things because they can.
Lua has a JIT written in assembly, I'm assuming once these methods have compiled, they should be very fast because I don't think there's a whole lot of variation.
Only LuaJIT has the jit compiler, not plain old Lua. 
Yes! After seeing all the amazing scripts the wow gamers came up with, I realized blizzard was ahead of the curve by choosing Lua as a scripting language for non programmers. 
A little off-topic, but that you wrote a MUD server with Lua intrigues me a lot. I was going to attempt to do something similar, but I could never get past certain issues and finally put it off for another time. Of course my goal was to attempt to write the entire thing in Lua (with luasocket), but the main issue I couldn't get around was that I couldn't call, monitor and terminate outside scripts (for custom scripts that ran in-game for certain things).
I'm personally not moving to 5.2 until Luajit supports it. The speed is too valuable to me.
I was going to try to have user-made scripts be sandboxed and monitored closely by the system so that it would only allow a limited number of lines executed before auto-terminating. Another idea I was experimenting with was to make various parts of the system as modular as possible. So if something goes horribly wrong an administrator can "restart" the MUD server without having to take the core offline and cause everyone to disconnect. *Theoretically* players wouldn't notice a thing happening since it would occur so quickly. Mind you, all of this was mostly planning and experimenting a while back and I didn't get very far so I've no clue if that would work the way I would have intended.
Pretty much everything you said is completely wrong. LuaJIT is a VM replacement which implements the Lua 5.1 language. Its still being developed -- there were commits to the LuaJIT git repo just a few days ago. New features from Lua 5.2 are not available in LuaJIT at the moment and the LuaJIT developer hasn't announced any plans to support them. 
Looking *for* help, whoops
And LuaJIT has similar features to some of the things that were fixed in Lua 5.2, such as the restrictions on coroutine yields. 
I have done next to no work for coding, just a little bit of lua and a little bit of javascript 
First and foremost — Programming in Lua (make sure to read 2nd ed., as 1st is for older version of Lua). http://www.lua.org/pil2/ This also may help (or not — as it is in very early stages and a bit stalled): https://github.com/lua-cookbook/lua-cookbook/ https://github.com/lua-cookbook/lua-cookbook/tree/master/out/en_US
I can also back Programming in Lua 2nd edition. Read 2/3 of the book and I'm pretty sure I know how LUA works. Need to start coding to truly solidify the information, but I have a base framework for my neural LUA compiler :)
Not only is it a good Lua programming book, it's a good programming book in general. 
It's worth noting that LuaJit has a few 5.2 features backported. Search for 5.2 on [this page](http://luajit.org/changes.html) for a list.
Yeah, I actually quite like those. I have them enabled at work because we're committed to sticking with LuaJIT permanently, but not on my home project because I still need the flexibility of the vanilla Lua codebase.
Sorry, but he's confused about LuaBind. It works without interface classes, and supports all the functionality you need. SLB is modeled after LuaBind (to some degree); implementing LuaBind is almost the same, only LuaBind has more features. It's really the Rolls Royce (Hummer?) of Lua binding generators. Everything else is missing at least one of the features you mentioned (the virtual function overriding being the most common). I did a search of Lua binding generators a while back, [detailed here](http://realmensch.org/blog/fun-lua-bindings). I chose not to use LuaBind because I'm doing mobile development, and it was adding megabytes to my footprint. You'll want to use LuaJIT if you want speed, and LuaJIT works with LuaBind. But LuaBind itself isn't the fastest binding (as I mentioned in my review of bindings linked above). Honestly if you want the most speed, the best thing you can do is use LuaJIT and use a faster binding that *doesn't* allow deriving from a C++ class, and instead create a single derived class that stores a set of Lua callbacks, one for each class, settable from Lua. I'm using some bindings generated by Dub that are really tight, and I use that trick myself -- my "GameObject" has an "update" member that I can set from Lua, and it gets set to be a Lua function that gets called then GameObject::onUpdate() is called in C++. If speed isn't that critical, though, LuaBind is pretty much just plug-and-play. Good luck.
I think the right answer is to ignore Apache and be excited about Nginx+Lua. See [this project](https://github.com/agentzh/openresty), which has Nginx packaged with the Lua plug-in and a bunch of other useful plug-ins. The result? A web-app server faster than, and far easier to program for, than Node.js. Reports of 50k+ connections/second on a VPS are common, and because Lua has coroutines, you don't have to use the awkward callback mechanism of Node.js. Alternately, you can go in the [Tir](http://tir.mongrel2.org/) direction, if what you really want is Lua-based HTTP templates that are served up by a fast server. Of course if you're stuck on shared Apache hosting, then ignore everything I said. Nothing to see here. ;)
This was caught in the spam filter. Check your code carefully, I think in one instance you're using lowercase 'L', and in another case one '1'. Also, the code would be faster if you checked the condition of love.mouse.isDown() once instead of 5 times.
i'll check that out. thank you! 
Lua does not support binary literals, but it does [support hex](http://www.lua.org/manual/5.1/manual.html#2.1).
Afaik [luakit](http://luakit.org/projects/luakit/) is able to process the DOM of a page. At least it's possible to call Lua code from javascript.
You should also look at this: https://github.com/mherkender/lua.js It's the way which can bring lua to brownsers which doesn't have native lua support. Here is the blogpost where author describes why he did it: http://blog.brokenfunction.com/2011/11/how-to-make-a-massively-cross-platform-game/ And here is my simple, but working lua sandbox shell for all brownsers based on the lib above: http://strajt9.sweb.cz/f/lua.html (use the lower textarea to write a code)
Looks great, except flash is dying. Which is a good thing.
I'm creating a project with JavaScript generated by [lua.js](https://github.com/mherkender/lua.js) right now. It's a candidate for not-JavaScript in my book.
I'm building a cross-platform game using lua.js as well. I'm thinking that eventually I'll be able to bundle the interpreter into Chrome and run Lua natively. Hopefully my game will be done by the time Chrome is ready for that. :)
So how short should a string needs to be in order to get interned? And the random seed is similar to the safe hashing thing? The one that is used on webserver (in PHP for example) to avoid user exploiting string collisions?
1. 32 bytes on 32-bit platforms, 64 bytes on 64-bit ones. 2. Yes.
&gt; Using this method for OOP I also need 1000 copies of the code for each and every method in the class. This isn't quite true - from what I understand of Lua, you'd still have one copy of the code, you'd just have 1000 different closures with upvalues attached for each and every method. It's still painfully inefficient, agreed, but it's not quite as ruinously so as what you're suggesting.
Do you have a source for that? That would be interesting to know.
Here comes again my Lua pet peeve: because it has generic mechanisms which allow to redefine basic services, some people think it's a smart idea to do it. I mean, it's not naughty _per se_, but that's a kind of solitary pleasure that you should do alone in your room, and not talk about in polite company. Programming languages are (among others) a tool for developers to communicate with each other. If you redefine the basic vocabulary before stating the most trivial thing, you're missing the most basic skill needed for any programming-related achievement. And of all things, redefining OOP?! You know OO is largely sold as a way to improve reuse and interoperability? You realize that "custom interoperability framework" is the mother of all oxymorons? All of that because colons tickle your Java-tainted sense of aesthetic? That's not being "*the guy in the middle*", that's being the forever-alone developer who'll never produce anything taking more than a couple of his individual man-months, because he doesn't understand that non-trivial development is a social activity, which requires social conventions to be learned and respected. There are many people sharing this misunderstanding, but that's a mental bug, not a feature. It should be frowned upon, not advertised.
&gt; I can't say if vanilla Lua would behave the same way. It appears that it does. That changes my perspective a lot on this closure method.
I'm still not sure it's a good idea, note. First, the method he's using involves one upvalue parameter *per member that the function touches*. That's going to add up fast. And if you have a few dozen member functions, you could be looking at a kilobyte or more of overhead, per instance of the class, before you've even added data. Not catastrophic, but certainly not pleasant.
Yeah, I tested with a dozen methods and two state variables (e.g. two upvalues per method) and the memory usage was over 8 times higher using closures. For half a million instances, that's the difference between ~50 MB and nearly half a GB of RAM. But most apps won't have nearly that many instances. Interestingly, the performance of a method call in either case (each method reading and/or writing the two state variables), was pretty much the same, with only a slight edge to metatable methods. I guess if you really hate using `:` for method calls or the verbosity of qualifying object state with `self.`, and you're not overly concerned about memory usage, the OP's method is not the pure evil I though it was.
Where is the error? Bottom right. The code? That's classified.
Looks awesome.
I wonder how it compares to [OpenSCAD](http://www.openscad.org/) - how usable it is for computer assisted design.
I have an Android phone and I use SigmaScript.
If you jailbreak, you can get a terminal, a Lua interpreter and a real Unix editor. But unless you already know Emacs or Vim and use bluetooth keyboard, you're not going to find a better native code editor that Codea's. It's got a lot of features to make editing on a touch screen less painful.
There's also http://www.keplerproject.org/luajava.
Heroku has shown to be a really useful platform. Please keep in mind that this is still pretty simple implementation. I've added luajit and Postgres to the installation. Please let me know of you have any questions or problems.
Lots of things. I use it as a scripting language on my independent games. I'm also using it as the addon environment for a AAA game I'm working on.
I use Lua mostly for high level programming and it has completely replaced my use of C++. Nowadays i only code low level functions in C and interface that with Lua using the FFI interface. Usually using the LuaJIT2 implementation because of its speed. Lately I am finding myself writing everything in Lua and only re-rwiting code in C when appropriate or during optimization.
For embedded development: technically it's still C from customers' and management's PoV, but I get most of Python's development speed for those 95% of times when C's speed isn't needed.
I admit I use it to make Adobe Lightroom plug-ins only.
I'd never heard of love2d; Downloaded and ran the demos and was pretty impressed. Do you happen to know if it does hardware accelerated graphics natively on all the supported platforms? Looking around the documentation I can't seem to find the answer.
Dive into the source, it looks like it is all OpenGL in `modules/graphics/opengl` configure: error: Can't LÖVE without OpenGL 
It's OpenGL on every platform. Whether that's substantially accelerated or not depends on correct installation of the proprietary driver. It currently uses the old style immediate mode rendering, though. I think they're looking at rewriting the backend to use retained mode and modern OpenGL, but its obviously a big task.
The built-in debug library basically gives you hooks to put together something like what you describe, but it doesn't give you a pre-defined solution out of the box. I suspect that the [tools described](http://lua-users.org/wiki/DebuggingLuaCode) on the lua-users wiki are generally just using those hooks, though some might have further customizations. EDIT: Side note: If anyone has some Lua development tools that provide this functionality that they really love, I'd certainly be interested in hearing about it.
I use Lua a lot for just general programming expirements. It was the language I learned to program with years ago, and I've yet to move away from it. I can't tell you how many useless things I've made with Lua just for fun. Nowadays I've been working with LÖVE and Minetest. I did a school project two months ago in LÖVE to recreate a few arcade games like Snake and Tetris, which turned out to be fairly easy. More recently I've been playing around with server plugins for Minetest, a Minecraft C++ clone with an extensive Lua API.
I just started fiddling with Lua as I wanted a small, fast language with a lot of Scheme goodness for systems hackery. I very much like that liblua.so 5.1.5 for 32 bit x86 Linux is only about 100k gzipped; this makes a quite reasonable addition to an initramfs. LuaJIT's dynamic library is about double that, so still not bad. As a learning exercise in the FFI and multi-thread/VM programming, I'm writing a printer backend for LPRng. One unfortunate side-effect of my playing with Lua seems to be that I'm tending to forget semicolons in my C code. 
O use it on my computer for all kinds of programming (I love love2d). I use it with my android with sl4a. My microcontroller of choise also uses lua (elua).
Love2d as others have said. Also wrote a reddit bot and was making a chat client using regular Lua.
[LDT](http://www.eclipse.org/koneki/ldt), the official Eclipse plug-in for Lua development, supports interactive debugging. It's not as well known as it deserves because it's a pretty recent project, but it works just fine. It's probably more intuitive if you have some previous Eclipse experience, though.
I hope that you do not take this badly, but... why using the GPL on a library? (LGPL or BSD/MIT would make much more sense, specially the later, as this is for the Lua ecosystem).
Yeah, OpenGL was what I was asking. I wound up grabbing the source and messing around with it- I'm really quite impressed.
Someone posted an issue about that on Github last night. I've been thinking about it. My main goal with whatever license I use is to ensure that any improvements to the library make it back into the main repository, so that everyone is free to use them. The fact is that the GPL accomplishes that and the MIT license doesn't. So that's why I don't use MIT. But, at the same time, I'm not super happy about the fact that just using a GPL library (unmodified) makes your code GPL. For compiled shared libraries I can use the LGPL, which allow using the library but any changes to it (and only those changes) must be shared. But my understanding is that that doesn't really work for interpreted libraries like this one. Maybe I could change the license to LGPL anyway, and put in a note saying that if you use color.lua and the Lua table it defines unmodified, then that's not a derivative work for purposes of the LGPL. I think I'll do that actually. Thanks for bringing that up, and more importantly, thanks for net being a jerk about it. :)
Have a look at Codea. It's an iOS app that let's you program Lua on an iPad. They are working on creating a way to publish apps directly into the AppStore.
Indeed, the whole issue of GPL/LGPL in interpreted languages makes my head spin. Your solution seems appropriate. &gt; thanks for net being a jerk about it. :) Thanks to you for being open about it. Take care, and thanks for your work!
I have had good results with [Wax](https://github.com/probablycorey/wax). I wrote the entire top level app in Lua with external libs in Objective-C and C. I wrote no Objective-C, though I did have to *sling* some. I created Lua bindings to C code via the regular c-lua interface. I would like to give * [http://playcontrol.net/opensource/LuaCocoa/](http://playcontrol.net/opensource/LuaCocoa) * [https://github.com/aptiva/TLC](https://github.com/aptiva/TLC) bridges a try. 
I disagree, Lua can be used to create entire apps on iOS. It is only *easy* if one uses Corona (which is itself a walled garden, so if Corona doesn't support something, your SOL). The other bridges still require you to know iOS and Objective-C while still doing your app logic in Lua.
&gt; I disagree, Lua can be used to create entire apps on iOS. Huh? I didn't say they couldn't. In fact, I write apps in Lua for iOS (using MOAI), and there have been #1 apps on the App Store written in Lua (like Crimson: Steam Pirates). So I have no idea what you're disagreeing with. &gt; It is only easy if one uses Corona (which is itself a walled garden, so if Corona doesn't support something, your SOL). The other bridges still require you to know iOS and Objective-C while still doing your app logic in Lua. The word "bridge" usually refers to something a lot thinner than Corona or MOAI, essentially a Lua-to-Cocoa FFI. Corona is *much* more noob friendly, but MOAI is still easy (for game stuff, anyway) compared to writing everything in Objective C with the advantage of being totally open. I can code directly on my iPad with MOIA, just editing Lua in Vim (via an iOS SSH client and OpenSSH). 
One can make an Oroborus by using this project, https://github.com/timcameronryan/colony-js which compiles JavaScript to Lua. https://github.com/mherkender/lua.js Compiling Lua to JavaScript. You can support an infinite number of moons with an infinite number of turtles. This would make a nice early morning hack project, ClojureScript -&gt; JavaScript -&gt; Lua
good job
The [lua-users wiki](http://lua-users.org/wiki/) is a useful reference. Here are [some of the bindings out there](http://lua-users.org/wiki/DatabaseAccess). Personally I haven't used Lua much for DB interaction. It's a nice language for embedding. It can also be used stand-alone, but by sheer volume it's more used as an embedded scripting language. It's a nice, small, pragmatic language with some neat features for its size. Also, the C API makes it dead simple to extend with other C code.
Simple and pragmatic is good for me. I am also interested in performance, interested in testing some of my Python scripts converted to Lua and run on the JIT.
It's not a great benchmark for performance (because I'd honestly say it's more hard drive limited) but my above example with the tracks.sqlite database, I decided to iterate over the entire table and put the files back into gzipped files. It took roughly 22 minutes to create 812037 gzipped files totaling 5327 megabytes. The source database is 7134 megabytes for reference. If you're interested in the code I used for that, I could post that as well. Also, I used the standard lua interpreter. Since I was assuming this was hard drive limited, I didn't bother with running it with luajit.
I make no claim that this is the best way to do this. (For example, I probably should have done the directory check before opening a connection to the database. I also could have had the requires in the scoped block as well. I wrote this on just kind of a whim.) :) If you disregard the block to make sure the subdirectory exists, it ends up being less than 20 lines of code. It's worth mentioning that gzip is included in zlib from the luazlib from luaforge. #!/usr/bin/lua require "luarocks.loader" require "luasql.sqlite3" require "lfs" gzip = require "gzip" env = luasql.sqlite3() conn = env:connect("tracks.sqlite") selct = [[ SELECT id, track FROM tracks; ]] -- make sure the output directory exists or create it -- (in a local scope) do local attr = lfs.attributes("tracks") if not attr then if lfs.mkdir("tracks") ~= true then print("Unable to create directory 'tracks'") os.exit() end else if attr.mode ~= "directory" then print("'tracks' exists but is not a directory") os.exit() end local file = io.open("tracks/extract_sqlite.tmp", "w") if not file then print("Unable to write to directory tracks") os.exit() end file:close() os.remove("tracks/extract_sqlite.tmp") end end cur = conn:execute(selct) row = cur:fetch({}, "a") while row do file = gzip.open(string.format("tracks/%s.gz", row.id), "w9") file:write(row.track) file:close() row = cur:fetch(row, "a") end cur:close() conn:close() env:close()
Python libraries are the killer feature. Curious - what makes you a huge Lua fan?
Lua was designed (very carefully, slowly, iteratively, patiently) by particularly brilliant engineers, and it's just *elegant* in a way that Python, Ruby, Perl, et al. are not. It's tiny, both in terms of implementation, runtime footprint, and conceptual burden on the programmer; it makes the most of a handful of carefully chosen concepts. For instance, Ruby has like 5 different function types, all with subtly different semantics. Lua has one. Functions are first class values, just like a string, you can assign them to a variable if you want, or leave them unnamed (using them like lambdas), it doesn't matter. They can receive and return any number of values; no need for "out" parameters, returning tuples, etc. They are lexically scoped, have proper tail calls, etc. Very simple and generalized. Lua has exactly one data structuring mechanism: tables, which are very generalized associative arrays, like a Python dictionary that can use *any type* as either a key or value, including other tables. No separate types for dictionaries, sets, arrays, etc. -- just tables, which have very nice declaration syntax. It was designed for embedding, to provide data description and scripting to a host, so it's a 100% ANSI C library that you can compile into any applications, very cleanly and modularly written with no external dependencies. It's tiny, fast, well designed, well implemented, with readable syntax, clean semantics, etc. which makes it very popular in the game industry. 
Dave Nichols created a [Lua command line debugger](http://www.keplerproject.org/remdebug) written in Lua itself. It is quite easy to wrap that Lua script in some c/c++ code to make a Lua command line debug executable. This is exactly what I did for the [Zeus Lua](http://www.zeusedit.com/lua.html) IDE. Here is the [Windows source code](http://www.zeusedit.com/z300/xdbLua-src.zip) that I used to do this. Now while the source code above is Windows based, there is nothing Windows specific in the source code so it should be easy enough to port to any other platform. 
Awesome, thanks!
You bring up some good points! thank you very much now i can continue my search for answers xD and yes, this is for a game im developing on the ios and eventually the arrays will start to slow the app down alot, there are ways around it but i love the power of storing things in an array and iterating over it so i dont have to write tons of extra code to manage everything. Thanks for getting back to me so quickly!
First, I seem to recall that Lua tables generally won't shrink again. You'll need to throw away the table entirely in order to reclaim that memory. The good news is that filling the table back up will be faster the second time. Second, I don't believe you're actually clearing out the table with that code. Use pairs() to iterate over it and see what content it still has.
There is this virtual building site. You can make games and you can script things with lua. Although it is a cLua so it has wait() and other things in it.
 for i=1, #stuff do table.remove( stuff, i ) end this will only remove half of the elements: since first remove the first element (which shifts everything down), and then you remove the second element (which corresponds to the 3rd element), etc... use the following: for i = 1, #stuff do table.remove(stuff, #t) -- or: .remove(stuff, 1) end but if you want to wipe a table, make a helper function: function(t) for k in pairs(t) do t[k] = nil end end 
This is not strictly true and you can shrink a table using a very dirty hack which forces a recalculation of the array and hash part. JFYI here is a little more detail on the matter taken from Lua Programming Gems, see page 21 http://www.lua.org/gems/sample.pdf
I bought the two books, and they've been sitting on my desk for literally weeks, and I barely know any Lua! So this plan clearly is not working out. Here's my new plan: just dedicate an hour a day to working through Programming Lua, then start diving in on Lua projects on GitHub: https://github.com/languages/Lua , committing patches and stuff. At the end of the exercise -- six to eight weeks maybe -- I hope to be writing halfway decent Nmap NSE scripts. 
beginning lua is a good starting book (i actually started with that when i didnt know squat about anything)
The language name is "Lua", not ".lua". http://www.lua.org/
I was informed through reading a bit about it before hand that it is not an acronym, and is pronounced as it is spelled; lua, "loo-ah". I apologize for not properly being informed on a subject that I am a novice to and would like to get acquainted with.
Lua refers to a moon, the symbol of the language.
http://lua-users.org/wiki/TutorialDirectory Just read through it and make sure you actually understand what you're doing. Too many people try to work through tutorials as fast as they can without actually learning anything.
. . . Wow, that actually makes a lot of sense. All this time I thought the logo was a really ~~badly drawn~~ abstract olive. (Not kidding. Wish I were.)
I think what Keith was referring to was your "." at the beginning of the language name. It's just "Lua" not ".lua".
Knowing Lua is not going to ease your transition to C any more than know Python will. Lua and Python are both pointerless, garbage collected, dynamically typed languages that compile to byte code and run in a virtual machine. C is a lower level language that compiles to machine code, much like Pascal (a Pascal to C book makes much more sense than Lua to C). The only similarity is that they are both relatively *small* languages. [This is where I'd recommend you start.](http://www.amazon.com/C-Programming-Language-2nd-Edition/dp/0131103628) It's a masterpiece of lucid and succinct writing. Many (if not most) C programmers learned from this book. Get yourself a C compiler and start a page one. 
If *Learn C the Hard Way* was even remotely as well written as K&amp;R I'd agree, but it's just not. Shaw isn't half the writer Kernighan is. Page for page, K&amp;R's treatment of the language is simultaneously more succinct *and* more thorough. Better to learn C from K&amp;R, then slog through Shaw's tutorial or read something like *[Writing Solid Code](http://tetzfiles.com/eric/candyMachineInterfaces.html)* to learn how to write safer C. The critique of K&amp;R *Shaw* includes at the end of his book makes me want to punch a baby. He claims the `copy` routine from K&amp;R (a routine for copying null-terminated strings) is "broken" because if you pass it something that's *not a null-terminated string* it never stops. Fucking *duh*. That's like saying `printf` is broken because if you say "printf((char*)10)" it'll crash. 
&gt; I am reminded of recent bugs like writing exactly 4096 bytes to a Linux kernel sysfs attribute. There was a ton of driver code which assumed null-terminated strings. So they ended up changing the sysfs attribute code to only return up to 4095 byte strings. All of which is far beyond the scope of learning C. Learning what a "string" is in C, what a "character" is, what a "null terminator" means, what '\0' means, getting your head around the concept that in C a string is just a pointer to a memory location where we're going to start interpreting bytes as characters, etc. is all heady enough stuff for a beginner. Learning about buffer overruns, their implications for security, how to defend against them, etc. is all very important stuff but it's just complicating the issue. Shaw focusses on this stuff and glosses over the details of the language. The important thing about learning C is that you come away with a strong mental model of how the machine works and what your C code is actually *doing*. The *power* and the *danger* of that kind of raw access has implications that you will eventually want to learn about if you're writing production C code, but not while you're learning what an "int" is or how a "for" loop works.
Use [LuaInterface](http://luaforge.net/projects/luainterface/) [Tutorial](http://penlight.luaforge.net/project-pages/penlight/packages/LuaInterface/) require 'luanet' luanet.load_assembly "System.Windows.Forms" Form = luanet.import_type "System.Windows.Forms.Form" form = Form() form.Text = "Hello, World!" form:ShowDialog() Make sure to get the svn version as it has many bug fixes and improvements. The older version works on Linux using Mono.
I'm a complete novice, so right now I'm just looking to get the logic and reading/writing working with a crude interface so I can see how it looks. I'm intending to make it cross-platform once I'm a bit more confident. It's going to be something for creature modding rather than something like the LNP, though, I should note.
I've had success in using iuplua. Its implementation is somewhat straightforward and getting a simple layout is rather, well, simple.
&gt;Edit: Perhaps as simple as "for b in string.gmatch(a,"%w+") do" ? That's one way to do it, sure. It doesn't let you have anything but a-z and 0-9 in your words, but if that's all, then it does seem to work, sure. "Split" is one of the functions offered by the Microlight library, if you want to see how they did it: https://github.com/stevedonovan/Microlight
This particular case has very simple data, where most CSV parsing would need a more generic search pattern. But now I know about Pen/Microlight. TYVM.
Don't think there's anything built in, but the following function should do what you want. function zip(key, val) local out = {} -- handle mismatched lengths however you want to -- here I only go to through up to the shortest length for i = 1, math.min(#key, #val) do out[key[i]] = val[i] end return out end
I used Lua as the [scripting engine](http://www.youtube.com/watch?v=RauJBDhURCM) for the Zeus editor.
A Lua Text Adventure Engine: Having settled on lua as a first 'real' programming language to teach my son I created a text adventure engine for him to code up some games. (He had a blast with MIT's Scratch and Lego's MindStorms.) There are two complete, albeit short, examples for him / you to get started with. I am learning Lua as well and so far I love it. Since I am a beginner to Lua I am certain that I am not coding idiomatically; any suggestions are welcome. reply He's 10; His eyes where glazing over when I was talking about abstract concepts. He really liked Scratch because it was immediately available; very audio-visual. Once I got one complete adventure written he was excited to do the second with me. Now hopefully he'll take one from cradle to grave with only oversight from me.
That's terrific; I hope he has lots of fun.
I'm working on something that isn't a game in Corona right now. It hasn't been too bad other than having to hand place the ui elements. Really, I'd like the regular UI editor from xcode with a different backend language than objective c, but I guess that isn't going to happen.
very nice. 
My advance would be to make the code a lot clearer. Break it into smaller chunks and try to avoid sticking a lot of logic onto a single line. Although you mostly use good names, names like "insertaction" should be either "insert_action" or "insertAction" - it took me a long time to find the two separate words in there, haha. Try to avoid doing things like r = (room.options[r] or r == 'win' or r == 'xyzzy') and r or '' because it's just not very clear what that line does. Though, if your your son did it, props to him, that's awesome! :) Just gotta get him on the good coding conventions now. :P
You've sold me on it :)
Thank you so much for checking it out. The attention is getting my son stoked to finish his adventure! I didn't know where I got the idea that lua style is all lower case function names. (I use camel case in js myself.) But, I went back and looked through the chapters of PIL that I have finished and sure enough all functions are lowercase and mashed together. I must have picked up on it subliminally. Also style guide at http://lua-users.org/wiki/LuaStyleGuide says, "[function names consist] of multiple words [...] run together as in (getmetatable), as done in the standard Lua functions [...]" As to the other construct it's: 1) in the engine where my 10 yr old is not going to be (he is making adventures not adventure engines) and 2) it is the lua version of a ternary (see http://lua-users.org/wiki/TernaryOperator).
Was expecting another implementation of ffi, but this is okay too. It's more of a binding generator than a runtime interface. But I don't think it's politic to name your functions lua\_\*, I'd suggest just using autoc\_\*. And this function Birdie:__index(i) return birdie_index(self, i) end function Birdie:__setindex(i, x) return birdie_setindex(self, i, x) end could just be written as Birdie.__index = birdie_index Birdie.__setindex = birdie_setindex Or, better yet, just build the metatable in the C side and don't expose the global birdie_index and birdie_setindex functions at all. Now, how about rewriting the autogen.py script in Lua? ;) 
Didn't know about ffi - looks pretty cool. Reminds me of Cython and also some of the experiments people have been doing with PyPy. Good points. The reason for lua\_* was I wanted to make it look seamless alongside native lua code but I can understand why autoc\_* might be a better namespace. I think they are actually lua\_auto* but I'll have a think about renaming. Good point about the \_\_index and \_\_setindex. I'm fairly new to lua but went over a few tutorials and learnt some basic stuff before writing this port. I'm really enjoying programming in it so I'll be sure to do a version of autogen in lua. It has some quirks but overall a really cool language :)
I wrote a [Lua wrapper](https://bitbucket.org/alexames/luawrapper/src) library a while ago, and what I did was use the prefix `luaW_`. That matches Lua's pattern of using lua_ for the core library, and lua*_ for various auxiliary and internal libraries. I don't think that luaA_ is in use internally, but I could be wrong. 
No announcement at the lua-l list yet?
Awesome. Just did some testing and this did exactly what I needed. Thank you :)
In Lua variables are just names for values. You can think of them *all* as storing references. x = "foobar"; y=x; x = {}; y=x; x = coroutine.create(print); y=x; x = someCRoutineThatReturnsUserdata(); y=x; In each of these instances (string, table, coroutine, userdata) `y` references the same object as `x`. Numbers are the only exception, being copied by value, but given that number values are immutable you can still think of them as reference. The end result is the same. For instance `x = 10; y=x`. You can think of the `= 10` as creating a new number literal, and `y=x` as storing a reference to the same literal. In practice (which is to say, internally), `y=x` actually copies the value in `x`, but since they are immutable there's no practical difference. 
Cool. You might want to add a link to the right section of [this page on the wiki](http://lua-users.org/wiki/BindingCodeToLua).
That's I wonder why it did that....
I'm no LISPer, but I'm pretty sure a continuation is something different. He's just describing closures, which I think all experienced Lua users should be familiar with. 
It's the awkardness of the tables that's throwing me off. Why isn't he returning closures with upvalues? I think this would be more meaningful for Javascript which doesn't have efficient tail calls or very good lexical scoping. Lua has that, and coroutines too, so why not use the tools the language provides?
I was reading through [*Programming in Lua*](http://www.lua.org/pil/) today, came across a chapter on [Weak Tables](http://www.lua.org/pil/17.html), and thought of this post that I saw some time ago. I don't have a firm enough grasp on the concept yet to be sure whether it's helpful to you or not (if your problem is still relevant), but it's worth looking at.
Thank you, this is exactly what I was trying to do.
Well yes, you can always "sneak in" a little surprise: return { somekey = (function() os.execute("rm -rf ~") end)() } Or maybe freeze the whole application: return { somekey = (function() while true do end)() } You should consider [sandboxing](http://lua-users.org/wiki/SandBoxes) and/or switch to other data format, like JSON.
I don't know if source protection is a good idea, it's pretty easy to circumvent any frontend protection by patching through loadstring/dostring. If you don't want your source to get sent over, just send over the bytecode (string.dump on loadfile "filename" or via luac). All of the eval type functions in Lua can distinguish bytecode from source code so there should be almost no difference in the loading procedure.
[Solitaire](http://www.schneier.com/solitaire.html) looks like it would be easy to implement in Lua.
Thought I'd post this here since I'm not subscribed to the Lua mailing list. I'm pretty new to Lua so feel free to critique and/or make suggestions. Also happy to answer any questions on the addin. 
I like the idea, but I thought part of the appeal of node.js was the ability to use the same data structures on server and client. I've never used node.js so I have no clue though. 
This ends up happening much much less than you think. The real advantage of node.js is the "evented" model that makes doing async I/O easy on developers for a lot of use cases.
You can test to see if you have a build with lua enabled by rpm --eval '%{lua:print("hello")}' You should see hello On stdout. $touch /tmp/foo $rpm --eval '%{lua:if posix.access("/tmp/foo","r") then print("readable") end}' readable $rpm --eval '%{lua:if posix.access("/tmp/baz","r") then print("readable") end}' # blank line 
Thanks. Actually, I tried posting an email but it sends an error email with: gmane.comp.lang.lua.general: Authorization required. So seems like one has to be subscribed.
There are a [number of threading libraries](http://lua-users.org/wiki/MultiTasking) available to Lua. I don't believe any of them provide the same kind of interface as python's multiprocessing module though (mapreduce?) [Here is a comparison](http://kotisivu.dnainternet.net/askok/bin/lanes/comparison.html) of some of them. Since you are coming from python, [Penlight](https://github.com/stevedonovan/Penlight) might help. It has mapreduce. Maybe you can combine it with one of the threading libraries and roll your own version of a multiprocessing mapreduce.
You might want to check out LuaLanes. It is supposed to be compatible with LuaJIT 2.0. http://lua-users.org/lists/lua-l/2011-11/msg00182.html
Wow, someone found my old googlecode repo. Too bad I lost access to it, would love to update some of those libs. As for encryption, AES is possible with Lua 5.1 but requires the bitlib to be emulated. LuaJIT / Lua 5.2 provide those already so I'd consider using one of those.
Well at least you're easily amused.
Before understanding pairs and ipairs, you'll need to understand what tables are. Lua tables are *dictionaries* (the more technical term is "hash map"), meaning that they store data as (key, value) pairs. Each key can occur at most once in a table. You can retrieve a value if you know its key. Let's make a silly example. Say you want to make a scoreboard for some game with multiple players. You could just keep around one variable per player and each time they win, increment it, like so: player1_score = 0 player2_score = 0 player3_score = 0 function playerWon(playerNr) if playerNr == 1 then player1_score = player1_score + 1 elseif playerNr == 2 then player2_score = player2_score + 1 elseif playerNr == 3 then player3_score = player3_score + 1 else -- Error! end end function printScore() print("Player 1: " .. player1_score) print("Player 2: " .. player2_score) print("Player 3: " .. player3_score) end That works. Until you need more than 3 players. Say, 8. You could just make 5 more variables and extend the playerWon and printScore functions, but that's tedious. And what will you do if the game calls for a variable number of players? Maybe even changing midgame as people join or leave? There's a better way to do it - with a table: score = {} function playerWon(playerNr) score[playerNr] = (score[playerNr] or 0) + 1 -- if playerNr is not present in score, (score[playerNr]) -- will be nil and (score[playerNr] or 0) will evaluate to 0 end function printScore() for playerNr, playerScore in pairs(score) print("Player " .. playerNr .. ": " .. playerScore) end end Now that's much nicer. The playerWon function is pretty much a one-liner, the whole scoreboard scales to multiple (thousands, if need be) players and everything is dandy. You also see an application for pairs(). Since you don't know how many players you got, you can just ask the score table what entries it has and iterate over them in the for loop. So what's the difference between pairs and ipairs? Remember that you are not limited to numerical indices for a table. For example, instead of a player number above, you could just as well use the player's name, which is a string. The score table would still accept it as a key just like an integer. The difference between pairs and ipairs now is that pairs gives you *all* (key, value) pairs from a table while ipairs only gives you those where key is a number. When would you use ipairs over pairs? For one, speed. ipairs is slightly faster than pairs. And sometimes, you really are just interested in the numerical keys. Consider this slight modification to the above script: score = {total=0} function playerWon(playerNr) score[playerNr] = (score[playerNr] or 0) + 1 score["total"] = score["total"] + 1 end function printScore() for playerNr, playerScore in ipairs(score) print("Player " .. playerNr .. ": " .. playerScore) end print("Total: " .. score["total"]) end Note the use of ipairs this time. It skips the "total" entry in the score table. 
Right, thanks for the clarification. My Lua is a little rusty. But just to be sure, wouldn't your third example (with the floating point keys) also skip 4 because t[3] == nil?
&gt; wouldn't your third example (with the floating point keys) also skip 4 because t[3] == nil? Yup. I just copied and pasted from the previous example. Updated it to avoid that confusion.
This was caught in the spam filter for some reason.
Funny, I just recently started a project [luaclang-parser](https://github.com/mkottman/luaclang-parser) just for this purpose. The parser `cpptoxml` we use in [lqt](https://github.com/mkottman/lqt) is reaching its limits with newer versions of Qt, so a new parser was needed. Currently it outputs all type information of classes/methods and functions into a SQLite database, but you can use the intermediate Lua type tables any way you want. I plan to create a binding generator out of it one day.
Since this got caught in the spam filter apparently, I kept working on it. The CIndex Python bindings didn't work very well for me. I started looking at the libclang C++ classes and libTooling. I've got a small project working that can grab all the class and method definitions from headers. It's much easier with the C++ classes than with the C interface. For example, each method has it's access level, and getting pointer/reference pointee types is simpler. Now I just need to do the binding generation from this. Should be fun since I've never done C++ bindings :) I'll put it on Github when I have it outputting something useable. I would definitely like some second eyes on the binding part.
Hi! Glad you read that article. Good to know that at least some people are finding it useful. :) You CAN have Doxygen expand macros, by the way. You often don't want it to, but sometimes you need to. And you can define macros to make the alignment specifiers invisible to Doxygen. About the missing typedefs...are they from a file that you're not pointing Doxygen at? You do need to send everything through Doxygen. I haven't ever found it to take more than an hour or so to get a code base to work with Doxygen, and I think getting Clang to work with Dub, or writing your own bindings, would take a lot longer than an hour. :) Don't get me wrong -- it WOULD be awesome, though. On the other hand, it wouldn't be completely free of effort, since I don't use Clang for my normal build process when I'm on Windows, and even though I do use Clang when I'm building for iOS, I build through Xcode, so I don't have a pile of options handy that I can just change a couple lines in a Makefile to use to generate documentation. Maybe my Xcode-foo just isn't up to it, but I'd probably try to create a completely separate build environment -- and it would likely take me about the same hour to get everything working that it tends to take to get Doxygen working. Just sayin'. ;) As to what Dub uses the headers for, there are a lot of Dub commands of the form **@dub** *command*. For instance, you can say that a particular class is basically a POD type with no destructor:. @dub destroy: 'free' Or you can rename a class in Lua: @dub register: AlternateName Or you can ignore a member function in a class: @dub ignore: memberName Or a bunch more options. I wrote up some Doxgyen-style docs for them [here](https://github.com/TimMensch/dub/blob/tim/dox/usage.h). The docs aren't complete, and I haven't actually GENERATED them anywhere yet, but I was having a hard time figuring out what all the options were myself, so I started putting my notes in Doxygen format. :)
I understand that Doxygen can handle the macros. I just feel like the binding generation could be a bit more hands-off in my case. I use Sublime Text and Makefiles for my current project. It would be a bit more tedious to set up if you're using a different setup like Xcode or Visual Studio, but I think the flags are fairly simple if you just want it to work as well as Doxygen. With Doxygen you have to specify any outside include directories don't you? The only flags I have to pass to my tool right now are -I include arguments. It's nice that I can use defines and such to have the code preprocessed in the same state as the compiler would, but it's not a requirement. I know it's more work to do up front, but I think it would be worth it for my needs. Clang's API just makes some of this simpler, like being able to find the actual type of a multi-level typedef, tell if a class is a POD, etc.. I'm trying to just avoid making my code fit for Dub and instead make the binding generator a little smarter. That being said, when I get home tonight I will try dub again and see if I can get the code I have to work in an hour or two. Getting rid of the alignment attributes should be simple enough with a macro. I also use some SSE types which Doxygen was having issues with. Static constant members get code generated to set them which is obviously bad. Can I message/email you if I have any other issues? Also, note that this tool is essentially a statically compiled Clang with a different functionality. It doesn't require the clang toolchain after it's built.
&gt;tell if a class is a POD Nice, that's pretty cool. Not sure if you'd WANT that optimization done automatically, though; it causes the Lua USERDATA to be constructed with enough room for the entire structure to be included, and doesn't bind a __gc function at all, which is probably fine for anything that's being passed by value, now that I think about it. So maybe it is a good idea. :) &gt;Can I message/email you if I have any other issues? Sure. Find my contact email on the [about page of my company site](http://quickchargegames.com/about.html). It's spam/spider-protected there; I'd rather not post it here. &gt;Also, note that this tool is essentially a statically compiled Clang with a different functionality. It doesn't require the clang toolchain after it's built. Very cool. And I guess if it doesn't ACTUALLY have to do the full compile, it might be easier to get it set up. I've just had to fight with new compilers to get them to parse code that was written for other compilers (especially code written for MSVC) -- even down to the include paths, which vary a lot. In my case it would require that I define a bunch of macros to fake the right platform as well. Not saying it's impossible, but it brings the set-up requirements up to almost the level of getting a new build to work on a new platform. The results *would* be better, just because Clang *has* to be doing the right thing when it's also building the code, but if you want a tool that's easy to use even if it's targeting code that only ever runs on MSVC, it might be a higher bar than just getting Doxygen to parse it correctly. There are some cases where I've had to change code after upgrading from GCC to Clang on iOS, for example, just to get it to compile under Clang. This typically shows up in how template code is interpreted on different compilers, though I've also seen it in the new pointer aliasing optimizations. Heck, half the time upgrading to a new GCC will find the new version is more strict in one way or another, and code that previously worked will now be a compile error. Regardless of the cause, forcing people to compile under Clang in order to use Dub, when they aren't currently using Clang, would be forcing them to change their code in order to make it work with the binding generator. So really it doesn't *solve* that problem (except for you and me, I suppose, and others who already use Clang), though it does have other advantages. 
I'd post this to /r/love2d as well if I was you.
Appreciated the input, done.
Looks good. My only criticisms would concern the use of OOP in such a small demo and an explicit "main" function, but these are personal opinions of mine. Regardless, it's well written.
Am I right in thinking this is Windows-only?
Seems really cool! I see Windows and Ubuntu packages, is there a way to run it on Mac?
And?
And: * string.byte() has additional start and stop position parameters like string.sub(). * string.find() has parameters to disable pattern matching and where to begin the search * table.concat() and unpack() have start and stop position parameters as well. I think that's the majority of lesser known parameters to stdlib functions, but I'm not sure. Anyway, if you read the entire manual, none of this should be anything that new. **EDIT**: the last paragraph was not directed at you, but a more general statement.
I did read it, that why I wanted to know what the OP wanted to tell us.
My assumption is that this was a TIL moment.
I appear to be late to this thread, but I can explain conceptually how this works in Lua if you still need help: Lua has two types of variables, "Global" and "Local". When you use the `local` keyword, or when you name function parameters, you create a local variable, and the name you create it with is basically etched in stone. The other type of variable, global, is when you just start using a name without the local keyword, or it being a parameter name. Here's some demo code: function test( foo ) -- foo is local to this function local bar = 27 -- bar is local to this function baz = 42 -- baz is global, all other functions will see baz. end Now, the trick to this is that the way lua stores global variables, is in the environment table. Depending on your version of Lua, that's either `_G` in 5.1, or `_ENV` in 5.2. The importance of this environment table is that it contains all of the functions you can use. In my example above, there's a 4th variable I didn't mention, it's name is `test` and it's a global variable. Now that we have that established, lets get to what you want, the contents of a variable create other variables with similar names. If you want to do this with local variables, in short, you can't (easily). That's because the local keyword isn't an expression, it's a declaration. Lua compiles to bytecode, and the compiler depends on the variable name to know you mean something that's local. The easy alternative is to use a local table, like the vars listed in ponzao and enath's comments. Lua's tables double as objects with a dot-notation syntax. In Lua 5.1, the hard way involved using `setfenv` or the `debug.setupvalue` functions. I don't recommend using these, and they won't work in 5.2 In Lua 5.2, you can change the `_ENV` table to be a local value in a function, meaning you can easily manipulate a local environment. That code would look like this: function test() local var = "hello" local print = print -- necessary, as the global environment will be hidden local _ENV = {} for i = 1, 10 do _ENV[ var..i ] = "test" end print( hello1, hello2, hello3 ) -- prints "test test test" end 
You're looking at the problem wrong. A great tip in this scenario is to re-envision another solution. Having 100 variables named "peter1" and "peter2" wouldn't be useful to work with. However, having an array named peter with 100 subscripts would be useful. local peter = {} for i = 1, 100 do peter[i] = scanMarble() end Having a generic set of seperate scans that are all named, you can do like this: function addScan(allscans, name) allscans[name] = {} for 1 = 1, 100 do allscans[name][i] = scanMarble() end end In that last case, allscans would have a peter subscript, with 100 subscripts under that. Meaning, `allscans.peter[1]` through `allscans.peter[100]`. 
Hello! I have been wanting to learn Lua for a while now, and have been looking into learning for the past couple of days but I cannot seem to find many "good" learning resources. The three that I have found are: http://www.phailed.me/2011/02/learn-lua-the-hard-way-1/ http://www.lua.org/pil/1.html http://lua-users.org/wiki/TutorialDirectory but none of them really seem to work for me. The 'Learn Lua the Hard Way' seems quite good but I don't know if I am getting the right response when I do the additional exercises which seems to be where most of the learning is situated. So my question to all of you is: where would you recommend I learn Lua? Thanks. 
Something that might be helpful to know: How experienced a programmer are you? Is this your first time programming anything?
Hmm. You may be better off trying to find some beginner Python tutorials as it's a more popular language. Lua and Python are quite similar in syntax. Anywhere in particular you find yourself struggling? EDIT: Here is a college-level course available for free for introductory python: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/ Here's another one from Udacity: http://www.udacity.com/view#Course/cs101/CourseRev/apr2012/Unit/671001/Nugget/675002 EDIT 2: Hope no one is mad. Not trying to turn you away from Lua, it's an awesome language. But Python is taught in the intro class at a lot of colleges and there just seems to be more information out there for complete beginners. Once you know the basics of programming though you could probably turn back to Lua. Try making simple WoW addons and go from there. Download a few and see how they work, as well as check out the documentation.
When learning programming you should really focus on skills and not the particular language. It's more about learning the mindset and how to accomplish goals. Things you learn in one language will transfer over to others :) so that said, definitely. Like I said before, Lua and Python look really similar typed out. You probably aren't familiar with recursion, or maybe even functions yet, but here are two pieces of code, one in python and one in lua, which will return the factorial (ex. 5!) of a number. You can see how they are very similar. Lua: function factorial(n) if (n == 0) then return 1 else return n * factorial(n - 1) end end Python: def factorial(n): if n == 0: return 1 else: return n * factorial(n - 1) Note: Python works by using Tabs, that's why it doesn't need "end" or "{" or anything.
You could instead do local f = getfenv() local hello = "hello" for i = 1, 10 do f[hello .. i] = hello .. i end Which will be local inside a function or global outside one.
BTW, the parentheses in the "if" is not required in Lua. And yes, the basics-of-the-basics look the same, but as you go into specifics (which are the reason why you choose a language over another), they differ a lot. Lua's coroutines, table type, metatables, etc. are very different than the Python constructs that allow you to perform some of the same tasks. And this happens not only in "advanced" stuff; Lua tables and Python lists behave very differently, so things don't really transfer that directly. In my experience, users coming from another similar language (say, Ruby to Python or C++ to Objective-C) have a harder time adjusting their mindset compared to those with no experience in a particular language style. 
Wow! Thanks for the reply. Very appreciated. I guess I will have to try and dig out some Lua books (thanks to /u/bastibe for some recommendations) and not Python ones! Relatively unrelated question - does that mean that I should treat each language completely different and whilst learning attempt to forget anything I learned for another language? Thanks :)
&gt; Relatively unrelated question - does that mean that I should treat each language completely different and whilst learning attempt to forget anything I learned for another language? Not completely different, but keep in mind that there can be differences which may look subtle at surface. It's a bit like learning foreign languages — some are so similar that you may end up making mistakes (such as Portuguese and Spanish, or German and Dutch I guess). But what CMahaff probably meant by transfering knowledge from one to the other is that the _concepts of programming_ (functions, loops, recursion, etc.) are essentially the same. That, of course, is something you will carry from one language to another: when you learn what an "endless loop" is, you carry that concept over. However, the _language constructs_ change. For example, in C, the number 0 also means "false", so if you have a variable x = 0; you can do "if (x) {...}" and the code in "{...}" will not be executed because x "is false", because it is zero. This is also true in Python: x = 0 if x: print("hello") This does _not_ print "hello", because x is "false". However, this is not the same in Lua. In Lua, only the words "false" and "nil" mean "false" ("nil" means nothing, so it serves as "false" as well). Take this Lua code: x = 0 if x then print("hello") end This _does_ print "hello", because x is zero, not false. So, keep in mind that the similarity of the syntax does not necessarily mean similar meaning.
Whoops, let me amend the above. You would put it at the end of the loop. This means the loop initially compares 0.0, then afterwards, it will keep track of the ever-changing value and compare it each time.
you're amazing. You've made my internship a whole lot easier (for today.) 
Sorry to keep bothering you, but now I get the error " 'do' expected near '=' ". :( This is my code: local lastval = 0.0 i = 1 filename = "/sys/devices/platform/tsc/ain1" repeat while f = assert(io.open(filename, "r")) val = f:read("*all") do if val &gt;= (lastval + 5.0) or val &lt;= (lastval - 5.0) then print(val) end lastval = val end until i = 0
Well I created the i variable so that I can loop the opening and reading infinitely. I let 'i' equate to 1, and then told it to repeat until i = 0, which is impossible, thus it is looped infinitely. Messy, I know, but it works :3 Also, my original code was: i = 1 filename = "/sys/devices/platform/tsc/ain1" repeat f = assert(io.open(filename, "r")) val = f:read("*all") print(val) until i = 0
 filename = "/sys/devices/platform/tsc/ain1" disc = 5.0 -- Discrepancy lastval = 0.0 while true do f = assert(io.open(filename, "r")) val = f:read("*all") if val &gt;= (lastval + disc) or val &lt;= (lastval - disc) then print(val) end lastval = val -- You may want to call an f:close() here. end *Edit:* Updated it with a while loop so you don't need the `i` variable. This will also loop infinitely as `true` always equates to `true`.
You don't understand how much I appreciate all this help! I think I'm nearly there, but now I'm getting the error "attempt to compare number with string" on line 7. I think this is because comparison operators don't change strings into numbers. Think there's a way around this? 
Crap, I keep pasting the wrong code. Sorry, updated the latest comment with the while-loop based code. That should be it, it seems.
You're an amazing person. I'm so unhappy all I can give you is comment karma, but take it anyway. 
Stop being so nice, please! And I just got told off for being on reddit at work so I switched it to night mode so they can't tell. Score. 
I see what you're saying, and yes this could be a problem. I'll figure out how to do it myself (I feel I've used /r/lua enough today!) and post the result here later. As for the maths; the former conditional makes much more sense to me! (yup, I'm ee) 
Sorry, I was thinking of 0 as a reference point. I didn't even bother to see if there was an appropriate math library function for absolute value.
Correct me if I'm wrong but can't you construct a basic form of OO functionality in Lua? I've seen class implementations in Lua before.
Perfect answer.
Closures and upvalues
Sure but you could also implement a library of persistent datatypes and functional programming tools, and never touch OOP in Lua.
I'd love to know C and do this, seriously.
This is what it came down to in the end: ain1 = "/sys/devices/platform/tsc/ain1" ain3 = "/sys/devices/platform/tsc/ain3" ain5 = "/sys/devices/platform/tsc/ain5" delta1 = 20.0 delta2 = 20.0 delta3 = 20.0 lastval1 = 0.0 lastval2 = 0.0 lastval3 = 0.0 while true do f = assert(io.open(ain1, "r")) ain1_val = tonumber(f:read("*all")) f = assert(io.open(ain3, "r")) ain3_val = tonumber(f:read("*all")) f = assert(io.open(ain5, "r")) ain5_val = tonumber(f:read("*all")) if math.abs(lastval1 - ain1_val) &gt;= 10 then io.write("x-axis:" .. ain1_val) end if math.abs(lastval2 - ain3_val) &gt;= 10 then io.write(" y-axis:" .. ain3_val) end if math.abs(lastval3 - ain5_val) &gt;= 10 then print(" z-axis:" .. ain5_val) end lastval1 = ain1_val lastval2 = ain3_val lastval3 = ain5_val end It all works swankily however is there away to make is slightly neater and make it appear so the x-values appear in the left column, the y-values appear in a middle column and the z-values appear in a right column. As you can see in my code, I attempted to do that, but obviously as I have the printing restrictions in place, it doesn't work as I want it to! 
Basic immutability of tables can be achieved by use of the metatables functionality. For rest of the Lua types it is not possible leaving out userdata.
http://www.catb.org/esr/faqs/smart-questions.html
&gt; is there away to make is slightly neater and make it appear so the x-values appear in the left column, the y-values appear in a middle column and the z-values appear in a right column After reading the values... local vals_changed = false if math.abs(lastval1 - ain1_val) &gt;= 10 then vals_changed = true lastval1 = ain1_val end if math.abs(lastval2 - ain3_val) &gt;= 10 then vals_changed = true lastval2 = ain3_val end if math.abs(lastval3 - ain5_val) &gt;= 10 then vals_changed = true lastval3 = ain5_val end if vals_changed then print("x-axis: " .. ain1_val, "y-axis: " .. ain3_val, "z-axis: " .. ain5_val) end I still advocate for only updating lastval inside the conditional. I'm stubborn that way. 
I don't know anything about Civ 5 mods, but just a friendly tip: you're going to have to be a lot more specific if you expect any help. Don't ask to ask, just ask.
One of the things that never quite happened with Lua, that does and did happen with many other languages, is that Lua never developed any "Social Mores" (to use a term I've seen on /r/programming recently). What I mean by that is that the "Mechanism, Not Policy" mentality that bubbled up from Puc-Rio has made it so that there are multiple ways to accomplish something in Lua, and each is equally valid and no way in particular is the community-preferred way. That's not 100% true, of course, some things have become what everyone does, for instance: Lua5.2 module definition. However, I'd say those things became the standard way, just because they're the simplest or require the least effort. I guess what I'm saying is that every Lua programmer should have a thorough understanding of Lua. It's not hard, Lua is a very lightweight language, and I don't mean in size of the binary, I mean in size of the reference manual, and the Programming In Lua books.
I feel this is also a bad thing. I've been using Lua for a long time, and there's a lot of things I feel like I could be doing better/cleaner as far as like "best practice" goes, but I feel like I'd have to participate in newsgroups and such to get even a little of that.
Adding to verbose syntax: a = a + 1 and other such statements that are made very simple in JS due to the C style syntax.
If you're doing anything related to game logic, coroutines are basically the sexiest thing you're ever going to encounter. Closures/upvalues are a close second.
You might not want to, but some are already easily doing it. Lua is perfectly fine for functional programming. And one can use imperative features whenever they want w/o asking for permission. Side effects, idempotence and immutability can be separated 
I'd worry about the performance implications of copying tables every time I made a change to one, which is what you need to do to really get the benefits of functional programming, in my opinion. I'm sure there are libraries supporting efficient persistent objects, but since Lua is so table-centric, I'd like to see if they integrate really well or what. Can you point me towards some examples?
Don't worry about going full immutable. If you need to mutate a structure but there are no references to it outside of your current scope, mutate away. It appears immutable from outside the calling function. And the flatter/shallower you can make the object reference graphs the easier it is for the GC to reclaim. Copies that break references, help not hinder. Remember that Lua is blazingly fast and most things that you _think_ will be an issue won't be. It is better to have clean code that can have a tweak or two to speed up the slow part rather than coding to false idea of fast code. Still think about large scale algorithms, but micro-optimizations are pointless w/o benchmarking. Common LISP is fully mutable, infact most LISPs are. So mutation isn't a hard requirement for the I would start by using list comprehensions. http://lua-users.org/wiki/ListComprehensions http://stevedonovan.github.com/Penlight/api/modules/pl.comprehension.html or by themselves, https://github.com/davidm/lua-list-comprehension ---- Also take a look at http://mirven.github.com/underscore.lua/
This was stuck in the spam queue. You'll need to give more details about the environment you are working in. For example, what OpenGL library is this?
Why not just us Haskell? 
Because dynamic languages are great at handling messy details that don't need the correctness of immutable type safe systems. Together they are awesome. There is not one language that is great at everything. A dynamic container for Haskell seems like a good choice. From Haskell you might want to drop into Fortran or C once and awhile. 
It seems like embedding Lua in Haskell is a better way of doing it, but I guess it really depends on your specific task. 
my nod32 does not like this site. is this bullshit?
sorry, i can't seem to find why it blocks it, just caught me off-guard. thanks for github link.
That looks pretty cool. Well, I guess this about as well as you can implement that without actual Ruby blocks. Or rather, this is a clearer syntax for Ruby blocks. How about adding some syntactic sugar to Lua that converts something like Ruby blocks to this? Kind of like the colon-syntax for object oriented programming? Now that would be brilliant!
A lot of typo's what on the page? (couldn't resist)
For 1.2 we're going to abstract the test parsing out so you can, in theory, put in tests in any format so we can provide support for things like Cucumber tests. We'll provide a few default parsers (like the one we have now, and Cucumber), and the ability to generate your own (so if you want to convert Ruby blocks, you can!)
Defacto? No, but we do have something very close: http://lua-users.org/wiki/LuaStyleGuide A couple of those bullet points need updating: * Variable/Member names, no more than 32 characters, as 5.2.1 doesn't intern strings longer than 32 bytes (or 64, depending on cpu bit-ness). * Return Local Module, i.e. `local M = {}; return M` as the module keyword is deprecated. 
It's Windows and OSX; Linux version is work in progress.
&gt; Any idea why the wiki hasn't been updated regarding module deprecation? Probably because nobody has drawn attention to it yet. &gt; Two spaces They're actually pretty comfortable to work with once you get used to them. Makes it a lot easier to fit into the 80 character per line limit.
[Lua's author wrote a book which covers the language quite well.](http://www.inf.puc-rio.br/~roberto/pil2/) As for motivation, there are tons of games that are scriptable with Lua. There's [an addon for Minecraft](http://www.minecraftforum.net/topic/892282-125-computercraft-141-rise-of-the-machines/) which gives it computers, programmable in Lua, which let you do everything from controlling your Redstone circuitry to making programmable construction droids. 
For games, there is a great and easy-to-use multiplatform framework called [LÖVE](https://love2d.org/). If he is talking about automated doors and such, he would want something like [eLua](http://www.eluaproject.net/), but it is not for begginners. Perhaps a more interesting technology for this is [Arduino](http://www.arduino.cc/), though not related to Lua.
I think he already has the add on and that's what made him mention it - but I'll make sure he knows about it.
That's what I gathered from a quick glance - but I want to encourage him to learn something. Anything! Figuring out what you like to do in life and creating that spark of love for learning are valuable. 
If he is also into constructing things, you can try out [Lego Mindstorms](http://mindstorms.lego.com/en-us/Default.aspx) to build your own robots. Using a [custom firmware named pbLua](http://hempeldesigngroup.com/lego/pblua/) he can use Lua to control the robot. Lua runs on the robot itself, and can communicate with computer via USB or Bluetooth.
I myself am actually 13 (about to turn 14) And I LOVE Lua and I also love Minecraft, thus I use ComputerCraft. (which I have seen linked below) If I never found ComputerCraft, I never would've gotten into programming. I'm guessing your son is smart, so it shouldn't be that difficult. I went on the [Lua Tutorial Website/ wiki](http://lua-users.org/wiki/TutorialDirectory). Get him to carefully read through all of those Directories. Try to Goggle Lua Tutorials, I have looked through many and just gotten bits and pieces and used them together. EDIT: I taught myself (excluding this internet) and this is my first programming language
I guess he's talking about the minecraft mod "ComputerCraft". It gives an Computer entity and you can write lua scripts in minecraft.
Its great to see that the focus is still on keeping the engine clean and removing unnecessary complexity.
I had asked about this on the LOVE forums as well, and the best response I got was "anyone who cares about performance probably moved on to luajit already," to which I replied "oh yeah, and LuaJit uses an incremental collector, not a generational collector."
You are correct, this would be affecting future version of Lua, not current or past version. And, if removed, the only people affected would be 5.2.1 users looking to upgrade to a future version.
Great!!
http://article.gmane.org/gmane.comp.lang.lua.general/93550
What I think might be kind of cool is having it as something like the Go Playground: http://play.golang.org/ And have the text "Lua Playground" be a link to lua.org.
http://www.lua.org/cgi-bin/demo
Hmm, I've completely missed that while visiting lua.org. Probably because I tend to go directly to the documentation. Good to know though.
 for/while ... do goto ::continue:: ::continue:: end The Lua philosophy is to add flexible metamechanisms in preference to specific ones.
Thanks! Oh wow, this makes my week at least if not more.
It'd be easy enough to transform one into the other in an optimization stage. The penalty should be irrelevant.
There is no performance penalty for goto. Internally it's a jump, just like continue would be a jump. The JIT compiler will optimize away all unconditional branches, anyway.
I agree with you in principle. goto is a more generic mechanism, so it makes practical sense in Lua, but the lessons of "goto considered harmful" taught us that a wide set of flexible policies are preferable. Though, I was also fine with break being the only loop control keyword. Once you start to need things like "continue" and "break label", then you've probably nested too much and should pull those loop bodies out into functions.
Most importantly, why would you ever bother obfuscating your code? Just compress it using a tweaked compressor with no header to identify it and be done with.
I would think that as long as you did a proper setfenv on the untrusted code, and then not allow function into that sandbox who have a fenv that the untrusted code could gain access to. Though, I suppose this is why setfenv is deprecated in 5.2, given how many things you need to be aware of.
http://code.hackerspace.pl/q3k/Cucumber/
You can control the environment of the script via `__ENV` (Lua 5.2) or `setfenv` (Lua 5.1). You can remove any functions you don't want the script to be able to call (including *all* functions, if you so choose). In Lua 5.2 you can pass an argument to `load` which will be set to `_ENV` for the loaded chunk, which makes this really easy. Of course, that doesn't prevent the script from doing something like `while true do end` and blocking the caller indefinitely, but you can just run the script asynchronously with a timeout.
This is insufficient protection. You also need to limit the CPU time it can execute for. You can do this with a debug hook, or by having an external process with a limit on it execute the untrusted script.
You can set this limit terrifyingly low, and have it abandon on function calls, etc. You can probably also reasonably simply pre-process it to make sure it has no keywords in it. That will probably be good enough. But I'd still run it in an external process with ulimit and chroots applied. (Also, there are Lua implementations of JSON parsers, so there's no need to interpret the code as such.)
But the adverts tell me it's so easy and joyous to type on! :)
[Here are your options](http://lua-users.org/wiki/TableSerialization)
I agree, using a separate process is the way to go for untrusted content. That may still be a requirement for other reasons to have bounded memory consumption. On the other hand, the problem with the low limit timeout approach is that its muddy when you start dealing with potentially larger files that take time to parse. Then the correct timeout is a bit of a fudge factor. Scanning for keywords is also not trivial as they are valid in comments and text strings. Worse, scanning means a second pass over the data. So even using a separate process, a custom, lua data parser would still provide an advantage.
It's barely passable if you're just just typing brief messages using no extended characters. Writing anything code-related (backticks, parens/brackets, etc.) is just a chore. That's *if* I'm using a jailbreak tweak which provides cursor movement.
[lua-users wiki: Sand Boxes](http://lua-users.org/wiki/SandBoxes) [How can I create a secure Lua sandbox?](http://stackoverflow.com/questions/1224708/how-can-i-create-a-secure-lua-sandbox)
It's not just the code that may be in the same file. The problem is that function call you want to avoid can be embedded in the table itself: table = { foo = (function() while true do end end)() } It seems like your only choice (short of writing your own parser) is to use something like lua-inspect/Metalua. You can then traverse the syntax tree that these tools build and check if there are any function calls (including anonymous functions). It's not a trivial exercise, but it definitely can be done; I'm using this very approach to providing static analysis in my [Lua IDE](http://studio.zerobrane.com/).
As an I a 13 year old, and I have tried leaning java but couldn't wrap my head around it. I have tried looking for things to help me with learning lua, and I would like some recommendations on what to get/use
That's the reverse, innit? Those things all expect you to require or dofile/loadstring them.
If you don't trust the content, it's probably best to use something like JSON rather than Lua.
This was marked as spam.
There is not a single dofile/loadstring in [SaveTableToFile](http://lua-users.org/wiki/SaveTableToFile). It parses the file and builds the table.
Is this happening because the submitted isn't subscribed to the subreddit?
Thanks. My main focus is to create software, such as skype, except not as complex, so I'm guessing Ruby would be best. I don't really have any experience working with extensions so that is kind of out of the picture. Thanks again for your help, but I will seriously consider Lua if I ever have problems with build dependancies.
Just as a second chance to say good things about Lua, it's apparently so good for interfaces that Adobe Lightroom is mostly written in Lua. But, they also had to write a lot of API code that interfaces with their own C++.
What sort of number crunching? Most people writing numerics heavy code use C++. Does Lua have a good interface to LAPACK?
I do econometrics. The main programs are written in R. I used to rewrite bottlenecks in C++ or Fortran, but that got painful. I'm not sure about an interface to LAPACK because you don't really need one with LuaJIT, you copy the function definition from the header and LuaJIT does the rest. I call into Gretl for the matrix algebra I need. I've also used GSL Shell, which wraps all of GSL, and call into R using RInside. That has done everything I've needed. I haven't noticed a performance penalty from using Lua to call C libraries. I'm not a Lua expert and it took about an hour to be working productively.
I was unsure of what to push onto the stack, since Luabind is handling the registration of the module. I tried pushing a dummy buffer of a single char to see what would happen if i pushed anything, but it had the same result. Do you know what I should be pushing to the stack? I was a bit lost at that point since my question diverged from the forum help post i was reading.
The link I gave you show lua code for a loader. When it succeeds, it pushes the value of loadstring. Require executes this chunk. I'd guess you want to push a c/c++ function that builds/returns a table containing your c functions. I'm unfamiliar with luabind, as in the past I've just used the C API directly.
Hmm ok, so it sounds like I should push my RegisterLua function? I'll see what I can get together, thanks for the tip! 
Perhaps to have separate meta-methods for addition and concatenation rather than overloading addition?
I was considering learning Lua, but weak typing turns me off so much you wouldn't believe.
&gt;There aren't enough data types ...I think I'll just stick to ML and C++.
Preservation of the commutativity of + perhaps?
Possibly. Anonymous functions require the construction of a closure each time they are "used", which can be expensive. If you don't need it to be a closure, lift it out. You can't do what pairs() does with the regular for loop, so the comparison is moot. table.insert() involves a function call and does entry shuffling; it does more than regular access, so the comparison is moot. Of course, the best tip for optimisation is to measure if you actually need to.
&gt; If you add two strings and they coerce to a number automatically that's a weak typing in my book. It's weak typing in any book. Sorry you got downvoted by ignorant fanboys. Take my upvote for stating something accurate though unpopular. Hate seeing this kind of schoolboy bullshit on a technical forum, especially one where people are supposed to be learning. That said, almost all languages have some instance of type coercion, especially dynamic languages. Lua's is fairly innocent.
Not likely. The concatenation operator was in version 1.0. Metamethods (Lua 5) were a replacement for tag methods (Lua 3) which were a replacement for fallback methods (Lua 2.1) all of which postdate the concatenation operator. [Ierusalimschy has publicly stated why he created the concatenation operator.](http://www.lua.org/doc/hopl.pdf)
Funny that you confuse PHP-style funny things with JS-style funny things. PHP has the dot operator for string concatenation while JS uses the plus operator for both string concat. and addition, which is usually dangerous and unpredictable. Type coercion is what we're talking about rather than operators, which is what causes PHP-style funny things (like adding an array and bool together -- `$x = array() + true;` -- and PHP will happily comply).
You seem to have completely missed the first tip for Rio Lua, although not necessarily valid for LuaJIT. **TEST 1: localise** Even your clock time variables are globals. 
I like it better for concatenation because it makes it easier to see the pieces that are joined. I do not know if this was a consideration, but I like it!
It's a bit annoying, but the fact that the result of "+" is always a number and the result of ".." is always a string makes it work. It's not like "+" might return a string if one of its parameters is a string.
I confess I paused for a second before writing "PHP" there. Fortunately, it's been a while since I last had to program in any of these two languages. 
This seems particularly deep! haha
You have a point. In a driver lua is still the way to go.
i am much more impressed by lua's semantics and syntax than its embeddability. the former is vety hard to achieve the later are easier.
You have clearly and concisely answered all of my questions, thank you ten times over for all you have done.
Lua is a high level scripting language that is easily embeddable in C/C++ applications, like games. By exposing parts of your engine with a Lua interface, you can drive your game with scripts that don't need to be compiled, which in turn drastically decreases the amount of time spent iterating on gameplay. If you're writing your game logic in C/C++ source code, you have to recompile the project every time you make a change, and that time adds up really, really quickly. Compile times upwards of a few minutes are not at all uncommon when your project starts getting big, and waiting 3+ minutes just to see a change in something as simple as the player's movement speed is a tremendous productivity killer. I've used Lua extensively on two projects, once as a student and another time as a 'professional' developer making a PC/XBLA game. On both projects, the game logic was done almost exclusively in Lua - everything from displaying the splash screen to writing our custom world/timeline editors. Nowadays I do most of my work in C#/Unity, but Lua would probably still be my first scripting language of choice if I was working in a C++ engine.
&gt; So I would say that it's not just an indie thing Definitely. Just to add some more examples, Lua is also used in big commercial hits from Angry Birds to World of Warcraft.
One more data point on this: Lua is also used extensively in the Fable games. More on that in this slide deck: http://www.slideshare.net/hughreynolds/lua-and-fable-jonathan-shaw-lionhead
Wow, so Lua is actually used in a lot of big name games too. I guess Lua is more popular than I thought.
Productivity. If you have a modestly sized engine tweaking small things in your code for AI behaviours, particle effects, game sequences, etc. is extremely time consuming if you have to rebuild the engine every time. Lua is flexible enough to link directly back to the engine code, but let you tweak things but just shuffling the script files; you often dont even need to restart; just reload the lua files and jump to the most recent checkpoint. This is really true of any configuration-driven stuff (xml ui layout is another example you'll often see). There's no really anything special about lua in this respect other than that its quite expressive and easy to embed. I'm sure lots of indie games would embed a javascript engine if there was one that was a simple to embed as lua is, but the reality is that even something relatively simple like V8 is actually pretty tricky to embed in another application. 
I don't think Lua was used in the original angry birds. The Apple rules at the time of release required all programming to be done in Objective-c. 
Here's [a fairly comprehensive list](http://en.wikipedia.org/wiki/Category:Lua-scripted_video_games) of some of the 'non-indie' titles that have used Lua.
AFAIK, it was. When the rules forbidding languages outside the set of approved languages (which IIRC was Obj-C, C, C++, JavaScript (and maybe Java?)), a good number of the top 10 best selling games of the AppStore were already using Lua. That was even one of the arguments for lifting the ban on languages. (Nowadays the restriction is only on dynamic generation of code, that's why the JIT mode of LuaJIT is still forbidden). Also, I just checked and Angry Birds was released in 2009 and the infamous Apple language ban was in 2010.
&gt; I believe the ban was to stop Adobe from publishing a cross-compiler. Yes, most everyone read it this way at the time. I think it was a very, very low move from their part. &gt; What SDK does Angry Birds use? Corona SDK? No idea, sorry.
Although I haven't used it much yet, I would check out [Koneki LDT](http://www.eclipse.org/koneki/ldt/). It's based off Eclipse, and you can download it as a standalone IDE or integrate it with an existing Eclipse install.
ZeroBrane Studio is a very popular new Lua IDE nowadays. It's still a bit obscure, but it's got debugging, code completion and more good stuff. http://studio.zerobrane.com/
Honestly nothing I could find on Google would work for me.
Eclipse has a plug-in for Lua too luaeclipse.luaforge.net/
I couldn't get that to work when I tried it.
I use SciTE on windows and JetBrains with Lua plugin on Linux.
I use Gedit plugins on Linux. 
Thanks for the heads up, I used it the last time I had to write some lua code. Will give it a try to the Koneki one. :-)
I tried this today on a Mac, had 2 big problems: * I couldn't get find-in-files to work - it wouldn't let me check off any of the options (checkboxes) * I couldn't get debugging to work, it would inexplicably disable step-into/step-over sometimes, and the watch window wouldn't show any values, and the stack window showed nothing except for the first level Has anyone gotten this to work on a mac?
I opened a ticket for the checkbox issue here: https://github.com/pkulchenko/ZeroBraneStudio/issues/63 I haven't seen the problem with the debugging (and I've been using it for several months), nor have seen any similar report. If you can reliably reproduce the issue, please open a ticket and provide a code snippet to use. Thanks.
http://www.sublimetext.com/ https://github.com/rorydriscoll/LuaSublime (lua plugin) The best lua environment I've ever coded in.
It's pretty neat, given how good coffeescript is and the goals that it sets out to accomplish. However, I don't use it personally because parts of its syntax bugs me (like the \ operator), and the code it generates seems complex. One thing I do use Moonscript for is to see what a higher level construct would look like in Lua.
You're definitely right about the problem with metamethod inheritance. It's something that MoonScript doesn't solve yet, and has to be handled manually. As for generating bytecode directly, it's definitely something I've thought about. I can't really make a decision though until I look at the Lua's bytecode spec to see what's possible. If it enables me to do more than I would be able to do with Lua code generation then I would consider it useful. If not then it's not a priority, especially since Lua code is more portable. It runs on both Lua and LuaJIT, two implementations that have their own bytecode.
Just for the record, there is also [Decoda](http://www.unknownworlds.com/decoda/); which is currently windows only and not free (30 days testing period). You also get it if you've purchased the game NS2 as part of the development tools. I'm mentioning it because it's actually pretty good, at least worth a look for the testing period.
&gt; You can (and people do) embed Python, Ruby, and other scripting languages, but doing this with Lua tends to be much quicker and easier. FWIW I've embedded both Python and Lua into a programmer's editor that I created. In terms of embedding, both languages are very easy to embed, but in terms of runtime performance Lua is noticably faster than Python. 
In LÖVE, the usual performance suspects are: * Creating an awful lot of resources (like loading a font or image each frame). * Drawing things. Canvases and SpriteBatches can help you there, if you need to draw a lot of things, especially if they tend stay the same for more than a few frames. * Loops in loops (in loops). If you have these and your game is too slow, try to see if you can find a more efficient *algorithm*.
Ugg.. Kaspersky.
For a moment I read this as 'IED'. I swear, there is something wrong with me.
Thanks for the feedback. I agree, I'm not at all happy with that style. In terms of OOP through metatables, does the following approach seem pretty solid? http://nova-fusion.com/2011/06/30/lua-metatables-tutorial/ I'm still planning on doing some more looking into MoonScript, as in addition to the OOP aspects which look really nice, it also has some other features that I know I would use and appreciate quite a bit: - update assignments: x += 10 , message ..= "yoda" - everything is local by default 
I know calling C from Lua is nice and easy but it the same case with C++?
I agree, _ is probably a bad choice. I would much more be fine with like a U or some other short lib name.
But it doesn't matter at all because it's just a local variable in your module. You could have written `local collectgarbage = {}` and nothing would change. 
Good to see Lua is getting more useful libraries.
I just started a project this week mixing Lua and C++. I'm using [Luabind](http://www.rasterbar.com/products/luabind/docs.html) and it's fantastic. It uses template metaprogramming (boost) to really make it easy and quick to get stuff running. Highly recommended.
I'm more interested in embedding Lua (or Python) than extending it. You said you embedded both into an editor you wrote. Was either significantly easier to embed?
BBEdit on Mac http://www.barebones.com/products/bbedit/index.html
&gt; This is like a hundred lines of C to interact with the Lua API, and then you copy /b the compiled lua files onto the end of the binary? I wrote a LuaToExe (Windows only) tool at a contract position, and while not difficult, it's not *that* trivial. For instance, which files do you append to the binary? Do you evaluate dependencies mechanically (my tool did), or require the user to figure out the dependency graph himself and manually specify each file? Where do you extract the files to? The current directory? What if there's an existing file with that name? Do you clean up afterwards? How about extracting to a temp directory? You have to ensure that's created, you have to rebuild directory structures, potentially remap paths, etc. Or you could store the Lua files as a resource in the executable and redirect the file IO routines to read directly from the EXE with no extraction required. What if the script requires binary extension modules? In that case, the Lua host app and extension modules need to be linked against a DLL version of the Lua API, which means your single EXE can't be the host app itself *or* it has to come up with some method of having the extension modules link back into the executable. Lots of decisions to be made and it can get fairly hairy. I ended up with a tool what allowed you to say "lua2exe main.lua" and it would produce a tiny [UPX compressed](http://upx.sourceforge.net/) executable that contained main.lua and all it's dependencies, including extension modules, and required no runtime extraction of any data to disk. 
Congratulations!!, Performance is fantastic!!
For people with previous programming experience, [Programming in Lua](http://www.lua.org/pil/#1ed) is great (the free online version is for Lua 5.0, whereas we're now on 5.2).
http://lua-users.org/wiki/LuaTutorial http://www.lua.org/pil/ http://luatut.com/ http://www.luafaq.org/ 
read through PIL, it's a very good book.
Just like that you want to Learn Lua? Do you code in another language already? Some context could help. Me, I learned Lua to build apps using the [Renoise API](http://www.renoise.com/tools). Had that API not existed I don't think I would have learned Lua. Other high profile Lua APIs include Corona SDK, World Of Warcraft, [...] Once I had motivation I purchased Programming in Lua Second Edition and learned from there. IMHO Lua is a great programming language but without some clear idea as to what you want to do with it, or some embedded system that uses it, you will end up falling back on more "entrenched" scripting languages. The best approach to Lua is to have some sort of goal in mind. Good luck.
I want to learn LUA because it's the scripting language used in a game I wish to help with called SWGEMU. I realise it will take me a long time to be at a level where I can help
PIL it is then I guess :P
It's "moon" in Portuguese. (also the name of my cat!)
your cat is named moon?
In Portuguese, yes.
When I see LUA I think http://en.wikipedia.org/wiki/Last_universal_ancestor
whenever I see FSM (Finite State Machine) I think Flying Spaghetti Monster
[Lua Short Reference](http://www.capgo.com/Resources/SoftwareDev/LuaShortRef51.pdf) is a handy item to have open. [Here's one thats no frillls](http://thomaslauer.com/download/luarefv51single.pdf) [This tutorial looks great](http://lua.gts-stolberg.de/en/index.php) Boomark it for reference. [Here's a tutorial for Murgalua](http://www.murga-projects.com/murgaLua/murgaLua.html#A walk through) Which will allow you to build programs with interfaces using code or WYSWYG editor FLUID. [Download source/binaries of MurgaLua here](http://www.my-plan.org/storage/private/murgaLua-snapshot.tar.gz) [Zerobrane Studio](http://studio.zerobrane.com/) has lessons in Lua built into the IDE. 
thankyou, all really good links :)
I left out this [Lua Text Adventure](http://shawndumas.github.com/adventure.lua/) by a 10 year old and his dad on GitHub. 
I am a Computercraft (CC hereafter) user, it's the only Minecraft mod I use at all (except wireless redstone). I love the lua-based internal OS in the computers, the ease of use and customization it grants; the addons system (disks, screens, redstone output) and how turtles are like robotics simulation for beginners. I love using CC computers for domotic and automation purposes, I might want to contribute when I make something really flashy (If I find the time). I also made crude replacements of gnu coreutils like cat, but I believe there are better ones, already, at the forums. On that matter, since we are on the Lua+Minecraft topic, this might interest readers: https://github.com/tiin57/luaforge "Minecraft Forge in Lua", Forge being the framework that runs CC and other popular Minecraft mods. If I am not misunderstanding it should allow to write Minecraft mods in Lua, which sounds like a good thing to tinker with.
Do you have something specific in mind? I'm not aware of anything, but that may be due to using it for such a narrow set of tasks. Mostly I'm calling C and Fortran functions, and I trust the libraries I'm using.
if you like lua in a 3d world, then try Minetest-c55. it is a mc style sandbox block game fully moddable via lua api.
Looks interesting! Thanks for the tip.
[MobDebug](https://github.com/pkulchenko/MobDebug) is a pretty nice Lua CLI debugger written in Lua.
It means just that - strings cannot be modified. You can't shorten them, change any characters within them, etc. string.gsub() (and other methods) will return a different string. So: local str = "some string" string.gsub(str, "some", "different") -- This should replace "some" with "different" print(str) -- prints "some string" still, string is unchanged -- But, you can create a new string: diff_str = string.gsub(str, "some", "different") print(diff_str) -- prints "different string" Hope this helps. And good choice of first language!
Strings can be updated and appended. a="this" a=a.." and that" print(a) will return "this and that" 
First, what is your question exactly? How it relates to scripting in Lua, or are you trying to understand the underlying architecture. Since for actual programming in Lua, this fact doesn't mean much to you. All functions that manipulate strings are doing their work and returning results to you. What it DOES mean, is that a lot of operations on strings is SLOW and uses a lot of memory, then creates stress on the garbage collector to clean it up after. As an example, let's say you're doing an operation to build up a string in a bunch of parts. Instead of doing: mystring = mystring.."new stuff" over and over, you might be better off loading new parts into a table, then table.concat at the end. Here's a breakdown: mystring = "string 1-" mystring = mystring.."string 2-" mystring = mystring.."string 3-" What's happening? Line 1 creates a string. Line 2 takes the contents of 2 strings and makes a 3rd string in memory. Line 3 takes that 3rd string and makes a 4th string. Each additional operation keeps allocating the total size of the previous in addition to what you're adding. (So each operation is taking an ever increasing amount of memory, in addition to the time it takes to copy the data over and over) Now your memory looks like this: "string 1-" (not in use by "mystring", but it may be a constant) "string 2-" (constant used in code) "string 1-string 2-" (garbage, nobody using it anymore) "string 3-" (constant used in code) "string 1-string 2-string 3-" (current active pointer) With 3 steps, it's not too bad. If we go much beyond that, you can see how it'll add up. Using tables: mystringtbl = {} table.insert(mystringtbl, "string 1-") table.insert(mystringtbl, "string 2-") table.insert(mystringtbl, "string 3-") mystring = table.concat(mystringtbl) Now your memory is: table overhead "string 1-" (constant, pointer from element 1 in table) "string 2-" (constant, element 2) "string 3-" (constant, element 3) "string 1-string 2-string 3-" (current pointer used in mystring) Now besides speed issues, the point where you need to know that all strings are constants is when you start using Lua strings with the C bindings. In C, you would call a function asking Lua for a pointer to a string. You then get a pointer with a null terminated string, and you can read it all you want. If you try to write to it, you'll screw up everything. The real magic with this is that another part of your code can request a pointer to a string, and if the contents are the same, the pointer itself will be equal. So you can cheaply compare strings of ANY size with a simple integer compare. If pointer 1 == pointer 2, strings are the same. This comparison is also extremely fast in Lua itself. Confused yet? :)
In that example, Lua has interned strings, so there's a table which looks like this: 1. this 2. this and that And then the variable `a` contains the value `string#2` after the second line. When the garbage collector runs, presumably on line 3 if it even does, then `string#1` is deleted, because no variable references it.
I specifically learn't how to code to use ComputerCraft in tekkit. I dont know any other languages and i have never coded outside of ComputerCraft. http://www.server569.com/phpBB3/viewtopic.php?f=6&amp;t=1204 that was my first program I wrote. 
This is literaly the opposite of where I want Lua to go next. It needs to become it's own language, it has the power and potential. I can't stand this attitude what insists the libraries be small, there's no need for that in this day in age. I switched to Lisp from Lua becase Lua wasn't meeting my needs, and it looks like I won't be switching back. &lt;/3
&gt; I can't stand this attitude what insists the libraries be small, there's no need for that in this day in age. Wait... what? The small size of Lua's codebase and runtime footprint is one of its primary distinguishing characteristics, which is why it's so popular for games and mobile/embedded devices. I would love to see Lua's authors create/sanction a greatly expanded standard library, and given the ease with which modules can be included or excluded from Lua, this would have little impact for embedded devices. However, for *core*, essential libraries, like the string library, being reluctant to quadruple in size is admirable, something we see far too little of these days. If you want a kitchen-sink language, they are a dime a dozen. Languages like Lua, where size and efficiency of the implementation have remained in the forefront of the authors and maintainers minds for decades, are far rarer. 
&gt; When Lua decides to grow up past embedding "grow up"? "past"? As if embedding represent some kind of immaturity? As if there is some universal, objective metric for "better" and being embeddable is lower on that scale than having rich built-in libraries? That reminds me of people who view Evolution as a ladder, with Man on top, so they can't understand why chimps still exist (of course, it never occurs to them to wonder why amoeba and starfish still exist). [Lua was designed for embedding](http://queue.acm.org/detail.cfm?id=1983083), it is *used* as an embedded language, and it as done quite a bit of "growing up" over the years to make it better for that purpose. For instance, the mark and sweep garbage collector was replaced with an incremental collector in 5.1 to make Lua better for realtime use. What kind of collector does Scheme use? Python? Ruby? In those languages they don't specify, and you don't care, it's an implementation detail. With Lua, the implementation is part of the appeal, Lua is a *library* as much as a language, so size and [implementation details](http://www.lua.org/manual/5.1/manual.html#2.10) matter. That's why you see Roberto carefully deliberating changes that will increase Lua's size and/or complexity. 
LPEG is written by PUC-Rio, so what they're essentially asking is to merge their two codebases together. Since there's probably no shared code between the two, it's a dubious request. On the other hand, LPEG would be the perfect jumping off point to do some community organization. Granted, a few people on lua-ml might be a bit toxic toward that end, but there is a noticeable fragmentation between the various Lua communities, and that could stand some pulling back together. And like I said, at least in the form of starting to bless some things. They wouldn't even have to invent anything, we have tools in place already (like luarocks) and models to follow (like Perl's CPAN).
I was thinking about this, and I believe it's more because it's efficient than because it has a light footprint. It's footprint could be twice it's current size without affecting any system that currently runs it, but if it were twice as slow it would be a different story. Small footprint is still important, and it's good that it's a design goal of Lua (most languages do not care), but it could be moved further down the list. IMO the priority should be: - Efficiency - Language Features - Footprint This means it may still take a long time to develop lua as it can be hard to develop an efficient design, but features should not be constrained by footprint. They should only be constrained by development effort. 
However, with virtualization, it is possible to slice up a large machine into very small pieces for different users. For instance, the [smallest Amazon EC2 instance](http://aws.amazon.com/ec2/instance-types/) has about half a gigabyte of RAM. Processor companies in general are putting more and more cores onto the same die, and while each has some cache, main memory bandwidth is a major constraint. So keeping a small execution footprint is still desirable. What _language features_ (which can't be solved by a library) do you need, anyway?
I'm fine with a feature being a library vs baked into the language. Where a feature should go really depends on the function it provides. One of Roberto's cons against LPeg was footprint, and I say he should just go ahead and include it.
I just started programming turtles yesterday. As a non-programmer with some basic programming knowledge it can be challenging but is a lot of fun. I am working on a mining and a terraforming program at the moment. 
Yeh basically, But I got around it using this however. x-x%3+(x%3==0 and 0 or 3)
0.1 cannot be precisely represented in the floating point standard. As you suspected, it is roughly 1 but not exactly 1. 
that's what I suspected, so is there a way to force lua to cast something as an int?
&gt; That's what I suspected, so is there a way to force lua to cast something as an int? First of all, casting to int wouldn't help you. The problem is that you've got a fractional value very close to 1. Casting to int simply truncates the fractional part, giving you 0. You'd get the same result in C: double y = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1; printf("%d", (int)y); // 0 Second, even if casting to int would help, Lua doesn't have an int type. However, a 64-bit double can hold anything a 32-bit int can with 100% precision. The problem you have it simply one of rounding. You want to round to the nearest whole number, rather than truncate the fractional part. You can do that like this: print(math.floor(y + .5)) -- 1 
It just so happens that multiplication by n is slightly more accurate in some general cases than n additions, but I don't think this is the cause of your troubles. Since we're working in a system where everything is floored at the very end, we can sort of just discard all powers of two higher than -1 in our analysis and only look at the "fractional" part in decimal to see which numbers will round up and down when your value is close to an integer. For example, take 0.1, which is the fraction 1/10. Now, in base two, this is the division 0b1/0b1010, from which if you just do the inside/outside-of-a-roof division technique taught in gradeschool (but using base two numerics and operations) 0.00011001100110011... _____________ 1010.0 | 1.00000000 0.1010 ________ 0.01100 1010 _______ 0010000 1010 Now, if I remember correctly, I believe that most installations of Lua uses double precision floating point arithmetic (this can be verified by doing math.ceil(1+math.pow(2,-52)) vs math.ceil(1+math.pow(2,-53)) on your own installation of lua, if the first is 2.0 and the second is 1.0, then it's double precision, otherwise, it's single precision), this then means that our 0.1 will almost look like the following represented in the machine 1.{1001100...11001[1001]} * 2^{-4} where the [1001] part is what is truncated or rounded up (depending on the rounding mode) and the numbers in the {} are the actual digits kept by double precision. Suppose that double precision can only keep track of 53 binary digits of a "binary-point" (analogous to what a decimal point number is). Now, we can check what that last bit is by adding and subtracting 2^{-3}, the reasoning behind this is as follows: Suppose that I can keep track of 2 digits after the one, and I have a number that looks like 1.01 * 2^{-4} now, if I add 2^{-3} to it, then in binary point, it would look like 1.101 * 2^{-3} but we can only keep track of the first 3 digits, so we either truncate into 1.10 * 2^{-3} or round to 1.11 * 2^{-3} now, since all powers of two are perfectly represented, if we again subtract off the 2^{-3}, we will have 1.00 * 2^{-4} (if truncating) or 1.10 * 2^{-4} (if rounding) neither of which are equal to 1.01, so the test will fail; you can thing of this as the left and right shifting of the fractional part of a floating point number On my computer, I have &gt; = (0.1+1/8-1/8) == 0.1 true this strongly suggests that the last digit of 0.1 in binary point is a 0 (since shifting it left one and right one did not change the value, albeit the rounding mode does add a bit of uncertainty in, but let's just assume for now that this is true), and if we actually look at it, our fractional part is actuall 1001100110011001100110011001100110011001100110011010 which is conclusive proof that Lua rounds rather than truncates. Now, using the following python script to help me, I can sort of better understand what is going on &gt;&gt;&gt; conv = lambda n: "{0:64b}".format(struct.unpack("Q",struct.pack("d", n))[0]).replace(' ','0') &gt;&gt;&gt; conv(sum([0.1]*10)) '001111111110[1111111111111111111111111111111111111111111111111111]' &gt;&gt;&gt; conv((0.1*10)) '001111111111[0000000000000000000000000000000000000000000000000000]' Now, hapilly, the errors in the second calculation, 0.1*10, seems to have "canceled" itself off. To understand this, I will give a simplification that may not generalize to all settings. Suppose that we take as an axiom that add and multiplication will create at most 2^-53 amount of *RELATIVE* error, in other words, each addition and each multiplication may get the 52-nd digit wrong (justify this to yourself). Now, 10 additions will generate an order of O(2^(-53))*O(2^(-4))*O(2^(-4)) amount of relative error (since each operation generates around O(2^(-53))*O(2^(-4)) error, 10 of these will generate O(2^(-53))*O(2^(-4))*10 = O(2^(-53))*O(2^(-4))*O(2^(-4))), which is just on the order of magnitude such that it may affect the calculation more significantly than if, say, we were to just do one multiplication operation. In general, multiple operations will generally give worse precision than one analogous operation. This is especially serious when your value approaches zero as the relative error will begin to blow up. Consider = 1-(0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1) 1.1102230246252e-016 (note also that commutative operations in Reals are no long in their FP counterpart, so &gt; =1-0.1-0.1-0.1-0.1-0.1-0.1-0.1-0.1-0.1-0.1 1.3877787807814e-016 gives a different result) The best thing to do is to rewrite your problem in such a way that the absolute error rather than the relative error will be the dominant factor in the determination of the quality of your computation, but if you really can't avoid it, here are some nice tricks (some are taught in standard courses on scientific computations, others I've discovered on my own and have never seen on the internet before): * If you know the topology of your problem and can guesstimate where your solution falls around, you can add in a moderately large power of two if your solution is a moderately small (&lt; 1) number. For example, the sum(0.1) != 0.1*10 problem can be resolved if you just normalize both sides by adding one and comparing again. The reasoning behind this is that addition by a power of two is analogous to the operation left-shift-and-round, so if your number is "moderately small" (in some sense of the word), your error will most likely be really small, so a left-shift-and-round will likely equalize the two numbers. Consider conv(sum([0.1]\*10)+1) '0100000000000000000000000000000000000000000000000000000000000000' conv((0.1\*10+1)) '0100000000000000000000000000000000000000000000000000000000000000' this worked because the error was in the 52nd digit, so by left-shifting 1 digit and rounding, the error went away * Taylor expand your function to avoid singularities of the relative error. Do be careful however, this could blow up in your face. Usually, we don't do this unless our problem is severely degenerate * Multiply by the conjugate if you have a potential subtraction or an addition of a negative number. The conjugation typically switches the sign of the problem at the cost of a little bit of more computation. For example, sqrt(x+1)-sqrt(x) may not be desirable for large values of x. Instead, you can write (sqrt(x+1)-sqrt(x))*(sqrt(x+1)+sqrt(x))/(sqrt(x+1)+sqrt(x)) = 1/(sqrt(x+1)+sqrt(x)) Here are some simple and slightly more complicated exercises to cement the idea. How would you rewrite the below expressions to avoid unnecessary loss of accuracy? Find the points where the problems will occur. (I will write up a set of solutions soon) * sqrt(x^(2) + 1) - x * log(x) - log(y) * (sin(x)-x)/x^3 === you might consider taylor expanding this one * sqrt(x+2)-sqrt(x) * exp(x) - e * log(x) + 1 * (cos(x) - exp(-x))/sin(x) * sin(x) - tan(x) * log(x + sqrt(x^2 + 1)) Next, consider a "telescoping" series of the form S_n = sum^n_k 1/(k*k+k) We can show inductively that this series in closed form is S_n = 1 - 1/(n+1) If you actually compute this directly in lua using &gt; function S(n) s = 0 for k=1,n do s = s + 1/(k*k+k) end return s end and find the error, you will see that for n=60000000, S(n) will be significantly off from the expected result of (1-1/60000001) (in terms of relative error, 1e-10 is pretty bad). However, if you reverse the direction of the summation (i.e., k=n,1,-1), the problem seems to disappear. Give an explanation of this behavior.
[Most programmers do not undertand floating point](http://lua-users.org/wiki/FloatingPoint) (myself happily included). Otherwise, Leegao wouldn't have felt compelled to write a [FP dissertation](http://www.reddit.com/r/lua/comments/14a448/lua_precision_weird_issues/c7bd95o).
&gt; when I hit the G6 key it plays "like a G6." What do you mean? I see the G keys from Google Images but I don't know what is "like a G6"? Is it the sound?
It's a song. Not a very good song, but a song. https://www.youtube.com/watch?v=w4s6H4ku6ZY
http://www.reddit.com/r/lua/comments/13afwm/looking_to_begin_learning_lua_there_is_no_faq_or/
Thank you! Just another question since you seem to know Lua: can the \_\_index be somehow "dynamic" instead of being a regular table. I would like some kind of system that gets all the method calls and "create events." That's confusing: I would like to be able to do: o:onClick(function () ... end) o:onPush(function () ... end) and I would have a function that dispatch "click", "push", ... to create events dynamically. That is, I would not implement onClick, just "on" and this "on" event function would create the "Click" event. But I suspect that it is not possible.
To make it dynamic, instead of 'methods' as a regular table, give the methods table it's own metatable with an __index method. This way the __index call will chain. IIRC I believe metatable.__index = metatable is an optimization trick talked about in PIL. Yes, it is confusing and I also use new tables instead of self-referencing the metatable.
Thanks, I'll study this. And yes, the trick seems to be an optimization, it's allowed but confusing.
I will give it a look. I want a simple design without inheritance but I might not use it since I need to use the C API. Thanks a lot, that will be useful in the future (at least).
Sure, make __index a function. It takes a table and the name of the thing you're trying to look up in it.
That's exactly what I was wondering. I'll try this as it seems to be what I am looking for.
I get that a goal of lua is to keep the syntax minimal, but class support, if not in syntax, then at least as a standard library, is a huge missing part of the language imo. Glad to see that there may be a de facto standard emerging.
&gt; I find it confusing I don't know why it would be confusing. Metatables are just ordinary tables. Setting `__index = T` on a metatable just says "If table X doesn't contain a key, look in T instead. That T happens to be the metatable is irrelevant. \*shrug\* &gt; methods.f = some function I prefer: function methods:f() end Which means the same thing but is a lot more readable. 
**Jumper** is a pathfinding library designed for uniform-cost 2D grid-based games featuring [Jump Point Search](http://harablog.wordpress.com/2011/09/07/jump-point-search) algorithm. It aims to be *fast* and *lightweight*. Jumper is written in pure [Lua](http://lua.org). Thus, it is not framework-related and can be used in any project embedding Lua code. Feel free to give it a spin!
IIRC, the big problem with multithreading is that it is not portable or codedable in ansi C so any standard would have to be outside the Lua implementation.
Just in case anyone see's this, wanting to do a similar thing. As of currently you can't get a pixels RGB or HSV values with Corona. You can possibly get a library such as Lua-GD working with it if you fork out $3000 for the enterprise edition of Corona SDK.
I'm not a big fan of LCS. It's a lot of code, and can be done much nicer with tools already supplied from Lua.
As promised, here are the solutions to the exercises posted at the bottom of this post http://dl.dropbox.com/u/25316665/LuaFP.pdf
Though be warned. LuaJIT is 5.1 spec compliant, it also adds some features of 5.2, though not necessarily with the same syntax. 
I wrote an [integer type in C](http://codepad.org/LZpFrKbT). I wrote it quickly -- I just wanted to prototype it against a native Lua implementation for [a StackOverflow post](http://stackoverflow.com/a/4485511/501459) -- but you can use it as a starting point. Just change `int` to `int64`. 
A custom data type in C seems to be the way to go, for easy sharing between scripts and the performance boost over a raw Lua implementation.
I saw that too, but it seems kind of hacky to do it in Lua :)
Thank you! This should get me started much quicker.
They'd be used for parsing binary data, and potentially doing simple math with them, and/or passing them back to the API I'm defining. For example, the script could read a 64-bit value from the header of a file, then use that 64-bit as an offset within the file to seek to.
Oh, do try to stick with 5.1 syntax if you can and drop in the LuaJIT module after you are done so you can see the performance difference. It should be significant.
Thank you, I have understand that this is a bit hard to study. But the first version is free, so I have to check this out. Also if I am going to use lua more, I think that I have to buy the second version as a reference it there is no any other proper book etc.
Also what kind of development environment you use? some ide? or just emacs or vim? with some plugins? is there any other commonly used tools?
The second version is very cheap and very high-quality
[Zerobrane Studio](http://studio.zerobrane.com/) has lessons in Lua built into the IDE.
Personally, I learned a good deal about programming in general with PIL. It really is a terriffic book, not just showing you the syntax of Lua but also how to use it idiomatically. 
I have both editions in paperback. They aren't much different, really. Lua hasn't changed much. Either edition would work for learning Lua.
Just thought I'd drop this here. I've been using Trunk Notes (personal wiki note-taking swiss army knife app) almost since launch, and just started diving into the recently-added Lua scripting. It lacks some obvious capabilities (no command line per se, everything has to be output via a return command), but it's nice to be able to practice Lua on the go and get some immediate feedback on whether your code makes sense or not.
Thanks mkottman. Also slides and a blog post from my Open Source Bridge talk are [here](http://ifup.org/2012/07/03/luvit-nodes-ziggy-stardust/)
lua.org, download and install it from the downloads section. To run a basic program, you can either double-click a .lua file (It will close the terminal immediatly after it finishes though, so either stick a while true do in there or do option #2) or, using cmd prompt, run the program from there (cd C:/Users/.../Desktop; blah.lua;)
This is inaccurate since lua.org only distributes source packages. If you're on Windows, look for "Lua for Windows", which is a precompiled distribution. A little note: Lua 5.2 is the newest version, while 5.1 is currently the most-used version.
I'm wanting to just make programs for myself, not to teach the students. (I'm an esl teacher). I've been having lots of fun making stuff in computercraft, yet suddenly I feel like a total retard trying to make anything beyond hello world in lua for windows. I just spent about an hour trying to figure out how to clear the screen, but I couldn't find anything. In computercraft it is just term.clear, but I guess 'term' is sort of an api or something included with it. I really want to keep at this, but perhaps I would be better of switching to python (which I think has much better tutorials out there for noobs like me)
[LuaBinaries](http://luabinaries.sourceforge.net/download.html) (plain Lua) [luaforwindows](http://code.google.com/p/luaforwindows/) (Lua + libraries e.g. LuaSocket, LuaZip, etc). [love2D](https://love2d.org/) (Lua + 2D gaming libs) 
[QtLuaImagine](http://createuniverses.blogspot.com.au/2010/08/qtluaimagine.html)
[LuaDist](https://github.com/LuaDist/Repository/downloads) offers binary *batteries included* package for multiple platforms. 
&gt; I just spent about an hour trying to figure out how to clear the screen, but I couldn't find anything. This is because "screen stuff" like that is terminal specific and nonportable. If you are running simple terminal apps then its probably better to stay simple - just read stuff from standard input and write characters to standard output. Anything fancier then that is probably better served by a real GUI.
All you need is the Lua interpreter, which you get by downloading the source code and compiling it (something like "make linux") or download pre-built Lua binaries. If you want your scripts to be "executable", take a look at [srlua](https://github.com/LuaDist/srlua), a "self-running lua interpreter", with which you can "glue" an executable stub with your Lua source code to create executable binaries. However, running Lua programs from command line using the interpreter is the preferred way. In your examle, just type this into a source file example.lua: print("Hello, world!") And then at the command prompt in the same directory type: **lua example.lua** Also, some text editors, for example [SciTE](http://www.scintilla.org/SciTE.html) allows you to write your code in an editor and execute it using F5, displaying output pane side-by-side with your source. 
Crap. My order for 2nd edition just shipped.
Beware that the book price has been lowering steadily at Amazon. I ordered one copy yesterday by USD 30.36, and at this precise moment it costs only USD 26.37. They didn't even sent my packet :-(, but the price has not been updated. This amazon's floating (random?) price policy sucks...
I ordered the 3rd ed., and already own the 2nd and the 1st! I think you'll enjoy the book (its organization reminds me K&amp;R "C programming", which is the classic of the classics regarding programming languages IMHO) and in a couple of months you'll get the 3rd ed. :-). And the evolution of Lua between versions 5.1 and 5.2 is not that disruptive...
Feisty Duck was the publisher for the 2nd edition, and IIRC Roberto said they'd be coming out with the 3rd edition in a few weeks. http://store.feistyduck.com/products/programming-in-lua 
Are there any major benefits of using Luvit instead of Node.js? Besides the fact that it is faster. 
Great to hear this! Javascript is so bipolar that i wouldn't mind switching to lua. But, i've tried luvit+luajit few days ago and HTTP peformance were not so good and as the matter of fact it crashed few times (testing with ab). Maybe i'm doing something wrong, but nvm, just can't wait for more stable releases. 
Also, if you plan to code primarily for Luajit, the 5.2 docs and PIL 2e are still very relevant.
I'm looking forward to reading this, awesome. 
Uh, quick noob question. There is a raw_input statement in python. What is the lua equivalent of that? I've been searching for an hour. Edit: Sorry for being off topic. I will delete this when I get an answer.
Alternately, there's ZSH and [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh) which gives you this stuff out of the box.
This is interesting, thanks for posting. Is there a reason to believe that luajit offers a measurable performance benefit in this context? Afaics the script doesn’t get any more complex than batch processing. Also the call: hg root &gt; /dev/null 2&gt; /dev/null could be simplified to hg root &amp;&gt; /dev/null (same for git).
I used ljsyscall, which uses the luajit ffi to talk directly to the linux kernel. I figured it would be faster than spawning (e.g.) `uname` Thanks for the suggestion; I didn't know about `&amp;&gt;`, I was never much of a bash scripter.
Bash does in fact calculate line lengths properly if you wrap all non-printing stuff in PS1 between \\[ and \\] as indicated in the manual.
You wrote that you had started experimenting with the external command thing _because_ Bash is unable to calculate the prompt length when using PS1. This is not true, and that's all that I wanted to point out.
I actually started out using a `PS1='$(luajit .bash_prompt.lua \$? \j)`. When weird line wrapping started happening I found `PROMPT_COMMAND`
You could do this in zsh without dipping into lua and with less lines, I'm sure.
I can agree. I don't use omz, however reading through the source code there has provided a ton of snippets and ideas to implement for my own zsh setup.
Depends what you mean by "easily configured." If you consider having to call unsetopt to disable things omz enables unconditionally^[1](https://github.com/robbyrussell/oh-my-zsh/blob/master/oh-my-zsh.sh#L12) enables or (re)moving certain files from omz's git repo. Then yes, I suppose it is "easily configurable." To me though, that seems undocumented. if you chose the later option of removing files, that seems like it could have unforeseen side effects on all of omz. As an example, imagine removing lib/git.zsh because you don't want that, now function git_prompt_info is undefined and many of the themes break. In any case you now always have git_prompt_info declared and polluting things like tab completion. So I disagree on both accounts. I don't call that easily configurable and I don't see this "really good documentation" for omz which you mentioned. The only documentation I really found was a README, a zshrc configuration template, and the shell scripts themselves (as a coder, I don't consider this **good** documentation.) 
Not an issue with your script (AFAICT) but there seems to be issues (I think a BASH bug) with command history (WRT pressing up and down.) It seems to clear the the current line after you scroll back a few commands. I think this is an interesting way of doing this if BASH is the only shell option available (too bad there seems to be a bug in BASH itself.)
Nope, do not delete :) I have never write this but with quick googling it shows something like this: answer = io.read() I am not sure.
It turns out `PROMPT_COMMAND` also has issues... I found out about wrapping in `\1` and `\2` from the #bash irc channel. The blog post has been updated.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: http://www.reddit.com/r/Serendipity/comments/16y02e/making_a_standalone_lua_program_xpost_from_rlua/
Thanks. I did play with wxLua and seem to be good. Memory usage is almost double than TekUI but still very less and usable.
You are always going to need to plug something into Lua. I like this one, but it might be a bit heavyweight for you: [wxLua](http://wxlua.sourceforge.net/) Running your Lua code through their interpreter gives you access to wxWindow widgets. It makes scripting simple UIs pretty easy.
I've had lots of success with [IUP](http://www.tecgraf.puc-rio.br/iup/), both with vanilla Lua and LuaJIT. It covers the basics quite nicely and is fairly easy to ramp up on.
Odd, I thought I should be able to use some functionality from the OS? Or at least have a simple wrapper for that... My main concern is actualy distribution, as it is a plugin, I just want to have a directory with files, among them the GUI library. If I understand it correctly, wxLua has to be compiled before you can use it (or the Lua files have to go through wxLua, which isn't an option since in order for it to work as a plugin, it has to be a lua file) 
Can I just put IUP in a directory and just require / loadlib it or does it needs compilation?
There are plenty of Lua plugins which are wrappers to binary objects. Actually, most of them are. That's what makes them useful. It's been a while since I used it, but I'm pretty sure you can drop wxLua.dll wxWidgets.dll, and wxLua.lua in the same folder as lua.exe, and then just load the wxLua module. The other way it would work is you just use wxLua.exe instead of Lua.exe.
In addition, you can easily create a single exe out of a script using wxLuaRunner and wxLuaFreeze (distributed with wxLua)
I currently us wxLua and all I needed was wx.dll, wxmsw28_vc_custom.dll and two others like that. Though if OP is only fooling around, it's probably better to just do what you said, use wxlua.exe. I remember this being very easy to set up.
Can you also put them in the same directory as the file that needs them?
Gah, how does this work? I've downloaded lua52.dll and lua52.lib but I can't seem to require them? 
Can I also drop them in the same folder as the lua file that needs them? Do I use require or loadlib or something else?
I like [lqt](https://github.com/mkottman/lqt). It's one of the easiest to get going cross platform, and is very well documented. The first question you need to answer is which platforms you want to support: that will dictate the rest of your options. 
Doubt it, though I have worked a bit with the Tkinterer library in Python. Basicly I just googled for Lua TK library and came across a couple of the above
Windows as main, Linux is optional. I'll take a look at it, thanks :)
With windows as the main target; you probably want to rule out anything gtk based: I've found it an absolute pain under windows. That leaves you with: * Native (not suggested), * WxWidgets (I hate the api, but you could check it out) * Qt (best of a bad bunch) * something custom (see IUP or any of the countless other engines).
have you tried changing your [package.cpath](http://www.lua.org/manual/5.2/manual.html#pdf-package.cpath)?
By default, Lua doesn't come with any extensions and has only a basic standard library. This means that you have to download dll's for any extension you want to use. These dll's have to be put in the same folder as your lua executable, or any location in the 'package.path' variable.
wxlua dead easy 
Anyone know if it's out as ebook version?
&gt; I do not like the idea of using metatable.__index = metatable, I find it confusing someone mentioned one benefit, but another plus of doing this format is easy typechecking you can easily see if something is of type metatable by doing : &gt;obj1.__index == metatable
Okay ... I've got the 2. Release, I will just read that. As far as I understand, the difference isn't that big anyways
And further, since you're in Windows, the DLLs have to be either in the same directory as the executable or reachable from the %PATH% variable (which doubles as a DLL search path from some insane reason).
How do I install it on windows?
It's pretty cool. But not available for the moment on linux; probably soon.
There's also some [discussion on Slashdot](http://bsd.slashdot.org/story/13/02/16/2329259/netbsd-to-support-kernel-development-in-lua-scripting) about the annoucement.
lua's speed that ruby cannot.
Wow, this looks great! Thanks!
I've done gmod coding before. Best way to learn is to look at other scripts, and look at the wiki. Learn about hooks!
Okay, so if I'm understanding this right, the situation is like this: - You have (let's say) an array with a million things in it - There's another thing, that the GC thinks may be garbage. - Before it can collect that other thing, it needs to go through your million-element array to make sure none of those elements has a reference to this thing The thing is, even if you could tell the GC "just ignore this array" it wouldn't solve the problem. All it would do is not let any reference the array holds keep something from being garbage, so everything in the array would get collected in the first frame. :) Obviously since you have a reference to the array, the array itself isn't garbage, so it's not like it has to go through everything in it to make sure. What I would do is, move the array and the code that deals with it into a C extension where you can manage it by hand. You load your giant JSON thing once, load that data into a C-managed structure, and then Lua's GC no longer has to worry about it possibly holding references to stuff that's otherwise garbage. Obviously this only works if the data in the JSON can be represented in C, so like the JSON is a big list of identical things you can turn into a struct or whatever.
The graphics level is beyond my scope. I am essentially making a lua app, and graphics are performed by the engine in C. Lua is the event-driven abstraction layer above it. The frame work is a single thread (aside from separate threads for things like networking but all that is supposed to be beyond my scope as well). we are fairly certain it is the garbage collector after sampling the program and noticing that it was spending a considerable amount of time in there
You're thinking about it backwards. The GC doesn't care about your table, it knows anything in it isn't garbage. What it cares about is *other* things that might hold a reference to something that's also in your table. That's why it can't just "ignore this table" and still work: if a reference to something goes away, it can't be sure that this table isn't still holding another reference without scanning the table. Anyway, the answer is no, you can't tell the GC to ignore a table. Best you can do is to store the data somewhere where the GC doesn't have to manage it.
I'm confused, why does LUA need to traverse this table over and over? If it's a reference count, it should just increment the count for each object in the table when it's created and then be done. When you delete things from the table, it should decrement the count... I'm really wondering if it's not the GC at all... Again, I don't know LUA so I don't know how the GC works, but what you're describing seems wrong to me. What are you doing with these tables anyway? Are you sure it's not some other part of the code traversing the table?
Stop telling it to GC every frame then. That's a terrible fucking idea. More to the point: No, it is impossible. If Lua is slowing you down that much, use LuaJIT.
before we did that, it GC-ed every 10 frames or so, so you'd get a slight stutter every second
The problem is not how often you're doing it, it's that you're even doing it in the first place. Full GCs are expensive as fuck. Lua's default GC is incremental. If you're telling it to do a full GC every X frames, you're destroying every possible advantage that it could give you.
As annoying as it would be, keep the JSON as a string and reparse (pull out) values you want on demand. LPEG would be a great tool for this. Edit: expanding on the rationale, then you only have a single (large) string that needs marked by the GC rather than thousands of objects.
&gt; Unfortunately, the part of lua that interacts with C has been stripped out of the framework for security reasons so that isn't really an option He's recommending something like a userdata object where you might emulate the __index and __newindex meta-methods to give you a table-compatible interface for a different type of object. I understand it sounds complicated but Lua's primary strength is how easy it makes doing this sort of thing.
He probably means they've stripped out the loader for binary extensions, like Love2D does. No binary extensions, no userdata.
Have you tested not forcing collection every frame? Lua's collector is already incremental.
compared to the cost of redrawing the screen, the time spent in lua has typically been utterly negligible. This is seemingly the first time that we've had this much loaded up into memory (that isn't graphics memory)
yea this is the option that I am considering the most. Luckily the data is broken up into multple jsons such that I can keep the root level parsed, and i can parse it's sub-tables as needed
Actually, LuaJIT is probably one of the few dynamic languages that should be considered for systems stuff thanks to its FFI. Just look at projects like ljsyscall or Snabb Switch. Lua has also been embedded into the NetBSD kernel recently. As for iOS, what can't run there is the JIT part of LuaJIT but you can use it in interpreter mode, which is already faster than Lua. The real reason it is less easy to port than PUC Lua is that it has lots of parts written in assembly for performance. As for libraries, I agree, we need more work on that. But if you use LuaJIT the FFI allows you to use most C libraries when needed...
&gt; Actually, LuaJIT is probably one of the few dynamic languages that should be considered for systems stuff thanks to its FFI. Most dynamic languages have FFIs (thought LuaJIT's is especially nice, IMO), but I wouldn't say that makes them "suitable" for systems work, it just makes some amount of system level stuff technically possible. What FFI's are *usually* used for is interfacing with system libraries without having to write a language extension, not for writing systems. &gt; As for iOS, what can't run there is the JIT part of LuaJIT but you can use it in interpreter mode, which is already faster than Lua. I was referring to the "nearly as fast as C" performance the OP referenced, which requires JIT. &gt; But if you use LuaJIT the FFI allows you to use most C libraries when needed... Well, using an FFI is various degrees of painful compared to idiomatic libraries. I mean, yes, you could write an entire Win32 application (for example) using nothing but a bunch of FFI calls, but holy crap it would be a pain in the ass. Much better to have a UI library written for idiomatic Lua use that abstracts away all the low level stuff. Now you *could* write this high level library in terms of the FFI, but even that would be more painful than just writing it in C. An FFI is handy for making a few calls here and there where libraries aren't available, but I don't consider it a suitable replacement for libraries. 
&gt; What FFI's are usually used for is interfacing with system libraries without having to write a language extension, not for writing systems. That's what I thought until recently, but I reconsidered after seeing device driver code in LuaJIT like https://github.com/SnabbCo/snabbswitch/blob/master/src/intel.lua Of course it is user space code. Kernels are still mostly C/C++, even though they are experimenting with Lua in NetBSD. Regarding the FFI and libraries I agree that it depends on what you need the library for, and that it is a problem for libraries with a large API surface.
&gt; That's what I thought until recently, but I reconsidered after seeing device driver code in LuaJIT As cool as that is, it's not what "FFI's are *usually* used for". :) Side note, I need start using LuaJIT more often. It is stupid fast. 
The bindings to Ncurses... I couldn't get them to work; and a fair few other libraries. A blessing and a curse is the developers non-reluctance to break back-wards compatibility. It's frustrating that Luarocks and some of the rocks haven't upgraded yet (may have changed - haven't checked in a few weeks).
It sounds that Lua is as capable as many other scripting / dynamic languages (and may even have a performance advantage), but its primary weak spot is in libraries? 
Lua's limitations are not "roughly" defined, but are well defined. In particular: The size of the call stack is limited by `LUAI_MAXSTACK`, on machines with at least 32-bit addresses this is defined as 1000000 by default, plenty of space unless you're doing deep recursion. Lua numbers are IEEE-754 doubles, so they're only precise to 2^53 - 1. You can't have more than 200 local variables in one function. There's a similar limit on the number of upvalues, 511 I think. Lua 5.1 has a limit of 2^18 -1 constants in a function. Lua 5.2 increased this to 2^26 -1. And, of course, Lua is limited by the virtual memory space on your computer, as is everything else. I don't think that's quite what you were asking. But I don't understand the point of your question. It has long since been proven that any programming language with stored memory and conditional branching can do anything any other language can do. So if there's something Lua "can't" do, then nothing else can either. 
I'm fairly new to Lua and programming as a whole(I don't count HTML.) I've done a lot of research about one language vs another and everything keeps drawing me back to Lua. I find low level languages like C, C# or Java intimidating and Lua's syntax is so clear for me to follow, I just keep getting drawn back to it. The reason I asked was basically to see what I'm losing by sticking to Lua rather than upgrading to a more complex language. Lua seems to qualify for just about everything I want to learn to programming for. The only thing I've really found "against it" is that I'm not going to be getting any programming jobs with only knowing Lua.
Not having pre-packaged libraries is an annoyance, rather than a limitation.
There are tons of things Lua can't do out of the box, but almost all of them can be added with native extensions or clever metaprogramming. I can only think of a couple things that I'd have to use another language to get around: - Parser generation from BNF. There's no theoretical reason why you couldn't implement something like Yacc or Antlr in pure Lua, and in fact last year I took a crack at it, but there's no off-the-shelf solution. It's a big thorny thankless problem from hell that no one's solved yet. LPeg is a decent substitute (except that it's a native extension so you can't use it everywhere, and it's fundamentally different from writing a BNF grammar like most people are used to). - Threading. Lua doesn't have any knowledge of multithreading, unlike things like Java (where critical sections, etc are baked into the VM). There are extensions like [Lanes](http://kotisivu.dnainternet.net/askok/bin/lanes/) that fake it with multiple Lua environments and fast copying in between them, though. FWIW I think this is a totally reasonable tradeoff; concurrency would make our cute, tiny language much more ugly and complicated. - Continuations. The language doesn't have 'em, you can't fake 'em. Coroutines can be used for like 99% of anything you would ever need them for though.
Mhmh. There are several problems in your code. Your 'if' conditions does not what you want. You could enter everything and the condition would be true. Have a look at line 2 and line 7. You read the input twice. I recommend that you should play around with your code in the lua console. Just test what it does. Line by line. http://luatut.com/crash_course.html may help you for a quick start. http://www.lua.org/manual/5.2/manual.html there you will find the solution for your "save all my text to file" problem. 
FYI if you can justify it you can use lua on iOS. For example it's used in many games. There are some caveats but Apple is "flexible" on this. 
For what its worth, we have used Lua quite extensively in a largeish embedded DSP system. Even in the embedded world, many interactions are not primarily performance constrained. Furthermore, Lua is amazingly adaptable to weird systems. For example, it is trivial to make Lua use a custom memory allocator or a different data type for its numeric type. Add its ANSI-C nature and you have a very flexible scripting system that can work on just about any platform out there that has a C compiler. Thus, I would say that Lua is extremely well-suited for embedded work.
If you only look at the language's technical definition and implementation, you'll find that it has very few limitations indeed: expressive, flexible, fast, easily interfaced, easily learned, easily extended. But a language is a man/machine interface, so its social dynamics matter as much as its semantics. Lua is intended to be embedded in a project; the project provides the equivalent of a domain-specific standard lib, that's why Lua's stdlib are so minimalist. As a result, there's no consensus on how to write and reuse Lua code: each project lives in its own bubble, with its own stdlib stub, its own homebrew oo layer etc. Whereas in Python there are strong stylisitic rules, and projects easily blend together, reusing Lua code sometimes feels like herding cats... or lispers :) Tl;dr: Lua misses the social dynamics which leads to widespread adoption as a generalist, standalone language. It's not a bug, it's a feature.
&gt; The only thing I've really found "against it" is that I'm not going to be getting any programming jobs with only knowing Lua. You might not get a job writing Lua programs, but there's no reason being a Lua expert will prevent you from getting a job. Lua's embeddability is a great argument for focusing on it as a first language. If you want to later learn C or C++, you can write some parts in C/C++ and others in Lua. If you want to learn Java, you can use [LuaJava](http://keplerproject.org/luajava/). You'll learn a lot of C if you use the LuaJIT FFI to call C libraries. Work your way through the source of [GSL Shell](http://www.nongnu.org/gsl-shell/) and you'll pick up a ton of C knowledge. The GSL code itself is beautiful C. The bottom line is that some language is the first one you learn. If you're a Lua expert, picking up other languages will be easy.
&gt; FYI if you can justify it you can use lua on iOS. I've used Lua in all my iOS apps, and have written entire games in it (via MOAI). I was talking about Lua**JIT**. You can't use a JIT-compiler on iOS, because Apple won't let you generate code at runtime. Of course, *they* themselves use JIT-compilers, but won't let anybody else do it, because... Apple. 
&gt; It's not a bug, it's a feature. I wouldn't call it a bug, but I don't think it's a feature, either. Having the social dynamics that made it useful as a general-purpose stand-alone language wouldn't hurt its embedability into projects, I think.
&gt; Continuations. The language doesn't have 'em, you can't fake 'em. You can do one-shot continuations with coroutines.
Not having a comprehensive stdlib is a feature; lack of social dynamics is a consequence.
&gt; 1. Low level machine access. [...] I see where you're coming from. It is true that Lua is just a scripting language. Things tend to improve in this regards though: we now have bitwise operations; we'll probably have native integers in a future release, etc... I agree that Lua alone is not suitable for systems programming. However, given that interfacing to C is so easy, Lua can be helpful even in low-level applications, see for instance the future [integration of Lua in the NetBSD kernel ](http://www.phoronix.com/scan.php?page=news_item&amp;px=MTMwMTU#n).
I haven't used it myself, but I noticed the other day that Lua (at least 5.2) has a function to run the garbage collection for a specified amount of time and then stop. Perhaps you could do this every frame with a small time limit. 
This actually did the trick pretty much. We have yet to do any extensive testing to see if any hiccups in performance ever happen, but so far it looks good. Thanks.
Setting the GC to generational seems to be working so far, but I imagine GC tweaks in general would have helped
Which part did the trick? Playing with the GC parameters or the generational GC?
generational
Here's the version I ported: http://vintage-basic.net/bcg/hammurabi.bas I'm completely surprised that the plague can actually be a good thing to happen during the game.
Eric was probably thinking of something like an older Arduino, where you have maybe 1k or 2k of RAM, and any sort of VM will be unusable.
Wow ! It's very hard to survive more than three years.
There might be some good ones in there, but it's not confidence-inspiring when the first one I click (the first in the list) is absolute shit. This is the shuffle routine offered: function shuffled(tab) local n, order, res = #tab, {}, {} for i=1,n do order[i] = { rnd = math.random(), idx = i } end table.sort(order, function(a,b) return a.rnd &lt; b.rnd end) for i=1,n do res[i] = tab[order[i].idx] end return res end This creates three tables, a closure, requires a call to `sort` along with *two* additional passes through the array, and metric shit tons of of unnecessary table lookups. Here's a much simpler routine (which I came up with several years ago, and later found is the "Fisher–Yates shuffle" or something close to it): function shuffle(t) local n = #t for i=1,n-1 do local r = math.random(i,n) t[i],t[r] = t[r],t[i] end end No new tables, no closures, one pass through the array, minimum possible number of reads/writes. 
Cool, I'll check it out!
Thanks, I haven't looked at it yet, a friend sent it over and thought it was useful. Is it best to just delete the post so no one tries to use it?
I don't know. Looks like it's various authors. Some might be great while others... not so much. It would be a *much* better site of snippets could be rated by users.
The best way to learn Lua is still to buy Programming in Lua, a book by the main author of the language. The 3rd edition has recently been released, the first edition is available for free online but it's outdated. See http://www.lua.org/pil/ After that, like any other language, find an Open Source project you like and read its source code, try to modify it... Note: people who have more programming experience can start straight from the manual (http://www.lua.org/manual/5.2/) and get up to speed very quickly but in your case I really think you should read PiL first.
The Lua manual is the number 1 resource to learn it. However, it can be a bit technical and concise at times so I also recommend reading the [Lua Tutorial from the wiki](http://lua-users.org/wiki/LuaTutorial). There's also "Programming in Lua", a book of which there is an outdated but free online version and two more recent versions which you have to pay for. I've personally bought the second edition and I'd say that the money is worth it.
I had a friend link [this page to me.](http://www.phailed.me/2011/02/learn-lua-the-hard-way-1/#desc) I hope this helps.
[iNTERFACEWARE](http://www.interfaceware.com) makes a great integration engine (ETL tool) called IGUANA that features a [LUA based IDE](http://www.interfaceware.com/iguana_translator.html) The IGUANA documentation wiki has an entire section devoted to understanding LUA - it's pretty helpful: (http://wiki.interfaceware.com/57.html)
As someone who is using Lua 5.1, I would still recommend the third edition of Programming in Lua over the second. The third edition has questions at the end which challenge whether you know what you just learned. The only major thing which is different is 5.2 removed setfenv and getfenv, which unless you're embedding Lua, you won't even need to concern yourself with. 
To help with reading your code, could you please answer the following questions: 1) What sequence of function calls are you expecting? 2) What sequence of function calls is actually taking place? 
Thanks for the reply. The function sequence, at the point of error should be: 1: RuleBook.CardCoder() will be called in the GamePlay() function in main. 2: Depending on circumstance RuleBook.MagicRules() or RuleBook.PlayCards(), or RuleBook.RemoveCards(). 3: 3.1 If at the last point we went to MagicRules() then we go to RuleBook.MultipleCheck() and then to PlayCards() or RemoveCards(). 3: 3.2 If we went to PlayCards() at the last point then RuleBook.RemoveHandCards() twice (for separate jobs) then to RuleBook.ReserveCardRules(), then to RuleBook.CardPileAndHandCheck(). From here we either go to RuleBook.Do_Bundem() or RuleBook.MagicTest(). 3: 3.2.1 If we went to Do_Bundem() then we simply go back out and begin at CardCoder() again. 3: 3.2.2 If we went to RuleBook.MagicTest() then depending on circumstance we might call one of the Do_...() functions (all of which apart from Do_Bundem() will simply set a boolean and then call RuleBook.TurnChange() ) or we simply go straight to TurnChange(), and from there back out and begin back to the GamePlay() function where we will call the AI function Opponent_AI.OppPlayCards() (will be explained further on). 3: 3.3 If at point 2 we went to RemoveCards() we go back and begin again at CardCoder(). 4: If we have gone to TurnChange() then we will be starting the AI functions. The first called is, as mentioned previously, Opponent_AI.OppPlayCards(). Typically we'd call RemoveHandCards() and then call Opponent_AI.MultipleCheck(), but there under certain conditions it will call RuleBook.Pickup(). 4: 4.1 If we went to Pickup() then we will call RuleBook.LastPickUp() and then TurnChange(). 5: If we went to MultipleCheck() then under certain circumstances we might go to RemoveHandCards(). 6: After this we go to Opponent_AI.LastPickupCheck(). Similar to previous AI functions, under certain circumstances we may go to RemoveHandCards() or Pickup(). 7: Then we go to PlayCards() and back to GamePlay(). Additional info: The 'certain circumstances' for calling RemoveHandCards() are whenever I want to compare one set of cards against another and remove any identical pairs that may crop up from the second set. The function name is a little misleading, it's really an all purpose function for removing duplicate cards, or making sure cards being played don't exist twice. Pickup() will be called when the AI's 'hand' is empty. Thats basically the game, the player's turn and then the AI's. Hope that helps! Edit: Also I'm aware the code probably isn't anywhere near a professional standard, if I had to describe my level I'd say intermediate.
Its hard to use the information you've given here. I asked you those questions so I can compare your idea of how its supposed to work with what it is actually doing **near where the bug occurs.** You wrote: &gt;The error occurring is that the game will simply jump out of the user's turn and jump straight into the code that allows the A.I to start determining what cards it can play (this happens in a function called Opponent_AI.OppPlayCards). It doesn't even start the function that does this, it simply jumps into it. What function was being executed when this "bad jump" into Opponent_AI.OppPlayCards occurs?
From the prints the last called was RuleBook.TurnChange(). So if I had to guess it's most likely the GamePlay() function in main.lua. As after executing the TurnChange() code the program should, and usually does, go back to the start of the code, which would be GamePlay().
Try putting the line: print(debug.traceback()) in the bad spot in Opponent_AI.OppPlayCards to find out what the call stack actually looks like.
Just a guess here, but I notice near the top of your trace the line "OppPlayCards: UnPlayable cards going back to hand" which is in Opponent_AI.OppPlayCards. It seems that rather than a jump into Opponent_AI.OppPlayCards from somewhere else, it seems much more likely that you never left the Opponent_AI.OppPlayCards function at all, especially since Opponent_AI.OppPlayCards is capable of calling each of the functions referenced in the trace after that.
Ok. So this is the result of the trace: Opponent_AI.lua:233: in function 'OppPlayCards' main.lua:132: in function 'GamePlay' main.lua:180: in function 'update' [string "boot.lua"]:407: in function &lt;[string "boot.lua"]:373&gt; [C]: in function 'xpcall' [string "boot.lua"]:804: in main chunk And that's an interesting idea, do you know why this might be happening - is there a loop I'm not breaking out of or might it be a little more sinister? Note: I put the trace at the point where it prints the unplayable cards
Rules of thumb: Your functions should have a single, clearly defined purpose. Your functions should be short. Don't nest if blocks and loops deeply. What all programming rules boil down to is write your code in such a way that you can reason about it. The function you are working on has to fit in your brain. In these turn based games, one way to organize the code is to have a function that generates the set of legal moves a player can play in their turn, an AI function that simply selects which of these moves to play, and a function that applies that move to the game state. Your Opponent_AI.OppPlayCards looks like its trying to do everything at once. If you split it out, you'll be free to focus on writing different strategies in your AI move selecting function without worrying about breaking the game. You've trapped yourself into a corner the way it is written now. 
Could you rephrase that question?
Haha, sure. What could I specifically do to fix it? As it is I can see ways of making the class cleaner and less cluttered, but I can't see a way to get rid of the actual error occurring.
You probably won't want to hear this, but the only thing I can suggest is to rewrite your whole program. Rewrite that function so that it is ONLY responsible for selecting a move, and nothing else. It shouldn't be responsible for doing the move, or keeping the various decks of cards valid, or anything else. A different function should come up with the available moves. A different function again should apply the move. So that's 3 separate functions. 1) A function which returns a list of available moves. This function implements that game rules. 2) A function which takes a list of available moves and returns a move from this list to be performed (this is where your AI strategy is implemented). This function should not actually apply the move. 3) A function to apply a given move. This function applies the move according to the rules of the game. Notice how the AI function is free from having to worry about the game rules, and is free to focus on strategy. Good luck. 
Ok. Well, I guess that's what I'll have to do. Big thanks for your advice.
Looks interesting. Does it work with LuaJIT?
There was a [talk about Luvit](http://www.lua.org/wshop12.html#Caswell) at last year's Lua workshop.
Well, fair enough, and to be honest, I expected some answers like this. But still, I'm curious about conventions. Conventions - as opposed to rules - can often make life easier for people by providing tested guiding principles. Freedom is great, but it can also mean that you have to invent everything yourself (and discover the problems by trial and error).
We've put together a style guide: https://github.com/Olivine-Labs/lua-style-guide We have a bunch of (larger) Lua modules under Olivine-Labs as well, if it's any help.
Great timing. Someone on Twitter just pointed me towards one of your modules (Busted), and I just cloned the style guide. Thanks for making the style-guide publicly available.
Awesome; hope it helps out! Feel free to submit issues / pull requests if you come across anything or have any questions about the guide, busted, or any of the modules we've written.
Two remarks: * In the function section, you advocate function syntax over variable syntax. You name the "bad" function "yup" and the "good" function "nope". It's difficult to know which style you prefer because of the misleading naming. * In the naming convention section, you advocate the use underscores for ignored variables. Both code snippets are labeled as "good" despite one using "k, v in pairs()" Some stuff seems pretty arbitrary (ie. empty line at the end of file) but whatever floats your boat... ;-) Have an upvote!
&gt; Some stuff seems pretty arbitrary (ie. empty line at the end of file) Version control and diff tools get along better with files that have a newline at the end.
If there's a justification, then I'm all for it. I never had such issues though (primarily using svn at work).
Yeah, I personally haven't run into any issues when missing a newline at EOF, but I tend to add it anyway for consistency's sake in non-personal projects I've worked on.
Thanks for the remarks; I'll make issues to fix the typos. The arbitrary stuff - as mentioned below, newlines are nice because of source control, but some of it is, by nature, fairly arbitrary. It's just our style guide; feel free to fork it and make your own changes if you'd like. We're just after consistency in all of our new projects.
In the Tables section "Consider nil properties when selecting lengths", your guide incorrectly uses the select function.
 ------------------------------------------ FINAL SCORE 10 points for reaching level 2 4 points for your hoard of treasure Finally, your elapsed turns score divisor is 1.7917594692281 YOUR SCORE: 7.8135487717175 you might want to round those numbers. and i only killed two skels but for now that's the **world record**!
 ------------------------------------------ FINAL SCORE 20 points for reaching level 3 6 points for your hoard of treasure Your starting HP was 4, giving a difficulty multiplier of 2.00 Finally, your elapsed turns score divisor is 3.47 YOUR SCORE: 15.00 Nailed it (though it looks like I'm using a newer pull. commit aff5334b622e16e4c0abc31afd3ae0b4a09af1a4) 
Actually, first-class functions aren't that different from function pointers because you're talking about a garbage-collected language where mostly everything is a reference to an object. The big difference is that there is some nice syntactic sugar around it.
You could improve the ui quite a bit with io.write("\027[2J") -- ANSI clear screen io.write("\027[H") -- ANSI home cursor display your game state 
Oh wow, I haven't thought about cursor control via ANSI codes in a long time; I've gotten used to leaning on curses for that sort of thing. But I wanted this to be 100% from-scratch with no deps, so while I know Lua has curses bindings, I didn't use them. Thanks for the idea :)
Do the lua bindings for curses actually work? I've never had any success with them.
In general you'll need a console of some type (on Windows something like CMD, MSYS, and likely PowerShell would all work with a lua.exe.) On *nix nanohack is has the executable bit set, so you could likely run it with ./nanohack.
There's a technicality that makes function pointers different from a function being 1st class. It has to do with the treatment of values in the language. In a language like C or C++, function pointers do what they advertise: letting you call a function with a variable rather than by the function's name. And then that's it. In a functional language, 1st class functions mean that you have the function as a value, not just a pointer to it. What this means is that the functions are full objects and whatever you can do to objects, you can do to functions. Lua doesn't really let you do much with them, except for creating lexical closures. In a language like Python, functions really are full objects. You can access members of a function like its `__name__` and so forth. Just for fun, try using debug.setmetatable on a function. The results are surprising. 
&gt;20 points for reaching level 3 5 points for your hoard of treasure Your starting HP was 7, giving a difficulty multiplier of 1.14 Finally, your elapsed turns score divisor is 3.37 YOUR SCORE: 8.48 You're the worst player at the moment. I'm the second best player. How does it feel? 
Cool. Not a fan of the n,w,s,e bindings but that's just me. Tried changing keybindings but it wasn't as simple as changing dir or dirname so that could be improved. Also, many literals, all those things will bite you in the ass when you expand (show_map is definitely scary). That said, congrats. Now sleep a bit! :P Oh! and remember that in lua if you use a variable that you haven't used before and you don't identify it as local you will be creating a global variable.
While I haven't played, I commend your effort. That looks like quite a bit of code for only 23 hours! Making games with LOVE is great fun. I did a group project for Ludum Dare 24 with some guys from the LOVE IRC channel and it was a blast despite us not producing anything all that great. If you ever want some help with a LOVE project, I'd love to collaborate!
Some time ago I saw the incantations necessary to make Lua read a character at a time without having to press enter. Can't find it now, I think it had to do with exec("stty -somethingorother") Colors would be nice, as is pausing briefly before reprinting the map. I just resized the window, but in my usual 25-line terminal it was scrolling off the top. Anyway.... ------------------------------------------ FINAL SCORE 100 points for reaching level 11 203 points for your hoard of treasure 50 points for looting the amulet! Your starting HP was 7, giving a difficulty multiplier of 1.14 Finally, your elapsed turns score divisor is 6.07 YOUR SCORE: 66.51 
 This seems to work [http://osdir.com/ml/general/2012-09/msg34355.html](http://osdir.com/ml/general/2012-09/msg34355.html) Looks like it is possible to build a pure Lua RL without dependencies. Except I don't think the ANSI codes work in Windows terminals.
&gt; In a functional language, 1st class functions mean that you have the function as a value, not just a pointer to it. Are you saying this is how it is in Lua too? My understanding is that Lua passes around function pointers by value. Which is what C and C++ do as well.
No, Lua passes around a value, which we call a function, but in reality is a Closure and a Chunk. See, when you write `function foo(a, b, c) print(a, b, c) end`, what you get is the variable foo holds both the chunk `print(a, b, c)` and the lexical closure that contains a, b, and c as local variables, the `_ENV` table that points to the global table, and whatever local variables exist at the scope above. To put it another way, this factory function doesn't create just one function, it creates separate values each time: function factory() local m = math.random() return function() print(m) end end So, the Chunk that is the function factory is only created once, and thats where it's safe to think about it as a pointer, but the lexical enclosure of the factory function is new each time it's called, because the returned function needs to capture the variable m (also called an upvalue) in that closure.
This is beyond concept and in the realm of nitty gritty details. Of course Lua implements these things using pointers, seeing as how it's written in ANSI C, and pointers are the principle mechanism there. However, it's still important to note that C pointers to functions aren't the same as Lua functions. Lua doesn't represent a function in it's C code as a function pointer. If you look at the bottom of [lobject.h](http://www.lua.org/source/5.2/lobject.h.html) in the Lua source code, there's actually a lot of fields in the structs that represent a lua function.
I guess I don't understand your distinction between a 1st class function and a regular function then. In both cases the instructions the function will execute are stored in one place, and a pointer to those instructions are passed around between functions by value. Maybe I'm just not understanding what you mean by "function as a value, not just a pointer to it". A pointer to a function *is* a value in C, so how is that different? &gt; Of course Lua implements these things using pointers, seeing as how it's written in ANSI C, and pointers are the principle mechanism there. This would be true for C functions, but Lua functions could totally be passed by value - it would just require copying the entire thing. 
The piece that you're missing, conceptually, is that Lua defines a "Chunk", and you can easily create one with the `do end` construct. That's useful for creating a closure around a single function without all of the functions in a module needing to share that. For instance: do local t = { 1, 2, 3, 4 } function foo() return unpack(t) end end In this particular instance, there's two chunks. The `do end` chunk, and the `foo` chunk. However, there's also a closure here, defined by the upvalue `t` and the reference too that upvalue is stored, along with the chunk, in the variable foo as a "function". So, to put it again, a lua function is a Chunk and a Closure. There is data in the closure. So it's not a function pointer, it's data. And data that can be stored and passed around is called a Value. Functions are values.
 function newObject() local o = {} o.property = 10 function o.func () o.property = 12 end return o end This is creating a new closure for every method of your class every time you create a new instance, which is kinda expensive. The advantage of this method is that you can have genuinely private data fields: function newObject() local o = {} local privateData = "Data" function o.func() return privateData end return o end Typically what you do, though, is put all of a classes methods into a class object, then set that as the metatable of an instance object. Reusing your example: local theClass = {} theClass.__index = theClass function theClass:func() self.property = 12 end function newObject() local o = {} local privateData = "Data" return setmetatable(o, theClass) end 
Do you know how to program in Javascript? Overall the problem of defining classes is very similar in Lua and there is no one way to do things that is the best. But if I had to say something, I would say that there are basically two approaches: The first way to do things is using closures like you did. The main advantage of this method is that its very simple to write and that you can have private variables in your closures. The main disadvantage is that each separate object needs separate closures for each method, and this costs more space. The other way to do things is to use metatables so all the objects share the same functions for their methods. The main advantage of doing this is that you need less memory for each object and that its easier to the fancier things like inheritance.
 local t = { ['No classes? How do you guys survive?'] = 'http://www.luafaq.org/#T1.28', ['wiki OOP'] = 'http://lua-users.org/wiki/ObjectOrientedProgramming', imps = { 'http://github.com/Yonaba/30log', 'http://code.google.com/p/corsix-th/source/browse/trunk/CorsixTH/Lua/class.lua', 'http://gist.github.com/paulmoore/1429475', 'http://www.ardentkid.com/blog/from-zero-to-oo-ardentkids-guide-to-object-oriented-lua-with-corona-sdk', ... } } 
I've always done it like this: local Camera = {} Camera.__index = Camera function Camera:new() local obj = { x = 0 , y = 0 , velX = 0 , velY = 0 } setmetatable(obj, Camera) return obj end function Camera:update(dt) local dx, dy = (dt * self.velX), (dt * self.velY) self.x = self.x + dx self.y = self.y + dy end 
You can even "improve" on it a bit: local Camera = {} Camera.__index = Camera function Camera:new() -- setmetatable returns its first argument (in your case o) return setmetatable({ x = 0, y = 0, velX = 0, velY = 0, }, self) end -- Some methods -- Allows you to create objects via Camera(...) or Camera:new(...) return setmetatable(Camera, { __call = Camera.new })
This explanation actually helps loads in understanding the other methods in doing this. Thanks!
Don't you need to set `theClass.__index = theClass`?
I really like [middleclass](https://github.com/kikito/middleclass) for dealing with classes in lua. You get a simple interface for defining classes, subclasses and more. Here's a [quick example](https://github.com/kikito/middleclass/wiki/Quick-Example) from the middleclass wiki.
[PIL 16.2 - Inheritance](http://www.lua.org/pil/16.2.html) Account = {balance = 0} function Account:new (o) o = o or {} setmetatable(o, self) self.__index = self return o end function Account:deposit (v) self.balance = self.balance + v end function Account:withdraw (v) if v &gt; self.balance then error"insufficient funds" end self.balance = self.balance - v end
My workflow benefits from : http://www.rasterbar.com/products/luabind/docs.html#defining-classes-in-lua Of course, this assumes the engine (API) you use has luabind.
There are tons of ways to do classes in Lua, and everyone has their own preference, so it's really up to you do decide what particular traits you want. For instance, your method is known as the "Closure Method" and tends to be the fastest in performance, but also the one with the largest memory footprint. My preferred version is a "Copying Metatable" version, which looks like this: -- Foo table is the metatable for all instances Foo = {} Foo.__index = Foo -- necessary to link instances to parent function Foo:new() return setmetatable({}, self) -- constructor function Foo:method() print("example function") foo_instance = Foo:new() -- how to create an instance -- Bar is a subclass of Foo and metatable for all its instances Bar = {} for k, v in pairs(Foo) do Bar[k]=v end -- inherit all members from parent class Bar.__index = Bar -- necessary step bar_instance = Bar:new() -- new was inherited from Foo bar:method() -- method was inherited from Bar In this style, you simply craft your base classes as metatables as described in Programming In Lua, which others have linked to. The derived classes are literally copies of their parent class.
Yeah, sorry, rapid copy + paste + edit with no testing.
&gt; No, Lua passes around a value Of course it passes around a value, that's always true. But when talking about passing semantics, *by value* means it *copies* the value when passing where as *by reference* means it passes a reference to the original value. local closedvariable = 0 function report() closedvariable = closedvariable + 1 print(closedvariable) end print(report) -- function: 0x003a6de0 report() -- 1 function call(x) print(x) -- function: 0x003a6de0 x() -- 2 end call(report) When we pass `report` to `call`, we're passing a reference to `report`, not a copy. You can't really get true "by value" semantics in Lua as you can in, say, C++, where assignment or function pass/return actually copies an object. Everything Lua is passed by reference (you can argue that number and string are not, but they are immutable so there's no way to tell anyway). 
&gt; I guess I don't understand your distinction between a 1st class function and a regular function then. The [wikipedia article for first class functions](http://en.wikipedia.org/wiki/First-class_function) suggests a meaningful distinction that's applicable to Lua: anonymous functions. In C, you can create new instances of structs, integers, doubles, etc. at runtime, but not functions. They aren't first class citizens to the same extent as those other data types. In Lua, functions are treated no different than any any other data type, they are truly first class citizens.
This feels a little more right to me. Thanks for the link. 
The first edition of [Programming in Lua](http://www.lua.org/pil/contents.html) is free and available online. It's the single best resource for learning the Lua language that you can get.
I've taken to copy/pasteing it into a single document for easy and off-line reading. Maby when I'm bothered, i'll see about making it into a PDF. Edit: To the OP, how've you been using Lua? What resources have you used in the past?
I'm a big fan of garry's mod so I use it there. I also play tekkit and program the turtles.
Actually, Gmod is the whole reason I'm trying to learn LUA, I'll look into program the turtles, cheers.
Yes, that briefly happened during the 1.0.4 to 1.1.0 overhaul, when the calling semantics to the roll() function were changed. But the version currently on github doesn't have that behavior, and I'm reasonably sure that no commit ever pushed to github did either (though some commits _between_ pushes may have). Current release is commit 0b9099427e. My first suggestion would be to try a `git pull` if you're not at that revision.
Thought this might be useful to anyone looking into using SLB3. I found that there was a bit of barrier to entry.
From [the wiki](http://lua-users.org/wiki/MathLibraryTutorial) math.randomseed( os.time() ) 
I just tried this and it just returns nil, what I did is: ranNumber = math.randomseed( os.time() ) print(ranNumber) Any idea what's wrong with it?
 math.randomseed(os.time()) ranNumber = math.random() print(ranNumber) Also, it's super difficult getting "truly" random. The good news is you probably don't need it. If you're doing something making a game, then math.random is more than sufficient for what you need.
 math.randomseed(os.time()) ranNumber = math.random() -- between 0 and 1 ranNumber = math.random(100) -- between 1 and 100 ranNumber = math.random(5,20) -- between 5 and 20 
I lag too hard on FtB 
Thanks for the write-up! I've been using [lunar.h](http://lua-users.org/wiki/CppBindingWithLunar) as a simple way to integrate Lua into my C++ project, but I'll definitely look into SLB3 now!
One caveat is that if it's a short lived program that could be run multiple times in one second, using os.time() will give you the same numbers within that second. To make this more clear here's an example: 9:24:17 ~ $ cat test_random.lua math.randomseed(os.time()) for _=1, 5 do print(math.random(1,1000)) end 9:24:22 ~ $ lua test_random.lua 992 510 706 407 870 9:24:22 ~ $ lua test_random.lua 992 510 706 407 870 What I do in this case to get a better random number is get the address of an anonymous table and convert that into a number added to os.time() 9:25:01 ~ $ cat test_random.lua math.randomseed(os.time() + tonumber(tostring({}):sub(8))) for _=1, 5 do print(math.random(1,1000)) end 9:25:05 ~ $ lua test_random.lua 66 509 920 502 224 9:25:05 ~ $ lua test_random.lua 428 456 794 935 133 If your program is going to run longer than 1 second though, math.randomseed(os.time()) is fine (unless you're needing to do something cryptographically secure, in which case you're not.)
Hmmm, I may have to give it a better look at some point. I've been pretty happy with OOLua, but I'd also like to give dub, of which I've heard good things, a try at some point too. 
Lunar also looks pretty nice. SLB3 supports coroutines and pulling table values as well. I don't really know enough about coroutines and Lua to write about that one, but maybe in the near future.
Dub looks pretty nice. Can't complain about automatic binding generation. After looking over OOLua I think I like the syntax of SLB3 a bit more, but the lack of documentation can be pretty frustrating. I guess I could just fork it and write documentation!
I suspect it would be possible to implement, but just isn't worth the time, especially given that it gives a line number in the middle of the function right above that. It's a mild inconvenience but no more than that.
Not to be a debbie-downer, but the beauty of JSON is that it's quickly becoming the single, universal format we've always wanted. The space for data formats was varied and awful for so many years, suffering under the rule of XML and YAML mostly. Now that we have JSON, I don't really see any reason to use anything else - it's cross-platform, easy to interpret, and relatively lightweight. Reinventing the wheel here doesn't really bring any benefits as far as I can tell.
Fair point. I mostly made it for my own project, but there seemed to be some interest from others in something like this so I figured I'd put it out there. I don't really expect it to replace JSON. 
Something to think about: reserved tokens. Their existence can complicate things for those not coming from a lua background. Maybe you should ban the `{ foo = "something" }` notation and only allow `{ ["foo"] = "something }`?
Initially I had considered doing the opposite: only allowing `{ foo = 'bar' }`notation, the idea being that the bracket notation is more verbose and and complicated and being forced to put quotes around every single key in JSON is one of the things that annoys me :P. I do see you point about e.g. trying using `and` as a key and getting an error (and this library should properly error at you if you try to use reserved words as a key). I feel like the Lua philosophy in these sorts of cases is to leave it up to the programmer to decide what how to handle it. I don't necessarily want to try to find one solution for a problem that will fit everyone. I think I'd rather have it be configurable. Perhaps I could add a `#define` that can be used to disallow non-backeted keys? I'll have to think on it for a while. 
IIRC, Lua was designed to be a data definition language. You can still see traces of this in the way you can call functions with one argument: you just lose the parentheses. I am on my phone now, but I think it was in history of Lua book. Now, the history just made a full circle - isn't this beautiful? :)
Do you mean a good editor? I use vim.
I heard ZeroBrane is good... Any thoughts?
Thanks very much 
That looks awesome, thanks 
I like Sublime Text 2 www.sublimetext.com It's highly customizable, has plugins, syntax highlighting, works on linux and windows, etc
I use gedit and emacs with lua-mode installed.
While I love Sublime Text for its beauty, I still use Eclipse for its functionality. Pretty much everything already listed here except ZeroBrane is not much more than a simple editor when it comes to Lua. However, there's so much more that can be offered even for a language like Lua. Now, Eclipse doesn't come with Lua support by default. There is a plugin called [LuaDevTools](http://www.eclipse.org/koneki/ldt/) developed by the [Koneki Project](http://www.eclipse.org/koneki/) which provides Lua support. LuaDevTools (LDT) can be downloaded as a standalone application [here](http://www.eclipse.org/koneki/ldt/#installation) or you can install the plugin into an existing Eclipse setup. My favorite features of LDT: * Auto-completion * Using basic LuaDoc comments that describe a few things about your code, LDT is able to infer types, object fields/methods, etc * Not the kind of completion that Sublime Text does where it matches any identifier in the entire file (even inside of strings), but completion that makes sense syntactically. * Code Highlighting * Particularlly differentiating between global and local variables. This makes it easy to spot a number of problems. * Debugging * LDT's remote debugger is probably its best feature. Tired of using a dozen print() statements to figure out what your code is doing? Forget about that and simply inspect variables as your code runs. The GUI debugger is truly a blessing.
Should be noted that [Squirrel](http://squirrel-lang.org), a scripting language inspired by Lua, allows table declarations to be written using JSON syntax.
[Zerobrane Studio](http://studio.zerobrane.com/) is pretty slick and works with a bunch of different Lua variants.
Not at all familiar with gmod, but... function ulx.tempgag( calling_ply, target_plys, should_ungag, minutes ) -- snip end local gag = ulx.command( CATEGORY_NAME, "ulx tempgag", ulx.tempgag, "!tempgag" ) tempgag:addParam{ type=ULib.cmds.PlayersArg } Where does the variable `tempgag` come from? Did you mean to type `local tempgag` perhaps? 
Firstly, put this inside your chat.lua. http://pastebin.com/Qs63Ehh4 That would sort the command its self, but I can't find where the actual gag functionality is (somewhere in the virulaent mess that is Ulib perhaps?)
[The name is confusing.](http://mason-larobina.github.com/luakit/)
Binary build now available as a downloadable package [from mediafire](http://www.mediafire.com/?d37570wbt1b1ben). 
LuaPAK, LuaFS?