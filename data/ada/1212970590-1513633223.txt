Carpool with ya?
I'll meet you at Fulton Ferry Landing by the Brooklyn Bridge, we'll take the [Telectrascope](http://www.cnn.com/2008/WORLD/europe/05/22/scope.project/) service tunnel over to London, then head through the Chunnel and down to Venice. Thank God I drive a hybrid! 
Apparently this is REEEAAALLLLY popular, since response on the AdaCore website is often quite slow...
Available for the following platforms: * x86-linux * x86_64-linux * x86-windows * dotnet-windows The .Net version is new, it was not available in GNAT GPL 2007. (Is estrange, I though GNAT GPL 2007 was not available for AMD64... ?) In the [GNAT GAP 2008 release](http://www.adacore.com/home/academia/gap), it is also available for: * sparc-solaris * leon-elf-linux The last one is for embedded targets (bare-board target, not operating system at all, just a (Ravenscar)[http://en.wikipedia.org/wiki/Ravenscar_profile] run-time system), for the radiation hardened (LEON)[http://en.wikipedia.org/wiki/LEON] processor (by the European Space Agency). Space technology, this is pretty cool!
If you find your submissions from certain sites getting banned for some reason (I have no idea why that's happening), please drop me an email and I'll try to rectify it. I just happened to notice this happening with some Adaredditors, and have taken care of what I've found so far.
The [full program](http://www.math.unipd.it/ae2008/final_program.pdf) describes not only the keynotes and the papers that will be presented, but also the tutorials and vendor sessions (and social events). Note there are parallel sessions, and some ARG meetings. And the general assembly for the members of the Ada-Europe association. The [Ada-Europe 2008 proceedings](http://www.springerlink.com/content/p12h89140481/) are already available in the Springer website, so you can read the papers at any time.
Interesting 2001 article from CrossTalk, a military journal about software engineering. It covers different topics about Ada usage, from industry to academia.
Correct me if I misunderstood...
&gt; From: Jamie Ayre &lt;ayre@adacore.com&gt; &gt; &gt; To: announce@adacore.com &gt; &gt; Date: Wed, 11 Jun 2008 18:15:39 +0200 &gt; &gt; Subject: [Libre] GNAT GPL 2008 is now available Dear GNAT GPL user, We are pleased to announce the release of GNAT GPL 2008, the Ada Toolset for Academic users and FLOSS developers. It introduces hundreds of enhancements including: * Availability on the Windows .NET platform * Upgrade of the debugging engine * Improvement in robustness and efficiency for Ada 2005 features * Many new warnings &amp; restrictions to help programmers detect errors earlier * Companion tools such as gprof, gcov, gnatcheck, gnatpp and gnatmetric are being enhanced to support a wider variety of needs, coding styles, and coding standards * Support for Pre/Post conditions GNAT GPL 2008 comes with version 4.2.1 of the GNAT Programming Studio IDE and GNATbench 2.1, the GNAT plug-in for Eclipse. It is available on the GNU Linux (32 and 64 bit), .NET, and Windows platforms. GNAT GPL 2008 can be downloaded from the "Download GNAT GPL Edition" section on https://libre.adacore.com. For regular updates on the GNAT technology, please visit the Developer's Center. It includes a developer's log giving updates on the GNAT technology, technical papers, code samples, and documentation. For more info, please visit: [www.adacore.com/category/developers-center/development-log](http://www.adacore.com/category/developers-center/development-log) 
The conference [awards](http://www.math.unipd.it/ae2008/aw.html) this year were: * **Best paper**: "[A New Approach to Memory Partitioning in On-Board Spacecraft Software](http://www.springerlink.com/content/17367785935g35k5/)" * **Best presentation**: [John McCormick](http://www.cs.uni.edu/~mccormic/) for *Ada and Software Engineering Education: One Professor's Experiences* and [Ben Brosgol](http://www.rtsj.org/BenBio.html) for *A Comparison of the Object-Oriented Features of Ada 2005 and Java* (same number of votes) Ben Brosgol has won other awards, like the [Ada-Europe 2006 best paper award](http://www.hurray.isep.ipp.pt/activities/ae2006//awards.shtml), or the [Outstanding Ada Community Contribution Award](http://www.adacore.com/2006/11/22/adacores-ben-brosgol-receives-sigadas-outstanding-ada-community-contribution-award/).
Of course I meant "lying around". English could use a good automated grammar checker.
I installed GNAT GPL 2008 on my upgraded Ubuntu Linux system and got this message when trying to start gps: &gt;gps_exe: ../../src/xcb_lock.c:77: _XGetXCBBuffer: Assertion `((int) ((xcb_req) - (dpy-&gt;request)) &gt;= 0)' failed. &gt;Execution terminated by unhandled exception &gt; &gt;Exception name: PROGRAM_ERROR &gt; &gt;Message: unhandled signal &gt; &gt;Call stack traceback locations: &gt; &gt;0x905c0c9 I submitted this to AdaCore this morning as an unsupported user and was pleasantly surprised to get a response tonight, and which works (Bonus! :-) &gt;Ubuntu is not a supported/tested platform and requires extra manual work to work with GPS. &gt;You need to remove all libraries from &lt;install-gps&gt;/lib/gps in order to run GPS on ubuntu.
Well, this problem is quite simple to resolve ... You could also comment the following line in /opt/gnat/bin/gps (if you install in /opt/gnat) and it will work #LD\_LIBRARY\_PATH=$root/lib/gps:$LD\_LIBRARY\_PATH
[Related...](http://www.reddit.com/r/programming/comments/75gu5/us_national_security_agency_nsa_releases_tokeneer/)
Regarding Queue's reader-hostile interface, I wrote to ACM's publisher, James Maurer, a couple months ago to complain. He actually wrote back right away and concurred that the Queue staff doesn't like it either, and that a new one was in the works. Haven't see it yet, though. If others would like to pass on their opinions to encourage the relaunch (although if you think that the current layout is the greatest thing since sliced bits I'd probably prefer you didn't :-), you can rant at: feedback@acmqueue.com, or contact Maurer directly at jmaurer@acmqueue.com (that address isn't confidential, it's published right in the magazine). 
Be sure to read the Discussion at the end of this Gem as well; there's a bit there about changing the format of the persisted data.
It's a fair article by someone who was taking Ada out for a spin all by his lonesome. There are a few misunderstandings, like stating that the programmer is responsible for freeing the memory associated with using Unbounded_Strings, and there being no way to attach additional information to exceptions (it's primitive--being just a string--but it is there). Other issues he cited, like the type conversion and the reason for having to declare all your types, arise from not having grokked [Ada's language design model](http://blog.kickin-the-darkness.com/2007/08/fundamental-theory-of-ada.html), but that would have been a bit much to expect of one just trying out Ada for the first time. I give him credit for a fair-minded recounting of his experience.
Let us know if you have any issues with the Ada sub-reddit, like one of your posts getting inexplicably banned. (Now I don't have to worry about what happens here if I get hit by a truck. :-) 
Hi there! We are here to help you when any problem related with this sub-reddit, so don't hesitate to contact us.
Hello.
&gt; ObjectAda Real-Time targeting Power Architectures running Wind Rivers’ VxWorks 6.6 is immediately available starting at $15,000 in the U.S. with quantity discounts available. Holy fscking shit... ...anyone have a torrent yet?
As a young computer programmer in Minnesota I drove by Cray's office every day on my way to work at Sperry. At the time I really wanted to work someday for the maker of the "world's fastest supercomputers". I had applied there in college but didn't get an offer, and so was building up experience until I felt that the time would be right to try again. At the time, pre-1988, I did wish there had been Ada for the Cray because that's what I was using at Sperry, and I wasn't too keen on Fortran and CAL. By the time Ada did make it on to the Cray I had already left the state to take advantage of other opportunities. It's all worked out pretty good, though :-)
DET was the "Design Evaluation Simulator", which was a simulation of the [AN/UYK-43](http://en.wikipedia.org/wiki/AN/UYK-43) computer, focusing on the instruction set architecture. I was responsible for the cache memory simulation and implementing the table-based implementation of the transcendental functions. Good times... :-) 
Actually, the first Ada-related thing I worked on, fresh out of college in 1983, was a [VHDL](http://en.wikipedia.org/wiki/VHDL) compiler. Although it was being written in Pascal, VHDL itself is based on Ada, so we were making heavy use of the Ada LRM as part of implementing semantic analysis. Then it was on to the AN/UYK-43 Design Evaluation Tool, which was all Ada. We started with Telesoft Ada, which blew chunks, and then our design lead got hold of a beta version of the VAX Ada compiler, which was a thing of beauty, even in beta. 
The [Player/Stage](http://playerstage.sourceforge.net/) platform for this binding.
i think i'm the only one that enjoyed thumbing through this ...
Oh, not at all! Even though it's a bit dated, being for GNAT 3.15p, it's still an excellent and interesting look at what's under the hood. 
I'm new to Ada, so the following isn't a troll but a question. Why would I use the adacore GPL edition instead of gcc?
AdaCore is the primary driver of GNAT development, and they then periodically release updates to the FSF. So with their GNAT GPL version you're pretty much getting the leading edge of GNAT Ada technology at the time of the release. Though with the full constraints...or freedoms :-) of the GPL. (This is no way diminishes the great efforts of those who maintain and package the FSF versions of GNAT, such as [Ludovic Brenta](http://people.debian.org/~lbrenta/debian-ada-policy.html), who voluntarily perform a great service for the Ada community.)
GNAT GPL 2009 contains the following: - gnat-gpl-2009-43- ... (platform-specific) This package contains the GPL Edition of GNAT, the Ada 2005 tool chain maintained by AdaCore, and includes GPS, a fully integrated IDE. It also includes full html documentation for both tools. Supported target platforms include: - Linux - Macintosh (Darwin) - Windows (native) - JVM (Windows) - .Net (Windows) - gnatbench-2.3.0-bin-eclipse.zip Binary distribution of GNATbench for Eclipse, a plug-in for standard Eclipse that inserts the GNAT GPL Ada technology into the Eclipse framework. - AJIS Support for Ada / Java interfacing through JNI, including: - An Ada binding of the JNI API - A stub generator for the native declarations of a Java class (equivalent of javah for C) - An automatic and type-safe Ada to Java binding generator - ASIS A full implementation of the ASIS standard for Ada 95 including the Data Decomposition Annex. Also includes extensions for Ada 2005. - AUnit Unit testing framework. - AWS Ada Web Services (AWS) provide a complete framework to develop Ada Web based applications. - Florist An Ada binding to Posix. - GNATcoll The GNAT Components Collection is a suite of reusable software components and utilities. - GtkAda A portable Ada graphical toolkit based on Gtk+, that provides an Object-Oriented hierarchy of more than 100 widgets and a GUI builder (GtkGlade). - PolyORB This directory contains PolyORB, a CORBA compliant instantiation of a generic middleware. - XMLAda A toolkit to parse and manipulate XML streams in Ada. - Sources Directory contains the sources used for building all the components of the GNAT 2009 environment. 
Just in case you are interested, I have created a new subreddit for all things related to critical software development: design, coding, verification, tools, best practices, norms, etc.
Does Ada still have an advantage in this field? What I'm seeing is that the use of tools like Simulink or SCADE is increasing and aerospace engineers prefer them over a traditional programming language. In exchange for a much reduced scope of application their constructs are much easier to check and the C code they generate is (plausibly) bug free. For the things you can not do easily with these tools there are now code verification tools that can check C code, some of them using techniques like model checking. It seems to me that C will be more and more used in this area as a kind of portable assembler, and the new tools that generate it from a higher level (executable) specification will make the advantages of more advanced languages like Ada irrelevant.
No. Stop polluting the reddit with this crap.
Italian to English [translation](http://translate.google.com/translate?js=y&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;u=http%3A%2F%2Flinguaggioada.blogspot.com%2F&amp;sl=it&amp;tl=en&amp;history_state0=) (via Google Translate).
No one mentions the [MIL-STD-1750](http://en.wikipedia.org/wiki/MIL-STD-1750A)? (although it is 16bits)
Party at Brukardt's place, Tucker's bringin' a couple cases of Sam Adams! 
And even worse, they keep saying ADA instead of Ada.
Actually, referring to Ada as ADA by the uninformed is not all that uncommon, but calling it an operating system is just plain ignorant. 
This was actually written by a former Secretary of the Air Force??? It reads like a college freshman's term paper.
I find the OS "mistake" funny (and sad, of course). But ADA irritates me. What can I do - I'm superficial.
Well, the Ada run-time *is* an operating system when it runs directly on the hardware.
Somehow I don't think Wynn was being *that* technically astute... :-)
Well it's good to know that "Goolge.com" redirects to Google.com :-)
Why would you need in out parameters in functions? Just use a procedure.
The "!problem" section of the linked-to AI lists several justifications. This is, to me, a sorta semi-religious issue, and I'm more or less agnostic on it. But since Ada is not a genuine "functional programming" language, it's not hard to justify to me a change like this that will remove a programming annoyance, increase efficiency, and eliminate the need to *work around* the "no out parameters" rule when one has a legitimate reason to do so. (I've certainly had to do it many times over the years. Access parameters were a step forward, and now this resolves the issue for good.)
So it's just a poster? A single PDF? No explanation or anything. Meh.
[Better?](http://www.reddit.com/r/ada/comments/acs9w)
Much. Thanks.
This is supposedly the emoticon for "tongue-in-cheek": :-? Doesn't really do it for me though... ;-)
Forget that place, at least move up to Ada95. It's down the road a few years from Ada, but has a few nice features that make the move worthwhile. Ignore anyone who suggests moving to Ada2005, it's a stuck-up neighborhood that somehow also manages to be somewhat run-down. (All the cool kids have moved to Python.)
I don't know, I have mixed feeling about these new forms of expressions. Both this one and [conditional expressions](http://www.reddit.com/r/ada/comments/8amb7/conditional_expressions_implemented_if_gnatx_then/) just look a lot to me like somebody's idea of a "cool feature". I know C has the ternary expression ("que?this:that"), which I've seen criticized and sometimes barred by coding standards, so what was the compelling rationale for adding it to Ada, and then go beyond it to full case expressions? Now, I'll likely use these in my own code, because I'm an Ada geek, but I'd be hesitant about using them in production code that others would have to maintain. I see some value in them, in that they can reduce SLOC count, but there's a lot of non-contributary verbiage there for simply assigning a value to variable. Writing and invoking a well-named function would likely improve the clarity of the operation, at the expense of writing a few lines of utility function. (And I dread eventually seeing a single compound assignment expression consisting of a bunch of conditional and case expressions. If/when I run across that I will hunt down and punch the developer in the mouth.)
Ada's not mentioned in that article, but [here's](http://www.spacedaily.com/news/laser-04f.html) the reference. &gt;To accomplish the tasks at the required speeds, the BC/FC system executes over 600,000 lines of "C" and Ada high-order software using the computer processing power of more than 80 Power Pcs.
I read through a bunch of the documentation, and it's quite well written. Plus, the examples are very clear and informative (though I only looked at the Ada ones). I will be playing around with this.
I've been informed that a Python binding is next on the list. At that point my programming life will be complete :-)
I upvoted this for what it is, but now that I can actually download it I see that it's nothing but source code. A README or something to indicate what is needed to put this to work, rather than having to *totally* figure it out on my own would've been helpful.
Bound-T supports also 8-bit AVRs, so it might be interesting to use it for your AVR/Arduino code.
I wrote Ahven because I wanted to do some changes to AUnit 1.x but AUnit had gone major rewrite in its 2.0 version and it made more sense to write my own unit testing library from scratch than add something to GPL'd old unmaintained AUnit version. Extra trivia: ahven.stronglytyped.org is run by AWS (Ada Web Server).
Perhaps this version will compile my ada code on windows vista. I can't figure out why it 2009 GNAT won't do it.
If you could supply a code sample that demonstrates the problem, some of the readers here might be able to help, or ask at [StackOverflow](http://stackoverflow.com/questions/tagged/ada) or [comp.lang.ada](http://groups.google.com/group/comp.lang.ada/topics). Both those sites have an active and knowledgeable Ada presence.
 with Ada.Text_IO; procedure Hello is use Ada.Text_IO; begin Put_Line("Hello, world!"); New_Line; Put_Line("I am an Ada program with package use."); end Hello; And this is the error I get: [2010-06-12 17:07:23] Could not determine the project for file: C:\Users\sebastion\Code\Ada\hello.adb [2010-06-12 17:07:23] Invalid context, cannot build Every time I try to make a new project, it freezes.
One guy I know suggested: Perhaps you may try to delete the .gps folder (it will be rebuilt). Or you can use the following stub project: project Stub is for Main use ("hello.adb"); end Stub; 
Well, I was able to get it compiled, but I had to do it from the commandline. I suppose it works. Thank you for all your help, marc-kd.
What kind of snake oil is this? Some signs that this is bullshit: &gt;One-way functions are almost a myth because of the scarcity of these. Our number system for instance does not have a known one-way function within its methodology and to date, intensive cryptography has therefore become the norm for securing communications when using numbers as the raw data in encryption transformations in which plain text are turned into more difficult to read cipher-text. Numbers as input? What else? Intensive cryptography? What? &gt; Vector cryptography is being promoted as new cryptography. A classical sign from Schneier's "dog house" column, a "new" form of cryptography. 
Is there a comparative between SPARK and the B-method or Event-B? (in the style of this one between [SPARK and Frama-c](http://lists.gforge.inria.fr/pipermail/frama-c-discuss/2009-November/001532.html))
Very unlikely. The language does not offer compare-and-swap, and most programmers do not use garbage collection, which makes implementing lock-free algorithms very difficult.
Link to the [implementation](http://www.skein-hash.info/SPARKSkein-release).
Don't know who here may feel fit to answer this (I'm not), but you might also try posting at [comp.lang.ada](http://groups.google.com/group/comp.lang.ada/topics) or [StackOverflow](http://stackoverflow.com/) (and hang some appropriate tags on it). 
Ada was designed with concurrency in mind, but not really as an enabler for parallel computation. Before Ada 95, it was focused on on the rendezvous concept (two-way synchronous message passing). Ada 95 is roughly equivalent to early Java with the addition of a basic memory model (there is nothing comparable to `java.util.concurrent`). However, it is quite difficult to allocate and deallocate tasks dynamically.
&gt;However, it is quite difficult to allocate and deallocate tasks dynamically. Pardon? How so? Actual code: -- Task monitoring ingestion from a client task type Ingester (Client_Connection : Source.Stream_Handle) is entry Start (Start_Ingesting : Boolean; Ds_Config : Tapped_Data_Structures.Data_Structure_Configurations; Tap_Settings : Tapped_Item_Management.Tapped_Settings_Handle); entry Set_Ingestion(On : Boolean); end Ingester; type Ingester_Handle is access Ingester; Ingestion_Manager : Ingester_Handle; Allocating: Ingestion_Manager := new Ingester(Client); Deallocating: procedure Free is new Ada.Unchecked_Deallocation (Ingester, Ingester_Handle); Free(Ingestion_Manager);
The call to `Free` might not actually reclaim storage in this case, see 13.11.2(15). The task which is about to deallocated needs to signal the task which is performing the deallocation. Apparently, the only way to do this is the `abort` statement, which you might not want to use due to its distributed performance overhead.
[13.11.2(15)](http://www.adaic.com/standards/05rm/html/RM-13-11-2.html) refers to the bounded error case of attempting to free a discriminated, unterminated task and simply says, "the storage for the discriminants (and for any enclosing object if it is designated by an access discriminant of the task) is not reclaimed prior to task termination". Nothing in there about not reclaiming task storage in the course of proper allocation, execution, termination, and deallocation of tasking. I don't understand what you mean by: &gt;The task which is about to deallocated needs to signal the task which is performing the deallocation The processing of the task that needs to be deallocated should be implemented in such a way that it will complete processing and enter a terminated state, or accept a rendezvous with a "shutdown" entry so that it will complete and enter a terminated state, or yes, be aborted, though that's the exceptional way of terminating a task. I've rarely seen the "abort approach" used, almost every instance of tasking I've seen in, or developed for, production Ada systems uses one of the first two approaches. Once the task is terminated, it's a simple manner of the application's "task manager" invoking an instantiation of Unchecked_Deallocation on the access pointer to the task, as illustrated in my example above. And just to reiterate, there's nothing "quite difficult" about dynamically allocating a task.
There's the 'Terminated attribute that will tell you if a task can be already freed without any leaked memory.
I really can't await writing post-conditions with side effects. Nice tool for code obfuscation.
A.18 covers those containers in the standard. http://www.adaic.org/standards/05rm/html/RM-TOC.html This paper describes the predefined container library in Ada 2005 http://www.adacore.com/2006/02/02/ada-2005-rationale-containers-pt-8-of-8/
Newbie questions are perfectly fine here :-) The intent of the design of Ada's container library is to provide the core building blocks for creating your own containers, like stacks and queues (which, for example, you would use the Vector container to do--and there's an example of doing that in the [Container Rationale paper](http://www.adacore.com/wp-content/uploads/2006/02/Ada05_rational_07.pdf)). If you want to work with an already built, comprehensive set of commonly used containers I'd recommend the [Booch components](http://booch95.sourceforge.net).
The Feeds links do not point to the correct location.
The feed links should be fixed now.
Why it is so hard to prove total correctness for cryptographic algorithms? The symmetric primitives do not even contain data-dependent loops!
Cool. Call me a grumbler, I have two comments: 1. Programmers will like this and drop case coverage of CASE in favor of large anonymous membership tests in IFs. They rid them of having to say what they are doing with the help of a nice named, inlined function. 2. OTOH, Microsoft demonstrates how one creates attraction by increasing the amount of sweetening ingredients to XYZ#. So membership tests can generate quite some business. And opportunities for code review.
It would be better if you distilled this down to a minimum set of code and actually posted both files to see. At any rate, I was able to replicate this and didn't have any problems getting it to work, but I had to make a few guesses at exactly what you are doing. http://pastebin.com/iz9Snys7 My guess is the error you are seeing is due to the package (something) being part of another package (current?), and therefore you aren't "using" 'something'. You'd need to specify it as Current.Something.Vector (or, if you are using Current, as Something.Vector). In Ada, "use" statements are not viral... in otherwords using a package (current?) that uses another package (something) does not mean your current code (new_file) is using that package (something).
Here's [Part 1](http://www.adacore.com/2010/06/22/gem-89-code-archetypes-for-real-time-programming-part-1).
(H/T to [Ada Denmark](http://ada-dk.org/index.php?page=home), you guys are da bomb!) And a big thanks to Ada-Europe and the presentation authors for putting all this material online.
FYI: niestu.com had a hard drive failure recently, so it might be down for a while.
Wow, I didn't know you could use Ada with mindstorms. I may have to pony up for a set now...
http://www.ada-france.org
"The Ada Way". Too bad, every contest involving Ada is reserved to students. What about the hobbyists out there? :(
Develop an Ada product. Commercialize it. Win! Develop an Ada product. Release it as open source. Monitor who adopts it. Win! Develop an Ada product. Package it as an rpm, deb, or other format and [get it accepted](http://people.debian.org/~lbrenta/debian-ada-policy.html#Help-wanted) as part of a standard Linux distribution. Win!
What compiler? Gnat? What's the directory organization of your code? Have you set up the proper include paths?
I'd keep using GNAT, either with Cygwin, MinGW, or AdaCore. What external packages are you using?
The directory organization of my code is all the files in the same directory. Compiler: mgnat is the one closest to working, Adagide just flashes for a second on the screen then closes. I don't know what that's about, but other people have had that problem (unfortunately, the forums that I found didn't do anything to help that guy). I know nothing about include paths... my ada program compiled perfectly fine without include paths on Linux. Basically, my compile script for Linux looked like this: gcc -c cards.adb gcc -c players.adb gcc -c tbsp.adb I know that's not exactly a makefile, but that did what it was supposed to do. When I moved it over to Windows and did "mgnat cards.adb" for the first file it compiled, but when I tried the "mgnat players.adb" for the second file it told me that I needed to include cards.adb. Neither compiler is well-documented and I can't find any FAQs for them. PS - I apologize for sounding uninformed about Ada, I am really a novice and I just want to make games. I've looked into these problems before posting in this forum, but found very little resources.
Install GNAT before installing AdaGIDE. I'd get the GNAT GPL from here http://libre.adacore.com/libre/ and then get AdaGIDE from here http://sourceforge.net/projects/adagide/. Or is it a problem with your code? is there a "with cards;" included in your players code?
Like handsolo said, just get the [GNAT GPL 2010 distribution](http://libre.adacore.com/libre/tools/gnat-gpl-edition) for Windows, install it, then run 'GPS' (it will be in your Programs/GNAT menu) as your editor. (GPS is the GNAT Programming Studio IDE.) Go though the project creation wizard and you should be good to go. BTW, mgnat is the Ada for .Net compiler.
I would try to get a cross-compiler running under Linux. It might be a bit more work initially, but at least I can use a unified development environment, with matching compiler versions.
If the OP is running with GNAT, particularly GNAT GPL 2010, the distribution is essentially the same for Linux and Windows, simply use the accompanying GPS as the IDE. And depending on how much the app depends on platform-specific resources, services, and other aspects (such as file naming), code may or may not be easily portable between the two. The more the application can stick with pure Ada, with libraries and such accessed through common Ada bindings, like XMLAda or GTKAda, the more platform-independent it will be.
This worked! So, now I have an .exe! Thank you! Now, I just need to figure out why my program doesn't run correctly :-/
[Programming and Problem Solving Using Ada 95](http://books.google.com/books?id=X_VlpfGoQRgC&amp;printsec=frontcover&amp;dq=programming+and+problem+solving+with+ada+95&amp;source=bl&amp;ots=H5qqd8NcVu&amp;sig=c5WiReXevXCKfLxhZNyLYqhuUjc&amp;hl=en&amp;ei=yInTTOTiC4XHnAeN2ryOBg&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=1&amp;sqi=2&amp;ved=0CBcQ6AEwAA#v=onepage&amp;q&amp;f=false)
http://www.adahome.com/Tutorials/Lovelace/lovelace.htm http://www.computer-books.us/ada95_5.php http://www.adacore.com/home/ada_answers/ada_2005/safe_secure/ You can also find "Ada for software engineers" and "Concurrent and Real-Time Programming in Ada" on torrents.
[Ada 95 for C and C ++ Programmers](http://www.amazon.com/Ada-Programmers-International-Computer-Science/dp/0201403633). While it is out of print, it can still be gotten from various sources. It's a bit dated, being written for Ada 95 (obviously), but it's a good bridge for those with C/C++ familiarity, and from there it's a rather easy transition to Ada 2005. Another good source is [Ada Distilled](http://www.adaic.org/docs/distilled/adadistilled.pdf), "An Introduction to Ada Programming for Experienced Computer Programmers". Given the Python experience, there's a couple articles on interfacing the two, which I hope to get around to messing around with sometime. [Ada Python Binding](http://www.inspirel.com/articles/Ada_Python_Binding.html) and [Ada Python Interfacing](http://www.adacore.com/home/products/gnatpro/multi-language/ada-python), the latter being a rather extensive guide--that does require a firm foundation in Ada, so it might be something to look forward to rather than trying to dive into that right away. And of course, the best way to learn a language is to look at code, lots and lots of code. This sub-reddit has lots of links, a number of [Ada projects](http://sourceforge.net/softwaremap/?&amp;fq[]=trove%3A163) are hosted on SourceForge, and [AdaPower](http://adapower.com/index.php?Command=classes&amp;Title=Source+Treasury) has links to code. Just ask if you're looking for anything in particular. Oh, and I'd encourage you (and others) to also watch the ['ada' tag on StackOverflow](http://stackoverflow.com/questions/tagged/ada) and keep on eye on the [comp.lang.ada](http://groups.google.com/group/comp.lang.ada/topics) newsgroup. There ain't no lack of Ada expertise around, and most people are eager to help out. 
Be sure to allocate some time to reading through the first sections of the GNAT User's Guide. If you have GNAT GPL, you have the guide, too. It is considered well written, I think it is, and it covers some Ada, too, besides how to use GNAT. The GNAT Reference Manual explains the details.
Is support for ANSI escape sequences activated on your platform? See: http://en.wikipedia.org/wiki/ANSI_escape_code#Windows_and_DOS
I forgot about the whole ANSI thing. I'm an idiot. I found a package called nt_console. Works brilliantly for what I need. Thank you.
Went ahead and subscribed to comp.lang.ada and checked out some of your links, coming from a "purely open source" world of Python, it's quite interesting to me how much "Pro" Ada software exists through AdaCore. Appreciate the links, I have much reading to do :-!
-- Hello Thomas! (Inside joke. Never mind :-)
-- Hello Marc, That was some funny stuff, especially how my brain momentarily froze, desperately trying to figure out what was happening. :D
Oh, this is very good! I've been waiting for that.
Great effort!
This code is supposed to implement the Tiny Encryption Algorithm (TEA), but using the C code for the algorithm with the same test data gives different answers (see the end of the paste). EDIT: Solved, thanks to #ada on freenode. Needed more parenthesis. xor is lower in precedence than +. 
Previous articles: [Part 1](http://www.adacore.com/2010/06/22/gem-89-code-archetypes-for-real-time-programming-part-1), [Part 2](http://www.adacore.com/2010/10/11/gem-92-code-archetypes-for-real-time-programming-part-2), [Part 3](http://www.adacore.com/2010/11/08/gem-94-code-archetypes-for-real-time-programming-part-3).
Well, don't keep us in suspense. What do you love about the book?
Unlike some of the Ada books I've checked out that barrage you with information or present you with stupid examples ("in this example we read in a list of integers and sum them"), this book has a *ton* of realistic examples that are used as a medium for explaining the concept rather than something that's used at the end of a section "see, this is how X is used, moving on." So far it's eased through some concepts around scheduling and concurrency with reading sensors and relaying information, and it continues to build on the complexities of the program (presumably leading to a real-time version)
Does the third edition finally cover work stealing and fork-join approaches?
I don't have the book with me at the office, I'll check for you when I get home :)
Just curious, but what's the use case for those? Also, happy reddit birthday!
I've got the book in front of me now, while work-stealing and fork-join isn't specifically named. There's a whole chapter (that I haven't come to yet) titled "Avoidance synchronization and the requeue facility" as well as two chapters covering scheduling (fixed, dynamic, mixed, round-robin, etc)
These techniques have been used somewhat successfully to achieve parallelism when it is not naturally occurring. This is (yet another) very difficult problem, quite different from reacting to several external events concurrently. When people talk about multicores, it's mainly about this challenge.
Isn't avoidance synchronization is something totally different?
Considering fork-join, I'm not sure I know its contemporary meaning. However, if fork-join is about automatically distributing work across tasks such that their number depends on data size and each job's progress, then it can be done with quite the usual means. * Either use more tasks than there are processors. Scheduling is usually quite good. (OK, that's lame.) * Or else, something along the following should do task type Worker(Data : access Stuff) is entry Run (A, B: Index); end Worker; type Collegue is access Worker; procedure Split_Work (Data : access Stuff; A, B: Index) is W1, W2: constant Collegue := new Worker(Data); begin W1.Run (A, B/2); W2.Run (B/2 + 1, B); end Split_Work; task body Worker is A, B: Index; begin accept Run (A, B: Index) do Worker.A := A; Worker.B := B; end; if Can_Do_It_Myself (B - A) Then for K in A .. B loop null; end loop; else Split_Work (Data, A, B); end if; end Worker; 
The slides conveniently forget that C++ allows template specialization where the other languages don't. You can do things in C++ that you can't in Ada, Java or C# (such as compute a factorial at compile time).
I did notice that, though I don't think it was "conveniently" omitted. Ben Brosgol has an excellent reputation amongst the Ada and Java real-time communities--I'm not sure why that aspect of C++ templates wasn't mentioned.
`Split_Work` lacks code to combine the results. It is desirable to avoid most of the context switches. You need serious magic in `Can_Do_it_Myself` to throttle creation of new tasks at a certain point to avoid overscheduling.
Yes, though combining needs little more than another rendezvous (join). The subject is, AFAIK, a subject of much reasearch. In this light, and out of curiosity, what kind of magic could be generally applicable? Any pointers? Regarding the context switches, I have seen excellent results when the number of POSIX thread based tasks is 8x the number of cores. Likewise, if tasks are tied to cores programmatically, this helps too. It thus seems there are reasonably good means to produces effective scheduling?
downloads are password protected?
I'm already there!
I saw that, that's why I posted it here. You can never go wrong with the Thomas Locke stamp of approval! :-) :-) 
I'm ever so slowly learning to sail in these "social" waters. It's not my strongest side! Heck, I haven't even figured out how to post something to this Ada reddit (sub?) track.. LOL Feel free to educate me.
Easy as Ada :-) Over on the right side of the page you'll see the button that says "Submit a link". That will take you to a page where you can enter a title and URL. If you click it while you're in the Ada sub-reddit, the "reddit" box on the page (which specifiies the sub-reddit to which you want your submission posted) will be preloaded with "ada". If you're elsewhere on reddit, just enter "ada" in that box. Then click Submit. Alternatively you can scroll down to the bottom of this page and click on "bookmarklets" under "Reddit Tools". That gives you some buttons you can drag onto your browser--I just use the "Submit" button. Then, when you're on a site you want to submit to Reddit, just click the button, which takes you to the Reddit submission page preloaded with the URL, fill in the title (it will create one automatically, but you're usually better off putting in your own), select the "reddit" into which to post (i.e. ada), and click Submit. Done!
Oh god.. How simple. This is literally one of those "can't see the forest for the trees" things. Thanks for the kind assistance marc-kd.
Yeah, go figure. I'm killing the submission.
Just as an FYI... [GNATbench](http://libre.adacore.com/libre/tools/gnatbench) is an Eclipse plug-in for Ada. EDIT: Added link.
Thank God! It's been what...ten years? Much better!
The RSS feed referenced in the source contains only one article... from 2007.
I sent them a question about this.
Before drawing any conclusion from this curve, look at: http://ngrams.googlelabs.com/graph?content=programming&amp;year_start=1970&amp;year_end=2008&amp;corpus=0&amp;smoothing=3
Huh, interesting! Be interesting to see "Ada programming" baselined against "programming" and see how the two correlate. Or any other language for that matter. I tried ["Ada programming" vs "programming"](http://ngrams.googlelabs.com/graph?content=Ada+programming%2C+programming&amp;year_start=1970&amp;year_end=2008&amp;corpus=0&amp;smoothing=3), but the Ada line is flat when displayed using the plain "programming" scale :-)
I've been thinking of starting my own toolkit of routines and reading in a config file was high on my list. Thanks for this; I can crib bits! Unfortunately, there are a few problems with your solution from my POV : 1) The Defaults_&lt;X&gt; arrays are declared outside the Config_File_Parser package. So anyone can read from or write to Configuration.Defaults_One. Easily fixed by adding a private type. 2) Declaring the package loads the configuration file. And there's also a Load_File op! I'd lose the package initialisation. 3) Adding a config parameter =&gt; re-compiling the program. I'm looking to use some kind of map of strings. 4) Get looks like it should be a generic function. The other forms can be derived from it.
Another all-Ada option you've got if you want to use XML based configuration files is available via the [XPath_In_Ada](http://mckae.com/xia.html) (XIA) utility for reading the files, and [XML_EZ_Out](http://mckae.com/xmlEz.html), which is now also available as part of the Debian/Ubuntu Linux distributions, for writing them. Not full DOM, but much easier for small files. 
Hey zmower, All good points, but I do have my reasons for solving it like I did. 1) Completely ok with me. It will be perfectly clear in the code if interaction with the Defaults_One array is taking place. But I do see your point. 2) Yes, when the package is declared, the Config_File is loaded. I left the Load_File procedure visible so other configuration files can be loaded as need be. 3) This ensures that it is impossible to call unknown configuration keys in the program. I wanted it like that. And if you suddenly need a new configuration key, chances are you're going to use it somewhere in your program, so recompiling is going to happen anyway. 4) What would we gain from making Get a generic function? Would it simplify the code? I rather feel that simply overloading Get is easy to understand and very readable. If you create a package with similar functionality as this one, please feel free to post it on the wiki as an alternative solution. The more options available, the better! Thanks for your comment. :o)
A lot of the things you're looking for are not really covered in books since they're not standard but rather by some of AdaCore's libraries. Sockets for example came up in a thread I started on `comp.lang.ada` as something that probably *should* be standard, but aren't
I've got the Ada 2005 John Barnes book, and it's pretty good. But it does not deal with non-standard packages, and since there's no standard socket package in Ada, it's not dealt with. The same goes for GUI, XML and networking in general. What it does do, is present nearly every standard Ada 2005 package in a concise and accurate manner. So yes, it's a good reference book on standard Ada 2005 features. I don't think there are any Ada books that deal with non-standard packages, so if you want XML support in your program, you grab something like XML/Ada (libre.adacore.com) and read the manual on how to use that specific set of packages. The same goes for sockets, GUI programming and most anything else that's not part of standard Ada 2005.
As noted, Ada books are pretty much going to stick to Ada. For help on the other subjects, there's no lack of experienced practitioners willing to help out amongst those here, on [StackOverflow](http://stackoverflow.com/questions/tagged/ada), and on [comp.lang.ada](https://groups.google.com/group/comp.lang.ada/topics).
&gt; What it does do, is present nearly every standard Ada 2005 package in a concise and accurate manner. That's pretty much what I hoped, so I think that I will buy it after Christmas. &gt; I don't think there are any Ada books that deal with non-standard packages, so if you want XML support in your program, you grab something like XML/Ada (libre.adacore.com) and read the manual on how to use that specific set of packages. OK. Coming from languages like Python and Java I am used to these things being a part of the standard library, so I assumed that they would be in Ada too. I saw references to GNAT.sockets but I realise now that the prefix GNAT. means that it's a GNAT specific package rather than a standard package. 
&gt; Sockets for example came up in a thread I started on comp.lang.ada as something that probably should be standard, but aren't No argument here. I noticed that GNAT comes with GNAT.sockets, so even if the standard does not define networking compiler writers are going to write their own implementations. Now I just have to dust off *Pan* and see if I can find a live usenet server. 
Oh crap, I have a dentist appointment that day. (Really!) And, I live on another continent. Bummer. Maybe next year :-) 
Well, if you ever happen to come to Denmark, feel free to look us up!
You might be lucky enough (like me!) to have [a great ISP](http://www.sonic.net) that provides usenet access. Failing that of course, you can use [Google Groups for comp.lang.ada](http://groups.google.com/group/comp.lang.ada)
www.eternal-september.org provides free access to text-only Usenet news. I use Emacs ...
I think it's the best all-round Ada book on the market, but he only brushes over the Annexes and does not cover non-standard features (as pointed out by other posters). I'm currently reading a book that's specifically about concurrent and real time programming in Ada, which is a more in-depth treatment of that particular topic and related Annexes. Unlike C header files to figure out what an API does, which requires slogging through #ifdef's nested within #ifdef's etc, reading .ADS files is generally worth while. With Python and Java, where the spec and implementation are one file, it's easy to get lost in the detail and not 'grok' the over-all API. In most cases the API is very straightforward. That being said, anything in the GNAT packages is specific to the GNU Ada compiler. It isn't true of other Ada compilers, so it isn't covered in a book that covers the Ada standard. If you are using some other compiler, you may find your compiler vendor offers alternatives to the GNAT libraries and I would direct you to their documentation. The other problem is that there are just fewer Ada programmers out there than there are Java or C# programmers. With a smaller market, it's hard for a publisher to justify paying an author to write a book, edit it, bind and publish it. I would recommend http://en.wikibooks.org/wiki/Ada_Programming and http://wiki.ada-dk.org/index.php/Main_Page as good second sources, in addition the book.
&gt; You might be lucky enough (like me!) to have a great ISP that provides usenet access. I live in New Zealand and am saddled with Telecom NZ's Xtra service. They [dropped Usenet support](http://publicaddress.net/3124) some years ago. For a good while I used the free server supplied by usenet4all.se but their service is increasingly erratic and the server often goes down for days or weeks. I am almost at the point where I might (shudder) *pay* to get proper, reliable usenet again. What has the world come to? 
Thanks for that. I will try this one and see how it works out. 
In the future I suggest linking to the original source, instead of a two sentence blurb. That said, the [original posting can be found on Google Groups here](http://groups.google.com/group/comp.lang.ada/browse_thread/thread/73764fe730d436cf/477ff22c52a28ee7?lnk=gst)
At [Amazon](http://www.amazon.com/Ada-Software-Engineers-Mordechai-Ben-Ari/dp/1848823134).
I have that book, and it is good. Very good. I enjoyed reading it.
AdaGOOP was successfully used for the development of the [XPath In Ada](http://mckae.com/xia.html) (XIA) library.
Ooof that page burns my retinas. It's too bad the source code isn't published to a repository instead of just a tarball :(
&gt; Ooof that page burns my retinas. It's too bad the source code isn't published to a repository instead of just a tarball :( If you clicked on that link then you're braver than me. There is no way that I would run code downloaded from chat.ru. Google finds a few references to this package from 2003 on lists.adacore.com, so it's probably legit, but still. 
Interesting. I'd love to see some of that code!
The original article, with pictures and charts, can be found in the [CrossTalk archives](http://www.crosstalkonline.org/storage/issue-archives/2000/200008/200008-McCormick.pdf). 
Prof. McCormick's [Real-Time Embedded Systems Lab](http://faculty.cns.uni.edu/~mccormic/RealTime/) (i.e. the Train Lab) at UNI.
A couple years ago I decided that I needed to get some experience with at least one of the dynamically typed languages, since all my programming experience up till then had been with static and strongly (to some degree or another) languages. I decided to go with Python. It was popular, there was a lot of material about it on the web, and even AdaCore had integrated it into their GPS IDE as the scripting language. I enjoyed learning it, did a bit of serious (for me) GUI work with PyGTK, and plan to go with it the next time I've got an appropriate project in mind. Unfortunately it's been more than a year now since I last touched it, and I've probably forgotten more than I knew of it by now :-) But what I did find interesting is that--and this is totally my unscientific perception--Ada programmers looking into dynamic languages appear to lean towards Python. (That GPS uses Python was nice, but it had little influence on which dynamic language I eventually chose, and I've never done any Python scripting in GPS anyway.) I can't really say for sure why, maybe part of it is the syntax, which is pretty readable (not all brace-y and symbology-heavy like some languages). Maybe its blend of OO and procedural capabilities is analogous to Ada's, so it feels complementary. I don't know, it just didn't take too long to get reasonably comfortable with it as a newbie.
Someone has now written [all the code](http://paraffin.sourceforge.net/)!
(I had a comment here, which seems to have vanished for some reason. Anyhow, as best I can remember...) A couple years ago I decided to get some experience with one of the dynamically-typed languages, since all my experience had been with static and strongly typed languages. I opted to go with Python because it was strongly typed, popular, and therefore a lot of info about it was available on the web. I did like working with it, doing a serious (for a Python newbie) project for myself that centered on putting together a GUI for creating and editing multi-faceted configuration files for another application. I used PyGtk for the project, and that itself was a joy to work with. Unfortunately I've not touched Python seriously now in over a year and have probably forgotten more than I learned :-) But given the right project I fully expect I'll go right back to it when the need arises. One perception I have, and this is just *my* perception, is that Python seems to have a particular appeal to Ada programmers. The GNAT GPS IDE uses it as its scripting language, and AdaCore provides some tooling for integrating Python and Ada software. Maybe it's the syntax, which isn't bracey or heavily symbol-oriented, I'm sure the strong typing is a factor--it was for me--and perhaps also that Python seems to embody a particular balance of OO and procedural programming support that is comparable to Ada's support for those methodologies.
*Now* you're talkin'!
&gt; "Starting with Android 2.3 (Gingerbread) it's possible to write applications in languages other than java. The intention was to make C and C++ programmers happy, but it opened the door for the rest of us." Does this mean that apps outside of Dalvik will have full access to the GUI libraries on Android 2.3? I don't know if the GUI libraries are themselves written in Java or whether they are native with a wrapper library for Dalvik. The prospect of being able to write a full Android app in Ada is intriguing, to say the least. 
Accompanying [slides](http://people.cs.kuleuven.be/~dirk.craeynest/ada-belgium/events/11/110205-fosdem/03-ada-in-debian2011.pdf) [pdf].
Okay, I see all this. What exactly *is* coreland all about? Is there any kind of overarching description of what's behind it?
rothwell of #ada IRC fame. It's his stuff. His old coreland.ath.cx site is no longer being maintained. Instead he has now started http://io7m.com/ He has uploaded all his projects to github so they are not lost.
There's also some simple Jabber support in AWS: [AWS Jabber support](http://www.adacore.com/wp-content/files/auto_update/aws-docs/aws.html#Jabber)
[Part 1](http://redd.it/f3s27).
Looks interesting, especially for those of us attempting to use Ada as a general purpose language rather than an embedded programming language. My first impression is that the book in question, Understanding Unix/Linux Programming, appears to date from 2002, which makes it somewhat out of date, and it is quite expensive. The second thing I noticed was the suggested switches to gnatmake: gnatmake='gnatmake -gnat05 -gnatE -gnato -gnatv -gnati1 -gnatf -fstack-check -m -O3' Can anyone elaborate (pun maybe intended) on the use of -gnatE in this code? 
&gt; the use of -gnatE By default, the GNAT Ada compiler does not strictly conform to the Ada Reference Manual when it comes to the elaboration order of Ada units. It uses a faster, "static", method that is completely consistent with RM requirements, and that guarantees elaboration safety. In my experience this GNAT-default order is sufficient for the overwhelming majority of cases. However, there are some more complex elaboration order situations that cannot be accommodated through a strictly static elaboration approach. The purpose then of the -gnatE flag is to direct GNAT to use the RM-defined "dynamic" elaboration approach that completely conforms to the requirements of the Ada reference manual. The section on [Elaboration Order Handling](http://www.adacore.com/wp-content/files/auto_update/gnat-unw-docs/html/gnat_ugn_33.html) in the GNAT User Guide covers all this in detail. In reviewing the other flags, -gnato enables overflow checking, and -fstack-check enables run-time stack checking; both of these checks are disabled in GNAT's default configuration for historical performance reasons. So the bottom line appears to be that this set of suggested switches is to ensure that Ada compilations are performed in full compliance with the Ada (2005) language specification. 
The book is also available here http://www.cmis.brighton.ac.uk/~je/adacraft/ And it is a great book btw.
[Source code and executables](http://www.math.uic.edu/~jan/download.html).
Hi, in fact there are plenty of Ada OS. Ada is mostly used in real time computing because of its features, and such systems need Ada features from the bottom-up, so they use Ada to code the OS too. Or at least what you would call OS on a real time system...
There have been a few attempts at doing this: * [MaRTE](http://marte.unican.es/) * [Lovelace](https://webcache.googleusercontent.com/search?q=cache:cTIva1PsvkkJ:www.lovelace.fr/+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us&amp;client=firefox-a&amp;source=encrypted.google.com) * [Admiral OS](http://sourceforge.net/projects/admiral-os/) This topic comes up for discussion every few months in the comp.lang.ada newsgroup, you can go and read there to get an idea of some of the pros and cons. Just search that group for "[Ada operating system](https://groups.google.com/group/comp.lang.ada/search?group=comp.lang.ada&amp;q=ada+operating+system&amp;qt_g=Search+this+group)". 
&gt;in fact there are plenty of Ada OS Mmm, I don't think so. I've been working with Ada for a very long time, and the only OSes I know of that were coded in Ada and that achieved some level of completeness were [MaRTE](http://marte.unican.es/) and I believe an early, no longer supported, version of RTEMS. I would be more than happy to be proven wrong, though :-) 
&gt;Unix does not handle real-time applications very well What other kinds of applications are there?
&gt;Let be a little technical here, and come back to the original point. &gt;Alsys, then Thomson Software Products, have almost always implemented the Ada runtime for bare targets in (a subset of) Ada. This is what I know as the closest approximation of an OS. &gt;The Ada standard assumes the following ressources as granted: tasking, heap, exceptions, io (too name a few). &gt;One of the purpose of the OS is to provide tasking, so breaking the "egg and chicken" problem imply prohibiting use of the tasking within the OS kernel code. Not a big problem by itself, but a new set of tasking primitives will have to be defined for kernel internal use. A good point could be using a (very) simplified implementation of protected records. &gt;The Ada heap is a nice but complicated piece of code. It could be reused for an OS, except that it does not comply with MMU or DMA requirements. A lower memory management level is to be implemented (and the Ada heap should be rebuilt on top of it). The Ada heap is also protected against concurrency. This is nice to have, but depends on the Ada tasking internals. Some adaptations would be required. &gt;One problem is the Ada type system. An OS constantly switch from one level of abstraction to another: for example, it reads a disk block, and then understands it as a directory content. With its strong type system, Ada is not comfortable at that (any comment ??). With its weak type system, C let the user do all the mistakes he never wanted to do. An usual solution is to make extensive use of System.Address: programming in Ada with a C style. Not only it is as unsafe as C, but Ada make things a little more ugly than C. The best work-around I have ever found is using array-of-bytes buffers and then use the address clause to map a more typed view. Looks too much like C. Beware of aliasing and alignment problems ! &gt;What we need in an OS would be a language with some controled 'type morphing' features. Modula 2 included some basic morphing (with its predefined 'generic' types: BYTE, WORD, ..). A good academic subject ? &gt;Exceptions are good for many things. I would promote use of exceptions in an OS. But the Ada 95 exceptions raise multiple concerns when STORAGE_ERROR is raised, because the exception occurence stuff may require use of dynamic structures. This is a huge problem in an OS which must survive to memory ressources limitations. So I would recommend using only a subset of the exceptions features. &gt;If you look back at these restrictions, you will find out that most of them imply using a specific, reduced, implementation of the runtime. But each compiler comes with its own (specific) runtime, and runtime interfaces. Any solution will be compiler-specific and involve building your own 'Ada' environment (runtime) first. This is not really Ada anymore. This environment will be the lower layer of the OS kernel. The rest of the OS (drivers, file systems, network, ..) could be built on top of it. &gt;In France the SOL project intended to build a Unix clone in Pascal (ISO version). The founding came from the French ministry of defense, because of export restriction on US products. Eventually, SOL came to life, but they was forced to define their own variant of Pascal (and managed to get it adopted as an AFNOR standard--the French equivalent of ANSI), so they could still claim using a 'standard' Pascal. SOL was not really better than Unix version 7, and could not keep on competing with BSD. This is a dead thing now. A lesson to learn ? &gt;The final lesson is Ada has never been designed for such a purpose, obviously. This has probably never been part of the DOD requirements, anyway. &gt;Pascal Martin. Have these problems been fixed with Ada 2005? Will they be fixed with Ada 2012?
(I don't really know what you're quoting from there.) But, to answer your question anyway, "[real-time](https://secure.wikimedia.org/wikipedia/en/wiki/Real-time_computing)" computing is generally considered to mean software systems that operate under significant performance constraints and response deadlines--often very short ones--as in the case of guidance systems, aircraft avionics, and operating systems. One can be pedantic and argue that all computer systems are "real time", since they all have to conform to some kind of performance constraint. True, and therefore a tautology. "Real-time" is just the term commonly applied to those systems with more stringent, fast-paced performance requirements. (I'm not going to get into how well-suited Unix is for real-time apps without knowing the context of the quote. I've seen Unix work fine for "[soft real-time](https://secure.wikimedia.org/wikipedia/en/wiki/Real-time_computing#Hard.2C_firm.2C_and_soft_real-time)" systems, but would be very leery of it in a "[hard real-time](https://secure.wikimedia.org/wikipedia/en/wiki/Real-time_computing#Hard.2C_firm.2C_and_soft_real-time)" system.)
It's not clear to me what the "problems" are that you're referring to. Martin lists some issues and concerns he sees with developing an OS using Ada. Building an OS in *any* language will have to wrestle with how well-suited that language's constructs are to the requirements of an operating system implementation, including performance, maintainability, expandability, concurrency, etc. That's just doing due diligence. One also needs to be clear on the difference between an operating system and the run-time library needed by applications programmed in a given language. Ada programs can be written to use no RTL and thus be able to run on the "bare metal" (see AdaCore's "[Zero Footprint Profile](http://www.adacore.com/home/products/gnatpro/toolsuite/runtimes/)", for example). But that's a totally different thing from an *operating system*.
I'm not a real time systems expert; I'm a newbie indeed. But I was thinking of cyclic executives and such sort of things, which might not be considered as operating systems, although they run on top of hw. I'm sure you're right talking of OSes as we think of them when we talk of complete systems :)
This is the first I can remember hearing about bettercodes.org ... I don't know what's wrong with c.l.a or SO!
Or even here! No shortage of knowledge in this here venue.
bettercodes.org offers a bit more than c.la. and stackoverflow, AFAIK. At bettercodes.org you also get 2GB worth of space for your software projects. I think they currently support Git and SVN. Also the platform is open source, which is always nice. bettercodes.org can probably be described as a mix between github, stackoverflow and a thin social website. I haven't signed up yet, but in the name of boosting knowledge of Ada, I probably will. :o)
There, I've signed up. Lots of tools available, perhaps too many. While everything appears to be working just fine, the interface does feel a bit crowded. But I think it's worth checking out.
See the c.l.ada thread titled "Ada group in bettercodes.org" from Feb 23rd 2011.
O yes! I do remember now .. slipping :-(
Support for garbage collection is roughly on par with C++. Some of the criticism was valid for Ada and C++ at the time, but no longer applies to either language. Ada does offer a module system, and C++ still doesn't (hidden symbols on ELF platforms do not work so well in practice and are rather difficult to use). On the other hand, it can be argued that C++ offers better binary compatibility for dynamic shared objects.
Polish-to-English [translation](http://translate.google.com/translate?js=n&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=pl&amp;tl=en&amp;u=http%3A%2F%2Fwww.ada-poland.org%2F&amp;act=url).
&gt;How well does Ada Address the criticisms of c++ Well. Except for the garbage collection part obviously, which is one feature I would like to see fully integrated into the language at some point. (But I ain't holding my breath :-) Ada is built on a well thought-through programming paradigm, a "[type model](http://blog.kickin-the-darkness.com/2007/08/fundamental-theory-of-ada.html)", which provides language design and implementation guidance for its behavior and future evolution, and which has helped Ada limit the feature encrustation (and ad hoc disambiguation rules) that C++ now staggers under. (And just to get it on the record: I have done a fair share of C++ programming, mostly in the areas of message traffic management and large scale data analysis. I agree with the kernels of the author's complaints about C++, although it's at time a bit over-the-top, as all enjoyable rants should be :-) 
Hear hear. Am new to Ada but I have considerable experience with C++. I can already see many common problems with C++ that do not occur in Ada (A tiny example: the 'ads' files are a million times better than the include files). &gt;Except for the garbage collection part obviously, which is one feature I would like to see fully integrated into the language at some point I understand that Ada was designed to have an optional GC( while C++ is not). Am very curious to know why wasn't any compiler vendor interested in providing (optional) support for GC? On a related topic, is it possible to change the storage pool for a type *dynamically*? (If that is so, I can easily port a tiny non-general-purpose GC written in c/c++ to ada and can live happily ever after)
There's a discussion on [Ada and garbage collection](http://stackoverflow.com/questions/1691059/why-doesnt-ada-have-a-garbage-collector) at Stack Overflow. Also, here's a "[memo](http://www.enyo.de/fw/software/gnat-gc/)" about adding a conservative garbage collector to an earlier version of GNAT. I don't believe one can dynamically change the storage pool with which an access type has been associated--but I'm no expert in this area. I would suggest asking at [StackOverflow](http://stackoverflow.com/questions/tagged/ada) (tag the question as 'ada') and/or [comp.lang.ada](https://groups.google.com/group/comp.lang.ada/topics). (I kinda also suspect that there might be some "*Real Programmers manage their own damn memory!*" in play... :-)
Awesome marc-kd. Thanks. :o)
I'm going to be updating some code tonite!
[Start of discussion thread](https://groups.google.com/group/comp.lang.ada/browse_thread/thread/f0be8eebb2993001#).
I would have put the actual strings into the package body, with the spec containing eg "function Revision return String;". Otherwise, I think it's a good idea; though I'm not quite sure about 'svn info' on its own, wouldn't you need an 'svn update' first?
I just liked the guidance on incorporating this stuff on svn check-ins. I know it's simple, it's just one of those things you never get to unless the HOW-TO gets dropped right into your lap. I'm guessin' you probably don't want to run svn update as part of your journeyman edit-compile-link cycle because you'll want to control just when to accept updates into your work environment. And also, if you're using a remote repository, like SourceForge, you probably don't want to be hitting that every time you do a 'make'. The author did mention doing this as part of a 'release build', so that's where I'd look at putting in an svn update. (If I used gnatprep, which I don't; and if I used make, which I don't :-)
[English translation](http://translate.google.com/translate?js=n&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=ru&amp;tl=en&amp;u=http%3A%2F%2Fru.ada-community.org%2F&amp;act=url).
I would have called it a teeny tiny crevice!
Well, it does not seem to be the best introduction I have seen. Among mistakes I read : - By default, the members of an enumeration are constant integers. - The confusion between record and package in the lesson 6 
I've sent them an email pointing out these mistakes. Hopefully they'll fix them.
Well, I think they should do a part on the type system which is the most important point in Ada
The table of contents is here: http://www.functionx.com/ada/index.htm By the way, Thomas, you could also report that the next link on the last lesson (6) redirects to the previous lesson (5).
Are you trying to do an article about Ada fundamentals, or are you a corporate shill for AdaCore? Because for newbs I'd recommend starting with Mingw and Adagide. Not only is Adagide easier, but you aren't stuck with AdaCore's "Thou shalt not sell the software you create unless you pay us mega-bucks" restriction.
I'm not trying to do an article about Ada - I've merely posted a link to one. Isn't that what reddit is all about? And I have no affiliation with AdaCore. I just happen to think that GPS is a good editor, and I enjoy using it myself. I don't mind the GPL. You obviously do, so it's great there are products like Adagide that suits your needs better. Choice. A good thing. :o) 
Sorry, I thought you were the author of the article. My comments were directed toward the article, not to your link. Perhaps you could have made the link "Ada(Core) Fundamentals - An Introduction To Companies that suck the life out of a darn good language".
The addendum in the article notes that this usage is an erroneous utilization, so it's...well...erroneous.
comp.lang.ada [discussion thread](https://groups.google.com/group/comp.lang.ada/browse_thread/thread/3a7c118fd2cc64f9#) on this subject.
&gt; The SETI@Home Service requires a command-line SETI@Home client. To ensure the integrity of the results, SETI@Home clients must be downloaded from an approved server, so one is not distributed with this package. A list of approved download sites for the SETI@Home client is available at http://setiathome.ssl.berkeley.edu/unix.html. Look for the latest i386-winnt-cmdline.exe release. Is the required client still officially available? I can't seem to find it :(
I emailed Ted Dennison about this and he's not aware of where one might find that client. He said he basically stopped working on SETI@Home some time ago. If someone turns one up, great, let us know. Otherwise one might find some value simply in studying the source code. SETI@Home did have several hundred users at its peak.
Too bad the SETI is shutting down :(
English [translation](http://translate.google.com/translate?js=n&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=fr&amp;tl=en&amp;u=http%3A%2F%2Fd.feneuille.free.fr%2Fenseignerada.htm&amp;act=url).
From the conclusion: "A language can not spread unless it is taught." So true.
&gt;Too bad the SETI is shutting down :( Smile, [it's not](http://setiathome.berkeley.edu/forum_thread.php?id=63910) :-) "As noted in the Scientific American and elsewhere, the Allen Telescope Array was recently forced into hibernation. While we are sad to see this happen, SETI@home receives its data elsewhere, so our project is not directly affected. Dr. Eric Korpela wrote a helpful Q&amp;A about this in the SETI@home Staff Blog."
That thread was pure win for me. Learned a lot of new stuff, and I really liked your Task termination example marc-kd. Thanks! :o)
Here's [Part 1](http://www.adacore.com/2011/05/09/gem-105-lady-ada-kiss-python-part-1), a general overview of interfacing Ada with scripting languages.
Tangent: I didn't realize GW had an Ada group; is this a group that has events?
I take it that by "GW" that you mean George Washington University. If that's the case, you might try contacting [Michael Feldman](http://www.seas.gwu.edu/~mfeldman/), GWU emeritus professor.
Huh, it turns out AdaCore publishes the same articles under `www.adacore.com` and under `libre.adacore.com`. I hadn't seen this article when I submitted [this one](http://www.reddit.com/r/ada/comments/hsy9w/gem_107_preventing_deallocation_for/). Whoopsies.
There's some interesting [commentary in the German version of the article](http://www.heise.de/developer/meldung/Fuer-Ada-Entwickler-und-Lego-Fans-GNAT-GPL-2011-veroeffentlicht-1261001.html)
Using Google Translate to look at one comment at a time is kinda tedious, any comments in particular that were provocative or insightful? EDIT: Never mind, once I ran the comment page through the translation, all the links (comments) automatically get translated as well.
[This thread](http://www.heise.de/developer/news/foren/S-Wer-benutzt-hier-Ada/forum-203246/msg-20377538/read/) is fairly long and has occasional interesting pieces going back and forth on the merits of Ada versus other languages (C, C++, Java) in terms of type-safety, static analysis, etc. I stopped reading halfway through since I have work to do..and then I ended up back on reddit ;)
A word or warning: Most of these repositories contain code which can be considered alpha or beta quality at the best. Ahven's repository is of course an exception and jdaughter is in somewhat decent state also.
Think of it as "mega-pair" programming :-)
I'm sorry, but is that a question? Lots of embedded implementations don't allow dynamic allocation so it is actually convenient to have things separate. 
Eh? Perhaps you're not commenting on what you think you are?
All I see is a link to the Ada RM that together with your title is a tautology. Is there something about this package that bothers you? Do you think it's awesome? You haven't actually said anything. 
You're right.
I don't understand the appeal.
You can write a high integrity blog engine I guess? :-P
Perhaps if you were in the intersection of web devs and Ada lovers.
this was handed to me at work and very useful until I got a copy of ada as a second language. an excellent introduction.
Fascinating stuff. I am still at work and so am away from my Ada environment at home and can't play with this yet. Is this intended to be part of a bigger project, or simply something done for the hell of it? 
Just for the hell of it :) I had contemplated writing a full window manager until I discovered [i3](http://i3wm.org) :)
"[This is kind of ridiculous.](https://github.com/rtyler/fucked-ada#readme)" Ya think? :-) 
I don't know, seems to me that just building atop [Ada.Command_Line](http://www.adaic.org/resources/add_content/standards/05rm/html/RM-A-15.html) would be a lot more straightforward (and portable). E.g., [Command Line Processor](http://www.adapower.com/index.php?Command=Class&amp;ClassID=AdaLibs&amp;CID=193) 
There is also [this one](http://rosettacode.org/wiki/Execute_Brain****/Ada).
It's a bit convoluted, isn't it? Or is that just me?
I like this quote: "And as for the argument that software is essentially different from durable goods and thus should not be subject to similar warranty protection, it is ironic that software vendors are making the opposite point when they apply for software patents." You speak the truth Dewar!
The remote control is a nice touch. 
Going, Thomas?
My wife and I are definitely planning to go, so we'll be in Stockholm with 99% certainty. :o) Hopefully a bunch of the Ada-DK guys will be going. Should be a fun journey by train then!
Neat! Do you know that guy? Is the source available? :)
Someone at AdaCore is trying to get in touch with them to find out more info. Will update when more is known...
I'm glad Jason is going to commit to Ada to put together some quality software, but I have to comment on a couple things he said: &gt;there are no Ada idioms Of course there are! All programming languages have idioms. Here's one regarding item counts and indices (caveat--not compile checked): type Item_Counts is range 0 .. Max_Items; subtype Item_Indices is Item_Counts range 1 .. Item_Counts'Last; type Item_Collections is array (Item_Indices) of Data_Type; Item_Count : Item_Counts := 0; Items : Item_Collections; Another idiom is to rely on unconstrained arrays and attributes when possible. Instead of declaring procedures with fixed-length array parameters and a count of filled indices: type Data_Set is array (Integer range 1..20) of Integer; Data_Size : Integer := 0; procedure Process (Data : in out Data_Set; Last : in Integer); which means you would have to iterate through the Data parameter like this: for I in 1 .. Last loop Data(I) := ... Instead do something more like this: type Data_Set is array (Positive range &lt;&gt;) of Integer; Data : Data_Set(1..10); procedure Process(Data : in out Data_Set); for I in Data'Range loop Data(I) := ... (Now these could be improved even more by defining and using application-specific numeric types and constants.) These are a couple simple idioms, there are more involved ones, such as for [interrupt](http://www.adacore.com/2007/10/15/ada-gem-13/) [handling](http://www.adacore.com/2007/10/22/ada-gem-14/), and ensuring [mutual exclusion](http://www.adacore.com/2009/09/21/gem-70/).
There's also a comment that Ada is a "lot less fun to write". I **beg** to differ! The things that detract from my enjoyment of programming are stupid type mismatches, stupid mismatched procedure parameter invocations, stupid array overruns, stupid null dereferences, and all kinds of stupid bugs that Ada compilers reject out-of-hand, or blow up at with a run-time exception as soon as they're encountered. Ada helps me catch the stupid stuff right away, so that instead of wasting time tracking down bugs that trigger a misbehavior showing up elsewhere in the code, I'm able to focus on the much more interesting meat of the application. Also, to be fair, I've been writing Ada for over 25 years, and so many of the idioms and practices are just second-nature to my programming activities. I don't even think about things that newcomers to this strongly, statically typed language will have to encounter, understand, and learn to [work with](http://blog.kickin-the-darkness.com/2007/08/fundamental-theory-of-ada.html). So do I sling out error-free code just because I'm working with Ada? Of course not. But because of the language I've eliminated whole classes of programming errors.
When he said that Ada is a lot less fun to write, that was in comparison. Just because you enjoy Ada (As do I), my 25+ years of writing Ada has led me to the conclusion that it is a rugged, solid language. However my 3 years of writing Python has me agreeing with the author, it's just a lot more FUN! So, while I wouldn't want an implanted pacemaker to be programmed in Python, but if I had to do a web spider or quick-and-dirty 3d graphics then I'll always default to Python.
Finally, a decent explanation of 'aspects' and their use!
I was overstating the case for effect. In any case, though, there's a difference between the idioms you point out above and some of the C idioms that show up everywhere: the Ada idioms are immediately understandable. Of course every language has idiomatic and non-idiomatic approaches, but there must be a better word for some of the unreadable things I see C programmers do.
I think I made it clear later on that I find the sort of enjoyment you do in writing good Ada, but it's not the same cowboy-shootout fun that you can get with C.
Suspension objects are not semaphores, not even close. Why do Ada programmers know so little about concurrent programming?
Ada's used for operating systems development? What projects?
There have been a few attempts at this, but the only active one I know of that has reached some level of usability is [MaRTe](http://marte.unican.es/), which is a hard real-time OS for embedded applications. I'm also 95% sure that there was an early version of [RTEMS](http://www.rtems.com/) written in Ada, but I've not been able to reacquire any reference links to that--although their integration with Ada is quite good.
Looks cool enough, but I think the *real* "Open Source Answer to Delphi and VB" is, of course, [Lazarus](http://lazarus.freepascal.org/)...
It's Windows only. That is, the IDE runs only on Windows, and the GUI it creates seems to be Windows only too, unless I'm much mistaken. I really can't see why anyone would want something that limited in 2011. 
Are there any bigger screenshots running around? Those ones on the SF page are *tiny*
Windows only :( I'd prefer GtkAda over that.
The originator of GNAVI, David Botton, was focused on increasing the accessibility of Ada to Windows developers.
The paper doesn't seem to be dated .. when was it written?
It was published in the August 2010 Ada Letters. 
[RainCode](http://www.raincode.com/company.html) used to offer parser generators of the kind for XML, targetting several languages, including Ada 95. I think the Ada version was made available freely a few years ago. Don't have a link handy, though.
More posts like this, please. In addition to technical articles, I love hearing about successes, especially non-defense successes.
When I find 'em, I put 'em up! Here's the "[Who's Using Ada?](http://www.seas.gwu.edu/~mfeldman/ada-project-summary.html)" site, which includes some non-defense products and projects.
[Part 1](http://www.adacore.com/2011/09/05/gem-109-ada-plug-ins-and-shared-libraries-part-1/) was about GNAT and shared libraries in general.
I've exchanged emails with the author, Brad Moore, over the last few years. He knows his stuff, and his published articles in Ada Letters on container design, memory pools, and multi-processing. This is good stuff, check it out. 
After reading the above, proceed to http://okasaki.blogspot.com/2008/07/functional-programming-inada.html
I haven't been reading Ada code for a couple of months, so OP's post confused the hell out of me. Perhaps this link will make a bit more sense for me ;)
The other day I though of a reasonable improvement to brainfuck, goto. For those of you who don't know, that's like qwop with portals.
The other day I though of a reasonable improvement to brainfuck, goto. **Edit:** Basically qwop with portals.
Always interesting to see an example of a well-known idiom done in Ada. But personally I think that code generation from UML is better done in a language that supports pattern matching; especially since the code to be generated probably depends on distributed properties of the model (for example, UML inheritance). My vote in [ColdFrame](https://sourceforge.net/projects/coldframe/) was for XSLT (I wouldn't like people to think I got it totally right there, XSLT isn't the right language for checking model completeness/correctness!)
Full FOSDEM 2012 [Ada Room Announcement](http://people.cs.kuleuven.be/~dirk.craeynest/ada-belgium/events/12/120204-fosdem.html).
I love a good, fully worked out example. I clicked the upvote arrow as *hard* as I could!
/me blushes Thanks man. That means a lot, and it makes me want to write some more. :o)
GNATCOLL.Traces is pretty neat, I just wish they'd fix the bug in GNATCOLL.Traces.Syslog that I reported to AdaCore November 6th. 2011. As long as that bug is present, the Syslog package is pretty much useless. But still: GNATColl is a great piece of software. :o)
There's also the AWS.Log package available.
Just got this notice sent from inspirel.com: &gt; A simple but effective logging for Ada is also part of the YAMI4 project. Check the generic IAL.Log package. I haven't tried it, but I can at least confirm that there is a package called IAL.Log in the source package for YAMI4. :)
Given that there's the original three I listed, AWS.Log, and now also [YAMI4's](http://www.inspirel.com/yami4/) IAL.Log package has turned up, I think we're pretty well covered in this area. No more loggers, write something else!!! :-)
More info on the [D-Bus protocol](http://dbus.freedesktop.org/doc/dbus-specification.html#introduction). 
One new thing in these packages is x86_64 targets. Previous (4.3.3) versions of CSWgcc4ada could only create 32-bit object code. The compilation isn't straight forward, unfortunately: maciej@unstable9s:~/src/ada &gt; cat hello.adb with Ada.Text_IO; use Ada.Text_IO; procedure Hello is begin Put_Line ("Hello WORLD!"); end Hello; maciej@unstable9s:~/src/ada &gt; gcc -m64 -c hello.adb maciej@unstable9s:~/src/ada &gt; gnatbind hello maciej@unstable9s:~/src/ada &gt; gnatlink hello -m64 /opt/csw/lib/gcc/sparc-sun-solaris2.9/4.6.2/sparcv9/adalib/libgnat.a maciej@unstable9s:~/src/ada &gt; file hello hello: ELF 64-bit MSB executable SPARCV9 Version 1, dynamically linked, not stripped maciej@unstable9s:~/src/ada &gt; ./hello Hello WORLD! Maybe there's an easier way?
...and there is one! maciej@unstable10x [unstable10x]:~/src/ada $ gnatmake -m64 hello gcc -c -m64 --RTS=amd64 hello.adb gnatbind --RTS=amd64 -x hello.ali gnatlink hello.ali -m64 maciej@unstable10x [unstable10x]:~/src/ada $ ./hello Hello WORLD! maciej@unstable10x [unstable10x]:~/src/ada $ file hello hello: ELF 64-bit LSB executable AMD64 Version 1, dynamically linked, not stripped
Where do you get the source code of GNAT-AUX? I can see the code browser, but I don't see the direct link to the git repository that you can check out.
Anyone who goes through the effort of getting this up and running is welcome to share their experience. Other links: [DragonEgg 3.0](http://dragonegg.llvm.org/) [LLVM](http://llvm.org/) 
Another company discovers that investing in their employees in the form of training instead of hiring people whose resumes fit produces better work! Few companies, many in transportation and critical systems, hire their employees for talent and then train them. During this period they teach them the language, but also the methods, techniques and technologies used by the company. After training the individual is ready to work as a cohesive member of the team, not some individual with their own way of doing things.
I don’t know what licence AdaCore put in GNATPro code, but the FSF licence terms are now GPL V3 with additional permissions described in the GCC Runtime Library Exception, version 3.1.
I'm in a pretty similar situation. I don't know how much use this will be but for my class they gave us: General Ada Textbook: http://www.it.bton.ac.uk/staff/je/adacraft/ A data structures textbook (in ada): http://homepages.udayton.edu/~winslole/350.htm Some Sample code: http://users.cis.fiu.edu/~weiss/ada.html 
That stuff looks great. Definitely better than what I've been looking at. At least you got something for the class. We've got a "textbook" which is just the notes he uses in class compiled into one file. Nothing extra and he doesn't even really answer questions after class or try to help if you ask for it.
And also [Ada Distilled](http://www.adapower.com/pdfs/AdaDistilled07-27-2003.pdf), though that is oriented towards more experienced programmers. Stack Overflow also has a coterie of [Ada respondees](http://stackoverflow.com/questions/tagged/ada), so questions can be asked there as well.
Sorry I couldn't get back earlier. I just wanted to thank you guys for all the great links. I've been reading some of them very diligently. Now I'm off to learn some more. I have to be able to create a "professional grade" program with two link allocated stacks, among other things, in less than a week. Once again, thanks for the guidance.
See, the problem is that technically it is a Data Structures class that is supposed to be language independent. But he "recommends" using Ada and all of his examples are in Ada. I did not see the other new prices, I'll give those a look. I see what you mean about it being a pain to learn. Most of the resources I've seen feel like the assume you already mastered another language which is making it tough.
why "still"? this implicates that using Ada is wrong or outdated.. for who uses Ada, see here: http://www.adacore.com/home/ada_answers/lookwho and here: http://www.adaic.org/advantages/projects/ and here: http://www.seas.gwu.edu/~mfeldman/ada-project-summary.html
Lack of free tools? IDK about you, but I heard abut AdaCore and GNAT - and they support general PC very well. When it comes to Ada programmers it is more of a chicken &amp; egg problem - because, outside of aerospace, military and space niche, it is not used much not many ppl are learning Ada, which ends up with not many ppl knowing Ada, and thus it is not used outside of its niche (because of lack of programmers).
Not sure since when is gnat available. But as much as i know there were no free tools in the early Ada times, which was a blocking factor for long. Now it is ok but perhaps too late to make big penetration.
Thank you! Do you know anything about more recently developed weapons platforms? Maybe the F-22, F-35, or possibly missiles?
&gt;There are just not enough Ada programmers to be able to break the barrier of the niche domains. I am in the position to be able to decide which programming language we would use for the next embedded project and I have to stick to good'ol C because I cannot find enough experienced Ada programmers to set up a team! How experienced are you looking for? For experienced people you can get laid off Aerospace software engineers. For new hires, Ada is an exceptionally easy language to learn. And most new hires on the recent grad end of the scale are used to learning new languages anyway.
From what I can find via Google, the F-22 is Ada while the F-35 is C++, although I have no first hand experience on either of those programs. Edit: I felt like looking at what other countries were doing... the Eurofighter Typhoon is programmed in Ada.
Eurocopter Tiger and Agusta NH90 also has parts programmed in Ada.
An early version of GNAT became available in or around 1994. Prior to then, Ada development environments were quite expensive. As the US military was mandating its use, too many vendors saw it as a cash cow. Anyone could have see what would happen: grumbling, resistance, and obstruction from the contractors forced to pay out big bucks for immature compilers and development environments, and pricing that eliminated any chance of hobbyists taking up the language. I started programming with Ada in 1984 using a terrible, terrible compiler (Telesoft). In '85 VAX Ada was released, and our project moved to that, first as a beta site and then the general release. It was expensive, but very high quality. I wanted to work with Ada at home, but even the cheapest compilers were hundreds of dollars at that time. So for years I worked with the far more accessibly priced Modula-2. By the time GNAT became available the window of broad hobbyist opportunity had passed for Ada. That's not to say the language is dying, it's use seems to have stabilized over the last decade, which bodes well for those companies, large or small, that employ it for the competitive advantage in creating high quality, critical systems. Which also supports those of us who simply enjoy working with it as well.
Ada is still going strong in some defense arenas. FishEye Software in the Boston Area is looking for Ada develpers/integrators to work on an embedded sensor system. Security Clearance is required. Contact : Bob Chisholm, roc@fisheyesoftware.com
I have found the Lovelace tutorial to be a great starting point for learning Ada: http://www.dwheeler.com/lovelace/
Would your industry suffer from less messy hacking? John McCormick's study(*) indicates that students new to Ada and to embedded systems will perform a lot better than those new to C and to embedded systems. Performance here means implementing minimum requirements, and possibly more. I'd speculate that programmers versed in C, and approaching Ada without prejudice, will have little difficulty with the language; in particular, the study shows that much of the Ada advantage was about its expressive, problem oriented fundamental type system. (*) August 2000 issue of [CrossTalk](http://www.crosstalkonline.org), available from their archive
Thus creating a self-referring and self-fulfilling prophecy...
This is brilliant. Already a few ideas for improvements occur: 1. Have it automatically generate presentation slides. 2. Add the ability to generate nonsense graphs. Perhaps that would be a separate project though. CBSG could generate labels for the graphs. 3. Trying to think of a way to incorporate clip-art into this. You couldn't really generate the clip-art but you could have a stock library of fairly insipid images, such as those usually used in slides, and randomly combine them with generated graphs and text. Imagine the fun one could have with interview candidates. Present them with a document generated using all of the above and ask them to comment on it. 
But.... why the red eyes??
Lovelace had a T-800 core?
Just saw a suggestion from the author: Copy a line from it and paste into a Google search. Nervous laughter ensues.
I'm currently learning Ada because I'm considering using it for a new open-source project (an astrology program). I'm impressed by the type system, which seems to me to be as expressive as Haskell's. Ada seems verbose, but the verbosity seems to make code more readable, so that's an acceptable tradeoff.
The xmonad config file is actually a Haskell program and defines the main procedure. When starting xmonad, if there is a new or modified config file, it is compiled into a customized version of xmonad, which is then run. 
A config file parser is available at http://wiki.ada-dk.org/simple_configuration_file_reader_-_using_a_generic An example of use in Rosetta.org http://rosettacode.org/wiki/Read_a_configuration_file
My site (stronglytyped.org) is now actually hosted on normal Apache. I changed the distribution from Debian to Fedora at one point and for some reason my AWS code didn't work on Fedora (with GNAT GPL), so had to change the server software. However, there are other AWS sites like http://www.vetoteka.pl/ (see http://groups.google.com/group/comp.lang.ada/browse_thread/thread/0469b2bba5f3a7bd) and http://blazedialer.com/ In addition, people behind http://virtual-worlds.biz use AWS on some of their sites (see http://virtual-worlds.biz/demonstrations/slas/). 
check out the ada bound 0mq for a nice network layer complete with publish subscription pattens. http://www.zeromq.org/bindings:ada 
Pretty much, in that they're message passing frameworks that hide most of the underlying socket, protocol, etc detail. After years of wrangling sockets on my own, I've grown quite fond of such frameworks :-) YAMI licenses under either GPLv3 or a paid-for Boost license (which includes support). That's why I didn't build it into [TOMI_4_Ada](http://sourceforge.net/projects/tomi4ada/) (Text-Oriented Message Interfaces 4 Ada), I didn't want the supported protocols to be any more than GMGPL or LGPL. 
Those codelabs.ch guys are churning out quite a few interesting things. Very nice!
Crikey, this is a pretty serious collection of stuff!
This seems to be stuck at GCC 4.6, which is not really current.
Im sure with some more community support it could be kept more current. clang is making great inroads on c based gcc, i agree with activelols comment on an llvm based ada compiler thats not gcc based really.
Google translation to [English](http://translate.google.com/translate?sl=auto&amp;tl=en&amp;js=n&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;u=http%3A%2F%2Fwww.elektronikpraxis.vogel.de%2Fthemen%2Fembeddedsoftwareengineering%2Fimplementierung%2Farticles%2F365761&amp;act=url).
When are these machines dated from?
1985 was the first release, i used them in the early 90s. Alot of what is in ibm rational jazz really came from Apex, it was truely ahead of its time, the rational terminals could be rotated vertical and the screen changed accordingly to make coding easier. It had things like name completion, edit time checking, function completion and lots of other goodies, the OS was as you know written in ADA and was rock solid.
Of course if you turn off most of the runtime like that you get as small binaries as any other. It would be great fun to see a fully developed kernel in ADA (like the rational R1000 OS). I have done a similar thing many years ago for some satellite firmware with Ada and the Ravenscar profile. ADA Ravenscar is well suited to Hard real time and coding up interactions with hardware. Maybe I should start a little project :)
The company I work for uses Rational Apex Ada (though there has been some move towards gnat). Does anyone else use Rational Apex Ada?
LockMart in Huntsville, AL uses it.
I don't think I've ever had $12K just laying around. :D
I have only recently developed an interest in Ada. I'm hoping someone can clarify what is the difference between (or relationships of) Spark, GNATprove, and alfa.
Any! :-) Most Ada open source efforts are ones that "scratch an itch" for one or two developers, so there isn't much in the way of big team projects that you'll find elsewhere. If you're looking to contribute to an existing open source Ada project, my suggestion would be to look at what's out there on [SourceForge](http://sourceforge.net/directory/language:ada/), [GitHub](https://github.com/languages/Ada), or other hosting sites, find something that interests you, familiarize yourself with it, and contact the owner to offer up your assistance (suggest some ideas and maybe even offer up a patch to show your bona fides). Good luck!
Interesting. I'm definitely going to learn Ada 2012.
Hey, thanks for that detailed and informative reply, I appreciate it. This is really interesting, for me at least. I have the impression now that it is possible that set of Ada which formally verifiable could expand.
This is pretty close to my interests... targeting low resource devices. Hopefully the interest in Raspberry Pi carry over to GNAT GPL 2012.
I was directed to this subreddit from StackOverflow, and I believe this is exactly the sort of thing I was hoping to find here :)
I seldom see Ada bashing and think it is simply due to lack of interest in the language. Which is even worse than bashing. It's like the [Dungeon Scene](http://www.youtube.com/watch?v=8EI7p2p1QJI)
That's true, you don't see it being bashed *nowadays*, Ada has very little mindshare amongst anyone under, say, 30, or that never had any experience with the defense and aerospace industries. So it's ignored, which as you've observed, can be worse than being hated. Back in the day, though :-), C++ was "where the market was going", and Ada was loudly being proclaimed as [bloated|expensive|slow|inferior|ad nauseum] and so good riddance to it. Problem is that there was a kernel of truth to some of the criticism at the time--expensive, slow--and by the time those were rectified, pretty much by the advent of GNAT, the window for Ada as a broadly accepted language had closed. Many of the criticisms were bogus, though, and came from people wanting to get that hot new language C++ onto their resume, or who had never actually used Ada but were simply imagining what it must be like in order to be so terrible, or refused to learn how to program "Adamatically" and insisted on using it in the manner of C or Fortran, which--surprise, surprise--was awkward to do. I dealt with all these in abundance. (And 15 years later I'm still pissed over the system engineer that altered one of my slides without my knowledge the night before my customer presentation to downplay Ada as simply an interim solution on the way to C++.)
I am kind of an observer here with its benefits and drawbacks. I am an embedded guy, dealing often with safety critical software in an industry that has seldom ever dealt with Ada: automotive. This is an industry where cost is superior to anything else due to the very high volumes, so if you can save 10 bytes here and there and afford a smaller and cheaper microcontroller, you are the winner. In this comparison Ada (at the time when it could have been considered an alternative) has failed. Still the automotive industry is incredibly conservative. Even the very latest standards aiming safety critical automotive software are drafted today with C language API (I talk about AUTOSAR not e.g. Genivi). I have started studying Ada on my own, mostly because I am in charge to introduce processes and technologies that would make our (C language) software safer. I am still playing with the idea to make a proof of concept implementation of one of our the software stacks in Ada to demonstrate how things could and should have been done properly, but I am also constrained by time and resources so this did not happen so far. Apparently this would only help to convince myself and the architects of the team. The marketing team would not accept a solution that they are unable to sell on the dozen other cpu platforms that we ought to support - and eventually this may be the end of the story.
woohoo! and the rest of my coworkers insisted I use makefiles..forget that mess.
I just hope they are not forgetting the original design goals of the language with all these additions, that is it Ada code should be easily readable. That's all I have to say
He did specifically refer to *FSF* GNAT, though! A little googling took me to http://gcc.gnu.org/install/binaries.html, so if you're running on Windows you could use Cygwin or Mingw. On the whole, though, I suspect he didn't really mean FSF. He certainly had a deer-in-headlights look, maybe the stress got to him!
I'm still appalled every time I must use other so-called modern languages and I need to manually manage critical sections. It is just so wrong...
it's a shame open Ravenscar died i guess. There are not really many people (read no big projects) using Ravenscar that I know of anyway. 
You have no clue how to code this, or you have no idea how to convert from a number represented in one base to another? If the latter, well, that's the first thing you have to understand--and that's independent of programming language.
Disagreed. I started with python and moved on to languages like C++, Java, Ada, and Scala. I think I'd rather switch to perl/lua for scripting instead of Python.
Why?
Another recently updated Ada tutorial for beginners is [AdaTutor](http://zhu-qy.blogspot.ca/2012/08/adatutor.html).
I misread the post at first with the impression that this was a project to compile Ada into Java bytecode to run on the JVM, using it instead of the GNAT runtime. Then I read into the project more, and now I'm thinking it's more one of those "because I can/want to" projects.
I'm pretty sure the intent of jadam is to be a JVM. While I highly doubt it would ever be competitive against the standard ones, it could be a fun and interesting project, and really help one to learn more about the ins and outs of Java Byte Code and VMs and such. Plus, you're free to make modifications and experiment with ideas you might have for such a thing.
You can slice a string with the index operator, e.g. given String "Charles" you can retrieve the first character with Charles(1). To account for an arbitrary length string you could use Ada.Strings.Unbounded to take in input.
I have worked with this professionally for a space project, unfortunately I found some pretty big nested interrupt bugs that meant we had to abandon it for XGC Ada
We need to take a step back here. Could you tell us the context in which you're asking this, and previous questions? It sounds like you're taking a programming class and these are your homework assignments. These have been very basic programming tasks, so I take it this is a beginner class. Now this is all well and fine, people here are willing to help out with some guidance on how to implement something in Ada, pointing you to programming techniques or the right language library and so on. But if you want help with your program, there needs to be some evidence of a good faith effort on your part to at least figure out a solution to the problem, even though you may not be quite sure how to code it yet. An approach for "How [to] store the previous words" is a *very* basic programming concept that should be almost immediately graspable by anyone being taught by an even marginally competent instructor. Show us what you got, and then we'll go from there. 
We just reached 40 members. :)
As is the custom, a somewhat less official edition is freely available in the resources section at [adaic.org](/http://www.adaic.org/ada-resources/standards/) 
Unfortunately not too many active members. I often find myself looking at a thread with no comments and thinking "Oh. No one to talk to." That loop doesn't really get us anywhere.
I've been feeling the same thing, it's a real shame.
Why most Ada projects host either on sourceforge or launchpad. Both raise the entry barrier of contributing to a project in comparison with github/bitbucket. Heck, even a custom git/hg repo is much nicer to work with than those bloated (SF) or unintuitive (LP) websites.
Thanks 😈
Shame nobody will be able to use it for closed commercial apps due to the libs and tools being GPL'd, I'd be happy to hear if this is not the case.
Hmmm, this would be a fertile area for some additional investigation to see just how far this kind of introspection could be taken!
Aside from the comment which notes that MKS was replaced by SI 40 years ago, what's with this misuse of abbreviations and capitalisation? System.Dim.Mks FFS.
Manuals are certainly good source of information, but I also like to read and analyze code written by others and learn from other programmers. Anyone knows public ADA2012 source code that nicely demonstrates the new features? 
I read this yesterday, and found it quite interesting. I think one thing missing from the discussion however is that not only does Ada do a lot to keep bugs out of your code, it's also taught to people in a way where from the start, they're working to avoid bugs. It's a different mindset from C, not many people go into writing a C program thinking 'how can I design this so there's a few bugs a possible?', it's often an afterthought. In Ada, you're constantly thinking about the domain of your problems and how you can use the type system to enforce the invariants of your program. I don't think the wight with which safety is taught when teaching is mentioned often enough and it's a shame. My other peeve with commentary on Ada that I've read is that the authors seem to assume people will understand what words like 'rendezvous' mean, and so much more about the concurrency aspects of Ada. I have a feeling many C programmers don't see a need for Ada because they're used to writing either foreground interrupt/background main loop code, and feel that's good enough for them, or that an RTOS is good enough to get the job done. I'm always of the opinion that the more the compiler knows about your system, the better job it can do, and you can have an Ada compiler know absolutely everything about the code part of your system (it knows how threads interact and can then use more efficient scheduling for example). Anyway, that's enough for one morning, time to go to work.
No it belongs to Frederic Boyer: https://plus.google.com/114442651972982900363/posts/iAZcTguxSsd
Everyone's certainly going to have their own preferences (and clenches :-). I think the value of something like this is to lay down a baseline for all those areas where one doesn't have a particularly strong opinion. If you can live with what's there, be it this Ada or any other programming language style guide, then you don't have to think about those areas any more. 
All you European types: Tweet, Hangout, blog, etc., you know, all that social network stuff.
"Aonix ObjectAda® 9.0 for Windows is a major new release with significant support for many of the new language features in Ada 2005..." Still kickin' but hardly up to date. Better than the no 2005 support I get with Green Hills though I suppose!
Windows only? WTF...
I report, you debug! :-) :-)
Aonix has been highly Windows-centric with their Ada products. Since this one company was willing to invest significant resources on what is still the most popular OS, I begrudge them nothing.
It will also be available in GCC 4.8. Mind you, I'm not sure that there isn't a bug in there somewhere ... see comment in the Gem.
But that's just the point: Windows is only the most popular OS on the desktop. On the server it is not the same situation. Ada is a perfect fit for server-software where stability and security usually is first priority, and yet all we have to play with is GNAT. I don't begrudge Aonix anything, and I'm not sad that we "only" have GNAT. I merely _wonder_ why a company would choose not to make their product available on what is the most popular OS for server-side software. The Unices are sitting comfortably on +60% of the servers globally, and I'm sure the remaining Windows powered servers are mostly used for Exchange/Sharepoint, ie. boring stuff. People doing exciting stuff server-side is doing it on Linux/BSD. Windows is not even a player in that field. Ada deserves having at least a couple of compilers available. :) Maybe we should do a kickstarter and see if we could round up enough cash to convince someone (Aonix, Irvine, whoever) to port their Windows only compilers to Linux/BSD?
This is really interesting. I work in aerospace, where we have a huge library of software in Ada and we are experimenting with making mobile platforms on Android and iOS devices. Our current approach was to re-write some of the components in C so that they can be used via JNI for Android and directly in iOS. This makes an interesting case to try using the Ada code directly. 
While they're referring to Interfacing to Java in general, rather than Android, AdaCore's [Gems 55-58](http://www.adacore.com/adaanswers/gems/P80) go over how to do that interfacing.
Thanks for pointing this out.
This allegedly has been passed around enough to help bring a few more folks into the `#ada` channel on [Freenode](http://freenode.net). It would seem that Ada 2012 is getting enough marketing push from AdaCore and interest from the developer community to garner interest from Java/C developers.
Man, I was totally going to post this two days ago but didn't because I'd assumed you'd beaten me to it already! I'm very excited about this, hoping to get my hands on a copy sometime soonish. I see they still haven't updated their list of supported platforms for GNAT Pro Safety-Critical.
It's about time, well, it's actually a bit late. I was disappointed when I saw some comments on a previous embedded.com link where many developers were lamenting the fact that Ada on ARM wasn't realistic and that led them down the road of C/C++. Hopefully this starts to take off so embedded devs use Ada more!
I've suspected there's been a concerted push from AdaCore. I've seen a significant uptick in the last few months in the number of Ada articles published in industry magazines, the overwhelming majority of which are being authored by AdaCore employees. Kudos to them! And also, Ada postings to /r/programming are much more likely to get upvoted and hang around for awhile, rather than getting downvoted to hell right away like they were a couple/three years ago.
Wha.... cool?
Only one of Micheal Dickens' students would be so masochistic as to do this in Ada.
Glad to see that Atego isn't treating Apex as just a legacy product whose only value is squeezing it for a few last dollars/euros of revenue.
Apex was bulletproof, hope they have kept the quality.
John Carmack made me do it http://www.youtube.com/watch?v=00Q9-ftiPVQ (15:30)
"My God, how can you write programs where you're just assigning random shit to random shit...." Best. Quote. Ever. I've always enjoyed listening to Carmack. Bright fellow.
No problem you will get a lot of help from people here, it is just to ask, even specific language questions. I hope you stick with Ada as it is a fantastic way of learning some deep lessons about programming over all, it is a fantastically powerful language in the right hands. It may seem a bit wordy, but don't forget the design goal was a language that is readable and maintainable, it was a response to huge unmaintainable military code bases. Ada guides you to structure your programs in a logical and a good way, it is a pleasure to work with strongly typed languages when you have worked with C languages. Ada lacks somewhat in library support but there are bindings for most things if you look around. 
There's nothing wrong with Ada 95. I'm studying to become an engineer here in Sweden, and my program (Industrial engineering) among others have courses in Ada 95. 
I want to learn too and in my opinion, most of the material out there sucks. I'm going through this tutorial for Ada 95, http://www.infres.enst.fr/~pautet/Ada95/a95list.htm. What I like about it is it uses simple examples to explain concepts. In my opinion, in just about any language, the material at times will use convoluted examples to explain concepts, I've yet to see the author do that here. Another thing I like about it is it explains concepts well whereas material I find in Ada 2005, they merely gloss over. I bought a book on Ada a few years ago and the book merely glossed over the concept of packages, but not the author of this linked tutorial. Of all the materials out there for any language, I like this authors style. Maybe others think this tutorial is too dumbed down but it works well for me who is literally trying to teach myself programming on my own. Teaching myself programming, for every language I try to learn, there is always a point in the material where the author glosses over a concept. I've yet to find the author of this material gloss over something. I'm basically learning Ada 95 in order to learn Ada (future) because so far I find anything on Ada (future) inadequate.
As the changes from Ada 95 to Ada 2005 and on to Ada 2012 generally all can be seen as extensions to the language, it isn't that bad to start by learning Ada 95 and then moving on using the on-line materials describing the changes. Still, you are right that it would be better if we had some complete, on-line tutorials for the newest version(s) of the language. Some hints for your studies: * Type invariants should really be learnt together with the type system. * Pre- and post-conditions should really be learnt together with subprogram declarations. * The "for ... of ... loop" syntax should really be learnt together with the other loop constructs. * As pragmas are obsolescent, only the (new) aspect syntax should be taught. 
So this is useless? pragma License (Modified_GPL); I kind of wish the combination of choice of compiler and licensing were not so convoluted. If I want to make my own commercial software, will I have to pay AdaCore or could I end up accidentally opensourcing it with GPL (I'm not against GPL by the way).
I'm thinking that at some point we're going to need to create /r/TerosAdaLab to do justice to Tero's projects! 
Related blog entry: http://olimex.wordpress.com/2013/03/20/mod-lcd3310-example-with-olimexino-328-arduino-uno-written-in-ada-language/ More or less accidentally, now also one Bulgarian company knows that Ada is still used. :) (I bought the stuff mentioned in my article from Olimex/Bulgaria and had to have some discussion with support to figure out all the details of the devices.)
The latest package in the download section is 3 years old. Anyone knows if this tool is still used/maintained?
The latest commit in the [git log](https://forge.open-do.org/plugins/scmgit/cgi-bin/gitweb.cgi?p=xreq/xreq.git;a=log) is from December 20th of 2012, so I'm assuming it's still maintained at the very least :)
CORBAfied!
&gt; I think you are mixing things up. Can you clarify it a bit?
Cool. I like the ability to subtype arbitrary elements as opposed to strictly consecutive ranges.
Note: There's a bug in the article regarding the illustration of the use of Static_Predicates. I let AdaCore know and they're in the process of getting it fixed. Anyhow, here's a little test program I wrote to illustrate non-consecutive enumerations: with Text_IO; use Text_IO; procedure NC_Enums is type Month is (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec); subtype Long_Month is Month with --Static_Predicate =&gt; Long_Month in (Jan, Mar, May, Jul, Aug, Oct, Dec); Static_Predicate =&gt; Long_Month in Jan | Mar | May | Jul | Aug | Oct | Dec; subtype Short_Month is Month with --Static_Predicate =&gt; Short_Month in (Apr, Jun, Sep, Nov); Static_Predicate =&gt; Short_Month in Apr | Jun | Sep | Nov; begin Put_Line("Long month list"); for M in Long_Month loop Put(Long_Month'Image(M) &amp; " "); end loop; New_Line(2); Put_Line("Short month list"); for M in Short_Month loop Put(Short_Month'Image(M) &amp; " "); end loop; New_Line; end NC_Enums; 
&gt; The book does a good job of showing how CORBA can enhance some of the ambiguity and unspecified mechanisms in Ada's Distributed Systems Annex CORBA! I thought CORBA was long dead. Does CORBA have a strong association with Ada that I'm not aware of? I don't mean to troll; I just would have expected a contemporary book to address distributed systems with contemporary technologies. (But it's just a nitpick, really, I'm looking forward to reading the book.)
A comparaison of Ada distributed systems annex and CORBA was published as early as 1999: http://www.rfc1149.net/download/documents/rst99.pdf
The last remaining stronghold of CORBA (and its brethren, DDS) is in the defense industry, where Ada retains a significant presence.
Is it me, or is there nothing in those links?
There is something strange going on with that page. Links to the videos: part 1: http://www.youtube.com/watch?v=H_uUNP3YoBA part 2: http://www.youtube.com/watch?v=wgtDYk-Q0Qg 
Thanks for the update.
Direct link: http://www.youtube.com/watch?v=00Q9-ftiPVQ#t=15m30s
Kudos to the Altran/AdaCore team that pulled this off. This gets a significant foot in the door, with the potential of a huge downstream payoff--for the companies, Ada, SPARK, the auto industry, and public safety.
I'd rather everybody spend time making great Ada-based software, you can keep reaping in the karma ;)
Yeah, r/ada, THE path to karma dominance :-) :-)
There's just no catching up to marc-kd! I'm sooooooo far behind. :D
very nice
Interestingly, the process that creates your download ZIP does not remove duplicates. I wanted to check after reading Robert Dewar's introduction to [contract based programming Ada 2012, Dr.Dobb's](http://www.drdobbs.com/architecture-and-design/ada-2012-ada-with-contracts/240150569) which uses a de-duplication procedure as an example ;)
Just noticed that both AUnit (unit test framework) and XML/Ada are both included as part of the default GNAT GPL 2013 download. No longer need to install them separately.
The author writes: &gt; I shall define a "poet" as a non-engineer who develops software for a living. That being the case, what distinguishes an engineer from a poet in the context of software development? Certainly in the analysis and design phases, engineers are more pragmatic and have the knack for factoring complex problems into essential parts. This is cringe-worthy. So, all non-engineers are poets, now? And all engineers are more pragmatic and have better factoring skills, merely by the virtue of being engineers? Really? - Non-engineers are more than capable of embracing software engineering practices; - Some engineers are not at all pragmatic (in spite of their extensive training); - There's no evidence that engineers have better factoring skills -- or if there is, the author has certainly not presented it. To suggest such a thing without evidence shows a disregard for empiricism -- an attitude I would associate with "poets" more than "engineers"; - By denigrating the "poets" with their limited skills, the author reinforces a false divide between communities, turning software engineering (and by extension in his article, turning Ada 2012) into a privileged club that only iron-ring bearers may join, and shunning non-engineers into a ghetto. What a terrible message to convey in an Ada advocacy piece. The rest of the article hinges on this fallacious premise: &gt; If a manager of an IT department wants to separate the engineers from the poets the simplest way is to provide each developer with the option of using either Ada or Java / C++. All things being equal (job security, career advancement, etc.) the engineers will choose Ada. That's ridiculous. First, show me the evidence that this is the "simplest way" to separate the two groups. Have you studied this problem? Have any data to support your claims? Second, there are countless scores of engineers who would choose Java or C++ -- because that's where their skill set is, or that's the cultural norm where they work, or because of massive communities, or the reams of available third-party code. (Yes, not all engineers write every layer of their system from scratch, in-house.) I am not an engineer; and where I live, I couldn't call myself an engineer, even if I wanted too, because I'm not a P.Eng. But I am certainly no poet. I love Ada 2012, and would encourage anyone who's building a complex, safety-critical system to consider it strongly before settling on a more familiar language. I'm offended by this notion that, for lack of an iron ring, I'm some kind of hipster wannabe who has poor skills and an inability to choose appropriate technologies. Articles like this, and the mindset behind them, will only make it harder for the Ada community to grow.
I'm glad that you posted it --- even if my blood pressure is a bit elevated this morning as a consequence. :) 
Thank you for posting this -- doubly so for bringing attention to `comp.lang.ada`, which seems like quite an active community!
Ha! I was on Usenet for a while back then: before Eternal September, but not quite back to teletype days. :) So many Usenet groups have dried up since social media took off... I'm glad to see this one is still trucking along (even if it's been somewhat co-opted by Google Groups!).
For those, who don't know: Sphinx is a tool to generate documents from reStructuredText files: http://sphinx-doc.org/latest/ The Python language itself uses it for documentation, and also Adacore uses Sphinx for some of their docs (like http://docs.adacore.com/gnatcoll-docs/ ). I suspect that they don't use my extension but instead their own or nothing at all. (My extension mostly adds some helpers for Ada language, but it isn't 100% necessary to have it for Ada docs.) sphinxcontrib-adadomain is required if you want to build Ahven's documentation (http://docs.ahven-framework.com/2.3/) from scratch. Earlier, you had to clone the sphinxcontrib repository and install adadomain manually, but after 0.1 release, you can use 'pip' or some other similar tool to install it. 
Ditto, I have seen statements like that before. The only vague justifications I have seen stem from the way Ada has been used historically in industry (apparently, I have only used it in a majority OO manner).
I don't suppose any of the authors are lurking here? There's an odd error on page 14; the "package Encryptable_Pkg" example is unexpectedly repeated from page 13.
Sorry that you're not getting any response on this. Eclipse just doesn't have a big presence amongst GNAT Ada developers, it's pretty much either GPS or Emacs. (Yes, yes, vi, etc. Peace!) You're fully welcome to send a report of your experience to "report@adacore.com". They do read these, and though you're unlikely to hear anything back as I'm guessing you're an unsupported user, it does go into their "bug database" as something to eventually be addressed. You might also try asking on comp.lang.ada, there's a fairly diverse user base there, some of whom may be more Eclipse-savvy.
thank you!
232 signatures so far.
"IRONSIDES not only has better security properties than the two most popular DNS servers, but outperforms them as well." !!
Simon, you need to get spreading the word over there!! :-)
I haven't used SPARK, but I'm impressed that the SPARK annotations only comprised about 10% of the code. One thing not addressed here was a formal verification of the underlying stack. It seems to me that a flaw in, say, `libc` or `libpthread`, or the network stack, could potentially be exploited. This doesn't detract from their result; it just makes me wonder about the challenges of end-to-end verifying a layered system (such as an app on a general purpose operating system, plus drivers, etc.). 
Why would you put her on anything? She didn't do anything of importance.
Got it working. gnatbench doesn't work with the 64bit version of eclipse on windows.
SPARK Intro [PowerPoint slides](http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=9&amp;cad=rja&amp;ved=0CH8QFjAI&amp;url=http%3A%2F%2Fcs.nyu.edu%2Fcourses%2Ffall01%2FG22.3033-007%2Fspintro.ppt&amp;ei=oK7aUf2pH5TI9QTF8oDYDQ&amp;usg=AFQjCNH3dhgLVXVcSdJDYPdcDrD-elkOBg&amp;sig2=3SUT73k-Tje4mtFYfZDqzw&amp;bvm=bv.48705608,d.eWU). Collection of Ada Gems [about SPARK](http://www.adacore.com/adaanswers/gems/category/sparkpro). (Start with 68 and 69).
So how'd you get it working?
I used the 32-bit version of eclipse. I should've read the gnat readme more closely. Says: "Note the requirement for a 32-bit Eclipse version on Windows and Solaris." 
Some tutorial material from Phil Thornley at [SparkSure](http://www.sparksure.com/).
I've always been kinda leery about using 'renames' a whole lot. Some of which probably traces back to the rampant abuse of the feature early on in my Ada career (back in the 80, yikes!). It seemed to be common practice--at least where I was working then--to start off a package body with a block of renames clauses, shortening the names of all the packages that were being 'withed' into something acronymical. E.g. package AVFA renames Air_Vehicle_Flight_Algorithms; package AVCI renames Avionics_Command_Interface; Okay, maybe the package names were a *bit* long, but trying to decipher a block of code infested with three- and four-letter acronyms was no piece of cheese. We were also pretty much forbidden from using 'use' clauses, so you either ended up with sometimes verbose selected.notation, or went the package renaming route. Decades later I've established a comfortable practice with 'renames' and 'use'. I still am very unlikely to use 'renames' just to shorten a package name, I will use it to reduce naming confusion though: I've done some work with [0mq](http://www.zeromq.org/) and the [Ada binding](http://www.zeromq.org/bindings:ada) to it. In the binding there's a Zmq.Sockets package, and when you've also got GNAT.Sockets and a plain Sockets package floating around, renaming Zmq.Sockets to ZSockets can be an opportunity to add clarity. Also, as described in the article about renaming to get a record field... &gt; DoB : DATE_TYPE renames Workers(I).Birthday; I've used it in a similar manner, mainly to cut down the verbiage of an extended reference such as that quoted above. Lastly, the one situation in which I am quite promiscuous about renaming is using 'renames' on operators when needing to do "conversions" of one sort or another. In any of my code that's working with strings you'll see: function "+"(S : String) return Unbounded_String renames To_Unbounded_String; function "-"(U : Unbounded_String) return String renames To_String; Situations where I need to convert a value from one representation to another, and that aren't simple type conversions, are where you'll find me throwing 'renames' clauses all around.
Ha, there's a funny old picture of my dad in there :)
Tell him! Will he be impressed that he's on the front page of a sub-reddit? :-) :-)
Characteristically, he was very modest about it :)
I had lunch with him once about a dozen years ago, and some time later worked on a project where he had written the original code that I was porting. Apparently he was also one to contribute patches to the GNAT compiler. 
Here's a [local news report](http://www.waff.com/story/22901802/man-killed-in-wreck-with-unlicensed-minor) on the accident, with video.
Find the 'inject_begin()' and 'inject_end()' methods and modify the 'CurrentLineOut =' statement in those to do whatever you want, e.g. Put_Line("Entering ..."). The script does have limitations. Read the author's header comments.
I have an OpenGL binding I'm working on (it's going under some major restructuring) -- https://github.com/OneWingedShark/TAO-GL There's two goals for the binding: 1: thickness -- I don't want to have pointers/addresses in parameters if avoidable (there are several places I don't yet see how to avoid exposing the address). 2: type-safety/strong/types -- in OpenGL there's these object enumerators, like # of lights that are variant on the executing platform and so cannot be statically determined [unless you forgo possible excesses by assuming absolute guaranteed minimums]. The way that this can be properly handled is by use of the elaboration of generic packages say that we have a formal parameter NUMBER_OF_LIGHTS which we have the default value be the query to get the number of light-objects the video-card supports; assuming it returns 32, we can then say: Type Light is new Enumeration range 0..NUMBER_OF_LIGHTS-1; which will give us the proper enumeration of 0..31 as well as prevent doing something stupid like adding working_texture and working_light variables together.
Concerning this portion of the example: RainBow : array (Colour_T) of float := -- VIOLET, BLUE, GREEN, YELLOW, ORANGE, RED ( 450.0, 495.0, 570.0, 590.0, 620.0, 750.0 ); There's an even better way to indicate which indices are associated with which values: -- Rainbow contains the frequencies of the associated colors. Rainbow : array (Color_T) of float := (VIOLET =&gt; 450.0, BLUE =&gt; 495.0, GREEN =&gt; 570.0, YELLOW =&gt; 590.0, ORANGE =&gt; 620.0, RED =&gt; 750.0); As you can see here, the comment will never "go stale" and the intent given in the first comment is perfectly supported by the language itself. There are some minor nits to pick on in the examples (like why he's using `Float` instead of a fixed-point, or using the _T suffix) but those are [mostly] irrelevant to the subject of readability.
How is this an improvement compared to Paraffin? (https://sourceforge.net/projects/paraffin/)
That's what Randy Brudardt [wanted to know](https://groups.google.com/forum/#!topic/comp.lang.ada/Tlj_mZCXVL0)!
On Mac, gnatmake doesn't know how to build dynamic libraries using RPATH properly, you might have some luck using it instead of gprbuild; but AdaCore might fix the Mac bug! (and of course you may have a mixed language project, so you need gprbuild). Google suggests chrpath or patchelf (looks as though chrpath is available in Debian?) Linking to other libraries - use Library_Options - http://docs.adacore.com/gprbuild-docs/html/gprbuild_ug.html#Building-Libraries
fresh version of gprbuild has -R option for this: $ gprbuild --help -R Do not use run path option Not sure how old gprbuild in Debian however... 
I should've figured to look there -- thanks for the help; it works!
I went with the other solution for disabling RPATH (gprbuild -R), but for linking in other libraries, using Library_Options works. Thanks!
-R is by far the better way. My usual problem is getting the build to *include* rpath!
I'm not sure it is quite what you're looking for, but the book "Building Parallel, Embedded, and Real-Time Applications with Ada" is pretty good at explaining tasking in Ada.
Another option is lesson 13 in the "[Ada 95 Lovelace Tutorial](http://www.dwheeler.com/lovelace/lesson13.htm)", but doesn't go into the same depth as "Building Parallel, Embedded, and Real-Time Applications with Ada".
Flash and Powerpoint? Seriously?
As we have no idea what your code looks like, it's awfully hard to try to answer this question.
(And yes, I know that these benchmarks are somewhat contrived and artificial, it's still pretty cool though.)
Would that be [Specification and Description Language](http://en.wikipedia.org/wiki/Specification_and_Description_Language) or [Simple DirectMedia Layer](http://en.wikipedia.org/wiki/Simple_DirectMedia_Layer)? If you want a binding to either, go for it!
See also comp.lang.ada [thread](https://groups.google.com/forum/?hl=en#!topic/comp.lang.ada/afb8KEof7Ek).
Ada's a great language! It's main focus is Engineering. It's used a lot in Aviation and Aerospace. Basically, if something has to be done correctly, Ada's the language of choice. Make the best of it, you won't be sorry. Here is a video of a few people hyping Ada. http://www.ada2012.org/passion.html As far as help, check out the Usenet newsgroup comp.lang.ada
Also, don't start your post titles with "So". It's a lame meme and everyone is tired of it.
I'll be answering in reverse order of the questions presented. &gt; Are there any online resources to go to when I need help? Ada **is** a bit light on its online material, true. The [Rationale](http://www.ada-auth.org/standards/rationale12.html), [Language Reference Manual](http://www.ada-auth.org/standards/ada12.html), and [wikibook](http://en.wikibooks.org/wiki/Ada_Programming) are pretty high-quality, and freely available. There's a few intros/tutorials online, but I'm not sure of the quality of any; here's [part 1](http://blog.projectpolymath.org/ada-2012-tutorial_01/) and [2](http://blog.projectpolymath.org/ada-2012-tutorial_02/) of a few I started and didn't finish. &gt; Why do you think I'm being taught ada instead of another language? Despite the claims of it being a verbose, unwieldy, complex language; programming in Ada will teach you some good software-engineering habits. Also, it has some features that play well with each other and allow good decomposition of your problem-space: types, packages, generics, and tasks spring immediately to mind. &gt; My questions are what sets ada apart from other languages? One thing that sets it apart is design, there's a lot of languages out there that were 'grown' instead of designed. (PHP and C++ spring to mind.) Another thing is the priorities/goals for the design: Ada is one of the few languages that emphasizes maintainability as a design-goal. (When you get into the field you will likely come to appreciate this quality because much of the programmer's time is put into maintaining/extending projects/codebases rather than going ground-up.) &gt; Everyone I've talked to about this who has a programming background says its weird and very unpractical as a first language to learn. I very much disagree. Many popular OOP languages have boilerplate syntax that "should be ignored" by the student until they have basics of the basics down (like conditionals/dataflow, processing, and likely compound-objects); by introducing/exposing these unnecessary details to the students you're introducing stumbling-blocks. -- With Ada though, you can start out teaching the procedural-style, then add in type-derivation (which *is* inheritance [though very basic]), then packages (which *is* the concept of encapsulation), then generics (which *is* abstraction, and can be used to create static-polymorphism)... and by then you have all four [major characteristics of OOP](http://www.careerride.com/oops-characteristics.aspx) before having even touched objects ("tagged types" in Ada). So there *is* a **lot** of sense in using Ada as a first programming-language. ----------------- PS -- Another excelent feature of Ada is `subtype`, **many** problems can be drastically reduced or avoided completely by [further] restricting valid values from a type. Example: -- Just a stub-type. Type Window is tagged null record; -- A pointer to a window. Type Handle is access Window'Class; -- A pointer to a window excluding Null. subtype Safe_Handle is Not null Handle; -- A function, inside which you never have -- to check for Null parameters. Function Is_Minimized( Win : Safe_Handle ) return Boolean; -- A single digit. Subtype Digit is Character range '0'..'9'; -- A numeric-string, using Ada 2012: Subtype Part_Number is String with Dynamic_Predicate =&gt; (for all C of Part_Number =&gt; C in '-'|Digit); PPS -- The `The Fundamental Theory of Ada` already mentioned on-thread is an **excellent** read.
I read that article; it is *excellent*! Thank you for writing it.
&gt; The problem is that the instructor has to be aware that Ada can be taught this way and decides to teach it this way. This is true... Though I do have some trouble imagining that possibility escaping anyone (of reasonable intelligence, whose job is to teach intro to CS).
Ha! You'd be surprised. I've had professors try and teach C that don't know what a pointer is. I've had professors dock points for using recursion because they didn't understand the code. Granted, someone who has decided to teach Ada is probably competent. 
&gt; Ha! You'd be surprised. You're probably right. &gt; I've had professors try and teach C that don't know what a pointer is. Er... how? Once you touch on arrays (and especially C's *lack* of bound-checking, pointers naturally come to the surface. &gt; I've had professors dock points for using recursion because they didn't understand the code. *sigh* -- I can see that happening, though if you comment it there's little chance of that: Pragma Ada_2012; with Ada.Characters.Handling; Package String_Ops with Pure is Function Trim( Input : String ) return String; Private Use Ada.Characters.Handling; -- Ada.Strings.Fixed (or similar) cannot be used in a pure unit, that -- however does not prohibit the implementation in a pure function. -- The value returned is the string itself when the initial character is -- graphic, but when it is not only the tail of the string, which is -- passed into itself, thus ensuring all whitspace is removed from the -- end. Function Trim_End( Input : String; Front: Boolean ) return String is (if Front then (if not Is_Graphic( Input(Input'First) ) then Trim_End(Input(Positive'Succ(Input'First)..Input'Last), Front) else Input) else (if not Is_Graphic( Input(Input'Last) ) then Trim_End(Input(Input'First..Positive'Pred(Input'Last)), Front) else Input) ); Function Trim( Input : String ) return String is ( Trim_End( Trim_End(Input, False), True) ); End String_ops; &gt; Granted, someone who has decided to teach Ada is probably competent. We should hope so anyway. On the topic of the suitability of Ada for teaching there's these [two](http://people.cs.kuleuven.be/~dirk/ada-why.html) [links](http://people.cs.kuleuven.be/~dirk/ada-why2.html).
I would bet most of the people you spoke to have either never heard of Ada or have heard of it from someone who doesn't know what they are talking about and they are most likely C/C++/Java/etc programmers who think that that language is the only one in existance.
As for the verbosity point, it wouldn't matter with a decent IDE, unfortunately, there isn't one, only part-way decent ones.
I'm guessin' that not too many people on this forum have any experience with it. I'd love to be proven wrong though.
Well, it's not actually surprising at all :-) First, the end tag has to match the unit name: &gt;task TickerTask is end **SimulatorTask**; Should be "end TickerTask;" You can't compile a task alone in a file, a task has to be embedded within a unit, normally a package. (Maybe you did that, but you only provided the task code here.) Ada allows **either** a delay alternative **or** a terminate alternative, [you cannot have both](http://www.ada-auth.org/standards/12rm/html/RM-9-7-1.html#p8). If your intent is to have a ticker running until the program shuts down, you have to have some way of notifying this task that it's time to shut down. E.g.: task TickerTask is entry Shutdown; end SimulatorTask; task body TickerTask is begin loop select accept Shutdown; exit; or delay 1.0; Text_IO.Put_Line (Text_IO.Standard_Error, "Tick!"); end select; end loop; end TickerTask; One can't expect a task to shut down (via a terminate alternative) when the rest of the program does, because how is this task supposed to know that *it too* is also supposed to shut down? After all, it's still actively ticking.
The "safety" aspect seems to be rooted in certain semantic aspects of the functionality and how it's the application's responsibility to set things up right to ensure that everything works correctly. There's a rather [technical writeup](http://www.open-std.org/JTC1/SC22/WG15/docs/rr/14519/14519-10.html) questioning the inclusion of these functions as part of the standard that sheds a little light, if one can follow it :-)
Forking a process results in a long list of process environment changes: changing of process ID, resetting of interval timers, non-inheritance of parent's locks on shared memory, non-cloning of threads, etc. While these effects are specified in POSIX, they are thorny and complex enough that I would consider any fork() that's not immediately followed by exec() to be an inherently unsafe operation, in any language. So "Unsafe" seems like a good warning to the engineer: you'd better be certain that you know what you're doing!
[Cross posted](http://www.reddit.com/r/programming/comments/1qalbw/phoronix_gcc_looks_to_turn_off_java_replace_with/)
GCC/Ada's back end is C (or now C++, I believe) so having the front end verifiable would only go part way. And, personally, I've found the front end fairly opaque, which would be a Bad Thing in a verification context.
&gt; GCC/Ada's back end is C (or now C++, I believe) so having the front end verifiable would only go part way. Right, but having Ada be in the default-deployment makes it easier for backend stuff to be rewritten in Ada. &gt; And, personally, I've found the front end fairly opaque, which would be a Bad Thing in a verification context. That might be; I'm no expert in compiler front-ends, so I have no way to grade it.
There's [TclAdaShell](https://sourceforge.net/projects/tcladashell/), a binding to Tcl/Tk.
Hmm, I don't know much about Tk. Is it small enough to be statically linked without making the binary huge? Am I going to have weird dependency issues? 
OpenGL is an option but it might be a bit low level for what you want.
It depends on what you want to do. You can use GLUT. I'm not sure if thick bindings are available for OpenGL itself but the c imports work well enough. The way we use it is we built our own custom library for the things we want to do mostly in Ada, but at the lowest level, it makes OpenGL function calls (using thin bindings). It takes a bit to set up, but once you do it's cross platform.
If this is for 3D, I would recommend testing Globe3D (http://globe3d.sourceforge.net/ ) and as Gautier always takes care about portability, I think it could be a good starting point.
He's also very responsive to questions.
The direction I went with the applications I've developed was to have the core processing all implemented in Ada, which then communicates via ZeroMQ and JSON to a GUI written in Python with PyGtk.
oooh, that sounds like a good idea! I'm not the biggest fan of Python, but obviously one could substitute any other scripting language there. Thanks so much for the tip!
Good luck and nice scripting, Ada lover! ;)
Thanks!
Wow, that looks excellent. OpenGL it is then I guess!
Are you sure? It says Open**GL** specifically several times there.
I haven't looked, but flyx mentions both.
Personally, what I would really like to see is an Ada front end for LLVM.
I thought the same thing I thought of previous releases "neat, okay back to normal Ada." For me, most of my work is going to involve `String` types and sockets, both of which are already practically a PITA on Ada 2012, and impossible to work with in SPARK :(
I can't compile and check this, but one thing that strikes me is the location of the line: Result (Row, Col) := Element; Immediately following this is the Col2 loop that updates the Element variable, but that calculated value never makes it into the Result on the final iteration through the Row2 loop. 
We'd have preferred you not have deleted it, because its presence could help others learn if they run into a similar problem in the future.
Sorry about that, I'll keep this in mind for future posts.
Pretty decent [comment threads](http://redd.it/1sjyop) when this was posted in /r/programming.
H/T [@tkoskine](https://twitter.com/tkoskine)
Nailed it :-) I figure we could all use more followers -- [@That_MarcC](https://twitter.com/That_MarcC)
As of now, the schedule isn't posted. Personally I'm hoping to see something from the Ada Heads (/u/ThomasLocke, and Co.) on real-world "modern" Ada projects :)
&gt; Personally I'm hoping to see something from the Ada Heads on real-world "modern" Ada projects :) If they do, I hope they make their presentations available for those of us that won't be able to make it.
From what I can see as I follow along, this looks fantastic! But just a video overview like this has problems. It goes so fast that it's difficult to follow along. There's too little explanatory information in the captions. As a video it would be easier to follow if it were about three times as long, with a running commentary + captions of what is being done and why. An additional approach would be as something like a tutorial, with numerous screenshots and explanations of each step of the way. Such things are time-consuming and tedious to create, but when done well provide the a deeper explanation of how to exploit a tool like this. Once one has the basic familiarity with the tool's operations through such a tutorial, it becomes much easier to follow along in a video.
Yeah, I would. Ada's a great language. I'd take it over C++ any day. I'd even hire those that don't know Ada and teach it to them.
&gt; The tools really aren't bad, the ostensibly benevolent guardian of GNAT, AdaCore is really obnoxious and I don't think GNAT Pro is really all that great. The tools could use a bit of "sprucing up", but overall Ada itself seems to lend itself to a better quality of tool for the same amount of effort of a C-language tool. I have had generally good experiences with AdaCore and reporting bugs -- I got a reply from Mr Dewar himself twice (for reporting a bug in task/access-type interaction). I will agree that the Ada community could use another freely available Ada compiler... I've been kicking the idea around of starting up such a project. -- I think doubling down on the Library idea from Ada 83 could yield some good results: having the source [extended AST] stored in a DB, along with compilation-units could prove useful -- imagine having style-changes to source being a function of the viewer and not a 'change' in versioning and always having a working/compilable system saved/'registered'.
&gt; I'd even hire those that don't know Ada and teach it to them. Thank you! I am rather disgusted with the anti-training attitude in the industry.
I think this is a fair analysis. As far as UI's go, you can do them in Ada but it's not as quick (development speed wise) as Python would be. To do this you'll import a graphical library such as OpenGL and essentially build up your own "tool kit". However, if you're willing to put in the effort for the upfront work, you can make quite nice and totally customizable UIs with Ada. Whether or not this will be worth it depends on the project size and duration. Basically creating your own UI library takes time but once it's done, it'll be just as easy to use as anything else (presumably easier since you put in it exactly what you need).
Stack Overflow [posting](http://stackoverflow.com/questions/22097042/when-declaring-a-float-range-0-10-0-what-do-i-have-to-watch-out-for) about its use. Also, [another](http://stackoverflow.com/questions/22097916/how-do-i-declare-a-non-inclusive-floating-point-range-in-ada).
What's the consensus on this kind of thing? I know it would be frowned upon in many languages (and Java was even designed to never allow this kind of thing) due to the ambiguity it creates for the reader who doesn't have the entire namespace in their head when reading it. I'm just getting started with Ada programming, but it would be interesting to get an Ada programmer's point of view on this.
Brilliant. Thanks to both you and /u/tkoskine. Coming from a ton of other imperative languages, the actual Ada syntax is not what's difficult for me/ It's the little cultural/style things like these that trip me up. You're being very helpful! Having the renamed function in a limited scope where it is useful and mostly unambiguous makes a lot of sense, and can even increase readability.
 Ada.Text_IO.Flush; -- just in case Ada.Text_IO.Close (Handle); The "just in case" comment scares me! Is there not an assurance that `.Close` will flush the file descriptor before releasing it?
So, under nominal circumstances, no, you don't have to explicitly Flush a file, Close takes care of that. And in doing this for thirty years, I've never seen it work any other way.
Yeah. I cannot reproduce my earlier "findings" anymore. Code behaves correctly even without any Flush on three different compilers (gnat, Janus/Ada, ICCAda) on 4 different platforms (Windows, Linux x84_64+arm, OpenBSD).
I have not worked with Ada in a while, but I think it's because the semantics of both are equivalent in this case.
The only time this has bitten me is when the procedure updated the out parameter and then raised an exception: the out parameter (a socket number) wasn’t updated. This took some finding. I ended up wrapping the socket number in a tagged object to make sure it was passed by-reference - [ARM 6.2](http://www.ada-auth.org/standards/12rm/html/RM-6-2.html).
I trust the exception was not raised by a language-defined check -- if it was, even an assignment to a by-reference parameter may not happen, or may be "disrupted" - ARM 11.6(6/3).
No, quite legit, as far as GNAT Pro for Android is concerned. The rest is hoping at this point.
You can already build android gnat from fsf sources
I liked the part where you think you're worth $50 an hour to not even write code.
There's a lot more to the project than *just* code --the fundamentals [foundational architectures] are especially important. An hour of design can cut off *days* of Debug-driven development; a good couple of days [or weeks] can cut that down by months. PS - Some really good DB-architects get more than $100 an hour.
So 7K for a database schema and website. Followed up (maybe) by a delphi implementation (of an Ada development environment). And if you get stuck, ask stackoverflow. (and as a side-effect: badly backronym your way into another OSS project's name) Sounds legit.
&gt; So 7K for a database schema and website. &gt; Followed up (maybe) by a delphi implementation (of an Ada development environment). Not "followed up" -- "as part of." The "follow up" would be the Ada 2012 compiler in Ada 2012 [possibly in Ada/SPARK]. (That is, bootstrapped.) &gt; And if you get stuck, ask stackoverflow. *shrug* -- It's been a long while since I've broken open Delphi for a serious project. I'll admit I'm rusty.
I have the Barnes *Ada 2005* book, it's excellent, a bit pricy bot absolutely worth it. The updated *Ada 2012* book just came out: [link](http://www.amazon.com/Programming-Ada-2012-John-Barnes/dp/110742481X/).
That's early! I wasn't expecting it for another month.
I've used this technique and effectively is very pain-free. Even if you need to work with the C internals, it might be enough to provide a small C wrapper that receives the pointer and do the messing there.
I have downloaded the sources of GNAT GPL 2014. gprbuild failed because GCC 4.9.0's GNAT.Command_Line does not contain Try_Help. Try to compile GNAT 2014, don't even know where to start. I am really curious if AdaCore is promoting their product or just releasing it to GCC team to incorporate it in future?
The 2014 version of binary files are much better than the 2013 because running gps is fine with 2014 while I have a crash with gps 2013.
Well, what level are you looking for? Basic? Advanced? Is it for you alone, or for a group who range in experience? What's the level of programming experience? Are you looking for continuing education from basic *through* advanced? An easy starting point is the "[Learn Ada](http://www.adaic.org/learn/materials/)" section at the Ada Information Clearinghouse.
Github has a collection of links to books on programming. Here is the link to Ada's books: https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#ada
I'm currently working on game support stuff, but progress is slow. See http://www.sdlada.org for a start.
* [ada.cx](http://www.ada.cx) * [adacommons.com](http://www.adacommons.com) * [adaic.org](http://www.adaic.org)
You also have http://en.wikibooks.org/wiki/Ada_Programming It's far from complete and depending on what you're looking for and your skill level it might have or not have what you need. The reference manual can sometimes be a pain to read but is comprehensive. The book written by John Barnes on Ada is a great book: http://www.amazon.com/Programming-Ada-2012-John-Barnes/dp/110742481X/ref=sr_1_1?ie=UTF8&amp;qid=1403249325&amp;sr=8-1&amp;keywords=Programming+in+ada The link is for the 2012 version, just search for "Programming in Ada" for others versions, im currently using the 2005 version.
Planet Ada: [http://planet.ada.cx/](http://planet.ada.cx/) 
Thanks for the info Lucretia9. Your project does sound interesting, and if had the experience I would certainly offer to help. However, I was referring to an already existing library in the new GnatGPS. I send an email to AdaCore University about this, but I haven't gotten a respond. An automatic message that I received said: “Is being held until the list moderator can review it for approval. The reason it is being held: Post by non-member to a members-only list.” So I guess it is possible I may not get an answer; therefore if anyone is member of AdaCore, I would really appreciated if you could ask them about a tutorial or the documentation.
Here a list in .OPML format: &lt;opml version="1.1"&gt; &lt;head&gt; &lt;title&gt;FeedDemon Subscriptions&lt;/title&gt; &lt;dateModified&gt;Fri, 11 Apr 2014 10:02:31 GMT&lt;/dateModified&gt; &lt;/head&gt; &lt;body&gt; &lt;outline text="Ada"&gt; &lt;outline text="Planet Ada" title="Planet Ada" type="rss" xmlUrl="http://planet.ada.cx/rss20.xml" htmlUrl="http://planet.ada.cx/"/&gt; &lt;outline text="Ada Programming Language Tips" title="Ada Programming Language Tips" type="rss" xmlUrl="http://ada.tips/feeds/all.atom.xml" htmlUrl="http://ada.tips/"/&gt; &lt;outline text="Ada Resource Association" title="Ada Resource Association" type="rss" xmlUrl="http://www.adaic.org/feed/" htmlUrl="http://www.adaic.org"/&gt; &lt;outline text="AdaCore Latest Updates" title="AdaCore Latest Updates" type="rss" xmlUrl="http://www.adacore.com/rss/all" htmlUrl="http://www.adacore.com"/&gt; &lt;outline text="Green Hills Software: Leading the Embedded World" title="Green Hills Software: Leading the Embedded World" type="rss" xmlUrl="http://www.ghs.com/news/news_feed.xml" htmlUrl="http://www.ghs.com/news/index.html?referrer=rss"/&gt; &lt;outline text="Thomas Løcke Being Incoherent" title="Thomas Løcke Being Incoherent" type="rss" xmlUrl="http://blogs.fsfe.org/thomaslocke/feed/" htmlUrl="http://blogs.fsfe.org/thomaslocke"/&gt; &lt;outline text="Ada Rocks - EVERYWHERE" title="Ada Rocks - EVERYWHERE" type="rss" xmlUrl="http://adarocks.com/rss.xml" htmlUrl="http://adarocks.com/streamline"/&gt; &lt;outline text="Ada programming" title="Ada programming" type="rss" xmlUrl="http://ada-programming.blogspot.com/feeds/posts/default" htmlUrl="http://ada-programming.blogspot.com/" category="Ada programming,Building GCC,Eclipse,GNOME,Gtk+"/&gt; &lt;outline text="The Dark Energy Blog" title="The Dark Energy Blog" type="rss" xmlUrl="http://blog.spacesocket.com/feed/" htmlUrl="http://blog.spacesocket.com"/&gt; &lt;outline text="Ada: When the software HAS to work" title="Ada: When the software HAS to work" type="rss" xmlUrl="http://www.reddit.com/r/ada/.rss" htmlUrl="http://www.reddit.com/r/ada/"/&gt; &lt;/outline&gt; &lt;/body&gt; &lt;/opml&gt; 
thanks
http://www.canalada.org/ada-programming-news-feeds/
that was fabulous, thanks
Too bad none of the development is done in the open :( I'd really like to see the source checkins and perhaps even help with contributions, but periodic code drops make things quite unpleasant to work with
It provides just what clueless programmers want, unfortunately. FREEDOM!
At about 15:30 on [QuakeCon 2011 - John Carmack Keynote Q&amp;A](http://www.youtube.com/watch?v=00Q9-ftiPVQ) says: &gt; **I really have had somewhat of a conversion experience to the benefits of doing that [static checking] and it's almost like talking to a foreign culture to the dynamic-language people and I'm like "_My god, how can you write a real program where you're just assigning random shit to other shit and expecting it to work?_"**
That's why you have to test the hell out of everything with unit tests. You can't rely on the compiler to enforce the fact that parameter foo is an integer. You have to test that as part of your unit test. Unfortunately, complex objects are just objects, so it's hard to say something is a "health potion" object and not "horrible poison," without examining the contents of the object to see if it has something like "restoresHealth" field or a "renderedDeadInSeconds" field.
This post made my day. Thank you.
I remember nigh on 20 years ago discussing a possible contract in Switzerland who used Ada a lot in their banking. Having a native Fixed point type and strong typing (amongst other things) has its benefits in large scale financial software development.
Thanks for your answer! You've pretty much answered everything I needed to know.
What to do kinda depends on what kind of projects you're interested in. For some people, the idea of creating a libxml2 binding generator using the [XML API Description File](http://xmlsoft.org/libxml2-api.xml) would be "fun". Maybe not so much for others :-) Being more of a tools and utilities oriented kind of guy, one big task that would be very useful would be to start with an existing full-featured SDK, say that of Java or Python, and create a corresponding native Ada implementation of the packages and modules. Not necessarily a function-for-function clone, but use the existing SDK as a roadmap to dramatically expand the scope of Ada's library infrastructure. Or, if you have some application in mind you'd like to bring into existence, code it in Ada, and use that as your learning experience. 
I learnt Ada95 at uni and after working in the "games" world with C and C++ I burned out. The first thing I did was relearn Ada, mainly because I didn't touch a debugger once at uni. Ada 2012 is the current standard and imo the best it has ever been, there are some problems, but tbh, minor really. Ada is a general purpose language that can be used for anything, web apps - mobile (but you'd have to build your own compilers for those), but Ada is lacking library support unllike other languages, such as Java, which has loads of libs and tools. So, think of something you want to do and write it in Ada 2012 (make sure the gnat2012 flag is set which it will be on latest compilers). I wouldn't start with SPARK as that limits what you can do even more. 
Also, there an an IRC channel on Freenode #Ada, we hang around in there not doing much :D
Speaking of libraries, is there an equivalent to maven/npm/pip/gems for Ada?
Not yet. Jacob Sparre Anderson has put together a proposal for something like it, called go Ada, it's named after the equivalent in Go. 
Anyone knows more about SAVOIR? When will they release the specs to public? I am working on a very similar software architecture for automotive and would like to compare the concepts.
This thread is a little old. What are your thoughts in writing an arbitrary precision arithmetic library for generating primes, RSA, DSA, ECC crypto, etc.? I want to learn ADA since we're slowly introducing it in our workplace. I was already planning of doing a bignum library in C mostly out of interest, but I think ADA might make a lot more sense.
&gt; This thread is a little old. Considering the "velocity" of /r/Ada this is still new. &gt; What are your thoughts in writing an arbitrary precision arithmetic library for generating primes, RSA, DSA, ECC crypto, etc.? It would be cool; I think we'd have to implement or [link to it]^1 in any SSL [re-]implementation. (I'd have to re-read the RFC to see which encryption algorithm[s] it uses.) You can even make a `subtype` for prime-numbers, at least in Ada 2012: Subtype Prime_Number is Positive with Dynamic_Predicate =&gt; (if Prime_Number = 1 then false else (for all Index in 2..(Prime_Number+1)/2 =&gt; Prime_Number mod Index /= 0) ); The above isn't a bignum-prime subtype, but rather only primes over the native integer-range. &gt; I want to learn ADA^2 since we're slowly introducing it in our workplace. That's good to hear; if I might ask, which company are you working for? &gt; I was already planning of doing a bignum library in C mostly out of interest, but I think ADA might make a lot more sense. Go for it!^3 Just be aware of several things/differences in approach: * The separation of `spec` and `body` is more strict in Ada than .h-/.c-files. * Ada is [all about types](http://blog.kickin-the-darkness.com/2007/08/fundamental-theory-of-ada.html). * Pointers ["access types" in Ada parlance] are ***not*** needed for most things; embrace a "never use pointers" ideology and you'll probably balance out your instinct to reach for them first. (Callbacks are the usual exception; though even this can be mitigated if you are using Ada's generic facilities.) * Arrays are "smart" in Ada; they carry around attributes with them: `'First` for the first index, `'Last` for the last index, `'Range`for shorthand of `A'First..A'Last` (assuming `A` is the array). * Think of the compiler as your friend, pointing out Bad Stuff before it bites you; it's a different mentality when your compiler rejects things that are incorrect rather than accepting it [and letting you find there was an error in a core-dump]. ^1 - If we're talking a fully formally-verified SSL [or the like], linking to a library is a bad idea. (Because we don't ***know*** the library was proven.) ^2 - Ada; you'll get a little grief over ADA (American Dental Association)... it's kinda funny because in all other regards the Language is completely case-insensitive, excepting string-constant internals [obviously]. ^3 - The comp.lang.ada newsgroup has a good signal:noise ratio and the people there are generally pretty good w/ answering questions. #Ada on Freenode's IRC is also a good place to get help.
I am on meetup, but I don't really use it much yet. I doubt there would be many people attending a meetup anyway, maybe like 3 people as Ada doesn't have the coolest image. Ada is a great language and needs more people to realise it, if you can do something about that then cool :) Try setting up a meet up on meetup. Some of us are trying to get Ada used in different areas and to be accepted more. 
Thanks, I've just started reading *Ada 2012*, jumped ahead to Access Types, then gotta go back and read the rest, and then build some sideprojects with it. Any chance you're in South Bay or SF? Would love to grab coffee or a drink sometime.
&gt;maybe like 3 people as Ada doesn't have the coolest image. Typesafety and safe manual memory are the new hotness among the bleeding edge SV hacker crowd, it's just that it seems not many appreciate that Ada has been doing both for a long time now. As mentioned, Mozilla is even inventing a new language for it, rather than, say, improving GUI programming tools in ADA. Is Ada fully open source, or are there parts that are encumbered with proprietary licensing? That would be one reason it hasn't taken off.
I'm aware that Mozilla and Google are wasting their time developing new C's and Facebook are developing a new PHP, when Ada can actually do all of the above, bar weird functional programming, which I can do without. Ada is an open standard, unlike other languages, you don't have to pay a fortune to get access to the standard manuals, they're available for free. You can like anyone else implement the standard as an open or closed compiler as you like. But, to ask whether various libraries cost, then I would say all of AdaCore's do because they are GPL'd now which means closed commercial apps using that code cannot happen.
I think Ada is suffering from the same problems Lisp has: reputation and syntax. When I've mentioned Ada on other forums, the responses reflected a view of Ada that's stuck in the 80s (ironically, from people who wouldn't have been born yet when Ada-83 came out). People also think the syntax is too verbose. Pointing out that the code is more readable and that most people read more code than they write doesn't help.
&gt; Pointing out that the code is more readable and that most people read more code than they write doesn't help. After playing around with Scala a bit, I've found this aspect of Ada quite appealing.
There is a meetup group in Stockholm organized by the non-profit organization Ada in Sweden: http://www.meetup.com/Ada-Stockholm/ Last meetup was 9:th of July (That meetup was sponsored by Ericsson and through the Software Craftmanship meetup group)
Only to be cut down by the misuse of an unchecked conversion? :)
Nope, there is no technical reason not to use Ada, if you want to write a system from scratch. When it's transactionally message-oriented, some architects like to put existing AMQP-flavored systems to use. The large scale of the system beings up the project risk of ability to find developers for the chosen platform. It would be easier to find Erlang devs.
&gt; C/C++ give you control over latency and variance of latency Would you mind elaborating on how C/C++ (the language) provides this?
Ada is already being used in the financial field: [Deep Blue Capital Selects AdaCore Products for Financial System Development](http://www.adacore.com/press/deep-blue-capital-financial-system-development/)
When I've needed to create a limited binding to a library for a project, there's a couple ways I've gone about doing it. One is to have gnat generate me a full set using the [-fdump-ada-spec option](http://gcc.gnu.org/onlinedocs/gnat_ugn_unw/Running-the-binding-generator.html). The result is usually kinda cryptic though, so I'll often tweak it to make it a little more application friendly. If I just need a few structures or library functions, I'll create the binding for just what I need. And if there's function arguments I don't really need to worry about, I'll make liberal use of the types in GNAT's [Interfaces.C.Extensions](http://www.cs.uofs.edu/~beidler/Ada/gnat/i-cexten.html) package, like void_ptr and opaque_structure_def_ptr.
Ada is the best language for all jobs IMO. It provides the real time annex for this kind of thing. 
Yup, saw that, but they're not an exchange, just a prop algo trading firm. They do have their own money and possibly client money riding on their technology, but it's not quite the same as a public exchange tasked with custodying large amounts of lots of other peoples' money.
Well, maybe not the right phrasing, but raw speed, direct control over memory, and lack of GC at least, and the extent to which those enable low latency and low variance of latency. C++ is still the gold standard for financial exchanges, closely followed by Java with skilled object and GC management.
From what I've seen someone who currently uses C# or Java could get up to speed in Ada pretty quickly. The question is: would they want to? 
I've been down here since 2000, and in the last few years it's really starting to come alive. More than just the Rocket City, the arts and nightlife are really starting to ramp up.
Is there a necessary distinction between an "experienced Ada developer" and an experienced embedded or systems developer? I would imagine that talented real-time developers, comfortable with other toolchains such as C/C++/Embedded Java, would also fit the bill. Perhaps I'm missing something
Our client requires an experienced Ada programmer because the flight software is written in Ada. One might argue that an experienced embedded or systems developer should be sufficient to fill the bill, but that...uh...wouldn't fly with them. 
The way you want start learning ADA depends on what you want to do with it? You wanna do Saftey Critical stuff? Its what Ada is best and shines at.
* From what I can tell, there is no standard environment other than the gnat compiler. * You don't really need a modern book, just one that's good and new enough. The Craft of Object-Oriented Programs is commonly recommended. * You can turn on style checks in the compiler. That's a great option.
Learning materials: http://www.adaic.org/learn/materials/
Is this project open source? If so you can use gps: http://libre.adacore.com/tools/gps/
For home use I just go get the [GNAT GPL packages](http://libre.adacore.com/download/configurations#). * GNAT Ada GPL 2014 (compiler and GPS IDE, includes XML/Ada) * AWS (Web stuff) * PolyORB (distributed processing, CORBA-type things) * AUnit (unit testing) * GNATColl (useful utilities of all sorts, e.g. JSON, Python binding, just...stuff) Aside from GPS, GNAT + Emacs with its Ada mode is a popular combination. For help with Ada, you can ask here on /r/ada, [Stack Overflow](http://stackoverflow.com/questions/tagged/ada), and [comp.lang.ada](https://groups.google.com/forum/?hl=en&amp;authuser=1#!forum/comp.lang.ada). All are regularly monitored by experienced Ada programmers who are happy to help out.
Is GNAT FOSS? Or there are "strange" licensing schemes?
Game development.
GNAT GPL 2014 is plain old GPL v3. If you go with the FSF distribution, which is what is distributed as part of Fedora, Debian, Ubuntu, etc, you get a modified GPL (analogous to LGPL), with allows proprietary development.
1) There isn't one, pick an editor and use a command line. 2) Barnes' Ada 2012 one, very good, but pricey. The reference manual (RM), the rationale's and the style guide. 3) Best practices?
Also, keep an eye on my SDL 2 binding http://www.sdlada.org
Nice! Thanks ;)
You can at least set up a window and draw into it with GL (or at least should be able to). Just no input or anything else :/
Great work. Don't forget that SQLite is ACID compliant, and heavily tested. 
Couldn't agree more. Southern Alabama, now, THAT's a different story..
It already has even if not another line is added, there is already enough there to write very capable GUIs and web apps. The Rails parts of it have been used in production sites for some time. Although I needed to fix things for use with more recent versions of GNAT which are in that version now. Since Gnoga is truly cross platform and web as well, my personal use will be enough to keep its growth continuous for years to come. I will be using it as part of software I will be writing for my medical clinics. (I wear a lot of hats, I'm also a physician for Chinese medicine)
A list can be expanded by doing: @@TABLE@@ @_my_list_@ @@END_TABLE@@ See [http://docs.adacore.com/aws-docs/templates_parser/template_statements.html#table-statement](http://docs.adacore.com/aws-docs/templates_parser/template_statements.html#table-statement) If that's not what you need, tell us what you are actually trying to do. 
I'll keep upvoting this post.
That's exactly what the @@TABLE@@ statement is for. From the description: &gt; Basically the code between the @@TABLE@@ and @@END_TABLE@@ will be repeated as many times as the vector tag has values 
ada.cx ada.tips comp.lang.ada on usenet/google groups Freenode #Ada channel. 
It's Ada, not ADA.
http://www.adaic.org/learn/ was the top Google hit for ‘learning ada’.
*Programming in Ada* by John Barnes.
AŞK
the Ada reference card was a big help for me http://www.digilife.be/quickreferences/QRC/Ada%20Reference%20Card.pdf
some of my old homeworks with some bugfixes are posted here: http://ahabeger.blogspot.com/
Just FYI, there's a new version of that book called *Programming in Ada 2012* by the same author. Presumably, it subsubmes the original text while also covering the latest 2012 features. I've ordered a copy of the book for myself, but I haven't received it yet. (Maybe the original version is better for students?)
Yeah, the 2012 book is definitely the way to go unless his class is using an older compiler for whatever reason. 
For those 4 benchmarks “that require memory to be allocated" (table 2), Ada was approximately equal once, used half the memory twice, and twice the memory once. For the rest, my first guess would be use of a different algorithm/set of libraries.
Generally when comparing languages, you don't implement the same benchmark in the same way. Ada and C++ are very different languages and the source code is usually very different. You can make guarantees in Ada you can't make in C++, so the C++ implementation may contain bugs (for example) that wouldn't even compile in the Ada version. Other factors that may go into size or speed are compiler switches, pragmas, or even the compiler implementation. The version of the language may result in different code generation and optimization, especially if the new language features haven't been as cleanly optimized as some of the older language features. The algorithm actually used can make a huge difference, as do the supporting libraries and language runtimes. Generally, an order of magnitude (10x) is a serious issue. 2x in some benchmarks 1/2 in other benchmarks, shows the languages are roughly comparable in memory usage. Depending on the algorithm, problem domain, and implementation, and the degree which you need other features like bounds checking on arrays, Ada is no less efficient than any other language.
&gt; Here is my question: how should I map my registers? I think the best answer there is another question specifically "how are you going to use them?" If a register is general purpose numeric, there's no compelling reason to use masking or bits at all; if a register has different individual bits with meaning (e.g. the x86 [FLAGS register](http://en.wikipedia.org/wiki/FLAGS_register)) [and you're writing an emulator] then you could decompose the register like so: type Flag is (Carry, Parity, Adjust, Zero, Sign, Trap); type Flags is Array(Flag) of Boolean with Atomic, Volatile, Pack; Of course if you're not emulating the x86 you'll have to do something different to do an actual interface to the FLAGS register... I'm not exactly sure what as I've never needed to go that low-level.
nope for volatile, it's just the visibility of the effects, so it could optimise away successive writes, Atomic is a stronger warranty. Thanks for the discussion pointer, I effectively just learned that some register could be accessed as 16bits, whereas others have to be accessed in 32bits, I will ignore the issue for now. thanks for the register example, luckily I was going in the same direction by hand.
sorry, my question was not precise (also I guess the link gave some context), I was talking about device registers in MCU. For the general registers, the compiler does its turf.
Well adacore's stuff is 100% pure GPL. David's project is based on mine, they will be using FSF licences code eventually, so you won't need a huge wallet to use it commercially and keep it closed which you can't do with pure GPL. I just built a compiler and separated out packages from the FSF code and it can be used commercially and closed if you like.
Optimising away successive writes to a volatile variable would be considered a compiler bug by me and all Ada programmers I know. The ARM says about "volatile" in C.6(20): "The external effect of a program (see 1.1.3) is defined to include each read and update of a volatile or atomic object. The implementation shall not generate any memory reads or updates of atomic or volatile objects other than those specified by the program." That said, "atomic" brings with it the stronger advice, perhaps useful for device registers, in C.6(23/2): "A load or store of an atomic object should, where possible, be implemented by a single load or store instruction".
The SSL certificate has been sorted - forum is back up! https://www.adaformicrocontrollers.com 
https://gist.github.com/nraynaud/51b96081806795a208fc ok, here is my direction of work, it's a bit tedious. 1) every 1bit field should be accessible in bit banded memory (stop this read modify write madness, someone will get hurt). 2) the busses and the mutexes (I have the clock distribution, the DMA channel, exceptions and GPIO alternate functions in mind for now) should be visible in the type system. So that you can explore your possibilities from the IDE. For now I have just prototyped that in the RCC. 3) avoid API user side bit manipulation. I'm a bit sad that the MCU manual is not online, in HTML, nicely sliced by chapter, otherwise I would gladly put the links in the documentation so that people can quickly find the meaning of the registers. 
I've run into a number of files that the gnatpp shipping with GNAT GPL 2014 wasn't reformatting, and it was just a limitation of the tool. I'm blessed to now be working with a GNAT Pro distribution and am no longer running into any problems with those files. You'll probably have to wait for the GNAT GPL 2015 release to get an updated gnatpp.
I'm a bit befuddled, those guy are selling mission critical, real time, embedded Kool Aid. I crashed their compiler today, they ship something that can't schedule events at a finer resolution than 1ms, and their formatting tool doesn't format. If I were buying my tools, I guess I would look somewhere else to spend my money.
Did you pay for this, or are you using the free, unsupported version? Are the limitations in the compiler, or associated with the platform/OS that you're using? GNAT Pro is doing quite well for the mission critical, real time system on which I'm working. YMMV.
I'm using the free version. I guess it's the same code developed by the same people. I don't know why they would develop a second shittier compiler on the side and give it for free. That would be costing money and give them a bad reputation. My mileage is starting shitty. I'll stick a bit longer with Ada to try a bit harder to see if the bright sky come, but there is clearly a tooling problem for open source.
I'm not sure if they're using Ada/SPARK, but it'd be nice if it were. From the comments: &gt; An Ada microkernel - the long-awaited APSE (Ada Programming Support Environment) could be built on it. &gt; &gt; &gt; If it was designed and coded well, it could be used under Unix - eventually you could replace the c-based UNIX with a superior (faster as well as more secure) Ada OS. If you start with the microkernel then, over time, you can re-code the other parts, leaving things like the user GUI until last.
No, there is a single code base, or "trunk" probably more accurately. AdaCore will take a snapshot across the code base and package that up as a GNAT GPL release. GNAT Pro releases are also snapshots, and not just of "HEAD". When a GPLed GNAT is released, parts of it may be ahead of the latest GNAT Pro release, and parts behind. From current experience, I know that our version of GNAT Pro's gnatpp was better than GNAT GPL, while the latter's XML/Ada release had some fixes that weren't yet in GNAT Pro.
When I worked with GNAT Pro (5 years ago was the end of 12 years of Ada), I *think* I came across a reference to some proprietary code or products, which were not planned to ever be GPL'ed; I think it was third-party stuff not developed by AdaCore themselves. 
Slight off-topic: Anybody heard about remote (world-wide, including Europe!) Ada engineer position ever?
There was a huge stumbling block for the last 10 years or so when the public releases of the GPL compiler was intentionally infecting your projects with GPL unless you paid for a support contract. This turned off many of the serious Ada enthusiast that were not employed in large corporations or the military. That changed over the last few years with FSF version of GNAT becoming more easily available on all platforms that didn't infect your commercial or personal products. Some like myself are getting involved again and starting new projects that are getting people interested again in hacking in Ada. (see http://www.gnoga.com for example) Who knows you may just see local groups start up (again) in the coming years :) David Botton 
Update sorry for not including more info
As of the time of the writing of this comment, the prize is up to $400.
They should have used nodejs and mongodb for astronomical scale ;)
A new, potential Ada user here. I think I know what you mean, even though I've only done a little bit of Ada so far. I tried the GNATbench development environment with bad results. The smaller problem was that you needed a 32bit JDK and 32bit Eclipse to run the GNATbench plugins. (Isn't 64bit a standard nowadays? Well, anyways.) The real problem was that when I tried to create a new "Ada Project" in an existing project directory with my sources, the plugin failed with some error AND DELETED THE ENTIRE PROJECT DIRECTORY WITH ALL MY SOURCES. Thank god that was only a test project a few hours of work with it, so nothing of real value was lost, but wow. The gnat (gcc) compiler has worked well for me, so I will continue without the GNATbench.
I’m not sure that SPARK would prevent an SQL injection vulnerability! I understand that techniques to avoid this are easy enough to come by in Javascript etc, you just have to know to use them.
The author isn't suggesting that SQL injection is something that SPARK would prevent, but that it gets written off as a mere "bug" that a "genius hacker" exploited, when it's really something produced by a poorly trained or incompetent programmer.
If a languages/libraries/tools have holes I think blaming the programmer for being incompetant is not constructive. Better to bake security into languages/toolsets. The weakest link is surely the human in this chain.
You know that Ada is not really a drop-in replacement for PL/SQL, right? All the database interfacing would have to be provided by an external package like [GNATColl.SQL](http://docs.adacore.com/gnatcoll-docs/sql.html). Have you worked with Ada before? Have your coworkers? Are they in on, or at least open to, doing this? I don't know about *your* boss, but I've found that often when the developers present a united front regarding a preferred technology or tool, management is usually amenable to it. There's a variety of generic reasons that make Ada a good choice, but the argument needs to be in the context of your environment. Touting Ada's precise floating point and real time control semantics probably isn't going to have much sway there, instead things like built-in value and index range checking might.
Well, My list of benefits is that it is similar to PL/SQL (important, since other options have been shot down because no one else knows the language), and would provide more stability, readability, **better error handling**, and improved speed over Bash. Additionally, Oracle offers SQL*Module, a pecompiler that translates Oracle SQL statements into an Ada module which can then be linked into our project. Also, our project is getting more complex (and handling a lot more data than it did when it was designed), so minor issues we are currently having with Bash are most likely only going to get worse. I was wondering if developers that have more experience with Ada could offer some additional insight
I wasn't clear in my original post. Sorry. I am looking to replace the Bash scripts (and maybe the PL/SQL later, if it works out). Oracle provides SQL*Module, a pre-compiler specific for Ada, which I believe will be a good selling point. I took two courses in Ada95 in college (90's). My co-workers have not done any work with Ada. Their experience is primarily CA: Gen, COBOL, PL/SQL, and ksh. Looking at examples of Ada and comparing it to PL/SQL, they look similar enough to where I think Ada will have the lowest learning curve of the options I've looked at so far. 
Try looking into Python for your bash scripts. In it's simplest form you can still call your bash from python, and extend around it. Or just rework what you have to Python. Examples are plenty on the internet, and it is fairly easy to learn. COBOL is not really an option as it is mainly for large batch processing. Unless that is what you do :) ADA is not really an option either, as the added features that ADA gives over C\C++, most likely has no use for you. I think Python can also execute PL/SQL, just google around, and experiment with it :) See also http://www.oracle.com/technetwork/articles/dsl/mastering-oracle-python-1391323.html 
Ok, thanks for your input. This is a solution meant to stave off future problems. What we have now works relatively well, but I don't think that Bash will keep up if our system continues to grow (more source systems). Transitioning now would be less painful. I think Ada would be a good fit for our situation, the best that I've come up with so far. I am going to look into /u/beerke's suggestion about Python though. I've played with it a bit, but maybe it deserves more serious consideration.
Hi, I have yet to use this tool myself, but there is SparForte that allows you to do batch scripting in AdaScript. It only runs on Linux platforms. From the SparForte website: [ BEGIN ] Ken O. Burtch is the author of "Linux Shell Scripting with Bash" and former IT Architect with the "Webkinz" brand websites. With nearly 20 years experience in the IT business, including many years with multi-billion dollar companies, Ken was concerned over hard to scale, hard to maintain scripting languages, he created SparForte as a tool to solve real business problems. Based a ISO standard proven effective for large, mission-critical projects, SparForte is designed for fast development of large projects while, at the same time, providing easier maintenance and bug removal." [ END ] [ BEGIN ] AdaScript is a small subset of the Ada programming language, with additional features related to shell commands and databases. AdaScript is intended to be "upward compatible" with Ada. AdaScript scripts should run with little difficulty under Ada, but Ada programs may require large changes run under SparForte. [ END ] * http://sparforte.com/index.html * http://sparforte.com/documentation.html * http://sparforte.com/sparforte15/examples/database.html 
&gt; I’m not sure that SPARK would prevent an SQL injection vulnerability! You could use Ada 2012 to ensure that various data-elements are correct, this in-turn can eliminate the possibility for SQL injection. As an example, you could ensure that [date-strings](http://www.reddit.com/r/programming/comments/2b4kpg/conspiracy_and_an_offbyone_error/cj2k5ac) are both correct and consistent, or that an [SSN](http://www.reddit.com/r/programming/comments/296l7a/stop_unit_testing_database_code/cihyzfr) is formatted correctly.
No sound? I think it'd be easier to follow with a voice-over explaining what's going on, and why.
Agree.
Whats the difference between yours and http://docs.adacore.com/gnatcoll-docs/json.html except that yours is wrapped around a stream ?
This is a GCC 4.8.1 cross-compiler targeted to the RPi. The [README](https://bitbucket.org/jenssiebert/gnat-rpi) is confusing, tho: the intro says the instructions have been tested on Ubuntu 14.04 x86, among the packages required is mingw-w64, and the last para says to copy the results to a Windows system. Is that right? 
Or just use Raspbian and apt-get install gnat
Thank you, that's perfect! I got tired of trying to diagnose things I'm so unfamiliar with. I'll try to fix it this weekend likely, start from scratch and pay better attention to what versions of each software are compatible with each other. Have a good day.
Thanks, that's a pretty site. I had previously been using this: http://www.infres.enst.fr/~pautet/Ada95/a95list.htm
I've seen a lot of code examples, like at RosettaCode, but I'm curious to see some real-life Ada. I'm especially curious about its use in various space programs, but I haven't had luck finding actual code.
This thread has been linked to from elsewhere on reddit. - [/r/urm0m] [DAE am bot???](http://np.reddit.com/r/urm0m/comments/2uk174/dae_am_bot/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
This thread has been linked to from elsewhere on reddit. - [/r/urm0m] [DAE am bot???](http://np.reddit.com/r/urm0m/comments/2ukb7h/dae_am_bot/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
This thread has been linked to from elsewhere on reddit. - [/r/urm0m] [DAE am bot???](http://np.reddit.com/r/urm0m/comments/2unf20/dae_am_bot/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
This thread has been linked to from elsewhere on reddit. - [/r/urm0m] [DAE am bot???](http://np.reddit.com/r/urm0m/comments/2usxkt/dae_am_bot/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
This thread has been linked to from elsewhere on reddit. - [/r/urm0m] [DAE am bot???](http://np.reddit.com/r/urm0m/comments/2ut2h9/dae_am_bot/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
This thread has been linked to from elsewhere on reddit. - [/r/urm0m] [DAE am bot???](http://np.reddit.com/r/urm0m/comments/2ut3s1/dae_am_bot/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
This thread has been linked to from elsewhere on reddit. - [/r/urm0m] [DAE am bot???](http://np.reddit.com/r/urm0m/comments/2utn5p/dae_am_bot/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
Trying to get my wife to enter this, as she's a graphic designer.
Some follow-up discussion is available at http://sourceforge.net/p/avr-ada/mailman/message/33575458/ (avr-ada mailing list)
http://www.newsreaders.info/recommended-newsreaders.htm
I've found that Thunderbird and the free access from [Eternal September](http://www.eternal-september.org/) is an excellent replacement for Google Groups.
Glad to see Ada in this context. Not very impressed by the typing style: `package Types is ... type T_Int8 is new Interfaces.Integer_8; ...`
No offence, but how is this anything to do with Ada? And you can't do any modern Ada programming on Gentoo because support is, in a word, shit.
Ah gotcha. Yeah, no decent Ada 2012 compiler as that really came about at 4.7.x
It's gotten better lately for C/C++ et al, but even for those I generally still can't rely on official portage, especially when I need new language features or libraries. The latest version of clang/llvm in portage is 3.6, and even that was only added within the last month.
&gt; the senior programmer/analyst said that she had never heard of Ada before today not a good sign for senior programmer/analyst.
Rosetta Code's got an [implementation](http://rosettacode.org/wiki/FizzBuzz#Ada). It's really quite a straightforward problem and solution. 
Here it is cleaned up a bit w/ Ada 2012 to be a bit more maintainable. procedure FizzBuzz( X : Natural ) is function FB( I : Integer ) return String is (if I mod 15 = 0 then "FizzBuzz" elsif I mod 5 = 0 then "Buzz" elsif I mod 3 = 0 then "Fizz" else "" ); begin for I in 1..X loop Ada.Integer_Text_IO.Put ( I ); Ada.Text_IO.Put ( ' ' &amp; FB(I) ); Ada.Text_IO.New_Line; end loop; end FizzBuzz;
Nice approach. I didn't think of making a function for the calculation. I've only worked with Ada 2005, but this code looks like it'd compile in that just fine. What's different in it with Ada 2012?
Okay, now that I'm on a computer (and not my phone) I noticed the format for that function is totally different than I was expecting. That would make functions faster to write I guess.
&gt; What's different in it with Ada 2012? /u/arc-kd: Look REAL close at function FB... Then read about expression functions. Expression functions... and aspects, and quantified expressions, and conditional expressions. So now you can say something like: package Identifier is -- An IDENTIFIER is a string of no more than 4 characters, -- all of which are alphanumeric, and cannot start with a -- digit or be the empty string. Type ID_String is String with Dynamic_Predicate =&gt; Valid( ID_String ); private Function Valid(S :String) return Boolean is (S'Length in 1..4 and then S(S'First) not in '0'..'9' and then (for all Ch in S =&gt; Ch in '0'..'9'|'a'..z'|'A'..'Z') ); end Identifier;
Honest request, I have a very basic understanding of Ada and much of my familiarity with the syntax is probably more to do with using VHDL in my undergrad then with using Ada. However the more I read about it the more it 'feels' like it is everything I would want in a language. With other languages that I have learned in the past (C, C++, Python). I feel that regardless of how much I 'studied' it, I only truly became (slightly more) conversant when I read through the code repository of mid to large projects. Personally I find it easier to build an intuition and design patterns from "good examples" if you will. Having said this most of what I found on Ada is usually code snippets or examples with &lt;20 LOC. My request to you is what would be a unanimous "good example" of an Ada 2012 project? (...publicly available!)
I had the exact same discussion in the comments of a previous thread [here](http://www.reddit.com/r/ada/comments/35b3ie/fizzbuzz_xpost_from_rlearnprogramming/cr3xaci). I would really like to see someone else contribute with more weight to this discussion. Watching your post with eager attention! **I would add to this request, not only an example of 2012 'Design by Contract' but an actual mid to large sized project in Ada 2012 (publicly available?).** There are examples but they are usually &lt;20 LOC examples just to illustrate the author's point. For me at least I feel I only start to "get" a language after going through the implementation in large projects, that everyone in the community agrees are 'high quality' design. 
So I just found a lot of comments and an article in /r/programming that made it click for me: https://www.reddit.com/r/programming/comments/1bzh5r/ada_2012_ada_with_contracts_dr_dobbs/ From my understanding of it, contracts are there to 'fix' Ada not being able to check your logic (as it can already check for memory errors plus illogical values from type ranges). contracts have a syntax (and a level of code writing) that is sort of similar to pseudo code in regards to readability. With the contracts, you can 'code in' the requirements for your application and then it will allow your static analysis tools (such as spark tools) to validate the code as well as it will allow for detailed exceptions during run time. So it allows for very easy debugging and in certain cases, allows you to easily formally verify a certain module is correct. Then, as an added bonus, turning all of them on and off is trivial with a particular flag, so you could have all of them do extensive checking during testing, but then when it comes time to ship a finished product, you can easily remove them to speed up execution.
Genode is not yet running on Muen in version 15.05 - it just took its first step to x86_64 with base-hw. When SPARK2014 GPL is released we'll start to integrate the Muen port (maybe with 15.08).
*A wild tumbleweed appears...* this sub is very quiet :/
Nice one! thanks for sharing. Linked it if anyone else is interested. [Muen's git] (http://git.codelabs.ch/?p=muen.git;a=tree;)
I agree with you. So long as the candidate is ready and willing to come in and learn the language and put it to work, I'm game to recommend someone like that--especially if they've got the real-time experience. Unfortunately though, we're looking to staff a position for which someone else makes the final hiring decision.
Great! For an alternative approach, see the [STM32F4 GNAT RTS](https://sourceforge.net/projects/stm32f4-gnat-rts/) project on Sourceforge. Also supported on Mac: [GNAT GPL 2014](https://sourceforge.net/projects/gnuada/files/GNAT_GPL%20Mac%20OS%20X/2014-arm-eabi-darwin-bin/) and FSF GCC [4.9.1](https://sourceforge.net/projects/gnuada/files/GNAT_GCC%20Mac%20OS%20X/4.9.1bis/), [5.1.0](https://sourceforge.net/projects/gnuada/files/GNAT_GCC%20Mac%20OS%20X/5.1.0/).
If you're going to write Ada software using a free Ada compiler you have basically three options: * FSF Ada - This is what is provided on most Linux distributions. You can use this to develop non-free software, just as you could use Emacs to write it. * GNAT GPL - This is acquired directly from AdaCore. It is free, and all software compiled with it and subsequently distributed is covered by the full GPL. (No LGPL at all.) * GNATPro - This is the professionally supported version of GNAT Ada, and is quite expensive for a single developer--though the support is exemplary because that's what you're paying for. You can develop non-free software with this version. All three of these build from the same code base maintained by AdaCore, and all are roughly equivalent in features and capabilities. GNATPro of course will always be in the lead, as that's what's provided to paying customers. You can quite successfully use FSF Ada to develop commercial programs for a small business with no compiler licensing fees. Others have done it. If you're doing some kind of esoteric development on unusual hardware or with unusual requirements (and there's big money on the table) you might want to spring for GNATPro despite the cost--which I believe is somewhere in the twelve to fifteen thousand dollar/yr range.
This comes up a lot as they pissed off a lot of people by changing the licences of their libs to pure GPL. If you can't afford their licence for pro you can use FSF. What area are you working in? Another thing, you should come to #Ada on Freenode, I have the same name there as here. There are other people there who are in the same boat and one in particular is trying to raise Ada's profile, he is dbotton on Freenode, his website is getadanow.com
I see, thanks for sharing your experience as a product user. Would be interesting if they would consider a reduced rate for smaller companies. Arguably the larger share of costumers is in Aerospace/Defense/Rail. Who likely would consider 15k as budget peanuts. For a counterpoint: medical devices and instrumentation are a textbook safety-critical application that could benefit from Ada as a development language. However most new developments and research are often created by small medium business or even startups who then license or sell it to bigger companies that can fork the money to pull through regulation and take it to market. Speaking from a personal level if I was starting a business I would like a more stratisfied product from AdaCore. For example if the company makes less then 500k a year they could purchase pro for 5k/yr with all the tools and libs but with no online support, something along these lines. A good example of small customer mindset is 'Nucleus RTOS' licensing (joint Mentor Graphics+NXP). A 'meet-me-half-way' product would contribute to change the decision balance business wise. We "risk" changing the C/RTOS/C++ status quo and spend 5k on a tool + the cost of training up developers, for the promise of more correct code with proper run-time boundaries, full OOP, packages, tasking, language interfaces, etc. There a lot of unknowns in changing development environments if you add on top of this the inertia of 'first language syndrome' it becomes impossible to change status quo without some sort of disruption. For instance, I think the GNAT GPL ARM release was a great move, it shows they are commited to move away from the stereotype of the 'government contract' language. It's a great gateway to demo and to draw attention from the SV 'wearables' crowd. I think It's obvious AdaCore are making a valiant effort to expand the language use in universities and other contexts and if I can be biased I can only hope they succeed. :) 
&gt;Would be interesting if they would consider a reduced rate for smaller companies. This has been wished, and AdaCore badgered about it, for maaaaaany years. They have been completely unswayed by any and all arguments and pleas. The most common request was to pay them a reduced fee for access to the compiler and tools, omitting all technical support (as you suggested). The gist of their refusal, as I understand it, is that AdaCore sees itself as a *technical services* company that focuses on Ada development. To them (and again, this is *my* perception) it makes no sense to omit technical support, as that's their raison d'etre. (And don't argue with me about it, and frankly don't bother wasting your time arguing with them. You can go back and review all the arguments in the comp.lang.ada archives :-) The argument could be made that if one is committing to a "serious" product development effort, vs bootstrapping in your spare time in the extra bedroom, that $15K for top-flight technical support and tools is not out of line. You're going to be spending that kind of money for platform infrastructure, accounting services, business licensing, marketing, *paying yourself*, etc., so it's just another comparable business expense. (I know this precludes just that kind of solo hacker startup, but AdaCore would probably suggest that supporting that domain isn't in their business plan. And it's their company, they can run it in any way that makes money for them.)
Its not quite that simple. A number in that ballpark gets you 5 developers. You can't buy support for 1 developer. The quantity discounts (with quantized levels of developers) get pretty aggressive after that. All honor system. No technological license enforcement.
Question: Which standard are you going to go with? Ada 83? Ada 2012? (95? 2005?)
Awesome! Maybe now I can get cracking with learning Ada with my Mac. 
He will be missed.
Ah, that is a great shame. You can see the guy in action here: https://www.youtube.com/watch?v=0yXwnk8Cr0c
Such sad news. RIP Robert.
Sad news. He personally responded to a few of my bug-reports when they were ironing the bugs out of GNAT's early Ada 2012 functionality.
Emacs comes with Ada mode. Why are you trying to build it separately? If you want the latest Ada mode then install it from GNU ELPA.
I see. I think it's best to report the bug to the Ada mode list. Stephen Leake who writes Ada mode be able to help. http://host114.hostmonster.com/mailman/listinfo/emacs-ada-mode_stephe-leake.org
Now at v1.1.0
I'd be very interested to see all their code in non-PDF form, happen to stumble across it when you found the paper?
I saw this on LinkedIn, and someone commented there that the owners (Saab) weren't going to open source the source code :-(
The FSF RTS is updated from the GNAT Pro sources at the start of each major GCC release (4,8, 4.9, 5.1 ...). The GNAT GPL RTS is a snapshot of the GNAT Pro sources at the time of the GNAT GPL release. So there would be little point. Also, the compiler is deeply involved with the RTS, because it generates calls to the RTS to support exceptions, finalization, tasking etc.
You should install the latest ada-mode (5.1.8) from GNU ELPA, as stated [here](http://stephe-leake.org/emacs/ada-mode/emacs-ada-mode.html). It works with `.gpr` files, with some limitations with respect to Emacs ada-mode project files (e.g. no project-specific auto-casing dictionaries).
I had the pleasure of working with Robert and Ed Schonberg back in the 90s with GNAT. Robert and Ed were both accomplished musicians as well as highly entertaining people to talk to. The survival of Ada as a language was driven because of Robert's singular vision of moving the language out of the "expensive, niche language for the military" and into "open-source language for the masses." While the language didn't get the traction he expected, it went on to significantly influence other languages (like C#). I'd dare say that if not for GNATs existence, the language would have been nothing but another footnote in the "good idea, bad execution" language graveyard. I didn't always agree with him, but I'm glad to have known him.
Added to my Amazon wishlist, maybe some day I'll write some serious software and need it :)
The article says "the Raspberry Pi version is a follow-up to the company's earlier GNAT GPL for Bare Board ARM last year”, but I think it’s targeted at Debian running on the Pi - a somewhat different proposition! And of course you’ve been able to develop Ada natively on the Pi forever ...
During the Ada 2005 process, at the Vienna Ada-Europe conference, there was definite objection to requiring multiple instantiations (as, for example, with the [Ada 95 Booch Components](https://sourceforge.net/projects/booch95/)) because of the extra complication for users. This scheme uses multiple instantiations, but in a better way and for better reasons than the BCs did!
more technical details [can be found on AdaCore's blog](http://blog.adacore.com/how-to-prevent-drone-crashes-using-spark)
Paperback versions are now in stock on amazon. Hardcover ones already shipped (that is what I ended up buying).
In Ada2012, use a predicate (I think it should be a dynamic predicate, though GNAT will accept just `Predicate`): subtype Valid_Character is Character with Dynamic_Predicate =&gt; Valid_Character in 'C' | 'c' | 'V' | 'v'; 
Thanks, that looks to be exactly what I was looking for.
what?
&gt; It is my dream to have the ebook of &lt;&lt;programming in ada 2012&gt;&gt; 
Now go buy [The Thrilling Adventures of Lovelace &amp; Babbage: The (Mostly) True Story of the First Computer](http://www.amazon.com/The-Thrilling-Adventures-Lovelace-Babbage/dp/0307908275).
&gt; GNAT Programming System I wasn't sure if I needed to download all those additional source packages under 'GNAT Ada GPL 2015' on the page, but this looks like the perfect solution, thank you.
Works great :)
Check out her Draw My Life video celebrating her 200th birthday here: https://www.youtube.com/watch?v=FQ7FcNWBc20
I suppose it must be browser or locale specific, I'm using Linux and I get zero text in Firefox 38 and the latest Chromium :(
I think you should provide the full error message + put your code on something like [lpaste.net](http://lpaste.net) so we can read it more easily.
Yes , its done .
Answered on c.l.a.
Thanks for the news... Maybe a link to the course would help? :/
Here it is http://university.adacore.com/courses/spark-2014/#sthash.bqFgC5zo.sfju
There is one in the text on the blog :)
Are there any links to the article where I don't need to make an account?
Yeah, I just clicked the link to the article when I ran across it. Not sure why you're being told you need an account.
Ada Home is a good overall reference site. http://www.adahome.com/ Here is their example page. http://www.adahome.com/Discover/Examples/
I found Ada for Software Engineers to be a great book. There is a free [online edition](http://www.weizmann.ac.il/sci-tea/benari/books/ase.pdf) from the author's Web site.
It's a general purpose language and can be used for anything not just defence. What are you interested in? What projects would you like to develop? Then do it in Ada.
Well, except that it's really dated now.
&gt; It's hard enough to find tutorials, particularly for Ada 2012 I was triggered to get a bit into Ada thanks to FOSDEM last weekend. It's indeed suprisingly hard to find good resources/tutorials for Ada 2012. There's the book of course, but I'm not sure if I want to pay €88 just to 'try it out'. Or I'm not looking hard enough, of course :)
Here is the link to [the video](http://ftp.fau.de/fosdem/2016/aw1124/memory-management-with-ada-2012.mp4)
Take a look at quicklisp, it's a nice project and has greatly improved CL usage over the years.
Excellent! but I’ve never heard anyone (even a Brit :-) call it 'Adda'!
My thought exactly, I've only heard yanks say it that way. It's got one D not two! I'm looking at you, John Carmack!!
It's really not 🙈
Excellent!
 Marco Panunzio, on-board Software R&amp;D Engineer at Thales Alenia Space - France posted an [update on LinkedIn](https://www.linkedin.com/groups/114211/114211-6130015352064663552?trk=hp-feed-group-discussion): &gt;Use of Ada in the space domain For those of you that regularly wonder about recent software developed in Ada, the on-board software of the ExoMars TGO spacecraft, now heading to Mars, is developed in Ada 95. &gt;This blog entry (despite some simplification of language for dissemination to the general public), gives some insight on some recent activities for the upload of a new platform software binary.
The most ill-formatted code I’ve seen for a long time! Not sure what the token `¡` is meant to be, possibly `=`. The compiler is complaining because the code is the equivalent of `package X is new X`, and after the compiler sees `package X is` `X` refers to this `X`, not any other `X` that might be out there. Try package Integer_IO is new Text_IO.INTEGER_IO(Integer); use Integer_IO; or package Int_IO is new INTEGER_IO(Integer); use Int_IO; And then get eutecada.adb:17:07: warning: variable "I" is never read and never assigned eutecada.adb:17:09: warning: variable "J" is never read and never assigned eutecada.adb:17:11: warning: variable "K" is never read and never assigned eutecada.adb:17:13: warning: variable "L" is never read and never assigned eutecada.adb:17:15: warning: variable "N" is never read and never assigned eutecada.adb:35:11: warning: for loop implicitly declares loop variable eutecada.adb:35:11: warning: declaration hides "I" declared at line 17 eutecada.adb:108:24: "Precision" is undefined 
It still doesn't work. Try your more realistic test case above. You quickly get overflow and useless results.
Yeah, I think it's a write-off, having had a closer look at it.
You must be interviewing for a job in aerospace. Yeah gnat has a nice ide and compiler. Ada is a great language. I did it for 10 years while simultaneously working extensively in Java. I will say that although I love Java and OO and I am amazed how quickly I can build up an application in that language, Ada is just amazing because it's such a beautiful language and you can develop in any style. Structured, OO or a mix of either. 
You should spell it ‘Ada’ - people can be picky about this. (And isn’t it ‘Java’, too?)
ADA is american dentist association. Ada is a programming language named after Ada Lovelace. Like Java, Groovy, Scala, etc.. Not JAVA.
nice explanation... i read that it was based on pascal...is it more of a functional programming? (lambaphobia)
Ada is a very nice imperative language. It has all the power of C++ but it is easier to read and harder to make mistakes.
For that compiler, for that level of optimisation, with that code, OK. But in general the evaluation order is arbitrary ([ARM 6.4(10)](http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-6-4.html#p10)).
I think [this video](http://ftp.fau.de/fosdem/2016/aw1124/memory-management-with-ada-2012.mp4) should explain the differences between `access` and `access all`.
Thanks, I haven't watched the video yet (don't have time today), but I will take a look at it tomorrow. By the way, I recognized your username---your code projects and articles have been very helpful in learning Ada so far :)
still growing
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [GNAT GPL 2016 now available • \/r\/ada](https://np.reddit.com/r/programming/comments/4lzpfb/gnat_gpl_2016_now_available_rada/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Just Wow!
Thanks Simon!
That's pretty cool! 
Can I upvote a post about my own project? :-)
More a language with concurrency built in: https://www.seas.gwu.edu/~csci51/fall99/ada_task.html 
What do you want to do?
Go Simon Go! 
Does anyone have any tutorials working the displays on the STM32F746NG board? It looks like a couple of the examples are using it, but I'm having a hard time following it (only had time for a quick look so far). 
Very impressive interview.
&gt; STM32F746NG Would this help? http://www.inspirel.com/articles/Ada_On_Cortex.html
Basically you need to buy/rent a virtual server (vps) and setup Jenkins there by yourself. I run http://build.ada-language.com/ but I don't take any new projects, as I plan to switch to my own home made version at some point. (Architecture of Jenkins is horrible from the security point of view for public projects - the web interface needs to be the master node, which is kind of no-go for me. Master node should be totally independent from the web view. There are some Jenkins plugins for that but they break after every Jenkins update.) 
Sorry, my question was pretty vague. The Pos variable was just to test how Ada handled assignments. When I input -1 the assignment to Pos raises and error, like I would expect. When I input 3, the assignment to Even does not raise an error. Why?
That was the problem. I didn't expect a switch would be necessary. Thanks for everyone's time.
What type of job is it?
&gt;modify existing Apache AH-64 flight software Ada code and related software models/simulations in a Linux environment.
I could do that (I've worked in Aerospace - mostly space - for 10 years with ADA development) But I guess this job would require US citizenship and the possibility to get the correct security clearances..
I programmed Ada between the years of 1988 to 2004. Now I am in the .net c# asp.net world since 2005. I thought Ada had died. 
You can make it yourself, a ".gpr" file just a project file and it's text. Here is an example: https://github.com/AdaCore/Ada_Drivers_Library/blob/master/boards/common_config.gpr And here is the documentation: https://docs.adacore.com/gprbuild-docs/html/gprbuild_ug/gnat_project_manager.html
Ok, just keep this thread up to date. The embedded runtimes are referencing a different git repo, maybe this was in the video and I missed it, I'm not sure, I'll go back and look. At this point, it's not generating the errors as before, but it's not building either. I won't bother to post the build errors here just yet, but they aren't in the project source, rather, they are in the gnat run time library, which seems rather strange. 
Hmm, possibly they were compiled with a different version compiler than what you are using (check your environment path order). I will admit getting the development environment set up correctly is not as simple as visual studio.
Have you tried mingw?
Ok, so an update just in case anyone else comes across this. It seems that what I've run into is bugs in the refactoring of the Adacore drivers library framework. I met up with a friend who has been working with this and we used his zip file of an older release and had only a few minor issues getting it going. I'm not going to jump to conclusions yet, but, my initial tests seem to indicate that there have been some new bugs introduced into the current release. There seems to be some attempt, for example, to refactor the config files so that one isn't needed in the root. However, the blinky project still references a config from the root. The real problem though is that attempting to rebuild the drivers and arm projects for the board that I have yields errors that I'm not sure how to fix. I will compare new and old versions of those files, but later, right now, since I have a working board with code, I have my own fish to fry. 
[Wikibooks](https://en.wikibooks.org/wiki/Ada_Programming) is a good start. [Ada Reference Manual ](http://www.ada-auth.org/standards/12rm/html/RM-TOC.html) is useful too. 
There is this book by John Barnes, [Programming in Ada 2012](https://www.amazon.com/Programming-Ada-2012-John-Barnes/dp/110742481X/ref=sr_1_1?ie=UTF8&amp;qid=1471572582&amp;sr=8-1&amp;keywords=ada+2012) I have started it, but I haven't made it thru yet. It's pretty good, but I also use the wikibook as another source. If you have an O'Reilly Safari subscription, Programming in Ada 2012 is available from that as well. Thanks to others for posting more useful sources too. E: Safari not Safary, duh. Long day.
The world is ready for an "Ada in a nutshell" book.
Backwards compatibility is a big concern for the Ada revisions. I only know of one single change between the 95 and 05 versions, that never arose in my code around the time. The other side of the coin is that some old design decisions that today seem bizarre are still there in the standard library, but that's just a minor peculiarity of the Ada way. Finally, I have found useful this high-level overview of additions in each revision, not that it is that important if you target Ada 2012: http://www.adacore.com/adaanswers/about/ada-comparison-chart
That was an interesting article. Its going to make me more worried about exception handling and type conversions than I already am, sigh.
In GPS, there is Navigate - Goto File Spec&lt;-&gt;Body, which goes to/opens the "other"; similar on the right-mouse-button menu in the editor window. In Emacs ada-mode, it’d be C-c C-o.
Just use Unchecked conversion with extreme caution.
For me, it looks like, you have installed other version of ncurses than GPS wants. It is hard to help without knowing which Linux distribution you use (welcome to Linux world ;) ), some possibilities: - GPS require exactly ncurses version 5.x and you have installed newest version 6.x. In that case, try find in your package manager old version of ncurses. It may be called libncurses5 or ncurses5. - Some Linux distributions have own policy on libraries names, etc. If you have installed ncurses version 5.x and GPS still not working, try create symlink libncurses.so -&gt; libncurses.so.5
It is a decent book no doubt. But you can learn much of the same material from the wikibook, from the adacore university site, from the documentation in the gnat-gps files as well. I wouldn't let the lack of a book stop you from chasing your dreams if I were you.
Thanks, Just as you see I love that book. Because it is a system describe of the Ada knowledge. I need it just one. I have enough time to read too much material. I have do many things to earn my life currently...
Woot! Class assignment complete, let's go drinking!
The way I understand it, declaring a type as private, makes the type obscure to the generic package. Meaning your package does not know what type it is, as it could be anything (scalar, array, record). So, if the generic type has no limits on what it is, 'Value has no meaning. Two options. One, create a generic function to simulate 'Value for your type. This is what you'll have to do is your type is a record, array, or can be either float, integer, etc. Two, declare your generic with limits. Such as "type Item is (&lt;&gt;)" This will tell the package it is a discrete type, or "type Item is digits &lt;&gt;" for floating point. 
Interesting and pleasing! I wouldn’t personally use `-gnatg` (used for compiling GNAT units) or `-gnatp` (Suppress all checks) ...
I'm not familiar with GPS. My best guess is that it's pointing to a .ads file for compilation, rather than you real main file.
It says that it cant work as a source file or something if it points towards it. So no, that's unfortunately not it
It sounds like you don't have the main file correctly set. You say you're using gps. So... Select Project/Edit Project Properties... Click the "Main files" tab. Do you have anything listed under Main files? Note that "jubiler.adb" cannot be a main program if it's a package body. A main program must be a *procedure* or *function*. If you don't have a main program, try something like this: with Jubiler; procedure Run_Jubiler is begin Jubiler.Main_Procedure; end Run_Jubiler; Save this file as run_jubiler.adb, then set that file as your main file. 
Can you post the gpr file?
another guy suggested that my main files were skewed so now i have what i guess is the correct way: project Jubiler is for Source_Dirs use ("./**"); for Main use ("main.adb"); end Jubiler; However now it acts as if there was no Jubiler.adb file &gt; main.adb:115:84: "sprawdzicWystawe" not declared in "Jubiler" main.adb:147:69: "sprawdzicWystawe" not declared in "Jubiler" main.adb:155:23: "sprawdzicWystawe" not declared in "Jubiler" main.adb:155:55: "iloscWyrobow" not declared in "Jubiler" main.adb:169:26: "wystaw" not declared in "Jubiler" and so on even though i do have "with Jubiler" up.
Are your file names lowercase only? Gnat has trouble if that's not the case.
Yes, lowercase. Made sure just now too. I created a new project and copied my code into new files as well with no success, kinda looking for anything that might be wrong..
Looks like it's trying to include the XML/Ada library. The AWS website says this is optional "to support SOAP". You can get XML/Ada from the same place as GNAT 2016.
I just tried this and the file is already set to static. What do you think could be causing my problem?
How do I download xmlada? It is difficult to find on the website.
It's part of the GNAT download. But it doesn't seem to be part of GNAT 2016 (yet?). If you select GNAT 2015 then it becomes one of the options. Alternatively the latest code is on [github](https://github.com/AdaCore/xmlada).
Here, AWS doesn’t try to build zlib stuff unless it finds zlib installed. But then, I’m on a Mac. What OS are you using?
Woot! This sub-reddit gets a shout-out in the article!
Are you using the gcc that comes as part of a GNAT distribution? What version?
I'm using the `gcc-ada` package from the AUR. I didn't really look into what it was tracking. From the [link](https://www.archlinux.org/packages/core/i686/gcc-ada/), it looks like its tracking gcc's main page.
I notice you typed one too many: "Synchronized_Queue_Interfaces" and same with "Unbounded_Priority_Queues". Still didn't compile, but fix these first. Synchronized_Queue_Interfaces.Synchronized_Queue_Interfaces
You seem to be getting types "Integer" and "nodeWeight" mixed up in the instantiations. This kind of thing happens when you write: type nodeWeight is record nodeWeight: Integer; nodeNum : Integer; end record; which makes it too hard for me to decipher. I'd change some names and then follow the rules exactly! 
~~I changed the inner nodeWeight field to currWeight. I'm still getting the same error. What exactly ARE the rules for instantiating this, because I can't find any useful documentation for it.~~ Oh I.... I guess I fixed it? That's.... really weird. 
You probably shouldn't manipulate the array returned by getenv. Instead, create a copy and change that. Then call setenv at some point if needed. Here is example how to call getenv from Ada (tested on Linux): with Ada.Text_IO; use Ada.Text_IO; with Interfaces.C.Strings; with Interfaces.C; use Interfaces.C; procedure EnvC is function getenv(Name : Char_Array) return Strings.Chars_Ptr; pragma Import (C, getenv, "getenv"); begin Put_Line("Home = " &amp; Strings.Value (getenv (To_C ("HOME")))); end EnvC; 
I can violate using the secondary stack that way, but that's not considered implicit heap allocation. The following example shows me violating the No_Secondary_Stack pragma, but without that restriction it's perfectly valid. pragma Restrictions(No_Implicit_Heap_Allocations); pragma Restrictions(No_Secondary_Stack); with Ada.Strings.Unbounded; use Ada.Strings.Unbounded; procedure Main is function Heap_Test return Unbounded_String is begin return 30*'H'; end Heap_Test; S : Unbounded_String; begin -- Main S := Heap_Test; S := S &amp; "test"; end Main;
That doesn't seem to be triggering it. --main.adb pragma Restrictions(No_Implicit_Heap_Allocations); with Alloc; procedure Main is W : Alloc.Node_Ptr; begin W := Alloc.New_Node; end Main; --alloc.ads-- pragma Restrictions(No_Implicit_Heap_Allocations); package Alloc is type Node is record X : Integer; Y : Integer; end record; type Node_Ptr is access all Node; function New_Node return Node_Ptr; private procedure Allocate (N : in out Node_Ptr); end Alloc; --alloc.adb-- package body Alloc is function New_Node return Node_Ptr is N : Node_Ptr; begin Allocate(N); return N; end New_Node; procedure Allocate (N : in out Node_Ptr) is begin N := new Node'(4, 0); end Allocate; end Alloc;
That would depend on your compiler... "The operations that implicitly require heap storage allocation are implementation defined." http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-D-7.html#I7886 
&gt;Why is that? Run time libraries. Ada includes a large library of support functions in the binary. C does also but to a much smaller degree. Remember, C has *only* 29 keywords. Ada has many times that. Each of those many keywords in Ada requires run time support...that big library I mentioned. &gt;Am I missing something? No. Your observations are accurate. Remember. C is a *mid*-level language. Ada is a *high*-level language. C, then, is unique is this regard.
I haven’t done tests to check this either way, but GNAT GPL 2016 is based on GCC 4.9.4; the Ada part of FSF is up to a year older than the GPL equivalent. 
I forgot to mention that. This is true for the GPL version on 4.9.4 and the FSF version on 4.9.3.
Both C and C++ have built in concurrency support. It seems like people in this thread are rationalizing so much unused functionality being built into the binary.
I did now, didn't work ([see my reply] (https://www.reddit.com/r/ada/comments/5b429f/binary_is_too_big_compared_to_c/d9nnuij/)). Guess there's nothing else it can optimize or maybe Ada compilers aren't as good as a C compiler... I don't know.
Ok, compiled again with a couple of different flags, here are the results; File name is followed by optimization level (*i.e.* \*_O1 for -O1 flag *etc*). **C**, for the sake of comparison gcc (GCC) 6.2.1 20160916 (Red Hat 6.2.1-2) -rwxrwxr-x. 1 user user 8624 Nov 4 12:56 hello_c -rwxrwxr-x. 1 user user 8624 Nov 5 23:55 hello_c_O1 -rwxrwxr-x. 1 user user 8624 Nov 5 23:55 hello_c_O2 -rwxrwxr-x. 1 user user 8624 Nov 5 23:42 hello_c_Os **Ada** GNATMAKE 6.2.1 20160916 (Red Hat 6.2.1-2) -rwxrwxr-x. 1 user user 254272 Nov 4 12:56 hello_ada -rwxrwxr-x. 1 user user 254312 Nov 5 23:50 hello_ada_O1 -rwxrwxr-x. 1 user user 254312 Nov 5 23:50 hello_ada_O2 -rwxrwxr-x. 1 user user 254272 Nov 5 23:42 hello_ada_Os GNATMAKE GPL 2016 (20160515-49) -rwxrwxr-x. 1 user user 587648 Nov 5 23:46 hello_ada_adacore -rwxrwxr-x. 1 user user 587648 Nov 5 23:54 hello_ada_adacore_O1 -rwxrwxr-x. 1 user user 587688 Nov 5 23:54 hello_ada_adacore_O2 -rwxrwxr-x. 1 user user 587648 Nov 5 23:47 hello_ada_adacore_Os Results from GNATMAKE GPL are just absurd! I guess that's the price to pay for a high-level language... *c'est la vie.*
Your binary size for the regular gnatmake is roughly 10 times the size of mine, which is odd. Also, I highly suggest you use the flag to strip symbols. This makes my hello world a little under twice the size of the C version, which I would consider reasonable.
Which version and flags are you using?
Complexity of the modern (ie. non-standard) Pascals is on par with Ada's, but Ada is the more cohesive of the two. Pascal has become as big as it is now by frequent extension over the last 30-45 years by different people and for varied reasons. Many of these extensions, taken together, are rather ill-conceived: writeable 'typed consts', redundant classes when objects serve the same purpose, extended/advanced records which are almost indistinguishable from objects, six different string types etc. Features were often bolted on, with old features left in place to ensure backwards compatibility. Nevertheless, though perhaps *because* of this, if you know to make a selection of features to use, Pascal can be a rather practical language. Ada on the other hand, was designed in one go (well, four 'goes', with the different revisions...) by committees with the specific purpose of designing a programming language. Various (presumably controversial) features were added with pragmas, rather than dedicated syntax and semantics; this keeps the core language as big as can reasonably justified. If you consider Ada's individual pragmas to be language features, the language isn't far removed from being as messy as Pascal; it's just that the skeletons are all stuffed into a single closet, biding their time (eg. the `with` clauses in Ada 2012). C# as initially conceived was about as complex as Ada '83. From about 2006 on it's started to steadily accumulate features, but hasn't yet turned into a chaos like Pascal, and I'm not sure that it will. In this respect, C#, like Ada, benefits from having been maintained by relatively few people (Anders Heljsberg, and the current crew), and from the relative lack of disparity in computer systems compared to Pascal's heyday (especially in the seventies). I can't comment on Java and won't comment on C++. When comparing complexity of programming languages, I tend to look at the number and nature of their semantic primitives; lexical and syntactic features aren't necessarily a good basis for a comparison, due to significant variance in syntactic styles, different ways to represent the same construct, and the ability to reuse tokens in different contexts (such as the parentheses in C, or even Lisp). Syntax is little more than a layer of (ideally practical) presentation on top of a collection of semantic primitives. It's not so much the abstractions provided by these constructs as the interactions between them that form the bulk of a language's semantic identity, and the source of its complexity. That's why standard Pascals are notable mostly for their strict adherence to the tenets of structured programming (programs, subroutines, conditional execution, lexical scope) and their simple type systems: `algorithms + data structures = programs`. Ada introduces tasks with 'entries' to provide access to thread-local data, a system of generic packages, and more. Complexity is dependent on whether these features are reasonably orthogonal, the constraints on the interaction between these primitives well-chosen. (Curiously, early C# (and apparently Java), introduced nothing new apart from the packaging, but in the mid-late 2000s a similar phenomenon took hold of this corner in particular, with people's almost religious adherence to the notion of design patterns as meta-semantic primitives.) To get a good idea of what you'll be working with, to gain insight into the inner workings of a language (and its designer), look at its fundamental building blocks, at how they can be composed and how they cannot. Probably unlike most people, and perhaps to my fault, I'm not really concerned with the standard library offering when evaluating programming languages. Pascal has a fairly large RTL full of redundancies that see little use, while Ada's standard library is about the same size but tidier and more complete (as there's less of a 'legacy'). Ultimately I spend most of my time working on my own and third party code, not with standard libraries, so provided there's a good set of primitives a even just a small standard library to support productive idioms, you won't hear from me. But yes, it's worth taking a gander.
Uh, that got a little long. I'm going back to slinging SML now, so I've no time to make it shorter. Hope you get the gist of it.
I feel you. (From someone who is pathologically unable to write short comments. 💕)
On [Github](https://github.com/AdaCore/aws), makefile.conf:52 is ifeq ($(shell gnat ls -Pxmlada 2&gt;&amp;1 | grep 'project file .* not found'),) Up til 27 Nov 2015 it used `gprls` instead of `gnat ls`
I wouldn't say that Ada is inherently unsuitable for game engine development. What Ada does lack are the libraries that other languages have for game development. So what you can easily do with a library call in C/C++ means you may have to write your own in Ada. [A port of Doom3 to Ada](https://www.reddit.com/r/programming/comments/1craky/adaport_of_doom_3_engine_id_tech_4_commencing/) has been ongoing for 3 years. So it is possible. Ada is good for "Systems" or embedded programming. The Tasking feature of Ada is really nice where you need to have discrete software elements running concurrently. The closest thing to tasking I can think of with other languages is threading. However, tasking is more suitable to real-time concurrency. The nature of the language is very strict (relative to C, Python, Java, etc.). So it may be cumbersome to get away with things in Ada that you can do easily in more mainstream languages. This can be a positive though as strict data typing provides data integrity. Run-time exception handling is also a nice benefit in critical systems. So what you have, in Ada, is language that is inherently good for critical, real-time systems. So think air traffic control, military equipment, automotive control, train control, space systems, telecommunications...that kind of stuff. Stuff that doesn't necessarily need a fancy GUI, but needs to keep processing reliably and accurately. Ada derivatives like SPARK and the Ravenscar Profile were developed especially for safety-ciritcal real-time systems. Source: various radar software jobs
How about these: http://globe3d.sourceforge.net/ https://github.com/AdaDoom3/AdaDoom3 https://github.com/thindil/steamsky https://sourceforge.net/projects/adagate/ And of course real-world systems, like these: http://www.adaic.org/advantages/projects/ https://www.seas.gwu.edu/~mfeldman/ada-project-summary.html 
Thank you for the long comment. I would be interested to read the long version. Have no problems with reading long texts especially about things I am interested in.
I'm by no means an expert when it comes to Ada but from what I gather it would be absolutely ideal for writing something such as Global Thermonuclear War; or maybe a nice game of chess. 
I'm working on a tiny part of a huge living project, so major changes like that would be a last resort. Unchecked conversion is definitely what I'm looking for. The array of tiny int is unconstrained, which ADA didn't like, but I'm sure ill find some way around it. Also i phrased it wrong, the conversion is from tiny_int to string. thanks for the resources! I'm going to look into it. While ADA is still strange to me, I like it, especially since my education was focused on embedded systems.
Yes but as every site like this, it needs to stay aware of the URL for code and so on. For the projects I declared, I try to keep the data up to date
Best typo ever :)
rather an array of ints. For some reason they represent a byte as type tiny_int is range -2**7 .. +2**7-1; I have an array of those coming in, and need to convert them to a string
bloody iphone!
You shouldn't need that, there are better ways, see my other comment.
Why are you using JEWL instead of something like gtkAda?
is ada web server not packaged by Debian?
[More info](http://blog.adacore.com/make-with-ada-winners-announced), with video.
[Part 1](https://redd.it/4s04fk)
If I understand you correctly, the following should be what you are asking for. This is with Ada 2012, for an older version you have to use the pragma on each type. procedure Main is type Volatile_Integer is new Integer with Volatile; type Volatile_Pointer is access all Integer with Volatile; type Volatile_Pointer_To_Volatile_Integer is access all Volatile_Integer with Volatile; X : aliased Volatile_Integer := 4; X_Ptr : Volatile_Pointer_To_Volatile_Integer; begin X_Ptr := X'Access; end Main;
Yeah, the ugliness I'd why I couldn't get it to work. I'll try this tomorrow, thanks!
Wonder if this has been shared in C forums or just here?
Er, -fpic?
On libre.adacore.com Choose a native platform of the GNAT GPL 2016 to see the spark package
Well part of your question was the location of spark package which i gave you and i tried it. For example the x8664 linux package is at http://mirrors.cdn.adacore.com/art/5739d613c7a447658e0b0189 I did not check for the lemma library though but there was a "or" in your question. Cheers
Thank you. Does anyone know where bug reports are submitted so this can be included in the normal distribution or the location made more obvious?
I'm not sure. It's the adacore distribution so it seems like i'd have to go through them.
On the command line, try `-bargs -shared`. In a project file (I haven’t actually tried this), package Binder is for Default_Switches ("ada") use ("-shared"); end Binder;
If you have any questions, let me know. I'll try to answer them as best as I could. I tried making the book the sort where there will be quite a bit of hand-holding to get you started. I hope that it helps you. And yes, I talk about linked lists :)
According to [futex(2)](http://man7.org/linux/man-pages/man2/futex.2.html), &gt; Several higher-level programming abstractions are implemented via futexes, including POSIX semaphores and various POSIX threads synchronization mechanisms (mutexes, condition variables, read-write locks, and barriers) so there may be no need.
No worries. One more one then - can you point to any examples of object oriented Ada? I'm seeing a lot of packages with similar syntaxes to modern object oriented code, but nothing that actually has classes/instantiated objects.
pthread_mutex_t is definitely implemented using futexes. Mostly I'm annoyed about memory. Suspensions objects could be as small as one 32 bit int on Linux but the way they are implemented uses up a pthread_mutex_t and a pthread_cond_t which is silly.
You can use Atomic_Components, but keep in mind [Atomic](https://en.wikibooks.org/wiki/Ada_Programming/Pragmas/Atomic#Incorrect_usage) might not fulfil everything you expect it to.
In my book there are two chapters dedicated to OOP. One talks about the basics and the other delves into more complex topics. Here is the source code for the two related chapters: https://gitlab.com/introductoryada/introductory-ada-programming/tree/3fb9e5d7764363a10dfba393d2ee63b736c03f07/ch06 https://gitlab.com/introductoryada/introductory-ada-programming/tree/3fb9e5d7764363a10dfba393d2ee63b736c03f07/ch13 Is that what you had in mind?
Ive never used chrome, isn't it some variant of linux? Check what distro it's based on
Install Crouton on it, a copy of vim, and the compiler and you're good to go.
Appendix A should do the trick. It holds your hand the entire time. Firstly, depending on your distro, I would recommend you try installing GNAT from my package manager. That's what I would do. Lastly, I would download GNAT and point PATH (in Linux) to the binary files for GNAT.
I doubt it would cost that much with AWS or Azure..
Can someone explain what the Time_Since_Last_Due_Active field is doing? I get that it's related to the wait time between activations, but it's being incremented with the tick time and then decremented with the activation period? Edit: Whoops, missed the if-statement. So it checks if the time since it's due is greater than activation period, and if so, toggles the pin and decrements the counter back by the amount of the activation period so that it can check when that value goes above its threshold again?
I need to try this out on my own codebase!
Fixed! Thanks Simon...
Not a direct answer to your question but are you familiar with http://sparforte.com/ It is an Ada like scripting language built with GNAT and may help provide examples as you work through similar questions.
Yes, I am. I have compiled it and have "/bin/spar" on my system. I have found that it is very limited in what I am trying to do -- also, it was Mr. Button who did SparForte, right? It is his wonderful creation and has dependencies that are not pure Ada and not particularly Windows friendly. My aim is to learn through the process of creating my own scripting language that is NOT as strongly typed as Ada, and just a bit more strong-type-compatible (like JSON, etc.) than shell script, taking advantage of the power of Ada to be more maintainable and expandable. Because I haven't quite figured it out yet, I was hoping to at least find out if a real pro at least believes it is possible to manage the input, output, and error of a single unit (task) within an Ada program and if this would then be inherited by a Spawn (rather than the main program's input, output, and error). If I dig, I might find a way to cross the output of one non-blocking-spawn to the input of another non-blocking-spawn. Just one success and I should be able to complete the rest from there...
There's the one Lock_Free pragma extension but that only affects performance and not semantics.
You’re probably running into [GNAT’s file naming rules](https://gcc.gnu.org/onlinedocs/gnat_ugn/File-Naming-Topics-and-Utilities.html#File-Naming-Topics-and-Utilities) and Ada’s [compilation unit rules](http://stackoverflow.com/a/32633111/40851). But if you want anything more you’ll have to be more specific; for starters, what exactly is the error message?
They're right, I am sorry to seem redundant at first, but I wanted to go over two things to re-affirm your confidence in Ada. First, the GPS IDE does occasionally have problems, but all the official releases from AdaCore are virtually flawless in in their primary functionality. It is usually only when you tinker with the environment or try to compile it yourself that real problems show up. Now to answer the rest. Ada's naming scheme is really easy for modern filesystems. Just name the package file the same as the package name (or procedure name, if a plain executable), only in lowercase. There is more to it than that, but with default settings, that is the simplest. Now for packages, you have to have both a spec file (*.ads) and a body file (*.adb). If you write a program with just a procedure that uses no original packages (uses only Ada.*, GNAT.*, and 3rd party imported libraries), then you only need the body file (*.adb). In Ada, the spec is required for the interface with everything else and is the primary location to write "--" documentation comments. Because it interfaces with everything else, the functions, procedures, and packages defined in the spec file must match the order and lines in the body file exactly. The main difference is that new types and packages must be defined in the spec and the body must define actual instructions to follow. In the body of a procedure or function, there is an area that is like a mini spec file, except that it is not in two parts, so the limitations are a little different -- you don't have to declare the spec for functions and procedures there, you can only create new instances of packages and not the complete packages, and you define variables to be initialized and used in the body. This mini-spec-like aria is after "is" and before "begin". With GPS, the comments will be associated with the nearest object that is not separated with a blank line. Priority for line before or line after, if both are present, is decided in the settings. Now, thank you for your patience. I had no intention of telling you too much of what you already knew, but you said you were new to Ada and what I have written should cover the two likely causes for something like file-does-not-match error. Enjoy!
[Tips] In GPS when you create a new file, start typing the name of your package: package My_Package is end My_Package; Then when you do "File -&gt; Save (CTRL+S)", GPS will suggest the right name for this file. "my_package.ads" in this case. It also works when there's only a procedure in the file (my_procedure.adb): procedure My_Procedure is begin null; end My_Procedure; or a package body (my_package.adb): package body My_Package is end My_Packages;
One way would be to ditch the GNAT-specific C-interface stuff, and use the task termination handler API provided by the language... http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-C-7-3.html#I7744 
Short answer : Yes (see http://stackoverflow.com/questions/24666940/ada-concatenate-integer-with-string ) :) Long answer : something like this should do the trick : procedure generate(prefix : String; suffix :String) is begin for i in Integer range 1..12 loop declare path : String := prefix &amp; Ada.Strings.Fixed.Trim(Integer'Image(i), Ada.Strings.Left) &amp; suffix; begin -- do what you want null; end; end loop; end generate;
Thanks!
It turns out what I want is Independent https://docs.adacore.com/gnat_rm-docs/html/gnat_rm/gnat_rm/implementation_defined_pragmas.html#pragma-independent
I’m not working with atomics myself, but you might be interested in having a look at GNATCOLL’s helpers for them: see &lt;https://github.com/AdaCore/gnatcoll/blob/master/src/gnatcoll-atomic.ads&gt; and &lt;https://github.com/AdaCore/gnatcoll/blob/master/src/gnatcoll-atomic__intrinsic.ada&gt;. You don’t seem to expose the same set of primitives though, so maybe that’s something that could be added to GNATCOLL?
To avoid dealing with Unicode code points everywhere in the application code Matreshka library was created. It provides "true unicode string type" (Universal_String) with handy methods such as slice, head, strartsFrom, index, to_upper. It has Text_Codecs to convert string to/from most popular encoding. To be more usefull in application development it also provides several stuffs where text processing is needed, such as XML, JSON, SQL interaction, web services, regexp. I found it very handy. 
&gt; Welp, there's a pretty big strike against Ada, psychologically speaking, for newcomers. Thanks AdaCore. How so? How is having transpilers a strike against Ada? Is having a Javascript target a strike against the hundreds of language that have a Javascript transpiler? (Off the top of my head, Kotlin, C#, Haskell, Scala, etc). In my mind this is just providing support for targets that are not yet targettable directly but still have a C compiler available, so it's a pretty useful tool in the Ada arsenal. But I guess if you really want to be negative, you can find a way:) Also what's with the constant AdaCore bashing? &gt; Ah, so it's a-ok to violate a standard for the sake of easiness? (In this case the "no-pointers" of SPARK.) SPARK has not been conceived as a solution to write all your code in. The idea is to write the critical parts of it in SPARK and write the interfacing code in Ada. The SPARK-to-C compiler supports a subset of both for the moment. &gt; Also, unless the C compiler is verified correct, this is just inviting bugs into your SPARK-proven code... good job breaking it, hero. You're talking about two things that are completely unrelated: Correctness of your code according to specification, and correctness of the compilation chain. Except for a very few exceptions (the native SPARK toolchain not being part of them) like Compcert, compilers are not usually verified. 
My employer here in Huntsville, AL (the "Rocket City) is looking for Ada developers with experience in avionics, with a big plus if you've got Apache helicopter experience. And it's *not* for conversion to C++ :-) PM me for details.
It's for Lockheed Martin Missiles and Fire Control here in Orlando, FL. The recruiter is: Kaley Tierney | Lead Recruiter | Insight Global, LLC 407.608.1520 Office | 62590 Ext. 300 S. Orange Avenue Suite 1500 | Orlando, FL 32801
&gt; I believe you misunderstood rule 18.2.2. Indeed I did. &gt; shared memory access must be synchronized, which does apply to any language, I'm still amazed that Ada allows leaving synchronization out without any complaint. Are there profiles that forbid unsynchronized concurrent access to globals? &gt; Ada functions are clearly not anonymous functions. Indeed, but the main issue with the quoted rule "5.1.4. Do not capture variables implicitly in a lambda" should not be taken literally when comparing with other languages, but logically. And the "capture variables implicitly" in inner functions is just as dangerous in Ada as capturing variables implicitly in lambdas in C++. You cannot capture variables in inner C++ functions, only lambdas can capture.
Again, I think you are reading the rule incorrectly. It does not say that variables should not be captured at all. It says that variables should not be captured implicitly. The example given shows a "correct" capture of variables, where the variable is captured explicitly, and an incorrect capture of variables. The text of the rule talks about capturing a variable by reference or by value, and allows capturing a variable by value. The rule goes on to recommend against the use of objects with static storage, which corresponds to global variables in Ada. The rule against using global variables does apply to Ada. The only way to declare a global variable in Ada is to declare it at the package level. Variables declared within a subprogram are not global and do not correspond to C++ objects with static storage.
&gt; It does not say that variables should not be captured at all. I understand that &gt; It says that variables should not be captured implicitly. Ada only has implicit capturing, there's no way to even specify it to be explicit. SPARK does explicit capturing through the dataflow declarations.
That is not really true. SPARK is a subset of Ada, not a superset. It is possible to provide the Global aspect specification to a normal Ada program. The Ada compiler used for SPARK2014 is currently the GNAT Ada 2012 compiler. The SPARK tools provide extra static analysis beyond what is provided in the Ada compiler alone, but that does not prevent a regular Ada program from using the Global aspect clause for procedure or functions.
I have written (Ada 95/2005/2012 compatible) unit testing framework called Ahven, https://www.ahven-framework.com/ Not sure is it any easier than AUnit, but if you like, you can take a look at the [tutorial](http://www.ahven-framework.com/tutorial.html), [user's guide](http://docs.ahven-framework.com/2.6/manual.html) and some [examples](https://bitbucket.org/tkoskine/ahven/src/9cc5a646877ef897ac8ec690f3a7ef669c1f5cec/examples/?at=default). Ahven is slightly more complicated than Unity as Ahven doesn't have test runner generator as Unity has, but otherwise it should be somewhat similar. (I use Unity myself for C code.) 
Do you really need a unit test framework for a bubble sort program? How about just using pragma Assert compiling with -gnata? e.g. https://github.com/zmower/game-of-life/blob/master/test_life.adb
I don't really like assertions, because tests provide some kind of how_to. Also, unit tests are much easier to use for..hm..testing. 
Ahven is easier to set up but AUunit is more flexible at this point.
I don't thank any GUI IDE competes with GNAT, and the simplest experience on the shell is probably tmux + vim + gnat make. You could theoretically configure any IDE for it if you're familiar with the shell commands; you could add in build scripts to Sublime, NetBeans, etc
There is an emacs mode that is maintained pretty well by one guy on the comp.lang.ada newsgroup. Apart from that its pretty much GPS. A couple editors have syntax highlighting but the completions arent very good. GPS can be extended with python scripting, dont know why anyone hasn't spun up a better Git menu for it yet.
&gt; I have yet to see an IDE which provides the level of git support that makes an open terminal obsolete. If you count Emacs as an IDE, [magit](https://magit.vc/) is the most complete and intuitive git UI that I've ever used. If you're using a different IDE, maybe keep Emacs + magit open in that terminal window. :)
Hello, what should be done in order to add a support for STM32L152 boards?
I'm not sure I agree with the author's claim that "SPARK originated from the Ada language" ... I thought SPARK originally targeted Pascal in the 1970s and was then ported to Ada? I am getting this from Barnes' 2012 book on SPARK.
See the [emacs ada-mode mailing list](https://lists.nongnu.org/mailman/listinfo/ada-mode-users) and the [ada-mode home page](http://www.nongnu.org/ada-mode/)
Thank you, I am just a beginner with Ada, but I have seen some interest to stm32l152 boards, also, I have one of these boards too. Maybe I'll try to make a port. Also, I have seen a port for TMS570LS3137. Does it have a lot of differences with TMS570LC4357?
Writing a BSP is maybe not the easiest way to start, you should try to get one of the STM32F4 discovery that we already support in Ada_Drivers_Library. 
No, SPARK is 100% derived from Ada and always has been. [Wiki](https://en.wikipedia.org/wiki/SPARK_\(programming_language\)#History)
Have a look in: http://docs.adacore.com/sparkdocs-docs/SPARK_LRM.htm particularly the bits about SPADE Pascal
Very enjoyable read, does make me want to dust off the old compiler and get back into Ada.
In terms of financial return they'd be better off dropping flash and supporting something like webm. The era of flash is over and good riddance to its insecure and unreliable arse.
which is included in -gnatwa (turn on a lot of optional warnings - vague but useful!)
I find it ironic that an online course about a programming language that supposedly encourages safe and secure programming practices requires one of the least safe and secure software packages the internet has ever known.
Let me be the one to laugh at "easier to maintain" XD
The 0x55 addresses suggest that PIE is involved. You need a better in-process backtrace dumper which translates the addresses to program and DSO offsets, undoing the effect of load address randomization.
The Ada Style Guide is fine, though I don't much like how it does context clauses.
I think the comment after the thing is a bit weird.
Oh, yeah, I always comment before the item... it just seems far more natural to me.
I singed up and posted to the list, you can see the answer - they don't want to provide pdf versions of presentations. 
yup to M120, say no to 1970's 80 columns!
But with 80 columns I can get 2 emacs frames side-by-side on my 13-inch Macbook and have a little room on the left for the corners of terms, finders, pdfs ..
&gt; Is it possible to avoid null pointer dereferencing in Ada? Yes. What you'll want to do is add a subtype [or possibly a new type, though that's likely more work] which excludes null. type Node_Ptr is access Node; subtype Safe_Node_Ptr is not null Node_Ptr; Then you'll want to alter some of the data-structures and return-types: -- Assuming you want to disallow the empty-list: type List is record Head: Safe_Node_Ptr; Tail: Node_Ptr; end record; and: function Pull (List_To_Change: out List) return Safe_Node_Ptr; &gt; And is it possible to clean the memory for sure? There's `Unchecked_Deallocation` and also storage-pools/-subpools.
Your problem is that your `Node_Deallocation` takes the node to be deallocated in `in` mode. The consequence is that, as you found, you have to copy the node to a local variable and deallocate that; `Unchecked_Deallocation` requires a variable as its parameter *because it sets the parameter to `null`*. `Node_Deallocation`’s parameter should have mode `in out` (and *don’t* make a local copy!)
Thank you, now I understand it didn't work without local copy, yes, due to in mode. So, we can't prove that function is right with SPARK, am I right?
They can be, but it really is helpful to exclude them where possible, like most function returns and procedure parameters. (That is to say, only use/allow null returns/parameters when absolutely necessary.)
I have a test-case for you: https://www.reddit.com/r/ada/comments/69hrhn/is_it_possible_to_avoid_null_pointer/
Depends on where you live and if you are willing to move
Ads in Rocket city are advertised on LinkedIn and comp.lang.ada often. Which I think is Alabama??
Hello, I started to learn AUnit and it's so complicated. And then I started to learn about gnattest. Is it worth learning? It seems that unit-testing with gnattest is more complicated than AUnit itself.
Boeing. The language is used a lot in aerospace. I used it for a number of years as a Dev working on avionics.
Ada is still pervasive throughout the defense industry, so a security clearance is pretty much a prerequisite for that. Be aware that you can't just go get one, your employer requests one for you so that you can have access to such projects. So, you'd need to get hired first. A number of defense companies in Huntsville, AL (the "Rocket City" that /u/Lucretia9 mentioned) use Ada and will continue to do so for the foreseeable future. PM me a link to your resume or a contact email through which to get it, and I'll pass it on to our company's HR. 
&gt; I'm not an Ada developer but promote it along with other techniques for higher-assurance development. On behalf of the fans of Ada, thank you! &gt; Most of my reading indicated it was mainly safe in static situations without a solid alternative to GC in dynamic ones. (Note: Ada was designed, even in 1983, to *allow* garbage-collection, though the standard doesn't mandate implementing GC.) There's a lot of features that do deal with dynamic situations, some bypass the "requirement" for pointers altogether -- like the ability to return unconstrained [read: variable-length] arrays from functions -- and others are a bit more technical. (See: [Memory Management with Ada 2012](http://ftp.fau.de/fosdem/2016/aw1124/memory-management-with-ada-2012.mp4).) &gt; Certainly some helpful features knocking out some issues but not safe in general case w/ unsafe deallocations happening. Following Cyclone language, Rust solved that problem with its borrow checker enforcing affine types and such that prevent temporal errors. I'll note that even static analysis tools finding temporal errors in random code were really hard to write compared to some other tools. Also, the separation logic used in tools such as VCC is way worse than the trouble Rust's borrow-checker brings. It was a great improvement on temporal safety within reach of average developer. &gt; &gt; &gt; So, my question is what work is being done on Ada to give it such a capability or does a recent version already have it? The combo of Ada/SPARK existing features plus a borrow-checker would kill about any other language in overall safety, development cost, and maintenance burden. Verified, concurrent, low-latency GC's are always a fallback that would usually be fine for desktop, server, or mobile. The borrow-checker's protections are preferable, though, esp given Ada users are the kind of developers that would tolerate it better and their use-cases prefer resource efficiency. I'm not sure. The ARG (the standards committee for Ada) has a system called AdaComment (ada-comment@ada-auth.org), [detailed here](http://www.ada-auth.org/standards/2xrm/html/RM-0-3.html#p58); I'm sure they'd be more than happy to hear from you. &gt; Thanks for your time ahead of time. :) No problem.
I'm not really sure what you're asking, can you simplify what you're looking for exactly?
Thank you.
Rust allows memory safety without a garbage collector, race freedom on concurrency side, these as general purpose as writing C++ code, all checked at compile time, and IIRC no overhead (zero-cost abstractions). They use a combination of rules for ownership and checking references. http://theburningmonk.com/2015/05/rust-memory-safety-without-gc/ https://doc.rust-lang.org/book/ownership.html That means they're already ahead of basically everyone on temporal safety &amp; usability combination. Ada needs that to eliminate one of its final weaknesses: safety of dynamic and/or concurrent code also done in flexible way more developers will appreciate. I'm wondering if there's a current feature that eliminates all temporal and race errors in dynamic, Ada code like Rust's does. If Ada lacks that capability, is there work going on to add that and do you have a link to show that?
Some things are easier to write and some things are harder, in different languages. Saying that it takes you significantly​ larger amounts of time to write everything in a language just means you are unfamiliar with it. It's normal to find a language you don't know hard to read as well. I think most of your qualms stem from being generally unfamiliar with Ada.
Not so sure about this! See [this question](http://stackoverflow.com/q/43916571/40851) on StackOverflow.
Ada is an amazing tool, if you know how to use it. You can ask questions on the #ada channel on IRC. Alternatively ask questions on comp.lang.ada. But I recommend #ada since I am there (as well as others!) and can answer questions in real-time. As for being the wordy, I recommend use of code-snippets (called aliases in the GPS).
Yes, it is wordy, it's meant to be so that the code is readable. The keywords are used in consistent places, ```is``` is used in a place which defines something: package X is ... procedure P is ... type T is ... I think it's consistent. You seem to be fighting with the "why replace C?" question and the answer is to use Ada for an actual project and you'll see for yourself. 
I know that you can do strange things with C. But if we take if (a = 5) { this error is easily found by the compiler. Just compile with -Wall flag. Also, this is a separate branch, so it should be tested. If you use tests, you easily find this error.
When working with Ada one also does unit-testing as in other languages (I usually use Ahven). It's just that one (in general) has more compile-time error checking in Ada than in C (depending of course on how you use these languages!), and it just means less things to test, not that one can just dropping testing altogether. And when one works professionally with Ada one also does static code analysis, unit-testing and formal verification. Also, the communities of C and Ada are not opposed each other, there is a cross-pollination of ideas such as: http://www.open-source-innovation-spring.org/frama-c-spark-day/ As a hobbyist you can do unit-testing and formal verification of the Ada code you write. The main problem of Ada is the lack of freely available libraries one can reuse as a developer. It might be due to the threshhold to get into the language that you are describing. I guess it is something the Ada community could improve upon. Anyways, there are many links for documentation at: http://getadanow.com/
Another problem with Ada is the community: [my problem](https://www.reddit.com/r/ada/comments/66o56h/proposition_to_university_adacore/). I wrote to university.adacore mail list, and they answered that they aren't going to provide presentations in pdf format and videos not in flash format. Also, I have written to gps mail list about a bug with shortcuts, but they ignored it. I will be glad, if you can help to solve this problems. 
In fact, we currently have at AdaCore an intern working with us on the inclusion of Rust-like pointers in SPARK. He has reached a first milestone which was the description of suitable rules to include safe pointers in SPARK, which have convinced the SPARK Language Design Group at AdaCore and Altran UK (the small group working on the evolutions of the SPARK language). He's now working with us and researchers from Inria team Toccata to give a mathematical semantics to the notions that we're using for these safe pointers: move (on assignment mostly), borrow (on parameter passing for mutable objects) and observe (on parameter passing for immutable objects). We have also started looking at the concrete implementation of these rules in GNATprove (the SPARK analysis tool). In this work, we don't target everything that the Rust borrow checker does: - we leave accessibility checking (the lifetime checking in Rust) to the compiler, using existing Ada rules, plus some restrictions in SPARK to avoid the need for dynamic accessibility checks - we leave nullity checking to proof (a Verification Condition will be generated for dereference of possibly null pointers), with the help here of Ada non-null types that reduce the need for such proofs. Given that pointers are always initialized to null in Ada, there is no need to separately deal with initialization. - we ignore the problem of memory leaks (which could be tackled later as an extension of the current scheme) So the main issue that we really address with this work is the issue of non-aliasing. Or rather the issue of problematic interferences, when two names, one of which can be updated, are referring to the same memory location. We're focusing on this issue, because it is the one preventing inclusion of pointers in SPARK, as for formal analysis we rely on the ability to perform modular analysis, where we make assumptions on the absence of problematic interferences. But since our solution to non-aliasing is based on this Rust-like notion of ownership of pointers, the same solution will also forbid use-after-free or double-free. This work is ongoing, we will certainly let the community know about our progress after the summer.
[Pdfs are available now.](https://www.reddit.com/r/ada/comments/6b6l6a/pdfs_of_adacoreuniversity_lectures_are_available/)
Problem was partially solved: [post](https://www.reddit.com/r/ada/comments/6b6l6a/pdfs_of_adacoreuniversity_lectures_are_available/)
I've recently started doing ada on embedded linux. I'm not sure I had a strong preference over C++ but I have come to appreciate some things. My general feeling right now, it's definitely better than C but it's less compelling over C++. If you're doing mission or safety critical code, it's worth taking a look at. Specifically ada's strengths: * I've never been a big assert user. I would say ada's use of constraints has caused me to re-evaluate this. If my code survives unit/integration test with the associated range checking / other assert checks on, it's probably right. * Modules are a big win. It makes going back to C/C++ kinda painful. * Interfaces is a pretty big win (over C). This definitely helps with limiting coupling, define test boundaries. That being said there are performance implications. * Concurrency support helps remove a lot of boilerplate vs C/C++. This is better in C++ 11 but still not as easy as ada. * Record representation clauses are helpful. I wish C/C++ had a portable, non-compiler specific way to do this. * Subsets (like ravenscar) are nice to help keep away from the more subtly complex parts of the language. It unfortunately is also super confusing for a beginner. There's already a dearth of ada resources. Using a subset subtly means most of those resources can't be used. 
I agree, I had some difficulties to locate errors and wanted to make several assertions but then I understood that it would be more wordy.
AdaCore is hiring, see http://stackoverflow.com/jobs?sort=i&amp;q=AdaCore
Awesome! Thanks for the detailed reply. That should be a good start. Do you all intend to aim for the full, dynamic safety that Rust has for base Ada if the SPARK project succeeds? And are there FOSS implementations of low-latency, concurrent GC's to handle full safety in dynamic, aliasing code for now along the lines of Go where performance impact is minimal?
Not sure for which checker. The code in that post is a beginner's mistake rather than a copy-paste error or code decay problem that the lightweight checkers that I wrote found. You could write your own checker for this issue, but I don't see how general it could be? Since the goal of course is to catch as many bugs as possible.
[AdaCore’s public customer list](http://www.adacore.com/customers) should demonstrate the falsity of your first paragraph.
Also, there could be another benefits. For example, the last year winner is among the judges this year. Though, they haven't told about this in his description: [judges](http://www.makewithada.org/judging).
Also, there is no spi support. It is a bit *IRONIC*. This is probably the simplest board for programming. It has simulators, toolchains, a debugger. It has also only SPI, UART and GPIO on the board. But the implementation in AdaCore Ada Drivers Library lacks SPI support.
I think this article is hitting the best issues, but doesn't the government basically keep ada alive on its own? 
They integrate their patches all year long. Some people only use the FSF version, especially because it allows you to build and distribute non-free applications while GNAT GPL makes you link your code with a GPL Ada standard library. For some hobbyist, this is the only way to produce proprietary applications written in Ada. You can monitor (mainly) AdaCore work in the FSF tree here: https://github.com/gcc-mirror/gcc/blob/master/gcc/ada/ChangeLog
[Betteridge's law of headlines](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines) aka: No.
You're confusing one compiler with the language. There is no GPL license on the language itself, you're (probably) talking about GNAT GPL, which is _one_ compiler implementation. You could use FSF GNAT instead, which has a runtime exception. Sure, it lags a bit behind GNAT GPL in terms of features and bugfixes, but what do you expect when dealing with free software?
&gt;You can use the FSF GNAT which your OS will have packaged, this has a runtime exception. I think it's package gcc-gnat for me. You mean with "runtime exception" that I can license my stuff compiled with that one however I want? This is what its info says: &gt;License : GPLv3+ and GPLv3+ with exceptions and GPLv2+ with exceptions and LGPLv2+ and BSD &gt;Description : GNAT is a GNU Ada 83, 95, 2005 and 2012 front-end to GCC. This package includes: development tools, the documents and Ada compiler. 
It's not really true, not always true at least. The GPL is more complex than that. For instance in the case [described here](https://opensource.stackexchange.com/questions/2338/can-i-use-gpl-libraries-in-a-closed-source-project-if-only-the-output-is-distrib). 
But there are also alternatives: [GNAT FSF](https://en.wikipedia.org/wiki/GNAT#License) with *GCC Runtime Library Exception* and [GNAT AUX](http://www.dragonlace.net/questions/quest_002/).
The date in the link says april 2016, not april 2017.
What is the difference between this and the adacore compiler?
It's not a version of GNAT, it's a completely different compiler. Doesn't support as much of Ada 2012 as GNAT does.
Google "ada to c converter", perhaps? 
Then off the secondary stack and disable exceptions.
...obfuscate a ***compiled*** program? Er, what is the *real* goal/purpose here?
The goal is to make it impossible for an investigator / reverse engineer to determine the original source language used of a compiled Ada program. In other words, I want to write an Ada program, but I don't want the end user to be able to determine that the program was compiled from Ada source code.
Ok, fair enough -- now we have to ask how much effort you're expecting (or willing) to spend. Perhaps one way to do this would be to compile to JVM, dotnet, or some similar VM -- would that be acceptable? (There are Ada compilers targeting these.) Another way would be to use a compiler that outputs source in another language, like the old AdaMagic form SofCheck (bought/merged w/ AdaCore) -- there are plans to do a Forth backend for the Byron compiler, and if/when that materializes you likely wouldn't be able to tell that the generated Forth code was compiled from Ada source.
I mostly was amused by the timing of a post showing an easy to detect bug and a post about automatically detecting bugs. While I agree that it's a beginner bug, it can certainly happen in refactorings of large functions
I think this project was mentioned long before makewithada 2017 started, am I right?
Ha! They are really interested! What about my closed [issue](https://github.com/AdaCore/embedded-runtimes/issues/15)?
&gt; Most companies avoid GPL like the plague. Both the compiler and the majority of libraries are infected by it um.. what? GNAT is not *the* Ada compiler, it is one of many Ada compilers, the vast majority of which are non-GPL. Also binaries compiled with a GPL compiler are not subject. Both GCC and GNAT are used on proprietary closed source software written in Ada and C...
Well I already know that we will get warnings for unused 'use type' clauses so I'm pretty excited about that.
I would love to see improved pointer semantics so that we can safely and timely deallocate memory without Unchecked_Deallocation or any other such joke.
It's not a joke, it's a way of informing the reader that this code is unsafe. 
I'd say it is to tell that this code may be safe (but there is no automatic guarantee within the current semantics). And language lawyers should work harder to get rid of it, ie. every Deallocation should be either safe or illegal.
if it was made illegal, how the hell do you deallocate memory? 
I don't mean Deallocation should be made illegal entirely. I mean the pointer semantics should be refined so that it is possible to determine at every context whether a call to (an instance of) Deallocation is safe and what's more, this should be best determined statically. Obviously, unsafe calls would be then made illegal by the (static) semantics.
&gt; Error establishing a database connection :(
It's up now
Variant records perhaps being able to use the same variable name in the variant fields?
Being able to have multiple case statements in a variant record on the discriminant
Ada was originally designed 35-40 years ago. Top priority was safe allocation and deallocation. Obviously, the perfect solution was not found since Unchecked_Deallocation exists in the language. However, there are several cases where one can make heap allocations safely without using Unchecked_Deallocation i.e. by use of RAII (part of the language since Ada 95 by setting 'Storage_Size on the access type that only exists locally inside a subprogram), pools and subpools (i.e. Brad Moore's Deepend on Source forge). My understanding is that the Rust language has an even better solution to the allocation-deallocation problem and is probably the inspiration of your request for Ada 2020. An Ada-like language that also has an improved solution to the allocation-deallocation problem is ParaSail. Both ParaSail and Rust have been inspired by the Cyclone programming language for safe allocation and deallocation.
You're right in that my request was based on improvement in memory management technology found in recent languages like Rust. However, despite of having raw pointer and about 5 kinds of smart pointer, the standard library of Rust is made of entirely _unsafe_ code, which means that Rust is still far from the ultimate solution. It should be expected that by the year 202x, Ada would be made better than that.
@joakimds Thank you very much for introducing ParaSail. I ve just started learning it for a few days but I feel sorry for not knowing it earlier. I think it is a language everybody must learn and use on a regular basis. Programmers must use it for a living. Because it is fast, safe, powerful, and simple. It's a masterpiece of programming language design.
In this post in reasons of rejection I have described my personal opinion about the possibility of creating a new llvm-based Ada compiler. My main problem with Ada was the fact that it was very difficult to utilize it - for example, with google-test framework I can write tests very quickly, but in AUnit I have to spend much more time. At the same time, I found out that SPARK doesn't allow to utilize pointers, but Frama-C allows. Thus, I decided that I won't be able to start/complete the project. But if anyone will find this post helpful, you are welcome to use the information (though it is not very much there).
&gt; My main problem with Ada was the fact that it was very difficult to utilize it - for example, with google-test framework I can write tests very quickly, but in AUnit I have to spend much more time. Why is that a non-starter? &gt; At the same time, I found out that SPARK doesn't allow to utilize pointers, but Frama-C allows. That's true, but you *can* use "mixed-mode" SPARK/Ada. (I've been experimenting with this, particularly using Pure and SPARK for type-definitions.)
The whole point of SPARK is to restrict the use of error prone language constructs.
I didn't find the reason to start investigation (not the development) when the best current implementation is so bad (it's just my opinion). At the same time I had another interesting idea (not about ada) for which it is much easier to find funding.
&gt; At the same time I had another interesting idea (not about ada) for which it is much easier to find funding. What is that? &gt; I didn't find the reason to start investigation (not the development) when the best current implementation is so bad (it's just my opinion). Wouldn't that be motivation to make a good implementation?
My idea is about ukernel ARINC-653 compatible RTOS for Russian processors. And I found it much more attractive than implementing an Ada compiler. I also wouldn't be able to utilize my Ada knowledge or my product, because there are no vacancies with Ada in Russia almost at all. You can check it in the main Russian job searching site [hh.ru](hh.ru). At the same time, Russian processors do [exist](https://en.wikipedia.org/wiki/List_of_Russian_microprocessors). 
I keep jumping between a new implementation and a new language inspired by Ada.
As you already know, I don't really like Ada. And for me a new language inspired by Ada is Rust. I don't think that it's worse than Ada. Honestly, I even think that it will displace Ada. First of all, it already has a bigger community and funds. Secondly, it seems that its analog of SPARK can be more reliable than SPARK (I think that Frama-C is already better than SPARK, at least, it works with pointers). If it has a good GUI tool and an analog of Frama-C I will definitely use it.
I didn't know you really didn't like Ada at all. I certainly don't think you've given it a chance and it just looks, to me, that you were looking for a safer C. Rust is in no way inspired by Ada, it's inspired by C++ and you can see that all over it. 
[removed]
[removed]
[removed]
[removed]
The book, System Design in Ada, described tasks as a way to define actors in a system. These actors work asynchronously, but can still communicate with signals. For your assignment, these actors will be your employees taking the produce to another actor, the storehouse. The customer will then request the produce from the storehouse, as an example. Similar to real life, these actors largely behave independently of each other, with brief points of communication between each other. This system can better utilize multiprocessing CPUs and more idiomatically describe a system.
I'm grateful for your reply! I *think* I understand the baseline of tasks. I just don't get how: select do_A; then abort do_B; helps me with my assignment. My rough plan was something like this: * make tasks with loops for a couple of producers, first they wait for x seconds, then they call "Put" entry for my storehouse * make tasks with loops for a couple of costumers, first they wait x seconds, then they select random set of items, then they call "Take" entry from my storehouse * if, for whatever reason, produce can't be put (storehouse at full capacity), then I call "Storehouse_Accepted_Take" entry, that can be accepted only inside "Take" entry of my storehouse (since there can be room only if any customer took something) * if, for whatever reason, I can't give items to my customer (storehouse is near empty), then I call "Storehouse_Accepted_Put" entry, that can be accepted only inside "Put" entry of my storehouse * (another option for the above would be "Wait_For_Specific_Producer" entry, that initiates rendezvous with any producer of a product, that's still needed to complete my order). I can achieve all that with select do_A; or do_B; but I honestly can't imagine a single instance, where the first mechanic is useful. Especially since I can't put accept calls inside asynchronous select.
 with Ada.Text_IO; use Ada.Text_IO; procedure Main is task A; task body A is begin select delay 1.0; Put_Line("A : Here1"); delay 1.0; Put_Line("A : Here2"); then abort Put_Line("A : Ereh1"); delay 1.0; Put_Line("A : Ereh2"); end select; end A; task B is entry Start; end B; task body B is begin select accept Start; Put_Line("B : Ereh1"); delay 1.0; Put_Line("B : Ereh2"); or delay 1.0; Put_Line("B : Here1"); delay 1.0; Put_Line("B : Here2"); end select; end B; begin null; end Main; The difference between task A and task B is quite simple. Task A starts working without asking permission and then is told to stop from a signal of some sort. Task B, by contrast, asks permission before working or starts to work on another function first. There might be a performance benefit from one or the other depending on the implementation, but let's ignore that. To decide whether you should use A or B depends on if the task should be workings mostly autonomously (A) or should be told to start (B). Using this way of thinking, you could define a producer as an A task, since it's main goal to to run constantly until told to stop.
Once again - thanks for help! :) I think I'll now find a way to implement this, but one question remains: how exactly Ada picks which process from accept ... then abort ... does. Like the modified program you just posted: I tried to figure out the output. My guess was: A : Ereh1 either A : Here1 or B : Here1 (both take roughly the same time), then the other one A : Ereh2 either A : Here2 or B : Here 2, then the other one To my surprise the output was slightly different: A : Ereh1 B : Here1 A : Here1 B : Here2 A : Here2 The main difference being there is no "A : Ereh2". I get that if accept finished all instructions before "then abort", then it stops doing the latter part. But why did it do it faster? That had 2 seconds of delay, while the latter had only 1 second.
The first line of a select , except following an 'else' or 'then abort', is called a triggering statement. All that has to complete for one path to be selected is this triggering statement. For task A, this triggering statement is 'delay 1.0'. So, Task A spits out 'Ereh1', since the triggering statement has yet to complete, then the 'ErehX' branch is aborted after this 1 second delay. This is why you never get 'A : Ereh2'. Just remember, tasks can not do two things at once. It may seem like it can due to the slightly wonky select syntax, but it is all rendezvous. As soon as one of these triggering statements falls through (sent signals just need to be accepted by the accepting task, not actually complete), then that branch is chosen.
Ahh, so in other words, until first statement in select is not completed, we do the "then abort" path? And if "then abort" completes before triggering statement, we end the select alltogether? So if I had: select -- this entry call takes 5 seconds to finish B.Complicated_Entry_Call; then abort delay 1.0; B.Do_Something_Else_For_3_Seconds; It'd always do the latter part - assuming the queue for both calls are always empty, and that task B is always ready to select either the first entry call or the other one. But with various queues at various times, it could sometimes do the first part, sometimes the latter? 
[removed]
Task B can not do two things at once, so whichever path is chosen depends on the order task B accepts the signals, how long they take does not matter. However, if those two calls went out to different tasks, an interesting thing will happen. task body A is begin select C.Long_Task; Put_Line("Killed"); then abort B.Short_Task; Put_Line("Not Killed"); end select; end A; Assuming if both calls are accepted without delay and if the process in C failed to be canceled due, the statements following C.Long_Task will actually execute as well. 
Why would it fail though? Is it something that just so happens sometimes, is there some simple explanation, or is it something very complex based on the base concept of this programming language? I'll try not to ask any more questions - I know I can be annoying at times, haha. Once again, thanks a lot. I hope I'll be able to do my task. I was a bit salty at first, that, having 25% chance of getting asynchronous select, I got it, but now I may actually feel more satisfied, having to do the harder route!
It will fail to end the optional sequence as long as the trigger gets accepted and has entered operation. It will fail to stop, presumably because Ada does not want to make Task C erroneous since it has begun execution. If it did abort the optional sequence, it might cause task C to have uninitialized variables, for example. As for why the optional sequence is not stopped after they entry call, I have to assume that it is because Ada doesn't want to implicitly abort execution of an executing sequence. It is fine if the abortable statement is terminated mid execution since it has been explicitly defined that way. I could not find the rationale for this feature, so this explanation was my own; it may not be correct.
What's your Ada background? Is your resume online somewhere? Indeed? Monster?
That was a good read. I'm intrigued about Ada, but I'm also skeptical regarding bloat.
Where are you located? In the US, you're basically looking for some Aero or Defense companies. I wish there were more, but I haven't seen them.
Lockheed is looking for some, but obviously knowing other languages are good too.
Where are you and/or where are you willing to work? I am hiring.
Hm, that is strange. Let's compare 1st and 2nd places corresponding to Makewithada criterion (from my point of view): 1st place: *Inventive*: controlling a brushless motor, hm, not really, 1/10 *Collaborative*: probably, but he used a custom open-source board. 9/10 *Dependable*: 10/10 *Open*: 10/10 2nd place: *Inventive*: Ada watch with IoT, sounds great! 8/10 *Collaborative*: probably. 9/10 *Dependable*: 10/10 *Open*: 10/10 I mean the second place project is really interesting, at the same time who does even care about another brushless motor controller?
You can build it from the source. Source tarball gnat-gpl-2017-src.tar.gz is in the download page.
Actually, you need to go to the download page, select "More packages, platforms, versions and sources", expand the "Sources" link under "GNAT GPL Ada", and download gtkada-gpl-2017-src.tar.gz. Read the INSTALL. You’ll need GTK &gt;= 3.14.0, it seems, I don’t know whether that’s the one in Sources.
Monte Carlo simulations can, since every iteration is completely independent.
Depends on the application and what you want it to do.
Hello, you may install prebuilt GTKAda library for macOS, see XNAdaLib binaries post on Source Forge: https://sourceforge.net/projects/gnuada/files/GNAT_GPL%20Mac%20OS%20X/2017-el-capitan/ HTH, Pascal. 
I ended up compiling from source, albeit with some problems with linker flags, but manually edited shared.gpr and everything compiled fine.
a
I think you might be confused about this sub
If the compiler implementation puts each task on a process that is smart-mapped to its own core, then they each run without blocking each other, but to correctly sequence the assembly instructions to handle exchanged information, blocking on "accept" and the like is necessary. You could simplify the process , for your benefit more than the programs, by making a protected type or a storage_io object in a task that receives data/signals from another, and when it is convenient for the task, it checks that data, processes it, and sends a reply via a similar mechanism to the reverse. This minimizes any blocking to a matter of a few assembly instructions worth, and maximizes the independent operating time for each task. Of course, blocking on a return value is probably more efficient if frequent data exchange is required for the tasks.
Technically yes. Some real-time applications do something similar but it is really fucking annoyingly awkward. The simplest possible way is to just atomically set and poll boolean flags but this makes things difficult. After that you can use nonblocking, lock-free and wait-free concurrent queue algorithms (just make sure to prove bounds overflows are impossible.) I've done [some](https://sstewartgallus.com/git?p=linted.git;a=blob_plain;f=src/ada-core/src/linted-lock_free_queue.adb;hb=HEAD) lock-free programming but it is really annoying and complicated. Also, Ada does not have very good atomics support. The GNAT Lock_Free [extension](https://sstewartgallus.com/git?p=linted.git;a=blob;f=src/ada-core/src/linted-atomics.ads;h=add719613a20423109fa1b80ccb729d1da083d3b;hb=HEAD) makes things slightly easier but is still annoying.
We use gnat, git, jenkins/hudson and gerrit. Is this what you’re asking for?
No, I mean using a build system where someone else can, starting from the same "input ingredients" (OS, build tools package dependencies, your application source code) reproduce _identical_ binary build products. 
I haven't tried using it for ada yet but have a look at nix: https://nixos.org/nix/
More of these articles please. 
The R-1000 seems like it would fit there.
[removed]