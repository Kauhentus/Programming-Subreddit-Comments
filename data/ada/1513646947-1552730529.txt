This group is about the Ada programming language not Cardano crypto currency... though I am sure at least one person here bought some Ada out of nostalgia.
My sincere apologies. I should've looked closer at the description. 
It seems gnatmake produces the same output (executable and object files) on each compilation if sources are the same. ALI files also depends on timestamp of the sources.
Says my wallet is disabled on Bittrex?
On Binance they say there is: "Network Busy, Withdrawl Suspend" and disabled the functionality. It's only for ADA.
Fat fingers....ADA
I don't understand the question. Some background and context would be helpful.
Get both dude, TRX will be huge and very cheap right now. XRP will continue to grow this whole year they themselves are very shocked at ripples success and have nailed/accomplished all of their goals way ahead of schedule. 2017 goals were met by June for example.
Wait if by ADS you mean ADA, I wouldn’t sell ADA this is a gem dude. Be patient.
Wrong Ada - This sub is about the Ada programming language. Not the Cardano Crypto currency. Of course having said that it probably would have been cooler if Charles had picked Ada and/or the subset of Ada called Spark to implement Cardano in as we'd probably be at least 6 months ahead on the roadmap. 
[removed]
TRX
Rewrite it in Ada?
Well, that's a cool story :) Do have a website/blog for your consulting business that we can look at ? 
Thanks for taking the time to read it! :P I'm keeping things a little bit stealthy right now as I build-up a team. I'm avoiding blowing my brains out early in the game. But absolutely, I'm planning on bringing out a very Ada-centric blog in time for our "hard launch". When that time comes, in the not distant future, I'm looking forward to posting some of our articles on r/Ada, and really look forward to constructive feedback!
Awesome story; thank you for sharing it!
Now you need to risk sharing it with the other language communities, /rust/c/c++/java/etc.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Going all-in with Ada: a manifesto X-POST r\/ada](https://www.reddit.com/r/programming/comments/7p66wx/going_allin_with_ada_a_manifesto_xpost_rada/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thanks for sharing your story! On a superficial level, I always felt more at home with Pascal and Lua-like languages, but what really got me interested in Ada was its type system, and the fact that I can have something like C++'s RAII. Like you, I worked through the "Ada 2012" book, and while I'm nowhere near a position to use Ada (mobile development and web design), I always wished for an opportunity to use it in side projects. You mentioned that you were interested in aviation (systems). Do you know perhaps where I could take a look at this kind of software? E.g. not just Ada tutorials, but finished software written for specific systems and machines. I'd be interested in broadening my knowledge about this kind of software, and perhaps also find professional opportunities to employ Ada. Unfortunately, I'm not near Toronto, but if you have some insights to share or your site is online, please tell us :) You do happen to have some kind of branding prepared for your upcoming startup? It's not much, but if you need any help regarding (web) design, I'd be more than willing to help!
&gt; All JSON parsing/generation, HTTP, and TCP/IP was implemented in Ada Did you use Ada Web Server?
You could search for cubesat stuff. Dunno about full avionics stuff.
Interesting. Thanks for sharing your experience. Were you the only developper on this project ? Did you took all the design decisions or were you challenged by someone else ? Did you implemented the JSON, HTTP, TCP/IP yourself ? If yes, was there some available libraries that you could have used instead ? From my point of view, a programming language can only become widely used if there is a strong codebase already existing as libraries.
That’s a stupid attitude to take. Where does this code come from then if all people think like you? Chicken and egg!
Interesting you mention the 777. I worked on the first funded Ada compiler back in the 80s. One of the early projects we were involved with was the fly-by-wire system of the 7J7. This plane was eventually cancelled but the research into it went directly into the 757, 767 and 777. Ada is a beautiful language. It has always had a bad rap of having been designed by committee, but in reality Jean Ichbiah's design elegantly incorporated the requirements into a very consistent framework. We'd all have been better off if it had been more successful in the marketplace. It was kind of a ["worse is better"](https://en.wikipedia.org/wiki/Worse_is_better) story.
another chicken and egg problem for you to seriously consider is that of people being discouraged from joining a community because of the aggressive tone of a few members of that community 
If you think that’s aggressive, you seriously have a lot to learn. Also, I’m sick of the same old reasons for not using a perfectly good language as “there’s a lack ecosystem” and “well, I’m not prepared to write anything.” It’s incredibly tedious.
&gt;We don't build buildings for the convenience of construction workers We also don't pay construction workers $100-200/hr to build buildings. The convenience of the software developer matters to the bottom line. &gt;We need to do a better job at building software, in general. I believe Ada is the best positioned language to facilitate the implementation of properly developed software, in general. I wholeheartedly agree with you. I've tried and failed to convince my team to start using Ada. There is a great deal of inertia around the idea of learning a new language just because it's demonstrably better. I wish you the best of luck. Maybe with a startup, you can affect change. I have a feeling those of us in a more established corporate culture won't be able to do much. ------------------------------------------- *erratum*: &gt;I have never fo**u**nd more enjoyment writing software than I did in Ada. 
I'm also curious about this. Partly community support is interesting, but is the code also audited, certified etc. etc.? This is of course less interesting from a mainstream p.o.v., but for mission critical software this is first in line.
Well I see someone has already brought it to our colleges in r/programming. Obviously the topic has been more controversial there. I've always been for lively discussion, and especially the interaction of controversial viewpoints. It gets people thinking, and as long as it stays about thinking, I think it's a good thing in general. For myself, I actually find Ada is something that will see more use through general awareness with the non-programming sides of things. On the business ends of things, I've found that, for example, bringing up how much easier maintenance tends to be with Ada, allows clients to stop worrying so much about the future, and what if their programmers leave, etc.
If you find these properties of a language interesting, you might like to check out Haskell and perhaps even Idris - even more power :)
"Widely used" != "used at all". There's no chicken and egg problem. He's saying that a language can be used, and worked on by a small community without a strong base of libraries, but that it will only become *widely* used once it has that strong base of libraries. I have trouble coming up with a counter example. Maybe Javascript? In any case, I do think he's almost certainly right for most cases.
Remember that 757 crash where the grounds crew put silver tape on the pressure sensors and the plane went down killing a few hundred? I think it was in S. America somewhere. I wonder which part of the flight control system failed to compensate for such an eventuality?
Well, starting your comment with "stupid attitude" is not a great welcome either. Anyway, I agree with you that the argument about ecosystem is widely used and is not a good one as we don't build Lego but software. Ada is a good language and there are good libs out there.
Do you still do Ada or keep up with the newer specs? As you've worked on an actual compiler, there is interest in building another, what were the hardest parts to implement? 
I'll quickly start with your questions: - Yes, I was the only developer. - I considered libcurl, and also libressl (ended up offloading SSL to nginx for now). In the end, I wanted to create a very strict, clear, and light-weight implementation - Finally I should say, I am definitely a supporter of open source, generally, but at the end of the day I'm a business, and GPL can be problematic. So I wanted to be prepared for the future with my own libraries that I can safely control the licensing of. Though to be honest, I am very excited to bring out work into the open source community, but probably with a BSD license. One specific project on that end I want to see in the near future is a more lean Ada port of libressl. That would be open-source. I totally recognize your standpoint on the existence of libraries, and I don't necessarily oppose that sentiment. However, personally, I prefer getting more down and dirty and being more focused and specific to the application. In other words, I kind of enjoy doing the dirty work. I also find something unsettling about, say having a JSON-RPC kind of API, and using curl just to handle the basic HTTP wrapping of JSON objects. That's a whole lot of machinery for a very simple task. What's more, it leads to a lot of potential for unforeseen vulnerabilities. To elaborate a bit more with yet another example: The HTTP back-end I produced was extremely strict. For example, there is a configurable limit on each HTTP Header line. This limit is actually specified as a generic parameter with no default, one of those is exceeded, the request is immediately rejected. I did this to more efficiently handle attacks. I don't think its enough to just protect against buffer overflows, we need to protect against attackers *simply wasting resources*. Another thing I should mention - although I made use of storage pools, all storage pools were strictly single-object arrays, and the pools are always preelaborated. The API doesn't use any heap at all. And that's very intentional. That's very hard to do these days with external libraries. But I'm interested in software that has no theoretical limit to it's run-time, and that has zero risk of degrading over time. I also found it interesting that after running for 5 months, the API did not generate a single page fault. Furthermore, I feel it's a better attitude to not be so reliant on external libraries. Honestly, if I had things my way, programming would be taught starting with assembly. I say that because I think its important to always keep in mind what's happening behind the scenes, rather than simply take it for granted. But I recognize this is a pretty controversial stance. I definitely don't want to go as far as to say that's the only right way. At the end of the day, it comes down to the needs of the project, and the style of the programmer. 
&gt;Lack of braces cause them problems? No, they were just afraid of being different (we do a good portion of our work in PL/SQL, which is Pascal based). The team was concerned that if anything went wrong, management would blame the different language and our team. Risk aversion has been very strong in the teams I've worked with in the corporate environment.
No, my argument is that people keep saying, "oh, Ada's nice and all, but it lacks x, y and z, so I'm not going to bother even though it's better that languages a, b and c." That's really stupid, these could be the people helping instead of hindering. As for you people who think calling something "stupid" is aggressive, I suggest you go have a word with Linus Torvalds, I think you'll come back here shaking in your boots after he calls you a "fucking idiot," which he has done to people in the past.
Thanks! And I also want to thank you for your constant avocation of Ada on the front lines. I looked through a lot of your posts and you have a great attitude towards others. You're definitely a role-model for me on Ada advocacy. 
I'm not well-versed in the exact regulations or standards, but I was involved in a medical device project where they were required to adhere to MISRA C. So any 3rd party library had to live up to those requirements, which somewhat limited to readily available code. I'm not sure how the regulations change between industries.
Ahh. Would be SPARK then in Ada's case.
So all coded by hand using Sockets?
Absolutely, having a SPARK/Ada code with verified pre and post conditions is absolutely such a guarantee, but the specific requirements will of course vary from each project, company, industry and country. Have you used SPARK? I've only read about it and honestly I found it very restrictive for "normal" code.
I never said I appreciate Linus way of speaking and from my point of view, it's not because he affords this that every one should be pulled down this way. Moreover, I would definitely discourage anyone I don't know to speak to me this way in real life.
Oh man, as nerdy as this is - I sometimes fantasize about getting to actually see the 777 PFC code. I don't think it'll ever happen at this stage, but man would that would really give me an ear-to-ear smile. As for broadening knowledge - I'm a huge advocate of broadening knowledge in everything, and for everyone. I will literally go as far as saying that education is the solution to all the world's problems. But fear not, because we are in the golden age now. It's so easy to find more information, and the more you take in, the faster you'll get at taking it in. You already meet the only requirement: thirst for knowledge. I also believe that cross-pollination of ideas is severely under-rated. Like I said, although I was the old-school self-taught type when it comes to programming, I didn't major in CS or engineering. I majored in architectural design. But I think that training has been extremely relevant to informing my software design. There are a lot of problems in designing buildings that are also problems in designing software. Examples are working around hard limitations (performance, memory, bandwidth, etc.), about ensuring long-term maintainability (carefully delegating roles and responsibilities, for example). Also the idea that "once it's running, you can't stop it" kind of mentality that is obvious in architecture, but often ignored in software. There are always going to be employers that give you hard requirements on your credentials, but there are also ones who don't. I think history has made it pretty clear that talent doesn't come from a degree. If you're good at doing something, you're good at doing something. The most *valuable* traits, in my opinion are 1) Humility - no matter what the evidence, never let yourself believe you are elite. 2) Desire to learn from others - people's opinions, even if you know you will never agree with them, will only open your mind further, and; 3) Raw, passionate interest in your craft. Branding is mostly done, and I have a very nondescript site up (annexi-strayline.com). I actually had a website more ready to go, but I didn't want to bring in too much attention as I'd rather not have clients I can't serve yet.. I think help will be needed in the near future, I'll PM you!
Oh I agree, I'd totally knock him out if he spoke to me that way. But again, saying something is stupid, when it is, is not a negative or aggressive thing you lot are making it out to be. I'm not a yes man, never was, never will be, I'll likely disagree with your opinion.
[removed]
Do you mean DDC-I?? Wow this is really neat to hear from you! I'd love to hear more! How was the general feeling in your team about Ada at that time? I heard that compiler was built on VAX/VMS? It sounds like it was a pretty pioneering project, and sounds pretty exciting. I'm personally a bit of a nerd for 70s-80s computing, and I found it striking how advanced Ada was for it's time (and honestly still is, in my opinion).
Interesting criticism you raise towards comparing construction workers with developers. You definitely have a point there. But I do want to clarify that my intended meaning was more about construction projects not being about the construction workers. My counter-point to business people on this is that while it may mean you get "delivery" sooner, you need to be careful not to forget about the long-term. The truth is, bugs cost a lot of money, and making changes to software usually is much harder than it needs to be. So in the long-term, I argue, it is extremely cost efficient to "do it right the first time". But, I digress, you really raise the key issue. I only hope you will keep-up your efforts! Thank you for your encouragement! Edit: typos
This - this is a great point to start. Also for learning more about SPARK!
Congratulations on ensuring your job security. 
Thank you for your feedback. I'll definitively have a look on Ada. I heard great things about Ada years ago but I never made further research because I thought it was limited to critical systems. I agree with you on the libraries part, especially if they didn't completely fulfilled your needs. I'm working with Java and C. We use the framework Spring in Java so it mostly consists at stacking blocks for the most technicals parts.
[removed]
Yep! (for the TCP/IP package) :)
LOL, well I hope you're right!
Did you use any external libraries?
Interesting question! In fact, this is one of the things I think unfairly eliminates Ada from projects - the idea that Ada is only for safety-critical software. Like any drive towards perfection, the relationship of effort to result is a logarithmic relationship. So if you reduce the requirements even a little, it gets a whole lot easier (and cheaper). That being said, this is part of the larger business-model, but for this particular project, no there was nothing like that. But it wasn't really *that* mission critical. And honestly, I don't think every project needs to be that "certified". It's a typical exercise in cost/benefit. But absolutely this is something I intend to offer to clients, and as I grow, all code will be reviewed by others. Also we will offer SPARK, and for clients who need that, then we'd say, well, we need to bring in the big-gun tools like GNAT Prove, and certified compilers. 
Well technically libc, but this is really just for system-call binding. As in I go direct to socket, setsockopt, send, recv, etc. That's it. No other libraries.
I wondered why OP didn't use librairies. He replied that they didn't fulfill his needs which is a reasonable reason. These 3 parts are recurrent needs when working on web problematics so it would be really surprising if there was no librairies available.
A specific requirement I was put off by was on tasking. No nested tasks, no queuing are the two I remember as being particularly limiting. Hopefully the next iteration of SPARK and ravenscar will bring more flexibility in this area. But you are right, with the right architecture and foresight it is possible to work it out and then the benefits of SPARK -- or what ever requirements -- can be reaped.
&gt; Also the idea that "once it's running, you can't stop it" kind of mentality that is obvious in architecture, but often ignored in software. What a wonderful mentality.
Not DDC-I. Softech. They were one of the 4 finalists in the design competition that Jean Ichbiah's Honeywell-Bull team won. Softech was given the first compiler contract as a consolation prize. Everybody there was enthusiastic about the language and the fact that we were building a cutting edge tool. 
Not at all. Due to circumstances I ended up doing a really different type of development. I wasn't strictly involved in the compiler. My background at that point was real-time process control so I worked on the run-time system which handled all the IO, threading, inter-process communication, etc. 
&gt; So in the long-term, I argue, it is extremely cost efficient to "do it right the first time". There's a whole school of software building which argues that the first time you simply have no idea where you are going, and therefore it is more important to iterate quickly so as to gather feedback and refine/evolve the requirements. It bothers me on a certain level (I don't like the "Move Fast and Break Things" motto), but I certainly recognize a nugget of truth there. The best received projects I've worked on all had early and frequent feedback in the making process.
This is interesting. My view on this is also another reason I appreciate Ada - it sets limits. A lot of languages seem to be about removing any and all kinds of restriction and limit. This is loved by many programmers, and I'd say regrettably that's usually because of over-confidence in their own ability to stay disciplined. I've always found that working in limits spawns the most creativity. If you want to craft something really well, you need to set limits first, and learn how to work within them. So in the case of Tasking, now allowing nesting Tasks is a good example of a reasonable limit. As a software designer, my position on that would be - if any task needs it's own tasks, then that task is being assigned too large a scope. In Ada especially, creating and retiring tasks is insanely easy. In other languages, task management is usually not even part of the language itself (C# for example), but awkwardly tries to be. In this case you naturally want to cram as much functionality into a thread as possible. I think Ada deliberately tries to mitigate this behavior. You don't want one task calculating the control laws for every control surface. And you definitely wouldn't want one task containing separate tasks for calculating all the control laws. 
Meh, I know hundreds of people who learned ada in college. 
I have worked extensively with ada, the poster is pretty much spot on. I should also point out that the product I worked on had approximately 400 developers working on it in the same building ( and another 300 or internationally. ) and the codebase was approximately 30 years old at the time. ( and is about 40 years old right now. ) ADA was the result of a 5 year long design process to create a programming language which was resistant to human error. Ada is a extremely strongly typed language with full typing for 'primitive' types, with more flexibility ( as well as structure and enforcement ) than any other language I have professionally worked with. so Lets say you need to create a small physics application, you would define a numeric type for 'meters', then another type for centimeters. then lets add 3 more numeric types for hours, minutes, and seconds. and a last type for Kilometers per hour. Lets say that all of these types are defined with a range of 0 -&gt; 1,000 and 4 decimal places ( Yes you can specify fixed or floating point decimal places. This would look like so: type Meters is digits 4 range 0.0 .. 1000.0; Ada makes it pretty much impossible for you to accidentally cast seconds to minutes, but lets say that you want to do some math, you would have to define a operator overload to make it possible to add them together ( and you would be forced to do the mathamatical conversion at that point. ), and you can even go a step further and have adding minutes and meters to return a KilometersPerHour type. You can also define 'packing' for your data types, so if you need to you can state that your newly defined numeric type is stored in LSB order even though you are in a MSB architecture. Adding onto that the fact that you can overload 'assignment' operators ( so you could do math in radians but store that in degrees ) In essence the compiler catches 90% of potential bugs in such a way that coding conventions struggle to do so, and couple that with the fact that ADA is a systems language ( so you have access to pointers, and can define data structures in any form down to a single bit. ) but of course this isn't surprising for a programming language which was designed to control, missiles, submarines, nuclear power plants, and planes. 
Thank you for that. This post has really sold me on doing more research into Ada. I'm always excited to find a better way to write more correct code. 15 years into this profession and never stop learning!
&gt; we do a good portion of our work in PL/SQL, which is Pascal based PL/SQL is actually somewhat based on Ada [see: [wikipedia](https://en.wikipedia.org/wiki/PL/SQL)], and it's even demonstrable in the article [Who (or What) is DIANA?](https://www.safaribooksonline.com/library/view/oracle-plsql-programming/9780596805401/ch24s01.html). If there were any more DIANA-based Ada compilers, Ada and PL/SQL could enjoy some **_really_** nice environments and interoperability.
**PL/SQL** PL/SQL (Procedural Language/Structured Query Language) is Oracle Corporation's procedural extension for SQL and the Oracle relational database. PL/SQL is available in Oracle Database (since version 6 - stored pl/sql procedures/functions/packages/triggers since version 7), TimesTen in-memory database (since version 11.2.1), and IBM DB2 (since version 9.7). Oracle Corporation usually extends PL/SQL functionality with each successive release of the Oracle Database. PL/SQL includes procedural language elements such as conditions and loops. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ada/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Thanks for the thoughtful reply -- I got some details mixed up and I will clarify them here. I've referenced some material to find exactly what I'm thinking about :) First of all, Ada allows for nested Tasks called Task hierarchies. I was thinking about the limitations of SPARK, but then I realized that my concern was... misplaced. SPARK 2005 included the Ravenscar profile and this is the only constraint in regards to Tasks -- same goes for SPARK 2014. [A complete enumeration of the Ravenscar profile is listed here.](http://www.adaic.org/resources/add_content/standards/05rm/html/RM-D-13-1.html) Note that Ravenscar is specifically meant for critical, high-stakes application -- here predictability is key and hence the stringent requirements. However, for most typical programming this requirement will be quite a challenge: no task termination, no dynamic attachment, no dynamic priorities, etc. is throwing away a lot of awesome capabilities, which would make normal multithreaded or concurrent application rather limited or convoluted in their design. After reading up on this, I realized that Ada has an incredibly flexible and powerful Task feature which provides a lot of options -- but adhering to the strictest requirements for all application can also be unnecessarily limiting. For example, if all Tasks had to be statically attached at all time each process would use a lot of resources on just switching between Tasks and keeping track of them -- this is fine for safety-critical software (limited number of tasks), but desktop applications ought to be more conservative in their resources. Imagine if Chrome or Firefox had to preallocate all possible threads! I haven't looked much into SPARK, but it seems like it isn't that much of an all-or-nothing that I remember. This is very nice! Maybe I should find a project where it could be applied as a test. --- Also, I am amazed that Ravenscar is literally just a profile. Just a bunch of pragma and suddenly Ada provides much stricter control of Tasks!
Ada is a extremely overlooked language, it even has all of the modern OOP concepts, hence why it used to be taught in Australian universities in the early 90's but fell out of favor when java started to rise in popularity. The largest issue that I had with the language is that validation: at least the # of parameters needs to be the same. Make sure that if you load parameters with different #s of parms (lower number first then higher numbers) just to make sure it does not crash. it is very slow moving and verbose, the majority of the time the price that you pay for more deeper static analysis at compilation time is paid for by developer hours up-front. but sometimes you do have a happy suprise ( I once wrote a complete radar message parser&amp;Builder in an afternoon, and for regulatory reasons we also needed an implementation in C, which took 3 days. ) 
You can’t do everything statically, I.e sometimes you need dynamic memory.
[removed]
&gt; Though to be honest, I am very excited to bring out work into the open source community, but probably with a BSD license. One specific project on that end I want to see in the near future is a more lean Ada port of libressl. That would be open-source. BSD's pretty good, though I'm a bit more partial to MIT myself. Someone on comp.lang.ada was interested in doing a SPARK-verified OID, and I think there might have been talk of a SPARK bignum library... Both of these would be useful in an reliable implementation of SSL and TLS. 
As someone who is into cryptos and finds ADA (the cryptocurrency) appealing for similar reasons you find the language appealing (safety-critical software), this post had me very confused until I had read through about half of it and realized I was in r/programming and not r/cardano..
Fell out of favour...when Sun started paying tons of cash to unis and companies to use Java, unfortunately.
Now that you mention it, the MIT license says a lot of things I like, I guess I overlooked it. It's growing on me! I'm also working on a very general Hash package that also contains packages for the manipulation of large numbers, as well as a very generic method of doing bit-wise operations on such large numbers. I might as well just open source that.
* Please start an ADA blog. Write this post on there. * Then post about libraries and tooling, including IDEs, debuggers, in Ada. Compare the state of libraries and tools for Ada with Go, Rust, C++, java. * Is it feasible to have Ada on .net or the jvm so you can get Ada's benefits with the ecosystem of either .net core or the java jvm as well? 
Have you learned Rust and Haskell? What kinds of things can Ada do that they can't do in Rust and Haskell?
And you point is?
did you even read my post above ? how would you define a type ( not a class but a type ) that represents a fixed point decimal number ( 0-&gt;1000 with 4 decimal places. ) and then prevent a programmer from accidentally adding that to another numeric type with a total of 4 bytes of ram in 4213 byte order in memory? AFAIK those 3 requirements put together are completely Compared to ADA Haskell is weakly typed, and rust is unsafe, both have a flavor of the month feel to them, and I am unaware of any serious safety critical (e.g. bugs cause people to die) projects using either of those languages. 
&gt; (I don't like the "Move Fast and Break Things" motto) Did you know that even Facebook, who coined the term, rejects it now?
You can’t check everything at compile time. What’s an insane byte order?
I just got hired at a relatively small shop, recently acquired by a multinational, and we use a mixture of Ada and C++. Actually, they're starving for Ada people now, which is why I'm trying to learn more. Ada is everywhere, we just don't see it. It's not a "sexy" language or as common as C++ or Java, but it's everywhere in embedded and realtime software for historical reasons.
Thanks for the extensive post. Ada caught my interest during a presentation at [FOSDEM](https://fosdem.org), but I haven't really had the chance to do something with it. Everything I hear about it sounds great. I just hope it gains popularity and gets more mainstream. 
First, Ada is a complex language with around 70 keywords. Second, the type system is really rich and can sometimes be overused leading a kind of "type hell" with too many types defined but that's a problem on design side not language one. Third, not a language for hacking, you have to define clearly what you want to do and design it the proper way. It is still possible to do few small programs but not the quick and dirty way :)
That’s where people like you come in.
[removed]
Here is real world code among many others yo can find on GitHub: Base64 in Ada https://github.com/cforler/Ada-Crypto-Library/blob/master/src/crypto-types-base64.adb Base64 in C http://fm4dd.com/programming/base64/base64_stringencode_c.htm 
Really!? Do you have some links for this, I couldn't find something from a web search.
You are so right about everything you said. I'm very much looking forward to doing exactly this is the very near future with out blog!
I'm stunned, humbled, and very excited by the amount of attention my post received. There has been a really great discussion, and I think the programming community at large raises a lot of important points about the availability of libraries, easy access to a compiler, and open source. I think we in the Ada community have a real opportunity to showcase Ada's exceptional ability in building reliable, highly complex, and maintainable software. In fact, I think Ada is ideal for the open source community, due to it's natural focus on readability. We have a lot of work ahead of us!
This is a totally fair point you raise. I want to preface that some of the most common criticisms of Ada, I personally think are strengths. One example is how "wordy" Ada is - I don't think this is weakness. I've written thousands of lines of Ada, and in my experience, it was smoother to write than C-syntax languages. I think that's because so much of it is natural language. Ada is more human - and programming languages, in my opinion, should target humans, not machines. So with those typical cases out of the way, I want to talk about what I think are the cons. Every language has cons. But, I think its a very subjective evaluation. For one, I initially felt like Ada's pointer system left a lot to be desired. I found it, in a sense, odd that with Ada's tagging system, as well as with its bounds-encoding system, that more information can't be stored with an Access Type, to allow more explicit management and checking of Access Types. As it stands now, there often times where one is forced to use "Unchecked Programming" features in order to achieve a reasonable goal. However, if you are trying to build a highly robust, reliable system, Unchecked Programming is really a dirty word. I've found myself needing to be overly contrived, just to avoid Unchecked Programming. The counter argument, however, is that the inconvenience of Access types is intentional, because they are inherently dangerous. Personally, I strongly agree with this sentiment - I do not think 99% of programmers can be trusted handling pointers properly. It only takes one mistake. By forcing Unchecked Programming, it's easier for code review to find every since instance of Unchecked Programming automatically, allowing the necessary testing to ensure safety. And if you do not use any Unchecked_Access, Ada can ensure, at semantically, that you will not have aliasing, null dereferences, or late referencing to stale objects. Another contentious "con" I run into is just the effect of the discipline Ada enforces. You really need to think about the design before you do the implementation. I personally feel this is one of the biggest strengths of Ada, but I also recognize that so much of the programming community is very use to the "hacking" methodology of programming. Trying to hack something together in Ada is very painful. This is, I think, the most common reason that heavy Python users seem to have such disdain for Ada. Python is meant for hacking, it's meant for just "doing it", without much planning. Now, I realize that I didn't really give any con, because I also see most of Ada's cons as actual pros. But that is the contentious nature of Ada in the mainstream space. Ada challenges a lot of assumptions, and especially, is a language that never had the convenience of the programmer in mind. Aside from brain***k, and possibly assembly, I don't know of any language that doesn't have the programmer's convenience front and centre. But I'm definitely on the side that the programmers convenience should not ever come first. I will be honest and say, personally, Ada is the most carefully designed language I've ever heard about or worked with. But I also understand why so many people disagree. 
- That is my plan! - Great suggestion - It is, but I personally am not interested in this, but would welcome it.
I absolutely do not agree. With virtual memory and with the amount of main memory typical in today's systems, you can afford to make specific compile-time reservations. Ada has a great Storage Pool system which allows you to create totally custom dynamic memory systems, which are capable of things like garbage collection. So you can get the semantic appearance of dynamic memory, while being able to completely eliminate fragmentation, and to be able to have a fixed memory reservation that doesn't change. In the end, dynamic memory is and always was a programmer convenience device. Without it, you need to consider what your maximum use might be, set a limit, and decided how you will handle hitting that limit. This is inconvenient. Also, in the old days when dynamic memory was first introduced, the system core memory would be a few hundred K, which made it a lot more restrictive to chose safe static allocations.
Yes. They moved past the start-up stage I guess :)
It has a few less keywords than c++ last I counted.
Most of the time your dataset is not unknown though, people are just lazy and don't bother calculation max size of allocation. 
Nothing against Ada, but I can't think of any reason I'd ever use it instead of Free Pascal. The quantity and quality of tooling and libraries available for FPC is just massively higher/better. It also supports far more platforms than any Ada compiler. 
Like I said, desktop apps. Take a word processor, going to load unknown sizes all the time.
&gt; Principle of Least Amazement How is Rust amazing?
The first few decades of software development used the paradigm "do it right the first time" and it simply does not work with almost all modern software of any size and hasn't done since the 1990's. 
I suppose "Principle of least astonishment :D" https://en.wikipedia.org/wiki/Principle_of_least_astonishment
**Principle of least astonishment** The principle of least astonishment (POLA) (alternatively "principle/law/rule of least astonishment/surprise") applies to user interface and software design, from the ergonomics standpoint. A typical formulation of the principle, from 1984, is: "If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature." In general engineering design contexts, the principle can be taken to mean that a component of a system should behave in a manner consistent with how users of that component are likely to expect it to behave; that is, users should not be astonished at the way it behaves. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ada/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Yes, I know. But that's not what I asked. I asked "How is Rust amazing?" Because to me, it's not.
The compiler errors are amazing.
Would have thought the level of assurance gained by using MISRA C would be roughly equivalent to that gained by using Ada at all - no need to go to the level of SPARK.
Access types in SPARK are still being worked on; they _might_ make it into the 2018 community edition
This article would indicate that would not be the correct assumption: http://www.adacore.com/uploads/technical-papers/2016-10-SPARK-MisraC-FramaC.pdf Granted it was written by AdaCore, but the content seems right, at least based on my limited experience with using MISRA (note: I've never used SPARK but have read about it). 
First of all, the mere usage of Ada does not mean your software is guaranteed to be bug free. No one is making or should make such a silly claim. However, without any doubt it does help to avoid many common software issues. I am glad that marc-kd addressed your Ariane 5 reference because too often people wrongly use that as an argument against Ada. As for Oberon2, I have never used it, but the only way it can be so simple is if it completely ignores to address many of the *complex* issues that need to be addressed in safety critical software. So comparing Ada to Oberon2 is not a good argument.
I also think it depends on what parts of MISRA are considered. "Code must not be commented out" is one of the directives which is a good practice in any language. MISRA also specifies how to handle deviations -- a good practice! The great strength of Ada in these regards also lie in its design. Doing unsafe/unchecked actions is possible, but is quite verbose and explicit.
Too a quick look and I was surprised to see the breadth of features in Pascal -- can you recommend some resources to dip the toes?
[removed]
FOSDEM is one of the best conferences to get updates about Ada in the wild. They have been having an Ada track for several years now.
&gt; Have a wild guess; what language was used to write the Ariane code? It's always people who don't know what they're talking about who trott this one out. The reason that failed was management taking a shortcut and not testing, not the implementation language. This is out on the internet if you actually cared enough to find it. &gt; – Nicklaus Wirth, together with his team in ETH Zurich, has designed &amp; developed the succession of beautiful languages starting with Pascal &amp; Modula 2 and finally ending up with Oberon 2. The absolute beauty of Oberon 2 was that its entire syntax, defined in the EBNF notation, would fit into a single side of an A4 paper. Using Oberon 2, they also developed the entire operating system with a fully functioning GUI/Windowing interface. And the entire source code of this operating system was compiling in 50 seconds. Wirth's languages are small, but they're not that pretty. Their syntax is generally pretty ugly, the begin...end in if blocks and loops are unnecessary, see Ada's, his insistence on confusing ; and . placement or not are annoying. The fact that his language specs can fit on a few pages of A4 is because they're full of holes, i.e. implementation defined, undefined stuff all over the place. This causes variations and therefore incompatibilities in implementations. See the various implementations of his languages, i.e. Pascal, which was never meant to get out of the classroom had to be modified extensively by implementers to make it capable of being a real language instead of a learning (toy) language. &gt; – On the other hand, the language specification for the ADA language was a kind of mini encyclopedia with hundreds of pages. And the most alarming part of The spec spells everything out to implementers. 
Yeah, I'm planning to visit one or two talks this year as well!
[This is the official documentation page](https://www.freepascal.org/docs.var) [There's also the official wiki](http://wiki.freepascal.org/) [This is the official forum for both Free Pascal and Lazarus, which is very active with many people typically happy to help beginners](http://forum.lazarus.freepascal.org/index.php?action=forum) [This is a great tutorial specifically geared towards teaching Object Pascal with a modern style](http://castle-engine.io/modern_pascal_introduction.html) The author of the above tutorial is also the author of a really cool [game engine called Castle](https://github.com/castle-engine/castle-engine) which is worth checking out as well even if you're not into game development as it's a great example of a clean, modern Pascal codebase that makes use of most of the more advanced features. (And no, I'm certainly not the author pretending to be someone else if anyone's suspicious.) Additionally I'll reiterate that if you're wanting to do any GUI development in general, the Lazarus IDE, which is written entirely in Free Pascal, is essentially designed as a more extensible, open-source, cross platform drop-in replacement for Delphi (to the point that most Delphi projects can be directly converted to build in Lazarus with FPC without too much trouble.) It's great for non-GUI stuff too though and is definitely the easiest way to work with Free Pascal overall on any platform (as it integrates heavily with the compiler and gives you real project files that can have multiple build profiles, e.t.c.) Lazarus also has lots of additional original features and functionality of it's own, and is generally a very stable IDE as it's a mature codebase (been around since 2001.) Work is always ongoing on it though and there's always useful new stuff being added (for example, as of recently it now has an integrated online package manager.) [Here's a screenshot of the Lazarus form designer in action](https://i.imgur.com/HiRj2Xy.png) [And here's one of the code editor](https://i.imgur.com/UPDFCPc.png) Note that although I'm obviously running on Windows there, it is in fact, as I already mentioned, a highly cross-platform IDE that can also run natively on and build applications for Mac, most Linuxes, and various others. If you're wondering how it does this, basically, the LCL (Lazarus Component Library) which all the visual controls are built upon is designed to be an abstraction around any underlying framework capable of implementing it. These different backends are generally referrred to as "widgetsets". So on Windows, there's the Win32/64 widgetset, which implements everything with native WinAPI functionality. For Linux, there are GTK2, GTK3, QT4, and QT5 backends that you can choose from. On Mac, you can use any of the Linux widgetsets, plus Carbon or Cocoa as well. All of this is still written completely in Free Pascal, as it's capable of interacting directly with and linking against C and C++ libraries at a native level (the compiler is also written in Pascal plus some inline assembly language to be clear though, and builds itself. There's no C or other languages anywhere in the codebase of the overall toolchain.) Everything about Lazarus works exactly the same way and uses identical text-based form files no matter which backend you use, with the only differences being the obvious overall aesthetic ones in how the different frameworks render the controls themselves. So you just write a project once using any version of the IDE with any backend, and can then also build it for as many of the other ones as you need or want to without changing any code. [Here's a screenshot of someone (not me this time) running the IDE on Linux Mint with one of the GTK widgetsets, for example.](http://wiki.lazarus.freepascal.org/images/d/dc/Lazarus1_6_Linux_Mint_17_2.png) Not trying to derail anything with this long comment, just so you guys know... I know this is an Ada sub, not a Pascal one, haha. I just like to answer questions as thoroughly as possible when asked!
Really interesting -- thanks for the links.
Wrong sub.
a company behind a cryptocurrency called ADA
Shame you lot didn't write the code in Ada.
Raspberry Pi is nice and all, but the lack of schematics and public device documentation makes it a no go for me/the projects I am working on). I’m also much more frequently working at a lower level. Interesting project nonetheless. 
You raise a very interesting prospect for me, which is combining code in Free Pascal and other languages. Thanks for bringing up FPC.
Glad I could help!
This is part of Ada's strong typing capability, which is fundamental to the language. The use of range types is quite ubiquitous, I would say, because when they are used wisely, they are very powerful in (a) protecting against human error in coding; (b) making future program extension and maitenance much safer; and (c) enabling more powerful static program checks possible. I'm sure I have forgotten other benefits!
I’ve not written a large Ada project, but whenever I do code I always find natural and positive subtypes to be immensely useful.
I've made a small project dealing with music scales. Defining my own types was mandatory. First, enumeration of notes and interval qualities (minor third, fifth and so on) avoid many problems of using integers in the same place. It also allowed me to define scales as arrays of boolean indexed by qualities. Then we usually perform computation (ex: was is the fifth of B note?) using modular types. That was really easy using a type like this: type Note_modular is mod 12; -- Number of notes = 12 Then computation were really easy.
Recent Gnat versions will do the work for you with the -Es binder parameter.
There will be several presentations from the introduction to Ada to really technical ones for the experienced developer
One place where it is particularly useful is in packed encodings of records. For a binary protocol or memory mapped interface a certain field might only occupy, f.x., 3 bits of the package. Using the ranged types it is possible in Ada to guarantee that pulling data to and from these fields will never overflow. Further, using SPARK these conditions can be proved and thus safely removed (rather than confidently removed) -- however, I've never used SPARK, so I can't comment on the actual behavior in it.
[removed]
Buy more or sell, is the question?
Actually, I forgot to mention switch options -g during compiling, -E during binding and -g during linking needed for full trace back to work properly. Otherwise, only addresses are printed out. 
Wrong sub
[removed]
Just checked seconds ago. It's good from here... YMMV.
I keep getting File not in classpath roots: /#!topic/muen-dev/1ILwIz8h-kM Error 404 So MMDV!
So they use virtualization instead of traditional kernelspace/userspace approach, am i getting this right?
I'm looking at it using a desktop Chrome browser. Also checked with Firefox. All good. Sorry!
The Muen webpage https://muen.codelabs.ch/ has more about the design, and links to the source code. (See the pdf's in the Documentation section).
Here you go (TL;DR - Muen is not vulnerable to Meltdown due to not relying on Security Ring separation and instead relying on full virtualization): -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA256 Hi, We thoroughly studied the potential impact of the recent Spectre/Meltdown speculative execution CPU design issues on the Muen Separation Kernel. In this mail we would like to share our findings regarding Meltdown. The analysis of Spectre will follow in a separate mail. For the technical details of the Meltdown vulnerability the reader is directed to the associated papers and blog posts [1][2][3]. = Introduction Meltdown is part of a new attack class which relies on observing side effects caused by speculative instruction execution by the processor. It is also referred to as Rogue Data Cache Load (CVE-2017-5754). For a successful Meltdown attack, three requirements have to be met: (1) The memory space of the unprivileged attacker contains privileged memory mappings to which the attacker has no access (U/S bit not set) (2) The mappings contain desired information (3) The attacker can measure the timing effects introduced by its attack = Assessment Muen uses VT-x and not ring-0/ring-3 transitions as isolation mechanism between subjects and the kernel. As VT-x transitions automatically switch the memory layout between guests and the host, Muen does not use the User/Supervisor bit in page tables for the enforcement of access rights. Consequently the precondition (1) for the attack is not met and the Muen kernel is not vulnerable. Subjects which internally rely on ring-0/ring-3 transition (e.g. Linux, Windows) are vulnerable from local attacks unless adequate mitigation is performed at subject level. E.g. for Linux guests, Kernel Page Table Isolation (KPTI, formerly KAISER) must be enabled. = Conclusion Meltdown is defended by our design decision to have a simple architecture which only utilizes a single isolation mechanism: hardware virtualization. We prioritized a minimal design over performance considerations and decided not to use ring-3 in VMX-root mode for native subjects. Since Meltdown only affects the ring-0/ring-3 isolation mechanism we were spared from that pit of lava. Kind regards, The Muen Team [1] - https://meltdownattack.com [2] - https://googleprojectzero.blogspot.ch/2018/01/reading-privileged-memory- with-side.html [3] - https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Ana lysis-of-Speculative-Execution-Side-Channels.pdf -----BEGIN PGP SIGNATURE----- iQIzBAEBCAAdFiEEtRpRfLSe/E8H4OecpJ58PN48zmYFAlpeE9cACgkQpJ58PN48 zmZQYQ/+N9YrE0sory5dEjylc265cwJMhEiMVqfKizRFpqKGT2uvc3vab5yGXYKk +w9MqTZX4lJjXJTQGf89K/x9wjtnZglvJIEuqtXlqcbTRsOkeyx9bY6t9HBMNOF3 20h+LFeT6DzmIXWnY9sJ6vbvi+gy3z3FUAUOMAEnsDahGc7420SJED3qJCXvXWBo GGZRFUJKr7W56BfoTUBDwbaXDI0YWVyr9Kag01/JvTHqI7A9hMdXg9clTeKTWNFW 0ja5Zhs5tTSCEu29k990dmjb2TXHH33pCHvRqlwH8fcTlkKQpB/ZVdCflYltz3wA xwuw0/yi0/6Mh+s290fdkiTsM+xzOg6A7APFpY5qCvLWK1iAUaNUu778Pc6BDUN0 8Gx/pwvKb60AeX7u0DH5IlenYAlpjVxn0H2yRhPHpJvzAIPW+hjG5TBOXu/IrcTz kpFG2BFJoRMZj+CQfJo/8+rBo/wyS5USmAe9zSLS6p/7JLsvV8fJCNPZHAxDow+N 1S5CC2Gzd5+ntJWBHyamZeHmF1GrBCUviqv6b5YotKNArCIcXYpmaGJpH7goo25E S2mLJfnEbbrQ+eHcPAxYAskHuJknENTDbO0zS/VJlWIlh4+QK4EafJFlhnjUYzVi j4y8FbWVU9tqMBmjzwXzCcRBs2Ww4HhFTh1JQtdxcDE8sXlOIcg= =wuhR -----END PGP SIGNATURE----- 
It's a real pity! I'm actually in Benelux until February 2nd, but had I thought about I really should have taken out the time to go to FOSDEM :) Best wishes for those of you who go.
[removed]
Just because this room is not about Ada as crypto currency but, as mentionned in the description, about the Ada programming language (https://en.wikipedia.org/wiki/Ada_(programming_language) )
**Ada (programming language)** Ada is a structured, statically typed, imperative, wide-spectrum, and object-oriented high-level computer programming language, extended from Pascal and other languages. It has built-in language support for design-by-contract, extremely strong typing, explicit concurrency, offering tasks, synchronous message passing, protected objects, and non-determinism. Ada improves code safety and maintainability by using the compiler to find errors in favor of runtime errors. Ada is an international standard; the current version (known as Ada 2012) is defined by ISO/IEC 8652:2012. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ada/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
This looks excellent, are you the author?
No I am not. It's a gentlemen named Jordan. The book is based on a final thesis work making a heart rate monitor using AVR-Ada on an 8-bit microcontroller. The author has put time into making it pedagogical and is a good starting point for somebody who wants to get started developing such applications.
Ada's never mentioned in the linked article, so I'm removing it. I agree with /u/egilhh that maybe you meant to post that one?
It's full of academic boilerplate. But a nice breakdown of the whole process. 
Yes, sorry, I meant to post http://static1.1.sqspcdn.com/static/f/702523/27395807/1483309459417/201701-Cook1.pdf?token=IIahOtpDOKV%2F4ww0moaXUVLiOIw%3D How should be fixed?
Just post that with the same title. Shouldn't be any problem. If it doesn't show up for some reason, just PM me and I'll push it through.
Wrong reddit, ffs
Friendly competition brings out the best in humanity. I agree the existence of Rust has had a positive impact on Ada/SPARK.
Anything that raises awareness of reliable software engineering is a good thing. Anything that raises awareness of just how bad some languages are (e.g. C) is a good thing.
Honestly, a better low-level language for "drivers and stuff" would be BLISS, or even Forth, rather than C.
What I find particularly interesting about this debate is the laser-focus on language features and programmer experience. This is obviously the natural bias of most communities in which the debate plays out, but I think it misses some extremely important aspects. One of the top Ada criticisms I hear time and again is the verbosity of Ada. I find this interesting because it usually presented as being some kind of inherent weakness, where it is, in fact, a deliberate design decision. So my counter-balance for Rust lies in the "write-only language" qualities that Rust takes from the C-like syntax. When building large, long-lived critical systems, working out of the box can only ever be half of the story. How well does Rust compare to Ada in the realm of maintainability over long time-scales, in legibility of algorithm implementation? After-all, this is the essential reasoning behind the "verbosity" of Ada. But I feel there is more to this. By placing programmer convenience at a low priority, and by requiring more "complexity" in the execution of certain programmatic goals, Ada forces the programmer to think more carefully, and to act more *deliberately*. The above quality leads into the kernel of my alternate argument to this entire debate. Where is the discussion about the software design and engineering processes? Where is the discussion about the long-term life-cycle? Honestly, if Ada is going to have a fair comparison with Rust, this needs to be part of the discussion. I say that because, from my perspective, it seems that Rust has been designed as a programmer's language, where as Ada has been designed as a mission focused language. Ada's design has faithfully and regularly processed a broad set of considerations from the entire spectrum from design, through implementation, testing, deployment, run-time, and towards long-term maintenance. I do not see this in Rust. Particularly on the first and last points, which again, are extremely important. If you let the programming community choose between Rust and Ada, I am quite confident Rust would win the majority, hands-down. But that does not mean it's the best solution to the problem. On a more philosophical note; I think the nature of this debate has a direct connection to a potpourri well-known human weakness, including: * Tendency for over-confidence in ones own abilities, * Preference for "the easy way" over well-planned, "measure twice, cut once" approaches, * Aversion to tediousness * Impulsive "just get it done" in preference to careful planning and delayed gratification, and * Perception bias - It looks different than what I'm use to, therefore I don't like it. I can't help but feel that this debate has seen Ada on the losing side simply because it was designed explicitly to dampen the effects of well-known human weakness in the implementation of software. Ada takes away most of the creature comforts that modern programmers have become accustom to. It makes programmers take more time, more care, and apply more discipline. This is not a weakness to anyone except the undisciplined, the impatient, or the overconfident. Ada puts an emphasis on proper *design*, not just implementation. This is extremely important, but it seems to get mostly ignored in this debate. I have not seen a single language that allows the careful, confident design of large, distributed systems with the amount of assured discipline, control, and reliability that is offered by Ada. 
The Wikibooks entry pretty much sums it up. https://en.wikibooks.org/wiki/Ada_Programming/Types/range
The Wikibooks entry does not show the full usefulness of such integer types. When one defines a type like type Day_Number is range 1 .. 7; one can then do things like: - define arrays indexed with this type, for example Calories_Eaten : array (Day_Number) of Natural; - loop over the numbers in the type, for example for D in Day_Number loop ... end loop; - make case decisions using numbers in the type, with compile-time checks that all values are covered, for example: D : Day_Number := ...; case D is when 1 .. 5 =&gt; Work; when 6 .. 7 =&gt; Rest; end case; 
Also can be done with an enumeration.
This is a bad example. Days are better represented by enumerations. Anyway number ranges are good for anything that should be bounded. For example, in embedded programming you may want to define a range of 16 bit numbers for certain hardware. In aviation you may want to set a range from min to max altitude. In graphic programming you may want a range of numbers to represent valid x-pixel location and another to represent valid y-pixel locations.
Now that's what I call a quality reply! For those with time on their hands, check out http://www.ifpug.org/wp-content/uploads/2017/04/IYSM.-Thirty-years-of-IFPUG.-Software-Economics-and-Function-Point-Metrics-Capers-Jones.pdf It's about metrics on software development, lifecycle and economics. The development costs by language in the tables in the appendix, and the explanations are well worth your time.
Great reply and I completely agree with you. If someone were to read the Ada Rapporteur Group (ARG) discussions (see http://ada-auth.org/arg.html), he/she should definitely see how strong the proper software engineering mentality is.
&gt; I'm guessing they raise an exception when the number is outside the range? Yes, or the compiler can either issue a warning or error if it's known statically at compile-time. &gt; What sort of problems do they solve? Lots of problems, say percentages: `Type Percent is range 0..100;` Closely related is `subtype`, which allows you to place more restrictions on a type, like `Standard` does with Integers: -- Imposes the constraint that a Natural be non-negative. Subtype Natural is Integer range 0..Integer'Last. -- Imposes the constraint that Positive be 1 to the last Natural. Subtype Positive is Natural range Natural'Succ(Natural'First)..Natural'Last; &gt; I've long heard about this feature and am quite curious what they look like and how they work. I'm also thinking of writing a library in a different language for something similar. 
Get in touch with Sara, https://www.linkedin.com/in/saragranadoscabeza/ She is looking for an Ada programmer in SPAIN.
I'm really digging this. Good stuff.
Rust is a serious competitor for Ada but it can't replace Ada. Parada can.
EDIT: ParaSail. I'm sorry for mispelling.
I would remark both the legacy SWF use as well as the Windows bias. 
It can replace Ada in some sectors, and can't in others. Ada is unchallenged in the embedded sector. Rust on the other hand scores many points over Ada in webserver development.
&gt; Was looking to check out some Adacore info, but none of my browsers or my networks support .swf files for security reasons. This is kind of a no-win situation. The "new stuff" simply doesn't work to the same level of functionality and reliability of Flash (disregarding people that are on older systems)... and then there's the option of overburdened use of JavaScript to waste CPU cycles and bandwidth. (Flash is probably the "least bad" for a ***full fledged*** interactive media/learning-system set-up... but we could probably do well with the particular format AdaCore uses with an embedded video + plain HTML forms.) &gt; How about someone transcode this info to a modern format or place it on YouTube? Then you lose all the interactivity that it would otherwise have; which, in turn, reduces knowledge retention.
Thanks /u/xradionut for the feedback . Note that we (AdaCore) are working on the next version of AdaCore U that will not rely on Flash or videos.
Thanks for the response Fabien! I'd really like to learn Ada as an alternative to C and C++, so I've enjoyed the articles, especially the Make with Ada.
There's always the [Wiki Book](https://en.wikibooks.org/wiki/Ada_Programming) or [John English's book](http://www.adaic.org/resources/add_content/docs/craft/html/contents.htm).
Working my way through the Wiki Book. :)
I would recommend John Barnes' book, Programming in Ada 2012. It costs money but worth it if you're serious.
Did I screw up by installing GNAT on Fedora? I'm using Visual Studio Code with the Entomy extension. Started exploring the language with simple programs and still trying to figure out the tools and environment.
GNAT supports Fedora since it is a Linux distribution. There is an Ada binding to POSIX called Florist. It can be downloaded from AdaCore's website and may be of interest to you.
I'm fine working with my editor, but I tried to get gps working, but got errors. Also was wondering how to do non-CLI apps.
is this the right subreddit? 
Looks like spam to me.
I find it interesting that you mention "spamming protected" being necessary to ensure that an apparent collection of disparate tasks are regularly accessing global variables. Obviously this is one of the most basic no-nos of parallel computing. I don't think this says anything against Ada, it just says the original design was terrible, or the refactoring was done poorly, and suggests Ada's incredibly refined abstraction capabilities were neglected. I'm not sure if you are suggesting if this is an Ada issue, or not. It's pretty unfair, I feel, to suggest that Rust is better simply because it does this "automatically". Ada focuses on the automation of finding errors, not fixing errors. I fundamentally think this is correct. So Ada's design essentially promotes a very regular, coherent, concise structural discipline that is very easy to follow and learn. Once you've learned it, and if you follow it, you won't run into these problems. I will whole-heatedly agree with you that any language can be used poorly. I'm not arguing at all that Ada somehow excludes poor design. In fact, I am certain there are swaths of Ada programs out there that are just transliterations of C programs. In fact, I've seen them with my own eyes. I think there is a problem now in the community where convenience and "speed" has become so important. This really flies in the face of human history and human nature. Humans are not good at making things quickly, and we're not going to change any time soon. We are good at thinking through difficult problems, and crafting intricate designed with creativity and care. I'm pretty young. I grew up with the internet. But at the end of the day, I write all code, including Ada, entirely in Emacs, with no syntax highlighting and no assistance except for auto indentation. I don't do this because of some out-dated notion, I do this because I've used IDEs too. Nothing gives you better focus on the task at hand than being 100% focused on the task at hand. Details matter in this world. If you are relying on the IDE to remember all your variable names, and to track your n-nested brackets, you're probably going to do a poor job of creating a careful, salient structure. And what's also interesting: it doesn't slow me down much. I completed a ~12K SLOC project in Ada within about 4 months, just me and Emacs. I'll tell you what I didn't do - I didn't need to jump from exception to exception. Ever. I also refactored two major components a few months later, and that was both easier than I expected, and it compiled into the project without any changes to the other components, and without any bugs. That is what Ada is designed to do. It's designed for taking the time to get it right, and I find it frustrating that the programming community seems to focused on "move fast and break things", and having their IDE autocomplete so much that they don't even need to learn the language anymore, or have situational awareness. Exceptions are for exceptional circumstances, and in Ada if you accidentally run into exceptions that frequently, you're either raising them for unexceptional circumstances, or you've got a poor grasp of the Ada type facilities. This is reminiscent of the Ariane 5 argument "against" Ada. As for your experience in the practicum, I'm not sure what your position was in that, but I need to be respectfully dubious. If I tried to host a practicums between Rust and Ada, I'd have such a difficult time excluding my bias, that I'd probably refuse out-right to do that. Maybe you are more immune to the effects of bias than I am, but that is exceedingly rare in humanity. In a project I'm currently working on, I have, at this stage, about 10 package specifications and no package bodies yet. I spent all the time working out the structure carefully (a lot of time). Now when I go to implement, I know it's going to work, even before I start. I am especially confident of this, because it's what I've done in every other project. Did the practicum students take this kind of time or care? Were they encouraged to? Why or why not? The crux of my original argument was that Ada provides more facilities for disciplined structure (than Rust), and has regularly involved design decisions that deliberately inconvenience the programmer (unlike Rust). A lot of those decisions have extremely careful background, and always have very clear reasoning. I see many features of Rust being advertised more like power-steering and heated-seats. Thus I can't help but feel a large component of the Rust/Ada debate amounts to a Corolla being better than a tunnel-boring machine, because it's easier to use, has air-bags, AND an entertainment system. 
learning Ada and trying to make a Tetris clone I find this interesting. I just grabbed the SDLAda bindings yesterday and was looking at the code to create the window.
Felix Krause's writings has been very helpful for me when making Ada bindings to C libraries. For example: https://flyx.org/2012/06/13/adabindings1/ Jacob Sparre Andersen has written on the subject of passing Ada strings to C on Stackoverflow: https://stackoverflow.com/questions/29561601/passing-string-to-c-function Right now I am working on a thick Ada binding to Wayland on Ubuntu 17.10: https://github.com/joakim-strandberg/wayland_ada_binding Still lots of more work to be done but it is possible to get the "Hello World" window up that can be seen here: https://github.com/hdante/hello_wayland Of course feedback is always appreciated :)
IRL you know the area of distribution of fish, but the Fishbank doesn’t provide anything like this, so I think that the comparison from the WP is inappropriate. 
I think you just misunderstood it. It was about the fact that you can never know whether you’ll get a small or something more similar to a shark.
Oh that is it! Then it’s okay. But I think that it’s better to use several servers, they’ll be kinda regional aquariums. 
This slows down the growth of value of tokens. It’s much better to have one global server. I hope that the platform’s team will implement its plan!
You’d think that they would’ve implemented Cardano ADA in Ada.
It was just a dream but alas, crypto currencies are just hype and implemented with languages that are in the same stream
At the same stage, interested in the same things. It is unfortunate that gnat-gps is still sort of hard to set up!
Wrong topic, we're talking about the Ada programming language not about crypto-currencies
See my GitHub, same nick and look for bare bones. There is an #Ada channel on freenode. Dunno about FYI errors, sounds like a fedora issue. The Barnes book is ok but it’s not a tutorial style book, it’s huge and only mentions some of the annexes. Try John English’s book and the Ada 2012 lrm .
Yes, I believe it is just the precompiled binary community edition that is only supplied as 32-bit on Windows or 64-bit on Linux.
Try FSF GNAT for 64-bit on Windows. See http://www.getadanow.com/#get_windows
Last time I installed GNAT GPL on Ubuntu, I did experience a minor glitch to do with GTK themes for the GPS IDE, but found the solution online.
Yes, the LRM is a great tutorial... ;-)
You can do units of measurement in Ada but it's not baked in like F#. I.e. in Ada you can multiply metres by metres and happily get a metres answer. In Ada, you need a library or some extra coding to get the correct units in those sort of cases.
There may be system lib version issues from one Linux dist to another, thinking in particular about GTK+ and GUI. GTK+ is probably your best bet for traditional GUI development. There is also Gnoga, which I haven't tried myself yet, but looks interesting. 
See this library: http://www.dmitry-kazakov.de/ada/units.htm
I like gnat for windows 64 from msys2 distribution. There are some instruction how to setup it at http://forge.ada-ru.org/matreshka/wiki/Guide#Windows64bit 
Just use FSF gnat 
Apparently much of the recent Fedora package support is spotty, looks like only one or two maintainers who have run into issues... :( I still have a Windows box and VMs to play with! :) I've been consider another distro or BSD. Will do my research first. 
As a newbie, it doesn't matter which one you use. I personally found that it was easier to get started with the AdaCore GNAT GPL (now called Community Edition, I believe). If you are just learning and/or writing software for yourself, or writing GPL software to distribute, then the AdaCore GNAT is fine. FSF GNAT is freer in the sense that if you want to write and distribute software without having to follow the GPL rules, then you can, because the runtime that comes with FSF GNAT has what is called a "runtime exception" to the GPL, which means that you can link your code to the runtime and distribute the result without having to publish the source of your own application. Now, you can develop as much as you like on the AdaCore GNAT, and then compile using the FSF GNAT for distributtion, should you wish. However, if you were to use bleeding edge features that haven't made it into FSF GNAT yet, then you could find you need to do some extra work to compile on FSF GNAT. To avoid that, you would just use FSF GNAT exclusively, and you'd have no worries.
&gt; Obviously this is one of the most basic no-nos of parallel computing. You misunderstand my argument. It's not about having many globals used from many threads. It's about not *knowing* which ones are. In Ada, when you are using a library, there is no way to know which parts access a global. So if you call any function from two threads, it might be doing thread unsafe things inside, without anything but documentation or SPARk telling you that it's happening. &gt; So Ada's design essentially promotes a very regular, coherent, concise structural discipline that is very easy to follow and learn. Once you've learned it, and if you follow it, you won't run into these problems. I don't even want to start arguing against that. This is what all the C gurus tell me is the reason they have no need for Ada, Rust or anything other than C. "Just learn to be better" is not giving me confidence in a language. &gt; entirely in Emacs, with no syntax highlighting You are aware that it's been scientifically proven that code readability increases significantly with syntax highlighting? (http://www.ppig.org/sites/ppig.org/files/2015-PPIG-26th-Sarkar.pdf among others) And I don't mean just for new developers or non-developers. This effect has been shown across skills. &gt; That is what Ada is designed to do. It's designed for taking the time to get it right, and I find it frustrating that the programming community seems to focused on "move fast and break things", and having their IDE autocomplete so much that they don't even need to learn the language anymore, or have situational awareness. You are just highlighting my issue. A 4 months project with upfront design has little need for (large) refactorings. A 10-15 year project with changing requirements does. And changing requirements are not something that will go away, ever, especially in long lived projects. &gt; Exceptions are for exceptional circumstances, and in Ada if you accidentally run into exceptions that frequently, you're either raising them for unexceptional circumstances, or you've got a poor grasp of the Ada type facilities. I don't see any way of even opening a file without having to take care of exceptions at 3 separate points. And I never know if I've covered them all. Maybe I forgot to catch the one that happens when the disk is full, or I only have read access to the directory I'm trying to create a file in, or .... &gt; As for your experience in the practicum, I'm not sure what your position was in that, but I need to be respectfully dubious. Which is why I am dubious myself, as noted in my own post. &gt; If I tried to host a practicums between Rust and Ada, I'd have such a difficult time excluding my bias, that I'd probably refuse out-right to do that. Maybe you are more immune to the effects of bias than I am, but that is exceedingly rare in humanity. I did not know about Rust during the time I was doing the Ada practicum. But the bias in hindsight is of course there. &gt; Did the practicum students take this kind of time or care? Were they encouraged to? Why or why not? As stated in my post, a 2 week practicum with learning the language + doing a project is not enough to be useful for this kind of comparison. &gt; The crux of my original argument was that Ada provides more facilities for disciplined structure (than Rust), Other than ranged numerics and language builtin subtyping, I don't see this. What's different between designing your program and not filling out function bodies and designing your program and not having function bodies? &gt; and has regularly involved design decisions that deliberately inconvenience the programmer (unlike Rust) Please explain to me how `Result` error handling, ownership or borrow checking are conveniencing the programmer. They are a serious pain until you actually get to the point where the program compiles.
unfortunately msys2 ada package does not ship with many tools, like gnat pretty printer,gnat stack,gnat test,gnat check, for instance. So the experience is sub optimal.
They don’t come as standard on FSF stuff either.
Book came in today. Ordering out so I don't spend time cooking dinner. Had a discussion about Ada and embedded Linux for personal projects at lunch today. "Ada? Well at least it's not C... That language can go die in a fire." said the lead programmer not fond of memory leaks and pointers. 
Very interesting! Thank you!
Gps is nice but not required. If you can have a reasonable output when you run gnatmake, as in you don't see a command not found error, you're all set. You'll just have to spend time in the command line more often.
You split it down by using child packages and separates. Just think about the structure.
Yep. I'm not worried about making it manageable when I have to. I just want to know at what point I will have to start thinking about child packages.
I have never had compile-time error due to an Ada file being too large. I guess compile-times can get long with huge files. To quickly check if the code one has written is syntactically correct (as in the code will compile/build) I recommend using "Check Semantic" over "Compile File" in the GPS.
Ada doesn’t care about file sizes because it is a language definition. Specific compilers may although these days that’s fairly unlikely.
I'm working with Ada 95 and GNAT if that helps lol
You think about that during design.
I knew she was a clever person, but wow! Her foresight and understanding of computing was amazing.
I've heard the name Genode before but hadn't looked up what it was about. Seems like a useful project, and using the combo of SPARK together with Genode to develop super-safe systems was a new idea for me. Thanks for sharing!
I've heard the name Genode before but hadn't looked up what it was about. Seems like a useful project, and using the combo of SPARK together with Genode to develop super-secure/safe systems was a new idea for me. Thanks for sharing!
You get to write your own comparison functions: e.g. function Uncased_Equals (L, R : String) return Boolean is use Ada.Strings.Fixed; use Ada.Strings.Maps.Constants; begin return Translate (L, Lower_Case_Map) = Translate (R, Lower_Case_Map); end Uncased_Equals; function Uncased_Less_Than (L, R : String) return Boolean is use Ada.Strings.Fixed; use Ada.Strings.Maps.Constants; begin return Translate (L, Lower_Case_Map) &lt; Translate (R, Lower_Case_Map); end Uncased_Less_Than; and, for enumerations, input from text via `Enumeration_IO` isn’t case sensitive.
Hm. Can I get the user to input something as an enumerated type then? So, Type Day_Type is range 0..6; Day : Day_Type ... Ada.Text_IO.Put ("Enter the day of the week: "); Ada.Text_IO.Get (Day); Let me know if that doesn't make sense. It's practically 4 am for me rn
For casing on Strings, you can do: type My_Enum is (Case_1, Case_1, Case_Other); function To_Enum (Value : String) return My_Enum is begin return My_Enum'Value (Value); exception when Constraint_Error =&gt; return Case_Other; end To_Enum; -- ... somewhere in your code case To_Enum (My_String) is when Case_1 =&gt; ... when Case_2 =&gt; ... when Case_Other =&gt; ... end case; If you want to case on strings, chances are that you actually *want* to convert it to an enumeration to see whether it is in some set of defined values or not.
Can I bother you for a basic working example? I'm having a tough time visualizing how this works &gt;_&lt;
Yes. Just get the day from the user and then do: Input_Day :String := Day’Value(Input); But put an exception handler in that scope to catch unmatched inputs.
If your classes are fixed, you would probably be better off using an enumerated type. In that case, you could also simplify the user interface by listing all possible values, and let the user select one using a number or simple character. Maybe something like this: (disclaimer; I didn't try to compile this before posting, so errors may occur) type Possible_Classes is (Barbarian, Fighter); type Class_Type is record Main : Possible_Classes; Level : Positive; -- no need for negative or zero levels Hit_Dice : Integer; -- This should probably be an enumeration, -- type Die is (D2, D3, D4, D6, D8, D10, D12, D20, D100) -- or you could use a subtype predicate disallowing illegally sized dice end record; subtype Selector_Range is Character range 'A'..'B'; Selected : Character; Selector_Table : constant array(Selector_Range) of Possible_Classes := ('A' =&gt; Barbarian, 'B' =&gt; Fighter ); Hit_Dice_Table : constant array(Possible_Classes) of Integer := (Barbarian =&gt; 12, Fighter =&gt; 10); ... Ada.Text_IO.Put_Line("Select class:"); for Selector in Selector_Table'Range loop Ada.Text_IO.Put_Line( Selector &amp; ". " &amp; Possible_Classes'Image(Selector_Table(Selector))); end loop; Until_Legal: loop Ada.Text_IO.Get(Selected); if Selected in Selector_Range then Character.Class.Main := Selector_Table(Selector_Range(Selected)); Character.Class.Hit_Dice := Hit_Dice_Table(Character.Class.Main); exit Until_Legal; else Ada.Text_IO.Put("Try again"); end if; end loop Until_Legal;
Like egilhh said, sind the set of possible classes is known beforehand, it makes more sense to identify them by an enumeration. Instead of the code egilhh suggested, you can also enable your users to directly input the class name. As simonjwright said, you can use `Enumeration_IO` for that: type Possible_Classes is (Barbarian, Fighter); package Class_IO is new Ada.Text_IO.Enumeration_IO (Possible_Classes); -- in your code Class_IO.Get (character.class.main); -- main being a Possible_Classes value now The approach I previously suggested would look like this (I added nicer construction of the `hitDice`. When your class's kind is an enumeration, you can simply define corresponding values in an array): type Class_Kind is (Barbarian, Fighter); function To_Class (Value : String) return Class_Kind is begin return Class_Kind'(Value); -- propagates Constraint_Error when Value is not a valid class. -- you need to choose where and how you handle that error. end To_Class; type Class_Type is record hitDice : Integer; main : Class_Kind; level : Integer; end record; Hit_Dice_Values : constant array (Class_Kind) of Integer := (Barbarian =&gt; 12, Fighter =&gt; 10); -- ... Put ("Class: "); character.class.main := To_Class (Get_Line); -- using Ada 2005's Get_Line function so we can read a string of arbitrary length Put ("Character's Level: "); Get (character.class.level); -- ... character.class.hitDice := Hit_Dice_Values (character.class.main); By the way, *[enter Clippy]* you seem to be loading complex structures into Ada. Perhaps a look at [AdaYaml](https://ada.yaml.io), my YAML implementation for Ada which enables you to parse YAML documents, would be of interest ;).
&gt; Can I get the user to input something as an enumerated type then? -- User-commands, enumerated. Type User_Command is (Save, Load, Quit); -- Function reads input, looping until a correct input is found. Function Get_Command return User_Command is Begin Loop -- Set up an inner block for the exception-handler. Declare Text : String renames Ada.Text_IO.Get_Line; Begin Return Result : Constant User_Command := User_Command'Value( Text ); Exception When CONSTRAINT_ERROR =&gt; Null; End; End Loop; End Get_Command; --... TESTBED: Loop case Get_Command is when Save =&gt; Ada.Text_IO.Put_Line("Item Saved"); when Load =&gt; Ada.Text_IO.Put_Line("Item Loaded"); when Quit =&gt; Exit TESTBED; end case; End Loop TESTBED;
[removed]
I work on flight software for ESA satellites, usually in Ada. It is the best language I have ever used (but I have never used Java, C#, Rust, or functional languages). My daily satisfactions with Ada come from the portability (running the same code on both target embedded computers and PCs), the problem-modelling ability (type system), and the wide scope that extends from bit-level HW access to programming in a high-level functional style.
Author of the blog post here. I do recommend to use pyOCD as described in the blog post. pyOCD will not only flash the program, it also provides debugging through GDB.
Not that I don't want to use pyOCD, just that I didn't know how! Using pyOCD to program the board is something that might be lacking from the blogpost for people like me that are new to this sort of thing. Otherwise, great article! Thanks!
I don't understand because there are instructions on how to use pyOCD in the blog post. It actually is the first part.
If you follow all the steps, at the I explain how to use GDB to connect to pyOCD and flash the program. 
You are welcome :) Please don't hesitate to share the outcome of your Ada adventures.
"both" implies a language other than Ada. Did you have one in mind? 
Ada would have caught your off-by-one error.... /s
Wouldn't use anything else. I've used a number of languages professionally. Ada is the only one that supports the way I think.
Here is an article where Ada and Rust are compared to the Steelman requirements: http://jedbarber.id.au/steelman.html
The definition of upper and lower case becomes more problematic the further you get from the Latin alphabet and English and Latin-based languages. 
Cool article! There's some potential here for splitting the requirements up into categories and plotting the various amounts of yeses and mostlys within each category for each language. That would reveal if one language fares much worse overall because, for example, of different syntactic choices.
There is a tiny issue with this function. It never completes even the input is legal. It think it should look like this. -- Function reads input, looping until a correct input is found. Function Get_Command return User_Command is Begin Loop -- Set up an inner block for the exception-handler. Declare Text : String renames Ada.Text_IO.Get_Line; Result : User_Command := User_Command'First; Begin Result := User_Command'Value( Text ); exit; Exception When CONSTRAINT_ERROR =&gt; Put_Line ("Your illegal input: " &amp; Text); End; End Loop; return Result; End Get_Command; 
It looks formatted under edit but looks unformatted under preview. Could some one show me how too keep the preview as same as under edit? Thanks.
First, ensure that every line is properly prefixed by the four-spaces (or tab) that's needed to trigger the code-formatting, then, if that doesn't work, try adding an extra line (or two) before the first line of code. That should fix it.
&gt; There is a tiny issue with this function. It never completes even the input is legal. It does complete; the `return`-statement returns from the function `Get_Command`, breaking out of the `loop`-construct. OTOH, if the input is invalid, the `Constraint_Error` exception is raised and handled by the empty-handler and the `loop` starts from the beginning. Yes, proper form/decorum would be to put some sort of "invalid input" message, but your question was about inputs, not etiquette.
You are right. The return statement in effect exits the loop.
You can licence it any way you want, just be careful of the GNAT GPL compiler, use the FSF one.
You mean the GPL and FSF GNAT. They're essentially the same, but he GPL one might have patches not applied to the FSF one. The GPL GNAT's library is GPLv3, no exceptions, unlike the FSF lib which is GPLv3 with linking exception.
Thanks again for answering!
FYI, there are more people around to answer on Freenode #Ada channel
There are some fundamental differences between how Ada and Rust solve (or don't solve) safety concerns 1. Variables of integral types often should only contain a certain subset of numbers that the backing memory can represent * Ada solves this very well with ranged types * Rust has no builtin solution for this, but there are crates for it 2. You should keep global mutable variables to a minimum * Ada does not address this * Rust treats mutable global state as `unsafe`, but allows it (for now) as an escape hatch for when you can't implement something otherwise 3. You should not access the same memory from multiple tasks without synchronization * Ada has language builtin synchronization primitives, but you are not forced to use them * Rust has synchronization primitives in its standard library and you are forced to use either them or other from external crates. Otherwise you cannot access the same memory concurrently. 4. You should handle all errors * Ada raises exceptions that you can catch and forward, or are implicitly forwarded if not handled * Rust has `Result` types that you need to forward or handle, but are not implicitly forwarded 5. Instantiation of Generics * Ada requires you to explicitly instantiate a generic under a new name and then use it through that name * Rust allows you to implicitly use a generic 6. Type aliases and subtyping * Ada can create an exact duplicate of a type under a new name that is incompatible with the original * Rust can only create alternative names for types or requires you to create wrapper types to emulate the behaviour from Ada 7. Low level representations * Ada allows you to specify the exact representation a type should have * Rust has no such feature. You can choose the order of struct fields implicitly in the type with a `#[repr(C)]` attribute 8. Aliasing * Ada allows you to have multiple names for the same object and modify it through all of them. You can't do anything dangerous this way, because you'll get a runtime exception if you do * Rust forbids this at compile-time, but you can use an explicit all-infecting escape hatch to change it into runtime-checks 9. there's probably more...
[removed]
Thanks for the break down. It was interesting to read, especially from someone like me who hasn't looked into Rust yet.
Hi, glad to see you have taken an interest in Ada. Have you visited adaic.org yet? There is some useful info there. If you are interested in where Ada is going or why certain features were rejected or are the way they are in the language, you can check out http://ada-auth.org/arg.html where the maintainers of the language (ie. the ARG) archive all their past and current discussions (i.e. covered in Ada Issues).
I'll look into these, thanks!
&gt; Rust appears to be reinventing the wheel. So I'm currently attempting to learn Rust a bit, and don't know much Ada (besides a simple Hello World). I've been reading about it though. Anyway, it looks like Rust is more about the 'technical' side of things whereas Ada looks more about 'functional' validity, or am I wrong here?
&gt; So Rust is rubish... Statements like that are very detrimental to a constructive discussion. &gt; There is complete control of visibility and globalness through encapsulation and nesting You misunderstand my issue. An unprotected global that is entirely encapsulated and inaccessible can still be accessed indirectly via a function. So if you have a function that accesses said hidden global and changes its value, and you call that function from multiple tasks, you end up with race conditions. I understand that it can be useful to access global statics in an unprotected way by implementing a lock free datastructure. That is a perfectly fine use case. The issue I have with it is that the language does not force you to differentiate between the case where you did it on purpose and the case where you did that accidentally. Even if you took care to use the global correctly, future refactorings a few years later might not realize this and break your assumptions. Note that SPARK solves this already.
&gt; Anyway, it looks like Rust is more about the 'technical' side of things whereas Ada looks more about 'functional' validity, or am I wrong here? I don't even know what that's supposed to mean.
When I see Rust's features, they advertise more about preventing segfaults, thread safety, memory safety and whatnot. When I think about Ada, it's more about defining how the system you're creating should behave, logically. More higher-level, I suppose. I'm not sure how to write down my thoughts, to be honest.
I'm not a big proponent of language wars, but I think we should be careful with our vocabulary. Rust is the newest hotness intended to replace C++ with something safer and contains a lot of influences from functional languages. It reads like a blending of C++ and those languages. It's growth is more organic. Ada was deliberately designed to be readable and maintainable. It's design is engineered through a process over the decades with code safety and validation in mind . That appeals to the engineering side of me. When you look at the sheer amount of code libraries Ada come out on the plus side. When you look at the current level of promotion, Rust is the cool new thing. Me? I need a stable systems language for both desktop and embedded projects. And the readability and history is the key for me. 
Rust people just bang on about ownership, that's literally the only feature of Rust, AFAICS. Ada is higher level, you're supposed to think about how to model the data rather than the algorithms. Which can be quite difficult, especially at a lower level, but it really does give you more control over it.
I'm not trying to start a language war, not at all. I firmly believe that every programming language has its application and I'm certainly no zealot when it comes to that. I was just curious why you would say that Rust is trying to reinvent the wheel. I don't know both languages well, so it was an honest question. Anyway, thanks for the downvotes, whoever you may be!
To me, (this is mostly subjective), Rust is attempting to be a replacement for C/C++ as a systems language. That's what Mozilla is using it for. I believe Ada already solves most of those C++ issues and Rust appeals more to the C++/Haskell geeks that don't like verbosity of Ada but like more of a C/C++/Haskell syntax. Enough talk, time to read and study some more code. 
Ada solves 2by not allowing globale at all, everything is scoped. Secondly you can define default values for variables and thirdly, references can be not null.
A global only available in a certain scope is still a global essentially. Would you elaborate? I don't understand the argument. default values for variables and non-null references are the same in Ada and Rust, so I decided not to list them.
No, global means global scope. In C like languages everything is in global scope. In Ada anything you define, function (not in a package), packages, tasks, etc are all defined within package Standard. Try “with Standard.Ada.Text_IO;” for proof. You can’t define a variable outside of a package or subprogram, etc, so in Ada there are no globals at all.
&gt; Anyway, thanks for the downvotes, whoever you may be Wasn't me :)
I like not spending days in a debugger looking for something the language can point out. I doubt that Rust fixes that issue.
Also, even in Ada you can cheat and grab hold of a variable from another package, just export it from one and import it to another. I'm betting other, supposedly safe, languages can do that too. After all, it's just a symbol to a linker.
The GPS and GNATBench have already been mentioned. For Windows development there is also: LEA - Lightweight Editor for Ada: https://sourceforge.net/projects/l-e-a/
There's also Ada extension for VS Code by Entomy (aka Patrick). 
Well, it should be taken with a grain of salt. To balance things out with Rust take a look for example at [/r/rust](https://www.reddit.com/r/rust/comments/85yj1b/d_parasail_pascal_and_rust_vs_the_steelman/) discussion of this article.
We've got a big discussion of this going on in /r/rust https://www.reddit.com/r/rust/comments/85yj1b/d_parasail_pascal_and_rust_vs_the_steelman/
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rust] [\[XPOST\]Why Rust was the best thing that could have happened to Ada](https://www.reddit.com/r/rust/comments/865k1q/xpostwhy_rust_was_the_best_thing_that_could_have/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
It would be better to say “shared mutable state” instead of “global mutable state” as from what I see some people think about “global” as a variable visibility scope instead of part of shared memory. 
I just can't respect an article that gives a lower score for this: &gt; Neither Parasail nor Rust support goto.
&gt;Ada is unchallenged in the embedded sector. While from the industry point of view this probably true at least in 10-15 years, for programmers new to the embedded programming Rust can be a pure bliss. Yes, there is LLVM target restrictions, lack of tooling support (including GUI tools) and crates ecosystem is the moving target, but Rust compile-time guarantees are indispensable for being able to focus on the code and problem which you try to solve. And some companies which work on embedded projects already utilize Rust and recognize it for its properties. (e.g. ErlyVideo) So while we can't expect Rust to be able to replace C or Ada for already established projects, we probably can look forward to a rising number of new embedded projects started in Rust.
&gt;* Preference for "the easy way" over well-planned, "measure twice, cut once" approaches; &gt;* Aversion to tediousness; I get a distinct feeling you haven't spent much time writing Rust? Rust is not exactly known to be a very terse language. Nor easy on the developer. In fact, some of its main features such as borrow checker and explicit error-handling are *explicitly designed* to force the developer to think about the design of the code. It's unlikely to even compile if you haven't. I can't compare Rust and Ada, since my total experience in Ada was about two months of coding, 15 and 20 years ago. However, my experience during the past 2 months of Rust is that I've been beaten over the head by the compiler more times than I'd like to admit, because I had not considered subtleties of my design. More interestingly, whenever I managed to get the code to compile, running the test-suite were almost always successful on the first run. (Especially important; so far massive restructuring of the code have so far not led to a single regression, according to the test-suite.) As said, your remarks makes me think you have not yet actually tried the language you thrash? Or you are a vastly superior polyglot coder to me, already beaten to perfection by Ada. :) &gt;* Impulsive "just get it done" in preference to careful planning and delayed gratification I think this mentality has been one of the main obstacles to Ada usage in the industry. Safety is not the ONLY important metric in software development. If you think programmers are impatient, you have not seen the average manager. New technology is *supposed* to boost productivity and that applies as much to programming languages as it does to society as a whole. A "better language" must mean improvements to the combination of *both* safety *and* productivity. Just as many (if not more) software projects are derailed by escalating development costs, as from crashes in production.
People frequently use the word "global" colloquially to refer to what is known as "static" (and in fact, that's what it's called in Rust as well). Rust does not have variables in global scope; all static variables are still scoped to a module. Even static variables have problems with safety and maintainability. Because there is only one for the lifetimes of a program, they provide a form of shared state both between different operations in a single thread, or in multiple threads. Because of this, in Rust, access to static variables is considered unsafe unless you encapsulate the state in a type that handles synchronization.
Rust is very much laugh cry in the dojo laugh on the battlefield. Once I got my program running it stayed running.
Rust can do that, too. And you need to annotate all uses with the `unsafe` keyword
Thanks for clarifying. I did not include this in my comparison, because both Rust and Ada encapsulate properly. Defining a variable in the non-private part of a package makes it a global though.
I think you mean Input_Day : Day_Type := Day_Type’Value (Input);
Cool. Discussion is always good.
Goto is a requirement in the Steelman set. If a language does not have this, surely it should be marked as fulfilling one fewer of the Steelman requirements? You may disagree with whether or not it is a useful requirement today, but it is unquestionably part of the Steelman requirements.
&gt;A "better language" must mean improvements to the combination of both safety and productivity. Just as many (if not more) software projects are derailed by escalating development costs, as from crashes in production. Improving safety necessarily results in fewer bugs, and fewer bugs implies getting the project done faster. So something that improves only safety is still thoroughly worthwhile. In fact, in theory it would be worth trading a small amount of direct productivity for. It's basically technical debt-resisting yourself.
&gt;Improving safety necessarily results in fewer bugs, and fewer bugs implies getting the project done faster. So something that improves only safety is still thoroughly worthwhile. In fact, in theory it would be worth trading a small amount of direct productivity for. It's basically technical debt-resisting yourself. I think the key here is trading *small amount* of direct productivity. When estimating development time for (in the industry, not for personal projects), you have to factor in the availability for developers for a given technoglogy, and the size of existing ecosystem for your intended target niche. This is why technologies must cater to attract developers. What is "best" is often less important than what is attractive. The trick IMO is to let developers remain lazy happy-go-lucky cowboy coders, yet produce safe programs that works well enough to be useful.
What you are saying makes perfect sense to me, and I think it's a good way to quickly describe the differences between Ada and Rust. 
Well, rust certainly does a better job of catching potential errors at compile time than say C++, especially with regards to memory safety errors (e.g. use after free). I don’t really have enough experience with ada to compare rust and ada in that regard though.
Don't be fooled! Ada is 100% free of license. Unfortunately, for the time being, there is only one freely available compiler (GCC/GNAT), but as long as you use the FSF version from gcc.gnu.org, you will get the runtime library exception clause, and then can be free to do whatever you want with your source. Some tips on FSF GNAT - You can use AdaCore's GPL compilers to build the FSF sources, and this will also give you a compiler that has the runtime library exception. I recently built GCC 7.2 with GNAT on FreeBSD, and it went without a hitch. Linux is even easier, as AdaCore's GPL version is readily available, and GCC is very easy to build on Linux, compared to other platforms.
Could not possibly be more satisfied. The only problem, for me, has being any time I need to use or look at another language, I feel an immense sense of foreboding. I'd rather quit the software industry than stop using Ada.
I've been learning Ada over the last week, and so for I think I can agree with most of that. There's a ton of reading material out there, lots of it is quite dense though. Not a bad thing, but during a long coding session it can be too distracting, and sometimes it takes a bit extra searching to find a code example. The quality of information is excellent across the board, however, which is more than I can say about any popular language. Have you done the Lovelace tutorial yet? I know it the 95 standard, but I'm sure it will still be relevant and useful, so I'm planning to do it over the weekend. Anyone who has done it have any insight on it? 
Have not done the Lovelace tutorial. Here's what I'm working on: 1) John Barne's book: slow read but very through 2) Rosetta Code: comparing Ada example with various languages I'm familiar with. 3) Bits and pieces of various tutorials, sites and videos 4) Exploring some of the resources found here: http://www.adaic.org/ada-resources/tools-libraries/ 5) Setting up environments for Fedora 27 and Windows 10 6) Reading Google+, Reddit and AdaCore Blog 7) Working on a project list. 
Looked at the Lovelave tutorial this evening. The web based compiler wasn't working, so the examples, I ran gnat while using VS code on Fedora. Seems to be a decent intro so far. I'm getting used to some of the compiler errors by creating simple typos... :D
Hi, Welcome to Ada programming! I have not tried the Lovelace tutorial before, but looong ago I did briefly try out Ada Tutor. You can find it here ( https://zhu-qy.blogspot.com/2012/08/adatutor.html ). I don't know how it compares to Lovelace, but you might find it a useful source. 
And I'm over here making a dnd character builder with Ada lol
I’m going to evaluate it for a new embedded project at work; nothing safety related, but I’m still interested in seeing how it measures up. I’ve also been interested in looking into dynamic dispatch of Tasks. Don’t know how much time I’ll have for that tho. 
Some of first programs I wrote in the 80's were for the original Traveller role playing game. We rolled characters and whole sectors of stars.
Using Ada? All of my friends give me shit for using Ada lol
Hi there. Thanks for the excellent article! I would like to try this out on Arduino boards. Would you mind clarifying the availability of the Common Code Generator enabled grpbuild? Is it generally available (e.g. in the GPL 2017 release) or is it yet to be released, or is it available to purchasers of the Developer, Enterprise or Assurance GNAT Pro products?
There os [FLTK](http://jedbarber.id.au/fltkada.html) now as well.
I will continue to work on an Ada binding for Wayland (https://github.com/joakim-strandberg/wayland_ada_binding). Currently only works on Ubuntu 18.04 and does not work on Ubuntu 17.10 due to a bug in the Gnome compositor that was fixed in Jan-Feb 2018 and that has found its way into 18.04 but not in 17.10.
More work on Ada on inexpensive targets (the bluepill and bluepill+ as I call that one). I just did screen demos for the bluepill a tft and an oled. I would like to get started on USB bulk for it. St has a USB hid fw that works on a bluepill so there is a start. http://www.hrrzi.com 
Are those pretty good?
Of the two, I've only read Ada for Software Engineers, though I've heard good things about Ada as a Second Language.
I'm doing the AoC 2016 in Ada, seems to be an interesting way to learn it. I used (Gauche) Scheme for AoC 2017 - so using Ada now means collecting experience with a language from the other end of the spectrum - even if both languages tend to long-winded solutions. So far I like it a lot, it's much less boring than expected...
Thought this was some programming language holy war.
&gt; I've found coming from a C++ background that when I start with a new language it always starts out looking like translated C++ code until I get a bit more proficient and learn the "right way" to do something in that language. [Ada for the C++ or Java Developer](https://www.adacore.com/uploads_gems/Ada_for_the_C++_or_Java_Developer-cc.pdf) while not being a tutorial might still be a useful reference for you.
I'm sorry to hear that John Barnes is dead.
I recommend /Ada Distilled/. http://www.adaic.org/wp-content/uploads/2010/05/Ada-Distilled-24-January-2011-Ada-2005-Version.pdf
I believe "tomb" refers to the size of his book
I think he meant tome not tomb.
The book is heavy and large enough to be a tomb. LOL!
From my understanding, they want to move to a language more widely used than Ada lol I think part of it has to do with the complaints around the department about how useless/bad Ada is. The Department Chair is also stepping down, so the new Chair might just like C++ more or he might think the intro class is better taught in C++, I don't know for sure though.
Sad
I'm sorry to hear that too. I was looking forward to an update of his book with the new Ada 2020 standard when it comes out.
Rust with a capital 'R' :P
Selling my old laptop and reinstalled the os. How to get rid of data deleted, but still residing on the SSD? I wrote a quick Ada program to write data to a file until it ran out of space. Easy to do in any language, but Ada is my easy-to-use language.
Literal title is literal.
According to the [AdaGide Homepage](http://adagide.martincarlisle.com), AdaGide does not bundle a compiler. So you have whatever compiler you installed and your question is completely independent from AdaGide. The LRM does not specify the size of `Long_Integer`. [Relevant section](http://www.ada-auth.org/standards/12rm/html/RM-3-5-4.html#p22): &gt; If Long_Integer is predefined for an implementation, then its range shall include the range –2**31+1 .. +2**31–1. Thus, there is no assurance whatsoever about the size of `Long_Integer`, only a minimum range that must be covered. If your assignment tells you that you shall assume `Long_Integer` to occupy 32 bits, just do that. I expect the assignment not to require you to write and compile actual code, since it is about calculating things. If you actually need a type that is guaranteed to be 32 bits, use `Interfaces.Integer_32`.
The only GNAT Community Edition compiler for Windows describes itself as a 32-bit compiler. You’d expect that to govern the size of access types (and `System.Address`). However, it has little to say about how many bits are used in a `Long_Integer`; if the compiler vendor wants to support a 64-bit integer they can, even if it takes more machine instructions than a 32-bit integer (I don’t know whether this is true for i86). You can see the limits for your compiler in `system.ads`. It’d be interesting to know what compiler your professor is using (AdaGide almost certainly uses whatever it finds on the PATH).
Making an Ada to C++ test binding.
Thanks for the response and the suggestions. I probably should have been less vague in my original post. I first noticed something was off when I was running a sample program provided in my class notes. It covers hashing using two techniques ("folding" and "division remainder"). I've provided a link to the code and the output provided in the notes as well as the output when running the program on my computer. 
After modifying the code, I now get "raised CONSTRAINT_ERROR : uncheck2.adb:18 overflow check failed", where line 18 refers to Sum := ConvertString4(A) + ConvertString4(B); Maybe I should get a newer version of GCC? I currently have 6.4.0
I'm not sure how it works on Windows, but are you sure you have the right cross-compiler in your "$PATH" ?
The compiler looks for runtime `foo` in `$prefix/arm-eabi/lib/gnat/foo`, and you don’t want to put it there (reasonably!) You need to specify which directory to look in. I’m not sure whether you could get away with for Runtime ("ada") use "./ravenscar-sfp-mynewchip"; or whether you need to use an absolute reference for Runtime ("ada") use Project’Project_dir &amp; "ravenscar-sfp-mynewchip"; 
Weapons_List is an Enum, with possible variations of all the different weapon types you've declared. You also declared a structure with fields named the same things, but **these are different**. Despite the same names, they're different types, and as far as I'm aware, there isn't a way to programatically access all the values of a Record by iterating over the field names. 
Correct. Weapons_Type probably should be declared as type Weapons_Type is array (Weapons_List) of Weapon_Info; then you could say stuff like: character.combat.attack(Battleaxe).classification := Martial; and for i in character.combat.attack'range loop if character.combat.attack(i).classification = simple then Of course you've also not actually declared a variable called character yet. Also I don't quite see where you are heading with your records either.. 
I can't initialize them until I know what class I'm working with, unfortunately. That's caused a lot of headache and tedious coding with this project lol.
I'll give that a go. And there is a character variable in my actual code, apparently I missed that detail when copying it over. And whatcha mean about the records? The only ones that have caused me grief have been the combat record.
Okay, this is compiling and working fine, as far as I've seen, but it wont let me output the name or whether or not it's proficient. I'm not sure if that's on my end or if it's just not allowed by Ada. Here's the code, though. --In the body of the for loop, after the if statement Put (character.combat.attack(i)); --for the name, maybe? Put (character.combat.attack(i).proficient); --for the proficiency I think printing boolean values has been an issue for me in the past, but I'm not entirely sure. I also wasn't positive that I would be able to print the weapon name like that, so I'm not too butthurt, would still like input though! Also, thank you!
If I'm remembering it right, you don't need to initialize the array. You can just use it as a key/value store. 
I just mean that I don't quite see where you are heading with what records have what fields inside of them and why. This is not an issue with respect to compilation but rather just pointing out that it is not yet 100% clear to me where you are heading with the program. It might be nothing and just me not seeing what you are trying to do. I think I can tell that you are trying to describe a certain character and whether or not they are proficient with certain weapons. That makes sense - but if I have two different characters and they each have a dagger, should it really be possible for one of them to have a dagger that is simple and another to have a dagger that is martial? Maybe it is or maybe you are mixing up things that are attributes of the character with things that are attributes of specific kinds of weapons. Again, this won't cause your program to not run or not compile but it might be that you are not designing something that you think you are.
You shoud read the part of ARM about IO (http://www.adaic.org/resources/add_content/standards/12rm/html/RM-A-10.html ). The standard library provides functions and procedures for String, Real, Integer and Enumeration types. For Boolean, this is quite simple but there are two ways to do this: Put(Boolean'Image(character.combat.attack(i).proficient)) or package Boolean_IO is new Ada.Text_IO.Enumeration_IO(Boolean); Boolean_IO.Put((character.combat.attack(i).proficient); For your object itself, just code a *Put* operation on your type
*I* would find it easier to understand `Intelligence` than `INT` (my first thought was that it was some sort of integer)
&gt;'m not seeing where you're getting that a two different daggers can be classified differently from on another. &gt; And, as of right now, the full code only supports the creation on one character. If you did ever have the need for two characters, every time you created a new character, you'd have to initialize (and use storage for) the indication of the classification of the weapon because you are storing that with the character instead of with the weapon. Writing code such that individual lines don't need comments for what the line is doing is of course quite reasonable (though I would agree with simon that overloaded abbreviations hurt that goal) - however in terms of professional software engineering I would caution that the mindset of comment free code can go too far. You can achieve the the 'what' goal with clear coding but it is very hard to achieve the 'why'. In addition, once you stumble upon your first piece of code that is 100,000 lines long and you find that someone decided comments were evil you will quickly learn to hate the original author since you now need to read thousands of lines just to figure out simple things like while a certain package exists at all. So yes, avoid comments line I := I + 1; -- Increment I but don't fall in love with the idea that you can write code and have no comments at all - particularly if it will be maintained by someone else after you or maintained by you 2 years after you wrote it. 
I'll mess around with this and see what I can do. Thank you for the insight! I'm sorta familiar with attributes, but not well enough to use them on the daily. I think I remember my prof going over 'image briefly, but she glossed over it; she was more concerned with 'succ, 'pred, 'first, and 'last.
Ohhh, I definitely see what you're getting at here. So, instead of storing the dagger information with the character, should I store it separately and just indicate whether the character has a dagger and do with that what I may? Wouldn't &gt; type Weapons_Type is array (Weapons_List) of Weapon_Info; still make it so the Weapon_Info record is stored with the character? Edit: Also, thank you for the real world advice. I always forget that the programs I write (or help write) won't always only be like 500 lines of code. Not commenting code is fine where I'm at, but I definitely don't want to make it more tedious for coworkers and such later on. I'll try to get into the habit of commenting more. I really appreciate the extra perspective!
If you are using the standard console(s) in Linux or Windows, I don't know a single standard way to do this, but there might be one. There is a reset command in most Linux distros that works in bash. I think you might have to look for an Ada library that binds to ncurses to get this ability internally without calling out to the CLI. 
The only way to do this in a truly cross compatible way is by outputting a bunch of newlines. If you are willing to limit yourself to a select standard terminal emulators, you can do it "for real" with ncurses. Either find an Ada binding or call out to the C code yourself -- it's easy!
I know this is not helpful right now, but we are working on a very full-featured curses binding that we will be open-sourcing as soon as it's ready. In the mean-time, you can just use ANSI standard escape codes. ("\033[2J\033[;H") Here is an Ada program to clear the screen: procedure Clear_Screen is Control_Preamble : constant Character := Character'Val (8#33#); -- '\033' Clear_Screen_Code: constant String := "[2J"; Home_Cursor_Code : constant String := "[;H"; Clear_Screen_Sequence: constant String := Control_Preamble &amp; Clear_Screen_Code &amp; Control_Preamble &amp; Home_Cursor_Code; begin Put (Clear_Screen_Sequence); end Clear_Screen; I tried this on xterm, an ANSI console, and a real-live VT520. Hope that helps!
/u/alkatori -- The above was meant for you.
I have just started exercising the Ada95 NCurses binding that is bundled with NCurses, and have found that it does not support Unicode at all, which was a little disappointing (because although I don't really need Unicode right now, it may be required in the future). Is this the reason you are developing your own curses binding for Ada? or were there other reasons? Props to you, by the way, for working on this! I'm guessing that doing it 100% in Ada would have just been way too much work? (I have been considering doing my own lame "curses" 100% in Ada, if NCurses doesn't work out for me, but I know that will be quite some little task, and I would only ever be supporting the most common terminal types. However, I'm guessing that much of the complexity of curses programming has been dealing with a plethora of oddball hardware, which is unnecessary in my use case.)
^The linked tweet was tweeted by [@adaprogrammers](https://twitter.com/adaprogrammers) on Apr 09, 2018 08:19:06 UTC (11 Retweets | 11 Favorites) ------------------------------------------------- Put it in your diaries guys \#MakewithAda is back in 2018! Registration opens October 16th! Which gives you 6 months to get learning/revive your Ada knowledge and get some ideas down! For all information and to see last year's projects follow this link [https://makewithada.org](https://makewithada.org) \#Ada ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
!Panic! I haven't learned enough Ada to know what I don't know! :P I need to start scoping out a Ada compatible board that can handle old school serial, a decent display and quadrature input. 
Don't worry, we will help :) There's a couple STM32 boards that fit your requirements. 
Yes! I'm gonna win this year...son as I learn ada
The fastest way to get started is to use GNAT Community Edition to create a an STM32F4 discovery "hello world" project from the template. Here's the board that works with the template project: http://www.st.com/en/evaluation-tools/stm32f4discovery.html 
Nothing like conio.h in Ada?
In my experience, it’s better to avoid the exception handler for performance reasons, but I am working on real-time applications. For your example, look into the ‘range or similar attribute. With it you can check if a variable is in a types range before assigning it to a variable of that type. I am on a phone, so not real easy to check this, but I would go this route instead of the exception handler.
Yes, that's what I'm doing and using the `loop` keyword without any exception handlers. The advantages I saw here are concise code, taking advantage of Ada's type system to throw errors, and fast fails. For example, I could do `subtype My_Int : Positive range 7 .. 13728;` Then bounds checking happens automatically any time you use a variable of type My_Int. I wasn't aware that exceptions were notably slow. I'm interested to know more about why that is.
Interesting construction, though I can't see why you'd want to do this on modern activation-stack based (read: reentrant) models. In non-reentrant models this could be equivalent to a loop, but in reentrant models this introduces non-determinism on the underlying activation-stack (and thus, if a user keeps missing, he'll eventually blow the stack). The way something like this would be done in Ada would generally be something like: Function Get_Value return Value_Type is Begin INPUT_LOOP: loop READ_INPUT: Declare Value : Value_Type; Begin Value:= Get; -- A call to the appropriate IO fn. Return Value; Exception When Constraint_Error =&gt; Ada.Text_IO.Put_Line( "ERROR MESSAGE." ); End READ_INPUT; end loop INPUT_LOOP; End Get_Value; But as a rule, there's nothing wrong with recursion. (Just make sure the problem you're ding is amiable to recursion, like exponentiation, rather then just emulating procedural via subprogram-calls, like factorial.)
The answer would be slightly different if OP is using a Mac .. see [here](https://sourceforge.net/projects/gnuada/files/GNAT_GPL%20Mac%20OS%20X/2017-arm-eabi-darwin-bin/) for a compatible cross-compiler (the rest of the toolchain is fine, and of course required).
Named blocks also help to let you know about off-by-one errors in copy/pasting, too. (Because they help the compiler keep track of things, just like it does you WRT readability.)
Recursion is a perfectly acceptable implementation technique, provided that you can be sure the recursion depth will not exceed the available stack. In this case, since the recursion depth is controlled by something outside your program (the input to the program), you can't be sure, so avoiding recursion would probably be best.
What would be the differences and advantages of this verses a message queue system like RabbitMQ?
[removed]
That's a simple question that requires a big answer, if answered fully. At a first approximation, message queue solutions can be used for some of the same sorts of end goals as full remote procedure calling, as provided by the Ada Distributed Systems Annex and by CORBA. Using the DSA, an Ada program can be built consisting of disparate partitions. They can be developed and debugged like any other Ada program, with full type-safety and other Ada guarantees operating to bind all partitions of the program into a coherent whole. Each partition can then be run as separate processes on the same machine, or on different machines connected by a network. From a functional point of view, the distributed program will behave the same as the non-distributed one. This gives strong guarantees of coherence between the networked components. CORBA, on the other hand, allows distributed systems to work using disparate programming language implementations, which allows interoperability with not only pre-existing systems, but also allows the use of different development systems according to the unique requirements of each service on the network. Message queues are also implementation language agnostic, but work at a lower level, requiring more effort in engineering protocols, ensuring proper versioning and interopability of components, and so on. Message queues are great for simple use cases, and situations involving the integration of already-existing disparate systems. Note that whatever method is chosen to create a distributed system, the process is always complex: networks are unreliable, network latencies can cause or surface problems that didn't otherwise exist, there is only a finite amount of bandwidth to use, security oversights can bring a system to its knees or worse, network topology changes and does not remain static (so service discover, for instance, needs to be robust), different networks operate under different rules and are not controlled by a single administrator, network transport cost is not zero, and different networks behave differently. Above all, transient bugs in a network application can be extremely difficult to debug, since reproducing them is often impossible. Middleware systems like PolyORB can help alleviate some of these things, but the complexity of distributed network applications remains.
Check out standard package “Ada.Characters.Latin_1”. In it you will find CR and LF. You can construct your own newline constant String to reuse whenever you need a newline.
CR = Carriage Return? I'm not sure what LF is. So, assuming I've instantiated the Latin_1 package, would that look like: CR : Constant String := Character'val(13); ... Put ("New" &amp; CR &amp; "Line"); According to radford.edu, the declaration for CR is CR : constant Character := Character'Val (13);
LF = Line Feed. See https://en.wikipedia.org/wiki/Newline
Try this: CR : constant String := Character'Val(13); LF : constant String := Character'Val(10); NL : constant String := CR &amp; LF; NL = New Line
Then would the code look like Put ("New NL line"); or would it be Put ("New" &amp; NL &amp; "line"); to get the output to look like New line
Use the &amp; operator to combine strings. Your second example is correct.
Awesomesauce. Thank you!
You can also use the package Ascii, which although deemed obsolete, isn't likely to go anywhere. However I'd still recommend Ada.Characters.Latin_1
That won't stop me from liking Ada lol everyone tries to get me to dislike Ada but I can't
I honestly don't know what to expect with it lol I just tried a thing I thought might work and it didn't.
I tried using the code provided to test it out but the compiler is telling me that System.OS_Lib is not a predefined package.
Scratch that, I found that I needed to change "System" to match my compiler. We're good! Thank you!
If you are on Linux, the "Importing the C system() function" example also works. You may need to adjust spacing accordingly if you are using gnatmake with the -gnatyy flag. I'm sure there's a better/safer way using tasks and SPARK... :)
Windows, unfortunately
Not an issue. I still keep a Windows machine for radios, apps and GPS. But it sleeps most of the time. On Linux I use Visual Code and Patrick's (Entomy) Ada extension. 
I've got VS Code but can't make it work with Ada. I'm just copy pasting from there to adagide for now. Any tips on that?
Ok cool so basically what I'm using it for lol. My adagide is butts so I can't type anything into it
NixOS indeed seems like the way for me to go. Unfortunately gnat has been disabled within the distro in release 18.03. I'm looking at ways to get it back and working. https://np.reddit.com/r/NixOS/comments/8eiw2s/id_like_to_get_ada_compiler_gnat_available_and/
Never mind. I did not notice the link. By the way, I would suggest to improve the perform a bit by modifying the code below \-\- ... for I in 1 .. Column\_Count loop if Header.Contents \(I\) = Target\_Field then Target := I; end if; end loop; if Header.Contents \(Target\) /= Target\_Field then raise Invalid\_Target with Column\_Missing; end if; Create \(Output.File, Out\_File, Out\_Filename\); Put\_Line \(Output.File, Header.Source.all\); \-\- ... by replacing with for I in 1 .. Column\_Count loop if Header.Contents \(I\) = Target\_Field then Target := I; Create \(Output.File, Out\_File, Out\_Filename\); Put\_Line \(Output.File, Header.Source.all\); exit; end if; end loop; if Header.Contents \(Target\) /= Target\_Field then raise Invalid\_Target with Column\_Missing; end if; Anh Vo
Just add exit statement during stop rendezvous. By the way, Boolean variable Active should be removed unless it is used for other purposes. I am wondering where your task do the work.
It would be cleaner to change the loop to while Active loop.
Because it’s spam. So please just report it to mods and move on.
\-O3 \(at least on my machine\) does end up giving a very small but real boost in run\-time performance. Looks like the C\+\+ version is compiled with that option
Interesting
There was also this [preprint that was released 5 months ago](https://arxiv.org/abs/1710.07047), not sure what the differences are.
 with Ada.Integer_Text_IO; with Ada.Text_IO; with Ada.Numerics.Discrete_Random; with Ada.Unchecked_Deallocation; procedure Main is procedure Put_Line (I : Integer) is begin Ada.Integer_Text_IO.Put (I, 0); Ada.Text_IO.New_Line; end Put_Line; package Integer_Random is new Ada.Numerics.Discrete_Random (Integer); G : Integer_Random.Generator; type Node; type Node_Ptr is access all Node with Storage_Size =&gt; 24*(Integer (Float'Ceiling (1_000_000.0 / 3.0))); type Node is record Left : Node_Ptr; Right : Node_Ptr; X : Integer := 0; Y : Integer := Integer_Random.Random (G); end record with Size =&gt; 24*8; package Tree_Def is type Tree is tagged private; function Has_Value (T : in out Tree; X : in Integer) return Boolean; procedure Insert (T : in out Tree; X : in Integer); procedure Erase (T : in out Tree; X : in Integer); private function Merge (Lower : Node_Ptr; Greater : Node_Ptr) return Node_Ptr; function Merge (Lower : Node_Ptr; Equal : Node_Ptr; Greater : Node_Ptr) return Node_Ptr; procedure Split (Orig : in Node_Ptr; Lower : in out Node_Ptr; Greater_Or_Equal : in out Node_Ptr; Value : in Integer); procedure Split (Orig : in Node_Ptr; Lower : in out Node_Ptr; Equal : in out Node_Ptr; Greater : in out Node_Ptr; Value : in Integer); procedure Make_Node (Node : out Node_Ptr; X : in Integer); type Tree is tagged record Root: Node_Ptr := null; end record; end Tree_Def; package body Tree_Def is procedure Free is new Ada.Unchecked_Deallocation(Object =&gt; Node, Name =&gt; Node_Ptr); procedure Make_Node (Node : out Node_Ptr; X : in Integer) is begin Node := new Main.Node; Node.X := X; Node.Y := Integer_Random.Random (G); end Make_Node; procedure Delete_Node (Node : in out Node_Ptr) is begin if Node /= null then if Node.Left /= null then Delete_Node(Node.Left); end if; if Node.Right /= null then Delete_Node (Node.Right); end if; Free (Node); end if; end Delete_Node; function Merge (Lower : Node_Ptr; Greater : Node_Ptr) return Node_Ptr is begin if Lower = null then return Greater; end if; if Greater = null then return lower; end if; if Lower.Y &lt; Greater.Y then Lower.Right := Merge (Lower.Right, Greater); return Lower; else Greater.Left := Merge (Lower, Greater.Left); return Greater; end if; end Merge; function Merge (Lower : Node_Ptr; Equal : Node_Ptr; Greater : Node_Ptr) return Node_Ptr is begin return Merge (Merge (Lower, Equal), Greater); end merge; procedure Split (Orig : in Node_Ptr; Lower : in out Node_Ptr; Greater_Or_Equal : in out Node_Ptr; Value : in Integer) is begin if Orig = null then Lower := null; Greater_Or_Equal := null; return; end if; if Orig.X &lt; Value then Lower := Orig; Split (Lower.Right, Lower.Right, Greater_Or_Equal, Value); else Greater_Or_Equal := Orig; Split (Greater_Or_Equal.Left, Lower, Greater_Or_Equal.Left, Value); end if; end Split; procedure Split (Orig : in Node_Ptr; Lower : in out Node_Ptr; Equal : in out Node_Ptr; Greater : in out Node_Ptr; Value : in Integer) is Equal_Or_Greater: Node_Ptr; begin Split (Orig, Lower, Equal_Or_Greater, Value); Split (Equal_Or_Greater, Equal, Greater, Value + 1); end Split; function Has_Value (T : in out Tree; X : in Integer) return Boolean is Lower : Node_Ptr; Equal : Node_Ptr; Greater : Node_Ptr; Result : Boolean; begin Split (T.Root, Lower, Equal, Greater, X); Result := Equal /= null; T.Root := Merge (Lower, Equal, Greater); return Result; end Has_Value; procedure Insert (T : in out Tree; X : in Integer) is Lower : Node_Ptr; Equal : Node_Ptr; Greater : Node_Ptr; begin Split (T.Root, Lower, Equal, Greater, X); if Equal = null then Make_Node (Equal, X); end if; T.Root := Merge (Lower, Equal, Greater); end Insert; procedure Erase (T : in out Tree; X : in Integer) is Lower : Node_Ptr; Equal : Node_Ptr; Greater : Node_Ptr; begin Split (T.Root, Lower, Equal, Greater, X); T.Root := Merge (Lower, Greater); -- commenting out the following line -- doesn't seem to affect running time by much, if at all Delete_Node (Equal); end Erase; end Tree_Def; Tree : Tree_Def.Tree; Current : Integer := 5; Result : Integer := 0; Mode : Integer; begin Integer_Random.Reset (G); for I in 1..1_000_000 loop Mode := I mod 3; Current := (Current * 57 + 43) mod 10007; if Mode = 0 then Tree.Insert (Current); elsif Mode = 1 then Tree.Erase (Current); else Result := Result + (if Tree.Has_Value (Current) then 1 else 0); end if; end loop; Put_Line (Result); end Main; The above is a memory\-safe version \(no memory\-leak\) of the submitted Ada implementation. I've used the file defalut.gpr to build the executable: project Default is for Source_Dirs use ("src"); for Object_Dir use "obj"; for Main use ("main.adb"); package Compiler is for Switches ("ada") use ( "-Os", "-fstack-check", "-ffunction-sections", "-fdata-sections", "-flto" ); end Compiler; package Linker is for Switches ("ada") use ( "-Wl,--gc-sections", "-flto" ); end Linker; end Default; The usual way to invoke gprbuild is "gprbuild \-p \-P default.gpr". The "\-p" means create the obj/ directory if it does not already exists and "\-P" is intended to be followed by the name of the gpr\-file one wishes to build with. Gprbuild obsoletes gnatmake.
More performance due to one heap allocation and one deallocation instead of many heap allocations and deallocations. The solution above pre\-allocates a fixed amount of memory from the heap where the access type Node\_Ptr is defined and the memory is deallocated when the Node\_Ptr goes out of scope. The drawback is that the pre\-allocated memory may be excessive but what one gets is speed. The usual way for achieving memory safety if heap allocations are needed is using memory pools and the example above uses a bounded memory pool. If one is not happy with the bounded pool implementation and would like an unbounded pool that only allocates the needed memory then one would need to implement this one\-self which is a non\-trivial exercise but doable \(but would alas need unsafe parts of Ada I believe\). It's quite possible Ada will have a more general \(unbounded memory and memory safe\) solution to Treap in the in the near future \(next year?\) when access types will be allowed in SPARK.
Well, the pre-allocated pool of constant size is considered cheating given there is no defined limit of the number of nodes. Also, I don't think there were enough people who could afford to allocate 8MB of RAM (`1_000_000 * 24 / 3`) just for the preallocated pool in 1995 :)
This is the benchmark detail, which is outside of the context for the algorithm implementation and a fair algorithm should not adapt for benchmarks.
https://youtu.be/ZXsQAXx_ao0
They are a family of microcontrollers ranging from quite high-performance (STM32 H7) to low-power, bare-bones (STM32 L0). You'd use them for anything microcontrollers are used for: signal processing, motor control, monitoring etc. etc. They are used in pretty much any and all industry. r/stm32 might be a place to get more specific questions answered.
To start Ada programming on the STM32 there is the Ada Drivers Library : https://github.com/AdaCore/Ada_Drivers_Library/tree/master/examples we support a good variety of discovery boards. We also have a bunch of example projects, ranging from serious to completely silly on our blog: blog.adacore.com And if you do start to program in Ada/SPARK you should have a look at our next competition : makewithada.org Have fun :)
Human language is so polysemic, so there is no way to define anything 100% confusion-free, especially when you operate with terms like "naive" and "unscientific" :) I am glad so many people found the benchmark interesting! And I am thankful for all the suggestions and contributions!
Mind letting me know generally whereabouts you are? Where I am (Washington DC area), there are basically no Ada jobs, ironic as that is.
Cool! Thank you! I am curious, what are some things that others made using the STM32 chip? I’m looking for a project to get my feet wet and have a quick win.
Wait! I can copy existing Arduino examples and re-implement them using STM32 and SPARK/Ada!
Thanks for replying. I looked in that subreddit, but it doesn’t seem to have that many memebers, leading me to believe that it’s abadoned.
stm32f4?
The Ada Drivers Library is not in SPARK itself but you can implement SPARK modules on top of it.
Wow, now that is a lively subreddit. Thanks!
Haven't yet completely read the research paper. Are there plans already to integrate the GNAT / SPARK improvements which make this feature possible? Could you predict in what kind of timeframe these might be released? Thank you.
SPARK code is exception\-free code. You can use "raise exception"\-statements but then you will need to prove that you will never raise the exceptions in run\-time. Exception handlers are also forbidden in SPARK. The design decision of aiming for exception\-free code can be found in the C\+\+ camp too because then the executables will not need to store the call stack for exceptions resulting in smaller executables, and no performance penalty by error code handling instead of exception\-handling, and no reason to store debug information unless one is going to use a debugger and step through the code. The idea of avoiding exceptions can be found in Google Go, Rust and ParaSail too.
I think it depends if you are more on the software or hardware side of embedded development. As a simple and approachable beginner project, I'd recommend a simple game: If you have enough LEDs you could maybe do Simon Says? That'll get you around IO, timing and possibly interrupts :) If you are more well-versed in embedded development I'd recommend working with a core peripheral you haven't used before.
We're working on the implementations in GNAT and SPARK right now. We plan for a prototype version by the end of the year (under some debug flag) and a full implementation during the following year.
errm .. Ada, please
Hi, one more question. If this sounds silly, then feel free to correct me. STM32F4 board uses the ARM architecture. Based on that, if I write a small application on that, can I (reasonably) easily deploy the same application on a Raspberry Pi or an equivalent more powerful ARM based processor?
The instruction sets are not the same so you will have to recompile your application for this target, as you would do with C/C++. On the other hand, Ada is very portable so you will have very little adaptation to do in the sources code. 
Interesting! It does make me slightly uneasy, though. Is it really going to be easier to understand?
The only use I've ever had for this is when logging traces for debugging: procedure Debug(Message : String; Where : String := GNAT.Source_Info.Source_Location);
I've been in contact with Dirk Craeynest and the short answer is no. The longer version is: The Ada\-Belgium Spring 2018 Event is an informal event, and no video or other recordings are made. Videos of our previous event are available on\-line though, i.e. of the presentations at the 8th Ada Developer Room at FOSDEM 2018 held early February in Brussels. See https://www.cs.kuleuven.be/\~dirk/ada\-belgium/events/18/180203\-fosdem.html for pointers to each presentation's recording.
I've already watched videos from FOSDEM 2018, but thanks anyway.
Does she program in Ada as well?
Based on what I found onlyine, she is not a software engineer. Her background is in producing media and combining the arts with tech.
Her is a TED talk by Zoe where she talks about Ada Lovelace: [https://www.youtube.com/watch?v=1QQ3gWmd20s&amp;feature=youtu.be](https://www.youtube.com/watch?v=1QQ3gWmd20s&amp;feature=youtu.be) Her is an interview with Zoe: [https://theconsultingdetectivesblog.com/2017/10/20/interview\-with\-zoe\-philpott\-creator\-of\-ada\-ada\-ada/](https://theconsultingdetectivesblog.com/2017/10/20/interview-with-zoe-philpott-creator-of-ada-ada-ada/)
She should learn Ada. That would be meta.
Does she accept ADA?
https://github.com/jrmarino/libsodium-ada Or write yourself.
Interesting to know what the "substantial initial subset" of 2012 is (and isn’t). Good for them, though. I remember HP being very proud of their ANSI C compiler (which turned out not to support function prototypes).
This is probably unobtainium for us mere motals and hobbists. 
I think it is possible; it's just there's a lot of the "herding cats" problem getting it started... that, and it's one of those projects where there's a lot of work that you can't see the effects of.
I agree, this does seem possible.
see also the GitHub repos of James Humphry: https://github.com/jhumphry?tab=repositories (those with "SPARK" in the name)
Not what I would call an Ada-12 compiler.
It's good that stuff like this is going up on YouTube. When I started learning Ada late last year YouTube was one of the first places I looked, and I could barely find anything about Ada on there. The AdaCore U website also requires Flash, which has been strongly discouraged for a while now and is essentially obsolete. Putting it all on YouTube should make it much more accessible.
Use FSF GNAT, don't use AdaCore's libs.
There are two free sources of GNAT: one, from https://www.adacore.com/community (CE), and one from FSF (FSF). They contain pretty much the same libraries; the FSF version comes with the [GCC Runtime Library Exception](https://www.gnu.org/licenses/gcc-exception), like the runtimes for other GCC languages, and allows proprietary software. The CE version does **not**; it’s pure GPL. Most authors of other libraries use the Runtime Exception or its previous incarnation, [GMGPL](https://en.wikipedia.org/wiki/GNAT_Modified_General_Public_License) (or even an MIT license). But you’d need to check first.
**GNAT Modified General Public License** The GNAT Modified General Public License (short: Modified GPL, GMGPL) is a version of the GNU General Public License specifically modified for compiled units and for the generic feature found in the Ada programming language. The modification is as follows: As a special exception, if other files instantiate generics from this unit, or you link this unit with other files to produce an executable, this unit does not by itself cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU Public License. The GNAT Ada compiler can automate conformance checks for some GPL software license issues via a compiler directive. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ada/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Someone posted in /r/programming for this post that AdaCore is revamping the university stuff to remove the flash and update the content.
Thanks everyone for the advice! This subreddit is a lot more active than I thought!
I used it for our intro CS class at uni. Since then, I’ve used it for a fun side DND project :) I love the language so much.
Neat! Was the class recent or a long time ago?
Two years ago lol. It’s been converted into c++ recently
Keeps me out of a debugger a hell of a lot more than c or c++.
What are you wanting to do with it?
Great question. I'm pretty good with Python, and can get by in Perl, Awk, and Bash as well as several additional languages (mostly all dynamic languages that are easy to code in, but have a performance penalty). I've wanted to up my game to something else for a while now. Java and C# are both good languages, but I'm not a fan of the JVM &amp; .NET for a variety of reasons. Some of the languages that leaves are: C/C++, Fortran, Ada, Rust, Nim, OCaml, Crystal, and Go. I've played with all of these except Go (not my thing). Nim &amp; Crystal are still a ways out from 1.0. Rust seems to be changing too fast. That really leaves C/C++, Fortran, and Ada. Ada seems to be the best from a language design point of view (personal preference) even though C and C++ are waaay more popular. Fortran is great for numeric/scientific computing (one use case I have), but is pretty confined to that niche. From a book perspective, I guess anything general would be ok. I can look on Amazon, but figured y'all would have recommendations. Thanks for any help in advance!
Of course it has :( I was one of the people in college always pushing for more industry related technology. Assembly-&gt;C, VHDL-&gt;Verilog, other stuff to Python or even VBA as those are all things commonly available to engineers. C++ is probably better for most people (not going into aerospace) to have on a resume, but Ada seems a lot cleaner.
Introduction to Ada Programming, 2nd Edition https://www.amazon.co.uk/dp/1987673859/ref=cm_sw_r_cp_api_i_OgdoBbSX4S4YC
My experience with ocaml has been stack overflows, eating all my 32gb memory until it dies (ocamlopt), the spacetime thing causing linking errors and packages not compiling, so fuck that.
What kind of apps are you looking at writing?
http://www.adaic.org/learn/materials/#ada_2012_books
Not sure how I missed this one earlier. It looks great. Thank you!
My experience with OCaml (although limited) was also frustrating due to the ecosystem. It also seems like multi-core is always just around the corner. F# is basically OCaml on .NET (seems to assume you're a C# guru), although it has some nice data science scaffolding. I also tried Haskell, but there is a lot of confusion and things you seemingly just have to know (like you shouldn't use this obvious to use library because it is super slow, so instead use this obscure library). Also, Monands and things like that can be too academic for me at times.
Anything that might come up in the future where a scripting language is just too slow or where I need something with a lot more compile time checks and parallel features. I like being able to distribute a single binary too that is small and can hide my code if I need to. The first applications I can think of would be software for running studies on electrical grid models. This is almost always done in the traditional scientific computing language (Fortran), or C or Python/Matlab, but Ada might make a decent fit. I've found that sometimes writing software to do something is the best way to learn that something :).
&gt; a fun side DND project If it were any language but Ada, I'd be certain you meant "Dungeons and Dragons," with no chance you meant "Department of National Defence." :) Instead, I'm only mostly sure!
Assuming you’re using GNAT .. there’s [Ada 2005 Math Extensions](https://sourceforge.net/projects/gnat-math-extn/), which is a binding to some parts of BLAS/LAPACK, [Ada Lapack](https://sourceforge.net/projects/ada-lapack/), which uses an automatic Fortran-to-Ada conversion, [AdaBLAS](https://sourceforge.net/projects/adablas/), which is a binding to BLAS, and [AdaLAPACK](https://sourceforge.net/projects/adalapack/), which is a binding to LAPACK (surprise!). The bindings above require BLAS, LAPACK libraries to be installed on your system. No problems for Macs, and should be easy enough on Linux systems; I think that there’s been a downloadable Windows release fairly recently, but can’t find it.
That’s exactly what I meant though lol. I recently started playing dungeons and dragons and decided to build a character builder for myself! Records and enumerated data types work very well for this project and when I started writing it I didn’t know how to do these things in other languages. Now that the program is over 2000 lines of code, I don’t want to try rewriting it in anything else lol except that’s most certainly the next phase, additional points if I can get it working with a GUI :)
I’m sad about the change but most people are happy
F# has always been a second class citizen on .NET, I wish Microsoft would send a touch more love it's way.
I'm looking at the application and the embedded spaces for Ada. There's some nice parts of Ada like types that work well for my coding which is radio and RF related. Also someone has a Units of measurement library that may help you. http://www.dmitry-kazakov.de/ada/units.htm 
I'm using it for hobby work which is radio and electronics related. Three areas of focus: * There's multitude of scripts and small programs that do various electronics and antenna calculations. Many are in Basic, Pascal or old school C. * Embedded projects for controllers, radios, tools, rotors, etc... * Large applications and libraries for complex radio apps 
Work: Ada for embedded flight SW in satellites and satellite-born instruments. Also used for PC-based testing tools and development-support tools for flight SW. Hobby: Ada for static analysis of executable code to determine bounds on execution time and stack usage. Pros: well designed language, stably evolving with great backwards compatibility and portability, supports both high-level programming and low-level HW acccess, good module systems, good type system. I could go on... Cons: somewhat limited "ecosystem" for desktop/network program, with a limited (but sufficient) set of libraries and library bindings. Why: see pros above.
What do you mean?
I only really touch a debugger when I'm doing something dangerous, i.e. pointer work, which I do very little now I don't touch C or C++ anymore. If I do end up in a debugger, it's not for long. When I was working in those languages before, we'd be spending days if not weeks in a debugger.
For units/dimensions, you can also check out https://www.adacore.com/gems/gem-136-how-tall-is-a-kilogram 
I think you have the wrong Ada...
https://www.cardano.org/en/buy-sell-ada/
As good a cause as this may be, the Ada programming language subreddit is not the place for it.
&gt;Now that the program is over 2000 lines of code, I don’t want to try rewriting it in anything else lol except that’s most certainly the next phase, additional points if I can get it working with a GUI :) Honestly, this is what makes the non-maintaince of the DOTNET and JVM GNAT backends so disappointing: being able to do all your program-/business-logic in Ada and slap on the UI easily via a Visual Studio project ([VB.net](https://VB.net), C#, at that point it hardly matters) and whip up a GUI to go with it would be really nice in situations like this. (Honestly, the best RAD language I've used is Delphi; it's kinda disappointing Borland never did a Turbo Ada or else we might have Ada packaged with Delphi right now.)
You lost me a little bit with this one lol. Are you saying it’s possible to make a GUI using Ada/ implementing Ada code in a GUI? Because I’ve been trying to figure out how to do this for the longest time.
&gt;Are you saying it’s possible to make a GUI using Ada/ implementing Ada code in a GUI? Because I’ve been trying to figure out how to do this for the longest time. Short answer: Yes. Longer Answer: With something like Dotnet you can do your UI in VB or C#'s RAD UI builder, import/link the assembly produced by your Ada code and there you are. The same with JVM, except perhaps a bit more irksome, as Java-UI is kinda nasty \[IMO\], but you'd just link to the CLASS file produced by your Ada code and there you are. For a "more native" approach there's the bindings to the QT \[C++\] library... but I rather don't like QT very much. \[Personal opinion there, some people do like it.\] — Additionally there's the [gnoga](http://www.gnoga.com/) library/framework which uses your browser as a 'viewport'. 
This is epic! Thank you so much! Do you also have some links perchance?
&gt;This is epic! Thank you so much! Do you also have some links perchance? Er, links to what? I've given you the link to [gnoga](http://www.gnoga.com/); the QT binding is easily searchable "[ada QT bindings](https://www.startpage.com/do/search?cat=web&amp;language=english&amp;query=Ada+qt+bindings)", using Dotnet is just like using dotnet and importing an assembly, using JVM is just like using a project importing Java class files...
I was looking for tutorial-esque links. I have never imported an assembly, nor do I know what that means, and comp sci stuff usually has good documentation/tutorials so I figured it was worth asking about. Thanks for the replies tho!
Ah, you right click on the project-view tree, and select the "References" option. [Link](https://www.startpage.com/do/search?language=english&amp;query=visual+studio+import+assembly+into+project&amp;cat=web).
I've only really used VS Code to type up my Ada programs and copy/paste them to adagide for compilation, building, and running. (My laptop hates adagide so it's unbearable to type in it.) Besides that, though, I haven't touched Visual Studio.
&gt;I haven't touched Visual Studio. I haven't used the Ada-integration for Visual Studio, but there's a thread about it in the \`comp.lang.ada\` newsgroup; search for "*ANN: VisualAda (Ada Integration for Visual Studio 2017)*" and you'll find it.
I really appreciate all of this! Thank you so much!
No problem; I hope it helped.
Good luck with the project guys!
Hopefully a friendly quality improvement hint: Youtube search "Ada lovelace documentary" and "Ada programming Adacore", listen to the pronounciation of the word "Ada". Thanks for the work.
Glad to see some more modern work. What I'd really like to see is some kind of live programming video where someone builds something on-video and walks through all the steps.
Good news! I have this planned as a series! I can probably get the first one done this week.
My biggest problem is that because of what you say, generally speaking only expert users use F#. That and you have to already know C# and Visual Studio in order to have any impact.
Does that work though? I would think that you'd always get the line of that declaration.
A ongoing project that evolves and teaches is hard, but the best for most learners. 
Yes, default parameters are evaluated at the point of call, not declaration
Well, depends on what kind of program it is and how long you've had to do it in. But [herr](http://www.adaic.org/learn/materials/) are some links.
Its got the same basic control and data structures as most languages do. Look on rosettacode.org for examples
You could read "Ada for C++ or Java Developers" (https://www.adacore.com/uploads_gems/Ada_for_the_C++_or_Java_Developer-cc.pdf) which does a good comparison of language constructs between the three languages. 
Overall it was a good read, but I found a few of the "how Ada can address CWEs" were very weak. For example, for CWE involving code injection, it states that Ada programs are *always* executed fron read-only memory and therefore can't be modified. Obviously, not always true and even C programs can be stored in read-only memory. The article does give some more specific cases, but there isn't enough details in some cases. It would have been better if there were more detailed examples that really show how Ada can help. 
I find this somewhat mind boggling O\_o
You can use OpenSSL and other C libraries pretty easily from Ada. Unfortunately the documentation for OpenSSL is not very good :(. In my project, I needed ECDSA sign/verify, so here was my implementation of it. Thin Binding: [spec](https://github.com/MichaelAllenHardeman/bitcoin_script/blob/master/code/bitcoin-api-openssl.ads) Thicker Binding: [spec](https://github.com/MichaelAllenHardeman/bitcoin_script/blob/master/code/bitcoin-crypto.ads) [body](https://github.com/MichaelAllenHardeman/bitcoin_script/blob/master/code/bitcoin-crypto.adb)
Here's the first of (hopefully) many [https://www.youtube.com/watch?v=m8wWEI\_ZLMU](https://www.youtube.com/watch?v=m8wWEI_ZLMU)
Thanks man. I ended up not turning anything in though. It was too much stresss and it's not a large portion of my grade considering the project due monday
You should go ahead and give it a shot when you have a chance. Ada's a lot saner than Java... 
It's just what we've been using in class. I don't know much about the use cases of Ada and maybe that should be a separate post but I'm more of a web dev person. I'm used to java, javascript, html, sql, c# kinda stuff
You can do web dev in any language, see the original CGI specs and use cases using Perl and C.
Interesting. Do you have a link?
https://www.google.com/search?q=cgi+libs&amp;ie=utf-8&amp;oe=utf-8&amp;client=firefox-b First two links. My [ether](https://github.com/Lucretia/ether) lib which isn't complete or useable, but is a start. I'll likely rewrite it at some point. There's a FastCGI implementation in Matreshka. 
Does gnat target that board in particular?
AdaCore has drivers for some of the Discovery boards among others. https://github.com/AdaCore/Ada_Drivers_Library/tree/master/examples (Special tanks to u/Fabien_C !)
Has this been submitted to the ARG?
The F3 - no, the others - yes. The F3 would be doable (adjust clock/memory/interrupt settings in the RTS, then sort out the Ada Drivers Library). The F407 is the MCU used in the Crazyflie drone, with an Ada version at https://github.com/AdaCore/Certyflie
Possibly; there's been a lot of work on a `Non_Blocking` aspect already; this paper could be something different, or it could be the same guys who started the non-blocking aspect AI. In any case I'll give it a read.
The F429 Discovery is the best for my immediate needs since I don't have to add a separate display. I will need to figure a way to package it as-is for a demo, maybe make a larger carrier board or mount with stand-offs. Question: Do all the STM32 chips come with a RTC? I can add a DS one thru I2C, but I'd rather not have the complexity. 
Not sure what you mean by RTC? the nrf51 has 2 RTCs, which basically deliver a regular interrupt - the STM32F429 one RTC: &gt;The real-time clock (RTC) is an independent BCD timer/counter. Dedicated registers contain the second, minute, hour (in 12/24 hour), week day, date, month, year, in BCD (binary- coded decimal) format. Correction for 28, 29 (leap year), 30, and 31 day of the month are performed automatically. The RTC provides a programmable alarm and programmable periodic interrupts with wakeup from Stop and Standby modes. The sub-seconds value is also available in binary format.
Thanks verifying it existed, wasn't sure since many boards don't, I was able to find some info on programming the RTC. https://stm32f4-discovery.net/2014/07/library-19-use-internal-rtc-on-stm32f4xx-devices/ 
Even if it didn’t, it wouldn’t take much to make it.
The last version of the Win32 package (by John Walker) is for Windows NT, so it doesn't look lovely from that side of things. But he did just wrap the C++ bindings.
My instinct is to distrust GDB and assume that the constraint error is real. Could you show us the Ada source code and indicate the location of the constraint error?
Thanks for the reply! My assumption was that they're connected, because the calculation that throws the constraint error just takes the number and multiplies it by a fairly large constant. The number should be in the range 500-1000, but the reinterpret of the 4 byte float into an integer means the integer value is around a billion, which of course causes an overflow. 
I can't say anything more without seeing the source code of the multiplication and the declarations of the types of the variables involved in the computation and the type to be returned from the multiplication. But in my experience, debuggers are much more likely to have "bugs", in the sense of showing misleading or incorrect information, than for a compiler to have a bug. If your compiler is GNAT, which version is it, and which options are you giving it? Some older versions of GNAT did not enable run-time overflow checks by default, which could lead to behaviour that is not expected of standard Ada. The compiler option that should be used the enable overflow checks is -gnato.
I'm sure it's possible, given the existence of [this PDF](http://www.gnavi.org/gnatcom/adacom.pdf). ( From http://www.gnavi.org )
See gnatcom 
I think this will be a really good resource for beginners, especially with the ability to compile and run code samples. Bravo to AdaCore!
I wonder if this using llvm and jit?
It's using GNAT Community, so GCC based.
Missed opportunity 
Why are you saying that?
https://groups.google.com/forum/#!topic/comp.lang.ada/umrsksm3nEs
I’m involved in that thread.
So I can see, so I figured you'd be aware that there isn't a functional ada frontend for llvm yet.
[This answer](https://stackoverflow.com/a/40891045/40851) talks about a makefile to automate [my attempt above](https://stackoverflow.com/a/40873379/40851). I said more about building Ada libraries &amp; linking with C [here](https://stackoverflow.com/a/26821216/40851) using [gprbuild](http://docs.adacore.com/live/wave/gprbuild/html/gprbuild_ug/gprbuild_ug.html). To include this in a Makefile, I’d leave at least building the Ada library to gprbuild: libmyadalib.a: force gprbuild -p -P myadalib.gpr .PHONY: force
You want to read [this and the linke to mixing languages](https://gcc.gnu.org/onlinedocs/gcc-7.3.0/gnat_ugn/Binding-with-Non-Ada-Main-Programs.html#index-adainit) and [this cmake file](https://github.com/mosteo/ada4cmake)
You're very welcome! I'm also pretty green (especially to Ada) so let me know if you have any issues :)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/CMk6jZY.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
So many language designers get stuck with the idea that arrays have to start at zero. Just learning Swift and yep, they made that mistake.
But what difference does it make? I am just learning Ada and many things are very cool, but I don't quite understand the real benefit of having arbitrary array index ranges. Still better than having none! Like C.
Ada packages can hold state like objects. For example, you can create a Singleton package and create multiple objects with renames.
It's not a major feature obviously, but it's QoL feature more or less. Note that you can use enums for array index, i.e. stuff like this: Mix : array(Color range Red .. Green) of Boolean;
You can index with any scalar type. You might want to index over temperatures ranging -100..100.
I'm currently porting Matlab code, where 1-based indexes are common, to Ada. And I'm interfacing with hardware where 0-based indexes are natural. It's nice that the language lets me choose whatever I need in the moment. And there are times when some other starting index makes sense, because that's what the range of the array just is naturally. If I were doing this in C it would be a pain to make sure I'm adjusting indexes right everywhere. C++ could handle this somewhat naturally with liberal doses of classes and operator overloading, but Ada has it built-in.
No, renaming doesn't work that way. A rename is just a rename, it's not a declaration and does not create new instances
One reason for using package renaming is to avoid usage of use-statements and introduce shorthand names for packages as Simon already has mentioned. It isn't a solution that everybody likes. I've understood that there is a large group of developers who are OK with it and another group that strongly dislikes doing that. That's why I avoid using renaming for the purpose of producing minimalistic code (short lines). To produce minimalistic code in Ada I prefer to use tagged types to be able to use the object-prefix notation and prefer to use enumeration types over constants (by taking advantage of "use all type"). Another thought on the subject of making minimalistic code in Ada is to ban usage of use-statements but to allow it for one package of your choice: "package My\_Package is subtype Unbounded\_String is Ada.Strings.Unbounded.Unbounded\_String; end My\_Package;". It is then possible to write "use My\_Package;" and then one can declare ubounded string variables by "Name : Unbounded\_String;", and to "get access" to the subprograms operating on unbounded string variables utilise "use all type Unbounded\_String;" To make sure it is only the package My\_Package that is utilised with a use-statement "use My\_Package;" one can use AdaControl which has a rule to ban use-statements but can make exceptions to that rule. And oh yes, I can mention that John Barnes writes in many places in his books "There is a strong school of thought against the usage of use-statements" which indicates one should avoid use-statements. If one thinks about it, having one package and one package only that deviates from the rule should be OK.
I have made use of package renaming in the Ada binding to Wayland ([https://github.com/joakim-strandberg/wayland\_ada\_binding](https://github.com/joakim-strandberg/wayland_ada_binding)). The idea was to have two packages Posix and Wayland\_Client (and also in the future a Wayland\_Server package but no plans yet to make that). The Wayland\_Client package depends upon the Posix package because there is a subprogram that takes a file descriptor (Integer) as input and to get the file descriptor one uses the Posix package to get it. However, the idea was also to hide the file descriptor in the private part of a type called File that is limited tagged, and it should not expose to the user its private content, only the subprograms that can be used on a File instance. To enable the Wayland\_Client package to have access to the private contents of File instances the Wayland\_Client package needs to be a child package of the Posix package. That's why there exists three packages Posix, Posix.Wayland\_Client and Wayland\_Client where the Wayland\_Client package is simply a renaming of Posix.Wayland\_Client.
That's what it says on the sidebar.
bad bot
In a general, abstract case, there's not much difference, you just get used to the one you have. But when dealing with meaningful data structures, where some particular indices will make proper sense, this is great. Specially since any scalar type can be an index in Ada. In your learning you'll come to some examples sooner than later, and will see the advantage, I'm sure. 
This is why universities shouldn't just teach C derived languages. Try [here](http://www.adaic.org/learn)
https://learn.adacore.com/
If the self-plug can be excused, [I love writing about Ada](https://two-wrongs.com/tags.html#ada). Unfortunately, I can rarely spare the time. :(
r/ada387
Where was it suggested that you should use package `Display`? It’s not standard Ada. Perhaps if you go back there you’ll find a hint.
Hello, These packages (Display and Display\_Basic) are part of AdaCoreU’s “support material”: make sure you follow the steps to install it on [http://university.adacore.com/getting-started/](http://university.adacore.com/getting-started/) (see the “For Windows, we also provide an installer to do this.” part). By the way, if you are learning Ada, you might be interested in [https://learn.adacore.com/](https://learn.adacore.com/) :-)
I recommend *Ada Distilled*, available from [http://www.adaic.org/learn/materials/](http://www.adaic.org/learn/materials/)
Item is the variable itself, but in an abstract sense. It’s the thing that the method is manipulating, in a way. Just like in your example, FORE represents the number of places before the decimal; AFT represents the number of places after the decimal; EXP represents the power to which the float is raised. They aren’t the actual value, they just point you to the information you need to know.
What you're dealing with here is named parameter association. Imagine that you have a subprogram `Function Probe( Object : Image_Data; Y, X : Positive ) return Boolean;` -- notice how the `X` and `Y` are in the reverse of how most people would write it (RADAR data is like that) -- without named parameter association you're forced to always call the function like `Probe(Data, 12, 128)`. With named parameter association, you could position the parameters how it makes sense to you, as well as disambiguating what the parameters in the call are for: Probe( X =&gt; 12, Y =&gt; 128, Object =&gt; Data );
Mods: we could also have a link to the [AdaIC learning materials](http://www.adaic.org/learn/materials/) page.
You can read the input as a string S, do whatever checking you need to do, and then use Float'Value(S) to convert it to a float. Alternatively, use Float_IO.Get and catch Data_Error.
You can also catch the Constraint_Error on Float'Value if you have bad input.
There's also David Botton's [LearnAdaNow.com](LearnAdaNow.com) effort.
for a cross-platform native library, try GtkAda!
Oh, sounds like a good idea; cheers!
For the package manager there's the on-going project Alire: https://github.com/alire-project/alr 
Wow that's great, thank you. I'll keep a close eye on this 
Function Get\_Float( Prompt : String := "Input a Floating-Point number: " ) return Float is Begin GET\_INPUT: loop Ada.Text\_IO.Put ( Prompt ); declare Input : String renames Ada.Text\_IO.Get\_Line; begin Return Float'Value( Input ); exception when Constraint\_Error =&gt; Null; end; end loop GET\_INPUT; End Get\_Float;
&gt;Hello my dudes, is there any package manager of some sorts to download and install Ada libraries. Not currently, to my knowledge -- though there is work towards such a package manager ongoing. Both [here](https://github.com/OneWingedShark/AdaProjectManager) and [here](https://github.com/alire-project/alr) are two separate efforts at implementing package managers, the former being stalled in design, and the latter apparently having some implementation but little/no documentation. &gt;Also, what is the best GUI library you could advise? preferably cross platform and easy to use(hoping to make a text editor) I would recommend David Botton's [Gnoga](http://www.gnoga.com/).
The FSF repo for GNAT is very close to the head of our own repo for GNAT at AdaCore. In particular, they support the same language, with the same SPARK extensions. So yes you can safely compile your code with GNAT FSF and analyze it with the SPARK toolset provided by AdaCore. Regarding runtime library licenses, also note that GNAT may compile your code with no runtime library at all (the zero-footprint profile) in which case the license of the runtime library that comes with your compiler does not matter. That is possible of course only if your code does not depend on features that require runtime support, and if you specify a zero-footprint library when compiling.
Mods: thanks!
Focus on real-time/embedded software concepts, and trying some of them out, (can do it on your development machine, don’t worry about finding and actual embedded system) understanding how they all work, and understanding how Ada works with the system, and how to get as much efficiency out of the CPU as possible. Some applications will have safety or security implications, or both. Also, how to interface Ada code with other languages as well, could be something too. Sometimes we have to interface legacy Ada applications with other newer code. I have been in aerospace s/w development for 17+ yrs. 
Learn by making games, games are an area of embedded when applied to consoles, start with console games like a text adventure, work up to simple 2D graphical games and then start messing with OpenGL. This will get you learning the language first. There are/were some simulators built in Ada way back, no reason why it cannot be done today. Then start to look at smaller embedded targets, there is AVR, ARM stuff available.
thanks for your help, i'll have a look and start trying some of them out. Just hope i can get to some sort of reasonable level. I don't want to be a burden on guys like you, i'm sure having someone asking you a question every 2 mins isn't great for your productivity!
Yes, i'm only new to programming but i believe its used in a lot of safety critical / aerospace stuff
thanks for the tips, a text adventure sounds like a good place to star and hopefully not too difficult for a noob like me!
Well thought out and well documented unit. Nice work.
^The linked tweet was tweeted by [@DirkCraeynest](https://twitter.com/DirkCraeynest) on Sep 10, 2018 20:46:26 UTC (5 Retweets | 10 Favorites) ------------------------------------------------- We're working on a proposal for another \#AdaProgramming Developer Room at \#FOSDEM2019 early February in Brussels. Help is welcome: join the \#AdaFOSDEM mailing list! [http://listserv.cc.kuleuven.be/archives/adafosdem.html](http://listserv.cc.kuleuven.be/archives/adafosdem.html) [Attached photo](https://pbs.twimg.com/media/DmwpaSzW0AAo8jh.jpg:orig) | [imgur Mirror](https://i.imgur.com/sLBB1pC.jpg) ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
We're looking for some some Ada developers in Huntsville, AL (the 'Rocket City'). You looking? PM me if you're interested.
You can do this with a static predicate (in Ada 2012, at least): subtype Your_Type is Integer with Static_Predicate =&gt; Your_Type in 5 | 20; That will throw an error if a value of type `Your_Type` is any value other than 5 or 20. And yes, this works for string types as you'd expect.
&gt; Could someone please show me an example for how to create a subtype of integers that can only be two values &gt; &gt; &gt; &gt; like for example how would i make a subtype that could only be the values of like 5 and 20. Subtype Two_or_Three is Positive with Static_Predicate =&gt; Two_or_Three in 2 | 3; &gt; and would that same concept work for strings Yes, though there are two or three different-ish methods to do this: -- Using a discriminated record. Type Example_1( Length : Two_or_Three ) is record Data : String( 1..Length ); end record; or -- MR, MS, MRS, etc... Type Title_Abbreviation new String with Dynamic_Predicate =&gt; Title_Abbreviation'Length in Two_or_Three; or -- Decomposing into various subclasses; I may be misremembering the exact -- syntax, but this should illustrate the idea. SubType Abbreviation_2 is String(1..2); SubType Abbreviation_3 is String(1..3); SubType Abbreviation is String with Dynamic_Predicate =&gt; Abbreviation in Abbreviation_2 or Abbreviation in Abbreviation_3;
Ahh, the everlasting polishing of the C turd.
It must be better to tack things onto an error-prone language to try to make it less error prone than to use a language that was designed to reduce errors, right?
Console I/O can be tricky. The first get for a needs a delimiter such as a return so it knows where to stop reading the input but it doesn’t consume it. When you read b that return is still in the input stream and thus you’ll get an empty input and thus constrain. In your second example the get_line contains the entire line including the delimiter. It’s able to read a from the line and ignore the rest. When you get afterwards the input is positioned properly to read the integer and works fine.
Idiots keep posting this stuff
thanks for detailed response, much appreciated. So does that mean, after i type in the number for variable a,its actually also trying to grab the text "put\_line.."? and therefore it doesn't like the mix of integers &amp; strings?
Try typing “34 56” on a single line an press enter. I suspect your original program would read both numbers just fine. When getting the first number it read “34” and converted it to 34. When you read the line it read “ 56” and converted it to 56. Now if you flipped and did the get_line first and entered the same “34 56” again it would take “34 56” for the line and only use the “34” portion to return 34 as the first number. The program would still be waiting for you to enter another line. Say you entered “78 90” and pressed enter. Then the get(a) would convert the “78” to 78 and leave the rest of the line in the input buffer in case you did another get(a). 
What do you mean?
This subreddit is about Ada, the programming language, this article is not about it.
Oh I apologize I will remove it immediately 
You can also just use a skip_line to discard whatever is left on the input line if you want.
Text\_IO's facilities for non-character, non-string I/O are not very intuitive. I recommend always getting a full line with the Get\_Line function, and then parsing that. This helps avoid the kind of surprises you encountered.
I take it this has nothing to do with [this](https://en.wikipedia.org/wiki/Microsoft_XNA)?
Hi, I will first point out that I don't know Rust, so I won't do a feature vs feature comparison. But on a higher level, some things that may interest you are: 1. SPARK - ability to prove your software is free of runtime exceptions. BTW, SPARK is supposedly going to get Rust like pointers. 2. Ravenscar profile - A restricted runtime for Ada that makes it easier to analyze multi-threaded programs 3. Distributes annex - support for distributed programs (note: only GNAT supports this) 4. Ability to restrict language features. For example, you can specify you don't want any heap allocation. 5. Ability to control at the bit level without sacrificing type safety. It's good that you don't want to get stuck on the syntax, because from my experience, \*most\* people from languages that use C-like syntax just can't get past that, which is a real shame. This is especially true despite the fact that Ada allows the programmer to avoid many of the pitfalls that languages like C and C++ are notorious for. &amp;#x200B;
So I'm not an expert on this topic, but something I've appreciated most about my time with Ada 2012 / SPARK 2014 is all the avenues it provides you to ensure that your program is correct. Pre- and post-conditions, contract cases, type invariants, loop invariants, loop variants, annotations of global accesses, data dependencies, etc. You can write these all down and have the tools check them. This is all built on Ada's strong, strict typing system that allows you to specify valid ranges that a value of a certain type will fall under, and keeps you from assigning your Relative_Humidity to Temperature or other such things (although I believe Rust can do that one). So I've found all those features very useful for specifying how certain data transformations should go. You can just write down all the ways in which the input data could be bad, all the ways the output data can be bad, and then there's only so many valid ways to get from A to B. If your implementation could possibly be wrong then either the compiler or GNATprove will tell you, or you'll quickly get an assertion failure in testing which gives you a good hint as to the source of the bug. My two cents is that while Rust has a heavy design focus on ensuring memory safety, SPARK has a heavy design focus on ensuring program correctness, which (because I'm not an expert) I can only imagine is a huge asset to safety-critical designs. There's also the fact that "correct" programs usually aren't intended to segfault, so I sometimes feel that SPARK is addressing the cause, while Rust appears to be addressing the symptoms. 
Literally any Ada book, it’s all in the types, ranges, enums, etc and then there’s private types, Ada 2022 added predicates. 
Hi, you might find this article worth reading: [https://www.electronicdesign.com/embedded-revolution/assessing-ada-language-audio-applications](https://www.electronicdesign.com/embedded-revolution/assessing-ada-language-audio-applications) It's been posted on the Ada reddit group before. The author has examples where he found advantages to using various Ada features to model aspects of DSP processing, such as the ability to specify decimal types at a logical level (i.e. specify the value range of a numeric type and the desired precision that is needed).
&gt; Ada 2022 added predicates. Range violation! Ada could have saved you from that. ;-)
That's quite a lot of interesting features--are there any MCUs that are recommended for learning driver development in Ada? I have a bunch of 8bit AVR chips and a few STM32 ARM dev boards.
Hi, Then maybe these will be of interest to you: (1) "Make with Ada" competition, which has some info and links to do bare board development, especially on ARM based devices ( [https://www.makewithada.org/](https://www.makewithada.org/) ). Explore and you will find quite a bit of resources. It's interesting to see the projects that people have done in the past. (2) There is the "Ada and SPARK on ARM Cortex-M" tutorial ([www.inspirel.com/articles/Ada\_On\_Cortex.html](https://www.inspirel.com/articles/Ada_On_Cortex.html)). I've never tried it myself, but others have. The author hangs out on comp.lang.ada usenet group and has helped people with the tutorial. (3) Simon Wright is quite active with Ada development tool support for ARM Cortex targets( See [https://github.com/simonjwright/cortex-gnat-rts](https://github.com/simonjwright/cortex-gnat-rts)) . He also hangs out on comp.lang.ada (4) You can also try getting tips and help from people on the #ada IRC channel too. &amp;#x200B;
Proving aspects of a program to be absent of runtime exceptions is something in SPARK/Ada that would be more difficult in Rust. I wrote a post [on capturing invariants](https://bluishcoder.co.nz/2018/01/10/capturing-program-invariants-in-ats.html) in ATS comparing to SPARK. Thinking about how you might do that in Rust might provide some insight.
&gt;Ada 2022 2022?
Mobile
Hi, Unfortunately, the deadline for submission for Ada202x has already passed back in June. You can still send your ideas to the Ada Rapporteur Group via the Ada Comment mailing list http://www.ada-auth.org/comment.html, but the submissions won’t be considered until the next revision phase. (Note: I am not affiliated with the ARG). 
Thanks for the info!
Just out of interest, what kind of features?
Look [here](https://github.com/AdaCore/Ada_Drivers_Library/tree/master/boards) for AdaCore supported boards (compilers [here](https://www.adacore.com/community)). My Cortex GNAT RTS is aimed at people who don’t want the full GPL to apply to their programs.
Nothing big honestly. Ada 202x has parallel loops/blocks, so i wanted to suggest 2 things: 1) Currently, parallel loops/blocks are mostly about multithreading, but in practice most of the loops are not big enough to split into multiple threads, it's faster to do small loops with single thread. Compilers are smart enough to do this (and Ada rules allows it), but i think it's worthwhile to have an explicit hint to control this behavior. GNAT has Pragma Loop_Optimize, which is pretty much what i want. 2) [AOS and SOA](https://en.wikipedia.org/wiki/AOS_and_SOA) would work well with parallel loops/blocks. Let's say we add new aspect array_layout that only works with records. So something like this: type Vector3 is record x : real := 1.0; y : real := 4.0; z : real := 9.0; end record; type Vector3_SOA is new Vector3 with array_layout; V3 : Vector3; --- Memory will contain: 1 4 9 1 4 9 1 4 9 1 4 9 V3_SOA : Vector3_SOA; --- Memory will contain: 1 1 1 1 4 4 4 4 9 9 9 9 (this example is based on [Jal](https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md#data-oriented-structures)) Iterating on SOA variant is way faster because it has less cache misses. 
There’s no reason a compiler couldn’t do 1 with an extra aspect/pragma. I know about jai and soa/sos. This would require the compiler support those in representation clauses which again can be implemented as extra aspects. I’ve been considering 2 for a while.
After reading this, I can't tell if it's the format, or what I've been doing professionally is useful at all
This is the wrong subreddit for this
Wrong place. Here we're talking about Ada programming language ([https://en.wikipedia.org/wiki/Ada\_(programming\_language)](https://en.wikipedia.org/wiki/Ada_(programming_language)) )
Bit of shameless self promotion, but I've been working on a build tool and package manager ([https://github.com/Entomy/Ada-tools](https://github.com/Entomy/Ada-tools)). As of this writing, the packaging, install, and uninstall features are fine. There's no package server/repo *yet*.
In Ada you will generally never need to use access types (pointers). Most uses indicate a problem with the design. I don't know Rust, but my understanding is it requires extensive use of pointers, like most C-based languages. While it has features to make pointers safer, not using pointers is safer still.
This isn't relevant to the programming language at all. 
bingo
name of parameter/argument for your procedure/function
Paste the source.
Imagine yourself in class with this problem. You say to the teacher, "My program doesn’t work!" What’s the response? It’s going to be, "Show me!" Unless, of course, you have a telepathic teacher who can read your mind. But they’re thin on the ground.
u/PengyDesu, we really need to see the source to see what's going on; is it something like this: Procedure Initialize( a, b, c : out Integer; d : out Float ); Procedure Process ( a, b, c : in Integer; d : in Float ); --... Z, Y, X : Integer; W : Float; Begin Initialize( X, Y, Z, W ); Process ( X, Y, Z, W ); End; Are generics involved? Perhaps ones having in out parameters?
My guess is that the second procedure that is getting called has the parameters all set to "out", which means the compiler doesn't need to pass in the original values, which would lead to garbage being fed in: So taking your example, he probably has Procedure Initialize( a, b, c : out Integer; d : out Float ); Procedure Process ( a, b, c : out Integer; d : in Float ); If I'm right, then I can see why it would be confusing, because even though the parameters are being fed in via "out" they can still be read within the procedure. If I'm not mistaken, in Ada83 you could not read an "out" parameter, but Ada95 removed that restriction.
Incorrect subreddit. Not relevant
Pay attention to the subreddit you're posting in. /r/ada is for the Ada programming language, not cryptocurrencies.
Ok so I totally forgot to respond to this post, that was shockingly my problem to the T. What I ended up doing to fix it was making an in parameter equal to my out parameter the moment my procedures began so they would have the values that I needed instead of being fed to garbage if that makes any sense. My professor is prohibiting the use of in out parameters in all our assignments so I just make one in and another out param and make my out param equal the in at the start. 
If your Sample record already has over 1000 components (A, B, D, ...) its declaration probably already requires more than 1000 lines, and your program must certainly have multiple 1000s of lines to assign and use those components. Adding another 1000 lines of "if" statements does not seem a huge overhead. That said, I would replace the 1000 components with a map container, keyed by String, and providing the value of the component named by the key String. If you also need immediate access to individual component values, without looking up a key in the map, these components could be defined as Cursors into the map, which are set once to point at that map element, and thereafter only used to read or write the value of the element/component.
A variant approach is to define the components of Sample as aliased and use a map of String keys to access values pointing at the components. That would be a minimal change to the structure of the Sample record, allowing immediate access (Sample.A) while also allowing String-keyed access (using the key "A" to index the map and get an access to Sample.A).
Thanks. I'll give this a try and update with you again
This subreddit is about the programming language Ada that has nothing to do with the ADA crypto currency.
Sounds like your professor is a doofus. But perhaps they have a reason.
Judging by the way you're calling it from the command line, you're passing the arguments via stdin. The way you've set it up in GPS is that you're supplying the filename as an *argument* to the program--so it's still waiting on stdin for its inputs. If you want to retain the flexibility of providing inputs either via stdin *or* by file, I'd have the start of the program check for arguments: if Ada.Command_Line.Argument_Count &gt; 0 then -- Open the file (and do any kind of error checking you want, or just -- assume you'll always call it correctly :-) Open(Input_File, In_File, Ada.Command_Line.Argument(1)); And then set using that file as input: Ada.Text_IO.Set_Input(Input_File); At the end of the program you ought to close the file if your inputs came from a file argument. 
The execution path `C:\AdaProject\obj\program input.txt` doesn’t look right; (a) I presume that’s actually `inputfile.txt`; (b) where’s the `&lt;`? I don’t know whether GPS would let you set `%E &lt;inputfile.txt` as the argument field. Also, are you sure you don’t need to specify a path for `inputfile.txt`? that is, are you in the right directory?
Requires degree over proven experience. That's like programming in a specific theoretical approach instead of proving the code works. Pass.
It's a requirement stipulated by the Federal government. Send us your resume anyway. Never know if a waiver can be granted. 
I am currently working on an excel-reader based upon Gautier de Montmollin's zip-ada. I will upload the code to a github repository during this weekend.
No, it is for eXtented Native Ada Library. Thanks for the pointer I didn't know about it, it's funny.
Do they need more devs? Asking for a friend...
We have open Ada positions in Huntsville, AL. PM me (or have your friend do so :-)
[removed]
This doesn't sound great: "For example, the median fully-loaded labor cost for engineers using Ada was ten percent less than those using C and twenty percent less than those using Java ($85,000 versus $95,000 and $105,000, respectively)."
As you need security clearance, I guess that it's American citizens only. I think it's good to tell it :) But would NATO clearance be ok ?
are you flying people out for the interview process?
We'd likely start with a remote phone screen and then if there is interest on both sides, fly people in. At times I have made offers only based on the remote interview as well.
I like it that the code avoids usage of use-statements and instead prefers use all type. It took GNATProve in GNAT Community Edition 2018 around 33 seconds on my computer to analyze all the source code and not any error detected (that GNATProve can detect!). There were some warnings like "lsc-bignum.adb:66:04: warning: no check message justified by this pragma". It may be possible to silence these warnings by removing the annotations.
There were some places "pragma Warnings (Off, "no Global contract");" and these pragmas can be removed by wrapping packages in the standard library inside packages that have the contracts GNATProve expects like for example I have done in the Aida.Text\_IO package that can be found at: [https://github.com/joakim-strandberg/aida\_2012/blob/master/src/aida-text\_io.ads](https://github.com/joakim-strandberg/aida_2012/blob/master/src/aida-text_io.ads)
Lately I've started enabling the "-gnaty" compiler flag to make the code follow the same coding convention that can be found in the implementation of the GNAT compiler standard library. For example the maximum number of characters on each line of code is 80 characters. The code in the STOTP repository almost follows the coding convention. I know it's a matter of personal taste but I was happily surprised to see that!
I was hating `use` already from C++ so I won't start using it in Ada ;) The prove is a bit tricky. It usually proves faster if you use a higher level (contrary to what the help says) since the correct proofs are found faster. I made the experience that with level=0 it sometimes doesn't prove completely since the timeout triggers to fast, but with level=2 it succeeds always. I checked out your Aida library and I find it interesting, I'll keep an eye on it. Although I won't use it in STOTP since all Text_Io uses are in examples and tests.
Since I already worked on a custom [Ada runtime](https://github.com/Componolit/ada-runtime) and runtime files are required to follow this style I mostly adapted it. Yet when I see the output of `-gnaty` there is still room for improvement.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/olzd] [SPARK by Example, message from Christophe Garion on the SPARK mailing list](https://www.reddit.com/r/olzd/comments/9rub94/spark_by_example_message_from_christophe_garion/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thank you very much! The Ada community really needs more resources like this!
I'd love to apply, but my current position/organization would be left in a lurch if I did. On the other hand, there might be some interesting Ada work here -- I'd love to be able to say with a bit more certainty though.
Awesome! I'll have to check the source out.
Slightly click-baity headline. It wasn't so much the code that caused the failure, but the incorrect specification being given to the programmers.
I would think you create a shared library in Ada. [https://gnu.huihoo.org/gcc/gcc-3.3.6/gnat\_ug\_unx/Creating-an-Ada-Library-to-be-Used-in-a-Non\_002dAda-Context.html](https://gnu.huihoo.org/gcc/gcc-3.3.6/gnat_ug_unx/Creating-an-Ada-Library-to-be-Used-in-a-Non_002dAda-Context.html)
&gt; Effect: &gt; 37 seconds after the rocket was fired (30 seconds after the liftoff) at 3700 m altitude Ariane 5 reached a horizontal speed of 32768.0 (internal units). This value was about five times higher than Ariane 4. &gt; &gt; The conversion to an integer therefore resulted in an overflow, which was not intercepted. &gt; &gt; The replacement computer (redundancy!) Had the same problem already 72 msec before and switched off immediately. As a result, diagnostic data was sent to the main computer, which interpreted it as trajectory data. &gt; &gt; Thereupon nonsense commands were sent to the lateral thrusters, and later also to the main engine, to correct the large flight deviations (over 20 degrees). However, the rocket threatened to break apart and burst itself (39 sec). &gt; &gt; An intensive test of the navigation and main computer was not undertaken because the software was tested on Ariane 4. &gt; Tragedy: &gt; The problematic part of the program was only needed for the preparation at the start and the start itself. &gt; &gt; It should only be active during a transitional period, for security reasons: 50 sec, until the ground station had taken control of a start interruption. Despite the very different behavior of the Ariane 5, this value has not been reconsidered. &gt; Optimization: &gt; Only 3 out of 7 variables were overflow tested - for the other 4 variables there was evidence that the values ​​would remain small enough (Ariane 4). &gt; &gt; However, this evidence was not for the Ariane 5 and were not reexamined. Problem of reusing software! &gt; &gt; Unbelievable - after 40 years of software error findings: &gt; It was assumed in the program design that only hardware errors can occur! &gt; &gt; Therefore, the replacement computer had the same software. The system specification stipulated that the computer should shut down in the event of an error and the replacement computer should intervene. A restart of a computer did not make sense, because the redetermination of the altitude is too expensive. 
...and given the first Ada was from Ada83 there would have been very little experience with actual use...
My first contact was hearing a brief talk about Ada, in the very early 1980's, and completely failing to understand the meaning of "type Counter is new Integer". Coming from an Algol/Fortran environment, I was totally mystified by the concept of "a new Integer". My first actual use was of DEC Ada, on both large and small VAXes, for both desk-top applications and embedded real-time systems. Love at second sight :-)
When I started my with my current job 3 years ago writing aircraft software
Fresh out of college in 1983 I was assigned to work on a VHDL compiler (VHDL is a hardware design language based on the then new Ada language) that ran on Sperry 1100 mainframes. The compiler was written in Pascal, but we used the Ada reference manual as the guide to implementing the "Ada features" of the language. Specifically, I did "overload resolution" semantic analysis--given the syntax tree and symbol table, I had to identify exactly which of potentially identically named operators and functions were being invoked in an expression. My first actual *Ada programming* task followed that compiler project, where we were developing a software simulation of the Navy's AN/UYK-43 computers's instruction set architecture (the purpose was to collect performance data and evaluate alternative architectures). We were using the Telesoft Ada compiler running on DEC VAXen. That compiler was a flaming garbage dump. Bugs up the wazoo, slow, unstable, missing features like rep specs and pragmas. My manager managed to wrangle a beta version of the DEC Ada compiler for our VAXes (we weren't allowed to tell anybody outside of our project we had it; if asked, we had to say we were using "Compiler X"). Compiler X was a joy to work with, solid, reliable, fast (for early Ada compilers), with a solid software development support environment. We only ever encountered one bug with it--one bug in a *beta* version of a compiler. This was the project where I first really sank my teeth into Ada, and have leveraged off that experience now for an entire 35+ year career.
While this article doesn't directly answer your question, it seems to highlight some of their key similarities and differences: https://www.electronicdesign.com/industrial/rust-and-spark-software-reliability-everyone When I first started comparing the two languages, I found it quite informative.
No. Read the provided material. Do a basic google search for Ada references and do your own homework.
I wasnt asking if someone could do the exercise for me, i was asking how to get values inside of an array inside of an record, the anwser is for i in 1..5 loop Av:=B("student number").note(I)+Av; End loop Av:=Av/5 
Here is my wild guess without seeing your data. Av := B(i).note + Av;
You should have asked that question, then. And, read the 'formatting help' just below the bottom right of the text entry box. (I think you could even go back and edit the post, to save future readers the pain)
When I first started using Ada I found the syntax tricky. There weren't good examples and explanations of the syntax; also the terminology was very different, so finding out how to ask for what you want is difficult. I don't want to do your homework for you, but I understand the troubles. I didn't fully understand the question, but this should be sufficiently similar to what you need to point you in the right direction. http://tpcg.io/Ez12JF 
I am surprised. I seem to be the first to post here. I am excited about the Make with Ada contest! This is the first year that I intend to participate. I am working on a project now (after many other projects) that I think will be at least useful to others. Since my projects are mostly useful to me and are for my convenience, I can't say from experience what of my projects others find useful, but in my spare time, I am trying to make this project usable by February... Good luck to everyone! Your projects of the past were amazing!
?? Why didn't you implement the compiler in Ada? After the initial bootstrapping in Pascal, you can throw the Pascal away.
Did you catch the year? 1983? :-) While a couple "compilers" had been validated, there was *nothing* approaching a production-quality Ada compiler in existence at that time.
I caught the year. It would seem that you are not familiar with compiler design. It is common practice to write compiler for a computer language using the language itself. This of course requires the use of a bootstrap compiler written in another language, but only initially.
I'm going to be charitable here and assume something about my initial post was misunderstood. We were writing a *VHDL* compiler, i.e. a compiler for the [VHDL] (https://en.wikipedia.org/wiki/VHDL) language. VHDL is a hardware design language, it is not a general purpose programming language. The VHDL language specification was *based on* Ada, meaning hardware-domain language constructs were added, and Ada features that contributed little or nothing to the purpose of hardware design were removed. At the time of this project, there were *no* production quality Ada compilers, therefore the VHDL compiler could not be written in Ada. The decision (made prior to my joining Sperry) was thus made to write it in Pascal. While it is possible that the contracting agency could've requested that the VHDL compiler subsequently be rewritten in Ada once production-quality Ada compilers were available, no such request was ever made. (And writing a production VHDL compiler in a *hardware design* language such as VHDL would just be...absurd.) Contrary to what it seems, I do have *some* experience with compiler design. Commencing with writing a compiler as a college course assignment (and wherein bootstrapping was part of the course syllabus), then working quite closely with the GNAT Ada compiler since its first release in the mid-1990s, resulting in over two decades of periodically delving into the compiler and library source code, supplying AdaCore with bug reports, suggested fixes, and enhancement requests and candidate implementations.
No need to be charitable. The part that you struck out made it seem like you were developing an Ada compiler, is all. Seemed odd that it would be written in Pascal.
I watched videotapes of Ichbiah, Barnes, and Firth presenting a tutorial of their newly christened Ada language (previously called Green) at the Ada Launch (1980 Dec 10--this was Ada 80). Barne's presentation of a discrete-set package was the 1st time I really understood information hiding, so it marked my transition from a coder to a software engineer.
My vote is no don’t add the aliased or volatile unless you actually need them for your application. You’re already doing something you shouldn’t by doing the overlay so why clutter the code if you don’t need to. 
wrong subreddit, this one is about the computer programming language Ada
wrong subreddit, this one is about the computer programming language Ada
One reason for `for A’Address use` might be that `Unchecked_Conversion` can (and in GNAT does) make a copy; so if you have a large object which, for instance, you want to treat as a `Stream_Element_Array` so as to calculate its CRC32, you can easily break the stack, especially on an MCU.
Found a link to an "old" version fo the GNAT reference manual: [https://www.cs.fsu.edu/\~baker/ada/gnat/html/gnat\_rm\_7.html](https://www.cs.fsu.edu/~baker/ada/gnat/html/gnat_rm_7.html) Paraphrased: The use of address clauses to overlay variables, achieving an effect similar to unchecked conversion was erroneous in Ada 83, but in Ada 95 the effect is implementation defined. Furthermore, the Ada 95 RM recommends the following implementation RM 13.3(19)): If the Address of an object is specified, or it is imported or exported, then the implementation should not perform optimizations based on assumptions of no aliases. GNAT follows this recommendation, and goes further by also applying this recommendation to the overlaid variable. This means that the overlay works "as expected", in that a modification to one of the variables will affect the value of the other. &amp;#x200B; It indicates it isn't necessary to specify neither aliased nor Volatile on the variables A or B which I find quite surprising because the GNAT compiler is strict with using 'Access on a variable on the stack requires the variable to be aliased, but specifying an address clause indicates that both variables are considered aliased by the compiler according to the GNAT reference manual in the link above.
The binding is complete in the sense that all C-functions are exposed in the public API of the thick Ada binding. The binding is of course memory safe and implements RAII using limited controlled types under the hood. Suggestions for improvements are welcome.
Finally updated the excel reader code: [https://github.com/joakim-strandberg/excel\_file\_reader](https://github.com/joakim-strandberg/excel_file_reader) Wasn't happy with uploading it because the code isn't packaged well for re-use, but will be useful for anyone wanting to read excel files!
Thanks Joakim, This sounds interesting but I actually don't know for can you use it for, do you some examples? Also the repo is called wayland_ada_binding, what is the relation between libudev and wayland?
\&gt; Do you know some examples? The benefit I see is being able to detect if the user inserts/removes a USB device to the computer (maybe one's Ada application should automatically do something when this happens for example maybe one has developed an external embedded system and the Ada application on the desktop should automatically try to communicate with the embedded system if one connects it to the computer with a cable). Imagine one's Ada application talks to other applications over a network, it is possible to detect if the user removes the network cable from the computer which means the application can close the sockets and try opening the sockets again later when the network cable has been inserted again. In order for a Linux application to detect such events libudev is what the application needs to use. Udev is an abbreviation for "Userspace /dev". All the devices can be found in the /dev directory and the udev daemon that represents all the devices as files/nodes in the /dev directory does not run in kernel space but in userspace for stability reasons. \&gt; Relationship between libudev and wayland? What the Udev Ada binding and Wayland Ada binding has in common is dependency upon an Ada binding to Linux, and the Ada binding to Linux has a dependency upon the a package called C\_Binding which contains code that is common to C bindings. Preferably I would like to put the C binding code in its own repository (but it's just a few lines of code!), the Ada binding to Linux in its own repository and put the udev and wayland Ada bindings in their own repositories. I imagine one can use submodules for this purpose. The drawback with submodules is lack of support for transitive dependencies (as I understand it). I want to be sure that common repositories that several submodules share is just downloaded once. The same repository should not be downloaded several times for each submodule and recompiled many times! Maybe it is possible to make this possible using submodules but I haven't investigated this enough. And all things considered, it's not a lot of code in the Wayland repository so I have just put all Linux Ada bindings there.
I’d heard of Ada but never really took the time to read up about it. This article made me sit up and take notice (as a side project, I’ve been writing a chess engine in C and recently started to try Rust). I was blown away by the performance benchmarks (https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/ada.html). I’m surprised but Ada seems to be a forgotten gem in the programming language landscape. Going to get it set up on my laptop over the weekend and give it a try. 
Indeed it is kind of surprising! Personally I think Ada was a bit hampered by it's unfair attribution to hard-real-time ans safety critical applications. In fact, it is one of the strongest (in my opinion the strongest) \_general-purpose\_ languages out there. It is highly orthogonal and meticulously engineered. Most of its features, especially its safety features, are usually found in so-called "managed" languages with all the inefficiency that come with those, yet Ada is a compiled language. &amp;#x200B; One often overlooked thing that I think Rust potential fails at that Ada succeeds at is that Rust doesn't have a strong foundation in discipline and practical use. If you invest in Rust now, you really have to worry about braking changes in the near future. With Ada, not only does it have 30 years of refinement behind it, it has a very rigorous standardization process behind it. 
&gt; If you invest in Rust now, you really have to worry about braking changes in the near future. Agreed. Personally, i think Rust still has a lot if maturing to do. I’ve dabbled with it in side projects but they’ve yet to commit to a kind of “long term support” release that stays stable for an extended period withoit breakage. 
The performance comparison between Ada and C in this article is misleading. The late Robert Dewar, one of the founders of AdaCore, had a set of equivalent Ada and C programs that produced identical machine code when compiled with gcc. The "catch" is in the definition of "equivalent". Most real-world software requires run-time checks to be correct; buffer-overflow vulnerabilities (which are impossible in Ada) are a common example of incorrectness due to missing run-time checks. Ada automatically includes the necessary checks for correctness, but most C code doesn't include them, so such performance comparisons compare apples to oranges. When comparing code that includes the necessary checks in both languages, Ada is about as fast as C.
I've noted that almost all Rust programmers never even acknowledge that Ada exists. 
Well, I suspect a lot of programmers under 30 and those don't work in the aerospace/defense software development industry have never heard of Ada.
I'd make a solid bet that at least 50% of Rust programmers who knew about Ada wouldn't be Rust programmers.
Welp, from my experience in teaching Ada to 19-year old university students, they really love it!
One problem with these Rust programmers is that even if they hear about Ada, start listing the things Rust has which Ada, apparently, doesn't. Like arenas, which from what I gather are the same as Are pools. The only thing that Ada doesn't have is the pointer move semantics and borrow checker, AFAIK there isn't anything else missing from Ada. Ada isn't a functional language so I'm not counting those features. 
Hi, do you think you can share a little more info about your experience teaching Ada? Would be interesting to read.
I am a professional Ada developer 1 year out of university. Ada is still used fairly often in military applications. I work at General Dynamics Canada in Ottawa where I'd say about half of the projects I've seen are Ada based. Other defense contractors will also likely have some Ada codebases. The nice thing about Ada is that it is very easy to interoperate with other languages, especially C/C++. So even though a codebase may have a lot of low-level code in C, the business logic can often still be in Ada. It is also worth noting that very rarely do companies list that they are looking for Ada developers, typically they post that they are looking for C++ or Java developers since if you know either of them you can pick up Ada pretty easily. Meanwhile I use Ada for my personal projects and find that it serves me well.
There are jobs out there. I'm hiring Ada software engineers right now - though we tend to have a mix of Ada, C++, Python, C# and C. Might be able to work in a summer internship if you are open to NH or AL.
Thank you, this really is good insight, I’m quite comfortable with java but haven’t started coding in C yet but will be taking a class taught using C next semester. I also plan on learning python at some point as well. 
You can do web apps with FastCGI, see Matreshka. Stefan Carrie does a lot of Java ports and a web framework. Like any application, Ada is great with respect to its data modelling capabilities and get your logic right and there’s less debugging time.
Sorry, but interoperability with C++ is painful as the C++ API is not standardised, also GNAT doesn’t handle it well, there are bugs which cause it to be unusable, iirc destructors don’t get called. C otoh is fine.
NH? What company?
Ada is a great language but unfortunately jobs may be in areas and locales you might not be interested in.
Lambdabeta, you are one of the lucky ones. Some defense companies have no problem using it while some shun it. Both the company I worked for previously and the current one are quite unfriendly to the idea of using Ada. At my current company Ada usage is not high and sometimes discouraged, despite having some large legacy code bases written in it. PengyDesu, even if you can't find a job that uses Ada, the positive influence it has on your software development skills and mentality can help you develop robust and working software even when using more inferior languages, such as C. Yes, this is based on my own personal experience.
I'm not a web developer, but you can't ignore the fact that there will be far more libraries you can use in other languages such as Swift, simply because they have a larger user base. Still, some people have mentioned in various places, such as comp.lang.ada, that they had very positive experiences using the Ada Web Server ([https://github.com/AdaCore/aws](https://github.com/AdaCore/aws) ) library to produce web front ends for their programs. Lucretia9 did mention that Stefan has been working a lot on making Ada web development more possible (see [https://github.com/stcarrez/ada-awa/wiki/Ada-Web-Application](https://github.com/stcarrez/ada-awa/wiki/Ada-Web-Application) ). There is also Gnoga ([https://sourceforge.net/p/gnoga/wiki/Gnoga-Home/](https://sourceforge.net/p/gnoga/wiki/Gnoga-Home/) )
Was on mobile so couldn't be bothered with links, added them now.
Thank you both Lucretia9 and micronian2. I’ll go with Ada for my next web project.
We have several opportunities for Ada developers here in Huntsville, Alabama (the "Rocket City"). PM for info.
I also work with Ada professionally in the defense sector and just want to add some more information. In recent years, my company has been shifting more and more towards C/C++. Ada is still a huge player, but it is never used when we write a new application. 
BAE Systems
I've experienced this in some teams at my company too. The issue is partly because when you use 'less popular' technologies, you risk losing your work force as they fear their skills becoming obsolete. Luckily AdaCore helps to keep Ada relevant, and it is still in the top 50 on the TIOBE index, at least for now.
Anyone knows what's the current yearly subscription price for GNAT Pro Developer?
1. Programming experience of students Two out of three were in a Computer Engineering course, 1 was in mainstream CS. One was first year and overall new to programming in general, one had solid C foundations, and was getting into C++, the CS student was more biased to Python, but was also quite fluent in C, C++, and Java. &amp;#x200B; 2. How long was Ada course and what was it about? It wasn't a course, as I am not a professor. I hired them as student interns over the summer. In the end, I had them implement some nice UUID generation and some generic hashing packages which I will open-source with a FreeBSD license in the very near future &amp;#x200B; 3. What were initial reactions to introduction of Ada? They were surprised that it wasn't being taught. My passion for Ada can be very infectious, so I don't really know anyone who hasn't spent more than 10 minutes talking to me about Ada without feeling that it is something that needs to be used more, and more broadly. Even non-technical people are generally surprised to learn that such a technology exists, and can't see why it isn't more popular. They all found it to be coherent and very powerful. The CS student was especially appreciative of never having a segfault. I present it from the position of software engineering, where it is about thinking things through carefully and deliberately, not rushing through to some kind of immediate gratification. Ada excels at this unlike any other language that is even slightly popular, or any that I know of at all. One thing that they were particularly affectionate for was the tasking model. &amp;#x200B; 4. What sort of resistance, if any, did you see from students? Literally none. They really loved Ada. As long as all the whys are explained to them, they saw the value in doing things properly (for once). If they understand \*why\* some rules are how they are, and why it is good, they appreciate it. I tend to focus on the data modeling strengths, and they were very quick to understand how superior Ada is in this regard. So much so that they definitely found going back to C-family languages to be painful. &amp;#x200B; 5. When did the students finally accept Ada? Immediately. I get the feeling that the younger people are actually yearning for something as structured, reliable, and othagonal as Ada. The truth is, the only people I know that enjoyed debugging were from the old-school pre-internet days. &amp;#x200B; 6. What were some challenges that you faced (e.g. tool issues, preconceived perceptions of Ada, etc) ? Tool issues are overstated. I've bootstrapped FSF GNAT on Linux, FreeBSD, Solaris (illumos), and even armv6 on a beagleboard running FreeBSD. Ubuntu has FSF GNAT available as a mainline package. &amp;#x200B; 7. How did your experience compare to that of the well known railroad school project ? ( see [www.sigada.org/conf/sigada99/Keynoters/McCormick.ppt](https://www.sigada.org/conf/sigada99/Keynoters/McCormick.ppt) and [http://archive.adaic.com/projects/atwork/trains.html](http://archive.adaic.com/projects/atwork/trains.html)) I'd say very little comparison. We were focused on very practical problems in the cloud-based distributed systems domain. This is my focus, as a company. As beginners, they really cut their teeth on some very nice UUID generation and hash algorithms. I really wanted to get them to work on something simple but useful to start. I still give them work when they are free, and they all really want to keep working with Ada. In fact, they themselves expressed their intention to try, where possible, to use Ada in their actual school projects. I of course encourage them to do so and to talk to their profs. &amp;#x200B; Any plans to continue teaching Ada? Absolutely. I am trying to think of how I can reach more people, I definitely would rather focus on the younger generations, as I think they are actually more receptive to Ada. Strangely enough, it seems that the most resistance I have seen against Ada has come from the 40+ crowd. &amp;#x200B; What does the school's faculty think about your successful experience teaching Ada? Like I said - not a school. However, if I ever have to stop using Ada for what I do, I will change careers. Period.
Ada is absolutely excellent for building APIs of any sort. I know that because it is largely what I do. We've got a few APIs now that were deployed after about 1 week of testing that have never had a single bug or failure in about 2 years now. Unlike building it in node or PHP, it is fully compiled which means it is fast as hell. I was able to overwhelm the FreeBSD network stack before the API got above 25% CPU usage. FreeBSD powers netflix, so that tells you something. The issue is lack of packages for doing this kind of thing. We are currently re-engineering out TCP, HTTP, and JSON packages, which, once done will be open sourced on a BSD license. Unfortunately, there are limited resources for this right now, so I can't give a firm timeline on that. We are committed to open-sourcing as much as possible, and so there should be, one day soon, a steady stream of stuff from us. BSD license means people can use it for whatever they want, including in proprietary software. Hopefully we can do our part to make Ada a more attractive choice for cloud-based software, as it is an excellent choice. P.S. Watch out for the upcoming Ada 2020 standard, which is going to have some amazing new features which will make it even more useful for big-data.
I don't mean to derail you here, but I'd definitely recommend targeting json backends for react-based web frameworks. You can build the UI in React, and drive it from the API in Ada over JSON. This is more modern than FastCGI. WebSockets are another, less common route.
Is there any reason they wholesale abandon Ada for new projects? That seems kind of silly. I'd expect that some lessons would have been learned from the JSF project. I really would hate to hear this "we can't find Ada programmers", since that is simply a weak cop-out, and demonstrably false - any good programmer can learn Ada in a matter of days. When you compare those days lost to the amount of time saved by having less debugging, less failure, less testing, and easier maintenance, I don't see how any half-competent manager would want to chose Ada.
I personally think you will see more growth in Ada use in the mainstream commercial sector. The defense industry has had a bone to pick with Ada since it was forced on them in the 80s. Despite it being clearly superior to any other mainstream language in their domain, I have seen almost all hate for Ada come from the defense space. I'm in the commercial space, Ada is under-used simply because it is not well known, yet. I think it is the perfect time for Ada, since no one cared about reliable software in the mainstream until the last 5 ish years. Money talks. Ada use is a competitive advantage. I know this from experience. I can make changes faster than I could with any other language or framework. I can bring new people into a project and have them understand it almost immediately. Compare that with some C# projects I've worked on, where it would take months for a new guy to get a grip on the code base, and every single change caused at least 4 unexpected problems to appear.
I'm not certain. I can guess and say that it's a hiring issue. Not that Ada programmers are hard to find. After all, you said its an easy language to learn, and I agree. No, I think the problem stems from hiring non-CS engineers to do CS work whom don't have the passion to learn. In the end, this means we have fewer competent Ada developers and to incentive to learn. Another factor I'd consider is the quality of resources available for Ada vs C. There is no shortage of libraries, guides, or tools for C. Trying to find quick help for Ada, though, is like trying to find a hot dog at a bratwurst festival.
Wow, thanks for answering all the questions in detail. It’s really encouraging to read how positive it went. Unfortuantely, I haven’t had as much luck convincing the newer hires to try Ada, though they are a little more willing to hear about it. I think in your case part of the reason you had a better result is because they actually had to use it and you were a good mentor to them. 
I completely agree with you on this. It’s an excuse that is too often played, especially by managers, despite the fact that there are plenty of cases where engineers have to learn a new tool all the time (e.g. having to learn a new SCM tool, learning how to use static analyzers, learning a new development process, etc). I was on a project where my request to write in Ada was rejected because of concern about no one having experience with it. Yet, on the same project they let a developer write a lot of Perl code and when time came to code review, no one on the team had experience with that language, but was still expected to review. 
Yes, when you need to use third party components, it’s harder to convince people, even despite the fact that Ada can still interface with them. Most of the time I have been on projects where you write almost everything from scratch, yet people still resist the idea of using Ada in those cases. 
Very interesting! I totally agree on your last point.. I hope I can help do something about this eventually.
That's brutal. I hope you are still pushing management though! Maybe one day you can break through :P. I can't imagine that Pearl is more prevalent than Ada.
Thanks for anwering. Do you consider AWS sufficient for a web API or a framework is desirable?
Honestly I haven't used AWS, but I have heard good things. I definitely expect that it will have everything you need to set-up an API.
I tried to make this article as comprehensive and readable as possible for the general public and the uninitiated. I know that it is fairly simplistic, but I believe the message is salient.
[removed]
That was a good read. I look forward to future posts. I might want to submit some of the ones I've come across too if you wouldn't mind. Thanks!
Thanks! I would very much love that!
You mentioned ' a perceived excess verbosity ' and previously I had the same opinion (I'm not Ada programmer). But today exactly this feature of Ada attracted me: Ada sources are absolutely readable and understandable without to know language at whole. And today this looks for me as the best feature of the language: I don't need IDE to understand language, even 'end Something' syntax is very helpful - I don't need to back to the page to see what is the block here: "end" shows me what was the block. Source code in Ada looks like literature programming example of D. Knuth.
This is really an important point. I don't think anyone can argue that software is written more than it is read. It seems amazingly silly that so many languages, including new ones like Rust, continue to ignore readability. Further still, the popularity of open source makes readability even more important!
That is what really bothers me with languages like Rust. It took me ages to be fluent in C++ and there are still constructs I have to look up what they do when seeing them (if I even know what to look up). And learning Rust sometimes seems to require to learn all special characters first to understand even simple code. When I started Ada I can't remember another language that was so easy to learn and understand. Also what do you gain when you write e.g. `thrd` instead of `thread`? It's far less time than you need to invest to reunderstand your own code again. I usually tend to write compact packed statements that are often hard to comprehend in other languages and the verbosity of Ada makes it so easy to write well readable and well structured code that can be understood easily after a long time.
There is probably not enough demand to prevent it from happening. It was probably enough to make it flexible enough. I would imagine you could also make a subtype of range 1..1. No real reason to do it, just no reason to prevent it. 
Great article. Please keep bringing more attention to the language. Perhaps Ada will then climb a positon in the TIOBEE next year.
Booleans are enumerations, you can do this with any enumeration.
...and ```fn``` or ```fun``` over ```function```?? But with autocompletion, long identifiers in Ada wouldn't be a problem.
[removed]
[removed]
and yet, these C/C++/Rust/etc. people have said to me in comments in various places that they think Ada is hard to read, like, can you read English????
[removed]
I think this is more about orthogonality than anything. All types have some kind of "range" (T'Base), which can be constrained with a subtype. The use-case is really up to the programmer. There is no reason that Boolean should be any different. This orthogonality is one of the greatest strengths of Ada. You're right it isn't very useful, but that's not really the point. Ada doesn't force you to make such types, and there is nothing wrong with them. Also what you described is not an error. The subtype declaration is correct, and the Constraint\_Error is correct. Nothing about this set-up is dangerous, or could cause erroneous execution of any kind.
It seems like readability and documentation are the last concern of the current mindset. Recently, at r/rust there was a discussion on adding named arguments and I was utterly surprised to see the amount of push-back. I mean it is such a clear-cut clarity improvement, but no-no: too much sugar; the type system should handle it; the IDE will do it. It is so weird that clarity – even at the cost of slight redundancy – is so frowned upon. Thankfully Rust has the RFC process so there is a chance that reason prevails over custom. Thread: https://www.reddit.com/r/rust/comments/a4y73y/my_wish_for_rust_2019_named_argument_syntax/
Here's a sneak peek of /r/rust using the [top posts](https://np.reddit.com/r/rust/top/?sort=top&amp;t=year) of the year! \#1: [Reddit is hiring a Senior Rust Engineer](https://np.reddit.com/r/rust/comments/7utj4t/reddit_is_hiring_a_senior_rust_engineer/) \#2: [Auditing popular crates: how a one-line unsafe has nearly ruined everything](https://np.reddit.com/r/rust/comments/8zpp5f/auditing_popular_crates_how_a_oneline_unsafe_has/) \#3: [Announcing Rust 1.26](https://blog.rust-lang.org/2018/05/10/Rust-1.26.html) | [226 comments](https://np.reddit.com/r/rust/comments/8igirv/announcing_rust_126/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
As someone who’s first 2 semesters programming class for a Aviation CompSci degree was Ada, this gives me hope. Currently working at a big Defense Contractor, and all the new hires want to do is C++. Management seems to be bending to their will maybe? 
Well, to be fair, borrow checker is Rust selling point.
and that is all the language really offers.
Wow, I'm getting far too honored these days! [u/Fabien\_C](https://www.reddit.com/user/Fabien_C) just cross-posted my blog to r/Programming, and that's been quite an experience so far! &amp;#x200B; Thanks for posting this, I hope it is encouraging. I am trying to get more grass-roots interest in Ada, and I honestly found it quite surprising how much the students enjoyed learning and working in Ada. I have always felt the resistance to Ada to be very off-putting and illogical. It seems to me to be overstated. I'm not sure why, but some in the community seem to be extra vocal about criticizing the adoption of Ada. From my experience "on the ground", I feel like most programmers, and especially students, are very responsive and welcoming to the structure and robustness of Ada.
I really think we just need more proponents willing to speak up and make the suggestion. I've pitched Ada to plenty of management people, and if you hit the right points they tend to become very interested. The key points to hammer home are: 1. Ada is serious business - 1. Ada was specifically and carefully designed to write huge critical applications that need to run for decades. 2. Started with 3 year peer-reviewed effort to create a requirements document before language design started - this was never done before, and has never been done again. 3. General purpose - not only designed for missiles, designed for anything, including large distributed systems like ATC and mission management. 4. High performance - compiled, unlike Java, and Python, means it is very performant. 2. Ada is proven 1. Ada has been around for over 30 years - \*and has been consistently updated the whole time\* 2. Ada has been selected and validated with a large number of very important projects 1. Boeing 777, 787 2. F-22, EuroFighter, NEURON 3. NextGen ATC, NavCanada ATC, NATS ATC, EuroControl ATC 4. ISS Environment control module 5. Canadarm 3. CubeSat - the only one to survive until reentry was the only one written in Ada 3. Ada reduces risk 1. Invest time upfront to get it right from the start - when the schedule is most flexible 2. Ada finds the vast majority of bugs in the very beginning 3. Testing is dramatically reduced and more predictable 4. Ada programs tend to have exceptionally low failure rates after deployment 5. Readability is prioritized - meaning new team members can get up to speed quickly 6. \* Maintainability is prioritized by the original language spec - the software is agile. Changes are easier to make, and are very unlike to cause unexpected side-effects\*. 4. Ada is public domain 1. No one owns Ada. 2. ISO standard - freely available - even more free than C++ (standard is not free to download) 3. Well maintained compilers readily available 1. FSF GNAT part of GCC - the most widely used, open source compiler suite that exists 2. Don't worry about "what happens in 10 years", GCC is not going anywhere, and it is forkable. 5. Ada is easy to learn 1. Any competent programmer can learn Ada easily - don't need to hire "Ada programmers" 1. I insert anecdotal stories as I mentioned in OP's post. 2. Most programmers can begin maintaining Ada code after a week or less 3. Ada is highly regular, and has less exceptional rules than other popular languages - "Once you get it, you got it". Of course I would optimize this depending on who you're pitching to. But trust me, these points will get interest from management. They are not usually interested in technical aspects. They don't care about "strong typing" or "programming by contract".
It's not only Rust, D doesn't have named arguments ether. You can find threads where people ask for named arguments and general response is that it's just syntactic sugar, useless etc.
Good read. I liked how you don't try to improve either the original or Ada code, but to replicate what originally happened with whatever code was written.
This is really an excellent summary for pitching the language, thanks
Thanks! I really hope this is helpful and that more managers can be convinced to use Ada for the next project!
Can only agree with you! Seems like Rust isn’t designed to be maintained. 
I think that is a rather harsh phrasing. 
Would you add RSS support to your blog?
We will be sure to make that happen!
&gt;I fail to see the usefulness of a variable that can only ever contain one value...yet Ada is perfectly alright letting you do such a thing, without so much as a warning. Why does Ada allow this? It's a natural consequence of the subtyping \[restriction\] -- and the reason it's allowed is because you can say something like `Options : Array(1..Option_Count) of Option;` ... `For Index in Options'Range loop` for any size of array, empty, one-element, and more.
This is pretty good. &amp;#x200B;
I think this summary should be made sticky for anyone that needs to pitch it, perhaps even improved by the community. It should be as easy as copy &amp; paste into an email. Management is very picky about technology that could get their \*sses burnt. If you mention secure and performant, reliable, maintenable code and mention high caliber projects suchs as those you mentioned and also space probes, satellites, medical equipment, etc you could get some people interested. If the know that their project could be built with the same technology that powers the space station (well sort of, but they can infer that) they could be persuaded to allow it. You already know that and have that experience.
Well, they also have an excellent package management system (Cargo) -- which is certainly something that Ada could have as well. That might be a great project for someone interested in boosting Ada adption -- without Cargo, I suspect that the adoption rate of Rust would be much lower. (Consider also Dub for D, Opam/Dune for OCaml, Node for JavaScript, and the venerable Maven for Java. It's a game-changer to have a vibrant package community, and great package tooling.)
We are aware and various people have looked into it, I have too.
&gt;these C/C++/Rust/etc. people have said to me in comments in various places that they think Ada is hard to read Yeah; this is puzzling.
puzzling is an understatement, I just think it's stupid.
On your youtube channel (thank you for it) you have told what do you expect from others packages: at least prebuilded RPM/DEB packages for most OS. Right? Meantime your project doesn't provide this. There isn't event instruction how to build it. No, I'm not going to build it, because I don't use Windows.
It might be advisable to say what ATM is in this context?
What? Yes it does. See the Package, Library, and InstalledPackageUnit classes. It most definately does. It's built upon dotnet core, which means two things regarding what you claimed. One, that building is a simple \`dotnet build\`. Two, that it runs on Linux as well. And I in fact do test the builds on a Linux machine as well.
Patrick, I've been meaning to check the tools out along with some of your new videos but I've too much work at work, plus helping on other folks Python and C third party projects at home have put Ada on the back burner. It's good it builds in dotnet core, since we are switching some projects to that at work and I have it loaded at home on my Linux computer. All my utilities for my department need to be ported to C#, so lots of fun in dotnet land. I also have two possible motor control projects, a mini CNC machine for my FIL and ban/tilt mount for tracking aircraft that are initially located with ADS–B. Instead of using existing libraries in C, Ada sounds like fun match. Plan on looking at Fabien's ACNC code to do the G-code. 
It's the library I'm most interested in getting feedback on right now, but any bug reports or ideas for the tooling is certainly appreciated as well!
This subreddit is for the Ada programming language, not the Americans with Disabilities Act (ADA).
Air Traffic Management, according to Emma's blurb.
Nice! Thank you for sharing.
Both of games are good, you can make profit playing both of them. 
Suppose you need to call an HTTP endpoint with a JSON payload, and one of the attributes _must_ always have a value of `true`. In that case it's very handy to have a type specifically for that requirement.
Thanks for these! I'm going to stick this up here for a little while :-)
It seems that some of the links are rather outdated and apparently there is another list of Ada resources: https://github.com/ohenley/awesome-ada
Oh, that's the better link I was looking for! (Too little sleep due to NYE fireworks...) u/marc-kd can you make a correction? Thanks!
Even as mod I can't edit a post's link or title. Feel free to resubmit and delete this one.
For whatever reason he refused to take my commit referencing Ytomino's Drake runtime, which is impressive and worth checking out. [https://github.com/ytomino/drake](https://github.com/ytomino/drake)
Maybe because it's a non-Ada runtime?
Looks like Ada to me.
In Ada, Strings are not UTF-8. This is not a minor point. Deliberately disregarding the standard disqualifies it as Ada.
I assume that there are good reasons for the Drake runtime which the standard Ada doesn't fulfil. Unfortunately I can't read the details in the wiki. 
This is remarkably pedantic. While yes, it doesn't meet the ACATS, it's still the same language. And it's honestly more useful for people who want high degrees of compliance with standard OS and text conventions, rather than an ideal microcontroller language. A simple disclaimer about this behavior is enough to get the point across. Never use Drake on a microcontroller. But it's still ideal for Windows, OS X, Linux, etc.
I agree. We have more restrictive subsets of Ada, but one that's a bit looser and more flexible would help promote the language. Purity above all doesn't allow for easier exploration. Now as a novice, I need to learn how Ada handles various codepoint sets since I can get data from a variety of sources. 
This argument is predicated upon the false belief that String is the only string type in Ada. In fact, Ada is fully Unicode capable without butchering the runtime. 
Can you then explain the effort put into Drake? It presence seems to be satisfying needs that some think are missing from standard Ada runtime. 
I said it wasn't Ada. I didn't say it didn't satisfy someone's "needs".
It appears to correct some inefficiencies with the standard runtime on workstations. Is this why Ads isn't progressing in that realm and limited mainly to safety and critical systems?
I have written one desktop GUI application in Ada 2012 which inputs, outputs and processes Unicode text in Microsoft Windows-- an obscure operating system but perhaps you have heard of it. This application Just Works. Compared to developing in some modern dynamic languages like Common Lisp and Perl, using core Ada for Unicode string handling is more inconvenient. But everything you want to do with Unicode can either be done with the core Ada facilities or with libraries. It's certainly easier to do that than go about hacking up a runtime. Perhaps the author had other reasons for building a new runtime besides string handling? 
It's always good to see more Ada libraries. I have a few questions about your decisions for the number-word package: * Why is `English_Number` defined using a non-portable derivation from `Long_Long_Integer` (`is new`) rather than letting the compiler choose the representation (`is range`)? * `Long_Long_Integer` is optional * If `Long_Long_Integer` is defined, it may not have a range large enough for your specified range, even if the compiler can create integer types with that range * `is range` will compile with any compiler that supports the range * Why is `"+"` an expression function rather than a renaming of `To_Unbounded_String`? * A renaming is more portable (expression functions are Ada 12 or later only, and this is your only use of an Ada-12 feature) * `PragmARC.Unbounded_Conversions` provides such "+" renamings in both directions ([PragmARCs](https://github.com/jrcarter/PragmARC)) if you do this a lot * Why do you explicitly initialize `Unbounded_String` variables to their default initial values? * Why do you convert `String` literals to `Unbounded_String` to pass to `Append` when there is an `Append` that takes `String`? * Why do use parentheses in `abs (Number)` rather than `abs Number`? It's unusual to see a result built up in an unbounded structure combined with recursion. Normally an unbounded structure is used with non-recursive iteration, or concatenation of bounded structures is used with recursion. Why did you choose this approach? I hope I'm not just wasting your time and you find some of these worth thinking about. Note that Ordinal cannot handle `English_Number'First` because it tries to take the `abs` of `Number`. Cardinal should have the same problem with `-Number`.
You have obviously spent some time reviewing my code, for which I'm most grateful. You make some good points there. I originally did this not too long ago as an exercise learning Ada in a practical application, and so mostly the answers are that I didn't know any better. Will definitely review the code with your comments in mind to improve it. Many thanks for the feedback. 
Can't be predicated upon the false belief that String is the only string type if I'm well aware of other string types. The presence of things like GNAT.Encode_UTF8_String and Unicode.CES.* (Found in XML/Ada) should indicate the matter is more complicated than you seem to find it.
&gt;It's always good to see more Ada libraries. I agree! :-) Mine is only a humble contribution, but it may help someone, I guess. &amp;#x200B; &gt;Why is English\_Number defined using a non-portable derivation from Long\_Long\_Integer (is new) rather than letting the compiler choose the representation (is range)? I was also fixated on getting a C interface working, so I wanted to "ensure" that a 64-bit representation would be used. I have now used "is range" without making it a Long\_Long\_Integer type. It all still works in GNAT, but may break, I guess in other combinations of Ada and C compilers. (I am still using C interface type long\_long in the CFFI package.) &amp;#x200B; &gt;Why is "+" an expression function rather than a renaming of To\_Unbounded\_String? Following Barnes' style in "Programming in Ada 2012". E.g. page 695. Since "rename" is not a thing in other languages I know, I didn't think of it. Plus, the expression function is a natural solution (to a Common Lisp programmer used to doing certain things using a functional methodology.) &amp;#x200B; &gt;A renaming is more portable (expression functions are Ada 12 or later only, and this is your only use of an Ada-12 feature) PragmARC.Unbounded\_Conversions provides such "+" renamings in both directions (PragmARCs) if you do this a lot I didn't know about your library. Thanks for the tip. Looks like there are some good things in there to explore. I have changed the expression function to a renames for the reasons you mention. &amp;#x200B; &gt;Why do you explicitly initialize Unbounded\_String variables to their default initial values? To be sure, to be sure, that would be Irish blood coming out. At the time, I didn't feel like guessing what the default initialisation, if any, would be in Ada. I have now removed the superfluous explicit initialisation, in case it causes anyone heartburn. ;-) &amp;#x200B; &gt;Why do you convert String literals to Unbounded\_String to pass to Append when there is an Append that takes String? Probably because I am influenced by the Common Lisp/dynamic language way of doing things, where "unbounded" strings are normal (or at least, due to garbage collection and automatic allocation, they can be treated like that). Another reason is that the following doesn't work: Cardinal_Ones : constant array (1 .. 9) of String := ("one", "two", "three", "four", "five", "six", "seven", "eight", "nine"); because Ada naturally wants all the Strings to be the same length, or indexing won't work. &amp;#x200B; &gt; Why do use parentheses in abs (Number) rather than abs Number? I'm starting to sound like I'm playing the same track over and over ;-) The reason is that I assumed abs was a function and not a unary operator, since that's what it is in Common Lisp, for example: CL-USER&gt; (let ((data-1 '(-19.17 -3.7 -9786746281239456231234987654123400685849293298485766118223)) (data-2 (list (sqrt pi) (sqrt #C(34 1)) (sqrt -1.0)))) (format t "~&amp;ABS function applied to a list:~%~A~2%" (mapcar #'abs data-1)) (format t "+ (PLUS) function applied to a list:~%~A~2%" (reduce #'+ data-2))) ABS function applied to a list: (19.17 3.7 9786746281239456231234987654123400685849293298485766118223) + (PLUS) function applied to a list: #C(7.604035920302488 1.0857400223612785) &amp;#x200B; &gt;It's unusual to see a result built up in an unbounded structure combined with recursion. Normally an unbounded structure is used with non-recursive iteration, or concatenation of bounded structures is used with recursion. Why did you choose this approach? Dynamic programming is again the answer. Where there is no error in the recursion, an unbounded string is not really unbounded: you could in theory work out the maximum length return string, if that were required. (Should be under half a kilobyte, I imagine.) I understand that Ada is often used in situations where dynamic allocation of RAM is undesirable, but I wasn't considering such cases here. &amp;#x200B; &gt;I hope I'm not just wasting your time and you find some of these worth thinking about. Any help in improving my code is appreciated. Thank you. &amp;#x200B; &gt;Note that Ordinal cannot handle English\_Number'First because it tries to take the abs of Number. Cardinal should have the same problem with -Number. Good point. I have excluded the bottom of the negative range (-2\*\*63). I suppose I will now have to add a check to the CFFI interface, and some documentation, since C knows nothing about allowable ranges, being the glorified assembler that it is... :-)
If you want to write Common Lisp, you could just use Common Lisp. I presume you're using Ada because it's different, and you want experience with that difference. I should probably have mentioned that the portable way to get the largest signed integer type is to declare `range System.Min_Int [+ 1] .. System.Max_Int`. You can look at `PragmARC.Unbounded_Integers` for an example of that (to try to avoid problems taking `abs` of an `Integer`) as well as of using the equivalent for modular integer types, `System.Max_Binary_Modulus`. This might cause your code to fail if it's ever compiled with a compiler that supports integers larger than 64 bits, but you've There's nothing intrinsically wrong in initializing a variable to its default initial value, but it looks wasteful (though it clearly isn't an issue in this case). One can hope that the compiler is smart enough to ignore it, but in the worst case it would create a null `String`, pass it to `"+"` to convert it to a temporary `Unbounded_String`, copy that into the variable, `Adjust` the variable, `Finalize` the temporary, and maybe get rid of the `String`. If you are going to do it, I would suggest that `Null_Unbounded_String` is a better choice. Of course your arrays of strings need to have components of `Unbounded_String`, but converting `String` literals to `Unbounded_String` when you don't need to looks wasteful (again). You probably ought to declare an array type for all those constants, so if something needs to change, it only has to happen in one place (also because anonymous types are Evil™). HTH
I recommend building a REST micro service back end using AWS, GNATCOLL (JSON parsing), and AdaBase (database access). You can use nginx (or any other reverse proxy) to expose all your services under a single port. For example, let's say I were building a contact managing app. I might have the API: - POST /auth - GET /users ?limit=20&amp;offset=0&amp;filter=* - GET /users/:userid - POST /users {user object} - PUT /users/:userid {user object} - DELETE /users/:userid - GET /contacts/:userid - POST /contacts/:userid [userid(s)] - DELETE /contacts/:userid [userid(s)] the way I imagine the folder structure is: - contact_app - api_shared - shared.gpr with "aws", with "gnatcoll", and with "adabase". - any shared data models - any shared utility subprograms - auth_api -.gpr with "../api_shared/shared.gpr" - contacts_api -.gpr with "../api_shared/shared.gpr" - users_api -.gpr with "../api_shared/shared.gpr" - web_interface - any modern web framework stuff /auth would get it's own project folder and executable. The default dispatcher returns 404 and there is one Method dispatcher for POST. It would pick a port: let's use 8081. /users would get it's own project folder and executable. The default dispatcher returns 404. There would be 4 method dispatchers. It would pick a port: let's use 8082. /contacts would get it's own project folder and executable. The default dispatcher returns 404. There would be 3 method dispatchers. It would pick a port: let's use 8083. to start the back end, you just need to start all 3 API executables. then start your reverse proxy with it configured to forward all traffic on /auth to localhost:8081 etc... I'll put an example up on my github in a few days. 
It's C++ fault… I would avoid interactions between code written in any language and C++, except through C interfaces.
Talking in general: it seems to me that more often employers tend to choose languages where there are masses, maybe because so it's more likely to find fairly good programmers and resources at lower prices. At the same time, “we” want to choose languages with higher probability to be hired (and earning a decent salary). This is a self-nourished problem which tend to reduce diversity.
Ada and Perl are two very different languages, I hardly can imagine that someone could pick one instead of the other to solve the same domain of problems!
&gt; no one cared about reliable software in the mainstream until the last 5 ish years. My casual fascination for formal methods and design by contract (no TM…) (which is what brought me to Ada) seem to have a good timing, if you are right! But I don't really see room for it outside of a relatively small garden.
Hi, no it wasn’t for the same problem. I wanted to use Ada to write BSP code while the other developer used Perl to create a tool to generate various data files offline that the BSP code would process at runtime. 
true
Glad to see this news, also that the support will be included in the Community Edition, at least for 32 bits.
You can see at [https://github.com/AdaCore/gnatcoll-bindings/tree/master/gmp](https://github.com/AdaCore/gnatcoll-bindings/tree/master/gmp) and [https://github.com/ytomino/gmp-ada](https://github.com/ytomino/gmp-ada) for GMP, MPFR binding
RISC-V32 is already available in the Community edition since June 2018 :)
there is GNAT Studio for Windows - [https://www.adacore.com/download/more](https://www.adacore.com/download/more) 
Thanks! We are currently writing simple programs that we are running from the command line in Linux. How do I write a program that then runs in a console in GPS?
May be this [http://gcc.gnu.org/onlinedocs/gcc-4.7.0/gnat\_ugn\_unw/Building-a-New-Program-with-GPS.html](http://gcc.gnu.org/onlinedocs/gcc-4.7.0/gnat_ugn_unw/Building-a-New-Program-with-GPS.html) can help
btw, there were tutorials for GPS on YouTube
You need to install gcc on your computer. To run gcc on windows you need mingw-w64, install it and you should be able to run it from command line. To setup build and run read VSC docs.
I just clicked on your link &amp; got to the project - now in long-term archive. If you go there &amp; look in Source/Commits you’ll find the author’s email address.
That's weird, I get a 404 and "The project adabindinggmpmpfr was not found." and no redirection. Might be something to do with browser plugins. Thanks for the tip.
Thanks. I already came across gmp-ada, the gnatcoll binding also looks interesting.
If you just need large number math, GNAT's implementation of the standard library contains System.Bignums. I'm pretty sure this will compile with warnings that your code might not be portable to other compilers, but it has all the standard large number math features. 
Thats, I've used System.Bignums, but I'm interested to familiarize myself with other MPI libs / bindings.
I see I got redirected to [https://code.google.com/archive/p/adabindinggmpmpfr/](https://code.google.com/archive/p/adabindinggmpmpfr/)
That link helped me determine which domains to allow to finally get the download working. Cheers, I appreciate the help!
That's really cool. It would be interesting to see how well it handles very large numbers of objects (e.g. 1000).
I can't directly address your post (hopefully someone else will), but I'd like to propose an alternative as a potential backup plan. I'm assuming that much of what you like about Ada are the correctness guarantees. While C/++ are not inherently designed for this, there are tools (e.g. sound static analyzers (e.g. IKOS)) that can achieve similar results. Perhaps you can bring the concepts of Ada to the practice of C/++ development. This is what I do at my job.
Have you tried contacting AdaCore? They're maintaining GNAT, it's their interest to fix this. I think it's a bug in GNAT, but it's just a guess. 
As Ada's remaining domain is predominantly the aerospace industry (with a good chunk of that being defense contracting, thus also requiring a security clearance), there's very limited opportunities for any sort of home-based workplace positions. The only company I can think of that would have such positions would be AdaCore, as their workforce is scattered around the world. (And other Ada vendors *may* be similar.) If you had, or would be able to easily get, a clearance and were willing to relocate, we've got on-sight Ada development positions available here in Huntsville, AL (and anyone can PM me if interested). Good luck!
Unfortunately, I can't do much more than commiserate. I too am a long time inhabitant of the Ada wasteland of the NE US. I had high hopes when I first moved here years ago given the plethora of academic institutions and corporations that could benefit from the use of Ada but that was not to be. I still long for the day that I can find worthwhile employment using a language that I thoroughly enjoyed. In the meantime I slog through the swamp with what seems like everyone else. I'm potentially less geographically constrained now but the possibilities are slim and not always in locations that I find desirable. On the bright? side I have heard of some Ada work in the NE but I'm still in search of details. Knowing the company involved I'm leery of what I might find. They didn't choose Ada but were mandated to use it and IMO their performance showed that lack of enthusiasm. However, if I find anything concrete I will pass the information along.
[removed]
This is a huge win for Ada!
Honestly this is the space we are in, and it is really not really about using formal methods in mainstream software - it's about designing software to just have less bugs and more maintainability. Using Ada for general-purpose and large mainstream applications makes an absolutely night-and-day difference in general reliability, security, and maintainability. It shows noticeable and huge reduction in bugs, and noticeably decreased, more predictable debugging and testing times. It is especially great for software built with large teams, where the information hiding qualities of Ada shine. Formal methods are really for going to that extreme where you need to have 100% confidence. However Ada alone can go from having low confidence to 95% confidence alone. It makes a huge commercial difference. The only reason that I see slow adoption of Ada is that management doesn't know how much economic sense it makes, and the technical people are often over-committed to the hacking culture of immediate gratification and cowboy approaches to development.
&gt;As Ada's remaining domain is predominantly the aerospace industry This makes it sound like Ada is in decline and this is the "last stand". I would counter that this is Ada's more "traditional" domain. Honestly, I think you will find Ada conquering more of its less traditional domains in the future. Above all else, we need more advocacy, and less defeatism. Most management simply grasp on to the most passionate things they hear from lower levels. This is what got Linux into the position it is today, not because of technical superiority, but because of economics (free) and buzz. Ada is free, the FSF GCC compiler is excellent, and most Linux-based C++ applications use GCC anyways. The FSF Ada compiler is a mainline package for most mainline Linux distros. Ada has the economics argument - not just because it is free, but because it reduces testing time, reduces risk, and vastly improves maintainability. &amp;#x200B; If the technical people make more noise about Ada, it will convince some management to give it a shot. If the community does a better job getting more younger people interested in Ada, I guarantee you it will gain more prestige. It may be anecdotal, but look at the buzz Rust made - I passionately believe that if more of the people who got excited about Rust knew about Ada, Rust wouldn't have made it off the ground. &amp;#x200B; Let's please have some more advocacy and less giving-up. 
O M G! This should help counter some of the "but no one uses Ada" responses we often get from people. &amp;#x200B;
The time has come. Congratulations AdaCore.
it's strange because everybody flying with planes "uses" Ada, the same for trains etc
Nicee 
Yuge
Yeah. Quite good press
Go, AdaCore. 
For convenience I hide the unbounded string usage in the private part of a tagged type, expose setters and getters of type standard String and take advantage of the object-prefix notation. For example (pseudo-code): package A is type T is tagged limited private; function Name (This : T) return String; procedure Set\_Name (This : in out T; Value : String) with Post =&gt; [This.Name](https://This.Name) = Value; private type T is tagged limited record My\_Name : Ada.Strings.Unbounded.Unbounded\_String; end record; function Name (This : T) return String is (Ada.Strings.Unbounded.To\_String (This.My\_Name)); end A; &amp;#x200B; package body A is procedure Set\_Name (This : in out T; Value : String) is begin Ada.Strings.Unbounded.Set\_Unbounded\_String (This.My\_Name, Value); end Set\_Name; end A;
This approach seems to solve quite a lot of my problems actually. Thanks for that! I suppose it just requires slightly more careful api design that my user end code doesn’t need to do the casting. Are you aware of what sort of overhead this has if I’m potentially doing tens or hundreds thousands of these casts per second?
Yes, I've been advocating for Ada for over 35 years now. In my career I halted the push by system engineers to convert major components of at least two major defense systems to C++, facilitated the efforts of like-minded others to maintain the Ada foundation of some additional systems, and my open source Ada utilities have provided useful functionality that's been incorporated into nuclear research, satellite testing, and economic modeling. In my present position I still openly and unapologetically advocate for Ada, and am again working hand's on to strengthen a team's expertise and comfort with the language. I have a pretty good idea of Ada's traditional domains, and after a decade and a half of rearguard action trying to defend them, I have seen relief that its market has stabilized and small inroads are being made in other fields. Nonetheless, the state of Ada is such that its *predominant*, and traditional, domain is the aerospace industry and a developer's (such as the OP) best hope of finding an Ada development position lies within that industry.
I haven't done any performance measurements but I can imagine the compiler has good opportunity to do performance optimizations. When one has a function that returns a standard String, or any array for that matter, there is no usage of any explicit access type (pointer) in the Ada code, but the compiler should know (depending on the code) that it is sufficient to return an address to the String/array instead of making a full copy. It's such an obvious performance optimization that it's hard for me to imagine it is not implemented in many Ada compilers. But again, I haven't done any measurements and hope somebody else has more input on this topic. It may be worth mentioning XString in GNATColl: [https://blog.adacore.com/new-strings-package-in-gnatcoll](https://blog.adacore.com/new-strings-package-in-gnatcoll)
Thanks for the help.
[removed]
Sane exceptions. Try to overflow integer and catch it in Rust in a sane way. Same goes to out-of-bound indexing. Sane OOP. Rust's take on polymorphism is not for everyone.
Ada doesn't have casts. It has type conversions, but what you're talking about aren't type conversions as defined in the ARM, they're function calls. We (at least, most of us) know what you mean, but it looks better if you use the ARM terminology. You're concerned about the "overhead implications" of these function calls. There's a technical term for worrying about overhead implications in the absence of evidence that they are a problem. It's called premature optimization. The rule for premature optimization is: Don't do it. You should only worry about optimization when you have quantitative timing requirements and the clearest, simplest solution doesn't meet them. If you don't have such requirements or your code meets them, then you're done. If your code doesn't meet them, then you almost always need to use a faster algorithm. The tiny improvements you get from reducing the number of conversions between String and Unbounded\_String, or making your code incorrect by turning off run-time checks, are rarely enough to make a difference. You generally end up replacing an O(big) algorithm with an O(smaller) one. Your compiler does a much better job of optimizing the little things than you possibly can, and vendors usually go to a lot of effort to optimize Unbounded\_String operations. Worrying about them is just a way to lose sleep. Regarding building up a return string of a function, it depends on what that means. For the simple case in the Extended\_Name example one generally just returns the expression (or uses an expression function in Ada 12). For more complex results, the 2 main approaches are recursive and iterative. There are arguments both ways for both approaches. Recursion can be short and elegant, but some developers have difficulty understanding recursion, and the stack is usually much smaller than the heap, so running out of space is more likely (but still uncommon). Iteration using an Unbounded\_String is clearer to such developers and less likely to run out of space, but may do a lot of allocation and deallocation under the hood. In the end, it's usually a matter of personal preference. HTH
This is great advice, thanks a lot!
Well considering how garbage I find GPS, and how nice I find VS Code, I worked out all the necessary stuff. Luckily it's not too bad. Like others have said, you need a toolchain. You can grab GNAT Community, mingw-w64, or something else. I'll be assuming you're using some variant of GCC/GNAT for the rest. VS Code uses a `tasks.json` file for its builds and other tasks. This is a very simple JSON file in which each task is described. If you're using GPR's for your projects, then a build is a simple as `"command": "gprbuild"` and `"args": \["*.gpr", "-p"\]`. If you're not using GPR, then follow your build system of choice. If you want to just use gnatmake, the command part should be obvious, and args needs to include all the files to be compiled. For running within VS Code, you can either run directly from the integrated console, or set up a run task.
Thank you! This is what I was looking for
You're welcome. Please ask if you run into any other hurdles.
"I downloaded Visual Studio Code with an Ada add-on" If you don't mind my curiosity, which Ada extension and why?
Its called Ada by Entomy. It's just an Ada syntax highlighter. 
The truth isn't always nice. Ada is a niche language. It was designed that way, and only made more general later one. It's not surprising then that it still has niche use (for the most part). "Ada is free" so are numerous other languages/compilers/toolchains. So what? "The FSF GCC compiler is excellent" Work on the Ada-tools project with me and find out how many faults in the toolchain I have to work around. It's a clusterfuck. What Ada needs isn't more advocacy by any means. Evangelizing something that is barely used to social creatures which weight popularity over technical merits is frivolous. Before you think I'm somehow a "defeatist" or "submissive" let me be clear: Not only do I do the overwhelming majority of software development in Ada, and make such projects publicly available as to increase obvious use-cases of Ada, I have a programming channel on YouTube which is, by certain metrics, more popular than AdaCore's channel. Unlike yourself, I'm actually doing something about it, not just bitching to others to do it for them. Over my time doing this I've spent the effort to find why people are drawn to Ada and what keeps them from using it professionally. It isn't what you think in most cases. What Ada needs isn't more advocacy. What Ada needs is more freely usable libraries and tools, better IDE support (there's a lot of complaints with GPS), more language/library bindings, and better educational resources. Plenty of people are aware of the language and its purported benefits. Plenty of people don't chose to use the language because of barriers to use.
I played with it, pretty cool! It's pretty limited for Ada though, you cant compile multiple source files. To be fair it's not Compiler Explorer problem, I wish GNAT had a switch that would compile whatever is in the source file.
I know what it is, I wrote that one. \^\^ I was just looking for feedback in the choice. Thank you though.
Hahaha oh! I just noticed your username^^ I didn't do much research other than googling, and I believe yours was the first result. If I remember correctly there were alternatives, but your description inspired the most confidence. While I haven't been able to run a program from VS code yet, the highlighter seemed to work well.
It still needs some work, but mostly just in edge cases. If there's anything you spot that's wrong or not highlighted, please take a screenshot of the issue and report it here: [https://github.com/Entomy/Ada-vscode/issues](https://github.com/Entomy/Ada-vscode/issues) I'll fix it as soon as I can, and it helps improve the highlighter.
GNAT chose to implement a single file per an Ada unit. Thus, AdaCore provides gnatchop utility to break a multiple Ada unit source file into multiple files where an Ada unit is contained in a separate file.
That was one of the trade-offs I had to make when adding support for Ada, along with working within how the Compiler Explorer currently works. So while it is a little annoying that you can't have an .ads file with a package specification and your .adb file for the body, the easiest solution I found was to wrap everything in a dummy procedures declarative part. [Here](https://godbolt.org/z/9vhiir) is an example borrowed from the Reference Manual.
Dummy procedure only works for unoptimised code though, if you add -O1 compiler will optimize out all of your code.
Thanks for doing this /u/Bigfoot_43 ! Do you know about gnatchop? It's a tool that splits a file with multiple ada units. For instance: package Test is procedure Lol; end Test; package body Test is procedure Lol is null; end Test; It would split this text into a test.ads and test.adb file. I don't know if this would fit in the Compiler Explorer system.
It was my pleasure hopefully people find that this addition to the Compiler Explorer is useful even without multiple source files. I must admit that I did not know about gnatchop until this morning when [/u/anhvofrcaus](https://www.reddit.com/user/anhvofrcaus) mentioned it in another comment. The work in adding Ada support to CE was my first time really looking into GNAT (outside of using it as part of GPS), but the issue of package specs and package bodies etc. had crossed my mind when I first started working on bringing Ada support to the CE. In the end I decided that initially at least having some support for Ada even if it was just subprograms was a good starting point and at least allowed for people to see the generated assembly for most things and compare it to other languages. I will say though now that I know of gnatchop I can start having a look into how it might be best to integrate this into the CE if possible.
I’ve already spent way to much time inspecting when the ranged type check occurs and when it is simply omitted! Thanks to whoever got this included!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Highly portable (and safer) Web server in Ada \[x-post r\/Ada\]](https://www.reddit.com/r/programming/comments/aq9dcm/highly_portable_and_safer_web_server_in_ada_xpost/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
The array is stored the same way as in any other language, as a contiguous chunk of memory. The only difference is that (at least for potentially dynamically sized arrays) the size/index information is stored, too (usually at a negative index in relation to the array address, so that 'Address would indeed return the address of the first element). The text you're referring to explicitly speaks about the *semantic* difference. An array and a pointer (i.e. access type) are different things. While in C, a char* is in a way semantically equivalent to char[], in Ada these are not. But that is a language thing, it doesn't really affect the way arrays are stored in memory. After all, every identifier refers to the memory location where it is stored.
What are the use cases of an empty array?
&gt;You have then a pointer referring to the first address used by the array. That's not how arrays work in C. When you make an array it's just a chunk of continuous memory. when you write a[n] it just means "take an address of a[0] and add n". Address of a[0] is not stored anywhere, it's computed at run time.
Similar to the use cases of a null pointer, I'd say. An empty string "" being the prime example.
If you have a function which returns an array of, say, playing cards still in the pack, it needs to be able to return *something* when there are none left; an empty array does that. Also, a String is an array of characters, and an empty String is represented by an empty array. To create an empty array, you need to have the last index less than the first: Empty : array (1 .. -42) of Integer;
ah, right, thanks! :)
That’s exactly how arrays work in C. After `int a[10];`, `a` is the address of the first element of `a`; so `a == &amp;a[0]`. `a[n]` is precisely equivalent to `*(a + n)`. See K&amp;R 2nd edition section 5.3.
Ada is more efficient then CCured. Ada compiler can store metadata and/or address only if necessary. For instance, string of fixed size (restricted by explicit compile-time-known bounds) can be in a known place on stack frame, having a known size, so no need to store pointer and bounds. They can can be hardwired in opcodes. When this information is dynamic, Ada compiler can pass pointer and metadata separately via different pathways. For instance, if there is a string on stack, and there are "declare-renames" constructs referring to slices of this string, pointer (hardwired or dynamic) is shared, but metadata are not. Fully explicit and coupled together metadata is used in access types and (conformant) array types. Ada does not mandate specific representation, but in GNAT in AdaMagic I observe this scheme: array access consists of two pointers, data and metadata. Metadata pointer refers to bounds. Compilers generate bounds pair on demand, when function is to be invoked on array slice. Metadata preceding data is one of the formats acceptable by Ada standard. This is an unfortunate source of limitations when working with array access types. Ada standard only allows what is compatible with "metadata preceding data", so construction of access values referring to arrays located in arbitrary memory positions, of arbitrary size, is not directly possible. It is possible to declare array imported from memory (X : constant String (1 .. Some\_Length) with Import, Address =&gt; Some\_Address) and pass it to functions accepting String, and also to slices of string declared this way. Only explicit access values are troublesome. I have an impression that GNAT and AdaMagic are still compatible with "metadata preceding data" scenario, but that must be demanded explicitly, by forcing access type size to be System.Address'Size. Assuming that compiler-specific tweaks are fine, one can have much fun with custom crafted access values, like I do in [https://osdn.net/projects/referencing/scm/hg/Fast\_Strings/](https://osdn.net/projects/referencing/scm/hg/Fast_Strings/) There is an inconvenience that metadata are not attached to pointer directly, so GNAT and AdaMagic String\_Access is not like C++20 std::string\_span or C++17 std::string\_view. There must be additional dedicated storage for metadata, and if the structure is copyable, Adjust must update metadata pointer to make it point to valid metadata buffer. Unfortunately this fun is far from being explored. Fast\_Strings are protected against tampering, very much like it is done in Ada, and same can be done to vectors.
Thank you for your answer!
Thank you for taking the time to write an extensive answer!
Do you have a credible source for this? My understanding is that most of these products (reasonably new ones) are C++ based. &amp;#x200B; VxWorks appears to be in heavy use as well. I couldn't really figure out what language it is written in.
Er no... a[n] is the same as *(a + sizeof(element) * n)
No, that part was correct. The compiler takes care of the `sizeof` for you. The controversial part is whether `a` is an address, or if it just decays into an address. Most experts will claim it's the latter. K&amp;R is ambiguous on the matter.
Wrong Ada. This subreddit is the programming language not Cardano cryptocurrency 
Try this: #include &lt;stdio.h&gt; char a[10]; int main() { printf("&amp;a[5]:\t%p\n", &amp;a[5]); printf("a+5:\t%p\n", a + 5); return 0; }
good source is AdaCore Web resources. The most critical mission software is written in Ada, some in C (often Misra C) and in limited subset of C++ (like Misra for C++). But leader is Ada, sure. Because behavior of C++ software usually is not 100% known for there authors, always there are "surprises". Today there are a lot of speculative languages which tries to sell itself using lie, fakes and fanatical assertions. Good example is "safe" language Haskell, it's difficult to discuss it seriously even :) Haskell applications authors never know how many times will be evaluated some expression even or what will be memory usage and performance of the resulting application. Sure, Haskell can not be used where Ada is using, but it tries to positioning itself as good language for... finances. It has not even control of overflow and range integer types :))))) While Ada, F# and C# - has. And these 3 languages have not such aggressive and lying propaganda. Another picture is modern C++. It's so complex that even Stroustrup said that he knows only 70-80% of the language. This can mean only one: avoid to use the language, it can lead to a lot of bugs (bugs = money, deaths, nerves). Today there are a lot of humorist languages, toy-languages, languages "jokes", problem is only that some of developers take them seriously and switch to such languages. This is always a big loosing of investments. Today it is possible to write software for banks and financial organizations in Haskell or C++ because financial organizations have a lot of money and they share them with IT: modern economics is not more "real" but it's more "virtual", and there are economics areas where people have not money and there are another ones where peoples don't know how to spend their money. This is the reason only why there are experiments with so hopeless languages and when you forget it, you begin to take those experiments seriously.
This is series of interviews with software developers interested in\* [*Ada programming language*](https://en.wikipedia.org/wiki/Ada(programminglanguage))*. The goal is to promote the community members and the language itself. Do you want to take part in this?* [*Contact me*](https://tomekw.com/about-me/)\*!
just in case, I used to read a blog series about generic network stacks in ada.. maybe you know about that ? I can't find it again ..
Umm, not really, no. I'm sorry.
Don't be. One day I'll run into it. Good luck with the interviews
And here is ["AdaFractal Part1: Ada with a Portable GUI"](https://blog.adacore.com/adafractal-part1-ada-with-a-portable-gui).
Great answers! Nice to see some more based critical views on Ada, rather than the typical churn of “not being C”. 
H, and it’s not c 😝
I can only give you an anecdote. I just started work on a new embedded project at work that will be using a mixture of Ada and C.
I've sent in an edited and expanded version, so just waiting for it to be updated on the site.
25:00 - GNAT front end for LLVM would be so sweet!
The entry has been updated and expanded!
The add on for Ada is pretty basic really.
https://github.com/MichaelAllenHardeman/contacts_app This is very unfinished, but it has a example of that.
THANK YOU SO MUCH!
My goal is to use ADA along with Golang. Go will handle the web stuff, ADA will do all of the database stuff. Then I want to setup ADA to listen on a unix socket or shared memory? First step is setting ada up to access pgsql.
Why not go all Ada? You can copy my project if you want, it shows how to make full Ada REST micro services.
Well, I want this to be closed source. And I believe AWS requires the project be open source or else you have to pay for a license? &amp;#x200B; Where in the gpr file should I put with &lt;path to adabase.gpr&gt; I put it at the top and got an error message. Also put it within the project definition and got "end expected".
Nevermind. I see!
afaik AWS uses GPLv3 [License](https://github.com/AdaCore/aws/blob/master/COPYING3) which, according to [choosealicense](https://choosealicense.com/licenses/) looks like it does require your code to be open source and also use the GPLv3 license. As to your question about the GPR stuff. Look at [/api_shared/api_shared.gpr](https://github.com/MichaelAllenHardeman/contacts_app/blob/master/api_shared/api_shared.gpr) and also look at the [GNAT Project Manager Docs](https://docs.adacore.com/gprbuild-docs/html/gprbuild_ug/gnat_project_manager.html)
Ok. When you say "add source to your project like the examples in the AdaBase project." Do you mean adding Source_Directories := ("src"); case AdaBase.Driver_MySQL is when "no" =&gt; null; when "yes" =&gt; Source_Directories := Source_Directories &amp; "src/mysql"; end case; case AdaBase.Driver_PgSQL is when "no" =&gt; null; when "yes" =&gt; Source_Directories := Source_Directories &amp; "src/postgres"; end case; case AdaBase.Driver_SQLite is when "no" =&gt; null; when "yes" =&gt; Source_Directories := Source_Directories &amp; "src/sqlite"; end case; case AdaBase.Driver_FBird is when "no" =&gt; null; when "yes" =&gt; null; end case; for Source_Dirs use Source_Directories; To my project gpr file?
That's not how GPL works. You need to ship source code when you distribute binaries, but If you just run GPL software on server it's fine. In fact, there is another license called AGPL which exist specifically to solve this loophole of GPL.
What I meant was, now that you have a library that lets you connect to the database, then use the examples that AdaBase provides to write ada that will connect to and use the database.
So, if I use postgres, the source for the entire project is src/postgres? Seems like Im missing something.
Ah! Nm, once again I see. So I should use: Source\_Directories := ("src" &amp; "src/postgres"); ?
I allow the programmer to select what kind of database they want to connect to. If you don't want to do that, then you can just ignore the scenario variable switching stuff and just link to postgres. 
I think, if you aren't going to use any other databases then it would be better just to put everything in "src" and not worry about splitting it into different folders.
Should I remove the switch linker section as well?
You should still have the OS_Version switch statement unless you don't want to support other operating systems
This will only be for linux. Should I use: for Default\_Switches ("Ada") := ("Switch\_Linker", "-lpq");
I removed the switch statement. Then I built/ran the app (first time doing so). I get an error: **file adabase-driver-base-postgresql.ads** not found. &amp;#x200B; My Files are: main.adb with AdaBase; with Connect; with Ada.Text_IO; procedure Main is package CON renames Connect; package TIO renames Ada.Text_IO; numrows : AdaBase.Affected_Rows; cmd : constant String := "DELETE FROM fruits WHERE color = 'red'"; begin CON.connect_database; numrows := CON.DR.execute (sql =&gt; cmd); TIO.Put_Line ("SQL: " &amp; cmd); TIO.Put_Line ("Result: Deleted" &amp; numrows'Img &amp; " rows"); CON.DR.rollback; CON.DR.disconnect; end Main; testapp.gpr with "lib/adabase/adabase.gpr"; project Testapp is for Source_Dirs use ("src"); for Object_Dir use "obj"; for Main use ("main.adb"); end Testapp; connect.adb package body Connect is procedure connect_database is begin DR.basic_connect (database =&gt; "adabase_examples", username =&gt; "adabaser", password =&gt; "test", socket =&gt; "/tmp"); end connect_database; end Connect; [connect.ads](https://connect.ads) with AdaBase.Driver.Base.PostgreSQL; with AdaBase.Statement.Base.PostgreSQL; package Connect is -- All specific drivers renamed to "Database_Driver" subtype Database_Driver is AdaBase.Driver.Base.PostgreSQL.PostgreSQL_Driver; subtype Stmt_Type is AdaBase.Statement.Base.PostgreSQL.PostgreSQL_statement; subtype Stmt_Type_access is AdaBase.Statement.Base.PostgreSQL.PostgreSQL_statement_access; DR : Database_Driver; procedure connect_database; end Connect; &amp;#x200B;
Solved that error message. Sorry. I assumed src would include everything under it. Source\_Directories := ("src", "src/postgres"); Did the job. Now the error I am getting is warning there are no sources of language ada in this project &amp;#x200B;
yes. that is correct.
So Source_Directories is just a variable you have to tell the compiler to use the values in Source_Directories for Source_Dirs use Source_Directories;
you would get this error if the AdaBase src file isn't available. If you didn't put the path to adabase.gpr, or you didn't fully copy the repository that would happen.
My dirs seem to be right. testapp testapp/lib/adabase testapp/src &amp;#x200B; Although I have no postgres folder in testapp/src &amp;#x200B; So why did the previous error go away when I added Source\_Directories := ("src", "src/postgres"); Thats strange. &amp;#x200B; Current gpr is: with "lib/adabase/adabase.gpr"; project Testapp is Source_Directories := ("src", "src/postgres"); for Object_Dir use "obj"; for Main use ("main.adb"); end Testapp; &amp;#x200B;
try building it with the scenario variables set correctly as I showed you. You can also modify adabase.gpr to set Driver_PgSQL to yes by default.
I changed the line to: Driver\_PgSQL : Driver\_Included := external ("POSTGRESQL", "yes"); I still get the same "no ada in this project" error.
because you aren't selecting the source directories correctly. Source_Directories := (...) is just setting a variable named Source_Directories to some value. the actual command that tells GPR what source to use is: for Source_Dirs use (...) 
GOT IT!. Works now. Thank you so much for your help sir.
np.
If you have the time, what do you make of this error: gprbuild: could not locate library builder "/opt/gps/libexec/gprbuild/gprlib" GPS is withing opt. But libexec folder is not there.
You have something wrong with your installation. You kind of have to install GPS and GNAT to a place your user has read write access to or you'll run into problems. I recommend uninstalling gnat and gps, then downloading [GNAT GPL](http://mirrors.cdn.adacore.com/art/5b0d7bffa3f5d709751e3e04) and putting it in your home directory. ~/gps
Ok, thank you. I will try that.
Ok, I did this and I still get the file [adabase-driver-bas-postgresql.ads](https://adabase-driver-bas-postgresql.ads) not found error. &amp;#x200B; My gpr file is: with "lib/adabase/adabase.gpr"; project Testapp is for Source_Dirs use ("src/**"); for Object_Dir use "obj"; for Main use ("main.adb"); package Linker is for Default_Switches ("Ada") use ("-lpq"); end Linker; end Testapp; &amp;#x200B;
it should be -base- not -bas- I assume it's because the scenario variables are incorrect. Make sure adabase.gpr has this stuff like so. Os_Version : Os_Type := external ("OS_VERSION", "unix"); Driver_MySQL : Driver_Included := external ("MYSQL", "no"); Driver_PgSQL : Driver_Included := external ("POSTGRESQL", "yes"); Driver_FBird : Driver_Included := external ("FIREBIRD", "no"); Driver_SQLite : Driver_Included := external ("SQLITE", "no"); Debug_Symbols : Driver_Included := external ("DEBUGSYM", "no"); OR make sure to set the options at compile time like: gprbuild Testapp.gpr -XMYSQL=no -XPOSTGRESQL=yes 
Yes that dir is there. &amp;#x200B; My section is: &amp;#x200B; Os_Version : Os_Type := external ("OS_VERSION", "unix"); Driver_MySQL : Driver_Included := external ("MYSQL", "no"); Driver_PgSQL : Driver_Included := external ("POSTGRESQL", "yes"); Driver_FBird : Driver_Included := external ("FIREBIRD", "no"); Driver_SQLite : Driver_Included := external ("SQLITE", "no"); Debug_Symbols : Driver_Included := external ("DEBUGSYM", "no"); &amp;#x200B; I see no difference between the two. &amp;#x200B; Not seeing what you mean when you say -base- ?
https://imgur.com/a/Pjji7ZU I mean you misspelled it in your comment.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/sIAkfR0.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20egwytww) 
Also, ive been using the build button in GPS. That is when I get the postgres file error. gprbuild Testapp.gpr -XMYSQL=no -XPOSTGRESQL=yes returns: gprbuild: could not locate library builder "/home/user/opt/gps/libexec/gprbuild/gprlib" &amp;#x200B;
I use GNATCOLL.ORM and PostgreSQL to implement [http://сыроедофф.рф/](http://сыроедофф.рф/) It is currently able to import Instagram automatically and publish so that search engines can index it. Instagram remains convenient way to introduce new content for my customers. &amp;#x200B; GNATCOLL documentation had enough information. Basically you need to set up connection parameters with GNATCOLL.SQL.Sessions.Setup. Having done so, you can get sessions from pool and they will just work. As soon as they go out of scope, they return to the pool. Behind the scenes, GNATCOLL creates prepared statements for faster processing. ALTER TABLE breaks PREPARED though, but this can be handled. The only stupid problem I face with GNATCOLL.ORM is silent swallowing of database errors. You get 0 rows responses and process it as if it was a valid response, only to find out that session was broken. I have solution for this problem, put Check before and after every query, and also use these Commit and Rollback instead of GNATCOLL versions: procedure Check (Session : GNATCOLL.SQL.Sessions.Session\_Type) is Connection : GNATCOLL.SQL.Exec.Database\_Connection := Session.DB; begin if not Connection.Success then raise Transaction\_Failed with Connection.Error; end if; end Check; &amp;#x200B; procedure Commit (Session : GNATCOLL.SQL.Sessions.Session\_Type) is begin Check (Session); Session.Commit; Check (Session); end Commit; &amp;#x200B; procedure Rollback (Session : GNATCOLL.SQL.Sessions.Session\_Type) is Connection : GNATCOLL.SQL.Exec.Database\_Connection := Session.DB; begin Session.Rollback; Connection.Rollback; end Rollback; &amp;#x200B;
AH. open the Scenario View and make sure the variables are set there https://imgur.com/a/1tFBg6C
Ok. Now the build button gives me the same error as your gprbuild command. &amp;#x200B; gprbuild: could not locate library builder "/home/user/opt/gps/libexec/gprbuild/gprlib"
I don't know why your gprbuild is broken :/
Its not broken, its just not there. libexec folder is not there.
the correct path should be: ~/GNAT/2018/libexec/gprbuild/ you must have something wrong with your linux environment. Some env variable must be incorrect. 
path environments are: &amp;#x200B; export PATH=/home/user/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin:/usr/local/go/bin:/home/user/opt/GNAT/2018/bin:/home/user/opt/gps/bin
AWS is not the only web server. [http://forge.ada-ru.org/matreshka](http://forge.ada-ru.org/matreshka) (FastCGI and SpykeDog) [http://www.dmitry-kazakov.de/ada/components.htm#HTTP\_implementation](http://www.dmitry-kazakov.de/ada/components.htm#HTTP_implementation) (IIUC used in GNOGA)
You mean the GNAT folder or gps?
find where this is added and remove it: `/home/user/opt/gps/bin`
Perhaps I am starting GPS incorrectly. I go into the bin folder and run ./gps Is this right or should I be running something within the GNAT folder?
GPS comes packaged in the GNAT GPL I had you download earlier. there is no need to separately install them. In fact it might cause errors.
HAH! Got it. I had to run gps within the GNAT folder. I used doinstall and installed to a new gps folder. So Im guessing running doinstall is not needed?
I've never messed with doinstall before.
&gt; http://сыроедофф.рф that's the first ada web server I've seen in the wild. Congrats! :)
Depending on what you want to do, you might be interested by these technologies: * [Ada Database Objects](https://github.com/stcarrez/ada-ado) * [Ada Web Application](https://github.com/stcarrez/ada-awa) Moreover, you can look at the presentation of both of them at FOSDEM this year. * [Ada Database Objects presentation](https://peertube.social/videos/watch/1930a7bc-6416-4f24-b3e9-33c711717ed4) * [Ada Web Application presentation](https://peertube.social/videos/watch/b83e8c78-f3d6-4833-80fc-b73ec8ddbacf) &amp;#x200B; Both are distributed under Apache 2.0 licence but if think that AWA is using AWS underneath, so you'll have to check the constraints.
Well, [Ada-France](https://www.ada-france.org/adafr/index.html) is one of these too, as well as [the blog](https://blog.vacs.fr/vacs/) from the author of [Ada Web Application](https://github.com/stcarrez/ada-awa) :)
&gt;we can't override Image Fixed in Ada 202x http://www.ada-auth.org/standards/2xrm/html/RM-4-10.html &gt;A complete rewrite of the garbage that is GNAT/GCC-Ada with a toolchain and toolset that isn't as fragile as sugar glass. Well, if you gonna shit on GNAT at least be more specific.
There is PostgreSQL support in Matreshka library: http://forge.ada-ru.org/matreshka/wiki/SQL
\&gt; Well, if you gonna shit on GNAT at least be more specific. In general these interviews seem to be with the demographic that inhabits the comp.lang.\* newsgroups, which I hope isn't representative.
What’s that supposed to mean?
\&gt; How do you see the future of Ada? very bad... I'm hope it will changed, but it's difficult. Today there are a lot of hipsters, different narcissists, a lot of young people with very nonprofessional relation to IT and established IT practices. Haskell, Rust, Go - they are positioning itself for hipsters, with a lot of self-promotion, fakes, aggressively - what the author call "how to sell". Good example is Git. Microsoft (and Satya Nadella) decided to follow the fashion and trends and to buy GutHub due to this. Author mentioned bad "sell" strategy but true is that stupid majority defines agenda for all including smart minority :) It's true for politics, for anything. And if author things that Ada is good, he he can rightly wonder why no one else thinks so, and why they call Rust, Haskell "safe" languages ​​while they have a lot of problems (in stability, in standard, in predictability, in performance, in libraries, in readability, etc). It's not easy to sell Ada as hipster modern language IMHO ;)
Thank you so very much for your efforts and advocacy. I'm personally focused on the non-traditional applications in the more mainstream domains. Hopefully I can do my part there!
&gt;The truth isn't always nice. Ada is a niche language. It was designed that way, and only made more general later one. It's not surprising then that it still has niche use (for the most part). Could not disagree more, Ada is a very general-purpose language, and always has been. The original purpose of Ada was not safety-critical embedded - it was required that it could handle that, but it was not targeted at that. Ada was originally planned to be the ultimate languages for every single system in the US military - including administrative (office) things (which it was used for). Ada has continued to be general-purpose, and has only gotten more general (if anything), with very not-embedded feature-sets like containers and OS interfaces (file i/o). More recently, and undersold are the Ada 2012 user-defined indexing and iteration. This lets you do the things that popular languages like Java and Python let you do, like indexing an array with a string. &gt; "The FSF GCC compiler is excellent" Work on the Ada-tools project with me and find out how many faults in the toolchain I have to work around. It's a clusterfuck. Honestly, most times I've seen people complain about "bugs" in GNAT is when they are doing something extremely wrong - as in what they are trying to compile is not valid Ada. &gt; Unlike yourself, I'm actually doing something about it, not just bitching to others to do it for them. Over my time doing this I've spent the effort to find why people are drawn to Ada and what keeps them from using it professionally. It isn't what you think in most cases. What Ada needs isn't more advocacy. What Ada needs is more freely usable libraries and tools, better IDE support (there's a lot of complaints with GPS), more language/library bindings, and better educational resources. Plenty of people are aware of the language and its purported benefits. Plenty of people don't chose to use the language because of barriers to use. This is very uncalled for. We're working on a very large collection of high-quality packages we are going to be releasing as open-source. We've been working hard on these, I've been paying for a lot of work out of my own pocket as well. We're going to be releasing everything with a BSD license as well. I want things to be done well and ready to release. We don't jump the gun. Do not act like you're doing something about it and I'm not. That is really uncalled for. I'm glad you have a Youtube channel. I'm contributing in the way I think will bring the most value. Your attitude is not helpful. &amp;#x200B;
&gt;Honestly, most times I've seen people complain about "bugs" in GNAT is when they are doing something extremely wrong - as in what they are trying to compile is not valid Ada. Oh boii, I love when people pull this. I've seen everything from gnatclean deleting the installed libgnat files, to gprbuild not caring about pragma Wide\_Character\_Encoding(UTF8) or -gnatW8 when compiling binder generated files causing Unicode failures in Stand-Alone libraries, to ignorance about how Windows works causing Unicode failures with IO. Don't strawman me. I said there were issues with the *toolchain.* You then implied I didn't know how to write proper code and was blaming bugs on the *compiler.* &gt;We're working on a very large collection of high-quality packages we are going to be releasing as open-source. So you don't have anything you can prove this with? I've seen tons of vaporware in Ada over the years, and little reason to see differently. At the very least give some indication on what these packages will provide. Also, who's "we"? Out of nowhere you change from "I" to "we". Considering the language here implies a business backing this, what's the incentive? Other than AdaCore there just haven't really been any significant company backing of any Ada projects. And these are going to be freely released? How is there any benefit for a business to do this? It's not like Microsoft making some core stuff freely available, where the benefit is greater community trust and better image. I hope you understand my skepticism; this just doesn't add up. &gt;We've been working hard on these, I've been paying for a lot of work out of my own pocket as well. Yeah, me too. You didn't think I only did videos did you? Here's the repos: [https://github.com/Entomy?tab=repositories](https://github.com/Entomy?tab=repositories). Ada libraries, the most popular Ada extension for VS Code, and the large and growing collection of tooling for Ada that is Ada-tools. &gt;We're going to be releasing everything with a BSD license as well. I want things to be done well and ready to release. We don't jump the gun. Yeah but you haven't yet. I've already covered the issue here.
It means his discounting our opinions because of who he perceives us as. Which is hilarious because both of us aren't part of the comp.lang.\* newgroups. Hell I'm way too young for that shit.
Yeah, Ada ain't hip. Not by a long shot. While I'm sure it can grow in popularity if "sold" well, it's never going to become super popular for that reason. It's still and for men in suits. Cool kids don't do suits.
Discus flagged my two comments going into great detail on this as spam. They are being reviewed and when cleared will be up.
Thanks for your reply. I don't think that I'd emphasize guarantees. I find Ada a fun language to build programs with, and that comes from its support for expressing a design faithfully. I've thought that if I was given the opportunity to bring some of the C hackers around me into an Ada project, the first thing I'd point out is that, in Ada you define a lot of types: you have an A2D which outputs a 12 bit millivolt value, you define a type for that; you've got monetary values in different currencies, you define different types (even if they are all "new Integer"). All the diagrams of nested boxes with interfaces and internals are neatly mapped to package hierarchies. I don't think that I ever follow anything like a waterfall model; but rather design and code simultaneously, and Ada is even more helpful then. Using Integer and Float types and splitting things into a couple catchall package may be a starting point -- then refining the concepts and structures goes hand-in-hand with more precise type definitions and package organizations. The thing is, that I'm spending my effort thinking in terms of the problem I'm solving or functionality I want; clarifications of those connect easily to changes in the code, and Ada semantics regularly help in pointing out clarifications/distinctions that refine comprehension of the problem. Most often, the point at which I've understood the problem and the solution thoroughly, the code is close to a decent representation of that (modulo some ugliness hidden in private parts which I'll get back to) and when the program builds it is very close to working perfectly. I never have that experience with non-trivial C/C++ programs. I think that the better correctness/reliability of Ada programs derives from the expressiveness which helps programmers think/work closer to the problem space -- supported by the thoroughness and consistency of its static semantics (which took a huge leap forward with Ada 2012/SPARK 2014).
If it doesn’t have braces, it’s not hip. This stupidity does my head in.
"Based on our knowledge of processors, we can assume that in most cases floating point calculations will be slower than integer calculations." While this was true when floating-point was implemented in software, these days most processors have FPUs that operate in parallel with the CPU, resulting in floating-point operations that are as fast or faster than integer operations. It's curious to see this misconception still accepted and being spread when FPUs have been common for over 20 years.
&gt; Yeah but you haven't yet. I've already covered the issue here. We will. But I don't really need you to believe me - I have zero interest in proving anything to you. You've come in here with an extremely aggressive attitude, and have made a lot of incorrect assumptions about myself and my company, and you somehow think that it would be worth it for me to "prove" why you are wrong. I see no benefit to that, because you are not important by any metric. Nothing you think or say will change how we work or our own schedules. If you chose to believe that I am lying, I really could not possibly care less. I do not understand how your kind of anger and incredulity is helpful to anyone. It only makes you look bad. 
I assume you just add a if L = R then -- sort by other things here end; right before the other comparison
Inside the "&lt;" function you would do if L.Name /= R.Name return L.Name &lt; R. Name; end if; -- code for sorting by other things here
Thank you! 
You may have to place a Skip_Line right after the Get_Line. Try that.
I'm not getting a whole line, I'm only getting one integer at a time. 
&gt;How is the tooling? Support for IDEs, linting, IntelliSense, debugging, profiling. There are multiple compilers available, most of them cost money. I'm not going to mention commercial tools, since i dont really know much about them. GNAT is the only free compiler, it's maintained by AdaCore and it's part of gcc. So if you have installed gcc you probably have GNAT already. GNAT can do a lot of things, so linter is not really necessary. You can use gcc tools for debugging, profiling etc. There are free static analysis tools available like AdaControl. As for IDE: Adacore provides IDE called GPS. Adacore also works on [Ada Language Server](https://github.com/AdaCore/ada_language_server) and add-on for [IntelliJ](https://github.com/AdaCore/Ada-IntelliJ). There is also emacs ada-mode available. &gt;Are there package managers, or something to manage libs, like npm/yarn, cargo? Not that i know of. Since Ada is pretty niche language, there is not a lot of open source activity. You can make one :) &gt;From what I understood SPARK is a superset of Ada. Is the "Pro" version better, or has more features, or is it more secure? SPARK is a subset of Ada, but it also has features not yet available in Ada. Afaik (correct me if i'm wrong here), all of the SPARK toolset is available for free, you're probably talking about commercial versions of [GNAT](https://www.adacore.com/gnatpro/comparison). &gt;How's C FFI support? Ada has language defined interop with C, C++, Fortran and COBOL. GCC can generate ada spec files from c headers using -fdump-ada-spec switch. It's not perfect, so there are alternative tools available to do this: [headmaster](https://github.com/ytomino/headmaster) and [Cappulada](https://github.com/Componolit/Cappulada) &gt;Are there people using Ada/SPARK for things aside Avionics/Military? You can check out where it's used here: https://www.adacore.com/industries &gt;I say this because this language seems powerful to fill the voids that C and Rust, and maybe even Go in some aspects do. You're right, but due to historical reasons Ada become a niche language. It's hard to have hype for almost 40 years old language. Imo, Ada is better alternative to C in pretty much any case. I'm not going to compare it to Rust since i'm not that familiar with it but SPARK has rust-like pointers and there are proposals for Ada 202x to add them in Ada. As for Go: Ada has generics, i guess Ada wins here too :)
 &gt; * How is the tooling? Support for IDEs, linting, IntelliSense, debugging, profiling. Ada has not so great support for tooling, especially IDE's: * There is GPS, if you can put up with it. * There are two plugins for vscode I've only tried [one](https://marketplace.visualstudio.com/items?itemName=Entomy.ada) which has syntax highlighting and snippets, but no LSP. * There is [Visual Studio](https://marketplace.visualstudio.com/items?itemName=AlexGamper.VisualAda) integration, I've never used it. Ada is it's own linter, unlike other languages which require a linter, Ada picks up on errors for you. You won't get integrated debugging on anything other than GPS. There is only one open compiler for Ada, that's GNAT. There is gprof support built in because GNAT is based on gcc. Don't believe people who say there are multipole open compilers, there aren't, they all point to various versions of GNAT. &gt; * Are there package managers, or something to manage libs, like npm/yarn, cargo? There is an [attempt at one](https://github.com/alire-project/alr), I don't know how far it is or whether it's useable. &gt; * From what I understood SPARK is a superset of Ada. Is the "Pro" version better, or has more features, or is it more secure? It's more of a supersubset. SPARK is a subset but then adds more pragmas. The "pro" version just means paid support and more up to date sources. &gt; * How's C FFI support? Excellent, see [Appendix B](http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-TOC.html) to see what languages are defined to be interoperable. &gt; * Are there people using Ada/SPARK for things aside Avionics/Military? I say this because this language seems powerful to fill the voids that C and Rust, and maybe even Go in some aspects do. Ada was commissioned, not designed, by the US DoD, to replace all the languages they were using at the time, it was designed to be used in pretty much anything. It's used more in aerospace, transport (trains, cars) and military now. C is a bad language to choose, it's way too dangerous. Rust only really adds the pointer borrowing stuff, Ada doesn't have that, but it does have more things going for it. People will bring up arenas wrt Rust, but Ada already has that, had it since Ada95, I think, they're called pools. &gt; * Last but not least, how are the job prospects in the field? If you want to get into the above areas, pretty good I'd say. Anything else, nope. &gt; I know some of these could have been answered by googling, but I wanted to hear your opinions about them instead :) You should read [these interviews](https://tomekw.com/tag/interview/) for a better overview, they're linked to in this reddit. 
&gt; There are two plugins for vscode I've only tried one which has syntax highlighting and snippets, but no LSP. AdaCore is working on Ada LSP. It's pretty usable already, works better than other VS Code extensions. 
&gt; Tooling Mixed. The compilers are great. The rest of the tooling is dated, but reliable in most cases. For example, GDB feels like something out of the 80's, but it does work reliably. Some other tooling isn't so reliable, or at least I've had bad experiences with it. &gt; Package Managers? I'm working on it. I've got the actual packaging and installation working. Started work on package distribution. But it's not even ready for a beta release yet (maybe in two months) &gt; Spark It's like an isoset… paraset… however you want to phrase that. It both adds some stuff, like contracts, and removes certain things that are hard to prove. At this point, SPARK has been directly integrated into the language, but it was formerly done in special comments. &gt; FFI Amazing. Absolutely amazing. FFI's to C, COBOL, and FORTRAN are part of the standard and directly integrated into the language. I've never seen such a great way of doing FFI's. &gt; The rest Meh.
They got a demo or anything?
https://github.com/AdaCore/ada_language_server
There's at least two attempts at a package manager. I've got one. Right now it packages and installs. Working on package distribution now. And yes it's cross platform.
It would help *a lot* if you gave an example of the sort of input you expect and what you want to happen to it.
[AdaCore is taking steps to fix this travesty!](https://blog.adacore.com/a-modern-syntax-for-ada)
Thank you!
Hey! Finally an excuse to break out [Compiler Explorer for Ada](https://ada.godbolt.org/z/7s0y_g)! Unfortunately, the example you gave optimizes everything out quite quickly, because there's no side effects. Regardless, remember that the *compiler* has no way to know that `size` is 1, not at this point. Anything could be passed in, and the compiler has to account for that. I'd try a different example in Compiler Explorer, but it's too new and has too many limitations right now. But the answer is that yes, it seems to take into account the range of the type in optimizations, when that size can be known at compile time.
I'm not sure why do you think it's should be optimized. Natural has 0 .. integer'last range, so size CAN be 1, 2, 3 etc (It can also be 0, which is a bug in your code :) ). GCC will try to eliminate unnecessary code, including loops and if statements, but it needs to be 100% sure it can do it. If you just compile this procedure alone compiler has no idea how it's used, so it has to make this loop. Try calling hello(1, 32) from another function.
&gt; the example you gave optimizes everything out quite quickly I know, I tested with making some side effects, of course, I just wanted to keep the example minimal. Here is a "working" one: https://ada.godbolt.org/z/n_gNrb. &gt; compiler has no way to know that `size` is 1 Why? What do you mean? It would be just a condition before everything else in that `begin..end` block. If `size` would be a compile time constant, I'm sure compiler would remove/unroll loops for small `size`-s. So it could generate all these or the most possible code pathes (where it worth the optimization), then executes the proper one at runtime.
Why can't it be 100% sure if \`size == 1\`, then loops could be unrolled, especially if I do very little work in the body (and the whole function is performance critical)? For higher values I don't care. If I call \`hello(1, 32)\`, I want \`size\` be 1, and want loops running only once. I don't understand your point.
&gt; Why? What do you mean? The compiler only knows that some value is passed in for `size`. It might know some restrictions on the range of that parameter, but it can't know the actual value since it's not determined until runtime. What it *could* do is an optimization called "code specialization" (and a few other names, IIRC) and I think that's what you're getting at. The technique is sometimes used for runtime optimization in languages that are JIT compiled: they can detect when a block of code is run with certain input values and create a specially optimized version of that code using those specific values. Then, the original is modified to check if those are the values passed in and use the specialization if possible. This can also be done at compile time, and I think some profile-guided optimizers will do this. I've never seen it done in Ada, but I don't see why it couldn't be, even based on a type's attributes. But I don't think your example lends itself to this sort of optimization. It's hard to know if any performance gains from specialization are worth the cost of an extra compare and branch (something that has to happen anyway to handle the loop iteration), so that's not an optimization that's going to happen automatically.
April fool!!!
I can see this happening if `hello()` was inlined.
General structure of every "&lt;": &amp;#x200B; `if Left.First_Field &lt; Right.First_Field then` `return True;` `elsif Right.First_Field &lt; Left.First_Field then` `return False;` `elsif Left.Second_Field &lt; Right.Second_Field then` `return True;` `elsif Right.Second_Field &lt; Left.Second_Field then` `return False;` `-- ...` `else` `return Left.Last_Field &lt; Right.Last_Field;` `end if;`
Thanks!
[Click the stackoverflow link](http://lmgtfy.com/?q=ada+gtk)
I've never used it and don't know of any simple examples, but AdaCore's GPS IDE uses GTKAda: https://github.com/AdaCore/gps It's a pretty big program. Searching for `with Gtk` produced a bunch of different usage examples, so you can probably find examples of what you're looking for: https://github.com/AdaCore/gps/search?p=2&amp;q=%22with+Gtk%22&amp;unscoped_q=%22with+Gtk%22 
Here are some projects: [https://github.com/YruamaLairba/gtkada-minesweeper](https://github.com/YruamaLairba/gtkada-minesweeper) [https://github.com/berriedale/arun](https://github.com/berriedale/arun) [https://github.com/thindil/steamsky](https://github.com/thindil/steamsky) &amp;#x200B;
AFAIK you can’t. You’ll have to use Ada.Strings to remove the white space. 
How do I do that?
Post the code of what you've done.
I figured it out. I just needed to do put(variable, 0); instead of put(variable)
[removed]
[removed]
Wrong sub
If you think i posted wrong forum, i am going to post others until i find right forum to sort this dispute
Thanks for telling me that i posted a wrong forum, i will find right one to complaint
This sub is for Ada programming language, read sidebar.
thanks &amp;#x200B;
Thanks for sharing! The interviews are really interesting!
Thank you!
Wikipedia link is broken
iOS development is possible with AdaMagic. Hard like Android - yes, unavailable - no.
ObjectAda also pretends to be Ada 2012 now
What do the recipients of a one-shot message make of the count?
Glad you got it, but you could always just write your own "img" function or use use a trimming function in Ada.strings.fixed.
Thanks very much! Very instructive and helpful resources!
Use a custom function -- Type Die is range 1..6; Function Image( Object : Die ) return String is Temp : String renames Die'Image( Object ); Subtype Tail is Positive range Positive'Succ(Temp'First) .. Temp'Last; Begin Return Result : String := Temp( Tail ); End Image; 
Nice write-up.
And where do you get adamagic? Afaik it’s a d’acore and it costs, therefore unavailable.
[removed]
In my experience, there is usually time for a lot of talking, and time for a lot of work, not usually time for both. Ada, being proven and very effective in practice, is a language for getting real stuff done. Rust and Haskell are languages good for selling-out crowds at StartupCon 2020. The reality is, there are always the showboats with a following of blindly loyal fans, and there are always the quiet people behind the scenes making an actual difference. Ada is the latter, and that is ok. Ada has probably saved real lives, possibly thousands of them. Rust and Haskell will probably never have that pedigree. I'd be more worried about Ada getting corrupted with fashion than I'd be worried about it dying.
thank you for this interesting interview. Section "**How do you see the future of Ada?"** is very good and accurate :)
Interesting, I'd love to know his (or other ADA enthusiasts) views on ML or haskell (or even clojure). Saying this after reading rosetta code samples and seeing how lovely haskell solutions were to see.
Not on Github, but there's a GTKAda version of Mine\_Detector at [Mine Detector](https://pragmada.x10hosting.com/mindet.html) (The Gnoga version is on Github.)
One way is to use an instantiation of Ada.Text\_IO.Integer\_IO; the Put procedures have a Width parameter that can be zero, in which case you'll get the image with no leading space (this appears to be what you did. Another way is to use one of the many libraries out there that have already addressed this. For example, the package PragmARC.Images from the PragmAda Reusable Components has Image functions that will do what you want. This can be useful if you need to obtain a String with the image rather than just outputting it. [PragmAda Reusable Components](https://github.com/jrcarter/PragmARC)
RufasCube, a 3D puzzle written in Ada, has now been updated to use OpenGLAda 0.7.0: &amp;#x200B; [https://github.com/fastrgv/RufasCube](https://github.com/fastrgv/RufasCube)
your link with [learan.pl](https://learan.pl) gives me 404. What is the matrix?
Ok, I was added second link this should works on 100% (you may have problems because [www.laeran.pl](https://www.laeran.pl) is ipv6 only). Matrix is communicating protocol, like Jabber, IRC or Telegram. I was linked Wikipedia article about Matrix too :)
BTW, here is the Electronic Design article by the same person who will do the presentation at TCF 2019 [https://www.electronicdesign.com/embedded-revolution/explicit-embedded-programming-trenton-computer-festival](https://www.electronicdesign.com/embedded-revolution/explicit-embedded-programming-trenton-computer-festival)
Could you provide at least the location ?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/spark] [Building Better and Safer Programs Using SPARK and Ada (a Trenton Computer Festival 2019 presentation)](https://www.reddit.com/r/spark/comments/b0kl3r/building_better_and_safer_programs_using_spark/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
"Ghost code" is a pretty cool feature. Just looking at Ada.
That's a bug in the compiler. Works as it should here (GNAT Pro 20.0w (20190217).
FSF GNAT 8.3 prints false, true. No warning though.
As a student in a comparative programming languages course, your extension is a godsend, keep up the good work!
I like the idea, but I don't understand where to join the discussion.
I'm afraid, at this moment it is available only in this pad. This is Cranix idea and as far I know he don't have Reddit account. I'm just trying to help him, because I like this idea either. If you have any proposition when we can discuss it, feel free to add it there :) Or do like people on IRC: they give own propositions and corrections on IRC and we are updating this pad :) So, if anyone have any suggestions, complains, etc can write here in this topic too and I will update pad.
You did not mention which version of GNAT was used. With GNAT Community 2018 (20180523-73) running on Windows, the expected results were printed correctly as shown below. By the way, you also forgot to include with Ada.Text\_Io; use Ada.Text\_Io in your post. False True Anh Vo
I am on IRC from time to time, but I miss this discussion (Cranix should really get a reddit account :) At least I'd like to attend, and maybe do a short presentation on embedded Ada. 
If I remember correctly, this discussion started around 1 month ago on IRC and going very slowly forward. It appear from time to time on IRC if someone read pad and have questions or propositions. You can always discuss in this pad, it's chat, give your propositions here or on IRC and we just add them to pad :) Maybe more people will read it and join the discussion then.
\&gt; Ada, named after Ada Lovelace am I right that initially the language was called "Green"?
Yes it was first Green
so.... this is the reason why subreddit is green? :)
And it is never mentioned by Rust proponents. Came to this observation after watching and reading 30+ hours of Rust videos and articles. 