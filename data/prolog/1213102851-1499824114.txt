&gt; certain mathematical symbols are not displayed &gt; correctly, including &gt; &gt; * ⊢ displayed as | &gt; * ⊬ displayed as |;/ &gt; * ⊨ displayed as = &gt; * ⊭ displayed as =;/ I'm curious as to why this can't be fixed with sed.
Great ebook; the link off of reddit seems to be dead, so [here's](http://www.dblab.ntua.gr/~george/languages/books/WAMbook/) another.
wow; looking at it, makes me want to buy it - counter-intuitive, but it's hard to read on the web. 
[Download link for a zip file containing the HTML version of the book and source code](ftp://ftp.amzi.com/share/xsip.zip) [The PDF version](ftp://ftp.amzi.com/share/xsip_pdf.zip) [Page where I found the links, has other prolog stuff too](http://www.amzi.com/products/learning_products.htm)
This is about declarative programming with state: The tutorial is a good start, I stumbled on this page after finding EDCG's by PVR http://www.info.ucl.ac.be/~pvr/edcg.html And saw that with EDCG's I could augment my current parser by adding new accumulators for debugging information, but wouldn't have to do so at the expense of clarity. Logical state threads build on this, and allow you to augment dcgs with named arguments with defined operators. Check out this calculator written as a logical state thread: :- ensure_loaded( library(threads) ). :- thread( stack, [push,pop], [] ). :- thread_method( push(X), Old, New, New = [X|Old] ). :- thread_method( pop(X), Old, New, Old = [X|New] ). :- thread_pred( expression/0, [stack,dcg] ). :- thread_pred( term/0, [stack,dcg] ). :- thread_pred( factor/0, [stack,dcg] ). eval(Exp,Result) :-- ( expression, stack::pop(Result) ) with (dcg(Exp),stack). expression --&gt;&gt; term, [+], expression, stack::pop(X), % The expression. stack::pop(Y), % The term. Result is X + Y, stack::push(Result). expression --&gt;&gt; term. term --&gt;&gt; factor, [*], term, stack::pop(X), % The term. stack::pop(Y), % The factor. Result is X * Y, stack::push(Result). term --&gt;&gt; factor. factor --&gt;&gt; ['('], expression, [')']. factor --&gt;&gt; [X], number(X), stack::push(X).
http://github.com/tef/nomads/tree/master I've ported it to swi prolog
I am working on a rather large project based heavily on Prolog and we use SWI Prolog. It might not be THE fastest out there , but the GUI Tracer alone makes it woth it.
50$ on Prolog
I admit I haven't read the linked thesis, but some notes from practical experience rather than theory: * A basic understanding of Prolog is necessary to avoid writing hideously inefficient programs. Often naive users will write these and then conclude prolog is slow * For many of the tasks I encounter, the simplest possible prolog implementation often out-performs the nearest equivalent Java or Perl implementations * You can probably always write a faster C program yourself, but the program may be several orders of magnitude larger, harder to extend, maintain, etc. This point holds especially if you are using more expressive LPs, e.g. answer-set programming. * Whilst SWI-Prolog may not be the fastest prolog, the fact that unbounded integer support is built in allows for some neat tricks - see http://blipkit.wordpress.com/2009/05/19/swi-prolog-gmp-rocks/ * For data-oriented tasks, SQL may be a more meaningful point of comparison, as many imperative programs offload heavy-duty processing here. SQL is more declarative than (non-pure) prolog and is typically the fastest way of doing certain kinds of queries on large data. However, prolog's mix of declarative and imperative means it's sometimes possible to fine tune complex queries to be faster than SQL. And prolog and RDBMSs can work well together. 
Moved [here](http://cs.union.edu/~striegnk/courses/nlp-with-prolog/html).
Try using it with threads. :( 
There is a type on the link to the functor_constraints.pl it should be: http://www.cs.kuleuven.be/~toms/PrologTypes/functor_constraint.pl
Because it didn't make the cut?
I see what you did there, !
no
good article. Let's not forget that prolog is still very slow, and it is only relatively recently that good free mature implementations exist. 
I think Sicstus Prolog is pretty darn fast, actually, but I don't know about other implementations
Sicstus being the best implementation by far, especially until recently, has had a weird effect overall, I think. It's good but very expensive, which led to Prolog being a bigger deal in places where the expense didn't matter as much, and harder to use outside those places. Even a personal license, which prohibits distribution of applications, is €155, an academic license that allows distribution is €1560, and commercial prices go up from there. Those aren't absurd prices by the standards of something like Visual Studio, but they do hinder adoption by independent tinkerers, who are often the early adopters of new languages (and good advocates for them).
I would not say that Prolog is slow at all. It depends on what kind of problem you are trying to solve. I wouldn't do image manipulation in Prolog but ,lets say for text transformation it is very fast. For example XSLT is a pain in the ass compared to some transformation frameworks based on Prolog. The real problem is the one of the first things you are told when starting CS is that an algorithm is a list of steps the computer has to take inorder to solve a problem. And then, much later you meet prolog, and you just dont get it.
Pyke introduces a form of Logic Programming (inspired by Prolog) to the Python community by providing a knowledge-based inference engine (expert system) written in 100% Python. Unlike Prolog, Pyke integrates with Python allowing you to invoke Pyke from Python and intermingle Python statements and expressions within your expert system rules. 
Putting the functionality in libraries or making it part of the language does not have be any different from the end-programmer perspective; it all depends on how powerfull the host language is. In Haskell, there really is no need to bake prolog in. Many usefull constructs from loops to monads are not part of the language either; just part of the libraries. In Java on the other end, it's nearly impossible to offer the constructs of prolog in a way that uses the actual type system, and offers a similar syntax. 
So Haskell replicates all of Prolog's functionality?
[Mercury](http://www.mercury.csse.unimelb.edu.au/) replicates all of Prolog's functionality, but was designed in such a way so as to allow good static analysis and therefore great performance. [Erlang](http://www.erlang.org/) was originally written in Prolog and thus has a similar syntax and behaviour, but they have sadly removed backtracking. NFA regular expressions can also handle much of Prolog's behaviour. I once wrote [a minimalistic logic programming implementation using Perl's regex engine](http://www.perlmonks.org/?node_id=318350). Unfortunately, because Perl's regex engine is not reentrant, I had to rely on forking and it slowed it down the point of being unusable. I may try this again with Ruby's regex engine as I hear it's reentrant. Oh, and of course SQL can handle much of this (and more!), but since it doesn't handle lists well and sucks at recursion, not many people try this route.
No it doesn't. However the monad functionality on lists is interesting, because it essentially backtracks. For example, this function returns all pairs of integers that sum to 10. becomes10 :: [(Int, Int)] becomes10 = do a &lt;- [1..10] b &lt;- [1..10] guard ( a + b == 10 ) return (a,b) The only thing missing is unification. Now you could use some sort of dictionairy for that. And honestly, it wouldn't be any less type safe than plain prolog, but it feel less pretty, relationship names would be encoded by string. Yuck. And when using Haskell it's a shame to throw away the type safety. Haskell does do one-way unification out of the box. One way is just called pattern matching. And since the list monad (which is just provided by library functions) is essentially backtracking, many kind of puzzles are as easy to solve in Haskell. The freedom of unification is sort of red herring in Prolog anyway; since prolog does enforce sequentially. If you formulate your correct logical reasoning incorrectly, it might use way too much memory or never stop. In prolog they enforce the order of execution by looking at the order of the code. A functional language like Haskell enforces it by the direction of unification. It keeps resolving the left hand side to the right hand side. 
No. You have to program it. Your question indicates that you will need to ask many more questions. Do you only know Prolog or only other languages? If you only know other languages, pick up a used copy of "The Art of Prolog" or "Prolog Programming for Artificial Intelligence". Remeber that second editions exist to make first editions affordable. 
Oh, and as for a language that truly combines Haskell with Logic programming and full unification, there is curry: http://www-ps.informatik.uni-kiel.de/currywiki/ Which is quite interesting. Because Haskell allows us to express imperative programming using monads, and the logic part of curry allows you to reverse execution order. So you can take an imperative algorithm, write it as a haskell monad, and then ask Curry given this 'result', what possible inputs were there. Other multi paradigm languages where that kind of stuff is truly baked in are Oz. http://www.mozart-oz.org/ The thing is, most people dont' just want backtracking and simple unification. To solve actual real life puzzles, we actually go to real CSP support. (constraint satisfaction programming). Because prolog just forces one specific, quite brute force way, that just doesn't scale up with a large class of problems. Curry does linear constraints, Oz does them all. 
And the issue with Haskell where it gets more dirty, is that you would have to encode free variables some way. (they can't look like normal variables). Imagine using a language where there is no typing, like Lisp. In Lisp you can write a prolog interpreter and then provide it with prolog code that will look extremely native. That is: not more or less native then the rest of the lisp code. Does Lisp replace all of prolog's functionality? No, none of it. But this is a valid lisp expression: ( brother X Y := father X , father Y ) So, write a prolog interpreter (which isn't that hard actually), and put it in a library, and suddenly you are mixing and matching prolog code and other style code. Languages like Lisp (untyped) and Haskell (typed) they don't offer ANY constructs out of the box. They offer just the minimum needed for a turing machiene. The rest is all in libraries. It's all custom code written in Haskell or LISP. From looping constructs in Haskell to object-oriented programming in LISP, it's all done through external libraries. Some languages are made to be so strong that you can use any paradigm with them. Those set actually includes _javascript_. Javascript gives a programmer 'enum', and full access to the original javascript code of a function. You can literally take a function as input, parse it, rewrite it, In other words, it is theoretically possible to have a javascript function that given another javascript function, it will return an object, where you can assign legal values to both input and/or output, and query a list of possible values for the remaining free variables. 
In AI class, we focused a lot on search algorithms. Depth first search, iterative deepening depth-first search, bidirectional, etc. Does Prolog allow for sophisticated search algorithms, or rather, does Prolog make the encoding of such algorithms simple? Does Mercury?
See also, http://www.cs.toronto.edu/cogrobo/main/systems/index.html http://www.cs.toronto.edu/cogrobo/kia/ it was a trick, Golog isn't Prolog but a logic language for agents.
I did that course at Edinburgh University with Chris Mellish in 1992 - he was the third year AI course co-ordinator IIRC. Can't say I remember much of it now though, I might set aside a few hours to review this over the weekend :)
It might help if you paste some of what you have so far.
Same, paste your code and I'll try to help you.
I think what you want is findall/3 which generates a list of all solutions in one list rather than each one individually.
I cannot use findall because it generates new variables whenever it finds a anonymous one. (Which is bad because I want to apply finite domain constraints). Any ideas? Edit: I think I got it now. What I needed was the ( ^ )/2 operator.
Looks like it uses SWI-Prolog. I have never actually compiled code with SWI-Prolog though... what comes out? An exe with the interpreter embedded? Or is it real live machine code that nokia can use on the target platform? 
Looks like `save-lisp-and-die`: http://www.swi-prolog.org/pldoc/doc_for?object=section(2,'2.10',swi('/doc/Manual/compilation.html'))
Any idea why core.logic from clojure is missing from this list? It's based on Kanren, which was implemented in Scheme.
Just guessing: the article lists logic programming **languages** for the JVM, while core.logic is a **library** for a JVM language.
Fair enough, guess I didn't read all that closely.
I don't use Aquamacs, but there's a [homebrew](http://mxcl.github.com/homebrew/) package for swi that I've used a few times.
swi-prolog package in macports?
I always installed it using MacPorts, the swi-prolog package. After that, I started it with the swipl command. As for integrating it with Aquamacs, I have no idea. Look into how you can do SWI Prolog integration in Emacs and perhaps adapt it for Aquamacs (which should be basically the same, I guess).
Thanks for the input fellas, I think I got it figured out now, just need to make it load swi on automatically. Thanks
You should post back with your solution!
lovely programs. I am crossposting to /r/sysor as there are loads of cool optimization programs there 
I too have never used this. So I queried "freeze example" on comp.lang.prolog and came up with - (https://groups.google.com/group/comp.lang.prolog/browse_thread/thread/73655b88993c11b7/53768415bee6e727?lnk=gst&amp;q=freeze+example) there are some good examples in there (from 1990!).
article to go with gist, http://www.playwithlua.com/?p=5
Two classic books are *The Art of Prolog* and *The Craft of Prolog*
The Craft of Prolog is a great recommendation. It has aged a little bit but still remains a good read. Also, check out the author, Richard O'Keefe's website, which contains lots of other great code samples - http://www.cs.otago.ac.nz/staffpriv/ok/software.htm
I learnt a lot with Dennis Merritt's Building Expert Systems in Prolog: www.inf.fu-berlin.de/lehre/SS08/KI/merritt.pdf Also, for non logic related development with prolog Jan Wielemaker's thesis is fairly good www.swi-prolog.org/download/publications/jan-phd.pdf And of course, SWI-Prolog publication area is a must check: http://www.swi-prolog.org/Publications.html)
There's also *The Practice of Prolog* ( articles about real world applications of Prolog) collated by one of the authors of The Art of Prolog.
Does anyone have a copy of the paper "Question Analysis: How Watson Reads a Clue." listed here?
Here's how I'd solve it (I'm just a beginner too but I've written lots of little play scripts like this) Copy the head of L1 up to N to L2 maybe by counting down N. One predicate. x(N,[L1H|L1T],[L1H|L2T]) :- ... Unify L2 with two copies of the head of L1. One more predicate. Alter the termination condition to fill the rest of the list.
This seems like a nice little exercise - you'll never be any good at prolog unless you learn how to think stuff like this out yourself, so I think it might be unwise to ask for too much help. If your exams are any good you'll probably be asked to solve a couple of problems like this in them -which means you better have an actual understanding of the solution! I'd write it as two cases; one for finding the correct position and one for stopping and constructing the base of the answer ;)
Thanks so much for helping me, that really helped, I'm very new to Prolog. =)
You probably ought to do it with multiplication and addition if you want to "concatenate" like that. Like A*10+B.
Check my variation of his/her solution if you want to get to know Prologs resolution engine better.
I don't see anything wrong with it, it's working ok on my PC.
The question was rhetorical and meant something along the lines of "Why didn't you write it like this instead?"
 map2list(Pred, [H1|T1], [H2|T2], [H3|T3]) :- Pred(H1, H2, H3), map2list(Pred, T1, T2, T3). map2list(_, [], _, []). map2list(_, _, [], []). :- map2list(atom_concat, [1, 2, 3], [4, 5, 6], Output). Ought to do the trick. (not tested)
Maybe a bit late, but here is how I'd tackle it. First build a predicate that takes a list, and copies it element by element from L1 to L2. So you have it performing a single copy in the rule as it processes. Then I'd add in the N value, so it's passed through all your rules. Don't bother doing anything with it, or changing it, just alter your predicate so it's there and passed along on each call. Now you add the duplicate bit. I'd have N count down as you go from predicate to predicate, across the list, so subtract 1 each time. Work out what the value needs to get to for it to duplicate that element. Now you just need to add another rule to do a double copy when N reaches that value, and the normal single copy every other time. You should now be done.
Sorry I was being stupid: mem(X, Y) :- append(_, [X|_], Y). works.
Please tell me this isn't the coolest thing you've ever seen... If you're into programming, ai, machine q &amp; a, watson, siri, wolfgram alpha, etc...
I'm not an expert on prolog or rdf, but yes the principles are the same. There is a continuity between databases and logic system, like in sql -&gt; datalog -&gt; prolog. The idea is to store entities and the relations between them, and have a way to query them. In prolog you have the possibility to add a relation between any number of atoms, while in RDF a fact is made only by a subject, a predicate, and an object. This has some nice propreties, like that now the knowledge base is essentially a directed graph (where relations are the edges), so every query is translated to a graph traversal. If you remeber, in prolog the order of rules matters and someone can create a query that loops forever. This is not good for a database, so SPARQL and DATALOG are designed to guarantee that every query completes.
Prolog is more expressive than SPARQL and RDF. For instance you can work with lists in Prolog. Prolog is also a functional programming language in itself. Both the syntax for stating rules, facts and querying the knowledge base are the same in Prolog, which I cannot say of SPARQL+RDF. Furthermore, RDF was designed with the intention of making distributed knowledge bases. For example, in my thesis project, I'm building an ontology of object descriptions. I can attach those description to classes defined in another, separate ontology. You can use RDF with Prolog, of course. 
The usual way is to use a DCG (Definite Clause Grammar). If you can get "The Art of Prolog" from the library there is a nice example almost equal to your problem. 
I recommend Blackburn and Bos on computational semantics. It uses Prolog as the language of choice. DCG syntax is almost identical to the production rules you used. However if you need more than just the parser telling you whether the parse was successful, you will need to carry around some structures to accumulate the parsed components. I don't recall if the "Art of Prolog" go into it that much, but it is certainly the focus of B&amp;B's book. And oh, SWI Prolog's http lib has a "dcg_basics.pl" module that you should check out. You should get the hang pretty fast by just studying that module.
Did something similar in my logic programming course a year ago. http://pastebin.com/dTfBctB4 
Aha... PL/0 ... I'm actually doing some hacking on someone else's PL/0 toolset in python: https://github.com/tangentstorm/PL0-Language-Tools You might find this online book helpful: http://www.learnprolognow.org/lpnpage.php?pageid=online See chapters 7 and 8.
&gt; I've got it working nicely. Right ;) It depends on what is the purpose of the exercise. You need to keep a mapping from the clear letters to the encrypted letters. Probably the intention is that you do this using a list for the clear letters, other for the encrypted letters and that you go through the clear text, and through the mapping, using recursion. If this were not an exercise you would have more options. The mapping could be kept in a list of pairs (like the library(pairs) in SWI-Prolog), a binary tree (library(assoc)), or in a predicate that you assert in the database, and the encryption could be done with maplist (library(apply)).
I'm fairly new to prolog myself, but I think I can help you out here. Curiously, your last example is working fine for me on swi-prolog. I'm not sure what's up with that. However, my understanding is that the following is more idiomatic: last(Y, [Y]). last(Y, [_|Tail]):- last(Y, Tail). When a predicate is called, any variables get unified with values that can solve the goal being pursued, and the same variable get instantiated with the same value. So, in the first clause, Y will be set to the same value, eliminating the need to "carry it over" from the second argument to the first through an intermediary variable, X. Also, the underscore in the second clause is used for singleton variables (this is, at least, how it works in swi-prolog), which is useful since it lets you mark variables that don't need to be dealt with. I like to make all my declarations really explicit, so I'd write this predicate thus: last(Last, [Last]). last(Last, [_Head|Tail]):- last(Last, Tail). I hope that helps and that my terminology is correct.
I don't think you're looking at it at the right perspective. Like abathologist said, the variable "x" shouldn't be *set*, it should be *unified*. In other words, Prolog will *find* for you the value of "x" that makes the predicate true, you aren't setting it yourself. Keeping this in mind, you want to set up the predicate such that it'll be true when both the first argument and singleton element of the list are the same, and then Prolog will unify "x" to the argument you want, and print out what it found.
is/2 evaluates its right argument as an arithmetic expression, and unifies it with its left argument. In your example, Y will be 'you', which is not an arithmetic expression. So is/2 is not happy. Just put X = Y. If I may add a little optimisation trick, you should put a cut '!' in your first clause, because [Y] unifies with [Y | Tail]. And Y is a singleton variable in the second clause, but the compiler will tell you. 
Thanks for sharing these resources. I've been peeking at *Artificial Intelligence through Prolog* in spare moments, it looks very interesting and I'm excited to get further into it. Do you recommend any one of these works in particular?
try the installers for swi-prolog n mac which you can find here http://www.swi-prolog.org/download/stable as for how to program in prolog I recommend Learn Prolog Now! an online free version of which can be found here http://www.learnprolognow.org/ 
Sadly, not much seems to be happening with the Mercury language, if I've understood things correctly? I got the feeling, when looking the project and forums over, that it had kind of stalled... or? At my job we're very interested in efficient prolog-like languages, as we currently make business-logic systems with Prolog, but would really like to get better integration towards the .Net world (and others) If Elixir is based on Erlang, that's also a problem, as it seems Erlang is not super-happy with connecting to .Net and using .Net datatypes. We take massive calls - up to 5 meg, with information about loans, securities and stuff, and translating and making all that information available to Prolog (we use Sicstus Prolog) is a major drag on our execution time. Right now I'm working on building a system which translates our Prolog-based logic-model specifications into C#, based on the use of "Yield Prolog"; a way to emulate Prolog behaviour in C#.. pretty damn clever guys who wrote that - just hope I can make it work :)
I thought Mercury was still being developed, albeit slowly.
I don't know - it's just the impression I got from the forums and other visible activity.. maybe they've changed forum or something..
There is also the nascent [Picat](http://www.picat-lang.org/).
Another candidate is Oz (http://www.mozart-oz.org/)
Check out the Lambda Prolog implementation [Teyjus](http://teyjus.cs.umn.edu/)
Would [this: Using Elixir to write RabbitMQ Plugins](http://www.rabbitmq.com/blog/2013/06/03/using-elixir-to-write-rabbitmq-plugins/) help? (Or maybe there is a way to do this in Sicstus). Along with [Using RabbitMQ with C# and .NET](http://www.codethinked.com/using-rabbitmq-with-c-and-net)? The Rabbit MQ server is written in Erlang. 
Also [Caledon!](https://github.com/mmirman/caledon)
There is a larger png and a PDF version in the source tree under man/figs. http://www.swi-prolog.org/git/pl.git/tree/HEAD:/man/figs
Apparently a new version was released in June, and a windows binary a few weeks ago: http://www.mercurylang.org/ I searched the mercury site for .Net, just for kicks, and it looks like the developers have put a bit of thought into integration: https://www.google.com/search?q=.Net&amp;sitesearch=mercurylang.org I find Mercury very interesting, but I'm just a hobbyist and still cutting my teeth on Prolog with swi-prolog, so I guess I'm a long way from trying something like Mercury or Curry.
Interesting! He seems to be - or to have been - quite passionate about Prolog: both of these books have a section devoted to justifying its usage over conventional languages. Did that come through in his course?
The questions can be downloaded from [the contest's webpage](http://people.cs.kuleuven.be/~bart.demoen/PrologProgrammingContests/Contest2013.html).
Nice write-up, but am I missing sth.? 4*8=48?!?
It seems to me that the speaker may suggest that forall/3 is a 'yucky feature' of prolog. Am I reading that right, or does the irony go the other way here? It it is considered a yucky feature, can anyone help explain why that is? I've done a bit of searching, but haven't found anything clear on the matter...
I think you mean *findall/3* (not *forall/3*) and I believe the irony does go the other way here: you can find *findall/3* being used in the solutions for the previous contests. It's not part of the pure subset of Prolog, obviously, but it's not considered anywhere near as "yucky" as the dynamic database predicates or other side-effecting predicates Prolog systems may provide and, unlike them, it is indispensable for practical Prolog programming.
I don't get it either. The third question suggests he is talking about 6*8=48, but I can't see why the same typo ("4" instead of "6") would happen twice.
Never looked closely at it, actually, though we've been looking around for prolog:ish alternatives. The most important thing for us has become good integration with .Net - so much so that I've started rolling my own "prolog" in C#, based on Yield Prolog techniques :)
This idea from [Yield Prolog](http://yieldprolog.sourceforge.net/) of implementing backtracking using iterators is really nice, isn't it? There was some talk recently on the SWI-Prolog mailing list about the potential utility of a Prolog-in-JavaScript. Now that almost every browser supports "yield" in JavaScript **(edit: [wrong](http://kangax.github.io/es5-compat-table/es6/))**, if one wanted to implement a complete and fairly SWI-compatible Prolog implementation in JS, this might be a good way to do it. It would be great if you are able to open source your C#-implemented Prolog-like! Personally, I'd love to play around with such a thing in Unity if it is compatible.
As far as I can tell, the backtracking emulation works perfectly. Have a look at the examples; yield prolog seems very usable as is - there are several different ways to use it, and they are worth looking at. Myself I don't even want to write the Prolog code, as we're making a system for business rules which we need to integrate very closely with "normal" c# code. We draw the rules in a visio-like system, and then we generate the prolog emulating c# code directly from the drawings, customized to integrate with the rest of our system, and compile it directly into a dll. We're using some classes and many methodologies from YP, but control everything ourselves. It's not that mindboggling once you get used to YP's way of thinking, but writing the y# code manually seemed tedious. I hope we'll release some kind of free, limited trial that would work for smaller solutions - that would be great fun, and probably good marketing. Do many browsers support yield now? Yay! Yield Prolog can generate to javascript as well -more fuel for my delusions of grandeur! :) 
&gt; Do many browsers support yield now? Yay! I'm sorry, I had this totally wrong. As [this](http://kangax.github.io/es5-compat-table/es6/) page shows, only Firefox supports it. But it [has recently been added to V8](http://wingolog.org/archives/2013/05/08/generators-in-v8) and so [it has appeared in recent development versions of Node.js](http://blog.alexmaccaw.com/how-yield-will-transform-node), which is nice.
&gt; The question is should I try to find remake it to a selfmade predicate for comparison or is there a small fix for this. You can write a very simple "selfmade" predicate for this in 2 clauses, without using *nth1*, and it gives the correct behaviour for your example. Think of a declarative formulation in words: "pos(L1, L2, E1, E2) holds if either E1 is the first element of L1 and E2 is the first element of L2 (that gives you the first clause - you can even write it as a fact), or if pos holds on the tails of the two lists with the same E1 and E2 (that gives you the second clause)." Try expressing that in Prolog on your own and we can help you if you get stuck.
If you have any other resources for this page, please post here or PM me
You could mention Covington's two recently freed books, currently still on the front page of this subreddit. Obviously, there's a lot that could be added under implementations; since you mentioned the JavaScript Prolog at [ioctl.org/logic/](http://ioctl.org/logic/), you may also want to mention [Yield Prolog](http://yieldprolog.sourceforge.net/), which offers a nice way to embed Prolog into languages with "yield", including Python, C# and ECMAScript 6. (We were discussing it a few days ago in the Ciao Prolog thread - ironically.) There are a few things on [SWI-Prolog's Links page](http://www.swi-prolog.org/Links.html) that you don't have. The tutorials by Anne Ogborn and Michael Richter are nice, although SWI-Prolog specific. (The links are dead for me right now, but I think Anne is just having temporary issues with her webserver.) I'd definitely also add the "Coding Guidelines for Prolog" link - that document is very helpful. Perhaps you could message the mod and ask to have a link to your list put in the sidebar, as a helpful resource?
Thanks for reminding me about the Covington books, I downloaded both, but forgot to add them. I also added a more links section for the SWI-Prolog page, rather then copy/pasta their links I'll probably move it over to a wiki before submitting so other people can start adding stuff. 
Cool. Thanks for doing this!
[SICSTus Prolog](https://www.sics.se/projects/sicstus-prolog-leading-prolog-technology) is proprietorial. [B-Prolog](http://en.m.wikipedia.org/wiki/BProlog) is also commercial.
Considering solutions like that. I think with chicken or gambit scheme you could get that boiled down to C, and therefore easy to integrate w/other code.
I was also thinking that would be the way to go. It's unfortunate that we don't have a good Prolog option for iOS, like a Prolog to C compiler or an easily embeddable interpreter that is permissively licensed.
There are other parts of Prolog that interest me as well. e.g. the natural language processing facilities. Not that I really know all that much about it, just interested.
It's certainly not difficult to implement Prolog-like definite clause grammars (DCGs) on top of miniKanren or Schelog using Lisp/Scheme macros, but that's a bit of an uphill battle, especially if you're new to logic programming and/or DCGs. If you're interested in Prolog and NLP, I recommend you have some fun with SWI-Prolog on a desktop platform. Prolog for iOS is just not happening right now, unless you want to make HTML5 apps for iOS, in which case there are a few Prolog-in-JavaScript options, such as [jsprolog](http://ioctl.org/logic/prolog-latest). A Prolog to portable C compiler is high up on the infinite list of projects I'd like to attempt - and I'm sure I'm not the only one. I'll remember to PM you if I ever get one started. :-)
Mercury is a superset of prolog that compiles to C. Check it out at mercury-lang.org
I'd rather see it target LLVM. I'd love to give it a shot, but I don't have time to take that on right now. 
Already looked, and this is where I stopped. &gt; The Mercury libraries and runtime (the files in the library, trace, browser, ssdb, mdbcomp and runtime subdirectories) are distributed under the terms of the GNU Library General Public License (LGPL). See the file COPYING.LIB for copying permissions for those files. Thanks though!
You cannot nest predicate calls inside other predicate calls. You are just passing the structure **test(X)** as a literal argument to member without it being treated as a predicate call. You need a conjunctive query (comma) to connect test and member together: ?- test(X),member(a,X). X = [a, b, c, d, e] ; false. The first solution indicates that member succeeded. The second result (false) is the second clause in member. 
I'm a bit confused about how this discussion progressed. I'm worried that it reveals a basic misconception on my part. From the title and text of this post, I understood OP to be asking for information on implementations that did not have open source licenses. But your answer seems to about a totally different thing, and yet this is what seemed most to interest OP. Can you perhaps shed any light on why this happened? Do I perhaps misunderstand the question? Sorry for asking this kind of weird question...
[YAP](http://www.dcc.fc.up.pt/~vsc/Yap/) is licensed under Artistic License It's non-copyleft license
Hi! I though I'd add to /u/nickmain_'s answer because, if you're new to the LP paradigm, it might at first seem like a shortcoming that predicates don't automatically call other predicates given to them as arguments. In fact, it is a feature. Using [`call/1` and friends](http://www.swi-prolog.org/pldoc/man?section=metacall), it *is* possible to call a predicate given as an argument. E.g., test_text('This is only a test'). warn(X, test_text(X)) :- call(test_text(X)), format('-----\nBe warned: ~w!!\n-----\n', [X]). It looks like this when queried: ?- warn(X, test_text(X)). ----- Be warned: This is only a test!! ----- X = 'This is only a test'. However, the fact that predicates don't automatically evaluate their arguments but just accepts them as normal terms lets us do all kinds of nifty things. Here are some examples: With the operator (`=../2`)[http://www.swi-prolog.org/pldoc/doc_for?object=(%3D..)/2] we can decompose a predicate into a list, the first member of which is its functor, the rest its arguments: ?- gives(giant, kisses, dwarf) =.. X. X = [gives, giant, kisses, dwarf]. So we could write a predicate `member1/2` that does work like you where first expecting: member1(X, Predicate) :- call(Predicate), Predicate =.. [_Functor, ListArgument], member(X, ListArgument). `member1/2` first calls Predicate, binding its argument variable in accordance with whatever facts are available in the database. Then it decomposes Predicate and checks if X is a member of the list ListArgument. Unlike the previous example, `warn/1`, which only succeeds with the predicate-argument `test_text/1`, `member1/1` will work with any 1-place predicate whose argument-variable unifies with a list. So, given the above clause and the following facts, test([a,b,c,d,e]). test1([1,2,3,4,5]). we get results like this: ?- member1(a, test(_)). true ?- member1(1, test1(_)). true ?- member1(a, test1(_)). false. We can also use pattern matching to write predicates which take predicates as arguments in order to provide interfaces that return different kinds of information depending on the kinds of queries posed. I'm working an a toy program for dealing with topic indexes in books, and I'm using patters like the following (the pager numbers are made up): author_of(heidegger, 'Being and Time'). index('Being and Time', ontology, pages([10, 29, 13])). index('Being and Time', anxiety, pages([123, 12])). involves(book(Title), Topic) :- index(Title, Topic, _). involves(author(Author), Topic) :- author_of(Author, Book), involves(book(Book), Topic). involves(book(Title), Topic, Pages) :- index(Title, Topic, Pages). This allows for queries of this sort: ?- involves(author(X), Y). X = heidegger, Y = ontology ; X = heidegger, Y = anxiety. ?- involves(author(A), ontology). A = heidegger ?- involves(book(X), Y). X = 'Being and Time', Y = ontology ; X = 'Being and Time', Y = anxiety. ?- involves(X, Y). X = book('Being and Time'), Y = ontology ; X = book('Being and Time'), Y = anxiety ; X = author(heidegger), Y = ontology ; X = author(heidegger), Y = anxiety. ?- involves(book('Being and Time'), ontology, P). P = pages([10, 29, 13]) Of course, it quickly becomes tiresome to write a new predicate for every topic that occurs in a book, especially with long titles. Instead I can write a predicate that will add a new fact for `index/3` given a title and a list of topic-`pages/1` pairs: multi_index(index(Title, Entries), Predicates) :- call(index(Title, Entries)), findall( Predicate, ( member(Args, Entries), Predicate =.. [index, Title | Args] ), Predicates), maplist(assertz, Predicates). Now, if I declare `index/3` to be dynamic by adding `:- dynamic index/3` towards the top of my file, I can define the following two facts, author_of(heidegger, 'The Question Concerning Technology'). index('The Question Concerning Technology', [ [truth, pages([1,2,3,4])], [entfernung, pages([3,2,4,5])], [gestell, pages([1,2,3,4,2]) ] ]). then query, ?- multi_index(index(X, Y),P). X = 'The Question Concerning Technology', Y = [[truth, pages([1, 2, 3, 4])], [entfernung, pages([3, 2, 4, 5])], [gestell, pagest([1, 2, 3|...])]], P = [index('The Question Concerning Technology', truth, pages([1, 2, 3, 4])), index('The Question Concerning Technology', entfernung, pages([3, 2, 4, 5])), index('The Question Concerning Technology', gestell, pages([1, 2, 3, 4|...]))]. Each of those topic-`pages/1` pairs is now an `index/3` fact of the form `index('The Question Concerning Technology`, &lt;Topic&gt;, pages(&lt;Pages&gt;)`, and I can pose queries on them just like the others: ?- involves(book(B), gestell). B = 'The Question Concerning Technology'. Yeah... I kind of got carried away, sorry. But you, or another, might find it useful, plus think I wrote a new part of my indexing program along the way ;) tldr: the fact that Prolog doesn't automatically evaluate predicates given as arguments to other predicates is great, because it lets us mess around with the predicates in nifty ways. 
Doh! I see that now in the Wiki list. It's GPL or Artistic. Have you used it? Thanks!
Nice ideas! We could have the reddit alien on the side, making a :-? face :)
Yes, abathologist, please do become a mod and make these changes! As you probably know, this subreddit went totally dead for about 2 months. I think we all expected someone else to submit content and after I submitted a few links about a month ago, others started submitting and /r/prolog has quickly become active again. With that in mind, and since we are a small community and there isn't really a huge amount of Prolog content and activity on the web, **I think our top priority should be to keep this subreddit active**. I think your ideas are excellent for achieving this! I'll add three more suggestions for the sidebar: * We could explicitly say that beginners and beginner questions are welcome. I don't think we're in danger of being overrun by soft questions right now, and if we ever are, we could change the policy. * We could explicitly say that self-posts to encourage discussion are welcome. With Prolog seeing very little discussion on other sites and in the blogosphere compared to other languages, I think we should try to stimulate our own discussions on this subreddit. * We could describe the subreddit as being also about logic programming and related topics, such as constraint logic programming, constraint handling rules, answer-set programming, etc. The communities of people interested in these things are tiny and we might as well broaden our scope and include them.
I think the first step is asking for a new moderator (because the current one is "dead".) This is done here: http://www.reddit.com/r/redditrequest As for your other suggestions, I'm a-ok with them (as a prolog newbie myself, the most complex things I've done are just some English grammar parsers to analyse Google keyword data in a fun way)
I'm curious about what you wanna do with prolog. Can you leak some points?
Number One: learn it. ;-) I have no concrete plans yet, but I see lots of uses in support roles for expressing complicated logic w/o writing metric tonnes of nested if statements. Especially where one condition implies another, which implies another etc... 
I think you read it as Non-([l]gpl open source), but OP meant (Non-[l]gpl) (open source), i.e. open source but not GPL or LGPL.
Just be careful, though. From the [README for Yap 6.2 (stable)](http://sourceforge.net/p/yap/yap-6.2/ci/master/tree/README#l19): &gt; The main core of the YAP distribution is distributed under a dual license: the Perl Artistic license 2 and the FSF's LGPL. The YAP distribution also contains files distributed under the LGPL exclusively, and under the GPL. With the cross-pollination between Yap and SWI, it's not clear to me what's what any more.
&gt; I think the first step is asking for a new moderator (because the current one is "dead".) Thanks! I didn't even realise this. &gt; This is done here: http://www.reddit.com/r/redditrequest abathologist, will you request /r/prolog for yourself at /r/redditrequest?
Ah ha! Thank you. All clear now.
I had never tried or heard about logic programming before, so it was quite a pleasant surprise to get in touch with Prolog. This motivated me to try to get the word out about logic programming!
Will do!
Yo, I've gotten mod (pkrumins account was not deleted but was invisible for some reason or other) I'll make you mod, and probably put up a new logo over the course of the weekend.
Great! Any thoughts on what the logo should be? Personally, I think we would be better off going in the direction of /r/haskell or /r/python rather than /r/lisp (I'm not crazy about the reddit alien being everywhere and allover the place). In fact, I think we might do well to take a cue from the ALP page.
Either's fine by me, I can whip something up for either style, and then make a post about it so that people can vote or so.
Sounds good. Is it cool with you if I just start tweaking some stuff on the sidebar and such, with the understanding that these are provisional changes subject to change or erasure?
Absolutely, go ahead!
In light of your suggestion that "We could describe the subreddit as being also about logic programming and related topics", I'm thinking we can put some subtle emphasis on the etymon of 'Prolog'. This indicates that we are ultimately interested in *programming with logic* (Programmation en Logique), but that Prolog itself looms large this regard. I'm trying to think about the sub in this way now.
Almost everyone I went to Uni with hated Prolog - we had to learn it as part of our AI course. I think it's a neat language, there's a bit of a logarithmic learning curve though. Once you've got your head around recursion, Prolog gets a whole load easier.
Wonderful! I'm looking forward to reading through the piece when I get a chance. I'm impressed with your diligence and responsiveness in the /r/programming thread and, it appears, you've done a great job of spreading the word!
We've taken the liberty of linking to your tutorial in the sidebar. As an aside, if you get a chance, would you maybe change a line in your section "Installing Prolog"? It reads, "Executables for Windows can be downloaded here and for Ubuntu/Debian here.". The OS X installation is also available at the first link, and a mac-using reader might otherwise be discouraged. Thanks!
Does help! I'm glad you like it, since it's largely cribbed from your comment ;) I hope that appropriate things will be added and subtracted from the sidebar as circumstances and criticism converge. I also threw some stuff together in the [subreddit wiki](http://www.reddit.com/r/prolog/wiki/index), which could be a good platform for offer basic and tangentially related info. I added you as a contributer to wiki, in case you're up for it.
Thanks for making the change! Better to be proud of your ~700 upvotes in /r/programming and the abundance of positive feedback on your post! You've touched the minds of many folks over the last 24 hours. That's pretty awesome! I've been skipping around *The Art of Prolog* recently: &gt; We believe that programming can be, and should be, an intellectually rewarding activity; that a good programming language is a powerful conceptual tool—a tool for organizing, expression, experimenting with, and even communicating one's thoughts ... we think that programming can be, and should be, part of the problem-solving process itself; that thoughts should be organized as programs, so that consequences of a complex set of assumptions can be investigated by "running" the assumptions; that a conceptual solution to a problem should be developed hand-in-hand with a working program that demonstrates it and exposes its different aspects. (2nd edition, p. 3)
Cool. Thanks!
≡ to me just means "defined as", "⊨ ⇔ ⊢" would certainly be better if you wanted to informally assert that "it's sound and complete".
≡ is definitely also used for logical equivalence. See [here](http://en.wikipedia.org/wiki/Logical_equivalence), for example.
Before consulting the wikipedia table of logic symbols, I had initially assumed it was equivalence, since my only previous exposure to the symbol is from old logic stuff where it is given as a synonym for &lt;-&gt; (e.g., in Russell and Whitehead).
Wha! That was as interesting and illuminating as I'd hoped. Thank you! It gives me a lot to think about and sheds a lot of light on my many areas of ignorance. So much to learn — so little time — so many distractions. Your exegesis gives an apt expression of the utopian ideal that motivates the science of logic. I know I'm taking some poetic license here, but the evident persistence of that ideal in those who use and teach Prolog is one of the things I've really enjoyed about learning the language.
Agreed.
I did indeed. Thanks. 
* [CLIPS] (http://clipsrules.sourceforge.net/) * [Lambda Prolog] (http://www.lix.polytechnique.fr/~dale/lProlog/) * [Twelf] (http://twelf.org/wiki/Main_Page) 
 threesum(List, N1, N2, N3) :- nth(N1, List, Item1), nth(N2, List, Item2), N2 &gt; N1, nth(N3, List, Item3), N3 &gt; N2, 0 is Item1 + Item2 + Item3. This uses the nth/3 predicate that is usually available in any Prolog system. Hope it helps.
I like it! I had a go at [a solution](http://www.reddit.com/r/programming/comments/1paali/three_elements_that_sum_to_zero/cd3u86b) before reading this, but I used is_set/2 to make sure that the indexes where distinct, instead of just comparing them, which was a bad decision. If I'm not mistaken, this produces what the author of the linked blog post calls the "naive solution" -- brute forcing the solution by testing all combos. Correct? Edited: some letters etc.
Yes, this is the "brute force" solution, that solves the problem in O( n^3 ).
Why do you think Prolog would be a good match? I thought Prolog was mostly good at backtracking, not at solving constraints. Maybe linear programming?
I thought Prolog was often used for constraint programming. The sidebar here mentions "constraint logic programming, constraint handling rules," and the [Wikipedia article for constraint programming](http://en.wikipedia.org/wiki/Constraint_programming) mentions Prolog. It's also possible that I've misinterpreted this problem as a constraint programming problem.
I was under a similar misaprehension with respect to prolog and constraint solving when I tried to make a sudoku solver. I ended up using a constraint library but it certainly worked. Perhaps [this](http://en.wikibooks.org/wiki/Prolog/Constraint_Logic_Programming) will help.
Thanks for the suggestion! Do you know how I might define a participant as a set of boolean values? e.g. a list of participants must look something like: [ [true, true, true], /* sunglasses, backwards hat, awesome */ [true, false, false], /* sunglasses, no backwards hat, not awesome */ ... ] And then have an idea about how I might set the constraints?
The way you have looks OK to me although it's not totally clear to me what the problem is. You have the two data sets: sunglasses and backwards hat and for each participant you have awesomeness. If you just want to collect some stats then the easiest way is probably to filter the lists: awesome_backhat([[S, true, true]|Ps], [[S,true, true]|Rs]) :- awesome_backhat(Ps, RS). awesome_backhat([[_, false, _]|Ps], [Rs]) :- awesome_backhat(Ps, RS). awesome_backhat([], []). If you're looking to generate the lists from the desired statistical results then you're beyond my prolog skill.
&gt;If you're looking to generate the lists from the desired statistical results Yep, unfortunately that's exactly what I want to do. 
In that case my suggestion would be to take a look at the problem mathematically. It seems to me that you have a system of three equations that need to be satisfied. Once you find a solution you will have the shape of your lists. Maybe /r/learnmath is a better choice for this than /r/prolog .
Ok, I've defined it as a math problem. I'll try posting it in a math subreddit, but it's definitely going to need to be solved by a computer: http://i.imgur.com/VFlgzFk.png I used a subset of my real data there.
I think that might be. Most Prolog implementations with which I am familiar have constraint solving libraries. While I have but the vaguest understanding of constraint programming, I believe that it is precisely Prolog's backtracking nature that makes it suitable, as this seems to be a principle search strategy in constraint solving (according to wikipedia).
**Edit:** This is a bad, misconceived answer resulting from my lack of understanding, but I let it remain for whatever, reason. I may not properly understand your problem, in which case I'd appreciate correction. However, it seems to me that some simple, vanilla Prolog code would provide an easy solution. Here's my sketch at some code for the purpose: Is there a particular reason why you want to want to use a nested list of booleans to represent the data structure of a participant? My inclination would be to write your database in more descriptive terms, using a predicate `participant/4`: participant(1, sunglasses(yes), backwards_hat(no), awesome(yes)). participant(2, sunglasses(no), backwards_hat(yes), awesome(yes)). participant(3, sunglasses(no), backwards_hat(no), awesome(no)). participant(4, sunglasses(yes), backwards_hat(yes), awesome(yes)). participant(5, sunglasses(yes), backwards_hat(no), awesome(no)). ... Then we can query the list to find out the info on any or all particulars: ?- participant(3, X, Y, Z). X = sunglasses(no), Y = backwards_hat(no), Z = awesome(no). To get a list of all the participants we can use `findall/3`: ?- findall(participant(N, S, B, A), participant(N, S, B, A), Participants). Participants = [participant(1, sunglasses(yes), backwards_hat(no), awesome(yes)), participant(2, sunglasses(no), backwards_hat(yes), awesome(yes)), participant(3, sunglasses(no), backwards_hat(no), awesome(no)), participant(4, sunglasses(yes), backwards_hat(yes), awesome(yes)), participant(5, sunglasses(yes), backwards_hat(no), awesome(no))]. We can add a helper predicate, `participant/1` to give us a participant without having to write out all four arguments of that data structure, participant(P) :- P = participant(_,_,_,_), P. and a rule to short-cut the collection of all participants in a list: participants(Ps) :- findall(P, participant(P), Ps). We can also add some helper predicates that let us query the database for participants with certain qualities: awesome(P) :- P = participant(_,_,_,awesome(yes)), P. sunglassed(P) :- P = participant(_,sunglasses(yes),_,_), P. backwardshated(P) :- P = participant(_,_,backwards_hat(yes),_), P. With these in hand, we can find just those participants who wore sunglasses: ?- findall(Participant, sunglassed(Participant), Participants). Participants = [participant(1, sunglasses(yes), backwards_hat(no), awesome(yes)), participant(4, sunglasses(yes), backwards_hat(yes), awesome(yes)), participant(5, sunglasses(yes), backwards_hat(no), awesome(no))]. Or we can find any combination thereof, e.g.: ?- findall(Participant, (backwardshated(Participant), sunglassed(Participant)), Participants). Participants = [participant(4, sunglasses(yes), backwards_hat(yes), awesome(yes))]. We can add a rule that will tell us the number of participants with certain properties (This example uses some higher-order programming: `call/2` calls a functor on an argument. For example, if `Type == sunglassed` then `call(sunglassed, X)` is equivalent to `sunglassed(X)`): num_participants_of_type(Type, N) :- aggregate_all(count, call(Type, _), N). This rule will will query thus: ?- num_participants_of_type(backwardshated, N). N = 2. ?- num_participants_of_type(sunglassed, N). N = 3. For the sake of concision and elegance in expression, we can write a rule to answer a list of properties with a list of those participants who bore the combination of properties along with the number thereof: participants_with_properties(Properties, Ps, Num) :- findall( P, foreach( member(Predicate, Properties), call(Predicate, P)), Ps ), length(Ps, Num). Queries: ?- participants_with_properties([sunglassed, awesome], Ps, Num). Ps = [participant(1, sunglasses(yes), backwards_hat(no), awesome(yes)), participant(4, sunglasses(yes), backwards_hat(yes), awesome(yes))], Num = 2. ?- participants_with_properties([backwardshated], Ps, Num). Ps = [participant(2, sunglasses(no), backwards_hat(yes), awesome(yes)), participant(4, sunglasses(yes), backwards_hat(yes), awesome(yes))], Num = 2. Finally, one possible rule that would give results like those you specified is the following (in this instance, `maplist/3` is equivalent to `length(Did, NumDid)`, `length(DidAwesome, NumDidAwesome)`, etc.) : behavior(Type, did(NumDid, num_awesome(NumDidAwesome)), did_not(NumDidNot, num_awesome(NumDidNotAwesome)) ) :- participants(Ps), partition(Type, Ps, Did, DidNot), include(awesome, Did, DidAwesome), include(awesome, DidNot, DidNotAwesome), maplist(length, [Did, DidAwesome, DidNot, DidNotAwesome], [NumDid, NumDidAwesome, NumDidNot, NumDidNotAwesome]). Querying this will give you the answers to your Behavior 1 or 2: ?- behavior(sunglassed, Did, DidNot). Did = did(3, num_awesome(2)), DidNot = did_not(2, num_awesome(1)). And if you want it in natural language, you can use `format/2`, or the equivalent in the implementation you're working with. I hope that helps! If not, I hope you can help me understand my misconception of your project. 
Wow, thanks for all that! I will read through it and get back to you. I just updated the post with a much better description of what I'm trying to do, if you're interested.
Awesome, thanks! I wouldn't have this problem if those pesky researchers would just share their data with me &gt;:(
Edit: I figured it out! Now I need to generalize it so I can have more than 6 participants. :- use_module(library(clpfd)). setListDomainToBoolean(List) :- List ins 0..1. syntheticdata(Ps) :- /* Define list of participants */ Ps = [[A1,B1,C1],[A2,B2,C2],[A3,B3,C3],[A4,B4,C4],[A5,B5,C5],[A6,B6,C6]], /* Define range of values (Boolean) */ maplist(setListDomainToBoolean, Ps), /* Set constraints */ /* Number of participants who display A */ A1 + A2 + A3 + A4 + A5 + A6 #= 3, /* Number of participants who display B */ B1 + B2 + B3 + B4 + B5 + B6 #= 4, /* Number of participants who display A and C */ A1*C1 + A2*C2 + A3*C3 + A4*C4 + A5*C5 + A6*C6 #= 2, /* Number of participants who display B and C */ B1*C1 + B2*C2 + B3*C3 + B4*C4 + B5*C5 + B6*C6 #= 3, /* Number of participants who do not display A and display C. (C - (C&amp;A))*/ (C1 + C2 + C3 + C4 + C5 + C6) - (A1*C1 + A2*C2 + A3*C3 + A4*C4 + A5*C5 + A6*C6) #= 2, /* Number of participants who do not display B and display C. (C - (C&amp;B))*/ (C1 + C2 + C3 + C4 + C5 + C6) - (B1*C1 + B2*C2 + B3*C3 + B4*C4 + B5*C5 + B6*C6) #= 1. /* Run this query to find the sets which satisfy the constraints syntheticdata(Ps), maplist(label, Ps). */
Awesome. Thanks for sharing. I'll take this up as my first, brief tutorial introduction to constraint programming. This is a good deal for me: I blabber about something irrelevant and get a good education in return ;)
&gt; The banker who earns more than the architect, is neither the youngest or the oldest. largerIncome(banker,architect). hmm... I can't say that's wrong, but I'd rewrite it as "If someone is a banker, then he earns more than someone who is an architect.". Think of Prolog as a typed language (which it isn't, but just imagine it). You want the parameters of each predicate to be of a certain type. For example, for betterGolfer/2, you'll want both parameters to be people rather than professions, e.g. betterGolfer(brown, jones). For profession/2, you'll want the first parameter to be a person and the second to be a profession (e.g. profession(brown, banker). ). The next part is a bit tricky: The banker is not the youngest, and the banker is not the oldest. I suspect negation is needed unless there's a clever trick. This part isn't obvious to me. You'll also need the profession/2 predicate somewhere. Keep going. When I first learned Prolog, my brain hurt. It still does some times. It's one of those languages where you can spend an hour writing only a few lines of code, but this gets better as you learn the patterns used. Eventually you'll have a tear in your eye because it's the most beautiful code you've ever written (and because you haven't sleeped for 20 hours).
Are you saying that the the swi `library(lists)` set predicates are dependent upon element order? If this is what you meant, I don't think that is the case: ?- subset([4,3], [3,2,1,4]). true. ?- subset([3,4], [3,2,1,4]). true. Does the swi [`library(orsets)`](http://www.swi-prolog.org/pldoc/man?section=ordsets) help address your last question?
&gt; permutations to test equality um... I think you mean sorting...
&gt; Maybe solutions where I one needs to define an order on the possible members of sets? You don't have to because for this very purpose Prolog defines a total ordering on terms. See [here](http://www.swi-prolog.org/pldoc/man?section=standardorder) in the SWI-Prolog documentation, for example. This is the order used by sort/2, keysort/2 and setof/3. As abathologist said, [library(ordsets)](http://www.swi-prolog.org/pldoc/man?section=ordsets) gives you set operations on sets represented as such ordered lists.
That's funny. I had tried with union: ?- union([1,2],[3,4],[1,3,4,2]). false. ?- union([1,2],[3,4],[1,2,3,4]). true. **edit**: which makes me wonder what's better: myunion(A,B,C) :- union(A,B,X), permutation(X,C). or myunion(A,B,C) :- union(A,B,X), subset(X,C). I reckon the first one if sets are lists without duplicates. The second might be better if we "set theoretically" identify, e.g., the lists [a,a,b] and [a,b].
Thanks, that may help.
Sorry. I did not write that clearly. I meant using for instance *union* from library(lists). And define myunion(A,B,C) :- union(A,B,X), permutation(X,C).
A notation for map seems saner than having to come up with variable names that are not standardized. Pt.x is clearer than Pt_x as the former has a more uniformly defined semantics.
A map is more efficient than list for name based lookup and more logic/declarative than dynamic predicates. Map \= OO.
I think I can sympathize with your concerns. However, I am excited to try it out and am open to the idea. It looks to me like it might allow syntax that gives some of the advantages of the the object-oriented syntax of Flora2. If I understand correctly, the clause, M.multiply(F) := point{x:X, y:Y} :- X is M.x*F, Y is M.y*F. which is quarried thus, ?- X = point{x:1, y:2}.multiply(2). X = point{x:2, y:4}. Is semantically equivalent to something of the form (granted, the former is dependent on the module name) multiply(F, point(x(Xm),y(Ym)), point(x(Xn), y(Yn)) ) :- Xn is Xm * F, Yn is Ym * F. which would be queried in this way, ?- multiply(2, point(x(1), y(2)), X). I must admit that I find the former much easier to parse. The benefits of this seem to compound quickly as soon as we start dealing with more complicated data structures. Given that structural equivalence between the "function on a map" and the more conventional determination, it does seem to preserve its logical meaning. No? It is my understanding that the logical nature of a syntax comes from the semantics determined by the rules of combination and transformation, rather than the adherence to any particular form of notation.... However, as you know, I haven't the clearest understanding of these matters, so I may be missing some important qualifications? (Great post/discussion topic, by the way. I applied to be included on the swi mailing list a month or more ago, but haven't been granted the privilege yet... who knows how long it would have taken for me to find out about the update otherwise!)
I should qualify my claim about the semantic equivalence. I believe that, unless p is unary, `R = p.q` is actually equivalent to something like `get_value(p, q(R))` where `get_value/2` is a rule akin to get_value(P, Q) :- Predicate =.. [P | Args], call(Predicate), member(Q, Args). Or perhaps, if `p` is a unary predicate with a list as an argument, `get(P, Q) :- call(P, List) , member(Q, List)`. Note: I haven't actually looked at how the syntax is implemented, I'm sure it's not this simple, and I'm just speculating. Thinking of this as an 'accessor', and naming it in accordance with an imperative idiom does seem to occlude its declarative, logical reading (see section 5.4.1.2 in the documentation for the instances of this). But could we just think of the combination of the `./2` operator and `=` as an abbreviation for something along the lines of "... has predicate ... with value..."? So, if `Ball = ball.{color:red, shape:spherical}`, then ?- Color = Ball.color. Color = red. would be read as an expression like ?- color(Ball, Color). Color = red. So `ball{color:red}` would be thought of as if it were `color(ball, red)`. But this would be a form of expression that also allowed for some 2nd order reasoning, as if we could write 'Property(ball, _)` to get all the properties of an object. So we would have a concise, standardized system for reasoning about objects: material(Object) :- _ = Object.color, _ = Object.shape. instead of having to come up with adhoc systems, such as by writing a `quality/3` predicate to be used thus `quality(ball, color, red)`. 
Yes, and Prolog already has maps: see library(assoc). I would have welcomed an efficient native implementation of O(1) logical maps as a library; even operator declarations and macros for convenient handling. But it's not necessary to extend the core language and destroy its syntactic conventions in order to do this.
I agree that the new syntax still has a clear and reasonable logical meaning. It's just that = has a very specific meaning in Prolog. A = B means (declaratively) "A and B are the same Herbrand term", or (operationally) "attempt to unify A with B". Now there's an additional "check if B is an application of a map to a key and if so, apply it" part to this meaning, which is ridiculous. I think they used to explain this by saying that Prolog is not an "expression-oriented language": terms are not expressions, and they don't evaluate. &gt; instead of having to come up with adhoc systems, such as by writing a quality/3 predicate to be used thus quality(ball, color, red). But quality/3 is more general (a ball could have multiple colours) and more consistent with the logical spirit of Prolog, in my opinion. :-)
Your points are well taken. What you say about the resultant ambiguous meaning of `=` does make good sense to me. Perhaps it would have been better introduce a different operator for this purpose, to minimize unnecessary equivocation. Well, a ball shouldn't have more than one color at a time in the same place..., so we'd need a spatio-temporal index if we were going to assign multiples. ;) You make a good point about the generality. I wonder if I'm not just a bit hung up on OO notions (and too easily beguiled by attractive syntax. something about those curly brackets...). Do think there would have been a way to implement similar sorts of sugar that were "more consistent with the logical spirit of Prolog"? 
&gt; Do think there would have been a way to implement similar sorts of sugar that were "more consistent with the logical spirit of Prolog"? I think so. It depends what one wants. Perhaps some convenience operators on top of library(assoc) to make it more natural to define new assocs and access and update them? Maybe I'll give it a go this week and post some code.
For the past two weeks I've been trying to get about how to write a simple prolog program. It awesome, I can now write prolog program confidently after reading ur post.
I was bored at work, hope this helps: bstadd(K,[K, Left, Right],[K, Left, Right]). bstadd(K,[],[K,[],[]]). bstadd(K,[X,Left,Right],[X,Left,NewRight]) :- K &gt; X, bstadd(K,Right,NewRight). bstadd(K,[X,Left,Right],[X,NewLeft,Right]) :- K &lt; X, bstadd(K, Left, NewLeft).
First of all, you made a small mistake in your base case: &gt; R=[X|Y]. should be &gt; R = [X, Y] It is a simple two element list, after all. Y is the second element, not the tail. This, however, does not cause the loop. That issue is pretty much inherent to problem. From the post I think you understand how it happens, so as to a solution: You would be to keep track of what places you've visited and make sure not to visit them again. After all, there is nothing to stop the programming from going in circles, which is easy to see looking at the first two clauses of road/3. To find the shortest route, the easiest way would be to find all routes (see findall/3) and select the shortest from the list. The best way would to use a clever search algorithm, such as [Dijkstra](http://en.wikipedia.org/wiki/Dijkstra's_algorithm). But I'm guessing that that this is an assignment for some course where you'll get to search algorithms later on. 
I don't really understand how to not visit them again. Could you give me some sample code? I'v changed my original predicate to this: route(X,Y,R,N) :- road(X,Y,N), R=[X,Y]. route(X,Y, R, N) :- road(X,W,N1),visited(W,R), route(W, Y, Xs, N2), N is N1+N2, R = [X|Xs]. visited(X, R) :- \+ member(X,R),!. but now it won't find all routes.
The TA in me doesn't let me give you the full solution, but here's most of *a* solution &gt; % route/4 is merely a wrapper for road/5 &gt;route(Start, Goal, Route, N) :- &gt; % 4the argument in call below is the 'visited' list. &gt; route(Start, Goal, Route, [Start], N). . &gt; % Step case for route/5 &gt; route(CurrentNode, Goal, Route, Visited, N) :- &gt; road(CurrentNode, NextNode), &gt; \+ member(NextNode, Visited). &gt; % TODO recursion and stuff. Note thought, that this is an inefficient solution. As you find the path going deeper in recursion, but you get N on the way back. A full tail-recursive solution requires another argument for N.
Ghehe, it seems this is an assignment somewhere that is giving people trouble. Someone else was asking about the same thing recently. Anyway, if you mean about preventing loops in general: I don think there's really a simple catch all solution. You have to figure out where the loop occurs and how to prevent it. In this particular case though, it's because you can visit some nodes (in intuitive terms, some cities) several times and keep looping around (or even going back and forth) without ever reaching the destination. Have a look at what I told the previous person who asked about this, it might help. [here](http://www.reddit.com/r/prolog/comments/1tdd63/can_anyone_help_me_out_with_this_swiprolog_route/)
You can use assert to remember the current best. Retract it and assert the new best when you find a better one.
That sounds like a good idea, thanks! 
Some Prolog implementations have a library called library(aggregate) for this. See [here](http://www.swi-prolog.org/pldoc/man?section=aggregate) for SWI-Prolog, for example. Then, with that module loaded, a query like aggregate_all(max(C), solve(A,B,C), Cmax). will unify Cmax with the largest value of C found over backtracking. As you can see, there are also templates for finding minima, sums, counts, bags and sets of solutions. (Unfortunately, I see it says under "To be done": "- aggregate_all/3 can be rewritten to run in constant space using non-backtrackable assignment on a term." Indeed, looking at the [source](http://www.swi-prolog.org/pldoc/doc/swi/library/aggregate.pl?show=src) I see that only the "count" template is currently implemented using a non-backtracking primitive; everything else uses all-solutions predicates underneath. So for memory efficiency, you might still be better off doing this yourself using assert/retract to maintain the current best solution.)
If this were already implemented in constant space it'd be perfect :(
Thanks again, I implemented it like this and works like a charm. Small follow-up question if I may: is there a better way to set a maximum run-time (for searching a better solution) without interrupting the rest of the program? I was planning on using *statistics(process_cputime,Time)*, and comparing with the time the algorithm started, but not sure if it's really the proper/best way to do. 
The predicate [*call_with_time_limit/2*](http://www.swi-prolog.org/pldoc/man?predicate=call_with_time_limit/2) does this. You can also have a look at the [*resbound* pack](http://www.swi-prolog.org/pack/list?p=resbound).
Perhaps it's good to as what yourself what you intend to do with the line 'E is D'? The whole purpose of is/2 is to resolve an arithmetic expression. And considering you don't seem to want to do any arithmetic, it is the wrong function to use. I think you are looking for =/2. Of course, if you replace the use of is/2 with =/2 the line is redundant. But that's another matter :) Also, a tip for probably the next error: parse_time/3 is a predicate, not a function.
I get this if I don't do E is D: ERROR: &gt;/2: Arguments are not sufficiently instantiated
Well, there are 2 issues here. The first is not actually the cause of the error. When I said it is redundant, I did not mean you can just leave it out and keep everything the same. After all, E is unbound at this point. Long story short, you can simply pass D to compare_time/3. The error, though, is admittedly a bit odd. Usually you will see this error when one of the arguments is variable. In which case the error makes sense. This is not the case here and I'm not sure why it gives this particular error. Ask yourself, though, what are you passing to &gt;/2? Which of course is the same here as asking 'what are you asking to greater/2'? This relates to the last comment in my previous post. Remember, functions can be evaluated to different kind of values, predicates can only be evaluated to truth values.
I've changed it around a bit, it now reads: greater(X,Y) :- parse_time(X,iso_8601,StampBefore) &gt; parse_time(Y,iso_8601,StampBefore). sent_before(X,Y,Z) :- message(X,Y,D),greater(Z,D). And I get this error: ERROR: c:/users/liam/dropbox/uni work/1310582.pl:3: evaluable `parse_time(_G6845,iso_8601,_G6847)' does not exist What I'm trying to perform &gt; on is the result of parse_time which takes a variable (a date) and turns into seconds. 
Ah, yes. I understand the previous error now. It evaluates the expression from the inside out...I'll get back tot that later Anyway, apart from fixing the passing of the date, you are effectively doing the exact same thing as before. Taking out the compare_time predicate out this way (which, incidentally, I would advice against for general design reasons) doesn't actually change anything. Here's your problem: &gt;/2 takes two numerical arguments. These arguments can also be arithmetic expressions, which it will then evaluate, exactly like is/2 would with it's second argument. Now, both arguments must, of course, be fully instantiated. The predicate is not an equation solver, after all. SO when you pass an argument such as &gt; parse_time(X,iso_8601,StampBefore) \&gt;/2 will try to evaluate this mathematically. Before, you passed a unbound variable as first argument. This was the first error recognized. Now that is solved, the program will look at the arguments and find they are all instantiated. Then it looks at the function parse_time/3 and try to evaluate it. But it can't, because it is not an evaluable function. It does not return the value you are looking for, it binds the third argument. In other words, it cannot be used in place of the Time stamp that you are looking for (like you would do with a function with a return value like you would in procedural programming). Instead, you can call the predicate parse_time/3 and it will bind the timeStamp to the variable given as third argument. You can then use that variable to do whatever you want with this value (such as, say, compare it to another value obtained in a similar way :) )).
Ok, so up until your final paragraph I was fine and now I'm confused. I've changed it to this: isgreater(X,Y) :- E = parse_time(X,iso_8601,StampBefore), F = parse_time(Y,iso_8601,StampBefore), E &gt; F. sent_before(X,Y,Z) :- message(X,Y,D),isgreater(Z,D). But that gives this: ERROR: &gt;/2: Arguments are not sufficiently instantiated. Sorry if I seem like a complete moron but Prolog is completely new to me.
Don't worry, a lot of people have this problem when they start out with prolog. Particularly if they have used other programming languages before. Anyway, I think there are two things that you can do that probably help more than any other explanation I can think of: 1. Type 'E = parse_time(X,iso_8601,StampBefore)' (without the quotes) into your prolog terminal and look at the result, particularly the value of E. 2. Look at [the documentation for parse/3](http://www.swi-prolog.org/pldoc/man?predicate=parse_time/3) to see how it works. In case you don't know how to read it: The + before an argument means that it must be bound at time of calling (in intuitive terms: it is and input argument), the - means that it must be given as variable (in intuitive terms: it is an output argument). And argument with ? can be either, but that's not very important right now. 
All my Prolog terminal outputs is E = parse_time(X, iso_8601, StampBefore). As for part two I see that you're saying that the output( the number that I want to compare is in fact the final arguement)?
1. That's the point. E gets bound to the entire expression. 2. Yup :)
DUDE I COULD F***ING KISS YOU! Thank you so much it's finally working now.
Any time. Good luck with the rest of the assignment.
Thanks! I ended up using call_with_time_limit2 in combination with a catch/3 to call my "solveForBest" function. And in the solveForBest function I did a test checking for a "good enough" score. Everything seems to be working very well! Thanks a lot, to both of you! 
I really enjoyed this guys functional JavaScript book. And I'm reading the reasoned schemer so I thought this looked cool.
It's sort of a standard topic for Lisp books, although that's not to say it isn't a great topic for Fogus to cover in his series. Off the top of my head, the following Lisp books give an implementation of Logic Programming and/or Prolog: * *The Reasoned Schemer* - as you mentioned. * Norvig's [*PAIP*](http://norvig.com/paip.html). * [*SICP*](http://mitpress.mit.edu/sicp/) - freely available. * Paul Graham's [*On Lisp*](http://www.paulgraham.com/onlisp.html) - freely available. * Nils Holm's [*Logic Programming in Scheme*](http://www.lulu.com/shop/nils-m-holm/logic-programming-in-scheme/paperback/product-20579378.html). I'm sure there are a few others, including the Clojure books that cover `core.logic`. Just to say that if anyone is looking for Prolog-in-Lisp material, there's already a ton of it out there.
Good point. And thanks for the links. I wonder how this would be different from the examples you give. 
ಠ◡ಠ
is there a proof that it's computationally impossible? If so- please link me :D
Well, it's impossible in finite time... The only way to make sure a set is infinite (that is, numerably infinite like the natural numbers) is checking it has infinitely many elements (assigning a natural number to each one, one after the other), and there's no way to do so in finite time (given that checking membership takes more than 0 units of time)
All infinite sets map to N? How would you constructively define the reals?
You may have better luck defining infinite sets by what they don't contain: exclusion sets.
Just giving an example, it's up to you to define what cardinality you want to define.
That's wrong. Prolog doesn't allow negative facts but it allows negative conclusions, based on the so called "Negation As Failure". NAF is based itself on Closed World Assumption. In easier terms, what is not implied by your theory is considered false. If you don't define "infinite" Prolog will tell you that it's false that something is infinite.
succinctly define the real number set. I think it'll just take time- I'm relatively new to prolog.. and logic for that matter! 
Prolog might not be the best thing for this, it's more of a practical logic language than a proof assistant. You might have more joy with Agda, although it's more complex to get to grips with.
I swear to goodness- I can't learn another language before I master prolog.. maybe the problem will make more sense after I'm a prolog god.
thank you cockmongler ;)
no
If you'd like help, please share with us how you're approaching the problem and what code you've written so far. In any case, I think this problem is %90 coming up with categories and qualities of behavior in relationships. Once you have all of that worked out, the coding should be easy. Maybe ask /r/relationships or some related sub for help there. Best advice I can give you: if you don't demonstrate that you're already trying to work through the problems alone then it appears you're just trying to get someone to do your work for you.
http://en.wikipedia.org/wiki/Real_analysis
*Here's a bit from linked Wikipedia article about* [***Real analysis***](http://en.wikipedia.org/wiki/Real%20analysis) : --- &gt; &gt;**Real analysis** (traditionally, the **theory of functions of a real variable**) is a branch of mathematical analysis dealing with the real numbers and real-valued functions of a real variable. In particular, it deals with the analytic properties of real functions and sequences, including convergence and limits of sequences of real numbers, the calculus of the real numbers, and continuity, smoothness and related properties of real-valued functions. --- [^(**Picture**)](http://i.imgur.com/xQnHJRy.png) ^- **^The ^first ^four ^partial ^sums ^of ^the ^Fourier ^series ^for ^a ^square ^wave. ^Fourier ^series ^are ^an ^important ^tool ^in ^real ^analysis.** [^(image source)](http://commons.wikimedia.org/wiki/File:Fourier_Series.svg) ^| [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/millinao can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/prolog/comments/1uu4fh/defining_infinity_help_me/cerszuq)
"&gt;=" works with numbers. The operands must be numbers or variables instantiated to numbers. "@&gt;=" works with terms, and that includes uninstantiated variables. Uninstantiated variables are less-than any other thing, and between them they are sorted by their address. ?- X &gt;= 3. ERROR: &gt;=/2: Arguments are not sufficiently instantiated ?- X @&gt;= 3. false. ?- X=4, X &gt;= 3. X = 4. ?- X=4, X @&gt;= 3. X = 4. 
The problem is that book and dictionary are atoms in dictionary :- book. but book is a term in isfrom(book, paper). So you may want a relation between book and dictionary (keeping them as terms): issame(dictionary, book). Then the base case of isItFromATree becomes: isItFromATree(X) :- isfrom(X, tree). isItFromATree(X) :- isfrom(Y, tree), issame(Y,X). isItFromATree(X) :- isfrom(Y, tree), issame(X,Y). The recursive step as suggested by /u/Unic0arn remains the same. Hope that helps!
The summary of what is wrong, is that your program doesn't do what you think it does, and prolog doesn't work how you think it does. In particular, you're confusing unification and assignment. Try X = 1 + 2 and X is 1 + 2 in prolog. Recall foo(A+B) :- ... is the same as foo(C) :- C = A + B. Edited to add: As for why you find prolog worth insulting, I'd suggest keeping your opinions to yourself. Asking for help and insulting the tool you're using makes you look both ignorant and petulant.
Try something like this. fib(X,X):- X&lt;2. fib(X,Q):- X1 is X - 1, fib(X1, Y1), X2 is X2 - 1, fib(X2, Y2), Q is Y1 + Y2. You may also want to try some of these: http://potassco.sourceforge.net/
Ah. Found one: Welcome to SWI-Prolog ?- fib(5,Z). Z = 5-1-1-1-1+ (5-1-1-1-2)+ (5-1-1-2)+ (5-1-2-1+ (5-1-2-2))+ (5-2-1-1+ (5-2-1-2)+ (5-2-2)) * From the insults I thought for a moment that I was getting too drunk. All this needs is to tag left-side arithmetics as "execute if possible". * Need an apology and a discussion board populated with people who have a functioning braincell, perhaps two. Where is it? 
Confused? *Desperately Downvoting like a Febrile Ferret?* You wont be after this: eval(X,Y,Z):-fib(X,Y),Z is Y. Lets try it: ?- eval(6,X,Y). X = ... - ... - 1-1-1-1+ (... - ... - 1-1-1-2)+ (6-1-1-1-2)+ (6-1-1-2-1+ (6-1-1-2-2))+ (6-1-2-1-1+ (6-1-2-1-2)+ (6-1-2-2))+ (6-2-1-1-1+ (6-2-1-1-2)+ (6-2-1-2)+ (6-2-2-1+ (6-2-2-2))), Y = 8 . 
Agreed. Also, after reading this thread, I think what's wrong is OP's attitude towards learning a programming language.
OP does not seem to be learning Prolog :-) He is making an interesting, possibly ground-breaking, point about the definition. In snotty newbie terms: "Why is the numeric space excluded from logical reasoning in all Prologs?" * "Prolog for Mathematicians" does some of issues. 
Make "isfrom/2" a transitive relationship: isfrom(X, Z) :- isfrom(X, Y), isfrom(Y, Z). This is recursive, so if you're using Prolog then you need to be careful where you put this clause. Now you can just say: isItFromATree(X) :- isfrom(X, tree). A dictionary is a kind of book: kindOf(dictionary, book). A particular item is made out of a particular material if that kind of item is made out of that material: isfrom(Item, Material) :- kindOf(Item, Kind), isfrom(Kind, Material). So then: isItFromATree(dictionary)? I don't use Prolog, but I assume it should work. Now, this isn't homework, is it?
Thank you for replying. I got it to work. Thinking of it as a tree made me understand it much easier. I am still trying to wrap my head around the idea of Prolog recursion though. Perhaps I need to play around with it a bit more.
Firstly, thank you for replying. I have a question though. The reason you have to use 3 rules for isItFromATree is because you defined "isfrom" and "issame" instead of just a single "parent", like what /u/Unic0arn used above right?
Thanks for replying. I now understand that I should have used, as you wrote: kindOf(dictionary,book). instead of dictionary :- book. Your method does work and is almost similar to /u/Unic0arn's method. And no, it's not homework. :D
You're welcome. That's right. This is if you want to have different meanings for isfrom and issame, otherwise the parent predicate works just fine.
The thread you linked to seems to answer your question. Could you explain what part of it you couldn't make sense of? If you're working from the terminal, the easiest thing to do is to `cd` to the directory where your code is and then run `swipl` there. SWI-Prolog will inherit the terminal's working directory as its own.
I guess I need the ELI5 version, I don't quite get the step-by-step guide. My apologizes for my ignorance. 
If there is a file called `.plrc` in your home directory, SWI-Prolog will consult it when it starts. You can find out what your home directory is by running echo $HOME in the terminal. If you create a new text file in this directory and put :- initialization(cd('/my/project/directory')). in it, then save it as `.plrc`, SWI-Prolog will always cd ("change directory") to `/my/project/directory` at startup. So put the directory you always want it to start in in place of `/my/project/directory`.
I followed the instructions, which were pretty much how I had interpreted them from the StackOverflow thread that I originally linked. [This](http://i.imgur.com/u5TkBiY.png) is the message I get when tying to save the raw-text as a name-less file with the ".prlc" extension. For reference - my home directory is "/Users/Connor" when I run the command in terminal. I tried to consult a ".pl" file in the path I linked in the file after trying to save the ".prlc" and it's still not recognizing the new default directory. Am I doing something wrong? We were taught the first day in the course that the "pwd." command in SWI-Prolog gives the current directory which outputs as "/" when I query it. What am I doing wrong? Am I helpless or what? Thank you for your help thus far.
It should be `.plrc`, not `.prlc`.
Jan just posted this as an FAQ entry. I think he makes some interesting points; for example, the one about avoiding object-relational impedance mismatch.
Yep! This is a nice overview. It's got me psyched to have another go at setting up something useful on a Prolog server. Do think it would be worthwhile submitting this to /r/programming? Might be some good publicity if people decide it's worth squabbling over or making jokes about ;)
Good idea! Anne Ogborn gave some feedback on the mailing list so maybe we should wait a day or so and see if Jan changes it. But post it to /r/programming when you see fit and I'll jump into the fray if I'm not too late.
Sounds good. I'll wait a couple days.
Hi. I did this PopMech interview. I had to edit this Q&amp;A down to 1/10th of our actual conversation transcript so it's not all there, but... That's exactly what Hofstadter was saying, that the hype surrounding the idea of encapsulating all of human knowledge into Prolog (as if that would magically bequeath cognition into computers) was the silliest thing he'd ever heard of.
It's very strange and disappointing that Douglas Hofstadter would say things that are so wrong. Perhaps he was oversimplifying? Prolog is a *programming language* well suited to building automated reasoning systems. It's basic deduction mechanism can be extended to implement others, not necessarily "based on very rigid, deductive logic". The [Fifth Generation Computer Systems project](http://en.wikipedia.org/wiki/Fifth_Generation_Computer_Systems_project) was a *Japanese* project. It's goal was to build a supercomputer that would be the platform for future advances in artificial intelligence not that "all of human knowledge was going to be encoded in databases with Prolog". It's failure was not the cause of the AI Winter in the US (obviously not, because the Americans were using Lisp, not Prolog), although it failed for similar reasons. "Prolog was one of the silliest approaches I've ever heard of, and it fell to the ground in shambles." Clearly not. [Many of us are still using it!](http://www.swi-prolog.org/logs/dl-statistics.html) :-) If Hofstadter wanted to attack AI programming languages, he might as well have criticised McCarthy for wanting to build AI systems in Lisp, which would have been an equally ridiculous criticism. A more valid target here would have been Doug Lenat's [Cyc](http://en.wikipedia.org/wiki/Cyc), which, unlike Prolog, was - and to a lesser extent still is - an attempt to encode "all of human knowledge".
I don't have experience, but I'm interested in GGP. What competition is this? Does it use the GDL language to specify games? That language is very easy to process in Prolog because it's a variant of Datalog, as you probably know. You probably also know about the free book [here](http://logic.stanford.edu/ggp/chapters/cover.html) and the basic Prolog player code [here](http://www.general-game-playing.de/downloads.html). Let us know how you go!
&gt; "Prolog was one of the silliest approaches I've ever heard of, and it fell to the ground in shambles." I think he is only criticizing the idea that prolog's basic deduction engine models a fundamental mechanism of human cognition. He isn't saying that prolog itself isn't useful. Hofstadter is interested in models of cognition. See his ["Copycat" project](http://en.wikipedia.org/wiki/Copycat_%28software%29) for an example. 
Did he mention anything about Cyc?
How can that work? Isn't the first argument supposed to be a number describing the position in L of the element E? Ah - you've put that stuff in argument 3 instead.. In nth_elt_with_tests, what test should be made on the length of L? 
If you assert rules you need an extra pair of brackets, like so: assert((p:-q)).
Do you want to specifically print the information? Because nth_elt/4 should already fail in both these cases. Anyway, checking these inequalities can be done independent of the the replacing process that nth_elt/4 performs. If you keep that in mind, along with the fact that you can get the length of L with the built-in predicate length/2 you should be fine.
Thank you so much, that was exactly what I needed!
Thank you very much! This immediately fixed it.
No problem. By the way, I'd advice to pretty much always just use a .pl file rather than asserting everything. Could save a lot of time.
I'm assuming this is homework. It's a problem that's more complicated than it needs to be. First try writing a predicate that returns the Nth item of a list. "nth_elt(N,L,E,R)" - eeew. This is one of the faults of Prolog; people write code so concise that it's unreadable. I'll rename it to: listElementAt(List, N, Element, Result). List and N are "inputs", Element and Result are "outputs". So, the base case. The element at position 1 is the first element of the list: listElementAt( [Head|Tail], 1, Head, Tail ). Now for the recursive case. listElementAt( [Head | Tail], N, Element, ...secret bit... ) :- ...you write this code. Hint: N-1, and the secret bit needs Head in it...
Ciao has many interesting extensions that I would love to explore if I had the time, like alternative search strategies, fuzzy, lazy, parallel/concurrent, etc. Also, you should check out XSB which has tabled resolution and very interesting ODBC/SQL integration that allows for automatically generating SQL queries from Prolog/Datalog queries, and 1 to 1 predicate/SQL table mappings. IMO, dismissing Shen based on its syntax is shallow, it has many, many interesting qualities, like optional laziness which is integrated into the type system. The fact that the type system is optional and you can gradually add static typing to different parts of your code, or disable it when necessary is a powerful feature.
Thanks for you reply! This is very helpful. I hadn't given XSB much thought, but I will look at it now that you've mentioned it. You are absolutely right about my shallow remarks on Shen. I appreciate you drawing attention to aspects of Ciao and Shen that I was too uninformed to appreciate. I think I will set aside some time play around with both Shen and Ciao now that I've received an endorsement.
When you say "cannot use ...", do you mean that you're not allowed to because of the conditions of the exercise? I find it hard to tell which parts you can't figure out, and which parts are forbidden...
If-&gt;else/2 are forbidden and multiple "is" operators are forbidden by the exercise. 
&gt; foo(A,A,0). foo(A,B,1) :- A&gt;B. foo(_A,_B,-1). This is **wrong**. First of all, it's not deterministic and gives wrong answers on backtracking: ?- foo(1, 0, X). X = 1 ; % Any other answers? X = -1. % WRONG! Secondly, it can give wrong answers straight away: ?- foo(1, 1, -1). true. 
The cuts seem unnecessary. The first clause will fail if the head doesn't unify (A=A). The second and third clauses will fail if the test (&gt;, &lt;) fails. I'm not sure that this will work in other prolog implementations, but in Ciao Prolog you can use num/1 to generate integer or float numbers. So you'll have something like: foo(A,A,0) :- num(A). foo(A,B,1) :- num(A), num(B), A&gt;B. foo(A,B,-1) :- num(A), num(B), A&lt;B. This predicate is determinst if both A and B are ground terms, but if either A or B (or both) are variables you'll have a "reversible" predicate that can generate pairs of numbers that follow the constraint. This is a very declarative! 
You need to use asserts. It may be slighty different in your prolog implementation but something like this should work: foo(Y) :- retract(acc(X)), Y is X+1, asserta(acc(Y)), !. foo(0) :- asserta(acc(0)). You may need to declare acc/1 as a dynamic predicate or something like that.
What are you trying to accomplish, in particular?
`=:=/2` is probably the one to use instead of `==/2`, since it takes care of assuring the vars have numerical values. `aba == aba` is true.
Thanks. I knew 'asserta' might be used and it doesn't feel very prology. But this looks like the only way.
I'm not trying to accomplish anything right now, however, I used to consider is there any ways to record how many time the program pass through a particular point. And also to achieve something like "yield return" because sometimes when entering another iteration, I don't want to "restart" all things again. Though, I found using the "setof" can avoid the above problems in most cases latter. Well actually, I was just reading "Hacker and Painter" and it talked of writing accumulator in different languages in order to "mock" Java. And I found prolog is not in the list and seems impossible to achieve this kind of thing.
I see. Thanks for clarifying. At first I thought you might mean just an accumulator for a certain process, like those discussed here: http://people.sju.edu/~jhodgson/ai/accums.html These sorts of accumulators are very easy to write in Prolog. But it sounds like, from what you say and /u/MrQuimico's reply, that you need a *global* accumulator. Outside of simply threading an accumulator value through the relevant parts of the program, the use of assertions is the only one I can think of. I agree with you that "it doesn't feel very prology". On the other hand, it is a completely valid use of assertions, and assertions are *not* anathema in the language. If you *need* a global accumulator variable and this is the only to achieve it, then I guess this would indeed be the prolog way of achieving the desired result? But I would be interested in seeing what prology solutions we can come up with for particular use cases. I find that sometimes when a non-prology answer is the only option, it means that the question has been posed in a non-prology way. For my own sake, I wonder if you could describe a use case where you would employ "yield return", as I'm not familiar with that device. 
They are equivalent in theory. In practice you choose the one that can make you most productive.
It's *very* difficult to understand the strengths of logic programming without studying it at least a little. From the [comp.lang.prolog FAQ](http://www.logic.at/prolog/faq/faq.html): &gt; **5\. I think language X is better than Prolog. What do you think?** &gt; &gt; These debates rarely result in any productive discussion. To some extent, one's favourite language is based on irrational ideology. &gt; &gt; However, many people now agree that different languages are good for different things. Prolog seems to be good for problems in which logic is intimately involved, or whose solutions have a succinct logical characterization. Like other interactive, symbolic languages, Prolog is also good for rapid prototyping. &gt; &gt; Also, note that there are many different "Prologs" and other logic programming languages available, all with different capabilities. [This stackoverflow question](http://stackoverflow.com/questions/8297574/difference-between-logic-programming-and-functional-programming) has some decent answers that might help you. Personally, I think Prolog takes at least as long as Haskell to really "click" in your mind - to reach the a-ha moment. If you really want to assess your own productivity difference, you have to reach that moment.
This thread has been linked to from elsewhere on reddit. - [/r/functionalprogramming] [Functional programming vs logic programming (x-post r/prolog)](http://np.reddit.com/r/functionalprogramming/comments/20kjc0/functional_programming_vs_logic_programming_xpost/) *^I ^am ^a ^bot. ^Comments? ^Complaints? [^Send ^them ^to ^my ^inbox!](http://www.reddit.com/message/compose/?to=totes_meta_bot)* 
That's the main part of my question though. People say tha functional programming, specifically in haskell, leads to much more elegant results than imperative languages. I'm wondering if logic is equally or more efficient. 
I'm no expert so the following are open for discussion: * For many problems, functional programs are more concise. With Prolog, you need to have a logical statement for each step in the process taking the output of one statement as input for another, whereas with a functional language you just concatenate the functions on the inputs. * For some problems involving searching for an answer, Prolog is much more concise. * Prolog is impure. Haskell is pure. This has ramifications for testing the validity of code, doing funky optimisations and automatically parallelising code. * "More efficiently" (i.e. "more concise") is not always a good thing. IMHO imperative languages are much easier to debug even though they involve a lot more typing. * Both functional and declarative programming have the capacity to seriously hurt your brain. This applies to imperative and object-oriented code as well, but dare I say to a lesser extent.
Prolog code is a lot more concise than, say, Smalltalk or Java. However, Prolog isn't a hammer. You can't fix every problem in it (like you can in Python ;-) ) but it is exceptionally good in some specific areas such as language processing, AI and expert systems.
 ?-[[4,3],[2,1]]=[[4,3],[2,1]]. True Simple surely?
Thanks. I was using "=:=" and "is" like an idiot. Can you explain?
be happy with three principles: matching, decomposition and recursion eq([HA | TA], [HB | TB] ) :- eq(HA, HB), eq(TA, TB). eq([],[]). eq(A,B) :- A is B. 
= means can unify 5 = 5 ? True. X=Y? True X=5? X=5. [5,4]=X? X = [5, 4]. http://www.doc.gold.ac.uk/~mas02gw/prolog_tutorial/prologpages/vars.html 
Got the joke, but just in case someone doesn't know how to do it: ?- [1|[2,3]]=[_|T]. T = [2, 3].
The first two clauses are the "base case." You need to get them out, first. To work out how this works, use some examples, like compress([1,2,2],C) This won't match neither the first rule or the second, since X is not empty, nor it coincides with [1,2]. So, we try to match it to the third rule. Since 1 is not 2, it doesn't match either. It will match the third rule, though, with Tail = 2. Since X is not Y, we recurse calling compress again, with parameters: Y=2, Tail=2, Out to be determined, this is: compress([2,2], Out). This matches the third rule, with Tail empty. It calls itself again, with compress([2], Out) Which now matches the *second* rule. Since [2] is not [], setting Out=[2] finishes. Now we backtrack the successive calls (i.e. come back and check what Out is, and when it was created), eventually getting to C=[1,2].
First line says that an empty list has length zero. Second line: The length of a list with head element H and tail list T is K+1, where K is the length of T. The second clause calls length1 recursively with shorter and shorter tail lists until the first clause is matched (T is the empty list). That returns zero and the recursive calls unwind, adding one to the result each time.
This subreddit is really going downhill.
This got [an answer on Stackoverflow](http://stackoverflow.com/questions/23064735/how-to-generate-negative-examples-in-inductive-logic-programming), in case anyone else is interested.
Yes that was my question there. Both ALPEH and Progol have positive example only mode which is good enough in inducing rules of simple games. For complicated real world cases, negative cases are also required. It is in general difficult to observe negative cases. That is why I was wondering how do people generate negative cases in general. In any case I ran the code on towers of hanoi where we have a negative rule that the smaller block should never be on a bigger block. The system was successfully able to induce on(A,B) :- bigger(B,A), It was really cool that instead of using a negation it was able to switch the order of the parameters to represent the same logic.
Interesting! I've been meaning to learn more about ILP since I read the chapter on it in *Prolog Programming for Artificial Intelligence*. I would have suggested giving examples of illegal moves for certain positions for each game and seeing if it could then induce the general negative rules. But I presumed that wasn't an acceptable solution for you. What you ended up with seems much nicer.
According to my experience, a domain must be given before using a negative example. （THX to my high school teacher's saying "Without a domain, all functions are out of the question.") For example, "The number is not 2." can not be simply described by: ?-not(X=2). but numbers(X):- member(X,[1,2,3]). ?- numbers(X),not(X=2). We seldom pay attention to the domain problem because "domains" are common sense in most cases. For example, "I'm not telling a lie" means "what I said was true" because everyone knows a person is only able to tell "either a lie or a truth" which is a preset domain in our mind (People sometimes don't understand with each other because they have different "domains" :3 ). However, machines know nothing about this. Thus, the Towers of Hanoi problem can be simply solved by adding a domain of movement which is "Any block on the top can be moved to position 1, 2 or 3."
Dude WTF NSA is watching cant say that on the surface web WOW
You can write yourself one in Lisp, only about 400 lines. :3 
I'm not sure you understand. OP was trying to use the ILP program PROGOL to induce (output) a logic program for the rules of Towers of Hanoi given merely examples of the game being played as input. &gt; Thus, the Towers of Hanoi problem can be simply solved by adding a domain of movement which is "Any block on the top can be moved to position 1, 2 or 3." This is what PROGOL was inducing, because all examples satisfied it. Unfortunately, this rule is wrong, because of the restriction that the block on top cannot be moved to a position where there is currently a smaller block on top. There was no negative example to show that this is not legal.
Sorry I'm a illiteracy and I did misunderstand. Thank you for pointing it out and please forget about it.
well, do you know how to break 375 into 300, 70 and 5?
Here's a quick cheat using bagof/3: extractOverdue(OverdueList) :- bagof(B, (borrowed(B), overdue(B)), OverdueList). 
What's exactly the problem with your code? In any case, the last line in the first backtracking [OverdueList] = Key+RestOf Is screaming at me. Been a while since my last coding something in prolog, but this would be more prolog-ish. The idea is to make this *only* work if it matches *all the conditions*. So you can put stuff on the left if needed! extractOverdue([Key|Rest], Today, [OverdueList | Key ]) :- borrowed(Key, _, _), isOverdue(Key, Today), extractOverdue(Rest, Today, [OverdueList | Key]).
That's the line I was having trouble with! Ohhh the way you did it makes so much more sense! (sorry i'm fairly new to prolog, I only started learning a few days ago). Hmm...although I thought that "extractOverdue(Rest, Today, [OverdueList | Key])." would add each key to the list if it was overdue..I just keep getting "false" as a result...hmmm... I should note that I'm using extractOverdue([book1], 40, A). as a test case, which is borrowed and is overDue as of that date.
Argh, it's been too long since my previous "complex" prolog. There's a problem with my re-definition, since OverdueList is unbound (there is no way to figure out what the value is.) But there's also another problem with your rules. What happens with this "test" case: extractOverdue([], 40, [book1]). Observe that this should be true. If this is not true the recursion can never end, since this is the end state: empty, date, full_list.
Unfortunately I forgot my flash drive with my program on it, but wouldn't that case just activate my first call of extractOverdue([], _, []). ? Then in that case it would just return nothing.
I'm sorry i'm not sure what you mean by this? I'm fairly new to prolog.
This means that prolog can't figure out something during backtracking. In some sense, _S1 *is* an answer, but it is not known what the answer is :D This is what I commented in my previous answer about a variable being unbound. Having in the first "long" clause [Overduelist|key] at the beginning and at the end means that what Overduelist will match is never known, hence the _S1 answer. It is *this* unknown. 
I saw that..and I figured that being an unbound "variable" would have something to do with it...this is my first language like this so I'm fairly noobish when it comes to these terms. I'm sorry I'm having a hard time following you, I think what you're saying is that _S1 is an unknown answer because "Overduelist" never finds a match...agh this is all so confusing. My homework was actually due last night but I appreciate all the help from everyone. I think i'll ask the teacher for help tomorrow because I want to understand this stuff and it would be easier to explain in person(also he's very good at explaining this stuff, it's just that he's hard to get in to see...on the plus side I think I got the farthest on this assignment then most of my other classmates :D) Thanks for the help everyone!
Prolog is very special, and just by trying you'll get a better understanding of programming. I sometimes like to think of prolog clauses as just "matching patterns." So, if you "know" 1,2,3 and are asked 1,A,3 to make it match, A=2. An unbound variable is then something where there is no match, but you asked with such insistence that prolog told you "okay, A is A, got it?" Enjoy prolog, and congrats on having a teacher that explains well in person :)
Ah! That makes sense! Hmm..well thanks for the help :)
I dont know if this helps, but I solved project Euler #17, in prolog, my code is on my github here. https://github.com/gabesotto/Euler/blob/master/PrologSolutions/eulerProblem17.pro I wrote this a long time ago, and I'm sure I could make it cleaner now. But the idea is you make facts to map numbers to how they are spelt, and then you have a recursive predicate that keeps dividing by 10 saving the result and the remainder and recursing on them until you get to zero. 
Well, hopefully you've figured it out from the [answers you've got on Stackoverflow](http://stackoverflow.com/questions/23533281/create-a-list-of-nodes-from-a-graph-in-prolog).
My problem was exactly the order dependancy, the list can be entered in any order and it has to return it with that order but completed. Im trying with some auxiliary functions to eliminate the '_' in the list and proceed with that.
Firstly, `Func` should be `func` - only variables are capitalised in Prolog. Secondly, it only needs one argument. Now, I don't want to give everything away. You could define `func/1` (the `/1` is the arity) as follows: func(Xs) :- perm([g(a,one), g(a,two), g(b,one), g(b,two)], Xs). This means: "`func(Xs)` is true when `Xs` is a permutation of (the given list)". Now how do you define `perm/2`? You can use a predicate `sel/3` defined such that `sel(X, Xs, Ys)` is true whenever Ys is obtained from Xs by *selecting* and removing X. You get all the permutations by nondeterministicially selecting each member of the list in turn and doing this recursively: perm([], []). perm(Xs, [Y|Ys]) :- sel(Y, Xs, Zs), perm(Zs, Ys). How is `sel/3` defined? Well you can have a go at that yourself. I called them `perm/2` and `sel/3` because in SWI-Prolog (and others) they're actually already defined in a library (that automatically loads when you use them) as `permutation/2` and `select/3`. In any case, you can see if you got it right by trying: ?- X = [g(b,one), g(a,one), _, g(a,two)], func(X). X = [g(b, one), g(a, one), g(b, two), g(a, two)] ; % type ; for next solution false. % nope, that's it. You can get all correct solutions to your query. For example: ?- func([g(b,one), X, Y, g(a,two)]). X = g(a, one), Y = g(b, two) ; % type ; for next solution X = g(b, two), Y = g(a, one) ; % type ; for next solution false. % nope, that's it. 
You could use the permutative approach as discussed by /u/mycl. Another approach is subtractive: given your match set, your input set and then your output. func([], [], []). func(Match, [I|IT], [I|OT]) :- select(I, Match, Submatch), func(Submatch, IT, OT). Caveat: I haven't tried this. So, it may be wrong but you get the idea.
Yes i got the idea, and i will give them all a try to this problem! thank you for your help.
&gt; but is there anyway i can have func([g(b,one), _ , g(a,two), g(a,one), X] and the output will be: X = [g(b,one), g(b,two), g(a,two), g(a,one)] ? Well, in this case you can just change func(Xs) :- perm([g(a,one), g(a,two), g(b,one), g(b,two)], Xs). to func(Xs, Xs) :- perm([g(a,one), g(a,two), g(b,one), g(b,two)], Xs).
I'd really like it if there was a venue for long and or deep print,audio and video communication on science,philosophy and art. Markets have gotten larger and also more distracted but at the same time material has gotten glitzy and shorter. 1980s Nova used to be good or maybe that is my rose colored glasses. Question: Do you think there is a market for lengthy challenging material and what would it take to create such a venture? 
If you wish to use union and intersection, then consider that xor == A|B - A&amp;B. So, you'll need a difference rule too.
I was actually trying something in the lines of: if element is not in intersection of the sets place in list Was my reasoning right?
You'd need to walk both sets to do this.
Could you help me out please? Can't seem to figure it out.
I'm getting the following every time: Ans = [1|_&lt;random number&gt;] So I'm doing the first part right, by getting the first element, but apparently confusing the rest.
Sorry, was going to input it and pressed 'save'. Here's all I've got at the moment, sorry if it's nowhere close to the solution. xor([], M, []). xor([X|Y], M, [X|Z]):- \+ intersection([X|Y], M, [X|Z]).
The following predicate works fine with your test case at least: xor(L1, L2, L3) :- append(L1, L2, L4), intersection(L1, L2, L5), subtract(L4, L5, L3).
Using the "not" operator like that won't yield the results you want. I recommend going for the dumbest, most inefficient solution first; then work on optimization. To give you some guidance, your member &amp; intersection rules can be more efficient with a cut operator. memberchk(X, [X|_]) :- !. memberchk(X, [_|L]) :- memberchk(X, L). intersect([], _, []). intersect([A|AT], B, [A|RT]) :- memberchk(A, B), intersect(AT, B, RT), !. intersect([A|AT], B, R) :- intersect(AT, B, R). 
Created the subtract clause, and it did work even with different cases, thanks a lot.
Glad i could help!
Wich prolog implementation are you using?
Assuming your sets are ordered list of numbers without duplicates, you can implement your xor most efficiently (the xor of sets is called the [symmetric difference](http://en.wikipedia.org/wiki/Symmetric_difference), by the way) by walking through both lists with the following algorithm: * Accumulate the result set starting with an empty list. (Use a difference list if you know what that is.) * *Base case:* If either list is empty, append the other one to the end of the result set and return that set as the final result. * *Recursive case(s):* Consider the heads (first elements) of both lists. If they are the same, discard the element from both lists and recurse. If one is smaller, remove it from its list and add it to the end of the result list and recurse. Try to implement that algorithm in Prolog.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Symmetric difference**](https://en.wikipedia.org/wiki/Symmetric%20difference): [](#sfw) --- &gt; &gt;In [mathematics](https://en.wikipedia.org/wiki/Mathematics), the __symmetric difference__ of two [sets](https://en.wikipedia.org/wiki/Set_(mathematics\)) is the set of elements which are in either of the sets and not in their intersection. The symmetric difference of the sets *A* and *B* is commonly denoted by &gt;&gt; &gt;or &gt;==== &gt;[**Image**](https://i.imgur.com/SN5VOYN.png) [^(i)](https://commons.wikimedia.org/wiki/File:Venn0110.svg) - *Venn diagram of The symmetric difference is the union without the intersection:* --- ^Interesting: [^Intersection ^\(set ^theory)](https://en.wikipedia.org/wiki/Intersection_\(set_theory\)) ^| [^Union ^\(set ^theory)](https://en.wikipedia.org/wiki/Union_\(set_theory\)) ^| [^Set ^\(mathematics)](https://en.wikipedia.org/wiki/Set_\(mathematics\)) ^| [^Set ^theory](https://en.wikipedia.org/wiki/Set_theory) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chtuh6k) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chtuh6k)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Are you typing `:-` first at the prompt? Just type `use_module(library(clpfd)).` and press enter. Echoing MrQuimico, what Prolog implementation is this?
No, and again did not find anything on Google. Is there any alternative? I will be trying SWI-Prolog soon, what are the main differences?
I think this will work. ins([], _, []). ins([X|XT], Domain, [X|T]) :- member(X, Domain), ins(XT, Domain, T). Then, replace append(Rows, Vs), Vs ins 1..9, with append(Rows, VRs), ins(VRs, [1,2,3,4,5,6,7,8,9], Vs),
Did not get this, sorry.
It didn't work? Or you don't understand the code?
Both actually.
What was the error? Or did it just not produce any results? As for the code itself, do you have a specific question?
*** It does work *member* will walk through the list given by Domain. It's defined as: member(X, [X|_]). member(X, [_|T]) :- member(X, T). So, in your case, you'll be building output lists based on membership of Domain. I say "output lists" because Prolog backtracks to yield all possible combinations. You can try it stand-alone to understand... ?- ins([_, _], [1, 2], Out). BTW, "\_" is an anonymous variable. So, in this case, [\_, _] has two unbound elements. If I wrote it correctly, you should see: Out=[1, 1] Out=[1, 2] Out=[2, 1] Out=[2, 2]
So, the *ins* implementation I gave you does work. However, it will be inefficient as you want distinct numbers, that is, permutations of *Domain*. Adding: *ins* produces all possible [multisets](http://en.wikipedia.org/wiki/Multiset) which is just extra work for *all_distinct*. I recommend you do the following: append(Rows, Vs), perm(Domain, Vs), where *perm* is given by: perm([], []). perm([X|R], L) :- perm(R, L1), select(X, L, L1). 
Thanks for your response. I've correct the original post - I was trying to be general but clearly that didn't work as intended - I was also quite frustrated when I posted it so I apologise for the poor quality post. An example list actually looks like this: `test1([[],[csse1001,math1061,eltv1001,math1051],[deco1400,infs1200,eltv1005,math1052],[csse2002,csse2010,eltv2001,eltv2002],[deco2800,csse2310,eltv2005,eltv2006],[comp3506,deco3800,eltv3001,eltv3002],[csse3002,deco3801,comp3702,infs3204]]).` or `test2([ [ csse1001,math1061,eltv1001,math1051,deco1400,infs1200,eltv1005,math1052, csse2002,csse2010,eltv2001,eltv2002,deco2800,csse2310,eltv2005,eltv2006, comp3506,deco3800,eltv3001,eltv3002 ], [],[csse3002,deco3801,comp3702,infs3204] ]).` They're course codes for university subjects, and are only offered in semester1 or semester2 - the list is in the form: [[priorlearning], [y1sem1], [y1sem2], [y2sem1] ...] if an item e.g. `[csse1001,math1061,eltv1001,math1051]` is in position it is in, then I have to check that those subjects are all legal semester 1 subjects. The test I want to make is on, for example, "csse2002" has: s1(csse2002). But "deco1400" might have: s2(deco1400). 
OK. I would rather structure the data something like curriculum(PriorLearning, [year(Y1Sem1,Y1Sem2), year(Y2Sem1,Y2Sems2), ...]) where `PriorLearning`, `Y1Sem1`, etc. are like the course lists you have above. This makes that fact that semesters come in pairs more explicit and allows them to be more easily processed as such. Regardless of that, the basic template to express the predicate on lists that holds when each member of the list satisfies a specific predicate (`s1`, for example) is as follows: s1_list([]). s1_list([Course|Courses]) :- s1(Course), s1_list(Courses). You could read this as: "`s1_list` is true on a list when it is empty or when `s1` is true on the first element of the list and `s1_list` is true on the rest of the list. Of course, you can then write the corresponding `s2_list` predicate by just replacing `1` with `2` above. You can also factor out this template using a metapredicate call: maplist(_, []). maplist(Pred, [X|Xs]) :- call(Pred, X), maplist(Pred, Xs). Your Prolog implementation probably already provides this `maplist/2`. Then you could also just write `s1_list(Courses)` as `maplist(s1, Courses)`, etc.
Unfortunately we're forced to structure the data the way I have it. How would I get to a point where I can plug in `[[],[csse1001,math1061,eltv1001,math1051],[deco1400,infs1200,eltv1005,math1052],[csse2002,csse2010,eltv2001,eltv2002],[deco2800,csse2310,eltv2005,eltv2006],[comp3506,deco3800,eltv3001,eltv3002],[csse3002,deco3801,comp3702,infs3204]])` into this s1_list? Thank you very much for your help though, I'm going to give it my all with maplist and that s1 thing you were wrote there. Thanks again. p.s. writing that out (the equivalent in English) gave me so much clarity, really helped me a lot.
Can't you do something like: test([]). test([A, B | Tail]) :- p1(A), p2(B), test(Tail). That should divide the list into "pairs" (A, B) and applies p1 to A and p2 to B.
I wasn't aware you could do something like that. So something like this: %% semestersok([Prior,S1,...,Sn]) :- study plan with semesters S1-&gt;Sn and prior study Prior meets timetable requirements semestersok(SP) :- ??? checkSem([]). checkSem([A, B | Tail]) :- s1(A), s2(B), checkSem(Tail). Where SP is the list in question.
I thought you had a list within which were pairs of lists you had to verify independently, in which case `checkSem` would be the `semestersok` you're looking for. Is there something I'm missing?
It works like this: `semestersok([[],[csse1001,math1061,eltv1001,math1051],[deco1400,infs1200,eltv1005,math1052],[csse2002,csse2010,eltv2001,eltv2002],[deco2800,csse2310,eltv2005,eltv2006],[comp3506,deco3800,eltv3001,eltv3002],[csse3002,deco3801,comp3702,infs3204]]).` Where by, all the elements in the first element in the list of lists have to satisfy s1() and all the elements in the second element in the list of lists have to satisfy s2(). e.g. [csse1001,math1061,eltv1001,math1051] all need to be s1(csse1001), s1(math1061), etc. [deco2800,csse2310,eltv2005,eltv2006] all need to be s2(deco2800), s2(csse2310), etc. 
Hahah this is awesome. I finally understand (Sort of...). Thank you very much kind stranger. This works great when they're in lists but can't quite do it automatically, I need to add a bit more code to get them into the forms that the s1_list/s2_list relations can accept. I.e. how do I get `[[],[csse1001,math1061,eltv1001,math1051],[deco1400,infs1200,eltv1005,math1052],[csse2002,csse2010,eltv2001,eltv2002],[deco2800,csse2310,eltv2005,eltv2006],[comp3506,deco3800,eltv3001,eltv3002],[csse3002,deco3801,comp3702,infs3204]]` into `[] %% remove this` `[csse1001,math1061,eltv1001,math1051] %% use s1_list` `[deco1400,infs1200,eltv1005,math1052] %% use s2_list` `[csse2002,csse2010,eltv2001,eltv2002] %% etc.` 
Right, so you want to remove the first element? Well, there's a couple of ways to do this, but the easiest perhaps is to just throw it away at the start, and do the checks after. So if we take the definition of `semestersok` I wrote before and rename it to `checkSem` as you suggested before, we can write the new `semestersok` as the predicate that accepts a list, of which it needs to throw away the first element, then call `checkSem` on the rest. Like this: semestersok([_ | Tail]) :- checkSem(Tail). Note that this also means that if the list has no first element (it's empty), it fails the check.
You're a genius. If I get this working, I shall buy you reddit gold or donate to your favourite charity! P.s. does it have to be named Tail? Or can it be named something more relevant.
As long as you rename all references it can be named anything you want (though of course variables need to start with a capital letter).
Here are some answers, in case they are still relevant: **First Question:** We write Prolog almost exclusively with *predicates* rather than *functions*. This terminology helps us stay mindful of the fact that, as a rule, statements of the form *functor(arg1, arg2, ..., argN)* do not "return" any value aside from their truth value. Predicates cannot be composed by passing one as an argument to another, which is what you're trying to do with *elementAt(X, Tail, -(Index, 1))*; instead, predicates must receive values from other predicates by sharing variables. Thus the need for *NewIndex is Index - 1*. However, *arithmetic functions* appearing in the second argument of *is/2* are an exception: e.g., if you call *X is 2 - 1* (which is equivalent to (*is(X, -(2, 1))*) then *X == 1* will be true. Arithmetic function are evaluatedwhen they occur in special contexts, (e.g., in the second argument of *is/2*, or on either side of the arithmetical equality operator *=:=/2*). Having to write ... NewIndex is Index - 1, elementAt(X, Tail, NewIndex). instead of just ... elementAt(X, Tail, (Index - 1)). Obviously adds to the verbosity of the language. On the other hand, it keeps things very clear and explicit. More importantly, the fact that Prolog doesn't evaluate a predicate's argument allows one to take full advantage of the homoiconic nature of the language, and facilitates a style that freely uses meta-programming tropes. E.g., you can pattern match on arithmetic expressions, construct a partial arithmetic expression in place and evaluate it in another, or just use the minus sign to help structure arguments. **Second question:** When you query your first definition of *numElements/2*, you must pass it a a free variable as its first argument, in the hopes that it will ultimately be instantiated with a value equal to the number of elements in the list occupying the second argument. Then, when Prolog tries to resolve *NewX is X - 1*, it must subtract 1 from a free variable, which is an instantiation error. Tracing a query to your first definition makes the problem clear: ?- trace. true. [trace] ?- numElements(X, [1,2,3]). Call: (6) numElements(_G1500, [1, 2, 3]) ? Call: (7) _G1585 is _G1500+ -1 ? ERROR: is/2: Arguments are not sufficiently instantiated Exception: (7) _G1610 is _G1500+ -1 ? Exception: (6) numElements(_G1500, [1, 2, 3]) ? The answer given doesn't run in to this problem, since it calls *X is NewX + 1* **after** the recursive call to *numElements/2*, so that, procedurally, the definition will strip away all of the elements in the list until, reaching the empty list, it instantiates *NewX* with 0. Only then does it start to uncoil from the recursion, adding 1 to *NewX* at each level of its unfolding. Generally speaking, it seems to me that your approach of *deriving* the number of elements by subtraction doesn't make sense to me: it requires that we have an initial value to subtract from, which must already be the value of the number of elements in a list if it's going to turn out right. On the other hand, your definition would work to *verify* that a given number is the correct number of elements in a list. Hope this info is still useful! How are your Prolog studies proceeding? 
FYI: your question got trapped in the spam filter (for no reason I know of). I just released it this morning, but could you tell us whether or not your question is still relevant?
ah this is really great. Thanks a lot! It took some trying by hand and thinking deep, but this helped! If there are several clauses after the :- (do you call them *definitions*?), is it so that always the first clause will be considered first, and if it is a recursive call, we follow the whole recursion, before we consider the following clause? 
I use Sicstus prolog, but it has support to call C and Java libraries. Perhaps if you're having trouble you could try the twitter api calls with either C or Java. Transform the returned data into prolog lists or facts and then use the data that way? Just a thought.
Yeah it is an idea, but I am just really trying to do this to learn more prolog and see what is possible. So it would not really be why I am trying to do it, I want to learn about api's in the process and try and do a few different connections to different services.
Very glad I could help! Sorry we are a bit slow and sleepy sometimes on this subreddit. The short answer to your question is *yes*. But here's some terminological correction and (over) elaboration: A *clause* is either a *fact* or a *rule* (and those are both definitions). A fact is a bare assertion at the top level, e.g. this_is_a(fact). A rule is created using the operator *:-/2* (which we can read as "... if ___"), and has the form &lt;head&gt; :- &lt;body&gt;. The body is a statement (often a conjunction using the *,/2* operator; thus: *p(X), q(Y)*). You are correct about Prolog's procedural operation when evaluating the body of a rule. In a conjunction, Prolog calls each of the conjuncts sequentially, and the conjunction as a whole is true iff each of the conjuncts is true. This procedural nature of Prolog's evaluation strategy makes it an *impure declarative language*: in a purely declarative language, simply stating things correctly would suffice to describe the intended program, regardless of the particular order of the statements; *Prolog's procedural impurity requires that we also state the right things in the right order*. The ability to write non-tail-recursive rules is one artifact of the procedural execution. You can use side effects (e.g., *writeln/2*) to observe the procedural execution in action: ?- 1 =:= 1, | writeln('This line will be written.'), | 1 =:= 0, | writeln('This line will not be written, since the preceeding statement will fail, and Prolog will simply report "false".'). This line will be written. false. Note also how this works with free and bound variables: procedural_evaluation_example :- format('Outputting an unbound variable yields the variable's ID:~n ~w~n~n', [Variable]), Variable = some_value, format('After binding the variable, outputting the same variable yields the appropriate value:~n ~w~n~n', [Variable]). Querying *procedural_evaluation_example/0*: ?- procedural_evaluation_example. Outputting an unbound variable yields the variable ID: _G3532 After binding the variable, outputting the same variable yields the approriate value: some_value true. Sorry for over-explaining! It should be noted that lots of things can be achieved by leveraging Prolog's backtracking and its procedural execution. We welcome all questions and discussions here! But you should also be aware that answers to technical questions can probably be obtained quicker on StackOverflow with the [prolog] tag.
Were you able to find someone to work with?
How about a roguelike? http://ansuz.sooke.bc.ca/software/golorp.php
There's an AI contest over at [Vindinium](http://vindinium.org/) You'd have to implement the http comms yourself but they have a variety od sample bots written in various languages.
That conflict/2 parts of valid/2 get evaluated only after pressing semicolon makes sense if it the result is true; false. The ; (in the code) is a disjunction and creates a choice point. The entire expression (X ; Y) is true if X is true *or* Y is true. So in this case (\\+ Reg1 = Reg2) gets evaluated first. If this is true, the entire disjunction is as well and then the call to valid/2 is as well, so True is returned. When you hit semicolon after that, prolog will backtrack to the last choice point and try the next branch. (informally, it pretends that the call (\\+ Reg1 = Reg2) failed). The last choice point is the disjunction, so now the other side of that disjunction (calls to conflict/2) is evaluated. So that's the reason why those calls seem to be evaluated 'separately'. However, if the first call of a disjunction fails, prolog should backtrack automatically to evaluate the other side. In other words, I don't think the return False;True should *ever* happen. I don't know why it does for you. The only thing I can think of is that it seems that the evaluation of both sides of the disjunction is given separately. *Maybe* there's versions of prolog that just handle the disjunction this way (only ever used SWI myself) or there's a setting for it somewhere? I'm not sure what is going on, but you could try and see what happens when you eliminate the ; from your program, using two clauses of valid/2. As to the other problem, it's hard to tell what's going on without seeing the code, but it may be part of the same problem, given that you are using valid/2. Anyway, I hope this helps your understanding a bit, even though I don't know what's going wrong. Best advice I can give: I'd try to eliminate the ; from the program to see what happens then. 
&gt; However, if the first call of a disjunction fails, prolog should backtrack automatically to evaluate the other side. In other words, I don't think the return False;True should ever happen. I don't know why it does for you. I find this strange, too, but perhaps arbitrary_student saw it while tracing, where the first failure would be shown, of course.
He specifically mentions hitting semicolon though. I think that would give an invalid command warning mid-trace.
I've switched to SWI and it no longer does it on the False;True. Thanks for the heads up that this was unusual behaviour.
Cuts are the greatest thing of all time. Thank you very much for taking the time to respond, I really appreciate the help - I'm gonna experiment with the if-then-elses as well and see what I can come up with. Thank you again! Update: Breezing through these exercises now that I know what cuts are and how to use if-then-elses
What about building a recommendation engine for anime?
The code in my reply draws from the stylistic suggestions I made in a separate reply. To get the summary data you want, you'll need to either (A) thread the info through your program, or (B) use a dynamic database. Approach (A) means adding in an extra argument to all of your predicates, which will pass through a list accumulating the answers given. I'd probably go with this solution myself, as it keeps you from having to deal with the non-logical, sometimes opaque behaviors that result from changing the database during run time. For example, your clause for `hungry/0` might end up looking like so: hungry(Answers) :- write('Are you hungry?\n'), read(Answer), nl, ( affirmative(Answer) -&gt; alternate(z, [hungry=yes|Answers]) ; negative(Answer) -&gt; yes([hungry=no|Answers] ; invalid ). At each decision, the predicate receives a list of past `Answers`, and you'll add the new answer to the list that gets passed along to the next. For (B), you need use a dynamic database. The SWI-Prolog author, Jan Weilmaker, offers [an insightful warning against doing so](http://www.swi-prolog.org/howto/database.txt). It might be good to implement your program both ways, so you can see the differences and practice the concepts. If you go for (B), each time information is entered, you'll assert a new fact into the database. You might, for instance, rewrite `hungry/1` thus: hungry :- write('Are you hungry?\n'), read(Answer), nl, ( affirmative(Answer) -&gt; assertz(hungry(yes)), alternate(z) ; negative(Answer) -&gt; assertz(hungry(no)), yes. ; invalid ). Then you can collect your summary answers at the end by querying your asserted facts `hungry/1`, `raining/1` etc. Alternatively, you could just have a single predicate, `answer/1`, that recorded the answers given. In this case, you'd write the consequent of the conditional like `... assertz(answer(hungry=yes)) ....` Then you could collect all summary information just by finding all the values of `answer/1`, thus: `findall(Answer, answer(Answer), Answers)`, and `Answers` will be a list like `[hungry=yes, raining=no, ...]`. If you're not familiar with dynamic predicates, you should read up on them in your implementation, as they produce some behavior you might not expect. E.g., if you don't clear the database of your dynamically asserted facts between running the program, you'll end up with multiple answers recorded. 
I hope you don't mind some unsolicited advice on style. These things are just according to my personal opinion: Instead of testing for `y` and `yes` in each clause, you could write a predicate to test for both: affirmative(y). affirmative(yes). negative(n). negative(no). Then your conditional will look like `affirmative(Answer) -&gt; thing_to_do ; negative(Answer) -&gt; other_thing ; ... `. You might also write a predicate to handle invalid input, saving the repetition of that statement: invalid :- write('\nInvalid Input!!!\n'), fail. Conversely, I'm not sure what you gain anything by having a separate rules for, e.g., `hungry(yes)` and `hungry(no)`. In particular, I think you could really shorten up `waitestimate/1` by omitting these extraneous rules: waitestimate :- write('What is the estimate waiting time?(write in minutes, ex:50)\n'), read(Time), nl, ( Time &gt; 60 -&gt; no ; Time &gt; 30 -&gt; alternate ; Time &gt; 10 -&gt; hungry ; Time &gt; 0 -&gt; yes ; invalid ). That is both more concise and, in my estimation, easier to understand.
Sounds like you're still calling `hungry/0` from within the body of `waitestimate/1`. I only gave example code in my reply, for illustrative purposes, and to get it working properly, you'll need to make the appropriate changes to the rest of the program too. If you post your revised program, I'll be happy to take a look.
The best place to ask this is on the [SWI-Prolog Google group](http://www.swi-prolog.org/forum). If you're using an older version of SWI you may also have better luck with the latest [development version from the PPA](https://launchpad.net/~swi-prolog/+archive/devel).
https://news.ycombinator.com/item?id=8305486
I think articles like this miss the point of Prolog somewhat. After reading *The Reasoned Schemer* and playing with miniKanren I was quite infatuated with this embedding of logic programming into functional programming where predicates are modelled as functions returning streams of bindings. miniKanren offers luxuries like "fair" (interleaved) disjunction that the Prolog programmer can be quite jealous of. But Prolog is impure for a reason. Warren showed that Prolog's (unsound) unification and backtracking can be implemented with very little efficiency loss by slightly modifying the conventional imperative operational model. Pure logic programming libraries such as those discussed in this paper look very elegant when implemented in functional languages, but they are fundamentally interpreters. You can write logical language interpreters as pure, declarative and feature rich as you like in any programming language, whether it be Haskell or indeed *Prolog itself*. Part of Prolog culture is recognising precisely what the declarative shortcomings of "Classical Prolog" (as they refer to it) are and writing (meta)interpreters to compensate for them, as needed. In my view, Prolog has the misfortune of being the simplest compromise between imperative programming and pure logic programming and therefore being seen as weird by adherents of the former paradigm and looked down upon by fans of the latter - this paper being a prime example.
I tend to think of Prolog as two parts: an efficient mechanism to manage a term bank (a subset of which -- clauses -- are special) with unification to find the term you want; and resolution/execution semantics on clauses. I would be happy to have the first part as a library and implement the second part myself using whatever style that is convenient for the problem (think of Coq, for example, which uses imperatives to evolve the proofs). A term bank that is completely reflective of the program and a Prolog interpreter to interact with the term bank would be nice to have but efficiency of the interpreter itself is not a big concern. 
Well, for me that's the crux of the matter. Prolog allows an implementation where the execution strategy is inextricably linked to the database (I assume that's roughly what you mean by the "term bank"): clauses are not merely terms that are interpreted but instead play the role of procedures and are *compiled*. Only clauses that are explicitly declared `dynamic` must be allowed to be inspected, asserted and retracted. If efficiency is not a concern then the case for purer logic interpreters operating over such databases is much better. Or, if you want to separate logic from proof procedure then what you suggest makes a lot of sense. But I like logic programming because I want to *program* in *logic* without a huge performance penalty.
I wrote my own language; I call it Epilog. It does backtracking and has minimal unification. Execution is scheduled on the backend; I got rid of the depth first semantic entirely. It also means no 'cut' or order-dependent execution at least as a first class language feature.
I didn't call it database because terms can have logical variables and unification is used to find terms, not what typical relational database could handle. I agree that logic programming would be nice but it is difficult to do programming in the large and one quickly needs to resort to non-logical schemes. My beef with the paper is that the search strategy part isn't usually the problem and it is not hard to implement different search strategies in Prolog as you mentioned. I like Prolog as a top level to examine and interact with but I would be okay to have other schemes to change the program state (encapsulated by the term bank). I guess we are talking about two different aspects of Prolog: your point is that efficiency is important if one depends on logic programming (at least in style) to do most of the work; my point is that as one goes meta-logical, I don't care what is accomplishing the job so long I could examine the results with Prolog and I would like be able to use Prolog at the toplevel rather than a logic library. But we seem to arrive at the same conclusion that a logic library seems to miss the point (neither efficient nor providing the experience of interacting through a Prolog shell). 
Interesting! I'm not big on theory, but I do use a lot of Prolog, and have started looking at specializing the variant I use to improve it in certain ways. Since I find the logic formulation of Prolog so useful and handy, I've pondered if a more declarative approach wouldn't be even better.. Is this your stuff?: http://www.cs.rochester.edu/research/epilog/
You can rethinking anything, there is no perfect language. You have to have a balance and for what it is, Prolog delivers. SWIProlog is extending the language in little ways to make it more useful and modern. 
No. I haven't released it. Same name though. The language is a little Erlang-y in that it can execute across a distributed environment. It treats predicates disjunctively. It's also pretty low level. For example, there's a conditional branch instruction. Works pretty well for what I need though.
It's easier for us to help you if you give a concrete code example and explain what you don't understand about it.
I was thinking more in direction of where I can find some good tutorials, some helpful examples of recursion. Meta prolog stuff.
If you're stumped on recursion generally, maybe read the [wikipedia article on the topic](http://en.wikipedia.org/wiki/Recursion). Or, if you're more familiar with Java, check out [this StackOverflow answer](http://stackoverflow.com/questions/15941818/java-understanding-recursion) on recursion in Java. As far as I know, there's nothing special about recursion in Prolog. I got to understanding recursion through studies in logic and the philosophy of mathematics, several rereadings of the first chapter of [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sicp/full-text/book/book.html) and lots of playing around with Scheme, Haskell, and Prolog. I have spent a lot of time operating under a partial understanding of recursion. But my understanding has gradually deepened as I studied more and became more familiar with using it to solve problems. If you understand the topic well enough to complete the kind of exercises you're dealing with, it might be helpful to just bracket the mysterious parts and move forward with your studies. You can revisit the topic when you run into problems, and each time you do your understanding will expand. There are two relatively simple examples of recursive definitions which you might find illuminating: (1) the factorial function and (2) the structure of lists. Have you encountered these yet? If not, we can talk over them a bit here to see if that will help. As for Prolog-specific resources on recursion, I recommend *The Art of Prolog*. I have found it introduces things in a very understandable way. 
Recursion is pretty much the only way to loop in Prolog. Do you understand recursion in general? Prolog isn't so different from other languages in how this is accomplished. In the simplest scenario, a function just calls itself with some sort of exit criteria.
I feel I have a good grip on recursion in general, it's just a mystery when it comes to programming. And i still tend to think in the if-then and for-loop Java style way. Gonna take a look at the examples mentioned in another answer today, and just repeat until I hopefulle accept and understand this. Thanks for all help! 
Since it's not (yet) mentioned there, let me say that [tuProlog](http://apice.unibo.it/xwiki/bin/view/Tuprolog/) also works well on Android - I've got it installed on my phone. I don't think there are any CLP libraries for it, though, but it has very tight integration with Java.
Thanks for sharing these! I put it in on the google+ group thing. I really enjoyed Michael's presentation. Anne's was more difficult for me to follow (just because I am semi-literate literate programmer, and her talk is about a specialized, bleeding edge development).
Yes, I'm regularly using the [SWISH](http://swish.swi-prolog.org) interface (which is based on pengines) to interact with SWI-Prolog, and it's getting better every day! Definitely worth a look.
Can anybody comment on how useful the bisecting debugger from Mercury is? It's the first time I've ever heard of such a thing. I can't imagine it is as useful as it sounds. When I'm debugging, I need to know beforehand the part of the application I'm looking at because my brain is too small to keep the entire application in my head. If the debugger throws some unknown point in execution at me to determine if it's correct, I'm unlikely to be able to make sense of it
I haven't used them. I have serious reservations about their utility for *ordinary* web development, but it's quite possible that I'm failing to see the full potential, especially for the collaborative and educational applications Anne Ogborn is interested in. (I replied that you shouldn't need them when you asked about AJAX.) The JavaScript client usage is where the alarm bells started for me. When you request a page that uses the JS pengine client, the server might send a page with Prolog code inside `&lt;script type="text/x-prolog"&gt;`. The browser then sends that Prolog text *back* to the server, where library(sandbox) has to *check* that it's safe, before allowing the client to run queries against it. That just seems very silly. If you want code to run on the server, keep it there and run it there. If you want to run Prolog in the browser you need a Prolog implementation in JS - admittedly we don't have any outstanding options there yet, but that's where I would focus my efforts. I agree with zmonx that SWISH is nice, but ultimately we want a Prolog environment that is purely browser-based. The mere fact that a sandbox is needed for pengines already smells like poor design to me. You don't see the Python, Node or Ruby web development communities advocating for exposing REPLs to sandboxed VMs as web interfaces on the open web; making such sandboxes totally safe is a security nightmare.
I recommend the first couple of chapters of this book: http://books.google.co.uk/books?id=fbYjjEn6a_4C&amp;printsec=frontcover#v=onepage&amp;q&amp;f=false
I'm very new to prolog, but this doesn't feel prologish to me. read's like a C code.
Understood, but although my "bad reasoning" *was* bad - it's not a valid description of how Prolog interprets that code - it's not bad in the sense of being a useless requirement that I should never want to implement. Part of what I'm asking is how to implement that IMO obvious sense of equality (and one that seems closer to equality in first-order logic than Prolog unification). Is there already a library or standard predicate that I'm missing? Is there an idiom that resolves the issue? Is there a simple way to collect assumptions I've made for a particular line of reasoning (such as A and B must never be proven equal) and check them later? **EDIT** - that bit about collecting assumptions to check later might be me accidentally answering myself. Keeping a list of assumptions made so far so they can be checked later probably isn't much of a hardship, esp. given that code is data. 
There is no purely logical way to read negation. You define it by your operations. In Prolog it is the closed world assumption -- that is what is not known right now is not true (since right now we don't know that A and B can't unify therefore A\=B is always false). If you don't like that you have to introduce some other model semantics: answer set, constraints or what not. == is also meta-logical and solves your problem. There is no pure logical answer to your question.
I know about the closed world assumption. It cannot be the absolute roadblock you claim it is. Prolog is Turing complete. Therefore, it can compute anything that a Turing machine can compute. The only problem is how to express what I want such that Prolog can interpret it and give the correct result. I just need to figure out how to express what I want to Prolog - and that's what I was asking about. I already know that unification doesn't mean what I originally wanted it to mean. I already explained that misunderstanding in the original post. I didn't specifically say that if I'd misunderstood unification I'd also misunderstood it's negation. OK, but that's still already understood. 
Not sure what you are looking for. But since there is no logical reading to it there is also no one answer to it. You define it by what you implement. For example, you could simply have two clauses: pack(L1, L2) :- pack_by_unification(L1, L2). pack(L1, L2) :- pack_by_equality(L1, L2). Or maybe you are looking for coroutining, with freeze or when, for example, which can also be used to build constraints.
Those two clauses - yes, but that's not keeping track of the assumption underlying each case. As in my edit to my [comment here](http://www.reddit.com/r/prolog/comments/2hqhy5/confusion_about_equality_vs_unification/ckv4qgh), that probably just means I need to track the assumptions explicitly. Perhaps a predicate `eq_or_not(Arg1,Arg2,Prior_assumptions,Assumptions)`. It also means already-instantiated cases will yield duplicate results - `[a,a,a,b,b]` will yield `[[a,a,a],[b,b]]` twice. I'm not ready for co-routines, but I'll make a note that this may relate. 
You can try but the problem is intractable in principle. For example will you also handle comparisons of a(X, Y) and a(S, T), or even a(X, c) and a(b, Y), or X and [1,2,Y], or X and [1|Y]? What about deeper nesting levels or higher arities?
Here's what I came up with... /* ** eq is a speculative if-then-else equality predicate. ** ** The first two arguments may be either equal or unequal. Both ** possibilities are considered. ** ** The equal case is handled by unification. The third argument ** (an if-case predicate) is called for this case. ** ** The unequal case is handled first by using `\==`, but also by ** recording the new assumption for later re-checking. The fourth ** argument (an else-case predicate) is called for this case. ** ** The fifth and sixth arguments are the prior assumptions and ** the resulting assumptions. Both are code called using `call/1`, ** like the if-case and else-case. */ eq(X,X,IfCase,_,Assum,Assum) :- call(IfCase). eq(X,Y,_,ElseCase,Prior,Assum) :- X \== Y, call(ElseCase), Assum = (X \== Y, Prior). /* ** Arguments to take_all_same/6 are... ** ** 1: The element to take ** 2: The source list to take matching elements from ** 3: The taken elements list ** 4: The remaining elements list ** 5: Prior assumptions ** 6: Assumptions after the take ** ** This is a simple enough in principle, but clunky and ** hard to read as expressed here. Need a better ** Prolog metaprogramming style. */ take_all_same(_,[],[],[],Assum,Assum). take_all_same(X,[H|T],Taken,Remain,Prior,Assum) :- eq(X,H, (Taken=[H|Taken2],take_all_same(X,T,Taken2,Remain,Prior,Assum1)), (Assum1=Prior,Taken=[],Remain=[H|T]), Assum1,Assum). /* ** Convenience take_all_same/5 ** ** The case when there are no prior assumptions. */ take_all_same(X,S,T,R,Assum) :- take_all_same(X,S,T,R,true,Assum). /* ** The main pack/4 predicate. Arguments are... ** ** 1: The list to pack ** 2: The result ** 3: The prior assumptions ** 4: The resulting assumptions */ pack([],[],Assum,Assum). pack([AH|AT],[BH|BT],Prior,Assum) :- take_all_same(AH,AT,Taken,Remain,Prior,Assum1), BH = [AH|Taken], pack(Remain,BT,Assum1,Assum). /* ** Convenience pack/3 ** ** The case when there are no prior assumptions. */ pack(X,Y,Assum) :- pack(X,Y,true,Assum), call(Assum). The code is clunky, but seems to be doing what I'd expect. For example... 1 ?- pack([a,a,a,b,b],X,Assum). X = [[a, a, a], [b, b]], Assum = (a\==b, true) ; false. Boring case - the assumption recorded is redundant but valid. 2 ?- pack([A,A,A,B,B],X,Assum). A = B, X = [[B, B, B, B, B]], Assum = true ; X = [[A, A, A], [B, B]], Assum = (A\==B, true) ; false. With no way to decide whether A and B are equal or not, both cases are tried. Only the not-equal case needs an assumption recorded. 3 ?- pack([a,a,a,B,B],X,Assum),B=a. B = a, X = [[a, a, a, a, a]], Assum = true ; B = a, X = [[a, a, a], [a, a]], Assum = (a\==a, true) ; false. We don't tell Prolog that `B=a` until it's too late for `pack`. We still get two cases, but the second has a contradiction in the assumptions. 4 ?- pack([a,a,a,B,B],X,Assum),B=a,call(Assum). B = a, X = [[a, a, a, a, a]], Assum = true ; false. As the assumptions are recorded, we can recheck them to eliminate the self-contradictory cases. More complex terms? 5 ?- pack([h(a,b),h(a,b),h(A,b),h(a,B),h(a,B)],X,Assum). A = a, B = b, X = [[h(a, b), h(a, b), h(a, b), h(a, b), h(a, b)]], Assum = true ; A = a, X = [[h(a, b), h(a, b), h(a, b)], [h(a, B), h(a, B)]], Assum = (h(a, b)\==h(a, B), true) ; X = [[h(a, b), h(a, b)], [h(A, b)], [h(a, B), h(a, B)]], Assum = (h(A, b)\==h(a, B), h(a, b)\==h(A, b), true) ; false. No problem - Prolog is dealing with that, same as ever. Just for fun... 6 ?- pack([h(a,b),h(a,b),h(A,b),h(a,B),h(a,B)],X,Assum),A=B,call(Assum). A = B, B = a, X = [[h(a, b), h(a, b), h(a, b)], [h(a, a), h(a, a)]], Assum = (h(a, b)\==h(a, a), true) ; A = B, X = [[h(a, b), h(a, b)], [h(B, b)], [h(a, B), h(a, B)]], Assum = (h(B, b)\==h(a, B), h(a, b)\==h(B, b), true) ; false. It doesn't seem intractable ;-) 
You can use the term inequality constraint `dif/2`, which is not part of ISO Prolog but is supplied by all implementations providing constraint logic programming (CLP), [including SWI](http://swi-prolog.org/pldoc/doc_for?object=dif/2), because it's the simplest constraint beyond plain Prolog. It gives you exactly what you were hoping for, i.e. just by replacing `X \= H` in your code above with `dif(X, H)`, I get the following interaction: ?- pack([A,A,A,B,B], X). A = B, X = [[B, B, B, B, B]] ; X = [[A, A, A], [B, B]], dif(A, B) ; false. 
Awesome response! dif/2 is exactly the right thing to use here, because it also works when its arguments are variables.
Very nice! Your effort is clever and commendable. Now I see what you were saying. I see where my mistake was. While negation is metalogical, A\=B does not involve clauses and is a syntactical question that can have a logical reading. A==B |- A=B is obvious. But I think it also happens that under mgu A=B |- A==B. Now Prolog's native implementation is not logical: for example if you ask :- A\==B, A=B., it would answer affirmatively. By arranging to effectively change this to a question of :- A\==B, A=B, A\==B., you have restored a logical reading by deploying metalogical means to correct Prolog's logical defect. Good job.
Also have a look at the previous section on [attributed variables](http://swi-prolog.org/pldoc/man?section=attvar) if you want to get an idea of how these coroutining and CLP predicates work under the hood. Most Prologs do it this way now. For example: ?- freeze(X, X mod 2 =:= 0), dif(X, 4), get_attrs(X, Attrs). Attrs = att(freeze, user: (X mod 2=:=0), att(dif, vardif([_G3847-4], []), [])), freeze(X, X mod 2=:=0), dif(X, 4). `Attrs` has the attributes defined on the variable `X` at that point. You can see `freeze/2` and `dif/2` have both left hooks on `X`. When `X` gets unified, control is passed into those hooks to respond accordingly - I guess that's why they call it "coroutining". If I'm not mistaken, Prolog's backtracking behaviour is very closely related to generators as found in Icon and Python. Take a look at [Yield Prolog](http://yieldprolog.sourceforge.net/) to see how Prolog can be compiled into languages with a `yield` keyword.
That initial Yield Prolog explanation looks to me looks a lot like an idea I've had for a long while - probably since around the time, long ago, when I played with Icon for a bit. A lot of people would call it an abuse of exceptions - throwing for success rather than failure. Depth-first search would seem an obvious case. To me, this seems cleaner than having the function check for the-recursive-call-succeeded cases... int search_unordered_bin_tree (NODE *n, int v) { if (n == NULL) return; if (n-&gt;value == v) throw found_at(n); search_unordered_bin_tree (n-&gt;left); search_unordered_bin_tree (n-&gt;right); } A similar approach could even handle LR parsing - throw for reduce, catch at the point the non-terminal symbol is shifted. Recursive descent and LR parsing become pretty much the same thing - though of course you still have to work out the state model. It's also interesting that if you replace `throw` with `yield` (and deal with some details) in that LR parsing example, you end up with backtracking LR parsing. Anyway, I used to think of Icon as kind-of imperative Prolog - it's main execution model is basically backtracking depth-first search, just without the unification. Being imperative, it was actually a bit too close to Prolog for me at the time - I wanted the relative operators to give boolean results, with an `if` construct to trigger failure and an `else` construct to catch failure - like a functional `if-else`, but as two separate control constructs. 
 You mean like: memberchk(&lt;value&gt;, Lst), X=1. ?
Well, that would work in the case when the value is in the list, but if the value isn't in the list, I'd like X to be set to 0 and the program to continue execution from that point forward.
When you reach reverse(A,B) the list A has an unbound variable as its tail. Reverse apparently introduces a choice point, starting with an empty list and then increasingly larger lists. Here is a transcript from SWI: 10 ?- reverse([1,2,3],A). A = [3, 2, 1]. 11 ?- reverse([1,2,3|_],A). A = [3, 2, 1] A = [_G424, 3, 2, 1] A = [_G424, _G430, 3, 2, 1] A = [_G424, _G430, _G436, 3, 2, 1] ..forever
You should probably only call it with an empty list as second argument: pirateTalk(S) :- pirateTalk(S, []).
In your current implementation the second argument of `pirateTalk/2` is an accumulator for the part of the input that was already translated, not for the final result. The translation of `"abe"` proceeds roughly like this: pirateTalk([97, 98, 101], []). pirateTalk([98, 101], [97]). // clause 2 pirateTalk([101], [98, 111, 98, 97]). // clause 3 pirateTalk([], [101, 98, 111, 98, 97]). // clause 2 reverse([101, 98, 111, 98, 97], B). // clause 1 B = [97, 98, 111, 98, 101]. // reverse writef([97, 98, 111, 98, 101]). If you want the second parameter to be the translated text, you must reformulate your code to reflect that: pirateTalk2([], []). pirateTalk2([H | T], [H | A]) :- member(H, [97, 111, 117, 101, 105, 121]), !, pirateTalk2(T, A). pirateTalk2([H | T], [H, 111, H | A]) :- pirateTalk2(T, A). Then it works in both directions: [trace] 1 ?- pirateTalk2(X, [106, 111, 106]). Call: (6) pirateTalk2(_G1994, [106, 111, 106]) ? creep Call: (7) lists:member(106, [97, 111, 117, 101, 105, 121]) ? creep Fail: (7) lists:member(106, [97, 111, 117, 101, 105, 121]) ? creep Redo: (6) pirateTalk2(_G1994, [106, 111, 106]) ? creep Call: (7) pirateTalk2(_G2073, []) ? creep Exit: (7) pirateTalk2([], []) ? creep Exit: (6) pirateTalk2([106], [106, 111, 106]) ? creep X = [106]. [trace] 2 ?- pirateTalk2([106], X). Call: (6) pirateTalk2([106], _G1929) ? creep Call: (7) lists:member(106, [97, 111, 117, 101, 105, 121]) ? creep Fail: (7) lists:member(106, [97, 111, 117, 101, 105, 121]) ? creep Redo: (6) pirateTalk2([106], _G1929) ? creep Call: (7) pirateTalk2([], _G2007) ? creep Exit: (7) pirateTalk2([], []) ? creep Exit: (6) pirateTalk2([106], [106, 111, 106]) ? creep X = [106, 111, 106]. 
Exactly. This means for example that `"aoa"` becomes a valid translation of `"a"`, because `[97, 111, 97]` matches the head of both the second and third clause. 1 ?- pirateTalk2([97], [97, 111, 97]). true. Here is some [further reading](http://en.wikibooks.org/wiki/Prolog/Cuts_and_Negation) on cuts, hope that helps!
Code works in swipl 6.6.6 It didn't compile and run successfully, I just used it from the REPL.
What resources are you using to study with? An example program that adds two numbers from user input: add_input :- prompt1('Input first number: '), read(X), prompt1('Input second number: '), read(Y), Sum is X + Y, format('The sum of ~d and ~d is ~d.', [X, Y, Sum]). Example usage: ?- add_input. Input first number: 89. Input second number: 29. The sum of 89 and 29 is 118. true. 
&gt;I am using SWI Prolog. Are you studying from a text book, a tutorial, or the SWI manual, or anything? I'm glad I could help. Why don't you have a go at your writing your conditional and I can help if you run into trouble? You can even use pseudo-code where you don't know the Prolog idiom, and I can help you translate it.
What video are you watching? A lecture on Prolog? read(Age), ( Age &gt;= 18 -&gt; writeln('You are eligible to vote.') ; writeln('You are not eligible to vote.') ).
Glad to help.
It looks like you just have to add clauses for the built-in `is/2` and to `allowd_build_in/2`, so something like allowd_build_in(out(A), writeln(A)):-!. allowd_build_in(fail, fail):-!. allowd_build_in(A=B, A=B):-!. allowd_build_in(A is B, A is B) :- !. %Add this line But I haven't tried it to see if that does the trick. (**Edit:** And the same for `&gt;`, as zmonx said.) By the way, a wonderful free resource for learning about meta-interpreters is Markus Triska's article [A Couple of Meta-interpreters in Prolog](http://www.logic.at/prolog/acomip/acomip.html). It's short, but demonstrates a lot of subtle and deep ideas that are worth taking the time to understand.
Awesome, very big thanks for advice. I added that lines to prolog interpreter but the trace still looks odd. [Take a look here](http://pastebin.com/NWsB4gMG). I understand the trace from swipl alone but I can't understand the trace from the interpreter. Shouldn't there be something else instead of 1-body- (factorial(5,_G431):-5&gt;0,_G442 is 5-1,factorial(_G442,_G452),_G431 is 5*_G452)-[N=5,F=_G470,N1=_G476,F1=_G482]- (5&gt;0,_G476 is 5-1,factorial(_G476,_G482),_G470 is 5*_G482) and shouldn't there be more calls of factorial like 2-body-(factorial(4,_XXX)... ... %more trace 3-body-(factorial(3,_YYY)... and so on which eventually bubble to the result? (Sorry for me english if *shouldn't there be* is not valid)
To be honest, I find this code quite strange. Look at the following predicate: record_trace(Depth, body, Goal-Body-NamesVars):-!, copy_term((Goal:-Body)-NamesVars, PredText-NVs), foreach(member(X, NVs), (call(X);true)), recordz(exec_trace, (Depth-body-PredText-NamesVars-Body)). record_trace(Depth, Typ, Goal):- recordz(exec_trace, (Depth-Typ-Goal)). You can see where the duplication in the output comes from: there is already a copy of `Body` as part of `PredText`. Also, the call `foreach(member(X, NVs), (call(X);true))` looks *very* strange. Your friend is best placed to explain what he is doing here. If you want to start from scratch, you should be able to make something a bit less complicated. A lot of Prolog textbooks show how to write a tracing meta-interpreter. For example, *The Art of Prolog* (2nd edition) - a wonderful book, if you have access to it - has one as Program 17.7. The code is available [here](ftp://ftp.cs.cmu.edu/user/ai/lang/prolog/bookcode/aop/0.html) and you will see it is only 17 lines. It writes the trace to standard output as it goes, but you could easily modify it to `recordz` or `assertz` all the information you want at interpretation time and then recover the trace afterwards.
Thanks for info and links it is really helpful. I read the book's chapter with meta-interprets, I found it really helpful. Because the guy, who wrote the custom meta interpreter does not respond to my emails, I think that line foreach(member(X, NVs), (call(X);true)) is because of binding of program to variable 'c[X]' and inside Prolog database while loading program from file using and getting the trace from it recordz(prog, c(Term, VarBindings)) ofc, I am noob in Prolog, so my assumption of how it workds can be very wrong. You see I need full trace (like failed goals and indication of backtracking) to make a visualisation how prolog computes. I am reading another books but some books containing tracing interpreters do not what I need. Dammit! :D
Do not let the book fool you: The first append/3 version is *clearly* tail recursive, because the final goal is a tail call. You can test it easily yourself and see that the predicate does *not* run out of local stack space even for very long lists: ?- length(_,Exp), L is 2^Exp, writeln(L), length(Ls, L), append(Ls, [], _), false. yielding: 1 2 4 8 16 ... 8388608 16777216 ERROR: Out of global stack You see that we run out of *global* stack before we run out of local stack. For illustration: When I add, as a third clause, the nonsensical case: append(_, _, _) :- false. then tail call optimisation cannot be applied since a choice-point is left, and therefore, I get with the query above: ... 262144 524288 1048576 ERROR: Out of local stack In Prolog, *many more predicates* are tail recursive than in functional languages. For example, "append" is *not* naturally tail recursive in functional languages, but it is in Prolog thanks to the power of unification, which lets us reason also about partially instantiated data structures. Please check out Richard O'Keefe's excellent book for a very nice overview of all these issues, and many other important topics.
Thanks for the explanation and the book recommendation. 
When that book was written, they hadn't figured out how to tail optimize such calls, and only optimized if you were passing in new values and not referencing anything back in the incoming parameters.
Probably the authors of that specific book had not figured it out, but other people already had had, even at that time: The WAM was published in 1983, and had thus already been available for a few years when the book was published in 1989. The WAM has no problem at all with optimizing such tail calls.
I will not go into very much detail about these questions, because after reading **The Craft of Prolog** you will be able to answer them yourself. Only a few general points: First, breadth-first search is often very memory expensive and therefore avoided. Very often, *iterative deepening* is a good approach for search problems: It combines the memory efficiency of depth-first search with completeness of breadth-first search, and is still an asymptotically fastest method under very general assumptions. Many people fail to realize this, and it is somewhat counter-intuitive but true: In a general search tree, the exponential blowup in the *bottom-most* layer is enough to cover, with a constant factor, *all* extra passes that iterative deepening must perform. Second, a failure driven loop can just as well run out of global stack space! Simply try it yourself. Allocate larger and larger objects in a failure driven loop, and see how it overflows: ?- length(_,Exp), L is 2^Exp, portray_clause(L), length(Ls,L), false. 1. 2. 4. 8. ... 8388608. ERROR: Out of global stack Third, efficient backtracking is what Prolog really shines at. You will need to understand how *trailing* works in the WAM to see what makes efficient backtracking possible. See the section about the Trail and other memory areas in Richard O'Keefe's book for an excellent introduction. Very relevant for you is also garbage collection, tail recursion, *and how these relate to choice-points and argument indexing*. Finally, the most important point: Try to work in the *pure* subset of Prolog most of the time. The extra-logical constructs like !/0, setarg/3 etc. have severe consequences. Most importantly, they prevent your predicates to be used as true relations (in all directions), do not let you test your predicates in isolation, and make it much harder to reason about your code in declarative debugging techniques. Thus, try to stay in the pure monotonic subset of Prolog, especially when you are just beginning to learn the language.
I've seen iterative deeping, and my immediate thought is sometimes I still care about the constant factors, but that while one set of constant factors is higher (you traverse some states multiple times and your search needs to track its depth) another set of constant factors is smaller (you don't need to maintain a huge queue). How that balances obviously depends on things I don't know and the particular problem, but I believe you - with the proviso that the number of states per search-depth doesn't always increase exponentially, especially (but not only) when the search space is finite and you maintain a closed set to block repeated evaluation of states. Actually, I'm more interested interested in state and automata closures than searches - that's a big part of what's motivating my current interest in Prolog. Just to state the obvious, a search or a set closure is like an automata closure where you only pay attention to vertices/states - you jump over the edges/transitions without recording them. An automata closure doesn't really care whether you construct it depth-first, breadth-first, best-first, upside-down or inside-out because the relevant structure is determined by the inputs, not the evaluation order. And at least my case, the interesting automata are finite even when they're not (I'm interested in push-down automata and more, but there's still a finite digraph of states as part of those models). Possibly iterative deepening is still the right way to work, but I'm still interested in understanding all the options. Also, I'm never happy in any language until I have an intuition for the "breaking strain" of the techniques I'll be using. I may be jumping ahead of my current ability quite a bit but that's not unusual for me. Anyway, you've definitely sold me on that book - and I'm beginning to suspect you may be Richard O'Keefe ;-) 
Just to also state the obvious (and I'm certain you know that already): The problem you describe can be solved in polynomial time, since the closure can never outgrow the number of states. You can simply write a predicate like automaton_state_reachables/3 which, given an automaton and an initial state Q0, yields a list of states that are reachable from Q0. You can then use this as a building block for a second predicate, say automaton_states0_states/3 which gives you all states that can be reached from *any* member of States0. *This is where DCGs will be very useful to you, since they let you conveniently describe such a list.* Once the state you are looking for is in the set States, you can easily reconstruct a path in reverse, if you have kept track of the layers (i.e., lists of states) encountered during the search. All of this is perfectly solvable in plain Prolog, using for example association lists for faster lookup in the transition table. For very large problems, I would use attributed variables: One variable for each node, with an attribute that links a node to its successors. This is often an efficient way to represent a graph in Prolog. However, I would always use the pure method first, because it is *much* easier to debug and reason about.
DCGs are a lot like monads: DCGs allow you, among other things, to implicitly pass arguments around, just like monads in Haskell. Only it's more general than in Haskell, because you can use DCGs in all directions :-). I recommend to always consider using DCGs when you are describing lists, they often make things a lot more convenient, more readable, and also more efficient.
&gt;DCGs are a lot like monads That's sparked an epiphany for me. I had noticed some formal similarities before, but never made much of it. But now it's coming together, and I also see how Mercury is able to do pure IO with DGCs. That really seems to demystify the concept of monads a bit, since the idea of difference lists is pretty straight forward.
Because I liked the idea of helping students to realize how prolog works. It was supposed to be easy C# web app with no prolog programming but turns out it is harder than I thought. I already made one implementation without any prolog code written but it was blind turn as I can't do something on the school server to make it work. So I needed the interpreter but how am I supposed to write complex code in language I don't fully understand with so little time to learn it.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Continuation**](https://en.wikipedia.org/wiki/Continuation): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science) and [computer programming](https://en.wikipedia.org/wiki/Computer_programming), a __continuation__ is an [abstract representation](https://en.wikipedia.org/wiki/Abstraction_(computer_science\)) of the [control state](https://en.wikipedia.org/wiki/Control_flow) of a [computer program](https://en.wikipedia.org/wiki/Computer_program). A continuation [reifies](https://en.wikipedia.org/wiki/Reification_(computer_science\)) the program control state, i.e. the continuation is a data structure that represents the computational process at a given point in the process's execution; the created data structure can be accessed by the programming language, instead of being hidden in the [runtime environment](https://en.wikipedia.org/wiki/Run-time_system). Continuations are useful for encoding other control mechanisms in programming languages such as [exceptions](https://en.wikipedia.org/wiki/Exception_handling), [generators](https://en.wikipedia.org/wiki/Generator_(computer_science\)), [coroutines](https://en.wikipedia.org/wiki/Coroutine), and so on. &gt; --- ^Interesting: [^Continuation ^War](https://en.wikipedia.org/wiki/Continuation_War) ^| [^Analytic ^continuation](https://en.wikipedia.org/wiki/Analytic_continuation) ^| [^Continuation ^high ^school](https://en.wikipedia.org/wiki/Continuation_high_school) ^| [^Continuationism](https://en.wikipedia.org/wiki/Continuationism) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clfng1l) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clfng1l)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
you have nothing to define `poisonous/1' so you need either a rule or ground rule to define it. If you are in doubt, you can try queries like `insect(beetle)' or 'not(poisonous(beetle)' on its own prior to testing the food(beetle) query.
if you are thinking about having some food be checked if poisonous and some that isn't, you should think about a secondary `food/1' rule. Hope this helps.
Why does calling an undefined predicate lead to error? One of thinking of the rationale is as follows: Prolog only knows the predicates you've defined for it. If you query ?- poisonous(beetle). without having first defined `poisonous/1`, it is like me asking you "are beetles snorglebloits?" You don't know what "snorglebloits" means, so you can't answer one way or another. Your Prolog implementation assumes that you want Prolog to be able to answer any query posed. From this assumption, it follows that, if you are querying an undefined predicate (which prolog won't know how to interpret), you either forgot to define something somewhere, or you changed the name of the definition but forgot to update the reference to it, or some other user error is at play. The warning about singleton variables is just a helpful device for catching common error: i.e., inconsistent naming of variables. It is assumed that, if you really meant a variable to be used just once in a given scope, then you don't care about the variables name and would use an underscore, `_`. Otherwise, you probably changed the name of one occurrence of the variable without changing another, or there is a typo somewhere. Named singleton variables can usually be accommodated by preceding them with an underscore: poisonous(_X). However, you probably wouldn't want this in your database, unless you are defining a very dangerous world, because it states that all things are poisonous! &gt;what if nothing is currently poisonous? I'm trying to use this language inside a game app for AI. So it's feasible that no objects/entities are currently known as poisonous. If you plan on asserting `poisonous/1` facts later on, then declaring them dynamic is certainly one way to go (and you'll need the `dynamic` declaration at some point). Another approach would be to start with a fact that should be true by definition, so no knowledge would be needed by the AI except the meaning of terms (I'm speaking loosely and metaphorically, obviously): food(X) :- insect(X), not(poisonous(X)). insect(beetle). poisonous(poison). Of course, you could also follow /u/fspeech's clue, and write a custom `not_/1` predicate which will assume that the absence of a definition to entail that the goal should fail: not_(Goal) :- ( current_predicate(_, Goal) -&gt; not(Goal) ; true ). `not_/1` is true if the goal's predicate is already defined and the goal fails, or, if it is not defined at all.
If you are going to be asserting and retracting clauses for `poisonous/1` then declaring it dynamic as above is the right way to solve this problem.
Maybe... poisonous(_) :- fail. The predicate exists but never succeeds - I'm not convinced that's what you need, but maybe as a placeholder for something you'll develop later? Warning - I've only been learning Prolog seriously a few weeks myself, so don't assume this is good style or a recommended idiom or anything. 
you will learn and appreciate prolog more if you actually read a book and work through it and solve the problems and solutions. we can feed you some prolog one question at a time, but it will take a very long time to wrap your brain around it. you are asking prolog about poisonous things but prolog has no idea about what poisonious is. you might as well remove insect(bettle). it's not magic, prolog works in a closed world, it only knows what you tell it. the proper way is to define at least one thing that is poisonous or take out that query. 
what exactly is not working? what did you add to the code and why, what error did you get?
I'm trying to make a programme to play a card game called love letter. I'm using win-prolog. My code is basically non-existent and has a few failed attempts commented out. But here it is. deck([princess, minister, general, wizard, wizard, priestess, priestess, knight, knight, clown, clown, soldier, soldier, soldier, soldier, soldier]). newlist([]). select_random(deck, X, newlist) :- random_member(X, deck), select(X, List, newlist). points(princess, 8). points(minister, 7). points(general, 6). points(wizard, 5). points(priestess, 4). points(knight, 3). points(clown, 2). points(soldier, 1). win("You win"). lose("You lose"). %hand(X). %drawhand((X), (Y)). Randomise. Next card auto(X, Y, X) :- X=Y. keepprincess(X, Y, X) :- points(princess, Z), points(Y, W), Z&gt;W. %loss(X, Y, X) :- % points(X, 7), % points(Y, U), % U+7 &gt;=12, % X=lose. loss(minister, Y) :- %This rule kind of works. Would be beneficial to programme the minister in as that's the only card where this rule is true points(Y, U), U+7 &gt;=12, You lose. loss(X, minister) :- points(X, U), U+7 &gt;=12, You lose. comp(X, Y, X) :- points(X, Z), points(Y, W), Z&gt;W. comp(X, Y, Y) :- points(X, Z), points(Y, W), W&gt;Z. auto(X, X, X). auto(princess, X, X). auto(X, princess, X). first(X, Y, Z) :- member(deck(X)|Y), Also random_member doesn't appear to be a function in WIN-Prolog.
select_random(deck, X, newlist) :- random_member(X, deck), select(X, deck, newlist). select_random(deck, X, newlist). ERROR: length/2: Type error: `list' expected, found `deck' I don't know what this means.
I tried this... deck([H|T],H,T). ERROR: Undefined procedure: deck/3 ERROR: However, there are definitions for: ERROR: deck/1 false.
Does this mean that `random_member/2` is in WinProlog? Or are you using a different implementation? Are you familiar with basic Prolog data types, yet? E.g., atoms vs. variables vs. numbers vs. compounds?
&gt; Also random_member doesn't appear to be a function in WIN-Prolog. In that case, look for a predicate that will generate random integers. Set the range of integers to be within the possible indexes of items in the list of cards, then pick a card at the randomly generated index. Out of curiosity, is this a personal project or for school? What lead to your choice of WIN-Prolog? (This isn't meant to imply any disapproval of that implementation: I don't know enough about different implementations to have an opinion.)
That would be because you queried `deck/3` without first defining it in your program. Are you working with any instructional material? There are a lot of basic Prolog concepts that you don't yet seem familiar with. That's not a problem, and the basic concepts are easy to learn! But it will be very difficult for you to move forward with your program if you haven't already learned the difference between, e.g., defining a predicate in your program and querying a goal at the top level, or the fundamental data types, or how to work with lists, etc. Perhaps start by working through this tutorial: https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/ It's relatively short, and should be mostly (if not entirely) compatible with whatever implementation you use (so if you decide not to use SWI-Prolog, just skip the steps about installation).
You are looking for one of the built-in predicates `select/3` or `random_select/3`. Most (all?) prologs have [`select/3`](http://www.swi-prolog.org/pldoc/doc_for?object=select/3) which is just like [`member/2`](http://www.swi-prolog.org/pldoc/doc_for?object=member/2) except the third argument is bound to the list with the selected element removed. If the element being selected is a variable, `select/3` chooses the first element of the list, leaving choice points to select subsequent elements instead upon backtracking. SWI-Prolog also has [`random_select/3`](http://www.swi-prolog.org/pldoc/man?predicate=random_select/3) which is just like `select/3` except the element is chosen at random and it leaves no choice points. This works great unless the order of the deck is partially known (e.g. due to abilities like Scry in Magic the Gathering).
Most Prologs don't support `Rule(A,B)`, but you can use `=..` (univ) and `call/1` instead: X =.. [Rule, A, B], call(X), ... 
&gt; X =.. [Rule, A, B], call(X), I actually tried that but I only get that A and B are not sufficiently instantiated, and I don't know how to get around that. I'm using http://swish.swi-prolog.org/ right now, and usually SWI-prolog in case that matters.
Rule must be lower case, it's a predicate not a variable.
But it is a variable, this is what I tried: commutative(Rule) :- not(counter_example(Rule)). counter_example(Rule) :- Goal1 =.. [Rule, A, B], call(Goal1), Goal2 =.. [Rule, B, A], call(Goal2). sibling(a,b). sibling(b,a). commutative(sibling). parent(c,a). parent(c,b). commutative(parent). Is this actually possible? 
Sorry to bother you again... I finally ordered and got my copy of The Craft of Prolog, and with it a surprise. amazon.co.uk describes the publication as "Publisher: MIT Press (2 July 2008)", so I was expecting a 2008 edition. What I received seems to be a 1990 edition - there's no mention of any year other than 1990 on the copyright page. Then again, the back page shows a 13 digit ISBN - ISBN-13 didn't exist until around 2007. Am I correct in assuming that Amazon are probably referring to a re-printing (or maybe some kind of "remastering" - converting to modern formats - though I'd have thought it was TeX based anyway) rather than an edition, and the content itself hasn't been updated since 1990? BTW - I've already spotted a minor error - a bit bad for a reprinting 18 years after the book was published. In section 1.4.2 - Last Call Optimization - item 3b (pg. 27) says "Prolog now jumps with the goal len([b,c], 3, X)." where it should be "len([], 3, X)." - the `[b,c]` and `[c]` steps handled in 1b and 2b respectively. Of course that's no big deal, but I've had the experience of being thoroughly confused by what turned out to be an error in the book a few times before. I can't find errata [on the MIT press page](http://mitpress.mit.edu/books/craft-prolog) or elsewhere. Do you know if they exist? Despite these confusions and nit-picks, my first impression (having read only the first chapter) is that it's good. It's not shy about comparing Prolog to other languages, esp. Pascal, and Keefe doesn't seem to feel the need to constantly criticize those other languages or to make the comparison examples artificially bad. The pace is fast enough to maintain interest. Chapter 1 didn't tell me much that's new so far but it wasn't meant to. From a quick skim the rest of the content looks very interesting, and I'm aware that being a 1990 edition doesn't make it out of date in any way I should care about. 
Firstly, you've asserted `commutative(sibling)` and `commutative(parent)` as facts. Remove those two lines, then consult the file and then query it with ?- commutative(sibling). and it should work. Unfortunately `?- commutative(X).` won't give you back `X=sibling` and `X=parent` but you can easily make it do that if you want to. Secondly, `call/N` is now in ISO Prolog (and it's been in most implementations for years) so instead of, e.g. Goal1 =.. [Rule, A, B], call(Goal1), you can just put call(Rule, A, B), Thirdly, relations that satisfy your `commutative/1` are usually called *symmetric*. *Commutativity* refers to binary operations `op` with `op(A, B) = op(B, A)` for all `A` and `B`.
Nice! There may be several small errors in the book (and yes, I believe there has not been a truly updated edition for many years), but overall it is chock-full of excellent examples and insights. For specific issues, you can always consider to ask the author directly via mail. He is working as a university professor and has been very helpful in the interactions I have had with him. However, there are also some areas in which the book is out of date by now, most importantly: No discussion of constraints like dif/2 (which had been available as of the earliest Prolog implementations) or finite domain constraints (which also have been available for decades now), and its use of low-level I/O instead of the pure and also more efficient usage of DCGs with library(pio), which has now been available in SWI-Prolog for several years already. So, I recommend you catch up on these topics in other ways, after getting a solid foundation via this excellent and still very relevant book. Since you like the language comparisons, a nice reference for you: Check out the extremely funny and superbly written "Prolog compared with LISP?" paper by Richard O'Keefe (written in 1983!).
Hmm. Yes that does seem to work. But I do not understand why. Could you tell me, what does sorted([L2|T]) send to the sorted predicate? Does it send the entire list or does it only send L2?
L1 is the first element of the list, L2 is the second element, T is the rest. [L2|T] Sends the rest. if the list was [a,b,c,d,e,f,g], then L1 = a, L2 = b, and T = [c,d,e,f,g] and [L1|T] will send that [b,c,d,e,f,g] If the list was [[],[1],[2,3],[4,5,6]] L1 will be [], L2 will be [1] and T will be [[2,3],[4,5,6]] and [L1|T] will be [[1],[2,3],[4,5,6]] Play around in the top level and understand how to pull apart lists and put them back together. 
If `Rule` is only an atom, you don't need `=../2`. `=../2` destructures compound terms, returning a list where the functor as the head and the args are the tail: ?- term(Arg1, Arg2, atom_arg) =.. List. List = [term, Arg1, Arg2, atom_arg]. You can use it both ways, to compare, build, or destructure terms. `Goal =.. [Rule]`, with `Rule` instantiated as an atom, is equivalent to mere unification: ?- atom =.. [atom]. true. `Pred =.. [atom, Arg1, Arg2], call(Pred)` is functionally equivalent to `call(atom, Arg1, Arg2)`. So, in your `counter_example/1` rule, either `call/3` or `=../2` will suffice. What about the following for testing symmetry? symmetric(Functor, Domain) :- \+asymmetric(Functor, Domain). asymmetric(Functor, Domain) :- call(Domain, A), call(Domain, B), call(Functor, A, B), once(\+ call(Functor, B, A)). usage: ?- symmetric(==, between(1,100)). true. ?- symmetric(&lt;, between(1,100)). false. --- edit: whoops! I see /u/mycl already clarified everything. I'll leave this in case it helps. 
Your reply is much appreciated. Seeing all the small differences in proposed solutions is really nice as it invites to compare the concepts and structures. I like your implementation of symmetric, didn't think of using a specific domain like that.
First of all, you are describing a *list*, so consider using a DCG for convenience. The general pattern will look similar to: path(To, To, _) --&gt; []. path(From, To, Visited) --&gt; { connection(From, Next), \+ memberchk(Next, Visited) }, [From], path(Next, To, [From|Visited]). You will have to flesh out connection/2, and what it means when an element is consumed on the way. This may involve changing [From] to some other terminal that you want to occur in the final path. Starting from this, it is trivial to apply iterative deepening: ?- length(Path, _), phrase(path(Source,Target,[]), Path). This will try path//3 with increasingly longer lists, thereby automatically yielding iterative deepening on backtracking.
Your code doesn't read declaratively, simplify, looks like you are trying to shoehorn imperative style with prolog. It's doable, but really hard to reason about.
What you refer to is a Symmetric Relationship. http://en.wikipedia.org/wiki/Symmetric_relation
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Symmetric relation**](https://en.wikipedia.org/wiki/Symmetric%20relation): [](#sfw) --- &gt; &gt;In [mathematics](https://en.wikipedia.org/wiki/Mathematics) and other areas, a [binary relation](https://en.wikipedia.org/wiki/Binary_relation) *R* over a [set](https://en.wikipedia.org/wiki/Set_(mathematics\)) *X* is __symmetric__ if it holds for all *a* and *b* in *X* that if *a* is related to *b* then *b* is related to *a*. &gt;In [mathematical notation](https://en.wikipedia.org/wiki/Mathematical_notation), this is: &gt;&gt; &gt;==== &gt;[**Image**](https://i.imgur.com/aUqiFaX.png) [^(i)](https://en.wikipedia.org/wiki/File:Bothodd.png) --- ^Interesting: [^Symmetry](https://en.wikipedia.org/wiki/Symmetry) ^| [^Antisymmetric ^relation](https://en.wikipedia.org/wiki/Antisymmetric_relation) ^| [^Binary ^relation](https://en.wikipedia.org/wiki/Binary_relation) ^| [^Transitive ^relation](https://en.wikipedia.org/wiki/Transitive_relation) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clxvyz2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clxvyz2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Hi thanks for this.. but it just hangs when searching for a path greater than two.. I think there is something wrong with my state_change/3 predicate but I can't figure it out as it works fine for finding one change or chaining them together manually. :S 
Hi thanks- for the comment- where do you think this is the case? 
Sounds like you need to go through the list with an axillary "seen list". Something like this: dups_removed([], [], _). dups_removed([H|T], [H|TT], Seen) :- \+ member(H, Seen), dups_removed(T, TT, [H|Seen]). dups_removed([H|T], TT, Seen) :- member(H, Seen), dups_removed(T, TT, Seen). This will need some adapting to your case but illustrates the idea.
I actually solved my problem by just cutting down on the excess information during certain stages (my program only needs to know the names of the diseases during the stages that were giving me trouble) so that instead of a list of lists, it was just a list of elements, which I was able to eliminate multiples from by simply using the sort() function. Thank you so much for responding though! /r/prolog seemed kinda quiet when I first checked it out, and I was surprised to get a response so quickly.
I googled "win-prolog documentation" and [this page](http://www.lpa.co.uk/dow_doc.htm) was the first result. On it is a link to the [WIN-Prolog 5.000 reference manual](http://www.lpa.co.uk/ftp/5000/win_ref.pdf). On page 377 of that manual is the documentation for `is/2`. All of the arithmetic functions supported by WIN-Prolog are listed there. I see that `ip` stands for *integer part*, but I also can't see any function for rounding up, so what you have is probably the best solution. If you're working with WIN-Prolog, you should definitely check out that documentation page.
Thank you!
No problem, was just lucky it got onto my front page. It is a shame this place is so quiet though.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Logic programming**](https://en.wikipedia.org/wiki/Logic%20programming): [](#sfw) --- &gt; &gt;__Logic programming__ is a [programming paradigm](https://en.wikipedia.org/wiki/Programming_paradigm) based on [formal logic](https://en.wikipedia.org/wiki/Formal_logic). A program written in a logic [programming language](https://en.wikipedia.org/wiki/Programming_language) is a set of sentences in logical form, expressing facts and rules about some problem domain. Major [logic programming language](https://en.wikipedia.org/wiki/Logic_programming_language) families include [Prolog](https://en.wikipedia.org/wiki/Prolog), [Answer set programming](https://en.wikipedia.org/wiki/Answer_set_programming) (ASP) and [Datalog](https://en.wikipedia.org/wiki/Datalog). In all of these languages, rules are written in the form of *clauses*: &gt;&gt;H :- B1, …, Bn. &gt;and are read declaratively as logical implications: &gt;&gt;H if B1 and … and Bn. &gt;H is called the *head* of the rule and B1, …, Bn is called the *body*. Facts are rules that have no body, and are written in the simplified form: &gt;&gt;H. &gt;In the simplest case in which H, B1, …, Bn are all atomic formulae, these clauses are called definite clauses or [Horn clauses](https://en.wikipedia.org/wiki/Horn_clause). However, there exist many extensions of this simple case, the most important one being the case in which conditions in the body of a clause can also be negations of atomic formulae. Logic programming languages that include this extension have the knowledge representation capabilities of a [non-monotonic logic](https://en.wikipedia.org/wiki/Non-monotonic_logic). &gt;In ASP and Datalog, logic programs have only a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) reading, and their execution is performed by means of a proof procedure or model generator whose behaviour is not meant to be under the control of the programmer. However, in the Prolog family of languages, logic programs also have a [procedural](https://en.wikipedia.org/wiki/Procedural_programming) interpretation as goal-reduction procedures: &gt;&gt;to solve H, solve B1, and ... and solve Bn. &gt;Consider, for example, the following clause: &gt;&gt;fallible(X) :- human(X). &gt;based on an example used by [Terry Winograd](https://en.wikipedia.org/wiki/Terry_Winograd) to illustrate the programming language [Planner](https://en.wikipedia.org/wiki/Planner_(programming_language\)). As a clause in a logic program, it can be used both as a procedure to test whether X is fallible by testing whether X is human, and as a procedure to find an X that is fallible by finding an X that is human. Even facts have a procedural interpretation. For example, the clause: &gt;&gt;human(socrates). &gt;can be used both as a procedure to show that socrates is human, and as a procedure to find an X that is human by "assigning" socrates to X. &gt;The declarative reading of logic programs can be used by a programmer to verify their correctness. Moreover, logic-based [program transformation](https://en.wikipedia.org/wiki/Program_transformation) techniques can also be used to transform logic programs into logically equivalent programs that are more efficient. In the Prolog family of logic programming languages, the programmer can also use the known problem-solving behaviour of the execution mechanism to improve the efficiency of programs. &gt; --- ^Interesting: [^Functional ^logic ^programming](https://en.wikipedia.org/wiki/Functional_logic_programming) ^| [^Inductive ^logic ^programming](https://en.wikipedia.org/wiki/Inductive_logic_programming) ^| [^Abductive ^logic ^programming](https://en.wikipedia.org/wiki/Abductive_logic_programming) ^| [^The ^Journal ^of ^Logic ^and ^Algebraic ^Programming](https://en.wikipedia.org/wiki/The_Journal_of_Logic_and_Algebraic_Programming) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm8suec) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm8suec)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Prolog is a programming language. It's based on unification and backtracking, so its style is different from imperative languages and even functional languages, but it's still a programming language. Prolog programs can have bugs the same as any other language. It's dynamically typed, so type errors can go unnoticed by the compiler and may not be noticed until the right combination of circumstances occur. Although it has some support for modularity, it seems to have been hacked on after the fact, so it's not ideal. The solution for that is the same as always - adopt good practices, test, and keep your brain active. On specifics, I don't know and haven't even read that document you link yet, but just speculating - where Prolog is used, I believe it's often relatively small Prolog subsystems. Other systems will make calls into the Prolog call via some foreign function interface, which is an aspect of Prolog I've not tried to learn yet. Prolog is well suited to expert systems - that's essentially what it was originally developed for. But the techniques used to implement a knowledge-based expert system aren't unique to Prolog until you look at quite low-level details. For one kind of inference engine (the only kind I know about), the basic idea is to convert a tabular form of information to a tree. Each node in the tree represents a question, and the arcs leading out represent possible answers. So the basic problem is to decide, given your table of facts (or examples) and the answers you've received so far, which question to ask next. That decision can be made based on the weighted average of the amount of information that would be provided by each answer if it turned out to be correct - the "entropy". This is the basis of the ID3 algorithm in an over-simplified nutshell. Converting a table to a tree isn't very interesting if the table is complete and you evaluate the full tree - you may as well have just picked out the exact row of the table e.g. using a hash-table implementation - but if you only ask so many questions you can still reach useful and fairly reliable conclusions without knowing all the answers. And with some statistics, you can work with numeric information as well as small discrete sets of possibilities - e.g. you can estimate probabilities (and from them entropy values) based on an assumptions about probability distributions. See [this Wikipedia page on decision tree learning](https://en.wikipedia.org/wiki/Decision_tree_learning) for more. BTW - I'm no expert. I've dipped my toe in with Prolog a few times, and been learning it a bit more seriously in the last month or so. I've been aware of ID3 for a long time, and implemented a variant a couple of times - most recently in C++. However, I've never written what I'd call an expert system. I've used a rather simplistic form of ID3 as an overkill solution for a problem, mostly out of curiosity, is all. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Decision tree learning**](https://en.wikipedia.org/wiki/Decision%20tree%20learning): [](#sfw) --- &gt;__Decision tree learning__ uses a [decision tree](https://en.wikipedia.org/wiki/Decision_tree) as a [predictive model](https://en.wikipedia.org/wiki/Predictive_modelling) which maps observations about an item to conclusions about the item's target value. It is one of the predictive modelling approaches used in [statistics](https://en.wikipedia.org/wiki/Statistics), [data mining](https://en.wikipedia.org/wiki/Data_mining) and [machine learning](https://en.wikipedia.org/wiki/Machine_learning). Tree models where the target variable can take a finite set of values are called __classification trees__. In these tree structures, [leaves](https://en.wikipedia.org/wiki/Leaf_node) represent class labels and branches represent [conjunctions](https://en.wikipedia.org/wiki/Logical_conjunction) of features that lead to those class labels. Decision trees where the target variable can take continuous values (typically [real numbers](https://en.wikipedia.org/wiki/Real_numbers)) are called __regression trees__. &gt;==== &gt;[**Image**](https://i.imgur.com/JjFIzKq.png) [^(i)](https://commons.wikimedia.org/wiki/File:Linear-svm-scatterplot.svg) --- ^Interesting: [^Machine ^learning](https://en.wikipedia.org/wiki/Machine_learning) ^| [^Decision ^tree](https://en.wikipedia.org/wiki/Decision_tree) ^| [^Decision ^list](https://en.wikipedia.org/wiki/Decision_list) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmf4fu2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmf4fu2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Suggestions: graph traversal a) depth first b) breadth first c) iterative deepening finding substrings in lists removing elements in a list splitting a list into a number of lists based on the type of element maybe some dcg stuff for some basic sentances
Divider of common greats 
bit late but check out chapter 8 of simply logical it might help you: https://www.cs.bris.ac.uk/~flach/SL/SL.pdf 
What do ip/2 and member/3 do? SWI doesn't seem to include either as built-ins. EDIT: I more or less figured out the above. The problem is in the second clause of gameplay/5. It will only create one new list, leaving the other one as an unbound variable. This will fix it, copying the old version of the other list: gameplay([H|T], Num, Y, PH, CH) :- Z is Num mod 2, ((Z == 1) -&gt; write('It is '), write(Y), write('s turn.'), nl, insert(H, PH, NewPH), NewCH = CH ; write('It is computers turn'), nl, insert(H, CH, NewCH), NewPH = PH ), points(H, X), write('Your card is '), write(H), write(' ('), write(X), write(')'), nl, Num2 is Num-1, gameplay(T, Num2, Y, NewPH, NewCH).
I've changed the code rather radically since yesterday :) My biggest problem right now is getting a human to choose between two cards...how do I implement that?
Keyboard input (*good* keyboard input) is tricky in Prolog. You've probably figured out, for instance, that read/1 actually reads a *term*, not arbitrary keyboard input. Give it a capital letter, and it will read an unbound variable. A lot of individual Prolog systems provide better options than the standard ones, but they won't work on other systems. The best way I've found is to read things a character at a time using get_char/1. Read characters into a list until you get a newline, then parse them.
Thanks. Feedback is always welcome
Then "Solutions to Selected Exercises" is on pages 652 to 669. I'm struggling to understand why you haven't found it yet...?
You can benefit a lot from using format/2. For example, instead of: nl, write(PH), write(PD), nl, write(CH), write(CD), nl you can write: format("\n~w~w\n~w~w\n", [PH,PD,CH,CD]) And similarly, instead of: write('Thanks '), write(X) you can write: format("Thanks ~w\n", [X])
I'm using WIN-Prolog and I copied that in and it seemed to have a problem with it.
You can still use SWI-Prolog at home, debug your program there, fix it, and use the modified version with win-prolog. The required changes should be minimal.
It's not published. I keep it private...at least for now.
Hi Prologerrs! I never thought to look for a logic programming community on reddit before. I'm assuming that you're interested in not-just-prolog? miniKanren is an embedded scheme DSL for doing logic programming. This is a small Clojure implementation of that, as a literate program. It's mostly of interest as a way to learn about how miniKanren is implemented, which is really rather fascinating. 
That is the most basic prolog. Take a tutorial. What have you tried? The guidelines for questions here should be on par with the ones at stackoverflow
Well, I don't have a single word, but I think an appropriate term would be the cardinality of the truth set of foo, where foo is a predicate.
Out of curiosity, what are you working on? My reply assumes you're using SWI-Prolog. But I'm sure there are ways to achieve your desired result in any implementation. If you really wanted to add facts to your main Prolog environment, i.e., so that they would be available when you ran `$ swipl -g 'fact(X,Y);halt'`, you can load the desired database into you [user initialization file](http://www.swi-prolog.org/pldoc/man?section=initfile), e.g., by adding :- consult('path/to/databse.pl'). But that will pollute your runtime environment with those facts and potentially impact any other programs you run via `swipl`. A slightly more cautious approach would be to import the database as a module, so you can control exactly which predicates are made openly available to the system. Or, you could also refrain from exporting predicates from the database file, so that the facts would only be available by using the `module:prediate/n` idiom; that would provide a bit of encapsulation. Then your command line queries would look like: `$ swipl -g 'database:fact(X,Y); halt'`. But, take note, if you just query a fact this way, I don't think you'll get any output at all. `swipl` will run the goal `fact(X,Y)` and if it succeeds, it will drop you you into the interactive top level; if it fails, it will call `halt` and terminate. Unless `fact/2` were actually a rule that included instructions for what sort of output to produce. However, I'm not sure when it would be useful to use the the Prolog toplevel just to query a custom database of facts. I would probably make a little [PrologScript](http://www.swi-prolog.org/pldoc/man?section=plscript) program to query the database and output answers in a useful fashion. I hope that helps! Please follow up if you have additional questions or to clarify if I misunderstood your question :)
I think /u/synthmaster is right about the terminology of "domain" for the logical concept. Although, because of Prolog's hybrid nature, there is a potential ambiguity in the question "given some relation `r(X, ... )` (where `...` may be 0 or more additional arguments), how many things will `X` unify with?". "Number of things" could either mean the number of different solutions during which `X` will be unified, or the number of distinct values with which `X` can be unified given all the possible solutions. I think these two possible interpretations are exemplified in the difference between `Answers` and `Domain` in the following query: ?- findall(X, member(X, [a,a,a,b,c]), Answers), sort(Answers, Domain). Answers = [a, a, a, b, c], Domain = [a, b, c]. So with that difference in mind, I would probably answer OP's question as either "What is the number of answers for X?" or "What is the size of the domain of X?" depending on what was meant. Given the specification in terms of "number of clauses" I'm guessing the former. However, I think my terminology of "answers" doesn't quite fit. I'm also just speculating on that part, and don't know exactly where to look for technical discussion on the topic. I imagine more knowledgeable folks can be more help. As for the concept of "domain", I believe that comes from the [theory of relations](https://en.wikipedia.org/wiki/Theory_of_relations)
Thanks. I had overlooked uniqueness. The reason I need this word is because I'm trying to optimise my language implementation. I need names for variables and functions. With a predicate a/4 you might have a(A, B, C, D) as a search node in the search tree. When trying to unify this predicate, I want to order the search by the size of the domain for each variable, where the size of the domain can be easily calculated. This way, the variables with the smallest domains (fewest options) are investigated before the variables with the larger domains. "Domain" is a good word.
Many thanks for your answer! We are working on a module, which will calculating delivery cost for our e-commerce platform. We had a brainstorm and prolog was one of the options for further research ( we just simply didn't say "no" and decided to take a closer look on it ). But.. seems that we won't use it - as you noticed, prolog is not the best option for just querying a db of facts, even if query is very complicated. Thank you once again! 
Easy: We need high speed anwering maschine for huge db. By using your example prolog will start in about 10-15 seconds ( db must be loaded ). 
Thanks for your advice, i didn't know that i can compile prolog files or communicate with it by http. Am i right to think, that you can build app, which will be pseoude-web-service based on prolog ? So i could ask questions about world by json or some query ( even in right prolog syntax ) ?
Yes, perfectly right. Consider for example the SWI-Prolog [homepage](http://www.swi-prolog.org), which is *entirely* hosted by SWI-Prolog itself. SWI-Prolog comes with a particularly strong set of libraries to implement HTTP services and to communicate with remote Prolog engines (search for *pengines*). JSON syntax is also supported.
That's the way to achieve my goal. Thanks for help!
I have put together a small example to illustrate the interaction via pengines, using SWI-Prolog as an HTTP Unix daemon: Let **server.pl** consist of: :- use_module(library(pengines)). :- use_module(library(http/http_unix_daemon)). :- initialization http_daemon. fact(a, b). fact(c, d). fact(e, f). You can start the server and let it listen on (for example) port **6357** via: $ swipl server.pl --port=6357 This requires a recent development version of SWI-Prolog. The server contains an example database in the form of fact/2 facts, as in your example. Then, let **client.pl** consist of: :- use_module(library(pengines)). main :- pengine_create([ server('http://localhost:6357') ]), pengine_event_loop(handle, []). handle(create(ID, _)) :- pengine_ask(ID, fact(_,_), []). handle(success(_, [fact(X,Y)], false)) :- writeln(X-Y). handle(success(ID, [fact(X,Y)], true)) :- writeln(X-Y), pengine_next(ID, []). This connects to the server (which may run on the local machine *or even a remote host*), posts a query, and prints the results *in the client*. Example usage: $ swipl -f client.pl -g "main,halt" a-b c-d e-f I hope this helps!
i see what you mean, i haven't used dcg syntax before so i'll have to read more about that. It makes sense though, i ran it under swi prolog with gtrace. Thanks for explaining it to me. I need to play and practice with prolog a lot more, it takes a complete different view then other programming languages which i find a bit hard to understand. Together with the graphical debugger however it's more easy to see how it backtracks and where to adjust so now i also understand why it's better to test for P1 &gt; PrevFirst and P1 &lt; P2 ... very early.
Just since you mentioned your interest in many-soted logic, have you checked out order-sorted logic? The Eco-logic book (Robertson et al) develops an order sorted logic programming language with functions in Prolog and a compiler for translating to Prolog in a couple of chapters. It's an integration of Prolog's "demo" and Lisp's "eval" with dynamic type checking. Small, simple, and easy to use. I've got the code if you want to play with it.
I've been reading up on order-sorted logics for the last day! I'm trying to see if I can get Gödel working on my machine (but I think that's a type system based on many-sorted, not order-sorted logics, right?), and I was literally just thinking if I could figure out how to start implementing some basics of such a thing in Prolog. Also, I've been having trouble finding good text resources, so the book recommendation is most welcome and I'd love to look at the code you mention. Thanks! 
Types in Logic Programming, MIT Press, Edited by Frank Pfenning has 11 papers on type systems for logic progrmming languages. As far as I can remember Gödel is many sorted not order sorted - my copy of the Gödel book is in storage whilst I move flats so I'm going on memory here. Here's the OSL (Ordered Sorted Logic) interpreter from Eco-Logic, Logic-Based Approaches to Ecological Modelling, Robertson et al. This is designed to work on my own Prolog system but it's fairly ISO compliant so it should work on yours too. If not I'll give you a link so you can download my system and use it if you're running Linux on x86. %-*-mode:prolog-*- %%% %%% Eco-Logic: Logic-Based Approaches to Ecological Modelling. %%% Robertson et al. %%% %%% Chapter 5 An Order Sorted Logic (like chapter 4's but with lemmas) %%% %%% %%% [-'../../misc/Eco_Logic.code/chap5/order_sorted_logic']. %%% %%% %%% If things are not defined then they should fail. %%% Example : no sort_term predicates defined should fail. %%% :-set_prolog_flag(unknown, fail). :-op(950, xfx, #). :-op(900, xfx, &lt;-). :-op(900, xfx, &lt;=). :-op(700, xfx, in). :-op(500, yfx, and). :-op(500, yfx, or). %%% %%% Obj in Sort %%% %%% Object is a member of Sort. %%% Obj in Sort :- var(Obj), var(Sort), throw(error(domain_error(in/2, Obj, Sort))). Obj in Set :- member(Obj, Set). Obj in Sort :- subobj(Sort, Obj). Obj in Sort :- subsort(Sort, SubSort), Obj in SubSort. Obj in Sort :- sort_term(Sort, Obj, Consts), satisfiable_constraints(Consts). Obj in srelation(Relation) :- sort_relation(Relation, Consts), satisfiable_constraints(Consts). Obj in Sort :- sort_test(Sort, Obj, Test), call(Test). Obj in Sort1 and Sort2 :- Obj in Sort1, Obj in Sort2. Obj in Sort1 or Sort2 :- Obj in Sort1; Obj in Sort2. Obj in inv(Sort) :- \+ Obj in Sort. %%% %%% satisfiable_constraints(+Consts) %%% %%% All of the elements of the list of constraints %%% Consts are satisfiable. %%% satisfiable_constraints([]). satisfiable_constraints([Obj in Sort|Rest]) :- Obj in Sort, satisfiable_constraints(Rest). %%% %%% solve(+Term, ?Result) %%% %%% The interpreter %%% solve(Term, Result) :- term_class(primitive, Term), !, Result = Term. solve((Obj in Sort), Obj) :- !, Obj in Sort. solve((A and B), (RA and RB)) :- !, solve(A, RA), solve(B, RB). solve((A or _), RA) :- solve(A, RA). solve((_ or B), RB) :- !, solve(B, RB). solve([H|T], [R|Rest]) :- !, solve(H, R), solve(T, Rest). solve(((Ins, Outs)#Tm), Result) :- !, satisfiable_constraints(Ins), solve(Tm, Result), satisfiable_constraints(Outs). solve(Term, Result) :- meta_fun(Term, Result, Call), !, call(Call). solve(Term, Result) :- meta_pred(Term, Call), !, call(Call), Term = Result. solve(Term, Result) :- % nonvar(Term), compound(Term), standardise_term(Term, ETerm), (term_class(function, ETerm), !, osl_eval(ETerm, Result) ; term_class(predicate, ETerm), establish(ETerm, Result)). %%% %%% solve_list(+L,-S) %%% %%% S is the list L where each element is sorted. %%% solve_list([], []). solve_list([H|T], [SH|ST]) :- solve(H,SH), solve_list(T,ST). %%% %%% standardise_term(+Term, -ETerm) %%% %%% The Term in the sorted logic can be standardised to form the term %%% ETerm with all its arguments fully evaluated. %%% standardise_term(Term, ETerm) :- Term =..[Functor|Args], solve_list(Args, RArgs), ETerm =.. [Functor|RArgs]. %%% %%% osl_eval(+Term, -Result) %%% %%% %%% osl_eval(Term, Result) :- sys_fun(Term, (Ins,Outs), Result in Sort, Call), satisfiable_constraints(Ins), call(Call), satisfiable_constraints(Outs), Result in Sort. osl_eval(Term, Result) :- term_class(defined_function, Term), lemma((Term=Result)), !. osl_eval(Term, Result) :- term_class(defined_function, Term), (Ins,Outs)#Term1 &lt;= Body, standardise_term(Term1, ETerm1), Term = ETerm1, satisfiable_constraints(Ins), solve(Body, Result), satisfiable_constraints(Outs), add_lemma((Term=Result)). %%% %%% establish(+Term, -Result) %%% %%% %%% establish(Term, Result) :- sys_pred(Term, (Ins, Outs), Call), satisfiable_constraints(Ins), call(Call), satisfiable_constraints(Outs), Result = Term. establish(Term, Result) :- term_class(defined_predicate, Term), ((Ins,Outs)#Term1, standardise_term(Term1, ETerm1), Term=ETerm1, satisfiable_constraints(Ins), satisfiable_constraints(Outs), Result=Term ; (Ins,Outs)#Term1 &lt;- Body, standardise_term(Term1, ETerm1), Term=ETerm1, satisfiable_constraints(Ins), solve(Body,_), satisfiable_constraints(Outs), Result=Term). %%% %%% term_class(C, T) %%% %%% Term T is of class C. %%% term_class(primitive, Term) :- number(Term), !. term_class(primitive, Term) :- atom(Term), !. term_class(primitive, Term) :- var(Term), !. term_class(defined_predicate, Term) :- def(Term, pred(_,_)), !. term_class(defined_function, Term) :- def(Term, fun(_,_,_)), !. term_class(predicate, Term) :- sys_pred(Term, _, _), !. term_class(predicate, Term) :- term_class(defined_predicate, Term), !. term_class(function, Term) :- sys_fun(Term, _, _, _), !. term_class(function, Term) :- term_class(defined_function, Term). %%% %%% Built in sorts %%% sort_test(number, N, number(N)). %%% %%% Built in system functions. %%% sys_fun(A*B, ([A in number, B in number], []), C in number, C is A*B). sys_fun(A-B, ([A in number, B in number], []), C in number, C is A-B). sys_fun(A/B, ([A in number, B in number], []), C in number, C is A/B). sys_fun(A+B, ([A in number, B in number], []), C in number, C is A+B). %%% %%% sum_elements(+Lst, +Acc, -Sum) %%% %%% The sum of the elements of Lst plus Acc is Sum. %%% sum_elements([], Sum, Sum). sum_elements([H|T], Acc0, Sum) :- Acc1 is Acc0 + H, sum_elements(T, Acc1, Sum). %%% %%% sum_elements(+Lst, -Sum) %%% %%% The summation of all of the elements of Lst is Sum. %%% sum_elements(Lst, Sum) :- sum_elements(Lst, 0, Sum). sys_fun(sum(Lst), ([], []), Sum in number, sum_elements(Lst, Sum)). %%% %%% Built in system predicates. %%% sys_pred(A=B, ([], [A in universal, B in universal]), A=B). sys_pred(A&lt;B, ([], [A in number, B in number]), A&lt;B). sys_pred(A=&lt;B, ([], [A in number, B in number]), A=&lt;B). sys_pred(A=:=B, ([], [A in number, B in number]), A=:=B). sys_pred(A&gt;=B, ([], [A in number, B in number]), A&gt;=B). sys_pred(A&gt;B, ([], [A in number, B in number]), A&gt;B). %%% %%% Built in meta-functions. %%% meta_fun(setof(F), Set, (findall(X, solve(F, X), Bag), sort(Bag, Set))). meta_fun(bagof(F), Bag, findall(X, solve(F, X), Bag)). %%% %%% add_lemma(+G) %%% %%% Add the goal lemma(G) to the database so we can retrieve it %%% without solving it again. %%% add_lemma(G) :- assert(lemma(G)). 
I think you are already very close to recognizing that CLP(FD) is the way to solve such problems: You can simply introduce integers for people, and post ordering constraints between them to break symmetries. For example, in this case with SWI-Prolog: :- use_module(library(clpfd)). group(Ps) :- Ps = [_,_,_], Ps ins 1..15, chain(Ps, #&lt;). CLP(FD) is meant to be used, I highly recommend it as the solution for such problems. All serious Prolog systems ship with a CLP(FD) implementation, so it's also not like you are doing something completely out of line when using such a common feature, in fact quite the contrary. Nevertheless, I will limp along with you the hard way, if you want this, so you can later better appreciate the benefit of constraints. So, take the following as how one can solve it without CLP(FD), with the fat disclaimer that this is *not* the way to do it in modern Prolog systems, but for instructional purposes alone, to make you eventually be more grateful for Prolog features that were invented 40 years ago and have steadily improved since then. First, \=/2 is very rarely a good idea. Use dif/2 instead to state disequality, since it is sound in all directions, even if its arguments are variable. However, to break symmetries, you can require more than just disequality: Use @&lt;/2 to require that the elements in the list be increasing with respect to the Prolog standard order of terms. For comparison again: This would of course be trivial with CLP(FD) by just posting #&lt;/2 constraints among the members of each group, with the advantage that you can post #&lt;/2 at *any time*, not just when the arguments are ground. For simple checks, you can use memberchk/2 instead of member/2. For lookups, consider using library(assoc), so that you can asymptotically more efficiently determine whether an element has already occurred. Just to be clear: This is indeed a comparatively hard problem to approach especially of you are just beginning to learn the language, so do not be too hard on yourself for now! You can try to solve a few easier problems between your attempts. For comparison, you can also try to solve it in languages you are familiar with and see that it would usually be even harder then. Just keep up the effort, and you will eventually obtain a quite nice solution for this if you are interested. I'll be here for any questions!
Thanks so much! I haven't had time to try and run them yet, but I hope to soon. It's awesome to read over though :) 
Use the "-O" flag of SWI-Prolog for better performance. It precompiles arithmetic expressions too. Speaking of arithmetic, please use CLP(FD) constraints like (#=)/2 instead of is/2. It is much more declarative and general and has almost the same efficiency. For example, write Max #= Size^2 and Magic #= (Size * (Max+1))//2 etc. Same for #&gt; and other comparisons. Try to obtain simpler code by relying more on pattern matching instead of indexing. format/2 gets easier to use with some practice. I think it's OK and quite flexible. Not bad for your first CLP(FD) attempts! Keep it up, and play with different labeling strategies in labeling/2. Hint: [ff] is often a good strategy. As for books, I recommend you first read *The Art of Prolog*, and then *The Craft of Prolog*, while keeping in mind that we now also have constraints which make many things a lot easier for beginners.
A turn mechanic is easy to describe in Prolog: In essence, you only have to relate one state of the game to the next state, when a certain turn is made. For example: state0_turn_state(S0, Turn, S) :- .... Here, you can make a case-distinction (via distinct clauses, depending on *Turn*) and relate one state to the next state after the turn is made. Clearly, you have to devise a suitable representation of the game state as a Prolog term. One major advantage of such a declarative description is that it can be used in all directions: You can ask "What is the next state when I make this turn?", and you can also ask: "Which move should I make to reach a target state?" A sequence of turns is also very easy to describe, and is a natural extension: state0_turns_state(S, [], S). state0_turns_state(S0, [T|Ts], S) :- state0_turn_state(S0, T, S1), state0_turns_state(S1, Ts, S).
Very nice! I find lists of lists (i.e., one list per week, one list per group) a very fitting representation for this problem. In essence, it *is* a matrix (groups = rows), so whether you have one huge matrix or a list of lists does not make much difference, but the list-of-lists representation lends itself more easily to pattern matching and higher-order-predicates (maplist/2 etc.), so I recommend it. I see you are a bit stuck with declaratively describing the "socialisation" constraint (unique pairing), so I want to give you a small hint. Suppose I have the group [A,B,C] of players, which are in ascending order. Then the pairs are [A,B], [A,C] and [B,C]. I know that all three of these pairs are members of the set of all pairs of players, [[0,1],[0,2],...,[1,2],[1,3],...,[2,3],[2,4],...,etc.]. I can express this with the tuples_in/2 constraint in SWI-Prolog (fd_relation/2 in GNU Prolog, table/2 in SICStus Prolog). And now a little twist: I introduce a unique integer for each of the possible pairs of players above, and extend these pairs to triples, like so: [[0,1,0],[0,2,1],...,[1,2,8],[1,3,9],...,[2,3,20],[2,4,21],...,etc.]. I used the IDs 0,1,8,9,20 and 21 just as examples, it does not matter which integers they are as long they are unique (I leave coming up with a formula that yields a unique integer for each pair as a simple exercise for you). And now the point: I again use tuples_in/2, but I introdue a unique variable for each of the pairs in each concrete group:[A,B,X], [A,C,Y] and [B,C,Z], *and then* I require that X, Y and Z be pairwise distinct, and this ensures that each pair occurs at most once. LOL! Have fun with Prolog!
I have a long running, but sadly neglected interest in table-top RPGs, so I thought I'd have a look at the Pathfinder system (as described [here](http://www.d20pfsrd.com/gamemastering/combat#TOC-How-Combat-Works)) to see if I could put together a little mock up. It looks to be a rather complex and involved system. I quickly become caught up in questions about how the characters should be represented, how the map would be drawn up, how to model environmental conditions, mutual awareness, targeting, etc. It should be lots of fun to realize! Of course, as you say, given the complexity of the system, and depending on the expectations of your class assignment, you'll almost certainly have to *either* give a very simplistic representation of the system as a whole, *or else* pick a very small aspect of the system to model in detail. Character creation looks like an easy place to start: in part because all other mechanics seem to presuppose a lot of data about the characters (e.g., determining initiative for combat); also because the creation of the character doesn't require dealing with changing state. Regarding implementing a state-mechanic, hopefully zmonx's good advice is enough to set you on you way! If not, I'd be happy to talk through some of the details with you, if you give me a better sense for what you're pursuing. For instance, I Googled "DPS" in this context, and, according to the [wikipedia article on damage per second](http://en.wikipedia.org/wiki/Damage_per_second), calculating DPS shouldn't require any tracking of state: it's determined by a simple equation. But this makes me think you must have something particular mind mind with regard to Pathfinder. In any case, it sounds like a fun project! :)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Damage per second**](https://en.wikipedia.org/wiki/Damage%20per%20second): [](#sfw) --- &gt;__Damage per second__ (DPS) is a term used with [computer games](https://en.wikipedia.org/wiki/Computer_game) to describe the average rate of damage inflicted over time. The term is especially common in [massively multiplayer online role-playing games](https://en.wikipedia.org/wiki/Massively_multiplayer_online_role-playing_game) (MMORPG) and is a key aspect of [theorycraft](https://en.wikipedia.org/wiki/Theorycraft). In this circumstance, "Damage" is a scalar quantity that is applied to an in-game opponent, until that opponent's [capacity for absorbing damage](https://en.wikipedia.org/wiki/Hit_point) is exceeded and the opponent is defeated. Therefore the higher the DPS value, the less time it takes to defeat an opponent. &gt; --- ^Interesting: [^Theorycraft](https://en.wikipedia.org/wiki/Theorycraft) ^| [^Glossary ^of ^video ^game ^terms](https://en.wikipedia.org/wiki/Glossary_of_video_game_terms) ^| [^The ^Matrix ^Online](https://en.wikipedia.org/wiki/The_Matrix_Online) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cp4oz14) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cp4oz14)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thanks for the tip. Last question, is there a way to query the knowledge base at run time knowing that the query structure itself will be changing based on the user input? For example, if I enter "Is Fido a mammal?", I should essentially perform the query mammal(fido). But the input could be anything, so I can't just hard code that query. If I have the terms in variables like X = fido and Y = mammal, is there a way to say Y(X) in code?
&gt; but it was magic to me learning about it. You know you're expanding your programming horizons when that happens. Just out of interest if we gave the following definition: let &lt; be an partial ordering (irreflexive and transitive) on N. An element A of N is called * a maximal element of N if there is no B in N such that B&gt;A * a minimal element of N if there is no B in N such that B&lt;A then it pretty much is a textual description of your code where N={X | a(X)}. Isn't Prolog great!
&gt; Isn't Prolog great! The more i learn about it the more i like it! I like the gtrace functionality of swi prolog a lot and i like to try these kind of things for better understanding. It's really so different then other programming languages that some things are hard to understand at first. It is fun to use it though which is half of the work :)
I was curious about efficiency of various approaches, especially compared with this nice solution. I don't know if my strategy for testing it is very effective, but here are my results. I wrote the following three pairs of predicates: smallest_1(A) :- a(A), \+ (a(B), B &lt; A). biggest_1(A) :- a(A), \+ (a(B), B &gt; A). smallest_2(Total) :- aggregate(min(A), a(A), Total). biggest_2(Total) :- aggregate(max(A), a(A), Total). smallest_3(A) :- findall(X, a(X), Xs), sort(Xs, [A|_]). biggest_3(A) :- findall(X, a(X), Xs), sort(Xs, Sorted), last(Sorted, A). Then asserted 1000 facts with `a/1`, each with a simple ascending value: ?- forall(between(1,1000,N), assertz(a(N))). true. And then I ran each of the versions of smallest and biggest with `time/1` to see how many inferences they required to reach the solution: ?- foreach(member(P, [smallest_1, smallest_2, smallest_3]), (format('~w: ', [P]), time(call(P, X)))). smallest_1: % 1,003 inferences, 0.000 CPU in 0.000 seconds (91% CPU, 5065657 Lips) smallest_2: % 3,026 inferences, 0.001 CPU in 0.001 seconds (99% CPU, 5085714 Lips) smallest_3: % 1,013 inferences, 0.000 CPU in 0.000 seconds (98% CPU, 2936232 Lips) X = 1 ?- foreach(member(P, [biggest_1, biggest_2, biggest_3]), (format('~w: ', [P]), time(call(P, X)))). biggest_1: % 502,502 inferences, 0.067 CPU in 0.068 seconds (100% CPU, 7448557 Lips) biggest_2: % 4,027 inferences, 0.001 CPU in 0.001 seconds (99% CPU, 4682558 Lips) biggest_3: % 2,014 inferences, 0.000 CPU in 0.000 seconds (99% CPU, 4085193 Lips) X = 1000. Not surprisingly, the efficiency of the most declarative approach seems *highly* dependent on the order in which the facts are asserted in the database. Using the `sort/2` and then taking the first or last element of the list takes fewest inferences, but I think this is sort of cheating based on the SWI-Prolog implementation: for SWI Prolog `sort/2` through C, and counts a call to `sort/2` as a single inference.
Also, the version with findall/3 might do a lot of copying into the clause store if it is implemented along the same lines as the Edinburgh library findall/3 by R. A. O'Keefe. This could trigger clause store garbage collections which take time of course. Obviously different implementations differ here. 
gtrace? What's that?
P.S.: The timing analysis strategy is perfectly valid, just try it out with 10,000 instead of 1,000 facts to see how quickly the versions diverge: %?- foreach(member(P, [biggest_1, biggest_2, biggest_3]), (format('~w: ', [P]), time(call(P, X)))). biggest_1: % 50,025,002 inferences, 6.729 CPU in 6.846 seconds (98% CPU, 7433865 Lips) biggest_2: % 40,025 inferences, 0.007 CPU in 0.007 seconds (95% CPU, 5845626 Lips) biggest_3: % 20,076 inferences, 0.004 CPU in 0.006 seconds (65% CPU, 4992788 Lips) X = 10000.
IMHO you have to know Prolog's rules for computation (literal/atom selection) and search (clause selection). That's good enough for smallest_1/1 and biggest_1/1. However, for the other procedures you also need to know how aggregate/3 and sort/2 are implemented. In these cases it's just educated guess work. Resources: *The Implementation of Prolog* by Boizumault, and *Prolog: The Standard* by Derensart et al. for Prolog's computation and search rules. For educated guess work: implementation manuals and *The Craft of Prolog* by O'Keefe. I assume you've been taught the basics of asymptotic efficiency of algorithms. Also, you learn an *awful* lot when you implement Prolog.
Thank you!
btw, I didn't mean to denigrate the nice declarative specification you presented. I think it's great :) I tested those other approaches out more because I think, *ideally*, such elegant declarative definitions *should* be feasible for production-level code but I am too much a novice to have recognized right off the bat that they would not be. 
yes don't worry, i didn't mean them to be the best solution (i mentioned instead of using variables in the predicate). I'm starting to learn prolog and try to find solutions without predefined predicates although they certainly are helpfull and (mostly) better suited for the job. This one however made me realize how backtracking and 'plain' prolog really works.
This is exactly what I am looking for and what I mean. However just one question. Would you say that this is potentially better than Vellmen? Also you say that the books mentioned looked ok. Do you mean ok as in meh, its alright theres better, or do you mean they are ok in the sense that they are good options?
 ?- version. Welcome to SWI-Prolog (Multi-threaded, 64 bits, Version 7.1.30) [...] true. ?- listing(forall). :- meta_predicate forall(0,0). forall(A, B) :- \+ ( call(A), \+ call(B) ). true. ;) I can definitely see why one would prefer the latter, since it lets you keep your head in the mode of backtracking. I have learned Prolog with SWI Prolog, and have had a heavy bias towards the declarative ideal. I have thus tended towards declarative idioms whenever possible, and thus cultivated a style that relies on higher-order predicates to abstract procedural code into declarative forms. Thus, I will tend to use [once/1](http://www.swi-prolog.org/pldoc/doc_for?object=once/1) instead of `!`, when it makes sense, I'll reach for maps and folds instead of explicit recursion, and use `forall` and `foreach` instead of just making explicit failure driven loops. I should also probably note that my foundations are spotty, being self-taught and only a hobbyist. I bet that, if I had a proper eduction in logic programming, I would have made my peace with Prolog's elegant impurities some time go, and I would have made myself in proper backtracking already. Instead, I am only coming to embrace these things now :) Which Prolog do you mainly use?
&gt; Which Prolog do you mainly use? I use my own. I used SWI to bootstrap the compiler in the beginning but I haven't used any other Prolog for years now. &gt; Thus, I will tend to use once/1 instead of !, when it makes sense, I like to use once/1 too. I specifically added code in the compiler to make it cheaper. &gt; I'll reach for maps and folds instead of explicit recursion I have to admit for certain things a map and fold/foldr seems to be the obvious way to do things. &gt; I should also probably note that my foundations are spotty, being self-taught and only a hobbyist. I bet that, if I had a proper eduction in logic programming, I would have made my peace with Prolog's elegant impurities some time go, and I would have made myself in proper backtracking already. I only really *got it* when I implemented the language to be honest. 
[Here is the mobile version of your link](https://amazon.com/gp/aw/d/0674571762?tag=as_mi_tl-20&amp;ie=UTF8&amp;qid=1415866438&amp;sr=1-1)
C# != Logic Programming and the Prolog Language 
Of course.
Please post the data too so that we can reproduce this. Three general comments in any case: 1) Consider writing a DCG and then using library(pio) for parsing from files. It is much more declarative, useful and convenient, because you can apply a DCG to a file and also use it interactively and in test cases to work with it. 2) Very often, when I hear "why ... *on the second run*?", someone forgot that asserted facts *remain* asserted between runs. You have to retract them to start from a clean slate on subsequent queries. Better yet, *avoid* assertz/1 if possible, because it makes it impossible to test your predicates in isolation and in all directions. If you want to work with a database from somewhere else, it is better to convert it to Prolog clauses and then include it in your program, or turn it into a library and use it with use_module/1. This way, such mistakes (repeatedly asserting the same facts) cannot happen. 3) I agree that such questions are useful and also welcome. The general theme in such cases is: Try to stay in the pure subset of Prolog as much as possible to get the most out of it. Use declarative I/O (library(pio)), declarative arithmetic (library(clpfd), library(clpq) etc.) and avoid side-effects which complicate things considerably and make it hard to test your code.
&gt; Consider writing a DCG and then using library(pio) for parsing from files. It is much more declarative, useful and convenient, because you can apply a DCG to a file and also use it interactively and in test cases to work with it. They're fast as well. My DCG parser for Prolog is faster than my handcoded recursive descent one.
&gt; reading in the file on each lookup of a word Just for completeness: That's of course definitely *not* a good strategy. If the database is very static, consider converting it to Prolog clauses before using it at all. If it changes often, then writing a parser (recommended of course: with DCGs and library(pio)) is totally OK. However, be very careful not to accidentally assert the same things twice unintentionally. There is a feature called "transactions" that will maybe become available in future SWI-versions, and which will allow to run queries with a state of the world that automatically gets restored to the previous state when the query has finished. This would provide a nice solutions for such problems. The SWI-Prolog RDF database already has such a feature for a restricted subset of data. As an aside, such problems naturally solve themselves as you get more accustomed to Prolog, because eventually you will use term representations for many things throughout, after seeing how versatile your solutions become with it.
In your new version, the Prolog engine has the opportunity to apply argument indexing, and can thus later quickly determine the set of relevant clauses based on the arguments that are already instantiated. In the original version, a linear scan (which you had to code in Prolog with member/2, thus further slowing it down instead of the hash-based lookup implemented in C by the Prolog engine) over all words was necessary for each word, making your total runtime quadratic instead of linear. Thus, it is typically much more effecient to have facts represented in Prolog in such a way that argument indexing can be applied. In earlier versions of SWI-Prolog, this basically had to be the first argument (the feature is/was called "first-argument indexing" and provided by all serious implementations), but nowadays SWI and many other systems apply just-in-time indexing based on the argument that is instantiated on calls. It's a wonderful development really, and all users benefit enormously from it. As an aside, if you want to avoid the dynamic database (assertz/1 etc.), a balanced tree (see library(assoc)) provides a good combination of decalaritivity, making it easy to formulate test cases and test your predicates in isolation, and reasonably fast lookup.
Again: Please post clear instructions so that others can actually run your program with the right data. At least give a concrete URL. Another point I noticed is that you rely a lot on side-effects and failure-driven loops to see results. Instead, define clear relations and let the toplevel display the results for you! For example, define relations like word_anagram/2, word_anagrams/2, and anagrams/1, so that you can actually reason about the solutions within your program, and write actual test cases for these relations. You can later always print them out with queries like: ?- anagrams(As), maplist(writeln, As). but there should be relations to reason about them.
I guess my description was too vague. My robot obviously has to walk around in a house. Robot should do useful things like cleaning. The house has 6 rooms with doors and the robot can only move between connected rooms. One move costs, say, 1 charge level, if you are doing some task that requires carrying, then t costs 2 levels. If you clean some room from dirt then it costs 5 levels of energy. Also, I do not have a recharger in every room, only, say, in the kitchen. Imagine you are in situation where you need 2 moves to get from the sitting room to the kitchen but after vacuuming things in the sitting room, you have one energy level left. Then you are stuck there because you cannot reach the charger. I modelled every single constraint and I know they work because I checked decrease of battery levels in various situations but my program is very slow because I recharge repeatedly, even after having just recharged. My axiom is correct, assuming procedural language, i.e. I get current energy level, if it is max, then I don't recharge. I checked the condition and P == C is apparenty false when I just recharged, and negation would turn it into true iff P &lt; max charge. I tried P &lt; C but it was still stuck recharging...I tried to search for the way prolog treats numbers but all suggestions did not work. That is why I am stumped.
If it is max, you don't recharge, that's understandable. But certainly not the converse: Just because the battery level isn't max certainly doesn't mean that you immediately recharge! Realistically, in procedural language or not, you only recharge if the battery level is below a certain threshold *much lower* than its max capacity, don't you? That's why I suggested P =&lt; 1. When do you actually want to charge?
Here is one of the bad traces: s0 &gt; recharge &gt; recharge I recharge in the kitchen two times, when second is not needed, I start with battery level 0 just to check if it recharge. It does. Here is the successor axiom: battery(W, S) :- A = recharge, maxCharge(C), W is C. Here is possibility axiom: poss(recharge, S) :- battery(W, S), in(kitchen, S), maxCharge(C), not(W =:= C). I set W as C which is 10 because I set atemporal maxCharge(10) in s0. However, in the next state I recharge again, which means my possibility axiom deals with numbers incorrectly? I think the correct decision to recharge is as long as I am not just recharged because of constraints mentioned above.I cannot just decide to recharge when &lt;= 1 because I may need more steps to get to the charger.
&lt;= 1 is just one of many possibilities. In your case, that condition is *too specific*, because you may need to recharge sooner. On the other hand, W =\= C is *too general*, because you may not need to recharge immediately. So, the task here is to find and formulate the correct condition on when to actually recharge. From what you say, the right condition will obviously need to take into account the distance to the battery station, so I suggest you write a predicate that computes the distance, and then decides whether a recharge is needed when taking into account the current battery status too.
Have you looked at SWI Prologs [semantic web library](http://www.swi-prolog.org/pldoc/package/semweb.html) and/or the [ClioPatria](http://cliopatria.swi-prolog.org/home) project that uses it?
&gt; Order-free execution semantics. Not sure I understand what this means. By this do you mean computation rule? If so, how do you schedule I/O? For example, say I wanted to display "hello" then "world", how do I make sure I don't get "world" followed by "hello"?
Depends on how you look at it. My approach is to *not* prune the search tree. Instead, I depend on the scheduler to choose paths most likely to converge on a solution.
It's still streaming I/O. That has order because the data has order. It's only the execution code that can be scheduled however you want.
Are you saying that if I had something like this: announce :- write('hello'), write('world'). that instead of utilising Prolog's pragmatic control (left-to-right computation rule) that I would have to use some explicit control to enforce the order of computation, maybe something like this: :- left_to_right(announce/0). announce :- write('hello'), write('world'). 
No. I'm being quite serious.
No, it doesn't solve the halting problem. No, it doesn't have to be clairvoyant. An MLA takes previous inputs and uses it to predict what to execute next. Obviously, the devil's in the details.
What's an instruction? Do you mean atom/literal in the body?
Use a game state to keep track of the state, make it tail call recursive so you can always pass in a new game state. Here is an example from my 2048 game loop. game_loop:- getEmptyGrid(EmptyGrid), initalizeGrid(EmptyGrid, StartGrid), nextGrid(StartGrid, GameGrid), GameState = [GameGrid, 0, play], % Grid, Score, play game. game_loop(GameState). game_loop(State):- end_condition(State). game_loop(GameState):- displayGrid(GameState), writeln('Enter w,a,s,d to move or q to quit'), repeat, write('input&gt; '), read(X), write(X), do(X, GameState, NewState), nl, game_loop(NewState). 
Wow. Neat factoid indeed!
Oh yes. that helps a bit with readability. Here's some practical advice that won't immediately help you find your bug, but will help with the readability of your code, enabling you and others to comprehend it more more effectively: - Keep your lines short when possible: =&lt; 80 Chars is a common rule of thumb. - Indent subordinate statements. - Refactor your code into short rules that deal with general cases. - Separate your game logic from your input and output by enclosing input and output in their own predicates. - Maybe use lists instead of those really long predicates? If you were passing the data along as a list, you could abstract away from all those instances where you just have to repeat the same variables over and over. I'll look over it in more detail when I get a chance later tonight.
When is it due?
Will you continue to discuss Prolog the language, or will it be more about applications of Prolog that they might find interesting?
No worries! I maybe should have posted that comment in a separate post. It's more me trying to explain my rational to the active subscribers here, probably needlessly. Sorry to have troubled you with it. That was clumsy of me. As I said in my comment, I don't think *your* offer of payment is problematic, but we have had some problematic ones recently, and I was trying to differentiate. However, /u/logic_programmer's reply is right on: the rate you're offering is far below qualified consultation rates, and in any case, the Prolog community is generally very eager to help earnest learners. If you're willing to put in the work in formulating good questions and responding to criticism, you can get lots of guidance. 
Yeah, your motives are quite clear from the context. The programming world, especially those little communities around beloved, relatively obscure languages like Prolog, is surprisingly enthusiastic about offering free labor/expertise. It's one of the joys of engaging with the enthusiastic experts you'll meet (I am enthusiastic, but not expert ;).
I dont really understand this idea of domain specific languages.. what would be a really simple example? 
Ok then, I would suggest DCGs but not just for parsing, show how they can be used for generating as well - maybe generate HTML pages from structures using a DCG.
I'm interested! In general, I think the more language-experiments the better, even if I don't personally find them compelling. I have a question. Please forgive me if it is naive or if I misunderstand something basic. You say &gt; Predicates are executed when they are seen. Given this example, bar($x) will execute when foo() is entered: Does that mean that you cannot use complex terms as data structures? I.e., in Prolog, if we had the predicate foo(bar(Baz)) :- ... We could decide whether `bar(Baz)` was just a data structure, of if we wanted to try evaluating it as a goal somewhere in the body of the clause. But if I understand what you're saying, if we have code like the above then `foo/1` can only be true if `bar(Baz)` is also true. If this is right, what is your motivation for this decision?
&gt; Do I understand correctly that, in this code, you first specify and define the DSL for describing relational semantics, and then proceed to implement IMP? Yes. &gt; So you're exhibiting here two DSLs (if IMP qualifies as such)? Yes and no. IMP is just a simple IMPerative language used to teach operational semantics. It's not used for anything other than executing test code. &gt; Are there any other unique properties of your Prolog worth mentioning, in addition to the collapse_multiple_minuses Not really. I do have arbitrary precision floats. I actually added the changes to the reader for collapse_multiple_minuses just for the example given - one of the advantages fo rolling your own implementation.
I gave a talk at Strange Loop 2014 that might give you some ideas: https://www.youtube.com/watch?v=G_eYTctGZw8 I'd probably also mention DCGs, term_expansion macros and run-time code generation (asserting facts and clauses to create/augment predicates). The snags I've encountered vary widely depending on the programmer's background. The two most common are probably: the functional flavor, the mental model of logic variables. Good luck!
I'm not completely sure I understand your question. So, I'll go over some design decisions I made. Anytime the Epilog interpreter sees something in the form of x(...), it evaluates it as a rule. The rule once it succeeds generates a "fact" version of itself. So, for example if $x = foo(_) then, foo(\_) will look for rules matching that namespace and arity. $x OTOH will take a fact with an identical signature to whatever foo(\_) evaluated to. For example rule foo("hello") rule run() new foo("bye") $x = foo(_) In this case, $x == foo("hello") and $x == foo("bye") 
&gt; First, I think you are terms that are often used in the context of Prolog, but with very different meanings, is that right? Well, I probably am but not in this case. I just said it poorly. What i meant to say is that the Epilog interpreter sees something in the form of x(...), it evaluates it as *if it were* a rule. In other words, anytime the interpreter sees foo(...), it's essentially calling a function. &gt; But you're saying that anything which has the form Functor(Args...) is evaluated as a "rule" in Epilog? Addressed above. &gt; And when you say "fact" you mean some transformation that takes place after a "rule" succeeds? Yes. &gt; What does it mean to "take a fact"? Does this mean assigning the variable $x to a value withe the free variable in foo(_) instantiated (BTW, are the $x variables assigned, or more like functional bindings, or are they logic variables?). A "fact" is a compound type with its own special unification code (though it's essentially like a list). And, yes, $x is just a logic var. More precisely, it's a symbolic reference. &gt; Do you mean it with be either the one or the other on back tracking? Or that it is actually equal to both simultaneously? If the latter, how does that work? I meant that it's one or the other on backtracking. &gt; My specific question was about what happens when you have one complex term as argument to another, as in your original example: So, two answers in: rule foo(bar("baz")) ... rule test() foo($x) foo(bar($y)) In the first case, when foo($x) is called, it finds the matching rule and $x will unify to bar("baz"). Contrast that to the second case, where bar($y) is called and the it's unified to whatever foo(_) returns. 
I only lurk in the r/prolog subreddit, and played with it during graduation, but I'm the moderator of r/functionalprogramming. Feel free to cross-post your answer there. Hope you get some ideas or contributors :)
Thank you for posting on G+! Thank you for being honest with your experiences, however hearing what excites you about prolog and puzzling problems you encountered would be awesome.
Functional languages use several tricks to prevent that. In what example or situation did you see this problem?
Thanks for your interest. On the NLP front, I see the problem as one of layers. Each layer deals with various aspects of the language problem, such as word matching, phrase matching, deep meaning matching to produce knowledge. Similarly, you must go in the reverse case to produce language from knowledge. So, in my efforts I found a number of issues with Prolog that the language made very difficult to overcome. Multiple terms. In some instances you could have, say, 20 terms you're trying to resolve. A depth first search walks through all candidates for each term in order. A depth first solver simply takes too long to naively resolve potential candidates. So, then, you end up writing all this code to prune the search tree. It turns that many solutions may work at the level you're searching at but those solutions are still sparse relative to a 20! search space. My view is that instead of pruning the tree, you guide the search to the most promising branches. This requires the ability to guide search in the first place -- something that a depth first language doesn't provide. Note that this problem exists even for breadth first. Sometimes you need to do depth first because the terms you've already bound to are "good" candidates. Open as opposed to closed system. I found that Prolog wants to treat each solve discretely. The idea is to parse a sentence and turn that into knowledge; it also means that you need to know the boundary of that sentence. (I know you can work around it). I wanted to create a system where input can be streamed in and output streamed out at all levels -- essentially a processing pipeline -- requiring a semaphore primitive. For N items on the input queue, stages that require N+1 items can wait until they see what they need. These are the main two motivations for Epilog, I have other motivations but they are implementation-specific and do not depend on the language itself.
I can honestly say that I don't understand anything about your question. Can you rephrase it and define correct order? Guess: Are you looking to do a topological sort? http://en.wikipedia.org/wiki/Topological_sorting Here's a topological sort demo from my Prolog manual: | ?- p_to_s_graph([a-b, b-d, c-d, d-e],S), top_sort(S, Sorted). S = [a-[b],b-[d],c-[d],d-[e],e-[]] Sorted = [a,b,c,d,e] ? % yes If this is the *sort* of thing you want then have a google for the Edinburgh graphs library (http://www.j-paine.org/prolog/tools/files/contents.html) for source code (or just check out your Prolog manual to see if it's already there).
i mean I have certain rules that specify that one variable is bigger than the other and i want to order all the variables by those rules.
A naive solution: items_order_items(Is0, Order, Is) :- foldl(merge_item(Order), Is0, [], Is). merge_item(Order, I, Is0, Is) :- select(I, Is, Is0), phrase(list_pairs(Is), Ps), \+ ( member(X-Y, Ps), memberchk(X &gt; Y, Order) ). list_pairs([]) --&gt; []. list_pairs([L|Ls]) --&gt; pair_with(Ls, L), list_pairs(Ls). pair_with([], _) --&gt; []. pair_with([L|Ls], W) --&gt; [W-L], pair_with(Ls, W). Example query and its result: ?- items_order_items([a,b,c,d,e,f], [a&gt;b,b&gt;c,a&gt;d,b&gt;e], Is). Is = [f, e, d, c, b, a] ; Is = [e, f, d, c, b, a] ; Is = [e, d, f, c, b, a] ; Is = [e, d, c, f, b, a] ; etc.
You want to order *variables* or do you want to order what the variables reference?
sounds like a constraint problem http://www.swi-prolog.org/man/clpfd.html 
Cool :) I wish there was some kind of documentation for the Prolog part, though - clicking the Prolog link in the documentation section didn't work, unfortunately ( using reddit is fun on android)
Since my Spring Break-- end of February.
Nice to see something a little bit different!
Nice usage of Prolog!
Thank you. In my circle, everyone knows the background. So I didn't do a proper introduction. 
If you have a concrete problem of transaction logic or frame logic, I can try to solve it. 
I may have too weak a grasp of the meaning of those terms. Only, it was my understanding that they deal with situations where the state of the system changes: new facts become known, or new relationships introduced, or different agents have access to different knowledge based. It seems that this puzzle depends on the introduction of a new fact at some point, and on the asymmetry of knowledge between to agents. Your solution represents this change in state by appending '1' and '2' to the predicate names, I thought. But I also suspected this same problem could be modeled in a way that captured the change in what is known resulting from the one party admiring they do not know! If that makes sense. I'm a bit cloudy today, and on my phone besides.
It's much easier than that: even(X) :- X mod 2 =:= 0. Even better, use CLP(FD) constraints to make it easier and more general: :- use_module(library(clpfd)). even(X) :- X mod 2 #= 0. This lets you ask quite general questions and still obtain useful answers: ?- even(Y). Y mod 2 #= 0. 
Yes, pretty much as it says: Rules must be loaded from a file. Save the code to a file and then consult it. For an integrated editor, use: ?- emacs. You can also use the following to specify the rule on standard input: ?- [user]. Then enter: even(X) :- X mod 2 =:= 0. Then press ENTER, and then press Ctrl + d.
Nice! I have to admit, I taught myself all programming I know, with little to no guidance...just cookbooks mostly! I appreciate this feedback! I had asked on code review stack exchange how to find this type of information but no one there really knows prolog, let alone SWIPL...
oh geez, I just failed their captcha test ...
An important step in getting help in forums like this is presenting whatever code you've tried out so far, and/or a clear articulation of what particular issues/challenges you're stuck on.
I couldn't acess the book...
The condition is only tested *once*. If it succeeds, the first branch is executed. If it fails, the second branch is executed. However, the other branch will *not* be selected when backtracking, because the conditional won't be re-executed. What you're trying to do might be possible by splitting the rule into multiple clauses. Also, I'm pretty sure that you have extra arrows in your code. There shouldn't be any between the write statements in a single branch.
citizen and natcitizen should always fail, because they are already citizens of the country, in this case Ireland, so they can't qualify, I will pastebin all of the code in my original post.
You have a number of errors in your code, aside from the logic. What you want is closer to this: qualify(X) :- \+((citizen(X), write(X), write_ln(' is already an irish born citizen'))), \+((natcitizen(X), write(X), write_ln(' is already a naturalized Irish citizen'))), ((marriedirl(X), write(X), write_ln(' qualifies: he/she is married to an Irish citizen')), fail; (adoptedirl(X), write(X), write_ln(' qualifies: he/she was adopted by Irish-born parents')), fail; (irlparent(X), write(X), write_ln(' qualifies: he/she has an Irish parent')), fail; (irlgrandparent(X), write(X), write_ln(' qualifies: he/she has an Irish grandparent')), fail; (permres5(X), write(X), write_ln(' qualifies: he/she is an Irish permanent resident and has been for at least 5 years')), fail). That will at least print the reasons, but it will still fail, because you're telling it too at the end of every branch. Also, you'll get multiple copies of some messages if they qualify through multiple relatives. You can fix that with cuts in adoptedirl/1, irlparent/1 and irlgrandparent/1.
You caught me stealth editing my post about the multiple messages. To be fair, you didn't get *any* messages, did you? As for making what you have work, my suggestion, in this case only, would be double negation. Generally a bad idea, but it will work since you're using write statements. qualify(X) :- \+subqualify(X). subqualify(X) :- \+((citizen(X), write(X), write_ln(' is already an irish born citizen'))), \+((natcitizen(X), write(X), write_ln(' is already a naturalized Irish citizen'))), ((marriedirl(X), write(X), write_ln(' qualifies: he/she is married to an Irish citizen')), fail; (adoptedirl(X), write(X), write_ln(' qualifies: he/she was adopted by Irish-born parents')), fail; (irlparent(X), write(X), write_ln(' qualifies: he/she has an Irish parent')), fail; (irlgrandparent(X), write(X), write_ln(' qualifies: he/she has an Irish grandparent')), fail; (permres5(X), write(X), write_ln(' qualifies: he/she is an Irish permanent resident and has been for at least 5 years')), fail).
I am not sure what you mean by any messages, my code was functioning the way I described it, and I did not know that my code was buggy. I've only been working with prolog for a few days.
The best way to get started with Prolog.
I have seen this recommended before but, it makes the predicates names a bit long especially if you have 4 or 5 place predicates dont you think? greatgrandfather_grandfather_father_son(X,Y,Z,G). vs male_line(GGF,GF,F,S). as an extreme example.
append/3 is part of the Prolog [Prologue draft](https://www.complang.tuwien.ac.at/ulrich/iso-prolog/prologue), the meaning of arguments is very well known. Despite that, the name is still quite unfortunate, because it suggests a certain direction and thus limitation, whereas append/3 is a true relation that can be used in all directions. The meaning of arguments in reverse/2 is clear as well. In the other examples, not so much.
What have you tried so far?
Was this meant to link to something?
Yes! The link is: [https://www.npmjs.com/package/pengines](https://www.npmjs.com/package/pengines)
Thanks :) Looks neat. I'm excited to see what will come of the pengine tools.
From the type of problem I'm guessing this is a homework assignment, so I'll keep it pretty broad. As far as the summing up goes: You can simply add the distances of direct routes while finding the path, as long as you create an extra argument to keep track of the distance in your direct_connect predicate. Note that you are using a tail recursive definition. That has a few consequences when calculating the distance here as well. - It's perhaps easier, because you don't have to think 'backwards' about it, just add up the distance of every path you take. - You need to extra variables. One to keep track of the sum as you go down, one to pass the final value back up (the same way you collect and pass the route) - You need to initialize the 'counter' variable as you call the predicate Note, though, that right now you 'lose' the distance in your connected predicate. As to your first question, you'd have to be a bit more clear: What do you mean by 'optimal answer'? The shortest route? The least number of changes? Then how the program stops depends on how you intend to find the optimal route. You can't assume you know you have the optimal answer once you found that solution. The easiest (though inefficient in terms of calculation) way is too collect all solutions and then find the one with the shortest route (or whatever value you intend to optimize). 
You can express this by creating a rule that says that triangle(b,a,c) is true *if* triangle(a, b, c) is true. So you'd get something like triangle(A, B, C) :- triangle(B, A, C). Of course, you'd like to catch all permutations in one go, you'd get something like (there probably a built-in permutation predicate, not sure) triangle(A, B, C) :- permutation([X, Y , Z], [A, B, C]), triangle(X, Y, Z). *However* this will lead to infinite loops (the permutation of the permutation of the permutation... etc.) So you'll need to create another predicate, call it tri/3 or something (better). Then you get tri(A, B, C) :- permutation([X, Y , Z], [A, B, C]), triangle(X, Y, Z). And you're done. You can do the same thing for your angle predicate.
In [SWI-Prolog](http://www.swi-prolog.org/), one uses the [permutation/2](http://www.swi-prolog.org/pldoc/man?predicate=permutation/2) predicate. 
I'd probably define something like this instead equals(triangle(A,B,C), triangle(D,E,F)) :- permutation ([A,B,C], [D,E,F]).
I think that makes sense if you explicitly what to compare equality between triangles. Though it just be for readability in that case too, as you could just call permutation directly. However, what I think OP's issue is, is that the order of the arguments doesn't matter. The fact that they represent the same object is implicit, so you'd want to be able to call triangle(a, b, c) and, for example, triangle(b, a, c) interchangeably.
Just post your assignment here, I'm sure someone will be glad to help you
Also make sure you specify what you do know and what blocks you
You seem to be approaching logic programming in a procedural way. With logic programming, the goal is to declare your program logically. So it can be read logically. cat(felix). cat(max). dog(bob). meow(X):- cat(X). bark(X):- dog(X). X can meow if X is a cat or X can bark if X is a dog. cat(X):- member(X, [felix, max]). meow(X):- cat(X). Same stuff. Your predicates are sort of like your types. But if you will like to just have meow(X):- stuff, without checking if X is a cat. That will get very ugly.
On question 2: - http://www.swi-prolog.org/pldoc/man?section=preddesc
In my case a duplicate does not matter because ordering does not matter. I was trying to assert my own understanding with this question. Thanks!
Thank you, I think I prefer to keep explicitly using predicates to check for everything. This also limits the amount of answers to only valid ones (valid types) that the prompt gives me back.
Thanks!
Well I was bored at work so... Can you use another predicate? bar([], 0). bar([H|T], N) :- bar(T, N1), N is H+N1. foo(L1, L2, L3) :- bar(L1,N1), bar(L2,N2), L3 = [N1,N2].
Thank you. It is definitely OK to use another predicate, but this is not equivalent to the version I have. What I was looking for was all the possibilities of sums using one operand from the first list and the second operand from the second list. As an example: foo([1,2,3], [3,4,5], X). X = [4, 4]. X = [4, 5]. X = [5, 5]. X = [5, 6]. X = [6, 6]. ... Also, ultimately I would have liked to change the list length from being exactly 2 to being anything less than some length N.
Thanks!
Do you mean that when c(foo, bar) is true, c(bar, foo) is also true? Yes.
 :- meta_predicate symm(2, ?, ?). symm(P_2, A, B) :- call(P_2, A, B). symm(P_2, A, B) :- call(P_2, B, A). item(walrus). item(duck). item(manatee). item(elephant). item(goat). c(walrus, duck). c(walrus, manatee). c(manatee,elephant). c(goat,duck). c(manatee,duck). p(List):- var(List), longest_unique(All),!, member(List,All). p(List):- nonvar(List), check_all_compitable(List). generate(List):- findall(I,item(I),Is), length(Is,MaxList), between(1,MaxList,Size), length(List,Size), generate_h(List). generate_h([A,B]):- c(A,B). generate_h([New|List]):- generate_h(List), item(I), \+member(I,List), forall(member(M,List),symm(c,M,I)), New =I. generate_all(ListOfSols):- setof(Sol,generate(Sol),ListOfSols). build_unique([]). build_unique([New|Rest]):- build_unique(Rest), generate_all(ListOfSols), member(New,ListOfSols), forall(member(Exist,Rest),\+is_permutation(New,Exist)). build_unique_size(Unique,Size):- length(Unique,Size), build_unique(Unique). longest_unique(List):- generate_all(Sol), length(Sol,L), longest_unique_h(List,L). longest_unique_h(Unique,Size):- build_unique_size(Unique,Size). longest_unique_h(Unique,Size0):- Size1 is Size0 -1, Size1 &gt;=2, longest_unique_h(Unique,Size1). check_all_compitable([]). check_all_compitable([H|T]):- forall(member(M,T),symm(c,H,M)), check_all_compitable(T). is_permutation(Xs, Ys) :- msort(Xs, Sorted), msort(Ys, Sorted). 
Trying to show code in reddit is annoying. This works but is a bit horrible lol. It is slow and does a lot of repetitive work. I am sure you can work out a way to make it more efficient. 
Great :) you need a meta predicate symm to make c/2 behave nicely as symmetric predicate. You could list 2 copies of each fact alternatively but that would get boring quickly. Note that something like. c(foo,bar). c(X,Y):-c(Y,X). Will cause you problems... Some info on meta predicates here: http://yfl.bahmanm.com/Members/ttmrichter/yfl-blog/meta-predicates-in-swi-prolog 
Thank you very much!
I provided [a solution using library(clpfd)](https://www.reddit.com/r/dailyprogrammer/comments/3efbfh/20150724_challenge_224_hard_langford_strings/ctegoc7), but it is very slow. I seem to always get very slow solutions when I try clpfd, which makes me think I don't really know how to use the library. Or is it the case that the library isn't capable of generating performant solutions to this sort of problem? Anyhow, I thought it might be a fun diversion for some prologers.
As the person who posted this challenge and *loves* Prolog, I couldn't agree more that Prolog is an excellent choice for solving this problem. I actually did solve the problem in Prolog when designing it, but I didn't use the clpfd library. Like you, I'm not familiar enough with how it performs to be able to tell whether or not it would be a good choice for this particular problem. It's technically an exact cover problem (as is sudoku, for instance), and since clpfd seems to be good at those, it might work here as well. However, regular old Prolog searching/backtracking is enough to solve this problem. This code: langford([], []). langford([S|Ss], Ns) :- \+ var(S), langford(Ss, Ns). langford([S|Ss], Ns) :- var(S), select(N, Ns, Ns2), S = N, nth0(N, Ss, N), langford(Ss, Ns2). Is totally sufficient to solve both challenge inputs (it doesn't have the bells and whistles to read input and print output, but this is the spine of the program). So, for instance: ?- length(L, 8), langford(L, [1,2,3,4]). L = [2, 3, 4, 2, 1, 3, 1, 4] ; L = [4, 1, 3, 1, 2, 4, 3, 2] ; Add a few lines to that, and it can solve the bonus as well (though it might take a minute or two).
This is very nice indeed. It is not only much much much faster than my clpfd solution, it is also easier to understand and much more concise. I think I should make more of an effort to solve problems using basic Prolog, and only try to complicate it with "advanced features" after the fact. As you'll see, I took the liberty of posting a solution based on your predicate to the /r/dailyprogrammer thread. It shows of the potential elegance of Prolog for this kind of problem much better than my convoluted clpfd approach. Thanks for doing such a great job with challenges. They give me hours and hours of joy and excitement :)
Try 8 and greater to see the huge benefit of `global_cardinality/2` and `min` labeling strategy. For trivial problems, naive backtracking is very often faster than complex propagation, but for larger problems, constraint propagation typically wins by a huge margin. I agree that /u/XenophonOfAthen's solution is great, and it can be shortened still!
Looks like this problem here, but in Prolog. http://www.checkio.org/mission/mathematically-lucky-tickets/ 
There is a tradition of not doing people's homework, so here are suggestions. Run the code with trace on. In SWI-prolog you start this with trace. This chapter of Learn Prolog Now should help. http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse10 Your hint for #2 is: how would you handle an empty list? And if you have gotten this far, and you really need to know this, keep going through Learn Prolog Now, or get a copy of the Clocksin and Mellish Programming in Prolog.
Pro tip: Enclose the code and equation examples in back-ticks (`) to make it render as mono-spaced literals, rather then transformed by markdown rules: that way you don't lose your asterisks to italics. E.g., writing `20*(3+2)` Will look like `20*(3+2)`. [edited to fix typos etc.]
Do you want the results of the calculations or the lists with the parentheses inserted?
start by representing the problem using facts and rules in Prolog.
Kudos to that! As a Prolog lover, please keep going with it as I think this is highly interesting! 
http://stackoverflow.com/questions/1917607/relational-logic-programming-in-python
The best way to read Prolog code is to think declaratively. A clause of the form Head :- Body. is read as: **If** `Body` is true, **then** `Head` is true. In a *fact*, as in your first clause, the (omitted) `Body` is implicitly `true`. So, what do these definitions actually mean? Let us consider the clauses one by one. Luckily, they can be considered in isolation, because you are staying more or less in the pure monotonic subset of Prolog, which is a good thing! (In actuality, I highly recommend to use CLP(FD) constraints instead of low-level arithmetic, i.e., use `(#=)/2` instead of `is/2` to make your predicates more general.) The first clause: fib(0, X, _, X). Just read it declaratively: Let us take for granted that this relation holds: If the first argument is `0`, then the second argument is equal the last argument, and vice versa. The second clause. Let us start with reading the `Body`: **If** `N1` is `N-1` **and** `Sum` is `X+Y` **and** `fib(N1, Y, Sum, F)` holds, **then** it is true that `fib(N, X, Y, F)` holds too. Notice the inductive reading of this definition: Suppose we already know solutions for `N1`. Then it is easy to compute a solution for `N`. That's what this clause means. The last clause, `fib/2` is only an interface predicate. Instead of `trace/0`, use the graphical tracer in SWI-Prolog: ?- gtrace, your_goal. This will give you some ideas what is going on. However, I still recommend the declarative reading (If ... then ...). Remember that `:-` is actually meant to represent an arrow, like `&lt;==`, and means logical implication.
One problem with this code is the way it's tied so closely to using an input stream. Your problem is simpler and needs you to define a predicate like: tokens(Str, List). Which is fairly easy to create, noting that strings in Prolog are just lists of character codes, i.e.: ?- X = "foo". X = [102, 111, 111]. 
Explicit evaluation is indeed nifty. It lets Prolog have all the expressive and reflective power of Lisp's homoiconicity without having to worry about quoting and quasi-quoting. If one wants functional notation and implicit evaluation, you can just load a module (e.g., [library(func)](http://www.swi-prolog.org/pack/list?p=func)), write your own functional syntax using term_expansion, or use an implementation like Ciao that has [it's own standard functional syntax](http://ciao-lang.org/docs/ciao/fsyntax_doc.html). One might reasonably suggest some Prolog implementations are "broken" for any number of reasons, but /u/codercoder's silly gripe isn't one of them.
These two predicates does what you want: `append3DL(A-B, B-C, C-D, A-D).` `value(coin(Type,V), Number, Amount):- coin(Type,V), Amount is (V*Number).`` But to learn the prolog language and the declarative thinking you need to do some reading for yourself, there is loads of resources on the internet. 
Was the snarky remark geared towards me or towards my professor? Either way you're probably right. There's only a select few in the class of 40 that can come up with solutions while everyone else sits there a little numb. My first thought with this question was to somehow make predicates that could just extract value from the database. But now I realize I should just calculate it, which would be a ton easier. Thank you for that! Can I ask why you checked if Amount, Value, Number were integers? Is it just a check? Is it necessary for the core of the code?
I appreciate the answers, but how did you approach the append3DL? I'm a little confused on what difference lists are. A list with an end pointer right? What resource do you usually use? And why do you do Coins is V * Number, Coins = Amount? Couldn't you just do... Amount is V * Number?
~~Cool idea, keeping the end of list accessible. Difference-lists do look very interesting. Never seen them before ;)~~ Just realized that this concept is used when working with [Definite Clause Grammars](https://en.wikibooks.org/wiki/Prolog/Difference_Lists) in prolog. Can't really remember if my professor introduced us to difference lists before showing us DCGs ;)
It makes me sad that so many posts in this subreddit are homework posts.
Why? At least that means people are learning Prolog :) Who knows, if they find a supportive, encouraging community waiting for them when they have questions, maybe it will inspire them to stick with the language and then eventually there might be more users, and more posts here of a different nature.
Version 7.2.3. I even deleted and downloaded the most recent version, the problem doesn't go away.
Well, I'd prefer to see exciting new developments in the Prolog world. On the other hand, I have just learned about difference lists.
fwiw, I don't see the basis or motive for the snark or why /u/blurryroots thought their remark was relevant or helpful at all. Your questions seem well posed and totally reasonable to me. ime, /u/blurryroots' solution is over-engineered, given the problem posed. However, we can appreciate that they were striving for good declarative properties. I think the following predicate would be entirely sufficient: value(Coin, Number, Amount) :- Coin = coin(_, Value), Coin, Amount is Value * Number. Notice that this is very close to your first attempt. You only forgot (or didn't know) how to access the `Value` variable that is contained in the compound term `coin(N,V)` bound to the `Coin` variable. This is a very common technique in prolog: we use compound terms to represent data structures, and then we can either: 1. hide the complex data when we don't need it, by passing around variables bound to that structure 2. or, access fields in the structure, by unifying the variable with matching compound term
Thank you for your input! I actually didn't know that you could do that. When I saw that solution in one of the other comments I realized how simple it was. 
I'm having a bit of trouble following the `evaluate/3` problem, so I'll pass on that for now. But I will note that the phrasing of the assignment and the example don't seem to match up, since `VarValue = x:3` is not "a list of values for each variable". Maybe I can return to this tomorrow when I have more energy. I do believe I can help with your `concatALL/2` questions. Your attempt reveals a couple of misunderstandings: 1. You seem to misunderstand how `append/3` works. 2. You seem to be a bit confused about how the `[H|T]` syntax works on lists. 3. As a result of 2, you seem to misunderstand how to achieve recursive definitions that iterate over the items of a list. I'll offer some tips to clarify these aspects. `append/3` relates the front and back of a list to the list in its entirety. To make this meaning perspicuous, we can use the following variable names: `append(Front, Back, List)`. Suppose now we bind the variables in a way that reflects your use of `append/3`: - `Front = [E]` - `Back = L` - `List = L` This will describe a list whose `Front` is the single element `E`, whose `Back` is `L` which is the same as the entire `List`. What you have done is formed a *cyclic list*, a list that repeats infinitely. You can see how this pans out by posing the following query, and letting it return several answers on backtracking: ?- append([a], L, L), length(Front, _), append(Front, _, L). L = [a|L], Front = [] ; L = [a|L], Front = [a] ; L = [a|L], Front = [a, a] ; L = [a|L], Front = [a, a, a] ; L = [a|L], Front = [a, a, a, a] ; L = [a|L], Front = [a, a, a, a, a] ; What's going on here? - `append([a], L, L)` creates a cyclical list, L = [a|L]. The head of `L` is the atom `a` and the tail of `L` is `L`. But `L` is a list whose head is `a` and whose tail is `L`, so its tail is again a list whose head is `a` and whose tail is `L`, etc... - `length(Front, _)` will create a list of free variables of unspecified length. Each time we backtrack to get another answer, the length of the list will increase by one. - `append(Front, _, L)` will bind `Front` to the front of the list `L`. As the length of `Front` increases on backtracking to get new answers from `length/2`, we will get longer and longer front segments of `L`. The point being, if we want to use append create a new list by putting a `Front` and `Back` together, we have to supply a fresh, unbound variable as the `List` argument. The other issue here is, since `NestedLists` is meant to be a list of nested lists and `C` is meant to be a *flattened list*, i.e., a list of single elements with no nested lists, we don't want to wrap the elements from `NestedLists` in a new list, or else we'll end up with a list of lists. I.e., we want to append the front list to the back list, not a list containing the front list to the back list: ?- E = [1,2,3], append([E], [4,5,6], C). E = [1, 2, 3], C = [[1, 2, 3], 4, 5, 6]. %% notice that the first three elements are enclosed in a list. ?- E = [1,2,3], append(E, [4,5,6], C). %% here we just pass the list `E`, not a list containing `E` E = [1, 2, 3], C = [1, 2, 3, 4, 5, 6]. Lastly, your recursive call to `concatALL/2`, `concatALL([T|_], L)`, would wrap up the tail in a new list, and cons that on to an unbound variable. You can quickly see how this won't help us iterate over the elements of a list by just seeing what happens when we take a list and cons it onto an anonymous variable: ?- L = [1,2,3], X = [L|_]. L = [1, 2, 3], X = [[1, 2, 3]|_G3180765]. This wont' be much help. I have to get to bed now, but here is one solution to the problem. Hopefully studying it and comparing it to your attempt will be instructive. I'll answer any questions you might pose if I have time. concatALL([], []). concatALL([List|Lists], Concated) :- is_list(List), concatALL(List, ConcatedList), append(ConcatedList, Lists, NewLists), concatALL(NewLists, Concated). concatALL([Element|Lists], [Element|Concated]) :- \+ is_list(Element), concatALL(Lists, Concated). Happy logic programming! ;)
Weird! Bummer. I don't ever use the SWI-Prolog GUI front end, but that sounds like a real problem nonetheless. If you haven't already, you might want to file a bug report: https://github.com/SWI-Prolog/issues/issues Hopefully you can still use swipl via the command line in the meantime.
I was following through your solution and realized where I went wrong (though I feel like I'm slowly closing in). Through your walkthrough of my code I couldn't fully derive your solution though. \+ means not provable? (through google). Is this the same thing as using not(is_list(Element))?
A closely related, if not identical issue, was recently discussed on the SWI mailing list, please see [the forum thread](http://www.swi-prolog.org/forum?place=msg%2Fswi-prolog%2F1A3uBpZPKko%2Fim4EFctpCgAJ) for more information. Does the workaround that is explained in this post work for you?
Thanks for commenting! Indeed it seems like I have the same problem. Deleting the $HOME/Library/Preferences/org.swi-prolog.swipl-win.plist* file did not help. Also, just like the OP in the forum, I have already deleted and reinstalled SWI-Prolog, but to no avail. I'm confused by the second suggestion, deleting the dylib files. I don't seem to find those. The only thing I find when looking for them with Spotlight are some logfiles about Tapatalk, which is totally unrelated (as far as I know). I highly appreciate any further suggestions. (Also, the names of the people in the forum suggest they are Dutch or Flemish, I am a native Dutch speaker as well so if it's easier to explain a solution in Dutch, by all means, go ahead.) 
The [top voted prolog question](https://stackoverflow.com/questions/130097/real-world-prolog-usage) at StackOverflow has a list
After digging a bit it seems that Clarissa prog uses this http://sourceforge.net/projects/regulus/ (via http://www.mitpressjournals.org/doi/pdf/10.1162/coli.2007.33.2.271 )
These predicates should do what you want, start the program by typing "start.", and then enter integers followed by a dot and [ENTER]. start:- ask([]). ask(Acc) :- write('Enter a integer: '), read(Int), nl, action(Acc,Int). action(Acc, Int):- Int \= 0, integer(Int), append(Acc, [Int], NewAcc), ask(NewAcc). action(Acc, 0):- write('You entered a 0, Here is the total of integers you entered:'), nl, write(Acc). action(Acc, Int):- \+ integer(Int), write('Only integers is accepted'), nl, nl, ask(Acc). **Example output:** [debug] ?- start. Enter a integer: 5. Enter a integer: 4. Enter a integer: 3. Enter a integer: 7. Enter a integer: 9. Enter a integer: 1. Enter a integer: 0. You entered a 0, Here is the total of integers you entered: [5,4,3,7,9,1] true **EDIT** I've only test-runned this code in SWI-prolog 6.6.4, but probably works in other prolog implementations aswell.
At a quick glance, it seems that your sub/4 function is ordered oddly.
dewd... This is Prolog, the **programming language**.
Hi. Here are some questions and remarks to serve as tips: - To help us read your code, precede each line of code in your post with 4 lines, and it will display more readably and preserve the proper formatting. - If `isIntersection(_,[],[]).` means that the intersection of any list (`_`) and an empty list is an empty list, what is `isIntersection([],,).` supposed to mean? - In the second clause, you destructure the list in the second argument to `[Y|Ys]`, but then you never do anything with `Y` or `Ys` alone, you only ever use them together, so why are you bothering to match on the head and the tail in the first place? Why not just use a single variable bound to the list as a whole? - Why are you Adding the head `X` to the tail `Z` in both the head of the rule and the body of the rule? Usually when we use recursion to build a list (as we will be doing in the third argument here), we either build the list in the head the of the rule or in the recursive call (when we are using an accumulator argument). Revisit the [definition of `append/3`](http://stackoverflow.com/a/11551001/1187277) and notice the pattern used to construct the appended lists in the third argument. I hope these prompts help you work to an understanding of your code! Let me know if you have any other questions. :)
Sory about the destructuring I really don't know what I'm doing. I think confused by the name scoping. I'm trying to say if the head of X is a member of Y appending it to Z and if its not destructure the list and don't append it. Trouble is I'm not strong is this language at all. Edit: (I think I have it but I'm curious what the _G7841 things are. Our book (Modern programming languages) doesn't really go over it. code: isIntersection(_,[],[]). isIntersection([],_,_). isIntersection([X|Xs],Y,[X|Z]):- isMember(X,Y),isIntersection(Xs,Y,Z). isIntersection([X|Xs],Y,Z):- not(isMember(X,Y)),isIntersection(Xs,Y,Z).
There you go! Nice work :) That should work for *almost* all the needed cases. However, it fails for this query: ?- isIntersection([], [1,2,3], Y). false. `Y` should be bound to `[]` in this case, right? I think this relates to my second question: what is `isIntersection([],,).` supposed to mean? That *is* valid Prolog syntax, but it is a funny thing to see in this context. Facts and rules are usually best thought of as stipulating relations between their arguments. So if `isIntersection` is here naming a relation between its arguments, what are the arguments? You can get a clearer sense of this by posing the following query on the Prolog top level: ?- ([],,) = (A,B). A = [], B = (','). The fact `isIntersection([],,).` is stipulating a relation between the empty list, `[]` and the comma atom, `,`. What does this have to do with intersections? My guess is you mean that fact to read `isIntersection([],_,[]).`, which complements the first fact in such a way that the two taken together mean "the intersection of an empty list and any other list is just an empty list". **Edit**: I just realized that, the second clause was probably written `isIntersection([],_,_)` but because you are not indenting your code or enclosing it in backticks (\`), reddit's markdown renderer is reading the surrounding underscores as instructions to underscore the comma. For this reason, please be sure to format your code examples correctly when posting for help :) In any case, `isIntersection([],_,_)` is an incorrect rule in this case, since it says that the intersection of the empty list and any list is some anonymous variable. That means, with your code, the following query succeeds: ?- isIntersection([], [1,2,3,4], apples). true. Things like `_G7841` are the interpreter's representation of anonymous variables. When when us an underscore, `_`, to represent an a variable whose value we don't care about, the interpreter still needs to keep track of the variables to differentiate them. E.g., ?- A = a, B = _, C = _, D = C, write(('A'=A,'B'=B,'C'=C,'D'=D)). A=a,B=_G1770,C=_G1773,D=_G1773 A = a, C = D. Notice that `B` and `C` are different anonymous variables, but `C` and `D` are both bound to the same anonymous (uninstantiated) variable. No reason to be sorry. My questions were only meant to help you figure out the code, not to chastise you. There is lots to learn when approaching a new language (let alone a whole new programming paradigm!) and no one should fault you for making natural mistakes as you try to figure out how things work.
Nice explanation and walk through! I have a question about the comments though. Doesn't `L0 = [A|L1]` actually bind `L0` to a list with the head as `A` and the tail as the value of the *next* recursive step, rather than the *previous* step? Now that the standard, homework solution is out of the bag, I'll throw out an answer to show the support of standard SWI-Prolog library predicates: exclude_less(L, N, Remnants) :- exclude(&gt;=(N), L, Remnants). I.e., "Remnants is what remains when we exclude the elements of L that N is greater than or equal to".
I got it to work but thanks. The problem I was having is that the recursion kept returning the previous calls and giving me back the original list. Example wihth list [5, 4, 3, 2, 1]: [5, 4, 3, 2, 1] [4, 3, 2, 1] [3, 2, 1] [2, 1] [1] [1, 2] [1, 2, 3] ... [1, 2, 3, 4, 5] 
I got it to work, your code looks neat althought my scenario was a bit different. Imagine a bunch of classes that inherit each other. I had to return them into a list in the order that they extend each other. I ended up find my problem which was that I need an extra variable that will equate the final list at the end of my recursion and return it back up. But I will keep in mind your advice for thinking declaritively for my exam :)
 :- findall(T, trip(rome, dublin), Ts) Ts would then be a list of all trips. Here is a version of trip that will find the two step trips: trip2(C1, C3, [C1, C2, C3]) :- flight(C1, C2, _, _, _, _), flight(C2, C3, _, _, _, _). Since this is clearly an assignment for a class I will leave it up to you to find the 1 step trips and introduce recursion to trip2.
Thanks for the reply. So I have this working finding the flights one by one. trip(X, Y, [X, T, Y]) :- flight(X, Y, _, _, _, _), flight(Y, T, _, _, _, _). I also have it working for finding all the flights using findall all_trip(X, Y, T) :- findall(T, (flight(X, Y, _, _, _, _), flight(Y, T, _, _, _, _)), T). I'm wondering though, how do I format my findall so the result comes in like: T=[[rome,london,dublin], [rome,paris,dublin]] instead of T = [newyork, cork, rome, chicago, amsterdam, london, paris, berlin, sao_paulo]. 
I'd say first come up with a recursive solution in a language you're more familiar with. Then you can write that solution in prolog. Then you're not trying to solve the problem at the same time as dealing with prolog syntax. 
A quick note on terminology: `t(MinDate, MaxDate)` isn't a *predicate* unless you define facts and rules determining when `?- t(Min,Max)` is true. Until then, it is just a compound term. Define a rule that defines the relation between three compound terms of the form `t(MinX,MaxX)` such that one is the time interval common to the first two, (if such exists). common_freetime( t(MinA,MaxA), t(MinB,MaxB), t(MinC,MaxC) ) :- .... % Rule body here. .... % t(MinC,MaxC) will be the common interval Then define a rule that takes two lists of such terms and maps the predicate `common_freetime/3` over paired elements in them them to generate the third list: % don't forget your base condition! game_times([A|ATimes], [B|BTimes], [G|GameTimes]) :- common_freetime(A, B, G), ... % rest of rule 
If you would like help, please make a start or show the the code you have started working on, or at least write out an explanation of your thinking process and where you are stuck. If you do not bother to show and share your work so far, it is unlikely anyone will bother to help you, and I will then moderate this post to remove clutter.
Hey, I don't recall what version I'm running, I'll check when I get home, but the problem was with the algorithm. The solution is actually A / B #= X #\/ B / A #= X, with that fix I got it work. The division and subtraction could happen either way. I didn't understand the rules of kenken correctly the first time around.
Just add these 2 rules: find_sched(Sched):- findall(X, (course(X), eligible(X), \+passed(X)), Sched). eligible(X):- passed(Z), prereq(Z,X). Then just compile the pogram and run it with: find_sched(S). Or you can ignore the find_sched predicate and just run the query directly with: findall(X, (course(X), eligible(X), \+passed(X)), Sched). This code is really straightforward once you learn prologs mindset, but basicly: the findall-query will generate a list of all courses that is eligible and you have **not** passed. the eligible-predicate is just a rule that takes a course-name as input and then checks wheter you have passed the pre-req for that course, if you have it will succeed and the predicate is "true" , if you have not passed the pre-req it will be "false".
I would use clpfd. :- use_module(library(clpfd)). constraints(Values):- Values =[A2,A3,B1,B2,B3,B4,C2,C3], all_different(Values), Values ins 1..8, %Vertical abs(A2 - A3) #\=1, abs(B1 - B2) #\=1, abs(B2 - B3) #\=1, abs(B3 - B4) #\=1, abs(C2 - C3) #\=1, %horizontal abs(A2-B2) #\=1, abs(B2-C2) #\=1, abs(A3 -B3) #\=1, abs(B3 -C3) #\=1, %diagnoal abs(A2- B1) #\=1, abs(A2- B3) #\=1, abs(A3- B2) #\=1, abs(A3- B4) #\=1, abs(B1- C2) #\=1, abs(B2- C3) #\=1, abs(B3- C2) #\=1, abs(B4- C3) #\=1.
Thanks for this suggested alternative. I don't know much about clpfd, but I think I'm able to comprehend it.
Check out the GNU Prolog [mailing lists](http://gprolog.org/#maillist). The lead developer of GNU Prolog is extremely responsive and, in my experience, very willing to answer interesting questions about GNU Prolog internals. Make sure you do your homework though: The WAM book is definitely a good start, and trying out `pl2wam` on several examples will also help you to ask good questions.
Thanks for the reply! Coincidentally, that mailing list was my next stop after I asked here. Daniel Diaz himself responded. Turns out there isn't a specification in the sense I was looking for, but he pointed me towards some relevant parts of the source code. Very friendly and informative!
Great! Good luck with your project, it sounds very interesting. Note also that nowadays many Prolog systems use different abstract machines: SWI uses the ZIP, B-Prolog uses the TOAM etc. So, this may also be worth looking into. Some perspective: As your graduation project in university, you can try to improve tail calls in the SWI-Prolog abstract machine.
reminds me superficially of "Dedalus: Datalog in Time and Space" db.cs.berkeley.edu/papers/datalog2011-dedalus.pdf . Is there an implementation to play with. At the moment I play with CHRrp: CHR extended with rule priorities https://dtai.cs.kuleuven.be/CHR/download.shtml . Oversimplified a prolog which returns always constraints.
I show you one solution using CLP(B) constraints, which works in SICStus Prolog and SWI: :- use_module(library(clpb)). suspects(Ps) :- Ps = [P1,P2,P3], % one thief sat(card([1],Ps)), % the thief lied sat(P1 =&lt; ~P2), sat(P2 =&lt; ~P2), sat(P3 =&lt; ~ ~P3), % IT: innocent and truth teller sat(IT1 =:= ~P1*P2), sat(IT2 =:= ~P2*P2), sat(IT3 =:= ~P3* ~P3), % at least one innocent truth teller sat(card([1,2,3],[IT1,IT2,IT3])). From this, I hope you can construct - if necessary - a version that does not use CLP(B) constraints. One nice thing about a CLP(B) version is that it is quite short and clear. Also, it requires no search if there is only one solution: ?- suspects(Ps). Ps = [1, 0, 0]. 
This sounds like a mix between sudoko and the N-Queens problem. I'd take the suggestion from the first link and look at understanding how Constraints work with Prolog. Then maybe see if you can get an implementation of n-Queens to work, and modify it to fit your given "range board". GL!
The basic reason is because prolog isn't an algebra system. It can solve variables in terms, but it can't solve variables if there is any evaluation of arithmetic. In order for prolog to solve a goal with variables in it, it needs to match the variables with actual terms (unification). This is done purely syntactically, and 6 is a number. It doesn't have the form X+Y, so prolog can't fill in values for X and Y, and fails unification. This is going to happen any time you have arithmetic. 
What you say is correct for =/2 not for =:=/2. =:=/2 evaluates the arguments and does arithmetic comparison. | ?- 3+3 =:= 6. yes However, =:= requires ground arithmetic expressions and cannot deal with variables. See my other answer for a solution to this (either using co-routines or CLP). 
Hello. Your code is so clean and works (tried it in SWISH), at this stage I probably should be ashamed to even ask follow up questions. But I have to because I can't make it to work in Visual Prolog. Specifically, VP doesn't seem to like the "\==" part. And I lack the knowledge to make it work. Could you explain what "\==" does (is it just a "not identical" predicate?), how is it different from "\=" so i have some keywords to search VP documentation for? I've read http://www.swi-prolog.org/pldoc/man?section=standardorder and have been reading http://wiki.visual-prolog.com/index.php?title=Language_Reference/Built-in_entities for the last hour but to no avail. Also I guess I should ask what does the number after predicate means (example from swi documentation "==**/2**". Is it the number of arguments?)
Yes, the number after the predicate is the number of arguments.
&gt; I don't understand prolog at all What are the rules for deciding if something is next to each other? Write it down if it helps. What do these rules look like as a line in prolog? What is the base "check" for this type of thing? How can recursion be used on this base "check"? These types of questions should help, good luck.
Please, just write it down in the exact same way you are telling it to us: A binary tree is **either**: 1. a leaf 2. **or**, **if** both `L` and `R` are binary trees, **then** the term `node(L, R)` is *also* a binary tree. Next, translate this to Prolog: When you see "or" in an informal description, you translate this to a disjunction in Prolog, most frequently using two separate clauses. **if** `Body` **then** `Head` is written in Prolog as `Head :- Body.`, because `:-` looks like a small arrow, `&lt;==`. That's it: One fact and one rule. That's two clauses in total to solve this task.
Thank you very much, this helped me a lot. Thats's my solution: tree(leaf(X)). tree(node(X,Y)) :- tree(X), tree(Y). It works like intended, but what if someone asks for tree(leaf(leaf(1))? Can I limit leaf(X) to just numerical values? 
Please think declaratively: You want to express that the first case holds only **if** `X` is a number. So, you state the constraint, using the by now well known **If** `Body` **then** `Head` notation: tree(leaf(X)) :- number(X). `number/1` is a built-in predicate. Note that, unfortunately, it is not a monotonic predicate, so you lose the ability to *generate* solutions if you use such built-ins. Use them with care, or use *constraints* for a truly declarative solution that works in all directions. For example, using CLP(FD) constraints for *integers*: tree(leaf(X)) :- X ins inf..sup.
A good Prolog solution will work correctly *in all directions*. In particular, always keep in mind *the most general case*, which means the case where all arguments are *variables*. How does your predicate handle the most general case? Your original program works nicely also when you query for example: ?- tree(T). **But**, if you use `number/1`, then it will not work as nicely. This is because `number/1` is inherently *not monotonic*, and therefore not a pure logical relation. Consider for example: ?- number(X). false. Decalaratively, this answer means that there is *no solution whatsoever*. But, counter-intuitively, by adding further constraints, we suddenly obtain solutions: ?- X = 3, number(X). true. Clearly, this is quite unfortunate and problematic behaviour. The clean solution would be to throw **instantiation errors** if the arguments are not yet sufficiently instantiated to say anything definite about them. **Constraints** elegantly solve this issue by *delaying* conditions that cannot yet be decided. `label/1` can only be used on variables whose domains are *finite*, so you *cannot* use `label/1` in this case. But even without `label/1`, you at least obtain answers that are always correct, if you just use CLP(FD) constraints to constrain the argument to integers. This is because you cannot trick CLP(FD) constraints into yielding wrong answers: ?- X in inf..sup. X in inf..sup. Notice that we get a delayed goal as answer, but **not** `false/0`, as we got with `number/1` in this case. This also works exactly as expected if we now plug in concrete integers: ?- X = 3, X in inf..sup. X = 3. Works as expected, also if we just swap the goals: ?- X in inf..sup, X = 3. X = 3. Thus, constraints are a pure solution to such issues, and you should use constraints instead of resorting to lower-level predicates if you want to reason soundly about numbers. In particular, use CLP(FD) constraints to declaratively describe concepts where **integers** are involved.
This should be a good [chapter](http://www.swi-prolog.org/pldoc/man?section=chr ) to read up on, there are some examples later down. It's possible in specific libraries of prolog, but not standard prolog.
Yes, CLP(FD) constraints are in the core of SICStus, SWI and YAP and many other Prolog systems. For SWI-Prolog, I recommend you put `:- use_module(library(clpfd)).` in your `~/.swiplrc`, so that you do not need to explicitly import the library for simple programs.
The syntax for destructuring a list into its head and tail is `[H|T]`. You are missing the square brackets in the head of your second clause for `test/2`. 
Without seeing the lecture notes, it is impossible for us to know what the author might have meant (btw, there are surely people here and on Stack Overflow who speak languages other than english ;)). However, my guess would be that they were talking about logical equivalence in Horn Clause logic, rather than an operational equivalence in any actual Prolog system. It seems relatively common for instructional material to first discuss an idealized version of pure logic programming with Horn clauses before descending into the operational details of Prolog. I could be mistaken however, and if there is such a Prolog system that allows multiple terms in the heads of a rule, I'd be happy to know of it. I think, though, if you did want to be able to write rules with multiple terms in a head, this would actually be pretty easy to achieve using `term_expansion/2` (of course, given a Prolog implementation that supports it).
Thank you so much for your reply. I very new to prolog and I am still trying to grasp the concepts so apologies for the poorly formatted question. If you don't mind, could you please explain how this bit works? test([], []). test([X|T], [Combination|C]) :- reference(X, Combination), test(T, C). It works perfectly and does exactly what I wanted it to do so thank you once again for the help :)
What it does is largely dependent upon what `reference/2` does :P But that I don't know yet! But I think you must be asking about this general patter: p([], []). p([X|Xs], [Y|Ys]) :- q(X, Y), p(Xs, Ys). Declaratively, `p(XXs, YYs)` is true if `q(X, Y)` is true of each of the coordinated pairs of `X` and `Y` in the lists `XXs` and `YYs`. Procedurally, when we call `p/2` like this, `p(List, FreeVar)`, where `List` is bound to a list and `FreeVar` is a free variable, this pattern will 1. *Initialization*: Destructure `List` into its head `X` and tail `Xs` by unifying it with `[X|Xs]`, and unifying `FreeVar` with the partial list `[Y|Ys]`, where both `Y` and `Ys` are free variable, the first of which can be bound with anything and the second of which must be bound to a list. 2. *Rule body*: Call `q(X,Y)`, binding `Y` according to the definition of `q/2`. 3. *Recursion*: call `p(Xs, Ys)` on the remaining elements in the tail `Xs` and the free variable `Ys`. 4. *Base condition*: Keep recursing through all the elements of `List` until reaching the empty list, `[]`, at which point the free variable in the second argument will also be unified with `[]`, completing the construction of the new list. To get a feel for how this pattern works, try loading the following little program increment([], []). increment([X|Xs], [Y|Ys]) :- succ(X, Y), increment(Xs, Ys). Then turn on tracing by entering the following query at the top level: ?- trace. Then query `increment/2` thus: ?- increment([1,2,3,4,5], A). And step through the trace, noticing what happens at each step. 
Ah yes! Sorry, forgot to add that bit. The reference part of code does exactly what you predicted in the previous comment: reference(1, [1,2,3]). and so on... It simply grabs the value of Combination which matches X. Once, again. Thank you for your help!
Writing a parser *for* Prolog is a really great idea. I recommend you obtain a copy of the Prolog ISO standard to get all the information about the precise syntax. A nationalized version of the ISO standard costs only about 60 USD. See the [ISO Prolog page](https://www.complang.tuwien.ac.at/ulrich/iso-prolog/) by Ulrich Neumerkel for more information. Also check out the sources of GNU Prolog, which contains an excellent parser according to the [Conformity Assessment](https://www.complang.tuwien.ac.at/ulrich/iso-prolog/conformity_assessment).
Function-call-style syntax needs there to be no space between the name and the opening bracket. So, `1 + 2` and `+(1, 2)` are equivalent but `+ (1, 2)` isn't. In lispy syntax the last one corresponds to `(+ (, 1 2))` and assumes an `+/1` and `op(+, fx)`. This presence or absence of an immediate `(` is also how you tell `./2` from a clause terminator. Any unary operators are ones that follow a `(` or an infix op (and don't have a `(` after, of course).
I've usually seen this done with constraints. Have you used the constraints library before?
no... tell me more. :P
CLP is probably the easiest way to solve this, but if you don't want to use that there are other options. One way is to make a graph out of the chess board. So each square is connected to what a queen could capture at that square. Then the 8 Queens problem is reduced to finding an independent set of size 8. (you could also reframe this as finding a clique) Or, you could make a capturing relation that succeeds if one queen can capture another. Then the problem is finding 8 Queens such that +/ capture(Qi, Qj) 
character_counter([a,b,c,c],List), forall(member(count(A,B),List),format("Total for ~w is: ~w\n",[A,B])).
The best way is to think declaratively: Relate a list of elements to the list of those elements that are even. We start with the simplest case: `[]`. This denotes the empty list, and its even elements are again `[]`. So we have: list_evens([], []). The second case describes a list with at least one element. In that case, we have to distinguish: Is the element even or not? Such a distinction is described by two different clauses that describe the cases. We use CLP(FD) constraints so that the program can be used in all directions. The first case: list_evens([Odd|Ls0], Ls) :- Odd mod 2 #\= 0, list_evens(Ls0, Ls). Note that this *tail recursive* clause also relates the other elements according to our definitions. We read it declaratively: **If** `Odd` is odd (ie., `Odd mod 2 #\= 0`) **and** `list_evens(Ls0, Ls)` holds, **then** `list_evens([Odd|Ls0], Ls)` *also* holds. That is, `Body ==&gt; Head`, written in Prolog as `Head :- Body`. The final case is: list_evens([Even|Ls0], [Even|Ls]) :- Even mod 2 #= 0, list_evens(Ls0, Ls). In total, we have the following program: :- use_module(library(clpfd)). list_evens([], []). list_evens([Odd|Ls0], Ls) :- Odd mod 2 #\= 0, list_evens(Ls0, Ls). list_evens([Even|Ls0], [Even|Ls]) :- Even mod 2 #= 0, list_evens(Ls0, Ls). It works in all directions, for example: ?- list_evens([1,2,3], Es). Es = [2] ; false. And also in the most general case: ?- list_evens(Ls, Es). Es = Ls, Ls = [] ; Es = [], Ls = [_G745], _G745 mod 2#=1 ; Es = [], Ls = [_G799, _G802], _G799 mod 2#=1, _G802 mod 2#=1 ; etc. Note though that tail recursion does not help a lot here to improve efficiency, since the predicate is nondeterministic at least in the most general case. There are ways to make it deterministic in more specific cases, using powerful meta-predicates. However, as a first example, I think the above is a good and general definition that shows two tail-recursive clauses.
Thank you. In the end, I defined a new predicate which essentially is the inverse of the other predicate, which prints out messages and then fails. Like along these lines: my_predicate(a, b) :- is_true(thingy). my\_predicate(_, _) :- \\+is_true(thingy), print out error messages, false. Might you also know why assertions aren't working for me outside of the terminal prompt? https://www.reddit.com/r/prolog/comments/3w9ez8/define_predicates_within_another_predicate/
Your `definer(a). definer(b).` are just two *facts*, i.e., simply additional clauses of the predicate `definer/1`. Instead, you want to run them as *queries*, which you can do with the directive `:- initialization((definer(a),definer(b)).`. This will *invoke* these goals after the file is loaded, and hence run the first clause that is meant to actually execute. This works completely portably across ISO Prolog systems and is a nice way to assert facts dynamically at the time the predicate is loaded. Another quite beautiful way is to use term expansion. The details differ across implementations though.
Great, this is a good way to do it. I answered the question regarding dynamic generation of facts in the other thread. In short, use the `:- initialization(Goal).` directive to execute `Goal` after the file is loaded.
For me when writing search-tree's for more complicated queries I get alot of help by using the *trace*-command. The trace command lets you trace the execution of a prolog-query. Since writing search-trees in prolog is basicly to visualize the SLD-resolution in a tree, you get much of the information needed just by doing a trace. If you need help with a specific query you can post the code and maybe we can help you.
Where would this part fit in? Sorry for the newbie questions :P
It's just a query. First count the characters in the list and output a list of counts, then for all members of that list print the result.
wow, what a useless reply! Thanks man! (:
Well, I didn't want to give you the solution out right since you asked for a clue. You can check this out for about 5 different solutions. https://github.com/segmond/PrologThingz/blob/master/PPAI/nqueens.pl Here is the first one. % eight-queens problem % solution(Pos) solution([]). solution([X/Y | Others]):- solution(Others), member(Y,[1,2,3,4,5,6,7,8]), noattack(X/Y,Others). noattack(_/_,[]). noattack(X/Y,[X1/Y1 | Others]):- Y =\= Y1, Y1 - Y =\= X1 - X, Y1 - Y =\= X - X1, noattack(X/Y, Others). template([1/Y1,2/Y2,3/Y3,4/Y4,5/Y5,6/Y6,7/Y7,8/Y8]). test_solution(Sol):- template(Sol), solution(Sol). 
your clue was useless because it assumed that I didn't know how to think about the problem in logical terms. If you had taken a bit more time to check out my OP, you would have seen that I already have a sample script (not working as intended, unfortunately), which clearly demonstrates that I know how to put the problem into logical terms. Aynway, thanks for posting your solution. I can't analyze it in depth right now, but at first glance I can see that it only produces 100 solutions, when the problem is known to have 120. Maybe there's something you missed. In any event, it looks very elegant.
Thanks, Will check it out.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Using CLP(FD) to solve factorial and Fibonacci problems reversely \[X-post from \/r\/prolog\/\]](https://np.reddit.com/r/programming/comments/3zdygu/using_clpfd_to_solve_factorial_and_fibonacci/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I'm not sure what exactly you're asking. Is it not just: client(X,Time), property(X,Properties).
I think I see what you want. Here's what I would do: Getting the client times is just client(ID, Time), where the list of available client times is stored in Time. You do the exact same for property times, except, since you have a list of ids, you need to do it element by element. Write a recursive function to do that for you. See [this link](https://stackoverflow.com/questions/30800407/prolog-iterating-through-list) for help with recursion if you've never worked with it before. You can also try the maplist function to get the property times, which I think might return a list of lists. You can then flatten the list if you want all times in a single list.
Could I use something like date_time_value for the weekday, hour and minute for that? If so how?
The solution is quite simple. Recall that Prolog is all about describing **relations** between entities. So, in your case, you are describing a relation between a parse tree and a list. Just write it down: parse(=(X,Y+Z) --&gt; [X,=,Y,+,Z]. Or equivalently, just using infix syntax: parse(X = Y+Z) --&gt; [X,=,Y,+,Z]. Note that the argument of the DCG is already a nice parse tree: A Prolog term that completely describes the assignment. You can of course also use a term of the form `assing/3`instead, but isn't it more readable like that? Try an example: ?- phrase(parse(X), [a,=,b,+,c]). X = (a=b+c). Note that this also works in the other direction, so try to find a better name! One that makes sense in all directions, not just for parsing, but also for **generating** programs ;-)
Thanks for all the help, I was able to write a solution for my problem.
The truth is that traces are **not** a good way to reason about Prolog programs. Instead, you should reason **declaratively** about your code. Do it like this: Take a predicate head, and read it as: "This holds **if** the following holds ..." and then read the goals of the first clause. Then say, "**or** if the following holds..." and then read the goals of the next clause etc. This way, you have captured what the program describes. If you want to see the exact steps of a proof, you should write a meta-inteprerter that builds a **proof tree** instead of a trace. You then read a proof tree like `true =&gt; A =&gt; B =&gt; C` this: "**true** holds, **therefore** `A` holds, **therefore** `B`holds ... etc., and eventually arrive at your original query.
If you use the `trace` command on a query regarding a predicate that depends on other predicates you will automaticly see the trace for the full query, including all predicates that are used. 
How did you manage to append it tho and make it display 3? I keep doing this for 2 months now and I can't seem to get it...
There are lots of reasons to get a deep understanding of Prolog and LP outside of employment concerns. But I'm sure there are also plenty of employers who *would* appreciate knowledge of declarative techniques, the LP paradigm, and constraint programming. In any case, why are you cautioning against deep study of Prolog in a subreddit dedicated to the language?
**tl;dr** Your problem space is huge and you're misusing `is/2`. Your code isn't looping indefinitely, it is just taking a very long time to run because the problem space it describes is *huge*. Given enough time, it *would* terminate (as there is no recursion in your code at all and it's not tasked with exploring an infinite problem space). If considering the code itself doesn't convince you it must be terminating, you can perform a little experiment to prove it. Change your first definition to sat(X) :- member(X,[0,1]). This will drastically shrink the problem space (without altering anything in the structure of the computation) and then querying `solve/2` will fail almost immediately. Let's run a trace on the `solve/2` query, to see what is going on with your program. In the normal top level, you can turn on the tracer, just by querying ?- trace. (You turn it off by querying `notrace`.) In swish, you trace a query by entering the query into the field, then, from the drop down menus below the input field, selecting **Solutions &gt; Debug (trace)**. Step into each call, and you'll see a trace that looks like this: Call: (8) solve(_G152, _G153, _G154, _G155) ? Call: (9) sat(_G302) ? Call: (10) lists:member(_G302, [0, 1, 2, 3, 4, 5, 6|...]) ? Exit: (10) lists:member(0, [0, 1, 2, 3, 4, 5, 6|...]) ? Exit: (9) sat(0) ? Call: (9) sat(_G305) ? Call: (10) lists:member(_G305, [0, 1, 2, 3, 4, 5, 6|...]) ? Exit: (10) lists:member(0, [0, 1, 2, 3, 4, 5, 6|...]) ? Exit: (9) sat(0) ? Call: (9) sat(_G308) ? Call: (10) lists:member(_G308, [0, 1, 2, 3, 4, 5, 6|...]) ? Exit: (10) lists:member(0, [0, 1, 2, 3, 4, 5, 6|...]) ? Exit: (9) sat(0) ? Call: (9) sat(_G311) ? Call: (10) lists:member(_G311, [0, 1, 2, 3, 4, 5, 6|...]) ? Exit: (10) lists:member(0, [0, 1, 2, 3, 4, 5, 6|...]) ? ... What is going on here? Well, each time you call `sat/1`, it is unifying the free variable with the first successful solution to `member(X, [0,1,2,...])`, which is `0`! That means, you are first unifying all the the variables with 0. Once this fails, down at the arithmetic part, Prolog will then start retrying the unifications one by one. So it will next unify all the calls to `sat/1` with 0, except the last, which it will unify with `1`. When this fails, it will try to unify the last with `2`. Etc. It will keep doing this until it has tried every single one of the the 10^16 permutations. That's why it's taking so long. But then we should ask, given that a 4x4 grid of all zeros satisfies your constraint, why isn't Prolog finding any solutions along the way? If you keep tracing the execution past unification of all the calls to `sat/1`, you'll arrive at this: ... Call:0+0+0+0 is 0+0+0+0 Fail:0+0+0+0 is 0+0+0+0 ... If `is/2` were equivalent to the arithmetic `=`, then this goal would succeed. What this failure tells us is that you have misunderstood the intended meaning of `is/2` (of course, it could also be telling us of a mistake in the definition of `is/2`, if we knew that `is/2` was intended to be equivalent to the arithmetic `=`. But that's not the case here). Take a moment to consult [the swi-prolog documentation for `is/2`](http://www.swi-prolog.org/pldoc/doc_for?object=(is)/2). Notice the mode specification is `-Number is +Expr` That means the predicate is only well defined when the variable `Number` is left free and the variable `Expr` is bound. This is made explicit in the prose that follows in the documentation. `is/2` is only intended for obtaining the value of an arithmetic expression. To test the equality of two different (instantiated) expressions, you want [`=:=/2`](http://www.swi-prolog.org/pldoc/doc_for?object=(%3D%3A%3D)/2). If you replace `is/2` for `=:=/2` throughout, your program will quickly find the first solution ?- solve(A, B, C, D). A = B, B = C, C = D, D = [0, 0, 0, 0] ; But it will then take a very long time before it arrives at the next viable solution
For relations over integers, I recommend you use CLP(FD) constraints instead of low-level arithmetic. For example, if you simply replace `is/2` by `(#=)/2` and `member/2` by the CLP(FD) constraint `(in)/2`, you get: :- use_module(library(clpfd)). sat(X) :- X in 0..9. solve([A1,A2,A3,A4],[B1,B2,B3,B4],[C1,C2,C3,C4],[D1,D2,D3,D4]) :- maplist(sat, [A1,A2,A3,A4,B1,B2,B3,B4,C1,C2,C3,C4,D1,D2,D3,D4]), A1 + A2 + A3 + A4 #= B1 + B2 + B3 + B4, A1 + A2 + A3 + A4 #= C1 + C2 + C3 + C4, A1 + A2 + A3 + A4 #= D1 + D2 + D3 + D4, A1 + A2 + A3 + A4 #= A1 + B1 + C1 + D1, A1 + B1 + C1 + D1 #= A2 + B2 + C2 + D2, A1 + B1 + C1 + D1 #= A3 + B3 + C3 + D3, A1 + B1 + C1 + D1 #= A4 + B4 + C4 + D4, A1 + A2 + A3 + A4 #= A1 + B2 + C3 + D4, A1 + B2 + C3 + D4 #= A4 + B3 + C2 + D1. You can then use `label/1` to obtain concrete solutions. For example, the first two solutions are: ?- solve(As, Bs, Cs, Ds), maplist(label, [As,Bs,Cs,Ds]). As = Bs, Bs = Cs, Cs = Ds, Ds = [0, 0, 0, 0] ; As = [0, 0, 0, 1], Bs = [0, 1, 0, 0], Cs = [1, 0, 0, 0], Ds = [0, 0, 1, 0] .
/u/zmonx beat me to the punch! And he's much more knowledgable than I am any how :)
That's a very good analysis, and a very neat way to prove that the query actually terminates! Interestingly, the misconception here is the opposite of what I more frequently hear from students and also on the Internet: We often hear "this Prolog program is extremely slow", when in reality, users are in such cases often accidentally writing programs that **do not even terminate**. In this case, the program **does** in fact terminate. Also with CLP(FD) constraints, such declarative reasoning remains very easy: Simply run the program without actually calling `labeling/2`. If that terminates, then the program plus `labeling/2` will **also** terminate. Nice job, thank you for sharing!
BTW, one very nicely researched text about CLP(FD) was recently published by m00nlight: http://m00nlight.github.io/constraint%20logic%20programming/2016/01/01/using-clpfd-to-solve-factorial-and-fibonacci-problems-reversely/ I really like the consistent use of CLP(FD) constraints in these snippets. This also contains pointers and links to many good additional resources. Highly recommended to get a glimpse of what is on the horizon!
Very easy, using `findall/3`. First, I add two constraints to break a few symmetries among solutions: A1 #&lt; D4, A1 #&lt; D1 then I write a simple auxiliary predicate: num(L) :- solve(As,Bs,Cs,Ds), append([As,Bs,Cs,Ds], Vs), findall(., labeling([ff], Vs), Ls), length(Ls, L). and then I get: ?- time(num(N)). % 38,589,981,870 inferences, 7454.767 CPU in 7455.806 seconds (100% CPU, 5176551 Lips) N = 2002046. **Exercise 1**: What is now the actual number of solutions? Recall that we have removed symmetries in the hope to improve the running time. **Exercise 2**: Can you remove even more symmetries by posting additional constraints? **Exercise 3**: Are other labeling strategies more efficient in this case?
Please properly format your code and spend some energy to articulate and pose your question. You can consult the "formatting help" link at the bottom right of the edit textfield.
The crucial point, as I understand it, is similar to Searle's Chinese Room argument: For example, the stomach does not merely *simulate* that it digests, but it *actually* digests. In this view, no matter what any algorithm does, it cannot be regarded the same as the actual living entity that exists *in the real world*, even if in effect it behaves indistinguishably from the living entity.
Can you just represent the letters as integers, then have a simple predicate to map the higher integers to letters? E.g., translate(0,0). translate(1,1). translate(2,2). translate(3,3). translate(4,4). translate(5,5). translate(6,6). translate(7,7). translate(8,8). translate(9,9). translate(10,'A'). translate(11,'B'). translate(12,'C'). translate(13,'D'). translate(14,'E'). translate(15,'F').
Actually, an even simpler idea is to just use character codes as your basic elements for running the constraint solver, then convert these to and from character representations for displaying the answer and/or inputing possible solutions or whatever. You can do all the conversions back and forth with `char_code/2`. This works since character codes are just integers.
It would be fun to work out a package that would provide a text-centric interface to constraint solving tools. I'd be interested in collaborating on such a thing were it to get going. Here's a sketch in the direction of what I think you're after: :- use_module(library(clpfd)). possible_chars("0123456789ABCDEF"). list_domain([N], N). list_domain([N|Ns], N \/ Rest) :- list_domain(Ns, Rest). vars_in_chars(Vars, String) :- string_chars(String, Chars), maplist(char_code, Chars, Codes), list_domain(Codes, Domain), Vars ins Domain. We can use these predicates like so: ?- length(Vars, 16), possible_chars(Cs), vars_in_chars(Vars, Cs), all_distinct(Vars), label_chars(Vars, Chars). Vars = [48, 49, 50, 51, 52, 53, 54, 55, 56|...], Cs = Chars, Chars = "0123456789ABCDEF" ; Vars = [48, 49, 50, 51, 52, 53, 54, 55, 56|...], Cs = "0123456789ABCDEF", Chars = "0123456789ABCDFE" ; Vars = [48, 49, 50, 51, 52, 53, 54, 55, 56|...], Cs = "0123456789ABCDEF", Chars = "0123456789ABCEDF" ; Vars = [48, 49, 50, 51, 52, 53, 54, 55, 56|...], Cs = "0123456789ABCDEF", Chars = "0123456789ABCEFD" ; Vars = [48, 49, 50, 51, 52, 53, 54, 55, 56|...], Cs = "0123456789ABCDEF", Chars = "0123456789ABCFDE" Given those tools, it's just a matter of stipulating constraints for all of your rows, columns, and boxes. 
If you do what /r/abothologist recommends (i.e., use `char_code/2`to translate characters to character **codes**), you can use `all_distinct/1`itself! That's really as close to the "equivalent of `all_distinct/1`" as it gets. Use `all_distinct/2` directly!
+1. Topic of the next meeting: "**Using an already available Prolog**", brought to you at the **(N-1)**&amp;nbsp;languages meetup. ;-)
Thanks!
The lowest row possible. Imagine it like a connect 4 board, and you're dropping a piece in, return all the possible spaces the piece can go.
What do you think R-1 does? ;)
Is that the root of all my problems, R-1 doesn't take 1 away from R? It should be R - 1
But saying that.. you don't have to actually use any arithmetic to solve your problem.
I haven't looked at Lambda Prolog in a long time, but you've reminded me how interested I was, and I now I'm gonna try to play with it too! Looks fun as hell :) I'm running OS X 10.11.2 and I'm going to start trying the build now, and see if I run into the same problem. I'll report back shortly. I'm also going to get on the [##prolog freenode channel](https://webchat.freenode.net/), so I'll be there for a bit (I'm "shon" or "~um") in case you want to chat about it. I'll also lurk in the #ocaml irc channel, since it sounds like it might be an ocaml-to-osx issue rather than anything to do with treyjus.
Wow, man, thanks for the response. Really appreciate your effort. The install worked perfectly. Will definitely share my work here once I've got something to show.
I'm familiar with a bit of SWI-Prolog and a good amount of typed lambda calculus / intuitionistic type theory so I'm hoping once I understand general syntax and flow I can get to writing statements without too much trouble. I'll keep looking for more literature and documentation, though - if I find anything you'll be the first to know.
nice!
Sure thing! I hope you do indeed change everything around :) This was only meant to help provide some sense of different ways of approaching the problem. Please let me know if you have any questions. Just a quick note: you initially represented the grid as a list of compound terms `cell(X,Y,Contents)` that relate pairs of coordinates `X,Y` to contents `Contents`. While this data representation might be have some particularly useful qualities I'm missing, it also seems to be somewhat awkward insofar as you forced to traverse and copy lists in order to find and update the contents of a cell, but the list structure itself doesn't actually help organize the relations between cells in any useful way. Therefore, it might be worth your time investigating these two options: If you represent the grid as a two dimensional list, you can use the list structure itself to encode the coordinates, and the content of the list cell just is the contents. Then, traversing the list is not an additional step you need to deal with, but amounts to computing the position. It is then easy to write purely declarative predicate that can be used in any mode (run "forwards" and "backwards") to access particular cells given the coordinates, or to return the coordinates given a cells contents. For example, given a grid represented like this (with the atoms `a1,a2,etc.` replaced with appropriate contents test_grid(Grid) :- Grid = [[a1,a2], [b1,b2]]. we can write the following rule grid_x_y_cell(Grid, X, Y, Cell) :- nth0(Y, Grid, Row), nth0(X, Row, Cell). And it works almost like magic to, for instance, give us the contents of a cell at (0,0): ?- test_grid(G), grid_x_y_cell(G,0,0,C). G = [[a1, a2], [b1, b2]], C = a1. Enumerate all the cells of a certain column (or row) on backtracking: ?- test_grid(G), grid_x_y_cell(G,1,Y,C). G = [[a1, a2], [b1, b2]], Y = 0, C = a2 ; G = [[a1, a2], [b1, b2]], Y = 1, C = b2. Or tell us which coordinates have cells that unify with a certain content: ?- test_grid(G), grid_x_y_cell(G,X,Y,b1). G = [[a1, a2], [b1, b2]], X = 0, Y = 1 ; false. Conversely, you could avoid lists all together but use a compound representation like you had first selected. In this case, we would define a grid as a set of facts: cell(0,0,a1). cell(1,0,a2). cell(0,1,b1). cell(1,1,b2). Then we can write a rule analogous to list-based one, like so: x_y_cell(X, Y, Content) :- cell(X, Y, Content). To make updates to the grid using the list-based approach, you can use `select/4` to make a new list (as demonstrated earlier). While making updates to the fact-based approach requires altering the database using `retract/1` and `assertz/1`. The latter requires venturing into dynamic databases, which is [often discouraged](http://www.swi-prolog.org/howto/database.html), but very useful and very fun, and something you'll want to learn to use eventually. Sorry for writing so much. :)
Very good question. One very important reason is that, given implicit depth-first search as it is readily available in Prolog, it is extremely easy to implement iterative deepening *yourself*. For example, a huge number of search tasks in Prolog are about finding a *list* (of moves, of state changes, of commands etc.) with some properties. If you have a predicate `p/1` that describes what a solution looks like, then you can query: ?- p(Ls). to ask for solutions. As you correctly note, this may not find a solution *although there is one*, due to the incomplete and efficient depth-first search strategy that Prolog uses. **However**, we can very easily obtain iterative deepening **ourselves**, if we just query instead: ?- length(Ls, _), p(Ls). That's it. On backtracking, this **generates** increasingly longer lists `Ls`, and invokes `p/1` only on lists of **bounded** length. Bamm! Iterative deepening. Iterative deepening is a very nice search strategy, asymptotically optimal under very general assumptions, and you can make it easily available in Prolog yourself. I guess mostly for this reason, the default execution strategy is kept extremely simple. When needed, you can easily implement other search strategies on top of it.
Don't take this the wrong way, but is that **really** the reason Prolog made that decision? I can't be sure, but it looks like iterative deepening wasn't well known when Prolog was first released in 1972 - [this paper (sadly behind paywall, so I can only see the abstract)](http://www.sciencedirect.com/science/article/pii/0004370285900840) seems to show that in 1983, iterative deepening and its advantages were only just being recognised. In any case, it's worth considering the state of computing when the first Prolog was released in 1972 - the same year as the worlds first 8-bit microprocessor, the Intel 8008. One example mainframe of that era (the IBM System/370 Model 145) had 512KB RAM, 233MB hard disk storage and a 2.5MHz processor. And Prolog was initially purely interpreted - the first Prolog compiler, by David Warren, didn't happen until 1983. In the early days, even the LISP community considered Prolog slow, even though LISP at that time was mostly interpreted too and also had a reputation for being slow. Forcing a more expensive search strategy seems like a bridge too far in that context. 
All very true, +1. Why is it though that iterative deepening was not adopted later, and why is it *still* not the default search strategy in Prolog? I think an important reason for this is what I wrote: You can easily implement a complete search strategy on top of the default depth-first search strategy that Prolog gives you.
I think it comes down to: compromises had to be made for speed and memory: "in France at that time, were exceptionally good: practically 1Mb of memory to execute the programs" from [1]. The depth first search is minimal in terms of memory that you need to track state - just one list/stack of choice points as opposed to fair searches that maintain trees of paths to continue. In the early days just before prolog was invented there was a strong focus on resolution based theorem provers (with complete search and logical soundness). There was no intention or interest to have incomplete search! It's really interesting looking back at early "prolog" papers like [3] and seeing how they stress soundness and completeness (with underlines!). An exception is PLANNER, Colmerauer did learn about PLANNER before prolog was invented [2], but apparently didn't give it much attention because they cared more about resolution and didn't know lisp. Then when working on a text parsing application: "A draconian decision was made: at the cost of incompleteness, we chose linear resolution with unification only between the heads of clauses. Without knowing it, we had discovered the strategy which is complete when only Horn clauses are used. Robert Kowalski [1973]" - [1], page 6 Another compromise (reducing the logical soundness of prolog) that had to be made: "We observe in passing that this was also the time when the “occur check” disappeared as it was found to be too costly." - [1], page 8 * [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.7438 * [2] https://en.wikipedia.org/wiki/Planner_%28programming_language%29 * [3] http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf --------- Let me just add this quite long quote from the paper [1]: &gt; Backtracking was &gt; selected early on for management of non-determinism, in preference to a management system &gt; of several branch calculations simultaneously resident in memory, whose effect would have &gt; been to considerably increase the memory size required for execution of the deductions. Alain &gt; had a preference for this method, introduced by Robert Floyd [1967] to process non- &gt; deterministic languages, and was teaching it to all his students. Although, certainly, the use of &gt; backtracking led to a loss of completeness in deductions comprising infinite branches, we felt &gt; that, given the simplicity of the deduction strategy (the execution of literals from left to right &gt; and the choice of clauses in the order they were written), it was up to the programmer to make &gt; sure that the execution of his program terminated. 
Prolog is intended as a programming language, not a sound and complete theorem prover for definite clauses, although zmonx has emphasised just how easy it is to turn it into one. As you say, Prolog's main competitor was Lisp, a language based on ideas from lambda calculus but with impure (side-effecting) functions, i.e. procedures. Likewise, Prolog was based on Horn clause logic, but with side-effecting predicates. At the time, this considered to be indispensable for a useful programming language. (This was, of course, long before Haskell proved the contrary.) When you have side-effects, the order of evaluation - proof search, in Prolog - obviously matters, and depth-first search is the most procedurally natural. A Prolog clause a :- b1, ..., bn. means, procedurally, to call `a`, call `b1`, then `b2`, ..., then `bn`, and backtrack on failure. Under the right circumstances, it also has the meaningful declarative semantics. Other strategies, such as iterative deepening, would force the `bi` to be called a (possibly indeterminate) number of times, meaning we would lose control of the procedural semantics if the `bi` are allowed to produce side-effects. With modern hindsight, the necessity for pervasive side-effects and therefore the decision to mandate depth-first execution is questionable. I, for one, love good old Prolog, which I believe is a beautifully simple compromise between impure procedural and pure declarative semantics. On the other hand, zmonx has been vociferous in his advocacy for a transition to greater purity in modern Prolog.
Oh I am sorry, I should have included this: The second element of a tuple can only appear once, thus in these examples, P or Q would be invalid. Because the 2 appears 3 times. In the first example P is invalid, in the second Q is invalid
By "possible solutions" I mean different ways of writing the program ;) It is quite clear that your specifications describe a deterministic predicate. I'm working on composing reply :)
You're very welcome! The most important step, of course (which I apologize for being too selfish and lazy to help with), is to compare my solution with your own efforts and see where you were on the right track and where you might have been confused. Also note that if your course has not yet introduced `select/3` and the `-&gt;/2` and `;/2` operators, then the instructor probably won't want to see them show up in your homework answers. For this reason, and for purely pedagogical purposes, you'd be well served to figure out how to write `select/3` yourself and to provide a definition of `q/3` that doesn't rely on `-&gt;/2` (which is, any how, declaratively impure). If you want to talk any of your progress over, I'd be happy to continue the exchange :)
Yes i am using swi prolog. the thing is in the example, after the answer there is a . meaning those are all the answers. But my code returns the answer, and then i am able to press ; to get more answers, while in the example there was only one answer available. That is the main part for my confusion, am I thinking too much about this or is there something wrong with my code?
Hey, That is not selfish at all. You already helped me a lot in understanding it. I asked my tutor if this was okay, and unfortunately not. But it did make me understand what I should check in the recursive calls and the base case. This is eventually what I came up with: add([],[],[]). %%Base case add(T,[],T). %%Adding an empty list to T is simply T add(P, [(A,B)| T], R):- %%Recursive predicate not(member((_,B), P)), %%If B is not in the list P yet then: add(P, T, R2), %%Recursive call (R2 is now the tail without the tuple (A,B)) append([(A,B)], R2, R). %%Add the tuple (A,B) that wasn't in the list yet to R2, and put this in R (the result) add(P, [(A,B)| T], R):- %%This gets called if B is already member of list P (due to redo) select((A2,B), P, L), %%Select the tuple with B, and put the first value in A2 C is A + A2, %%Add the values together (A2 is the tuple found in list P, A is a recursive call, thus from list Q) append([(C,B)], R2, R), %%Append these to lists together in R add(L, T, R2). %%Recursive call with new result R2 (the one without the newly added one.) **Thanks for all your help!**
; tells prolog to go find more answers, where . Tells prolog to stop. So when you're finding more answers, it's because you're pressing ; more times. 
Oke I get it now, thanks a bunch!!:D
Glad I could help! That looks like a very nice solution—well commented too! :)
Haha it is, sorry I posted this from my phone so I don't know if I was meant to flair it or something. And hmm I was thinking of doing something like that but I'm not sure how to call the removeDups predicate from the new predicate and then check if it has applied correctly?
I'll help you a Little.. :) newPredicate(InputList):- removeDups(InputList, CleanedList), ensureAllValuesPresentExactlyOnce(InputList, CleanedList). In ensure... Go through each value in inputlist, and make sure there is exactly One of those values in Cleanedlist; easiest if you know some built in "countoccurances" predicate or something like that. Prolog is great for many things - i work with it every day, so good luck :)
Aaah I see thanks for the explanation! And aah fair enough haha, for the record I think flaired topics in subs can be quite nice! 
What kind of work do you do with prolog, if you don't mind me asking?
Well, we are all learning something from them, so all good imo. 
Business rules, and lots of stuff surrounding that - you want a system based on rules? Pick a language based on rules :)
Please post your `primeMinister/3` facts as well. When I run the following program primeMinister(a,b,c). primeMinister(a,b,c). primeMinister(a,b,c). stints(A,Count) :- aggregate_all(count,primeMinister(A,_,_),Count). I get the expected result for queries: ?- stints(b,C). C = 0. ?- stints(a,C). C = 3. 
I think you forgot the link.
Fixed, thanks.
Sure! I didn't mean to suggest you have an obligation or owe /r/prolog anything. But we'd like *more* posts, not less :)
Looks nice! If I used Visual Studio, I'd certainly try it out :) Re syntax coloring, one things I've often though would be nice in a syntax highlighting package would be making `:-`, `.`, and conjuctive `,`s stand out stronger, so that the logical demarcations where more perspicuous. Although, such a thing is certainly not necessary...
Here's a short example of character conversions using [`char_type/2`](http://www.swi-prolog.org/pldoc/doc_for?object=char_type/2): http://swish.swi-prolog.org/p/Coverting%20Char%20Cases.swinb
In general, the `ERROR: ...: Arguments are not sufficiently instantiated` error means you are calling a predicate on an argument with a free variable, when that predicate requires the argument to be non-variable (`downcase_atom/2` requires its first argument to be an atom). Now, why would `downcase_atom/2` complain about an instantiation error when you use `read/1` to read in lowercase chars but not when you use it on uppercase? Because **`read/1` reads in Prolog terms** not strings of characters. When you call the following: ?- read(X), downcase_atom(X, Y). |: V. ERROR: downcase_atom/2: Arguments are not sufficiently instantiated Prolog reads in the uppercase V as a free variable, then passes that to `downcase_atom/2`. If you want to use `read/1` to get your inputs, you'll need to quote uppercase atoms: ?- read(X), downcase_atom(X,Y). |: 'A'. X = 'A', Y = a. However, if you only want to convert single characters, you should probably be using [`get_char/1`](http://www.swi-prolog.org/pldoc/doc_for?object=get_char/1) instead of `read/1` (since the latter is really for reading in prolog terms to inspect them or to interact with the program). On the other hand, if you want to be reading in longer sequences, you should consider using [`read_line_to_string/2`](http://www.swi-prolog.org/pldoc/doc_for?object=read_util%3Aread_line_to_string/2): ?- read_line_to_string(current_input, X), string_lower(X, Lower). |: ThisLineWill be read as in as STRING! X = "ThisLineWill be read as in as STRING!", Lower = "thislinewill be read as in as string!".
very clear and helpful! Thank you very much! I understand now
If you only want a character, you only need to read in a character. In Prolog, characters are represented as atoms (not to be confused with *character codes*, represented as integers), so you don't need to convert it into an atom. E.g., get_upcase_char(UpperChar) :- get_char(Char), char_type(UpperChar, to_upper(Char)). Of course, there might be reasons to read in a whole line and just take the first character (like if you want to validate whether an input line or something).
I believe the cut is what's throwing you off. The middle clause will unify P to 11, then the cut will prevent it from trying the next clause. My advice is to use pattern matching instead of a counter. Consider this: fours(P, [P,P,P,P|_]). fours(P, [_|T]) :- fours(P, T). The first clause will bind P if the list starts with 4 of the same thing. The second clause is the recursive case, which will trim off the first value and try again. This version is still flawed. For example, if the list contains five 12s in a row, P will be bound to 12 first, and the bound to 12 again upon backtracking. That's because there would be two separate (overlapping) instances of four 12s in a row. If you only care about the first value of P, a cut can fix that. fours(P, [P,P,P,P|_]) :- !. fours(P, [_|T]) :- fours(P, T). The cut prevents us from trying the recursive case once we find a match. We can also shave off a few iterations of the loop in the worst case since we know the list must be at least 4 items long to find a P. There are different ways to do this, but the easiest way is to extend the pattern: fours(P, [P,P,P,P|_]) :- !. fours(P, [_,A,B,C,D|T]) :- fours(P, [A,B,C,D|T]). Now the last clause will only recurse if the list has at least 5 elements.
 grade(100, "A"). grade(80, "B"). grade(60, "C"). ?- grade(Score, Letter) Adding.. ELI5 First, you need to establish your baseline knowledge. In prolog, that's done by establishing "facts" which in this case are the various "grade(...)" rules containing literals as their parameters. Second, you need to build a query. A query is given by "?- ...". In my example, I asked prolog to give me results for all predicates matching "grade" with two variable parameters. This will return all matching results in the "fact" database -- which is everything. You can constrain your query by filling in a literal parameter. If you wanted to know all scores that'll give you an "A", then you'd just: ?- grade(Score, "A") Why does this work? Because prolog has this idea of "unification". When you unify against something, you're looking for results that match and discarding results that don't match. In my above example, you'll only get one result because there is only one thing that matches "A" as the second parameter in "grade".
In prolog you just state which things are true in terms of border/base cases or in terms of the simpler cases. For this problem in particular there are only borders 
The harder problem of reporting grades for real numbers is also easy: grade(a, X) :- 90 =&lt; X. grade(b, X) :- 80 =&lt; X, X &lt; 90. grade(c, X) :- 70 =&lt; X, X &lt; 80. grade(d, X) :- 60 =&lt; X, X &lt; 70. grade(f, X) :- X &lt; 60. The query ?- grade(Grade, 77). Will bind the variable Mark to the atom 'c' because of the third clause. *Assuming we only need to learn the grade given the mark*, we can improve performance *on some systems* with cuts. grade(a, X) :- 90 =&lt; X, !. grade(b, X) :- 80 =&lt; X, !. grade(c, X) :- 70 =&lt; X, !. grade(d, X) :- 60 =&lt; X, !. grade(f, X). Prolog tries clauses in order. If it finds a clause that succeeds, it returns the variable bindings to the caller. Upon returning, if there were clauses that it were not tried, a choice point is recorded so Prolog can try the others in case of future failure. The ! cut symbol tells Prolog to forget about untried clauses for the same predicate. Since the clauses for this problem are mutually exclusive, these cuts tells Prolog to forget choices that we know will fail. **Edit:** Be clearer and fix my mixed up concepts of mark and grade. Mark is the number; grade is the letter.
not really, with your new logic you could add: grade(_, M) :- var(M), write('You must enter a grade.'), nl, !. grade(G, M) :- integer(M), between(0, 100, M), grade_(G, M), !. grade(_, M) :- write('Your grade for the mark of '),write(M),write(' is not in the system.'), nl. which I believe is part of the specs. Then it handles that case that the mark is an integer out of range, or not an integer at all, or not even entered. 
No problem. It can be handy to keep a list of operator precedence handy; [here's SWI-Prolog's](http://www.swi-prolog.org/pldoc/man?section=operators). Notice that `,` binds more strongly than `-&gt;` (it has a lower precedence number). 
Wow thanks! 
Ok first of all predicates describe relations.. so you will never have something like: '?- ocurrenceof([1,1,1,2,3,4,4,5,6] , 1) = 3'. What you might have is ' ?- ocurrenceof([1,1,1,2,3,4,4,5,6] , 1,Count). Count=3. ocurrenceof([] , _,0). %empty list, count of anything is 0. Base case. % The first item in the list is the same as what you want to count so % add1 to the recursive count. ocurrenceof([H|T] , H,NewCount):- ocurrenceof(T,H,OldCount), NewCount is OldCount +1. %The first item in the list is different so keep old count ocurrenceof([H|T] , H2,Count):- dif(H,H2), ocurrenceof(T,H2,Count). Samples Qs: ?- ocurrenceof([ana,john,ric,ana,ana,ana] , ana,Count). Count = 4 . ?- ocurrenceof([1,1,1,2,3,4,4,5,6] , 1,Count). Count = 3 . Another way to do this (Which is probably overkill for what you want), but is something I saw on stack overflow and its quite neat. First we have Reifed Tests, these assign 0 and 1s to tests. :- use_module(library(clpfd)). if_(C_1,Then_0,Else_0) --&gt; { call(C_1,Truth) }, { functor(Truth,_,0) }, % safety check ( { Truth == true } -&gt; phrase(Then_0) ; { Truth == false }, phrase(Else_0) ). if_(If_1, Then_0, Else_0) :- call(If_1, T), ( T == true -&gt; call(Then_0) ; T == false -&gt; call(Else_0) ; nonvar(T) -&gt; throw(error(type_error(boolean,T),_)) ; /* var(T) */ throw(error(instantiation_error,_)) ). =(X, Y, T) :- ( X == Y -&gt; T = true ; X \= Y -&gt; T = false ; T = true, X = Y ; T = false, dif(X, Y) % ISO extension % throw(error(instantiation_error,_)) % ISO strict ). Then we can define tcount: tcount(P_1,Xs,N) :- N #&gt;= 0, list_pred_tcount_(Xs,P_1,0,N). list_pred_tcount_([] , _ ,N ,N). list_pred_tcount_([X|Xs],P_1,N0,N) :- if_(call(P_1,X), (N1 is N0+1, N1 #=&lt; N), N1 = N0), list_pred_tcount_(Xs,P_1,N1,N). Sample query: ?- tcount(=(1),[1,1,2,3,1],X). X = 3.
Wow! `tcount/3` is awesome! Usable as a true relation, i.e., in all directions!
For good measure, here's a high-level approach using SWI-Prolog standard predicates. occurrences_of(List, X, Count) :- aggregate_all(count, member(X, List), Count). Which you can use like so. ?- occurrences_of([1,1,1,2,3,4,4,5,6], 1, X). X = 3. ?- occurrences_of([1,1,1,2,3,4,4,5,6], 4, X). X = 2. 
I would have a predicate 'was_married/2' was_married(bob,jill). was_married(X,Y):-X@&lt;Y,was_married(Y,X). is_married(jeff,jill). is_married(X,Y):-X@&lt;Y,is_married(Y,X). is_child(bobjr,bob). is_child(bobjr,jill). is_adopted(alfred,jill). is_adopted(alfred,jeff). stepparent(P,C):- is_married(P,P2), is_child(C,P2). %You could add a negation that C can not be a child of P for other cases so add \+ is_child(C,P). 
The library of the old DEC-10 Prolog system is a great resource. http://www.j-paine.org/prolog/tools/files/contents.html
Thank you!! Ill check it out!
If I get it right, your approach would be to do it for one case, to transform the list once, then doing it for the rest of the cases. My problem comes from, first, as you pointed out, wrong notions because inexpertise and second, because: I cannot make it work with that approach, because for the First (and last) element of an input list, I always have to make an operation a certain way. And for the rest of the list (the body), I need to apply rules depending on what it's neighbours elements are. I know it's a bad approach, because is the exact type of problems I had when I first started with lists in Java, but I am not finding that one way of unifying both concepts, because for the body I need to do: regla(H1,H2,H3,Output) and for the first element is: regla(o,o,H1,Output). Again thanks in advance
If it's any consolation for you: I have myself struggled with exactly this problem for much longer than I would normally care to admit. But I make an exception just for you (no joke!), because I have seen that you strive for purity and you have the potential to really benefit from it. I can only repeat that you will have to think in terms of *relations* between such lists, and this will likely mean in this case that you have to reason about two lists where you currently try to cram in everything into one. At least I get the strong impression that's your current problem, with code like `[OutputPrimero,Acc]`. Remember that it is totally OK to reason about different terms like so: Acc0 = [], Acc1 = [E|Acc0], ..., Acc = ... and step by step describe what `Acc` actually consists of. We read such clauses declaratively: **If** `Acc`is ... **and** `Acc1` is ... **and** ..., **then** the relation (which is to be described) holds between such and such terms. Note again that we make use of different lists and variables when doing so, because we already know that all terms are immutable and cannot be different things at once. 
Surely you mean right to left? as in "&lt;-" I admit I am a bit rusty on prolog and logic in general but the implication goes for right to left i think.
Yes, of course! I fixed this.
Again thank you very much, I will study this thoroughly 
You are very close, but a few simple mistakes currently prevent any solution: 1. First, the last line misses the `Final`. 2. Second, already the following goal **fails**: `M = [M1,M2,M3]`. This obvisouly *cannot* hold, because `M` is an individual man, not a *list*. You obviously mean instead: `man(M1), man(M2), man(M3)`. 3. A bit more subtly: Always use the constraint `dif/2` to express that two terms are different. Currently, you are using "not provable" (`(\+)/1`), and this leads to incompleteness of your predicate. Instead, use the following definition of `not_in/2`: not_in(X, Ls) :- maplist(dif(X), Ls). Use this everywhere you are currently using `\+ member...`, for example: not_in([joel,_,kia,_], Final), With these simple changes, you already obtain valid answers.
Very nice explanation! To fill in the small missing hint that I think is appropriate following your last sentence, I would like to point OP to the `dif/2` constraint. `dif/2` can be posted before the brute force search even starts, and often significantly prunes the search space. Use `dif(X, Y)` to state that `X` and `Y` are *different* terms.
Okay, thank you so much. So I am at least getting something other than false back. But what I am getting back is not making much sense. For example: `I = [[joel, reynolds, volkswagen, blue], [rosemary, _G1149, _G1152, white], [elliot, parker, _G1167, black], [joel, montoya, kia, gold], [sally, harrison, _G1197, _G1200]], dif(f(_G1214, _G1149, _G1152, _G1230), f(rosemary, gardner, subaru, white)), dif(f(_G1261, _G1167, _G1277), f(parker, mercedes, black))` Why is it giving me addresses to variables? Also, why does it display the results of the dif predicate? Here is how I changed my code: ` man(joel). man(elliot). man(chris). woman(rosemary). woman(sally). not_in(X, Ls) :- maplist(dif(X), Ls). sol(Final) :- man(M), woman(W), man(M1), man(M2), man(M3), Final = [[_,_,_,_],[_,_,_,_],[_,_,_,_],[_,_,_,_],[_,_,_,_]], not_in([joel,_,kia,_], Final), member([joel,_,_,blue], Final), member([M,reynolds,volkswagen,_], Final), member([W,_,_,white], Final), not_in([rosemary,_,toyota,red], Final), member([_,parker,_,black], Final), member([M1,_,_,gold], Final), member([M2,_,kia,_], Final), member([M3,montoya,_,_], Final), member([elliot,_,_,black], Final), not_in([elliot,_,mercedes,_], Final), member([sally,harrison,_,_], Final), not_in([_,gardner,subaru,_], Final).` My attempt at fixing the issue: `man(joel). man(elliot). man(chris). woman(rosemary). woman(sally). last_name(reynolds). last_name(parker). last_name(montoya). last_name(gardner). last_name(harrison). make(volkswagen). make(kia). make(subaru). make(mercedes). make(toyota). color(gold). color(black). color(blue). color(white). color(red). not_in(X, Ls) :- maplist(dif(X), Ls). sol(Final) :- man(M), woman(W), man(M1), man(M2), man(M3), woman(W1), woman(W2), last_name(L1), last_name(L2), last_name(L3), last_name(L4), last_name(L5), make(Ma1), make(Ma2), make(Ma3), make(Ma4), make(Ma5), color(C1), color(C2), color(C3), color(C4), color(C5), Final = [[joel,L1,Ma1,C1],[elliot,L2,Ma2,C2],[chris,L3,Ma3,C3],[rosemary,L4,Ma4,C4],[sally,L5,Ma5,C5]], not_in([joel,_,kia,_], Final), member([joel,_,_,blue], Final), member([M,reynolds,volkswagen,_], Final), member([W,_,_,white], Final), not_in([rosemary,_,toyota,red], Final), member([_,parker,_,black], Final), member([M1,_,_,gold], Final), member([M2,_,kia,_], Final), member([M3,montoya,_,_], Final), member([elliot,_,_,black], Final), not_in([elliot,_,mercedes,_], Final), member([sally,harrison,_,_], Final), not_in([_,gardner,subaru,_], Final). ` This results in an infinite loop. 
Okay, So I reordered my goals like you said, but I am receiving answers that repeat makes of cars and last names and stuff. How do I ensure each value only appears once in my final answer? Here's an answer I got: `I = [[joel, reynolds, volkswagen, blue], [elliot, parker, kia, black], [chris, montoya, volkswagen, gold], [rosemary, reynolds, volkswagen, white], [sally, harrison, volkswagen, gold]]` And here's my code: `man(joel). man(elliot). man(chris). woman(rosemary). woman(sally). last_name(reynolds). last_name(parker). last_name(montoya). last_name(gardner). last_name(harrison). make(volkswagen). make(kia). make(subaru). make(mercedes). make(toyota). color(gold). color(black). color(blue). color(white). color(red). not_in(X, Ls) :- maplist(dif(X), Ls). sol(Final) :- Final = [[joel,L1,Ma1,C1],[elliot,L2,Ma2,C2],[chris,L3,Ma3,C3],[rosemary,L4,Ma4,C4],[sally,L5,Ma5,C5]], not_in([joel,_,kia,_], Final), not_in([rosemary,_,toyota,red], Final), not_in([elliot,_,mercedes,_], Final), not_in([_,gardner,subaru,_], Final), member([joel,_,_,blue], Final), member([M,reynolds,volkswagen,_], Final), member([W,_,_,white], Final), member([_,parker,_,black], Final), member([M1,_,_,gold], Final), member([M2,_,kia,_], Final), member([M3,montoya,_,_], Final), member([elliot,_,_,black], Final), member([sally,harrison,_,_], Final), man(M), woman(W), man(M1), man(M2), man(M3), woman(W1), woman(W2), last_name(L1), last_name(L2), last_name(L3), last_name(L4), last_name(L5), make(Ma1), make(Ma2), make(Ma3), make(Ma4), make(Ma5), color(C1), color(C2), color(C3), color(C4), color(C5).` In other words... Is there an easier way to say M1, M2, and M3 are all different other than doing `dif(M1,M2), dif(M1, M3), dif(M2,M3),` because that process will get much more lengthy when i have to do it for make, last_name, and color. 
I did it, it looks gross but I went through and dif'd them all. I got the correct solution but It gives me multiple incorrect solutions along with it. such as `I = [[joel, montoya, subaru, blue], [elliot, parker, kia, black], [chris, reynolds, volkswagen, gold], [rosemary, gardner, toyota, white], [sally, harrison, mercedes, red]]' rosemary cannot have a toyota because i specifically stated `not_in([rosemary,_,toyota,red])` why is this a viable solution still? I also tried adding two more rules that split up red and toyota but that didn't help either.
Thanks for the tips! I based this off of your advice in the other post... person(amelia).person(melony).person(julia).person(sarah).person(rachel).lname(west).lname(sanford).lname(travers).lnamejames).lname(couch).suitcolor(blue).suitcolor(yellow).suitcolor(black).suitcolor(red).suitcolor(white).suittype(onepiece).suittype(twopiece).place(first).place(second).place(third).place(fourth).place(fifth). not_in(X, Ls) :- maplist(dif(X), Ls). sol(Final) :- person(P1), person(P2), person(P3), person(P4), person(P5), fname(F1), fname(F2), fname(F3), fname(F4), fname(F5), lname(L1), lname(L2), lname(L3), lname(L4), lname(L5), suitcolor(C1), suitcolor(C2), suitcolor(C3), suitcolor(C4), suitcolor(C5), suittype(T1), suittype(T2), suittype(T3), suittype(T4), suittype(T5), place(R1), place(R2), place(R3), place(R4), place(R5), Final = [[rachel, travers, C1, T1, R1], [melony, L2, C2, T2, first], [amelia, L3, C3, T3, R3], [julia, L4, C4, T4, R4], [sarah, L5, C5, T5, R5]], not_in([rachel,_,red,_,_], Final), not_in([melony,james,_,_,_], Final), not_in([amelia, west,_,_,_],Final), not_in([julia, couch,_,_,_],Final), not_in([_,_,yellow,_,second], Final), not_in([rachel, _, white, _,_], Final), /* person((Fname, Lname, SuitColor, SuitType, Place) */ member([_, _, white, onepiece, _], Final), member([P1, _, _, onepiece, second], Final), member([P2, _, yellow, onepiece, _], Final), member([P3, _, _, onepiece,_], Final), member([P4, james, _, twopiece, _], Final), member([P5, _, black, twopiece, _], Final). I haven't implemented logic for solving the place but I have two questions... a) why does it just return true? and b) to determine places do I just need to figure out all the possibilities based on the problem and add them as member and not_int statements or is there anything fancy I can do with integers in prolog?
There are elementary syntax errors in your code (probably as a result of the strange formatting), `fname/1` is nowhere defined etc. Please at least make sure that others have a chance to know what you are talking about, and paste the code in such a way that all issues are reproducible. You can do the **fanciest** things with integers in Prolog, using CLP(FD) constraints. Check your Prolog system's `library(clpfd)`, `library(clpz)` or built-in integer constraints like `(#=)/2`, `(#&gt;)/2` etc. These are general relations over integers, way cooler than in all other languages, and you can use them to freely state constraints over integers.
2 suggestions for improving the solution: - use `dif/2` instead of `(\==)/2`. `(\==)/2` is an impure predicate, while `dif/2` can be soundly used in *all* directions, also if its arguments are variables. - use the definition of `all_dif/1` to avoid so many `dif/2` constraints. `all_dif/1` describes lists whose elements are *pairwise* different.
I want to know this as well!
You need to know what r16 games map to what r8 (qf) games and what r8 games map to what r4 (smf) and then r4 to final.. g(qf1,g1,g2). Could represent that the winners of g1 and g2 play in quarter final 1. Then g(smf1,qf1,qf2). For the semi final.. and g(final,smf1,smf2) for the final. With these facts you could then have a rule playing/3 with a case for each round or a recursive rule, but for this I would stick to having separate cases for clarity. 
But doesn't the base case need to be true for the simplest version of the rule?
Okay this might be why my logic always fails. So what should the second line be? Or how do I need to think about this? I'm generally struggling to grasp how I should construct the recursion, I think I'm failing to understand how to build one.
On your second case you are using X as the result. You could think of this like a sequential program remove([H|T], Y) { if(H =/= Y) { [H|X] = remove(T, Y) } return X } This might be a little easier to understand why it won't work. Also, for your third case you don't have any conditions, so if H =/= Y then both cases 2 and 3 will run. 
Your base case has 0 as the result. What does appending to 0 do? 
I hear you. Understanding this is quite hard at first. The key insight is that you need to think in terms of *2&amp;nbsp;lists* to append efficiently at *the&amp;nbsp;end*. For example, I can write a *partial* list as: Ls = [a,b,c|Rest] If I now further instantiate `Rest`, then `Ls` will *also* be further instantiated. For example: Ls = [a,b,c|Rest], Rest = [d,e] Try this and see what `Ls` is. And now I can take this further: I can again instantiate `Rest` *partially*, and say for example (note the new naming): Ls0 = [a,b,c|Ls1], Ls1 = [d,e|Ls2] and now have a relation between `Ls0`, `Ls1` and `Ls2`. `Ls0` is the list I actually care about, but I need to keep track of the others too so that I can append further elements at the end. Therefore, you will find that predicates that reason about such list differences usually take at least *two* arguments: The original list, and the remaining part that can be used to *further* instantiate the list. Importantly, note that this is *not* needed to implement a *stack*, because a stack can be implemented by *prepending* elements and fetching them from the *front*, and for this you do not need such partially instantiated structures. I can prepend elements easily using the usual list notation, for example: Stack0 = [a,b,c], Stack = [d|Stack0] and now obtain `Stack = [d,a,b,c]`. Note however, that I *again* need two arguments: The "original" stack, and the "new" stack. But now there is a crucial difference (pun intended) compared to the previous case: *Both* lists are now fully instantiated, because I do not need to keep track of any remaining list that needs to be further instantiated. However, I can combine the two approaches and thus build a datastructure where I can efficiently add elements at the front *and* at the end! In your case, this seems to be more general than what you asked. In fact, if you really only need a stack, then, as I said, you do not even need any partially instantiated structures at all.
count([],_,0). count([X|T],X,C):- count(T,X,C1), C is C1+1. count([H|T],X,C):- count(T,X,C). 
In your specific case, no. Since `b`, `c`, and `d` are all independent, the particular solution to `b` will not influence the solutions to `c` and `d`. But in the general case, a rule with multiple cuts will behave differently to one with just a single cut. Cuts are commit points: when the cut is evaluated, the prover commits to any choices made up until that point. Anything that hasn't been tried is cut from the proof tree. But goals that come after the cut are allowed to backtrack as normal. By putting multiple cuts in the same clause, you're committing to partial results multiple times. If `b` has multiple solutions, the first cut commits you to the first of those solutions. Within the context of those bindings, `c` might still have multiple solutions. The second cut commits you to the first solution for `c`. But since there's no trailing cut, *all* possible solutions to `d` will be tried.
Is it valid Prolog syntax? You can run it like this: $ swipl file.dat
Just noticed the sidebar included answer set programming, so this fits here. ASP is also based on the stable model semantics, but all current implementations require that programs be grounded to remove variables. s(ASP) executes normal logic programs using the stable model semantics, but it does so without any form of grounding. As a result, you can use features that won't work in ASP, such as lists, structures and real numbers. Do note that the current system is a research implementation written in Prolog, so, while it's fully functional, don't expect much in the way of performance. Bonus points if you can figure out the name.
The func library doesn't require function definition either. Just syntax for calling, as you describe.
ah yes, sorry, probably mixed up with something else 
well, humans (animals, plants) neither fully understand themselves, nor do they directly optimize themselves. AFAIK "fight for survival" fueled evolution (random mutations, and competition as fitness function) EDIT: Of course, avoiding danger is only one aspect; ability to acquire food / ability to thrive in specific environments (either versatility or specialization), and ability to successfully reproduce are also important factors.
So the Prolog model is to pursue a query to either success or failure. In the case of success, you emit that success. In the case of failure, you do nothing. But then, whether you succeed or fail, you then backtrack to the last decision point and try remaining clauses. So when you expand `?- a(Result)` to `?- a(1).`, there's nothing left to do with that query. You've found a result (`Result = 1`). Now, you have to backtrack. The only thing you can backtrack on is the expansion of `a`. Try another expansion of `a` and continue. Though if you need to show actual SLD resolution, then you need to be showing q ∨ ¬p1 ∨ ¬p2 ∨ ¬p3 .... 
See my article on "Using Prolog to Solve Logic Puzzles" will give you plenty of insight. http://bennycheung.github.io/using-prolog-to-solve-logic-puzzles 
Regarding Prolog, a lot has happened in the past 20 years, and you should augment your writeup to either use *instead* or *in addition* to what you show: - CLP(FD) constraints and - in particular, the [`geost/[2,3,4]` family of constraints](https://sicstus.sics.se/sicstus/docs/4.1.0/html/sicstus/Combinatorial-Constraints.html#index-geost_002f_005b2_002c3_002c4_005d-_0028clpfd_0029-3419) provided by SICStus&amp;nbsp;Prolog. Using such constraints makes the formulation a lot clearer, shorter and also more efficient.
As a Constraint Programming practitioner, I agree wholeheartedly: using dedicated algorithms to do the reasoning is much more efficient, and encapsulating those in constraints do make models clearer. Moreover, constraints can be added to prolog via CLP(FD) (I believe Constraint Programming actually comes from logic programming, right?). Everybody's happy!
Thank for the hints and greatly appreciated! I aware that Prolog's constraint programming libraries existed. However, I would like to explain the structure of spatial reasoning rather than to efficiently solve the puzzle. 
For a start, simply check out the [SICStus documentation](https://sicstus.sics.se/sicstus/docs/latest4/html/sicstus.html/lib_002dclpfd.html#lib_002dclpfd) of its CLP(FD) system. This is one of the most powerful CLP(FD) systems that is currently available. You use CLP(FD) constraints like any other Prolog predicates. They simply are an expressive way to state what holds among variables that stand for integers, and your use case is such an example. There are also a few good books about constraint processing.
Prolog is also very good at exhaustive search. However, in Prolog, there are much more intelligent approaches for solving such puzzles. For example, take a look at **Constraint Logic Programming** to let the constraint solver perform reasoning to eliminate many possibilities before even searching for concrete solutions. Here is a sample solution, using SICStus Prolog and its [**CLP(B) system**](https://sicstus.sics.se/sicstus/docs/latest4/html/sicstus.html/CLPB-Introduction.html#CLPB-Introduction): :- use_module(library(clpb)). exactly_one_true([X,Y]) :- sat(X#Y). thieves([A,B,C,D,E]) :- maplist(exactly_one_true, [[~E,B], [~C,~E], [E,~A], [C,B], [D,~A]]). Sample query and its result: ?- thieves(Ts), labeling(Ts). Ts = [0, 0, 1, 0, 0] ; Ts = [1, 1, 0, 1, 1]. From this, you see that the puzzle admits two solutions: In one of them, exactly one person is the thief, and in the other solution, 4 of the 5 people are thieves. This ambiguity is a sign of a pretty badly designed or worded puzzle in my view.
This is awesome. As someone who is not very experienced with Prolog, these feel like magic to me. Do I need to know how constraints work internally to use them effectively (like how one needs a procedural understanding of Prolog)? Also, would you recommend any resources for learning more about constraint programming?
You don't need to model problems like these with constraint logic programming. They can be modelled just as nicely with pure prolog. However in many cases indeed .... libraries liked clpfd or clpb can make problems much more tractable. No, you don't need to know the hard implementation details to use libraries/frameworks like these. Here are some links I recommend: http://www.pathwayslms.com/swipltuts/clpfd/clpfd.html http://www.swi-prolog.org/pldoc/man?section=clpb http://www.swi-prolog.org/pldoc/man?section=clpfd
I agree with points (2) and (3), though I'm not 100% about point (1). I still think the low-level arithmetic plays an important role for SWI Prolog at the moment. However, point (1) would be a good change to make in the long run. Obviously low level arithmetic has issues in terms of making declarative and logical code, but low level arithmetic can occasionally come in handy for situations that require a bit more attentiveness with respect to performance. Either way, thanks for elaborating.
Ahh my mistake. I momentarily forgot that you were applying point (1) to *CLP(FD)* tutorials. Right, in this context that makes perfect sense.
I share your sentiments with respect to not wanting prolog to remain in an unprogressive state. Logical arithmetic is one important piece of the puzzle. I, however, also desire progress on a (difficult) yet less glamorized front of LP: concurrency. In other words, I'd like to see some progress on the level of a language like Erlang for example. `library(pengines)` tries to do this, however I think at the moment it is superficial emulation. Useful no doubt, albeit still emulation. Another facet of improvement I desire in prolog (which has been researched a lot), would be parallel computing in logic. Mercury is one implementation of the logic paradigm which has gained some traction in this area. Though it seems that it has lost plenty of momentum. Other experimental implementations such as Parlog seem to have been "lost in the fog" over time. Either way, it seems I've diverged quite a bit from the original topic, so I'll cease my fantasizing for now =]
Point taken. In terms of didactic value, constructs such as `is/2` are arguably counterproductive, _especially_ when trying to introduce a newcomer to a more declarative method of programming. Multimodal and/or nondeterministic/multideterministic benefits are often stressed as main selling points to beginning prologgers. Arithmetic that doesn't properly coincide with this new "worldview" not only seems contradictory to the student, but can also be off-putting. It's arguable that the low-level utilities should be introduced later. I was one of those students who learned the lower-level stuff first. Also, yes, it is a good point -- with a factor of 2 making such a difference in an application, perhaps SWI-Prolog or Prolog altogether should be up for reevaluation.
Are you kidding me? An SQL database server is a joke in comparison to what a Prolog server can do. Imagine setting off a query and the Prolog server doing some serious computation on a powerful machine, like computing a timetable for a whole university or school. This is a task that Prolog and constraint logic programming are eminently suitable for, yet is completely out of reach for SQL. And that's only *one* example! Other examples include semantic web queries, natural language processing, DNA sequencing etc., which can all be naturally tackled with Prolog. And yes, the Prolog server can also query an SQL server as part of the computation. There are bindings for that too, but often the Prolog server itself can also be the database, so there really is often no advantage to using SQL when you are already using Prolog. As I see it, pengines make the interaction between different and possibly remote Prolog processes convenient and quite seamless. Note how easily the server response can be handled in the client by constructs that come very natural in Prolog: **Clauses** that handle the different cases. So, it's like a *first-class citizen* analogon of a rest-API.
&gt; "This would normally be done by writing code on the server and then the client just sends the data needed for the query over to the server. Which then returns the computed timetable." That's exactly what pengines help you with, in a way that blends in quite naturally. Using pengines, you do not have to invent your own protocol for submitting queries and answers, but just query the pengine and handle the results with built-in mechanisms, also allowing for multiple results. Your Q&amp;A site and search is yet another example where the server can do a lot of the processing and simply transfer results.
I've found a few, after searching for a while (no link though!) - the ones I found were not easy to understand, but there are a few projects or there 
If the goal is to survive as long as possible, wouldn't the ideal strategy be to move along the longest space-filling loop that fits in the map, and repeat that path forever? Maybe I'm overlooking something, but the strategic depth of this game seems low.
Maybe not ;) Swi has a lot of 'modern' features and I use it for general purpose stuff all the time! 
Funny, I read the same in a tweet few days ago. I'm learning Prolog recently and I really love the paradigm shift, and consider it so refreshing compared to most other languages, that to me it is "modern". That guy is quite knowledgeable (wrote dense articles about spline/nurbs curves) and said he spent his life on Prolog so .. I have to reconsider.
Note that Prolog variables start with an upper-case letter **or an underscore**! The latter is useful if you are teaching Prolog in China or Japan, for example. Note also that in Prolog, lower-case entities are **atoms**, so variables must be distinguished from this. And note especially that most other programming languages do not even *have* variables in the logical sense. In other languages, an atom is a container for a single fixed value. But in Prolog, this is not so: A variable in Prolog is *actually* a variable in its logical sense, which stands for "anything at all". A variable in Prolog can be *partially* instantiated, and so variables in Prolog are much more general than in other languages. In logic, uppercase variables are indeed sometimes used, and Prolog follows this notation.
&gt; In logic, uppercase variables are indeed sometimes used, and Prolog follows this notation. This may be the answer. When I studied logic, it was all x and y in lower case. If I go to https://en.wikipedia.org/wiki/Mathematical_logic, it seems to use x and y. If I go to its French translation, it uses P and Q. Maybe it's a French thing? More searching around shows that there's a huge variance in logical notation. Edit: this [Wikipedia page](https://en.wikipedia.org/wiki/Propositional_calculus) isn't even consistent with case in the same page.
Those I know that do Prolog all use SWI. I have no idea what licensing looks like for biz use, tho.
You grounded ra/3, but then asked ra/2. So it returning false is correct.
How it would correspond logically *to what*? The thing in your sample code is a statement of fact. You are saying "the tuple `(da,da,la)` is a member of the set `ra/3`". But your sample code contains no complex terms, just simple atoms (namely `da` and `la`).
You have been given this some serious thought... what would you recommend to use for Prolog (self)study? Clocksin &amp; Mellish is mentioned a lot, the Learn Prolog Now site is behind its book and has a not so enthusiastic review.
First I'd suggest that you use an accumulator in the last predicate. Something like: calculate_days_between_months(Month, Month, TotalDays, TotalDays). calculate_days_between_months(Month1, Month2, Days, TotalDays) :- \+ Month1 = Month2, days_in_month(CurrentDays, Month1), Subtotal is CurrentDays + Days, NextMonth is Month1 + 1, calculate_days_between_months(NextMonth, Month2, Subtotal, TotalDays). You can then call the new predicate with Days set to the first partial month and add the final partial month. If you want to get rid of the math-related "imperativeness" you could use constraints. Most prologs have some sort of library for this and using them generally gives you more flexibility. I don't know how you'd implement your predicates so that you could go backwards as well off the top of my head but it should be possible.
The best resource I have seen for learning Prolog is the **GUPU** teaching environment by Ulrich Neumerkel. If you are interested in trying it out, please PM me, and I will see what I can do.
First things first: Most Prolog books are outdated, so do not let outdated material confuse you. Your observation is very correct, no matter what a book says about this! This is currently very imperative. +1 for trying to make your program more **declarative**! So, what is the reason that this feels so imperative? A very important reason for this is that you are in fact **using imperatives** in the **names** of the predicates! Names like `calculate_...` *start with an imperative*, and automatically suggest only *one direction of use*. However, the whole point of Prolog is that you can use pure relations in **several directions**. Obviously, the imperative names no longer make sense in other directions. For example, assume the distance in days is already *given* at the time the predicate is called. It does not make sense to say we "calculate" it then. Instead, in that case, we can think of it as a "test" of a property. To avoid such issues, first and foremost use names that make sense in **all directions**, using primarily **nouns** and **adjectives** that state *what the arguments are*. Next, what about **generality**? When I study a Prolog program that I have never seen before, I always first try the **most general query**, to see what the predicate responds in the most general case. In this example: ?- calculate_days_between_months(M1, M2, D). ERROR: is/2: Arguments are not sufficiently instantiated Exception: (7) calculate_days_between_months(_6426, _6428, _6430) ? abort So the most general query **does not help at all** in this case, because you are using language primitives that are **moded** and only work in particular very specific situations. The way out is to use **more general** language features *instead*. I show this using the example of `days_between_months/3`. Note that at the same time, I have *changed* the name to a more declarative one: days_between_months(Month1, Month2, 0) :- Month2 #= Month1 + 1. days_between_months(Month1,Month2, Totaldays) :- Nextmonth #= Month1 + 1, days_in_month(Newdays,Nextmonth), Totaldays #= Subtotal + Newdays, days_between_months(Nextmonth, Month2, Subtotal). In this case, I have simple replaced low-level integer arithmetic with **CLP(FD) constraints** to make the solution much more general. Also, note that this is now **tail recursive**! Example: ?- days_between_months(M1, M2, D). D = 0, M1+1#=M2 ; M1 = 0, M2 = 2, D = 31 ; M1 = 0, M2 = 3, D = 59 . So the most general query now **yields answers** that help us to understand the predicate better, even if we know nothing else about it! Thus, we are using Prolog to really ask queries about the described solutions: Are there such and such solutions? "Yes, **if** ..." I leave generalizing the other predicates as an easy exercise. Note that your solution **incorrectly** cuts away valid answers if you use more general queries, due to your use of `!/0` which almost always *destroys* important declarative properties of your programs. *Remove the cuts* to obtain a more general program! In summary, to make your program more declarative and general: - use **declarative names** - use **CLP(FD) constraints** instead of low-level integer arithmetic - **remove all `!/0`** to avoid cutting away valid answers. 
I must confess I was debating that very reasoning when I wrote my reply, and then decided that it would be obvious there is only one thief. But, looking at the text again, indeed, the text is such that it is not explicitly excluded that several thieves could have worked together. 
ok just so I understand this correctly: doing the recursion in calculate_days_between_months with an accumulator would just make it tail-recursive, not much else right? Tail-recursive is very good in general of course, but since a year has a maximum of 12 months I deemed that not really relevant in this case. But if there is also another advantage I'd love to hear that
This is so awesome, I am beginning to fall in love with constraints. I did some reading on CLP(B) and came up with this: sat(A#B#C#D#E) tested it and it works! ?- thieves(List),labeling(List). List = [0, 0, 1, 0, 0]. edit: ah now I better understand what labeling is for. Of course that is no longer necessary in this case: ?- thieves(List). List = [0, 0, 1, 0, 0].
I don't understand the difference between complete and incomplete solvers, but I do see that sat(A#B#C#D#E) is not what I hoped it would be. I tested it only within the program, and then the program results in only the version with one thief, so I had, too soon, concluded I had succeeded. When I play with this expression interactively indeed, it does not work as intended and I understand now why. (The # operator works on the two elements left and rigth of it, it is maybe left associative or right associative, I don't know, but in any case it will not check them all in one go). It took me an embarrassingly long time but my next go at it is this: sat(card([1],[A,B,C,D,E])) seems to work 'solo': ?- sat(card([1],[A,B,C,D,E])),labeling([A,B,C,D,E]). A = B, B = C, C = D, D = 0, E = 1 ; A = B, B = C, C = E, E = 0, D = 1 ; A = B, B = D, D = E, E = 0, C = 1 ; A = C, C = D, D = E, E = 0, B = 1 ; A = 1, B = C, C = D, D = E, E = 0. and in the program: ?- thieves(List). List = [0, 0, 1, 0, 0]. as such :- use_module(library(clpb)). exactly_one_true([X,Y]) :- sat(X#Y). thieves([A,B,C,D,E]) :- sat(card([1],[A,B,C,D,E])), maplist(exactly_one_true, [[~E,B], [~C,~E], [E,~A], [C,B], [D,~A]]). 
Regarding CLP(FD) in general, the exact details differ slightly between various Prolog systems. For example, you **do not have to import** any libraries in systems like GNU&amp;nbsp;Prolog and B-Prolog. The more you and others use CLP(FD) constraints in your programs, the easier it will be to convince vendors to **enable them by default** also in other systems. So, please contribute to these developments by using such features! If you get sufficiently serious about constraints, you will eventually arrive at SICStus or a similarly powerful system. Until then, you can use one of the free systems to learn the basics. The more advanced your constraint programs become, the more you will run into inherent limitations of less advanced systems. For a recent example, please see the following question and the references included in the answers: http://stackoverflow.com/questions/39994779/duplicate-constraints-in-clpfd-and-with-dif-2 About your other questions: Using `!/0` almost invariably leads to **loss of solutions**. In your specific case, this problem was overshadowed by low-level primitives that already inherently limited the generality of your code, and at least these primitives led to an *instantiation error* instead of failing silently. However, as soon as you use more general predicates instead, `!/0` will incorrectly commit to one of the branches. In general, your use case is a textbook example for using CLP(FD) constraints, as always when **integers** are somehow involved. In SWI-Prolog, you can use constraints like `zcompare/3` to reflect a comparison to one of the **atoms** `=`, `&lt;` and `&gt;`, which you can in turn use for pattern matching. This approach **combines** efficiency with generality. See also the newly discovered meta-predicate `if_/3`! Regarding books, my personal recommendation is *The Art of Prolog* in combination with *The Craft of Prolog*, always keeping in mind that more recent developments are not covered in either book. In particular, you should know about: - `dif/2` - `library(pio)` - and, of course, **CLP(FD)** for integer arithmetic. The link you found contains more information about these features, as well as answers to all your other questions. Well, possibly excepting one.
&gt; should return true when J is found in Puzzle is different than : &gt; But why does it not return true **each** time it hits a 0? What I would do is *something* like this : in_my_maze(_,[]):-fail. in_my_maze(J, [H|T]) :- member(J, H). in_my_maze(J, [H|T]) :- in_my_maze(J,T). The idea is: check if it is in the head, if yes return true - otherwise continue executing (the second definition of in_my_maze which will now use the next list, after the previous head). If you reach an empty list, J does not appear in your list of lists. If you want to count how many times you encountered a J, add a accumulative counter in the definition of in_my_maze. 
This definitely seems very OK. It will run verbatim for example in GNU Prolog and B-Prolog. If you try this for example in SICStus Prolog, you need to add: :- use_module(library(clpfd)). at the beginning of the file. Also, one tip: Consider using `(#=)/2`instead of `(is)/2`, to make clear that you are reasoning over integers.
I'm getting "Error establishing a database connection" :'(
Hhmm, can you post the full output that you're getting? Edit: Oops, for some reason I thought you meant you were getting that in Prolog and was really confused. I hadn't realized that the site was down, but it should be back up now!
When putting code on Reddit, prefix each line with four spaces. That will format it appropriately. Reformatted: teacher(stan, discreteMath). teacher(kim). teacher(tim). course1(discreteMath). course1(introductoryProgramming). course1(dataStructures). course1(advancedProgramming). course1(artificialIntelligence). course2(daspstat). course2(linguistics). externalTeacher(teacher, department). department1(X):- course1(X). department2(X):- course2(X). competent(teacher) :- department1(X); department2(X). externalTeacher(X, Y) :- teacher(X), competent(Y).
So a few thoughts: * You have defined a `teacher/1` and a `teacher/2`. That's perfectly valid, but also likely not what you wanted. * Check that you are getting variable and term casing correct. Variables have to start with a `Capital` letter, while terms start with a `lowercase` letter. * You should check your warnings. In SWI-Prolog, the rule `competent(teacher) :- department1(X); department2(X).` gives the warning "Singleton variable in branch: X". That warning is there to help you; figure out why Prolog is emitting that warning and figure out why that's likely a problem. Give it another go.
That's correct. This first time through the list, it finds the 2 and returns true. When you hit semi-colon, it backtracks and attempts to find *another* solution. Since there isn't another one, it returns false. If you try ?- member(2,[1,2,2,3]). you'll get true ; true ; false. because it finds both solutions and then fails to find a third.
Thanks a lot! 
Sodoku
I've been working with programming languages a lot, and I've found logic programming really good for prototyping languages. You can set up simple parsers and code generators pretty quickly. 
From my experience with this, I *strongly recommend* to **decouple** the Prolog and Java components. By this, I mean that you write the Java part in Java, and the Prolog part in Prolog, and use for example **sockets** to communicate between the two. Recent Prolog systems often have capabilities to process and produce **HTTP**, and I recommend to simply use a web interface for communication. Any tighter integration is a source of many potential problems, since both Prolog and Java want to apply memory management (garbage collection) and handle signals, and if you combine the two in the same process, you will likely end up with some obscure and very hard to debug issues. In comparison, f you simply decouple the parts and use a well-defined protocol to communicate between the two, you can use each of the languages where it is strongest, and test both parts in isolation. Look at **Pengines** in SWI-Prolog for a well-defined and definitely very recent web-based API. Other Prolog systems like SICStus also offer interfaces for sockets for other ways of communication.
That is a nice approach - we use this method with Sicstus to run lots and lots of business - rules, and being decoupled feels like an advantage I've been toying with generating prolog - synonymous c# code as well (built on the p# project), but got sidetracked with other stuff - something similar to p#, for Java (IIRC) is Prolog Cafe Edit: I also translate automatically through reflection, anything that passes between c# and prolog, between. Net classes and a json-like representation which is handy for prolog to work with. Simplifies things :) 
It does use unification.
There are several problems with this, compounded by an imperative wording of both the task description and your comments. I start from a clean declarative description. Let us consider: What is the *last* element of a list? It's rather easy: Suppose we already *have* a relation `list_last/2` that relates a list `Ls` to the last element `L`. How can we use this as a building block to reason about all kinds of lists? When reasoning about lists, it is often useful to distinguish **two cases**: * *empty list* `[]` * and list with at least one element: `[X|Xs]`. In our case, the relation *cannot* hold for the empty list, so this is an example where the general pattern fails us. But we can still figure out cases that definitely **hold**. For example, if the list consists only of a single element, i.e., it has the form `[X]`, then `X` is the *last* element. Second, suppose `list_last(Ls, L)` holds, *then* `list_list([_|Ls], L)` **also** holds. In other words, if we know the last element of a list `Ls`, then we also know the last element of the list `[_|Ls]`. So, in Prolog, we can write this as: list_last([X], X). list_last([_|Xs], Last) :- list_last(Xs, Last). Example query: ?- list_last([a,b,c], Last). Last = c ; false. And now the point: This relation holds in **all directions**. We can use it *not only* in cases where the list is instantiated, but also to **generate** answers in much more general cases! Example: ?- list_last(Ls, Last). Ls = [Last] ; Ls = [_G788, Last] ; Ls = [_G788, _G791, Last] . So, when programming in Prolog, also think about general cases and different instantiation patterns. The wording of your task and your comments should reflect this! Think about what *holds*, and write this down in Prolog!
Thank you for help. I honestly think I'd understand this stuff better if we were introduced it a different way (since background in java doesn't help me tremendously here). :) 
Welcome to the club! When programming in Prolog, you will fare best if you ask yourself: **When**, i.e., under what **conditions** does the relation *hold*? The body of each clause describes the conditions for *that* clause, and clauses of the same predicate denote logical *alternatives*. A good **naming convention** also helps a lot. For example, in your case, you must keep in mind which argument describes what: Which is the list, and which is the last element. A name like `list_last/2` makes it easier to keep this in mind.
That's just not how prolog works. member's second argument is a list, and movie(_,X,_) is not a list. You have to query movie(_,title(X),_),member(of,X).
There are a couple of issues here: * Using **movie(..)** embedded in another predicate does not treat it as a "call" to that predicate - Prolog just treats it as a passive term. You need to pull the reference up into a separate predicate query. * You need to unwrap the **title(..)** term to access the word list before passing it to **member**. Thus, this query works: movie(_,title(Words),_), member(of,Words). The first query pulls out the title words as the variable **Words** for each movie (a different movie each time back-tracking occurs).
Your TA is referring to a solution using tail recursion.
Can you show me how?
I didn't realize there was a difference. Thanks
Also you can write foo(X, Y, X) :- Y =&lt; 0. foo(X, Y, Y) :- X =&lt; 0.
You're calling factorial(N,F) with N unknown, F known In the first line of the predicate you check if N&gt;0. But N is still unknown, so Prolog doesn't know if the inequality holds. That's what it's saying: I need to check the value of N, but N is not instanciated. You can check with trace and guitrace where your the program gives an error btw
`is/2` only works one way, which is to say in a query of the form `A is B`, `A` may be variable, but `B` must be ground. If you want it to work both ways, use `clpfd` and the `#=/2` predicate: :- use_module(library(clpfd)). factorial(0,1). factorial(N,F) :- N in 1..2147483647, % between 1 and max int N1 #= N - 1, factorial(N1,F1), F #= N * F1. I'm on mobile, so I haven't tested this. **edit**: typo
Now i can see that, thanks for pointing that out.
Any way to read this for free? I searched arXiv for "RenalDB" with no luck.
BiB has a two year embargo, so I can't host it anywhere publicly. I can send you a copy if you PM me an email address. 
`whatDoYouFindEasierToReadThanMixedCaps`? `maybe_names_with_underscores_instead`? Therefore, I first suggest more readeble **names**. The convention in Prolog is to clearly indicate what *each argument stands for*, and separating these descriptions with **underscores**. Therefore, let us start with: n_square_roots(N, Squares, SquareRoots) :- numlist(1, N, Squares), maplist(sqrt(0.001), Squares, SquareRoots). Key features: 1. **readable name** 2. **no side effects** Why is (2) important? Because: If you only print your answers on the terminal, how are we supposed to **test** such a predicate? How do you write unit tests, how do you check for regressions, how do you compare different versions? How do you use such a predicate in other or more general cases? In Prolog, we use predicates to describe **relations** between arguments. Therefore, we *avoid* simply emitting text on the terminal. We use predicate arguments *instead*. We proceed, again using a more readable **name**: sqrt(E, A, Y) :- X is A * 0.5, Y0 is (X*X + A)/(2*X), sqrt_loop(E, A, X, Y0, Y). The loop can be simplified like this: sqrt_loop(E, A, X, Y0, Y) :- ( abs(X - Y0) &lt; E -&gt; Y = Y0 ; Y1 is (Y0*Y0 + A)/(2*Y0), sqrt_loop(E, A, Y0, Y1, Y) ). Note that there is no need for goals like `X0 = Y0` or `X0 is Y0`. Simply use `Y0` **instead** of `X0` in such cases. The if-then-else has made `once/1` unnecessary. In addition, it has eliminated a flaw in your logic, in that you only checked for "greater than" and "less than" but not "equal to". Sample query and answer: ?- n_square_roots(5, S, Qs). S = [1, 2, 3, 4, 5], Qs = [1.0000000464611474, 1.4142135623746899, 1.7320508100147274, 2.0, 2.236067977915804]. I leave making this **more general** by using CLP(R) or CLP(Q) **constraints** as an exercise. In Prolog, use constraints to reason about arithmetic in all directions. At the very least, consider switching to **rational numbers**, to get rid of the nasty floating point numbers.
Thanks so much for the comprehensive reply!
This sounds like a homework problem, so I'll only gently nudge you toward a solution. First of all, make sure you understand what is meant by "recursive solution" and "efficient solution". You'll want to look up what tail calls and accumulators are and what they do to the efficiency of your program. In your case, it would probably be easier to find the recursive solution first, then figure out how to adapt that to the efficient solution. Now, in both solutions, you can break the problem down. You could start by writing a predicate that uses recursion to remove just the first occurrence of an element from a list. Armed with that, you should be able to adapt it to remove all occurrences from the list. And then you should be able to make it more efficient. The trick to recursion is to make sure you're always working toward some sort some sort of base case. When you're doing list processing, you want each recursive step to process ever smaller lists, until you eventually are processing the empty list.
What does imp, ou and e mean? Did you define them as binary operators somewhere?
You could look at [=..](http://www.swi-prolog.org/pldoc/doc_for?object=\(%3D..\)/2) to break down compound terms. What would you do if I provided a list like `[P -&gt; foo(X, Y)]`? Would you expect `[P, X, Y]` or `[P, foo(X, Y)]`?
You have simply used a way to output the data that can easily trick you to misinterpret it. Try the following query instead: ?- easy(T), gizmo(M,T), format("t: ~w, m: ~w\n", [T,M]), false. This yields: t: 1, m: a t: 2, m: a t: 3, m: b t: 3, m: c t: 3, m: a Note the use of `format/2` to conveniently print the data in any format without so many different goals. And, better yet, **avoid side effects** entirely, and simply ask Prolog: ?- easy(T), gizmo(M, T). T = 1, M = a ; T = 2, M = a ; T = 3, M = b ; T = 3, M = c ; T = 3, M = a. Here, **the toplevel prints the answers for you**, there is no need to print it yourself! From this answer, you clearly see the different cases, and the order in which they appear in answers. For more complex cases, you will find it harder and harder to understand the precise mechanism in such low-level detail. My recommendation is to focus on **declarative** properties instead. For example, are there any solutions? How general can you make them? What can you say about the termination properties of your code etc.?
Please consider the following query and answer: ?- T = 2, gizmo(M, T). T = 2, M = a. This shows that the query is actually **deterministic**, and hence no backtracking occurs after reporting the single solution. Why? Because, in short, the Prolog system is more intelligent than you think: It has dynamically constructed an **index** on the second argument of `gizmo/2` (because it was instantiated), and has used efficient hashing or a fast scan to determine that only a single solution can occur in this case. Therefore, the "naive" execution trace that is purported in old Prolog texts no longer does justice to what modern systems offer... This is exactly the case that occurs in your example: The system is smart enough to detect that `gizmo/2` need not be tried again. Note that other Prolog systems may implement different indexing schemes. In modern systems, JIT indexing is quickly becoming the standard, and YAP, SICStus and others offer it automatically. See your Prolog system's documentation for more. Also, in SWI-Prolog, try the **graphical tracer** with `?- gtrace, your_goal.` to see where choice-points are created, and where they are automatically *avoided* due to indexing.
Thank you so much for such a detalied answer! 
You're welcome! My recommendation is to not get stuck with such low-level details. Let the Prolog system do the tough work for you, so that you have time to focus on more interesting aspects of the language, at least for now! Focus on a clear, declarative task specification, and see how far it takes you. Then, if you would like to make your solution faster, there will still be plenty of time to discuss how you can do this!
With CLP.
A much better, more readable and more **portable** solution is to add the following directive to your program: :- set_prolog_flag(double_quotes, chars). With this setting, the following equivalence holds: ?- "abc" = [a,b,c]. This is extremely nice and convenient, and works in SICStus, YAP, SWI etc. In contrast, using "strings" is not ISO Prolog and will tie you to a specific dialect of Prolog. With this setting, you can leave your code completely unchanged!
Thank you! That's great, and really appreciated :) I also made use of `atom_chars(..) ` so that it accepts atoms as input too, is there a way to achieve this in a portable way? **Edit: looked it up, and `atom_chars/2` is ISO**
Thank you.
While I did think of that, I run out of stack space if I don't help out by starting with a closer state. I also tried to enlarge the stack, but that didn't work. Would rearranging the order of the transitions help with this? **Edit: yes it does!!** Thanks for the suggestion, I'm having way too much fun with this!!
Rearranging the clauses will only help in some cases, while others will still loop. To really guarantee completeness, you need to implement a **complete** search strategy, like *iterative deepening*. This is extremely easy in Prolog, if you simply use `length/2` in front of your query: ?- length(Cs, _), start(State0), dfa(Cs, State0). Here, `Cs` is first instantiated to a list with *increasing but fixed length*. `dfa/2` will only try to find solutions up to the specified depth. This guarantees that the search is complete: If there is a solution, you will find it, no matter how complex it is and how many cycles there are in the automaton. Note how easy it is to turn the incomplete search strategy of Prolog (depth-first with chronological backtracking) into a complete one! +1 for keeping everything pure, and therefore very general, usable in multiple directions! Iterative deepening works correctly as long as you stick to the pure and **monotonic** subset of Prolog, which you are doing!
A good way to learn more about any Prolog predicate is to first try the **most general query**. This means that all arguments are fresh *variables*. Declaratively, this simply asks: "Are there any solutions whatsoever?" The Prolog engine will reply with answers. For example, in your case: ?- fib(N, X). N = X, X = 1 ; N = 2, X = 1 ; ERROR: Out of local stack This is obviously undesirable, and shows an additional problem with this definition. To build a *memoized* version of `fib/2`, first start with a clear definition that is most straight-forward to you. For example: fib(0, 0). fib(1, 1). fib(N, F) :- N #&gt; 1, N1 #= N - 1, N2 #= N - 2, fib(N1, F1), fib(N2, F2), F #= F1 + F2. (This uses CLP(FD) constraints, which you can use by simply adding `:- use_module(library(clpfd)).` to your programs or initialization file.) With this version, we get for the *most general query*: ?- fib(N, F). N = F, F = 0 ; N = F, F = 1 ; N = 2, F = 1 ; N = 3, F = 2 ; N = 4, F = 3 ; N = F, F = 5 ; etc. That's already a clear improvement, since it correctly emits the intended sequence. To add *memoization* for this, we use the **tabling** mechanism of your Prolog system. For example, in SWI-Prolog, we enable this by adding the following directives to the program above: :- use_module(library(tabling)). :- table fib/2. And now, the program also works for larger cases: ?- fib(500, F). F = 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125. There are ways to do memoization also explicitly within your program. This will become much easier for you once you know more about Prolog. For now, I recommend you benefit from the available features, and focus on clear declarative specifications.
The second version of put/1 looks correct. The first one doesn't. You're binding the first argument of location /2 to here(CurrentLocation), with CurrentLocation being a singleton. Avoid singletons. Why the other version wouldn't work I can't say. I suggest running a trace or just writing the variables to console to see what's going on. It shouldn't be hard to find where the problem is that way.
In addition to what LetMeHaveAUsername already said, I have one general comment on such so-called **impure** predicates: Using predicates (like `assertz/1`) that have such extreme side-effects as *modifying the database* will typically render your code very *imperative* and prevent you from using it in *all directions*. This means that you can no longer *backtrack* in such cases and expect the original contents of the database to be as they were before. That's unfortunate, because a major attraction of using logic programming in the first place is that exactly such reasoning is possible! Applying global state modifications makes that reasoning invalid, and introduces implicit dependencies that make your program *a lot* harder to understand and debug. A so-called **pure** way out is to think in terms of **relations** between entities, and making them available *explicitly* as predicate *arguments*. For example, to *move* something from location `A` to location `B`, you need to *relate* a state of the world *before* the move to a different state of the world *after* the move, like this: move_state0_state(Move, State0, State) :- ... This way, you ensure that your predicate remains usable *also in reverse*, and you can use this to query for example: **Which** move did I make to get to `State`? And also: What was the **previous** state, *before* I applied a move? And even: Which moves are possible **at all**? This way, you will be able to use your programs *much more generally*, and truly benefit from the declarative paradigm. Everything else is better called "logic hacking" instead of "logic programming", since it is so limited and imperative.
Thanks, that's useful, though I was motivated to do this to learn about lists in Prolog.
Hmm... I tried to trace the 2nd version (posted as code here on reddit), but to no avail. It syncronizes with `location /2` correctly and when i try to `put /1` something 2 times, first time it is true and then it becomes false. I also tried using `assertz` instead of `asserta`, but it still doesn't work.
It is correct behavior when you call put/1 twice with the same argument and it returns false the seconds time. In intuitive terms, once you put something away you don't have it it anymore. In probably more useful technical terms: Assume have(thingamajig) is true. When you call put(thingamajig) the first time, have(thingamajig) will be retracted. When you call it a seconds time have(thingamajig) will be false, and therefore retract(have(thingamajig)) will fail too, as that is how retract/1 behaves. Unless you re-asserted have(thingamajig) in the meantime, of course.
In my opinion, this particular example is too tough to start with when learning about lists for the first time. I recommend you start with a simpler exercise instead. The problem is that you need to immediately think about a **relation** between two lists, and in addition also relate the indices to their results. This quickly leads to quite a few arguments that are hard to keep track of when you are not used to it. Still, I give you a hint: You cannot simply write `fib(N-1, ...)`, because the term `-(N,1)` is **not** an integer. Instead, you must do it in two steps: First, relate the arithmetic **expression** `N-1` (i.e., the term `-(N,1)`) to its *result*, using for example the arithmetic **equality constraint** `(#=)/2`: N1 #= N - 1 Thus, you can use `N1`, which will be an **integer**, in your program. Note that using **constraints** gives you a lot of freedom in how you *order* your goals: You can essentially play with any order you like, and see how efficient different orders are. I recommend you use such constraints to at least give you a bit more flexibility, and avoid having to worry about too many different things at once.
The on-line version is a little more snazzy than the 7.3.16 I have installed. The predicate `trace` is your friend. Stick it in front of your query and you can step. In http://swish.swi-prolog.org/ under the solution menu in the query area you can select `Debug` which adds it for you. After playing with your predicates there were several problems. The first is your fib/2 resolves the second parameter as a number which will never match your attempt in the third definition of fib_mem/2 which is attempting to use a list. If you change that to invoke fib_mem/2 that is half the battle. Your second problem is your attempt to match `N - 1` in the third definition of fib_mem/2 against the facts above. The interpreter will attempt to unify the compound ground term with a constant number, e.g. `3 - 1` to the number `2`, which is always false. For your approach you will need to resolve the compound ground term using the `is/2` infix operator prior to the generic case of fib_mem/3. An example solution may look like: fib_mem(1, [1, 0]). fib_mem(2, [1, 1, 0]). fib_mem( Known, Set ) :- ground( Known ), compound( Known ), Resolved is Known, fib_mem( Resolved, Set ). fib_mem(N, [X, X1, X2 | Tail]) :- fib_mem(N-1, [X1, X2 | Tail]), X is X1 + X2. fib(N, X) :- fib_mem(N, [X | _]). There is probably a more logically pure way to resolve this problem in Prolog but I don't know it ;-). If you are concerned about the domain of fib_mem/2 or you like feeling sane you may want to trap cases where the first parameter is less than 1 and raise an error. Arguably you might want a few cuts in there to prevent stack overflows and backtracking where it will not make sense. (Edited: I fought the Reddit formatter and I won.)
In my experience, a lot of the confusion among beginners stems from inconsistent naming conventions as employed in this material and many other texts. For example, we have: `brother_of/2`, yet we have `parent/2`. **Who** is the parent in this case? The first or the second argument? Then, we have `student_of/2`, yet we have `father/2`. **Who** is the father? The first or the second argument? How could this be improved with a more consistent naming convention? For example: - `father_child/2` - `parent_child/2` - `brother_of/2` - `teacher_student/2`. This would make perfectly clear what each argument means in *each* case, and remove a lot of the confusion. This, coupled with a heavy focus on procedural properties (a lot of the text deals with **how** Prolog solves this, instead of **what** is actually guaranteed), very early introduction of `!/0` and incompleteness introduced by impure negation when most beginners will not even be able to fully grasp what the actual relations are denoting make it a rather tough read in my opinion, probably suited to very advanced Prolog programmers with a lot of experience in low-level details and a keen interest in the operational intrinsics.
This mistake would have been **immediately** obvious with a better naming convention. For example, `parent_child/2` is a **clear** name: It makes clear what each argument denotes. But `ancestor/2` is **unclear**: *Who* is the ancestor, the first *or* the second argument? Suppose you had used: person_ancestor(Person, Ancestor) :- parent_child(X, Person), person_ancestor(Ancestor, X). Then this would read: "**If** `Person` is a child of `X`, **and** `X` is an ancestor of `Ancestor`, **then** `Ancestor` is an ancestor of `Person`." That is obviously **not generally true**, so there must be a mistake in one of the goals. Note that it is *highly suspicious* that `Ancestor` appears at an argument position that does not necessarily denote an ancestor, and the naming convention makes this mistake extremely easy to spot.
K. Thanks.
Bratkos book does have clp(fd) and clp(r) in the latest edition so that is some progress for you! 
[removed]
You are currently setting `double_quotes` to `codes` in many of the source files. In SWI-Prolog, that is a good idea to get rid of the non-portable "strings". However, an even better option is to set `double_quotes` to **chars**: This results in much more readable answers from the toplevel. For example, with `double_quotes` set to `chars`, we have: ?- X = "abc". X = [a, b, c]. One very important feature that would improve *many* of your examples a lot is `dif/2`: Using `dif/2`, you can express **disequality** of terms in a completely pure and general way. You are currently using a lot of impure negations like `\+ trap(T)`, and this prevents you from **generating** answers. If you use `dif(T0, T), trap(T0)` instead, then your code can be used in more directions. A lot of the `!/0` and other impure constructs can be removed by using the newly found language construct `if_/3`. See the recent publication *Indexing dif/2* by Ulrich Neumerkel and Stefan Kral for more information. Several of these tasks could benefit a lot from CLP(FD) constraints, to make the solutions more general. Thank you for sharing, +1!
Thanks for the tips, they are very welcome! I agree that the `double_quotes` probably was a bit misused, I was personally quite confused with swi-prolog strings at first since I didnt remember them when learning prolog at school. I assumed that "string" always would be list of codes. For many tasks I really missed something like `$a` to mean the char-code of "a" like erlang have, that would have made my pattern-matching alot more readable since I could write `[$a,$b,$c|_]` instead of `[97,98,99|_]`, perhaps `double_quotes` to chars is the solution I was looking for. CLP is something I'm very excited about, I just need to make time learning it :) 
It's perfectly OK to set `double_quotes` as you did. The value `codes` is the default in all other Prolog systems. There is indeed a dedicated syntax to obtain the character *code* of a character: Use `0'C` to obtain the character code of the character C. For example: ?- X = 0'a. X = 97. However, this is a rather ad-hoc and illogical notation, breaking syntax highlighting and still tying you to *codes*. In contrast, If you set `double_quotes` to **chars**, you can simply use the **atom** `a` to denote the character: ?- X = a. X = a. and also: ?- "abc" = [a,b,c|_]. true. To get used to CLP(FD), simply use `(#=)/2` and `(#&lt;)/2` where you currently use `(is)/2` and `(&lt;)/2` to reason over integers. This can make your program *at most* more general, while retaining the same performance in practice.
Nice! I've been looking at some different approaches to doing Prolog in c#, and this is very interesting - I see you use some c# constructs that I am not familiar with :) I've been generating c# (from prolog business rules ) similar to that of PSharp, which also has some very clever tricks (and is also, supposedly, iso compatible), but this is more readable Hope I'll have time to look more at your system! Nice work! :) 
By the way - what kind of AI stuff have you made (/plan on making) with this? I like Prolog and do some gamedev, but haven't really come up with a need for Prolog-rules in my games.. sadly.. :)
Most of my AI work has been in Natural Language Processing, hence working on DCGs quite early in this project; and as a lot of typical techniques like A* search are probably more easily implemented imperatively, I'm currently focused on the procedural generation side. If I find any sensible AI engines I'll be adding them to the repo, but it's slim pickings so far. On a side note, I actually have an older project (https://github.com/FacticiusVir/Warm) which is a straight Prolog interpreter hosted in .NET.
As the name implies, `!/0` typically **cuts** away solutions. That is *almost always* extremely undesirable, and severely reduces the generality of your program in almost all cases. It is extremely hard, almost impossible, to use `!/0` in such a way that the resulting program remains logically sound. Your program is one example of this among countless others like it. For instance, in your case, you can no longer **read the clauses in isolation**, and no longer read them as *disjunctions*. Instead, you now have to take into account **procedural** phenomena that are extremely hard to understand (there are two independent control flows you have to consider), and the clauses are now subtly related, which requires you to read the whole program "at once". It also makes declarative debugging **impossible**, since you cannot simply apply declarative reasoning as you would expect in other cases. Operationally, `!/0` always **succeeds**, and significantly influences the search for solutions. There are countless books on this topic explaining it in painful detail, yet never managing to draw an adequate conclusion from this. In my personal opinion, a valid conclusion is that the construct should be *avoided* because it is too hard to understand, and different constructs should be used *instead*. You can imagine that this opinion is somewhat unpopular among those who are explaining such issues for a living, and also among those who have already invested a lot of effort into understanding such issues... Your second question is already much more interesting. First, `regardingYourCodeForLastElement`, you may find it easier `to_use_underscores_for_readability`. In `last_element/2`, you can pull unifications **into the clause head**, like this: last_element([E], E). In `element_after/2`, to "isolate the first element", you simply use **unification**. If you have a list `Ls`, its *first* element `First` can be related to the list like this: `Ls = [First|_]`. Note the use of an *anonymous variable* to state "anything at all". So, you can write: element_after(Element, After, [Element|Ls]) :- Ls = [After|_]. And more concisely, you can pull the unification into the clause head again: element_after(Element, After, [Element,After|_]). Note that this works in **all directions**: You can use it also to *generate* answers! Therefore, your wording "isolate the first element" warrants some reflection. How do we isolate an element that is not even there at first? A more declarative wording could be that we **relate** a list to its first element. If you are thinking procedurally, you will be tempted to stick `!/0` into many of your programs. This way, you can continue to write Fortran programs using the "Prolog" dialect of Fortran. However, to get a glimpse of the beauty that truly declarative programming allows, better keep your programs as general as you can! 
Ok! That could be interesting! - possibly something I could use to run input validation rules in some C#-capable client :) -Will have a look!
I found out about this site looking for Picat related items, but he covers other languages too: http://www.hakank.org/answer_set_programming/
&gt; (I hope this isn't off topic – r/prolog looked like the best fit for my question as ASP seems to come from a Prolog tradition) It is definitely not off topic. I'm not a mod, but when they un-orphaned this subreddit and redid the sidebar, we agreed we should be as open as possible to all things related to logic programming, because the community is so small; it's not like we'll ever be flooded with content. That's why ASP is specifically mentioned in the sidebar as on topic.
Come to the freenode.net ##prolog channel. They live for stuff like this there.
I totally support this. ASP is an interesting declarative paradigm that has several relevant applications. Is is closely related to Prolog and of course logic programming in general. Definitely on topic! With some luck, the paradigm will also lead to a greater appreciation of declarative features in Prolog!
That's an awesome resource, thank you for sharing this! The page has moved to a more recent location though: https://potassco.org/ The source code is available from: https://github.com/potassco/
/user/gurzil has already provided a very good answer, and has also used a very nice naming convention: planet_resources(Planet, Resources) This makes clear *which* argument is the planet, and *which* argument denotes the resources. I strongly recommend to stick to such a convention, at least for your most important predicates. That is, consider using: planet_exports(Planet, Resource) :- ... and also: planet_imports(Planet, Resource) :- ... This way, mistakes are much less likely, and using the predicates is easier for mnemonic reasons alone already. By the way: `:-` is meant to denote an **arrow from right to left**, and this readily shows that you accidentally reversed most heads with bodies in the code you posted. In your case, the core relations are `planet_imports/2` and `planet_exports/2`, and these must occur as *heads* when defining them.
In Prolog, a variable is truly a **variable** in the true sense of the word, and used as we know it from logic: A variable stands for *anything at all*. This is different from the majority of other programming languages, where a variable is always associated with some value. Thus, when you print a variable with `write/1`, you get output that again denotes a variable. For example: ?- write(X). _G840 Note that the original name of the variable is not important, and in fact the name of the variable is not accessible within the Prolog program. Therefore, the system emits again a variable, but with a different name. I can trick the system to emit the same variable name I am using in the query, but this only works by coincidence, and you cannot rely on it: ?- write(_G840). _G840 Note that the proper Prolog terminology is that a variable becomes **bound**, and a term (which may also be a variable) becomes further **instantiated**. A variable that is not bound is called **unbound**, and if it is also not involved in constraints it is called **free**. So, if you see a term like `[G2201_1]`, it means a list whose single element can be *any term at all*. If you print it, this still holds, but the variable name that is emitted may (and typically *will*) be completely different. Note that you must distinguish between a variable *name* and the term the variable is *bound to*. `G3232_3` is *still* a variable in Prolog, which is unbound, and logically, it stands for *any term at all*, just like `X`, `Y`, and any other variable.
Nice, but maybe you could also explain *why* alfreds_coach's code doesn't terminate and yours does, since both are logically correct.
Thank you, this is a very helpful answer!
You can suggest of course! We have a few ideas but nothing is set in stone yet :)
If you could show a hands-on example of an application that integrates with a SQL DB that'd be neat! 
Good idea :)
I would map colours and letters to integers and then use clpfd all_different constraint.
**Yes**, that's of course easily possible, using for example the ISO predicate `assertz/1`. Example: | ?- assertz((a(X):-b(X))). Of course, you also need a definition for `b/1`, so for example use: | ?- assertz(b(z)). Then you can query: | ?- a(X). X = z In addition, to construct `a(X)` if you only have the **atom** `a`, you can for example use `(=..)/2`: | ?- T =.. [a,X]. T = a(X) Use such features with **caution**: In particular avoid the temptation to use this so-called **dynamic database** for side-effects, such as simulating global variables. Using the database for this purpose destroys important properties of your programs, makes them a lot harder to test and reason about, and very likely also slower than necessary. The database is fine for *adding* data and frequently reading it, but not very well suited if you want to also frequently *change* or remove this data, since it entails **indexing**, and that takes time of course.
No. Predicate ordering is a fundamental part of the language paradigm.
The order of *predicates* **never** affects the result. You can write your predicates in *any* order you like in your source code, and the results will be exactly the same. You probably mean the order of *clauses* of specific predicates, or the order of *goals* within clauses. Which one do you mean? Personally, when I see a new Prolog program, I always first try the **most general query**. This means simply the query where all arguments are *fresh variables*. For example, in your case, I would try: ?- gamble(X). Ideally, the answers exhaustively tell me how any solution may look like *at all*. In your case, since you are impurely *committing* to the *first* solution, the answer will be quite disappointing: I will not be able to see *all solutions* in that way, even though I have asked for them! In fact, I will only ever see at most a *single* solution. That's clearly a major shortcoming of *both* versions you show. Even worse, the impurity means that a *more specific* query may unexpectedly *succeed*, even though logically, the answers of the most general query should be exhaustive. That's another major drawback, precluding powerful **declarative debugging** approaches which are applicable if your program admits a logical reading! To beneifit most from logic programming, a good guideline is to make your relations *as general as you can*, while retaining acceptable performance. In your case, there are likely ways to make this *much more general*, while also retaining efficiency in simpler cases. However, we need to know more about your code to be able to say *how* you could achieve this, because currently we only get for the most general query: ?- gamble(X). ERROR: Undefined procedure: gotmoney/1 
Ah yes, I meant clauses. As for my example, I wouldn't read too much into what it does-- I just made it up as an example of a predicate that will behave *differently* depending on the order of the clauses. So my question is: **should we try to write predicates that behave the same regardless of the order of the clauses?** From my experience, this might require inserting otherwise redundant goals, but may improve readability in the sense that each clause can be interpreted separately.
Under a declarative reading, the order of *clauses* makes of course no difference, and in many cases, it also makes no difference in practice: For example, think about all applications where Prolog is mainly used for storing huge amounts of **facts**: The order of these facts makes no or very little difference. However, for recursive rules, different clause orders will *typically* yield different termination properties. In general, it is good practice to **put facts first**, and rules after that. The order of recursive rules among each other should, and typically also *doesn't*, make any difference, so you can again place the rules as you like, at least as long as your predicates are reasonably pure. This all breaks down if you are using `!/0` in your programs: Cuts **destroy** these properties, and if you use `!/0`, then you truly can no longer read the clauses in isolation, and their ordering will become absolutely critical. This definitely *harms* readability of your code, since you then have to take into account more rules at once, which is typically too much to think about. Instead of `!/0`, consider using more local constructs, like if-then-else. That's at least somewhat easier to understand, though still comes with severe drawbacks. For example, it still harms the general case, and therefore the flexibility of your code, in that `(-&gt;)/2` impurely *commits* to the first solution. In my opinion, the best approach is to first and foremost focus on a **clear declarative description** to benefit from its readability and generality. For example, in your case, you could simply state the two possible cases: gamble(X) :- has_money(X). gamble(X) :- has_credit(X). This is much easier to read, and *much more general* than what you had. **If** you need it, you can *still* destroy completeness of any query, by simply using `!/0` **in the query**, instead of messing up your code with it. In fact, to more clearly express this, I recommend to use `once/1` in such cases *instead* of `!/0`. So, you can write: ?- once(gamble(X)). and *still* enjoy the experience of incorrectly losing the second answer.
Ah OK. That makes sense. In that case, I would refine my question to cases that we *only care* about a single answer. Let me give a better example: first_letter([Curr|_], Curr):- char_type(Curr, alpha),!. first_letter([Curr|L1], A):- \+ char_type(Curr, alpha), first_letter(L1, A). first_letter([], ''):-!. Now, in the second clause, the goal "\+ char_type(Curr, alpha)" is not strictly necessary (assuming this order of the clauses). By removing this goal, we can make the predicate more concise without affecting the output.This is a toy example, but you can imagine cases in which you could make the predicate a lot more concise, at the expense of a clear declarative description. Is this ever a good idea? Should we always favor the clear declarative description, even if it makes for a longer and more verbose predicate?
The key question, in my view, is: **How can we have both**, i.e. a declarative description that is *also* concise. Let us stick to the above example. First of all, is it *declarative*? **No**, obviously not, because we have: ?- first_letter(Ls, L). Ls = ['A'|_17674], L = 'A'. This **incorrectly** says that there is *only* a single solution, because it *impurely* commits to the first clause in this most general case. Second, is it *concise*? **Not so much**, because the following version is almost equivalent *and* shorter: first_letter(Ls, L) :- once((member(L, Ls),char_type(L, alpha))). Note that this version simply *fails* for the empty list. (In my view, that's preferable, because if there are *no letters at all*, we cannot with a straight face say that the first letter is `''`.) The key question is now: Can we have a version that is concise, general *and* efficient? For a start, please consider the following version: first_letter([L0|Ls], L) :- if_(talpha(L0), L=L0, first_letter(Ls, L)). talpha(L, T) :- ( char_type(L, alpha) *-&gt; T = true ; T = false ). This uses `if_/3` from Ulrich Neumerkel's [`library(reif)`](http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/sicstus/reif.pl) to combine generality with good performance. Here is an example query: ?- first_letter([a,b,c], L). L = a. So this case works as intended. Interestingly, the **most general query** now *also* yields at least a few solutions: ?- first_letter(Ls, L). Ls = ['A'|_23200], L = 'A' ; Ls = ['B'|_23200], L = 'B' ; Ls = ['C'|_23200], L = 'C' . That's definitely an improvement over simply committing to a single solution in such cases. This improvement has become possible due to the use of the purer *soft&amp;nbsp;cut*, `(*-&gt;)/2`, which admits multiple solutions on backtracking instead of mindlessly cutting into the sequence of solutions. It's still not perfect though! For example, we can easily show that this version still *incorrectly terminates*, although we expect the existence of arbitrarily many answers: ?- first_letter(_, _), false. false. This query shows that `first_letter/2` **terminates**, although it should not, in the general case. I leave fixing this as an exercise for you. Note that so far, the purer and more declarative program variants were either *more concise*, or only *marginally* longer than the versions which were more imperative and more limited. Thus, I can only recommend to first of all focus on a clear declarative description, and aim to make that as readable and general as you can. In almost all cases when programming in Prolog, the most elegant solution is *also* among the most efficient.
Sounds like monoids in Haskell
Let us tackle it in **stages**. First, here is a properly *formatted* version of your code: end_result(NaturalNumber, [List]):- between(1, NaturalNumber, BetweenNumbers), relative_prime(NaturalNumber, BetweenNumbers), [List] is BetweenNumbers, X is NaturalNumber+1, end_result(X, [list]). relative_prime(X, Y) :- gcd(X, Y) =:= 1. Note that I also have replaced `End_result` with the lower-case version `end_result`, so that this even *compiles*. Next, you are faced with **unexpected failure**: ?- end_result(9, Ls). false. This is a **typical** problem for many beginners. As you have already observed yourself, *tracing* is an extremely **tedious approach**. In Prolog, we can do a lot better by applying **declarative debugging**. For this, I am using the following auxiliary definition: :- op(920,fy, *). *_. I can now use `(*)/1` to **generalize away** any goal in a clause. Since you are faced with a program that is **too specific** (it *fails* where it should *hold*), we definitely need to make it **more general**. Let us *try it out*, by **generalizing away** all constraints (= goals) of `end_result/2`: end_result(NaturalNumber, [List]):- * between(1, NaturalNumber, BetweenNumbers), * relative_prime(NaturalNumber, BetweenNumbers), * [List] is BetweenNumbers, * X is NaturalNumber+1, * end_result(X, [list]). With this version, we have: ?- end_result(9, Ls). Ls = [_6596]. Now that's at least *something*: It at last *succeeds*, though of course the program is now much **too general**. We now need to *pinpoint* the precise location of all errors. Let us start by picking a goal in the middle, and *enabling* it again: end_result(NaturalNumber, [List]):- * between(1, NaturalNumber, BetweenNumbers), * relative_prime(NaturalNumber, BetweenNumbers), [List] is BetweenNumbers, * X is NaturalNumber+1, * end_result(X, [list]). With this version, we have: ?- end_result(9, Ls). ERROR: Arguments are not sufficiently instantiated Now that's *too bad*! We cannot continue with *declarative debugging* because a strange non-relational predicate is in the way. Luckily, there is an easy solution for this: Simply use `(#=)/2` to reason over integer expressions via more general **constraints**. Thus, simply rewrite the code to: end_result(NaturalNumber, [List]):- * between(1, NaturalNumber, BetweenNumbers), * relative_prime(NaturalNumber, BetweenNumbers), [List] #= BetweenNumbers, * X is NaturalNumber+1, * end_result(X, [list]). See your Prolog system's manual for more information about `(#=)/2`. With this version, we get: ?- end_result(9, Ls). ERROR: Domain error: `clpfd_expression' expected, found `[_2734]' And now we have found at least **one mistake** in the program: The goal [List] #= BetweenNumbers, *cannot* hold, because `[List]` is *not* an integer! Using CLP(FD), we are lucky: It uses a **domain error** to tell us that this can *never* hold in a very straight-forward way that likely indicates a programming error. Thus, I would start with correcting this particular goal, and then apply the same technique (incremental generalization and specialization) to the remainder of the program to locate any remaining issues.
That's what I thought. I find that Prolog sometimes pushes the limits of what I'd view as "pure." Isn't it possible to implement arg, functor, melt and freeze in straight Prolog? It's been years since I've read Art of Prolog but I do remember a few of those being in there.
`arg/3`, `functor/3` and many other predicates like `call/1` can *in principle* be implemented in plain Prolog. However, you need an *infeasible* number of clauses to do this, so it is better to provide "native" support (either in your VM or via specialized predicates) for such features. Even the very first Prolog system, sometimes called Prolog 0, had the constraint `dif/2`, but this feature is not mentioned in the Art of Prolog nor in the WAM tutorial. (I wish it were! Currently, most beginners still use `(\=)/2` and typically struggle endlessly with its impure semantics.) Prolog has a **pure core**, which is comprised of the constraints `(=)/2` and `dif/2`, conjunction, disjunction, further constraints like `(#=)/2` etc. It also has several *impure* features, notably `!/0` and predicates like `assertz/1`. More recent programming languages like Haskell and Mercury are more advanced in that they more strictly and forcefully *separate* impure aspects from pure ones. In Prolog, this separation is happening more slowly, but still noticeably: In the last decade, more and more pure alternatives have been found for impure constructs that were until recently considered largely unavoidable. For example, even though `dif/2` has been available for decades, it was not frequently used in practice due to its leading to additional choice points that are hard to eliminate. The pure `if_/3` (see [*Indexing `dif/2`*](https://arxiv.org/abs/1607.01590)) was recently found as a suitable alternative in many situations of practical relevance. Another example is `phrase_from_file/2` to perform **pure I/O** in Prolog. One important building block for pure **integer arithmetic** is a primitive like `(in)/2`, which is an important extension that is mentioned and explained in publications by Danial Diaz: Using `(in)/2`, you can implement CLP(FD) constraints, and this lets you eliminate many impurities that beginners traditionally struggle with, mostly distracting from more important language aspects that could be taught instead in that time. If you are looking at more sophisticated extensions, I highly recommend the SICStus interface for so called **attributed variables**. If you provide `verify_attributes/3`as an engine interface, your users can implement powerful constraint solvers over arbitrary domains **within** your system. For example, `dif/2`, `when/2`, `freeze/2` etc. can all be implemented with this important primitive and extensions for reasoning about attributed variables. As I see it, the most important current developments of Prolog focus on finding and implementing the best **pure building blocks** that allow us to write general *and* efficient programs. In the past, the unclean intermingling of pure and impure features has been praised as the "duality" of Prolog by others. However, note that pure predicates *also* allow a *procedural* reading, but impure predicates generally *preclude* a *declarative* reading, so it would in my view be justified to regard the *pure* predicates, if any, as enabling a dual reading! I hope you will integrate some of these results in your new implementation, and I am looking forward to trying them out!
This goes to show how little I know of Prolog.. I wasn't even aware of `dif/2`. Some form of clp was always in the cards. You can't read Diaz without being aware of clp. I've made a note of everything you've mentioned (especially Indexing `dif/2`). The main intention behind my implementation is for it to be a fast, highly tuneable type checker for the Shen programming language. Shen is a hybrid functional/logic language that has Prolog as its logic engine, and since it carries the standard FP emphasis on purity, the purer the Prolog, the better.
Looks great. Are you familiar with yield prolog (http://yieldprolog.sourceforge.net/)? I wonder if there's some common features.
it is very very good.
Roughly half the 'power of prolog' comes from the 'power of logic programming' and prolog is by far not the only logic programming language, e.g., - You can do logic programming using minikanren in scheme. (you can also extend the minikanren system if you find a feature missing). - Minikanren was implemented in clojure and called core.logic. - It was also ported to python by Matthew Rocklin I think, called logpy. - There is also datalog, with pydatalog it's python equivalent. - Also pyke. And so on. Plus logic programming has very important (arguably necessary) extensions in the form of constraint-logic-programming (CLP), inductive-logic-programming (ILP), and so on. It's a huge area. ILP at an advanced level starts making connections with PGMs (probabilistic graphical models) and hence machine learning, but its a long way to go for me (in terms of learning) before I start to make sense of all these puzzle pieces. You can have a taste of logic programming without leaving your favorite programming language. Just try to solve the zebra puzzle (without help if you can, esp. through any of Norvig posts or videos; they're addictive): https://en.wikipedia.org/wiki/Zebra_Puzzle An "expert system" (a term from the 1980s) is largely a logic programming system paired up with a huge database of facts (and probably some way of growing the database by providing an entry method to non-programmer domain experts). In other words, logic programming (along with other things like graph search etc) is at the core of GOFAI (good old fashioned AI), the pre-machine-learning form of AI, chess engine being a preeminent example of it.
Can't you just post your questions here or something?
Some nice examples of Prolog used in industry here. 
I'm a Prolog beginner myself, so it's possible that everything I say is bullcrap. But hopefully I'm able to give some help. First, familiarize yourself with recursion and how to use it to parse through a list. For example: check([]) :- !. check([X|Xs]) :- write(X), check(Xs). will go through a list and print out each element from the list. (**edit:** By the way, the write/1 is there just for an example, so at least the code does something meaningful. It has no relevance considering your problem.) Then, you'll need some way to check if any given term is an integer or a float. Prolog has integer/1 and float/1 for that. For example: checkInts((A, B)) :- integer(A), integer(B). will return true, if both A and B are integers *and* they are enclosed by brackets. As far as I can tell, studying those two examples and understanding them are the building blocks you will need to solve the problem. 
Not sure if I follow... Let's run a test: ?- check(abcd). false. As expected, the answer is false, because the abcd is just a single "atom" and should not be interpreted as a list. An atom is... well, it's a piece of data and is recognized as such because it starts with a lowercase letter. An atom is not a variable, so Prolog should not even try to chop it or extract a list from it (or this is what I understand at the moment). With a list, the result will look like this: ?- check([a,b,c,d]). abcd true. So, to tell Prolog that you have a list, you will need square brackets. Also, square brackets are essential part of the recursion in my example, because they describe, how I want to treat the list, when one is passed to check/1 predicate. More precisely, this part: check([X|Xs]) This tells to Prolog to receive a list and extract the first item of the list and put it to the variable X. The rest of the list is kept as a list and placed to the variable Xs. What comes after :- is just a bunch of stuff, what we are doing with X and Xs. So, as you can see, I'll just describe the structure of the terms and what I want with them and Prolog takes care of figuring out rest. Prolog is a pretty smart language and it is easier to get into it, if you don't try to think too much, how it is doing things. Not at the beginning of the learning curve anyway. You'll have to learn about "unification", which is a bit like pattern matching in other languages (for example Haskell), but in reality is nothing like pattern matching. But I think that seeing unification as a pattern matching may help you to see better, what is happening in my check/1 example. And understanding, why there are two predicates with identical name, is essential in understanding, how Prolog works. Sorry, I derailed from your question. I suggest that you'll check this tutorial, it might be helpful: http://www.learnprolognow.org/lpnpage.php?pageid=online Especially the explanation of different data types, or terms: http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse2 And here is a lesson about recursion: http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse9 A chapter about unification: http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse5 
I am no expert, and only just started learning Prolog myself. That being said, I was able to finish this assignment in about 15 minutes. If you have any specific questions beyond "Will you do my homework for me?" I'd be happy to help.
This looks pretty good, some obvious syntax errors make me think you have not even bothered to run this, but some things to note... You are missing some periods at the end of rules. Ex. holidays:-day(friday), month(august) closed(office):-not(business_hours) Below you use holiday, when the name of the rule is actually "holidays" % If it's not the weekend or a holiday, it's a workday. workday:-not(weekend);not(holiday). % Fridays in August are holidays holidays:-day(friday), month(august). Something like this can be more clearly written as.. % The office is closed outside of business hours closed(office):-not(business_hours) ... % The office is closed outside of business hours not_business_hours:-not(business_hours). The (,) inside a rule is equivalent to AND, so rules like setting(X):- spring,fall,business_hours,X=70. Would read in English "Its Spring, and its Fall, and its business hours." So since it can't be both Spring and Fall... you'll need a OR instead.
Thanks a lot for your help! I made some changes; how does this look? %expert system to find thermostat setting at workplace. % expert rules % If it's saturday or sunday it's the weekend weekend:-day(saturday);day(sunday). % If it's not the weekend or a holiday, it's a workday. workday:-not(weekend);not(holidays). % Fridays in August are holidays holidays:-day(friday), month(august). % Business hours are on workdays from 9 to 5 business_hours:-workday,time(X),X&gt;=9,X=&lt;17. %24 hour time, midnight=0. % The office is closed outside of business hours office_closed:-not(business_hours). % Summer is the months of June, July and August, fall - September, October, and November, winter - December, January, and % February, spring - March, April, and May. summer:-month(june);month(july);month(august). fall:-month(september);month(october);month(november). winter:-month(december);month(january);month(february). spring:-month(march);month(april);month(may). % The thermostat setting in spring and fall, during business hours should be 70 setting(X):- spring;fall,business_hours,X=70. % The thermostat setting in spring and fall, when the office is closed should be 50 setting(X):-spring;fall,office_closed,X=50. % The thermostat setting in winter, during business hours should be 68 setting(X):-winter,business_hours,X=68. % The thermostat setting in winter, when the office is closed should be 45 setting(X):-winter,office_closed,X=45. % The thermostat setting in summer, during business hours should be 74 setting(X):-summer,business_hours,X=74. % The thermostat setting in summer, when the office is closed should be 85 setting(X):-summer,office_closed,X=85. % The following 3 can be changed for different answers month(august). day(friday). time(11). 
Prolog is different from most mainstream languages, and it's hard to wrap your head around. You have a lot of parameterless rules. For example: weekend :- day(saturday);day(sunday). (or rewritten) weekend :- day(saturday). weekend :- day(sunday). That's not necessarily wrong; it will compile and run just fine. But it's now how I would expect to see the rule expressed. Prolog inference rules typically have at least one variable that's common between the head and the body. Let me translate that rule to plain English. It looks like you're saying "a day is on the weekend if the day is saturday or sunday". We can split that into two parts, and rewrite it in pseudo-Prolog: A day is on the weekend :- the day is saturday. A day is on the weekend :- the day is sunday. We can easily rewrite this in proper Prolog: weekend(Day) :- Day = saturday. weekend(Day) :- Day = sunday. Note also that we can take advantage of Prolog's pattern matching facility to write that even more succinctly: weekend(saturday). weekend(sunday). Your program as written will handle exactly one day, in one month, at one time. And to evaluate for a different day, you'd have to change the program's source code (or dynamically modify the database, which is generally not recommended). Essentially, `day/1` is a global variable, and other rules (like `weekend/0`) are accessing that global variable. By introducing a parameter, you make it possible to check different days to see if they're a weekend. Along those same lines, your implementation of `setting/1` has a parameter to capture the output, but it too looks at the "global variables". You could potentially write that as: setting(Month, Day, Time, Temperature) :- ..., Temperature = 85. or, as we saw with pattern matching earlier: setting(Month, Day, Time, 85) :- .... 
Sure. Suppose your `udiv` was expressed as a relation with parameter names: udiv(N, D, Q) With this relationship: Q = floor(N / D) Consider some cases: % 0 / 2 == 0 udiv( 0, s(s(0)), 0 ) % 1 / 2 == 0 udiv( s(0), s(s(0)), 0 ) % 2 / 2 == 1 udiv( s(s(0)), s(s(0)), s(0) ) % 3 / 2 == 1 udiv( s(s(s(0))), s(s(0)), s(0) ) % 4 / 2 == 2 udiv( s(s(s(s(0)))), s(s(0)), s(s(0)) ) Are you starting to see the pattern? For every two wrapping `s` cells in the numerator, we want to add one wrapped `s` cell to the quotient. For any given denominator `D`, if you find at least that many cells in the numerator, you can remove them and increment the quotient. Try doing this for a fixed denominator. See if you can write a `udiv3(N, Q)` that computes `Q = floor(N / 3)`. Having achieved that, you can move on to generalizing for *any* denominator. That's the tricky part, but it should be easier if you have something like `udiv3` under your belt. As one more hint, consider using accumulators. In fact, try implementing `udiv3` both with and without accumulators. I think it's possible to implement the more general `udiv` without using them. But I think it's both more efficient and more readable to use them.
http://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/ 
Exactly the kind of thing I was looking for. Thank you.
Thanks for reminding me of that. I worked my way through several of them in other languages at one point.
Never mind.... I see now that this syntax requires the following import: :- use_module(library(clpfd)).
Thats right. Constraint libraries are not 'core' in Prolog generally (except for some specific implementations such as Eclipse prolog- highly recommended, by the way). Constraint programming adds a lot of extra goodies but increases the size of the distribution so separating them makes a lot of sense. 
You can't write things like X is X-1. That tells prolog that X is a variable equals to itself minus one. Which is why you get no as an answer. You need to use a different variable 
For one, factorial is a predicate with two parameters, but you're calling it with only one in the recursive case. factorial doesn't return its result in the traditional way (via substitution). When you invoke factorial(5, R), the result is returned by unifying R with 120 -- it relates its two parameters, just as a function can be thought of as relating its parameter and result. Therefore, in the recursive case, you have to relate the result of the recursive call with R, the current result. You might also want to replace is with a pure predicate like #=, but that can come later.
&gt; what would the syntax of the body of a rule length_of_path(X,Y) You're already barking up the wrong tree. Prolog facts and rules are relations. If you want to talk about the length of paths between nodes, then these relate three different values: 1. The start node 2. The end node 3. The length Your rule therefore needs three parameters, not two. If you're used to other programming languages, you're used to the idea of passing arguments to a function and getting a result out. Things are different in Prolog. Inputs and outputs are all passed as arguments, and in many cases individual arguments don't fall into those fixed roles. In pure relational logic, any parameter can be an input *or* an output. If your goal is to find the length of the shortest path between two nodes, then [breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search) is a good choice. Which is interesting, because Prolog naturally does a depth-first search, so you'll have to work against the grain.
Have you tried drawing your graph on a piece of paper? If you do, I think the answer will be clearer.
I have traced it multiple times but don't understand what the calls refer to.
You might try tracing it by hand. Your query causes the second clause of polarbear to be chosen. Filling in the variables: polarbear([1|[2]],6,[1|Z]) :- polarbear([2],6,Z). H, T, and Y are all known at this point, but Z is not. The goal that Prolog was trying to satisfy was your initial query; it is now what is on the right side of the `:-`, to determine Z. That's what you're seeing in the first two `Call` lines of the trace: the first line is your query, and the second is the right side of the clause whose left side the query matched (with P and Z replaced by generated variables). This continues until we reach the base case, which has only one variable, H, which you can see has been instantiated upon first `Exit`. Similarly, the other lines show what the variables in the corresponding `Call`s have been bound to. Using the graphical debugger might help; it did for me when I was first starting out.
thanks bro very useful will try and get my head round it :) 
so call 10 is then the right side again? 
What is the criteria for the splitting, two lists of length 3? two lists of equal length? one list of values 3 and under and the rest? It will depend on this how you will implement it. 
lists of 3 elements so if I had 9 elements, i would then get a list with 3 sublist elements
To group elements of a list: group(_, [], []). group(N, Flat, [Group|Groups]) :- length(Group, N), append(Group, Rest, Flat), group(N, Rest, Groups). For example: ?- group(3, [1,2,3,4,5,6,7,8,9], Structured). Structured = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]. ?- group(3, Flat, [[1,2,3],[4,5,6],[7,8,9]]). Flat = [1, 2, 3, 4, 5, 6, 7, 8, 9]. ?- group(N, [1,2,3,4,5,6,7,8,9], [[1,2,3],[4,5,6],[7,8,9]]). N = 3. #How this works The predicate `group/3` operates on three arguments: the group size, the flat list, and the structured list. The implementation consists of two clauses. The first clause is the base case. It says that the flat list is empty iff the structured list is empty, and the group size doesn't matter. ~~It uses the cut `!` to say that if this base clause applies, then the recursive clause does not apply.~~ **EDIT:** Don't use the cut. If you need semi-determinism, use `once/n`: `?- once(group(3, F, S))`. The second clause is the recursive case, consisting a three conjuncts. Let's break it down bit-by-bit. The head of the rule unifies the group size with the variable `N`, the flat list with the variable `Flat`, and the structured list with `[Group|Groups]`. This in turn unifies the first group in the structured list with the variable `Group` and the rest of the structured list with the variable `Groups`. Once we know how our arguments are bound, we can look at the body of the clause. The first predicate, ` length(Group, N)`, asserts that the size of the first group is `N`. The second predicate, `append(Group, Rest, Flat)`, is saying that `Flat` is equivalent to the concatenation of `Group` and `Rest`. Since `Group` is known to be a list of length `N`, then it will be bound to the first `N` elements of `Flat` and `Rest` will be bound to the rest. The final predicate recursively calls `group(N, Rest, Groups)` where `Rest` is the rest of the flat list and `Groups` is the rest of the structured list. Here is a trace of a simple execution which may help your understanding. The output has been slightly cleaned up for readability. ?- trace, group(2, [1,2,3,4,5,6], Structured). Call: (1) group(2, [1, 2, 3, 4, 5, 6], _1294) Call: (2) length(_1620, 2) Exit: (2) length([_1626, _1632], 2) Call: (2) append([_1626, _1632], _1654, [1, 2, 3, 4, 5, 6]) Exit: (2) append([1, 2], [3, 4, 5, 6], [1, 2, 3, 4, 5, 6]) Call: (2) group(2, [3, 4, 5, 6], _1622) Call: (3) length(_1638, 2) Exit: (3) length([_1644, _1650], 2) Call: (3) append([_1644, _1650], _1672, [3, 4, 5, 6]) Exit: (3) append([3, 4], [5, 6], [3, 4, 5, 6]) Call: (3) group(2, [5, 6], _1640) Call: (4) length(_1656, 2) Exit: (4) length([_1662, _1668], 2) Call: (4) append([_1662, _1668], _1690, [5, 6]) Exit: (4) append([5, 6], [], [5, 6]) Call: (4) group(2, [], _1658) Exit: (4) group(2, [], []) Exit: (3) group(2, [5, 6], [[5, 6]]) Exit: (2) group(2, [3, 4, 5, 6], [[3, 4], [5, 6]]) Exit: (1) group(2, [1, 2, 3, 4, 5, 6], [[1, 2], [3, 4], [5, 6]]) Structured = [[1, 2], [3, 4], [5, 6]].
polarbear([2],6,Z) is still the second case. The first clause is triggered *only* when the list is empty.
Thank you for the in depth explanation. I didn't know that I have to use cut (!), for the base case.
You actually don't need the cut for correctness. I tend to be a little over zealous with my cuts, preferring semi-determinism over generality. But Prolog is really good at generality, so I need to get out of that habit.
Thanks, of course that worked! I knew about that page, I just thought "surely, the latest version I got from M-x package-install prolog-mode should be up to date". (That appears to not be the case)
Sorry for the delay. I've been busy with multiple things, and also this stuff is hard for me, so thinking about this alone also takes a lot of time for me. Here is what I currently have.: length_of_path(X,Y,Length) :- length_of_path(X, Y, [], Length). length_of_path(X,Y,_,Length) :- edge(X,Y) , UpdatedLength is Length + 1 , length_of_path(X,Y,UpdatedLength), !. length_of_path(X,Y,Visited,Length) :- edge(X,Z), not_already_visited(Z, Visited), UpdatedLength is Length + 1 , length_of_path(Z, Y, [Z|Visited], UpdatedLength). not_already_visited(_, []). not_already_visited(X, [H|T]) :- X \= H, not_already_visited(X, T). However, when I try the query path(a,b,Length)., I get the following output.: ?- path(a,b,Length). true ; Length = [] ; false. I'm so confused. Why isn't Length a(n) (integer) number (as opposed to a list)?
Seems like you need to put a period after your ground terms.
What do you mean by ground terms? 
Shouldn't the x,y,z in the predicate tell be upper case? 
An optimal value for the same problem and problem instance cannot be two different values. Are both models really optimizing the same decision variable, using the same constraints and use the same input data? It might help if you show the two models.
Great that you found the problem. And thanks for your kind words.
R.I.P. - one of the few acronyms that translates directly between English and French (or at least Latin) without losing any meaning or context. I think Colmerauer would have appreciated that fact.
Linux Mint has a screensaver that is a live, visual demo of a Towers of Hanoi solver. No source code (can be found in hundreds of places), but it serves to give a good 'gut feel' for recursion.
This is equivalent to `nth1/4` in SWI. The signature is `nth1(?N,?List,?Elm,?Rest)`.
This is not recursive .. 
Not by itself, no. This is the direction I was thinking: boss_of(ingo,john). boss_of(john,kelly). boss_of(john,karson). boss_of(john,kiki). boss_of(john,kyle). boss_of(kelly,lilly). boss_of(kelly,larry). boss_of(kelly,london). boss_of(kelly,luke). boss_of(karson,larsen). boss_of(karson,lobo). boss_of(kiki,lo). boss_of(larry,maddy). boss_of(larry,mei). boss_of(larry,mandy). boss_of(mei,nanook). subordinates(X,[X, Subs]) :- findall(Sub, boss_of(X,Sub), NextSubs), % if X is not the boss of anyone, fail here length(NextSubs, N), N &gt; 0, maplist(subordinates, NextSubs, Subs). subordinates(X,X) :- % X is just a member of the list if is not the boss of anyone. findall(Sub, boss_of(X,Sub), []). Which gives: ?- subordinates(ingo,Subordinates). Subordinates = [ingo, [[john, [[kelly, [lilly, [larry, [maddy, [mei, [nanook]], mandy]], london, luke]], [karson, [larsen, lobo]], [kiki, [lo]], kyle]]]] Each result item is either an atom, or [name, [sub, sub, sub]]. It could also be changed so that if they have no subordinates they could be in the list as [name, []], depending on how the result is going to be used. There is a more purely recursive way to do this, but I don't know if that is more or less clear to read, or better or worse in performance. 
Great answer! Thanks for this, makes it easier to conceptualize the solution in my head now.
I think this is exactly what you want: - `supervisor_of/2` describes the direct boss-employee relationship. - `boss_of/2` describes the complete boss-employee relationship. - `subordinates/2` is the list version of `boss_of/2`. It code is fully general, meaning you can give a boss and find the employees or give some employees and find a common boss (or give neither if you must). The most common use cases are first in the search order, meaning you can use `once/1` to get determinism when you want A) all employees under a given boss, or B) the nearest common boss of a set of employees. # Code: %% supervisor_of(?Boss, ?Sub) % Sub is a direct subordinate of Boss. supervisor_of(ingo, john). supervisor_of(john, kelly). supervisor_of(john, karson). supervisor_of(john, kiki). supervisor_of(john, kyle). supervisor_of(kelly, lilly). supervisor_of(kelly, larry). supervisor_of(kelly, london). supervisor_of(kelly, luke). supervisor_of(karson, larsen). supervisor_of(karson, lobo). supervisor_of(kiki, lo). supervisor_of(larry, maddy). supervisor_of(larry, mei). supervisor_of(larry, mandy). supervisor_of(mei, nanook). %% boss_of(?Boss, ?Sub) % Sub is a direct or indirect subordinate of Boss. % If Sub is given, the most immediate boss is found first. boss_of(Boss, Sub) :- supervisor_of(Boss, Sub). boss_of(Boss, Sub) :- supervisor_of(X, Sub), boss_of(Boss, X). %% subordinates(?Boss, ?Subs) % Subs is a list of direct or indirect subordinates of Boss. % If Boss is given, a maximal list of subordinates is found first. % If Subs is given, the most immediate common boss is found first. subordinates(Boss, Subs) :- subordinates_(Boss, Subs, []). subordinates_(Boss, [S|Subs], Seen) :- boss_of(Boss, S), \+ member(S, Seen), subordinates_(Boss, Subs, [S|Seen]). subordinates_(_, [], _). # Examples Get the maximal list of subordinates with `once/1`: ?- once(subordinates(ingo, Subs)). Subs = [john, kelly, karson, kiki, kyle, lilly, larry, london, luke, larsen, lobo, lo, maddy, mei, mandy, nanook]. Search the common bosses from the inside out: ?- subordinates(Boss, [larsen,lilly]). Boss = john ; Boss = ingo ; false.
X-post https://www.reddit.com/r/lisp/comments/6l0e3b/hiring_a_lisp_developer_for_a_small_project/
I'd suggest stepping through it and not trying to solve it on one line.
This is a syntax error. You should write `0.05` instead of `.05`. With what you have, the parser sees the `.` and thinks it's an infix operator. It sees an argument to the right (`05`) but not to the left. Thus an operator-expected error. This will also apply to the `.25`.
Perfect! Thank you so much.