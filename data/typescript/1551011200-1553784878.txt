there is no specific issue with typeORM. the problem we facing is that we wrote our own module loader for express openapi to address decoupling. we search a framework which delivers a comprehensive solution throughout the layers. like spring boot :) 
Was this inspired by rusts features “Result” and “Option” by chance? Cause I sure love rust for them. 
There have been many languages with these kind of features before already. They're very prominent in functional programming.
Looks nice!
&gt; How are you compiling now? Running it manually in the console? Sorry I didn't state it clearly. No. I don't run commands in console to build each time (I set watchers). The delay I meant was the time between save and change in actual code. Not much, but I would like if we can avoid it. You're taking TS as a primary language. I am treating it as an add-on feature to support my coding. I don't want to use type-checking other than the IDE support it provides. So if I can avoid the build step and writing in .ts instead of .js, I would like if there is way. I'm not against .ts and compile thing though, just looking for different ways to do these things.
No because you need a separate `...` for each object returned from .map.
I feel like we should point out that true-myth is _not_ fantasy land compliant, either. I'm not entirely sure why the author didn't go with it. I usually reach for [fp-ts](https://github.com/gcanti/fp-ts/blob/master/docs/Either.md) which is compliant, but true myth's docs do look much more approachable.
Does `Maybe&lt;T&gt;` type provide any advantage over `T | null`, if i never used the utility methods such as `map`, `mapOrElse` etc?
Bravo, I'll be raising this for discussion and consideration in this morning's scrum meeting.
I am concerned that this causes heap allocations, unlike rust which does all of this on the stack. 
Have you done what the compiler is telling you to do?
To answer your question, yes. https://true-myth.js.org/#inspiration
Nice little article!
r/MisleadingTitles You are implying the entire AirB&amp;B code base is written in Typescript. I imagine the slide is only referencing JS bugs only.
Bad article. Falls for the mistake of spreading/assigning the partial: &gt; Object.assign(this, argsX); The type of `this.x` is `number`, and not `number | undefined`. But the type of `argsX.x` is `number | undefined` (because it's a `Partial&lt;T&gt;`). That means your resulting value of `argsX.x` could be of the type `undefined`. **Do not object spread / assign `Partial&lt;T&gt;`!**
Was this supposed to be explain something useful? 
I do not seem to know the correct syntax for Typescript. How would I make "this.clickMe = this.clickMe.bind(this);" public/private. Or how ".catch(function(error)" could become a named function and still function like I wanted to?
These kinds of articles remind me how much I still have to learn. Looks like this article is based around the author's [fp-ts](https://github.com/gcanti/fp-ts) library. There's only a few articles posted on [his blog](https://dev.to/gcanti).
Meh 
Those don't seem like compiler errors, they seem like linter errors. Are you using ESLint or TSLint? 
Yeah, they are very interesting. And yes, the author of the fp-ts (among others) is the same of the article's author. He's trying the [dev.to](https://dev.to) platform since a couple of weeks, here is it's [Medium profile](https://medium.com/@gcanti).
Something very useful, actually. If you already knew those concepts, good for you! :)
what's your proposed solution to make sure the properties are type checked as number | undefined
Use `Pick&lt;T, K&gt;` instead of `Partial&lt;T&gt;`. That object represents a subset of `T`, but the property types are the same. function doStuff&lt;K extends keyof Point&gt;(partialPoint: Pick&lt;Point, K&gt;): void { const mergedPoint: Point = Object.assign({}, fallbackPoint, partialPoint); console.log('x is', mergedPoint.x); }
interesting, this puts the the responsibility at the caller, and makes it unnecessary to null check in the doStuff function
Despite some sour comments, good job on just trying to teach in general. It isn't easy. Keep in mind many typescript enthusiasts are FP enthusiasts too so don't be discouraged.
Tagless Final and MTL are common FP patterns, not specific to fp-ts.
The work done on fp-ts is nothing short of incredible, but I feel that attempting this level of functional purity in TS/JS is like having your favorite cake and eating it, but realizing it was made with artificial sweetener.
I want to believe you. But I don't follow you at the moment : &gt;The goal of a combinator is to create new "things" from previously defined "things" Coming from a strong typing background this is very confusing. Are these the same things? Are they related, unrelated? Does it matter if they are unrelated? What is setoid()? Why should I care about this? Why is the first example referring to some abstract concept that I may or may not be familiar with? I don't mean to be rude, just point out some genuine feedback. I find this to be a pattern with folks teaching functional design, I'm not sure why, but they always come across as detached from reality or otherwise lacking important context. Thanks for sharing anyway, I would be interested to learn more.
Right, but why do you link to edupioneer.net while the link points to https://morioh.com/p/667af9ed7376/getting-started-with-graphql-and-typescript ? Do you get paid for getting clicks or what?
You might receive more help if you fix the formatting of code in your post; it's not very readable as-is.
Instead of declaring the clickMe method like this: ```ts private clickMe() { // do stuff } ``` Declare it as a private property whose value is an arrow function: ```ts private readonly clickMe = () =&gt; { // do stuff }; ``` Now `clickMe` is a function with bound context (due to it being an arrow function), and you can remove the `this.clickMe = this.clickMe.bind(this)` from your constructor. This is a pattern that some people follow for React event handlers.
&gt; "The class method 'clickMe' must be marked either 'private', 'public', or 'protected'" For this specific error, it's not complaining about the `this.clickMe = this.clickMe.bind(this);` line. It's complaining that you didn't provide an access modifier for the declaration of the `clickMe` function: ```ts // error here clickMe() { // do stuff } ``` You need to specify the access modifier like this: ```ts private clickMe() { // do stuff } ``` 
In the first, you can use `Action` with no parameter specified.
Ah of course! It's a default, I was mixing it up with `T extends any`.
In the first example the T type parameters has an initial value, `any`. If you only write `Action`, then the property called `type` will have `any` type. In the second example, you will explicitly have to provide a type for the T type parameter whenever you use `Action`.
I have to agree. This is missing so much context. It's just a mere arrangement of abstract or very special terms without any real helpful explanation. I too would be interested in learning more, but it's not really possible to dive into the topic with the current state of this article.
I mean, [Babylon has typescript bindings](https://preview.babylonjs.com/babylon.d.ts), so you should be able to use that.. Really it doesn't matter if it does or not though, so long as you can import it then it'll work just fine. It doesn't really matter if the library is *made* for typescript or not, it'll still behave the exact same without additional setup Typescript is interoperable with JS code anyway.
Probably most of them have typings. So pick one.
And what if you have a tuple with more than two elements? If the tuple has a fixed size of 2, then you can just do: type Foo&lt;T extends [any, any]&gt; = T extends [infer A, infer B] ? ... : never;
it is for tuples of size N, i only used a tuple of size 2 to show the minimal example. I need to use infer to iterate through each type in the tuple, but working with (head, next, ...tail) to do (head &amp; next) seems to be a hard problem for every type in any[]
I mean if you're going really basic, maybe don't use a framework? TypeScript has great support for interfacing with HTML. If you want pokemon style fights you could even just use typescript and the DOM(HTML). Just use some css to layout the scene, switch images for different characters/monsters, display some text have some buttons to click to take actions. Maybe start with that, it may look better than you might think and be much easier than pretty much any other framework. Plus it is super lightweight and will load fast :P If you want to get fancy you can try [canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_usage). That will let you draw graphics (shapes, images, or text) to the browser without needing any libraries or frameworks, supported on desktop and mobile browsers.
Check in [https://definitelytyped.org](https://definitelytyped.org) for games libraries' definitions.
JS can handle heap allocations. Look at the amount of discarded data when building a modern react app that treats all objects as immutable.
Context matters a lot! It depends on where this gets used. 
True. In an inner loop it could be significant.
There are two issues here that I'd like to point out: 1) TypeScript attempts to 'play nicely' with JavaScript - its not up to JavaScript frameworks to play nice with TypeScript. If its a good framework with a well designed API it will work as well in TypeScript as it will in JavaScript. 2) As other point out the only other thing to look out for is TypeScript declaration files. If the types are released alongside the JavaScript framework, or even if the JavaScript framework is written in TypeScript itself then this is usually better. For example Phaser generates typescript definitions alongside each release here: [https://github.com/photonstorm/phaser3-docs/tree/master/typescript](https://github.com/photonstorm/phaser3-docs/tree/master/typescript) &amp;#x200B;
[https://www.egret.com/products/engine.html](https://www.egret.com/products/engine.html) 
For N-ary tuples: type UnionToIntersection&lt;U&gt; = (U extends any ? (k: U)=&gt;void : never) extends ((k: infer I)=&gt;void) ? I : never type ObjectOrString&lt;T extends any[]&gt; = string extends T[number] ? T[number] : UnionToIntersection&lt;T[number]&gt;;
A few ideas: 1. If all you know is JS, HTML, and CSS, you can go really far with just using HTML and CSS for your game. HTML/CSS makes for great UI building. 2. Consider also a text-based RPG using HTML/CSS. It can be easier to implement, and you can focus more on storytelling if you like that side of things. 3. Check out the Canvas API, which you can use to draw arbitrary 2d graphics. It's built in to every browser, so no need for a library: [https://developer.mozilla.org/en-US/docs/Web/API/Canvas\_API/Tutorial](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial) 4. If you want to go 3D, Babylon.js has great TypeScript support that I can vouch for. 3D is its own rabbit hole through, so if you haven't done it before I'd recommend sticking with 2D. 5. I've heard great things about Phaser, but I haven't used it myself.
For a simple game try from scratch for the heck of it. Learn canvas. I think you'll have an easier time wrapping your head around frameworks and engines for games later if you know the basics of how it all works. And learning canvas is going to be less involved than learning a game framework would be. I wanted to do basically the exact same thing and tried a few frameworks/engines but got a little frustrated at the amount of boilerplate and engine specific stuff I was doing for a very simple 2D game so I restarted with a simple game loop and built it out: function loop(timestamp: number) { updateCooldowns(); updateInput(); if (isVictory) updateVictory(); else if (isDemoMode) updateDemo(); else update(timestamp); draw(timestamp); window.requestAnimationFrame(loop); } There's a variable not shown here holding the 2d context for the canvas and the draw command uses that to draw everything. There's a load function not shown here that loads everything before loop gets called. Each function does what it says it does and this loop is the heart of it.
It would work if your typescript file was also legal javascript, but it doesn't explain the performance difference.
paste some example ts code that works with nodejs.
If you're not using TS for type checking outside of what you see in your editor, then you're 100% going to miss bugs. Most of the errors I get is when I change a common API and it breaks the usage in 5 other places, but then I can just follow the compiler and fix them
It is legal javascript (no interfaces and no explicit type declaration), the difference could be that we do use classes, arrow functions and constants with our target being the default (I think the is es3).
classes, const, and arrow functions are all legal ecmascript, so node can handle them.
But I don't know if it makes any performance difference that would explain why his code was a bit faster
Are the two scripts byte-for-byte the same or are they just functionally the same?
Here you have some functions we use, (this is from the code we started with) &amp;#x200B; p.s. sorry for the spanish &amp;#x200B; `"use strict"` `const calcNum = (base, diff) =&gt;{` `let total = 1;` `for(let count = 0; count &lt; diff; count++){` `total = total * (base - count);` `}` `return total;` `}` `const calcComb = (up, down)=&gt;{` `const upN = calcNum(up, down);` `const downN = calcNum(down, down);` `return upN / downN;` `}` `const calcHiperGeom = (N, n, K, k) =&gt;{` `N = Number(N);` `n = Number(n);` `K = Number(K);` `k = Number(k);` `if(N &amp;&amp; n &amp;&amp; K &amp;&amp; k){` `if(N &gt;= K){` `if(K &gt;= k){` `const res1 = calcComb(K, k);` `const res2 = calcComb(N - K,n - k);` `const res3 = calcComb(N,n);` `console.log((res1 * res2) + " / " + res3 + " = " + ((res1 * res2) / res3));` `}else{` `console.log("No puedes tener mas aciertos que bolas tomadas &gt;:V");` `}` `}else{` `console.log("No puedes sacar mas bolas que la cantidad total de bolas &gt;:V");` `}` `}else{` `console.log("Tienes que llenar todos los datos para poder calcularlo &gt;:V");` `}` `}`
This fails on const fail: ObjectOrString&lt;[({ name: string } | { age: number }), { height: number }]&gt; = { name: "", height: 999 }; UnionToIntersection also converts inner Unions to Intersections
byte for byte, we are trying to optimize a code we wrote together
How big is the difference in speed?
Super small, like less than 15 miliseconds small
If the difference is that small my guess is that your CPU is just a little bit busier than your friend's and can't finish running the script quite as fast. Even running the same script twice in a row will often get pretty different times. I usually do a dozen or so runs and average the result when I want to see how fast something runs.
 type UnionToIntersection&lt;U&gt; = (U extends any ? (k: U) =&gt; void : never) extends ((k: infer I) =&gt; void) ? I : never type Wrap&lt;T extends any[]&gt; = { [K in keyof T]: { wrap: T[K] } }; type Unwrap&lt;T extends object&gt; = T[Extract&lt;keyof T, 'wrap'&gt;]; type ObjectOrString&lt;T extends any[]&gt; = string extends T[number] ? T[number] : Unwrap&lt;UnionToIntersection&lt;Wrap&lt;T&gt;[number]&gt;&gt;;
Answer: It could. It all depends. Expert answer: The only way to really know is to control for all the other variables and just test it.
Just a tip: if you have an entire block of code you can format it much more nicely by putting 4 spaces at the beginning of each line, like this "use strict"; const calcNum = (base, diff) =&gt; { let total = 1; for (let count = 0; count &lt; diff; count++) { total = total * (base - count); } return total; }; const calcComb = (up, down) =&gt; { const upN = calcNum(up, down); const downN = calcNum(down, down); return upN / downN; }; const calcHiperGeom = (N, n, K, k) =&gt; { N = Number(N); n = Number(n); K = Number(K); k = Number(k); if (N &amp;&amp; n &amp;&amp; K &amp;&amp; k) { if (N &gt;= K) { if (K &gt;= k) { const res1 = calcComb(K, k); const res2 = calcComb(N - K, n - k); const res3 = calcComb(N, n); console.log(res1 * res2 + " / " + res3 + " = " + (res1 * res2) / res3); } else { console.log("No puedes tener mas aciertos que bolas tomadas &gt;:V"); } } else { console.log( "No puedes sacar mas bolas que la cantidad total de bolas &gt;:V" ); } } else { console.log("Tienes que llenar todos los datos para poder calcularlo &gt;:V"); } }; 
For node, there is [ts-node](https://github.com/TypeStrong/ts-node), which is a wrapper around node that can run typescript.
It's bad with the tests, but thing about how much of a nightmare it'd be without all the automated testing.
Phaser CE has a lot of support, and it's really a high level abstraction on Pixi.js. 
&gt; I have to context switch constantly I think this is where the mismatch comes in. Because you bounce among projects frequently and maybe are mostly involved in the early stages, you never really see the payoff for the time spent learning a type system. You only see the (honestly, pretty small) cost of learning the type system and never see the cost of not having typing. The poor bastard who maintains the code in a few years is the one who pays the price. If you spend nontrivial amounts of time maintaining the same codebase, especially working with multiple other people, the value becomes clear \*really\* fast. &amp;#x200B;
By changing string extends T[number] to T[number extends string it actually worked, thanks for the wrapping trick
I just use a package called module-alias and give it the same path config as ts.
Thanks for clearing those things up, makes me feel more comfortable going forward.
After reading what everyone has said, I'm starting to lean towards using just html and typescript, or just a small/simple library like Pixi.js. So a few questions, is webgl or canvas faster and lighter for a game of this type? Would using pixi.js give better performance than using no library, or would I be better off not using any? I understand some people feel that it wouldn't make a difference, but I want to make a habit of writing fast programming/games, especially if I want to target the browser for phones.
After reading what everyone has said, I'm starting to lean towards using just html and typescript, or just a small/simple library like Pixi.js. So a few questions, is webgl or canvas faster and lighter for a game of this type? Would using pixi.js give better performance than using no library, or would I be better off not using any? I understand some people feel that it wouldn't make a difference, but I want to make a habit of writing fast programming/games, especially if I want to target the browser for phones.
After reading what everyone has said, I'm starting to lean towards using just html and typescript, or just a small/simple library like Pixi.js. So a few questions, is webgl or canvas faster and lighter for a game of this type? Would using pixi.js give better performance than using no library, or would I be better off not using any? I understand some people feel that it wouldn't make a difference, but I want to make a habit of writing fast programming/games, especially if I want to target the browser for phones.
Sounds good! :) I haven't done any benchmarks myself on canvas vs webgl speed, though I would suspect that WebGL is faster, since it's closer to talking directly to the GPU itself than canvas is. Maybe write something simple in both and benchmark it yourself to see? In terms of speed of development though, canvas is probably going to let you get farther a lot faster, as you'll be left doing a lot of stuff yourself with webgl that canvas takes care of for you. Something like Pixi or Phaser should be even faster still in terms of development time, since they've even more for you already. Whether Pixi is faster than no library gets a big "it depends". Since Pixi has been used by lots of people over a long period of time, they've had lots of time to optimize it and make it really fast. However, on the flip side, a generalized library will almost by necessity be slower than doing things without a library, because a library's purpose in life is to handle every case in a general way. You might be able to write code that's highly optimized to your game/situation in particular, and end up faster in some cases. But writing a game can be enough trouble of it's own, it's often better for your development speed (and your sanity) to leave the optimizing work to the library maintainers.
if you are just now starting a project, it might be worth checking out [deno](https://github.com/denoland/deno)
Thanks. Switched to module-alias and fiddled with `require` vs `import` until it worked, and now it does My only complaint is that now I have aliases defined in two places :(
I personally work on a project using Typescript and pixi.js. It is pretty straight forward to get some sprites moving on the screen. Additionally it handles stuff like resources, sprite batching, compiling shaders, etc. for you. If you want canvas and WebGL support, you should use it. You can create prototypes vers fast with it, imo. The typings for pixi.js do not cover 100% of the functionality but this is not a big deal. There is still a documentation and an api reference. You can always use plain JS, if it is necessary. Phaser might be a good option if you need a whole framework for game development and not just a library for rendering. If you have experience with OpenGL (since you know some C and C++) and want only WebGL support, you could also build your own rendering pipeline. But this way you have a pretty big initial overhead, before getting actually started with prototyping your game(s).
Sounds like optimizing would be out of my scope. So a quick look around online tells me phaser does the follow that pixi does not: Physics I/O Camera scrolling (e.g. camera following you in a sidescroller like Mario) Collisions State management Tilemap Support Spritesheets/Animations/Tweens Audio Game Loop How much of that is meaningful to me if I'm just trying to build a simple pokemon-esque 2d rpg? If I'm not using much of these things I will likely just stick to pixi.js but if there are a lot of benefits to be had there then I would consider phaser 3.
Don't forget SVG. You can write your game with vector graphics - all markup, no bitmaps - and it is faster than you might think.
So I guess what's left for me to figure out if I need just the renderer + my own code or other small libraries/frameworks to handle small things or if I would benefit from having a whole framework like Phaser 3 and all the things it encompasses. F rom a quick look around I found phaser does the following that pixi does not: Physics I/O Camera scrolling (e.g. camera following you in a sidescroller like Mario) Collisions State management Tilemap Support Spritesheets/Animations/Tweens Audio (I think pixi has audio though) Game Loop How much of that is meaningful to me if I'm just trying to build a simple pokemon-esque 2d rpg or a final fantasy tactics like SRPG? If I'm not using much of these things I will likely just stick to pixi.js but if there are a lot of benefits to be had there then I would consider phaser 3.
Well, canvas is "lighter" than webgl for you. webgl means you need to start considering a whole boat load of other things just to draw some simple stuff to the screen, where as canvas is just the function call. Compare https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage vs https://stackoverflow.com/questions/12250953/drawing-an-image-using-webgl or https://webglfundamentals.org/webgl/lessons/webgl-2d-drawimage.html. Pixi wouldn't really give you performance but it would probably make getting started easier for drawing canvas/webgl things. It would definitely be easier than webgl. Just by the nature of using html or canvas/pixi and being a new project your game will be fast, don't worry about that until later. Honestly I'd say try and make a prototype in html for a hour or two and see how far you get, then try canvas for an hour or two, then pixi if you feel like it. Hopefully in that short time you'll understand which tool is most suitable for the game you're trying to make. Good luck !
For something pokemon-esque, you’ll probably end up using all of those except for Physics. I/O - Save files Camera scrolling - Camera following you as you move along a route or change areas Collisions - Running into buildings, NPCs, rocks State management - Not 100% sure but this sounds like easily separating title screen from battle screen from overworld Tilemap support - Pokemon overworld is built out of reusable tiles Spritesheets/Animations - Your character and NPCs walking around are a great candidate for a spitesheet Audio - Sound is good :) Game Loop - Every game needs one! It’s definitely possible to implement all of those yourself, and can be a fun learning experience if you haven’t done it before. If you haven’t worked with a proper game library before though, I’d recommend using one first so you can get an idea of common patterns that they implement to make life easier on you, and then if you feel you’ve outgrown them or want to deviate from how they work, you can implement them in whatever way you see fit. Hopefully that helps! :)
Those frameworks would be additional code on top of canvas. If you do canvas directly you cut out the middle man. I don't know if they do any kind of optimization to improve performance. They might. For 2d I'm not sure what they'd do to optimize. My simple games do some things to be better performing but usually that only comes up when there's a problem. And it's usually more about not generating tons of objects every tick, not getting a context from the canvas every tick, stuff like that. As far as I can tell Firefox and chrome on desktop and mobile can do very fast drawing to the canvas with the 2d context. I made an asteroids clone (like I said, very simple game) and the frame rate is basically pegged at a good rate in all my test. I took the game and used the canvas as a texture applied to a polygon that appears in 3d/VR using A-frame and it still has good frame rates with Google cardboard or daydream on a pixel. Canvas is very fast now
This is great advice. Deno is very good. 
Well.. I appreciate the suggestion, but if you're going to throw that out there, mind saying why you recommend it?
... that's totally valid JS. You could paste it into Chrome from 10 versions ago (chrome 63?) and it'll probably still run just fine.
7drl starts next weekend, always a good place to write simple rpgs. My recommended library is Rot.js http://ondras.github.io/rot.js/hp/ Here's your typedefs: https://www.npmjs.com/package/@types/rot-js
You also have the possibility to use a bundler like Webpack, and setup module aliases in its configuration.
Yeah, maybe even older, but I thought that just for being .ts it shouldn't run
Also has full TS typings! This is what I use. Love Phaser CE.
"Full" is relative. If you really need to dig into it - and not just its API - you will end up having to either toggle on JS for your build or do some real rewriting. For example, you cannot extend a default `Phaser.Weapon` class and then rewrite some parts of its internals, as those methods aren't typed.
Totally fair. I generally just use the state and sprite stuff, and the one type error I found I reported and was pretty quickly fixed.
Don't use ts-node in a prod environment. Use node on your compiled code
Node doesn't care what the file extension is, as long as it is readable text.
Right, I mentioned I'm using tsc to compile my source. Problem is I can't node it because aliases don't get resolved
Can you solve this with a symlink?
You can review my repo here where I solved this problem for compiling into my build/ directory: &amp;#x200B; [https://github.com/locnguyen/typescript-node-starter/](https://github.com/locnguyen/typescript-node-starter/) &amp;#x200B; &amp;#x200B;
If it's valid JS syntax, it will run on node. *If* you use TS syntax that *is not* valid JS syntax, it will not run on node. There's your answer. Ts-node installs a require hook that compiles TS at runtime. But node is not running the TS; it's running the JS emitted by the compiler.
Just keep in mind that it is nowhere near production-ready
Webpack.
I usually use Webpack for back-end apps as well, these days it's really a great tool for building anything web-related.
If it's configurable via JS/TS then you can import tsconfig.json and programmatically reuse the same aliases.
My setup doesn’t allow them to exist in the first place. It’s a hard error. 
Yes, I will not start a project in JS unless I expect it to be less than 100 lines of code. Typescript is great! In general, it seems that if a library uses typescript, you should have no problem importing it. If there is a handmade `.d.ts` file, then I always expect problems.
C# also has `any` which lol.
But why were they there?
I’ve ran into this problem before, and I’ve used webpack to bundle and transform my app code (without including node_modules). If you’re interested you can check out the tool I made which supports path aliases with no configuration: https://github.com/liangchunn/typescript-node-scripts It works like create-react-app but running `yarn build` spits out a single bundle which you can just run with `node dist/bundle.prod.js`. It also has a dev mode with incremental builds + auto app reload + pretty error messages. 
A colleague of mine found a new (for them previously unknown) xcode shortcut today. We laughed and joked it was enough to warrant a Medium article. 
Because some people don't use proper IDEs.
Wrong sub :)
Google is your friend... 
There is not really a fixed list. There are the ones which have a RFC and are generally accepted but anyone can make their own at anytime. It's generally a bad idea as an individual.
This many [https://http.cat/](https://http.cat/)
there are many, but 418 can cover most cases
Imagine having a CI system that even allows this kind of savagery to be merged into master. 
To build on the other answers: yes this is possible with interfaces. Interfaces are evaluated by the compiler lazily. This means that the compiler will not get stuck in an infinite loop attempting to resolve the reference to `Queue`. Types, on the other hand, are evaluated eagerly (usually). This means that types cannot generally be recursive. For instance: ``` type Nested&lt;T&gt; = T | Nested&lt;T&gt;; ``` is invalid. The compiler is smart though. If it can convert a type to an interface, it will under the hood. For instance: ``` type Query = { condition: string; rules: Query[]; } ``` can be easily converted into an interface and evaluated lazily, so the compiler will. I find that the TS playground is a great way to test some of these questions: https://www.typescriptlang.org/play/#src=interface%20Recur%20%7B%0D%0A%20%20%20%20things%3A%20Recur%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20const%20a%3A%20Recur%3B%0D%0Aa.things.things.things.things%3B%0D%0A%0D%0Atype%20Nope%3CT%3E%20%3D%20T%20%7C%20Nope%3CT%3E%5B%5D%3B%0D%0A
As others have said, there is no perfect way to type this as of yet (excluding [this suggestion](https://www.reddit.com/r/typescript/comments/apfkxh/how_should_i_correctly_type_an_array_flatten/egb1c25) which is an unsupported "feature" of the language that will likely disappear). One temporary solution that I find (marginally) cleaner than the other suggestions is: ``` type Flatten&lt;T&gt; = T extends (infer A)[][][][] ? A[] : T extends (infer A)[][][] ? A[] : T extends (infer A)[][] ? A[] : T extends (infer A)[] ? A[] : T[]; type b = number[] | number[][] | number[][][] | number[][][][]; type c = Flatten&lt;b&gt;; ``` This could, of course, be easily extended to include further depths as necessary. [ts playground](https://www.typescriptlang.org/play/#src=type%20Flatten%3CT%3E%20%3D%0D%0A%20%20%20%20T%20extends%20(infer%20A)%5B%5D%5B%5D%5B%5D%5B%5D%20%3F%20A%5B%5D%20%3A%0D%0A%20%20%20%20T%20extends%20(infer%20A)%5B%5D%5B%5D%5B%5D%20%3F%20A%5B%5D%20%3A%0D%0A%20%20%20%20T%20extends%20(infer%20A)%5B%5D%5B%5D%20%3F%20A%5B%5D%20%3A%0D%0A%20%20%20%20T%20extends%20(infer%20A)%5B%5D%20%3F%20A%5B%5D%20%3A%0D%0A%20%20%20%20%20%20%20%20T%5B%5D%3B%0D%0A%0D%0Atype%20b%20%3D%20number%5B%5D%20%7C%20number%5B%5D%5B%5D%20%7C%20number%5B%5D%5B%5D%5B%5D%20%7C%20number%5B%5D%5B%5D%5B%5D%5B%5D%3B%0D%0A%0D%0Atype%20c%20%3D%20Flatten%3Cb%3E%3B)
I would like to second AJV. It is one of the fastest (if not _the_ fastest) way to validate types at runtime. If I could shamelessly plug my own wrapper over AJV that I use for all of my projects: https://github.com/andnp/ValidTyped Quick example: ``` import * as v from 'validtyped'; const personValidator = v.object({ name: v.string(), id: v.number(), friends: v.array(v.number()), }); const dataFromApi: any = await getData('best-friend'); if (personValidator.isValid(dataFromApi)) { const name = dataFromApi.name; // is a string const nope = dataFromApi.nope; // is a compile error } ``` Note the authors of validtyped do not condone its use for validating people. It should be used only to validate runtime javascript types.
I would like to also nominate AJV. It is one of the fastest (if not _the_ fastest) way to validate types at runtime. If I could shamelessly plug my own wrapper over AJV that I use for all of my projects: https://github.com/andnp/ValidTyped It is pretty tiny and contains a few useful utilities creating expressive types (things like unions and intersections for example). All while maintaining a valid JSON schema under-the-hood and using AJV to validate. Quick example: ``` import * as v from 'validtyped'; const personValidator = v.object({ name: v.string(), id: v.number(), friends: v.array(v.number()), }); const dataFromApi: any = await getData('best-friend'); if (personValidator.isValid(dataFromApi)) { const name = dataFromApi.name; // is a string const nope = dataFromApi.nope; // is a compile error } ``` Note the authors of validtyped do not condone its use for validating people. It should be used only to validate runtime javascript types.
I'll do you one better. I actively maintain a library of all of my favorite helper types: https://github.com/andnp/SimplyTyped I used to keep a `tsUtils.ts` file with many of these that would get copy/pasted across many projects, so I've started collecting the more reusable versions into a single library of them.
I read through the open issues in the typescript repo with some regularity. You could also read through some of https://github.com/andnp/SimplyTyped which contains a collection of many types of varying complexity. Note this is a ~shameless~ shameful plug :)
In my 30 years of career, I’ve been a beverage producing utensil most of the time. Checks out. 
I strongly agree here. Further, I find that function type declarations can be a bit of an eyesore. ``` function mapper&lt;T, R&gt;(map: (x: T) =&gt; R): R { ... } ```
Using Babel to strip annotations means there isn't an extra build step, since Babel is needed in most use cases anyway.
file-endings doesn't really mean anything, it's for humans only (and for ms windows file association), it has no real meaning to most programs.
One hack I came up with is to not export the functions themselves, but a class with static methods. In `./src/mongo/users.ts`: export class MU { public static getUser = getUser; }
&gt; Should I `import * as MongoUsers from './src/mongo/users'`? Yes, more or less this. They do the same thing underneath (creating an object wrapper around), and is also the recommended way. 
Got it. Any way for me to make it autocomplete friendly? Maybe have an `index.js` under `./src/mongo/` that exports the `*` imports from its sibling files.
This would be the way to go, yes :-) Barrel files are really good for that.
I think `import { getUsers as mongoGetUsers } from './src/mongo/users';` should work in this case?
Why not using classes? Create classes with static methods and your problem is solved.
I'd rather leave the IDE deal with the imports. One less thing to worry about.
Coming from Java and picking up Python, I was glad to get rid of the N layers of indentation needed before I could start to write code. I like that I can get minimalist ergonomics in JS as well. Wouldn't want to go back to indentation :)
Importing '*' is a bit lazy, less readable, less precise and can give you these naming conflicts. Import the thing directly and possibly rename it with `as`: import getUser as getMongoUser from './src/mongo/users.ts' import getUser as getAuto0User from './src/external/auth0.ts'
Importing '*' is a bit lazy, less readable, less precise and can give you these naming conflicts. Import the thing directly and possibly rename it with `as`: import getUser as getMongoUser from './src/mongo/users.ts' import getUser as getAuto0User from './src/external/auth0.ts'
As the question is already answered I'd like to add something: Please don't use `T = any`. It easily introduces type-unsafety. If you really want a default type, then at least use `T = unknown`. But personally I'd prefer to drop the default type here as well. Just let the user specify the type explicitly.
I've seen this mixup so often already. Mostly made by people coming from C# (even tho the `=` is not used there with generics).
Lol ok.
You can export an object literal. export const mongo = { async getUser(uid: string) { /* do stuff */ }, getAcct(id: string) { /* do stuff */ } }; // Elsewhere import {mongo} from './other-file'; const user = await mongo.getUser('135'); &amp;#x200B;
awesome
TSlint's rule to disallow namespaces is to stop the old methodology of referencing files and using their members as globals. I have that rule disabled as modern exported namespaces is the perfect solution to the problems you describe. Then it is even possible to export types with them. Personally, you should really just use a namespace for this.
Sounds pretty cool!
Don't worry about performance unless you know it's a problem. The difference in this case would probably not be measurable at all. Though, if you import something from a module, that whole module is parsed and processed, because it might include and require side-effects that may or may not have anything to do with the thing you're importing. This will have implications for bundle size but.. Don't worry about this unless you must. 
Very cool, it sounds like they want to auto-generate type declarations from .jar files and auto-publish them to npm.
What's the use case for this? I didn't know node could run java programs..?
Other way around, checkout https://www.graalvm.org/
My understanding is: Vert.x is a runtime for writing servers. It's on top of the JVM. You can write in a bunch of different languages -- one is JS -- and it'll run on top of the JVM, with the vert.x runtime. Those libraries are implemented as .jar files, and there's an interop layer allowing js code to call back and forth with these .jar libraries. These libraries already have fully documented APIs by virtue of being in the Java ecosystem. If you want to write a vert.x server in js or ts, TypeScript declarations are the missing piece, and should be auto-generated from the .jars.
Oh that would be cool for me, we use a vertx backend (kotlin) and a vuejs frontend (typescript). It would help my frontend devs prototype some services.
That's is the main drive for the polyglot support in vert.x. You can use the right tool for the right task. A frontend developer that is proficient with TypeScript can write backend services in TypeScript and run along with the remaining languages: Java, kotlin, groovy, ruby, etc...
FYI, here's the talk Abstract Having spent over twenty years on developer tools I was convinced that Eclipse is the last development tool I work on. I was wrong. &amp;#x200B; It all started five years ago as an experiment to see what is possible when it comes to developing in the browser using modern JavaScript, HTML, and CSS. Five years later we have shipped Visual Studio Code a new smart code editor that is extensible, open source, and runs cross platform. &amp;#x200B; Code is now a 350k+ TypeScript application built using web technologies on top of the Electron shell, Node.js and uses hundreds of open source components. It is fascinating to see how many things have changed since working on Eclipse. It was a fun and interesting journey. &amp;#x200B; In this talk I look back on this journey, describe the design and technology decisions, the pivots, and what we learnt along the way.
100 oss components? So one npm package with dependencies.
Yes that is the goal. Currently some APIs are already generating type definitions, see: [https://www.npmjs.com/search?q=%22%40vertx%22](https://www.npmjs.com/search?q=%22%40vertx%22) &amp;#x200B; However this is only a small subset of APIs and for the rest you have no type information which defeats the whole point of TS. With this project users could get at least basic type info inferred and use TS as a main language for the JVM/GraalVM.
I've only just recently started using this myself - I fully adopted the AirBnB style guide and really like the opinions put forth. I feel my code is much better and more readable for it!
I have been using the AirBnB guide for my JS code already, and I like it for the same reasons. I don’t agree with every choice of theirs, but it is really wonderful to have my linter be so unambiguous. A TS version of that would be my first choice, but I was worried it might be a really unusual choice in the TS world. 
Yeah I made it work with TypeScript. The one setting they use that I just couldn't make work was the "no-submodule-imports" - I just couldn't get it to work with all of the imports I am making, primarily from Material-UI. I still try to import from root wherever possible, but cannot simply do it across the board!
Prettier, defaults
You can set up exclusions in your tslint config. There are many libraries (like lodash) where using submodule imports is encouraged so you don't pull in a ton of unneeded code. Example: { "rules": { ... "no-submodule-imports": [true, "date-fns", "lodash"] } } 
Dat.
&gt; Looking to add some consistency to my team with a super-opinionated TS linter. I would recommend using a formatter like prettier in conjunction with the linter. I'm not a fan of all the formatting Prettier does; I'm not even a fan of "standard" js/ts formatting at all TBH (I prefer Allman braces, for one). But getting used to its formatting is a heck of a lot easier than reading the mess of code you get from having a dozen+ devs working on the same code base, all of whom have slightly different style preferences even if there is a consistent standard on things like brace layout. Not to mention that being freed from worrying about formatting is *liberating* in a way that's almost magical. Just write code and hit Ctrl-S, don't worry about formatting.
That is a fantastic tip! This will force me to do it where necessary! One thing you mentioned that made me curious - ever since switching to root imports for my Material-UI files, I noticed my build process took way longer, and seemed to be including everything based on the text displayed during the build. I bet this is what you are referring to!
We use [Recommended rules](https://github.com/palantir/tslint/blob/master/src/configs/recommended.ts) + [AirBnB rules](https://github.com/progre/tslint-config-airbnb/blob/master/tslint.js) + some custom ones, such as "no-floating-promises" which is essential, in my opinion.
No. IDEs add them but don’t remove them. People don’t use linters or formatters. 
meh I loled
&gt;but for formatting, prettier and prettier Were you making a joke to suggest that Prettier is the one formatter to rule them all, or is it a typo? (I also just use Prettier.) Prettier for JS/TS and Black for Python have been fantastic productivity boosters for me. Probably like a lot of you, I'm the kind of person to get pretty anal about minor stylistic things, so a lot of my time would be spent styling code. Being able to completely ignore it and style everything with a quick Cmd+S (or wait for my pre-commit hook to kick in) is a big relief.
&gt; using submodule imports is encouraged Not anymore thanks to webpack/package.json `sideEffects: false`: https://github.com/webpack/webpack/tree/v4.29.6/examples/side-effects This allows for efficient tree-shaking. - date-fns v2: https://github.com/date-fns/date-fns/blob/v2.0.0-alpha.27/package.json#L4 - lodash-es: https://github.com/lodash/lodash/blob/6352e48c332ba465a8e557b925eb598dfab468fb/package.json#L13
[typescript-eslint](https://github.com/typescript-eslint/typescript-eslint)! The TS team themselves are adopting eslint. https://eslint.org/blog/2019/01/future-typescript-eslint
Just a head's up that [Palantir intends to deprecate TS Lint in favor of ES Lint](https://medium.com/palantir/tslint-in-2019-1a144c2317a9). I'm not saying don't use TS Lint for the time being, but I've been thinking I'll ditch my formatting specific lint rules and add Prettier, because I like it and hope having to migrate fewer rules to ES Lint will make things less painful when the time comes.
Any idea when the time is coming and/or how easy it would be to do TS lint rules in ESLint today? If I'm doing a big overhaul, I feel like I might as well make the migration as well.
They just announced it recently and I only found the post after getting curious about the number of PRs stacking up in the TS Lint repo. Also, I don't think the new rule package they mention is even out yet. So, I don't think I'm in a much better boat than you are. Personally, I wouldn't put a ton of time in to customizing rules at the moment. Instead, something like the TS Lint airbnb rules may be a good idea--that way you at least have something in place. And, since the ES Lint airbnb rules are used in a lot of ES projects, maybe there won't be that much work needed beyond swapping out the linters? Also, as mentioned, I'll probably be testing the waters with a combination prettier for format specific stuff and linting on top of that, which I haven't set up before but feel optimistic about.
Proper IDEs do that, JetBrains products for example.
Tree shaking avoids bloating your production build, but you will still end up with your builds, tests, etc. having to process a lot more code than necessary. 
Nice, thank you. 
I've used this with the vue parser and it's so slow right now. Any suggestions?
If you use React, I recommend Styled Components instead of scss/less. It matches the workflow of React much better, and your styles become typed. No more unused or missing styles!
You're not using webpack?
tried webpark many times but fail, any working example?
There's two approaches I've found. I'm on mobile so I'll probably have to reply again later with better formatting. 1 is a webpack plugin that generates a d.ts file next to each scss file, which properly types the class names, but if you chose not to commit these files you'll need to run webpack a couple times to properly clear the errors. 2. Create in the rootdir(defined in tsconfig) a file called globals.d.ts and do something like: declare module "*.scss" This works across the project and makes typescript treat the export of a sass file as any 
There is a third option: using one of the many styled component libraries that move your styles into javascript(or typescript in this case) https://www.styled-components.com/ There's other alternatives that may be better and also not require react if you are not using react. 
Which is ironic given that Angular 2 being written in TS is probably one of the factors that first gave TS a boost ("oh, look, Google's using it, there must be something to it").
Null propagation operator
The ? Operator. I think they were intending on implementing it, but I don't know if it was added yet.
You got it backwards. TypeScript was already before Angular 2 hugely popular. That was part of the reason why Google chose TypeScript as the basis for their new own language, which they then abandoned to use TypeScript directly. And frankly: Angular makes very very poor use of TypeScript.
You broke my brain. 
I would love to have a way to define the type of an object that is immediately destructured into its properties, without having to repeat the name of every field. This is just unnecessary boilerplate. Otherwise, I'm really looking forward to the pipeline operator and null propagation operator, though those are not really Typescript specific 
Useful mixins
Mine too. It opened it to unexpected things though!
Can confirm brain broken. Also saved for future. I'm still getting used to generics but this seems incredibly important for development
Records based on enjoy that can be officially guaranteed to be ordered.
When i first started, my primary wish was a that they added a full bundler to their compiler. Because I was running ts on a visual studio aspnet project. But I've come to realize that should be the responsibility of the editor and the build chain, not the compiler tool. Seen other new devs trying the same: Using vs to set up typescript inside aspnet projects, with onsave js compilation and bundling and module loading. And without having nodejs and vs crashing into each other. Not easy. So more of a vs suggestion.
The refactoring tools are a part of typescript compiler now, right? Would love if they added a "Convert to interpolated string" tool.
To be fair: Java Generics are also (Turing complete)[https://arxiv.org/pdf/1605.05274.pdf]
I don't know if it would be possible to implement, but I would love if they could make it possible to access class properties and methods without using the 'this' keyword, just like most other OO programming languages. It would save so much space, and make the code a lot easier to read
Extension functions.
- Pattern matching; - Higher-kinded types out of the box (and not with some kind of hack using module augmentation); - Compiler flag to prohibit usage of `null` and `undefined`; - Nominal type system or, at least, better ways to define opaque types and newtypes.
Boom—just extended my one-implementation-only class as a interface thanks to you. Had no idea that was possible. Otherwise I probably would have exposed the class instead, so defo cleaner code.
Better support for functional programming. They're actively [working on it](https://github.com/Microsoft/TypeScript/issues/29904), though, so I'm not too worried.
Great read, thanks
Wow, quality post. I'm so excited about ReturnType, it will save me sooo much typing. I use react + redux and being able to write class MyComponent extends React.Component&lt; ReturnType&lt;typeof mapStateToProps&gt; &amp; ReturnType&lt;typeof mapDispatchToProps&gt;&gt; is really great
I appreciate the utility of some of this, but I question whether it's really any stronger than the C# way. The interface isn't ONLY boilerplate when it has a single implementation. It's a documentation of the contract. Your system with all of the technical tricks is interesting, but leaves you without a simple one stop shop for finding the shape of the contract, without anything else. Doing enterprise development requires an awful lot of attention to separation of concerns, and we do C# interfaces a disservice to think of them as wasted boilerplate. I *like* defining my type's shape in one place, and implementing it in another. Kudos for your article, as it's opening up new avenues of study for me, and I have a long way to go to understand a lot of the nuance that you've developed competency in. I don't mean this post as a rebuttal, so much as a nod of respect to what this approach sacrifices for the sake of avoiding a single extra file.
Macros. Having rust-style typed macros would be amazing!
+1 hoping to hear a reply on interfaces as contracts much earlier in the design process.
**Better** type safety: - Don't allow assignment of `SubClass[]` to `BaseClass[]`. - Indexers should always return a union type with `undefined` (same with arrays). - Spreading `{ ...MyPartial&lt;T&gt; }` should **not** be assignable to `T`. - Distinguish between `undefined` and `missing`.
Good article
Did the author of this article have the permission of the original article here? https://medium.freecodecamp.org/typescript-curry-ramda-types-f747e99744ab The tiny footnote at the end is terrible attribution.
upvote this comment, downvote the post. hope the mods take notice
Take a look at embedding the monokai editor in your page. That’s what Code uses. 
Another reason to down-vote is the self-post rather than link post. Bah.
He really just copied it and put his name on it?
You can use either the TypeScript compiler API or the Babel parser library with the TS plugin to generate an AST (abstract syntax tree). With an AST, you'll be able to query a particular node for the type information about it. This is how `typedoc` can extract the info it needs to generate documentation. To see what ASTs can do, check out [AST Explorer](https://astexplorer.net).
theres simple automod rules to ban it if the mods care
Perfect. Thanks!
Also known as safe navigation operator. https://en.wikipedia.org/wiki/Safe_navigation_operator Null-coalescing operator would be nice too. https://en.wikipedia.org/wiki/Null_coalescing_operator
Thanks for answering; that's useful to know though for my problem I'm really looking for a solution that generates some static HTML in the manner that \`typedoc\` does.
Monaco has an interesting function for colorizing: https://microsoft.github.io/monaco-editor/playground.html#creating-the-editor-syntax-highlighting-for-html-elements I don't know if it can be used to also provide tooltips without the full editor though. 
https://github.com/Microsoft/TypeScript/issues/16 @RyanCavanaugh &gt;I get that this is a really, really nice operator, but having it be available before its rules have been ironed out is a footgun and we're not going to do that. The runtime behavior of the operator is still in flux; if you write code today it might stop working tomorrow in ways that aren't immediately apparent - maybe rare crashes, maybe data corruption, who knows? A little patience now will save you a lot of pain a few months down the road.
My 2c: export class HelloHandler extends BaseHandler&lt;IHelloEvent&gt; implements IHelloHandler { public Logger: ILogger = new Logger(); public constructor() { super(); } protected HandleMessage(message: IHelloEvent) { this.Logger.log(message); } } You're stuck thinking of this problem in terms of C#. You've involved cross-cutting concerns in a class (since that's what you have to do in C#, since attributes are a reflection thing and there are no modules) and are writing unidiomatic typescript (with the `I` before interfaces, UpperCamel for methods/fields). Then, the entire thing relies on DI, instead of modules (idiomatic ES6). 
Not everything is as plug and okay as you’re looking for ;)
Of course &amp; that's why we are called developers! :-)
Very informative. Thank you.
&gt;Implement type guards in a way that leaves out opportunities for runtime failure. Make use of TypeScript’s implementations around discriminated unions and the type inference they offer. Use them for simpler cases like filtering out null and undefined. Since the article doesn't go into depth, this would look something like: interface Ok&lt;A&gt; { success: true; value: A; } interface Err&lt;B&gt; { success: false; error: B; } type Result&lt;A, B&gt; = | Ok&lt;A&gt; | Err&lt;B&gt;; const x: Result&lt;string, string&gt;; x.value // type error if (x.success) { x.value // good to go x.error // type error } else if (x.success === false) { x.value // type error x.error // good to go } When a sum type has multiple properties in common you can access them unqualified, and if they have certain values that imply they're one of the cases, the typescript compiler is smart enough to automatically narrow down the type without any (potentially error-prone) user-defined `is`.
Cool! That last part of the snippet can be improved for type inference like this: ``` if (x.success === true) { x.value // good to go x.error // type error } else { x.value // type error x.error // good to go } ```
Yeah, you have to have an explicit check in at least one of the branches. Unfortunately just doing `if (x.success) ... else ...` won't narrow the type down enough.
I was looking for an implementation of \`Result\` in [https://github.com/gcanti/fp-ts](https://github.com/gcanti/fp-ts) but I couldn't find one.
It's called `Either` in that project.
It's implemented as the `Either&lt;TErr, TResult&gt;` type - see https://gcanti.github.io/fp-ts/modules/Either.ts.html 
No, if you're running strict null checks it should be fine: if (x.success) { const ok: Ok&lt;string&gt; = x; } else { const err: Err&lt;string&gt; = x; }
Ah, yeah. I run my examples through the playground to make sure I'm not speaking rubbish and I forgot about the flag. 
I've been bitten by that many times. I wish it would save the options in your cookies so you don't need to change it each time! 
Yes, sorry. In the more haskell-y corners of FP it's typically called `Either`, but where I come from (with F# and rust) it's typically called [`Result`](https://fsharpforfunandprofit.com/rop/). 
i mean.. its open source.. probably a few line PR..
the entire site is like that
Why does the isBird call actually work? Is there something wrong with the `animal is Bird` that I'm missing?
declare global { }
thanks!
Lacking: - Macros (with similar spec to babel-plugin-macros) - Stable Decorators (more of a tc39 issue) - Proper generator typing (the return value of yield) - Custom type behaviour plugins (relates to macros, transformers, and webpack like imports) Wanted breaking changes: - Remove the `any` type, or change it's behaviour to match `unknown` - Types of arrays should be `Array&lt;T | undefined&gt;` so that `array[i]`'s type is not incorrectly guaranteed to be `T`, unless `array` is a tuple and `i` is within range. 
No problem, any time!
Since literally anything can be sent to your api handler, you need to assert your request body has the type you expect. I would argue that extending request to have your types encourages you to make assumptions that only prove true in ideal circumstances.
To TypeScript, this is basically type assertion (`as Bird`) constrained to the return value of the type guard. TS believes your implementation asserts the type properly even if it doesn't.
Ah! So you're telling the compiler that "if this function returns true then the value is a Bird", but you're just returning true always?
Yes
&gt;and most web-compatible solutions at this moment Wasn't that the cause of \`index.js\`, a point he mentioned regretting?
Thanks for the explanation!
Hey thanks for the amazing input! However, I actually don't feel very stuck? I designed it this way using InversifyJS. I really like the "auto-wire" idea behind forcing everything through DI via InversifyJS' Container. I am a C# guy first so maybe you're right... But that's also why I love TypeScript so much it's a taste of C# in the javascript universe. &amp;#x200B; Anyways... I like that I can register a handler to listen to any interface that's emitted. This also keeps my code a bit cleaner without the callbacks etc.. Everything is handled in it's own class. &amp;#x200B; I would love to checkout any repos you have that do something similar to this! 
Not an article, but this project and its documentation are great https://github.com/gcanti/fp-ts
\`index.html\` is web compatible, not \`index.js\`
i read articles from this guy in the subway today and i think its a good blog. [https://dev.to/busypeoples/notes-on-typescript-fundamentals-for-getting-started-3cjo](https://dev.to/busypeoples/notes-on-typescript-fundamentals-for-getting-started-3cjo)
This is a great guide to writing clean OO / SOLID code in TypeScript. https://labs42io.github.io/clean-code-typescript/
I've always found this feature to make code more difficult to understand especially when you're mixing identifiers from global, closure, class, and local scope. I like that JS/TS make it easy to figure out where an identifier is defined.
Yes, that's the connection. When Ryan Dahl said it "I thought it was cute because there was index.html". Reference: [https://youtu.be/M3BM9TB-8yA?t=875](https://youtu.be/M3BM9TB-8yA?t=875), slides ([https://tinyclouds.org/jsconf2018.pdf](https://tinyclouds.org/jsconf2018.pdf)). &amp;#x200B; It's a tenuous connection I recognize. My observation was simply that if "thinking about web compatibility" has caused one node regret it might be worth reflecting on.
Front End Masters has an intermediate react course with a typescript module at the end. I haven't done it though so not sure if its any good.
[https://github.com/piotrwitek/react-redux-typescript-guide](https://github.com/piotrwitek/react-redux-typescript-guide)
Better default configuration options... Begone `noImplicitAny`. &lt;3 u `strictNullChecks`
There are too few. You basically have to learn each then apply what you know. 
Does this work? ```typescript type MapKeysToTuple&lt;T&gt; = { [index: number]: keyof T; } ``` Whether that works or not, don't you need to pass the type into bar? ```typescript const baz = bar&lt;typeof foo&gt;(foo); // or const baz: MapKeysToTuple&lt;typeof foo&gt; = bar&lt;typeof foo&gt;(foo); ```
Frankenstein result so far, it works but I think is far too much code and I'm sure could be simplified &amp;#x200B; **type** Cons&lt;T **extends any**\[\], H&gt; = ((h: H, ...t: T) =&gt; **any**) **extends** ((...r: **infer** R) =&gt; **any**) ? R : **never**; **type** Reduction&lt;Base, In&gt; = \[ Base, In \] **type** UnionReduce&lt;U, R **extends** Reduction&lt;**any**, **any**\&gt;&gt; = R\[\[ U \] **extends** \[ **never** \] ? 0 : 1\]; **type** UnionToIntersection&lt;U&gt; = (U **extends any** ? (k: U) =&gt; **void** : **never**) **extends** ((k: **infer** I) =&gt; **void**) ? I : **never**; **type** UnionToFunctionOverloads&lt;U&gt; = UnionToIntersection&lt;U **extends any** ? (f: U) =&gt; **void** : **never**\&gt;; **type** UnionPop&lt;U&gt; = UnionToFunctionOverloads&lt;U&gt; **extends** ((a: **infer** A) =&gt; **void**) ? A : **never**; **interface** UnionToTupleRecursive&lt;T **extends any**\[\], U&gt; **extends** Reduction&lt;T, UnionReduce&lt;Exclude&lt;U, UnionPop&lt;U&gt;&gt;, UnionToTupleRecursive&lt;Cons&lt;T, UnionPop&lt;U&gt;&gt;, Exclude&lt;U, UnionPop&lt;U&gt;&gt;&gt;&gt;&gt; { } **export type** UnionToTuple&lt;U&gt; = UnionReduce&lt;U, UnionToTupleRecursive&lt;\[\], U&gt;&gt; **extends infer** T ? T **extends any**\[\] ? T : **never** : **never**; **type** MapKeysToTuple&lt;T&gt; = UnionToTuple&lt;**keyof** T&gt; **const** foo = { a: 1, b: 2, c: 3 } **function** bar&lt;T&gt;(thing: T): MapKeysToTuple&lt;T&gt; { **...** } **const** baz = bar(foo) // type is \[ 'a', 'b', 'c' \], success!
The type of \`foo\` would be inferred by the compiler. And regarding your solution, the resulting type does not conform to the requirement of being a tuple. I posted a link to a solution I've found.
I have been following Deno for half a year and from my observation, Ryan's idea at this point is basically "if web standards has clearly defined something and we want to use it, we must implement them exactly as specified. If we want to add Deno only stuff, they will all only live under \`window.Deno\` namespace". &amp;#x200B; No compatibility with web has brought for more regrets for Ryan. Also connection between \`index.js\` and \`index.html\` is only nominal: ES module standards do not resolve modules in such way.
Simply means reassigning to a variable. let a = 2; a = 3; // rebinding const b = 3; b = 4; // illegal, can’t rebind a const
I think what they mean is _reassigning_. Someone can give you a more technical answer, but it essentially means doing the following: `myVar = newValue`. With `let` you can do that, just like with `var`. With `const` you cannot reassign, however you can still use potentially mutating methods on the variable value itself, for example `Array.prototype.push`. In my opinion you should always be `const` by default as it confers meaning. I wish it meant values were totally immutable, however it's still useful even just to know the variable won't be reassigned. Note that this is pure JavaScript, nothing to do with TypeScript.
https://github.com/Microsoft/frontend-bootcamp/blob/master/README.md
Link to the original article https://medium.freecodecamp.org/from-yaml-to-typescript-a-developers-view-on-cloud-automation-bba5365439f4
damn thats a lot of types
Just curious, how do you plan on using this type? I can't think of a use case that one could depend on this type because how can you guarantee the order of the keys in the tuple?
TS should do the path mapping right! After more than 2 year this is still not resolved. [https://github.com/Microsoft/TypeScript/issues/10866](https://github.com/Microsoft/TypeScript/issues/10866)
It doesn't look like that's possible with this library. `Just` and `Nothing` are both defined as classes that implement those methods through an interface, so if have a `Maybe&lt;number&gt;` it has to be either an instance of `Just&lt;number&gt;` or `Nothing&lt;number&gt;`. Check out the source for `Maybe`: https://github.com/true-myth/true-myth/blob/master/src/maybe.ts
This is just an unfortunate limitation of the type system. When you're drilling down into objects like that, it can get confused and instead defaults to the safer route. I think there are also some instances where properties can change on each access, so it can't be 110% sure that the value will be non-null. The easy way to tell TS that you know something will be present is with the `!` postfix operator: this.state.scoreList!.map(...)
I see, thank you for the quick reply, TIL about the postfix operator :) Unfortunately this now throws `Type error: Property 'map' does not exist on type 'never'. TS2339` May I pick your brain again for an idea about this?
He might also have problems with how he defined the component. I wonder what type the language-server returns for \` this.state.scoreList\`
Hmm, I usually don't run into that problem with the ! operator. Do you think you can post some more of your code? Especially the relevant definition for your state type? without knowing what it's supposed to be it's hard to know. If you can recreate the issue in a codesandbox that would be ideal.
Alrighty, so the thing that catches my eye, is the fact that you have curly braces around the component in your map. This means that the map is going to return a nice list consisting of `undefined`.^(how did no one catch that?) You might want to look into where typescript says the error is. when an error occurs it always gives the line number + at what position in that line the error is.
&gt;`const {scoreList} : any = this.state` Oh please for the love of, don't do this. The beautiful thing about TypeScript is that you can add type safety to your code. To use \`any\` throws that in the garbage. I would only use \`any\` when you're certain that you have no other choice. It is something that could be used as a last resort, but nothing more.
This is actually a pretty difficult problem, as seen in the discussion [here](https://github.com/Microsoft/TypeScript/issues/12290). For a single key, it is easy enough: function q&lt;T, K extends keyof T&gt;(record: T, key: K): T[K] { return record[key] } `keyof T` is the union of all string literals that can be used as a key for the record (`'name' | 'town'`), and K is a subset of those (essentially a single string literal). Then typescript can infer the type of the value accessed as T\[K\]. By the same logic, we can extend the above function to provide a second key: function q2&lt;T, K extends keyof T, K2 extends keyof T[K]&gt;(record: T, key1: K, key2: K2): T[K][K2] { const value1 = record[key1] if (value1 == null) return null return value1[key2] } The above code is not 100% correct, because we don't handle the case where T\[K\] is a nullable type and we can't safely access T\[K\]\[K2\]. The actual working signature is function q&lt;T, K1 extends keyof T, K2 extends keyof NonNullable&lt;T[K1]&gt;&gt;(record: T, key1: K1, key2: K2): NonNullable&lt;T[K1]&gt;[K2] | null This gets quite complicated already. Now to choose the appropriate signature with variable number of key arguments, we have to define this function signature for a number of arguments and use function overload to combine them all into one function. In my knowledge, there is no way to do this recursively with a single function signature (but I would be happy if someone could present a solution). What I came up with, for up to 3 keys (but could be extended further): function q&lt;T, K extends keyof T&gt;(record: T, key: K): T[K] | null function q&lt;T, K1 extends keyof T, K2 extends keyof NonNullable&lt;T[K1]&gt;&gt;( record: T, key1: K1, key2: K2 ): NonNullable&lt;T[K1]&gt;[K2] | null function q&lt; T, K1 extends keyof T, K2 extends keyof NonNullable&lt;T[K1]&gt;, K3 extends keyof NonNullable&lt;NonNullable&lt;T[K1]&gt;[K2]&gt; &gt;( record: T, key1: K1, key2: K2, key3: K3 ): null | NonNullable&lt;NonNullable&lt;T[K1]&gt;[K2]&gt;[K3] function q(record: any, key1: any, key2?: any, key3?: any): any { const v1 = record[key1] if (v1 == null) return null const v2 = v1[key2] if (v2 == null) return null const v3 = v2[key3] return v3 } With this "simple" function, we can now safely do this: `const countryOrNull = q(person, 'town', 'city', 'country')` And the Type checker will both validate our key literals, as well as provide the correct type for the variable
[removed]
You need to give a more complete code snippet than that. The error is not caused by the ternary operator at all, and the previous answers are wrong.
thanks very much for your reply! &amp;#x200B; so it can't be made recursive, but if I was willing to do the typing it could support arbitrary-big-number of levels, I guess. &amp;#x200B; really what I need is optional chaining (\`person?.town?.city?.country\`) and I know this is a tc39 prop but hopefully I can knock something together in the mean time with your help above - thanks! &amp;#x200B; if anyone has any other advise for solving this sort of problem, please let me know :) &amp;#x200B; (this problem occurs a lot with graphql results where data is often very deeply nested and every level is potentially undefined because graphql schema types are nullable by default)
You shouldn't need the any, and if you find yourself using it, try to figure out how to not use it. Typsecript should be able to infer the type when unpacking. 
The issue I'm talking about [here](https://www.reddit.com/r/typescript/comments/axoih5/strict_null_checks_in_ternary_operators/ehv3tsl), is probably not the solution to his problem, which is something I'm aware of. I do know that it is something which will present itself when OP actually runs it in the browser ^(I know, because I have experienced this before (:) I do agree that we don't have enough information to provide a solution, like the type of `this.state`, or where the error actually is. ('*the 4th line of this snippet*' doesn't tell us enough).
yeah that also indicates that the snippet is not the whole story. I'm guessing that they are accessing the variable from the ternary within a closure, which would make the non-null inference break since the compiler does not know that lambdas are immediately executed
The caller should be available as `this`. However, callers can rebind `this` to whatever they want.
SpecificReturn.unspecificContent can never have an inferred type without generics. Maybe you're looking for something more like this? type SomeApi = { doStuff: Function } type SpecificReturn&lt;T&gt; = { unspecificContent: T } type SomeFunctionType&lt;U extends SpecificReturn&lt;T&gt;&gt; = (a: SomeApi, b: number) =&gt; U const aFunction: SomeFunctionType&lt;SpecificReturn&lt;string&gt;&gt; = (a, b) =&gt; { return { unspecificContent: 'hello' } } 
thats not typescript complaining, thats your linter - you should modify your linter most likely. though i believe in typescript, class methods are bound by default
If I've understood it correctly, I wonder if `console.trace()` would give you what you need?
A less efficient and more verbose option is to break it down to a helper/wrapper class that represents each level of property access, but the types are correct: \`\`\`ts const foo = opt(me).get("town").get("city").get("country").value(); \`\`\` The \`opt()\` function returns an instance of the helper class containing a reference to \`me\`, which has a \`get()\` function that only accepts \`keyof Person\` as a param and returns a helper/wrapper class properly typed for the next level down, etc.. Call the \`value()\` at any level to unwrap the value. &amp;#x200B; Here's my rough draft of this idea in the TypeScript playground (be sure to enable the strictNullChecks option): [TypeScript Playground Link](https://www.typescriptlang.org/play/#src=function%20opt%3CT%3E(value%3A%20T)%3A%20undefined%20extends%20T%20%3F%20opt.MaybeValue%3CExclude%3CT%2C%20undefined%3E%3E%20%3A%20opt.Value%3CT%3E%20%7B%0D%0A%20%20%20%20return%20new%20opt.MaybeValue(value)%20as%20any%3B%0D%0A%7D%0D%0A%0D%0Anamespace%20opt%20%7B%0D%0A%20%20%20%20export%20declare%20class%20Value%3CT%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20public%20value()%3A%20T%3B%0D%0A%20%20%20%20%20%20%20%20public%20get%3CK%20extends%20keyof%20T%3E(key%3A%20K)%3A%20undefined%20extends%20T%5BK%5D%20%3F%20MaybeValue%3CExclude%3CT%5BK%5D%2C%20undefined%3E%3E%20%3A%20Value%3CT%5BK%5D%3E%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20export%20class%20MaybeValue%3CT%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20public%20constructor(private%20readonly%20_value%3A%20T%20%7C%20undefined)%20%7B%20%7D%0D%0A%0D%0A%20%20%20%20%20%20%20%20public%20value()%3A%20T%20%7C%20undefined%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20this._value%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20%20%20%20%20public%20get%3CK%20extends%20keyof%20T%3E(key%3A%20K)%3A%20MaybeValue%3CExclude%3CT%5BK%5D%2C%20undefined%3E%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(this._value%20%3D%3D%3D%20undefined)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20new%20MaybeValue%3CExclude%3CT%5BK%5D%2C%20undefined%3E%3E(undefined)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20new%20MaybeValue%3CExclude%3CT%5BK%5D%2C%20undefined%3E%3E(this._value%5Bkey%5D%20as%20any)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20%7D%20%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Ainterface%20Person%20%7B%0D%0A%20%20name%3F%3A%20string%0D%0A%20%20town%3A%20%7B%0D%0A%20%20%20%20city%3F%3A%20%7B%0D%0A%20%20%20%20%20%20country%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%0D%0A%7D%0D%0A%0D%0Afunction%20testWithUndefined(person%3A%20Person%20%7C%20undefined)%20%7B%0D%0A%20%20%20%20const%20foo%20%3D%20opt(person).get(%22town%22).get(%22city%22).get(%22country%22).value()%3B%0D%0A%20%20%20%20alert(foo)%3B%0D%0A%7D%0D%0A%0D%0Afunction%20testWithoutUndefined(person%3A%20Person)%20%7B%0D%0A%20%20%20%20const%20foo%20%3D%20opt(person).get(%22town%22).get(%22city%22).get(%22country%22).value()%3B%0D%0A%20%20%20%20alert(foo)%3B%0D%0A%7D%0D%0A%0D%0AtestWithoutUndefined(%7B%0D%0A%20%20%20%20name%3A%20%22Bob%22%2C%0D%0A%20%20%20%20town%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20city%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20country%3A%20%22USA%22%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%7D)%3B) &amp;#x200B; I gave up and typecast to any in the implementation of some functions instead of figuring out how to really get types to be 100% in the implementation, but the end result is both correct compile time types and correct runtime behavior. The result of \`value()\` is properly typed to either contain \`| undefined\` in its type or not, depending on whether there is anything potentially undefined upstream of that location in the nested path. &amp;#x200B; Notice that the \`opt.Value\` class has no implementation. Its only purpose is to provide correct compile-time types the \`value()\` function, while \`opt.MaybeValue\` is always used for the runtime implementation (no need to duplicate that code).
What do you mean class methods are bound by default?
Thanks for your fast and detailled answer :). Sadly in my realworld scenario the inferred type of unspecificContent is not just a string but nested objects based on multiple also nested function calls inside aFunction. Typescript infers this correctly as long as I dont add ":SomeFunctionType". With a generic SomeFunctionType all consumers of it would have to write their complex unspecificContent type manually which would be very redundant ^^
`this` inside a class method should point to the class instance
Cool optimization in `opt.MaybeValue.value()`: ```ts if (this._value === undefined) { // Any instance of MaybeValue with _value === undefined is functionally equivalent // at runtime, regardless of compile-time type, so there's no need to create/return a // new instance of MaybeValue with _value === undefined once we've hit the first // undefined value in the chain. Just reuse this instance. return this as any; } else { // ... } ```
I could probably reorganize this to be cleaner. I'll post an update if I do.
Not entirely sure this is what you meant, it's kind of odd (in my opinion) to have a contract like this. It's very SOAP API-like and assumes a lot of your functions have similar signatures but differing return types. &amp;#x200B; Nonetheless, this might be what you wanted: type SomeApi = { doStuff: Function }; type SpecificResponse&lt;T&gt; = { value: T unspecificValue: any; } type SomeFunctionType&lt;T&gt; = (a: SomeApi, b: number) =&gt; SpecificResponse&lt;T&gt; let aFunctionReturningString: SomeFunctionType&lt;string&gt;; &amp;#x200B; Using this, you can then call `aFunctionReturningString()` and access `.value` or `.unspecificValue`.
&gt;though i believe in typescript, class methods are bound by default I don't think that's true. If you want to ensure this resolves to the class, use arrow function properties. 
yeah true, i think i'm just so used to using arrow function properties that i assumed.
I would prob do it with a helper function. &amp;#x200B; type SomeApi = { doStuff: Function }; type SpecificReturn = { unspecificContent: unknown }; type SomeFunctionType = (a: SomeApi, b: number) =&gt; SpecificReturn; const helper = &lt;T extends SpecificReturn&gt;(func: (a: SomeApi, b: number) =&gt; T) =&gt; { return func; } const bFunction = helper((a, b) =&gt; { return { unspecificContent: 's', other: '' } }); Function wrappers tend to have more type control/cleaner syntax imo than complex type declarations. &amp;#x200B;
Depends how it was called. You can break that pretty easily. class Foo { method() { console.log(this); } } let fn = (new Foo).method; fn();
 logger = Logger.get('MyClass') logger.info('something')
This is really good, thanks for sharing.
https://reactjs.org/docs/faq-functions.html#bind-in-constructor-es2015 
I was putting the *any* in as a placeholder, I specified the type there, I figured people who read this would know to substitute the any with the right type specification. I use any sparsely, but I have `x as any` in my project once or twice where I just can't figure it out.
Alright, so here is the complete file after I made some changes from the comments. It works as intended but I am afraid about what u/Limecta and you said, that the error might still be present I just got lucky getting away with `any`. import axios from 'axios' import React, { Component } from 'react' import CircularProgress from '@material-ui/core/CircularProgress' import TableHead from '@material-ui/core/TableHead' import TableRow from '@material-ui/core/TableRow' import TableCell from '@material-ui/core/TableCell' axios.defaults.baseURL = 'http://127.0.0.1:5000' axios.defaults.headers['Content-Type'] = 'application/x-www-form-urlencoded' axios.defaults.headers['Accept'] = 'application/json' interface IScore { name: string, likes: number, likesSum: number, lps: number, } interface IProps { } interface IState { scoreList: Array&lt;IScore&gt; | null, } export default class Leaderboard extends Component&lt;IProps, IState&gt; { state = { scoreList: null, } private getAllScores = () =&gt; { axios.get('/scores') .then(function (response) { console.log(response.data); }) .catch( error =&gt; console.error(error) ) } render() { const { scoreList }: any = this.state; return ( &lt;div&gt; &lt;TableHead /&gt; {scoreList === null ? &lt;CircularProgress /&gt; : scoreList.map((row: IScore) =&gt; { return ( &lt;TableRow&gt; &lt;TableCell&gt;{row.name}&lt;/TableCell&gt; &lt;TableCell&gt;{row.likes}&lt;/TableCell&gt; &lt;TableCell&gt;{row.likesSum}&lt;/TableCell&gt; &lt;TableCell&gt;{row.lps}&lt;/TableCell&gt; &lt;/TableRow&gt;) }) } &lt;/div&gt; )} }
This is exactly how I would do it as well. Sometimes a wrapper like this is needed to work with automatically inferred types.
I'm seeing a few things here. First of, you probably want to tap more into the power of typescript, which is its type system. In your State where you say ```scoreList: Array&lt;IScore&gt; | null```. What you want to do instead is tell typescript that it going to be ```scoreList: Array&lt;IScore&gt; | "loading"```. Typescript understands this, and it makes it easier for you to check whether or not the calue is present. Second, you're not using a contructor. In the constructor, you want to set the initial value of your state, and nowhere else. Your contructor requires a props parameter. And you must also call super with that parameter. This might be the cause of your problem but i'm not sure Third, for in the future. When retrieving data for the first time, you want to do that in the `componentDidMount` method, because you're sure the component exists by then. And fourth, which may be a bit nitpicky, but i prefer to just use ```let scoreList = this.state.scoreList``` instead of ```const {scoreList} = this.state``` And lastly, if you don't already, but please use visual studio code for typescript projects, because they play really nicely with eachother. Vscode's is a dream to work with, and with it's intellisense, it gives you a lot of insight in your typescript code. 
What you've done here is almost completely implement a `Maybe&lt;T&gt;` monad! I pieced together a more complete monad: type Nil = null | undefined; class Maybe&lt;T&gt; { private wrappedValue: T | Nil; constructor(value: T | Nil) { this.wrappedValue = value; } map&lt;U&gt;(fn: (value: T) =&gt; U): Maybe&lt;U&gt; { if(!this.wrappedValue) { return this as Maybe&lt;any&gt;; } return new Maybe(fn(this.wrappedValue)); } flatMap&lt;U&gt;(fn: (value: T) =&gt; Maybe&lt;U&gt;): Maybe&lt;U&gt; { if(!this.wrappedValue) { return this as Maybe&lt;any&gt;; } return fn(this.wrappedValue); } get&lt;K extends keyof T&gt;(key: K): Maybe&lt;T[K]&gt; { return this.map(value =&gt; value[key]); } valueOrDefault(defaultValue: T | Nil): T { return this.wrappedValue ? this.wrappedValue : defaultValue; } } interface Person { name: string; town: { city: { country: string; } } } const alice: Person = { name: 'Alice', town: { city: { country: 'AliceCountry' } } }; const bob: any = { name: 'Bob' }; const maybeAlice = new Maybe(alice); const aliceCountry = maybeAlice.get('town').get('city').get('country').valueOrDefault('default value'); console.log(aliceCountry); // &lt;= logs 'AliceCountry' const maybeBob = new Maybe&lt;Person&gt;(bob); const bobCountry = maybeBob.get('town').get('city').get('country').valueOrDefault('default value'); console.log(bobCountry); // &lt;= logs 'default country' 
Maybe this will help? https://www.reddit.com/r/typescript/comments/ardmqb/an_example_of_generic_higher_order_functions_in/ In particular, `ReturnType&lt;T&gt;`
Ok, so the problem here is that by declaring `state = { scoreList: null }` as a class property, TypeScript "incorrectly" restricts the type of ScoreList to only allow `null` instead of `IScore[] | null` which you want. You can verify by hovering over this.state.scoreList which will show `scoreList: null` as the inferred type. Which is why it showed never in the else branch of your ternary operator (because if it has to be null, it can never be not null). The easiest solution is to declare it with the explicit type state: IState = { scoreList: null }; This is kinda confusing behaviour from TS since you did declare the type of state correctly in the `extends`, but for TS your code means that your component is a more specific version of one that _would accept_ `state: {scoreList: IScore[] | null}` but it only accepts scoreList as a constant null value not a list or null.
[removed]
What an awful example of object-orientation.
In C# it's called an object initializer. You can't do the exact same thing in TS, but you can change the signature of the constructor to take a single object argument, and then destructure it. 
`class Person { constructor({ name, age, gender }) {` [`this.name`](https://this.name) `= name; this.age = age; this.gender = gender; } }`
Just wrap params inside of the object.
Ya, but then you always have to use the object initializer. It would be nice to be able to call \`const person = new Person('me', 5, male)\` most of the time, but use \`const person = new Person(){ age: 5 }\` sometimes. Obviously this isn't a huge deal with 3 parameters, but some objects can have 10-20+ of them and that's when it becomes a pain...
Now we're talking, this is brilliant! :D And it seems to even work if T directly extends SomeFunctionType like here: const enforceSomeFunction = &lt;T extends SomeFunctionType&gt;(consumer: T) =&gt; { return consumer; } Thanks a ton :)
Thanks. So there's no way to use either? I had a feeling this was the case since there's no function/constructor overloading. I'm trying to It would be nice to be able to call `const person = new Person('me', 5, male)` most of the time, but use `const person = new Person(){ age: 5 }` other times. Obviously this isn't a huge deal with 3 parameters, but some objects can have 10-20+ of them and that's when it becomes a pain... 
Many thanks :) for your answer. Haha if it would be a SOAP API, then I would know what's the root source of all my problems xDD :P. Someone mentioned a best-of-both worlds solution which enforces the SomeFunctionType without loosing the inferred return type from aFunction here: [https://www.reddit.com/r/typescript/comments/axrg5a/how\_to\_use\_a\_function\_type\_but\_keep\_inferred/ehvtoy5](https://www.reddit.com/r/typescript/comments/axrg5a/how_to_use_a_function_type_but_keep_inferred/ehvtoy5) &amp;#x200B; I think your solution is perfect for those situations where T really is a simple type +1. I guess I should have initially stated more clearly that aFunctions unspecificContent in this very specific realworld case is a lot more complicated than just a string \^.\^
Do you need to use a class? If not, you can just use an interface with optional properties. For example: interface Person { name?: string; age?: number; gender?: Gender; }; const person = {age: 3};
The C# object initializer is just syntax sugar for: var person = new Person(); person.age = 3; Something like that would violate the design goal 8 of TypeScript and won't be added (unless JS adds it first). The 'cleanest' alternative is suggested by /u/Drawman101.
Updated answer
You can make use of overloading and provide several constructors. &gt; but some objects can have 10-20+ of them and that's when it becomes a pain... Having objects that have so many properties sounds like pain in itself already.
Here's how I'd write this: enum Gender { Male, Female, } interface IPerson { name: string; age: number; gender: Gender; } class Person implements Partial&lt;IPerson&gt; { name?: IPerson['name']; age?: IPerson['age']; gender?: IPerson['gender']; constructor(person: Partial&lt;Person&gt;) { for (const [key, val] of Object.entries(person)) { this[key] = val; } } } const a = new Person({}); const b = new Person({ age: 25 }); const c = new Person({ name: 'Hodor', age: 25, gender: Gender.Male }); You can have it work with null default values instead of undefined but then it's a bit more verbose and fiddly.
Cheers for your idea. ReturnType is often really useful yuus, and if you have a function returning a function you even can use `ReturnType&lt;ReturnType&lt;T&gt;&gt;` :D. Unfortunately you can not use it, to retrieve the inferred return type of a previously `:SomeFunctionType` typed function \^\^.
That's kinda funny. I didn't realize I was creating something so similar to a `Maybe&lt;T&gt;` because I was so focused on compile-time type trickery to get the result of `value()` to have `| undefined` in its type ONLY if the value or anything up the chain may possibly be undefined. A typical `Maybe&lt;T&gt;` implementation is simpler because always it starts off with the assumption that the value may be undefined. I simplified the types in my example, added full support for both `null` and `undefined`, and added a bit of `Maybe&lt;T&gt;` flavor to it by requiring that you must provide a default value to the `value()` function... but ONLY if the wrapped value may potentially be `null` or `undefined`: type nil = null | undefined; function opt&lt;T&gt;(value: T): opt.Value&lt;T&gt; { return new opt.Value(value); } namespace opt { export class Value&lt;T&gt; { public constructor(private readonly _value: T) { } public value(this: Value&lt;Exclude&lt;T, nil&gt;&gt;): T; public value(defaultValue: Exclude&lt;T, nil&gt;): Exclude&lt;T, nil&gt;; public value(defaultValue: Exclude&lt;T, nil&gt; | null): Exclude&lt;T, nil&gt; | null; public value(defaultValue: Exclude&lt;T, nil&gt; | undefined): Exclude&lt;T, nil&gt; | undefined; public value(defaultValue: T | nil): T | nil; public value(defaultValue?: T | nil): T | nil { return this._value == null ? defaultValue : this._value; } public get&lt;K extends keyof Exclude&lt;T, nil&gt;&gt;(key: K): Value&lt;Exclude&lt;T, nil&gt;[K] | (Extract&lt;T, nil&gt; extends never ? never : undefined)&gt; { if (this._value === undefined) { // optimization: no need to create a new instance of Value wrapper around // an undefined value. Just reuse this one. return this as Value&lt;any&gt;; } else if (this._value === null) { return new Value&lt;any&gt;(undefined); } else { return new Value&lt;any&gt;((this._value as Exclude&lt;T, nil&gt;)[key]); } } } } [TypeScript Playground Link](https://www.typescriptlang.org/play/#src=type%20nil%20%3D%20null%20%7C%20undefined%3B%0D%0A%0D%0Afunction%20opt%3CT%3E(value%3A%20T)%3A%20opt.Value%3CT%3E%20%7B%0D%0A%20%20%20%20return%20new%20opt.Value(value)%3B%0D%0A%7D%0D%0A%0D%0Anamespace%20opt%20%7B%0D%0A%20%20%20%20export%20class%20Value%3CT%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20public%20constructor(private%20readonly%20_value%3A%20T)%20%7B%20%7D%0D%0A%0D%0A%20%20%20%20%20%20%20%20public%20value(this%3A%20Value%3CExclude%3CT%2C%20nil%3E%3E)%3A%20T%3B%0D%0A%20%20%20%20%20%20%20%20public%20value(defaultValue%3A%20Exclude%3CT%2C%20nil%3E)%3A%20Exclude%3CT%2C%20nil%3E%3B%0D%0A%20%20%20%20%20%20%20%20public%20value(defaultValue%3A%20Exclude%3CT%2C%20nil%3E%20%7C%20null)%3A%20Exclude%3CT%2C%20nil%3E%20%7C%20null%3B%0D%0A%20%20%20%20%20%20%20%20public%20value(defaultValue%3A%20Exclude%3CT%2C%20nil%3E%20%7C%20undefined)%3A%20Exclude%3CT%2C%20nil%3E%20%7C%20undefined%3B%0D%0A%20%20%20%20%20%20%20%20public%20value(defaultValue%3A%20T%20%7C%20nil)%3A%20T%20%7C%20nil%3B%0D%0A%20%20%20%20%20%20%20%20public%20value(defaultValue%3F%3A%20T%20%7C%20nil)%3A%20T%20%7C%20nil%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20this._value%20%3D%3D%20null%20%3F%20defaultValue%20%3A%20this._value%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20%20%20%20%20public%20get%3CK%20extends%20keyof%20Exclude%3CT%2C%20nil%3E%3E(key%3A%20K)%3A%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20Value%3CExclude%3CT%2C%20nil%3E%5BK%5D%20%7C%20(Extract%3CT%2C%20nil%3E%20extends%20never%20%3F%20never%20%3A%20undefined)%3E%0D%0A%20%20%20%20%20%20%20%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(this._value%20%3D%3D%3D%20undefined)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20optimization%3A%20no%20need%20to%20create%20a%20new%20instance%20of%20Value%20wrapper%20around%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20an%20undefined%20value.%20Just%20reuse%20this%20one.%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20this%20as%20Value%3Cany%3E%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20if%20(this._value%20%3D%3D%3D%20null)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20new%20Value%3Cany%3E(undefined)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20new%20Value%3Cany%3E((this._value%20as%20Exclude%3CT%2C%20nil%3E)%5Bkey%5D)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20%7D%20%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Ainterface%20Person%20%7B%0D%0A%20%20%20%20name%3F%3A%20string%3B%0D%0A%20%20%20%20town%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20city%3F%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20country%3A%20string%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%3B%0D%0A%20%20%20%20path%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20without%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20optionals%3A%20number%3B%0D%0A%20%20%20%20%20%20%20%20%7D%3B%0D%0A%20%20%20%20%7D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20testWithUndefined(person%3A%20Person%20%7C%20undefined)%20%7B%0D%0A%20%20%20%20%2F%2F%20default%20value%20required%20for%20all%20paths%20because%20root%20of%20path%20may%20be%20undefined%0D%0A%20%20%20%20const%20foo%20%3D%20opt(person).get(%22town%22).get(%22city%22).get(%22country%22).value(%22default%20value%22)%3B%0D%0A%20%20%20%20const%20bar%20%3D%20opt(person).get(%22path%22).get(%22without%22).get(%22optionals%22).value(99)%3B%0D%0A%20%20%20%20alert(foo%20%2B%20%22%3B%22%20%2B%20bar)%3B%0D%0A%7D%0D%0A%0D%0Afunction%20testWithoutUndefined(person%3A%20Person)%20%7B%0D%0A%20%20%20%20%2F%2F%20default%20value%20required%20because%20%22city%22%20is%20optional%0D%0A%20%20%20%20const%20foo%20%3D%20opt(person).get(%22town%22).get(%22city%22).get(%22country%22).value(%22default%20value%22)%3B%0D%0A%20%20%20%20%2F%2F%20default%20value%20not%20required%20for%20this%20non-optional%20path%0D%0A%20%20%20%20const%20bar%20%3D%20opt(person).get(%22path%22).get(%22without%22).get(%22optionals%22).value()%3B%0D%0A%20%20%20%20alert(foo%20%2B%20%22%3B%22%20%2B%20bar)%3B%0D%0A%7D%0D%0A%0D%0AtestWithoutUndefined(%7B%0D%0A%20%20%20%20name%3A%20%22Bob%22%2C%0D%0A%20%20%20%20town%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20city%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20country%3A%20%22USA%22%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%2C%0D%0A%20%20%20%20path%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20without%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20optionals%3A%2042%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%7D)%3B%0D%0A%0D%0A) &amp;#x200B; Not sure if this is an actual useful idea, but it was fun to play around with.
You can do function overloads in TS. I'm on mobile, so I can't find the documentation now. 
look for typescript issues with most comments [https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc](https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc)
Wow, thanks for taking the time and writing all of this up, this is amazing, I feel like I owe you something now. &gt; What you want to do instead is tell typescript that it's going to be &gt; &gt; scoreList: Array&lt;IScore&gt; | "loading" &gt; &gt; Typescript understands this, and it makes it easier for you to check whether or not the value is present. This is a huge leg up, thank you! &gt; you're not using a contructor AFAIK using `npx create-react-app --typescript` (which is what I did) sets up the project in a way you can omit the constructor, correct me if I'm wrong. &gt; When retrieving data for the first time, you want to do that in the `componentDidMount` method Yes, that makes sense, thank you for pointing it out. I am in fact using VSCode for about 4 months now (coming from Atom) and I do agree that it's very pleasantly designed to put information where you need it, but sometimes that's the last place I look :'D. &gt; You should avoid using `null` or `undefined` as initial values just as much as using any as a type. Thank you for pointing this out as well, I did not know that those are equally/nearly as unpreferable and have used it quite a bit, will have to revisit some parts of my code now. You a real hero bruv! 
I don't think I have ever read a comment that has outlined a complicated matter as easily understandable as this one. Thank you so much for the help and the insight into what TS 'thinks' behind the scenes.
It says first class TypeScript support, yet the introduction says to create a `fuse.js` instead of a `fuse.ts`.
Because that’s the build file. Node can only work with JavaScript. 
They could transpile it on the fly. I want type safety in my build script as well.
Have you installed/added [`@types/react`](https://www.npmjs.com/package/@types/react) as a dev dependency?
This isn't going to help at all but I just avoid VS like the plague when it comes to writing TypeScript; it's all VS Code for me. I've struggled for years with BS compiler errors so now I just ignore it and life is happier...
This is a valid question. I should have mentioned that. Yes I have. It is a dev dependency and installed.
I’ve done this with fusebox before and the downside is that more time is spent transpiling than on the build itself. I’ve found a good workaround is to add a // @ts-check to the top of the file and use jsdoc as necessary. 
Haha. Not helpful, but it does make me feel better that I'm not alone in this struggle. I've been using VS Code and it is pretty fantastic. I just hate switching back and forth if I happen to be in another part of the project. 
If the entire build and bundling is measured in milliseconds, why would take the transpilation more than milliseconds?
&gt; design goal 8 of TypeScript Can you explain design goals 8 and 9?
Goal 8 means that they won't add any syntax that isn't present in ECMAScript already. TypeScript is just ECMAScript with type annotations. An object initializer like the one from C# would mean new syntax is added. This might collide with future additions of ECMAScript, and that would risk goal 6. What if TypeScript added syntax that is incompatible with a new ECMAScript feature? Goal 9 means that the type system is just present at compilation. After compilation it's completely gone, it's been "erased". That's also why TypeScript won't generate type checks for you. Structural type system means: If it behaves like a duck, it is a duck. If you have two different interfaces that share the same properties, then the interfaces are interchangeable. The opposite would be nominal typing, which is what C# uses. Nominal type systems increase type safety as you can't accidentally use the wrong type just because it matches.
Dead link. [ES4X](https://reactiverse.io/es4x/) is linked to a typo reactiverse.io.ex4x Any way I can help out on the project as an old person who isn't in school?
Thank you very much!
Finally! Great work to devs and much thanks. 
I love fusebox. So much faster then webpack. Its just a bit scary that the project is lifted by one guy (nchanged). But he is very responsive on github and accepts pull requests.
Investigate the stack trace API of your target runtime. You can iterate the stack frames to find location information for the caller. There is a performance hit, however. A better approach might be a compile-time transformer that inserts location information into each logger call.
I would update the linter rules so it stops complaining about stuff I want to do.
After dealing with a ColdFusion library of the same name, I will pass. Think I have PTSD from working with it.
I actually like it - vs for server side code, vs code for front end.. helps me to easily swap between the two concerns, having a bunch of files open to do with one thing in one, and a bunch to do with another open in the other.. that was almost incoherent but I think you get the drift
Haven't used fusebox, but I doubt this is the case. you can pass `-r ts-node/register` (assuming ts-node is installed) to `node`, or you can just set NODE_OPTIONS to `ts-node/register` wherever you're running your Node.js process from.
You can always help as this is a open source project, however if you're not a student you may not participate on the google summer of code initiative. Thanks for pointing out the broken link. I'll fix it today!
This is really awesome. I am kinda bummed they don't have Angular. They have Node Typescript, React TypeScript, but no Angular.
StackBlitz still seems way more awesome in my opinion. 
Well most of those have been added over time as the features of the type system grew, so AFAIK there isn't yet a comprehensive list of those helper types, but they're usually documented in the changelog they were added in. If there is such a list though, I'd be interested in it as well
I think the type declarations serve as documentation. Tooltips and "go to declaration" will show you what's there.
bottom of [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)
[Start of declarations currently in master](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es5.d.ts#L1421). Looks like this may be the best we got right now
Identical 
You can check out the src [here](https://github.com/Microsoft/TypeScript/blob/4ff71ecb98ccbd882feb1738b0c6f1cc93c2ea66/src/lib/es5.d.ts). Search for "Partial" and you'll find the start of the list. Not sure if these are all though. I'm also a fan of [type-zoo](https://github.com/pelotom/type-zoo). A collection of similar helpers. 
We use classes in a vast majority of cases. It makes code easier to read imo (especially when there's a number of functions associated with the class/interface). We also all come from OOP background so it is a much easier transition for us. The more I look at the second option, the more I like it (although autocomplete/intellij doesn't help much with recommending the next property to include).
I actually did not know that. Are you referring to the bottom of this page? [https://www.typescriptlang.org/docs/handbook/functions.html](https://www.typescriptlang.org/docs/handbook/functions.html) 
Thanks for this. That does make a lot of sense. I'm actually leaning towards tony-husk's answer because Object.assign is that function that I always forget exists but simplifies a TON of boilerplate work.
Oof. Making me feel bad and like I need to commit these goals to memory. The Typescript Commandments?
Depends what you mean by "only typescript". You can install types for jquery and this code would probably not change. If you want to remove jquery and use vanilla js with typescript on top, you'd have to totally rewrite this.
Yes. 
Post your `tsconfig.json`.
I'll probably install the types in the new project, but for reference I would like to know what piece of the documentation can help when doing stuff like this in the future :)
There's a lot more to using TypeScript than simply embedding it into the project like you do with vanilla JavaScript, the reason is because it must be compiled into JavaScript brie it can be used. There's a project structure that must be adhered to, it's impossible to help you without any indication as to what the rest of the project looks like.
What's your compile target?
tsconfig.json: { "compilerOptions": { "target": "es5", "module": "es6", "jsx": "preserve", "types": [ "handlebars", "jquery" ], "sourceMap": true, "outDir": "./www/js" }, "exclude": [ "node_modules", "**/node_modules/*" ] } I'm in Chrome Version 72.0.3626.119 (Official Build) (64-bit).
Posted my full tsconfig.json file [here](https://www.reddit.com/r/typescript/comments/ayevon/question_using_typescript_in_website/ei0hpim/).
You will need a bundler or add `type="module"` to your script.
I added `type="module"` to my index.html and the new error I got was: testpage.html:15 Uncaught ReferenceError: TestMovieDetailEdit is not defined at testpage.html:15 I tried adding "export" to my TestMovieDetailEdit class but that didn't make a difference. 
All valid Javascript is valid Typescript. 
ES6 Modules can not pollute the global scope. You need to create the instance and call \`alert\` inside a module script.
Installing the types?
There is [`arguments.caller`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller), but it's deprecated and probably not what you need. It's not entirely clear what you mean by calling from a class. You can only really call functions from other functions/methods. But if you're calling from a method I don't think it's possible to get the class. Your best bet is to get a stack trace and find the parent frame.
A similar use-case I've run into a few times is pulling all or some argument types out of a function: ```ts // All argument types type Args&lt;F&gt; = F extends (...args: infer P) =&gt; any ? P : never; // First argument type type FirstArg&lt;F&gt; = F extends (first: infer P, ...rest: any[]) =&gt; any ? P : never; // Second argument type type FirstArg&lt;F&gt; = F extends (first: any, second: infer P, ...rest: any[]) =&gt; any ? P : never; ``` Which is useful when you want to write wrapper functions that should take all or some of the arguments of the function they're wrapping: ```ts function doThing(a: string, b: number): boolean { // ... return false; } function doThingWrapped(...args: Args&lt;typeof doThing&gt;): ReturnType&lt;typeof doThing&gt; { // args has the type [string, number] here return doThing(...args); } ``` This is a pretty trivial example, but it's great when you're trying to wrap library functions that have mile long types or use types that aren't exported.
Yeah, the recommended package for using jQuery
&gt; I think the type declarations serve as documentation. I'm still trying to fully grok Typescript's generics. Some of those declarations still look like nearly indecipherable black magic. Of course they are not, but I'm surprised at the challenge coming from a long time largely in the .Net world.
Just a guess but have you tried swapping around mocha-loader and ts-loader?
Yeah, definitely. TypeScript is trying to model crazy, dynamic JS behavior and sometimes this means the generics are really confusing. If you have specific questions and post copies of the specific declarations here, I'm sure we'd be happy to help you make sense of them.
I guess there is no easy way to know what token is at (2:10)? What does your tsconfig look like? You may want to change its target type to es5, or run the output of ts-loader through babel-loader.
jQuery is the recommended package for using jQuery. And even more highly recommended: vanilla js/ts. A less tongue-in-cheek response though is that all valid js is valid ts. If you used a package in js, you can likewise use it in ts. The only difference is that you may decide to install a package containing type definitions in addition. I encourage you to look up DefinitelyTyped.
Yeah, what other responder said. You can install types like so: ``` npm install @types/jquery ``` Should just work.
It's identical in TypeScript. I think you meant to ask a different question: How is this written for Angular instead of jQuery? You'll get better answers on the Angular subreddit.
Apples vs Oranges
Why not use ts-node to run the tests directly without transpiling to javascript? Eg: package.json part ``` "scripts": { "test": "mocha --require ts-node/register tests/**/*.ts" }, ```
For Angular I did something completely different, it was more to learn if anything changes completely between them!
Honestly I had never heard of purescript before this so perhaps mission accomplished. 
I hate languages with no brackets, so it is clearly typescript for me, without reading the article.
If i was writing an article that's an ad for my product i'd at least write about something popular
Inconvenient as fuck
You will probably also want to modify your ts config file. I created a tsconfig.test.json file to use when I’m testing: ``` { “extends”: “./tsconfig.json”, “compilerOptions”: { “allowSyntheticDefaultImports”: true, “module”: “commonjs” } } ```
It would be nice if you listed the default settings as well, so we dont need to dig into the files to find it or guess. Other than that it looks quite good.
&gt;...In both cases, we are creating a module that exports a main function, and that’s it. If we want the code to actually run we should, at some point, call main(). In TypeScript we could’ve added the invocation in the same file, after all, it doesn’t impose us the purity restriction. PureScript, on the other hand, forbids us from doing it, thus it assures us that importing a module can’t result in executing unknown side effects, such as connecting to a database. I thought this snippet said a lot about the differences between typescript and purescript. Overall I found this to be a great article with an excellent knowledge-to-bias ratio. 
In modern JS you'd probably use [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals). `&lt;div class="row"&gt;&lt;div class="col-md-3"&gt;&lt;br&gt;&lt;label&gt;Petición &lt;/label&gt;&lt;input name="data[${n}] [petition]" class="form-control"&gt;&lt;/input&gt;&lt;/div&gt;` 
That’s really neat! Thanks for sharing.
This is one place where Kotlin (as a language that compiles to us as well) beats Typescript. This should be an access operator. It's a very basic thing to have.
once we stop supporting IE11, then we will be able to use proxy to achieve optimal chaining and safe deep property
I think ts-node won’t catch transpilation issues properly. Honestly, we use gulp to build the test code separately to ensure that it fails when there are transpilation issues because they can often be useful to pinpoint problems. Silent failures make your tests less helpful.
Is webpack the right tool for running tests? Since it is really for bundling and delivering your app is there really much benefit in using it for this?
You could transpile the files being tested and import those to the tests (rather than importing the typescript files), still allowing typescript for the tests. 
Remember the debugging thing: you want to step into code to figure out what’s going on in a failing test. The ideal thing is build everything (test code included) with sourcemaps. That’s how we’re doing it.
Actually, there is a built-in type called `Parameters` :) However, this is a good point. I've recently did something like: ```typescript type DispatchProp&lt;T&gt; = T extends (...args: infer P) =&gt; unknown ? (...args: P) =&gt; void : never; ``` so that I can easily type dispatch props in components when using Redux with React.
Optional chaining TC-39 proposal is in Stage 2: [https://github.com/tc39/proposal-optional-chaining](https://github.com/tc39/proposal-optional-chaining) Hopefully, we will have it in JS too soon :)
I'm fairly certain that it is possible (albeit very convoluted) with TypeScript 3.0 to implement this with an arbitrary number of arguments using argument types, conditional types, and recursion. I'm on mobile at the moment but I think the basic idea is that you recursively pluck off the first type in the arguments list until the list is empty, and you can pass the object type along with it at each level. Anytime the argument is not a property of the object, you return `never` to invalidate the type.
According to the GitHub page it is in stage 1. Or where you can see it is on stage 2?
Oh sweet. I figured this should be built-in considering `ReturnType` is. Now I can stop littering projects with redundant types. Do you know where these built-in types are documented? I'm not finding them in the [basic](https://www.typescriptlang.org/docs/handbook/basic-types.html) or [advanced](https://www.typescriptlang.org/docs/handbook/advanced-types.html) types docs.
I haven't tried, but something tells me this would require variadic generics or recursive types to be completely type-safe with a variable number of keys. Unfortunately neither of those features exist in typescript yet. I hope I'm wrong though.
You are right! they are both fruits :D &amp;#x200B; They are two statically typed languages that compile to JavaScript. They do have things in common and differences as well. The post clearly doesn't cover all aspects, as it would be one big blob of information. Hopefully I could make a series out of it.
Through the course of researching this I ended up digging into webpack. I got that running and it seems like I'm in business! Thanks for the help /u/Rollingdownhills and /u/ritajalilip!
You made this? Good job. Sorry, if it seemed like I was shitting on your work. It's an interesting read I just disagree with the "vs" framing. They're tools for entirely different jobs. Pure seems like a great functional language built on top of js, and Typescript is a great OOP language built on top of js.
Cool, but I'd rather use [`ts-optchain`](https://www.npmjs.com/package/ts-optchain) for it. The syntax is pretty neat: `oc(myObject).prop.deepProp.deeperProp(optionalDefault)` It wraps the object in a OCType and uses proxies under the hood (first great use case IMO) and sadly it does have an issue on defaults when strict null checks are enabled (which I circumvent by using the OR operator to set a default.
Definitely on stage 1, but there is a follow up question for me. I am currently on mobile so I have no chance to really investigate on that question. The typescript team has a distinctive rule set on which features will/can be implemented within typescript: e.g.: only Stage 2 ja features are allowed/considered to be implemented. No doubt this feature will be available in ja/ts but the question is when. So is this (for me QoL) Feature to be something we can expect in the near future ( 3–6 Months) or is it out of range because of its current stage?
Really cool and simple idea with method overloading. I've been using [idx](https://github.com/facebookincubator/idx) which solves the same problem but with a slightly different syntax: `const firstName = idx(props, _ =&gt; _.user.friends[0].first.name)` There is also a babel plugin to ensure there is no runtime overhead.
idx is the best implementation of this that I've seen.
I've tried it a bit and was blocked by sth that I couldn't recall, lol Biggest issue here is recursive types is currently a "hack", where it's very easy to break. TS compiler would randomly be able to detect the recursion and reject the code. So people are wary to introduce such type defs into libraries to avoid future breakage IMU. 
Yes I wrote the article, and don't worry I take this as good criticism and even share some of your concerns. I think both the title and image ended up framing the article into a "VS mode" where the intent was to show that there are different tools for diferent tasks. I try to make the contest unbiased enough to show that. &amp;#x200B; I don't share the thought that TypeScript is a great OOP language. I mostly use it in a functional fashion, and there are a lot of features that goes that way. More recently [this PR](https://github.com/Microsoft/TypeScript/pull/30215). &amp;#x200B; I didn't have room to elaborate too much on this, but JavaScript is a multi-paradigm language, and TypeScript trying to type it must be multi-paradigm as well. Features like async-await makes it easier to program imperative, future features like the pipe operator or pattern matching will make it easier for FP. &amp;#x200B; The main thing that both language share, and what inspired the comparison in the first place, is the idea of "restriction-guarantee-confidence", were by adding a restriction on what you can do you get some type of guarantee that increases your confidence in the code. In future posts I want to show different aspects of this idea, for example to avoid null checking TS has control flow analisys and PS has algebraic data types.
for writing imperative or OOP programs I agree, and I don't like python for that reason. In functional languages there is no need for brackets. If you do read the article, pay atention to the last section where I talk about the benefits of only using parentheses to describre precedence and not for calling functions. Current JavaScript features that are awaiting to be approved by the TC39 and implemented by browsers could instead be implemented in the userland in PureScript. 
 function get(obj: any, ...props): any { return props.reduce((result, prop) =&gt; result &amp;&amp; result[prop], obj); } get(true, 'abc'); Please, start using proper type checks already!
What's inconvenient about it? Properly formatted code still respects indentation even when having brackets. I come come from C family languages and also looked down at languages that didn't need them. Until I tried Elm. Now I suffer writing so many brackets all the time.
this should work for you: ```ts const throwError = (fn:Function, t) =&gt; { throw new Error(`not valid, ${fn.name} failed on ${t}`) } const shouldBe = &lt;T&gt;(fn: (t1) =&gt; t1 is T, t) =&gt; (fn(t) ? t : throwError(fn, t)) const foo = (a: number | null) =&gt; { a = shouldBe(_.isNumber, a) a // a is a number } ```
Its the vision. That every ide takes off of you. Something a coder hasn’t to write, yes. But that’s what an IDE is for 
Usually something named underscore should be used in the body of the function
This isn't type safe, you can supply props that aren't defined
I understand it's a preference, that's fine. But I wouldn't base my choices on such trivial things (brackets don't change the semantics).
Newbie here , what does the 'c' stand for?
`in` is just a js operator: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in It returns true if the object to re right has a property named as the string to the left. 
Isn't it just pure js? Transpiration to English: If variable contacts has property contactID and property contactID in variable contacts is NOT NotANumber return value of property contacID in contacts incremented by 1; in other case return 1. Google: 'in operator', 'ternary operator' , 'propery acessors' 
&gt; Btw. It could be a bit nicer with &amp;&amp; typeof contacts[contactID] === 'number' instead of this !NaN double negation That is not at all what !isNaN does, though. isNaN checks if the argument is a NaN value. Id does not check if the value is anything else than a number. 
Thank you .. that was the whole confusion. I was interpreting \`in\` as an iterator.
Yes it is, i see my mistake now. I'm context switching between C#, TS, JS, PHP and Kotlin and i'm going bonkers. I'm new to TS and Kotlin so there's lots of learning and confusion. Cheers for helping out.
Thanks i'll take your suggestion .. but i think i can make it prettier by going \`contacts\[contactID\] instanceof Number\` as I have TS at my disposal.
Why not? I agree that variables should be named appropriately but in this case it's pretty obvious, and it reads well. 
That is still just js. And `instanceOf Number` does not do what you think it does. A normal number like `123` is not a `Number`. `Number` is a class you can use to wrap the primitive number in an object. 
Thanks for that. I'll use your solution. 
&gt; Typescript is a great OOP language Not on board with that. I use TypeScript but do as much as I can to avoid doing OOP and instead try to write as much functional code as possible (sticking to pure functions, use data types like `Maybe`, `Either`).
I'm trying to stick to the functional side of TS as well. Can't wait for the pipe operator and pattern matching to show up.
My bad, it's Stage 1 indeed.
Good point, I'll correct the code.
Not sure what you mean, this funcion is typed with the three overloads above it.
That's a convention
If you're using webpack, you can configure this once in the webpack config.
Oh crap, I forgot to include the relevant line in the post... it's a variable of type \`Customer\`. Thanks for spotting, will edit the article!
I couldn't find any documentation but this seems a good place to look for them: [https://github.com/Microsoft/TypeScript/blob/4ff71ecb98ccbd882feb1738b0c6f1cc93c2ea66/src/lib/es5.d.ts](https://github.com/Microsoft/TypeScript/blob/4ff71ecb98ccbd882feb1738b0c6f1cc93c2ea66/src/lib/es5.d.ts) Search for `Partial`, there are many more below.
It is actually - the global isNaN function is there to check for both typeof == number as well as not being NaN. The Number.isNaN function is the normal ieee754 floating point isNaN function.
I prefer @src -&gt; src folder That is how we do it
Just cause you don't use it that way doesn't mean that it's not great for OOP. Obviously pure is a better choice for functional patterns as that's kinda its core purpose. Typescript is gaining more and more functional features, but it was designed for OOP first.
The type safety of this can be improved. The return type should include `| undefined` if any property up the chain from the final property (or the object itself) may possibly be `null` or `undefined`. If you happen to provide a path where nothing down the chain will ever be `null`/`undefined`, then the result should not include `| undefined`. There might be a more concise way to do it, but here's what I came up with (implemented to 3 levels deep). Notice that I also tweaked the implementation to be a bit more specific about testing for `null`/`undefined` (with `== null` test), and ensured that `undefined` is returned if a `null` value is encountered before reaching the end of the chain (instead or returning `null`. The only way for `null` to be returned is if the property at the end of the chain is `null`. type Defined&lt;T&gt; = Exclude&lt;T, null | undefined&gt;; // Don't know a good name for this type. // It's used to include `| undefined` in the return type if a property upstream of // the end of the chain is possibly `null` or `undefined`. type MaybeUndefined&lt;T&gt; = T extends null | undefined ? undefined : never; function get&lt; T, K1 extends keyof T &gt;( obj: T, k1: K1 ): Defined&lt;T&gt;[K1] | MaybeUndefined&lt;T&gt;; function get&lt; T, K1 extends keyof T, K2 extends keyof Defined&lt;T[K1]&gt; &gt;( obj: T, k1: K1, k2: K2 ): Defined&lt;Defined&lt;T&gt;[K1]&gt;[K2] | MaybeUndefined&lt;T&gt; | MaybeUndefined&lt;Defined&lt;T&gt;[K1]&gt;; function get&lt; T, K1 extends keyof T, K2 extends keyof Defined&lt;T[K1]&gt;, K3 extends keyof Defined&lt;Defined&lt;T[K1]&gt;[K2]&gt; &gt;( obj: T, k1: K1, k2: K2, k3: K3 ): Defined&lt;Defined&lt;Defined&lt;T&gt;[K1]&gt;[K2]&gt;[K3] | MaybeUndefined&lt;T&gt; | MaybeUndefined&lt;Defined&lt;T&gt;[K1]&gt; | MaybeUndefined&lt;Defined&lt;Defined&lt;T&gt;[K1]&gt;[K2]&gt; function get(obj: any, ...keys: string[]): any { return keys.reduce( (result, key) =&gt; result == null ? undefined : result[key], obj ); } 
I'm also not sure how the original code is working without the use of the `Defined&lt;T&gt;` type like in my code. Without using `Defined&lt;T&gt;` for defining the constrains for `K1`, `K2`, etc., I get compiler errors. For example, if `T[K1]` is possibly `undefined`, the `keyof T[K1]` is `never`. Maybe you were'nt testign with the `strictNullChecks` option enabled?
This whole statement is grounds for rejecting that pull request. It's needlessly complex for no reason beyond the original author thinking they're cool and shit for using the ternary operator and boolean stuff like `&amp;&amp;`. 
Agreed. I use Webpack for the React or Vuejs. But prefer sticking to the Typescript compiler for backend services. 
Thank you hero
Nicely done! &amp;#x200B; But to get this to compile (on TypeScript 3.3.3, strictNullChecks enabled) I had to make a slight modification: &amp;#x200B; replace lines \`K1 extends keyof Defined&lt;T&gt;,\` with \`K1 extends keyof T,\`
Oops; that's what I get for making a few "quick fixes" after copy/pasting out of the TypeScript Playground. I missed a few places where I had to add \`Defined&lt;T&gt;\` throughout my code to properly handle a situation where the object itself passed to \`get()\` is possibly null/undefined. I edited my original post with corrections (tested in the Playground this time).
I also just realized I don't need to defined my own `Defined&lt;T&gt;` type. It's equivalent to the standard `NonNullable&lt;T&gt;` type.
Would be cool if someone crafted an ESLint plugin that nudges you towards FP when writing TypeScript.
with source maps, typescript is "available" in the browser.
Yes, the downside is not being able to modify the typescript code while it’s executing, you have to modify the transpired JavaScript 
what typescript code would you modify on runtime?
You don’t modify your code in the browser while debugging?
I don't generally code directly in the browser, but i change the values of some variables sometimes to observe different behaviours in the fastest manner possible. And when a bug happens on a test system (Not using strictNullChecks unfortunately), it's 90% of the time "cannot find property of undefined" and that's easy to fix in the code. When debugging, i either run watch or for webpack i run Hot Module Replacement (HMR), so without even reloading the website, i already have the newest code.
You don’t modify your code in the browser while debugging?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javascript] [es5-to-dts: Generate TS definition files from legacy JS](https://www.reddit.com/r/javascript/comments/azi3a5/es5todts_generate_ts_definition_files_from_legacy/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thank you! Please see release 0.1.9 where I have addressed this question.
I don't. Didn't realize you could.
If you’re using chrome, can you not map the files in the browser to those on the disk? Would that work?
Use source maps and chrome remote debugger and you can debug TS live in an IDE.
Normally, at the start of a project I would create the alias for \`\~\` to be the root directory \`\`\` import { Whatever } from \`\~/models\` \`\`\`
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javascript] [\[xpost\] thi.ng\/umbrella blog series - data driven, functional anti-framework deepdive](https://www.reddit.com/r/javascript/comments/aznc5p/xpost_thingumbrella_blog_series_data_driven/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
So instead of fixing the legacy code, you wrote software to translate JS to TS to JS?
&gt;So instead of fixing the legacy code My work on this project doesn't consist on fixing or even altering the basecode. I'm supposed to work alongside it. &gt;you wrote software to translate JS to TS to JS No, it generates TS **definition file** so that I can work alongside the legacy code with ease.
&gt; 500 Internal Server Error
Just pointing out that this content seems to be stolen by "Zara Bryant": https://morioh.com/p/7a466bd923c5/typescript-vs-purescript
If you like OOP, you may be interested in class-validator and class-transformer.
I just started experimenting with Rollup to bundle my API server in a new project. I've only been using it a couple days, but I'm already confident I'll be using it in future projects.
Essentially, I'd like to have tests transpiled and then executed. I'm sure gulp could be configured to do something like that, but I'm curious to see if I can accomplish it with webpack. Do you have any suggestions re: other tools for test running?
We’ve just used gulp for the same purpose because that’s all we needed: webpack seemed like overkill.
Here ya go. https://github.com/hmemcpy/milewski-ctfp-pdf
I'm going through this book at the moment and can certainly recommend it to anyone looking to get a very fundamental understanding of type theory. But... for OP it might be overkill since category theory gets very abstract very quick (even though Bartosz does a pretty good job at linking this stuff to practical programming).
[The official Typescript handbook](https://www.typescriptlang.org/docs/handbook/advanced-types.html) already has some concise explanations with examples
I've spent most of my life with strongly typed languages, but that paragraph means nothing to me. If you want to be a great Typescript developer, I'd argue you probably shouldn't worry about using insane type constructs that few people will understand.
The generated declaration file (not specification file or definition file) is used when you want to distribute your library as JS code. It contains the TypeScript declarations for the JS code. This doesn't sound like this is what you try to do. It sounds to me that you compile to a folder which then is picked up by the TypeScript compiler. So for the compiler there are suddenly two files that declare the same variable: Your .ts file, and the .js code with the .d.ts file. Likely you want to exclude the bin-folder.
The complete error is: ERROR in ./main/typescript/core.ts 2:10 Module parse failed: Unexpected token (2:10) You may need an appropriate loader to handle this file type. | export class Account { &gt; id: string; | | constructor(account: string) { @ ./test/typescript/account.spec.ts 4:13-50 @ ./test/typescript sync .+\.spec\.ts$ @ ./test/typescript/core.spec.ts Apparently, the code being tested isn't transpiled with the tests.
hang out on the typescript gitter and you'll learn insanely fast, we solve some crazy problems there every day. [https://gitter.im/Microsoft/TypeScript](https://gitter.im/Microsoft/TypeScript)
You are totally right, thanks for spotting this! I must have forgotten to enable `strictNullChecks` in TS playground. I will update the article today.
&gt; The angle parameter is optional and used to be angle = 0, so I assume VSCode turning into angle: number | undefined = 0 There is a big difference between `number = 0` and `number | undefined = 0`. The first can be omitted and gets a default value of `0`. The latter can be omitted as well and gets a default value of `0`, but the latter additionally allows to pass `undefined` as a value. That's a huge difference. &gt; Does it still make sense to have this big set of function parameters? I don't see what would be wrong about it. All parameters are used. I'd be more worried about accessing `this.characters` from the function, that doesn't seem right. What does `this` refer to in the function? Also, why are you not typing `CharacterClass`? You're accessing `CharacterClass.spawnPosition`, so you clearly assume that function to be present. So better type that out.
My approach is: - (Almost) always declare interface - Use named object parameters pattern when more than ~2,3 parameters &gt; Does it still make sense to have this big set of function parameters? I think it's better to use named object parameters. It allows you to easily extend, reorder, annotate with interface and keeps code consistent with shared names. &gt; This 'shape' is only used once, is there any point to make an interface, I would always define interface/type alias, type, for clarity. Also when your're done with initial conversion you can start optimising and unifying your interfaces, like ``` // your `createCharacter` params obviously extends something like SpawnPoint // and I'm sure you're reusing this bit in your game interface SpawnPoint { xSpawnStart: number ySpawnStart: number } export interface CreateCharacterOptions extends SpawnPoint { CharacterClass: any arrayToPushTo: string numberOfCharacters: number angle: number | undefined = 0 } ``` &gt; What is the best way to share types across all the modules? Cheers! Those interfaces. I would also advise to to take a bit more functional approach with functions - so `createCharacter` fn takes `CreateCharacterProps` and returns typeof `Character`. You would get a nice simple blocks, that later can be used for anything else. &gt; How would I achieve this in TypeScript? VSCode does nothing here in the conversion. I'm thinking - use annotation from JSDOC, copy params body to interface and just add brackets in fn to use destructured parameters. Refactor should take like 15 seconds per function. Or wait few weeks for automatic code action in this, probably in TS3.4^^ I'm keeping eye on this one: https://github.com/Microsoft/TypeScript/commits/d2364f555ff72bbd81f379d58bf426550482e205/src/services/refactors/convertToNamedParameters.ts To sum it up ```ts /** * Creates any number of new character objects and returns them in an array */ export interface CreateCharacter { CharacterClass: any arrayToPushTo: string numberOfCharacters: number xSpawnStart: number ySpawnStart: number angle: number | undefined = 0 } export function createCharacters({ CharacterClass, arrayToPushTo, numberOfCharacters, xSpawnStart, ySpawnStart, angle = 0, }: CreateCharacter) { const characters = [] for (let index = 0; index &lt; numberOfCharacters; index += 1) { const [x, y] = CharacterClass.spawnPosition(xSpawnStart, ySpawnStart) characters.push(new CharacterClass(x, y, angle)) } // why use `this` like that? // for sure does not play nicely with TS :/ this.characters[arrayToPushTo].push(...characters) } ``` I Hope It helps a bit?
THANKS! Regarding `number | undefined = 0`, I am not sure why VS Code added the undefined bit? It knows better than me at the moment, as I am just at the start of the TypeScript journey. The original parameter was `angle = 0`, so why has it converted it to `angle: number | undefined = 0' and not `angle: number = 0'? Why does it assume I might want to pass `undefined`? Do I need this in all optional parameters to deal with the case when there is no parameter supplied? Regarding the mistaken `this`, please see my edit. Regarding `CharacterClass`, cheers, I am on it! :) 
&gt;2. Whether I still need to use webpack? No. Webpack is for frontend. 
That’s kind what I figured, and what I think I want. It’s just that the tutorials when dealing with paths aliases suggest webpack for the solutions, which I want to avoid for backend. 
You can set path aliases in your tsconfig.json. I don't have so much experience with that though. See if this helps: https://stackoverflow.com/a/38677886/8037425
Thanks. I’ll see if that works. 
Thanks so much for you time! Please see my EDIT in the post regarding the \`this', that was a mistake. So, to sum up: * More than 3 parameters use named object parameters pattern * Use an interface to document the types, use an interface for most things. * Make my function more functional, return an object rather than push to an array. I will look into this, I agree this is optimal, don't know why I did not do this, there must have been some reason. &gt;I'm thinking - use annotation from JSDOC, copy params body to interface and just add brackets in fn to use destructured parameters I don't quite follow this, I will wait for the update :) I notice you are exporting the interface and the function. Can you explain your reasoning? If the interface is only used in the module why export it? I don't think I am familiar with this pattern. The \`createCharacters()\` function is actually part of a class (see the EDIT), here is the whole thing... where would you put the interface in this file? Is there any other patterns here you see that are not good for TypeScript? **THANKS!** // game state import Boundaries from './boundaries.js'; import Event from '../classes/event-observer.js'; import Text from './text.js'; export default class { constructor(canvasWidth, canvasHeight) { // ========================================================================= // FINITE STATE MACHINE / ENUM TO SWITCH BETWEEN VALID GAME SCREENS // ========================================================================= this.currentScreen = null; /** * @readonly * @enum {symbol} * Supplement {@link https://github.com/google/closure-compiler/issues/3058} */ this.SCREEN = { TITLE_SCREEN: Symbol('TITLE_SCREEN'), GAME_SCREEN: Symbol('GAME_SCREEN'), PAUSE: Symbol('PAUSE'), GAMEOVER_SCREEN: Symbol('GAMEOVER_SCREEN'), }; // ========================================================================= // EVENTS // ========================================================================= this.events = { fire: new Event(), zombieDies: new Event(), heroDies: new Event(), }; // ========================================================================= // GAME INITIAL SETTINGS // ========================================================================= // this.resetLevelObserver = new EventObserver(); this.options = { lives: 2, numberOfBullets: 100, numberOfZombies: 100, }; this.keys = { rightPressed: false, leftPressed: false, firePressed: false, pausePressed: false, }; // ========================================================================= // SCREEN TEXT // ========================================================================= this.titleScreenText = new Text( ['Welcome', 'To', 'Zombie Game', "('s' to start)", "('p' to pause)"], canvasHeight / 2, canvasHeight / 4, '80px Helvetica Neue', 'red', ); this.gameOverScreenText = new Text( ['You', 'Are', 'Dead'], canvasHeight / 2, canvasHeight / 8, '80px Helvetica Neue', 'red', ); this.gameScreenText = new Text([], 140, 40, '25px Arial', 'black', 'right'); // ========================================================================= // SOUND DATA // ========================================================================= this.sounds = { playerShoots: new Audio('./assets/shoot.wav'), zombieDies: new Audio('./assets/invaderkilled.wav'), playerDies: new Audio('./assets/explosion.wav'), }; // ========================================================================= // BOUNDARIES // ========================================================================= this.boundaries = new Boundaries(canvasWidth, canvasHeight, 0, 0); // ========================================================================= // CHARACTERS // ========================================================================= this.characters = { /** @type {import('./hero').default[]} */ hero: [], /** @type {import('./zombie').default[]} */ zombies: [], /** @type {import('./bullet').default[]} */ bullets: [], }; } /** * Creates any number of new character objects and returns them in an array * * @param {any} CharacterClass * @param {string} arrayToPushTo * @param {number} numberOfCharacters * @param {number} xSpawnStart * @param {number} ySpawnStart * @param {number=} angle */ createCharacters( CharacterClass, arrayToPushTo, numberOfCharacters, xSpawnStart, ySpawnStart, angle = 0, ) { const characters = []; for (let index = 0; index &lt; numberOfCharacters; index += 1) { const [x, y] = CharacterClass.spawnPosition(xSpawnStart, ySpawnStart); characters.push(new CharacterClass(x, y, angle)); } this.characters[arrayToPushTo].push(...characters); } // ========================================================================= // GETTERS / SETTERS // ========================================================================= get screenText() { return [ `Zombies ${this.options.numberOfZombies}`, `Bullets ${this.options.numberOfBullets}`, `Lives ${this.options.lives}`, ]; } // upgrade to getAllCharacters(characters) inc seperate ones?? get allCharacters() { return [].concat(...Object.values(this.characters)); } /** @param {number} arrayIndex */ set deleteZombie(arrayIndex) { this.characters.zombies.splice(arrayIndex, 1); } /** @param {number} arrayIndex */ set deleteBullet(arrayIndex) { this.characters.bullets.splice(arrayIndex, 1); } } &amp;#x200B;
Ok - firstly disclaimer, TS is about as much flexible as JS, so this all is just my opinionated view on structure. Do not feel you suddenly need to follow some specific convention. &gt; I'm thinking - use annotation from JSDOC, copy params body to interface and just add brackets in fn to use destructured parameters You were looking for VSCode typescript code action to automagically refactor JSDoc comments into typescript annotations. There is one that you've used - but imo inline annotations are not always as useful as external interfaces, so I've suggested to: - Crtl + . to annotate from JSDoc (as you did) - copy/paste as external interface (`CreateCharacter`) - just add brackets to parameters and annotate it with previous interface This way your function refactor would take few seconds :) Also I pointed out there there will be automatic code action for this quite soon. &gt; I notice you are exporting the interface and the function. Can you explain your reasoning? You do not need to export interface to just use your function, but if in some place you would want to annotate object that later will be passed as param (or you have another function that extends options of previous one, or any other myriad of cases) - it comes useful. ```ts // e.g. something like this for default params const defaultOptions: Partial&lt;CreateCharacterOptions&gt; = { class: abc ... } const options: CreateCharacterOptions = { ... defaultOptions, ... options } const character = new Character(options) // or in other function that uses this interface function createALotOfThings(type: 'character' | 'other', options: CreateCharacterOptions | CreateSomethingElse) =&gt; { } ``` &gt; The `createCharacters()` function is actually part of a class (see the EDIT), here is the whole thing... where would you put the interface in this file? On top of a file. There is not really that much difference between OOP vs FP flavours in JS/TS so I'm not pushing any. It's easily interchangeable. Whatever makes sense in your case, and it looks like in your example using classes is really clean (so it's also fine to just mutate other class fields). I prefer functions, in big part because of this ability of splitting/ collocate different parts. In your example only for `createCharacters` I would create interface. arrayIndex and such of course are totally fine annotate inline. Since it's a class, not a function - I think it's also fine to leave it as it is. As somebody else pointed out - you should declare/ annotate classes for your objects - so you can reuse those types to annotate you class fields. It looks like you also need to declare &amp; annotate you class field before assigning it in the constructor. Most of this you can just initialise on class field &amp; just use constructor for things that need options (it's not experimental/proposal in TS) ``` // why not name you class export default class Game { // annotating class field characters: { hero: Hero[] zombies: Zombie[] bullets: Bullet[] } constructor () { this.characters= { hero: [], zombies: [], bullets: [], } } // or just initialise class fields characters: { hero: Hero[] zombies: Zombie[] bullets: Bullet[] } = { hero: [], zombies: [], bullets: [], } // or declare GameCharacters interface on top of a file interface GameCharacters { } class Game { characters: GameCharacters = {} ... // or asset type on empty arrays in field initializer (this wins for succinctness) class Game { characters = { hero: [] as Hero[], zombies: [] as Zombie[], bullets: [] as Bullet[], } ... ``` Also as a pointer for TS with OOP - you can use private/public/protected fields/methods annotations to specify public API. Also there is concept of abstract classes, which may or may not be useful as a parents for you Zombies etc.^^ 
Thanks for your epic reply! You will definitely get some free coin credits for the game :) It took a while, but I just got the whole game to compile! Now I need to go in and re-factor bit by bit improving my TypeScript, your post will help a lot. VS Code 'add missing members' helped a huge amount in getting the classes working. It just piled all the property types I needed to declare up the top, so I then found the duplicates in the constructor parameter and made them `public` to save the duplication. I have started to sprinkle in some nice things like declaring the base class `abstract' and some cool types like `fontColor: CanvasRenderingContext2D['fillStyle']` instead of `string` just to make things super descriptive. Cheers! 
I've been experimenting with using (Rollup)[https://rollupjs.org/guide/en] to bundle an API server written in typescript. So far I haven't run into any major snags. I think you can use the baseUrl compiler option in your tsconfig to resolve non-relative modules. For example I put `"baseUrl": "."` in my tsconfig compiler options, and I'm able to prefix my local imports with `src: `import errorMiddleware from 'src/middleware/errorMiddleware'`.
&gt;Zar LogRocket editor here. Thanks a lot for the heads up. 
This isn't true. Webpack supports `node` as a target: https://webpack.js.org/concepts/targets#usage
BTW - you can use the standard \`NonNullable&lt;T&gt;\` type instead of the ad-hoc \`Defined&lt;T&gt;\` type I created. They do the same thing. I'll update my post to use \`NonNullable&lt;T&gt;\` now...
This looks great, thanks for the share! 
Daniel time to change that profile pic
Interesting. However, I can't think of a situation where you'd want to use it. 
At first I thought it was the Valve dude
Yeah I doubt it's worth the effort for most projects. A few that come to mind: - Custom loaders could be useful you're dealing with multiple languages or special assets. - Tree shaking could improve start times in massive projects, but bundle size usually doesn't matter on the server. - Bundling dependencies probably helps prevent some dependency minor version mismatch issues.
&gt; Higher order function type inference #30215 Awesome. Really happy to see this one land.
Hey Colt! Always awesome to get a course from u! Unrelated question... why are u using bind(this) on ur React app methods instead of just using arrow functions?
Yeah, got it. I've updated the article (and linked to your comment).
Your article still claims that the code in your article has some false return types: &amp;#x200B; &gt;BTW, this type signature sometimes gives false negatives. If all properties and the source object itself are not nullable, then the result type should not include `undefined`. Check out [this implementation](https://www.reddit.com/user/Useless-Pickles) for more details. &amp;#x200B; But this is now incorrect, because you updated the code in your article. This section of the article could probably be reworked to explain that/how the return type properly does not include \`undefined\` when not relevant. Also, the "this implementation" link is currently linked to my general reddit user page :)
I've updated my code so that it compiles with `strictNullChecks`. The meaning of this sentence is to mention that the typings can still be improved, without going into details (that's why I link to your implementation). I'll correct the link.
Excluding the "bin" folder resolved the issue. For future reference, what is considered TS best practice for handling/bundling declaration files when distributing a library as JS code? Thanks.
Hi YOUREABOT, this is Colt. I didn't post this link originally (I hate self-promotion on reddit I promise!), but a friend of mine showed me your comment. And yes, this account is not my main account...definitely don't want my students seeing that :) As to your question...In my upcoming React course, I spend a lot of time talking about the various ways of binding in react, using .bind(), arrow functions, and class properties. I use all three throughout the course, but I tend to use the explicit bind() most often because it is the only option that makes it painfully obvious that you need to bind the value of this. When I teach react using arrow functions all over the place, I've found that some students just start writing arrow functions because it's what they saw me do, but they don't fully understand WHY. They don't understand the problem, and instead they just treat the arrow as some "react magic" or something that you have to do without fully understanding the reasoning behind it. I've seen students run into trouble when they start writing every function in a component as an arrow function because they think it's the "react way". I've found that if I use bind when I'm teaching, students don't run into that problem. It's more work, but it's way clearer. Also, I see a lot of instructors teach react using inline arrow functions inside of render, which is not ideal. It creates new functions every time render is called. Most of the time it isn't a performance issue, but it's not a good habit to teach students. As always with teaching programming, it can be tough to find a balance between what is easiest to understand and what is shortest/cleanest to write. Does that make sense?
I mis-read the code in the article. For some reason I thought you had incorporated the \`MaybeUndefined&lt;T&gt;\` stuff into the article. Makes sense now.
I maintain similar project called ts-essentials: [https://www.npmjs.com/package/ts-essentials](https://www.npmjs.com/package/ts-essentials) 
I like yours better purely because there's documentation. type-fest just has "go look at types.ts", so I noped. 
Thanks! Feel free to raise issues about missing types or submit PRs. I actively work on it. Lately it crossed 100k monthly downloads mark!
That's awesome, congrats! I just sent it over to a friend who recently started converting his company over to TS. I use TS in angular quite a lot, i might find a use for this sometime too :)
A few others: https://github.com/pelotom/type-zoo https://github.com/gcanti/typelevel-ts https://github.com/tycho01/typical https://github.com/kgtkr/typepark And of course my own :) https://github.com/andnp/SimplyTyped
When a build tool requires a 10-part series, we should probably step back for a minute and see if this still all makes sense. 
Do you have a more in-depth explanation for what `UnionToIntersection` does/how you use it? I don't quite follow the docs on that one.
Haha, going to have to agree with you there. The series doesn't even cover things like tree shaking or lazy loading, otherwise it would have been closer to 15 parts. I initially planned for this to be one single Webpack video, but as I went to record it I realized how much ground I had to cover just to teach the most basic setup. This was supposed to take me a day to produce, but it ended up swallowing up most of a week. I'm ready for the "configure every tiny little thing yourself all the time" phase to end.
Using loopback 4 currently. What it does it does well and it is a lot more stable than NestJS was when I used it with TypeORM, that experience was really frustrating and the error messages were useless. It makes a really nice Typescript REST API. It has a pretty minimal ORM though and they seems to be slowly moving the full feature set from the previous version over. The Graphql support seems like an afterthought, doesn't really work properly yet.
How much of these internals did you know deeply before you started the course, and how much of it did you learn as you were diving deeper?
I was familiar with most of Webpack as a developer, but I had zero experience with it as a teacher. I wouldn't say I'm an expert teacher or anything, but I feel pretty confident in my ability to explain most topics. Webpack is not one of those! I still remember feeling completely lost and stupid when I first started learning Webpack. It's part of the reason I wanted to make some content on it. It's confusing stuff!
Even if you don't want to hear that - that's the complexity of this job. Take the build tool of your choice - Gradel, Cmake, Maven - what ever. Just take one of the big boys toys. They are all complex, they act like a small programming language AND thats needed. It's an illusion to have 3 lines of build-system-code that handles all use cases.
Can someone explain when these are useful. Even reading the docs these seem to me like frivolous and useless typedefs. 
Probably when you want to impress all the junior dev girls with your mastery of abstract typing structures
This is really show how wrong WebPack is. Build tool should value time of developers and try to be invisible and just work out of the box as much as possible.
Isn’t there some etiquette about promoting your own competing project in a post where someone shares theirs I guess for feedback. At lest mention the post. If you aren’t going to comment then make your own post. I have no skin in the game here, but it just seems tacky. 
Since you have an already popular project I would expect more from you than hijacking the comments of some guys first post of their repo. 
In my case I like using it because I can get a single js file containing the entire project. Creating a docker container for the project then becomes trivial and massively more lightweight. (Copy file, run node vs copy minimal set of project files and run yarn install, them run node).
deprecated? 
Here a repo example where I use TypeScript and ESLint (and Prettier + React): https://github.com/tkrotoff/MarvelHeroes - .eslintrc.js: https://github.com/tkrotoff/MarvelHeroes/blob/master/.eslintrc.js - npm packages to install: @typescript-eslint/eslint-plugin, @typescript-eslint/parser, eslint, eslint-config-prettier, eslint-plugin-prettier, eslint-plugin-react, eslint-plugin-react-hooks (https://github.com/tkrotoff/MarvelHeroes/blob/master/package.json) - The diff that introduce ESLint: https://github.com/tkrotoff/MarvelHeroes/commit/c756d74a51a110fbe84c770616ce575b17575cf3 ESLint does not read your tsconfig.json like TSLint, it does less for now.
Hold on for now. TSLint is still valid and works well. True, it will be, eventually, replaced by ESLint, but it won't happen overnight. If you are really itching to switch, all the informations are in the [monorepo](https://github.com/typescript-eslint/typescript-eslint).
Yep: https://medium.com/palantir/tslint-in-2019-1a144c2317a9
He might be talking about the old [tslint vscode extension](https://marketplace.visualstudio.com/items?itemName=eg2.tslint)? Microsoft made their own [tslint vscode extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-tslint-plugin).
No, TSLint is really being deprecated in favor of ESLint.
It is getting deprecated once the necessary changes have been implemented in ESLint and an actual migration path exists. You're asking way too early.
No real need to get ahead of this one since ESLint doesn't fully cover what TSLint currently does.
Great project, thanks for sharing :) \`Opaque\` in particular is probably something I'll start using in my own code.
Thanks for sharing! Really useful to see Merge and Omit. It's easy to burn way too many brain cycles figuring out how to recreate those types each time you need them.
This way is the best one `import { parse } from 'url';`. Try enabling `esModuleInterop` option in `tsconfig.json` order to be able to use `import url from 'url';` instead of `import * as url from 'url';`. See details here https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html. 
There's an eslint plugin to run talking, right? So if you really want to run eslint today, you can use that plugin to get the tslint rules till they're ported over.
It depends entirely on the module you're trying to import and how it is exported. This has nothing to do with TS. `export default const add = (a: number, b: number) =&gt; a + b;` =&gt; `import add from './add.ts'` `export default const add = (a: number, b: number) =&gt; a + b;` =&gt; `import { add } from './add.ts'` `global.add = (a: number, b: number) =&gt; a + b;` =&gt; `import './add.ts'`
Each way is different depending on how the module itself is exported and how you as a developer would like to use the module. import 'jest-extended' This approach basically says, "Import jest-extended, but I'm not going to bind it's export to anything in particular, let's just make sure the file is there". This is relevant sometimes when the file exports a bunch of globals you intend to work with or has other side effects you want to leverage. import moment from "moment" This approach implies that the package "moment" has a "default" export and you're choosing to inject that default export into the variable name of moment. You could change that variable name to mikemitterer and it would happily map the default export to that variable name. import { parse } from "url" This approach means the package url is exporting an object that contains a method of parse, and you'd like to directly use that parse method without needing to think about the url package name itself. The url package might contain many other methods, but you don't care about those at all, and with tree shaking we might just leave those off what is compiled in the end. We'll be able to invoke this method using parse(). import * as url from "url" The url package exports an object and we want to capture everything within that object since we might be using it all. Since this is the same package as the above, our approach to invoking the parse method would now be url.parse(), since we've bound the entire exported object to a variable url. You could change that variable to mikemitterer and our invocation would become mikemitterer.parse(). &amp;#x200B; As a note, this actually has absolutely nothing to do with TypeScript, this is plainly how ES6 imports work, TypeScript is actually doing nothing here. If you'd like to read more details on importing, I of course highly suggest the MDN library: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)
Oh.. Would kinda expect tslint news to be on the "News" section of the [TSLint](https://palantir.github.io/tslint/news/) site, but I see now that it hasn't been updated since 2016. Or I would expect it mentioned on tslint github page somewhere. Or a link to it, at least. Neither of those pages even have a link to his Medium blog. Good to see I'm not the only one who are a bit disorganized. 👍
Huuu... I thought TS manages the imports somehow. Anyway - thanks for the mozilla-link. BTW: Just found out that \`**import** { **default as** moment } **from** 'moment';\` works... (That clarify the whole thing a bit) But maybe the main problem is the declaration in "moment"??? They declare a namespace "moment" witch is the default export but they also declare two functions "moment" If I use a namespace "mm" for my own modules and if I import like \`import \* as mm1 from 'mymodule'\` everything works fine and I can use new mm1.Hmac(). \`import mm from 'mymodule'\` works also. namespace mm { export class Hmac { ... } class SayMyName { constructor(public readonly name: string) {} } } export = mm; &amp;#x200B;
*sigh* I know.
Too soon. 
I'm not against emojis, but when they are used instead of words it's quite annoying as the sentence meaning is left to my interpretation.
You can use webpack with no config. I just tried it: ``` mkdir project cd project npm init -y npm i -D webpack webpack-cli mkdir src echo "console.log('hello world');" &gt;&gt; src/index.js webpack src/index.js node dist/main.js # prints hello world to the console ``` All you have to do is load `dist/main.js` with a script tag. I haven't watched it, but I'm guessing the intended audience of this series is developers working on medium to large React/Vue/Angular apps that use various loaders and plugins to solve real problems. I'm guessing the TS team didn't make that decision because there are already several solutions to the problem of bundling JS for the browser (webpack, rollup, brunch, browserify, broccoli, etc). Adding another to TSC would just increase the scope of the project to include bundling and add another tool to an already crowded ecosystem. One of the big reasons to use TS over other type-safe languages is how well it interops with existing JS tools.
&gt; I thought TS manages the imports somehow. In a way it does. The syntax is taken from ES6, but the TS compiler decides how to resolve the modules you import which enables things like resolving modules from custom paths (like `node_modules` or whatever `baseUrl` you define in your tsconfig). https://www.typescriptlang.org/docs/handbook/module-resolution.html
Or just busy people with busy lives.
I currently added `@babel/plugin-transform-typescript` (`@babel/preset-typescript`) just so I can add type syntax in my `.js` files. I prefer using Typescript over FlowJS. Yes not a lot of benefit with **type checking** but I think support will be added in coming months. Using ESLint with `babel-eslint` as a parser doesn't help much there isn't even good syntax highlighting for types (I'm not sure is it the theme I'm using or what. Theme `Tomorrow Night Bright Operator Mono` with ligatures) Not a lot of themes support operator Mono font style 😑. But at least I can write types and transform them through `Babel`. Hopefully the split between **Compiling** and **Type Checking** would see its effect in Typescript modules themselves. They should have invested in improving Babel and adding multiple file transforms with cross file information, and then focus on the type checker as a separate step. Typescript is too limited and opinionated ! Typescript should embrace Babel for your own good and support type checking with it too. I don't want to end up having to add the same transformations for both Babel and Typescript just to add type checking support. Typescript cannot compete with the transformation plugins available to use with Babel. Its just a waste of effort.
This one is pretty commonly asked. The thing that gets most people is the simple example of 2 types with the same fields. Try applying what you are asking for to more than one type with different fields. Try making one value a number for example. It’s giving you the right type, but you want it to realize the equivalence of the two types in this one case
Yeah, you're spot on. In the 2nd or 3rd video I introduce Webpack with its default config. It works for some projects, but most of my students are working on react/angular/vue projects as you mentioned. We then add in some loaders and plugins to handle things like SASS, image compression, splitting into a vendor bundle, etc. 
The type \`\[number, number\]\` is a tuple. It's a more specific kind of array type that has a specific length (2, in this case), and a potentially different type for the value at each index (both indexes have \`number\` values in this case). An example value of this type would be \`\[3.14, 42\]\`. Your code snippet and error message are missing necessary information to be 100% certain, but I'm guessing it's complaining about the argument to this function call: \` radarLine(\[d\['axes'\]\]) \` I have no idea what you're attempting to do there, or what you think you are attempting to do, but \`\[d\['axes'\]\]\` is clearly not an array with 2 numbers in it.
That's a really neat trick! Here's another way to achieve the same effect: interface StartMessage { kind: "start" start: number } interface KillMessage { kind: "kill" kill: string } type Message = StartMessage | KillMessage function emitMessage(message: Message) { switch (message.kind) { case "start": console.log(message.start) break case "kill": console.log(message.kill) break } } emitMessage({kind: "start", start: 1}) // ok emitMessage({kind: "kill", kill: "test"}) // ok emitMessage({kind: "kill", start: 1}) // compiler error emitMessage({kind: "kill", kill: "test", start: 1}) // compiler error
Very nice! It's a creative solution and quite concise. &amp;#x200B; The main issue I see is that TypeScript won't be able to deduce the correct type of \`payload\` where you have the \`// handle start\` comment. An alternative way to design things so that the payload type can be deduced is with [discriminated unions](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions): interface StartMessage { type: MessageType.START; payload: StartPayload; } interface KillMessage { type: MessageType.KILL; payload: KillPayload; } type Message = StartMessage | KillMessage; function emitMessage(msg: Message) { switch(msg.type) { case MessageType.START: { // TS knows that msg.payload is a StartPayload here } break; case MessageType.KILL: { // TS knows that msg.payload is a KillPayload here } break; } } &amp;#x200B; &amp;#x200B;
Three or so years ago was kind of an interesting time for TSLint. TypeScript was getting much more popular (and thus TSLint was also), but the "soft" parts of TSLint were not in the best of shape. The documentation was outdated and it was really tough to contribute to the codebase because code reviews tended to be a bit nit-picky [(80 comments for example!)](https://github.com/palantir/tslint/pull/800) and writing tests was really annoying. A member of the TypeScript team even [compared writing tests to pulling teeth](https://github.com/palantir/tslint/issues/620#issuecomment-144203154)!) Anyway, I took some time during a company hackweek that year to [redo the whole TSLint website](https://github.com/palantir/tslint/issues/830) and implement a new test system [I had recently proposed](https://github.com/palantir/tslint/issues/620#issuecomment-144561726). We also made it a goal to enforce all nit-picky kind of CR things with automated tools so that contributors wouldn't get annoyed too much by them. These changes ended up working out well and PRs to TSLint from outside contributors really took off and the review process became much less painful. I started stepping away from doing as much TSLint work a year or so later (just because I was too busy) and sort of forgot about the "News" part of the site. I'm guessing everyone else did also - I had never publicized or pushed it much. So yep, really just a bit of disorganization and a bit of busyness! The downfall of all software haha. for what it's worth though, there is [a GitHub issue discussing the transition](https://github.com/palantir/tslint/issues/4534) if you're interested.
I think using enums is overhead so I like more the code shown in another comment here. Alternatively try something like this library [https://github.com/pelotom/unionize](https://github.com/pelotom/unionize).
``` type T&lt;B extends boolean&gt; = { value: string; type: B extends true ? '1' : '2'; }; const bool: boolean = true; const stringObj: T&lt;typeof bool&gt; = { value: 'string', type: '1', } ```
Noted - thanks!
Yep agree with this. 
Just advertisement for a shitty course.
I saw this in advanced types too, I believe this is called discriminated unions, no?
Yeah after seeing the other comments I actually think this is a more comprehensive way of doing things. In my actual code I've found I never actually switch on the type, I just delegate it to a function (so I don't encounter the problem you mention), but I think I'll switch it all the same!
Another solution would be replacing switch with object https://github.com/ptol/ts-reducer-creator
Coming from a Java/Spring background, and a huge fan Mockito. I've been working with Typescript, Inversify and TS Mockito for the last year and have been pretty happy with it. 
The compiler can only infer the type from data that is present at compilation time, and in your example there is no value to infer `K` from. `nested.value` is just **any** string with no relevance to any type. What you could do would be something like `lookup(TestObject, 'nested', 'value')` (and use overloads for multiple depths).
Thanks for the answer! The option with the second parameter as an array of properties (or varargs as in your suggestion) was my "escape plan". Somehow I already knew that it was not doable directly via dotted strings but since I am not an expert I was not 100% sure about that. &amp;#x200B; Anyway I need to investigate on a way to remove all the the manual overloading or the "death by a thousand overloads" as they call it (see [Mappable tuple and array types](https://devblogs.microsoft.com/typescript/announcing-typescript-3-1/#mappable-tuple-and-array-types)). &amp;#x200B; &gt;!Note:!&lt; &gt;&gt;!You should also be aware that it is legit and possible to have the . character in property names.!&lt; &gt;!Yes I know, I just wanted to start "easy" and then improve on that :)!&lt;
&gt; Anyway I need to investigate on a way to remove all the the manual overloading or the "death by a thousand overloads" as they call it (see Mappable tuple and array types). You'd need [Variadic Kinds](https://github.com/Microsoft/TypeScript/issues/5453) in this case.
we use ts-optchain. it‘s awesome https://github.com/rimeto/ts-optchain
 export class Vector2 { private x: number; private y: number; constructor(x: number, y: number) { this.x = x; this.y = y; } add(point: Vector2): Vector2 { return new Vector2(this.x + point.x, this.y + point.y); } static UP = new Vector2(0, -1); static DOWN = new Vector2(0, 1); static LEFT = new Vector2(-1, 0); static RIGHT = new Vector2(1, 0); } let position = new Vector2(110, 10); position = position.add(Vector2.UP); 1. Avoid classes if possible, especially for small pieces of data. Plain data is preferable since it serializes nicely (I'm assuming you have a good reason to use a class here). 2. `public` is the default, avoid using the keyword is. 3. Don't use getters when they just return a hardcoded value, just use static member variables. &gt; Maybe the Up/Down/Left/Right should have their own class No, I'm not sure why you would consider this.
This is intense. 
Cheers! Let me address your points: 1. The reason I use a class is so that the method `add` is added to the prototype and shared between instances. I don't want to generate multiple copies wasting memory. I know that it might not be much memory wasted, but it is the principle and correctness I am interested it. Why avoid classes if possible? I am making an OOP game, it is made of characters which are classes like Hero and Zombie etc... I am not sure what 'serializes nicely' means and how it would help my game? 2. TSLint recommends to add the public to make it more readable, I tend to agree, and it is all compiled away so wastes no resources. 3. Fantastic! This is much better, nice win! Thanks again, it is good to hear from a more experienced developer, even if just for the peace of mind that I did not make some newb error, I only started TypeScript a few days ago (my JavaScript is probably OK)
I am new to TS and just going straight to [https://github.com/typescript-eslint/](https://github.com/typescript-eslint/) . I don't want to invest any time in legacy utilities. &amp;#x200B; Here is my setup for airbnb/prettier/typescript-eslint. There is a small issue that is overwrites a few of the airbnb rules, but that does not bother me much. \`\`\` { "extends": \[ "./node\_modules/eslint-config-airbnb-base/rules/best-practices.js", "./node\_modules/eslint-config-airbnb-base/rules/errors.js", "./node\_modules/eslint-config-airbnb-base/rules/node.js", "./node\_modules/eslint-config-airbnb-base/rules/style.js", "./node\_modules/eslint-config-airbnb-base/rules/variables.js", "./node\_modules/eslint-config-airbnb-base/rules/es6.js", "plugin:@typescript-eslint/recommended", "prettier", "prettier/@typescript-eslint" \], "parser": "@typescript-eslint/parser", "plugins": \["@typescript-eslint"\], "rules": { "lines-between-class-members": "off" }, "env": { "browser": true, "node": true, "mocha": true } } \`\`\` \`\`\` "devDependencies": { "@typescript-eslint/eslint-plugin": "\^1.4.2", "@typescript-eslint/parser": "\^1.4.2", "eslint": "\^5.15.1", "eslint-config-airbnb-base": "\^13.1.0", "eslint-config-prettier": "\^4.1.0", "typescript": "\^3.3.3333" } \`\`\` \`\`\` { "compilerOptions": { "target": "es2018", "module": "es2015", "sourceMap": true }, "include": \["src/\*\*/\*"\] } \`\`\` \`\`\` { // enable eslint checking and fixing in both \`.ts\` and \`.tsx\` files in vs code "eslint.validate": \[ "javascript", "javascriptreact", { "language": "typescript", "autoFix": true }, { "language": "typescriptreact", "autoFix": true } \], } \`\`\` &amp;#x200B;
&gt; The reason I use a class is so that the method add is added to the prototype and shared between instances. I don't want to generate multiple copies wasting memory. That doesn't make much sense. By using classes you are actually wasting memory. All your class instances will have an additional property `add` that points to the function. The alternative approach would be to just use plain objects and a single function: function add(vector: Vector2, valueToAdd: Vector2): Vector2 { ... }
&gt;All your class instances will have an additional property `add` &gt;that points to the function. This is incorrect. There is only one reference to the `add` function on the prototype. There is no `add` property on every instance of the class.
\*insert McDonald's slogan here\*
This is standard JavaScript module syntax, so when you're looking for answers to this question, you can also look for articles and resources that don't pertain specifically to TypeScript.
Automatic folder barreling plz
I feel like this article might be easier to get into if we saw the example at the end first so that we know what we're trying to achieve. Otherwise, very good and thanks again to gcanti for fp-ts and io-ts!
&gt; let err2: readonly Array&lt;boolean&gt;; // error! &gt; let okay: readonly boolean[]; // works fine I always thought `T[]` is just an alternative syntax for `Array&lt;T&gt;`, but apparently there's a difference. I wonder what the difference is.
You need to understand the difference between [] and Array() in javascript https://stackoverflow.com/questions/931872/what-s-the-difference-between-array-and-while-declaring-a-javascript-ar
Sure, but how is this any relevant to what I posted? That's about the runtime JS array, not about the TypeScript array type. In TypeScript `Array&lt;T&gt;` and `T[]` is interchangeably. const a: Array&lt;number&gt; = []; const b: number[] = []; const c: Array&lt;number&gt; = Array(); const d: number[] = Array();
Why does the read only array have the push method if it's useless ?
`ReadonlyArray&lt;T&gt;` does not has a `push` method.
What’s that ?
So in terms of Angular, would it help speed up ng serve at all if this flags as used as well in the main TS?
I had to look this up too. Looks like this refers to exporting all modules within a folder from a single index.ts, to make importing them easier for the package consumer. (https://basarat.gitbooks.io/typescript/docs/tips/barrel.html) This would be an interesting feature to have although if it happens at compiler level I'm not sure how I'd feel about the introduced discrepancy between the source and compiled code.
I think that "array type literal" is a strange name for `T[]`. I think of literal types as singleton types, such as `true` or `"foo"` as opposed to `boolean` or `string`.I agree that it is weird that `readonly` keyword introduces a distinction between `T[]` and `Array&lt;T&gt;`. I'm pretty sure there is 
This could be a nice Code Action, like the switch to named parameters feature introduced with 3.4. That way the code is auto filled rather than having the compiler do extra magic.
Yes. They're also called tagged unions or sum types.
Ah, of course! That would be great.
I am a bit worried with how mapped types work with arrays now. What if I want to map array items to `readonly` but do not want to fully convert it to a `ReadonlyArray`? Or, more realistically, what if I want to make `ReadonlyArray` elements mutable, but without adding push/pop/splice to it? If my understanding is correct, `readonly property: type` and `-readonly property: type` modifiers will now convert to/from ReadonlyArray, making the case described above impossible. Or am I wrong about this?
The x and y values are, as far as I can tell, inaccessible from outside of the class. Not being able to even read the values makes the class rather useless so this will of course have to change. If the change includes the ability to modify the x and y member variables then this could lead to trouble down the road. Accidentally modifying the UP vector can give the game hard to track bugs and a very strange behavior. Having factory methods like OP used in the first place makes sure this won't happen. If the Vectors on the other hand stays immutable, the static variables can be a good idea.
I remember writing "array and tuple type **syntax**" but I guess I must have messed up. Thanks for pointing it out.
You can likely use Rollup and [API Extractor](https://api-extractor.com/) to achieve this instead.
Nice one. Do you have the code on Github?
Treating `Array&lt;T&gt;` and `T[]` as different types still seems arbitrarily unnecessary.
It seems that this is a rather static (albeit with some name mangling) inliner as opposed to a real compile-time macro system, which would operate on AST nodes. I’m not sure what the practical use cases for this library are, maybe OP could post some examples?
Link returns 404.
Seems correct to me
Yeah, the difference in behaviour is explained by conditional type distribution in \`equivalent2\`. Conditional types distribute over unions iff the checked type is a naked type parameter, which is the case in \`equivalent2\` but not in \`equivalent1\` (as the checked type in \`equivalent1\` is \`(T extends S ? true : false)\`). Also, \`string | number\` is the same type as \`number | string\` since the order of the union constituents does not matter. By evaluating \`equivalent2&lt;string | number, string | number&gt;\` we get &amp;#x200B; \`\`\` type test01 = equivalent2&lt;number | string, number | string&gt; type test04 = (number extends (number | string) ? ((string extends number ? true : false) | (number extends number ? true : false)) : false) | ((string extends (number | string) ? ((string extends string ? true : false) | (number extends string ? true : false)) : false)) type test05 = (string extends number ? true : false) | (number extends number ? true : false) | (string extends string ? true : false) | (number extends string ? true : false) type test06 = false | true | true | false type test07 = boolean \`\`\` &amp;#x200B; which is indeed correct.
Probably not gonna happen on iOS without jailbreaking (is that even still a thing?)
The one from redux-starter-kit is already written in Typescript and comes from the Redux team. 
These typescript typings are mostly meant to be used with action classes. The \[stackblitz\]([https://stackblitz.com/edit/typescript-b5ekwc?file=index.ts](https://stackblitz.com/edit/typescript-b5ekwc?file=index.ts)) showcases that
&gt; Since this index.d.ts is part of the library itself, is my only option to clone the whole repo, work from that, submit a PR when I'm ready, hope they merge and release a new version quickly? You could alternatively use [patch-package](https://www.npmjs.com/package/patch-package) to alter the bad index.d.ts file. 
And while you're waiting for the PR to be merged, you can point `package.json` to your fork on GitHub. That or patch-package. You should avoid manual changes to local node_modules contents.
I ran into this issue a few days ago. My temporary solution was to directly import the built module from within the troublesome package (which in this case was within a 'dist' directory). Since it was effectively untyped, it was then possible to add a local type definition. 
How does this compare to class-transformer? Is it lightweight for the frontend?
For the documentation part about that I use lerna + TypeDoc + a TypeDoc plugin (https://github.com/marcj/typedoc-plugin-lerna-packages) to get one module type definition of all definitions in one package. Example result: http://marshal.marcj.dev. Of course, this is only interesting for the documentation part, so you have still to write a `index.ts` and reference it into the `package.json`. Not sure how TS should help and decide what's the public API for the package consumer and what's the complete API.
I actually started a year ago writing a heavy application that uses complex models on frontend and backend, back then using class-transformer and hit a couple of limitations so I was in the need to write my own. There are multiple points why Marshal is better: 1. Enum support class-transformer requires you to write a transformator for Enums. Marshal supports that out the box. ``` class User { type: Type } ``` 1. Marshal supports transforming Date out of the box So no need to write `@Type(() =&gt; Date) created: Date`, in Marshal it's just `@Field() created: Date`. 
I actually started a year ago writing a heavy application that uses complex models on frontend and backend, back then using class-transformer and hit a lot of limitations so I was in the need to write my own. There are many points why Marshal is better: ## Constructor support Usually, in Typescript’s strict mode, you are not allowed to write something like ``` class User { @Field() id: string } ``` because id is not set in the constructor. In Marshal you can put id in the constructor so it signals all users that id is necessary and that User can not be instantiated without it. ``` class User { @Field() id: string; constructor(id: string) { this.id = id; } } //even better way: class User { constructor(@Field() readonly public id: string) {} } ``` This doesn’t work with class-transformer. ## Enum support class-transformer requires you to write a @Transform() for Enums. Marshal supports that out the box. ``` enum Plan { basic = 0; pro = 1; } class User { @EnumType(Plan) plan: Type } plainToClass(User, {plan: 0}); plainToClass(User, {plan: ‘PRO’}); //works as well when @EnumType(Plan, true) ``` Pretty cool when you have a rest endpoint with partial options for the user and limit certain parameters to string literals. ## TypeOrm definitions I want to store some of my entities in the database (mongo first class here), so I need to tell MongoDB my indices. You can annotate indices in Marshal using @Index decorator and can transform the Marshal Entity in a TypeORM entity, so you can pass that into a TypeORM Connection to automatically sync indices. ## Marshal supports transforming Date out of the box So no need to write `@Type(() =&gt; Date) created: Date`, in Marshal it's just `@Field() created: Date`. ## Binary support Using the `buffer` npm package, it supports Binary data out of the box. ## MongoDB uuid/Object Id support Since I work a lot with mongo, it supports serialising those out of the box as well. ## Validation out of the box Not as many as class-validator, but won’t be much work to copy all of those. ## Mongo database abstraction With “@marcj/marshal-mongo” you can easily query and manipulate mongo records from your frontend without thinking one second about serializing stuff. Pretty much a efficiency boost in my projects. ## Partial serialization Using ``` partialPlainToClass(Page, { ‘id’: ‘232’, ‘children.0.name’: 33 }) ``` allows you to serialise arbitrary deep object values so you have the correct values types at the end. Very handy for all kind of patch mechanisms (JSON patch, mongo patch, …). ## Parent references When you have more complex objects with parent references (child-&gt;parent relation) that is not support in class-transformer. Example ``` export class DocumentClass { @IDField() @MongoIdField() _id?: string; @Field() name?: string; @Field([PageClass]) pages: PageClass[] = []; } @Entity('PageClass') export class PageClass { @UUIDField() id: string = uuid(); @Field([PageClass]) children: PageClass[] = []; @Field() @ParentReference() @Optional() parent?: PageClass; @Field()) @ParentReference() document: DocumentClass; constructor(document: DocumentClass, @Field() public readonly name: string) { this.document = document; this.name = name; } } ``` Just works. 
Can you fix the issue by remodeling your solution to only add to the existing types? If so, read https://www.typescriptlang.org/docs/handbook/declaration-merging.html
As a user of class-transformer, this is very interesting
Fuck off with your stolen content.
Thank you. I see it now.
You use Rest parameter (...) with no-array. Please check call stack to find where the error appears. 
thank you for your response. I searched the entire client and I don't seem to use ... anywhere. How could I check the call stack? Sorry I'm way out of my comfort zone here. &amp;#x200B; the Error does seem to say that the rest parameter error is linked to the apollo node module: &amp;#x200B; "ERROR in node\_modules/apollo-utilities/lib/util/mergeDeep.d.ts(2,52):error TS2370: A rest parameter must be of an array type." &amp;#x200B; I looked in the mergeDeep.d.ts file and see the rest parameter being used in that file: &amp;#x200B; &amp;#x200B; export declare function mergeDeep&lt;T extends any[]&gt;(...sources: T): TupleToIntersection&lt;T&gt;; &amp;#x200B; &amp;#x200B; But I doubt I have to change anything in that file right? &amp;#x200B; &amp;#x200B;
Hi, I am new to TypeScript and it seems to work in the browser just fine with no build tools. I am not sure what you mean about it not working 'out of the box'. I just add '.js' to the end of the file name in the import: `import Text from './text.js';` Now just `tsc --watch` and it all compiles when I hit save, in the HTML I have: `&lt;script src="src/app.js" type="module"&gt;&lt;/script&gt;` and it is party time! I have to say it took me ages to work this out and it is kind of insane that this is not in the manual, I found that info on some obscure help thread. I think the functionality was added after TypeScript 2, but I am not sure. IF i want a bundle... AT THE END before I deploy it, maybe I take an extra 10 seconds and type: `rollup --format=esm --file=dist/bundle.js -- src/app.js` TypeScript can already convert down to es2015, or ES2016 if needed. Between these 2 tiny command line tools `tsc` and `handbrake` 99% of important bundling jobs are done... unless you want to spend the rest of your life configuring files rather than writing code. YES this culture of build tools is a joke, taking a course on build tools shows the symptom of a problem. People need to treat dependencies like leprosy, that will will sort things out :) The less dependencies the better, it really is that simple... people seem to love to argue against this seemingly obvious fact. PS No disrespect to the guy doing the course, if people want it then good for him making it! &amp;#x200B;
Might you want to exclude your node\_modules directory in your tsconfig.json files perhaps? e.g. exclude": ["node_modules", "wwwroot"]
While it's not extremely descriptive having implicit exports, it's super convenient to just say ``` import { exportedFunction } from './somewhere/over-the-rainbow' ``` Go does it on the compiler level, but it namespaces folders using package names (a pattern I personally love)
https://github.com/palantir/tslint/issues/1759
This is quite peculiar and shouldn't actually error. `&lt;T extends any[]&gt;` means that `T` should actually be of an array type. A workaround would be so set `"skipLibCheck": true` in your tsconfig.json `compilerOptions` object.
I'll be watching this project. I have an existing project with Nest.js/TypeORM/class-transformer/class-validator that had a lot of issues that you mentioned are solved with your serializer. I'd love to use something that solves those issues once the code base is a little more mature.
lol this doc is so dense... no way to see what it does or how I'd use it... the "examples" repo is the worst I've ever seen. Do they know what example means ?
Any specific issue with the docs? I was able to get an app running from it. I guess it could use some more explanation around rxjs, for those new to it I kind of like the example repo, it's a full project so you can see how it all works together. But yeah, there's only one example
My biggest problem is that there is no main domain with dumbed-down explanations and simple small examples. I'm not going to read 20 pages of docs and read through over 20 files in order to see what it does and how. Give me a couple of single file examples. The barrier to know if I should use the library is way too high currently.
I created also a RFC for NestJS to replace class-transformer: https://github.com/nestjs/nest/issues/1735 If anyone is interested in reading current pain-points and advantages in more detail.
Great point, that's essentially what I did. Or maybe it's exactly what I did? I created a new file in which I import the objects from the existing library, defined all the updated interfaces, and then exported the constants again as my new types. ``` import _NfcManager, { Ndef as _Ndef } from 'react-native-nfc-manager'; interface NfcManager { // updated defs here } interface Ndef { // updated defs here } const NfcManager = _NfcManager as NfcManager; export default NfcManager; export const Ndef = _Ndef as Ndef; ``` Now, in the code where these are used, I simply import form my own `nfc-manager.ts` instead of the installed library. I'll submit a PR to the project if/when I confirm that everything is working correctly. I'll also probably float the idea of them removing the index.d.ts and instead relying on a new package in DefinitelyTyped. This project's maintainers shouldn't have to shoulder the burden of TS defs when they're not actively using it, that's why DefinitelyTyped exists! 
 interface Person { name: string; getGreeting(person: Person); } function Person(this: Person, name: string) { this.name = name; } Person.prototype.getGreeting = function getGreeting (this: Person, person: Person) { return `Hello ${person.name}, my name is ${this.name}`; } No idea why you would do this though. &gt; While the class syntax has (or had) potential to be good, it doesn't currently have near the same amount of flexibility of using prototypes directly. Nothing is stopping you from using class syntax and still modifying the underlying prototypes. 
Yup, I agree, it's weird.
I made an issue at https://github.com/marblejs/marble/issues/112 Not sure if that's exactly what you meant though
Index type with known properties: interface MyType { knownProperty: Foo; [key: string]: Bar | Foo; } The type of the indexer must contain all types of the known properties. Tho I would suggest you to not do this. It's not very type-safe. You'll have a better time separating those two.
Does this not work? ``` type Stuff = { [Key: string]: Bar; F: Foo; } ``` Also you have to put a newline before and after the triple ticks in reddit's md parser.
Thank you, great initiative. That seems like a good start :)
npm install tslint you have to add the tslint dependency to your actual package.json normaly its nested within some nested package by microsoft. by installing it locally (and maybe also globally (-g), cannot recall), the tslint command and editor support (in my case vscode) should work propperly. typical microsoft to implement it that way.
Yes, I meant when you bundling it. You have to use \`rollup\` or something else, extra compile step, time, complexity. While for many cases all that could be solved by adding 10 lines to the \`outfile.js\` generated by TS itself.
Small legibility suggestion, move the "pattern matching" into an object literal: interface FoldMatch&lt;A, R&gt; { nil: () =&gt; R; cons: (head: A, tail: List&lt;A&gt;) =&gt; R; } const fold = &lt;A, R&gt;( fa: List&lt;A&gt;, { onNil, onCons }: FoldMatch&lt;A, R&gt; ): R =&gt; (fa.type === 'Nil' ? onNil() : onCons(fa.head, fa.tail) ); requires you to specify the pattern match arms explicitly: const length = &lt;A&gt;(fa: List&lt;A&gt;): number =&gt; fold(fa, { nil: () =&gt; 0, cons: (_, tail) =&gt; 1 + length(tail) }); More typing, but it's more clear, and resembles languaged-based matching more: // shhh we're caml now let rec length list = match list with | [] -&gt; 0 | _:tail -&gt; 1 + (length tail) There's ["prior artwork"](https://github.com/louthy/csharp-monad) of "faking" pattern matching this way too: // don't mind a random chunk of c# var unit = (from lhs in Two() from rhs in Two() select lhs + rhs) .Match( Right: r =&gt; Assert.True(r == 4), Left: l =&gt; Assert.False(true) ); 
```typescript type WeirdRecord = {[key: string]: Bar} | {foo: Foo}; ```
that has nothing to do with microsoft and everything to do with the clusterfuck of idiocy that is node's module system
Rule #1: Keep it simple ```typescript export class Position { public constructor(public readonly x: number, public readonly y: number) { } public up(){ this.y--; } public down(){ this.y++; } public left(){ this.x--; } public right(){ this.x++; } } const position = new Position(110, 10); position.up(); ```
It's definitely accurate, though. If you have some code like: declare const dict: MyType; function getFromDict(key: string) { return dict[key]; } then the return type would absolutely be `Foo | Bar`, since `key` could be `'knownProperty'`. But it would be annoying to add manual type guards/checks as a result. +1 for separating the two.
Sure, but the actual problem is: const key: string = 'knownProperty'; dict[key] = myBar; Using the index accessor you can assign the wrong type to the known properties, and nothing prevents you from it.
That will not work. The type of the indexer must cover all types of known properties.
The common problem of the documentation written by a guy whom already know all the basic concepts of something and assuming that everyone knows them too...
This is pretty cool. Well written docs as well. The type safe schema validation is pretty similar to how I did it in my project.
How can we write roues in a different file like `posts.routes.ts` ?
But I also need velocity as well as position which is a 2d vector of the same type \[x,y\], as returned by `static UP = new Vector2(0, -1)`. Do you think I should have 2 separate classes? Cheers.
Yes, the x y values need to be available, I have not implemented this code yet, and did not spot that :) I found that there is yet another way to go about this here [https://github.com/matthiasferch/tsm/blob/master/src/vec2.ts](https://github.com/matthiasferch/tsm/blob/master/src/vec2.ts) , he also uses \`private values = new Float32Array(2)\` which I don't think adds any performance benefit for my uses. I lost you a bit on your description of the pros and cons of the static variables, any chance you could provide a very quick example of how you would do it? Cheers.
Your playground link is broken. The official TypeScript Playground is pretty bad. Use this one instead: https://typescript-play.js.org/
I just found a much simpler way: private emit = super.emit
And that does't work: \`class incorrectly extends base class\`
And I noticed another problem: Typescript will give me an error that I incorrectly extend the base class.
How about a Map&lt;Bar&gt; instead of the indexer?
You wouldn't. If class `B` extends class `A`, then `B` **is** `A`, and it should have all members of `A` available. Even if you hack around it, you can still just assign `B` to a variable of type `A` and then call the method that way. If this is an issue to you, then consider adopting composition instead of inheritance.
Thanks, this makes sense. I ended up extracting the dictionary into a separate object.
This! OP is doing OO wrong.
Don't know what use-case you mean with velocity, but: ```typescript export class Position { public velocity = 1; public up() { this.y -= this.velocity; } //or public up(velocity: number = 1) { this.y -= velocity; } } ``` If Position is already the same shape as 2DVector, then you don't need a second class. What use-case do you have with the 2d vector? Pass it into third party library?
My mission is to create a simple zombie shooter game in Vanilla TypeScript using the very best practices and architecture I can come up with to create a tutorial. At the end I would like to be able to defend all the decisions I made to make the code as readable and concise as possible. That is why I am trying to get all this feedback on how people would do it, to get to the solution I like the best. Originally my game had characters that had positionX, positionY and speedX, SpeedY to control the position on screen and move them about. My maths is not great, but a bit of research showed me that this was a perfect use case for a Vector2 or Point2D class to make things more readable. My conclusion (which may be flawed) is I want to represent my position and velocity in a Vector2 class like \[x : 1, y : 2\] and then add them together to move things about: let position = new Vector2(110, 10); position = position.add(Vector2.UP); The velocity value here is the `UP` value (`static UP = new Vector2(0, -1)`), but it might be something else, any velocity to move my sprite around. I could also add acceleration into the mix if I wanted, but that might be too much for my example. &gt;If Position is already the same shape as 2DVector, then you don't need a second class but I don't need any more than one class with a Vector2 class as per the previous solution AND the name will remain accurate, I don't want to refer to the Position class when I mean Velocity, they are both the same, a Vector2. I can't quite understand why your solution is more simple? Also in your second example velocity is fixed to 1 `public velocity = 1;`, is that not speed rather than velocity? Maybe I am getting out of my maths depths, I had to look it up here :) [https://www.mathsisfun.com/measure/speed-velocity.html](https://www.mathsisfun.com/measure/speed-velocity.html) So acceleration (speed) would be a constant force on x and y, but velocity would include the direction, so a different amount of x and y to point the character. &amp;#x200B;
`public velocity = 1` is not `readonly`, that means it's adjustable. Just one way to define a velocity. The architecture and structure of your classes and functions are defined by your use-cases, not by mathematical representation. You optimize for usability and readability, not for performance and math formula equivalence. If your need a velocity that is normally constant you shouldn't pass it always via a method argument. If velocity is most of the time different, add it as method argument. Your use-case defines the API, not vice-versa. So, if you say you have a Character that should be able to move with a certain velocity (where most movement have different velocity), you simply convert this requirement to code. ```typescript class Position { constructor(public x: number, public: y) {} } class Character { public readonly position = new Vector2(0, 0); public move(x: number, y: number, velocity: number = 1) { this.position.x += velocity; this.position.y += velocity; } } ``` Whether you add `up`, `down`, `left`, `right` depends whether it makes the API easier and you actually have a use-case. Do you need those methods in your code? Add them. Don't use them? Don't add them. If you need different velocity for x and y, change signature of `move` or add another method. Don't add functionality beforehand as this is premature optimization that you should avoid. 
The example for partial is very bad and introduces bugs. Don't do that. Don't spread a `Partial&lt;T&gt;` to a `T`.
How so? You're saying take all of the properties in `T`, then overwrite the ones the user has defined in `Partial&lt;T&gt;`. I don't see where type or logic errors could have an impact here.
Thanks for the help, I spoke to a friend who is very good at maths and physics and I think I am still a bit muddled on vectors. I am going to do some research and return to this thread when I have more clarity on them.
Nice article! Would be great if you added instructions for the VSCode ESlint plugin and gave config examples for prettier and airbnb. Here is what works for me: ``` { "extends": [ "./node_modules/eslint-config-airbnb-base/rules/best-practices.js", "./node_modules/eslint-config-airbnb-base/rules/errors.js", "./node_modules/eslint-config-airbnb-base/rules/node.js", "./node_modules/eslint-config-airbnb-base/rules/style.js", "./node_modules/eslint-config-airbnb-base/rules/variables.js", "./node_modules/eslint-config-airbnb-base/rules/es6.js", "plugin:@typescript-eslint/recommended", "prettier", "prettier/@typescript-eslint" ], "parser": "@typescript-eslint/parser", "plugins": ["@typescript-eslint"], "rules": { "lines-between-class-members": "off" }, "env": { "browser": true, "node": true, "mocha": true } } ``` ``` "devDependencies": { "@typescript-eslint/eslint-plugin": "^1.4.2", "@typescript-eslint/parser": "^1.4.2", "eslint": "^5.15.1", "eslint-config-airbnb-base": "^13.1.0", "eslint-config-prettier": "^4.1.0", "typescript": "^3.3.3333" } ``` ``` { "compilerOptions": { "target": "es2018", "module": "es2015", "sourceMap": true }, "include": ["src/**/*"] } ``` vscode settings.json (needed for now https://github.com/Microsoft/vscode-eslint/issues/609) ``` { // enable eslint checking and fixing in both `.ts` and `.tsx` files "eslint.validate": [ "javascript", "javascriptreact", { "language": "typescript", "autoFix": true }, { "language": "typescriptreact", "autoFix": true } ], } ```
&gt; You're saying take all of the properties in T from a default, then overwrite the ones the user has defined in Partial&lt;T&gt; ... and then you blindly assume that every overwritten property is not `undefined` anymore. The compiler intentionally lacks type-safety here. interface Data { value: string; } const full: Data = { value: 'bla' }; const partial: Partial&lt;Data&gt; = { value: undefined }; const merged: Data = { ...full, ...partial }; // Compiler says type is string, but it's actually string | undefined console.log(merged.value);
Thanks for the explanation!
NestJS is one of the best things that happened to Nodejs ecosystem lately. Its great to see its success.
Thanks. Did not want to add airbnb since it is too strict about rules. I did mention about eslint-config-prettier, but thought that it was an overkill for an introductory post. Regarding VSCode, is there some more instructions that need to be added, I thought it worked out of the box?
naah. nesting tslint and its rules in a 3rd party package and provide a generator without checking if it even works is kinda microsofts fault.
The only reason it works is because node's dependency system is whack. You can't blame someone for taking advantage of the tooling available to them, you blame the people for making the tools shitty in the first place.
Typescript supports null safe types with the --strictNullChecks option, so you don't need to check for null like in line 30 and 31. Be careful when the type changes from `Any` to something else though.
Don't try to fight against the system - just takes time an you likely loose. Why don't you wrap the emitter into your own class? Google for composition over inheritance...
Do you have an alternative way if writing this?
Why not use tslint? 
Use the `Pick&lt;T, K&gt;` type instead. Unlike `Partial&lt;T&gt;` it does not modify the type of the properties, but represents a strict subset. It does require an additional type parameter tho, so it's not very well suited for the class-scope.
Not gonna lie, sometimes it isn’t so obvious unless you read the documentation. At my work, I work on our CRM system and sometimes I’ll need to write a client side script that accepts a parameter given by the CRM. Unless I read the CRM client side documentation, I would never know which type to use. Sometimes it isn’t in the documentation either, which can be annoying. In react native’s case, similar rules apply I believe. You’ll have to consult tHE documentation in cases where the type isn’t obvious
—strictNullChecks isn’t the same as a runtime check, though. They’re both appropriate defenses depending on the circumstances.
Wow. I had no idea that an explicit `undefined` value would overwrite things to the left of it in object spreads (and also `Object.assign` it looks like). 
&gt; resembles languaged-based matching more: Actually your JS sample looks quite a bit like Scala. Can't wait to get it as part of the language.
While that's true - but if you write your whole code under strictNull, it's simply not possible to pass null to a function which does not allow a nullable type. And I would omit the checks. If you on the other hand write a library to be used by other or other software parts, you're right.
Check the link about the issue, that explains the out the box situation.
Yes that's another option: I wrote a scaffolding tool for ADTs https://gcanti.github.io/fp-ts-codegen/ if you click on the "fold handlers style" checkbox it will switch between positional and record
easy way to figure out is to add a function parameter that's wrong and then read the error message. like in the event handler add e: string and then the error will say something like type string cannot be assigned to type (correct type)
It makes sense, in a way. You did *define* the value... Of course, the fact that you can define things to be undefined is a bit troublesome in the first place...
I'm checking against null because 'request' can!!! come from remote. Another reason is - it gives me confidence - better check twice and fail fast...
\&gt; We wrote it with Javascript \&gt; /r/typescript 
No, they will not change this in the future. This is part of JavaScript, and TypeScripts clear goal is to stay close to JavaScript.
Could be worse. I used to use a programming language where you had to write something like this: SET PAGE "Page2" PANEL "Header" LABEL "UserNameLabel" Text "Caption" TO username 
Seems related to \[this issue about variadic function types\]([https://github.com/Microsoft/TypeScript/issues/5453](https://github.com/Microsoft/TypeScript/issues/5453)). If the union operator worked on array types, maybe you could do something like: \`\`\`ts function assign&lt;T, S extends any\[\]&gt;(target: T, ...sources: S): T &amp; S; \`\`\`
I actually like explicit `this`, makes it less magical and more like a normal argument. Reminds me of Python's `self` argument.
Thanks. It shows the lightbulb sometimes to me, though I am not sure when. I'll dig into it and add that soon. Thanks for the detailed explanation!
If there's no documentation with types what I try to do is F12 (jump to definition) into the library type definitions file and look at what's available. In your case I would go into `@types/react/index.d.ts` and search for Event to see if there's anything I can use.
This.
It follows javascript even more closesly. In javascript, it's not just convention. It's the LAW!
The behavior of the spread / `Object.assign` make completely sense. The behavior of the TypeScript compiler does not.
&gt; It is the C# convention to use 'this'. Bullshit. There's no official C# convention that advocates the use of `this` (or the lack of either). &gt; And Typescript follows C# quite closely. This has **nothing** to do with C#. It has to do with the way JavaScript works. And it's not goal of TypeScript to be close to C#, but be close to JavaScript.
Well, the goal is to be a superset of javascript, not to be as close to it as possible. That is, any valid javascript application would compile in typescript. Otherwise we wouldn't have non-standard arbitrary extensions like jsx, namespaces, primary constructors, etc. It isn't therefore *inconceivable* that this might be added as a convenience feature, but it seems pretty unlikely to me; in a language like C#, you typically use implicit this with `PascalCase`'d properties, so it's pretty clear what an unqualified access is referring to. This convention does not exist in javascript, so it'd be like using `with (this)` everywhere.
Goal 8 states: &gt; Avoid adding expression-level syntax. While the suggestion is technically not an addition, I'd still argue that it is a syntax change and falls under this category.
Yes, I agree. For implicit this to make sense, javascript would have to have different naming conventions than it does. 
Gotcha, that makes sense. I agree, the behavior of spreading undefined not changing the type is definitely a foot-gun.
It is LAW because it was necessary in the past because of JSs weird scope strategy but at least in classes it should be obsolete. 
Having implicit `this` literally ONLY adds ambiguity to your code. Why would you want that?
Hmm, you should try a language where this/self is not necessary. It's not like magic, it feels very natural if you are used to it. I don't even get it why TS decided to go this route??? 
import * as types from '@babel/types' function ({types: t}: {types: typeof types}) {}
agreed, an insanely good framework
you won't achieve much if you don't specify a salary.
The react library itself isn't written in typescript, that's why you react devs are having hard time using typescript, whih is very unfortunate when you see other frameworks like angular (and soon vue) being written in typescript natively, they don't have these kinds of problems 
That's a part of the interview process. I'm not looking for gig work
It doesn't really matter. It's the language that runs in browsers. It could have been different in a lot of ways. Personally, I disagree with a lot of design decisions of javascript, but it's not changing. And typescript's mission statement is to track javascript as closely as possible, so that's not changing either. If you want a language that works different from javascript, it's not going to be typescript.
That's the thing though, posting a range helps individuals know what skill level you're looking for and how much you value that role. Far too often I hear looking for X number of years, with Y framework and when I reach out they are not looking to pay more than 60k. That tells me everything I need to know about how they value what I provide. (Before anyone jumps on me for that, I recognize that's a good salary for a junior but I'm referencing jobs that ask for 5 - 10 years of experience) If you can't be transparent about what I can expect up front, why would I go through the effort of dusting off my resume, updating my github, ect on the hope that our desires align?
Eh, my main drivers are python, Java, and typescript, with not as much python these days and a whole lot of Java. I prefer using this in Java, and have no trouble with using it in typescript. In fact, until this post I never consciously realized that this was necessary, I'd just always done it. Why do I prefer it? Because it makes it explicit where the values or methods are coming from. Explicit is good, implicit is bad (usually, up to a certain point, and only as long as it adds clarity). It also makes refactoring easier, since at a glance I can see what belongs to the class and what belongs to the current scope. It helps u unfamiliar reviewers see what is part of the class without having to check, this.method() is unambiguous, while method() could be an import, locally defined function, even a parameter.
What if there are circular dependencies?
Factories. Lazy loading. Property injection. Panic and/or don't write circular dependencies. I suspect those are out of scope for a "learn dependency injection" article, though.
Well right now I could see us hiring several people between 60k - 140k depending on skill level and experience. 
60k - 140k
Lol "don't write circular dependencies". That's my preferred approach.
Yeah, mine too. I'm having a hard time thinking of a single time I had a circular dependency that was necessary. Or helpful, really. 
Look for full-stack devs. Typescript was very easy for me to pick up, as it feels like C#. I’ve had many younger devs join my team, knowing only JavaScript and C#/Java, who picked it up really fast (And seemed to enjoy using it). IMO one of the hardest parts about it is scaffolding and ironing out a dev workflow.
Salary range means absolutely nothing with respect to skill level. I actively hire, and speak to people hoping for $180k - $200k out of college and barely understand the full react lifecycle or differences between state management libraries. And on the flip side, people fine with $140k that are brilliant. I'm not advocating against salary transparency, I just don't think up front is useful. I'm willing to pay over what I should for someone amazing, and under for someone that may be serviceable but not quite where we would really need yet.
Nah wait, node and webpack already provides a module system which deals with that? Hmpf lets rewrite one from scratch.
I was not as clear as I meant to be. I completely agree that the salary someone is asking for (particularly in development) is not an indicator of their skill level, I was only speaking to the range the employer was looking to fill the role for.
Facts. 
This is just amazing! Thanks
Module system is kinda different to DI. You can do some of the same tricks with webpack (eg. injecting a fake module for local dev), but it's not quite the same as eg. auto injecting the same instance of a config provider to multiple objects, or automatically managing a request context object for the lifetime of an HTTP request
It doesn't. Just accept the help from your compiler. A whole bunch of other languages are using implicit this without problems. BTW talking about ambiguity on a language that still uses "var" with all it's problems is somehow cumbersome
I agree with the "static" argument. To bad that they already rejected the "this"-feature-request. Thanks for the info.
Thanks! Any ideas of the return type too?
Might not be the answer you asked for, but if there is no strict project requirement to do so, you might want to try to code using functions and modules only. That's what I do in my app, and coming from a Java and OO PHP background, it feels so much more ergonomic. When React introduced Hooks, I got hooked and converted all my class components in a prototype I was working on. Never looking back. I've yet to find an entity in my Domain that needs to be modeled as an object.
Yeah, it's very interesting. Check out the author's other posts too!
My question is why do we suffer from this nonsensical abstraction? given that Typescript - Does not support higher kinded type (not first class citizen). - Type inference mechanism is weak. which leads to unnecessary bloated type signature. Is that really worth it despite above caveats?
It's worth a lot. We all agree that the TS's type system it's not the Haskell's one, but it's still a good type system, which is better than blindly code JS and hope for it to work. TS gives you: * the visibility on the entire codebase * ADT, which let you make illegal states unrapresentable * about the HKT: [https://github.com/grossbart/fp-ts/blob/master/docs/recipes/HKT.md](https://github.com/grossbart/fp-ts/blob/master/docs/recipes/HKT.md)
And location? Any relocation package offer? Potentially support for working permit application?
Thank for the HKT example link. From their site, I found out that HKT is implemented with "lightweight higher-kinded polymorphism" just like kotlin's arrow library. that make sense. I agree that type system gives you a lot of benefits like you mentioned codebase visibility, ADT etc which stock type system of typescript already provides. Maybe my words wasn't clear enough So here again, My question was what is the justification for abstracting functional constructs on typescript. In my opinion, Typescripts type system is very shaky foundation for that kind of abstraction. AFAIK, there's no sound type system which combines nicely OO and FP even theoretically. For example, The scala language tried to mix the two paradigm and the result is split of coding convention. I think it failed at producing synergy of the two only increased complexity of the language. There's already good alternative like purescript, elm, reasonml, in functional aspect. then why we need to keep reinvent the wheel instead fortify the better? 
TypeScript is a superset of JavaScript, so it's a lot easier for a JS developer to learn it and it's easier to migrate an existing codebase to TS. Different cost-benefit, I assume.
There's the `emitDecoratorMetadata` compiler flag which adds runtime meta-data to classes with decorators, but beyond that there is nothing official. This flag is nowadays considered a mistake by the TypeScript team for the same reason why they won't add something like you want: It does not align with the clearly stated TypeScript goals.
This is [explicitly a non-goal](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals) (see #5).
Thanks for the rundown. I think I'll keep the duplication over a DSL.
`transitionsTo` looks like it receives a key of `{ init; startScreen; gameRunning; gamePaused; gameOver }` not the type of `Game['states']` (which is the entire `states` interface). I think this will work: ```ts interface GameStates { init; startScreen; gameRunning; gamePaused; gameOver; } interface Game { lives?: number; level?: number; STATE?: symbol; STATES?: GameStates; init?(this: Game): any; start?(this: Game): any; pressPause?(this: Game): any; looseLife?(this: Game): any; nextLevel?(this: Game): any; gameOver?(this: Game): any; } function transitionsTo(stateName: keyof GameStates, fn: any) { return function(...args: any) { const returnValue = fn.apply(this, args); this[STATE] = this[STATES][stateName]; return returnValue; }; } ```
It's pure TypeScript code, no DSL.
Cheers! It was the `keyof` keyword I needed :) Only one remaining error I can't seem to fathom! I added some more detail to my interfaces, but on the `game` object `[STATE]` says 'object literal may only specify known properties, and \[STATE\] does not exist on type 'Game': ``` interface GameStates { init; startScreen; gameRunning; gamePaused; gameOver; } interface Game { lives?: number; level?: number; STATE?: any; STATES?: GameStates; init?(this: Game, ...args: any[]): void; start?(this: Game, ...args: any[]): void; pressPause?(this: Game, ...args: any[]): void; looseLife?(this: Game, ...args: any[]): void; nextLevel?(this: Game, ...args: any[]): void; gameOver?(this: Game, ...args: any[]): void; } const game: Game = { lives: 3, level: 1, [STATE]: init, // ERROR!!! [STATES]: { init, startScreen, gameRunning, gamePaused, gameOver }, init(...args) { return this[STATE].init.apply(this, args); }, start(...args) { return this[STATE].start.apply(this, args); }, pressPause(...args) { return this[STATE].pressPause.apply(this, args); }, looseLife(...args) { return this[STATE].looseLife.apply(this, args); }, nextLevel(...args) { return this[STATE].nextLevel.apply(this, args); }, gameOver(...args) { return this[STATE].gameOver.apply(this, args); }, }; ```
I think you're getting that error because you're trying to set the symbol key `[STATE]`, but the `Game` interface only has a string key `STATE`. Try this: ```ts interface Game { lives?: number; level?: number; [STATE]?: any; [STATES]?: GameStates; init?(this: Game, ...args: any[]): void; start?(this: Game, ...args: any[]): void; pressPause?(this: Game, ...args: any[]): void; looseLife?(this: Game, ...args: any[]): void; nextLevel?(this: Game, ...args: any[]): void; gameOver?(this: Game, ...args: any[]): void; } ```
Use an interface instead of a class. interface Model { key: string; value: string; }
Cheers! Sorted. TypeScript is a lot more involved than I first imagined.
Agreed. Most of the time you don't need a full class you just need an interface.
Which is a shame because then we can't have nice things like Mockito or dependency injection that you don't have to manually wire up.
It can be. Though I would be surprised if there wasn't a simpler way to accomplish what you're doing. I'm not sure what value you're getting using symbols for the `STATE` and `STATES` keys (I guess you're making them almost private). Also, in my experience keeping a "state" string/enum is a bit of an anti-pattern. The state string should be a product of the actual data (not the other way around). So instead of ```ts const game = { state: 'gameOver', lives: 0 }; ``` You determine the `state` using the actual state of the data: ```ts const game = { lives: 0 }; const gameOver = game.lives === 0; ``` Then you can transition between states by simply writing functions that take a `Game` and return a `Game`: ```ts function killPlayer(game: Game): Game { return { ...game, lives: game.lives - 1 }; } const newGameState = killPlayer(currentGameState); ``` 
why not a type?
type aliases aren't much different from interfaces. The main difference is that interfaces remain open for addition of more members.
&gt; TS falls into the category of what can be referred to as transpiled languages. The keyword here is transpilation. It's often used as a synonym to the compilation, but in reality, it operates on a different scope. You see, the term complied languages often refer to C, C++, Java and alike. Even if they target different outputs, e.g. JVM (byte code) or machine code, they both compile from a high level of abstraction (such as Java's syntax) to something as low-level as machine code. TS, on the other hand, is transpiled to JS, which in fact is a JIT-compiled/interpreted language This distinction is completely obsolete and silly. By this argument C# is just "transpiled" as well, same as Java. And Wikipedia writes about transpiled: &gt; A source-to-source compiler, transcompiler or transpiler[1] is a type of compiler that takes the source codeof a program written in one programming language as its input and produces the equivalent source code in another programming language. This is not the case here either. The JavaScript is not equivalent. It lost all type information.
 &gt;The main difference is that interfaces remain open for addition of more members. Type aliases and interfaces are the same as long as you're not dealing with a mapped or conditional type. You can extend a type alias.
Thanks for taking the time to share this knowledge! I am using symbols as it is converted from JS where there is no `private`, I will probably refactor to make better use of TypeScript. I am not sure I agree about keeping the finite state machine state as a string/enum as an anti-pattern. I have been reading up for days on state machines. Check out [http://raganwald.com/2018/02/23/forde.html](http://raganwald.com/2018/02/23/forde.html) , that is where I took the JS code from. Very comprehensive article. Your way of doing it seems cool, but I can't see the whole game being designed around it. Do you have any examples of a game or similar using this pattern? My other more OOP traditional option was: [https://github.com/torokmark/design\_patterns\_in\_typescript/blob/master/state/state.ts](https://github.com/torokmark/design_patterns_in_typescript/blob/master/state/state.ts) namespace StatePattern { export interface State { handle(context: Context): void; } export class ConcreteStateA implements State { public handle(context: Context): void { console.log("`handle` method of ConcreteStateA is being called!"); context.State = new ConcreteStateB(); } } export class ConcreteStateB implements State { public handle(context: Context): void { console.log("`handle` method of ConcreteStateB is being called!"); context.State = new ConcreteStateA(); } } export class Context { private state: State; constructor(state: State) { this.state = state; } get State(): State { return this.state; } set State(state: State) { this.state = state; } public request(): void { console.log("request is being called!"); this.state.handle(this); } } } but I am not so sure this is as nice as the Reginald Braithwaite example? My current game I wrote from scratch in JS uses switch statements and an invented enum something like this (not working code, just cut and pasted bits to give an idea): public SCREEN = { TITLE_SCREEN: Symbol('TITLE_SCREEN') as symbol, GAME_SCREEN: Symbol('GAME_SCREEN') as symbol, PAUSE: Symbol('PAUSE') as symbol, GAMEOVER_SCREEN: Symbol('GAMEOVER_SCREEN') as symbol, }; /// function mainLoop(): void { switch (state.currentScreen) { case state.SCREEN.TITLE_SCREEN: /// break; case state.SCREEN.GAME_SCREEN: /// break; case state.SCREEN.PAUSE: /// break; case state.SCREEN.GAMEOVER_SCREEN: /// break; // no default } } and around the code things like: state.currentScreen = state.SCREEN.GAME_SCREEN; This is the most basic approach I could think of, but the code got out of hand. I am hoping to get a more structured approach in the refactor, all idea very welcome :)
&gt; Type aliases and interfaces are the same as long as you're not dealing with a mapped or conditional type. You can extend a type alias. Not true. interface I { thing1(): never; } // works interface I { thing2(): never; } type T = { thing1(): never; } // doesn't work type T = { thing2(): never; } 
You don't even have to use symbols or `private`. You could just prefix the name with an underscore. As long as your intention (that the value shouldn't be depended on by consumers) is clear, it doesn't really matter if someone could actually access the value IMO. I'm not a fan of the code in that Reginald article. I think it's because I'm biased towards [immutable reducers](https://redux.js.org/) and the idea that app state is a function of an initial state and list of actions. In my experience stateful code with a lot of mutations is harder to understand and debug. Though my only experience with code like this was an iOS Objective-C app filed with thousand line deeply nested `if/switch` abominations. I think your screen switch statement is fine. I just get worried when I see a string/enum variable `state` because it implies the states can never overlap which can be painful when requirements start changing. If I was writing the bank account code, I would use `open: boolean` and `held: boolean`, and make the appropriate checks in `deposit`, `withdraw` etc. If those functions became too complex/nested, I would probably split the logic into separate functions. Take this with a grain of salt though. Just my opinions. I probably write plenty of shitty code lol
If we really wanted to be pedantic, that's not extending an interface, that's ["declaration merging"](https://www.typescriptlang.org/docs/handbook/declaration-merging.html). 
IIRC, you can get type information with a Reflect polyfill, which allows you to do at least DI.
This. You could also use the Typescript Record type in this example instead of making a new Model interface. Inline the type as Record&lt;string, string&gt;. 
Weird flex, but ok.
Personally I stick with classes so that things like Dates/nested classes are actually instantiated and not just duck typed. 
Sorry for any possible misconception. The point I was trying to make here was that tranpilation is a process that operates on similar levels of abstraction rather than compilation - high to low-level.
some times duck typing gives you more safety though constructor(name: string, email: string){...} addToDB(new Person('asd@asd.com', 'jane doe')); // no error thrown compared to addToDb({email: 'asd@asd.com', name: 'jane doe'}); // an error would be easier to spot or if you have them destructured addToDb({email, name}); you can archive the same in classes by passing in an object but then it's just a bunch of boilerplate for no good reason. &amp;#x200B; If you come from the OO world and use classes as models with logic inside them then using classes is fine obviously. 
&gt; By this argument C# is just "transpiled" as well, same as Java. CLR and JVM bytecode is not source code, so this doesn't fit the definition of transpilation you've quoted. That CLR bytecode has a human-readable, non-binary format (CIL) is as pertinent as that machine code can be expressed in ASM; both CIL and ASM is assembly code, not source code. Compilation in a very broad sense means transforming code from one language into another, and the concept of transpilation was introduced to make a distinction between compiling from source code to source code and compiling to lower-level code like bytecode or machine code. &gt; The JavaScript is not equivalent. It lost all type information. By a similar token, using the word "equivalent" in a strict sense, even just re-formatting code in the same language loses something, so it's not equivalent. If you instead interpret the word in the context it appears in ("source-to-source"), it refers to the level of abstraction.
I use `type` and whenever I need to "extend" a declaration, I use union types. type MergedObject = WithField1 &amp; WithField2;
Many people insist that interfaces are "better" because they can be extended. But for practical purposes, you will do just fine with `type` and whenever you need to extend existing types, use union types. &gt;type WithBoth = WithField1 &amp; WithField2; To me it seems much more elegant and explicit than magically inserting stuff into an `interface`. This way, you never get into a situation where the same type is different based on whether somewhere in the code you added something to it.
Here's an opinionated take. In my code, I usually never use the `class` keyword and just declare the types based on the structure: type MyObject = { key: string value: number } Then I'd specify this structural type as a parameter in the receiving function: foo(o: MyObject) I'd just call it directly: foo({key: "k", value: "v"}); ...or, if `key` and `value` were defined beforehand: foo({key, value}); No need for `new`, `class`, constructors, all that jazz. TypeScript will let you know if you're passing an object with the wrong structure. e.g. it will complain about: foo({key, values});
Essentially it's a religious question of OOP vs functional. OOP style relies on classes (combine state and functions), whereas functional style splits up data and functions.
The main reason you want to use an interface over an type alias are error messages.
This is the most elegant way, though it should be Record&lt;‘key’ | ‘value’, string&gt;
Not really. Even old-school Java devs use what they call POJOs - plain classes that describe data only and don't have any methods (except for getters/setters, because Java). Data separation from logic is extremely important no matter what language or philosophy you use. Traditional classes with logic inside use data fields to store internal state which should not be exposed. For example, File class can wrap low level file system access and have a IO handle from OS stored as a private field. This handle is required to talk to OS but it should not be exposed to class consumers, because they should not care about low level stuff. And then you might have a ReportWriter, which hides File inside as a property and provides write method which accepts a POJO. In this case internal File reference is an internal state, private and not exposed, and POJOs will always come as method arguments and will never be stored inside ReportWriter instance. People who can't draw a line between internal state management and data and try functional programming usually end up with a total mess and loads of side effects and then can't find their way out.
&gt; Not really. Even old-school Java devs use what they call POJOs - plain classes that describe data only and don't have any methods (except for getters/setters, because Java). That is the equivalent of not-using classes in TypeScript and using interfaces for object literals instead. In Java they use classes because you can not not use classes. Java does not have something like object literals and structural typing like TypeScript does.
You could build your graphql schema using https://github.com/prisma/nexus. Code-first, generates the GraphQL SDL. I'm personally a big fan. 👌
We do the thing where you pass an object into the constructor but we don't write models by hand. We built a tool that generates ts classes based on our API models. Idk maybe typescript is better than it use to be but we ran into some problems with only interfaces. Like we use moment js and needed to actually instantiate it 
Usually, I do this when one module needs to modify another modules interface definitions.
I'm curious how you deal with circular relationships. For example I use [objection](http://vincit.github.io/objection.js/) in several projects and I find circular dependencies to be very common when describing two-way joins between tables. For example, a `Post` depends on `User` to describe its `author` relationship and `User` depends on `Post` to describe its `posts` relationship.
Just make sure to ask your users FIRST and let them CHOOSE to disable p2p. A lot of users have a slow bandwidth and a traffic cap.
Thanks for pointing this out. I will remove the example from the article.
Goodness, very complicated. Personally, I don't "think and type in TypeScript" like that. TypeScript lets me code JavaScript just like I do C# or Java. Personally, that's how I think and type in TypeScript. TypeScript allows you to play code golf with types. However, it's generally only done when creating typings for legacy JS libraries. This is because legacy JS libraries routinely allow input parameters to be strings, numbers, objects, functions, or all four at the same time. Typing files can get ridiculous because the legacy JS was ridiculous. However, under normal conditions, TypeScript types are usually very simple and stable. Strings are strings. Numbers are numbers. Objects are objects. You always know what you need, what your getting, and what you have to provide.
This seems to be specific to github, not typescript.
We are developing the JavaScript library. What you ask depends on the web developers who use the library.
Of course. I was just pointing it out. Any website who uses something like this without consent of the user should be banned from the world wide web.
Interestingly, the V8 JIT compiler will add its own type information back in and, if the types are stable, will compile it down to machine code. Stable types is the biggest reason transpiled TypeScript seems to run magically faster than vanilla JavaScript. If input parameters are always the same type (i.e. not strings one moment, then numbers the next), the V8 can optimize nearly everything down to machine code, which we all know is ridiculously fast. 
Many sites already, including big media ones
Thank you for making me aware. I'll make sure this script gets blocked wherever I have control over.
So this is a library to help developers push their bandwidth costs onto the users? That seems really scummy. Hopefully in the future this is something Chrome/Firefox can lead the way in auto-disabling in the same way they did recently with auto-playing videos. I imagine the only reason there isn't more backlash against this kind of thing already is a lack of awareness that it's occurring (supported by the fact that sites are under no obligation to tell you).
I like the technology, WebTorrent is kinda cool. But if this is used too much I think very soon browsers will start to block WebRTC by default and ask for permission like your webcam or Flash player.
&gt; Hmm, you should try a language where this/self is not necessary. Having started with C++, the ambiguity is really annoying since every time a function or variable is referenced I have to stop and figure out whether it's implicitly part of the class or not. I've never found it to be "more natural", it just makes the code harder to understand. Explicit is better.
I think you meant intersection types.
&gt; however, it comes along with the Monaco editor, and I want it headless, but I don't immediately see how to separate them [The Monaco source code](https://github.com/Microsoft/monaco-typescript/blob/master/src/tsWorker.ts) contains everything you want to know about embedding the TS language service in a Service Worker. I'd recommend reading it carefully.
With something like this, if you absolutely need it in your DI. https://github.com/inversify/InversifyJS/blob/master/wiki/circular_dependencies.md I usually try to stay away from ORMs that require you to do things like that, though. Or just create a third class / object / function / whatever that has access to both User and Post via composition and handle it there. 
*OwO, what's this?* It's your **6th Cakeday** esamatti! ^(hug)
You're right!
Sorry, but you can not block it. It is available as NPM packet and can be bundled. If the technology (that already exists many years but not as open-source product) is harmful it will be regulated by governments as cookies now do.
Yes. It lowers cost for video streamers. Non-profitable organizations use the script that allows them to bring their ideas to more people. Most of users have do not care about bandwidth, because it is already prepaid, but get the opportunity to watch videos for free or for lower cost but it up to website developers to ask their users if they want to share their bandwidth or not. This library makes free and open-source the technology, that is already used for many years as commercial product. See Peer5, StreamRoot etc.
Yes, it gives more opportunities. It is up to website developers how to use it. It is wise to show less adds for users that share their bandwidth.
&gt; If we really wanted to be pedantic I know I do. &gt; that's not extending, that's "declaration merging". Thanks for the correction.
That is interesting and a cool tech for sure. I'm in Canada where bandwidth is a premium and ISPs service per dollar is some of the worst in the developed world, which is probably why this tech is particularly unappealing given that I'm forced to monitor my bandwidth. I wish I didn't have to, but thanks to that restriction any web service that was tapping into my upload quota would be a major turnoff for me (personally). 
Can you give the code context around where you are getting the error? It’s hard to help debug from the error alone.
Okay, the \`vega-lite\` log code isn't actually two years old, it was updated \~1 week ago with a new method: [https://github.com/vega/vega-lite/commits/master/src/log.ts](https://github.com/vega/vega-lite/commits/master/src/log.ts) &amp;#x200B; My guess is that your versions are out of sync which is causing the Logger implementations to diverge. What version of \`vega-lite\` and \`vega-util\` are installed in your project?
&gt;ERROR in node\_modules/vega-lite/build/src/log.d.ts(23,5): error TS2416: Property 'level' in type 'LocalLogger' is not assignable to the same property in base type 'LoggerInterface'. Type '() =&gt; this' is not assignable to type '(\_: number) =&gt; number | LoggerInterface'. Type 'this' is not assignable to type 'number | LoggerInterface'. Type 'LocalLogger' is not assignable to type 'number | LoggerInterface'. Type 'LocalLogger' is not assignable to type 'LoggerInterface'. Type 'this' is not assignable to type 'LoggerInterface'. Type 'LocalLogger' is not assignable to type 'LoggerInterface'. Property 'error' is missing in type 'LocalLogger'. This error indicates that the LocalLogger defined in the instance of \`vega-lite\` isn't compatible with the \`LoggerInterface\` from \`vega-util\` because it's missing the \`error\` method which was added only a few days ago in \`vega-lite\`. My guess is that your \`vega-lite\` version is older than your \`vega-util\` version in your current project.
This is from my package.json: "vega": "^5.3.1", "vega-embed": "^3.18.2", This is from npm list | grep vega ├─┬ vega@5.3.1 │ ├─┬ vega-crossfilter@4.0.1 │ │ ├── vega-dataflow@5.2.1 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-dataflow@5.2.1 │ │ ├─┬ vega-loader@4.0.0 │ │ │ └── vega-util@1.10.0 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-encode@4.2.0 │ │ ├── vega-dataflow@5.2.1 deduped │ │ ├── vega-scale@4.1.1 deduped │ │ └── vega-util@1.10.0 deduped │ ├── vega-event-selector@2.0.0 │ ├─┬ vega-expression@2.6.0 │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-force@4.0.1 │ │ ├── vega-dataflow@5.2.1 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-functions@5.2.0 │ │ ├── vega-dataflow@5.2.1 deduped │ │ ├── vega-expression@2.6.0 deduped │ │ ├─┬ vega-scale@4.1.1 │ │ │ └── vega-util@1.10.0 deduped │ │ ├── vega-scenegraph@4.1.0 deduped │ │ ├─┬ vega-selections@5.0.0 │ │ │ ├── vega-expression@2.6.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-statistics@1.3.0 │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-geo@4.0.1 │ │ ├── vega-dataflow@5.2.1 deduped │ │ ├── vega-projection@1.2.1 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-hierarchy@4.0.1 │ │ ├── vega-dataflow@5.2.1 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-loader@4.0.0 │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-parser@5.6.1 │ │ ├── vega-dataflow@5.2.1 deduped │ │ ├── vega-event-selector@2.0.0 deduped │ │ ├── vega-expression@2.6.0 deduped │ │ ├── vega-functions@5.2.0 deduped │ │ ├── vega-scale@4.1.1 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-projection@1.2.1 │ ├─┬ vega-runtime@5.0.1 │ │ ├── vega-dataflow@5.2.1 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-scale@4.1.1 │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-scenegraph@4.1.0 │ │ ├── vega-canvas@1.2.1 │ │ ├─┬ vega-loader@4.0.0 │ │ │ └── vega-util@1.10.0 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-statistics@1.3.1 │ ├─┬ vega-transforms@4.0.2 │ │ ├── vega-dataflow@5.2.1 deduped │ │ ├── vega-statistics@1.3.1 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-typings@0.6.2 │ │ └── vega-util@1.10.0 deduped │ ├── vega-util@1.10.0 │ ├─┬ vega-view@5.2.1 │ │ ├── vega-dataflow@5.2.1 deduped │ │ ├── vega-functions@5.2.0 deduped │ │ ├── vega-runtime@5.0.1 deduped │ │ ├── vega-scenegraph@4.1.0 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-view-transforms@4.3.0 │ │ ├── vega-dataflow@5.2.1 deduped │ │ ├── vega-scenegraph@4.1.0 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-voronoi@4.0.1 │ │ ├── vega-dataflow@5.2.1 deduped │ │ └── vega-util@1.10.0 deduped │ └─┬ vega-wordcloud@4.0.1 │ ├── vega-canvas@1.2.1 deduped │ ├── vega-dataflow@5.2.1 deduped │ ├── vega-scale@4.1.1 deduped │ ├── vega-statistics@1.3.1 deduped │ └── vega-util@1.10.0 deduped ├─┬ vega-embed@3.30.0 │ ├─┬ vega-lib@4.4.0 │ │ ├─┬ vega-crossfilter@3.0.1 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-encode@3.2.2 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ ├── vega-scale@2.5.1 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├── vega-event-selector@2.0.0 │ │ ├─┬ vega-expression@2.6.0 │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-force@3.0.0 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-geo@3.1.1 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ ├── vega-projection@1.2.1 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-hierarchy@3.1.0 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-loader@3.1.0 │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-parser@3.9.0 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ ├── vega-event-selector@2.0.0 │ │ │ ├─┬ vega-expression@2.6.0 │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ ├── vega-scale@2.5.1 deduped │ │ │ ├─┬ vega-scenegraph@3.2.3 │ │ │ │ ├── vega-canvas@1.2.1 deduped │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ ├── vega-statistics@1.3.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├── vega-projection@1.2.1 deduped │ │ ├─┬ vega-runtime@3.2.0 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-scale@2.5.1 │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-scenegraph@3.2.3 │ │ │ ├── vega-canvas@1.2.1 deduped │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├── vega-statistics@1.3.0 deduped │ │ ├─┬ vega-transforms@2.3.1 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ ├── vega-statistics@1.3.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├── vega-typings@0.6.2 deduped │ │ ├── vega-util@1.10.0 deduped │ │ ├─┬ vega-view@3.4.1 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ ├── vega-parser@3.9.0 deduped │ │ │ ├── vega-runtime@3.2.0 deduped │ │ │ ├─┬ vega-scenegraph@3.2.3 │ │ │ │ ├── vega-canvas@1.2.1 deduped │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-view-transforms@2.0.3 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ ├─┬ vega-scenegraph@3.2.3 │ │ │ │ ├── vega-canvas@1.2.1 deduped │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├─┬ vega-voronoi@3.0.0 │ │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ │ └── vega-util@1.10.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ └─┬ vega-wordcloud@3.0.0 │ │ ├── vega-canvas@1.2.1 deduped │ │ ├─┬ vega-dataflow@4.1.0 │ │ │ ├── vega-loader@3.1.0 deduped │ │ │ └── vega-util@1.10.0 deduped │ │ ├── vega-scale@2.5.1 deduped │ │ ├── vega-statistics@1.3.0 deduped │ │ └── vega-util@1.10.0 deduped │ ├─┬ vega-lite@2.6.0 │ │ ├── vega-event-selector@2.0.0 │ │ ├─┬ vega-typings@0.3.53 │ │ │ └── vega-util@1.10.0 deduped │ │ ├── vega-util@1.10.0 deduped │ ├── vega-schema-url-parser@1.1.0 │ ├─┬ vega-themes@2.2.0 │ │ └─┬ vega-typings@0.3.53 │ │ └── vega-util@1.10.0 deduped │ └─┬ vega-tooltip@0.16.0 │ └── vega-util@1.10.0 deduped All of those dedupes sound wrong, but I'm too much of a newb to know where they're coming from.
But it's also complaining about level, warn, info and debug, in my original error. It seems they would have been there a long time.
Yeah, that's because the other methods all return a type of \`LoggerInterface\`, so they are all basically "downstream" errors from the first one.
So I specified "vega-lite": "2.6.0" and "vega-util": "1.10.0" in package.json, and npm list agrees that those are the versions that are being used, but the error never changes. :-(
2.6.0 of Vega-lite doesn’t have the error method: https://github.com/vega/vega-lite/blob/v2.6.0/src/log.ts The version you linked in the OP is from the 3.0.0 RC. Also, vega-util 1.10 is not from the repo you linked, it’s in the main Vega repo now.
I found passing an Array in a prop upset vetur and vscode's linting for various code (not necessarily related to the array) in the component. If this is the case for you, then you may need to use PropOptions to specify the type for the array (I do for all arrays and objects now), see here: https://github.com/vuejs/vue/issues/7640#issuecomment-365217858
I played around with a similar idea using [typescript-json-schema](https://github.com/YousefED/typescript-json-schema). Once you have JSON schema data for all your types, you can do all kinds of stuff with it: - Generate GraphQL schema https://github.com/ManjunathaN/jsonschema-to-graphql - Generate typescript interfaces https://www.npmjs.com/package/json-schema-to-typescript - Generate runtime type validation functions https://github.com/epoberezkin/ajv-pack
That cleared it right up. Thank you. And no more errors in the compiler either.
You can also do ``` options: Array as () =&gt; string[] ```
 bind&lt;T, A0, A extends any[], R&gt;(this: (this: T, arg0: A0, ...args: A) =&gt; R, thisArg: T, arg0: A0): (...args: A) =&gt; R;
`strictBindCallApply` May be of use to you https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html
sounds like peerDependencies are what you want—though they're kind of difficult to deal with
You can do something like this. function foo(x: string, y: string) { return "Bar"; } type Params&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never; type Param1&lt;T extends (arg: any, ...args: any[]) =&gt; any&gt; = T extends (arg: infer P1, ...args: any[]) =&gt; any ? [P1] : never; type Param2&lt;T extends (arg1: any, arg2: any, ...args: any[]) =&gt; any&gt; = T extends (arg1: infer P1, arg2: infer P2, ...args: any[]) =&gt; any ? [P1, P2] : never; type RestParams&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never; type RestParam1&lt;T extends (arg: any, ...args: any[]) =&gt; any&gt; = T extends (arg: any, ...args: infer P) =&gt; any ? P : never; type RestParam2&lt;T extends (arg1: any, arg2: any, ...args: any[]) =&gt; any&gt; = T extends (arg1: any, arg2: any, ...args: infer P) =&gt; any ? P : never; function bind&lt;X extends (...args: any[]) =&gt; any&gt;(func: X, self: any, ...args: Param1&lt;X&gt;): (...args: RestParam1&lt;X&gt;) =&gt; ReturnType&lt;X&gt;; function bind&lt;X extends (...args: any[]) =&gt; any&gt;(func: X, self: any, ...args: Param2&lt;X&gt;): (...args: RestParam2&lt;X&gt;) =&gt; ReturnType&lt;X&gt;; function bind&lt;X extends (...args: any[]) =&gt; any&gt;(func: X, self: any, ...args: Params&lt;X&gt;): () =&gt; ReturnType&lt;X&gt; { return func.bind(self, ...args); } const y = bind(foo, null, "1"); So whats happening here is that we create a new `bind` function which takes in a function in this case and infers its arguments and determines what needs to be returned. You can expand the overloaded types to handle more arguments. Though there might be other better, cleaner solutions. Let me know if you find one. P.S: Try it in [TypeScript playground](https://www.typescriptlang.org/play/index.html#src=function%20foo(x%3A%20string%2C%20y%3A%20string)%20%7B%0D%0A%09return%20%22Bar%22%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Atype%20Params%3CT%20extends%20(...args%3A%20any%5B%5D)%20%3D%3E%20any%3E%20%3D%0D%0A%09T%20extends%20(...args%3A%20infer%20P)%20%3D%3E%20any%20%3F%20P%20%3A%20never%3B%0D%0Atype%20Param1%3CT%20extends%20(arg%3A%20any%2C%20...args%3A%20any%5B%5D)%20%3D%3E%20any%3E%20%3D%0D%0A%09T%20extends%20(arg%3A%20infer%20P1%2C%20...args%3A%20any%5B%5D)%20%3D%3E%20any%20%3F%20%5BP1%5D%20%3A%20never%3B%0D%0Atype%20Param2%3CT%20extends%20(arg1%3A%20any%2C%20arg2%3A%20any%2C%20...args%3A%20any%5B%5D)%20%3D%3E%20any%3E%20%3D%0D%0A%09T%20extends%20(arg1%3A%20infer%20P1%2C%20arg2%3A%20infer%20P2%2C%20...args%3A%20any%5B%5D)%20%3D%3E%20any%20%3F%20%5BP1%2C%20P2%5D%20%3A%20never%3B%0D%0A%0D%0Atype%20RestParams%3CT%20extends%20(...args%3A%20any%5B%5D)%20%3D%3E%20any%3E%20%3D%0D%0A%09T%20extends%20(...args%3A%20infer%20P)%20%3D%3E%20any%20%3F%20P%20%3A%20never%3B%0D%0Atype%20RestParam1%3CT%20extends%20(arg%3A%20any%2C%20...args%3A%20any%5B%5D)%20%3D%3E%20any%3E%20%3D%0D%0A%09T%20extends%20(arg%3A%20any%2C%20...args%3A%20infer%20P)%20%3D%3E%20any%20%3F%20P%20%3A%20never%3B%0D%0Atype%20RestParam2%3CT%20extends%20(arg1%3A%20any%2C%20arg2%3A%20any%2C%20...args%3A%20any%5B%5D)%20%3D%3E%20any%3E%20%3D%0D%0A%09T%20extends%20(arg1%3A%20any%2C%20arg2%3A%20any%2C%20...args%3A%20infer%20P)%20%3D%3E%20any%20%3F%20P%20%3A%20never%3B%0D%0A%0D%0Afunction%20bind%3CX%20extends%20(...args%3A%20any%5B%5D)%20%3D%3E%20any%3E(func%3A%20X%2C%20self%3A%20any%2C%20...args%3A%20Param1%3CX%3E)%3A%20(...args%3A%20RestParam1%3CX%3E)%20%3D%3E%20ReturnType%3CX%3E%3B%0D%0Afunction%20bind%3CX%20extends%20(...args%3A%20any%5B%5D)%20%3D%3E%20any%3E(func%3A%20X%2C%20self%3A%20any%2C%20...args%3A%20Param2%3CX%3E)%3A%20(...args%3A%20RestParam2%3CX%3E)%20%3D%3E%20ReturnType%3CX%3E%3B%0D%0Afunction%20bind%3CX%20extends%20(...args%3A%20any%5B%5D)%20%3D%3E%20any%3E(func%3A%20X%2C%20self%3A%20any%2C%20...args%3A%20Params%3CX%3E)%3A%20()%20%3D%3E%20ReturnType%3CX%3E%20%7B%0D%0A%09return%20func.bind(self%2C%20...args)%3B%0D%0A%7D%0D%0A%0D%0Aconst%20y%20%3D%20bind(foo%2C%20null%2C%20%221%22)%3B)
Awesome, `CallableFunction` is definitely what I was looking for. I'd been looking at just `Function` and getting nowhere.
Looking at CallableFunction definition [https://github.com/Microsoft/TypeScript/blob/4ff71ecb98ccbd882feb1738b0c6f1cc93c2ea66/src/lib/es5.d.ts](https://github.com/Microsoft/TypeScript/blob/4ff71ecb98ccbd882feb1738b0c6f1cc93c2ea66/src/lib/es5.d.ts) I definitely over complicated my solution :D
Very cool, I wish safe traverse operator was at language level, like in Ruby `user.home?.address?.street`
Did not know [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) was a thing until I saw this project. Very cool! Too bad it (of course) won't work on IE11.
which is why it can be hard to use in many projects, sure you can try to use polyfills, but proxy isn't 100% polyfillable.
Because it's basically non polyfillable at all. Using proxies means a simple no on IE 11.
Ah, the penny has dropped! I hadn't even noticed the line about error is missing, because I was blinded by all the other errors. When I get errors in Java I can easily find the root cause, but I haven't learnt to do that in TypeScript yet. I went back to vega-util 1.8.0 and the code now compiles, **thank you**. npm list still suggests something wants vega-util 1.10.0 :-(. I really don't understand why I ended up with a version conflict between two libraries, neither of which I supplied a version for in the first place. I seem to get this sort of error every time I use vega, but almost never for any other packages.
Glad to help! From what you posted, it seems like Vega has a complex web of dependencies, which tends to exacerbate the problem, particularly if they aren’t careful about updating dependencies to ensure that all the packages are compatible with each in the more strict manner that Typescript enforces.
We are beyond the point of asking “why TypeScript”. Why would you write JavaScript without static analysis?
I take it you're a big proponent of TS lol. Idk who "we" is but it definitely doesn't include people just learning about and using TS. They still need to know why. Your counterpoint is definitely a good one, but there's no need for both languages, so do you ever see TS overtaking JS, and becoming the standard in web browsers? Or do you think it will always just be compiled into JS. 
The future lies with WASM and server-side rendering, so JavaScript isn’t necessarily the future. I don’t think my phone needs the capability to read types and interfaces; it is a waste of battery. I wouldn’t want TypeScript to make its way into the ECMA spec. I assume that in the future there will be libraries akin to the JVM that handle any necessary JavaScript DOM manipulation. I’d bet that these tools will be written in TypeScript too. TypeScript is good when compared with JavaScript. There are better alternatives out there if you can look at all languages IMHO.
Just think of it like a fancy linter—it makes sure my code is correct.
The creators call Typescript, "JavaScript that scales", and that's main reason I use it on a large Web app I'm working on. It's too easy to introduce subtle bugs with plain JS. Typescript is easier for tools to understand too which gives you superior refactoring options and code completion. I don't think there's much overhead in adding types or setting up a project but it my feel that way at first. The investment of adding types will more than pay for itself in my experience. 
You do know Typescript compiles into JavaScript right? Types and interfaces are only use at compile time. 
Yes. OP asked if I see a future where browsers adopt TypeScript natively. I do not. Obviously it should be compiled. That’s the server’s job, not the clients.
I'm referring to your comment about the phone which seems like a major misunderstanding of how all typed languages work. 
Nice work, I'll use yours before the proposal goes to actual stable version (or nightly)
I just released a babel plugin which adds IE11 support to this [https://github.com/epeli/babel-plugin-ts-optchain](https://github.com/epeli/babel-plugin-ts-optchain)
Here's a babel plugin which adds IE11 support to ts-optchain [https://github.com/epeli/babel-plugin-ts-optchain](https://github.com/epeli/babel-plugin-ts-optchain) 
It's Visitor from @babel/traverse. &amp;#x200B; Created a plugin for ts-optchain usin TypeScript [https://github.com/epeli/babel-plugin-ts-optchain](https://github.com/epeli/babel-plugin-ts-optchain)
But if we're going to use compiler plugins, why not just use one for the [ECMAScript Optional Chaining Proposal](https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining)?
It doesn't work with Typescript 
Totally valid question. &amp;#x200B; I agree with the point that's it's incredibly helpful in a team environment. While I or my teammate may be able to write fully functional js, there's still a lot of time spent trying to understand each other's changes if/when we have to work on the other's code. &amp;#x200B; I also find it very helpful for things like configuration objects, which are super common in javascript. It's nice when I call a method that takes a configuration object, and I don't have to check in the source code to remember what properties the object calls for, Typescript just tells me. &amp;#x200B; I'd take a little overhead in my code in exchange for less headaches day to day every time.
Currently, we only send JavaScript to the client. If we were to send _un-compiled_ TypeScript to the client, it would be senseless.
Another thing I like is it prevents me from getting too clever with my javascript. If I'm not able to describe the type statically—I should probably rethink my API
Yeah same for me until I accidentally noticed it started when I added an array as prop to a new component and I could start hunting down the issue!
You're not understanding at all. OP was asking if browsers (such as those in phones) would ever use TS. He said no, because there wouldn't be any need for it inside the client. &amp;#x200B; I don't actually agree, I do think there is value with TS at the client level—but that's besides the point. They clearly understand that *currently* browsers don't use TS, they're discussing whether or not it *would*.
Thanks for the response :) Makes sense
Thanks! I'm gonna keep using it and getting to know it. Just at first glance it didn't make sense to me.
Yeah that's one thing I was thinking about, the part about having other people understanding the code in a team environment. Thanks!
Apologies, my initial reading of the OP was wrong. 
This could be done by `interface Mine&lt;A,B,C,G extends Yours&lt;A,B,C&gt;&gt; {...}`
There is another language called Elm, and it promises ”zero runtime exceptions”. Well written typescript can almost do the same. When you are all typed there is no way you pass wrong data around, granted json from the server can still cause issues. We have been migrating to TS and the exception log (we use rollbar) show significatly less issues in ts code than the old ja code.
The proposal is still at stage 1, so it's not likely to come any time soon.
&gt; reading the difference beween the files... There aren’t supposed to be any. Ts just adds type annotation, that is stripped away when compiling. If you were looking for the value of typescript here, you haven’t understood the point at all. Ts helps you write correct code. It is much quicker and easier to write plain js. The only problem is, it will be riddled with bugs, that ts would have prevented. When porting projects from js to ts, or even from old ts, to more modern, stricter ts, I have always found plenty of bugs. Apart from bugs, I would also find strangeness. Like objects being reused for multiple, unrelated purposes, unused function arguments, and entire sections of unused or dead code. 
`type ExtractA&lt;G&gt; = G extends Yours&lt;infer A, any, any&gt; ? A : never` You can use this method to extract type arguments from a generic type, so you only have to pass G to your interface and can get A, B, C for free
Yeah I agree. In fact, looking at the long term, I wouldn't be surprised if the entire idea of HTML and DOM goes away and everything is simply streamed to the viewers screen fully rendered as pixels. Depending on how old you are, you might remember a time when music in games was MIDI notes, rendered "client side" by sound cards. This was because putting an audio song on a floppy disk was unthinkable. 
I didn't choose TS after evaluation. Mainly because i needed to maintain bi-directional compatibility with JS. For reasons, my team uses JS across all our projects. I ended up adopting JSDocs for our own code, and .d.ts definition files for 3rd party libraries. We can use TS compiler (and VSCode) to do run static analysis and code hinting, while still working in valid ES6/JS.
I have a Python project which is 13 years old - after a few years understanding your own code is a challenge. I'm rewriting it in TypeScript.
No worries
Also please get ready to ban PeerTube project and all the nodes that run it. It is based on WebTorrent streaming and p2p-media-loader is in its dependencies.
I'm in the process of writing it for O'Reilly. Stay tuned :)
LOL ok but I have no idea who you are or what the title will be :P
Effective TypeScript!
This does not work, because I have to explicitly define A, B, C, G in your interface, and I want to infer it instead.
...by danvk!
(line-art animal here)
Can you give a concrete example of what you want to do?
The example in the OP is what I want to do. The other commenter provided the answer. type ExtractGeneric&lt;P&gt; = P extends Original&lt;infer G&gt; ? G : never; Given a generic type `Original&lt;G&gt;`, I can extract the type of `G`.
(Woodcut)
Honestly, this looks like an over complicated `lodash.get`.
Typescript, not Clojurescript so line_art(animal, here); ;-)
Take your upvote and get out!
🦎
\- Types are code-documentation. \- Look at a function an you know what you thought when you wrote this function \- Let the compiler find bugs for you \- Helps your IDE to make better suggestions for autocompletion If you compare development costs and maintenance costs of a SW project than the relation is about 40:60 (some say it's 20:80... or 30:70) but let it be 40:60. Means you spend 60% of the time reading your own (or others) code. You know the feeling if you look at a function you wrote 6 month ago and you don't know what this thing does... In my opinion that's one of the best argument for types. BTW - I never get it why you wouldn't want to write types? You say this it's overhead??? You mean it takes more time to write \`function checkPort(port: number)\` instead of \`function checkPort(port)\`? 8 chars more - but you know if port is a number or if the function takes a string
Well, if you don't use TypeScript then yes. But this one retains the typing information and works well with the strict null checks feature. Lodash.get creates a black hole in the type system by not validating the path on type level and always returning any type.
When will it be available? (Every author's favorite question, I know.)
&gt; Mainly because i needed to maintain bi-directional compatibility with JS. And why did that prevent you from using TS for your project?
Currently shooting for late this year or early next.
O,Really? That sounds great!
Can we sneak peak a table of contents or something like that? :)
awesome, thanks man
Thanks, and good luck. I look forward to reading it.
Foreword: A Word From the Author Chapter 1: What is TypeScript?
&gt;Why types in general? because they are free tests for your code. I can not imagine to mantain a big project with fear of refactor because there are no types How do you start using typescript in a react project?
https://github.com/avivbiton/RandomContentGenerator/blob/master/tsconfig.json#L5 Just why? Why do you intentionally disable type safety features? Including the fucking awesome strict null checks.
Depends on your project. With Gatsby, the ‘gatsby-typescript-plugin’ page tells you how to use it (pretty simple to setup). CRA let’s you install it with a new project, but there might be a way otherwise to install it later down the road. In general, you have a choice to use typescript straight up or have Babel do the transpiling for you.
hm. I think I will use CRA with typescript since it's a new project.
This is the first my typescript projecti and even when I am used to static typing, I was getting some errors I did not know how to deal with at the time. But i am going to enable it again probably tomorrow or today and fix all the issues.
Please don't teach us JavaScript, no not even "esnext". You wanna learn TypeScript and they blab about async/await.
It's not possible to submit code changes in JS and have it update TS code upstream. That is what I meant. &amp;#x200B; I know that is universal for all transpiled languages, so my problem is not a TS problem, but my projects' problem.
Additionally, use enums or const enums for the state identifiers. Makes eventual refactoring easier (since find all usages, rename, etc. work then).
don't think there's a need for that. A good javascript book + a site like learnxinyminutes should do
The current state of the teamscript codebase at work says otherwise.
I use Jest.
Jest is great in general, and it's really low-effort to support TypeScript (I think it's a single line in its configuration file) - and they're working on actually making it zero-config. (If you happen to use Create React App, it'll already be set up for you.)
Jest is awesome for this. And there’s the ts-jest package that permits to easily handle compilation in-memory.
Jest is great. There’s also Intern https://theintern.io 
Mocha &amp; Chai
had never heard of it, but sounds nice enough to make a quick experiment with it. Thx !
Bad part about Jest is the inclusion of magic global variables. Also extending the `expect` assertions must be done in an untyped way. Boo!
I second this plus use sinonjs for mocking and stubbing properties.
Looks like you are wrong about Ava. There is one more way of using it with Ava which is the official one (using ts-node), see it described [here](https://github.com/avajs/ava/blob/d97f11ddbbf824fd72165266770b9ae046e62324/docs/recipes/typescript.md).
Angular (which is TS based) uses Karma and Jasmine
deno!
Definitely Jest, seeing as that they are migrating to TS
This is only partly related to your question, but the [`tsc-watch`](https://www.npmjs.com/package/tsc-watch) package is a vastly better solution for live watching typescript than `tsc --watch`. It caches and does partial builds, so it's super fast. 
I've been pretty happy with Jest using `ts-jest`
I support this, Jest is not great.
This is not a multi-purpose setup. Besides Jasmine is not great (you know, global variables).
I really like Intern, but it has *the worst* package name. It's impossible to find any help for it, because all of the search listings are job descriptions.
jest with jest-extended ([https://www.npmjs.com/package/jest-extended](https://www.npmjs.com/package/jest-extended))
They're rewriting Jest in TypeScript so presumably your second point will be addressed at some point.
Create React App with TypeScript enabled has been a dream.
48 minutes is quite an investment. Is there a CliffsNotes?
From the video description: This presentation was recorded at GOTO Copenhagen 2018. #gotocon #gotocph http://gotocph.com TJ VanToll - Developer Advocate at Progress ABSTRACT In 2014, I made a strong argument that TypeScript was destined to be irrelevant and that my company should not use it in any of our projects. Fast forward to 2018 and we use TypeScript for, like, everything we build at Progress, and I am no longer a source of trustworthy information. In this talk we’ll discuss why I was wrong. Specifically, we’ll take a look at why TypeScript succeeded where other compile-to-JavaScript languages like CoffeeScript and Dart have languished, and what that means for future of the technology. Come to learn [...] Download slides and read the full abstract here: https://gotocph.com/2018/sessions/639 https://twitter.com/gotocph https://www.facebook.com/GOTOConference https://www.linkedin.com/company/goto- http://gotocon.com #TypeScript #mobile #ProgrammingLanguages
You don't need Karma when you use React, as you don't need to render your components in the browser.
I've never had problems with either Mocha or Jest.
Regardless of the framework, I'd definitely suggest testing your Typescript after it's been through tsc or whatever you use to compile for real. 20s build is pretty long, I'm sure that could be cut right down.
He’s no longer a trusted source of information yet he gives a talk. 
You’ll need to define the function inside of the class, or drop the prototype I think. X is undefined for a or b because a and b are type number and not type vector.
Other than the implicit globals and [expect not failing the test inside try-catch](https://github.com/facebook/jest/issues/3917) I quite enjoy it.
class Vector{ x:number; y:number; z:number; constructor(*x*:number,*y*:number,*z*:number){ this.x = x; this.y = y; this.z = z; } negative(*a*: { x: number; y: number; z: number; }, *b*: { x: number; y: number; z: number; }) { b.x = -a.x; b.y = -a.y; b.z = -a.z; return b; } } Vector.prototype.negative = function () { return new Vector(-this.x, -this.y, -this.z); } Like this ?
This doesnt Raise any errors
The `Vector.prototype.negative = function () {` can be replaced with `public Vector negative() { `
That description explicitly leaves out the value of the CliffsNotes: Why did it succeed? What value did it have that Progress chose to use it for everything they build? There's nothing in that description that I didn't already gather from the title.
It's been more than 48 minutes; did you watch it?
No, and I don't plan on it. I don't have the hour to invest. That's why I asked for the CliffsNotes.
Tl;dr TS is easier for js developers to hop in since it does not reinvent a new syntax from the ground, also good marketing
Thank you.
I think they're already done rewritng jest in typescript: https://github.com/facebook/jest/issues/7807 https://github.com/facebook/jest/tree/master/packages/jest-core/src
I love jest. I can't go back to JUnit now. 
https://www.npmjs.com/package/mocha-typescript On mobile so forgive the formatting. Nice decorators for tests... And keeps my entire stack full typescript. Also works great with Istanbul for coverage. 
How do you write tests for code that hasn't been compiled down yet? And if you do, isn't it possible that the tests you do write for one compiled version become brittle as the compiler may change things between versions?
Did you download the slides? 
What's your question?
The logic problem here is that when a human gets something wrong, it doesn't mean they cease to be a trusted source of information forever.
Typing Ramda seems like the holy grail of Typescript 
FYI, here's the Abstract In 2014, I made a strong argument that TypeScript was destined to be irrelevant and that my company should not use it in any of our projects. Fast forward to 2018 and we use TypeScript for, like, everything we build at Progress, and I am no longer a source of trustworthy information. In this talk we’ll discuss why I was wrong. Specifically, we’ll take a look at why TypeScript succeeded where other compile-to-JavaScript languages like CoffeeScript and Dart have languished, and what that means for future of the technology. Come to learn the basics of TypeScript, and whether TypeScript is a good fit for your next project. 
Being able to admit when one is wrong is one of the strongest indicators of credibility that one can have.
I felt the exact same way in 2014. The thing is, TypeScript was really difficult to use then. You had to manage type definition files either manually or with its own package manager. VS tooling for TypeScript wasn't great and VS Code didn't exist. You spent more time fighting with the tooling than you gained by having type safety. Fast forward to today, we can easily manage type definitions with NPM, Visual Studio support has improved a lot and VS Code is an excellent editor for TypeScript. The ecosystem and tooling around TypeScript has matured and it's much easier to get everything running. We've converted all of our projects to at least support ts in addition to js now, and we're not looking back.
This was/is me.
I have to say tho my enthusiasm for TypeScript has been falling as of late. While I would never go back to writing JavaScript without types, TypeScript's types are not enough. &amp;#x200B; I encounter way too many situations everyday where TypeScript just cannot infer a type correctly. Take this example: foo(): number\[\] { return \[...Array(8).fill('foo')\]} TypeScript has no way to catch this error as Array constructor implicitly returns an any. Not even a warning. You need to explicitly type the array inside the return as Array&lt;number&gt;. &amp;#x200B; At the beginning I was super into TypeScript, thinking it would make it easier to design code by proof, but TypeScript compilers has just way too many issues due to JS's interops which makes it untrusty. Our team would've switched to PureScript or Elm a long time ago to compile to js if lack of ecosystem and most importantly hiring new people would not be an issue. Yes I do believe TypeScript is a much healthier and productive language than JavaScript, but it has its own issues which imho will keep driving the community towards other compile-to-js languages.
&gt; Take this example:foo(): number[] { return [...Array(8).fill('foo')]} This feels like a flaw, couldn't fill be easily typed as `Array.prototype.fill&lt;T&gt;(value: T, start?: number, end?: number): start extends number ? any[] : T[]`?
I think you may have found a bug. TypeScript is supposed to infer types, and does so correctly when you create an array without using the constructor. ``` // error foo(): string[] { const x = []; x.push(3); return x; } // no error bar(): string[] { const x = new Array(); x.push(3); return x; } ``` That bug might be worth reporting. I couldn't find anything with a quick search, but their issue backlog is a bit of a mess.
&gt;foo(): string\[\] { const x = \[\]; x.push(3); return x; } Just tested in typescript playground(using typescript 3.3) and no error is returned.
I get an error in VS Code so there must be some difference between our environments.
Yes. I can confirm. I just tested in vsc and it throws an error. Second example throws an error. Probably because Array constructor returns any\[\] . So second example is executed like this bar(): string[] { const x:any[] = []; x.push(3); return x; }
The difference was most likely the `noImplicitAny` compiler option.
The [type for `fill`](https://github.com/Microsoft/TypeScript/blob/v3.3.3/src/lib/es2015.core.d.ts#L33) isn't the problem here, the [type for the `Array` constructor](https://github.com/Microsoft/TypeScript/blob/v3.3.3/src/lib/es5.d.ts#L1338-L1339) is. You can see the same problem occur without `fill` in /u/badthingfactory's examples from [a sibling comment](https://www.reddit.com/r/typescript/comments/b5rmsh/why_i_was_wrong_about_typescript_with_tj_vantoll/ejforcy/). There are two relevant overloads for the `Array` constructor: new(arrayLength?: number): any[] new &lt;T&gt;(arrayLength: number): T[] I'd need to do more research to understand how the compiler chooses an overload when there are multiple acceptable candidates. For the upthread example it seems we'd want the second one to be picked for `Array(8)` so that the type inference engine might have a chance to "work backwards" and fill in `T` with a more specific type, but instead the first is chosen and we're stuck with `any[]`. (My terminology and/or understanding may be wrong here.) From a language usability perspective, it's not ideal that equivalent values constructed via array literal syntax (`[]`) and the `Array` constructor (`new Array()`) get different types. It feels like those two expressions ought to be equivalent at the type level, just like they are at the value level (this extends to arrays that are initialized with elisions, e.g. `[,,,]` and `new Array(3)` should be typed equivalently, but they aren't).
It sounds like something that should later be covered by `noImplicitAny`, a way to enforce generics on constructors
Not sure what `MyComponent` is refering to. However, it seems that you need to require that the component passed into your HOC accepts `navigation` property. You want to inject that property into this component, so it needs to be able to consume it. ``` export function addNavigationContext&lt;P&gt;( Component: React.ComponentType&lt;P &amp; IAddNavigationContextProps&gt;, ): React.ComponentType&lt;P&gt; { ... } ``` I think you've got it the other way around.
Hey, miloszpiechocki, just a quick heads-up: **refering** is actually spelled **referring**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Just a small question (assuming you're the author) - in the first section you talk about "unpacking an observable too soon" - in the case that you can't use async pipe (because you need it for both the component's HTML and some synchronous logic) how would you refactor this? I've had situations where I'd have to fetch data via HTTP, display that data as-is, but then manipulate the data and do other things with it - usually for subsequent HTTP requests or for passing to other components. It'd be nice to know a nicer way of handling this case :)
&gt; I am no longer a source of trustworthy information harsh...
Should this ``` combineLatest(nameObservable, processAndDraw).pipe( ``` be this? ``` combineLatest(nameObservable, balanceObservable).pipe( ```
It's not really a bug, I've investigated it, and there are some constructors (array, object, json.parse) that will return any and not correctly infer the types. From what I understand this choice was DOM related. Anyway, that was just one example from my head, point was that TypeScript isn't really type safe unless you make sure to type everything. Type infertion cannot be as strict as in other languages.
My company was a pretty early adopter of TypeScript our stack was AngularJS/.Net C# so we were already building angularJS on top of asp.net in Visual Studio. I think that was the perfect storm of a stack for early adopters of TypeScript. It was a very good language for us and one thing I think he doesn't mention is that my C# developers could easily understand it and read it and even preferred it way more than JavaScript(since all C# devs seem to detest javascript to their core). Its introduction first into Visual Studio I think played a huge role in its adoption for that reason. I as a front-end dev first thought it was ridiculous and it was actually my back-end developers who convinced me to try it. I was hooked after our first little greenfield project with it.
Have a Replay subject and have multiple subscribers. Multiple subscriptions to a replay subject makes the source http call just once. 
So then you could use the async pipe on the replay subject, but then also handle separate data manipulation in a subscribe? Nice set of articles by the way, had a little flick through them earlier. I'm a fan of reactive, but it can get messy quite quickly - it's nice to know a few patterns to help reduce the mess.
Exactly. The key here is to convert a cold observable (http) to a hot observable (subject), which supports multiple subscriptions 
Yup you're right. My bad. Will fix!
Typescript is definitely not complete. Heck, they just got bind/call/apply types working in 3.2 and you have to opt in to it with a compiler option. Turn on `--strict` if you haven't already... Otherwise strap in because the type safety keeps getting better. IMO other transpiled languages can't really do better.
But it has 3 rs
Too late at night for me to parse Typescript, but it sounds kind of like this issue: https://github.com/Microsoft/TypeScript/issues/28938
For my latest SPA project, I am using [parcel](https://parceljs.org). We literally have no configuration beyond our tsconfig! For my latest web app, I'm using [Next.js](https://nextjs.org) to provide seamless SSR and frontend development. We have about 100 lines of webpack code to get all our scss bootstrap build, DI through a single import override, and TypeScript all working correctly. Both projects use [npm-run-script](https://docs.npmjs.com/cli/run-script.html) for running tasks.
Any specific use cases it brings to the table? I've looked into Ramda before, but I always opted for what the article describes as "verbose" implementations.
You can also declare `{ x: number; y: number; z: number; }` to say something like: type Coordinates = { x: number y: number z: number } and use that instead. negative(a: Coordinates , b: Coordinates)
Elm and PureScript are definitely safer imho.
Yep, it's time use webpack. It's very convenient, you can just es6 import assets to use them.
Those both look like nominative type systems... Which means that unless you can write code with no non-Elm/non-PureScript dependencies, you are now running 2 different type systems: One for your transpiled language and one for JS. I think that's inherently less typesafe than systems like Flow and TS, which just define a typing grammar for JS.
Babel is used when running jest regardless. What I would suggest is get rid of ts-jest and just use babel. Add `@babel/preset-typescript` preset to strip the types and add the `@babel/plugin-transform-modules-commonjs` plugin if you're using import statements. My .babelrc.js ```javascript module.exports = { presets: ["@babel/preset-typescript"], plugins: ["@babel/plugin-transform-modules-commonjs"] }; ``` And the launch config ```json { "type": "node", "request": "launch", "name": "Launch Jest", "program": "${workspaceFolder}/node_modules/.bin/jest", "args": ["--runInBand"] } ```
It's incredibly hard if not impossible to have runtime type errors in Elm, which is not the case in TypeScript, that was my point. Following Elm for nearly 6 months I've seen one single runtime error reported on forums/issues.
https://www.learnrxjs.io/operators/multicasting/share.html
does it still generate that big json that I need to load in order to use it?
Always bet on Anders. And type safety.
Hopefully he'll have same epiphany about their package modularity in the near future.
When me and a colleague found out you can do this we were stunned. I can see why it’s useful, but it’s so ugly.
There's surprisingly little resources on (publishReplay + refCount) vs share/shareReplay, but FWIW the difference here is important (such that one might want to choose the former): 1. share (and shareReplay) multicasts an Observable right away. Effectively, it makes a long-lived subscription to that observable that is active even when there are no subscribers. Anyone subscribing an unsubscribing will start listening in on the shared observable, but that observable is never really destroyed. 2. publishReplay + refCount will instead make a "shareable" reference-counted Observable. What effectively means is that an Observable piped with publishReplay(1) and refCount() behaves like a shared observable when one or more subscribers are listening, but will actually completely unsubscribe when the last subscriber unsubscribes In things like Angular, or UI cases where loading a new component results in creating a shared observer, and there's no real cleanup, share() ends you up with memory leaks by leaving these leftover opened subscriptions. In that case, publishReplay(1), refCount() might be the better option.
Replay subject is one approach, but that gets at "*2. Avoid Unnecessary Indirection through Subjects*", you can use replay constructs and multicasting without relying on a Replay Subject: class MyClass { readonly mySharedThing$ = this.http.get(...).pipe( publishReplay(1), // Share the last instance of this message refCount() ); readonly myProcessedThing$ = this.mySharedThing$.pipe( ... ); } And then in the template: Display the raw value: {{mySharedThing$ | async}}. Display the processed value: {{myProcessedThing$ | async}}.
Before you *just* had to do: class StringSelect extends Select&lt;string&gt; { ... } &lt;StringSelect&gt; ...
&gt; there are some constructors (array, object, json.parse) that will return any and not correctly infer the types. In the case of `JSON.parse` there is no correct type that can be inferred. The object returned can be truly **anything**. Correct typing would require the compile-time analysis of the provided string, and that would work only for literals. You could only argue that the return type should be changed to `unknown` instead of `any` (since TypeScript 3.0), so you can't implicitly assign it to any other type. The team decided against it because it would result in breaking code **everywhere**. Instead you can opt in yourself by making use of [declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html): interface JSON { parse(text: string, reviver?: (key: any, value: any) =&gt; any): unknown; }
Being completely type-safe is not a goal of TypeScript. It's listed as the [non-goals](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals): &gt; Apply a sound or "provably correct" type system. Instead, strike a balance between correctness and productivity.
Yup, this is much neater 
why did you repost this and delete the other version ? looks like spamming to me.
it's like Mongodb Compass with less features ?
I posted this one yesterday right alongside with the “Why I Was Wrong About TypeScript” video. _That_ felt like spamming to me, so I deleted my post shorty after.
Haven't checked out Compass lately but when I did (\~a year ago) it was super slow. Also, Mongoku is open source!
The same experience here but I moved from Dart to TS. Productivity increases every day. I love Jest, using JS libs in TS has still room for improvement but is by far better than with Dart.
object keys as types is not related to typescript it's a JavaScript restriction. this is one of the few use cases where Map actually becomes useful, since it can have object references as keys.
I can't imagine refactoring a large JS codebase without typescript or incredibly high test coverage now. I'd still prefer TS and no tests to JS and tests.
When you say types as object keys do you mean like the record type where you can use an enumeration or union?
You can use types as the value for the key, by defining an interface or type for the object. So if you pass a variable to the key that doesn’t match the type, TS gives you an error. It’s also possible to define the keys of an interface to match any key of an enum which sounds more like what you’re looking for. I’ll try to find a snippet for ya!
I miss C++ for this exact reason...and RAII...and knowing how many bytes are in all my types...and many more reasons....but I actually do really enjoy using typescript. It's certainly better than using straight JavaScript
I’ve got a large React app I work on that I’ve slowly been converting to use TypeScript. I feel waves of relief with every file that gets converted, just knowing with high certainty that that file is “safe” from inadvertent breaks.
Try to take the existing JS library/module you like and convert it to typescript. Then pull request to upstream if the outcome is fine.
What do you think of the difficulty that arises with high test coverage when you decide you need to move functionality from one unit to another, or split up units—so that then you have the additional job of refactoring your unit tests as well as the code itself? When I'm not really sure the design of the code is right, this deters me from writing too many unit tests.
You kinda answered your own question 😋 Don't write too many unit tests. Unit tests are good for particularly complicated business logic that has lots of edge and corner cases, and well typed and defined units of code kinda get caught by the compiler and type system. Focus on integration tests between these units instead, and you'll have tests that better describe what you want to be testing and are more obviously and easily refactored when required.
Thank you for replying. Sounds like a sensible approach.
Rollup works pretty well too and can be simpler to setup. Here is a simplified version of my setup. If you aren't pulling in any node modules you can remove cjs, builtins, and resolve as well. ``` const rollup = require('rollup'); const resolve = require('rollup-plugin-node-resolve'); const cjs = require('rollup-plugin-commonjs'); const builtins = require('rollup-plugin-node-builtins'); const typescript = require('rollup-plugin-typescript'); const terser = require('rollup-plugin-terser').terser; const gzip = require('rollup-plugin-gzip').default; async function build() { const index = await rollup.rollup({ input: './index.ts', plugins: [ typescript(), resolve({browser: true}), cjs(), builtins(), terser(), gzip() ] }) await index.write({ name: "index", format: 'iife', file: './build/bundle.js', sourcemap: true }); }); build().catch(err =&gt; { console.error(err) }) ```
As u/Pavlo100 said, this is a restriciton in JS. You want Maps. They work as you would expect, and their type information is *more* correct in that the `.get` function always returns `T|undefined`. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map for how to use Map. The only issue is that it's an ES2015 (ES6) feature, so it may not be supported everywhere you want to run your code.
u/SoaringRocket u/cheekysauce Yeah, the huge popularization of unit testing everything comes from Ruby and Python, and was imported to JS. Common theme among these languages is that you don't have types, so to get the same level of trust in the code people had to use unit tests. Luckily, our usage of types lets us remove most of the unit testing and keep mostly the integration tests. Hooray! Just spent about 30min trying to find a really amazing talk that discussed the nuances of tests/types but for the life of me can't remember who gave it or where I saw it :(
Hey, please reply to me as well if you can find it! :-)
Only issue with this is when using `Object.keys` for issues documented by Anders. `Object.entries` went the other way but as a result as its own issues. Swings and roundabouts until we have exact types.
Excellent article
Polar is an Electron-based desktop app, so there is a Chromium built-in.
Nice! Thanks!