I've got two questions for you then... 1. How do you find similar libraries? For instance, I wanted to use pouchdb in react native, for whatever reason the standard pouchdb library does not support react native, meaning the plugin required some configuration (and knowledge I did not have). Somebody did this, I checked the code and well... the javascript code seemed alright but the typescript comparison did not work. Wrote the type definition and it works like a charm. But I've found pretty hard to find similar libraries just using npmjs, is there a different way to find similar libraries? 2. I do not understand how typescript resolves "declare var Foo: any;" maps to a library called Foo. Or if it maps to an interface contained in that namespace. Could you elaborate a bit more?
Similar libraries yeah just go ogling. The declare thing is the result of using require where yeah the library would be exporting a top level Foo variable for all its methods. You just require the js file then declare a var of the same name and typescript will assume that's a thing that you know because you used declare. It's basically just "this thing exists typescript, so don't throw errors". You end up using the library exactly like you would when not using typescript. No typing information or auto completion but it does work 100% otherwise.
Similar libraries yeah just go ogling. The declare thing is the result of using require where yeah the library would be exporting a top level Foo variable for all its methods. You just require the js file then declare a var of the same name and typescript will assume that's a thing that you know because you used declare. It's basically just "this thing exists typescript, so don't throw errors". You end up using the library exactly like you would when not using typescript. No typing information or auto completion but it does work 100% otherwise.
Have you considered jss?
Never heard of it.
You might want to use a library like [emotion](https://emotion.sh/). Autocomplete is less cumbersome to set up with a CSS-in-JS library, since TS understands TS syntax better than CSS syntax. For CSS autocomplete in emotion, you can use [this typescript plugin](https://github.com/Microsoft/typescript-styled-plugin). Also noting you can do pretty much everything in emotion's style syntax that you could do with SCSS, including variables (in JS), interpolations (in JS), color shifting functions (in JS), self-references, mixins (in JS), and so on. If you want classes to be accessible globally, you'll either have to write them normally with CSS, or you can use the [injectGlobal](https://github.com/emotion-js/emotion/blob/master/docs/inject-global.md) helper. If you still insist on using normal CSS/SCSS files... as you can tell, it's not easy (and probably not worth it) if you still want to reap the benefits of TS.
Yes to all
It's worth checking out https://github.com/typestyle/typestyle to have a look at that approach.
Thanks for explaining :)
&gt; OOP-style &gt; lots of application-level singletons What 
Ever done OOP with dependency injection? (e.g. IoC container, factory-based DI, constructor-based DI, service locator, XML-based, etc) All of them are for ways of managing application-level singletones. 
Try Parcel. See https://hackernoon.com/zero-config-typescript-bundling-with-parcel-ef76fabcbfe3
[removed]
Ah this is what you've meant with application-level. Sorry I misunderstood your intent. DI is just an implementation of the DIP (and SRP). Service-locator or similar are another implementation of the same principle, although I like DI the most.
Well done. This looks like a great alternative where Graphql isn't an option and you want an idiomatic TypeScript solution. :)
JavaScript obfuscator is a powerful free obfuscator for JavaScript and Node.js with a wide number of features which provides protection for your source code. It gives many obfuscation features like dead code injection, control flow flattening, strings encryption.
what's the actual use of this? all obfuscated code i've come across has been abusive advertising scripts, cryptocurrency miners and actual malware for windows script host
Yes, people can obfuscate various advertising scripts with this, but this is open package, anyone can use it in any way. Many companies using it for defending their products. Problem with false positive alert is appearing for few antiviruses only and can be avoided by playing with options. https://www.virustotal.com/ru/file/53af005143ac8cfd2eea82c0d05ba2ccf77d2ddd49182aa37632f42dfdec89c9/analysis/1514820105/
should give you a TS2322 compilation error. you have "strict": true in your tsconfig?
My mistake. I'm still a bit new to TS.
I don't have a specific case as I mentioned I have not used TS myself. I was just echoing some of the blogposts (albeit old) that were pointing to the typing system of TS as one that is not mature when compared to Flow.
The gap has closed to where both cover a few rare corner cases the other doesn't, but the functionality is approximately the same. The tooling support generally makes typescript the "win" by comparison, although there are gaps there, too. If you're 100% in the Facebook stack then flow might be easier. The biggest tooling issue (IMHO) is being solved with Babel 7 (currently in beta) and its first-class typescript support via plugin.
Typescript improved enormously even the last year, so those blogposts are not useful. Just make sure to set up your project with full strict-ness. (Default settings from` tsc —init` are ok.)
Author here, happy to hear your thoughts on this technique.
At this point I think it's relatively safe to say that the major differences between typescript and flow are by design rather than by deficiency of typescripts type system. By default typescript doesn't disallow nulls but a compiler flag will make it behave the same as flow. Typescript can use *.js files instead of only *.ts now but again behind a compiler flag. There are various forms of no implicit that can be set by compiler flags. These are defaulted to off because when they are on it can cause errors on some commonly used js patterns. Having them on is closed to flow. The biggest difference left is probably that typescript supports contravariance behind a flag but still has no support for covariance. This is basically by design as typescript was meant to enable a type system on any existing js code where flow will restrict certain patterns in js. The flow team basically said "those aren't good patterns, don't use them" and personally I agree. But typescript was explicitly designed to be able to handle existing patterns not force new ones. At the end of the day, if you aren't using typescript specific features like enums then you will hardly notice any difference between flow and typescript in day to day work. Just use the strict option or a subset of the features you actually want to restrict and then typescript and flow are basically 95% the same.
More precisely: `strict` must be `true` and `strictNullChecks` must not be `false`, or `strictNullChecks` must be `true`.
[removed]
They are nearly equivalent as others have said. Flow treats classes as nominally typed; Typescript only has structural types but nominal types can be faked with a bit of boilerplate. I think Typescript has better algebraic &amp; mapped types (which are awesome.) It also moves pretty quickly so things like variadic and possibly nominal types are on the way. The [Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap) might be a helpful reference.
This is a good and solid approach to express apps. We use something similar in out apps. You can further simplify it by using async/await and thus shorten your code quite a bit. I wouldn't necessarily say it will make you write less unit tests as tests are not a substitute to type safety (and otherwise) I would also suggest to take a look at https://github.com/nestjs/nest Which is a superset above express written in typescript. (I got no affiliation with nest.js, I just like it ☺️) 
I replied to your stack overflow post the best I could using my phone. I won't have access to a computer for another couple days, but hopefully it's enough to keep you going!
Dear TypeScripters, I recently gave a presentation at the San Francisco TypeScript meetup on [quicktype](https://quicktype.io/), a tool for generating static types from JSON, JSON Schema, and GraphQL. We've also recently released a [Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype) that lets you paste types from JSON. If you find it useful, or useless, please let us know - we love constructive feedback. Cheers! Mark
I usually use mapped types to pull this off: type RGB = "r" | "g" | "b"; type RGBMap = {[I in RGB]: string}; var rgbLabel: RGBMap = { r: "Red", g: "Green", b: "Blue" }; The compiler won't let you forget a string or add one that isn't part of the union. Works on enums too. 
Thanks! I had a look at Nest, but it seems to me that it's still based on the Express model where middlewares pass values down the chain by storing them in the Request object. I had a look also at the [pipes](https://docs.nestjs.com/pipes) stuff but it's not really a functional approach (i.e. transformers can throw exceptions). Sometimes a [simple and pragmatic approach](http://matteo.vaccari.name/blog/archives/1019) works best! 
The best way to do this is to have a function that takes a variable of type never (the body can be empty), and then call that function, passing in the variable you want to check, after you've handled every case. If you later add a case, the variable won't be type never any more, it'll be the type of the new case, so it'll cause a type error until you handle it. Search this page for assertNever: https://www.typescriptlang.org/docs/handbook/advanced-types.html. One of the most useful things I've learned about Typescript recently.
Yup. I mentioned that already, and I've used it before. I disagree with it being the "best" way, which is why I put effort into creating the string visitor. The assert never approach is a bit awkward and not immediately clear as to its purpose if you are not already familiar with it. Also, a switch or if/else chain that is missing the assert never does not look obviously different from one with the assert never, so it's easy to fall through the cracks in code reviews (either self review, or peer review when working on a team). Assert never can't help you at all when you forget to use it. I find it simpler to have a team rule to always use visitString(). Easy to instruct, and obvious in code reviews if it is not used.
Also, compare your `LiteralHandlerMap` type to the `StringVisitor` type I define in my code. Pretty similar, except I also support a generic return type, and the type of the param to each method is specifically the exact type being handled by that method, rather than the entire type union: Link to source on github: https://github.com/UselessPickles/ts-string-visitor/blob/master/src/StringVisitor.ts /** * Generic method signature for a string visitor handler method. * @template S - The type of the parameter to the handler. Must be a string literal, null, or undefined. * @template R - The return type of the handler. Defaults to void. * @param value - The value being visited by the visitor. * @returns A result to be returned by the visitor, */ export type StringVisitorHandler&lt;S extends string | null | undefined, R = void&gt; = (value: S) =&gt; R; /** * A visitor interface for visiting the value of a string literal type or a string enum type. * * @template S - A string literal type or string enum type. * @template R - The return type of the visitor methods. */ export type StringVisitor&lt;S extends string, R&gt; = { /** * Called when a visited string's value matches the name of the property. * @param value - The visited string's value. * @return Whatever you want. */ [P in S]: StringVisitorHandler&lt;P, R&gt;; }; 
I really disagree with your argument here. Your visitString method and associated dictionary are far more awkward and hard to read than any assertNever. It's just as easy to forget your thing as it is to forget assertNever because they both are used in some places that if statements are used, but not all, so it's not glaringly obvious that an if statement would need to use it just by virtue of it showing up in a code review. 
I usually hate the phrase, but “agree to disagree” :)
I was getting afraid nobody was doing this - thanks for that! Will try it out today and let you know on SO how it went. One other question: how do you figure these things out? So far I'm mostly trying to make do with looking at the type definitions and trying to figure out from that how they are meant to be used, as the documentation on them is really scarce...
You can also write: type RGBMap = Record&lt;RGB, string&gt;;
In your db.ts, try replacing `exports.connect = function(cb) =&gt; { ... }` with `export function connect(cb) =&gt; { ... }` Look here for an [js to ts introduction](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html) 
I did that and it works! Thanks, and I'll read that too!
AFAIK, all JS variables are initialized w/ `undefined` by default.
I think your tsconfig needs the `strict` or `strictNullChecks` option.
This was my bad -- strict was set and it was erroring out when tsc actually ran, but I guess vscode wasn't highlighting the lines as errors. Maybe I need to tsc:watch in vscode to have it highlight the lines as errors?
Looks like a really impressive bit of work mate! 
You can add a schema importer to make the table names and columns strongly timed as well. That's what [jOOQ](https://en.wikipedia.org/wiki/Java_Object_Oriented_Querying) in Java does
By my experienced VS Code does not notice changes to the `tsconfig.json` file. So when you change it (e.g. enabling `strict`) you should reload your VS Code. Simply use the `Reload Window` command or just close and open your VS Code.
Yup, good point! However, _actual_ isn't a property but an actual variable. We can assess that b/c it was declared using 1 of these 5 JS keywords: 1. var 2. let 3. const 4. function 5. class 
Yes, it doesn't import the schema. It does export the schema based on the table definitions by creating migrations though.
Not sure.. Its a bit of a tricky one..
I'm new to typescript and I've just finished reading 'Pro Typescript'. The author had a section on typings saying what I thought were some.good points. 1. Make sure it's worth your time. Will it actually help your work flow? 2. Do it iteratively - just do the top level stuff you are calling into and then go round again and add even more type info, using either your own code to inform type info or the libraries documentation. Do this until it stops being useful or there's no more to do. 3. If you think you've done something of use to others then put a PR into the Definitely Typed git repo
potsgres
How would this compare with knex (which has type definitions)?
There's actually a "restart ts server" command that is a bit more specific and doesn't break your flow.
This could be used as a great learning tool!
Knex with type definitions (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/knex/index.d.ts) basically gives you type safety on the function names and the types of their arguments. The name of the table of the columns are not checked. The rows are not typed. In Db, you create a class per table, which the type definition is derived from. When you construct a query, the table and columns are checked, plus, the return value of the query is type checked. But of course Db is still in development. :)
Hi u/pentafloppy, It depends on how your library is published and how you are importing it into your code. If your library is going to be part of the compilation, then you do not need the type definition as the type information is already included in each module you import. It would be the same as you writing another ts/tsx file If the library is imported as part of your node modules and the source code contains just the us files you need to d.ts file to give you the type definition for typescript to work. Alternatively, you could declare the module you are importing as ‘any’ and typescript will ignore the type information and try to work just like JavaScript would.
In my project I'd want to convert (right now it's in Flow) would have a library which is then directly incorporated into the dependant project, both would be written in TypeScript. So if I understand you correctly, I could just import it and it could compile from the get go?
I would strongly recommend to not publish the library as pure typescript, it's not a common pattern and you'll likely run into frustration. Number one is that your compilation settings for library and project will be unable to be set independently, and you might run in to trouble trying to update to a new typescript version. Instead, compile and publish the compiled library with `declaration: true` in tsconfig, and `main: compiled/file.js', `lib: compiled/file.d.ts' in package.json. This is definitely what you should do if publishing to npm at large, and good practice to follow even for internal projects.
`import {x} from 'lib'` might have advantages if you're doing [tree-shaking](https://webpack.js.org/guides/tree-shaking) but I'm not sure if that stops working with `import *`.
&gt; I don't suppose there's a way to make the factory function called Matrix(). i.e., there's no way to make the namespace a function? You can just merge it with a function as well, e.g. interface Matrix { x: string; } function Matrix() { console.log("a"); } namespace Matrix { export function create() { } } 
Check out a couple of my repos, in particular the package.json and tsconfig.json files: https://github.com/Dean177/with-url-state Or https://github.com/Dean177/create-reducer-extra Should give you a decent guide 
It all depends on how the library is written, but it is generally a good idea to be as specific and granular as possible with your imports if you are bundling with Webpack/Rollup.
if you're using bash, the shell will be expanding those globs, since this is how Unix handles globs. However, bash does not by default understand `**` globs. So your `./src/**/*.ts` will be treated like a `./src/*/*.ts`. Try `echo ./src/*/*.ts` and see what bash shows you. To enable `**` globs, you must enable "globstar" globbing. echo ./src/**/*.ts # fails shopt -s globstar # enable globstar recursive globbing echo ./src/**/*.ts # see if there's a difference http://www.linuxjournal.com/content/bash-extended-globbing https://unix.stackexchange.com/questions/49913/recursive-glob
I think for dead code elimination, you must tell TS to emit ES6 import / export syntax, letting a downstream tool like webpack or rollup handle the DCE, bundling, and transpilation. If I'm correct, `import *` is no worse than `import {}`.
I'm pretty sure it's purely a style choice. The ES6 import/export spec basically requires them both to behave the same way, performance-wise. If TS is transpiling to CommonJS or AMD, the emitted code for `import *` and `import {}` will look identical. Imports are always referred to via property access, even when using the `import {}` syntax. For example: import {Foo} from 'foo-lib'; import * as BarLib from 'bar-lib'; alert(Foo); alert(BarLib.Bar); ...transpiles into: var foo_lib_1 = require("foo-lib"); var BarLib = require("bar-lib"); alert(foo_lib_1.Foo); alert(BarLib.Bar); 
If you have namespace Foo { export const x = 1 export const y = 2 export function bar() {...} } export default Foo This can no longer be tree-shaken, right? Even if I only use: import Foo from 'foo' console.log(Foo.x) 
How would you rewrite your import statement to enable tree-shaking? The original question was about the performance downsides of `import *`. However, your example is only talking about a single ES6 export, which is a different kind of situation. Your example is effectively `export default {x: 1, y: 2, bar() {}};` These 3 are all equivalent: import Foo from 'foo'; console.log(Foo.x); import {default as Foo} from 'foo'; console.log(Foo.x); import * as fooLib from 'foo'; console.log(fooLib.default.x);
I’m working on a package to help with this! It’s called [create-typescript-package](http://github.com/ncphillips/create-typescript-package). The goal is to be able to develop and publish Typescript packages with zero build configuration. This projects pretty new, so if you check it out feel free to open an Issue or submit a PR if you run into any problems!
IMO, your example looks less convenient than the alternative. It gets simpler when you ditch the namespace and use regular, named exports. export const x = 1 export const y = 2 export function bar() {...} ...and then: import * as Foo from 'foo'; import {x} from 'foo'; For types, "overloading" with them never affects tree-shaking at all, because all types are removed by TypeScript compilation. Type-only code, including import statements, is removed by the compiler.
I was thinking of [a case like this](https://www.reddit.com/r/typescript/comments/7fd05g/typescript_naming_conventions/dqcckah/).
`export` statements must be static and top-level. This is an ES6 rule, not specifically a TS restriction. (when they're within a TS namespace, they have to be static and top-level within the namespace) export let now: () =&gt; number; if(someConditional) { let = /* function implementation here */; } else { // ... 
Yeah definitely, that's a good one. The initial example was something else, so I thought it was worth clarifying the difference.
Once we declare a variable w/ `let`, we can start accessing it right way. No need to initialize it 1st. It already contains `undefined` in it. Just open your browser console and copy &amp; paste the snippet below: ;-) void function() { "use strict"; let a; console.log('Variable "a" is: ' + a); a = 20; console.log('Variable "a" is: ' + a); }(); Only exception is `const`. This time, JS demands its initial value. :-P 
Oops, you're right, I was thinking of situations where the variable is accessed before its `let` statement has been encountered. E.g. `alert(a); let a;` I've updated my original comment; thanks for the correction.
That "temporal dead zone" explanation stuff merely makes the whole thing harder to understand IMO. An easier explanation should be just stating that keywords `let`, `const` and `class` now behave pretty much like all the rest of other regular programming languages: like C, Java, etc. Whether or not there is any "temporal dead zone" for those 3 variable declaration keywords should just be an internal implementation's detail. O_o 
That's my understanding... Just to be clear... You have a project called: `DarkSide`... this is going to be the library wrapping your logic. Then you have another project called `SomethingSomething` which is going to consume `DarkSide`... your project structure should be something like: SomethingSomething/ SomethingSomething/DarkSide SomethingSomething/tsconfig.json And your tsconfig.json should contain in the "include" section both `src` and `DarkSide` (or just adding the folder in it will do, I have tested this last one several times) 
No, I’d have a project called DarkSide which will be a node module of SomethingSomething and then imported/required in. Also, Family Guy reference?
[`Pick`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick) should do it: interface Mine { a: boolean; b: string; c: number; d: any[]; } type SuperMine = Pick&lt;Mine, "b" | "d"&gt;; // same as: // type SuperMine = { // b: string; // d: any[]; // }
In that case, when you compile the typescript project I think you need to tell it to generate the typescript definitions because node does not deal with typescript directly (although these files can be included) And yes
As an aside, I would highly recommend people checkout [create-react-app-typescript](https://github.com/wmonk/create-react-app-typescript)
Yeah, as novel as the post is this isn't scratching the surface of the complexities of using TS with React.
You *can* do submodule imports, but it results in imports relative to the package root. my-app-common/ models.js models.d.ts services.js services.d.ts package.json I find it annoying because I wind up with a project that has a bunch of *.d.ts and *.js files in my root directory. If the two can be easily separated, I'd suggest doing that. Note that you can use `tsc --traceResolution` to check where the compiler is looking for modules.
You will publish your library to npm **after** compilation. That is your responsibility as you cannot assume consumers of your library know/want to compile your library. So from a **runtime** perspective consumers will be using a plain JavaScript library and the fact it was written in TypeScript is irrelevant. For consumers that also use TypeScript and want to take advantage of Type Definitions you will need to export a d.ts file with your library definitions and point to that file in your library's package.json "types" field. See: * https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html Once your npm package includes both the d.ts definitions and the reference from the package.json. the TypeScript compiler used by consumers will automatically resolve the types during imports. 
Right, that makes sense. Thank you.
I don't know what ng2-packager is, but the import paths you want are supported by exporting those classes from files in your npm module. Either `/models/index.js` or `/models.js` where `/` is the directory containing `package.json`.
https://palantir.github.io/tslint/develop/custom-rules/
In the tsconfig for your library create a paths entry that points directly at your public api file.
Just write your library using TS but you should only ship compiled JS and, of course, typings. That's the best. 
It looks like it's an issue with the depth levels of generics. It seems to work fine if `track` is defined as `function track(x: Foo): Foo`. There're always places to improve inference, so maybe open one up on the TS repo and they'll take a look at it.
I don't quite have an answer for you, but here's what I can offer: Generics are stripped when you assign to `const promisifiedTrack` because the return type of `promisify` is not declared to be generic. When you invoke `promisify`, `Input` and `Output` are bound to `{}` for lack of a better type. (because the only way to bind them is to pass a value to `track`, but track isn't being invoked) So inference is finished even before you invoke the `promisifiedTrack` function. The simplest way around this is to declare a generic function signature for `promisifiedTrack` when it's assigned. const promisifiedTrack: &lt;T&gt;(x: T) =&gt; Promise&lt;T&gt; = promisify(track); This accomplishes the same thing as your `promisifiedTrackFixed`. Here's one possible reason this situation is not supported. Consider the following declaration of `track` using function overloading: function track(x: number): string; function track(x: Window): boolean; How should `promisify` bind the `Input` and `Output` generic parameters? If you know you're going to promisify functions that return the same type as their argument (a.la `track`) you can do this: function promisify&lt;Fn extends &lt;T&gt;(i: T) =&gt; T&gt;( fun: Fn ) { return &lt;T&gt;(i: T) =&gt; Promise.resolve(fun(i)); } const promisifiedTrack = promisify(track); promisifiedTrack(new Foo()).then(x =&gt; x.bar());
`(Pick&lt;A, 'a'&gt; | Pick&lt;B, 'a'&gt;) &amp; Pick&lt;A, 'prop' | 'anotherProp'&gt;`? Or some sort of `Diff&lt;A, 'a'&gt;` instead of the pick-all-but-a, but I don't remember the Diff syntax in TypeScript.
This is cool!
Don't even bother. Keep your frontend code outside of VS, and use vscode for it instead. You'll have a much better time.
Thanks!
There isn't one but you can use `Dissoc` from this package https://www.npmjs.com/package/subtractiontype.ts
Doesn't really have much to do with inheritance. You can slice and dice your data in many ways in JS.
Touche
You could enable the "allow js" option for now, so it will not complain about files that are not in Typescript yet.
Even with those errors, it is still transpiling and emitting .js files. Does that work for you?
Wow I actually did not realize that the files were being output! I'm testing it right now. Thanks for this.
Yeah! It's pretty great. In personal projects, I let some type warnings stick around if it's not gonna give me a productivity boost to fix them. I never look at the compiler output directly; I look at the red squiggles in my editor. So if I have type warnings in a file that's already working well and hasn't been touched in months, I don't have much reason to fix them.
&gt; When you invoke `promisify`, `Input` and `Output` are bound to `{}` for lack of a better type. (because the only way to bind them is to pass a value to `track`, but track isn't being invoked) So inference is finished even before you invoke the `promisifiedTrack` function. My point is, when you write something like this: const identity = &lt;T&gt;(i: T): T =&gt; i; const anotherTrack = identity(track); typescript is able to infer type. 
Yeah, no disagreement there. I was just trying to explain why your more complex inference case is really hairy, and potentially why it might seem straightforward in your example but actually get too tricky and ambiguous in other situations. I'm trying to speculate why the TS team might not have implemented it. In your `identity` example, the type of `T` merely needs to be copied verbatim to `anotherTrack`. It doesn't need to be "unpacked." In the `promisify` example, `Input` and `Output` need to be "unpacked" from the type of `track`. Due to function overloading, argument and return types of functions can have really complicated relationships. E.g. if one is a number, the other must be a string, but if one is a boolean, then the other must match a complicated interface. Describing those relationships via two types, `Input` and `Output`, isn't possible. Not even union or intersection types can properly describe those relationships. Flow doesn't seem to support the same flavor of function overloading as TS. Maybe that's related?
- Since you're exporting a default, the correct syntax to import it would be `import template from '...'`, without `* as`. Look up more details on ES6 modules for why this is the case. - Instead of specifying the template as a type you'll want to pass it as a value instead. - The decorator is missing. From the looks of it, since you're giving an `el` property here, it looks like this is supposed to be the root instance of the app. The `@Component` decorator is only available for Vue components, and can't be used to create instances. I might be wrong on that, but you should probably go with a normal instance anyway to save the trouble. With that in mind, here's what the working code should look like: import Vue from 'vue' import template from '../Detail/detail.html!text' new Vue({ el: '#app', template, }) 
as any all the things. That sounds rough man good luck!
Cannot find name `Template` because you're using the identifier as a type, but you imported a value. Did you mean to say `template = Template;` instead of `template: Template`?
[removed]
Yea I think I left the @component piece in there from a copy and paste. I'm not using SPA in my app, so was going to build an individual app for each page. But I think ill make the views compontents and then just have a simple app on each page that loads the component for future proofing.
&gt; Fixed Length Tuples Can we use the spread operator with tuples to use the values as function arguments with this change?
It doesn't look like this is possible yet. That is a different feature, but it may be made simpler with this work
It's all about type narrowing. If you're not aware of that, I'd look it up in the typescript docs. It's an insanely useful feature. Basically, class types are now narrowed based on inheritance relationships instead of structure, which is more logical.
Do us a favor and post a more complete code example, preferably with a link to the TypeScript playground. For example, you omitted your declaration of `myObject` and `CONSTANTS`, so please include them. They affect the answer. Our response will make a lot more sense based off of a complete example. Thanks!
What's the difference between using 'undefined | boolean' vs 'boolean?' ? 
[removed]
by using boolean? you are telling typescript that the value is indeed a boolean and not a boolean or undefined. At runtime the value might be undefined though, thats why you should use ? only if you are sure about that.
&gt; I don't know the term for doing this, which makes googling my solution difficult. it's called narrowing the type, there are a few mentions of it [here](https://www.typescriptlang.org/docs/handbook/advanced-types.html) &gt; I assume because it thinks `CONSTANTS` is mutable, but freezing it doesn't help either. that's probably it, and passing it through `Object.freeze` doesn't work since the type is already something like `string` instead of the literal type like `"one"` and it can't get it back i can think of some solutions: 1. create a namespace for the constants namespace CONSTANTS { export const ONE = "one"; } this preserves the literal type and works just like an object 2. create a module for the constants with exports like `export const ONE = "one";`, then use `import * as CONSTANTS from "./thatmodule";` easier if you're already using modules 3. create an `interface` or `type` with the literal types of the constants, then use it when declaring `CONSTANTS` as a normal object (maybe combine with `readonly`/`Readonly&lt;T&gt;`/`Object.freeze`) would have to repeat stuff so maybe this isn't ideal
I was hoping I wouldn't have to define everything twice. Doing `EQUALS: '=' as '='` resolves the issue, but it's ugly and redundant. I may do the module thing to prevent that.
the namespace solution also doesn't require repeating them and it works without modules
Does it not have to be defined in the namespace and as you create the object? Or does making a namespace also make the object? I've not used namespaces before.
I love the narrowing change, if I understand it correctly. Recently worked on a project with API that sends a ton of conditional fields based on a type field (e.g. fields 1, 2, 3 for type A, fields 1 2, 4, 5 for type B and so on). It was initially a mess with tons of checks for property existence everywhere, so I started refactoring it to concrete types without any conditionals like interface Item { field1: string ... } interface ItemA extends Item { type: 'A' field2: number ... } type ItemAny = ItemA | ItemB | ... I imagined I could then just check for the `type` field value on `ItemAny` and TS could figure out the specific type with appropriate fields, but no such luck and I end up just doing `as ItemB` manually after each check. With this change, it should just work, right?
Make `OPERATORS` an enum. Enums are both types and values. enum OPERATORS { EQUALS = '=', NOT_EQUALS = '!=' } [TypeScript playground](https://www.typescriptlang.org/play/#src=enum%20OPERATORS%20%7B%0D%0A%20%20%20%20EQUALS%20%3D%20'%3D'%2C%0D%0A%20%20%20%20NOT_EQUALS%20%3D%20'!%3D'%0D%0A%7D%0D%0A%0D%0Ainterface%20Thing1%20%7B%0D%0A%20%20%20%20operator%3A%20'%3D'%2C%0D%0A%20%20%20%20value%3A%20number%0D%0A%7D%0D%0A%0D%0Ainterface%20Thing2%20%7B%0D%0A%20%20%20%20operator%3A%20'!%3D'%2C%0D%0A%20%20%20%20value%3A%20string%0D%0A%7D%0D%0A%0D%0Alet%20myObject%3A%20Thing1%20%7C%20Thing2%3B%0D%0A%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'%3D'%2C%20value%3A%202%20%7D%3B%20%2F%2F%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'%3D'%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20Not%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'!%3D'%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'!%3D'%2C%20value%3A%202%20%7D%3B%20%2F%2F%20Not%20Okay%0D%0A%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.EQUALS%2C%20value%3A%202%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.EQUALS%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Not%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.NOT_EQUALS%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.NOT_EQUALS%2C%20value%3A%202%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Not%20Okay%0D%0A)
You can do pretty much exactly that already since TypeScript 2.0. https://www.typescriptlang.org/play/#src=interface%20Item%20%7B%0D%0A%20%20base%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20ItemA%20extends%20Item%20%7B%0D%0A%20%20kind%3A%20'A'%3B%0D%0A%20%20fieldOnA%3A%20number%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20ItemB%20extends%20Item%20%7B%0D%0A%20%20kind%3A%20'B'%3B%0D%0A%20%20fieldOnB%3A%20boolean%3B%0D%0A%7D%0D%0A%0D%0Atype%20ItemAny%20%3D%20ItemA%20%7C%20ItemB%3B%0D%0A%0D%0Afunction%20getItem()%3A%20ItemAny%20%7B%0D%0A%20%20%20%20return%20Math.random()%20%3E%200.5%0D%0A%20%20%20%20%20%20%20%20%3F%20%7B%20kind%3A%20'A'%2C%20base%3A%20'hello'%2C%20fieldOnA%3A%205%20%7D%0D%0A%20%20%20%20%20%20%20%20%3A%20%7B%20kind%3A%20'B'%2C%20base%3A%20'fubar'%2C%20fieldOnB%3A%20true%20%7D%3B%0D%0A%7D%0D%0A%0D%0Aconst%20value%3A%20ItemAny%20%3D%20getItem()%3B%0D%0A%0D%0Aif%20(value.kind%20%3D%3D%3D%20'A')%20%7B%0D%0A%20%20%20%20console.log(value.fieldOnA)%3B%0D%0A%7D%20else%20if%20(value.kind%20%3D%3D%3D%20'B')%20%7B%0D%0A%20%20%20%20console.log(value.fieldOnB)%3B%0D%0A%7D%0D%0A
[How about this](https://www.typescriptlang.org/play/#src=interface%20Operators%20%7B%0D%0A%20%20%20%20EQUALS%3A%20'%3D'%3B%0D%0A%20%20%20%20NOT_EQUALS%3A%20'!%3D'%3B%0D%0A%7D%0D%0A%0D%0Aconst%20OPERATORS%3A%20Operators%20%3D%20%7B%0D%0A%20%20%20%20EQUALS%3A%20'%3D'%2C%0D%0A%20%20%20%20NOT_EQUALS%3A%20'!%3D'%0D%0A%7D%3B%0D%0A%0D%0Ainterface%20Thing1%20%7B%0D%0A%20%20%20%20readonly%20operator%3A%20'%3D'%2C%0D%0A%20%20%20%20value%3A%20number%0D%0A%7D%0D%0A%0D%0Ainterface%20Thing2%20%7B%0D%0A%20%20%20%20readonly%20operator%3A%20'!%3D'%2C%0D%0A%20%20%20%20value%3A%20string%0D%0A%7D%0D%0A%0D%0Alet%20myObject%3A%20Thing1%20%7C%20Thing2%3B%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'%3D'%2C%20value%3A%202%20%7D%3B%20%2F%2F%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'%3D'%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20Not%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'!%3D'%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'!%3D'%2C%20value%3A%202%20%7D%3B%20%2F%2F%20Not%20Okay%0D%0A%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.EQUALS%2C%20value%3A%202%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.EQUALS%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Not%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.NOT_EQUALS%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.NOT_EQUALS%2C%20value%3A%202%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Not%20Okay%0D%0A) with an additional interface and using readonly.
I think that would be a part of [Variadic Types](https://github.com/Microsoft/TypeScript/issues/5453) which has been in the "Future" section of the [Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap) forever
There are 20 questions but the answers seem to only go up to Q12? Also i think some of the expected answers are a bit questionable: &gt; Q1. What is Typescript? How is it different from javascript? &gt; A: JavaScript is an scripting language whereas Typescript is an object oriented language. You can do OOP in JavaScript, you can do scripting in TypeScript. They have almost the same capabilities (outside of syntactic sugars, type constraints) because they both run in the same way. &gt; JavaScript has no optional parameter feature while Typescript has optional parameter feature. function parameters(optional) { console.log(`optional ${arguments.length &gt; 0 ? "was" : "wasn't" } provided`); } parameters(); // optional wasn't provided parameters("hello"); // optional was provided 
Seems like the interviewer suffered a stroke during the interview : &gt; How to compile a Typescript file? Easy, answers... &gt; What do you understand by classes in Typescript? List some features of classes. Answers question &gt; Is Native Javascript supports modules? That question doesn't make sense &gt;How to compile a Typescript file? I just told you &gt;Explain Classes in Typescript? List some features of Classes? Sir, are you ok ?
Well obviously these questions are no good, but what are your favorite TypeScript interview questions? If someone says they are familiar with TypeScript, I always like to ask, "What is one thing you would change about TypeScript?" (or a variant thereof: "feature you would add", "criticism you have", etc.)
Some of this is okay, but there is a lot incorrect about it and is pretty misleading.
These types of questions are excellent for mid to senior level. When you really start understanding something is when you start thinking about changing the system. When you're learning you often take the system for what it is and don't question it because you don't understand it yet.
`await` takes a `Promise`, but you pass a `Subscription` (result of `subscribe()`) which is transformed into a already resolved promise. This should work better: ``` let returnVal: Feed = await this.http.get(url) .map(res =&gt; res.json()) .toPromise(); ``` together with `try` `catch` for the rejected case.
Just stop using async/await. Tbh, RxJS is way better once you learn it. Async/await is a procedural style syntax sugar and brings back memories of Turbo Pascal...
If you care about code quality, you type check JavaScript.
I'm already using Observables and are fairly comfortable with them. the problem i'm running into and trying to solve using little code is how to run synchronous observables. do this; now do this; then do that; so if i run the following, assuming that all functions are formed as my response to 21October16, how do i make sure they all run properly? let userId = getUserId(); let products = getUserProducts(userId); let details = new Details( getProductDetails(products));
Hi , Thanks for your valuable feedback on Typescript Interview Questions. Please Let me know the Consolidated Changes so I can make. Also If you have more questions please share. Thanks Once again For reading.
I'm from the phone, so bear with me. Your async methods should return Observable. For example: ```function getUserId() { return http.get('someurl'); // returns Observable }``` And then you chain them: ```getUserId() .flatMap(userId =&gt; getUserProducts(userId)) .flatMap(products =&gt; getProductsDetails(products)) .subscribe(details =&gt; this.details = new Details(details));```
Some formatting help: getUserId() .flatMap(userId =&gt; getUserProducts(userId)) .flatMap(products =&gt; getProductsDetails(products)) .subscribe(details =&gt; this.details = new Details(details)); Bonus points for pointfree :D getUserId() .flatMap(getUserProducts) .flatMap(getProductsDetails) .subscribe(details =&gt; this.details = new Details(details)); Also just a heads up, you'll often see `mergeMap` instead of `flatMap` in examples--they are aliases for each other. 
Since TypeScript grew to encompass basically every feature of Flow, there is now the question of how finished and reliable they are as products, and TypeScript wins easily. Much bigger ecosystem and community too.
&gt; Use inference where possible so you don’t have to maintain a lot of type-specific code. In my experience, this is an area that Flow shines in – you don’t need much type code for it to infer almost everything. Would it be reasonable to say that when you rely on inference, you're still maintaining type-specific code, but instead of the specification being explicit it is now implicit in the inferred types. If the inference engine changes and gives you different types you still have to deal with the potential fallout from that. I can't speak for Flow, but I also find error messages in TS come out much cleaner when the program has explicit type annotations.
I didn’t have a great experience when trying to use TypeScript with Sequelize in the past. I seem to remember a lack of genetics to define models. Is this new, was I doing something wrong, or am I just remembering it wrong? What about things like associations? Are the typings strong?
Oh no, you found a bug in Deep Thought!
&gt; db.sync().then(() =&gt; { ... }); This confuses me.
`db.sync()` returns a promise that resolves when the database is ready.
A promise... So it's not sync. That is what confuses me. Why name it sync when it's clearly not sync?
It stands for "synchronize" because it synchronizes your ORM models with the DB's tables. It doesn't mean "synchronous".
I see, thank you. That is some very unfortunate naming.
The conclusion felt like an ad for Reason, more than the conclusion of a comparison.
Isn’t that only marking one instance of Props as readonly? I wouldn’t call that a readonly interface, as it isn’t tied to the interface. You’d have to remember to do that each time you create a new instance of Props. 
Fair point. You just as easily do: ``` interface Props extends Readonly&lt;{ firstName: string lastName: string }&gt; ```
I'll update my post accordingly.
With noImplicitAny I get the following behavior: let x x = 1 x = 'c' let y: number = x // Type 'string' is not assignable to type 'number'. let z: string = x // This is fine. This seems correct to me
&gt; Use inference where possible so you don’t have to maintain a lot of type-specific code. If you use inference "wherever possible", you lose the advantages of having a type system in the first place. You should only use inference when it doesn't cost you type safety. For instance, you can leave the return value off a function/method definition and let Typescript infer it, but now the compiler can't tell you if you fuck up and accidentally return an unintended type. For example: function supposedToReturnAString(value: number) { // bunch of code return value.toString(); // bunch of code // oops, left off parentheses here, so we're return a function, // which is perfectly legal since we didn't tell the compiler this // function should return string return value.toString } Most code *is* type-specific and should be annotated accordingly.
This is a contrived example with two properties. In the real world, interfaces often grow to 10+ props and this is where this method really shines. 
If it is a function prop or class prop, `boolean?` means it's possible to leave it blank. `undefined | boolean` expects a value.
As you probably came to realize, it was because of how you were exporting the value. In the first example, you are setting the entire module's export value to the value of the config. In the second example, you are exporting the value of the config under the *named* export `config`. In order to be able to use `import * as config from './config'`, you can only do it the first way. If you want to be able to export and declare the config on the same line, you can either do it using the second example, which would require `import { config } from './config'`; or you can export the value as default, as in `export default const config = ...`, and import it as in `import config from './config'`.
I just put a beta on npm for the v2 release of trilogy, which is now written in TypeScript. trilogy is a simple &amp; extensible library for dealing with a SQLite database. It's not an ORM and it won't become one since no relationship features are going to be added. A killer feature is equal support for native `sqlite3` and pure-JS `sql.js` as the backend. This release is a pretty big code change so before the final release there are 2 things I'm hoping to get feedback on or contributions for: the use of TypeScript and the newly added plugin system. This is my first project in TS and it's been great so far. The code for this release is currently on the [next branch](https://github.com/citycide/trilogy/tree/next) and there's an [issue](https://github.com/citycide/trilogy/issues/81) and a [PR](https://github.com/citycide/trilogy/pull/82) open for discussion &amp; reviews. If you want to try it you can do: npm i trilogy@next Thanks!
`true | false` vs `true | false | undefined`. I think that all types are permitted to be `undefined` unless you enable strict null checks.
I'm abit confused on what you mean in point 2. Do you mean that you want to be able to give T (the input type to the function) some constraint to stop users supplying something that isn't an object with fields? Do the fields have to be the same type? Could you give an example of a program you want to reject because it is not 'correct' in some sense? You can put a constraint on type T, but I'm not sure that's what you want: type PropKeysBoolean&lt;T&gt; = {[K in keyof T]:boolean}; interface Dict { [key: string]: string } function ObjectFromPropKeysFactory&lt;T extends Dict&gt;(obType: T) { let objectWithPropKeys = Object.getOwnPropertyNames(obType).reduce((acc,curr)=&gt;{ acc[curr] = true; return acc; }, {}); return (objectWithPropKeys as PropKeysBoolean&lt;T&gt;); } let objectFromInterfaceWithIndexType = { a: 'a', b: 'b', c: 'c' } let objectWithKeysFromInterface = ObjectFromPropKeysFactory(objectFromInterfaceWithIndexType); 
&gt;Do you mean that you want to be able to give T (the input type to the function) some constraint to stop users supplying something that isn't an object with fields? No, the issue is the **actual** property names don't propagate from the input object to the output object when using an indexed field: { [propName: string]: any } Whatever names were used for the properties on the input will be lost on the output when using an indexed property like that. All I want is for typescript to preserve the names, with auto completion and all that good stuff. I'm not having trouble making the input conform to the correct shape. And I'm not having trouble making the output correct in memory either. *The only issue* is that using an indexed property masks the actual prop names from the typescript language service such that inputing an indexed property type results in output that typescript doesnt know what any of the property names are. In the first example after the call to the factory if I type: objectWithKeysFromEnum. Then I will get auto completion for the fields key1, key2, key3. After the second example if I type: objectWithKeysFromI. I will get auto completion for k, d, and c. After the third example if I type objectWithKeysFromInterface. I don't get any auto completion. Typescript doesn't know that it has the fields a, b, and c. The only way to access them that satisfies typescript is by using string indexing notation like objectWithKeysFromInterface['a'] And that's unacceptable for my use case. I need the language service to understand that objectWithKeysFromInterface contains a, b, and c but I also want to provide a type for the input object. That's all I'm trying to achieve.
&gt; I need the language service to understand that objectWithKeysFromInterface contains a, b, and c but I also want to provide a type for the input object When you say *a type*, do you mean that it *must* be explicitly Dict? If so then I'm afraid I don't know of a way to achieve what you want because the indexer will mask the keys on the inferred type I think. Is it not acceptable for your use case to just use the inferred type for objectFromInterfaceWithIndexType, or to give it some interface type, or something Record&lt;"a" | "b" | "c", string&gt;? 
&gt;Is it not acceptable for your use case to just use the inferred type for objectFromInterfaceWithIndexType What type would I infer it to? Give me an example. I'm game for whatever. &gt;or to give it some interface type Again I don't know what the property names will be. So what type would I give it? &gt;or something like Record&lt;"a" | "b" | "c", string&gt;? That is the wrong direction and a nonstarter for my use case.
The type of dictionary isn't just string. Its am object that is used by the factory to actually create the values it's return has on the props. The dynamism isn't coming from an external source in the form of outside the code. But it is coming from some other developer using this library to feed an input in the correct shape (confirming to the dictionary) and receiving an object back out that mirrors the props but the values of the props in the output are constructed from the values of the inputs props. And a large impetus here is to cut down on boiler plate as much as possible. Not shift it around. But thanks anyway.
Here's the solution. Try it out and let me know if it works or if anything is confusing. // Implementation omitted because it's not relevant to explanation // Use generics. This says "T must be Dict or a subtype of Dict" function ObjectFromPropKeysFactory&lt;T extends Dict&gt;(obType: T): PropKeysBoolean&lt;T&gt; { // implementation omitted } // Do not annotate as Dict. Doing so would strip all type information and replace it with Dict. let objectFromInterfaceWithIndexType = { a: 'a', b: 'b', c: 'c' } let objectWithKeysFromInterface = ObjectFromPropKeysFactory(objectFromInterfaceWithIndexType); // Type information preserved. If argument does not conform to requirements, above line will show a type error By declaring the type of `objectFromInterfaceWithIndexType` as `Dict`, you are stripping all inferred type information from that object. Even though the compiler can infer it as an object with three properties a b and c, you've explicitly overridden that inference with `Dict`. Also, `ObjectFromPropKeysFactory` is not enforcing the `Dict` type restriction for its argument. Functions are usually declared with types for their arguments. Since you're using generics, you must use `T extends Dict` to apply a type constraint to your argument via `T`. If you still *really* want to enforce the right type at the variable's declaration site, there are ways to do that, but it's a weird choice since the function can and should do the same enforcement.
Nice! This looks like it gives us similar type resolution behavior to overloaded functions, since they do the same "If argument types match this signature, then return type is this, otherwise try one or more other overloads."
Besides it not supporting nested objects, it also does not support arrays. You still have to remember to use `ReadonlyArray&lt;&gt;` instead of arrays. The `Readonly&lt;T&gt;` is a poor half-thought solution.
This is a game changer. It's awesome to finally see typescript implement some advanced functionality like this. Combining this with mapped types, the possibilities are innumerable.
This will finally allow `DeepReadonly&lt;T&gt;`! Can't wait for.. I guess TypeScript 2.8.
I don't understand the following: &gt; type BoxedValue&lt;T&gt; = { value: T }; &gt; type BoxedArray&lt;T&gt; = { array: T[] }; &gt; type Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;; &gt; &gt; type T20 = Boxed&lt;string&gt;; // BoxedValue&lt;string&gt;; &gt; type T21 = Boxed&lt;number[]&gt;; // BoxedArray&lt;number&gt;; &gt; type T22 = Boxed&lt;string | number[]&gt;; // BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;; &gt; &gt;Notice that `T` has the additional constraint `any[]` within the true branch of `Boxed&lt;T&gt;` and it is therefore possible to refer to the element type of the array as `T[number]`. Also, notice how the conditional type is distributed over the union type in the last example. In the `Boxed` type definition, in the true path its defined as `BoxedArray&lt;T[number]&gt;`, what does the `number` part mean? I see that Mr. Hejlsberg is trying to explain it but I don't understand the explanation (perhaps I'm missing some prerequisite). 
It likely means that the type `T` has an indexer accepting an argument of type `number`. This is the case for arrays, you can do `myArray[0]`.
If `T` is indexable by a number (because it's an array, a tuple, or has a numerical indexer) then `T[number]` will return the type you get from indexing into that type at any possible given position. E.g. type T = string[] T[number] = string; type T2 = [boolean,string] T2[number] = boolean | string type T3 = {[i: number]: number[]} T3[number] = number[]
I don't see how marking individual props `readonly`is any better. Readonly for nested objects must be done manually. ``` interface Props { readonly bar: string readonly baz: { readonly foo: number readonly hen: string } } ```
The next TypeScript version (likely 2.8) will support a true `DeepReadonly&lt;T&gt;` type that will make all nested properties readonly, and make all arrays `ReadonlyArray&lt;T&gt;`.
I agree with you. But I also think there are a large number of devs that don't yet type check JS. This article was my attempt at easing those on the fence to give it a try.
Yeah, you're right - that is reasonable to say. I think there are pros and cons both ways. It also depends on the tool. My article is primarily for those new to type checking in JS so I think for them it makes sense to rely on inference at first and then add more types as you get more comfortable with it. To me, having type checking set up with inference is better than nothing, but adding explicit types is better than relying on inference in many cases.
In my mind, "wherever possible" and "only use inference when it doesn't cost you type safety" is the same; but your wording is more clear so I'll update the article to that. This does depend on the tool. With Flow, for example, you can go a long ways with inference and if Flow can't infer something with type safety, it won't type check until you add explicit types. My article is primarily for those new to type checking in JS so I think for them it makes sense to rely on inference at first and then add more types as you get more comfortable with it. To me, having type checking set up with inference is better than nothing, but adding explicit types is better than relying on inference in many cases. Anyways, thanks for reading!
Ohhhh. Neat. How do you know this?
A lot of these seem fairly obvious to me, but I think they're worth stating anyway. One point I disagree with is on "trivial" selectors. If you end up changing your state shape, it can be a lot less tedious to refactor a few selectors than to refactor every reference to that part of the state. Having selectors also makes it a lot easier to introduce a library like reselect (or some other strategy for memoizing state access).
The official docs are very good and will provide you with almost everything you need. Beyond that, there's also an excellent [GitBook](https://basarat.gitbooks.io/typescript/content/) and a [guide](https://github.com/piotrwitek/react-redux-typescript-guide) for React + Redux developers.
Thanks for reading! That's a fair point on the selectors. My experience so far has been that they aren't very useful and thus have been just additional boilerplate to write, but the advantages you mention are totally valid.
Thanks! that's what I'm looking for. Just a question, since you mention react, is there a specific reason to choose this framework to be used in typescript instead of others ?
You can `const _throwaway: Dict = objectFromInterfaceWithIndexType;` immediately after the variable declaration. That line will be eliminated as dead code by any decent VM or minifier, and it'll assert to TS that the variable matches a type. In type system terminology I think you're confirming "assignability." You can alternatively declare a `function noop&lt;T&gt;(a: T) {}` and then `noop&lt;Dict&gt;(objectFromInterfaceWithIndexType);` If you want to combine it all into a single variable declaration statement, the only trick I know is to abuse generics. You want the same behavior as generics: let inference determine the variable's type, but assert that it must be a subtype of something. The problem is you need to pass one generic explicitly (`Dict`) and let inference control the other. Explicitly passing generic params is all-or-nothing, so you have to split it over 2 function calls. function assertType&lt;T&gt;() {return function&lt;U extends T&gt;(a: U) {return a}} const objectFromInterfaceWithIndexType = assertType&lt;Dict&gt;()({ a: 'a', // ... Rest of object The extra parentheses and code are annoying, but a JIT VM should inline the functions as noops, and you'll get the right typechecking. I keep a collection of little helpers like that one, so I never have to rewrite them. Just copy a single helpers.ts into new projects. The language service will write the import statements when you need them. I wrote this on my phone so lemme know if I messed anything up.
Ditto the "TypeScript Deep Dive" recommendation.
It is on the [2.8 roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap#28-march-2018) so hopefully makes it in!
I can't wait so long!
In my humble opinion, angular, Aurelia and react offer similar tools for you to build your software. The positive of react is that you end up with pretty clean code once you know how to use it. React native web would be a better choice in that case because it allows you to target mobile later on if you choose so. All of them are pretty good and it depends on your experience 
Here are a couple of starter projects out in the wild already. https://github.com/Microsoft/TypeScript-React-Starter https://github.com/parcel-bundler/parcel I'm hoping to find some time to create an example repo to illustrate the concepts in the article, along with examples with selectors and sagas. Stay tuned!
Sounds like a string index. interface IntermediateStructure { /** Key is JSON.stringify-ed participants array; value is array of location strings */ [stringifiedJson: string]: Array&lt;string&gt;; } I know this is not your question, but if you want some pointers on implementing TypeScript piecemeal, I'm happy to help. Since TypeScript errors never prevent or affect transpilation, you can actually rename your entire codebase from .js to .ts and everything will still compile the same. Even with type errors, compilation will give you the same .js. It seems to me that starting in TypeScript will save you effort in the long run and should be great for prototyping as well.
With "noImplicitAny" set to false, TS can import those JS drivers without any additional configuration. Unless I'm misunderstanding the issue? Also, did my answer solve your typing problem?
Ok cool, lemme know if it does the trick and if noImplicitAny solves your third-party module issues.
Can’t you just a use a Map&lt;string, Array&gt;?
That's what I was suggesting. And if you turn off noImplicitAny, they'll be automatically declared as `any` with no additional code.
Are the sessions being recorded?
Looks like the compiler exposes diagnostics via separate methods `getSyntacticDiagnostics` and `getSemanticDiagnostics`, so this should be possible. The tools I've looked at so far -- ts-loader, awesome-typescript-loader, and fork-ts-checker-webpack-plugin -- lump all diagnostics together, but it looks straightforward to send them PRs for the option I'd need.
I just released a new version of ts-string-visitor that adds a new feature to simplify situations like this where you're just trying to map to a value without performing any logic: type RGB = "r" | "g" | "b"; const value: RGB = "r"; const rgbLabel = mapString(value).with({ r: "Red", g: "Green", b: "Blue" });
I'd absolutely favor a explicit declaration of `any` for the modules over turning off `noImplicitAny` for the whole application.
I agree, but I wanted to suggest the easiest solution for OP while he's in the early prototyping phase.
Use an interface instead of object type, implement it and let the constructor do the binding for you. interface ModelOptions { tableName: string; columns: string[]; objectStructure: ObjectStructure; addJoins: (query: QueryBuilder) =&gt; QueryBuilder; } export class Model implements ModelOptions { tableName: ModelOptions['tableName']; columns: ModelOptions['columns']; objectStructure: ModelOptions['objectStructure']; addJoins: ModelOptions['addJoins']; constructor(readonly options: ModelOptions) {} } https://www.typescriptlang.org/docs/handbook/interfaces.html
Yeah... this is a pain point for me, too. If you want them to be private, I don't have a good solution. But it looks like you're ok with public properties. You can append the `class Foo {}` declaration with a `interface Foo extends FooOptions {}`. That'll copy all options onto the class as public members, so you only need to declare them in the options interface, not on the class. You can `Object.assign(this, options)` in the constructor. Maybe Object.assign isn't good enough, for example if you want to whitelist the options. Decorators to the rescue! // Put this in a helpers file somewhere const owm = new WeakMap(); function Opt(target, propName) { const a = owm.get(target) || []; owm.set(target, a); a.push(propName); } function setOptions(instance, opts) { for (let propName of owm.get(Object.getPrototypeOf(instance))) { if (opts[propName] !== undefined) instance[propName] = opts[propName]; } } // And write your class like this: import { Opt as O, setOptions } from './my-helpers'; class BarOptions { @O bar: string; @O baz: string; } interface Bar extends BarOptions {} class Bar { constructor(opts: Readonly&lt;BarOptions&gt;) { setOptions(BarOptions, opts); } } 
OFFTOPIC: what's your color scheme? 
I realize there are sometimes a need for classes, but can you not do with just using the interface? Can you describe what aspect of being a class it is you need? In the above example, a valid `ModelOptions` has nearly the same properties as the resulting class.
For personal projects, I would even stick with the class, ditch the interface, and say `type ModelOptions = Partial&lt;Model&gt;;` You'll see public method names in the auto complete, but if I'm trying to prototype rapidly I don't care that much.
Just be sure to **not** spread-merge a partial and a full object. That way you end up with `undefined` values even if your full interface does not allow it.
Pretty sure that only happens if you have defined keys that are set to the value `undefined`. I feel like that's a really rare pattern.
Looks like Atom One Dark
Are you after a `constructor(private foo: Bar)` style thing for objects?
Maybe a mix of `constructor(private foo)` syntax and object spreads could help?
I'd do this myself, and this is a friend's code. I'm assuming there are gonna be more methods and such on the class. Should have been clearer on that, so my bad
This one is probably what I'd end up going with. Looks clean
Material I believe. Not 100% sure since it's from a friend's editor.
You haven't lost the advantages, but they will manifest them in a different way or be weakened. Building on your example, let's assume you have a 2nd function that takes a string: function takesString(str: String) { ... } Now if you try to call that method with a value from your method: const str = supposedToReturnAString(5); takesString(str); the error will manifest itself in the call to takesString instead of in supposedToReturnAString. It does mean the error won't point directly to the problem in your code. And there is the possibility that if the only way you use that value never gets typechecked again (only passed to untyped JS code, only passed to a method that takes an Any). But that is I wonder if a compiler option could be added to warn/error about inferring union types.
Awesome!
Just be aware that the instance is shared with the calling context. Either make it read only or duplicate it.
I'm afraid I don't have an answer as to *why* it does this, but I believe it is to do with type parameters bounded by union types. Here is a similar problem that doesn't involve indexer signatures: [issue](https://github.com/Microsoft/TypeScript/issues/13995). In the example you give you can probably just give `key` the type `DictKey`, I don't know if there is much to be gained by using a parameter (but you may need it for other reasons).
I don't think there is a simple solution to your problem such that you can use those tools to turn your .js into .ts. What if you just move forward with exclusively typescript and keep your old repos .js? Those projects will still benefit from intellisense of the newer projects. Vice versa, you can just write a library of `.d.ts` files as the intermediary. The `.d.ts` files will include all the interfaces, return types, etc. of your old es6. Thatway you can still use your old libraries w/ intellisense and types without refactoring. This solution is also nice because it's incremental– devs can just add the d.ts files as needed.
https://github.com/Microsoft/TypeScript/issues/8335
I created this extension last month, and it has been way more useful than I thought it would be. I figured it could be nice while refactoring code, but it turns out that everyday tasks like copying and pasting a parameter from one file to another happens a lot. I used to paste, wait for the yellow light bulb to show up, click on it and select the correct import. Now when I paste it automatically adds the correct import based on the location I copied it from.
Sorry, maybe Im wording my problem wrong (people on Twitter had the same initial response, so I'm definitely in need of polishing my writing act). My goal isn't to migrate JS to TS (at least not in the context of this question). I have some TypeScript already. I want to automate modifications to it (eg: migrating from one version of a 3rd party library to another, which may have breaking changes). In the JS world, we use jscodeshift/recast and codemods to do this. It allows us to run transformations on our code at scale. These tools are not supported by TypeScript. Right now its fine, we only have a handful of TypeScript. When we have 1000 repos and millions of lines of code though, we'll need automation. I'm wondering what people use for this.
[This article](https://dev.doctorevidence.com/how-to-write-a-typescript-transform-plugin-fc5308fdd943) may be of interest to you. I haven't done any experimenting with transform plugins yet, but it might lead you to some answers.
Unfortunately the plugin system (in this context) gives me what I already have, a way to generate code from existing code (and I'm not sure from reading this if it allows me to generate typescript or just js...would be cool if the former). Tools like Recast let us change a small part of a file and leave the rest intact, including formatting, and jscodeshift makes it easy to orchestrate the process at scale. If Recast worked, then we'd get jscodeshift. Babel supporting TypeScript get us a big part of the way there, but not the whole way.
Just don't assign the instance. Remove the private field.
Awesome! I've wanted something like this when I'm refactoring, especially when splitting up a project that's grown too big for the one or two files it started in. I'm on Windows and it's writing full import paths instead of relative paths. I get `C:\Users\cspotcode\Documents\dev\myProject\src\foo` instead of `./foo`. Is this a bug?
You can make it public. That sounds bad but it's react and you don't usually have instances of components anyway. But it looks kind of odd. Why are you assigning to the member if you're not reading it?
I have a TS-powered codemods tool in development, but it's not ready for production. If anyone is interested in contributing to such a project, we might be able to work together.
Merged, and published the fix, thanks for the PR!
That could be interesting. Out of curiosity, was making one from scratch less work than working on Recast? (they look like they have a lot of work to do, but it's reasonably straightforward). That's the option we're considering.
I'm not sure. I wanted to work with TS because I wanted the ability to use TypeScript's AST along with the typechecker. So, for example, you could check for all references to a certain interface and change them in some way. What kind of work does Recast need to support TS?
There's always `// @ts-ignore`
&gt; But it looks kind of odd. Why are you assigning to the member if you're not reading it? He said it in the title and in his post: It (the `Map` instance) has side-effects.
If you have strictNullChecks enabled in tsconfig.json you'll get an error in your example Simply do if(str != null) {} and inside the block ts will be sure it's a string 
&gt;which has side effects, even if I may never use its reference later? That's your issue right there. Why would you be creating an object *just* for side effects? That makes no sense.
You normally don't want to pass ambiguous union types through your whole application. Unless the union types has a common base type, it basically means every time you use it, you would need to write an IF statement. The better practice is to sanitize and stop propagation of your input or API service calls as soon as you can. 
[mp4 link](https://g.redditmedia.com/obaOkROje9Uxp5DQidM_vK_OuufRJS9dIChxi0BP66g.gif?fm=mp4&amp;mp4-fragmented=false&amp;s=3903ba7f9613ac99205540008e8fe947) --- This mp4 version is 95.85% smaller than the gif (726.1 KB vs 17.09 MB). --- *Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2
Aha. Had no idea that existed.
Reasons out of my control. The example I provided has the effect of creating and binding a map to the div I name. I never want to reference the map directly, but I need to instantiate it. Without making it a member of the wrapping component, it's unclear to other devs that this is not garbage collected.
I don't get it.
it's sort of hard to get because it's not explicitly explained in animation. But the bomb goes off because of a type error that could have been caught with typescript.
Why is it out of your control?
Lesson learned i should not make jokes. But what to you think off my first ever stop motion animation? 
As much as I love typescript, who would be testing their bomb in runtime anyway?
&gt; So for example if a nod What you're doing sounds fairly similar to what we need, yeah. This is what's missing for Recast: https://github.com/benjamn/recast/issues/424#issuecomment-324028011 Essentially they use the babel parser as far as I understand, which supports TypeScript AST. Recast is already architected to ignore nodes that don't change (similar to how you describe your project). So the only piece missing is the pretty printer of nodes that did change for the TypeScript AST. Since the majority of our code is likely to be JavaScript for the foreseeable future, and we'd want to reuse TS and JS codemod, its starting to look like the most cost effective way to get what I want is to contribute to Recast.
I see what you mean, but since it was a stop-motion cartoon where sheep are programming, I willing to let that one slide.
Your example only ensures it's not `null`. It can still be `undefined`.
!== null would only ensure its not null, but != null, because of type coercion, also checks for undefined. Its basically one of the very few times when not using !== is legitimate :)
For what it's worth, TS can parse and emit JavaScript as well as TS. So my TS-powered tool should be able to transform JS as well as TS, and could theoretically transform JS into TS by adding type annotations. However, existing JS codemods would have to be rewritten against the TS AST. I don't think babel supports TypeScript's AST; rather it supports parsing TS constructs into its own AST. You could not use the TypeScript type checker to derive semantic information from a babel AST. Either way, good luck to you!
By the looks of it, a sheep. 
Yeah, I realized that when I woke up this morning. Sorry about that. `isEmpty ` is coming from Ramda
In that case, it looks like: declare function isEmpty(v: any): v is '' | Array&lt;any&gt; | object; ... except that's not how the declarations have been written. And I think the authors had the right idea. It would only give you a narrowed type if the input was already known to be e.g. a string. Then it would narrow to the `''` literal. For arrays or objects it won't help much. A mutable array isn't necessarily going to stay empty for long. The type is still `Array&lt;T&gt;`. For objects, structural subtyping says that an object with no properties might actually have more. So saying that a value is the empty interface (`{}`) doesn't actually give you any useful guarantees. Asserting that a string is "not empty" just means it's a string. Nothing learned there. Same for asserting that an array or object isn't empty. The assertion tells you nothing about what the object *does* have, only that it has *something.* `isEmpty` is not designed to check for `null`, either.
text should show up faster, longer pauses between actions
Between ESLint making sure you don't use it in unsafe situations, and type systems that handle null/undefined properly (strict null TS or Flow), it's pretty safe to use without thinking about it imo.
Yeah you're right. So both approaches have value and I hope to see both of them available in the future!
Just to give another perspective, you could use `Maybe` wrappers around possibly undefined values. There are plenty of Maybe providing libraries out there, I use [my own implementation](https://github.com/alsiola/alex-utils/blob/develop/src/maybe/maybe.ts). The idea is that the Maybe encapsulates the concept that the value may or may not be defined, and allows you to safely transform the data. You would then write a copy function such as the following. If the encapsulated value is defined (known as a `Just`) then the function is applied, if it is not defined (known as a `Nothing`) then it is not. Either way a new Maybe is returned, which will contain either the sliced string, or still Nothing. function copy(word: Maybe&lt;string&gt;): Maybe&lt;string&gt; { return word.map(a =&gt; a.slice()); } To put this into context, let's imagine we have the variable `person`, that may or may not have a `firstName` property: const person1 = { firstName: "john", lastName: "smith", age: 34 }; const person2 = { lastName: "jones", age: 50 }; We want to get the user's firstname, then if present, capitalize it: interface Person { firstName?: string; lastName: string; age: number; } function getFirstName(user: Person): Maybe&lt;string&gt; { return user.firstName ? Maybe.Just.From(user.firstName) : Maybe.Nothing.from(); } function capitalize(name: string) { return name.toUpperCase(); } function getCapitalizedFirstName(user: Person): Maybe&lt;string&gt; { return getFirstName(user).map(capitalize); } When we want to display it, we need to unwrap the actual value out of the `Maybe`, which we can do with `withDefault`, which allows us to either return the value, or if it is a `Nothing` type then use the default. const defaultFirstName = "NO NAME SET"; const person1FirstName = getCapitalizedFirstName(person1).withDefault(defaultFirstName); // =&gt; JOHN const person2FirstName = getCapitalizedFirstName(person2).withDefault(defaultFirstName); // =&gt; NO NAME SET The positives of this approach are that the possibility of a value being not defined is enshrined within your types, so you get great compiler help without having to write type guards and null checks. The negatives are that you end up with `Maybe`s throughout your code base, which may or may not be a problem for you and your teammates. 
If it makes you feel better, I got it.. and I liked the animation!
the use case in the article would benefit more from just "optional catch" here's another one: function isValidUrl (url) { try { new URL(url); return true; } catch { return false; } }
It would indeed, but optional `catch` is not (yet?) a thing. 😉 I like your use case as well!
Appreciate the smarter object literal inference--definitely something I've ran into a few times.
Crazy times when programming in C# makes me sorely missed the typing capabilities and safety of TypeScript.
Hahaha, could this possibly look more suspicious?
Might work (checked out the branch and these seemed to work for basic examples): type Arg0&lt;T&gt; = T extends (x: infer R, ...args: any[]) =&gt; any ? R : T; type Arg1&lt;T&gt; = T extends (x: any, y: infer R, ...args: any[]) =&gt; any ? R : T; type Arg2&lt;T&gt; = T extends (x: any, y: any, z: infer R, ...args: any[]) =&gt; any ? R : T; or maybe: interface Arg&lt;N&gt; { 0: (x: N, ...args: any[]) =&gt; any; 1: (x: any, y: N, ...args: any[]) =&gt; any; 2: (x: any, y: any, z: N, ...args: any[]) =&gt; any; } type GetArg&lt;N extends keyof Arg&lt;any&gt;, T&gt; = T extends Arg&lt;infer R&gt;[N] ? R : T 
That why they introduced the ! operator. Read further down
I wish I'd read the announcement more carefully before I updated my whole codebase 😂
I found that (and used it) but it'd be nice to have more in-depth checking if possible rather than just opting out of the initialization check.
Yeah, I would imagine the complexity explodes pretty quickly.
How is non-nullable in c#? I write minuscule amounts of c#, but no-implicit-any and strict-null-checks are something I can’t live without in ts. 
I also found it super handy when porting legacy ts code to `”strict”: true`. Just tack on a `!` to all errors and deal with rewriting the code later. At least all new code will get the extra strictness, and old code will be no worse than before. 
Nice! Looking forward to 2.8. Conditional and inferred types just around the corner.
Exactly.
Non-nullable refs are the worst and one of the main features of TypeScript that I miss. I think they're in the pipeline for C# 8 at least.
reported will be deleted soon i guess
What if you return the value of a from the init function and then assign it in the constructor
I actually had to revert to 2.6.2 for this. 2.7.1 caused this nondescript dump /usr/local/lib/node_modules/typescript/lib/tsc.js:59841 throw e; ^ Error: Debug Failure. at checkUnusedClassMembers (/usr/local/lib/node_modules/typescript/lib/tsc.js:35757:38) at checkUnusedIdentifiers (/usr/local/lib/node_modules/typescript/lib/tsc.js:35643:29) at checkSourceFileWorker (/usr/local/lib/node_modules/typescript/lib/tsc.js:37913:21) at checkSourceFile (/usr/local/lib/node_modules/typescript/lib/tsc.js:37891:13) at getDiagnosticsWorker (/usr/local/lib/node_modules/typescript/lib/tsc.js:37945:17) at Object.getDiagnostics (/usr/local/lib/node_modules/typescript/lib/tsc.js:37934:24) at /usr/local/lib/node_modules/typescript/lib/tsc.js:59858:85 at runWithCancellationToken (/usr/local/lib/node_modules/typescript/lib/tsc.js:59834:24) at getSemanticDiagnosticsForFileNoCache (/usr/local/lib/node_modules/typescript/lib/tsc.js:59848:20) at getAndCacheDiagnostics (/usr/local/lib/node_modules/typescript/lib/tsc.js:60059:26) Something with the `checkUnusedClassMembers` is breaking my compilation, as turning that off lets it succeed. 
That's not how reddit works
Came here to say exactly this method. Works great with inheritance too. You don't need the spread though.
Look into the built-in Record&lt;K, V&gt; type. You would use it like this: Record&lt;keyof TypeWithPropKeys, boolean&gt;. For enums, you could drop the keyof bit and it will use the values of the enum instead of the property names.
&gt;You don't need the spread though. True. Too much ngrx has left me spreading out of habit these days.
I created this mainly for https://github.com/frenic/glitz/ a CSS-in-JS library I'm doing and realized that it could be quite useful for other as well. I'd love some feedback to make it even better.
Very cool. Just browsing/skimming the codebase. In the genesis Block instantiation, is the hash always hardcoded or will it eventually be generated by a microservce? 
Thanks /u/itl-lmfao ! The hash is generated by a hashing function. The process of generating the hash is manual :) 
Mining cryptocurrency on Heroku is against their Terms of Service.
So... the same as React.CSSProperties ?
How does this compare to https://github.com/typestyle/typestyle ? 
Do you have an example snippet for webpack that I can include?
One issue I've found with this is that the declaration file imports also have the same (original) paths and when these are used in another project TypeScript starts to get confused.
Would they work with ts-loader that reads the same package.json?
CSSType is not a library like Typestyle is. It's only a .d.ts file that won't compile into any code. Haven't compared the types between Typestyle and CSSType in detail. But they are quite alike. My first though was to use their type for my library too. But that would require me to maintain the types every times the CSS spec changes... and that sucks. :-) So instead I developed an interpreter that translates the data from https://github.com/mdn/data into Typescript types. So when the MDN data updates, the types can easily be updated too.
Not offhand, no, but here's the configuration option that does what you want: https://webpack.js.org/configuration/resolve/#resolve-alias
I think you still need to configure webpack's resolution options to match your tsconfig.
Thanks! I have added a link to the article. :)
Thanks, but I'm curious, as the author, how are *you* using this option? Isn't your code failing at runtime? What module loader is resolving those paths?
Since every source file now exists at multiple paths, is there a possibility that e.g. webpack will include the same code twice in a bundle? Also, it looks like the TypeScript compiler will do the work of parsing, typechecking, and transpiling each file twice (at both paths) and output errors twice. Just a caveat to be aware of, unless I'm wrong.
Probably because he's simply focusing on TypeScript itself, and not some third-party additional tooling you may use. TypeScript itself can create a bundle already.
TypeScript can't create bundles for the kind of code in the blog post. Namely, it can't bundle named exports and imports for values. (in his case, classes) It can only bundle purely namespaced code. To prove this, you can download his sample code, compile it, and run it. It'll compile successfully and fail at runtime. ``` PS C:\Typescript-Short-Imports&gt; node .\src\other\domain\ClassB.js module.js:557 throw err; ^ Error: Cannot find module '@components/ClassA' at Function.Module._resolveFilename (module.js:555:15) ``` 
Nice! Just let me know if you have any feedback or questions.
It's called Mammoth now. :)
Cool. Property based testing is pretty sweet (assuming you can actually come up with useful properties for what you are testing, anyways). I'm not sure I'd say "instead of examples", though. It's often useful to do both.
Yeah, you're right, I totally agree: it is more something to have in addition of example based tests. Most of the time properties just test some traits of the algorithms so does not replace examples. I find it a very useful tool to help developers finding bugs they don't even think about. It can also be used for complex systems for both units and end-to-end tests. 
I don't think many JS librairies bother with typechecking what you pass to their API (e.g. by using `typeof` or duck typing) so i don't get why it is a problem for TS librairies. If your consumer uses TS, then awesome they get all the typechecking and goodness of the TS Language Service, if not then they were not even expecting having these in the first place. If you still want to help them, it really depends on what tooling you want to support. I guess you could use JSDoc that is partially supported in TS: https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript 
Yes, I think this problem is not widely recognised - although as /u/RickyMarou suggests, I think it's a problem for regular Javascript libraries as well. In other words: _most_ libraries assume you not to use their API's correctly. And it makes sense somewhat. For example, I wouldn't usually expect you to pass `{ valueOf: Math.random }`, even though TypeScript wouldn't prevent you from doing that. That's usually a valid assumption. That said, you can of course still implement checks for invalid values in your TypeScript code even if the type definitions say they should be impossible. An interesting related problem is this: when a library written in TypeScript does not use `strictNullChecks`, then its type signature might e.g. say `someFunction(val: string)` when it actually expects `someFunction(val?: string | null)`. Now, if you call that from your TypeScript code that _does_ use `strictNullChecks`, you wouldn't be able to pass it `null` even though that's supposed to be possible.
Thanks /u/RickyMarou /u/blakflag /u/vinnl for your participation. Sure it is easy peasy to add gatekeeper code as /u/blakflag suggests though naturally that has a performance cost. Another facet/benefit of static typing is to allow for code optimization because arguments to functions can be restricted to values of known types. My main conundrum is that the upshot of this is that calling functions which are optimised according to static type knowledge from vanilla JS which bypasses static type guarantees can lead to subtle bugs and not so subtle problems in general.
TS or browsers don't optimize by types. Browser doesn't even know the type
JS VMs do. They notice when hot code paths are used in statically typed ways and they JIT-compile more efficient statically-typed machine code with, funny enough, runtime type checks to bail out when their assumptions are violated.
I don't think users of your code using it wrong is a pitfall whatsoever. JavaScript is not Java or C++, and it shouldn't be those things. I feel like you came from that languages and are having difficulty with JavaScript's flirting-with-the-devil. Every parameter of every function shouldn't be typechecked. That's insane. You don't use TypeScript to force your users to use your typing. You use TypeScript to prevent _developmental_ errors. Once the final product is developed and working, the TypeScript part is irrelevant. The _typing_ part is irrelevant. You have no obligation to typecheck users, period. This is not a pitfall of TypeScript, not your code. Arguably, it's a pitfall of JavaScript, but _definitively_ it is not a pitfall that is your responsibility or concern. No one has to be aware of it, and don't take any steps to mitigate it.
You said browsers don't optimize by type, suggesting the OP was wrong. I'm offering a correction, since OP is correct and browsers *do* optimize by type. OP said that static typing allows for code optimization, which is correct. When code is written to consistently execute in a statically-typed fashion, the VM notices this and optimizes accordingly. TypeScript makes it easier to write code in this style, for developers who want to do so.
ES6 has classes. It's the same optimizeable structure as TS class without type definition
Now I know you're trolling; that is totally off-topic. :)
&gt; You are essentially tricking developers into thinking they are writing Type safe JavaScript I think this is a huge misunderstanding by Marak. JavaScript does not, and never have, type checked. If someone uses the wrong types for a variable, that is the fault and responsibility of the user, not the language nor the developer. That is a principle of JavaScript. Am I correct in assuming you are coming from a more strictly typed language, such as Java?
Yeah, and I'm saying TS types, even though they are stripped at runtime and unavailable to the VM, still assist the developer in writing code that behaves statically at runtime and is thus optimizable by the VM.
Since you asked, sure :-) I've been in PLs over the years starting with Assembler (if you can call that a language and which is about as untyped as you can get), then C, C++, JavaScript (early days), Java, Scala now pretty much mostly TypeScript.
I don't know man. When the OP talks about showstopper, I see a possibility of having misunderstood the type erasure at play here. And now we are talking about optimization nuances. Maybe OP can clarify whether there was a innocent misunderstanding.
Sure, my initial conundrum was about optimisation nuances though VM (e.g. V8) optimisation is just one aspect. The other optimisation aspect is that functions implemented in TypeScript (or Flow/Babel for that matter) can make use of the static types of arguments to make assumptions about the restricted range of values that the function accepts as arguments to produce a correct result. Accordingly the TypeScript implementation of a function can be written in less code (nothing to do with the VM as such). This is because one doesn't have to check for some illegal, out-of-range or coercible argument values whose types would otherwise violate static type guarantees as compilation errors would indicate. If client code such as vanilla JS doesn't obey the same rules as statically imposed by a compiler/transpiler then there is a likely/substantial risk of erroneous results being produced by the TypeScript-implemented function. Such erroneous results may not be immediately detected though may be observed when it is too late. It's the sort of think that you have to be mindful of particularly when developing mission-critical software e,g. for a self-driving car.
https://astexplorer.net/ is extremely useful for stuff like this (be sure to set the parser to typescript)
I didn’t touch any types, but only added `!` after expressions that could be undefined, like `.pop()`. Could you give an example of a type definition that breaks with strict?
https://github.com/prettier/prettier/issues/3561
Oh nice, thanks!
This is literally a non-issue. As I can pass any invalid input to a TypeScript function by casting it to any, anybody can pass anything to a javascript function. No one really checks all their arguments: that would defeat the purpose of using a low friction dynamic language if 3/4th of your code was type checks and shape assertions anyway. So there's no difference really. The only (minor) issue with using a TypeScript api from JS (or vice versa) is that some design patterns are needless, or necessary. Eg: Redux' connect is annoying to use from TS because it does not infer types from the Store without you specifying it (the connect factory would have to be created from the store for that). Vice versa, some TS stuff might have a bit more ceremony from JS because it was meant to infer types (but obviously in JS it cannot)
&gt; Another facet/benefit of static typing is to allow for code optimization because arguments to functions can be restricted to values of known types TypeScript and Flow are basically glorified linters that use a (albeit pretty clever) static type system with no runtime info. The former has a compiler baked in, but it's mostly for convenience (to have "batteries included") and isn't really tied in with the type system aside for knowing how to strip the annotations. So those kinds of static typing benefits don't really materialize in practice. You gain small boosts from not having to do nearly as many assertions (you still do for type narrowing to make the type checker happy), but it's minimal. For all practical purpose, TS helps you write well formed JavaScript, but it doesn't give you anything beyond that.
Sure, I understand your good point about any-casting in TypeScript. For the purposes of argument, would it make a difference by widening the topic to catch your point with this, say, amended title? "Develop in TypeScript, consume with non-type-checked client code. What's the problem?"
Could track this proposal: https://tc39.github.io/proposal-bigint/
This needs to be added to the JS language; then TS can support it. There are good reasons TS doesn't add non-JS features like this. They've been discussed many times before; you should be able to find them with Google. A big one is that, if TS introduces non-standard language features, then JS introduces features that conflict (possibly using overlapping syntax), TS will have no way of supporting the new JS without breaking changes. The type system's syntax is carefully designed to hopefully never conflict with future JS syntax. Have you heard about the BigInt proposal? https://tc39.github.io/proposal-bigint/ What do you think?
Wonderful, thanks! Will check out the library ;)
You might be interested in TypedArrays - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray - which TS supports - https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es2017.typedarrays.d.ts
Thanks. I mentioned TypedArrays in my open.
Sure, thanks, I've done a lot of web search already but just really wanted to find out whether people in general were interested &amp; not just the language gurus. I also happened on the bigint proposal. It's great to see something being mooted on the standards track. It's no doubt a given that if it happened in JS core then TS would eventually support it.
The closest analogs in the JavaScript community would be a linter (ts-lint), a pretty-printer (prettier apparently works well), or a codemods tools. There is not yet a codemod tool for TypeScript, but there's work in progress to add support to the "recast" library.
Recast should have it reaaaaaaaaaally soon. Mostly just waiting on code reviews :)
it fixes just simple errors. I cannot change order of methods.
because it is plugin to VS:( 
Nice! Do you have a link to the PR? I wanna check it out.
I use [prettier](https://github.com/prettier/prettier).
These kind of things in JS always end up polarized. A part of the community can't wait to have it, and another part don't care. Mostly because the type of work that would need these kind of specialized types is kind of niche (compared to the scope of the JavaScript community as a whole). Like your example for TypedArrays. I used to live or die by them because I was doing complex image processing in node and in browser. They were my bread and butter. Then I went back to the web app world, and never used them anymore. Now I'm in the node tooling world, where they might be useful again. The various integer types are kind of similar.
That said, injection via function is still not possible in TS :(
Do you think, that it would be possible to do the same for a nameof(...) operator?
I'm interested.
Thanks everyone for your input so far. Being a stickler for strong typing, I've been working on and off various approaches for typed numbers in TypeScript for well over a year, probably longer. The approach which I'm most happy with now lets you write TypeScript code like the example below. This is a genuine working, type-checked example that requires a fairly thin library to compile against and to include as a run-time dependency. I'm rather pleased with and proud of the achievement though I do understand that strongly typed numerics is not something that everyone cares about. The names of the numeric types supported in my library are based upon the names of the ES2015 Types Array variants except in all lowercase. So there is float64, float32, int8, int16m int32, uint8, uint16, uint32. The float64 type is just an alias for the TypeScript/JS number type. function add(x: int32, y: int32): int32 { return int32(x+y); } function price(unitPrice: float32, numUnits: int32): float32 { return unitPrice*numUnits; } function tally(): float32 { return price(float32(4.5), add(int32(3), int32(2))); } console.log('tally=', tally()); Compiles nicely and when run outputs: tally= 22.5 
I'm using IntelliJ, it seems the most complex solution for me but I'm open for anything:)
Remember this transformer does it's work at compile-time, hard-coding strings into the JS at the call-site. So it can't do stuff like C#'s runtime type information. It can't e.g. `nameof(getAnimal())` and give you something like `"Cat"`. The static type is "Animal" so that's what you'd get.
Quick question - what are you developing for? Angular?
Oh, whoops! Nevermind then. Guess I should spend more time writing more C#.
I don't like how close those votes are! I prefer int8, etc., because they have extensible meaning. "short" is vague and open to interpretation, at least on first hearing, and as more bits as supported, more **arbitrary** names have to be assigned to them.
Hey thanks for commenting. Even on a handful of votes, this is amazing and shows just how polarized the PL community is. I wouldn't like to bet either way on this; it's about as volatile as the stock market! That's a good point that you make about arbitrary names imho.
Style A, but shorter - you should try to match WAsm naming. WASM has types i32, i64, f32 and so on.
Sizes of byte, short, int, and long are not defined exactly in C/C++. This causes confusion. Some languages define these precisely, so they aren't so consistent across communities. On the otherhand, int8, int16, and int32 mean the same everywhere (as far as I know).
My advice, at least to start, don't write typings for third-party code if they don't already exist. It's unnecessary. Either turn off noImplicitAny or declare them in an empty .d.ts file: declare module "lib-without-typings"; That will tell TS that "this module exists and doesn't have typings.". It will be of type `any`. But first, have you checked the @types declarations from DefinitelyTyped? Do they have any of the libraries you're using? Make sure you're using "moduleResolution": "node"
If the types don't exist in the package have you looked in NPM's [@types](https://www.npmjs.com/search?q=%40types)?
If you're going to use an NPM package that wasn't developed with TS, you'll want to add the package's typings, if they exist. A great tool to find typing files is [TypeSearch from Microsoft](https://microsoft.github.io/TypeSearch/). As an example, if I want to include lodash, run ``` yarn add lodash @types/lodash ```
Update: on 54 votes the tally so far is 81%Style-A: int8, int16, etc 19%Style-B: byte, short, etc
&gt;If it makes a difference I've been using Vue, and quick searches for the other big ones such as Angular and React show a similar lack of .d.ts files too. Vue should ship with typings, and you can get Angular or React from the [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) project (`npm i @types/package`). The TypeScript handbook also has a page for [React &amp; Webpack](https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html) which is a pretty good starting place for figuring out frameworks and build tools for TS.
Definitely typed and also nuget and node have typed definition packages for all the libraries you mentioned and 100's more 
Thanks for the reply, yeah I came across DefinitelyTyped and it had a couple but not the ones I am looking for now. I was looking at vue-axios (which I eventually found in the github repository but not in the npm package). Then moving on to websnova/vue-auth for JWT authentication - I’ve not found anything. I came across the noImplicitAny switch but thought that was a bit of a cheat, but I’m starting to think it’s the best way forward at the moment. Didn’t know I could add empty declare in a empty .d.ts file but I didn’t seem to able to get my tsconfig.json to pick up my experimental declarations anyway, will have to play about some more.
Yup, I did E404 every time, which I could put 2 and 2 together to work out that there was none but no where online I found specifically stating that there might not be one that that’s the error I would get
Unfortunately the npm @types and the TypeSearch didn’t have what I have been looking for, which is now a JWT auth package for vue. I have seen a angular auth package with typings but it just makes me nervous for other packages I may want to use down the line 
Sorry just noticed too you were using yarn for the package manager, is yarn likely to differ much from npm?
It shouldn't, but I cannot guarantee that. I use yarn because it tends to be faster, but otherwise either is fine for package management. 
Since Angular is written with TS, you'll find that a lot of TS code is written for Angular programs, which isn't great since you're using Vue. You might consider writing typing for the auth library that you wish to use, if you cannot find one. 
Express, dotenv, and knex works well and is very flexible.
Thanks!
That sounds reasonable. Most important is I think Style-A needs to at least be the default as it's *much* clearer and also more consistent with other Microsoft products.
I had my files in the types folder labelled as plugin-name.d.ts, Visual Studio just seemed to see it as a TypeScript file that needed compiling - not sure if that was normal { "compilerOptions": { "allowSyntheticDefaultImports": true, "experimentalDecorators": true, "module": "es2015", "moduleResolution": "node", "target": "es5", "sourceMap": true, "skipDefaultLibCheck": true, "strict": true, "types": [ "webpack-env" ] "typeRoots": [ "./node_modules/@types", "./types" ] }, "exclude": [ "bin", "node_modules" ] } 
I will consider it, the typings files don't look too complicated, just a ball ache going through other peoples sources to find the method signatures. I didn't know Angular was written with TypeScript, and I'm by no means married to Vue, just already had some experience in it. I think I might have a go proceeding with Angular, as that means there's a fighting change the types will be there. Thanks for your reply.
I'm not in front of a computer so I can't test this now, but I think you need to add "./types" to your "exclude" array. Should prevent TS from seeing those .d.ts files as TS to be compiled and allow it to see them as typings for external modules. Sorry I can't test right now; let me know if it doesn't work and I'll test it later.
Nest.js is a typescript framework for node.
Do you have to use TypeScript? Angular isn't a bad framework (I've been using it for ~9 months), but it is has a high learning curve, since you'll need to understand TypeScript and RxJS, as well as Angular's architecture patterns. If you're already using Vue, and you know Javascript reasonably well, you may find it easier and quicker to just use JS + Vue. Having a statically typed language is nice, sure, but not always necessary or useful. 
Hapi.js works well with it, might need to use v16 instead of the newest v17 though
I'd love to see your thoughts on sagas/selectors, especially since my sagas tend to touch other things (like issuing notifications etc). And by the time all that logic is introduced, it's way too much for one file imho. What I end up doing is creating a feature folder, that is responsible for a slice of state. Issue I'm running into is that I end up having to pass that slice of state into the selectors instead of the root state since they shouldn't know how state is organized overall (not a huge issue, just bugs me sometimes), and sometimes i have overarching selectors that need access to more than just their slice of state to be useful, so where should those go? Anyway, some great concepts here, and like I said I'd love to see it expanded upon. 
I guess this is what you do when you want a blog post to stand out?
The one thing I'm struggling with when using Koa is accepting file uploads. I'm on the middle of a hackathon right now, going back to finish in like 6 hours, and I started our mvc style web app with Koa but had to switch to Express 4 half way through because no matter which body parser I tried with Koa, I couldn't get the file data, just the file name. With Express, I used a body parser called multer and it worked.
It’s what you do when you use a static type system and have free time to do shit like this, rather than chasing down why your code doesn’t run properly because you forgot some variable might be “undefined”.
 ``` router.post('/files', async function (ctx) { // Get the stream. const {files}: {files: Array&lt;stream.Readable &amp; {filename: string}&gt;} = await asyncBusboy(ctx.req, {limits: {files: 1}}); const uploadStream = files[0]; // Pipe the pile to disk. const tempFilePath = '/tmp/'+uuid.v4(); const tempFile = fs.createWriteStream(tempFilePath); const done = new Promise((resolve, reject) =&gt; { tempFile.on('finish', resolve); tempFile.on('error', reject); }); uploadStream.pipe(tempFile) await done; // ... }); ```
Koa + Typeorm + Routing-Controllers + Class-Validator is very flexible and does the job well.
Great... now the next bit of shite code I encounter will be running on a custom flavor of node and will look like just a random grouping of emoji's
oooooh definitely typed BURN!
NestJS
There is a functional data type called "Either". The "Failable" idea in this blog is the more-or-less the same as an Either. Eithers have a "left" and a "right" type. The convention is to use the left type as the error type and the right type as the success type. (Easy to remember because right is right.) Eithers typically have all of the functional methods you'd expect on collections/monads (map, flatMap, etc). Some implementations are right-biased, which means "map" would operate on the right type. Other implementations have separate "mapLeft" and "mapRight". My preferred implementation will allow to convert the Either&lt;L, R&gt; to an Option&lt;R&gt; and vice versa. TL;DR: use Either.
I mentioned towards the end that this is a monad. The problem with just using flatMap is that if you have a series of failable calls depending on the results of the last one, you need to do some nesting. This method will ensure that all calls are in the same flat scope.
How do these things compose? Does `run` not need to take some input if I want to combine two failable computations?
I believe your `run` function is just the Coproduct (Either's) *join* function. Defined as: `run(f) = join(f, (x) =&gt; throw x)`
How does this actually differ from Either?
"Crux of the problem. You write TypeScript code based around assumptions that will be erased along with the types in the output JS. We see this in BuckleScript output too." -- Yawar λmin (@yawaramin on Twitter) https://twitter.com/yawaramin/status/961386334408474624
MEAN stack with TS all day. 
I usually just use "instanceof" try { // ... } catch(err) { if (err instanceof MyError) { // ... } }
Yeah but you have to be aware of what types of exceptions your try block can throw. Think of this as a glorified try/catch that forces you to either throw the error or handle it.
I don't at all have to use TypeScript, just thought it would be the best way forward for a SPA in Visual Studio, plus the SPA templates came with it. I am more familiar with Vue, but was aware this would be a learning exercise. Maybe you're right as I don't want to chew off more than I can handle. Thanks again
Does the compiler not whine about this? What version are you using?
ok so many properties like private and readonly are declarations of intent. for example you can set a variable to private but it is still valid javascript if called by when injected somewhere else. However if your tsconfig is setup properly (and I believe these are checked by default) when you go to compile you should receive and error you can choose to have these errors ignored of course.
Well I googled what you wrote and found a blogpost from 2016 claiming exactly what you want. https://blog.mariusschulz.com/2016/10/31/typescript-2-0-read-only-properties It is only a compiler guard, so if you’re doing this without compilation, it won’t work. That said, seems like you’re doing all the right things. Maybe it’s a regression in your version that may already have been fixed in a newer version of Typescript?
Since I can replicate my issue at https://www.typescriptlang.org/play/ I assumed it was not particularly related to my specific environment. In the blog you linked, he only scratches the surface. type Trw = { a: string; }; type Tr = Readonly&lt;Trw&gt;; // This is an error in all environments I've tried, and this is // the type safety he showcases in the blog post. const x: Tr = { a: 'foo' }; x.a = 'bar'; // This changes the interface before assignment. The change of // interface is what I would like to be an error. const _x: Trw = x; _x.a = 'bar'; Thanks for looking into it btw. It is much appreciated. I'm going mad over this. :P 
What you want is not possible and not supported by TypeScript, because it's not covered by what TypeScript aims to solve. It just adds the type safety that the property of that interface can't be written to, and that is the case. When you have the interface, you can't write to that property. It does not prevent the modification of the underlying object in general. For that to work the `readonly` would have to be enforced in the object itself during runtime, and that is something that JavaScript does not offer yet. If you want that functionality, wrap your object creation in a call to the `deepFreeze` library. It replaces your object with a new one that will crash when it's modified.
It might be currently unsupported, but I do not believe that it is impossible to support. What I'm after is purely compile time checks. I want it all stripped away at compile time. Typescript _does_ enforce checking of property names when assigning one type to another. So I have to say I'm very surprised to find out that it completely ignores the same check when it comes to the readonly modifier. type Tr = { readonly a: string; }; type Trw = { a: string; }; type Urw = { a: string; b: string; }; const foo: Tr = { a: 'foo' }; // This is NOT an error, because Typescript fails to respect the readonly modifier. const bar: Trw = foo; // This IS an error, because obviously property b is missing in type Tr const baz: Urw = foo; It should simply not consider `readonly a: string` assignable to `a: string` when comparing types.
Hmm it's weird. Maybe it's something with the actual statements. I've tried this in the playground and got the following result: ``` type Test = { readonly a: string readonly b: number[] } const t: Test = { a: 'test', b: [1, 2, 3] } t.a = 'blerp' ``` This give me an error: Cannot assign to 'a' because it is a constant or a read-only property.
I generally use classes with only getters if a property is read only. 
That is an example of the basic functionality that does work. The problem is that your type `Test` is considered compatible with another type `Test2` that does not have the `readonly` modifiers. If you have type U = {a: string; }; type R = {a: string; b: string; }; then this is _legal_ (as it should be): const r: R = { a: 'foo', b: 'bar' }; const u: U = r; and this is _illegal_ (as it should be): const u: U = { a: 'foo' }; const r: R = u; In the same sense, I believe it should be the case that if you have type Trw = { a: string; }; type Tr = { readonly a: string; }; Then `Trw` is assignable to `Tr` but `Tr` is not assignable to `Trw`.
That's an interesting idea, I might've missed that in your original post. It seems you may be right, sounds like a report for Github!
Yes, it is. Thank you. Welp, it is in fact [working as intended](https://github.com/Microsoft/TypeScript/pull/6532#issuecomment-174356151) :( Some people are talking about adding another modifier `mutable` in addition to `readonly`, such that readonly interfaces are not assignable to those explicitly stated as mutable. That sounds good to me, and perhaps it can even be bundled with a flag that completely disallows the ambigious definition of interfaces not explicitly modifying their properties with either `readonly` or `mutable`. 
Yeah, this seems about the same type of behavior. 
Since this behavior has turned out to be [working as intended](https://github.com/Microsoft/TypeScript/pull/6532#issuecomment-174356151), I might have to go with classes too. Is there anything about that approach that you think I should be aware of, or is it working out nicely for you?
To be completely honest, I put on my OOP hat a lot with typescript; interfaces, partials and classes all over the place. 
It turns out that you can do the following: class Foo { public readonly a: string = 'foo'; } class Bar { public a: string = 'bar'; } let foo: Foo; let bar: Bar; foo = new Foo(); bar = foo; bar.a = 'baz'; console.log(foo.a); and it will print `'baz'`. This is arguably even more surprising than the example with the interfaces imo. I'm not sure I like that Typescript allows `bar = foo;` here, but there is probably an argument for why it should. Using a private property and a getter seems solid, even though it's verbose: class Foo { private _f: string = 'foo'; get f() { return this._f; } }
I mean, you can always access private properties as stated by other folks, but at least the compiler and IDE will yell at you.
Yeah, compile time checks is all I'm aiming for here
This article has just taken the static vs dynamic language discussion and given it a spin by calling it "type driven development", which is essentially nonsense. It's not a method. It's just a property of the chosen language.
I mean types are awesome and people should definitely design things functionally, but I wouldn't go around throwing custom types everywhere. Every project has a "vocabulary" of custom things, you want to keep that as small as possible (that's why we use libraries/frameworks). You don't want to be in a place where you have 5 different types of stings and instead of creating another helper to transfer from one to the other you just cast it.
It's similar to the Elm way of making it impossible to express error states in your program. 
Nice article.
Neat, but am I wrong or can't you return arrays from components as well? Which is effectively the same thing and doesn't need a wrapper or fragment?
Probably a *brand*, a way to emulate a nominal type in a structurally typed language.
You can return arrays from `render()` as well, but then you have to specify a `key` for every element.
Hey mate, did you click and see what the package does for you?
Yes, but subjectively I find array syntax in JSX very ugly.
Right on! Need to give it a try 
The v2 types are under @types/jquery/v2. But I'm not sure how you can tell Typescript to use those (they are in the `@types/jquery` package)
How does that work for angularjs? It is 1.3 all the way until 3.9.1 and 3.9.2 is 1.4.
For me refactoring is another major benefit. The ability to basically break your API on purpose and then wander around fixing all the places where the change broke code is fantastic. I've tackled some pretty large TS project refactors I would scarcely have even attempted with vanilla JS.
When i had converted enough of our old ES3 single page app to typescript that i could press F2 on a property to rename it without breaking anything in the 20 or so files that referenced it.. That was worth the work thrice over. Probably a waste of time because we're gonna throw away all that old code and remake the app "next year", but until that becomes "this year" it is great to have help from the typescript compiler when adding new features to old code.
I've heard this referred to as 'error-driven development.' I agree, it is an amazing way to refactor code.
Have a look at the links in [awesome-typescript](https://github.com/dzharii/awesome-typescript).
Is your object is an instance of a class? If so you can only iterate on it (assuming you write typescript without "cheating"😊) if you describe an indexer on your object. Something like [id:string]:object. You can iterate on the object by calling Object.keys function. It will give you an array of all the keys in the object. Then evaluate each property by (typeof obj[key]) I'm on phone so cannot validate or write you a code snippet. Also, i don't know the scenario you are facing, but, I would consider using map instead of Javascript object
--target ES5 resolves the TS1056 error
 const obj = { a: 1, b: 2, c: 'string' }; const newObject = {}; for ( const key in obj ) { if ( typeof obj[key] === 'numbe r' ) { newObject[key] = obj[key]; } } something like this would do the trick? Here you're iterating the object using a for...in loop, which cycles through the keys of the object.
 Object.keys(obj).filter(k =&gt; typeof obj[k] === "number") .reduce((newObj, k)=&gt; ({[k]: obj[k], ...newObj}), {})
Came here to say the same; this should be possible with conditional types.
Uh... If you did this you'd get an error that type `{}` has no property `a` etc, no?
no if the property doesn't exist on the object it's created
But `newObject` implicitly has type `{}`.
Oh. That isn't possible with my config. Perhaps outside of strict mode?
 Object.preventExtensions(obj) Will prevent you from being able to add properties. It might be cast on objects in strict mode I'm not sure. You can check if your objects are extensible using: Object.isExtensible(obj)
I have started a React / Redux app in TypeScript and must say I love it, sure it make « bloat » code where I declare types, but it’s way easier to write and prevent mistake, I love it!
I'm actually not sure why you'd think a large-scale app would ever be worse off with TypeScript; it'd always be better.
Simple question before diving into it in a real app
Well in that case, I say TS is always better for big apps than plain JS. You don't lose power or get bloat.
What exactly is this? Is it a reimplementation of dotnet APIs in TypeScript? Is it targeted at people who are familiar with the dotnet collections and API and want the same thing running on a JS VM?
Slightly tangential, but you said &gt; and in future web assembly Typescript will probably never have a wasm backend. Nor would a wasm backend be beneficial for JavaScript (TS is JavaScript after all). The browsers already optimize the hell out of JS and none of them do it by compiling to a lower level intermediate assembly language. If it had made JS faster, they would've done it. It's different for primarily static languages like Kotlin and Rust. Theoretically, you could make a wasm backend for a very restricted subset of typescript. You'll have to restrict things like fiddling with prototypes and any runtime dynamism like implicit type conversions for it to have any actual benefits. And it would probably effect JS interop. (Because your libraries aren't written in the static subset of JS so they won't be compiled to wasm). Honestly, it would be better to use a different language altogether if you want any benefit from wasm.
I don't know why you got downvoted. That was a valid argument. And it was an argument against OP's point and not an argument against using typescript. Someone probably conflated it with the latter.
I don't quite understand. TypeScript is not JavaScript Typescript could easily be transpiled (or in this case Compiled) down to wasm much the same way Blazor does with C#.
went ahead and upvoted. I agree and I kept it rather general for that reason. It's true that any transpiler could work for this argument. But not all transpilers have the backing of microsoft or support in resharper. That's a feature you only get with TypeScript(AFAIK). Coming from a .net shop that's pretty handy. That's why the second sentence to that mentions TypeScript as a good transpiler option because of it's massive backing.
Hi, I came to nodejs and react native from the point of view of static types and I honestly can not understand why you wouldn’t change to typescript. In the first few weeks of me using it I found a few bugs with the implementation of some libraries that the authors saw as little JavaScript oddities before noticing it was a problem with the type they had imagined and it was working by “chance” in some edge cases. Said that, the one thing I have found annoying of typescript is the type definition as there are plenty libraries without the typescript definition file. Sure, you can declare everything as any and use it in the JavaScript way, but if you are going to do that, the safety ts gives you is gone for a section of your code.
The only time I’ve found found Typescript to be in my way is when I am creating higher order components with react. It feels very laborious to get the types right and generally isn’t fun. I would love to know how other people are writing higher order components with Typescript, because I was pretty dissatisfied with the solutions provided in the blog articles I read.
What do you mean by *higher order components*? Best regards, Noob.
It is JavaScript as far as the runtime is concerned. If you think about the TS compiler in 2 phases, type checking and transpiling, the transpiling phase just strips away type annotations. This is because TS has the same runtime semantics as JavaScript as opposed to C# which has it's own semantics. It can be compiled to wasm but it won't be "easy". It will require implementing JavaScript's object model/prototypes and inheritance in WASM. It won't be trivial. If you manage to do that, there won't be any speed improvements. The reason why C# property accesses are fast is because you can't add methods/properties on runtime, so the compiler can assume that if you have the address of foo, foo.x will be at that address + a constant offset known at compile time. In typescript, properties can be added at runtime which means the offset of .x property of foo cannot be known at compile time. So, you will have to traverse the object at runtime to find the address of x. Since JS objects are just hash maps, every property access needs a hash lookup at runtime. This is just one of the many costs of runtime dynamism. There are many more. So, yes TS be compiled to wasm but it will almost certainly be slower than the JS backend and to make it faster, because JIT compilers already optimize the hell out of JS code and it would be very hard to match that (even if wasm had JIT compilation). Or you can compile a subset of TS which doesn't have runtime dynamism at which point, you might as well use C# or Kotlin.
any examples and uses cases would be super helpfull!
Having dabbled with TypeScript but not adopted it, I can say the only reason I didn't fully embrace it was the pain of including dependencies' type definitions. There were four different recommendations at the time: give up and use any type, commented d.ts include, definitely typed, and @types. Any type has no benefits and is annoying cruft, commented include works but is extremely tedious, and the later two were simply missing many of the modules I use regularly. I spent so much more time trying to include dependencies than I did building apps, so I gave up on TS. I would like to try again and see if the situation has stabilized.
I agree with that actually, React is not very TypeScript friendly. We use still AngularJS and that generally has little problems.
Awesome, I've never used .NET except for PowerShell but this sounds really useful.
Awesome!
 type Filter&lt;T extends {[key: string]: any}&gt; = { [K1 in {[K2 in keyof T]: T[K2] extends number ? K2 : never}[keyof T]]: T[K1] }; type T1 = Filter&lt;{a: number, b: number, c: string}&gt;; Can be written down nicer, but this works. Needs TS 2.8+
I see your point. However we are making two separate arguments. I will concede that at the moment TypeScript does not grant any benefit to being convert to wasm. That's still not the point I am making though I don't care about converting to wasm because its more performant. I care about converting to WASM(or whatever other standard comes along) because I can still use my legacy code set 7 years from now instead of 5 years. Increasing the time until I need to rewrite the project. I am more concerned about the longevity and relevance of the code rather than the sheer performance. I understand your point and thank you for explaining it to me it is quite a bit deeper than I dare tread into these matters generally. Also the limitations you linked I found very interesting. Our code, because of our C# background I believe would actually meet those limitation since we are fairly use to this type of standard anyway (everything in our typescript is interface has constructors and the word "any" was made by satan). We enforce many of those limitations in our tsconfig.
Yup I agree with your original point. That's why I prefixed my first reply with "slightly tangential". I use TS myself and it's amazing. Conditional types in 2.8 has allowed me to type some really cool stuff.
Typescript types are sufficient.
I’d go as far as to say they are better, not merely sufficient.
Additionally, I don't even think PropTypes are in the type declaration for react. I seem to remember reading something about this.
Found it. https://github.com/Microsoft/TypeScript/issues/4833
That's really encouraging. @types was new when I last tried TS; probably an unfair time to form an opinion of it. ;)
&gt; Is it bad that it depends on a few ES5/ES6 features at run-time No. That's what polyfills are for. &gt;Should I put effort into making it ES3 compatible at run-time and lose the Iterable functionality of my enum wrapper? No. If you care enough you should make an ES3 specific version. Overall your code looks pretty solid to me. Good work! Nicely documented too!
C++ does in fact have digit separators these days! :) The syntax is a little bit different, though: C++14 uses single quotes to separate digits. The TypeScript team is very careful about adding new syntax to TypeScript in order to stay compatible with JavaScript. They implemented numeric separators in TypeScript 2.7 because the [Numeric Separators](https://github.com/tc39/proposal-numeric-separator) for ECMAScript has reached stage 3 of the TC39 process, so the feature is likely to be included in ES2019.
I added some more thoughts for discussion feedback to the original post: * Is the implementation of the Map interface just adding too much confusion? There are 2 ways to do many things now (e.g., keys() returns iterator, while getKeys() returns an array; get() and getValueOrDefault() with the second param omitted are equivalent, etc.) Should I drop support for keys(), values(), entries(), and get() for a less confusing API, or are the additional options good? I would keep the @@iterator(), and forEach() is still inspired by Map. * Is there confusion about getValue() vs getValueOrDefault()? Should I rename getValue() more explicitly as "getValueOrThrow" to avoid any uncertainty about whether the method will throw vs return a value when the key is invalid? (similar for getKey and getKeyOrDefault). * The combination of the above 2 points is particularly concerning to me, because I have a nondescript "get()" method from the Map interface that adds even more uncertainty about which method you should call between get(), getValue() and getValueOrDefault(). Maybe I should at least drop support for get(), even if I keep keys(), values(), and entries() from the Map interface. 
Just typing all of this out is actually helping me think about it. I think the right decision is to: * Rename "getValue()" to "getValueOrThrow()" and rename "getKey()" to "getKeyOrThrow()". Now there is absolutely no way for a developer to be surprised by the behavior when a key/value is not valid. * Get rid of the generically named "get()" method, because it just adds confusion. I don't think there's much value in being able to treat an EnumWrapper *exactly* like a read-only Map, and it's better to provide clearly named methods (above) that instill confidence in developers. * Keep the keys(), values(), entries() methods from the Map interface, because they provide a potentially valuable alternative way to iterate the data. * Keep the @@iterator(), and forEach() methods from the Map interface. Does anyone disagree with this?
I'm curious as to the intended use of this lib -- it seems like you're adding a lot of scaffolding around improving enums at runtime (runtime checks, mapping/iterating), but I've mostly used enums myself for more compile-time concerns. Since enums are defined at compile time, I always know all the keys and values, and feel like I would only benefit from runtime checks in relatively niche cases (e.g. interpreting some part of a response of an api call as an enum). For most of my enum usage, I want them to be as lightweight as possible, so multiple linear/superlinear operations in construction and large object sizes scare me. Not trying to throw shade in any way, just wondering how you're using enums. A practical example or two would go a long way. Very well documented though :)
Like you said, it's probably most useful when you have an enum describing possible values that you will receive from an external source (an API or a file) such that values need to be validated at runtime, etc. Here's an unusual use case I have. The setup for it is a bit long, so bear with me (necessary to avoid inevitable "why don't you just...?" questions that arise from oversimplification)... We're developing a front end against an API that exposes a Swagger (OpenAPI) document to describe the API. We generate TypeScript code/interfaces/enums/etc from the endpoints and "models" to get compile-time verification that we interact with the API correctly. Mixed in with all of that generated code is a "FileType" enum. There are multiple contexts in which files can be used, and there are different subsets of file types that are valid for each context. This knowledge is not encoded into the API spec in anyway, so we must implement these relationships in front-end code based on API documentation telling us so. So we have some generalized code that accepts a list of FileType enum values so that it can be reused in the different contexts where different subsets of FileTypes are valid. To get that list of valid FileTypes, we use a combination of ts-enum-util, lodash, and ts-string-visitor (another library I created) like this: const fileTypesForSomeContext = _.filter( $enum(FileTypes).getValues(), (fileType) =&gt; mapString(fileType).with({ [FileType.MDX]: true, [FileType.DBC]: true, [FileType.CSV]: false }) ); The mapString method from ts-string-visitor allows us to map each file type to true/false, whether it's valid for the context. If we forget to handle a file type, or if a new file type is added later, the mapString() usage will fail to compile with an error message about the file type that is missing from the handler. It forces us to make an explicit decision for each possible file type, which can be easily compared to the API documentation for manual verification that we defined it correctly. Due to all the type inference and generics, "fileTypesForSomeContext" ends up being of type Array&lt;FileType&gt;. But yeah, definitely use the raw enum itself when writing code where you know at compile/development time exactly what enum value you want to reference, etc. You only incur the overhead of creating the EnumWrapper instance when you use the $enum() function for a particular enum for the first time, so just don't use it if you don't need it and you still have your lightweight enum. I'm open to suggestions for making it lighter weight. I feel like I struck a decent balance between initialization complexity, caching, and efficiency of the various method implementations, but I could be wrong.
Another simpler use case is generating options for a dropdown/select-like component from an enum: const options = $enum(RGB).map( ([key, rgbValue]) =&gt; { const label = mapString(rgbValue).with({ [RGB.R]: "Red", [RGB.G]: "Green", [RGB.B]: "Blue" }); return { value: rgbValue, label: label }; );
I guess the example could be done without lodash too: const fileTypesForSomeContext = $enum(FileTypes).getValues().filter( (fileType) =&gt; mapString(fileType).with({ [FileType.MDX]: true, [FileType.DBC]: true, [FileType.CSV]: false }) ); I'm just in the habit of using lodash.
That and your other example make sense, and I can better see the need for such a lib if you're doing code generation of enums. I imagine you could write something similar to the above (that I believe offers many of the same benefits, e.g. compile time warnings for missing cases, maintains types, throws on invalid enum so some runtime verification) with something like: // general util function assertNever(n: never) { throw new Error(`Unexpected value: ${n}`); } declare const fileTypesArr: FileType[]; // assumed generated // doesn't actually need to be a type guard in this specific code function isValidFileForContext(file: FileType): file is FileType { switch (file) { case FileType.MDX: return true; case FileType.DBC: return true; case FileType.CSV: return false; default: throw assertNever(file); } } const fileTypesForSomeContext = fileTypesArr.filter(isValidFileForContext); But I'm kind of just thinking aloud. The above is very similar to your approach and likely shares the same ideas for how some of your libs are impl'd -- mine certainly has a bit more boilerplate and requires more code generation. It does carry a bit less runtime cost though (assuming file types array can be generated in parallel to generation of the enum itself, this only carries one O(n) operation with no additional objects created and only 1 call added to the stack [well, called N times]). I do also recognize that assuming the filetype array is generated is kind of cheating, since that's the only use of the lib in this example. I think overall you're right that it's all about balancing all the factors: boilerplate, dev experience, runtime, type safety, etc. I just almost always try to optimize for runtime since that's the only one that makes it into the final product. But I can see that the minor (one time) cost of a slightly deeper call stack and a few more objects created might be worth the better dev experience. It seems like you're thought this through well!
I could optimize a bit more if I changed methods like getKeys(), getValues(), etc, to just return a reference to a cached array, but then there's be no protection against data corruption from bad code that mis-uses the result. My background is ~13 years of working on large, complex, long-lived front-end code bases with teams of 5-10 developers of varying skill levels. I'm always looking for ways to simplify solutions in a way that there is a single common pattern to follow that is correct for many variations of a situation, using utilities/helpers/frameworks that self-enforce correct usage, with minimal need to remember how to setup boilerplate. Reduced training effort (to teach different variations of approaches for different situations), increased productivity, easier code reviews, higher confidence in code correctness, reduced chance of bugs, and ease of refactoring with confidence in the future are almost always worth a small hit in performance and memory usage to me in general UI code. If evidence of a run-time performance issue is discovered or presents itself, then I look at removing layers of convenience to optimize as minimally as necessary.
I’ve used it in some very large projects - it has the benefit that it forces you to really consider if any is truly appropriate, and if so you must put a tslint disabling comment. We had a code review rule that for every tslint disable there had to be a comment justifying it. Nearly every time you will find a more appropriate way to type the field, sometimes with a generic, sometimes with a new interface etc
For sure, I definitely agree with your points there. Though to play devils advocate, there's also something to be said for using native solutions whenever possible (maintenance burden, onboarding of new developers, generally more performant). The codebases I work with tend to run into perf bottlenecks if you aren't very careful (mostly large-scale data analytics and processing), which is why I may be optimizing bit more for perf. I have only been in industry for ~4 years though, so defer to your experience :)
I've been using https://www.npmjs.com/package/enum-values. You may wish to include this in your other projects list. I haven't spent time reading your readme yet but might switch dependencies if it offers better type support.
We don’t have this rule on by default, but we do require everything to be typed, and generally in code review you need to justify using an any. We also enforce most of the TS strictness as well, while initially a pain, it makes working with the code (and less issues at runtime with the strictness) much easier.
Thanks. It's always interesting to look at how other people solved similar problems. The main differences I see between my solution and "enum-values" in their overlapping functionality are: * enum-values does not strictly type the keys it returns. They are just string. ts-enum-util returns strictly typed keys that are string literal union types of the possible keys of the enum. * enum-values does not appear to infer the type of the enum for well-typed lists of values and key/value pairs. It requires you to specify the desired enum type as a type param when calling the method (am I correct?). ts-enum-util infers types from params of overloaded/generic methods so everything "just works" and is properly typed without any hints from the developer. * enum-values builds its result from scratch every time you call one of its methods. ts-enum-util caches some data the first time you use it for a particular enum, then does minimal lookups and defensive copying (to prevent corruption of data) each time you use it on the same enum afterward. * enum-values returns null if a reverse key lookup fails ([yuck!](https://basarat.gitbooks.io/typescript/docs/tips/null.html)). ts-enum-util gives you the option of handling a failed lookup by throwing an error, returning undefined, returning any other valid key for the enum (well-typed), or returning any arbitrary string. ts-enum-util also has additional functionality that you'll learn about when you read the README. Please let me know if you find anything confusing about the README and I will work to improve it. Thanks for looking :) 
Version 0.2.0 is now released with these changes: https://github.com/UselessPickles/ts-enum-util/releases/tag/v0.2.0
For sure for sure -- I think we're on the same page about a lot of this :) The only feedback I would have about actual code is: - I'm not sure if this is fixed yet, but I believe maps indexed by non-`string | number` (like your `instancesCache`) have O(n) lookup. Certainly the es6-map (and set) polyfills I used in the past had this issue, which totally defeated the purpose of using a map/set. If you can index with a representative string you can avoid this and probably remove the dependence on `Map` in general. - If you're going to use `Symbol.iterator` and thus rely on `Symbol`, might as well also use `Symbol.toStringTag` as well in lieu of `toString()`. - re: `getValue` vs `getValueOrThrow` and likewise for keys: personally I'd prefer the succinctness of `getValue`, since I'll look at the type definition to determine the exact behavior anyway. I don't think you need any kind of `getValueOrDefault` since that's pretty easy to handle as a consumer (`const value = foo.hasKey(bar) ? foo.getValue(bar) : DEFAULT` -- or via the less elegant catching); - Do you need to be able to index into your enums directly? I can imagine some scenarios, but for the most part the lib seems useful for performing operations over all values in the enum. If you don't, you could remove a fair amount of the upfront cost (no longer need to sort keyset, no longer have to associate key/val pairs with an index on construction).
* I'll look into performance of native and polyfill maps. The only way to guarantee a unique key, though, would be to incorporate every key/value pair from the enum object into the key. Calculating this key would be expensive. * I was using `Symbol.toStringTag` but was concerned that `toString` would not behave correctly in browsers that don't support it. Implementing `toString` guarantees correct behavior. A browser/environment that doesn't support `Symbol.iterator`, OTOH, will simply not natively support iterating the EnumWrapper. Either the code will be compiled to a target that causes the TypeScript to disallow the use of EnumWrapper in contexts that would use the iterator, or it will have been compiled with the `downlevelIteration` and will be transpiled to array-based code (thanks to EnumWrapper being ArrayLike). * I went the opposite direction. I prefer clarity/unambiguity when naming methods that do similar things with slight differences. People often make assumptions based on names rather than reading documentation. I also think its worth supporting both options to either throw on failure or return a default value (undefined by default, and supporting a param for the default value is no more complex). I now have method names that tell you exactly what they do (both for choosing which one to call, and code readability later on), you can choose which behavior you want, and IDE autocomplete will help you so you don't have to type the full name. * The ability to index the enum wrapper directly is what makes it usable as a param to various methods that accept ArrayLike values (lodash, for example). Even without the index signature, I still want to guarantee the order of iteration for the `forEach` and `map` methods, order of the returned lists of keys, values, etc. I'm also using the pairs stored at indexes as my data source for implementing several methods (see implementation of entries, values, getKeys, getValues, getEntries). If I get rid of the data there, I'll have to store it somewhere else.
Clarification on the decision to keep both `getValueOrThrow` and `getValueOrDefault`... There are valid use cases where you assume the lookup should always succeed, and that if it fails, there's a code bug somewhere. For these situations, `getValueOrThrow` is very convenient because the return type is exactly the enum type without the possibility of being `undefined`. The result can be passed to something that doesn't accept undefined, but you still have peace of mind that if there is a bug that leads to an invalid lookup, an error with a clear message will be thrown to help you quickly track down the cause. Without the version that throws an error, it would be up to the developer to implement the throwing of an error if `getValue` returns `undefined` (which is unlikely to be consistent and contain clear information about what was encountered vs what was expected). In other situations, you assume that lookups may fail, and that it is "normal" to happen. In these cases, you want the result to be possibly `undefined` so you are forced to check for undefined and implement some behavior. It is simple enough to support optional defaulting to values other than `undefined` via an optional param, so why not include support for that to improve code readability? Without a version of the method that returns `undefined` on failure, you need to wrap calls with `try/catch` blocks to handle the error and default to `undefined` or some other value, or must check `hasKey` before calling `getValue` as you did in your example. With a simple name `getValue`, it's not clear that it may throw an error, and there's nothing the compiler can do to ensure that you think about whether you should be checking `hasKey` before calling `getValue` or catching/handling the error. You may not discover that you forgot to check `hasKey` in one place until an edge case happens in production and an uncaught error is thrown. The name `getValueOrThrow`makes it immediately clear that it may throw an error both while writing the code initially, and while reading the code later. I also think `getValueOrDefault` is much more readable: `const value = foo.getValueOrDefault(DEFAULT);` vs `const value = foo.hasKey(bar) ? foo.getValue(bar) : DEFAULT;` 
For quicker cache lookups, the best I thought of so far is to use an obscure property name (like `__EnumWrapper_cache_key`) to store a unique number on each enum object, using `Object.defineProperty` to define it as not enumerable, which I can then read next time to use as my cache key. Flaws with this are: * It now depends on Object.defineProperty * It could break usages of the object where `Object.getOwnPropertyNames` is used, because my secret cache key will be found. I really wish object instances had a unique address/id in javascript.
Probably the most reliable solution is to use `JSON.stringify(enumObj)` to generate the cache key. I should do some testing of how quick that is compared to using native and polyfilled `Map`
I'd say if you can get away with it (and you can, if you put in the effort), then yes -- it's very helpful. You should at _least_ be using the `noImpicitAny` typescript compiler option, though.
Yeah, it is a pain that you can't get actual memory addresses -- likely why the polyfills can't do better than linear.
I like this advice. Sensible, incremental.
I agree there are valid arguments for both specs, I just generally prefer starting as lean as possible and only adding additional ways to accomplish the same task if it's heavily requested. The practical reason is that it ends up with smaller objects (more performant, but also less to understand about the lib so easier for new consumers). I don't think libraries have to solve every possible usage out of the box, but should tackle what they do well and allow themselves to be extended as much as possible. Consumers can write small helpers/wrappers to adapt libs to their needs. In terms of this specific api, it still feels most natural to me either just return the value or `undefined` (might not be good if `undefined` is a valid value type), or the value or throw, but not expose both. e.g. native js `Map` has only one `get`, which isn't even fully expressive by itself (since you can `set` to undefined, the api is ambiguous). This never felt like a burden to me, since it was still possible to handle `undefined` values via `has` and `get`. But these are mostly just small differences of opinion by this point -- I would be fine with a lib with either behavior (even if I have a preference).
More thinking aloud from me: * I realized after going to bed last night that I was incorrect in stating that I "need" the indexed entries on t EnumWrapper to implement other method. I could implement them in terms of the `this.keySet` and `this.enumObj`. * Looks like I can get a performance boost in `getKeys`, `getValues` and `getEntries` by using plain for loop instead of `Array.prototype.map`. This optimization is only possible if I have the data stored in an indexed manner. Otherwise I'd be limited to using `Set.prototype.forEach` to iterate the key set. For performance concerns about cached lookups in the `instancesCache`, it's important to remember the context: * These cache lookups should be infrequent (not inside loops, etc). * The number of items cached will be relatively small. This is not data processing. It's wrappers around static enums that are defined at development time in the project. And it only will contain the number of enums that are actually explicitly wrapped by `ts-enum-util`. I'd be shocked if anyone had a project where they wanted to use the features of `ts-enum-util` on more than 50 different enums. The worst case O(n) lookup into `Map` at 50 items is still very quick.
Hi ! I'm the author of the article. In the article I title "TypeScript give you a taste of future JavaScript, with typings." TypeScript if before all about typings, and ES6 compat transpiling features. There is no plans to target wasm in short or event long future ;) Though, Babel offers a better transpilation features-set with stage-x and tc39 proposals support. You point about standards are also valid for JavaScript (ESlint can force === too.)
These are useful additions, but what I really want is a helper for building the unions: ``` Import * as Actions from './actions' type ActionType = Values&lt;Actions&gt; ```
Got super excited about conditional types, and then really confused that I missed the 2.8 release. Looks like I didn't... still only 28% complete. This will be a great release though once it's done!
New release with some optimizations: https://github.com/UselessPickles/ts-enum-util/releases/tag/v0.2.2 Thanks for pushing me to think about performance :). Although, you'll probably be unhappy that I'm now storing another array. But I did also simplify a Set to a plain array, so maybe that makes up for it?
Anything not on YouTube? I cannot stand programming videos.
Yeah really makes no sense and feels a bit overdesigned. Why not simply put the path in a string? I guess if we get something like null propagation in TS/Js it would be redundant :)
Understood. (The videos are short and to the point BTW.) Other than what you see on the readme. There's plenty of examples in the tests and in the code. It really depends on what you're looking for: --- System/Linq: https://github.com/electricessence/TypeScript.NET/blob/master/source/System.Linq/Linq.ts If you are familliar with Linq, then you'll know what to expect from System.Linq. --- System/Time: https://github.com/electricessence/TypeScript.NET/tree/master/source/System/Time If you are looking for immutable time quantities like `DateTime` or `TimeSpan`. With much more than even the .NET Framework provides: `ClockTime`, `TimeQuantity`, `TimeUnit`, `TimeUnitValue` and some compile-time constants. --- System/Collections: https://github.com/electricessence/TypeScript.NET/tree/master/source/System/Collections `Queue&lt;T&gt;`, `LazyList&lt;T&gt;`, `HashSet&lt;T&gt;`, `IEnumerable&lt;T&gt;`to name a few. Way too many to say in total. The important part is that they are all `IEnumerable&lt;T&gt;` compatible and all collections inheriting from `CollectionBase&lt;T&gt;` expose a `.linq` and `.linqAsync` property where `.linqAsync` is lazy loaded when in a web environment. This was the big deal for this release. These two already existed, but it was very complicated to manage the lazy dependencies. Thanks to some help, I figured out it didn't need to be complicated. The Linq library is HUGE. So having it be a required dependency for all collections, simply wasn't acceptable. And importing it every time manually to use something like var query = Enumerable(myQueue).where(e=&gt;e!=null).toArray(); wasn't as nice as var query = myQueue.linq.where(e=&gt;e!=null).toArray(); (especially when writing for NodeJS). --- System/Promises: https://github.com/electricessence/TypeScript.NET/tree/master/source/System/Promises Although for most people this would be considered obsolete, it has some useful features while still maintaining A+ standards. There are synchronous methods available on these promises that allow for synchronous resolution when desired. It also provides a `LazyPromise` which is great for defining a cached API or something that you want only to resolve if a `.then` is used. It might be worth a quick browse of the tests: https://github.com/electricessence/TypeScript.NET/blob/master/tests/mocha/System/Promises/Promise.ts --- System/Threading: https://github.com/electricessence/TypeScript.NET/tree/master/source/System/Threading A lot of usefulness here that helps in deferring tasks and System/Threading/Tasks/Parallel.ts contains a promise based parallel library. --- System/Uri: https://github.com/electricessence/TypeScript.NET/tree/master/source/System/Uri Some useful Uri and QueryString building/parsing utilities. --- There's a lot more. Nothing goes to waste. Many of these classes rely on each or other classes contained within. I hope that helps. 
More interesting performance results. I was considering "optimizing" my reverse key lookup to not use a Map, but instead use a plain JS Object and build a string key for each lookup as `((typeof value) + value)` (necessary to avoid collisions between numeric and string values in a mixed enum). Performance tests reveal that sticking with Map for this is the right decision even when a polyfill is used, at least for the fairly small number of entries that are likely to exist in enums. https://jsperf.com/polyfill-map-vs-es6-map-vs-object-with-string-key
If you feel like there's too much in one file, then by all means split it as you see fit. I don't like prescribing hard rules since the answer to just about every question is "it depends". The structure that I propose is pretty flexible so you should be able to adapt to to what you see fit. Not sure if you're falling into this trap, but also I'd caution against thinking a file is "too big". A file is never _too big_, but a file can have _too many concerns_. If all the content in a file is tightly related or coupled, then IMO it's organized correctly. :) I'll try to touch on selectors in another article as soon as I have time to write up something, but the basic concept I've been using is to create selectors at the state tree depth for all the context they need. For example, if we have a state tree like: { foos: { bar: 'baz', qux: 'quux' }, fruit: 'lemon' } A selector `selectBar` only needs to know about the state from the `bar` level, so the logic may be in the `/bar` feature. Whereas the `selectLemonBar` needs state from the root level, so the logic may be at the root level `/store`. At the `/foo` level, you can import the `selectBar` selector and wrap it before exporting with something like: const wrapBarSelector = (barSelector) =&gt; (state) =&gt; barSelector(state.bar) I was ultra-brief here since I don't have time to write a full thing but I hope this points you in the general direction. 
Another thought on supporting both `getValueOrThrow` and `getValueOrDefault` vs implementing only one and let the user check for validity before looking up: I can optimize both of the methods to perform only one lookup each to perform both the validation of the key and retrieving the value. If I only implement one, then the end user will need to cause 2 lookups in the map to perform one of the two approaches in terms of the other.
Nice, thanks for the in-depth research, haha. I agree that map perf is fine for the intended use of this lib, and super optimizing on perf is probably overkill. We only ran into linear lookup issues for sets when rendering a map with 10s to 100s of thousands of points for which we needed to check containment of in a set. In general regarding object size: I admittedly don't know much about how tree shaking works in terms of how to author a lib that supports it well, so I dunno if e.g. its possible to tree shake parts of objects that aren't used (vs shaking functions that act on objects that aren't referenced). But that might be another area to explore if you haven't. Allows the possibility of authoring really big libs without actually bloating the final dist size.
But there's another problem, isn't there? Node has a [ton of builtin methods](https://nodejs.org/dist/latest-v8.x/docs/api/) and so does [JS](https://developer.mozilla.org/en-US/docs/Web/API). WebAssembly has neither as far as I'm aware. You might say it's not a big deal because now you can compile in whatever library you want from whatever language you want. But now we're bloating our apps with a mishmash of libs and APIs, with no standards and no shared code, and reinventing all these things we already had. Furthermore, WASM can't access the DOM so..... it's only real use as far as I can see is for crunching numbers. You could use it to process images, do some hard math, or maybe run a physics simulation... but for every day frontend webdev it strikes me as rather useless altogether, even if it becomes easy to use via TS+Webpack support.
On this article, if you wanted to compile ts to wasm you'd also have to compile most of the javascript runtime. Doing so you lose the benefits for optimization because javascript is by its nature dynamic. 
I found that rule has prompted me to become a better TS developer. I encountered it the same way as you did, using that starter and initially had many */tslint:disable-line no-any */ in my code. As I gained a better understanding of the available types I gradually removed 99% of them.
Okay, very cool indeed. Thank you kindly. We'd have to restructure our action creators to be in objects. Unless we can do: import * as actionCreators from "./action-creators"; type Action = ReturnType&lt;typeof actionCreators[keyof typeof actionCreators]&gt;;
Inevitably someone in your team will complain about losing the runtime guarantees. But proptypes don't do anything in a production build anyway, and the significantly better type system and build time guarantees far outweigh those benefits. And for the love of all that is holy, don't use proptypes AND TS types at the same time.
How does this compare to chroma.js + typings?
I've never heard of chroma.js before, but it looks like this library is all about colour manipulations and different colour models there are for assistance purposes. My aim is to create a library to convert colours in different colour models and add support for other colour related things like colour spaces and profiles.
What woud be a good usecase for that?
Adding annotations. In my case I wanted an ability where the user was able to attach some annotations to a segment of a text.
TypeScript is ideal for large and enduring codebases because it frees you from having to keep all the type information in your head. I only really consider writing plain JS anymore when it's a small throwaway script.
Huh, I always thought WeakMaps/Sets were just for holding possibly gc'd object refs, but I never really understood their value add. Just researched WeakMap specifics more. Do you understand what it is about WeakMaps that make them viable for private data vs regular Maps? In the example from the docs: const privates = new WeakMap(); function Public() { const me = { // Private data goes here }; privates.set(this, me); } Public.prototype.method = function() { const me = privates.get(this); // Do stuff with private data in `me`... }; module.exports = Public; Ignoring runtime for a second, why would this pattern not work with a regular `Map`? An outsider would still need a reference to the map containing the data (equivalent to `privates` here), and the object reference of the object's privates they are trying to look into -- if you have those two references you should also be able to access the value via `WeakMap` as well I would think...
Although now I'm confusing myself again... `this` in a function wouldn't refer to its position in the call stack, it would just be whatever context is bound to the function when it's called. It's been a long day, I'll think about this again tomorrow...
Advertisement for a paid course that is definitely not the 110 € worth.
Oh, sounds useful
*Unless* when React forces you to, such as when using the context API :p Bit unfortunate for us TypeScript users, but hey.
do you know if the new context api they're introducing require it?
This is a problem that would be solved by named parameters, which I feel that TypeScript would really benefit from. https://github.com/Microsoft/TypeScript/issues/467
In the example you posted, `this` is a reference to an instance of the `Public` class; not a reference to the function that falls off the stack. The reason that the contents of the `privates` are not accessible to anyone else is because `privates` is not exported from the module. General implementation details are that each `WeakMap` instance generates its own random and unique "key", which it uses to. The `WeakMap` does not maintain any data structure of keys/values, but instead uses it's unique "key" to store data directly onto the objects that are passed in as keys to the `WeakMap`. The data is stored on the object in a way that is not enumerable or otherwise publicly discoverable. Only that instance of the `WeakMap` knows how to access the data on objects. This implementation detail both gives the `WeakMap` O(1) lookups, and allows the data to be garbage collected along with the object key.
That's one aspect of it, but having strong types for each domain type goes beyond just parameter naming. For instance, a DateOfBirth type could ensure it's a date in the past. A phone number type could ensure it's in a valid format via regex. Having it enforced via types also helps ensure it's treated correctly throughout the entire call stack. I'm all for named parameter support, I just don't believe it alone can cover the benefits of specific types for domain-specific versions of existing native types.
I'd probably do this with branding and identity functions, to avoid the extra runtime overhead of constructing classes. Something like this: function FirstName(v: string) {return v as string &amp; {__firstName: any}} const Jerome = new Author( FirstName('Jerome'), ... ```
https://github.com/facebook/react/pull/11818
Hm, that still doesn't quite make sense to me. Consider this example: let privates = { // private data goes here }; function Public() { // stuff with 'privates' } module.exports = Public; Here, `privates` is again not exported from the module, so why is this not an acceptable pattern? That's maybe the crux of my misunderstanding. If the answer is something like "technically you can access `privates` via `module.getKnownProperties`" (or some function like that -- or in general if there is any way to still access these non-exported members), then my followup would by why accessing the WeakMap in a similar way not be possible? I did misunderstand the syntax, since I never create classes this way, so was thinking of `Public` as just being a bare function (and thus having whatever `this` context you bound to the function). Makes more sense if you create a `new Public()`, though the above still doesn't make sense to me.
I think I may just be misinterpreting the value prop of `WeakMap` w.r.t. privacy in these examples. Based on the linked article (http://fitzgeraldnick.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html), it seems like the author thinks there are multiple ways to get truly private data (though some like private symbols, as they note, aren't truly private), but that `WeakMap` are the only way to do so in a memory and space-efficient manner. Which makes more sense to me, since they're the only method that can generally map from objects efficiently and don't prevent GC on values so don't end up leaking. So the real value add for `WeakMap` w.r.t. private data is that they're efficient, not that they enforce privacy better than other constructs.
syntactically, you're doing the exact same thing as: element.addEventListener('click', () =&gt; Promise.resolve(doSomeStuff()) }) Babel transpiles this to something a little different using its *regeneratorRuntime* function, but you are correct. This function will execute as expected. You are also correct that if you were using multiple await statements, the promises would execute sequentially, like a queue. The one thing it seems you might be confused about: async functions don't *halt execution* of the main thread. Consider: event.addEventListener('click', async () =&gt; { await oneSecondDelay() await twoSecondDelay() console.log('you clicked something 3 seconds ago') }) Yes, its true that the log message wont appear for three seconds, but the rest of your events will still be fired and the page wont freeze. Click that button three times, and then roughly three seconds later you'll get three log messages.
In this example, `privates' is a single "static" object. That's fine for creating "global" private data within the module, but it is not equivalent to using a `WeakMap`, and there's also no reason to wrap such data in an object. Using a `WeakMap` allows you to attach different data to each instance of the object/class - private per-instance data.
It's really a combination of all its benefits: * Efficient O(1) lookups. * Doesn't prevent the key object from being garbage collected. * Value data is automatically garbage collected along with the key object. * It provides a way to add truly private data to instances of objects.
So in the readme is a quote: &gt; An int on its own is just a scalar with no meaning. With an object, even a small one, you are giving both the compiler and the programmer additional information about what the value is and why it is being used. &gt; ‐ Jeff Bay, Object Calisthenics But this doesn't give the compiler additional information because Typescript uses structural typing. With this I can still write class SafeHtml extends TinyTypeOf&lt;string&gt;() {} class UnsafeHtml extends TinyTypeOf&lt;string&gt;() {} const unsafe = new UnsafeHtml('&lt;image /&gt;'); const safe: SafeHtml = unsafe; and get no Error. The only benefit I can see is improved intelisense in vscode because VSCode resolves type aliases. Other than that it's just some runtime type checking. Adding domain context is already possible with type aliases. I'm probably missing a major point here though?
But the first 3 points make it practical to use for the 4th point. Otherwise, lookups are too inefficient to be used in every method to access private data, memory needs to be separately managed, etc. Mozilla has a "Why WeakMap?" writeup: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap#Why_WeakMap
You're not. I think the point that was missed was that nominal ideas don't translate to a structural world.
there's nothing wrong with it as you mentioned the only catch is it doesn't wait for anything but it's still useful for allowing you to use the "await" keyword to order the sequence of things that happen inside the callback.
I'm sure a library for this already exists, but a quick google didn't turn up anything so I implemented something simple. Thought I'd share in case it of any use to anyone :)
Looks like the author forgot about "branding" or any of these alternatives. https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html
Nope, depends on your style preference. In my example, I assume that the function will be inlined by a minifier or, at the very least, the VM. My style allows for the possibility of validation logic, too. You could even conditionally compile-out the validations for production builds.
Right, but TS is *almost* strongly typed, and if you look at the libraries that the article linked to, those are stricter subsets of TS. So no, you don't have to add runtimes for any of the dynamic type crap.
We pass a lot of paths in our code, and we have 3 types (so far) that are related to that; `Path`, `WindowsPath` and `PosixPath`. This allows us to force everything through a normalization function that transforms windows/linux into a commonly formatted string, and then all our methods that deal with pathing use that. Basically our type system becomes a test that you're passing strings that are independent of platforms. It would be extremely hard to fix properly with just strings and named parameters. Because strings can be anything.
That's a valid scenario, but I feel that's different than the method outlined in this post. I don't believe your usage of classes is outside of the norm. This post has you create a different type for first names and last names that won't validate or normalize differently. This post is about replacing all arguments in public methods with "tiny types", regardless of normalization or validation.
Typescript is JavaScript. Therefore it supports mutable types, virtual dispatch, polymorphism etc. You would essentially be creating a new language similar to typescript but optimized for byte code generation with none of the js features. You've got that, it's c#. 
I think what you'll find is that the native apis you refer to will become wasm based apis. Some are written in c++ today some is js btw. 
You should still wrap the creation in a function. The usage of the `as`-operator should be avoided as much as possible, and encapsulated as much as possible.
This is amazing. 
[This](https://github.com/gcanti/newtype-ts) implementation doesn't have any runtime and I think it's a better alternative.
I kinda agree, but in this case it's not a big deal because you're branding primitives. It's not like you're doing `12 as any as FirstName`
It's having one `as` in the create function versus having many `as` wherever you create an instance. I'd rather have less `as` in my code.
OP is a little confused about what dependency injection is. class Foobar { constructor\(foo: Foo, bar: Bar\) { } } This is in a DI style. Opposed to: class Foobar { constructor\(\) { this.foo = new Foo\(\); this.bar = new Bar\(\); } } The following code is just manual DI, but is still DI. DI does not require automated injection. const foobar = new Foobar\(new Foo\(\), new Bar\(new Foo\(\)\)\);
Consider this: https://github.com/dslomov/typed-objects-es7
Thank you very much for taking the trouble to share that link. Have a great day/night whatever your timezone!
One other question about this - why the `any` type for the brand property? I would think `undefined` or `never` might be safer.
&gt; Is there a specific example of how those would be safer? Only in some edge case where someone tries to use it, not understanding it's a brand. At least `never` would indicate not to use it, or `undefined` would be a more correct representation of what to expect. The `keyof` example is a case I hadn't thought of... I'm asking because branding can be a useful thing and I've seen a few different implementations (some using enum) but I haven't read a good article on best practices for implementing it.
[removed]
There's only one isomorphism [instance](https://github.com/gcanti/newtype-ts/blob/6eb0e332a2e229aba27c5942a1fa29e981045616/src/index.ts#L21) which is re-utilized. I just added a new section with a [benchmark](https://github.com/gcanti/newtype-ts/tree/6eb0e332a2e229aba27c5942a1fa29e981045616#performance)
Yes my mistake! I'd list what VM you use though, normally V8 is way ahead of anything else in terms of optimisations. Safari was 30% slower for me on https://jsperf.com/iso-random-test (assuming that's an accurate benchmark for whats going on).
Hi TypeScript devs! I converted the best TypeScript snippets on Stack Overflow Documentation to create this free TypeScript PDF book, any suggestions for improvements are appreciated as it will help me improve this PDF book; which will then benefit everyone 😊
Right. The new version wouldn't be a superset of JS anymore. It might be a bit easier to learn than jumping to C# though. I do miss C#... haven't really been able to use it since I moved to web dev. If I could compile C# to both WASM and JS it might be viable.
Yes. I have in mind integration with conversation privuders, however need a bit more time.
Great. Thanks for the quick reply. At work we used botkit and the Watson provided middleware. Will try to take a look at your code and see if I can give some hand. Thanks for the quick reply
Does TypeWiz work for higher order arguments like objects and functions, or will it only give them the type `object` or `Funtion`?
This looks great. Did you consider using a typed tuple for the parameter names instead of variable arguments? I'm assuming it's possible (but I don't know). I'm curious as to whether the ability to index into a tuple at the type level would give a nice type-encoding of this. From a caller's point of view I think the vargs would be nicer.
Currently, it will give `f` a type of Function. Though, if you have some ideas how to implement better support for higher order arguments - feel free to open an issue on github and we can discuss them: https://github.com/urish/typewiz/issues/new
The thing is, I'm not too experienced with TS to know if it's TS or React + TS. It's things like: window.fetch = function (url, opts) { return new Promise((resolve, reject) =&gt; { if (url &amp; url.endsWith('users/authenticate) { // code here } } } With TS freaking out because Property 'endsWith' does not exist on type 'Request' that stumps me. I've tried defining `url: string | undefined` but that's not it. I think this example isn't a React-specific issue though. That's just an example of things I scratch my head at.
Did you import the right `Request`? I've seen that issue before when writing express middleware.
This is amazing.
It's ts. For that one, you might just need to include the es2015 lib in your compilerOptions in tsconfig.json. It's better than rolling your own polyfill. Spend a bit of time understanding tsconfig options and the webpack setup.
Here's what my promises often look like lately: const checkToken: CheckToken = (email: string, token: string): Promise&lt;boolean&gt; =&gt; new Promise((resolve: FunBoolean): boolean =&gt; client.hget( `vim.network:email:${ email }`, 'token', (err: Error, reply: string): void =&gt; resolve(reply === token) ) ) Where I'll use an interface for my function: interface CheckToken { (email: string, token: string): Promise&lt;boolean&gt; } And then another interface for my common anonymous functions. Eg. I'm using `Fun` for functions that just do a bit of work with no return: export interface Fun { (): void } And a FunBoolean just takes a boolean as a parameter: export interface FunBoolean { (res: boolean): void }
Have it as specific as possible, that will prevent you from gotchas and increases your code quality. Did you know that these two functions are evaluated differently by the compiler, and that one is better than the other? function myFunction1(): ISomeObject { const result = { property1 = ..., property2 = ... }; return result; } function myFunction2(): ISomeObject { const result: ISomeObject = { property1 = ..., property2 = ... }; return result; }
Very subtle. *property1: ... =D So, you would agree with going on the overboard side with the type definitions throughout the code as required by the linter?
Very subtle. *property1: ... =D So, you would agree with going on the overboard side with the type definitions throughout the code as required by the linter? interface ISomeObject { property1: string property2: string } interface ISomeObjectFun { (): ISomeObject } const myFun3: ISomeObjectFun = (): ISomeObject =&gt; ( &lt;ISomeObject&gt;{ property1: 'a', property2: 'b' } )
&gt;This is super awful! Don't use casts! You're overriding the compilers type safety! If you ever add another non-optional property to your interface... Then the code will just compiler Ah, good to know (here I was, looking for a way to make the code more specific in an attempt at going overboard with specificity... yet specifying the type a third time actually makes it less specific.) When does casting most often pop up as a necessity? I've seeming had to use it when referring to something like a global window object, where I would extend the type of the window: const win: MainWindow = &lt;MainWindow&gt;window Not a good idea? Ever since the `const` keyword showed up, I've sort of taken to the look of seeing const abc = () =&gt; {} rather than function abc {}. I'll have to rethink that approach.
You have only one `&amp;` in your code hence the error : `url &amp;&amp; url.endsWith('users/authenticate)) for starters then, you should type your url in your function : window.fetch = function (url: string | undefined, opts) { return new Promise((resolve, reject) =&gt; { if (url &amp;&amp; url.endsWith('users/authenticate)) { // code here } } } Typescript will type your url as a string when you check for its validity `if url` so if it passes it will allow you to call for a string method on it like `endswith`
Not a good idea either. Instead you should use type-guards (if necessary define yourself) and actually evaluate whether you have the type you expect, instead of just blindly assuming that it's the case.
Bad use case also. You're **assuming** that `parentElement` is of type `HTMLFormElement`, and you're completely omitting the possibility that it can be the `null` type (assuming you have strict mode enabled). Instead you can define a custom is-guard that verifies your `parentElement` is actually a `HTMLFormElement`: function isHtmlFormElement(value: HTMLElement | undefined | null): value is HTMLFormElement { return value &amp;&amp; 'elements' in value; }
Your fetch polyfill is broken, which is why you're seeing that error. Check the docs for window.fetch. Specifically, look at the docs for the first argument to fetch(). https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API What is the first argument? Turns out it can be either a string or a Request object. Your code is trying to call the `endsWith` method on something that might not have it. If you try to integrate with a library that I wrote, and my library tries to call `window.fetch({/* ... */})` you're going to have trouble. So TypeScript is protecting you. Here's an easy way to avoid that error: window.fetch = function (url, opts) { if(typeof url === 'string') { return new Promise((resolve, reject) =&gt; { if (url &amp; url.endsWith('users/authenticate) { // code here } } } else { throw "fetch() with object not implemented yet"; } } Hover over `url` with your mouse, both outside and inside the if() statement. Check the type information in the tooltip; this type info comes from TypeScript. Inside the if(), TypeScript knows that variable can only be a string. But outside, it might be a string or an object.
It's not TS; the first argument to fetch() can be a Request object, which doesn't have a `endsWith` method. Hence the error.
His error was actually because the first argument can be a request object, not necessarily a string. It's in the fetch spec.
I can see how invalid types could be filtered with conditionals to get away from the optionals, but how about something like: const targetEl: HTMLElement = e.currentTarget Where `Type 'EventTarget' is not assignable to type 'HTMLElement' What's the better way to scoot around this without the type cast hack of: const targetEl: HTMLElement = &lt;HTMLElement&gt;e.currentTarget
Interestingly, looking around on StackOverflow, I'm seeing a lot of guys using `&lt;any&gt;` and `&lt;TypeCastX&gt;`, when they run into these kinds issues, but I'm not buying it. They're sort of like superficial patches to seemingly allow the misuse of TypeScript. Do you have a TSLint profile that you prefer to use that takes mine out farther? (I'm still trying to wrap my head around what a type guard is, if it's more than a conditional preventing a branch of code by type... and how to apply that to get one type of say EventTarget to be accepted as my expected type of HTMLElement.)
This looks like a good argument for variadic generics in the language :)
I think you're right! I'll try this when I get back, thanks. Anyway, it's just hundred little things like these that make getting used to TypeScript a painful experience for me.
What are the differences?
You remove a lot of verbosity already if you remove the idiotic interfaces and don't use the conditional operator to return `true` or `false` and just use a fallback value. function isHTMLElement(value: EventTarget | null): value is HTMLElement { return value &amp;&amp; 'parentElement' in value || false } function isHTMLFormElement(value: EventTarget | null | undefined): value is HTMLFormElement { return value &amp;&amp; 'elements' in value || false; } I also removed some types and streamlined them. `HTMLElement | EventTarget` makes no sense because **every** `HTMLElement` is already an `EventTarget`. And you can implicitly check `HTMLFormElement` from an `EventTarget` already, no need to force to pass a `HTMLElement`. These functions would be wrapped in a utility library. const targetElement: EventTarget = e.currentTarget; if (isHTMLElement(targetElement)) { const formElement: HTMLElement | null = parentElement; if (isHTMLFormElement(formElement)) { // To something here } } And this can be nicely wrapped in a function too: `getFormElement(e)`. And again: You don't **have** to do this, when you **really really really know** that it's always of the type. But very often the developer will forget about this type-safety-override in the long run and things will change. It does add some verbosity, but it also adds type safety - which is the whole point of TypeScript.
Since TypeScript 1.6 "unknown" properties in object literals are marked as an error: https://github.com/Microsoft/TypeScript/issues/3755 In `function1` I create an object literal whose type is not specified. TypeScript will infer the type of the `result` variable by looking at the object literal, and the type will always match. That means there will **never** be any unknown properties. When then returning the object it will check if the type is compatible with the return type, where extra properties don't matter. It's compatible. In `function2` I explicitly declare the type of the variable `result`. So TypeScript can ensure the object literal I create does not have any unknown properties. When returning the result there's no further check, because the type is the same. This is a trivial example and the problem could be avoided by just returning the object literal directly, instead of using a temporary variable. But yeah.. It's an example. Imagine a slightly larger function with temporary variables and you hopefully see the benefit.
In this case, TS is teaching a philosophical lesson. (I'll try not to sound too preachy; I learned the same exact lesson not too long ago) Why expose your fetch function on the window object when you're not using it as a polyfill? If you only need to pass it strings, never request objects, then that implies you only intend to use it internally. Putting an incomplete polyfill into the ambient environment is asking for trouble. Instead, why not expose it as a normal module export? Anywhere you need it, just import it. TS will even write the import statements for you. Add some JSDoc to explain the intent. Everyone using it will know that you intend to support a subset of the fetch API. Explain that when window.fetch is available, you'll internally delegate to that. (At least I assume that's what you'll be doing). TS will show this documentation in a tooltip for anyone else using it. Good software design is all about keeping things simple, predictable, without nasty surprises. TS supports that, so you'll have a much better time of you embrace that philosophy. Post some other specific code examples; happy to help explain more. If you're patient, there are also super-smart folks on the ##typescript IRC channel.
It would be nice to have a vs-code plugin for that with quick fix suggestions.
https://github.com/piotrwitek/react-redux-typescript-guide
I made this to have something easier to use in my own projects than redux and thought I could share it. It's written in TypeScript, so it comes with typings. If you type your store, you will have type-safety and auto-completion where-ever you want to consume the state or when creating actions to update it. I know there've been many lately, but just thought to share. I was inspired by /u/drcmda 's [react-contextual](https://github.com/drcmda/react-contextual), but wanted something with type-safety. I'm open for any questions or suggestions :)
I understand and you’re right, I didn’t want to complicate things at the very start 
I'd just like to add that also typing, for me at least, isn't really about finding bugs. First and foremost typing is documentation. What about jsdoc? Well if you've ever worked on a large project before you know that over time comments get out of sync with code. With typescript the types are actually checked for correctness by the computer so the ability for documentation type to not match code type is almost eliminated. Further, a type system makes tests that only exist to verify the types of variables completely redundant and unnecessary. You don't have to check the shape of a given parameter because the type system does that for you
So instead of just biting the bullet, marking fields as optional in the language's idiomatic definition (i.e. adding the question-mark to the end of the property name), you went with the overly contrived solution of producing a bunch of new types that require an entire blog post to explain. Yikes.
If you use `undefined` instead of `null` (See [Null is bad](https://basarat.gitbooks.io/typescript/docs/tips/null.html)), then you can take advantage of the standard `Partial` type to convert a type to have all optional properties. If you want to make all properties capable of being undefined without being optional (still must explicitly provide a value for the properties), then you could use a mapped type like this: type Undefinable&lt;T&gt; = { [P in keyof T]: P | undefined; } 
You don't need to add types everywhere, because type inference. And you don't need to use debugger to check variable type, because IDE.
I use ts-loader with typechecking turned off and paired with thread-loader. I'm gonna add hard-source-plugin, too. I can't offer an educated comparison to at-loader, though.
[removed]
I just added hard-source because you mentioned it, went from a 44 second build time to 10 second build... Thanks!
Why without type checking? What's the point of writing TS code then?
I use at-loader and never had any problems with it. I have used ts-loader before and only ever run into a single minor issue (which might even be fixed now) at which point I switched. It really doesn't matter which one you choose.
The language service does typechecking. Webpack doesn't need to, but webpack should be really fast. I can look at the red squiggly underlines in my editor, run `tsc --noEmit`, or check my editor's "Problems" pane to get type info. There's also a webpack plugin that runs the typechecker forked in a separate process so it doesn't slow down the build. Lots of options. We also use TypeScript to transpile our non-TS code. It's a big project and we adopted TS gradually. Some older parts of our codebase haven't been touched in forever; moving them to TS would have minimal benefit. We don't have checkJs enabled.
I think that TypeScript finding 15% of the bugs is impressive. Of the random sample of bugs, many could be off-by-one errors or other issues a type system would not find.
Yes, the authors touch on this: "Evaluating static type systems against public bugs, which have survived testing and review, is conservative: it understates their effectiveness at detecting bugs during private development, not to mention their other benefits such as facilitating code search/completion and serving as documentation."
Finally a good way to handle defaultProps! This is awesome, thank you for sharing.
There is actually a third alternative which is my preferred solution. Babel 7 has a Typescript plugin which can be used to strip the types. This is a really nice solution if you need/want babel plugins with Typescript. No need to run two compilers. There are plenty of optional libary specific babel plugins which enhance the developer experience (styled-components-displayname, glamorous-displayname), runtime speed (polished) or reduce the bundle size (lodash, recharts). Babel 7 is still in beta although I haven't run into any problems once got it setup which can be quite challenge currently. More information http://artsy.github.io/blog/2017/11/27/Babel-7-and-TypeScript/
I switched from at- to ts- because the former was acting up with my SSR app’s hot reloading. In at-loader’s defense, I probably screwed something up, but the problem went away when I switched to ts.
I have managed to setup babel with typescript and karma tests so if you are interested you can check my repo: https://github.com/Xesenix/webpack-3-scaffold
See non-goal #6: https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals
Yeah that's not not the purpose of TypeScript. Check out TypeScript.Net or Linq.js, maybe they will give you some of what you're looking for (if es6 and lodash aren't cutting it)
Interesting, I've never seen this list of goals and non-goals.
Already aware of this , not the title of my post. Seems like i'm the only one who wants the augmented array Being able to replace it in tsconfig should be a feature. 
Are you refering to types that are declared in the types section of the tsconfig ? AFAI it only accepts *.d.ts not actual code 
what does an ArrayList do that a normal array doesn't?
I think you can simplify this by removing P1, P2, and P3. You don't need them. For example: ``` await failable(() =&gt; callTheFunction(arg1, arg2, arg3)); ``` The `failable` API doesn't need to worry about function arguments because it's easy to wrap the entire function call in a zero-argument arrow function. Otherwise this makes sense to me. You'll probably want to make a synchronous variant as well for performance, since `async` imposes a few extra cycles around the JS event loop, per the `Promise` spec.
Syntaxic sugar stuff. By no way I meant that ArrayList is superior , it's just sugar + productivity . You can achieve everything with the built in array it's just not as convenient, like ".splice".
 --require Thanks you fixed it.
Thank you, you are right, dammit. Now I feel dumb. How can I miss something that obvious? &gt; [...] synchronous variant as well Yes, already had that on my list. At least something. For type safe exceptions in general I found the article [here](https://medium.com/@dhruvrajvanshi/making-exceptions-type-safe-in-typescript-c4d200ee78e9). I think that should play really well together; or is a good extension to what I have right now. Again, thanks for your comment.
This is going to sound condescending but you need to shake the notion that TypeScript should adapt to your expectations and experience. I'm assuming you're new to JavaScript and a lot of things can seem alien but you should endeavour to adapt to it rather than try and adapt it to you. I speak as someone who went through the same thing. I wanted my good old `List&lt;T&gt;` from .Net, I wanted uppercase properties and methods names. So I did it, and wrapped whatever 'weird' JavaScript concepts I could. It was a pain, and in the end I wasn't using the language as intended, I was hiding the quirks rather than learning them. It was a big waste of time.
That looks like a great article, thanks for sharing.
Because of some issues with the loaders in older versions I've always used tsc to build to ES6&gt; JavaScript, then used that as the input to Webpack (and Babel et al). It works well enough, but the Babel 7 support is something I'll be looking to move to.
&gt;I'm assuming you're new to JavaScript I've been using JS since Backbone.js &gt;I was hiding the quirks rather than learning them That's not my point . I use React or Vue ? I go Vanilla JS. I use Angular ? I go typescript. But when I go typescript i want my ArrayList&lt;T&gt; and .add() simple as that. But it seems i'm the only one . 
Then my post is incorrect it should say "How to add hidden dependancy to override built in types" that's what I wanted . It should be supported by the language for "internal only apps" but it doesn't .
You're welcome! =)
Huge thanks for the replies @both! That looks really interesting. I will need a little more time to get my head around it. But it goes in the functional style direction if I'm not mistaken. I have only worked a bit with rxjava so far ( I know that rxjs exists, but skipped it for the first typescript project) , that means there is little to no experiences regarding this. I will probably read up more on monads, composition, currying and stuff like that. Seems to be worth it. And of course look at libraries like ramda and similar.
Ye these operations give you all the good stuff. They can also be defined in terms of `join`, though it probably works out less efficient. function map&lt;R, T&gt;(res: Result&lt;R&gt;, f: (succ: R) =&gt; T): Result&lt;T&gt; { return join(res, x =&gt; returnResult(f(x)), _ =&gt; res as Result&lt;T&gt;) } function bind&lt;R, T&gt;(res: Result&lt;R&gt;, f: (succ: R) =&gt; Result&lt;T&gt;): Result&lt;T&gt; { return join(res, f, _ =&gt; res as Result&lt;T&gt;) }
You don't need to understand monads to use these examples and it may well get in the way IMO (at least for starting with). I'd start with composition and currying, then just work through these examples.
Alright, thanks. Will do that. 
Yes, of course, you're right. I'll change it. Thank you! 
You are absolutely correct about that. I apologize profusely. Completely our mistake posting this to the wrong subs. I’ll have it removed Monday. 
By default Typescript will interpret a string literal to have type string. So the inferred type of `state` is `{ light: string }`. Add the type annotation in the definition of `state` and it should work state: State = { light: "off" }; 
You can also do `”off” as “off”` I believe. This is a more general workaround if you don’t have public access to the interface, but you want to supply a string enum. What this does is to tell TS to understand the string “off” as the type “off” rather than ‘a string that happens to have the word off in it’.
Oh, I see thanks. One other question if you don't mind – is it possible to do something like: import React, { Component } from 'react' in TypeScript? I have tried using both the `allowSyntheticDefaultImports` and the `esModuleInterop` settings, but I think they only help with the default `React` export. The `Component` seems to be getting set to `undefined`. 
Thanks a lot!
Sorry but I'm not familiar with the react library
No problem, thanks for the help!
Try import * as React, { Component } from "react"; Not 100% sure it will work.
Why make it hidden? Why not just an explicit dependency? Write the `ArrayList&lt;T&gt;` you want and put it on npm. IMO "hidden dependencies" sound like a bad idea.
This would probably have been a good time to use either Partial, Pick, or a mapped type that allows the fields to be undefined.
I see you like promises :)
But why won’t you just promise the whole object? Is there also an option to await or Promise.all all properties?
The point of allowSyntheticDefaultImports is to not have to do the * as React. 
You should report what is in `response` when all the promises are complete. Also you should probably list *why* you aren't rejecting the promise when any asset fails to load, but instead passing along a {loaded: false, src: "" } down the line. Basically, cover exceptional usage. Also maybe condense it into a single file since its &lt; 100 lines long, so I don't see what we're gaining by all this indirection.
Ah right thanks.
I think you should either throw or reject with a `TypeError` when a non-object is passed.
Just use lodash.
When I switched from JS to TS, I don't remember having to do anything special to use modules. I simply used exports and exports the same way I did before. I was already using Webpack so I was already using ES6 style importing and exporting. Would you say your issues are related to the concepts behind importing from other modules? Are you working on Node or browser code? You should be able to import from another module like this: a.ts const SOMETHING = 42; export default SOMETHING; b.ts import SOMETHING from './a'; console.log(`The constant is ${SOMETHING}.`);
You need to use a bundling step that understands modules and to set that in tsconfig's "module" setting. That could be UMD, AMD, SystemJS, CommonJS. For example Node.js uses CommonJS which utilizes the require() method to handle the linkage. Which are you using? And do you currently have a build tool set up to handle this, such as Webpack?
&gt; Static type checking won’t ever protect you against runtime errors. Uh. Yes it does. Any incorrect use of an API or use of an undeclared variable.
Safe to say there's an implicit "all" before "runtime errors". Of course, even then I think Elm writers would beg to differ. 
I switched around between es6 and AMD for the module setting in tsconfig. I don't have any build tools set up. Is there anything I need to do to "use" a bundling setup other than just setting it as the "module" setting in tsconfig?
Both weak and false. An impressive combo. 
It does :)
It's rejecting with a string, not a `TypeError`.
oh, got it.
Still I can't see a benefit over using one promise to await the whole object. Why?
Depends on where you are running the resulting code. If you are using this on a browser then you'll need to add a precompilation step to handle the bundling/communication between the modules. If running through Node.js you may be able to just use them. That setting in tsconfig is just inserting the boilerplate code necessary to modularize your code. The generated JS still needs some help in understanding it.
I already had 100% unit test coverage of run-time behavior, but an important part of this library is correct compile-time types. So last night I added a suite of [dtslint](https://github.com/Microsoft/dtslint) tests to verify compile time types :) Example tests for an enum with numeric values: https://github.com/UselessPickles/ts-enum-util/blob/master/type_tests/EnumWrapper-number.dtslint.ts
Thanks! Learning about Partial and mapped types was very helpful.
I was applying the term of 'pure' in the functional way (pure function) not for perfectly random. Indeed both are prng. What I meant was: once generated calling one of its methods always return the same value. No change of its internal state
Ah. That makes sense! 
What is your front end?
You need to read to some docs. You’re making it too difficult. Read the docs. Keep it simple stupid. 
I thought that was why we use this shit?
Does anyone use Vue? Seemed so hot. But now, not so much. This is a three day old post. 
That means you can’t teach. 
It’s not free?
Does this allow for a single dispatched action to be handled in multiple reducers? It seems like from the example that isn't the case. 
Maybe part of the error is that you're not supplying any type parameters. Change it to ...extends Component&lt;{}, {}&gt;... and see what happens.
So, in a TS world, the primary issue with Redux is that createStore needs to also return `connect` in addition to the store (or the store needs to provide a "getConnect" function. Everything else can then follow through from that since its relatively easy to infer mapStateToProp and other signatures the moment you have connect inferring type from the reducer passed to createStore. I only glanced over 2 minutes at the doc but Im having trouble figuring out how things happen here (there's a paragraph on that in the doc but it didnt quite click to me). Looks like the storeBuilder does a bit more here with a fluent interface, which I found interesting (as my naive idea would have been to just have a new createStore that returns a store/connect tuple). Thoughts?
One of Redux's primary architectural benefits is the N to N to N relationship between Components, Reducers and Actions. It's part of the tradeoffs (its extremely powerful for complex systems and allows for a lot of flexibility when refactoring or integrating new requirements that were not originally there, with minimal changes). The moment you make a hard assumption on tying them (the most common being making reducers and actions 1:1), it drastically simplify the problem space. At which point, Redux isn't that great of a solution anymore and a lot of the overhead is unwarranted (and other frameworks/patterns could do the same thing much easier/better).
I don't know if I completely get the argument about `connect`. The primary problem from my perspective is that we need type information on what actions can actually be dispatched. As far as I can tell all other typescript libraries for redux don't solve this. Flowing this type information through connect is then equivalent / not hard, it could can basically be done with the standard connect if only it had slightly stricter types (typeful-redux re-exports redux-react connect with (slightly) stricter types).
Ok, I see that not making a hard connection between actions and reducers does introduce additional flexibility. In my personal experience, this hasn't really been something that I have wanted to do (and have still found redux very useful, if only for separating application state in a clean way from components and improving testability). But I can see that making this hard connection can be a disadvantage. I'll think about this - thanks for pointing this out.
I don't agree here. Simplifying the problem space is useful (with redux) in that you can more easily understand how the application works. The upside of redux isn't N-N-N relationships, it's having a global store that you can easily reason about, with tooling around it to make it simple to solve issues as they arise. For me, hooking into actions someone creates for separate purposes is no better than events, which are hard to debug in general. I will say that it's a "nice to have" but I try to stay away from such situations as much as possible.
&gt; it's having a global store that you can easily reason about, with tooling around it to make it simple to solve issues as they arise Sorry, I probably explained myself wrong. As per your description: &gt; it's having a global store that you can easily reason about, with tooling around it to make it simple to solve issues as they arise You are entirely correct. I didn't mean that N to N to N was Redux' primary advantage taken in a vacuum. It's its primary benefit over the other mature solutions available in the ecosystem. There's a lot of ways to get a global store that's easy to reason about with great tooling. Redux is one of those, but it has some extra complexity and overhead. That extra overhead is because of the N-N-N tradeoff. If you give it up, some other global store framework/patterns are superior.
I'm not sure it counts but here is a simple, but complete example of a todomvc app with typeful-redux: https://github.com/paulkoerbitz/typeful-redux/tree/master/examples/todomvc
https://github.com/lapanti/ts-react-boilerplate &lt;- my personal boilerplate has full typings, it isn't too large, but I'm working towards enlarging it
It makes the generated types a bit nicer. Example: `typeof { a: number } &amp; { b: number } = { a: number } &amp; { b: number }` is displayed as such, `typeof Intersect&lt;{a: number }, { b: number }&gt; = { a: number, b: number}`.
Thanks, IndexState clears up a lot for me. What is routerState, imported from an npm module, though?
Yes! And I fully share your frustration: it was really hard to find documentation on typings, so a lot of it is guessing with the help of type definitions. Luckily, I have been through this, and am working on a production open source project that uses Redux and TypeScript in strict mode: https://gitlab.com/Flockademic/Flockademic/tree/dev/stacks/frontend The most comprehensive one to look at is probably [this component](https://gitlab.com/Flockademic/Flockademic/blob/dev/stacks/frontend/src/components/orcidButton/component.tsx) (`OrcidButton`), which both receives props from the state, callback props to dispatch, and is wrapped in React Router. If you have any questions, I might be able to answer them as well.
https://github.com/babel/babel/tree/master/packages/babel-preset-typescript
They are parts of the https://github.com/reactjs/react-router-redux &lt;- react-router-redux library, which are needed to get it working with redux. The type of routerState you can find here: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react-router-redux/v4/index.d.ts#L46
That still uses tsc under the hood and always will. Babel might be replacing bundlers, though.
That babel plugin is removing the TypeScript parts from the code, resulting in JavaScript. It does **not** type check, as it's said in the relevant package: https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-typescript &gt; Does not type-check its input. For that, you will need to install and set up TypeScript. 
No it won't. It doesn't do a lot of what tsc does.
Vue is HD-DVD.
Yes, but its dependency that handles everything for it does
Which one? I looked at all of them, and none has a reference to TypeScript.
You probably need to look at the definition for subscribe. 
Assuming your using an editor with language service integration, you can hover over all those values to see their types. You can also use the "go to declaration" shortcut to jump to where they're declared so you can see all the relevant type information. For example, in VSCode, put your text cursor over `subscribe` and hit F12.
Small nitpick: you should use `PromiseLike` for your input types instead of `Promise`. `PromiseLike` is the minimum interface for a value to be considered a `Promise`, whereas `Promise` is the full `Promise` including helper methods that are not technically required for Promises to be awaited. Also, I noticed that type inference of the returned object assumes all properties are `any`. I think this can be fixed with conditional types once TS2.8 is released.
Agreed. Try subscribe&lt;string&gt;((data) =&gt; ...)
What line and column is the compilation error?
Thanks for the tip, how do you see that it assumes that the properties are of type any? I thought the way I mapped the type should infere the correct types
[removed]
The way observables work the type will be inferred from the observable deleteClient is returning. You don't need or want to type subscribe. You want to make sure deleteClient's return value is typed correctly.
If that's the case, that will also be represented in `subscribe`s - right now, we can't even tell it's an Observable. (Although it probably is, since it's probably an Angular app (`appService`) and it calls `subscribe`.) :)
It uses subscribe. I'd be shocked if it wasn't an observable. And observables absolutely do give the right type to the subscribe function. I use it every day.
Completely false.
Yeah that’s true. Default type (if none specified) appears to be {} in my experience (object). Regardless, from TypeScript perspective, the type error will be resolved once deleteClient()’s signature is changed to specific a return type of Observable&lt;string&gt;
The default type for subscribe is a generic. Unless your using a pretty old version of rxjs? It has properly inferred type through a generic for a while now.
&gt; The default type for subscribe is a generic. Generic is a type?? I’m not even sure what that means. Doesn’t generic imply a type needs to be specified ?
TS can imply the specific type of a particular usage of a generic function without explicit annotation. If we define: const makeResult = &lt;T&gt;(a: T, fn: (a: T) =&gt; T): T =&gt; { return fn(a); } And use it like this: const x = makeResult(1, a =&gt; { // a is typed as a number here, inferred because the first argument is a number return a; }); const y = makeResult("alsiola", a =&gt; { // a is typed as a string here, inferred because first argument is a string return a; }); You could explicitly type this as below, but there is no need to. const x = makeResult&lt;number&gt;(1, a =&gt; { // a is typed as a number here, inferred because the first argument is a number return a; });
Ah yes, thanks for the explanation, my mind blanked on generics for a second. 
OK, I looked it up to make my point clear. Look at [the type definition of `subscribe`](https://github.com/ReactiveX/rxjs/blob/master/src/internal/Observable.ts#L69). You will see that it takes an observer of type `PartialObserver&lt;T&gt;`. That `T` is derived from the object is a member of, of type `Observable&lt;T&gt;`. That's what I mean with "you can see from the type definition of the `subscribe` function that it can receive the type from its Observable". So indeed, you don't need to type subscribe itself explicitly, but you can look at its type definition to see that it takes it from its Observable.
 appService.deleteClient(event).subscribe((data: **string**) =&gt; { console.log('what is data type ', data, typeof data) // '3' 'string' let index = parseInt(data); }) fixed it
yeah i just typed data as string and the error is gone
does HttpClient return observables by default?
Yes that's the whole point of the http client module. Http calls as observables.
Hi, Author of InversifyJS here. I like what you have done. One of the goals of InversifyJS is to allow others to create their own libraries. At the same time, we want to keep the library as light way as possible. Functionality like this in an additional module makes sense to me. Thanks for spreading the word about dependency injection I also believe it's a very useful tool for writing maintainable and easily testable code.
&gt; uBlock Origin has prevented the following page from loading: Oh well, then not gonna visit it.
Question, what is the point of using typescript for your application when you're using 'any' several places? Might as well use Javascript at that point, or am I wrong?
Good bot 
Good bot
I hope TypeScript's compiler is improved to handle this part better: https://gitlab.com/Flockademic/Flockademic/blob/dev/stacks/frontend/src/components/orcidButton/component.tsx#L15 (By the way, the parameter names are flipped around [here](https://gitlab.com/Flockademic/Flockademic/blob/dev/stacks/frontend/src/components/orcidButton/component.tsx#L107), but that's besides my point). The problem is that I would like to automatically infer the parameter types and the return type of a dispatch-bound function. *initiateVerification: typeof initiateOrcidVerification* doesn't quite work, because `initiateOrcidVerification` returns a function for passing *dispatch*. Perhaps TypeScript 2.8 (coming this month) will solve this? It will at least provide *ReturnType&lt;T&gt;* and related features. If anyone has better ideas I'd be happy to hear about them.
Wow! Thanks for the reply.
What's the purpose behind passing in the `success`, `failure` and `run` functions as arguments, rather than having them as top-level functions?
Helps with type inference. Otherwise you'd have to add annotations at each step.
Just a note: react-router-redux isn't _needed_ to get Redux working with React Router; it's only needed if you want to keep your route state in your Redux store, and want to be able to change the route through dispatching Redux actions.
Static type checking has protected me from many run-time errors. It is much better to catch as many errors as possible at development time rather than wait until run time. There are certainly many types of errors that can slip through and would not be caught by static type checking. 
Why use a helmet if some people die in motorcycle accidents anyway, might as well ride without the helmet.
Things people do just to avoid RxJS...
Very useful, didn't know some specifics mentioned in the article :)
How is this better than an `Either` implementation?
Great article!
Same way async/await is "better" than Promises. It helps flatten out nested flatMap calls.
Great info, but I cannot follow the GIFs. The info disappears before I can read it, let alone comprehend it.
Do a search on John papa and redux, he has a library meant to reduce all of the boiler plate 
RxJS is a JS implementation of ReactiveX, which is a way to handle streams of events in a functional way. Anything can be a steam: arrays, user generated events like clicks, http requests, etc. Events can be synchronous or asynchronous, in other languages they can even run in different threads. You can synchronise different streams, merge them or modify to suit your needs. A good introduction can be found here - https://gist.github.com/staltz/868e7e9bc2a7b8c1f754 For your needs you'll probably need `merge` operator.
Thanks for the link. RxJS doesn't appear to cover the same use case. It looks great, but a different beast. `merge` in particular puts many observable event streams into one, which is not what I'm doing. I want to run a few discrete async functions in parallel, each returning a single result and possibly awaiting the results of each other. Using `merge` and `partition` seems like it would be more complicated. RxJS appears to combine observables into arrays but not objects. Without named properties, it's an extra burden to destructure the array to a set of manually-declared variables. Did I miss the method that accepts a dictionary of observables and emits a dictionary of their results once they've all completed? How should one observable use the result of another? My library is sorta like syntax sugar over `Promise.all`, except `Promise.all` accepts a collection of Promises you've already instantiated, requiring you to manually instantiate and store them somewhere. My library takes care of invoking the functions on your behalf without the repetition of a) storing each promise into a local variable, b) passing all those variables to Promise.all(), and c) destructuring the result from an array back into named variables. (ensuring you used the same names for readability)
There are bazillions of operators in RxJS for fine grained control. You might want to take a look at combination operators https://www.learnrxjs.io/operators/combination/
None of those accept or emit dictionaries without custom processing, which is the whole point of the library I wrote. I think you might just be misunderstanding what I built. My library's also tiny; looks like it would be about the same size if written on top of RxJS's API instead of the native Promise API. I'm not trying to reinvent a huge wheel; just offer convenient typechecking and a DRY convention for small, atomic batches of async operations.
I'm not saying your code is unworthy. What I'm saying is that if you start using RxJS then you might switch your mindset of how you solve your everyday problems. Reactive approach is very different to traditional imperative approach. Let's take a look at the example in your repo. There are two questions one needs to answer before writing any logic: what to do and what to receive as a result. The answer to the first question is that the code should execute four steps. The answer to the second question I suppose is how successful operations were. Do we really need intermediate data? In most cases - no. So let's rewrite this code with RxJS and let's assume that `backend` methods and `sendEmail` return `Observable` (RxJS has a helper to convert `Promise` to `Observable`): function emailLink() { // These two will run at the same time asynchronously return forkJoin( backend.getSomeData(), backend.makeFolder() ) // This one will wait for both first two to finish .flatMap(([getData, makeFolder]) =&gt; backend.writeFileInDirectory(makeFolder, getData)) // This one will wait until writeFileInDirectory finishes .flatMap(writeFile =&gt; sendEmail({'file': writeFile, 'email': 'user@example.com'})); } emailLink().subscribe( result =&gt; console.log(result), error =&gt; console.log('Failed miserably...', error) ); IMHO RxJS code is cleaner and easier to understand. First statement is always an operator which tells you how `Observable`s will be processed in the pipeline. Operator arguments (callbacks) tell you how `Observable`s will be modified at that step. It is also worth noting that RxJS is TS type inference friendly, so there's no need to write type annotations everywhere.
Object spread has incomplete generic support, but in this case you are doing something weird. I think your props should just extend the props type of Route, which you should be able to import from its type definition.
Cheers! That's what I ended up doing, I just made a new component that extended Routes prop types.
Hi all, I just published the latest version of `typescript-starter`. It's a minimal boilerplate generator with many of the most popular development tools pre-configured and ready to start hacking. (testing, coverage, typedoc, tslint, prettier, standard-version, etc.) **The CLI lets you get started quickly, just type `npx typescript-starter` to install the latest version and run the interactive generator.** (For those who haven’t seen it yet, `npx` is a quick-run command which now comes with `npm`. You probably have it installed already.) The interactive mode lets you quickly select from a number of configuration options, and I plan to keep adding new options which work well together. Are there other packages or tooling options you would like to see added?
You might find this project helpful for getting started with a new typescript project: https://github.com/bitjson/typescript-starter (or for copying working configurations into an existing repo) You can just run `npx typescript-starter`, and it will walk you through generating a pre-configured project. There are also examples of module exports and import for both Node.js and the browser. Hope that helps!
Enums are good here, for both semanthic and DRY reasons. Instead of writing export const A = "xx"; export type A = typeof A; you may write it only once export enum ToDoActionTypes { A ="xx" }. Now, ToDoActionTypes.A is a type and value at the same time. Additional benefit - no need for typeof.
Thanks, for some reason I haven't thought about using enums here!
This looks really useful. Thank you so much!
Very glad to help!
Hopefully you'll find the [configured `standard-version` workflow](https://github.com/bitjson/typescript-starter#one-step-publish-preparation-script) helpful. It generates the same style of changelog as the [Angular Changelog](https://github.com/angular/angular/blob/master/CHANGELOG.md). Everything should be completely cross platform, but I haven't tested on Windows (CI runs on linux), so I can't be completely sure. If you have access to a windows machine, the project has 100% test coverage (including testing the CLI and the output of 6 configuration combinations), so I'd appreciate if you could run the tests to check! You can just clone the repo and run: `npm install; npm run cov` If you notice any problems or failures, please open an issue!
Awesome!
Good point - one of proposed features is to only add types in places where they can't be inferred: https://github.com/urish/typewiz/issues/29
Thanks! Please feel free to open an issue if you have any ideas for improvement.
Thanks, submitted a PR and also found a bug in one of your dependencies. (explained in the PR) But once that dep publishes an update, tests will be passing.
Great, thank you! Merged.
&gt; Trying to figure out types of parameters for callbacks If you don't rely on object identity too much you can use Proxies to do this. (Same for object types too)
Symbols don't provide true runtime privacy. It's pretty easy to get access to the symbols without them being exported. `Object.getOwnPropertySymbols(toggleable)` Without private properties, the closest thing to true runtime privacy you can get is to use maps. Even then though not strictly private because Map could be modified to leak information.
Thank you :) If you had a chance to check it out I'd love to hear about your experience!
That's a good idea! Do you have some time to try to prototype this idea and send a PR?
Agreed! Somebody (you?) opened an issue about it: https://github.com/urish/typewiz/issues/15. If you are willing to give it a try and prototype something, I can offer guidance :-)
Update - thanks to [#21](https://github.com/urish/typewiz/pull/21) we now find the type of `f` as `(x: any, y: any) =&gt; void`. Once [#27](https://github.com/urish/typewiz/pull/27) lands, we should eventually be able to tell that the type is `(x: number, y: number) =&gt; number`. First, we'd find the types of the `x` and `y` arguments of callback, based on the runtime behavior (the current version of TypeWiz can already do that). Then, by querying TS for the type of the first parameter passed in the `app1` call, we'd get the type of the callback function (the return type would be inferred by TS), and then we'd use this as the type for `f` (that's what essentially [#27](https://github.com/urish/typewiz/pull/27) does)
Cool! &gt; First, we'd find the types of the x and y arguments of callback, based on the runtime behavior How does that work? Do you instrument the arrow function `(x, y) =&gt; x + y + 3` then connect it back to `f`.
Are you a frontend developer? Then typescript. Plenty Typescript courses, and it's easy to just keep developing your Javascript apps WITH Typescript after you learn it. (Check Maximilian Schwarzmuller's Typescript course on udemy) It's basically a superset of Javascript. You can still code javascript in it. It just wont be type-checked (will be of "any" type) Kotlin is used on backend, and android (and more?) You can use typescript for React Native (both android and ios), React, Node.. and many other venues. 
Maybe move the definition of x to below tha example class
Thats fine, the problem is that 'Example' is redefibed without a type so when treat it like a class i get errors
Been a while since I’ve done any TS, but I’m pretty sure you can’t use something before it is declared (ie: no hoisting). Assuming your code samples are accurate that seems like I could be your problem. Of course I also have absolutely no clue what you’re doing. You declare Example as a class, but try to use it as a type... you’re all over the place. 
Sorry, you’re right. Like I said, been a while since I’ve done TS. The type declaration should be unnecessary here, it would be implied by the new Example(), but I circle back around to my other two points: Don’t use the class before it is declared, and use import/export. The latter wouldn’t actually break anything in your code that I’m aware of, but is required for types and is just best practice anyway. 
As far as i understand ES6's import/export it doesnt declare the imported variables as global so i have to import them in each file. By the way i'm creating a game engine so thats a big problem.
What do you mean by checking? 
The compiler checks each file for errors using the definitions from other files.
&gt; ts appear to be dynamically typed While TS *can* be dynamically typed, the intended use is for everything to be statically typed; meaning each variable has a type at compile time and is not inferred at runtime. Best source for me when learning was the official docs: http://www.typescriptlang.org/docs/home.html
Js: const foo = undefined; foo.bar; // runtime error 'no bar on undefined', your code stops, your site visitor goes annoyed away Ts: const foo = undefined; foo.bar; // compiler warns you that foo has no bar, you fix this your visitor never gets the error. After using your site for some time, they come to a surprising conclusion that this might be the first web site that actually works but then it breaks because compilers get smarter but humans are infinitely creative and the balance is restored. 
hmm.. * so you're saying js is like airline that randomly stops in the sky and everything crashes * and ts is like an airline that works but the management, and processes that mgt do gets 'smarter' or i guess you mean 'more complex' * and the humans that work at the airline are very creative so 'type safely' at least to a few ppl is not actually a long-term good thing i guess? 
these are things not understandable in the context you're presenting them: * statically typed * variable * has a type * at compile time * not inferred * at runtime would you say the link you provided is accessiable and understandable to that subquestion? &gt; Sub-Question: so im still looking for the best basic/intro level ts learning resource would you also say that the link linked is accessiable and understandable to anyone that doesnt understand those terminology you presented/used? thanks for letting me know
My guy, if terms like variable and types are hanging you up, I think you need to learn some more basics of programming. Might even be worth while to do some super simple stuff in a statically typed language so you get a basic understanding of how they feel to use. C# and Java are my personal recommendations. Just enough to get the object oriented part down, and what it means to have objects and types.
I can try and adjust /u/Dw0's example to your analogy and hopefully I don't butcher it too bad. Lets say foo is a plane. The lets say that bar is the value for the fuel level. In js, if we run the code above but instead of undefined, foo gets set to something it should get set to like a turtle, it won't error out until runtime. So your users come to the site and it tries to run this... const foo = turtle; alert(foo.bar); ... it will halt execution of js because of the runtime error. BUT if you are using ts, you can do this... const foo: Plane = animal; alert(foo.bar); ... this error will get caught while compiling and you wont introduce a runtime error to your code. It basically adds an additional layer of safety to your code so that, in a way, your code doesn't contradict itself. It makes sure that you aren't trying pass a number into a function parameter that requires a string. It makes sure that you aren't trying to get a property that normally is used on a HTMLInputElement (an &lt;input&gt;)like "type" on something else like HTMLElement (a &lt;div&gt;). The main reason people say its important for larger projects is because how one function/method/property/etc. could be used in x number of spots. Are you going to check every webpage that uses that function/method/property to make sure it still works when you make one small tweak to it? The larger the project, the more time that would take. Unit test can help catch these as well, but TS will catch a lot of them at compile time. TS could almost be considered an inline testing suite that requires you to run the test before you can even see how it functions.
Lissen dude. Here is the deal. TypeScript is like a framework for javascript. It helps you in many many ways. The last thing being 'type safety'. It helps your IDE so your code makes sense the moment you write it. There is no other real reason to use typescript. Sure it prevents you from feeling stupid. But yea your IDE needs a lil help, flow or typescript. I like typescript because im from a c# background so its comfortable. With that being said, if you are going the front-end framework route such as Vue... TypeScript will be more of a hinderance than a benefit. Either way.. if you would be a good programmer you'd have no need for typesafety. With a full set of well defined unit-tests you get the same result. So you can also look at it like that: type safety are mini unit tests. Have fun!
What do you mean by TypeScript being a hinderance for Vue? I can kind of understand it since it's support is in it's infancy but I have loved converting my vue components to use typescript. It feels much cleaner to me.
This is good advice. I didn't appreciate TS until I'd spent a few weeks with Rust.
I swear, TypeScript has got to be the most complicated type system in widespread use. 
What the hell. This is so incredibly wrong. 
It has to support idioms that exist in JavaScript. And JavaScript devs typically don't care about having an understandable, straightforward-to-define interface because they don't have to type it.
ok see the sub question that asks about the basics and intro level /u/ClutchHunter
This is really cool: type IdOrName&lt;T extends number | string&gt; = T extends number ? Id : Name; declare function createLabel&lt;T extends number | string&gt;(idOrName: T): IdOrName&lt;T&gt;; but it's abit of a pain to write this in TypeScript and have it type-check. It would be great if, when there is a 1-to-1 correspondence between parameter and type-parameter, narrowing would extend from the reference to the parameter itself. 
I would like to see a way to automatically generate a type testing function for runtime use on these more advanced types.
Let me preface by saying I love TypeScript. As someone with a background on C++ and C#, TypeScript brings a familiar feel to plain Javascript. However, if you're only in Javascript, do you really need TypeScript? I say no. I've seem some complaints from pure Javascript users from another subreddit about the perceived "smugness" of TypeScript users, as if they're pushing TS down their throats. I guess some TS users (like me) just love TS because of previous experience with plain JS. I'm hoping you can appreciate it, too. However, if you have good memory that you know what parameters you pass to your functions, or if you're the only one modifying your code, or you don't want the compile-step added by TypeScript, then Javascript will be fine. The value of TypeScript is for us losers who can't remember the parameters needed on each of the function. Is it a number, a string? I already don't know one month later. It's also for losers who band together to code something. Loser B might be changing a function's parameter or an option, and it's required, and I would've never known unless TypeScript complained about the parameter required. Finally, it's for losers who want to code in C++/Java style ES6 or above classes, and have TypeScript's transpile it down to (pre-)ES5 Javascript code for compatibility with IE that your manager keeps reminding you of. Sure, you can use Babel for that, but that's adding a transpile/compile step to your Javascript to convert to Javascript, so TypeScript's inherent compile step isn't a hassle anymore.
I was getting sick of finding a lack of Intellisense in the view layer, unless I was using a beefy IDE like Visual Studio or JetBrains Rider, which give you a good experience with Razor view templates. I prefer using free, open-source tools, and I knew how to use React, TypeScript, and Node, so I put them together for work flow where you've got Intellisense from Visual Studio Code for your view layer.
Is `infer` existential types?
Wot in tarnation
prefer just a regular everyday life example that everyone would understand but i guess we could try the 'voltage' thingy, so here's how im understanding this: * 'a complex machine' - does it have to be complex or can it be simple? does it matter? if so why? if not why not, or why is it included then, cos extra things that are not needed causes confusion? how complex is the machine or does the relativeness of that not matter? * 'where wires of all different voltages' - didnt know wires have 'voltages' not sure what those are (can i actually see them with my eyes?) i dont think i ever saw them before, not sure * 'are unlabeled' - that doesn't sound like it's typically/usually a good ting * 'every wire can be plugged into every socket' - i thoguht you plug in those things that have metal stuff coming out of them into those 'plug holes' but ok * 'adds color coding to the wires' - that sounds good, i like colors * ' (data) ' - well if there's visual signaling (via colors) to however 'data' looks like, that sounds like a good thing * 'different plug shapes (variables/formal parameters)' - huh... that's interesting i didnt know they were different * maybe we could use the examples of toppings on pizza instead of 'different shapes' * 'to all the inputs,' - 'inputs' was never shown or explained (roadblock) * 'difficult to impossible to plug a high voltage wire into a low voltage input' - dont see how 'voltage' has to do with 'different shapes' - sounds like different things * 'causing damage to the machine' - don't know why it would cause damage to the pizza making machines * i think a pizza making machine taht makes different sizes would be a far far far better examples of everyday life * ' switch the configuration ' - what configurations... where did that come from.... * 'refactor' - but we still dont know what what configurations we're talking about, its super confusing, any everylife examples? * like the configurations for chrome extensions.... or... ? * 'much easier to know what configurations will work and which will cause malfunction' - really? that sounds good * **but how in the universe do we know that?** was it shown or said, did i miss it? is it by way of the pizza machine making different shape pizzes? based on what ingredients/inputs we put into the 'auto-baker pizza machine'? 
these are things not understandable in the context you're presenting them: * statically typed * variable * has a type * at compile time * not inferred * at runtime **would you say the link you provided is accessiable and understandable to that subquestion?** &gt; Sub-Question: so im still looking for the best basic/intro level ts learning resource **would you also say that the link linked is accessiable and understandable to anyone that doesnt understand those terminology you presented/used?** thanks for claifiying 
point: basics of ts is js ok well i stilll need to at least learn ts, so need a good learning reousrce that anyone would understand that's helpful point 
i dont know any programming or nothing, waht's the best learning resources to learn basics of ts taht anyone can understand? that's pretty much it
Yes its supposed to be ts
This is getting so complicated, I have no fucking hope of using any of this and I spend hours every day reading about computing languages.
We have, but it's a bit more overhead than I think we'd be willing to take on. We do post [design meeting notes](https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+label%3A%22Design+Notes%22+is%3Aclosed) when appropriate. Unfortunately, the specific conversation was more in an offhand meeting, but I did take some notes that started alluding to these ideas back when we thought conditional types would operate on the `true` and `false` types respectively. [You can read more here.](https://gist.github.com/DanielRosenwasser/cddd875b53b987b8bb5ee3db56a0ad93).
nah, TS isn't going to take down Scala that easily! 
Who needs these features ?
Return type is huge for redux action creators. 
Also conditional types allow a form of vararg type parameters to be used, which I've found useful in some stuff I'm doing.
Also, &gt; This is not old fashioned, it's how you include JavaScript files even generated ones. Is it really? TypeScript seems to have a strong focus on module loading.
I would also like to add that the specific error messages i get are things like "variable type should be the same - should be any, but is string", and a gigantic amount of "duplicate function definition", which is what leads me to think that it checks the JavaScript files like they are separate from the TypeScript ones.
I think library authors get the most befit from these. For example Redux types could be made more terse: https://www.reddit.com/r/typescript/comments/7yut1k/improved_redux_type_safety_with_typescript_28/duld7iq/ Also DeepReadOnly can be implemented using these: https://github.com/Microsoft/TypeScript/issues/13923#issuecomment-368688719
I think this is where your issue lies, TypeScript can dynamic load modules but this is quite tricky to get right, most of your issues will probably be resolved if you bundle your files into 1 via something like webpack.
Yeah, i know it can get tricky, that's why i turned it off...is bundling everything into one file really the only way to get rid of all of those errors? Just including them with script tags seems to work fine. I don't have any compile- or runtime errors, just nonexisting ones Visual Studio throws at me, while everything compiles and works fine.
You're probably right. Looking back on my example I don't think narrowing the type `T` would even help. If you change the signature of `createLabel` to declare function createLabel&lt;T extends number&gt;(idOrName: T): IdOrName&lt;T&gt;; it still wont reduce the conditional and expect an `Id`, it will always ask for `IdOrName&lt;T&gt;` which can't be satisfied. The difficulty seems to be with conditionals, not narrowing type parameter constraints.
Also with conditional types we can finally automatically narrow union types to a specific variant based on the type alone. This is *really* useful for `redux-observable` for example: type Action = AddTodo | RemoveTodo; // Previously: // Needs explicit type annotation, you can use the wrong type actions$.ofType&lt;AddTodo&gt;(ActionTypes.AddTodo) // Now: // Action type is inferred as AddTodo actions$.ofType(ActionTypes.AddTodo) 
* [Here's a good resource for learning JS](http://eloquentjavascript.net/). * [Here's one of the golden standards for JavaScript References](https://developer.mozilla.org/en-US/docs/Web/JavaScript). * [Here's the bullet points for TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html). If you struggle with understanding the concepts in those, then you should look for beginner programming resources, not TypeScript resources.
Okay, i have now confirmed that there are no more errors as soon as i close all HTML files - that makes it perfectly usable. Thanks!
Statically typed: Variable types are set by the developer, in code, and they do not change while the program is running Dynamically typed/inferred types: Variable types are determined by the compiler when the program is running. This means the variable type can change Compile time: When the code is processed by the compiler and converted into JavaScript (in this case)
We've been slowly transitioning a 45kloc+ application from untyped javascript to typescript. It works very well for us, and it really does catch bugs that otherwise often go unnoticed until you run it in production. The type system really isn't *that* hard when you're mostly just writing typescript. It's when you're interfacing with external libraries, that's where it gets a bit fucky. Luckily there's community curated types over at definitelytyped.org
Where can I find those? Sounds interesting...
Hey, the thing to keep in mind is that these features are meant to model specific patterns in libraries. You never *have* to use these features, but they're powerful and it's awesome when they are there. So don't feel pressured to use them, though I would totally encourage you to play around and learn them.
Could have done that already with a type guard.
great soon we can code in types only :)
I mean, not really, not with this API at least. What you want here is a filter that also narrows action types in the process. `redux-observable` and `ngrx` both faced the same problem. The type guard solution works for really simple cases (but not even that well for those). You could do all of these with a simple `switch` but for brevity's sake let's assume we have a type guard already defined: // Original (map) actions$ .ofType(ActionTypes.AddTodo) .map(action =&gt; otherAction()) // Type guard equivalent (you could also do it with a switch actions$.map(action =&gt; isAddTodo(action) ? otherAction() : ???) // The naive type guard solution already fails but there's a fix // It produces the same result but is slightly less efficient actions$.mergeMap(action =&gt; isAddTodo(action) ? otherAction() : []) It kind of falls apart once you need some of the more advanced functionality // Original (switchMap) actions$ .ofType(ActionTypes.AddTodo) .switchMap(action =&gt; [otherAction(), otherAction()]) // Naive type guard version (buggy, cancels otherAction on RemoveTodo actions) actions$.switchMap(action =&gt; isAddTodo(action) ? [otherAction(), otherAction()] : []) // The fix is either ugly or relies on `ofType` which is impossible to correctly define pre 2.8 actions$ .mergeMap(action =&gt; isAddTodo(action) ? Observable.of(action) : []) .switchMap(action =&gt; [otherAction(), otherAction()]); // This also works but it's also ugly actions$ .filter(isAddTodo) .switchMap(action =&gt; isAddTodo(action) ? [otherAction(), otherAction()] : [])
Type guards require a runtime expression; conditional types can happen purely at compile-time within the type system, which makes them idea for declarations that describe third-party libraries.
You shouldn't write new code that makes use of this. It's just there to cope with the non-sense that already exists.
How about this? It gets rid of all the repetition. Public options are exposed in `IClientFoo`, private options are exposed in `IFoo`, and implementation happens in `ClientFoo`. The constructor's private signature is technically "public" but it's been marked `@internal`. This, coupled with TypeScript's "declaration" and "stripInternal" options, means that signature will be omitted from your compiled type declarations, so as far as external code is concerned, it doesn't exist. interface IFoo extends IClientFoo { secretSauce: string } interface IClientFoo { id: number; value: string; } interface ClientFoo extends IFoo {} class ClientFoo { constructor(foo: IFoo) { Object.assign(this, foo); } } 
This was my first thought, but I don't think it's accurate. IClientFoo, given OP's definition, should be able to change (e.g. adding new properties) without IFoo changing. Also you are setting secretSauce to IClientFoo, which is a key it can't have. I think there is a `Delete&lt;OriginalType, 'secretSauce'&gt;` definition, but I don't know it off-hand.
You have IFoo extending IClientFoo and vice versa in your snippet. IClientFoo does not implement all properties of IFoo. See OP's constructor for it: constructor(foo: IFoo){ this.id = foo.id this.value = foo.value } It cherry-picks the properties that it supports and ignores the ones (secretSauce) it doesn't. &gt;In TS2.8, the Delete generic can be implemented like this: Ah, yes. Pick. I think that's what OP is looking for. type IClientFoo = Pick&lt;IFoo, 'id' | 'value'&gt;;
I see what you mean; I missed that. I'm not sure what OP's intent is. Why is `ClientFoo` a class in the first place? We don't see any methods so I wonder if OP really wants a class. Do they merely want to expose their `IFoo` as a `IClientFoo` to prevent external code from mucking with internal properties? Does OP know that every class declaration is also an interface declaration, so `IClientFoo` and `ClientFoo` can probably be merged? If you only want to expose the interface, not the class, you can do: export type IClientFoo = ClientFoo;
&gt; actions$.map(action =&gt; isAddTodo(action) ? otherAction() : ???) actions$.filter(isAddTodo).map(action =&gt; .... )
i dont know any programming or nothing, waht's the best learning resources to learn basics of ts taht anyone can understand? that's pretty much it
This question is unrelated to TypeScript; it's about nodejs. You should ask GoDaddy if they can host a nodejs server; that will give you an answer.
I really don't think anyone should be messing with that kind of features. TypeScript is really good with verifying models, functions arguments etc, none of which should need that kind of complicated features. I wrote a relevant blog post about it a few days ago, I would be happy to know what you think about it: https://medium.com/@vitalyb/dont-let-typescript-slow-you-down-92d394ec8c9f
My bad on this one, that actually works. I never tried it with actual type guards, just with: actions$.filter(action =&gt; action.type === ActionTypes.AddTodo).map(a =&gt; ...) Which doesn't work. Still this doesn't really change the fact that proper `ofType` typings are great. Redux already used to have quite a bit of boilerplate before TS 2.8 if you didn't opt-in to one of the opinionated action/reducer/etc. creator frameworks. You needed to define: 1. action types 2. return types for the action creators (as an interfaces/type aliases) 3. action creators 4. type guards (if you went the filter route) With TS 2.8 and the updated `ofType` typings you only need the action types and action creators (I know there were tricks to get the return type of function pre-2.8, they were a bit too ugly for me to consider).
I would say don’t worry about ts yet. Learn the basics of JavaScript. Ts is a great tool that improves js but in order to understand it you need to know js. You aren’t going miss out on anything by learning js first and it’s a better path to just learn the basics of js first anyways. I knew js for 5 years before even starting ts. Of course you don’t need anywhere near that much experience to learn ts - I just didn’t see the need until I started looking into it more. Basically, like 90% of ts is just JavaScript (maybe even more). Ts pretty much just adds on to js code to improve how well you write your code. You also really need to learn the issues that ts solves and you can really only figure that out by writing js. For js, codecademy.com is always a good place to start. It’s free for the most part and is what I recommend most people trying to get started. Code school is also great but it’s paid so if your looking for free resource, codecademy is the way to go. 
Sure, there's all *sorts* of resources for that. But just look for beginner stuff, not TypeScript stuff. [freeCodeCamp](https://www.freecodecamp.org/) is good, /r/learnprogramming is great, too. They have a wiki and a lot of other resources to help you get started.
Read his post history. It's very strange
Not sure if you want to cut down on type def boilerplate or code boilerplate. Anyway, what about: interface ClientFoo { id: number value: string } interface Foo extends ClientFoo { secretSauce: string } const createClientFoo = (foo: ClientFoo) =&gt; ({ id: foo.id, value: foo.value }) `createClientFoo` will accept a `ClientFoo` or `Foo` object.
I agree, but if the two interfaces are really related then IFoo should probably extend IClientFoo. Otherwise you've just got two things that coincidentally have two properties in common (for the time being)
It doesn't matter as much in typescript. Interfaces are only structural only. There's no difference between extending an interface, and just including all the same properties.
Maybe take a look at [this](https://www.typescriptlang.org/docs/handbook/advanced-types.html). You described your problem rather vaguely, so I'm not sure which solution is best for you, but you will find multiple in there. You could use something like the 'pluck' method, where you copy the properties based on the keyof operator. On the other hand: are you sure you want to copy the data and create a new object? To me this kind of looks like using the client interface to hide the information of the more complex interface may already be the solution that you are looking for. 
OLD declare function createLabel(id: number): Id; declare function createLabel(name: string): Name; NEW type IdOrName&lt;T extends number | string&gt; = T extends number ? Id : Name; declare function createLabel&lt;T extends number | string&gt;(idOrName: T): IdOrName&lt;T&gt;; dude, I'll take the old way any time over this complicated nonsense!
I’m not sure this is possible pre-2.8 (which just rc’d!), but with conditional types I imagine you could do something like type MappedNonFunctions&lt;T&gt; = { [P in keyof T]: T[P] extends Function ? P : ...whatever mapping involving P... } On phone so cant know for sure if this is correct, but it’s the basic principal behind the function property name type alias in this PR: https://github.com/Microsoft/TypeScript/pull/21316
No, that doesn't work because in my example `Foo` itself is the function; the function is not a property of `Foo`. So your example ignores and removes the function signature; I want to preserve it.
Does anyone have any example on how to use the new 'Exclude' type? I'm trying to extend `React.InputHTMLAttributes` with my own `onChange` handler and I'm wondering if it will allow me to remove the `onChange` definition from the InputHTMLAttributes. I've tried but I'm not sure the correct usage. Thanks!
Generics are used for Arrays, Maps, and Sets. An array is not merely an array; it's an array of `T` where `T` is the type of the items in the array. The array has a pop method that returns a `T | undefined`. It has a push method whose arguments are all of type`T`. Other things like the map and forEach methods all have the type T somewhere in their interfaces. Without generics, all arrays would be arrays of `any` which is not very helpful.
Here's a real world example. I just wrote this piece of a code a little while ago. It's for Java (more specifically JavaFX) but the idea transfers over to TypeScript. In JavaFX you have these fxml files. They're xml files that contain a layout for a given view. You can think of them like HTML. Each view has a controller class related to it. The controller handles the logic of the view. What my method does is update the view then resize and update the title of the window that's containing the view, then finally returns the controller for the view. The problem however is that the controller can be any type and I want this method to be generic so that it will work for any of my views (so it has to be able to return any type of controller). How can I do this? By making the return type generic. private &lt;T&gt; T updateStage(String fxml, String title, int width, int height) throws IOException { FXMLLoader loader = new FXMLLoader(getClass().getResource(fxml)); Parent root = loader.load(); primaryStage.setScene(new Scene(root, width, height)); setStageTitle(title); return loader.getController(); }
Thanks for the reply. I guess this is as good as we can do for now. I'll check the TS issue tracker to see if anyone's made a feature request for function signature extraction.
Why do people downvote this post? Is the infromation not correct/good enough?
Too basic, and contains info more easily found in official documents.
Any where you want a method or data structure to handle a broader than single different amount of types. But still be able to give garanties on run time, you should use a generic. Examples include: * Array, Set, Dictionary and other collections. * Methods handling external events, like getting data from an API. If you go into other languages, you can also add clauses to generics, like c# where you can force generics that implements an interfaces, that are common for all types the method could expect to receive. This could allow you to write a full CRUD enabled REST API for all your classes, if you just ensure your classes all have the same interface defining a key called Id.
Oh ok, thanks!
All of this code is used in a real world application. I promise. ELI5 for kids who understand basic typescript: You should avoid the `any` type in typescript. It is only to be used when converting old code. Generics can save you from having to use the `any` type. One of the most common things in javascript is doing **web requests**. Lets say you do a http request to a server. The server might always return a response that wrap the results in extra response data, how many hits there was, and such... It might fit this interface: interface ResponseObject { success: boolean; count: number; errors: string[]; data: any; // Not type-safe. } To stay type-safe I could write one interface per return type that might be returned: /** What my "/api/GetLastLogin/" endpoint returns */ interface ResponseLastLogin { [...] data: Date; } // And one for number, string, and one for array number and string, one for a single user, one for an array of users, ...etc. Or i could make a single generic: interface Response&lt;T&gt; { [...] data: T; } doWebRequest(url, (result: Response&lt;number&gt;) =&gt; { // I've just told typescript that data should be of type number. // It is safe to use it when adding numbers. console.log(result.data + 5); }); Or if your webrequest method is async, you could make the entire method generic: let result = await doWebRequestAsync&lt;string&gt;(url); // The result.data object is now a string. The result object is a Response&lt;string&gt;. console.log('My data was ' + result.data); **Collection of data** (like arrays) _should be generics_ because you don't want to write one StringArray, one NumberArray, etc. Lets say you need to write your own implementation of a collection of items (maybe you miss C#'s List's): class MyCustomListImplementation&lt;T&gt; { private collection: T[]; public add(value: T): void { this.collection.push(value); } // ... The constructor and other methods } So if i try to add a string to a `MyCustomListImplementation&lt;number&gt;`, typescript will throw an error. And if i retrieve a value, typescript will know it is a number without me having to tell typescript that it is a number, more than once.
Additionally, content is completely obscured by ads on mobile.
I suppose I should add more detail. The challenge with the above is that the `clientFoo` object will still have the `secretSauce` property on it. Say for example I load `foo` from a database and do some stuff with it. Then I want to return it as part of the client response. If I write it to the response stream (say in Express) like this `res.send(clientFoo)` using your example above then the JSON received of the client will include the `secretSauce` property. What I want to do is create a different object. In C# for example using JSON.Net serializer it will recognize my types and only serialize according to the specified type. Since TS typings don't exist at run time the properties of derived classes still exist.
&gt; Why is ClientFoo a class in the first place? Added some context to my original post. `IClientFoo` is intended for clients of the module/API/service whatever I'm making and `IFoo` is an internal representation with some secret data. &gt;Does OP know that every class declaration is also an interface declaration, so IClientFoo and ClientFoo can probably be merged? For sure. I left out any interesting implementation details that would necessitate two different declarations but in this case there's no absolute point for both. &gt;If you only want to expose the interface, not the class, you can do: That's a neat trick, I like that.
&gt; You could use something like the 'pluck' method, where you copy the properties based on the keyof operator. That's pretty close to what I'm looking for. &gt;are you sure you want to copy the data and create a new object? Also happy to delete properties that aren't in the `IClientFoo` object. Anything that ensures the underlying object matches the type so if I were to do something at runtime without typings available (send it as JSON across the wire or write it to disk) the `secretSauce` property wouldn't be revealed.
&gt; If you go into other languages, you can also add clauses to generics I may be misunderstanding you, but Typescript has this. interface Id { id: string; } const fn = &lt;T extends Id&gt;(a: T) =&gt; { return `Id: ${a.id}`; }; const a = {name: "hello"}; const b = {id: 7, name: "hello"} const c = {id: "7", name: "hello"} const d = fn(a); //Compiler error const e = fn(b); //Compiler error const f = fn(c); //Works Or do you mean something else?
That's what I meant, just have some typescript in a while :-)
I'm still very deeply confused about this whole conditional type thing. 
I think it's easier to think about the `type` keyword as a function on the type level with slightly different semantics. The arguments are the generic parameters, the return type is the type on the right sight of the assignment. That way a lot of things map directly to already known concepts: const convert = &lt;T&gt;(array: T[]) =&gt; array.map(x =&gt; x.toString()); type Convert&lt;T&gt; = { [K in keyof T]: string }; const numberOrNull = &lt;T&gt;(value: T) =&gt; typeof value === "number" ? { value } : { value: null }; type NumberOrNull&lt;T&gt; = T extends number ? { value: number } : { value: null }; const sum = (o: object) =&gt; Object.values(o).reduce((acc, next) =&gt; acc + "|" + next); type Sum&lt;T&gt; = T[keyof T]; Some of these aren't perfect but I think they're still useful for understanding some of the more advanced features of the type system.
&gt;Prototyping is slower with TypeScript Maybe it's because I'm just from a background of strongly typed language but I've never found that defining types was an impediment to my development speed. Programming is about the data, not the procedure so you have to stop to think about your data structures at some point. Might as well type it down while you think about it. &gt;Types for 3rd party libraries might not be worth it This is where strong typing are the best. Figuring out other people's code is hard, strong type are some of the best basic documentation you can get. &gt;Due to the dynamic nature of JavaScript many libraries include various dynamic return types and arguments. There's nothing about dynamic typing that requires this. It's a conscious choice of developers who hate others and want them to suffer.
You can do that with the current TS version: /* * Diff, Omit taken from https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-311923766 * Overwrite based on https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-308052919 */ type Diff&lt;T extends string, U extends string&gt; = ({ [Prop in T]: Prop } &amp; { [Prop in U]: never } &amp; { [x: string]: never })[T]; type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Diff&lt;keyof T, K&gt;&gt;; type Overwrite&lt;T, U&gt; = Pick&lt;T, Diff&lt;keyof T, keyof U&gt;&gt; &amp; U; interface Foo { onChange: Function; onMount: Function; id: string; } type FooWithoutCallbacks = Omit&lt;Foo, "onChange" | "onMount"&gt; interface CustomCallbackProvider { onChange: (val: string) =&gt; void; } type FooWithCustomCallback = Overwrite&lt;Foo, CustomCallbackProvider&gt;
I worked in typed languages for the better part of the last 2 decades, and part of the reason I switched to JS land was because of the lower friction and faster initial implementation. That heavily depends on the problem space though. In the type of web apps I generally work on, the complex data structure that gets tossed around are often irrelevant to most of the consumer and only a few properties matters (I can already hear the "but you're doing it wrong!". Just trust me for a moment). More recently I've been working on more "typical" data pipeline, node, build tools and frameworks that are more similar to what is done in Go, Java, etc. Types are invaluable, and without them I spend 2/3rd of my time fighting with property typos or trying to remember the data shape I'm dealing with. So it's TS or Flow all day every day for those :) I think the lack of background with typed languages definitely is part of the resistance to them, but there's also just different problem spaces that are more or less type friendly (or type required), which explains all of the different reactions to them. There's also just some crap that doesn't type well. I've spent hours at times trying to figure out how to handle certain patterns (and I've done Haskell, Elm, ML...it's not like I don't know types) that are just not very TS friendly but were needed in the stuff I was writing. They were totally doable, but it took a lot of research to figure them out (and most people in existing libraries just punted on those with any types). I could use "any" in those case and call it a day, but I only know that after I find the solution (and realize it wasn't just me not knowing typescript). There's also all the time lost because of bad type definitions. That can't be discounted.
An example here, to code reusability https://hackernoon.com/generic-repository-with-typescript-and-node-js-731c10a1b98e
&gt; I've never found that defining types was an impediment to my development speed. It doesn't, in the long run. But have you never wrote some code, defined its types and then ended up deleting it because you went in the wrong way? That's the kind of prototyping that works with dynamic languages and the one TypeScript slows down. &gt; This is where strong typing are the best. Figuring out other people's code is hard, strong type are some of the best basic documentation you can get. I couldn't agree more. Strong typing are great, when they are done by the owner of the library. But when the owner wrote dynamic return types in pure JS and didn't write any types, that's a different story. Because then you end up using types that were written by someone else and which might be out-of-date, incorrectly inferring types, or just too complicated to use. I've spent way too much time trying to figure out what was wrong with my code when using LoDash's typing for example. My code worked, but TypeScript complained on some complicated generic inferring that I couldn't figure out. Would I gain anything if I wasted an hour trying to figure out how my generic usage of the typing (or LoDash typing) was wrong? I don't think so. &gt; There's nothing about dynamic typing that requires this. It's a conscious choice of developers who hate others and want them to suffer. Right, so for that kind of libraries, there is no need to use 3rd party typings or create your own.
Loved the article bro, can you elaborate on the font use points? Like I’m having difficulty following what you mean with users and accounts and why that is bad?
I’m with you. Having a plan in place makes it better for the whole team. 
&gt; defined its types and then ended up deleting it because you went in the wrong way? Yeah, that's when I love having "Find All References" so I know where I need to up change something. With dynamic languages I go "oh shit, I need to change this. Wait, why doesn't it work? Let me drop breakpoints. Oh, I forgot I need to change it here too. Wait, it's still not working? Oh I need to change this too." &gt;But when the owner wrote dynamic return types in pure JS and didn't write any types, that's a different story. Because then you end up using types that were written by someone else and which might be out-of-date, incorrectly inferring types, or just too complicated to use. Fair enough. I just re-read the original article. Yes, I agree I never write types for code I don't own. The risk of it being incorrect/stale isn't worth the effort. &gt;Right, so for that kind of libraries, there is no need to use 3rd party typings or create your own. Agreed. I just wanted to point out that's not a fault of strong typing in general. It's a fault of poor api design/documentation.
VS2017 has an automatic type inclusion feature which causes all kinds of issues. the key is to have a properly configured tsconfig. { "compileOnSave": true, "compilerOptions": { "types": [], "sourceMap": true, "target": "es5", "noEmitOnError": true }, "exclude": [ "node_modules", "obj", "bin" ] } from [strackoverflow](https://stackoverflow.com/questions/42663010/typescript-in-visual-studio-2017-automatic-definition-inclusion-causes-duplicat). this generally resolves the craziness
 { "compileOnSave": true, "compilerOptions": { "baseUrl": ".", "module": "es2015", "moduleResolution": "node", "target": "es5", "jsx": "react", "sourceMap": true, "lib": [ "es6", "dom" ], "types": [ "webpack-env" ], "noEmitOnError": true }, "exclude": [ "bin", "node_modules", "obj", "bin" ] } 
Perfect thanks for that! This is what worked for me ... { "compileOnSave": true, "compilerOptions": { "baseUrl": ".", "module": "es2015", "moduleResolution": "node", "target": "es5", "jsx": "react", "sourceMap": true, "lib": [ "es6", "dom" ], "types": [ "webpack-env" ], "noEmitOnError": true }, "exclude": [ "bin", "node_modules", "obj", "bin" ] } 
&gt; mple here, to code reusa Do you have a specific doubt ? 
I’m just asking about the cons
Updated to v0.0.1-beta.1? Where did you start!?
alpha.0?
-1
Unfortunately the TypeScript support is not very good. The `args` you get when implementing the functionality of your command is of type `any`. Same with `flags`, where every property is of type `any`.
Thanks for the tips. Nice article. We’re just starting to use it on a project and I’ve been bitten by out of date types from Definitely Typed once or twice or libraries that just have faulty types internally. It’s easy to fall into assuming the type checker is always right and you’re wrong. 
You're welcome! Let me know if you have other insights in the area. 
That little scoreboard at the end is so incredibly stupid. 
that's not true. They're fully typed: https://imgur.com/a/9bibO
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/lmwTVsW.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dw8vf7f) 
It doesn’t.
You don’t need a semi-colon at the end of every line. In the end, typescript compiles down to javascript, so you only need semi-colons in the same cases that javascript requires them. I think most people just use semi-colons because many other type-safe languages like java use them.
TS has a \`Pick\` type for this: interface Foo { id: number value: string secretSauce: string } type ClientFoo = Pick&lt;Foo, "id" | "value"&gt; const foo: Foo = { id: 1, value: "hi", secretSauce: "saucy" } const { secretSauce: _secretSauce, ...clientFoo } = foo export { clientFoo }
Plenty of moden languages still use semicolons. So not a single statement you made is correct. 
;
This post is doing your username proud.
As others have mentioned, they're actually not required in either JS or TS. You should use explicit semicolons in Javascript, because the language is actually ambiguous without them. Javascript expects most statements to end in semicolons, and implements a rule called Automatic Semicolon Insertion to effectively guess where you meant to put semicolons when they're not present. Typescript by necessity applies the same rules, since it must accept mostly arbitrary JS code. This means that the semantics of statements can change depending on whether a line ends in a semicolon or not. Personally, I prefer to avoid the uncertainty and just be explicit. A quick lint check ensures I don't miss any semicolons. 
Amazing. Every word you just said was wrong.
**TypeScript** TypeScript is an open-source programming language developed and maintained by Microsoft. It is a strict syntactical superset of JavaScript, and adds optional static typing to the language. Anders Hejlsberg, lead architect of C# and creator of Delphi and Turbo Pascal, has worked on the development of TypeScript. TypeScript may be used to develop JavaScript applications for client-side or server-side (Node.js) execution. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/typescript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
That is a question of coding style, not language requirements. There is nothing to stop you from omitting the semicolon. Most people do place it in their code in order to be explicit about it. And being explicit can help with readability which is especially important in a tutorial.
Every JS code is also valid Typescript. It doesn't require a semicolon. It is possible, though, that you use a linter without knowing about it. A linter helps with enforcing a uniform coding style throughout a project. Because most people prefer to end their lines with a semicolon this behaviour is the default one for most Typescript linters.
Every tutorial/book you find will also use indentation, but that isn't required by the language either. Style is a choice.
90s. Brendan Eich has expressed regrets about automatic semicolon insertion, not about semicolons themselves. You're so consistently wrong it's starting to feel deliberate.
Clearly a question from a person who never written a coffee in his life. ; is eol and used by almost all credible language. But no, he want to leave dangling line ending so that each to compiler imterpret on their own and expected output is atthe mercy of compiler.
Java is totally still in use and regaining popularity. 
No. Semi colons are common in ever C derived language. Others languages have their own conventions.
This guy must have barely learned python and now thinks every language is like it.
We don't have semis in our code base. Just configure your linter to your preference and worry about getting the job done instead. 
This is called destructuring. It is essentially a limited form of pattern matching in other languages. What I am doing is saying give me the key secretSauce but assign it to a variable called _secretSauce and give me the rest of the contents of foo and assign it to a variable called restOfFoo. This allows me to pick off specific keys and create an object with only the keys I want. If you wanted, you could have directly name restOfFoo as clientFoo. It would be the same thing. Also, you don’t have to assign secretSauce to _secretSauce, but I find it makes things clearer to others that you don’t plan to actually use that variable. It was a pattern that many people used at first, but in general, everyone has agreed that it is unnecessary. Types and Interfaces are almost interchangeable so there’s no reason to mark name them differently. 
OK. and why not teach newbies how to write code with minimal semis. Saying that semis is a matter of style is kind of irresponsible because newbies like me will end up writing every line with semi. that's just bad in 2018.
I never said that, nor am I responsible for teaching any style. Our developers work out quickly what our linter enforces. Personally I could go either way because it literally doesn't matter. I do like consistency though.
How long did this take you?
Part time development, that is in the evenings about one week. The toughest part was always was choosing the css and interface layout.
The worst part. I hear ya. I have so much fun making the magic happen with the computer, then I have to make it look pretty too, come on!
What was the answer?
Always. They always help. YW
This. Ignorance of your data types doesn't magically make them not exist. Even for hackathons and pet projects I would still think having insight into data would be a net benefit. 
One of JSs biggest problems is random data being able to be assigned to variables in ways you're not expecting.
In terms of class versus implementation, there is no need to create a duplicate implementation of a classes as an interface. You can directly use a class as a type and set public and private fields for what you need. If you need a subset, you just use Pick again. The only time I have found implements to be useful is when I have a class that needs to implement a generic interface that I’m using across multiple classes or something like that. I will say that I this is cause I also generally prefer objects with separate functions that can accept that object’s interface rather then classes. In general js classes are a lie anyway so I found directly using objects with functions has fewer gotchas.
Our coding standards even prohibit them
I don't understand :(
[Context on Twitter](https://twitter.com/kitsonk/status/973651805950242816). Added by Daniel Rosenwasser. Screenshot for posterity: https://i.imgur.com/AN06Gqv.png
If you don't export Configuration it is impossible for other code to import it and use it I their type hinting.
Something like this? enum Foo { A = "AAA", B = "BBB" } function reverseLookup&lt;T&gt;(enumType: T, value: string): T[keyof T] | undefined { for (const key in enumType) { if (Object.hasOwnProperty.call(enumType, key) &amp;&amp; enumType[key] as any === value) { return enumType[key]; } } return undefined; } console.log(reverseLookup(Foo, "AAA")); // === Foo.A console.log(reverseLookup(Foo, "NOPE")); // === undefined 
Thank you, that's exactly what I need! I tried some variants with `keyof` and friends, but I wasn't able to find this (/a) correct solution. I'll have a closer look at what you wrote, and see if I can take away some general lessons. Thanks again.
This is now supported. Recent commits to recast and ast-types have enabled jscodeshift to work perfectly with TypeScript codebases (make sure to use the flag `--parser babel`).
How's the ["Investigate error messages in haiku or iambic pentameter"](https://www.reddit.com/r/typescript/comments/87hg3f/investigate_error_messages_in_haiku_or_iambic/) feature coming along?
Conditional types look to be really powerful feature, making it possible to write complex recursive types such as [`DeepReadonly&lt;T&gt;`](https://github.com/Microsoft/TypeScript/issues/13923) and the like. Really excited to see what else might come of it. Why the need for an explicit `infer` keyword though -- is there ever a situation where inferring a type var by default would be undesirable?
Yup! I'm the one who did the initial implementation (Ben Newman then picked it up and did most of the work). It was a lot faster than expected, thanks to Babylon 7's TypeScript support. The Babylon support was a lot better than I thought, and they make sure not to conflict with Flow and other JS constructs in the AST, which is a requirement for Recast.
Yes, I think conditionals \+ infer is going to be a game changer. The ability to unwrap types will simplify so much in many scenarios
https://twitter.com/drosenwasser/status/978676938666586121
A couple of notes about your code: 1. Convert Configuration from type to interface. 2. Default exports are a bad practice in TS.
What is the difference between type and interface, and what is the advantage?
The linked code contains no static or private methods. That said, the answer here is “you can’t”. Static methods exist at the class level, your private methods are on the instantiated objects of a class. The transpiled js works because it’s js and there is no types to offer that sort of protection. 
Anyone wants to demonstrate how to create "deep immutable" type with Immutable.js?
I'm still pretty new to all this, so take this with a grain of salt, but I *believe* the issue is that TS is actually structurally typed, not nominally typed. So in your example, both are technically type A because they both have members `a` and `b`. Unfortunately, I can't find any good way of forcing a type to *not* have a property. [Here's](https://stackoverflow.com/questions/48215950/exclude-property-from-type?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa) one example, but I couldn't get it to work quite how you want it to.
In both cases your return value implements interface A, it looks like.
In both cases you are returning something that satisfies "A". or "the type is assignable to A". The fact that it has an extra"c: number" doesn't make it incompatible.
A proper pipe function would be possible once Variadic generics lands. I'm not holding my breath though because the proposal isn't fully fleshed out yet. In the meanwhile, you could do something like chain(obj) .$(func1) .$(func2) .value This can be made type safe if `Chain&lt;T&gt;` has a method `$&lt;U&gt;(f: (t: T) =&gt; U): Chain&lt;U&gt;` which is trivial to implement. It is fairly usable if I say so myself.
i think getters are ok as long as they behave similarly to ordinary property access (no side effects + fast enough that it doesn't matter if it's accessed multiple times)
Do you think getters and setters in, for instance, c# is an antipattern?
Probably not what you want, but you can use a tagged union. You'd have to add an additional discriminator property, but you get the desired behavior. 
Being devil's advocate here, but if the behavior is similar to ordinary property access, why use a getter/setter at all?
That's actually the point. From the perspective of the person using the class they should be thinking "I can treat this just like a raw field". In C# properties are expected to behave in certain ways such as setting the same value twice is no different than setting it once. Methods don't have those implied guarantees, so we know to be more careful about them.
I haven't used C# extensively, but if they work the same way as they do in Typescript, with the same syntax, I'd have to say "yes". I don't mind the general *idea* of getters and setters in code, but using a getter or a setter should, in fact, require a method call, so that we know that *a function is getting executed* rather than *a value is getting reassigned.* 
Isn't externally observed behavior, by definition, a side-effect? That is, even the most innocuous (and useful) case *for* a setter I can think of: class Money { private _dollars: number = 0; private _cents: number = 0, set dollars(dol: number){ this._dollars = dol; this._cents = dol * 100 } set cents(cen: number){ this._cents = cen; this._dollars = cen / 100; } get dollars(){ return this._dollars; } get cents(){ return this._cents; } } let account = new Money() account.dollars = 100; console.log(account.cents)//=&gt; 10000 If you imported Money from another file, and didn't know that dollars and cents were getter/setter based, then you would expect that last line to console.log 0. You wouldn't even know where to begin looking for the error because you've just "assigned a value", you didn't "run a function that could change anything else. In other words, I think it's an anti-pattern to have a variable assignment have side effects. Yes, even an "observable." Again - not saying that this isn't how some people, coming from C# might prefer their code. *However,* wouldn't it be easier and more readable to expect this? class Money { private dollars: number = 0; private cents: number = 0, setDollars(dol: number){ this.dollars = dol; this.cents = dol * 100 } setCents(cen: number){ this.cents = cen; this.dollars = cen / 100; } getDollars(): number { return this.dollars; } getCents(): number { return this.cents; } } let account = new Money() account.setDollars(100) console.log(account.cents)//=&gt; 10000 Now, the counterargument (that I can already see) is that if you were to reassign account.dollars manually, then you'd end up with cents and dollars out of sync. But isn't that the entire point of the *private* (or protected) keyword? That those values cannot be accessed outside of the class declaration? 
I recognize your handle! Ahh, that's right, I edited my comment because I think it should have said `babylon` and not `babel`.
Logically speaking, dollars and cents are the same concept so it would make sense to a C# developer that setting one would change the other. For a more common example, changing `customer.firstName` implicitly changes `customer.fullName`. Maybe `fullName` is represented by a field. Maybe it is recalculated each time it is read. Either way `fullName` is still considered to be a dependent property of `firstName`. **** Here are some of the tests that one would expect to pass for all properties in a C# class. account.Dollars = 100; x = CaptureObject(account); account.Dollars = 100; //double assign same value y = CaptureObject(account); Assert.AllFieldsAreEqual(x, y); account.Dollars = 100; account.Dollars = account.Dollars; //self assign Assert.AreEqual(100, account.Dollars) account.Dollars = 100; x = CaptureObject(account); account.Dollars = 200; //change value account.Dollars = 100; //restore original value y = CaptureObject(account); Assert.AllFieldsAreEqual(x, y); 
If you require a function call, then it's harder to refactor from using a raw property to using a getter, which is very useful. The contents of a class are supposed to be be opaque. I have made my peace with that, and it relieves a lot of the mental burdon when programming.
I suppose what I *really* oppose is the execution of just about any code you want - all without it being opaque to the end-user exactly what you're doing. I wouldn't mind, particularly, in your example with customer.firstName, if fullName depends upon firstName, that customer.fullName would actually be a *method* that returns a value rather than a value itself. To me, this behavior is the thing that *worries* me: let bb = new Person("Brian", "Boyko") console.log(bb.fullName) //=&gt; "Brian Boyko" bb.firstName = "David"; console.log(bb.fullName) //=&gt; "David Boyko" Looking at that code, it's **transparent** that bb.firstName got reassigned. But it's **opaque** as to where bb.fullName got reassigned. let bb = new Person("Brian", "Boyko") console.log(bb.fullName()) //=&gt; "Brian Boyko" bb.firstName = "David"; console.log(bb.fullName()) //=&gt; "David Boyko" Here, it's less opaque (but still a little misty) - The state of the BB instance got changed somewhere in between the two function calls, and while it's not necesarily the bb.firstName = "David", that's a good place to start debugging. If you're running the same method with the same parameters and getting two different results, you know the result is that the state the method depends on has been mutated. 
getters and setters are actually standard ECMA5 features, they have been around for a while. If they make you nervous I'd suggest you don't look into Proxies... :-)
Well, now you know that a function IS getting executed whether you set a getter or not (in which case the default getter is executed). You just have to think as a.x = 123 as a shortcut for a.set('x', 123);
Getters and setters come from OOP (Java, C#) where one of the basic rules is that you never ever make a property public. Hence public getters and setters.
is this right? type Identity &lt;T&gt; = { value: T, map: &lt;U&gt; (f: (value: T) =&gt; U) =&gt; Identity&lt;U&gt;, chain: &lt;U&gt; (f: (value: T) =&gt; U) =&gt; U, }; const identity = &lt;T&gt; (value: T): Identity&lt;T&gt; =&gt; { return { value, map: (f) =&gt; identity(f(value)), chain: (f) =&gt; f(value), }; }; i don't know what you'd use it for so it might be wrong it uses [generics](https://www.typescriptlang.org/docs/handbook/generics.html)
Your interface syntax is wrong. interface Identity { value?: any, map: (f: Function) =&gt; Identity, chain?: (f: Function) =&gt; any }
This is how I'd probably do it. I might set an extends to my `T`. Something like `type Identity &lt;T extends object&gt;`, just to tell the TS compiler that T isn't going to be a primitive.
You bet :)
&gt; But it's opaque as to where bb.fullName got reassigned. That's called "encapsulation" and, in a broader context, the OOP concept of "programming to the interface, not the implementation". The basic idea is that you should be able to use just the object's public interface and trust that it will do the right thing.
How would you ever use `isString&lt;T&gt;` in code? What's the value of that over a function?
I actually wish Yeoman was used more. Whenever I do a Node project with TypeScript, I always start with the tsconfig.json from Microsoft's official Node/TypeScript starter repo. It'd be nice to have it just be a `yo` command away instead.
Just to start with the biggest items: using a getter/setter function breaks core JavaScript/TypeScript language features, like object property enumeration or destructuring, as well as various higher-order functional programming patterns. Using properties where possible makes your code work with the rest of the language better. More abstractly around the topic of getters and setters, note that it's common for developers to have a strong expectation when seeing `setFoo(x)` or `getFoo()` that these are _cheap_ and _efficient_ functions. If they're doing anything else, a good style guide would recommend that they be named appropriate to strongly indicate what they're going to do. Treat functions as verbs: if the function doesn't just get a value, it shouldn't be called `get`. In a language without properties, one could argue that a getter function signifies that there _might_ be bad code involved. It's a hint of potential dragons. That's just not true in JS/TS though because property getters are a thing; there simply is no strong guarantee that any `x.foo` isn't evil, so we have to check (or trust our libraries) rather than relying on syntactic warning signs. Getter functions are sometimes just used for consistency in some languages. There's no easy standard way to have a read-only public field on a non-const object in C++ for example, so maintaining proper encapsulation around a field that has value constraints requires using a getter function around a private variable (with no corresponding "dumb" setter). And once you have getter functions for some fields it just looks weird to have other fields be public. This again isn't a problem for TypeScript, because it _does_ have read-only public fields. The final argument for getters/setters in a language like C++ is that there _might_ someday be a change required to a setter to enforce a constraint, but it would be a source-breaking change to make a public field become private, so the code might as well just use getters/setters from the start for "forward compatibility." This again isn't a problem for JS/TS because property setters exist, so you can evolve code and strengthen constraint checking without source breaking changes even without setter functions.
I see the need for conditional types to enable some popularly requested types such as `NonNullable&lt;T&gt;` and `DeepReadOnly&lt;T&gt;`. However I can't think of a time I'd ever need to use conditional typing myself in specific application code. Is it just for helping write these kind of general types or could someone provide me a personal example they're excited about.
Personally I think getters and setters can be useful. But they should be used for stuff like library developers. Like having a game library where there is a object pool in the background when you allocate stuff. Etc. Otherwise its not so smart to hide stuff imo.
So why use functions at all, instead of only getters?
Well this function is at the type-level, so it has no run-time impact because it gets erased when ou compile. It is still abit contrived. I'll give a useful example where you want to say something *isn't* a specific type We want a special to string function that accepts anything that isn't a string. We use a conditional type to tell us if a type is not a string, using `never` as the special type-level false value, and returning the type otherwise. type NotString&lt;T&gt; = T extends string ? never : T; function myToString&lt;T&gt;(x: T &amp; NotString&lt;T&gt;): string { return (x || "").toString(); } myToString(43) // ok myToString("hello") // error The intersection type basically says it must be `T` and `T` is not a string. This works because if `T` is a string, then `NotString&lt;T&gt;` = `never`, and an intersection `T &amp; never` = `never`. Otherwise, we get `T &amp; T` = `T`.
Is it possible to use a cache so that if `t === t1`, then `Optional.of(t) === Optional.of(t1)`?
You use methods because on occasion you'll need to get a response from an class, that requires multiple parameters. Getters take exactly zero parameters. If a method doesn't require any input, ever, then its *might* be better off as just a property-backed by a getter to generate the result on-the-fly, just in time.
=== is reference equality for objects and value equality for primitives. AFAIK there's no way to overload it. Maybe == should work but I don't recommend it. Is there a reason why Optional.of(t).valueOf() === Optional.of(t1).valueOf() doesn't work for you? valueOf is guaranteed to give the exact contained value or null by design.
It has nothing to do with overloading. If you see an object `t` that you've wrapped in a proxy before, instead of creating a new proxy, re-use the old one so that object equality is preserved. You can extract the value using `valueOf`, as you say, but it seems nice if reference equality is preserved for the optional itself.
So, yeah, this post puts into words the feeling in my gut that I didn't have the experience and knowledge to say. 
Again, not a problem with getters or setters (I use them in what little dabbling I've done with Java) - I have a problem with a property assignment running any code other than assigning a value to a property. 
First, It can only work for primitives and in case of primitives, I already return the actual value instead of proxy so === should work. For objects, I have to return a proxy because it might a field x which might be null. If I return the object itself calling .x.foo would cause an exception when x is null. Secondly, I don't think caching rules should be the library's business. The implementation is 50 odd lines so you can try doing it yourself. I may expose a plug-in API for you to do caching but it really seems overkill for such a small library.
Until TypeScript supports private set, public get on class fields (which the core team have been resistant about, because it doesn't mirror any JS phenomenon), there's no alternative for restricting read/write access to fields, unfortunately. However, using them impedes refactoring (this is a real headache when using builder pattern), increases code size and – more than anything – increases the developer's keystrokes.
This doesn't only work for primitives, here is basically what I mean. const cache: WeakMap&lt;object, any&gt; = new WeakMap(); function makeOptional&lt;T&gt;(x: T): IOptional&lt;T&gt; { if (x === null || x === undefined) { return nullProxy; } if (typeof x === "object" || typeof x === "function") { if (cache.has(x as any)) { return cache.get(x as any); } const proxy = new Proxy(x, optionalProxyHandler); cache.set(x as any, proxy); return proxy as any; } else { return x; } }
The issue is that excess properties fine allowed in assignability. TypeScript will do excess property checking at initialisation: interface A { a: string; b: string } interface B { c: number; d: number } function f(a: number): A &amp; B | A { if (a) { const res: A &amp; B = { a: 'asd', b: 'zxc', c: 2, d: 4 }; return res; } else { const res: A = { a: 'qwe', b: 'zxc', c: 3 }; // error return res; } }
I think you hit the nail on the head. They're likely not for everyday usage, but they're useful for certain difficult-to-express scenarios.
&gt; I'm not saying that t === makeOptional(t), I'm saying makeOptional(t) === makeOptional(t) Oh I see what you mean. I'll add an optional cache argument to makeOptional. I don't think I'll make it the default behaviour though.
Ye I didn't explain it well, sorry. This is one nicest uses of proxies I've seen actually!
What are the public properties and methods of Something and Bar? If they are the same or if Something is a subset of Bar this is the intended behaviour.
Oh, I didn't know that. Thank you!
I sort of agree with the anipattern crowd. But one place I've seen them be helpful is when you need to validate the assignment. Make sure it's the right kind of value etc. Granted this is probably done like that more so in non strongly typed languages. But one of the things I like a bout properties in python is that you can make the access of the property through getters and setters totally transparent. They use it exactly like a property but it still gets validated by the getters/setters. That being said in recent times, especially after learning more about functional languages, no side effects, and even reading the clean code series, I think they make code not as clean some times. My only requirement for getters and setters would to have little to no side effects.
Nice! Might use this for a library!
Here's a more robust implementation: https://github.com/tycho01/typical/blob/master/src/object.ts#L242
No, yeah, you're definitely right. I'm not sure what I was thinking about there. Sorry about that! I was mixing up the fact, I think, that string literals on types aren't emitted. I forgot about the fact that you have to have it to actually *use* the switch statement. interface Circle { kind: "circle"; radius: number; } class CircleThing implements Circle { radius = 3; kind: "circle"; } This is actually valid without `strictPropertyInitialization`, however if you need to actually *use* the discrimination in, say, a switch function, you need to actually have `kind = "circle"` instead. Actually, I'm gonna go mess around in the Playground and see if I can get an example working.
Okay, yeah, if you don't need the emitted code, how I said actually does work. [Here's a playground example](http://www.typescriptlang.org/play/index.html#src=class%20Something%20%7B%20%0D%0A%20%20%20%20type%3A%20%22something%22%3B%0D%0A%20%7D%0D%0Aclass%20Foo%20extends%20Something%20%7B%20%0D%0A%20%20%20%20number%20%3D%201%3B%0D%0A%20%7D%0D%0Aclass%20Bar%20%7B%20%0D%0A%20%20%20%20number%20%3D%202%3B%0D%0A%20%7D%0D%0A%0D%0Ainterface%20SomethingClass%3CT%20extends%20Something%3E%0D%0A%7B%0D%0A%20%20%20%20new(...args%3A%20any%5B%5D)%3A%20T%0D%0A%7D%0D%0A%0D%0Afunction%20whatever%3CT%20extends%20Something%3E(x%3A%20SomethingClass%3CT%3E)%20%7B%20%0D%0A%20%20%20%20console.log(x)%3B%0D%0A%20%7D%0D%0A%0D%0Awhatever(Foo)%3B%20%2F%2F%20ok%0D%0Awhatever(Bar)%3B%20%2F%2F%20I%20want%20the%20compiler%20to%20catch%20this%20mistake). However, the `strictPropertyInitialization` setting will throw an error on `Something`. If you're okay with emitting and want to pass the compiler flag, then just change it to `type = "something"`.
checked it out - not sure what you mean by robust - it doesn't handle tuples properly and strips out functions. aside from that, it seems to be the same.
You can simply do: ``` art.unshift(art.pop()!); ``` Which means you are telling TS that you are **certain** that the return value will not be undefined, thus it is always a string. However throwing around `!` can be dangerous, so only do it if you are sure there is no way to re-write your code where TS can naturally type-check without you having to override it. Also, `count` is never re-assigned so make it `const`.
Yeah, I wanted to respond with an answer that more accurately addressed your question, while explaining why it can be considered bad. Many tslint configs forbid it for that reason :D The other option would be to do: art.unshift(art.pop() as string); Which you are saying to TS, "Though this could be `string | undefined`, I know it will be just a `string`". --- Another option you might see in more TS code is just to respect the types are refactor your code: const line = art.pop(); if (line === undefined) { throw new Error("something bad happened!"); } art.unshift(line); This will not produce an error as TS is smart enough to know that after that `throw` statement, `line` can no longer be `undefined`. This also has the added benefit of catching errors down the line (potentially, though this small function should be fine without it).
I'd turn off that tslint rule, personally. This is a great situation to use a non-null assertion, which IMO demonstrates why a blanket prohibition is too agressive. But that depends on your project and your team; you'd know better than me.
It’s just a personal project. I feel dirty turning lint ruled off tho 
One trick if you want `strictPropertyInitialization` *and* the type-checking: you can just make the property optional and it'll still result in a compile-time error with no emitted code. 
 // tslint:disable-next-line:no-non-null-assertion Turn it off for one line without having to lose the usefulness of the rule otherwise. &gt; which IMO demonstrates why a blanket prohibition is too agressive. I disagree. It's very easy to put in exceptions and blanket prohibitions like that make you think twice about them.
It's your call; whatever leads to better code in the long-run. At least that's my philosophy.
Thought about it too, thanks. Found some related issues: [Don't widen return types of function expressions](https://github.com/Microsoft/TypeScript/issues/241) [Exact Types](https://github.com/Microsoft/TypeScript/issues/12936)
Found absolutely no documentation.
`as` is a way to do type assertion in TS: https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions Hope this helps!
I've found Maxamillian's coursework on Udemy to be very helpful so far (I'm 1/3rd of a way through it) on understanding the value of Typescript. Now there are two things to ask: What is the value of static types in Javascript? and What is the value of Typescript? These are two different things - FlowType, for example, provides type checking but little else. So, what is the value of static types? It allows you to more clearly see when you could pass in a value that *would have* caused an error at runtime. If it's possible for a value to be undefined, but you try to access a property on it - you will get notified that that is a possibility *while you write the code* rather than having to discover this scenario yourself. If you need to do math on a variable but you actually use the string version of it ("2" + "2" =&gt; "22") Typescript will tell you. This is especially helpful when working with a team to develop software because *even if you didn't read the source code someone else wrote*, you can get warned if you're passing in an incorrectly formatted input or getting back and incorrectly formatted output. Now, Typescript (unlike Flow) takes this further by adding in protections that are standard in Java and C# that are not standard in Javascript. It doesn't require, but *strongly encourages* the use of an object-oriented structure for your program - where each part of your program stands alone and simply interfaces with the others. It provides ways to ensure properties on an object are read-only, for example. The result is that if your team works in Typescript, it is a lot easier to manage the code and prevent each other from "stepping on each other's toes." 
__dunder__
Define art as an `Array&lt;string | void&gt;`? If you are unshifting `undefined`, then it is not a `string[]`.
When I first came to javascript land from .net land, I was looking for something to replace linq. Lodash is the defacto standard for that. What does this project bring to the table that lodash doesn't?
Have you tried `art.pop() as string`? Worst case scenario, you just typecheck: const thing: string | void = art.pop(); if (thing) { art.unshift(thing); } 
Yep that’s what I ended up doing. Thanks for your input!
Lodash does a lot of type checks that are not necessary with TypeScript methods. For example look at their delay function checking typeof func. Additionally lodash doesn't use iterables and async iterables which are newer constructs in JS.
The link I provided probably got completely messed up because I was trying to url encode it so Reddit would format the link text correctly. I think I messed it up! But anyways I have a concrete example of my problem that I will send you when I get home. It might just be poor class design that is restricting me from doing what I want to do. But I'll link it when I get home. 
Yeah that site puts the entire code text in a query string in the url. But it didn't encode it so Reddit was freaking out when I tried to format a link that had stuff like parentheses in the url. I tried to surgically url encode the link but it clearly didn't work!
You are not supposed to have a return type on your constructor, are you? And I don't think you should call it without `new`. Just because it's possible in js, with the prototype system, it's not necessarily a good idea if you use the `class` keyword.
This does not answer the question.
I can't educate you on the concepts of encapsulation in the span of a comment, but it is a topic you should research along with API design in general.
Huh. [Fun fact, the latest version of TypeScript solves your problem](https://blogs.msdn.microsoft.com/typescript/2018/03/27/announcing-typescript-2-8/#conditional-types). They've added an `Exclude` built-in type using the new conditional type mechanics.
Good call! I updated the code in the post to use `never` instead of `void`. Thank you so much!
Thanks, I'd love to see that!
So you used a preset for your linter, and complain that one of the preset settings changed your code? :) How about adding rules and disabling that one, or writing your own rules? Linters and Formatters are great. No reason not to use them. 
Correct me if I'm wrong (you may have configured your linter differently) but linters don't change your code; you do. The linter simply points you to your own code smell. In this case, it seems the regression test came from your failure to understand the map function call parameters as well as your own overloaded method name. In this case, I would reconsider whether overloading a function called array in a way that isnt synonymous with the language itself (map being a well-defined feature) is really smart or necessary. After weighing the pros and cons of changing array, I would then either change it, or remove the linter rule from my project. The linter is just a code secretary. You make the final call. Be the boss of your own code!
Seems to me the linters uncovered a case where you were using a non-mapping function as a mapper. Instead of instantiating an anonymous function every time the `map` call is executed, why not create a mapping wrapper for the non-mapping function and use it as the linter suggests? Or just turn off the linting rule in question, a process easily done by line, by file, or even for the whole project?
Indeed I was not in any means criticizing the use of linters. They are great and I use them. I did exactly what you did by using a preset configuration and overriding it with my custom flags. The idea is more to underline that some of the autofixed rules might break a code so devs have to use them carefully :) 
Basically I used the --fix of tslint in order to automatically fix simple rules. So yes, the fix has been done by the linter. My choice was simply to remove the rule. I might have opted for a local suppression too. But I found it risky knowing the autofix. 
Interesting. I wouldn't recommend letting the lintrr auto-fix things for you. It's a very useful tool, but I can see how auto-fix will lead to the exact types of frustration you encountered here
It was indeed, more or less, the aim of the article: do take the output of the auto-fix carefully. Nonetheless I really think it can be useful to use it to fix easy things such as: for of instead of index loop, no var, const when possible... I will update the article to be more precise on this point. Thanks for the comments 
I will update my article to be more precise on those points Thanks a lot for the comments and the time you took to read this article 
Thanks, I'll give it a shot.
Optional argument is not a good practice in JavaScript/TypeScript. Since there's no language level support for it, it means every time it's used, * it forces you to have a code in your function accommodate it (extra if statement or ternary) * forces compiler to do more work in generating virtual functions with different signatures * potentially hiding assumption from the user Just split it up with different names: ``` array&lt;T&gt;(generator: Arbitrary&lt;T&gt;) arrayWithMax&lt;T&gt;(generator: Arbitrary&lt;T&gt;, max: number) ```
I wrote a book on this with a dozen or so associated videos that might be worth your time. It's not an interactive class though. https://pagalvin.gitbooks.io/yet-another-typescript-book/content/ 
Worth a shot, thanks. I'm checking the other link in this post right now.
Following the useful comments provided by some of you, I updated the content of the article in order to be clearer about the "problem" and the possible ways to mitigate or fix it
While I perfectly agree that the language does not offer an easy way to do that. I partially disagree on the fact that it is not the right way to write JavaScript. As an example I would say that lots of functions provided by built-in JavaScript itself do have such optional arguments. For instance I would have encountered the very same issue if my code was the following: ``` const findRankinksOfCompetitor = function(nameOfCompetitor) { return rankingOnLastRaces.map(rankingRaceX =&gt; Array.indexOf(rankingRaceX, nameOfCompetitor)); } ```
You have a very good point. I have not thought about the problem related to the declaration of this anonymous function: instantiating an anonymous function every time the map call is executed. Indeed declaring the function outside correctly would certainly be the best approach. Concerning the idea to use the code suggested by the linter, it is not possible in my case as it changes the behavior in a bad way. The idea I selected so far was to remove this rule from my set of rules in order not to experience the same problem in the future (with auto-fix). But I think I will go for your suggestion of creating a wrapper ;)
Just because built-in function has optional arguments doesn't mean the API is flawless. There is huge issue with the optional argument of `parseInt` that the Committee had to recreate it with `Number.parseInt` to both preserve backwards compatibility and fix the broken assumption. Also I don't know the context of your code to see anything wrong about `findRankinksOfCompetitor`. The linter wouldn't collaspe the inner function to a function object.
That's neat!
Thanks a lot for your example. Hopefully, on my side, units detected the issue
When I saw your description of this issue I thought Typescript was selecting the incorrect function signature. However, the signature of map takes a function with a third parameter, and I believe that is what is causing your two parameter method to not be selected. &gt; map&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[]; I could be wrong though. Maybe you've just fallen into the "[first matching overload](http://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)" trap: &gt; Don’t put more general overloads before more specific overloads: /* WRONG */ declare function fn(x: any): any; declare function fn(x: HTMLElement): number; declare function fn(x: HTMLDivElement): string; var myElem: HTMLDivElement; var x = fn(myElem); // x: any, wat? &gt; Do sort overloads by putting the more general signatures after more specific signatures: /* OK */ declare function fn(x: HTMLDivElement): string; declare function fn(x: HTMLElement): number; declare function fn(x: any): any; var myElem: HTMLDivElement; var x = fn(myElem); // x: string, :) &gt; Why: TypeScript chooses the first matching overload when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called. 
Reading further on the Do's and Don'ts page gives us a little more insight: &gt; TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, and extraneous arguments are allowed.
Turning `strictNullChecks` off should be an absolutely no-go in modern code bases. And dude, that profile picture...
What I miss in every Angular tutorial is how to use Angular with `strictNullChecks` enabled.
quicktype can now convert your TypeScript types to any of its supported target languages. Of course you can still use it to infer your JSON types as well, or give it JSON Schema as input. Under the hood, in fact, it uses [typescript-json-schema](https://github.com/YousefED/typescript-json-schema) to convert the TypeScript types to JSON Schema, which it then converts to your chosen target language. Let us know what you think!
The library is written by the same guys who wrote the manual on [Functional Reactive Programming](https://www.manning.com/books/functional-reactive-programming?a_aid=playscala). The author has stated that, had he written the book today, he'd have done it with TypeScript examples (instead of Java).
All tested with C# code generation. - Does not support conditional types at all. - Does not support number literal types at all. - Does not support tuple types at all. - Does not properly support indexer types with known properties. - Does not properly support types with methods (they should be stripped). - Does not support `readonly` properties. - Does not support generics. - Does not support read-only target types. - Does not support choosing the appropriate type for `number` (a dictionary key of `double` is a **really** bad idea). - Produced code will fail when one of the keys is set to `undefined`. - Using a `struct` to hold all possible types of a union type is pretty wasteful. - The code contains mutable structs. - The code contains structs that don't override `Equals` or `GetHashCode`. - The code uses enums for string literal types. - The code creates a dedicated enum for every literal types. - As a result does not support discriminated unions. - Does poorly support union types, all properties across the union types are marked as optional in a new type.
Thanks for the feedback. A few questions: * Did you see the comment in the example `/** @TJS-type integer */`? Is that not what you mean by choosing an appropriate `number` type? If not, what would you prefer? * Did you manage to generate a dictionary with `double` keys? If so, how? * How would you expect union types to be represented in C#? * How would you expect string literal types to be represented in C#? * What do you mean setting a key to `undefined`? We have a bug where we fail to generate code for type `undefined`, but maybe that's not what you meant?
Goes to white page when converting to JsonSchema. (erros out)
What's the input you're giving it? Could you post a screenshot, please?
Rolled back a deploy to fix this, thank you for letting us know!