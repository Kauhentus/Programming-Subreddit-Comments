The primary web app I'm working on is [https://ohayo.computer](https://ohayo.computer/) I'm in the process of open sourcing it, hopefully will be done by EOW, so can't send a link to the full example yet. But it's a light app layer on top of a framework called TreeComponentFramework, and the Browser Abstraction Layer I call Willow for now, and the code mid-port is here: [https://github.com/breck7/jtree/tree/master/treeComponent/willow](https://github.com/breck7/jtree/tree/master/treeComponent/willow) And here is the Tree Language I created for writing Integration Tests ([http://treenotation.org/sandbox/build/#standard%20swarm](http://treenotation.org/sandbox/build/#standard%20swarm)). Although I actually extended that language to a language called "Monkey", and that will be open sourced with the rest of these things as soon as I finish them. So here is some test code written in that "Monkey" language. It creates the App, creates a program in the app, ensures there is some text there, simulates a paste command, and ensures correct rendering, then compiles the pasted text (and then goes on, but I cut it there). #! /usr/local/bin/node --use_strict /usr/local/bin/jtree arrangeTestSubject require /aientist/client/treeComponentFramework/OhayoTreeComponent.js async test compile createNewBlankProgramCommand hello-world.fire stringIncludes getWillowProgram.getPageHtml hello-world pasteCommand blockStringParam set$ greeting Hello world log$ greeting lengthIs getMountedProcess.getProcessTiles 2 saveCompiledCommand
&gt; As for the problem with having to wait until evaluation, it's simple: just treat require as a keyword and handle it specially This doesn't solve the problem at all. It still means a module must be evaluated to get its exported API. Native import/export doesn't have this problem.
&gt; It still means a module must be evaluated to get its exported API Not if the module is written in TypeScript, though, right? // square.ts const square = (num: number) =&gt; num * num module.exports = {square} // four.ts const {square} = require("./square") console.log(square(2))
What if square.ts's exports are dynamically generated? // square.ts const api: any = {}; api.square = (n: number) =&gt; n*n; api.cube = (n: number) =&gt; n*n*n; // More modifications to api could go here module.exports = api; // four.ts const squareModule = require("./square") // squareModule's contents unknown until square.ts is evaluated, // because its exports are built dynamically You could partially solve this by requiring exports to be fully statically typed, but if you're putting restrictions on it why not just use the import/export syntax that already exists? It also doesn't solve all of module.export's problems, e.g. tree shaking is still difficult. It's also a Typescript-specific solution. /u/agaricide's comment applies not just to TS but to the JS ecosystem in general. Besides TS being a superset of JS, unless you have no external dependencies in your TS project you're probably using some JS as well, and a solution would need to work with both languages.
https://github.com/snowPu/ngx-beautiful-charts/blob/master/tsconfig.json No strict flag. :-(
It's node that is shit. They have their own incompatible import method and took years to adopt import.
Cannot easily be edited by Content Management Systems (CMS) - I'd put it into one of the best advantages! The last thing I want anyone to do it so be able to edit the code in the server bypassing ci/cd, source control, review and many other important steps!
I've seen many getting started tutorials and this one really looks quite a good one, so I'd recommend this to beginners.
We ditched gulp years ago in the favor of Webpack on every project at the company. We use Babel only to compile TS and tsc only to run type-check during CI. During development it's perfectly enough what the IDE is reporting.
Okay, following [CONTRIBUTORS.MD](https://CONTRIBUTORS.MD) I needed to spec it out a bit first: [https://github.com/microsoft/TypeScriptSamples/issues/156](https://github.com/microsoft/TypeScriptSamples/issues/156)
Is it a front end only project? I do have a backend part and a few files need to be copied over to the build folder, not sure how Webpack can do that? Can it?
No. For backed we use node-babel during development. Than compile with babel for production. Still using tsc only at CI.
why not just use tagged unions?
Using overloading will be **much** more efficient for the compiler. This is not a good use-case for conditional types.
Hi Sean, I realise after quite a long time that OvernighJS does not like leading slashes for the route when putting it into the @Controller() decorator, i.e. @Controller("api") will work but not @Controller("/api"). This behaviour does not follow the standard of ExpressJS, so people may not continue to use if they dont know where the error comes from (at least from my own experience: I almost dropped it lol). So maybe you should consider update the README, or try to follow the ExpressJS standard. Other than that, it's a lovely package, thank you.
good tip, but I would prefer `const enum` in this case. Generated code is just a string. https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgYRAGxAJwjAbwCgYZgALOHHATxgF4YAiAYgDEBOARg4GY2mAGhIxkAQzwNm7HgAZeAdiEjkcKHFxTWbNgFFeaABxMiAXwDcRIqEhY4AOmwBzABQZseexSq0AlOaA
Read the article first . I’m not suggesting using conditional types
Flow doesn't show [comments in an IDE](https://github.com/facebook/flow/issues/2956) eventually became the the reason I started looking elsewhere when I first started writing JavaScript. I looked into contributing that feature to the codebase but it was in a language I'd only use for contributing back to Flow and after a few hours threw in the towel.
Yeah you can do this with [file-loader](https://github.com/webpack-contrib/file-loader)
That looks like a regular union type. I'm not sure what you mean by preceding.
If you mean the declaration looks like: | HandlerFunction | HttpFunction | EventFunction | EventFunctionWithCallback it's just a stylistic thing
Yeah, I think that's what I was getting at. Is the code I linked a type alias? Meaning that `HandlerFunction` can be any of those three types, and the pipe in front of the first in the list is to make it line up nicely?
You didn't link any code so it's hard to say. But the preceding `|` in a union is available for code prettiness, it doesn't change any meanings.
Sorry, I meant to link [this](https://github.com/GoogleCloudPlatform/functions-framework-nodejs/blob/master/src/invoker.ts#L112). I've got a cold today and it slipped my mind.
Woah nice I didn't know `const enum` was possible
Yeah, that's just stylistic, it doesn't mean anything different than if the preceding `|` wasn't there at all.
Considering the gigantic push for import for the last 4 years, the time it has taken to get here and their current implementation is a real turn off. Hopefully deno can clean up some of this mess.
Your last example appears to be conditional typing using a map instead of nested comparisons. What makes it not conditional typing?
Hmm, all the examples I gave in the readme show not to use a leading slash. I wonder if I should update the library or just the readme to say don't use a leading slash.
Not really a question for this sub, but you’ll want to use the `map` or `flatMap` observable operators to transform the result of the request
Can you give me an example for it? Im not used to this much.
You can go one step further and use exhaustive checking with this approach as well. You use a switch and in the default case you assign to never. Then if you forget to handle a case TypeScript will gently scream at you that you are assigning to never.
The [documentation](https://www.learnrxjs.io/operators/transformation/map.html) can describe it much better than I can, and further googling could get you better examples than the documentation.
I was starting a project. At the time I was stuck on a 32-bit Linux version, and somewhat Flow required a 64-bit one, so TypeScript won. And I'm using it since then. Interestingly enough, at the time, Flow was first choice, mainly because of my hate towards Angular (the new Angular, not the old one).
It's a pretty basic app; mostly a "Hello world" at the moment. Webpack takes 32 seconds to build. The webpack-dev-server suggestion was helpful, but I am not sure how to apply it. Let me clarify. I have a project with a ts+node+express server which shares types used with a ts+react app (both in the same project). The ts+node+express server is compiled with tsc but during development, I use ts-node-dev to do live reloading. Those both work without issue. The ts+react app uses webpack. When I do a full compile, it works fine. The ts+node+express server serves the content of the ts+react+webpack app out of a /dist folder and everything works as-expected in the browser. The part I haven't been able to get working is some sort of quick-rebuild of the web code. I've tried both a "tsc --watch" and a "babel --watch" approach, but in the browser I get a lot of errors around handling the import/require. I'm pretty new to all of these tools, so I'm not quite sure if I'm on the right path.
Why not have two separate methods instead of one?
Do you mean this conditional type? type CreatedElement&lt;T extends string&gt; = T extends keyof AllElements ? AllElements[T] : /** 1 **/ HTMLElement; /** 2 **/ declare function createElement&lt;T extends string&gt;(tag: T, options?: any): CreatedElement&lt;T&gt; Sure, you could also rewrite it with overloads as: declare function createElement&lt;T extends keyof AllElements&gt;(tag: T, options?: any): AllElements[T]; declare function createElement(tag: string, options?: any): HTMLElement; However, if you have many functions which use this pattern, you have to repeat these overload definitions for every function. If you add new overloads to one function, you also have to manually remember what other functions need additional overloads. By extracting a helper type like `CreatedElement`, you consolidate those overloads into one single type definition. As for compiler performance: I doubt you'll find a noticeable difference between using a conditional type and using overloads in this case. You should pick whatever makes your code more understandable and maintainable for humans. Only if you notice a measurable difference in performance, should you start worrying about "optimizing" your types (or perhaps file a bug for the TypeScript compiler itself).
In my real use-case I'm setting a lot more address fields and doing some side effects so it's nice to have the single method that accepts a type. I'm realizing though this is just something with TypeScript in general—string concatenation doesn't seem to work. Here's an even smaller use case: &amp;#x200B; [https://www.typescriptlang.org/play/#code/C4TwDgpgBAogjgVwIYBsDOAxAlgJzcAOSQFtoBeKAcgDNd8jTKAoJgYwHsA7fKAN1QQQAXLESpMdQiXJVaeYJSgBqKgwjMgA](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogjgVwIYBsDOAxAlgJzcAOSQFtoBeKAcgDNd8jTKAoJgYwHsA7fKAN1QQQAXLESpMdQiXJVaeYJSgBqKgwjMgA)
 function getOrderField(type: 'billing' | 'shipping'): keyof Order { switch (type) { case 'billing': return 'billingAddress'; case 'shipping': return 'shippingAddress'; default: throw assertNever(type); } } function assertNever(value: never): never { throw new Error(`Unexpected value: ${value}`); } You can't use string interpolation or dynamic strings for what you want.
Don't create methods with args like this, definitely a smell. If I was doing a code review of the code you'd posted I'd request you create a \`setBillingAddress\` and a \`setShippingAddress\` method, which would avoid the issue you're having altogether.
There's actually [an issue relating this](https://github.com/microsoft/TypeScript/issues/12754#issuecomment-511460517) which I myself am subscribed to due to my need of such (or similar) functionality. Currently TypeScript doesn't support what you're trying to achieve by doing it this way. What I can offer you is to create a type that maps the address type to the property name: ```typescript type AddressType = keyof AddressTypeToPropertyNameMap; interface AddressTypeToPropertyNameMap { billing: 'billingAddress'; shipping: 'shippingAddress'; } type Order = Record&lt;AddressTypeToPropertyNameMap[AddressType], string&gt;; ``` I know it ain't the prettiest of typings, but it does what you want: ```typescript function setAddress(type: AddressType, address: string, order: Order) { order[AddressTypeToPropertyNameMap[type]] = address; // works! } ```
Experimental in node ! not in the ES standard
I'd say don't concatenate. Just use the whole key. [here is a REPL with it working](https://www.typescriptlang.org/play/index.html#code/JYOwLgpgTgZghgYwgAgPJQCbWQbwFDKHIBGwANmaAOYCCGGUEAzkwPwBcyTYU1A3ASJMAFsAAOY6nQbM2nbrxBUBAXzx4EAexDdkmzNE7osUZAF5cgwqQpT6jFpwDkTgDRWuoiXZmPkLvDU8GABXEAQwYG0uCDBpByYACjAATzEITgBrCBTNGDQDKFdkOHtZeR5qYv0TI0KASksiPUKAbVT0gF1zErKWZAB6AeQAFVEmZEoQFGgofQnNELBOQPUmWPjZRKcbKdo+pjd-ADYAFmQAWRTkAGUeCFjikc0AdxBkAFUQYEgMW7A4JBDtUGkA)
Yeah webpack-dev-server is all you need. It is a development server that will detect changes and reload. I am literally using it right now. I think if you just google it a bit you should be able to find a tutorial on how to use it, it isn’t hard to setup. I just have it as a package script, like ‘npm run dev’
Confirmed :+1:
Here's the problem. I need my build tool to change about 10 lines of code in my project. WebPack+WebPack Dev Server requires 6,261 files, and over 500,000 lines of code! WebPack stats: \--------------------------------------------------------------------------------------- Language files blank comment code \--------------------------------------------------------------------------------------- JavaScript 3388 57185 90828 333265 JSON 686 1 0 70925 Markdown 653 28710 2 68876 TypeScript 125 2286 8371 10865 HTML 40 90 1 7020 C/C++ Header 21 1148 351 5984 YAML 89 60 40 984 Bourne Shell 4 168 113 819 CSS 5 34 12 735 Windows Module Definition 5 88 0 454 C++ 6 64 31 288 JSON5 2 0 0 123 make 7 46 7 116 CoffeeScript 2 10 7 49 Bourne Again Shell 2 11 1 43 Handlebars 1 5 0 23 DOS Batch 1 0 0 2 \--------------------------------------------------------------------------------------- SUM: 5037 89906 99764 500571
I appreciate it, and will explore it more. If I can get a lot more value out of it than just fixing this tiny import problem it may be worth it, but as my other post says that would be adding half a million lines of code to fix 10. As the adage says, a little copying is better than a little dependency.
I can understand the frustration. If all else fails you can use CommonJS imports in TypeScript with the `import = require` syntax as described [here] (https://www.bennadel.com/blog/3259-using-import-require-syntax-with-typescript-2-2-in-angular-2-4-9.htm). That avoids complications of shimming CommonJS modules to act like ES6 modules.
watts is the dynamic/concetenated string and &amp;#x200B; when i can use this script
You can do it safely and dynamically with string interpolation with a type guard: interface Order { billingAddress?: string; shippingAddress?: string; } function isSafeKey&lt;T extends {}&gt;(key: string, order: T): key is keyof T { return Object.prototype.hasOwnProperty.call(order, key) ? true : assertNever(`${key}Address is invalid!`); } function getAddressKey&lt;T extends {}&gt;(type: string, order: T): keyof T { // cast is safe here, you can capture a variable if you want to avoid it return isSafeKey(`${type}Address`, order) &amp;&amp; `${type}Address` as keyof T; } function setAddress(type: string, address: string, order: Order) { order[getAddressKey(type)] = address }
Very interesting, thanks for sharing. Gives me some more ideas to try.
&gt; The object may not have neither of the two fields. This is equivalent to saying "The object must have at least one of the two fields". The rest of the post implies you actually meant to write: &gt; The object may have neither of the two fields.
Well you could also try using this https://www.npmjs.com/package/nodemon-webpack-plugin Honestly it sounds like your build process is jacked though
This is interesting as Typescript has nothing to do with Angular, what made you think so though? Was it just knowing that Angular uses Typescript without knowing what it actually is?
Thank you for this answer! I was more curious about the TypeScript internals at play here than my particular code example.
I believe Flow now supports this, but it isn't enabled in AST command
That code will not even compile due to various issues... Besides that, `hasOwnProperty` is not an adequate way to check for `keyof T`. If the property is missing in the object (because it's optional) this call will return `false`.
This seems like the way to go. Worth noting though, that if you change the parameter ' type ' to exactly match the property names: `type: 'billingAddress' | 'shippingAddress'` It also works.
When is there a time when you would NOT use TS when writing for node or the browser?
It does seem like a lot of extra steps to avoid using Typescript, while wanting the benefits of Typescript. The extra JSDoc comments will be a huge overhead for every developer who has to maintain them, and there's always the potential danger of them not being kept in sync (as with any comments).
Couldn't get past the first two paragraphs. "Lol clickbait title" &lt;- insults the audience "Static types are 2019 hype" &lt;- insults the audience
no generics - no power
I just got out of bed but I'm pretty sure this is going to be silliest thing I see all day. Why would you go through all these hoops to get something that is massively worse in all aspects?
They do, not to the same extent.
I mean if you have a legacy jsdoc code base cool, but for literally everyone else this is useless
I figure this feature exists mostly for incremental adoption.
What if I just write declaration files instead of using JSDoc. How does it work across the code editors?
Yup, pretty much. Maybe I thought something in the lines of "if Angular uses it, then it's bad". Not a very rational decision.
Incredibly well, actually! The type checking mechanism is normally the same (TS language server and a plugin), some editors grab any \`d.ts\` file they can find, others read it from what you point at in \`tsconfig.json\`. You can think of it as a header file where your JS file is the actual implementation.
Thank you for that answer!
Very cool, IMO JSDoc types are step one for codebases porting to TypeScript. Really useful when you have a JS file which isn't worth porting (like [JS config files](https://github.com/flappy-royale/flappy-royale/blob/master/webpack.common.js#L6), or scripts) If folks want to know more, the [canonical reference is in the handbook](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)
I recently set up an end-to-end alerting system using Jest, Chai, and Puppeteer. Chai might sound a bit out of place there considering the use of Jest (we might switch to Jasmine in the future actually) - it's actually being used for the assertions because Chai's messages are much easier to put in things like Slack notifications in a nice format, and in a way that reads well, with custom prefixes. Puppeteer itself has actually been really great. I love that when you download it you get a version of Chrome guaranteed to work with it. It really simplified the process of getting all of that set up. We just throw it in a Docker container and run it as a CronJob in Kubernetes. Puppeteer's API was really nice to work with too overall. I considered using ChromeDP (a Go solution, as we primarily use Go where I work), but it's API was really not friendly, even doing things like getting the status code of the page you've just loaded was really difficult.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Yeah, fucker is everywhere and it's blatant spam.
And endtest is not even a good solution. It's the most crappy shit I've ever worked with.
Wish I had your perspective. I’m losing my fucking mind changing types in multiple places just to try out a “quick” thought. I literally hate my career right now. It used to be enjoyable, but I’m considering becoming a farmer or some shit.
Yeah, there's so much that Scala doesn't have, it's crazy! The only thing I really miss from Scala is for comprehensions, `Do` from fp-ts is nice, but it's nowhere near it
[Here's an example of that](https://www.typescriptlang.org/play/#code/PTAECEEMGcFMBNQHsB2oAWAXTAHAXCAJbywyEqZLRIBmmA7pAE6wB0AxkgLbCwAe6SAFdomQgDdYAWmj1CmduinkpmAJ45Y0dk0I5MwAFDsANjGigAqihaRFkAEYnYAYRiwAokyZImofpiwKPAWXj5+AN6goIbR0ZwookxC7JRMABTikCZ4oCiwkkwAlKBRsXEV0EKaGQAG1rb2TrCg7O65ACQRWSYAvrVFANzl0b2GY8aoov4oQlygLkgmvqXlirDeaqAAvKAARADEAGIAnACMJwDMR3sANOVczBa7h0cXAAyXAOx3D7CBKxexyOHkuLgAHHtxsNJoklmxlgBzdKLZZMDjoDZMNRDQyGEimZgtBLTdi5VG+PGyeSKdLsEoREagEALbhcIKYZD5ZA0UCYTFwPlIUCI-6gSBoLGUiptQUU9HrTa5PYAEWFACUEKAACrociIvaDUAOWwAa2GMvcrLRrEeTGgyrVoE1iF1+sNxrNFrispa8tt-1gvkdGq1bpQBqNJtI5qZJBowhMmDwTIq-J89DysEzDVITWcbjgYV8dNxYyAA)
That's a really clean example.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
I'm struggling to understand your question, but this stuck out to me: &gt; T[K] | T[][K] Did you mean `T[K] | T[K][]`?
So if I understand you right, and I'm taking some liberties with the specific API here for simplicity, you either have an object or an array of objects, and you want to apply an extension method to all of them. So if you had this snippet: function expand&lt; Type extends {}, Key extends keyof Type, ExpansionReturn &gt;( key: Key, object: Type, expansion: (value: Type[Key]) =&gt; ExpansionReturn /* replace with your real type */ ): ExpansionReturn { return expansion(object[key]); } It would work like so: `expand('foo', {foo: 'bar'}, s =&gt; s)` and that's more or less what you're asking. So you want to take something like this and extend it to being able to support `Type[]` instead of just `Type`, what you have to do is handle both cases separately, in both the code and the type system. The code is simple, `expansion(object[key])` becomes `objects.map(object =&gt; expansion(object[key]))`. However, you have to tell TS that you're both accepting and return an array. You can do this with conditional types and adding an additional generic parameter to capture whether you've passed an array or object: function expand&lt; Type extends {}, Key extends keyof Type, ExpansionReturn, Input extends Type | Type[] &gt;( key: Key, object: Input, expansion: (value: Type[Key]) =&gt; ExpansionReturn /* replace with your real type */ ): Input extends Type[] ? ExpansionReturn[] : ExpansionReturn { if(Array.isArray(object)) { return object.map(o =&gt; expansion(o[key])); } return expansion(object[key]); }
Had a quick look, there are lots of `any` that could be removed. For example, when typing a callback where you don't care about the return value, use `void`. For where you'll truly accept anything, use `unknown`. And there are others like `thisArg` that I haven't looked into but suspect can be typed better.
I'm doing an entire series on TypeScript. It's strictly for beginners, and it's meant to be as approachable as possible. It will be on Medium, with one new article about once a week. It will probably end up around 5 parts, but I currently have 4 planned. &amp;#x200B; This article is strictly a soft introduction to TS. There is no app building, or TS buzz-word BS. It's meant to help you learn, not make me sound smart.
Thanks! I appreciate the feedback. If you have a Medium account, please give me some claps!
If you like VSCode Typescript-wise, look for coc.nvim... it has many goodies
Another library not making use of the strict compiler flags... Why use TypeScript for type-safety, but then not make use of it's best type-safety features? Personally I do my best to avoid any such library. I'm tired of all the undefined and null checks.
Does the fact that this lib doesn't use the strict compiler flags have any impact on the consumer? I suspect not... but FWIW next version will enable the strict flag. It's already in progress... [https://github.com/Hypercubed/dynamo/tree/strict](https://github.com/Hypercubed/dynamo/tree/strict)
&gt;Does the fact that this lib doesn't use the strict compiler flags have any impact on the consumer? I suspect not... There is a very high chance that the author did not correctly annotate types that can be null or undefined. That does have an impact on the consumer.
Still waiting for function decorators. :-( They seem difficult to implement due to the hoisting.
Hello, thank you so much for help. I'll try to give more info about the issue, hope it'll help. &amp;#x200B; We've got entities like this: export interface Building { Identity: string; Id: number; Name: string; Floors?: Floor[]; Statistics?: BuildingStatistics; } export interface BuildingStatistics { Id: number; EquipmentCount: number; FloorCount: number; } export interface Floor { Id: number; Name: string; } The problem is when I want to make a query. &amp;#x200B; Building.Query() .Filter(x =&gt; x.EqualsField("Id", Guid.parse(buildingID))) .Expand(x =&gt; { x.Expand("Statistics", x =&gt; { x.Expand("FloorCount") ///// Works just fine }) }) .Exec().then(x =&gt; x.value)) .pipe(map(kpiValues =&gt; this.mapKpiAPIintoKpi(kpiValues))) } The problem is here: Building.Query() .Filter(x =&gt; x.EqualsField("Id", Guid.parse(buildingID))) .Expand(x =&gt; { x.Expand("Floors", x =&gt; { x.Expand("Name") //// "Name" is underlined" (Select or Expand doesn't matter cause instead of a string there might be a Class) }) }) .Exec().then(x =&gt; x.value)) .pipe(map(kpiValues =&gt; this.mapKpiAPIintoKpi(kpiValues))) } Underlined error - (TS) Argument of type "Name" is not assignale to parameter of type 'number' | "length" | "toString" | etc... 14 more etc.... &amp;#x200B; And here is our Select and Expand : public Select&lt;K extends keyof T&gt;(select: K) { if (this._select != '') { this._select += ","; } this._select += select; return this; } public Expand&lt;K extends keyof T&gt;(property: K, expand?: (expansion: ODataExpandBuilder&lt;T[K]&gt;) =&gt; void) { var expando = new ODataExpandBuilder&lt;T&gt;(); if (expand != null) { expand(expando); } if (this._expand != '') { this._expand += ','; } this._expand += property; let nextExpand = expando.buildUrl(); if (nextExpand != '') { this._expand += '(' + nextExpand + ')'; } return this; } I've found out also that if you just make an Expand with futher expanding or selecting you receive everything from this entity and entities in this entity (if that make sense) but we want to avoid that due to the amount of data we'll get that way. &amp;#x200B; If you need more info let me know please and thank you again. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; d
One of the hardest questions in this subreddit
Personally I never enabled such flags because I like the flexibility of Javascript. I haven't had any issues really. Every time a lib doesn't use this check someone rants about it. Does it really makes a difference? It's not like the null checks happen in runtime anyway.
&gt; Personally I never enabled such flags because I like the flexibility of Javascript. Then use JavaScript? Usually people use TypeScript for type-safety, and all these flags purely improve the type-safety features of TypeScript. &gt; Does it really makes a difference? It's not like the null checks happen in runtime anyway. I assume in particular you refer to the `strictNullChecks` with your comment, then: Yes, it does. **Immensely.** It's about communication. With this flag the consumer can be clearly notified via the type-system if something can be `null`. Or if it can be `undefined`. Or both. It's not guess-work anymore, or constant looking at the documentation or the code. The compiler will assist me, it will inform me. If a method may return a value or may return `undefined`, and I continue to use that value in a place where I expect to never have `undefined`: The compiler will warn me. It's communication, documentation, and automatic testing. And at any time I'm still free to opt-out of these checks via type assertions. Honestly, working on code bases without `strictNullChecks` is pure hell to me nowadays. I've seen "scaredy paths" (aka `obj &amp;&amp; obj.prop1 &amp;&amp; obj.prop1.prop2`) so often, where over time people were unsure whether a value can be missing or not.
&gt; yarn add react react-dom @types/react @types/react-dom --dev I'm pretty sure you shouldn't install `react` and `react-dom` as dev dependencies. Also I see no point of the classes. They're just adding bloat.
Regarding your [todo](https://github.com/Hypercubed/dynamo/blob/29451686033ce66d3087964c53ea6d9cdf8d0d29/todo.md): &gt; Any vs Unknown? Any known type, any unknown type, or any type? **Please** always prefer to use `unknown` over `any`. `any` should be avoided, it creeps into your code-base like a disease and easily lead to bugs. The issue with `any` is that it's **implicitly** assignable to **any other type**. This makes it easy to accidentally assign it to a properly typed variable, when it's not really sure if it's actually compatible! `unknown` on the other hand can not be assigned to any other type, so you don't run at risk to accidentally use it wrongly typed. But if the developer wishes so, he can still use it as `any` (or any other type) using a simple type assertion: `value as any`. It gives the developer the **choice**, instead of pushing it down your throat.
Eh, that's a weird reasoning. Just because I like javascript's flexibility I should drop TS altogether? I like TS also. I like the great intellisense support I get with it. I like being able to jump on a foreign code base quickly and understand it thanks to the type definitions. Type safety is neat, but is not totally why I use it. &gt;It's usually me. TypeScript is a pretty good language which offers a lot of features. But I've grown tired of constantly seeing new libraries that do not make use of TypeScripts type-safety features. Very often people are not even aware of them - they just copied an old `tsconfig.json` from somewhere else. I guess it doesn't hurt to let them know but I think you're acting as if strict null check is mandatory if you dare to call you a typescript user. Look it's a choice, and the reason why that feature is a compiler **option **. I personally do not think it's worth it for me to put that option on. It increases coding time and the cognitive load. It's my choice, it's not a built in option that I removed from TS just to impose myself. Does that make someone like that any less of a TS developer? &gt;It's about communication. With this flag the consumer can be clearly notified via the type-system if something can be `null`. Don't `foo?: BarType` or `fooFunc(foo: BarType | null) do that already? They communicate pretty clearly that a variable is expected to possibly be undefined. `. As for your last part, don't you still need to manually add a null check when working with variables that can possibly be null? `function fooFunc(foo, optionalFoo) { if (! optionalFoo) { // do something } //... } ` Unless I am mistaking, and if so please correct me but that compiler option does not remove the need to manually handle null variables, right?
&gt; Eh, that's a weird reasoning. Just because I like javascript's flexibility I should drop TS altogether? Yeah, I admit that was bit too far. &gt; I guess it doesn't hurt to let them know but I think you're acting as if strict null check is mandatory if you dare to call you a typescript user. I've grown more strict (word-joke, haha!) towards this subject because I got tired of using poorly typed libraries. &gt; Look it's a choice, and the reason why that feature is a compiler *option *. It's mostly an option because it got added later on (version 2.0, September 2016), and without an option it would be an extreme breaking change which would be against TypeScript Design Goal number 11. I believe if it would have been available from the start it would not have been an option. &gt; Don't foo?: BarType or fooFunc(foo: BarType | null) do that already? They communicate pretty clearly that a variable is expected to possibly be undefined. If you have `strictNullChecks` disabled... as a library author: There's a **high chance** you're not adding the appropriate `undefined` and `null` type annotations, because you are not really aware of them. If you do: Awesome! as a developer: The type additional `undefined` and `null` types do not help you at all, **because they don't exist as types**. [See this Playground example.](https://www.typescriptlang.org/play/?strictNullChecks=false#code/JYOwLgpgTgZghgYwgAgEJygFQJ4AcUDeyAbnADYCuEA-AFzIgUC2ARtANzIC+AsAFD8YFEAjDAA9iGQxx4gGLCEAChnj66LHhQAfBhTJkAlMgK8BfVQpFLhAEwgxQEW4faDZV5UVKUI9RgbcrvxAA) If you hover above the `fooFunc` function it will show `function fooFunc(foo: BarType): void;` as the signature. The `null` type is gone, because it does not exist as far as the compiler and the language service is concerned. The compiler won't protect you from passing in an invalid `undefined` value, or assigning an invalid `null` value to `BarType.value`. --- Another example would be `strictFunctionTypes`, which fixes the variance of function arguments: function doStuff&lt;R&gt;(values: number | number[], callback: (arg: number | number[]) =&gt; R): R { return callback(values); } function myCallbackImplementation(arg: number): number { return arg; } const result = doStuff([1, 2], myCallbackImplementation); The function `doStuff` accepts either a `number` or an array of `number`, and a callback accepting either a `number` or an array of `number`. However, the callback just accepts `number`, but no array. Without `strictFunctionTypes` this example compiles without an issue, despite the glaring incompatibility in types. The type of `result` will be `number` (inferred from the return type of the callback function). But the type will **actually** be a `number`-array. With `strictFunctionTypes` this will not compile. And again, if the developer really wants it, he can opt-out by using a type-assertion. But it needs to be a **conscious** choice. [See this Playground example.](https://www.typescriptlang.org/play/?strictNullChecks=false&amp;strictFunctionTypes=false#code/GYVwdgxgLglg9mABAEzgZSiYwA8AlAPgAoA3AQwBsQBTAZwC5EwQBbAI2oCdEAfJ1jpwDaAXQA0iCJQpsyEANaMiZTgHNGzdl178twkQEpEAXgKI8BxnkQBvRJ2qZOSKRRlz5pSjVoGA3IgAvgCwAFCgkLAIiCwAngDC0rIKAJIsAA4U1CzUYFBkUWDKahoCXJa6grb2jiDOiCqqASGhYQD0bYgAKrHp1IhwwDW0IBRQiDAMlVztnQDyIFDpiwNDFHCqktITU0IAjBIATCKIALQN09wqnGSxYRAItOMOI2MmKOiY2ET7R+IxCSSHjSmWyuXyhX890ecCyADp1qoiC9RlAoaEgA) --- I may be a bit too harsh in propagating this, but I've just grown tired of joining TypeScript projects that have type-issues all over the place.
One of our major issues was that external package typing support for Flow is inferior compared to TS, which eventually was the breaking point as we're now migrating to TS. In general IDE support seems to be better as well, I'm getting faster and better autocompletion and just general better integration with TS typings (WebStorm, but colleagues are saying VSCode support is better as well). I noticed I'm finding more documentation and answers to TS issues compared to Flow, seems like the community is bigger as well. &amp;#x200B; Since Babel supports TS now migration has been relatively painless, we're planning to migrate our other projects using Flow to TS as well. To me it looks like TS will eventually be the default option for typed JS, I don't see any reason to stay with Flow in the future. TS seems to have solved most of the issues for which we chose Flow and is currently better in a lot of other ways.
Looks like a great comment. I am on my phone right now so it's a pain to use the playground and reply reliably but as soon as I home I will take a good look at that.
Okay, I see, thanks for the advice :)
As a team of 5 dotnet developers, we found that starting and working on an Angular project together gave us a great jumpstart on learning TypeScript, NodeJS, NPM, RsJX, and Angular itself. If you have only dabbled in JavaScript before, then what you probably need to learn is not TypeScript so much as current typical web development practices. If you are only familiar with working with postback frameworks stiched together with jQuery, then you might need to play a bit of catch-up.
Be aware that Angular makes very poor use of TypeScript. I ranted a bit about it earlier: https://www.reddit.com/r/programming/comments/c4hpeg/why_angular_made_me_quit_web_dev/es0k0el/
We enjoy using TypeScript mostly for typing of our own code. I would agree that most libraries treat TypeScript itself as a loose form of strong typing, which I guess I write off too easily as a lack of rigueur by the community. I stand by my comment though. Someone who has only dabbled in JavaScript before needs to learn a lot more than just the right way to use TypeScript, they need to learn NodeJS, NPM, and a bunch of the common tools in that ecosystem. TypeScript is rarely used by teams outside of the frameworks and tools it is associated with. Angular will force you to address many of those tools tangentially, or even in ugly ways. You'll learn quickly that way...or you'll break your computer when you can't understand what the Angular documentation is trying to tell you about RSjX route piping.
duck typing union types user defined type guards try writing a console app
&gt; RsJX This is hilarious.
Any thoughts on typescript + react?
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Please don't read this and take it seriously. It's just a rant by a very mad developer. I guess that happens when you think TypeError is connected to the Angular instead of Javascript so you waste hours searching "site: stackoverflow Angular TypeError". Nothing in this blog post is connected to reality. You should, on the other hand, read this if you enjoy reading mad nonsensical rants like I do. Also there is absolutely nothing about Angular using TypeScript poorly in there. Also the dude is mad about "Angular", a word!!!
&gt; If you are only familiar with working with postback frameworks stiched together with jQuery, then you might need to play a bit of catch-up This has been most of my web front-end experience truthfully, but it has been more than sufficient for my projects. What has stopped me from fully learning a front end thing like Angular/React/etc is the sheer volume of JS frameworks for doing web development in. How does one choose? Is there any one that is more or less compatible with Typescript?
I loved it when I was working full time in that environment, and it's almost certain that the new TypeScript website will be built that way. Best starter recommendations are: - https://egghead.io/courses/use-typescript-to-develop-react-applications - https://github.com/typescript-cheatsheets/react-typescript-cheatsheet (assumes knowledge of JS)
Great, I hope it's built into their LSP support so that everyone else gets it.
If you are starting new, you want to pick one of the three main leaders: React, Angular, and VueJS. They all have at least baseline TypeScript support. All three have recommended CLI tools for setting up projects which can configure the created project to use TypeScript. Angular has the longest history with TypeScript support and most of the project is written in it, but that is barely relevant anymore (if you were just getting into VueJS at various points in previous years, the TypeScript support story was...confusing). &amp;#x200B; We spent spare time over the course of a month comparing small applications in React, Angular, and VueJS to get a feel for each before we settled on Angular. The downsides of Angular are that it has many dependencies, takes a long time to npm install, takes a long time to build, and you lose some of the benefits of the tooling if you aren't hosting your resulting application in NodeJS. If VueJS's TypeScript support was further along at the time, we might have chosen to use that instead. We've made three LOB and one retail web application since using Angular and I think the only thing we regret is all of the damn build time wasted ;)
You should be able to get it typed correctly (assuming your code is working) by changing: (expansion: ODataExpandBuilder&lt;T[K]&gt; =&gt; void) to (expansion: ODataExpandBuilder&lt;T[K] extends Array&lt;infer A&gt; ? A : T[K]&gt;) =&gt; void)
Nestjs
Thanks. What is your opinion of React + Typescript?
I do both as well, Vue is pretty good as they support TS as a first class citizen via extensions (and V3 is native typescript). The hardest part will be watching for the differences, TS and C# occasionally look quite similar (async/await looks very similar) and that can catch you out, also structural typing is quite different to C#. Other than that though just pick a project and work through it. There is a nice C# typescript Vue project on GitHub called toucan that was useful for me when I switched to ts as a source of inspiration so maybe have a look there as well.
What about the other way around? What’s the best way to go TS to C#
This has been my stack for a while, they work very well together.
Yes, good advice... but in that todo I am referring to the explicit types added to a dynamo instance for pattern matching. &amp;#x200B; \- \`Any\` - Matches anything \- \`AnyKnown\` - Matches any known type \- \`AnyUnknown\` - matches any unknown type.
The two are very similar. Both have async await, typed, support generics, interfaces, dependency injection, decorators/annotations, etc. Maybe enable strict mode for a closer to c# experience, otherwise just jump in and get coding. If you want something similar to MVC/WebApi check out nestjs. Something similar to entity framework? Check out TypeORM.
I strongly disagree with the idea that not using the strict flag eliminates type safety. May not be as type-safe as you like but still more so than JavaScript. TypeScript is a tool, we can use it in many ways. &amp;#x200B; Anyway, that is not the subject of this post.
It doesn't eliminate type-safety. But it heavily reduces type-safety. I added a few examples here: https://www.reddit.com/r/typescript/comments/ce71ja/github_hypercubeddynamo_fast_dynamic_method/eu0u6um/
Nest has been one of the best things to happen to the Node ecosystem in my opinion! I'm unfortunately in the process of converting a nest app to spring, but even without past spring experience in not having too much trouble with the port. The discord for it is also appear friendly in getting help, and the docs are pretty good for the most part
When we tested React we did so using JavaScript, as it seemed the expected convention (all of the samples and guidance were in JavaScript) and we wanted to use their paradigms to give it a fair consideration. I don't have any useful experience to share specifically with React + TypeScript.
React with typescript is very nice. But if you are going for React you should start by using React with normal JavaScript. Why ? Because React documentation is in JavaScript and most tutorials too. Also typescript is very cool but it adds some complexity: fixing typescript errors will probably slow you down in your learning process. React's official documentation is very good. Here is a nice introduction to typescript: https://scrimba.com/g/gintrototypescript This article is pretty good too. There is also a nice ES6 course in scrimba. It is very important for a React developer
I didn't write any typescript code since 2018. But here is my mind. Your map method is not returning a string, but an array of string, where each element is replaced by the pattern you introduced. Then this new arrays in interpreted as a complete string with coma between each element. You are surely searching after the array.reduce method, that combine each element on an array into another single element of the type you wants. Try column.reduce((a, b) =&gt; a + ', ' +b) or something like that.
Template literals use toString() &amp;#x200B; [https://stackoverflow.com/questions/45812160/unexpected-comma-using-map/45812277](https://stackoverflow.com/questions/45812160/unexpected-comma-using-map/45812277)
I take back my computer. Here is my solution ``` const columns : Array&lt;string&gt; = [ 'Yes', 'No', 'Maybe', 'Possibly' ] const SelectColumnReduce = (col: Array&lt;string&gt;) : string =&gt; { return `You must select, blah blah ${col.reduce((a, b) =&gt; a + ', ' +b )}...`; } console.log(SelectColumnReduce(columns)); ```
It's still an array, and those commas are from the string representation. You're looking for `.join` &gt; const blah = ['this', 'is', 'a', 'test']; &gt; `${blah}` "this,is,a,test" &gt; blah.join(', '); &gt; "this, is, a, test"
The way I understand it, you want your row entries to either have a dependency or not. Instead of saying "if the dependency is null, we'll treat it as no dependency", actually make it an optional dependency with \`Dependencies?: string\` instead of \`Dependencies: string | null\`. That's an optional attribute (\`string | undefined\`). If an object has it, it's string. If an object doesn't have it, it still matches the interface. Since your M1 no longer needs to pretend it has a dependency, erase the \`Dependencies: null\` further down. Also, you'll probably want to change Dependencies to a list or to singular.
This alteration fixes the issue. The array's type was being inferred by the values you initialised it with. Here I defined a variable to the array before the concat and then typed in explicitly. ``` // now lets flatten the milestone and make the tasks dependencies of the milestone const rows: IGanttRow[] = milestones.reduce((taskList: IGanttRow[], item: IMilestone) =&gt; { // if I change the top level Dependencies from null to "", but it's not what I want. Why won't Typescript take null | string as the definition expresses? const tempName: IGanttRow[] = [{ Id: item.Id, Name: item.Name, Duration: 0, PercentComplete: 0, Dependencies: null }] return taskList.concat( tempName.concat( item.Tasks.map(t =&gt; ({ Id: t.Id, Name: t.Name, Duration: t.Duration, PercentComplete: t.PercentComplete, Dependencies: item.Name })) ) ); }, []); ```
Thou shalt not use `any`
&gt; The hardest part will be watching for the differences, TS and C# occasionally look quite similar (async/await looks very similar) Generics in TS might throw OP for a loop, compared to generics in .Net
Try casting your object literal to the expected type.
What issues?
Looks like I'm not alone in this. I used both React and Angular for big projects. Currently working with Angular. I hate it more and more as I spend more time with it. My biggest pain points are the lack of typings for the forms and no type checking for the templates. I loved JSX/TSX for that. I could catch typos and type mismatches during compile time, which is kind of why one would use TypeScript anyway.
I actually disagree. While it adds some complexity, the benefits greatly outweigh them. Would those TypeScript errors just not happen with JS or your app would just blow into your face during runtime?
It's called a type assertion, not a cast. And it should be the last choice escape hatch, not a cheap way to work around lack of understanding.
&gt; Would those TypeScript errors just not happen with JS or your app would just blow into your face during runtime? In a production app yes but maybe it's not a big issue for a "hello world". I dig Typescript but it might make for a steep learning curve attempting to learn Typescript at the same time as coming to grips with the whole web dev ecosystem.
I guess that depends on your prior experience. If you have none then JS might be easier. I started using TypeScript after working in C++ and C# for a couple of years. At that point it was just another language.
Based on first impressions React + Typescript is a good combo. (3 weeks playing with React, 8 months Typescript.) Although React examples are primarily in Javascript, using typescript hasn't been that difficult once getting over the initial hump of setting up a project. I initially attempted to start a new project with Vue + Typescript but the lack of Typescript examples was more of a showstopper than with React. That issue was compounded by the fact there seem to be multiple different patterns one can use to create Vue components with no clear advantage to any particular pattern that I could see. (components can be classes or objects). I switched to using React + Typescript and still happy with that decision. Take all that with a grain of salt though. I didn't use Vue for long, so perhaps just got off to a bad start. Vue 3.0 will improve Typescript support AFAIK, so that might be worth checking out once it's ready. I was using Angular 6 with Typescript for a previous project. Angular uses Typescript out of the box, so the examples are easier to follow. Angular has more batteries included than React which is good for getting started.
Bash is made for this kind of job, not sure why the 'eww'? Having said that, a few NPM scripts seem to do the job for me. I think these elaborate dependency ridden build systems are a massive waste of time and energy. In the very near future it will all be standard ES6 modules everywhere and legacy browsers will be forgotten, people will look back at 'courses' in how to use webpack and laugh :) If you need all that cruft for corporate legacy browser support support then create-react-app/Vue CLI 3 has it all covered out the box, no need to waste a moments thought. This is how I do it, as minimal as I could make it with watching, building, testing and linting. ``` { "scripts": { "start-typescript-development": "tsc-watch --onSuccess 'npm --silent run test-and-eslint'", "test-and-eslint": "npm run test &amp;&amp; npm run eslint", "test": "mocha --reporter min --require esm", "eslint": "eslint --cache -f unix --ext .ts src/ test/" } "devDependencies": { "@typescript-eslint/eslint-plugin": "1.12.0", "@typescript-eslint/parser": "1.12.0", "eslint": "6.0.1", "esm": "^3.2.25", "mocha": "^6.1.4", "tsc-watch": "2.2.1" }, ``` If the build fails then it stops, otherwise it continues to test and lint. Seems very fast and the output formatting in the VS Code terminal looks good. I ditched the VS Code eslint extension as the amount of red wiggles all over my code was very distracting. Using the command line you can reference the errors when you want.
I don't think so. If this were a class, rather than an object literal on an interface, it wouldn't have been a problem. Its not like you can give it a truck and call it a duck.
&gt; If this were a class, rather than an object literal on an interface, it wouldn't have been a problem. I'm not sure how this would make a difference. &gt; Its not like you can give it a truck and call it a duck. interface Truck { makeNoise(): void; type: 'light' | 'medium' | 'heavy'; } interface Duck { makeNoise(): void; type: string; } function getTruck(): Truck { const duck: Duck = { makeNoise: () =&gt; console.log('Quack!'), type: 'male' }; return duck as Truck; } console.log(getTruck().type); // Neither 'light', nor 'medium', nor 'heavy'.
I have had good experience with TypeScript + React. Those two work very well together. Just be sure to start with all TypeScript strict-flags enabled (especially the super-set `strict`). Enabling these features later on is very very painful. And avoid using `any` if possible, prefer using `unknown`. Here are some more resources regarding TypeScript: - A blog where /u/mariusschulz sometimes blogs about new TypeScript features: https://mariusschulz.com/blog/series/typescript-evolution - An e-book by Basarat Ali Syed, which provides some more information beyond the TypeScript documentation: https://github.com/basarat/typescript-book I have heard good things about Vue.js, but I haven't used it myself yet. [GitHub Insights](https://github.com/vuejs/vue/graphs/contributors) indicate that it's mainly a one-man-show, which is something I'd rather not depend on.
Agreed. Personally, I haven’t found a better or faster to scaffold applications, and it was the one thing missing from the node ecosystem. For REST services, the techniques chosen here the pinnacle IMO (opinionated in the best way possible, modularization, IOC/DI. abstraction, extensibility, etc). Bar improving performance, it can do everything you’d need to build an enterprise-grade app.
How type-safe is fromPath?
Thank you. That fixed it. I suppose I still don't understand why it didn't work. It could inferred as string or null. It should accept both, right?
&gt; Bar improving performance And I've even seen it have heat performance. It keeps up with an async Express server that implements all the same features and can be even faster if your decide to use Fastify instead of Express
Thank you for your elaborated answer! Bash is not fun to work with or maintain, hence the eww :D My case is a little bit involved. I have a bunch of folders (`static`, some application data, env files) I wanted to copy to the build folder, for both dev and production environment. Also I wanted to watch for changes on all source folders (for dev), for two things - If a static file is changed (or added/deleted), the corresponding file in the build folder should be changed as well - If a TS source file is deleted, the compiled files should also be deleted (This happens a lot with typeorm migration, which is not often, but annoying) It seems that the consensus has been reached that gulp-typescript is not the right choice for compiling TS files. It should rather be a pipelined approach (as what you've shown), TSC compiles first, then triggers other things. In that case, gulp is no difference than bash script, just nicer to work with (builtin watch mechanism, nicer language)
Not much input given on the libs in the post. I've used GraphQL Code Generator with great success in the past. It'll even generate react-apollo specific components and hooks for you 👌
Played with a few of these libraries today. Still personally prefer the [graphql-schema-typescript](https://www.npmjs.com/package/graphql-schema-typescript) package we use now though. It gives us a lot of control, without lots of work, see [here](https://github.com/coralproject/talk/blob/next/scripts/generateSchemaTypes.js).
Yes, I love those generated hooks!
Looks cool. I definitely want a typed query-builder for Typescript. I use JOOQ in Java-land and would very much like to have an equivalent that I can use from AWS Lambdas written in Typescript. I think you've made the right choice in the short-term by focusing on a single DB. Though I think that's my Postgres bias at work - if you'd decided to focus on MySQL I'd probably be telling you it should be multi-DB :)
... wait... there are other databases??!?!?!1?
No, there’s Postgres and everything else ;)
This is exactly the kind of library that I want - thanks for making it happen!
It's definitely still a work in progress but I thought it was really neat and I wanted to share it sooner rather than later. Thanks for the kind words. :)
Typeorm
Nah - I don't want an ORM. I used (and enjoyed using) Hibernate for well over a decade - but I strongly prefer JOOQ. I want a statically typed query builder that embraces SQL in a similar way.
Well did you even look into typeorm at all? I don’t use ORMs. I just use it to execute and type queries. But they do have a query builder... so you may want to look into that. Of course they also have the ORM option but you don’t need to use it
I did, I just didn't really care for it, and even then, it's not really strongly typed in a lot of cases (it seems that you can't really strongly type `where` queries?). Vulcyn is also a lot closer to the metal I think. I've tried very hard to never make it devolve into `any` types which seems to be a pretty common practice with TypeORM. For example, with Vulcyn, if you try to insert into a table with non-nullable columns (without defaults) you'll get a type error if you forget them, and where queries can mostly be strongly typed. Also, in Vulcyn, you can strongly type SQL functions (e.g. `sum`) which doesn't seem to be possibly in TypeORM (granted, I haven't done it yet - mostly just because I haven't personally had to write a SQL query that uses `sum` in the project I've been working on - but I'm 100% confident it can be done). I have nothing against TypeORM, it just didn't feel _ergonomic_ to me (which I think is a very personal thing).
TypeORM has query builder, just check it.
One of my goals starting out was to make the usage of Vulcyn as close to SQL as possible (and it also tried to produce very idiomatic looking SQL if you inspect the resulting queries). The only major exception* to this is specifying composite `where` conditions which weren't very amenable to that; right now, you have to do ``` // WHERE role = 'admin' OR (role = 'SWE' AND salary &gt;= 80000) const {role, salaray} = db.users; db.select(db.users, "id", "name", "role", "salary").where(or( role.eq("admin"), and( role.eq("SWE"), salary.gte(80000) ) )) ``` and form it in AST-type notation. I might try to add a "better" way to express at least simple queries like this in the future, but it does tend to be less readable in my humble opinion, especially once you add in the appropriate indentation. You lose the sense of which conditions belong to which group. ``` .where( role.eq("admin").or( role.eq("SWE").and( salary.gte(80000) ) ) ) ``` Probably a matter of taste over which one is clearer (and I'm open to change/adding things).
Please don’t change the code to javascript
I made a lib that wraps repositories and queries using typeorm. It still has some quirks, but it works great for most cases. Check out https://github.com/IRCraziestTaxi/typeorm-linq-repository
Not so much readme. How it works?
This looks really useful. I use sequelize as an ORM, but the types are surprisingly wrong half the time. It never knows which attributes you're selecting, and whether or not associations are present.
The JOOQ query for that would be something like: ``` db. select(USERS.ID, USERS.ID, USERS.ROLE, USERS.SALARY). from(USERS). where( USERS.ROLE.eq("admin").or( USERS.ROLE.eq("SWE").and(USERS.role.gte(80000) )). fetch(); ``` Ignore my wacky formatting. The `USERS` class in that example would have been generated by JOOQ from the schema as part of the build process. I love this approach because any schema change I make in column, table, function names etc. is immediately observable as compilation errors if it's not backwards compatible. It's far from perfect, but it goes a really long way toward making the compiler do more heavy lifting for you (meaning you need less unit / integration tests) and it makes refactoring an absolute breeze.
In general the flow-typed definitions are updated either slowly or not at all, causing issues when using newer versions of packages or upgrading flow itself. I've personally come across multiple (sometimes major) issues with flow-typed versions being either wrong, out of date or non existent for a newer package version (React-redux, express, styled-components, sinon,... just to name a few). DefinitelyTyped seems to be a lot better maintained, in addition to Typescript being better with dealing with external types in general it makes for a big upgrade in developer experience coming from flow.
This looks pretty similar to [typed-sql](https://www.npmjs.com/package/@phiresky/typed-sql), written by a friend of mine, which has horrible documentation but I use in production with 1M+ users and maybe 20queries/second with great success, and [mammoth](https://github.com/Ff00ff/mammoth) which I've never used and which has some somewhat weird design, but which is documented much better. Just for reference
I once implemented such a library too ([see playground here](https://hediet.github.io/ts-typed-sql/)). However, I got lost in types and while doing so, I discovered that TypeScripts type system can do [quite much](https://github.com/Microsoft/TypeScript/issues/14833). Now many quirks have been fixed that my library relied on, so it does not work any more in newer versions of TypeScript. The types also got so complicated that I might have to start from almost-scratch if I ever want to make it usable with up-to-date TypeScript again. I also never managed to type left joins correctly...
component \`ImportDataSuccessTable\` accepts \`CronImportSuccessState \` and \`ImportDataTable\` accepts \`CronImportState\` but the parent component accepts props data which can be of both type, but here i am getting error? any help
That's because you have nothing that tells TS that `type` will limit the `data` type. Try it like this: interface SuccessProps { type: TabsType.SUCCESS_IMPORT data: CronImportSuccessState } interface NotSuccessProps { type: TabsType.NOT_SUCCESS_IMPORT // write all tabs types that aren't success import here, unfortunately we don't have complement types yet data: CronImportState } type Props = SuccessProps &amp; NotSuccessProps
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie), [13](https://www.reddit.com/user/carnati_si_varza) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
You must be new here. Welcome!
Fuck off with this spam. Endtest is a buggy garbage solution.
You will want a union type, not an intersection type.
What makes you think TypeScript **could** figure out whether what you want is correct or not?`There's no connection between `type` and an actual type. You will want to create a discriminated union. That's the keyword you can look up.
Oops, fixed
I'm sorry but this is a terrible article. It doesn't manage to tell us anything about the real advantages of Typescript, and the amount of factual errors *nearly* outnumbers the awful grammar.
use \[\`fp-ts\`\]([gcanti/fp-ts](https://github.com/gcanti/fp-ts)) ;)
I already knew it, I was just bored so I decided to write my own :-)
hey thanks for the hint, am new for TS and yea the \`type\` props are different and not connected with TS . Thanks again.
Discriminated unions are usually your best bet, but in cases where those might get a little tricker, also look up “type guard”.
Yeah, the documentation leaves some to be desired. The usage https://github.com/coralproject/talk/blob/next/scripts/generateSchemaTypes.js is pretty much our use case. We generate schema types from the schema file and import them across the project.
Love the class approach. This is the reason why I use nestjs.
I haven't implemented it but I think you can do that with the current setup.
Yeah I did take a good bit of inspiration from mammoth. Hadn't seen typed-sql so thank you!
Those iterator/generator improvements look amazing. I was just bitten by some of that in the last week, glad to know it's getting fixed.
&gt; --downlevelIteration being off by default works well since, by-and-large, most users targeting ES5 only plan to use iterative constructs with arrays. Where did the typescript maintainers get this idea? The whole `--downlevelIteration` UX for the average typescript user is: 1. use `for…of` with arrays and strings with `target: "es5"`. 2. run into a compiler error when they try to use `for…of` on a `Set` or a `Map` and get told to use `--downlevelIteration`. 3. after much googling of errors, set the option in their `tsconfig`. It’s an extra configuration option that has no ostensible purpose except to serve as friction when using iterators, and the default behavior is an incorrect implementation of `for…of`. It seems like the purpose behind this was to not add runtime changes for `for…of` loops except now everyone uses the `tslib` helper functions. Excited about the strict iterator/generator changes.
The emit for `--downlevelIteration` is not just larger - it's slower overall. At the time, we felt it was better to fail fast and opt in to `--downlevelIteration` than to make everyone's code slower across the board. The upside here is that this is a configuration option that people won't need to think about eventually, as ES5 browsers fall out of usage.
I need to check myself I think and I will do it !
&gt; The upside here is that this is a configuration option that people won't need to think about eventually, as ES5 browsers fall out of usage. Pray for that day. Is typescript planning on implementing the module/nomodule split for output? IMO I think that strategy is much more reliable for phasing out es3/es5 builds.
You can take a simpler example to see what's going on here const f = (x: number): any =&gt; { return x; } const n = f(2) + 1 If we inspect the type of n in this case, then we'll see it's `any`. Which is weird, we do expect it to be a number. But remember, in JS we could easily end up with '21' as we do 3 since the + operator also concatenates strings. If you use `any`, you're explicitly telling the compiler to not bother with any sort of type checking at all because you're telling it that the result of the function can be anything at all, a string, a black hole, a bomb, an object, etc. However, in your origintal function you explicitly typed the intercface that your function returns, which allows typescript to take the value of the returned type and treat it exactly as the interface you've defined. In other words, you set up a contract with the compiler that tells it explicitly what you'll always return from the function. More information on the any type here: https://www.typescriptlang.org/docs/handbook/basic-types.html#any Note that in the general TS case, `unknown` has superseded a lot of the uses that `any` used to have, such as values returned from API calls.
Great work on 3.6! FYI [u/DanielRosenwasser](https://www.reddit.com/user/DanielRosenwasser/), looks like the twitter feed at the bottom of that blog post is pointing to the wrong Twitter account. "@typescriptlang" instead of "@typescript"
 Great work on 3.6! FYI u/DanielRosenwasser, looks like the twitter feed at the bottom of that blog post is pointing to the wrong Twitter account. "@typescriptlang" instead of "@typescript"
&gt; Let’s say you have a function which returns a Result-like type. You want to make sure that every consumer of the function reads the Result to make sure that silent exceptions don’t happen. i'd use a Result to handle "expected" errors (not catch any exception, which is unexpected), pretty much like you would use `null` + `–strictNullChecks` as return type, but more expressive (a discriminated union) and chainable. // (let's ignore the fact that those operations are async) // declare function readFile(path: string): Result&lt;UserError, string&gt;; const result = readFile(path) .flatMap(parse) .flatMap(upload); if (!result.isOK()) { return doSth(result.value) }) return doSthElse(result.error) &gt; I stand by my original statement about libraries which use Result types. I took a brief look at io-ts/fp-ts and shudder so much code for what is essentially a JSON schema validator. Jesus christ. io-ts is a neat dsl in which you describe expectations about JSON in code, while you can extract the type from parser. In JSON schema you have to do the same (albeit not as code: w/o type-checking and pretty verbose), plus you have to declare the matching typescript types. Apart from the duplication, you have to perform the validation in userland, trust the result and cast it to your type. Schema and types can diverge, though (JSON Schema is more expressive). We work a lot with JSON from unreliable sources, and while I was sceptical to introduce io-ts (with all the FP associations) to the team, it was perceived as very helpful.
Thanks helps clarify things a bit!
So excited about the improvements to generators. My Redux sagas are responsible for so much heavy lifting AND the least safe area of my code, which is a problem. Hoping this helps!
I'm only excited about the no-semicolon aware fixes.
This is how \`useReducer\` should work. Great job If I ever have to add reducer hook to my project will definitively use your's
Move the discriminator to the top level of your object.
Do it like this: ```ts interface Type&lt;T&gt; { hdr: Header&lt;T&gt;; body: number; } type TypeOne = Type&lt;SomeType.One&gt;; type TypeTwo = Type&lt;SomeType.Two&gt;; type Types = TypeOne | TypeTwo; ```
I'd love to get feedback from you.
Very interesting. I'm not going to use it, but from looking at the GitHub, it looks pretty decent. Lovely documentation. Currently working on the frontend. I recommend having another repo that has a demo application built with Floyd could help increase visibility and ease of use. Maybe a seeder API that does something simple. Eg, create some resource, get some resource, edit some resource, and delete some resource.
Thanks! Yeah making some example applications is part of the plan
The "learn more" that link to [GraphQL.org](https://GraphQL.org) and [TS.org](https://TS.org) were not very helpful; I was assuming they'd tell me more about those concepts specifically for your project. I.e. "here's how our resolvers are special", "here is how we cater to TS more than vanilla [graphql.org/apollo/whatever](https://graphql.org/apollo/whatever)". Currently I have no idea how your resolvers at different than apollo...are they? If yes, that's great, show how; if not, what's the point (if there is a point, spell it out)?
typescrypt has a whole lot of capabilities, it's interesting you reduce it to null checking. Why should it matter anyway? If you want it enable it in your project and my job as a library author is to provide accurate type definition and tests?
I recently set up a GraphQL server with Apollo server. Why would I use this over that? Apollo has great typescript support.
Looks ok. I’ve been using type-graphql to define schemas/resolvers with typescript classes. It’s an amazing library. What advantages does yours have over that? Just wondering. Would like to be able to see a sample project using Floyd, the docs are pretty scarce atm.
thanks!
thank you! i found related issue , [https://github.com/microsoft/TypeScript/issues/18758](https://github.com/microsoft/TypeScript/issues/18758)
**FUCK OFF WITH YOUR STOLEN CONTENT!**
Thanks for going through it. You're right, currently the only features implemented are aimed towards tidying up the project structure, scaffolding, and stitching together schemas and resolvers. I'm also currently working on the docs in a separate repo, if you want to open issues in it, that would be wonderful
How do you address relationships between objects ?
I'm implementing a serverless api using restify and dynamodb local. When I attempted to 'PUT' an item into my database, I get an error from serverless/restify. I'm new to implementing API's in this way, but all of my 'GET' functions work, so I'm imagining I've overlooked something specific to 'PUT'. Essentially, I am able to hit the API using postman, but the API errors out. I believe the issue is specific to my callback functions to the restify server, as I see that serverless has no problem processing the API events in the yaml file, but I've read through the restify documentation and I get the same error, no matter what I try. ``` { "errorMessage": "Error while loading api", "errorType": "TypeError", "stackTrace": [ "TypeError: handler (function) required", "at Server.addMethodRoute (node_modules/lambda-restify/build/lib/server.js:292:19)", "at Server.put (node_modules/lambda-restify/build/lib/server.js:58:21)", "at eval (webpack:///./src/handler-api.ts?:14:8)", "at Module../src/handler-api.js:145:1) } ``` handler-api.ts ``` 'use strict'; import Server from 'lambda-restify'; import { getRequests, getRequestsByOwner, putRequestById } from './routes'; import { serverPre, serverUse, serverPut } from './server'; const server = new Server(); // Server callbacks server.pre(serverPre); server.use(serverUse); server.put(serverPut) //Request EndPoints server.get('/request', getRequests); server.get('/request/:request_owner', getRequestsByOwner); server.put('/request/create', putRequestById) // Lambda Handler exports.apiHandler = function(event, context, callback) { context.callbackWaitsForEmptyEventLoop = false; server.handleLambdaEvent(event, context, callback) } ``` f(x)serverPut in server.put.ts (line 3 under server callbacks). Note: the `console.log` never gets logged out. ``` export function serverPut(req, res, next) { console.log("Submitting item to database...") next() } ``` f(x)putRequestById (line 3 under request endpoints) ``` import { putRequest } from '../functions'; export function putRequestById(req, res, next) { console.log(req) console.log ("Submitting new Request...") putRequest(req) .then((data) =&gt; { res.send(data); next(); }) .catch((error) =&gt; { console.log('error', error); next(); }); } ``` f(x)putRequest from '../functions'; ``` 'use strict'; import { doc } from 'serverless-dynamodb-client'; const TABLE_NAME = process.env.SAMPLE_DYNAMODB_TABLE; export function putRequest(req): Promise&lt;any&gt; { const ddb = doc; const params = { TableName: TABLE_NAME, Item: { id: generateRowId(req), request_owner: req.params.request_owner, } } console.log('putRequest:', params); return new Promise((resolve, reject) =&gt; { ddb.PutItem(params, function (err, data) { if (err) { console.log("Unable to add item: " + "\n" + JSON.stringify(err, undefined, 2)); } else { console.log("PutItem succeeded: " + "\n" + JSON.stringify(data, undefined, 2)); } }); }); } function generateRowId(req) { var ts = new Date().getTime(); // limit to recent return (ts.toString + '-' + req.params.owner); } ``` I would expect that API call would go beyond the initial server.put callback since it is essentially a pass-through. If I remove that server.put callback, I get a `405: Method Not Allowed`. Any guidance would be appreciated. I've scoured most of the documentation on server.put, and haven't found a pattern like what I'm using, so I'd appreciate direct answers and not links to resources, unless they specifically address my question.
Hah! I know exactly how you feel. Coding in vanilla JavaScript is painful once you're used to TypeScript. However, I'd argue that part of being a good developer is being able to adapt to the conventions of the team you're working in - even if those conventions are wrong :) I wouldn't base your decision on whether or not the company/team uses TypeScript. After a few weeks you'll find that you adapt and will be comfortable again (although never quite as comfortable as you were using TypeScript)
You can get quite far without other people needing to be forced to use TypeScript by relying on JSDoc support: - https://devblogs.microsoft.com/typescript/how-to-upgrade-to-typescript-without-anybody-noticing-part-1/ - https://devblogs.microsoft.com/typescript/how-to-upgrade-to-typescript-without-anybody-noticing-part-2/ --- Generally speaking though, the advantages of not using TS are that you *may* not need to use a transpiler, you can conceptually have simpler code (especially if were used to strict mode) and you can use dynamic code everywhere and people won't get annoyed :)
Fuck that. TypeScript is amazing. If you need the job take it. If you don’t, do you really not want to have type safety? Anyone who isn’t on board with static typing these days isn’t someone I’d want reviewing my PRs
I have to work on shared non-ts codebases. Not all teams embrace Ts. Using Flow has helped for React components. And decent tests. Still. I feel lost for a few minutes every time have to make open on those projects.
I hear you loud and clear. At my company I rewrote the codebase from jsx -&gt; tsx in my first month of work, but I was empowered to do so as an architect and with the blessing of the existing dev team. Since then we've added PostCSS modules, hooks, mobx, and more and the team has expressed their enthusiasm and wonder at what can be done in the system as it exists now (some 10 months later). For reference, I
Take the job and evangelize them to Typescript. There's no reason not to use it on a large project.
I’m in the same situation except I took the job. Luckily WebStorm allows you to install types through the application. It’s nots perfect but it gives some assistance when combined with JSDocs. And yes, it’s been very painful. My very first sw job was working with TypeScript. Now my second job is working on three different apps in vanilla JS and nothing is consistent between the apps. Even the same exact function will have a different name and different implementation. It’s maddening
F£#k that..... Just rewrite in Typescript and then wait for them to catch up. 😄
Don't take those jobs. As you say, the pain would be too intense.
Take the job and convince them to switch to Typescript! if not, writing vanilla javascript is not so much different, but like someone else said, part of being a good developer is being able to adapt.
Pretty much what I did when I had a react gig. They were stand-offish at first but later thanked me heavily.
I find that using a type-enabled editor can ease the transition from type heaven into duck typed hell. Something like vscode. Atleast it has helped me a lot. The latest insiders build actually has quite good type inference, even for js files.
There are certain scenarios where typings just get in the way. I would take the jobs. If you notice issues where TS would prevent bugs kindly point those out. If you do end up championing improvement to the codebase that will be extremely rewarding. Just don’t expect to be trusted or given resources to rewrite the code day one.
Can you share your GitHub? I would love to read some of your code!
Take the job. Convert them. That's what I did and it's worked out.
I do the same at my job with pretty much every new tool/language I need to introduce: silently do the switch, get people annoyed about it, give them time to get over it and after a few weeks it will appear as an evidence to them. Obviously that works only when the team and project are small enough.
I agree with you, however I feel that both being able to adapt and refusing to lower yourself down to poorer standards are important. Not talking about Typescript in particular here, it’s just experience taught me that bending also has a cost.
There's a lot of resistance to TypeScript, even on /r/webdev. Apparently it's onerous to do all that extra typing to add types. It's much better to have 4 times as many tests instead. Hmm. You were right to turn down those jobs. Those people are dinosaurs and they will be extinct soon.
React development... all in vanilla... 🤔
How about setting checkJS and allowJS to true, noImplicitAny to false, adding the @ts-check directive to the files you're working on and adding jsDoc annotations to your code, that is about as close as you can get without converting the entire code base. Other than that, there is flow .
I don't think you can write JSX without a transpiler can you?
The whole point of the TypeScript compiler is that it compiles to JS. Couldn't you just develop in TS, and always deliver your "finished product" in compiled JS?
Use TSC.JS to convert your typescript into JavaScript. There must be an extension for visual studio code that will output a .js file when you save a .ts file. It's like automatically saving a PNG when you save your PSD.
&gt; The pain would be too intense What a bunch of horseshit. Quit whining. Millennials are idiots.
I might be complaining about moving back in time 7 years to pre TypeScript , but not so sure about the millennial part; I have 30 years experience as a developer.
I don't use it, but I think VS Code should automatically detect the types and provide Intellisense.
This is terrible advice that ignores that there may be legitimate reasons for that company to not use TypeScript (possibly outside of the scope of problems a software developer typically faces. For example, maybe they made a conscious decision to stick with plain JS to increase the hiring pool size? Etc.) OP doesn't want to be that new employee who just bugs everyone all day how they've been doing things wrong for years, and OP certainly doesn't want to burn out after 2 years of unsuccessfully trying to make an impact. Large organizations are _incredibly_ resistant to change. Looks like OP is simply looking for a TypeScript job, so maybe he should be looking for one instead.
would it be possible to clone the repo so you have a duplicate you can alter? Then add types to it? it seems adding types to a codebase would be a great way to thoroughly learn it any way? Then can show your coworkers how much better it is with types.
//ts-check is your friend
I think you should learn Typescript. Because it is static language, it will easy maintain your code after long time
Flow ?
You can fall back to React.createElement or [https://github.com/developit/htm](https://github.com/developit/htm) \- but I don't see any reason to not at least use babel.
Use JSDoc.
I bet you got a down vote because most people don't actually know that TypeScript can handle pure JS-files and even parses JSDoc for type checking: [https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html) So if these two companies are using JSDoc, it will definitely help to use ts' tools.
Yeah well then you're channeling your inner millennial I guess. With your attitude I'm surprised you've been able to stay in the field for 30 years. I've got 20 years experience. Adapt or die.
You can start using typescript with vanilla JavaScript.. This would be a great thing for an enterprise software product frankly, they should hire your BECAUSE you are familiar with typescript
Well babel is shit.. So there's that..
Username checks out.
Yeah, I though that too, but it is not working on my machine. I guess I can ask on some vs code forum. Thanks
Explain? What are the shortcomings? Are there better alternatives?
Typescript is better in every single way
They're not exclusive tough. It's a good practice to put the code generated by tsc through babel, because babel is much more granular with targeting certain browser environments than tsc's presets. (see [https://babeljs.io/docs/en/babel-preset-env](https://babeljs.io/docs/en/babel-preset-env) ) &amp;#x200B; Or, you know, have babel directly transpile the typescript for you because it's much faster (and you'd put it into babel afterwards anyways). Granted, you'd have to typecheck your TS in a second thread, but that's what many people using tsc do, too, to get the speed improvements. (See fork-ts-checker-webpack-plugin for example)
Intellisense in itself won’t be able to provide information about types or signatures unless you manually install TypeScript. The procedure is fairly easy though: https://code.visualstudio.com/docs/languages/typescript
There loads and loads of companies that don't work with edge technology. Turning down jobs just because they don't use the techs that you like as if that's the only factor isn't smart, unless you don't care about anything else than the tech stack you work with.
"targeting certain browser environments" and why would you do that? The sheer number of dependencies babel has is a slow stopper for me, it reeks of poor design. Also I call BS on your claim that it compiles typescript faster, are you suggesting they have a custom TS compiler? Because that's a great way to waste time and generate new issues.. TS is open source, if they can improve the compiler they can submit a pull request.
"Why would you do that?" Smaller download size and usage of more modern browser APIs, so more execution speed. In tsc, you can set ES5 as target, or ES6. If you want to support a browser, which lacks one single feature of ES6, you have to target ES5. With babel, it just transpiles to ES6 and that one missing ES5 feature. The resulting code will run much faster and be much smaller, as much more browser internals can be used without being polyfilled (and those polyfills being shipped). The number of dependencies reeks of modular design. You just don't need all of it. I'd not say that's a bad thing. And yes, it compiles typescript faster, as it just strips all type information without doing any typechecking. Tsc can do the same by using `transpileOnly: true` with comparable speed, but as I laid out above, you'll most likely add babel as a second transpilation step, so you'll do the tsc transpilation followed by a babel transpilation. Keeping both in one step is much faster. PS: While I don't know about babel, I can say with certainty the source code of tsc has very bad parts. Qualification to say this: I have read parts of it because I'm a collaborateur for fork-ts-checker-webpack-plugin which integrates tightly with internals of the typescript compiler for typechecking.
Well, one approach is to just use TypeScript as a type linter. This still gives you static type checking before bundling your JavaScript. You also get intellisense, etc., like you would for TypeScript. You do this by providing types using JSDoc comments. It's more wordy than TypeSript types but its just JavaScript comment, not a layer over it the way Flow is. You just need to turn on type-checking for JavaScript in VSCode with: c"javascript.implicitProjectConfig.checkJs": true in your settings. I wrote an article about how to manage all of this: https://medium.com/@trukrs/type-safe-javascript-with-jsdoc-7a2a63209b76
I'd argue that static type checking isn't edge technology. If the powers-that-be at a company aren't utilizing it, that's a red flag.
I appreciate this could be a lighthearted comment but the replies are giving it some weight so I just want to chime in..... I think this is pretty dangerous advice to give around. Whilst I am a huge fan of TypeScript, and my last 2 positions used it exclusively, I am first and foremost a JavaScript developer and so have no issue using the language my team understands and can support, whilst also trying to build support for TypeScript so that we can upskill the team and move everyone over to "the light side" Your advice could very easily make you someone being a bad team member by introducing tools only they can support, an arrogant person for not caring about the current team's conventions etc.... There's also the matter that you have to consider that the choice to not use TypeScript may have been an active one rather than a passive one - the leadership may have decided they didn't want to pay "the TypeScript tax" (personally I think it's worth it, but not every JavaScript developer agrees) All in all, this advice could end up losing them their job given how new they are
Do us all a favor and tell them you're declining the job because they're using vanilla Javascript. They need to know they're losing talent to this choice.
&gt;It's okay, forum gamification is overrated and it's easy to create new trusted accounts. Anyways. Yeps! That's exactly the workflow I'm using. My team (and I) prefer using JS, but we simply love TS type checking using VSCode and JSDoc annotations. It has caught an insane number of bugs, and can also act as a ES transpiler. JSDoc + TS + VSCode isn't too good with Never&lt;&gt; types, &lt;null|undefined|int&gt;[] filtering, and enums. But that's probably cos I'm a masochist who works in `allStrict: true` for `tsconfig.json`.
Uses React framework yet they code in Vanilla JS. Something doesn't make sense in OP's.