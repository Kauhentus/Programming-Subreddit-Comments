&gt; I'd still prefer TS and no tests to JS and tests. Oh... I agree. I'd like to see Typescript full on replace JS moving forward.
I made a quite detailed post on this a minute ago [https://www.reddit.com/r/typescript/comments/b6l0d1/my\_way\_to\_unit\_test\_browser\_code\_using\_typescript/](https://www.reddit.com/r/typescript/comments/b6l0d1/my_way_to_unit_test_browser_code_using_typescript/)
It's no longer a dream baby. Welcome to reality: https://facebook.github.io/create-react-app/docs/adding-typescript
Bad phrasing in my part: "Has been a dream for us using it on our last few projects". It's GLORIOUS.
Hrm, yes, yes. I know some of these words.
OMG, thank you!
Why you no understand "function liftA3&lt;F&gt;( F: Apply&lt;F&gt; ): &lt;B, C, D, E&gt;( g: (b: B) =&gt; (c: C) =&gt; (d: D) =&gt; E ) =&gt; (fb: HKT&lt;F, B&gt;) =&gt; (fc: HKT&lt;F, C&gt;) =&gt; (fd: HKT&lt;F, D&gt;) =&gt; HKT&lt;F, E&gt; { return g =&gt; fb =&gt; fc =&gt; fd =&gt; F.ap(F.ap(F.map(fb, g), fc), fd) }" üòÇ
Why does math always try and obscure the problem.... Use real names ffs
&gt; There's still an important case which is missing: what if both programs are effectful? I don‚Äôt get this. Surely you just compose effectful programs using function composition? Yes, you can‚Äôt have the effect of the second computation depend on the value returned by the first, but that‚Äôs a different thing.
I can recommend [the mostly adequate guide to functional programming](https://mostly-adequate.gitbooks.io/mostly-adequate-guide/) for a much easier explanation of applicatives - they're in chapter 10.
&gt;Yes, you can‚Äôt have the effect of the second computation depend on the value returned by the first, but that‚Äôs a different thing. Well ... no, not really. Function composition means exactly that, taking the return value from the first and piping it into the second. For what the author describes as "effectful", we would have two functions like `number =&gt; Promise&lt;string&gt;` and `string =&gt; Promise&lt;Profile&gt;`, and would want to end up with a function of type `number =&gt; Promise&lt;Profile&gt;`. You cannot do this with trivial function composition; the type needs to support flattening (which the functional crowd has annoyingly called a "monad").
Whenever a functional programmer attempts to explain functional concepts to newbies through all of the incredibly abstract category theory stuff I always think of [Evan Czaplicki's interesting talk on elm and mainstreaming functional programming](https://youtu.be/oYk8CKH7OhE?t=1647): &gt;It's like saying, oh, you want to add numbers? Just rotate space in the addition group. Like - why would you say that? Just add them.
MyConstClass is not a type, it‚Äôs a variable. This is like var a:string = ‚Äúhello‚Äù; var b:a = ‚Äúworld‚Äù;
Evan and Elm are incredible.
Ooo this is mighty interesting, will give it a play now!
`type MyConstClass = MyClass;`
It's not quite like that. Classes are variables. Using a class as a type refers to being an instance of that class.
I want a variable by that name, not a type.
You want both, so you have to do both. My code is a supplement to what you already did.
Yes, when you define a class in typescript you are essentially defining both a type and a run time variable. When you defined a const, you cannot use it as a type. So 'class A {}' will give you access to a type A and a run time variable A 'const B' will not.
Would you second cspotcode's answer to add an additional type by the same name?
Will this work if I export both the type and const? The same way exporting a class lets you use it as both a variable and a type?
That was really well done. Nice job 
Just try it? But yes.
&gt; I am thinking that instead of State = ReducerState&lt;R&gt; it needs State extends ReducerState&lt;R&gt; What people really need to understand is that `= ReducerState&lt;R&gt;` just declares **a default type** that is used when the type parameter is omitted. It is not a type constraint. People are still able to just pass `number` or whatever type they want.
oops sorry, yes I already know its a default type. I shouldve used other syntax. I was just trying to illustrate what I was trying to do in save the resolved conditional type to a value so it doesnt have to be done every time.
Pretty interesting. Thanks!
So there are three sorts of exports, as converted by TS, but one (`export = Foo`) is really only appropriate for CommonJS. It's more of a legacy export for Node/CommonJS than anything. Given these ES6 exports: export = Telnet; export default Telnet; export { Telnet }; ...or CommonJS exports... module.exports = Telnet; module.exports.default = Telnet; module.exports.Telnet = Telnet; These can then imported using CommonJS/Node: const Telnet = require('telnet-client'); const { default: Telnet } = require('telnet-client'); const { Telnet } = require('telnet-client'); Or with ES6 modules like this: import * as Telnet from 'telnet-client'; import Telnet from 'telnet-client'; import { Telnet } from 'telnet-client; With the `esModuleInterop` and/or `allowSyntheticDefaultImports` compiler settings, a default import will handle both your `export = foo` and `export default foo` exports. This is an compatibility setting for Babel's ES6 module implementation, which treats `module.exports = foo` and `module.exports.default = foo` the same. Typically, you'll want to use a default export.
TLDR: tslint has architectural problems related to performance, and Microsoft was already supporting both of them. They're simply dropping tslint and moving forward with only eslint.
 [https://codesandbox.io/s/3xmvxk0l9p](https://codesandbox.io/s/3xmvxk0l9p) &amp;#x200B; Sorry, had zero minutes of downtime yesterday but made this example the night you asked. It's a bit of a contrived example as I wanted to make something to also show a buddy of mine who's trying to get back into development. Specifically for you, I would just take a look at the types in `Car.ts`, and how it can be used in `app.ts`.
So the library I'm attempt to type exports the main class with the commonJS export module.exports = Telnet Telnet is also the only export so presumably it could be made default. My project uses the es6 style modules so for my type definition file presumably I'll just want to update my `export = Telnet;` to `export default Telnet` or would I also need to add one of these compiler settings as well.
If you're typing a CommonJS module, `export = foo` is fine. Just have to keep in mind that if you want to _import_ it into a TS project, you'll have to enable one of those compiler options.
Why are you asserting these types at all?
Freelancer here. I've done this for many clients and it works well for small businesses. Great article, thank you
I'm asserting them in unit tests. I'm only saying it in comments to make it clear what I am expecting.
I could not try it, as I was in bed at the time. I wanted to hit the ground running the following morning. I cannot export both, unfortunately, because I am using `export =`. class MyClass {} someFunction.MyConstClass = MyClass; export = someFunction; This lets the user const someFunction = require('package'); // or const { MyClass } = require('package'); Unfortunately, I don't seem to be able to export a type in addition to `=`.
wow, iam the first to say: nice and gj developing ts. &lt;3 it
Unfortunately we have to hold off on that until it moves forward to a mature stage in TC39.
this brings it to my point [https://github.com/Microsoft/TypeScript/issues/16#issuecomment-55315658](https://github.com/Microsoft/TypeScript/issues/16#issuecomment-55315658) :-)
In the "Contextual return types flow in as contextual argument types" section, it looks like both code snippets are the same aside from the comment. Am I missing the change? It looks like maybe the Type Argument is supposed to be omitted on the first snippet.
Thanks for the help!
Fixed, thanks!
typescript is so successful because it follows closely ES standards, very easy to learn. It would be crazy to diverge from ES standard, that why other languages compiled to JS are not as successful.
Wow your comment is almost 5 years old and still no optional chaining :(
Has there ever been talks about implementing strongly typed errors like in Java? Basically, in Java, if you don't catch an error type thrown by a method, the IDE will let you know. I feel like this is the worst aspect of Typescript
The feature you are thinking of is called "checked exceptions": https://github.com/Microsoft/TypeScript/issues/13219
[removed]
This is a huuuge release notes document. The generics piping is definitely great to see. The `readonly` / `const` section definitely sound like they'll helpful for some scenarios where you want literal types (like redux actions). But at the same time `readonly` smells a lot like C++ `const` and all that entailed... Will my linter be able to autofix my const-correctness? :P
Use "declaration merging." It'll take some googling, but it lets you merge a namespace with a function.
hi -3 points, i was just kidding with the comment guys. just joking around, for fun.
Are you building a DI container or something? Those usually register and instantiate one at a time exactly to avoid this problem. Anyway, you have a few options, but none of them are particularly good. Your first option is just to return them against an interface. Depending on what you need to do, this is probably enough. I would consider this the most idiomatic. Your second option is to do the ["func" approach](https://docs.microsoft.com/en-us/dotnet/api/system.func-17?view=netframework-4.7.2). One generic per input parameter, so you can trivially have the output typed correctly. This requires *a lot* of seemingly-redundant typedefs but it'll work for a reasonably small number of inputs. Your third option is to make a giant sum type with all of the possible instances, then use type guards to narrow down the class to a concrete value. This would work but it would be pretty ugly. There's not going to be a magic solution here since you don't actually have a tuple here - you have an arbitrarily-sized polymorphic array. Typescript doesn't really support this and I'm not aware of any typed languages that do.
That's interesting, because I notice that, at least at the moment, eslint is *way* slower on my project than tslint. :P I use the very excellent "lint-staged" on my projects, and at the moment I have it running both tslint and eslint on my files, and tslint finishes much faster (although, that's always on a small number of files, and it could be I have some derpy plugin taking a long time to load; I haven't looked into it at all yet). But even with temporary performance issues aside, there's so many good plugins out there for eslint already. I've had no problems (so far) with the react plugin or react-a11y.
Honestly I'm baffled that this one is still being held back by TC39. It's been hanging around for years at this point, I would have expected it would be a no-brainer. 
I disagree. That's one of my least favorite parts of Java, and I'm glad it's not in Typescript (or C#, actually).
I feel like exceptions are a "special" kind of return value - the thing worked, or it didn't, but instead of treating the possible results as standard return values, you "return" the result as if it were a special value, and the caller can choose to handle it or let everything explode. &amp;#x200B; Sadly, TypeScript users will likely have to put up with them forever. :( 
You can always swap it with things like `Result` or `Option` instead of throwing from your own code when you expect errors to occur (which really doesn't make them "exceptional" any more). You do still have to put up with it in general, but it can help.
I‚Äôve always wondered why they weren‚Äôt included in C#, as exception handling has always felt like one of the more fragile pieces of an application without proper type checking of what you‚Äôre trying to catch. But, it‚Äôs interesting to read Anders‚Äô thoughts on it...some downsides in there to checked exceptions that I had never considered.
I think you can still have proper type checking on exceptions in C#. Or more specifically, you can `catch` errors into separate blocks by matching on exception types. Usually when I'm throwing exceptions, it's for an error that I want to shut down the whole process / thread / request / etc. Or more specifically - not an error I want the immediate caller to catch and then use as application flow.
Right, once they‚Äôre caught they‚Äôre strongly typed, but I meant that whether you‚Äôre actually catching types that can be thrown is something you can‚Äôt discover until runtime in C#. But you are correct that when exceptions are used ‚Äúproperly,‚Äù that is, for truly exceptional situations, and not for general flow control, knowing the exact type of exception you‚Äôre getting usually is not important, and that seemed to be Anders‚Äô take on it as well.
Wrong subreddit. But looking at your profile it's clear that you're just a spammer.
There is no way to make this type safe. You try to make use of runtime values and mutations at compile time. Calling `magic.add` will not change the type of your magic injector, and thus the compiler is not aware of any added keys when using with the inject method.
also used in React class-based components when you define state
And this is a way cleaner approach than exceptions.
I think the types and interfaces should live in the packages of the code that they work with but if they form part of a module's interface then there is nothing wrong with rounding them up into a compound type/interface that is easy for clients to consume. Your question reminds me of the debate between package-by-feature and package-by-layer, even though custom types aren't a layer. I'm yet to here a good argument for the former even though popular frameworks like Rails used it. You can read about package-by-feature here in this really old but still relevant Java site. http://www.javapractices.com/topic/TopicAction.do?Id=205
i really like this one: https://basarat.gitbooks.io/typescript/
I guess in that sense it‚Äôs consistent with what is written, but it seems a weird definition of effectful. Lambdas are pure; the effect is functorial context. The suggestion that you need monads to compose two effectful programs does not seem misleading, to me.
Checked exceptions are considered a bad language design choice by many wise people in the Java community, including Joshua Bloch and Robert C. Martin. It's pretty telling that nearly all languages extending Java (like Groovy and Kotlin) ditched them. I had extensive discussions about the topic and I know a handful of people who would hate to lose out on checked exceptions. IMO it's useful to signal that an exception is expected so that you can get a warning when you don't handle it, but that should be part of a linter and not influence the compiler/interpreter or language. 
Is it possible with typescript using a linter to get such results ? I mean currently you can‚Äôt even specify the error type in a catch clause 
It does not need to be as verbose as the stated in the interview with 80 different catch blocks... for large scale applications like that, you can simply do a catch all block , the value is very high for smaller error types. Additionally, the idea that throwing an additional type means changing the old code which uses it so it‚Äôs a breaking change is not true either, if there is a catch all block then there is no change, additionally, some would look at it as a good thing that if you are adding additional potential errors, that you have a system to check that the code can handle it. On a further note, we may simply have different opinions , which is fine, but to just leave the feature out completely which could add a lot of value to many people, based purely on opinions does not seem reasonable. There are tones of configuration options with ts, having ‚ÄòtypedExcetopns : true ‚Äò will not imposed anything on your codebase but add a lot of value to people who would like a feature like so
Yes, I agree. I think the author is talking about it in the most strict, haskell-like terms, where they would be correct that you need abstractions like this for side effects, but this definition is not very helpful imo and doesn't explain the value of FP very well. 
I love you for including the incremental compiler option. Keep it up typescript team!
Ask yourself this, does it make sense to have your ShipmentAddress type and CardPayment type defined in the same file? There's not a generic right or wrong answer to this. But it'll lead your to answer for your application.
The upside of Packt publishing is that you can often get the ebooks for 5 bucks. The downside is that they‚Äôre often garbage. You‚Äôd be better off reading blog posts. O‚Äôreilly has the definitive book on microservices. It‚Äôs more of an architectural book though. It does not walk through actually creating a service in any language. It‚Äôs still a fantastic read. Lastly, I sure do love Node and TypeScript, but depending on what you‚Äôre going to do with those ‚Äúmillions of requests/users‚Äù, Node/TypeScript may not be the best solution... especially if there‚Äôs a database involved. 
I'm pretty sure you're asking the same as some other guy the other day where I answered: https://www.reddit.com/r/typescript/comments/aqxpmh/dynamically_type_the_return_of_a_function_with/egjewdy/ Let me know if this answers your question or if I misunderstood you.
I have a folder called `types` that has all the general data interfaces and some utility types. This folder is aliased to `Types` and its index re-exports all other files' exports. Types that pertain to, or are tightly coupled to, a single file's API are exported from that file instead. No issues with this setup on a large project. I'd recommend it.
Is this Typescript or [Assemblyscript](https://assemblyscript.org)?
 Learn typescript in hindi the complex topics broken down into simple chunks visit [https://www.softimpression.i](https://smartcodehub.com/)n or visit [https://www.smartcodehub.com](https://smartcodehub.com/)
what the fuck, stop spamming us with this shit! 
I don't want to be the asshole here, but if your company's plans are to scale to millions of users and the person responsible for that doesn't have any experience with such applications and is just starting to read about microservices and instrumentation, I don't see that happening. My advice is to stay with a monolith and to use the best practices you're aware of, keep things separated and cohesive, if there's any real need to move to microservices in the future then you'll have gathered enough experience to do it properly, otherwise you're basically risking your company's product to experiment with new technologies and tools. ^(Not like they don't deserve it if they're making you take those decisions.)
Your methods have no types. Give them one, even if they return "void". A variable which is initialized, does not require an explicit type. TypeScript can infer it. If you want, you can keep the explicit type definition. It is more a matter of taste. Your field "method" has no defined type. Besides the typing, I would not override the value of an argument, this may lead to confusion and bugs. Use a separate variable with the new calculated value instead. Furthermore I would shrink the length of some of your lines. They will be hard to understand in the future if you won't touch them for a certain period of time.
Ok.
How do I give my methods types? If, for instance, I had the following method: ``` helloWorld() { return "Hello World!" } ``` How would I give it a type?
```helloWorld(): string { return 'Hello, World!'; }```
Thanks!
`Type 'Promise&lt;{}&gt;' is not assignable to type 'void'.`
If you are not resolving any value, i.e. `resolve()` you should define `Promise&lt;void&gt;` as the return type.
Oh ok.
I would recommend your to read through the TypeScript handbook, starting with the basic types: &amp;#x200B; [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html) 
Always annotate types in methods is a bit strong. If a method just returns a constant, I don't see much downside to letting TS infer it's type. There are quite a few redundant type annotations here: &gt; constructor(method: string = "TEMPORARY", size: number = 10): void { The string and number can be inferred from the default values. The return type of a constructor is always the same so don't bother with ": void". Also, don't repeat type information in your jsdoc. The type annotation is enforced whereas the jsdoc is not. Inevitably they'll get out of sync which will lead to confusion.
Declare methods which return a Promise async.
Set noImplicitAny in your tsconfig.json. The type checking is quite lax without it.
Some quick thoughts, not all is typescript related: &amp;#x200B; * add a type: `method: any`; * remove the else: `else if (navigator.webkitTemporaryStorage)` * if your arrow function has only one parameter, you can remove the parentheses (around 'list' in this example, but i saw more): `const toArray = list =&gt; Array.prototype.slice.call(list || [], 0);` oh wait, you do it in some places - in that case: be consistent :) * about that previous method, i don't see why you would create that function in another function. just add that function somewhere, it nows gets recreated every time * add type: `let entries = [];` * just checking: does ts know what all definitions for `fs.root.whateverYouUse` * `position: number = 0` you can remove the type here * for explicit clarity: add public/private (or protected) to every class-method/variable. * constructors don't have a return type * lots of missing semicolons * i would only use arrow functions and not this: `reader.onloadend = function(e)` * use tslint (will tell you a lot of best practices and consistent stuff) 
The constructor takes an argument `method: string`. It should be `method: ‚ÄùTEMPORARY‚Äù | ‚ÄúPERSISTENT‚Äù` instead. Then, no other string is allowed as argument, and even better, you get type narrowing in the function body. You use callbacks for async in your implementation. It is nice that you made your interface promise-based, your own code is ugly and error prone. The best solution imho, is to use the library `fs-extra`. It has promisified versions of all of the `fs` functions. Then you can use async/await instead. I can‚Äôt tell without seeing your tsconfig, so I have to ask; Did you turn up the strictness to max? If not, do it. noUnusedLocals noUnusedParameters noImplicitReturns noFallthroughCasesInSwitch
No just Typescript. I meant to try Assemblyscript at some point. I wonder how much of a performance gain it can bring. Do you have experience compiling your typescript to web assembly? Any noticeable gains?
Generally the `strict` flag is a must.
&gt; A variable which is initialized, does not require an explicit type. TypeScript can infer it. With an explicit type you benefit from excessive property checks. With the inferred type.. not.
If you're willing to go down the functional, relatively uncommon route you can utilise typed monads e.g. `Result&lt;T, E&gt;`.
&gt; Always annotate types in methods is a bit strong. If a method just returns a constant, I don't see much downside to letting TS infer it's type. It's less for the compiler and more for the programmer. If you write the return type directly on the method declaration line, you don't have to read its code to know what it returns.
Web assembly should give you huge performance gains for tasks like raytracing etc
Very cool! I'll give it a try, thank you
&gt; The best solution imho, is to use the library fs-extra. It has promisified versions of all of the fs functions. Then you can use async/await instead. Just a heads up, fs promises are in Node &gt;= 10. It's still experimental, but everything seems to work... https://nodejs.org/dist/latest-v10.x/docs/api/fs.html#fs_fs_promises_api
If you're using an IDE like VS Code, you should be able to just hover over it to see what type it returns.
But you said ‚Äú that should be the job of the linter not the compiler‚Äù 
And if I explicitely set the return type, I can get it at a glance without having to touch the mouse and wait for a popup. And I often read files without my IDE (with a `cat` for example). I get that it's technically useless, but code so is Typescript ^^
Whatever floats your boat! I just don't think it's fair to characterize it as a "best practice".
Which technologies would be a better option if it has databases for almost all of the operations? 
I didn't, just throwing out an alternative.
The way to express that one type "forms a constraint on the minimal set of allowed values" of another is an **intersection**. If you have `type Foo&lt;T&gt; = T &amp; U`, then `U` forms the minimal set of values of `Foo&lt;T&gt;` Consider this simpler example: ``` function foo&lt;T extends { bar: string}&gt;(arg: T) { //... } ``` In this example, `extends` works basically the way you expect it to: `{ bar: string }` is the smallest interface that will satisfy it. So `foo({ bar: "hi", baz: "yo" })` and `foo({ bar: "hi", bop: 1 })` both work, but `foo({ bar: 1 })` and `foo({ baz: "yo" })` do not. Any type `T` you could pass must be an intersection containing `{ bar: string }`. Now consider your example: ``` function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) { return obj[key]; } ``` Anything you could pass for `K` must be an intersection containing `keyof T`. So what happens if we pass something that isn't in `keyof T`? ``` getProperty({ foo: 1 }, "bar") ``` `K` here has type `"foo" &amp; "bar"` which doesn't make sense; it resolves to `never`.
Node is great for quick responses. It‚Äôs a good fit for a system that quickly hands a request off to another system. When dealing in long running queries and CPU intensive tasks, we look to Java and now Rust (Vert.x and Actix respectively). That‚Äôs not to say node doesn‚Äôt have its place. But if you‚Äôre looking to handle multiple queries over multiple requests, other stacks will get you more bang for the buck. 
&gt; on't think it's fair to characterize it Another reason for it being a best practice, is that if you let it be inferred what can happen is that the return type can be unintentionally changed. Lets say a method returns a result from another function, so changing the return type of one function changes the return type of the method. This may not be what you want. The compiler will probably catch the issue if the change results in an error, but now a maintainer of the method will need to decide if that is consistent with the original intent of the method. If the return type is only inferred, there is less guidance than if it was explicit. 
Not necessarily. It's going to depend on what you do with your data. If you're already using typed arrays and good data design it's not likely that web assembly will offer anything in the way of performance. JavaScript on V8 isn't particularly slow though certain constructs can be and if you avoid those your mostly good.
This article same as the previous one and previous ... has zero specifics related to the TypeScript. This makes me think that TypeScript added to the title just because of hype. PS you can enable `esModuleInterop` TS compilation option which will allow you to do `import fs from 'fs';` instead of `import * as fs from 'fs';`. The option, by the way, is enabled if you generate default config running `tsc --init`. Besides it's better to enable `string` compilation option rather than just `noImplicitAny`.
Even in OOP, extending a class creates a subset of this class type, not a superset. So extends is not misleading here, but it‚Äôs that the naming is really OOP-style. Maybe too much for a language where nominal typing is still impossible.
The problem with React Native is that you start developing thinking that it will save you time from developing two native apps for Android and iOS and then you find out that developing them directly in their native frameworks/languages would've saved you much more time than fighting the limitations and bugs of hybrid development. jm2c.
my bet for this multiplatform right now is on flutter, flutter is better at this because it could compiled to native code I wish we could write flutter with typescript seriously I'm in love with the syntax, typing, IDE, lint and intellisense it's like using sith power but still being a jedi. 
I agree, but I don't really believe in Flutter. Just due to the fact it requires you to learn Dart it's a dead bet imho.
Huh interesting. We had to create a prototype at the university for an application like yours, except that it was based on/around one certain feature that I don't see in your application.
yeah dart is the bitter pill.
This reads like a spambot, and the post history confirms it.
which feature?
We tried to solve a problem for academic research. Our primary goal was to link scientific papers, because of their sources/citations. So we also created the possibility to select/highlight some text/area in a pdf, the citation of a source paper, and link it to the source. So once that was done (think of a collaboration tool for a faculty or research for a dissertation) you could click on that highlighted text and it opened the source pdf next to that pdf and showed the place/page/text where the citation came from. So in a perfect world a new faculty member, doctoral candidate, student has a quicker access to all these papers, instead of finding them and reading them to find a specific citation.
I use React Native and that isn't my experience at all. 
What's your comparison with the experience with native development then?
Very cool! Here's the [article overview Trool](https://levelup.gitconnected.com/trool-a-spreadsheet-rule-engine-for-nodejs-typescript-edcb05fca231) it as well.
To be fair, I definitely have more experience in React Native than developing with the platform SDKs so I'm obviously more comfortable with React Native. I have however worked on large applications in all three. Before I get started I just want to clarify one thing, it's not a hybrid app. I agree about your sentiment related to hybrid apps built with Ionic or Cordova but this is a native tool that executes JavaScript and it makes a huge difference. Also, from what I understand Flutter uses a similar architecture with different tradeoffs especially under the hood and I think it'll win out because it's a cleaner experience. Most of this applies to Flutter as well. I'll start with the low hanging fruit, you're doing everything twice so even if it did take 50% longer in React Native than either platform it still takes longer overall. That isn't to say it's slow to develop with, it isn't at all. Add in code sharing for web and it makes a huge difference. Then there is JavaScript, which I'm indifferent to. I think this is a major draw for a lot of people who want to use React Native and it's the worst reason for choosing it. Over the air updates are cool but not necessary. Running logic in a JS engine that passes messages to the native side means that to get completely synchronous code you need to go native (React Native re-architecture is supposed to address this). Ultimately JavaScript is just the language it happens to be implemented in. My biggest problem with going pure native is the MVx architecture. If your application doesn't fit into Storyboards, Android's layout files, HTML/CSS, things can get really messy. Even when you're doing things the right way you get excessive coupling, counter-intuitive division of responsibilities, dealing with the limitations of inheritance, etc. It's the whole Massive View Controller problem, and the ways of mitigating it like using MVP or VIPER don't really solve the core problem. I greatly prefer the React architecture which IMO was built to better scale to complex problems. I just posted another [comment](https://www.reddit.com/r/reactnative/comments/b7di6g/porting_a_cordova_vanillajs_app_to_react_native/ejvm5z4?utm_source=share&amp;utm_medium=web2x) on the React Native subreddit about it if you'd like to read more about what I mean.. One of the great strengths of React Native is that it is incredibly flexible about integrating with native code. There is definitely a steep learning curve to it but it's incredibly powerful tool that means you won't be forced to compromise. This can get incredibly complex if you try integrate into an existing app though, having gone through the same problems Airbnb did I get why they bailed and I would've too. Ultimately that didn't have as much to do with React Native itself as it did about that use case. I might be underestimating native development but I definitely think you're underestimating React Native especially it's upside which IMO is higher than any other front-end technology. Ultimately, it's a framework, and it's not going to stop you from shooting yourself in the foot and that's been the source of all my problems.
TypeScript support of ReactJS is a lot better than Angular, ironically.
&gt; "forms a constraint on the minimal set of allowed values" Extends clauses are an *upper* bound of the set of values denoted by a type, but they describe the minimal amount of functionality provided by the type.
I think the same. Working with Angular, I missed type checking in templates so much!
Not only in the templates, also in the TypeScript code direct. For example you can't use explicitPropertyInitialization with bindings. Or stuff like `ViewChild()` where you need to repeat the type twice (and it can even differ!), or sometimes you need to use a magic string that is somewhere defined in the template. Just... no.
IT's a joke but TS errors are truly a problem.
&gt; IT's a joke I believe that /u/DanielRosenwasser would not lie to us, and that this feature will definitely come. Together with the error messages in haiku.
Right. My understanding is that a generic is the union of all types. \`extends\` restricts the domain of that union to types that are intersections of the extended type (an upper bound). Each individual member of that union must be an intersection of the extended type (a lower bound).
 type ConfigEntry = { description: string, enabled: boolean } type Config = { flags: { [key: string]: ConfigEntry } } type Flags&lt;T extends Config, K extends keyof T['flags']&gt; = { isEnabled(key: K): boolean } const saneFlags = { wrap&lt;T extends Config, K extends keyof T['flags']&gt;(config: T): Flags&lt;T, K&gt; { return { isEnabled(key: K) { return true; } } } } const featureFlags = saneFlags.wrap({ flags: { dynamic_contact_form: { description: 'The new form that fills in form contacts from the current account', enabled: true } } }) const x = featureFlags.isEnabled('not_a_configured_feature') // should fail const y = featureFlags.isEnabled('dynamic_contact_form') // should work
What's the issue you face? Should just be something like `keyof TypeOfTheWrapCall['flags']`.
dragos's suggestion for types is great too it would work great with Daniels no explicit errors, for those people who keep using never everywhere
\&gt; This is a drastically simplified version of a real function in my application &amp;#x200B; That's useless. The simplified version does not throw any error on 3.4. We need to have the real deal. Also we would need tour tsconfig and command line arguments.
Thanks, I meant to include that but forgot. tsconfig.json: { "compilerOptions": { "outDir": "build/dist", "module": "esnext", "target": "es2015", "lib": [ "es2017", "dom" ], "sourceMap": true, "allowJs": true, "jsx": "preserve", "skipLibCheck": true, "esModuleInterop": true, "allowSyntheticDefaultImports": true, "strict": true, "moduleResolution": "node", "forceConsistentCasingInFileNames": true, "noImplicitReturns": true, "noImplicitThis": true, "noImplicitAny": true, "strictNullChecks": false, "resolveJsonModule": true, "isolatedModules": true, "noEmit": true }, "include": [ "src" ] } I'm using CRA, so I'm not sure what command line options are used.
Thanks for your advice. The O'reilly book you mentioned is this one? ([Building-Microservices-Sam-Newman](https://www.amazon.com.br/Building-Microservices-Sam-Newman/dp/1491950358?tag=kns00-20&amp;ascsubtag=go_952006559_46722489029_301325114634_aud-519888259198:dsa-413046190713_c_29039180478)). And could you send me some material that you like please? (blog posts included).
Thanks for your honesty haha. I never implemented alone a whole microservices architecture, neither think that is the right thing to do, but we are a startup here and I am alone at the back-end development. My plan for the next months is just studying how to implement the microservices properly and the back-end will keep monolith with auto-scaling... Do you have some good material to suggest to me?
You probably want ``` const passing = [1].reduce&lt;boolean&gt;(pv =&gt; true, true) ``` I can't get the compile error that you mention in your post, but the error seems like the error you would get doing ``` const b = [1].reduce(pv =&gt; true, true as true) ``` Where `reduce` infers the return type as the type passed to the initialValue argument (which is *asserted* `true`).
You can use `Object.values` on enum types, because they compile to plain JS objects. You can use this to make type-guards that won't require modification as the enum expands, e.g. enum Terrain { Water, Plain } enum Unit { Player, Enemy } type Square = Terrain | Unit; const isUnit = (a: Square) : a is Unit =&gt; { return Object.values(Unit).includes(a); } export class GameMap { squares: Array&lt;Array&lt;Square&gt;&gt;; constructor(squares: Array&lt;Array&lt;Square&gt;&gt;) { this.squares = squares; } // ... public containsUnit = (row: number, col: number) =&gt; { const square = this.squares[row][col]; return isUnit(square); }; }
Exactly! This also works: ``` const passing: boolean = [1].reduce(pv =&gt; true, true as boolean); ```
Can you define your terms? What are the imports for a class? What are import paths?
Thanks! I guess I need to look more into type guards. 
Yup that‚Äôs the one! Let me look into some more language related posts for you. 
The best jokes are based on reality. You're right that the errors need to get better. The good part is we've been trying hard to do better. Last year we started focusing on the UX and we really did see major improvements. That part of the post is true. I think we've basically gotten over the initial iteration, and "wave 2" is coming, potentially applying the same sorts of heuristics for better errors to overloads. No guarantees though! You'll see it in the next roadmap or iteration plan.
Oh I mean just your typical class imports statements. By paths I mean where they are coming from. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Syntax
Actually, this doesn't seem to work for me: enum Terrain { Water, Plain, } enum Unit { Player, Enemy, } type Square = Terrain | Unit; const isTerrain = (square: Square): square is Terrain =&gt; { return Object.values(Terrain).includes(square) }; const isUnit = (square: Square): square is Unit =&gt; { return Object.values(Unit).includes(square) }; console.log("isTerrain", isTerrain(Terrain.Water), "isUnit", isUnit(Terrain.Water)); The [TypeScript playground](https://bit.ly/2V8afn7) reports that the output is: `isTerrain true isUnit true`.
Check out TypeORM. 
Fuck off with your stolen content.
Are we circling back from exceptions to result codes?
Thanks! I‚Äôm going to start using it!
We have been using that for bit over half a year now and we are happy. What about you?
Or.. you could use the [the loader Typescript officially supports](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html).
Nice project! You mentioned spatial partitioning in your your blog post, I expect that to have insignificant effect here. It's a great optimization when you have many many objects, but it's not the case in this demo scene. Instead I suggest you look at parallelization options, such as [gpu.js](https://github.com/gpujs/gpu.js)
Sequelize with the type definitions worked decently well. Actually, on checking it seems the library is now being distributed with it's own index.d.ts file!
Not OP, but I've been using it for about a year now and am pretty satisfied. Documentation is not great, but given that it's got so few maintainers and is not _that_ popular yet, it's been amazingly stable and feature-rich. It's still somewhat of a risk, but the advantages provided by it using TypeScript _do_ offset those in my opinion.
The more modern approach is using code generation from something like GraphQL or OpenAPI, which works especially well with types.
In TS, get is a named function. ``` export class HelloWorld { get message(){ return "Hello World!" } } const obj = new HelloWorld(); const message = obj.message; ``` 
I fail to see the use case for that? Is it mainly for legacy projects that don't want to rely to `tsc`?
I'm using `sequelize` with `sequelize-typescript@canary`. `sequelize-typescript` provide some decorators to help you define your models in a more convenient way.
And new projects that want to use TypeScript and the Babel ecosystem. Babel is rich with plugins that provide language features and tooling support to optimise you app compilation
TypeORM is the best since it's the only ORM written in TS. All the other ones just have types bolted on top. Although TypeORM feels a bit too java-like to me. We use objection.js and apart from having to explicitly write some types into a generic argument and this problem: [https://github.com/Vincit/objection.js/issues/319](https://github.com/Vincit/objection.js/issues/319) it's been working well enough. 
I disagree. We do it the other way around-generate graphql schema from our objection.js classes using [https://github.com/capaj/decapi](https://github.com/capaj/decapi) and that seems to work much better. That way you don't have two separate sources of truth(schema and the resolvers). You just have a single model.
That is certainly a bit better than having typings in @types npm namespace, but it doesn't guarantee that the typings are correct.
It has improved a ton
ok.
If you really want to use ORMs then TypeORM is the best solution out there but it doesn't mean that it's great... &amp;#x200B; Frankly if I would choose again I am pretty sure I would just go with slonik ‚Äî [https://github.com/gajus/slonik](https://github.com/gajus/slonik) Nothing beats raw SQLs. I have stuck multiple times with TypeORM on code that was typed checked correctly and throw errors in runtime. Writing SQLs sure, takes more time but you have full control over the performance and it just works. 
Repositories or active record ? What‚Äôs your way 
Check out routing-controllers for this. Needless to say, cool to check under the hood.
I primary use the query builder, sometimes repositories.
Their implementation does use a global singleton registry for storing routes (see [https://github.com/typestack/routing-controllers/blob/master/src/decorator/Get.ts#L21](https://github.com/typestack/routing-controllers/blob/master/src/decorator/Get.ts#L21)). My approach uses the controller target itself for storing routes, which doesn't require this additional layer.
Thanks! The reason I try to promote this style is mainly because: a. one can avoid "defensive" coding, like using many if statements (and similar); b. when the time comes to *use* the enclosed value, one should call `unwrapOr` or `unwrapOrElse` (providing a safe fallback), while using plain (possibly *nullish*) values *the old way* it is very easy to forget to check if the value is *really* there (the *defensive style* is not enforced by the type system).
It's grown significantly. 12k stars and 93k weekly downloads. Sequelize has 18k and 500k, respectively. I have no idea if that's due to shiney object syndrome or not, but growing that quickly has to mean something. I've never tried typeorm but plan to on my next personal project. 
TypeScript is one of the few languages that actually has a feature which can force you to do null checks for all "| undefined" types: [--strictNullChecks compiler option](https://www.tsmean.com/articles/learn-typescript/strict-null-checks-best-practice/). 
I can't help you unless you're willing to be specific.
So you still need to run TSC to type check?
Yep, this is unfortunate, hopefully the babel plugin can support it somehow in the future. If you're using webpack then you can ingrain in the webpack build using fork-ts-checker-weback (see below). One thing I quite like about using Babel is faster compilation because it doesn't do type checking however. When I'm just scratching around and figuring out an API for something I don't always want to bother building up and tearing down the types so it compiles. I find I run the type check less often (minimum on precommit hook) and that allows me to move faster but still utilise the power of types. Does that make sense? [https://www.npmjs.com/package/fork-ts-checker-webpack-plugin](https://www.npmjs.com/package/fork-ts-checker-webpack-plugin)
I'd expect it to grow along with TypeScript as long as it's the only ORM in town that leverages it so much. Hopefully along with that growth, it will pick up some additional contributors and documentation writers :)
Nice plug lol....
Examples may help. Imports for a class: import { NgxsStoragePluginModule, StorageOption } from '@ngxs/storage-plugin'; import { AppRoutingModule } from './app-routing.module'; Import paths: '@ngxs/storage-plugin' './app-routing.module' By import information I really just meant the path information so that was probably redundant.
prisma.io you wont regret it
Any suggestions out there for firebase?
TypeORM is amazing, although I want to try Prisma as well. Also use Overnight for building Express servers.
[https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API](https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API) Because you want type information, you'll need to create a full \`ts.Program\` and then use the \`ts.TypeChecker\` to (for example) expand the full type of the \`link\` property on the component. For getting an idea of how the TS AST is structured, I recommend [https://astexplorer.net/](https://astexplorer.net/) (change the parser in the \`&lt;/&gt;\` menu to TypeScript). &amp;#x200B;
Quite useless as long as babel only support language features they like and ignore the rest. Namespaces and certain types of enums are not supported and will break the build. Good luck if you're depending on code generation tools like graphql-code-generator, which make use of these language features. 
Personally I don't use namespaces due to them bloating your bundles if used heavily. However see this reply üôÇ https://www.reddit.com/r/typescript/comments/b8fcg5/typescript_and_babel_a_match_made_in_heaven/ejy06jj?utm_medium=android_app&amp;utm_source=share Using Babel for TypeScript may not be for everyone but it unlocks the door for a significant number of JavaScript developers who don't want to or can't leave the Babel ecosystem üéâ Tsc isn't going anywhere any time soon so choosing not to use Babel isn't a problem so long as you don't want to use tools and libraries that depend on Babel or Babel plugins üëç For me it's been a dream move. I can develop and scratch out solutions without needing to fully type them to figure out the API I want due to Babel compilation not requiring types to be correct. Then I can add types and ensure the contracts all match up and enforce it in a precommit hook and the pipeline ‚ù§Ô∏è
I'm using it too, but I feel that I have to write myself lots of redundant information to make associations... I think I'll go for TypeORM next time
We've used [Prisma](https://www.prisma.io/) in production with a lot of success. It generates a database client in TypeScript, JavaScript, Flow, or Go where the datamodel is defined in a "Schema Definition Language" that looks like this: type Tweet { id: ID! @unique createdAt: DateTime! text: String! owner: User! } type User { id: ID! @unique createdAt: DateTime! updatedAt: DateTime! handle: String! @unique name: String tweets: [Tweet!]! } You can learn more about the datamodel specification [here](https://www.prisma.io/docs/datamodel-and-migrations/datamodel-MYSQL-knul/). They currently support MySQL, PostgreSQL, and MongoDB with support coming soon for Elasticsearch, Neo4j, Cassandra, and DynamoDB. The datamodel definition for all of those languages is standardized to the above format with special functionality according to the type of database. &amp;#x200B; The generated client, in this case TypeScript, is used for data access. Here is an example of how to read data: const user: User = await prisma.user({ email: "ada@prisma.io" }) Returns: { id: 'cjsviilie0g880b43twzd93li', name: 'Ada', email: 'ada@prisma.io', role: 'ADMIN' } Here is how to update the data: const newUser: User = await prisma .createUser({ name: "Alice", email: "alice@prisma.io", }) Returns: { id: 'cjswxd4t7379v0b56geckqnoy', name: 'Alice', email: 'alice@prisma,io', role: 'USER' } More information can be found about data access [here](https://www.prisma.io/docs/prisma-client/#basic-data-access). &amp;#x200B; I really like how simple Prisma makes it to manage and query the database and it's worked quite well for us. I would definitely recommend checking it out!
Thanks for the link! Yes you're right. I'm not speaking specifically about this simple scene when it comes to partitioning, but in general. it's a natural next step for any ray-tracer to handle partitioning. The GPGPU capability is definitely a must to bring it to a new level of performance, will check it!
Agree that this is the best option with TS however it has had some really gnarly bugs. Imagine a select or delete that ignored the where clause. That existed for quite a while at one point and there wasn't much motivation to fix.
I've never heard of anyone calling csv files as "spreadsheets" before.
The csv is generated from a spreadsheet. 
`get` is a keyword which means that a function executes to return the value. You did not name the function. What are they getting? class HelloWorld { get WHAT() { return 'Hello World!'; } } new HelloWorld().WHAT; // Hello World This may seem familiar: const myArray = [ 1, 2, 3 ]; myArray.length; // 3 Array `length` is a _getter_ that returns the length of the array. The name of the function (what you are getting) is `length`. Your getter does not have a name ("identifier"), hence your error. class Array { get length() { return 3; } }
writing raw SQL isn‚Äôt gonna get you any *less* surprised at runtime, I wouldn‚Äôt think
Totally agree with using Prisma. The problem with other ORM's is that they try to enforce an OOP defined access layer which causes friction with how SQL works. Prisma is one of the only tools that has both great binding with the host language (TypeScript) and the database itself.
use OvernightJS. [https://www.npmjs.com/package/@overnightjs/core](https://www.npmjs.com/package/@overnightjs/core)
&gt;does that make sense? Nope, not really to be honest
Could take a look at this repo. I believe they're using the typescript compiler to read files and auto-build mocks from the interfaces those files export. https://github.com/google/intermock
I have been using NestJS in two projects and the experience has been wonderful. It is definitely a little bit heavier than a pure Express decorator experience
Yeah to piggy back on this the path should be &amp;#x200B; `node_modules/.bin/tsc`
Looks cool. (I'm an ex-knex maintainer)
TypeORM is the way to go
Just use NestJS
Brilliant time-saver and tool for conciseness. I continue to be blown away by each new update of TypeScript (having used it for nearly three years now); don't know of any other software for which I look forward to updates as much.
&gt; By doing type State = typeof initialState This is only really going to be useful for the simplest of reducers. There are definitely circumstances where you have fields with potentially 2 types (e.g. something can initially be undefined) The const assertions certainly look useful though!
**FUCK OFF WITH YOUR STOLEN CONTENT!** You guys are seriously scum.
Give credit to the original author: https://medium.com/@mschettino/writing-better-reducers-with-react-and-typescript-3-4-30697b926ada Not that stealing scumbag Thomas Granger.
&gt; The spreadsheet must be exported as a .csv before usage. So if I understand it right it does not operate on spreadsheets, but it operates on csv files (which you just confirmed to not be spreadsheets).
I don't really wanna defend the guy if the content is indeed stolen, but do you have any evidence for your claim?
All the way down they write: &gt; Originally published by Matheus Schettino at https://medium.com The link does just lead to the medium main page. They refer to the original content here: https://medium.com/@mschettino/writing-better-reducers-with-react-and-typescript-3-4-30697b926ada They do this **frequently**. Take content of others and post it as their own, just a tiny remark at the end with no link to the original content. They even copy pasted TypeScript announcements as-is, where the TypeScript team regularly uses the term "we".
Why aren't your sorting your object keys or imports?
I don't like sorting imports because it can cause my tests to fail. I am using jest and webpack, so if I get a cyclic dependency in my production code (but it resolves succesfully because of tree shaking from the index.tsx as oposed to jest doing it from the test file) it will break tests. As for object keys, I preffer to sort them logically, so I put the most important ones to the top
I never understood why people sort them. I prefer to have them sorted semantically, not alphabetically, and that's something the tool can't do.
Sorting file names alphabetically lets you find it easier. If I'm doing: import { D, F, N } from './path'; But I want to now also grab `A`, where in my list of imports do I find `./path`? If it's sorted by imported variables, I need to first know what all variables I am currently using in that file. That's additional cognitive load at best, research at worst, and a Ctrl-F for the file name most likely. If you consider all goals when modifying imports -- adding new ones, subtracting existing ones, or changing existing ones -- the starting point for every single modification is "What is the file name I want to modify?" Only after that can you categorize other areas: import names or "semantics." What file do I want to modify, and then, how do I categorize that, and then, where would that be located? You can cut out the middleman there. Just ask what file you want to modify and know where it is located.
Sounds like you have too many imports. :-P I've seen files with more than 20 lines of imports... it's scary.
May this help &amp;#x200B; [https://www.smartcodehub.com/blog/detail/Typescript-Tutorials-Array-Sort-In-Typescript](https://www.smartcodehub.com/blog/detail/Typescript-Tutorials-Array-Sort-In-Typescript)
I like the intent behind the organization of sorted keys and I don't exactly know what that guy means by semantically, but for me personally, I found that sorting keys alphabetically made less sense in some circumstances like when you want the keys to be grouped by some other means. Forcing the alphabetical sort means that you can't construct some object where the keys have different purposes that should be conveyed by organization. For example, grouping them according to the purpose they serve, like these keys are passed through to the next child, these keys are for this component, these are for load state, these are for form state etc. with respect to imports the same applies, but i'd argue that if you're importing so many things from one place that you need to organize the keys other than alphabetically, then maybe that big file should be broken up according to the concerns you're trying to attempting to describe. Anyway, i guess my main point would be that the overhead of maintenance (not that high with unsorted keys) plus lack of flexibility to convey information with an arbitrary "semantic" sorting method (e.g. an informative code comment above a groups of key) makes sorted keys not worth it.
I don't why you're grilling me so much on vocabulary, but technically you're right. The idea is to put your rules within a spreadsheet while implenting them.
If you have a number of imports such that you decided to sort them semantically or group them in any sort of way, you have enough imports that sorting them alphabetically offers the benefits I listed. I do think it's good to have less imports, but whenever you hit the threshold of "I want these sorted in some way," alphabetically offers more benefits that any other categorization.
I tried looking yesterday but wasn't able to find anything, is there a rule for preventing calls to the unsafe lifecycle methods? (componentWillUpdate, etc)
It seems to me like you might have an unnecessary level of indirection. Maybe something like this would work?: interface AppProps&lt;C&gt; { ... } type HttpServerBounded&lt;C&gt; = C extends { port: number } ? AppProps&lt;C&gt; : never; type App = | { tag: 'http-server' } &amp; AppProps&lt;{ port : number }&gt; | ... ; Then `App` is always some specific thing, rather than a thing with a a generic type argument on it.
love this series
Yeah, me too. It's not easy to find such a quality resource. 
Check out the alternative transform based implementation which does not require Proxy: [https://github.com/rimeto/ts-transform-optchain](https://github.com/rimeto/ts-transform-optchain)
"I don‚Äôt have to add any extra levels of inheritance just to be able to treat all my similar classes in similar ways." Why? Just extend the abstract class...
This has always been possible with *strongly-typed-actions* library - nice to have built in support now thougb
I actually enjoyed this. I may have a use for this but i need to think about it more
It seems like you are using it more or less for its UI, Sharing and Collaboration capabilities, not as a database.
I'm glad you liked it! :) Yeah this was something I learned a few weeks ago, tucked it away in the back of my mind, and then an opportunity arose that was perfect for it recently. Maybe the same will happen to you.
Extending the abstract class to create a new class is definitely a valid choice in a lot of situations, but for this code in particular doing so would've been more of a kludge than a benefit. The classes that implement ShapeGenerator are at the 3rd level in an inheritance hierarchy (Generator at the top, non-abstract classes in the middle that fill in many of the specifics, and then the ShapeGenerators at the bottom implement even more specific logic). Since there's already an inheritance tree going on (and there are other 3rd-level classes mixed in here that aren't related to ShapeGenerators), making the tree now 4 levels deep instead of 3 needlessly complicates things (I'll have to start duplicating classes so they're ShapeGenerator-specific). Using an interface keeps things simple, and works really well for this case. Though, as you said, in different situations creating a new class can work just as well.
this looks super cool!
Thanks! What you said does make sense in terms of my case. IMO what you're saying is, the categorization and the definition of the apps are two separate matters. In the categorization case, the only thing needed is the bounds, so in that case I can just round it up to the bounds. This seems to be a perfect backup plan, thanks! Still curious about the ability to explore deeper in the type-level refinements :)
Glad I could help! :)
I think this more a bug than a feature. Code is documentation. Interfaces are Templates for classes, abstract classes and so forth. If you break this paradigm, in my opinion, it's not worth the confusion. However - the information per se is quite interesting
Creating a git submodule with these commons, so to speak.
My repo has 3 packages: front, back, shared utils and types. Front and back both depend on that third package. Whole repo managed with Lerna. 
Few good tips here, but using Object.values is very inefficient...
&gt; very inefficient In what sense? Some quick perf testing seems to reveal it as the fastest way to get object values - http://jsben.ch/kXEyP 
Fair enough! Definitely I think if this feature was used a bunch it would be a code smell, but I'd argue it \_is\_ a template for a class just in a slightly different way than usual.
I agree that importing the same module in the frontend and backend works well. Another pattern that I think works well is to serve your API with GraphQL, and use [GraphQL Code Generator](https://graphql-code-generator.com/) to generate types. Because types on both sides are based on the same GraphQL schema they will be consistent. I am currently using [apollo-hooks-codegen](https://github.com/bearbytes/apollo-hooks-codegen) to generate type-safe React hooks for the frontend.
I do this using TypeORM as my ORM. Like others here have said, I have a front end, back end, and shared project. Both my front end and back end projects depend on the shared one. TypeORM provides a ‚Äòshim‚Äô for the front end that basically defines all the decorator functions as no-ops. You can see what that looks like here: https://github.com/typeorm/typeorm/blob/master/extra/typeorm-model-shim.js#L16-L21 You could probably implement something similar for whatever library you‚Äôre using. 
It's going to be so great if it gets accepted!
This answer ignores his main issue: &gt; How can I use this same file on the frontend without also packaging my ORM into my frontend bundle? His types that he want to share have backend-related logic (likely some decorators).
happy cake day! can you elaborate?
On my current project I'm not using a nodejs backend, so it's slightly different. I'm using a Java spring application for backend with swagger. and \`swagger-typescript-codegen\` to generate types for the FE. &amp;#x200B; You didn't mention which ORM you are using, but you should probably google search about exposing the types specific to that ORM.
I have a project where I actually import types defined on the backend to the front. I also prefer declaring them as global types under some defined namespace (instead of explicity importing them). That way the types are available to the frontend through tsc, but the files where they live are actually never required in webpack. (Although requiring them prob woulnt be an issue with tree shaking)
this is from 2017. dont we have native ts support with babel 7 now? whats the point? are you a bot. questions....
TSLint has a very poor community rules and Palantir stopped working on it as well. There are PRs to react rules but the project seems to be abandoned by Palantir. I started to implement rules from eslint react but soon after Microsoft announced their goal for better ESLint interop. I suggest you fully drop TSLint and use ESLint with the TypeScript parser, TypeScript rule set, and React rules from Airbnb.
Use ESLint and Airbnb react rules. Palantir has abandoned react rules for TSLint and has really stopped giving TSLint love to the point where Microsoft even started support ESLint. ESLint has better compatibility now vs before. They now also have TS specific rules if you use the TS parser. You can learn more here: https://eslint.org/blog/2019/01/future-typescript-eslint
Any new JS method is just as fast or comparable to traditional ways now. V8 has come a long way, plus I would take better/easier to maintain code over slightly more performant code any day of the week.
The problem is precisely using object.values and iteration for the implementation. OP seem to be looking at it from a game perspective with potentially hundreds/thousands of execution.
Take a look at MikroORM, it's a project I've been cooking for about a year now. Heavily inspired by Doctrine, quite similar to TypeORM, but with some significant design differences. There is still lots of features I would like to cover, but the core thing is pretty solid now I believe. &amp;#x200B; [https://github.com/B4nan/mikro-orm](https://github.com/B4nan/mikro-orm) 
This was immensely helpful, thank you! I got our webpack compile time down from 5 minutes to 2 minutes with thread-loader and fork-ts-checker!
You can specify that `formattedObj` is able to be indexed by an arbitrary string: const formattedObj: { [index: string]: string } = {}; This article: [https://basarat.gitbooks.io/typescript/docs/types/index-signatures.html](https://basarat.gitbooks.io/typescript/docs/types/index-signatures.html) goes into detail on index signatures if you're curious.
Check this out: ```typescript const convertArrayToObj = (data: Array&lt;string | string[]&gt;) =&gt; { const formattedObj: { [key: string]: string } = {}; data.forEach((val) =&gt; { if (Array.isArray(val)) { formattedObj[val[0].trim()] = val[0].trim(); } else { formattedObj[val.trim()] = val.trim(); } }); return formattedObj; }; test('ArrayToObj', () =&gt; { const obj1 = convertArrayToObj(['A', 'B', 'C']); expect(obj1.A).toBe('A'); const obj2 = convertArrayToObj([['A', 'B', 'C'], ['1', '2', '3']]); expect(obj2['A']).toBe('A'); expect(obj2['B']).toBe(undefined); expect(obj2['1']).toBe('1'); expect(obj2['2']).toBe(undefined); }); ``` The type is called "indexed type"...
Yes, babel 7 supports TypeScript, and no I don't think it's not a good replacement for the typescript compiler. Babel arbitrarily decided not to support `const enum` or `namespace`. Right out of the gate they refuse to support not-uncommon TypeScript basic features. What else are they going to decide not to support in the future? No thanks. I'd much rather continue to use typescript by the people who made it than babel who just decide they don't actually want to support the language correctly. Here's one example: https://github.com/babel/babel/issues/8244
Personally I avoid initializing objects that have required values and then filling them in later, I prefer to build the object instead. function convertArrayToObj(data: Array&lt;string | Array&lt;string&gt;&gt;) { return data.reduce&lt;Record&lt;string, string&gt;&gt;((obj, x) =&gt; { const value = (Array.isArray(x) ? x[0] : x).trim() return { ...obj, [value]: value } }, {}) } describe('convertArrayToObj', () =&gt; { test('1d array', () =&gt; { expect(convertArrayToObj(['a', 'b'])).toEqual({ a: 'a', b: 'b', }) }) test('2d array', () =&gt; { expect(convertArrayToObj([['a', 'b'], ['c', 'd']])).toEqual({ a: 'a', c: 'c', }) }) })
Shorthand type for this is `Record&lt;string, string&gt;`
&gt;I also switch the lint rule to warn and not error. how does one do this? i'm new to ts
No worries! Regardless of the linter you are using, tslint or eslint. You should have a tslint.json Google the rule giving you trouble and add it to the rules property in the JSON. The properties take a Boolean, object, or array. I recommend using an object because rules have different strictness settings you can use. Generally you can add enabled is true and severity warn to any rule. The third parameter is what varies, it gives you different specific rules for when that rule is enabled
**FUCK OFF WITH YOUR STOLEN CONTENT!** You guys are seriously scum.
Original post https://medium.com/@kevin.lanthier/from-javascript-to-typescript-to-elm-5c36fca70b4a
Are they known for stealing content? 
Yes. Whenever you see "morioh.com" (the host they direct to) you can assume it's stolen.
Thnx.
 const twoSum2 = (nums: number[], target: number): number[] =&gt; { const map: Map&lt;number, number&gt; = new Map(); for (let i = 0; i &lt; nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) { return [map.get(nums[i]), i]; } map.put(nums[i], i); } } &amp;#x200B;
 // Map of a student -&gt; grade let gradebook: Map&lt;string, number&gt; = new Map() // Adding entries to the map gradebook.set('john', 85) gradebook.set('james', 75) gradebook.set('jill', 90) // Other usage... console.log(gradebook.has('jordan')) // false console.log(gradebook.get('james')) // 75 console.log(gradebook.size) // 3
Map exists in TypeScript because it's a JavaScript native: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map SO is wrong and so are you. 
&gt; SO says it doesn't exist. Always take SO answers with a grain of salt. Always read multiple answers and check the date of the answer. Accepted answers don't have to be recent or even correct. &gt; So I look at the docs. No map. Probably because it's a native JavaScript type. &gt; I see a Partial. Wtf is a Partial? It's in the docs. https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types
Ah, many thanks. The issue when I tried to make a Map was that I didn't have the lib defined: { "compilerOptions": { "target": "es5", "lib": ["es5", "es6", "dom"],
&gt; and so are you. This is why people think all developers are autistic. Knock it off.
Change your attitude and what you will get back will change too. Loser.
You are not alone! A few days ago I had the same problem. I decided to use "typescript-collections" from npmjs I was quite surprised to find such poor hashmap/dictionary support in TS 
I've often ran into similar issues with Google searching. It seems like if your issue isn't specifically related to the type system in typescript, you're better off prefacing your search with 'javascript + {question}' instead.
You should edit the original post with this so others know you solved it :)
&gt; I was quite surprised to find such poor hashmap/dictionary support in TS Because that's not the goal of TypeScript. The stated goal is just to enrich JavaScript with type safety. It does not add implementation besides some necessities for syntax (e.g. extends).
Don‚Äôt get so butt hurt over being wrong.
Can we go ahead and downvote the OP already, people? At least then others won‚Äôt help contribute to the thievery.
I just wonder why /u/vexator and /u/Bartvds don't do anything against it.
The barrier to entry isn't really infuriatingly high, I think maybe you got cornered by something and let the frustration get the best of you (who hasn't been there?). If you get stuck on typing things, just give them an `any` type, and come back to fix them later as you learn TypeScript. They intended to allow for incremental adoption and this can help a lot. I'm not quite sure what you're looking for, but if you want to view TypeScript's built-in types, the `lib` folder under source has all of them: https://github.com/Microsoft/TypeScript/tree/master/lib For example, [here's all of the es5 types](https://github.com/Microsoft/TypeScript/blob/master/src/lib/es5.d.ts), which also includes all of the built-ins like `Partial`, `Record`, etc. I found this to be an incredibly useful resource when I was getting started, and still reference it from time to time. As far as navigating VSCode, you can right click on types and either `Go to Definition` or `Peek`. This should give you a good understanding. But generally, with third party libraries, depending on how well-documented they are, it can take some guessing. I found React and Apollo types to both be poorly documented and harder to use at first, but that struggle you go through isn't wasted because you'll have a better idea how to find the type info you want next time. I hope this helps!
I don't know how these kinds of type detections happen in other languages, but I am guessing it's a constant time lookup in a types table or something. So ya, fast would be better. However, my game is turn based and the enums are small; I'm more concerned with correctness / maintenance. Do you know how to get /u/alsiola's solution to without giving each enum a globally unique value (this is what's currently working for me)?
Because {} is a superset
That is whats called a constructor type. It means that the argument is a function that is newable and returns an object. Although it is more realistic to type constructor to T. So that the return type can be inferred. 
`{}` is a superset of `number`? What exactly does `{}` mean then? Is there also a specific type for the empty object? These may be stupid questions but I don't know where to look up the answers.
&gt; .map(() =&gt; () =&gt; I think that should be &gt; .map(() =&gt; Sorry I'm on mobile so terrible formatting, but I'm not sure why you have the double arrow functions 
I appreciate the feedback. The built-in types I‚Äôm 100% ok with. It is React in this case that I cannot seem to find any documentation for. It seems to be a catch 22 to try to use types you don‚Äôt know the definition for...if you even know they exist to use them in the first place. Surely all third-party types can‚Äôt be like this. That seems like a huge waste of time. How am I supposed to know what types to use when? I can review their code, as I said, but at that point why not just make my own type?
{} is almost as any. Empty object is harder, tho.
Objects can still satisfy types even if they have more properties than required. I'm not sure how a type could assert that objects did not. There might be a way.
Thanks. I gave Google another try and this time I found something helpful. https://stackoverflow.com/a/52193484 &gt; if you annotate something as `{}` it can be any of following types: `string | number | boolean | object | {[key:string]: any} | Object | any[]` I guess the type includes type that you can generally read properties from. Due to boxing, that includes some non-object types. So it's kind of like duck typing in that it only cares whether the type behaves like an object.
You're right. I'm not so much looking for an *empty* object type specifically but I was expecting a type that includes objects with any properties whatsoever but not primitives like a number. Apparently that type isn't needed since anything you can do with an object can also be done with strings, numbers, booleans and symbols, including reading properties due to boxing.
Meh ;-)
I need the an array of functions so I can execute them sequentially 
 [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/cheerio/index.d.ts#L116](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/cheerio/index.d.ts#L116) &amp;#x200B; .get() returns any\[\]. You'd need to cast the output to the expected type.
None of your projects has the strict compiler flag enabled. That's a big no from me.
Here's a clearer version: interface Constructor&lt;T&gt; { new(...args: any[]): T }
Thanks for pointing that out. I added strict null check to all the packages and made the appropriate updates. Please give OvernightJS a second chance if you're willing. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/deno] [Build your Deno project with Drash (a new Deno microframework)](https://www.reddit.com/r/Deno/comments/banfwb/build_your_deno_project_with_drash_a_new_deno/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
When to use TypeScript: All JavaScript projects. Fixed it for you :)
That's pretty :) &amp;#x200B; What was it like making a library for deno vs node.js ? Same thing? Any quirks?
Could someone kindly explain why, in the implementation of both data structures, we have to create the phantom types for both type parameters? I think it's for type inference, but why can't typescript not infer it just by inserting them in the call site?
Plasma
Ooh, I think I get it now. Is `{new(...args:any[]):{}}` like an "inline" definition of an interface?
Yes, you can inline any interface definition as long it doesn't have `extends`. Just copy everything in the curly braces. interface Hello { world: string; } let x: Hello; let y: { world: string; };
You're talking about validatePassword, toValidation, validateName etc..., aren't you? In these examples, TS can actually infer the correct type. To explicit the returned type of a function is a good practice: it helps during the implementation of the function itself, warning you if you're returning a wrong type, and it's useful for a reader, who could have a clearer idea on what the function does just by reading its type signature.
Great, thanks a lot!
Then you just need `object` type.
Thanks. I also just realized that. So in conclusion I expected the value `{}` to have the type `object` but I think I now understand why it doesn't.
Thank you! Bottom line up front: easier and cleaner. Development of a server in Deno was faster than building a server in raw Node code. Handling the request-response cycle in Deno felt more robust than raw Node code as well. There are people doing benchmarks on Deno‚Äôs performance against Node and other projects and it looks like Deno is not as performant (from what I‚Äôve seen), but it‚Äôs fast enough for me to like it and code using it. It feels cleaner too. I love that there‚Äôs no package.json file. Importing code using URLs improves the development workflow IMO. For example, Drash uses https://github.com/jshttp/mime-db for its MIME type database when serving static files. In Node, I would‚Äôve had to import the mime-db package instead of importing the https://github.com/jshttp/mime-db/blob/master/db.json file directly. I feel like the whole ‚Äúimport using URLs‚Äù speeds up development and allows for maintainable code especially when you start breaking out your code into different files. Deno does have abrupt breaking changes (they have a note about that on their docs site, so breaking changes aren‚Äôt surprising). During development of Drash, I noticed my local environment‚Äôs unit tests would pass and would fail during the CI process. This was because Deno compiles all dependencies on the first run of the your Deno program, caches the dependencies, and always uses the cached dependencies unless you run your Deno program with the --reload flag to force Deno to recompile all of your dependencies and update cached dependencies. Drash stays up to date with Deno‚Äôs (at least I try to make it that way) latest release, so catching breaking changes and implementing fixes in Drash is high priority for me. I say this because if you build with Deno and plan to keep up to date with its latest version, you have to make sure you‚Äôre doing unit tests with the --reload flag to catch breaking changes early. I‚Äôm not dismissing Node btw. The documentation pages for Drash use npm for dev package management and it‚Äôll probably stay that way for a while. Node still allows me to build fast using babel, Vue, webpack, and the other packages I can‚Äôt remember. One thing I missed during development of Drash was adding scripts to the npm run command. I had to run my Drash scripts by typing out the full filenames every time and that got annoying fast. I know I can make aliases, but I just got used to npm run commands.
An optional variable declaration makes no sense. It can't be optional, because you declare it to be existing. You have to write: let variable: string | undefined; (or initialize it directly).
let maybe: string?
Forgot my semicolon but I think that's what you want...
Doesn't seem to work.
[https://github.com/electron/electron-quick-start/blob/master/main.js#L6](https://github.com/electron/electron-quick-start/blob/master/main.js#L6) &amp;#x200B; Since I encountered the problem through this line of code, how should I write in type script without an optional? Or would an optional one not be optimal here?
Unfortunately it throws the same errors as in my screenshot above.
That is an appropriate use case, yes. I don't know what you mean with attribute.
Sorry, I meant property. Like how is a variable outside of a class different than a property of a class, in terms of that they can be optional. 
`{ a: 6, b: undefined }` is not the same as `{ a: 6 }` If you declare a variable it's there, it's not optional, it just has a value of `undefined`
It is not about whether the variable exists, but whether its content exists.
Optionals are whether the variable exists. 
Good to know. Thanks for sharing these experiences. I had thought the project maybe stalled out. Good to hear that its progressing and fairly capable now. I‚Äôll give it a go!
What wouldn't make sense? It's undefined...
An optional is a type that can hold either a value or no value. The question that arises at runtime is not whether this property exists, but whether it contains a value that can be accessed.
But it's not. An optional is a function parameter or object property that can exist or not. What you think is optional is actually called nullable. It's an intersection of object type and undefined.
Np! :)
Okay, I'm just realizing that we may have a language barrier here, in a programming language sense. I have an Objective-C/Swift background. In Swift every variable can be of type optional. &amp;#x200B; Example taken from Swift: var optional: String? if (optional != nil) { print("Has value") } else { print("No value") } // prints "No value" In comparison to: if (notdefined != nil) { print("One") } else { print("Two") } // // error: MyPlayground.playground:15:5: error: use of unresolved identifier 'notdefined' // if (notdefined != nil) { // ^~~~~~~~~~ &gt;How can variable not exist after you declare it? That's exactly my point.
&gt;That's exactly my point. So why would you try to type it as "maybe not existing" if it 100% exists? Again, `?:` means "maybe doesn't exist", `| undefined` (with strict null checks) is "maybe doesn't have a value". Your Swift example that works in typescript is just: `var nullable: string` `var nullable: string | undefined` with strict null checks
&gt;So why would you try to type it as "maybe not existing" if it 100% exists? Because it's not 100% sure. The optional indicates that the value might not be given at runtime. However, this does not mean that the variable might not exist. &gt;Again, ?: means "maybe doesn't exist", | undefined (with strict null checks) is "maybe doesn't have a value". I guess that's exactly the difference between dynamic and typed languages. If the variable is declared, `maybe doesn't exist` just isn't possible.
&gt;If the variable is declared, maybe doesn't exist just isn't possible. It's not possible in typescript either, which is why you can't type it like that... &gt;The optional indicates that the value might not be given at runtime. It doesn't, for like 5th time. Just forget about Swift, in Typescript it means something else. And nullable (` | undefined`) means what optional means in Swift.
That's exactly what I meant with language barrier, it's defined differently. Thanks for the code example above, I'll do it like that.
&gt; Okay, I'm just realizing that we may have a language barrier here, in a programming language sense. I have an Objective-C/Swift background. In Swift every variable can be of type optional. Javascript (and therefore Typescript) is different from basically every other language in that variables (and properties) can have a value, be null, or be undefined. The distinction between undefined and null is subtle, but you need to be aware of it: https://stackoverflow.com/questions/5076944/what-is-the-difference-between-null-and-undefined-in-javascript I think the answer to your original question is simply that it's very common to need optional properties in an object, but it rarely makes sense to have undefined variables. In the code that you linked the author didn't initialize `mainWindow`, so its equivilent in Typescript would be `let mainWindow: Nullable&lt;BrowserWindow&gt; | undefined`. Skimming through the code on the page it seems as if they really should have written `let mainWindow = null`, which in TS would be `let mainWindow: Nullable&lt;BrowserWindow&gt; = null`. Typescript tends to force you to think about these distinctions, where vanilla JS allows you to be lazy.
In JavaScript, you can check whether a property exists on an object with the `in` keyword: const foo = { }; const bar = { baz: undefined }; 'baz' in foo; // false 'baz' in bar; // true foo.baz === undefined // true bar.baz === undefined // true Note that `baz` exists on `bar`, even though it is `undefined`. The `?` type-operator in TypeScript is not just a shortcut for `&lt;type&gt; | undefined`. It actually has semantic meaning as "this variable may not exist at all". Why is that significant? It helps guide TypeScript's type-guards. For example: type Foo = { a?: number }; function printFooA(foo: Foo) { if ('a' in foo) { console.log(foo.a.toFixed(2)); } } Here, the `if ('a' in foo)` check determines that `a` exists on `foo`, but it does not ensure that `foo` is not `undefined`. So you'll actually get a compile-time error -- something along the lines of `'toFixed' does not exist on type 'number | undefined'`. So let me get back to your question: why can't you use `?` on regular variables? The answer is that there is no equivalent way in JavaScript to check if a variable exists in the current scope. You can check `'a' in window`, but that checks if it's in the global scope, not in the scope of the function or block that you're currently in. Checking if a local variable exists at runtime would be pointless -- either you declared it with `var`/`let`/`const` or you didn't, and you as the engineer should know that at design-time. Instead, you'd do something like `if (typeof maybe === 'undefined')`, which checks whether the variable is _set_, and you signify that a variable may not be set with `&lt;type&gt; | undefined` Now, why TypeScript doesn't automatically set a variable's type as `&lt;type&gt; | undefined` when it's declared without being set? I don't know. In my opinion you should either get an error when doing just `let myVar: string;`, similar to what you get with `const myVar: string`, or you should get an error later on when you try to use the dot operator on `myVar` without first checking if it's set.
`?` is shorthand for `| null | void`. What does `let maybe: string | void;` say?
Let's talk about the key/value pair in isolation. If you declare `let obj: {a?: string}` then it tells TypeScript, "obj exists, and _key_ `a` may or may not exist at runtime, dunno." If you declare `let a: string` then you have initialized `a`, so it _by definition_ is an existing key, even though no value has yet been set for it. I understand the confusion, since when you try to access an object's key that has not been initialized, you get a _value_ of `undefined`, so it seems like setting the object's key to undefined is the same thing. They are in practice very very similar! In fact if you use the delete keyword as in `delete obj.a`, it will actually set the _value_ of a to undefined, but the object _key_ is garbage collected whenever the runtime (usually V8) is ready to do garbage collection. If you think about some of the Object methods like obj.hasOwnProperty("a"), and that a TypeScript _annotation_ of `?` can only tell TypeScript not to error at compile time regardless of whether the _key_ exists or not, you will understand why this is this way. It seems plausible that TypeScript could understand this in such a way as to compile to JavaScript that would result in initializing the value, but the tradeoff is that the JavaScript would also look very different from the TypeScript while also generating performance overhead.
The optional modifier only tells TypeScript whether this specific **property name** must exist on the **object** or not. Maybe this will help you, look at this code with `strictNullChecks`: interface TestA { a?: string | undefined; } interface TestB { a: string | undefined; } let testA: TestA = { }; //ok can omit a let testB: TestB = { }; //error, a needs to explicitely specified -&gt; //Property 'a' is missing in type '{}' but required in type 'TestB'. Both properties have the same type but only interface `TestA` allows us to omit the property. &amp;#x200B; Therefore a variable declaration with the optional modifier wouldn't make sense as a variable declaration will always create a variable with the provided name, you cannot make a variable name optional the way you can make a property name optional.
Functional programming, especially using compose. I‚Äôve not found any bigger pain point than this
Thanks for sharing!
Since Typescript is transpiled, I cannot edit the code interactively in the console 
Thank you! This sounds like an avenue worth exploring.
`Declare` / `define` are different than `assign`. Declaring a variable has nothing to do with whether there is any content assigned to it.
\- Module path maps are not resolved in emitted code [https://github.com/Microsoft/TypeScript/issues/10866](https://github.com/Microsoft/TypeScript/issues/10866) I know, I know - they closed the discussion because MS thinks this is not but but a feature. I still don't get it why - a little flag and some code changed would solve the problem \- Tripple slash for documentation Quite often documentation needs only a one liner instead of the verbose JavaDoc-style [https://www.dartlang.org/guides/language/effective-dart/documentation#do-use--doc-comments-to-document-members-and-types](https://www.dartlang.org/guides/language/effective-dart/documentation#do-use--doc-comments-to-document-members-and-types)
You know the optional pattern from Java? Here is a TS-version: [https://www.npmjs.com/package/typescript-optional](https://www.npmjs.com/package/typescript-optional)
Congratulations. Why should i use your library instead of Typeorm?
I have no experience on doctrine but raw sql writer for years. Can u provide more doc and examples on ‚Äúunit of work‚Äù? It seems to me it is equivalent of transaction but I cannot find it in the doc. Currently trying to use typeorm for a new project. Your library looks interesting and promising. How stable is it right now? Do u think it is production ready yet? Thanks!
For me the biggest no-go with typeorm was how it handles the difference between fully fetched association and just the identifier ([https://typeorm.io/#/relations-faq/how-to-use-relation-id-without-joining-relation](https://typeorm.io/#/relations-faq/how-to-use-relation-id-without-joining-relation)). In MikroORM, this is solved similarly to doctrine, you will always get entity object where it should be, even if it has not been fetched from the database ([https://b4nan.github.io/mikro-orm/entity-references/](https://b4nan.github.io/mikro-orm/entity-references/)). Generally speaking, the reason was the lack of Identity map. Another thing I missed was using entity constructors for required parameters ([https://b4nan.github.io/mikro-orm/entity-constructors/](https://b4nan.github.io/mikro-orm/entity-constructors/)). Speaking about mongo, another selling point could be support for cascade remove operations on application level, so it works for all drivers including mongo driver.
Unit of works pretty much encapsulates database transaction. It tracks all loaded entities and handles change detection when flushing (saving things to database). [https://martinfowler.com/eaaCatalog/unitOfWork.html](https://martinfowler.com/eaaCatalog/unitOfWork.html) Thanks to UoW, you can mark the entity for persist instead of persisting it right ahead, and then (at some later time) flush all marked entities to database at once (inside a transaction). I would say the library is pretty stable, I am using it on 2 mongo projects for more than 6 months, and about 1 month ago I started to use it on another project that runs postgresql.
Can‚Äôt find this in the doc. Is it not written yet? Or I overlooked. Can I do something like this: Update record a b c. Query record d. Failed some tests on d and rollback everything on a b c
Sure you can, there is some general info about usage with SQL drivers here: [https://b4nan.github.io/mikro-orm/usage-with-sql/](https://b4nan.github.io/mikro-orm/usage-with-sql/). Depends on your use case, but if you do not need to update a/b/c right ahead, you can simply mark those entities via \`em.persistLater(ent)\` and call \`em.flush()\` once your tests pass. This way you would not even make a DB call (apart from selects) if your tests fail. More info about how persist and flush works can be found here: [https://b4nan.github.io/mikro-orm/entity-manager/](https://b4nan.github.io/mikro-orm/entity-manager/). If you meant the UoW description -- that is missing in docs, I didn't have enough time to do some architecture page there as describing feature has more priority :\]
First off you are defining far too many types. The interface is fine but why bother defining `keyboard`, `onChange`, etc types? Just something like: export interface Actions { add: (e: KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; void, ... } Should be sufficient. I suppose if you are going to use that same signature over and over then defining them all in one generic place isn't too bad but defining them inside the component file is just too busy. Also you have at least a few places where you are typing unnecessarily. Like: &gt;let list: todo[] = [...this.state.activeTodos] There's no reason to type `list` here. Ts will infer that it is of type `todo[]` based on the value you are setting it to. Only manually type variables when the type won't be inferred. That's a start. In general I feel like a lot of this is messy just because you are doing so much state management inside a component. But that becomes an architectural discussion instead of a stylistic one so I'll just stop there. But cleaning those things up should help a lot.
Yes, exactly that. Changes accumulate inside the Entity-Manager's UoW until `flush()` is called. If it works similarly to Doctrine or Hibernate, no data/statements are sent to the database at all until `flush()` happens. So when you say: &gt; Update record a b c. Query record d. Failed some tests on d and rollback everything on a b c It's actually more like: "Update entities A, B, and C. Failed some assertion on D, so don't call `flush()`. There's no rollback, because there transaction was never started in the first place. It appears there's some kind of `autoFlush` in this library, which I'm not convinced is a good idea, especially since it defaults `true`.
How you would split this class logic? doing react hooks?
I find the `autoFlush: true` default somewhat astonishing. What was the rationale behind that choice?
I agree it was a bad idea to do this. That is why I introduced 2 new methods: \`persistLater\` and \`persistAndFlush\`. I will probably remove this autoFlush mechanism in v3 (keeping the \`autoFlush\` option available, just changing it to false for easier migration), but want to stay back compatible for now as there are already some projects using this.
As I noted in comment above, it was a poor choice. My initial idea behind this was to let developers explicitly say what should be persisted later, instead of the other way around. When I released it was a bad idea, I introduced the autoFlush configuration option so one can choose what they want, plus those 2 dedicated methods.
Your first example is easily implementable in TypeScript as `var x: string | undefined = undefined`. Your second example is a semantic error and is caught by TypeScript at compile-time (you cannot access an undeclared variable).
Lack of higher-kinded types is the most important issue for me at the moment. It makes it very difficult to properly type functional concepts (like functors, monads, monoids) as well as simple utilities (like _.mapValues). Current workarounds are very verbose and unwieldy. I encounter the need for HKTs in pretty much every personal project, and all complex projects in our company require them as well, regardless of being functional or OOP. Some less important pain points: - Lack of variadic generics (you can usually get around with lots of overloads, but it's very verbose or requires code generation) - Type narrowing does not consider indirectly thrown exceptions. E.g. if I define an `assert(condition)` function which throws, the compiler won't see it and the condition will not affect type information after the call. I have to always write `if (arg === null) throw new Error(...)` explicitly. In comparison, Flow does deep checks for exceptions.
I'd probably end up using redux or similar in any decently sized app. But this just looks like a simple todo practice app so I'm not suggesting taking on that complexity. If nothing else I would extract the todo mutation functions to a separate file. Have a function like const addTodo =&gt; newTodo: todo =&gt; (todos: todo[]) =&gt; [...todos, newTodo] Then you can just import that function, and the other similar todo handling functions, into the file and call them inside of writing all the code inline.
After bit more thinking, I realised the root cause here was the fact that I started MikroORM as mongo only project and didn't think about transactions at all. Now with support for SQL drivers and when all `flush` calls are encapsulated in transaction, the default autoFlush: true does not make much sense. I will note this in readme&amp;docs, that for BC the default value is `true`, but users are encouraged to use `false`.
Didn't this get quite a bit better with the last release?
&gt;Looks good.
Biggest problem I have is parsing the entries in DefinitelyTyped. I love the crowd-sourced types and certainly appreciate everyone's work, but I struggle at figuring out how to use each one. I'm still relatively new to typescript, so I'm sure this is something that gets easier the more you use it, but I feel like I'm always tracking down exactly what the different Generics do and what they're for. Then I give up and copy/paste from the tests. I wish there was an easier/more consistent way to document what the types are and how to use them.
thanks please star the repo if you like it
Using compose got a little bit easier. Generic functions can now infer their types better from other generic functions. So methods like compose will require supplying the generic parameter more often. Typing compose hasn't gotten easier though. I think you still have to [overload it like a billion times](https://github.com/reduxjs/redux/blob/master/index.d.ts#L506)
Wrt the lack of HKTs have you seen fp-ts? They have accurate representations of typeclasses for monads, applicatives, and functors (You actually don't need HKTs for monoids afaik). I just finished writing a `Do`-builder, reminiscent of Haskell's do notation for JavaScript which is completely type safe, generalized for all monads, and has great type inference, all built on fp-ts: https://github.com/gcanti/fp-ts-contrib/pull/8#issuecomment-475673334
Ah, sure. That's a [problem in C#](https://docs.microsoft.com/en-us/dotnet/api/system.func-17?view=netframework-4.7.2), too.
A class is also an interface. This is valid: class Test { test: number = 0; add() { this.test++; } } var test: Test = { test: 1, add: () =&gt; { test.test--; } }; So if you have a class you have an interface too.
Interfaces define a minimum contract that all concrete classes that inherit from it will fulfill. They‚Äôre useful if you want to require certain functionality or properties across a set of related classes (for example, the classes Student and Teacher could both inherit from the interface IPerson, which requires that both implement the properties Name and Age). You are forcing implementations to have certain attributes and allowing the compiler to catch it if they don‚Äôt.
is it possible that the maintainer for typeorm would have accepted such changes?
Is that function overriding?
Ah thanks! So when writing an interface you want to think of what properties/functions this should have at the minimum rather than trying to cover all cases?
For the most part, yes. It‚Äôs perfectly valid to have an interface that you know will only be implemented by a single class and therefore has all of the public properties and methods for it. You still get the benefit of the compiler making sure you‚Äôre doing what you intended to.
Interfaces are types only. Classes are types that also have behavior. That's it.
Thanks! I'm still trying to get better at designing interfaces.
I like your username btw! Do you write all your interfaces in one file? What's the standard on this?
No that would be if you made a new class that extends the base class and had a different implementation of the function in the new class. My example only shows using the interface defined by the class so the function implementation from the class doesn't make it to the object in any way. If the class had a constructor it wouldn't be run on the object that is set to the type Test.
Ah! Thanks for the clarification! So basically `test` implements `Test` and the compiler says "hey I need `test` and `add`"
Yep, it effectively treats it the same as if you had made an interface describing Test. interface ITest { test: number; add: () =&gt; any; }
Parts of it would be probably mergable (like the application layer of cascading), but pretty much all of it highly depends on unit of work, which is not present in typeorm, and I would say that is really too big design change to be merged. Without UoW and its identity map, most of MikroORM benefits could not exist. Of course, implementing UoW brought a lot of challenges, and I would be probably scared to even try to implement such a thing into typeorm as its codebase is pretty huge nowadays. Another problem would be back compatibility -- I can imagine pretty much any feature related change like those listed above would result in BC break, so one would have to hide those changes behind some configuration flag.
A sample React Native Redux Saga app that I can base myself on.
but the unit of work feature is the important part :(
Yes, that is why I invested my time to create this thing, there were just too many design differences... Btw also fan of Nest, too bad I didn't find it earlier :\]
U probably need a FAQ page and I am dumb enough to provide lots of q. üòÄ I think I am a typical raw sql user looking for orm in node btw. üòÇ
Agreed, FAQ page is missing. That is one of reasons I started this discussion, to get some feedback (and to understand what is hard to understand for others :\]). I will be more than happy for your questions, no matter how dumb they might appear :\] All feedback is welcome. Feel free to ask here, plus there is also `mikro-orm` tag on stack overflow.
Yes, that's exactly what I've often repeated here. But maybe the comment was not about my answer?
Thanks for the hint.
Thanks for the explanation
Ohhh - I forgot: A collection-framwork for TS This is really poor in TS. OK JS-Map but this is more or less a joke if you know what other languages have to offer.
For me I'd love to see a tool as good as `ng` for typescript projects. When building node apps or small cli tools I find there is a lot of additional boilerplate to set up, especially if you plan to publish. The additional schematics at https://nx.dev/ show how this type of tool could make it easier to set up specific boilerplates (such as express or hapi starters) or set up ready to publish a library.
This looks extremely useful!
This is a terrible habit to get in to. Here `test` is not actually a `Test` and would fail an `instanceof` check. Don't use a class as an interface. Use an actual interface if that's the behavior you need.
This might sound dumb but I put in one file exactly as much stuff as I want to see at one time. Sometimes that might be all interfaces, but in a 100kloc codebase it definitely won't be.
How is that related to TypeScript?
Did you have any answer or did you just come on here to tell me I‚Äôm wrong with nothing to support that claim?
Cool. How about supporting Firebase cloud functions too!
Kinda wish Deno to grow up and replace Node. Looks really awesome.
I think it does work on Firebase cloud functions as well! Did you run into any issues? Happy to patch if it doesn't for any reasons.
Have been watching deno keenly. Hoping to have the ability to essentially drop my existing node+ts projects into deno and never look back. Seems a while away before we get test runners and things like that working though.
 &gt; I don't understand what is the benefit of having namespace Button, and const Button within a same file? Because the props for the button and the button belong together. They're always used together, and only together. Why do you want to split that up? Just makes things more difficult. &gt; Why don't we name have different name for them? Sure, you could. And then you wouldn't use a namespace. It's a stylistic preference. With this way every props interface is always called `PropsType` and is always accessible via the component name. It's clear that `Button.PropsType` is the props type for `Button`. &gt; When we do "export default Button", whether it is exporting "const Button", or "namespace Button"? Why? Both.
Both libraries don't make use of the `strict` compiler flag. Why? Presumably you use TypeScript for type safety, but then you don't make use of TypeScripts type safety features. Also both your packages.config lack a link to the repository, so there's no link to the repository on your npmjs site.
Really don't appreciate this idea of conflating "what is my dependency" with "how do I get my dependency"
&gt; A lot of people, especially people coming from traditional OO languages like Java or *SmallTalk* I had to stop reading there from laughter. What the fuck SmallTalk?
Restricting file and network permissions makes sense, but it would have made more sense to let you do it on a per-module basis. The second one module needs network access _all_ modules will have network access.
Using `&lt;const&gt;` is discouraged due to the syntax conflict in tsx files. `as const` is preferred.
Managed to fix this myself by change the type var to a const of type StyledComponentsClass rather than a function type.
why the downvotes?
Good point! Updated the post! Thanks!
Closer, sure I suppose. The gap is still pretty large as far as feature set and "gains" (depending on your perspective) of typescript. I don't believe it will likely ever be a goal of javascript to make typescript obsolete with how the current javascript ecosystem is pretty split on whether it believes typescript is a net benefit or burden. What I do think would be interesting would be native support for typescript within the various js interpreters (v8, jscore, etc).
Nah. The type system that TS provides is still hugely useful.
I don't believe it will since event if typing gets standardized as a part of ES the standard will get outdated soon. Look how rapidly these days TypeScript gets evolved.
I don't think JavaScript is ever going to be getting explicit typings, which is why people use TypeScript. Babel has allowed for class syntax and polyfillable methods long before ESNext hits the market. People use TypeScript for the strict typing.
Deno doesn‚Äôt prevent a central repository of modules- it merely enables either model to exist while solving some of the big node_modules problems.
Time for the community to jump in and provide those? üòÄ
Didn't ts come out after ES6?
"Still" - "Will ever be" A but contradictory, isn't it?
The primary feature of typescript is static typing. Javascript/ES will never support static typing.
Yep I'm already working on a babel plugin to migrate my Typescript code back to javascript.
Typescript already made something for that. If you write tsc, then TypeScript will transpile your code into JavaScript
Wow, future proof!
If JavaScript ever gains strong typing, then yeah that could spell the end for TS. But is that a bad thing?
Check out "composite" projects. Basically you describe different parts of your project with different tsconfig files. The most common example I see is describing your source code and your tests via 2 different tsconfig files. It's easiest if your source is in a src directory and tests are in a test directory, and you put a tsconfig in the root of each directory. You can even create a 3rd tsconfig that joins the other 2 into a "composite" project, but it's not necessary. This is useful for other reasons. For example, maybe you want to set your tests to noEmit. Or allow more language features in tests than you do in your source code.
never. even when JavaScript will have all the features of TypeScript, it will be around just for its ‚Äûcompiler as a service‚Äú kind of way.
The `Optional` interface in Java was created as a workaround to Java's poor type system when it comes to `null`. TypeScript has much better type checking compared to Java which allows you to write code like: `const str: string|null = ...;` So it would be bad practice to use this TypeScript version of Optional.
[Union type](https://www.typescriptlang.org/docs/handbook/advanced-types.html), maybe? ``` /** * Takes a string and adds "padding" to the left. * If 'padding' is a string, then 'padding' is appended to the left side. * If 'padding' is a number, then that number of spaces is added to the left side. */ function padLeft(value: string, padding: string | number) { // ... } ```
You will probably want to use a tagged union type. interface A { kind: 'A', otherStuff: ... } interface B { kind: 'B', otherStuff: ... } function doStuff(item: A | B) { if (item.kind === 'A'){ // compiler knows it's an A } else { // compiler knows it's a B } } You need the kind literal because typescript has no runtime type support.
|
In case someone needs this as an Either: https://gist.github.com/burtonator/a204b5e34c64bdfc7f881d304dcf10ba
Haven‚Äôt tried but will!
This worked, thanks a ton!
The type declarations should declare a global `transpose` so there's no need to import anything. Depends on the declarations, and you'll need to make sure you load the declaration somehow.
This is and can be very good, but I need to have the ability to add types based on file extension (\`\*.browser.test.ts\` vs \`\*.server.test.ts\` and \`\*.test.ts\`) &amp;#x200B; Now I see that [there's an open issue on the TypeScript repo](https://github.com/Microsoft/TypeScript/issues/21951) about it
This claims that List is covariant, but (using their example) you can produce a program that fails at runtime: https://www.typescriptlang.org/play/#src=type%20List%3CT%3E%20%3D%20T%5B%5D%3B%0D%0Aclass%20Animal%20%7B%20eat()%20%7B%20%7D%20%7D%0D%0Aclass%20Cat%20extends%20Animal%20%7B%0D%0A%20%20meow()%20%7B%20%7D%0D%0A%7D%0D%0Aclass%20Dog%20extends%20Animal%20%7B%0D%0A%20%20bark()%20%7B%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20listOfAnimals%3A%20List%3CAnimal%3E%20%3D%20%5B%5D%0D%0Aconst%20listOfCats%3A%20List%3CCat%3E%20%3D%20%5B%5D%0D%0A%2F%2F%20validate%20assignment%20to%20different%20complex%20types%0D%0Aconst%20expectListOfAnimals%3A%20List%3CAnimal%3E%20%3D%20listOfCats%3B%20%20%20%20%2F%2F%20OK%0D%0A%0D%0AexpectListOfAnimals.push(new%20Dog())%3B%0D%0AlistOfCats%5B0%5D.meow()%3B The solution to this problem in other languages is to make list invariant.
It sounds like you're saying the claim is wrong which it is not. What you probably meant to say was that List being covariant is problematic with which I would agree in JS. The problem at runtime is that push mutates the original array. By using push you're changing the type of listOfCats but TypeScript doesn't know about this and lets your code pass. What your example better illustrates is why array (or rather object) mutation is problematic because it can change the underlying assumptions about it. Local mutations are not that problematic since it's easier to spot what the issue is. Doing this across callsites however can be a pain to debug.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javascript] [Tridi - simple 360¬∞ product viewer](https://www.reddit.com/r/javascript/comments/bc13b7/tridi_simple_360_product_viewer/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
In your TypeScript code you can "declare" global variables that are coming from JavaScript code, so that TypeScript will know they exist and can type them correctly. See here: [https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html) You can also separate these declarations into separate .d.ts files and use reference comments to include them into your TypeScript code: [https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)
You're welcome! :)
I'm curious what people's experiences have been with this site (or similar sites). It looks like a great way to jump into open source and make a little extra cash.
&gt; So it would be bad practice to use this TypeScript version of Optional. Depends on the usage. Them more tools you have the more choices you have...
tsconfig supports globs; have you tried putting those globs into 2 different tsconfigs' "include" arrays?
If you are using VS Code Insiders, you will be prone to errors as you are an opt-in beta tester. Try downgrading to regular VS Code. If you are using regular VS Code, try upgrading to VS Code Insiders in hopes that a fix has already been implemented. I use Insiders, and I haven't noticed this issue.
I've noticed that vsc is slower but nothing else. Nothing close to the issues you're reporting.
I noticed this earlier today. Everything was running much more slower, i.e. the linting check with the red underlines would take ages to disappear after I'd written code. Checked Task Manager and VS Code was using around 1.4GB of RAM. Just so you know you aren't alone OP.
Just curious, are you using styled-components in the project you noticed this in? Before I updated `@types/styled-components`, this issue was 100x worse (basically no TS support at all). I'm wondering if styled-components uses types that just bog down TSC.
[https://github.com/Microsoft/TypeScript/issues/30663](https://github.com/Microsoft/TypeScript/issues/30663) I upgraded to the nightly build and it solved for me, downgrading is also a viable solution. Looks like unfortunately the fix will no be shipped as 3.4.x, we will have to wait 3.5
The latest version of VS Code shipped with TypeScript 3.4.1 which changes some things and certain @types are causing TSServer to lag greatly. Here is what I did to fix the issue:
Solution? Disable all of your extensions, there's likely something that's incompatible with the new version of code. Enable them one by one until you find the culprit. Otherwise, uninstall and reinstall your last known good version.
These are the two things I tried first. Also tried the insider build.
If reinstalling your previous version didn't help you have to start looking at your system.
Oh I didn't try going back to the last version. Just disabled all extensions and reinstalled the latest version. Is there another downloads page that has old versions? [This page](https://code.visualstudio.com/Download) seems to only include the latest and insider builds. Do I have to clone and build myself to get an older version?
Likewise it should be noted that TypeScirpt v3.4.2 updated an issue with how TSServer provides responses to `configurePlugin` requests, which editors like Visual Studio use via IntelliCode. So it's kinda is a couple things around the v3.4 release that started causing issues.
I just upgraded my virtual memory, which I never had to use before. It does seem that something in VSCode is eating a lot of RAM.
I've double-checked just now and it seems to be an issue with the Vetur extension, at least for myself. I only encounter this issue when working in .vue files, everything is ok when in .ts files. [Screenshot of my issue](https://i.imgur.com/ABGcDlE.png) -- note how the error doesn't recognise the entire string (it takes many seconds to recognise it all). It slows down the whole application and makes the laptop's fans spin like crazy. Plus the RAM issue which is constant. This has only started happening ever since I installed the latest VS Code update, but it may well be an issue with the Vetur extension. I'll file an issue with Vetur tomorrow, before anyone asks. It's either that or VS Code, but considering how you and others have been reporting issues in this thread it is probably the latter.
Downgrade to 1.32.3 until an update is released to address it.
Is there an officially supported way to do this? I can't find old version download links on the official site. Do I have to clone/build?
I'm not sure what the process is like for Windows, but you can view the Feb update page here: https://code.visualstudio.com/updates/v1_32 For Mac, all you need to do is unzip the application and put it into your Applications folder. Make sure you disable auto updates before you do this in your settings or else it'll attempt to update immediately after opening (and *will* update once you close it)
Oh didn't think to check the release pages. I'm on a Mac, so this works perfectly. Thanks!
I thought it was just my computer or the new webstorm version just released but I noticed a pretty big slowdown with the typescript compiler recently. This might explain it, thanks for sharing.
Why not just `ComponentProps&lt;Button&gt;`?
For what it‚Äôs worth, a new build of VSCode went live just this afternoon, where the TS version was bumped, and I believe _both_ TS and VSCode got updated to fix this specific issue. Someone correct me if I‚Äôm wrong, but it should be fixed in the latest public VSCode version (released 4/11)
I thought it was just my 2015 macbook
For me it's the extension host crashing for the 5th or 6th time. Tends to be when I do things with git. I've even gone back to trying Webstorm to see what it's like.
Change your workspace TypeScript version to 3.3.
It's reddit, they'll down vote anyone saying something they couldn't think of themselves ;)
Correct. VSCode v1.33.1 now ships with TypeScript v3.4.3, which does address one of the main causes.
Don't use TypeScript 3.4 in your projects and set the local workspace TypeScript version explicit to 3.3. They shipped the latest VSCode version despite knowing of open issues that cause massive slowdowns.
This is wrong. The issue lies with the updated TypeScript version.
It appears the author, a self-described ‚ÄúBlockchain Tsar &amp; JavaScript Practitioner‚Äù, does not understand what static typing does.
I'd take a look at opaque types. They can do what you're describing.
It looks to me that the author had a goal to spread a rant for unknown reasons and worked towards baking it up with some arguments but ended up with listing just silly arguments. I guess after a while we will see "I Was Wrong About TypeScript"-like article from the same author as there will be a need to update the blog with a new post.
Excellent, my searching for "Custom number types" wasn't helping at all. I gave it a go following [this](https://codemix.com/opaque-types-in-javascript/) and whilst not quite as seamless (in Typescript) as I'd hope for it seems to be doing the job. Thank you!
Reposting your blog won't make it any better: https://old.reddit.com/r/typescript/comments/bbiykr/dont_do_this_part_one_objects_and_their_misuse/
Why do you not just use git? What you seem to be describing is essentially just doing development with someone else while keeping track of the changes. Seems like the interface could just be in a file in your project.
You can fake it in TypeScript but you almost certainly don't want to - TypeScript is based on structural typing and you shouldn't fight it. Add some sort of discriminant property like { type: 'ms', value: 1000 }
Isn't it a little late for April fools?
I could do that. This was mostly for additional types when consuming an API. So I wanted to keep track of the types without necessarily changing them.
I've run into the same problem before and I came to the conclusion that wrapping is safer and more semantic typescript.
Across packages
Either consider adopting a mono-repo approach (with multiple packages), or automatically deploy your types as a npm package.
I've used [newtype-ts](https://github.com/gcanti/newtype-ts) with good results. It allows having strong opaque types in TS, but without having the wrapper overhead in the compiled JS at runtime - it's all at compile time.
Why not convert the images to a video file and seek to the frames?
Fair enough, thinking about it some more I might go with this approach assuming it won't take too long to make the change. The idea of making more generic time durations and then not having to care about what the API units are would be nice.
That looks pretty neat!
&gt;Es6 brought Javascript closer to typescript. That's not quite accurate. TypeScript is the one closely shadowing developments in JS and just adds types to whatever's the JS standard.
&gt;If JavaScript ever gains strong typing, then yeah that could spell the end for TS. I'd say that if JS ever gains strong typing, it effectively *becomes* TS.
What if you have a dedicated repo just for types?
I like to do this: `type MilliSeconds = number&amp;{_: "milliseconds"};`
How do i deploy types as an npm package? I want to make a package thats basically only types that team members can import and keep up to date to ensure their services use the same definitions as the rest of the ecosystem.
I believe it would be beneficial for the whole ecosystem if the amount of packages got reduced. Shit like https://www.npmjs.com/package/ansi-cyan is really not needed.
Never understood stuff like this. Modules that barely do anything at all
"Hey, look at me, I'm important and a great open source contributor! I've released 26 npm packages!"
if you wanna type a function you do it like this: function foo(arg: string): string { // function code here } if you're using arrow functions you can do this: const hello = (arg: string): string =&gt; { // function code here } I'm not quite sure if that's what you're asking so please clarify if I'm wrong.
I‚Äôd love to see how DDD concepts translate into a frontend project from a practical perspective. Say an app using React/Redux/Redux-Saga. How would you structure your project?
&gt; but is this normal on regular projects? Just pointing out that Nextjs is already quite a large heavy fat framework.
Hot take: 9 times out of 10, a person who complains about TypeScript not letting them write the code they want was writing unreadable code in the first place. It is by far the most lenient type-checker in the world.
I really enjoy the site, but the dead-end links are very frustrating/annoying. Like congrats on your clever way of bootstrapping user data, but ultimately it means I can't rely on your site as a reference, and stopped clicking links because I don't trust them.
What you're trying to do is totally possible with NPM! (though a Git repo or a Git submodule is also a valid choice depending on your situation) It actually sounds like you're pretty close to having things working since you mentioned an existing NPM package, so I thought maybe seeing a barebones example might help explain better than anything else. I've created two repos: * An NPM package that publishes an interface - [https://github.com/tylerc/ts-interfaces-publish-test](https://github.com/tylerc/ts-interfaces-publish-test) [https://www.npmjs.com/package/ts-interfaces-publish-test](https://www.npmjs.com/package/ts-interfaces-publish-test) * A tiny repo with a tiny script that uses that NPM package - [https://github.com/tylerc/ts-interfaces-import-test](https://github.com/tylerc/ts-interfaces-import-test) Some points of interest: * Since we're only publishing interfaces, I'm using `.d.ts` files. * For the NPM package I specified `index.d.ts` as the `main` since all I cared about was publishing types. * If you need to publish common runnable code as well (not just types), TypeScript recommends you specify `main` in `package.json` as the compiled `.js` file (so consumers of your NPM package don't have to compile the package themselves), and specify a `types` field in `package.json` that points to a `.d.ts` file. You can use the `--declaration` compiler flag to generate `.d.ts` files from your TypeScript code. See this TypeScript handbook article: [https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html) The code itself is super simple, in `index.d.ts` I export an interface: export interface MyTestInterface { foo: string; bar: number; baz: any[]; } And after doing `npm install --save ts-interfaces-publish-test` in my other repo, I wrote this code: import * as interfaces from "ts-interfaces-publish-test"; let x: interfaces.MyTestInterface = { foo: "test string", bar: 42, baz: [] }; And everything works as expected! TypeScript gives me all the proper errors on `x` if I get the types wrong, I can easily use NPM to update to future package versions, etc. I hope that helps!
Where is the `E` type defined and what is the `I` type?
For first, you didn't define where E is supposed to come from. interface Foobar&lt;T extends new () =&gt; any, I = InstanceType&lt;T&gt;&gt; { type: T; props: { [k in keyof E]: E[k] }; } Then, no, props: `{} // this should error` is correct. Given your rule `props: { [k in keyof E]: E[k] }`, an empty object is fine because it has no types to begin with.
Ops. I is supposed to be E
That was a typo. The E in props should be I. &amp;#x200B; I have edited my post.
Wow. I thought I basically understood typescript types. But I've never heard of `InstanceType&lt;&gt;`, and after reading everything about it I can find, I still don't think I really understand it at all. Needless to say, I don't have a solution for your problem.
This reminds me of nestjs.
There is also `ClassType&lt;T&gt;`. Might be useful in OP‚Äôs case.
Try to learn them as you need them, not by reading the definition file first and using them second. `Component` is generic for `Component&lt;P, S&gt;` where `P` is the shape of the props and `S` is the shape of the state. `ComponentClass&lt;P, S&gt;` is your class itself, such as if you were to pass it to a HOC. `render()` and functional components return `JSX.Element`. What else do you need to know?
O, my sweet summer child.
The idea makes sense though. I‚Äôm not a fanboy for the ecosystem, but small, dedicated packages do make sense in certain situations. Here, maybe not so much, but for things like lodash, date-fns, moment, they do make sense to modulerize from time to time.
[https://github.com/sw-yx/react-typescript-cheatsheet](https://github.com/sw-yx/react-typescript-cheatsheet)
You at least need a type annotation on the array: const foobars: Foobar&lt;typeof SomeClass&gt;[] = [ { type: SomeClass, props: {} // this should error }, { type: SomeClass, props: { num: 3 } // ok } ];
There is no ClassType&lt;T&gt; in typescript@3.4.3?
But what if i want to add another class in addition to SomeClass Ex: class SomeOtherClass { str: string } const foobars: Foobar&lt;/* what to put here */&gt; { // or is there some other solution? { type: SomeClass, props: { num: 3 } }, { type: SomeOtherClass, props: { str: "banana" } } }
I'm pretty sure you cannot express those kind of constraints in TypeScript as you need existential types.
Is this part of a codebase you're working on, or are you just studying it? FYI there are more ways to use both React and TypeScript. e.g. when I use React + TS I do something like: export const MyButton = ({label, onClick}: {label: string, onClick?: () =&gt; void}) =&gt; { return &lt;BaseButton ... /&gt;; } Or I could extract the definition to make things cleaner: type Props = { label: string onClick?: () =&gt; void } export const MyButton = ({label, onClick}: Props) =&gt; { return &lt;BaseButton ... /&gt;; }
You want an Object called helloWorld? &amp;#x200B; Define a class like this: export class Printer { public foo(s: string) { console.log(s); } } Then create an instance of that class and call instance.foo("bar");
Maybe this is obvious to you, but as someone just starting TS, it‚Äôs not obvious. There is a chicken and egg scenario with TS in general, that beyond the default types (which I am comfortable with) you don‚Äôt know WTF you should use or even can use for what else, outside reading the definition code, which is kind of a huge pain in the ass when you‚Äôre not really sure WTF you‚Äôre reading when you just start off with TS. If there‚Äôs a better way, I‚Äôm all ears, I‚Äôm sorry but your comment is not helpful at all, in fact it‚Äôs just more confusing as I don‚Äôt know WTF you mean about shape. The problem is that it seems a lot of people have figured TS out just fine, and for the basics so have I, but picking up custom types seems like a non-starter if there‚Äôs no documentation. If the only answer is go read the type definition file, then fuck TypeScript as that‚Äôs no way to learn. I don‚Äôt think this is the case, but a lot of answers in this subreddit seem to think that‚Äôs an ok way to tell people to learn.
Thanks man! This is actually a huge help. I‚Äôm can‚Äôt believe I didn‚Äôt find this in all my Googling. Much appreciated! Any other helpful suggestions like this would be welcome.
I understood his comment just fine - do you know what generics are, and how to use them? If not, I can totally see why this would be confusing.
You sound a bit mad for not much over here. Id suggest you learn about Typescript and it's type system beforehand if you have trouble understanding how to use it with React. Because it really isn't more complex than `PropTypes`
I understand them from the perspective of how to create them and how they are explained on the TS docs. I‚Äôm not saying his comment is wrong. I‚Äôm saying that just telling me to use those without understanding why I might or how I would determine that on my own (like through actual documentation) isn‚Äôt helpful.
I understand the basics of TS. And I‚Äôm sorry but TS =/= PropTypes: https://www.reddit.com/r/reactjs/comments/8zzb4p/why_do_you_use_typescript_if_proptypes_is/ What I‚Äôm asking for (and stay with me here because I actually asked this in the OP) is for HELP on WHERE I can LEARN about WHAT THE TYPE DEFINITIONS ARE via sources you might recommend other than the type definition files. His comment is barely more useful than a Types definition file...which...as I stated already...is no help if you don‚Äôt already know what it means. I‚Äôve been writing JS apps in Node and React for over 5 years. I‚Äôm simply struggling to find a good learning resource for third-party types or a good approach to doing so.
Never said `PropTypes` == `TS types`. I meant typing your components with `Component&lt;P, S&gt;` is pretty much harder than transfering `PropTypes` to Typescript's types. No need to get all angry. Again, stay with me here. You don't see to understand Typescript then. Once you understand it, Type definition files will make all of it sense. It's no voodoo Magic, everything is explained on Typescript's website. But here's (one link on how it works) some doc on how those type declarations work. http://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#organizing-types
Just use the libraries as you would use them in JS. Might be an unpopular opinion, but if you are very new to TS leave "strict" mode turned off and just adopt use / pick up types where you think it will help you. Don't force yourself to type every single thing from day 1.
You can use exactly the same mechanism you're using to share other Typescript packages on npm. So if you're getting errors on import statements, you must be doing something different here. It already works for your other packages, right? So why not here? You must be changing something that's breaking it.
When I'm using a new package with its type definitions and I don't know them, I generally don't read the definitions by themselves. I start using the package and then you can do for example: const foo = package.methodFromPackage() Just omit the type for `foo`. In VS Code (and I assume in most of the other IDEs, too), you can then hover over `foo` and it tells you the type that is assigned implicitly. Then I take a quick peek at that type, and actually assign it to `foo`. This way I'm only looking at the types that I need right now.
I suspect the issue is i put the entry point as index.js not index.d.ts
&gt;There is a chicken and egg scenario with TS in general, that beyond the default types (which I am comfortable with) you don‚Äôt know WTF you should use or even can use for what else, outside reading the definition code, which is kind of a huge pain in the ass when you‚Äôre not really sure WTF you‚Äôre reading when you just start off with TS. The thing that "comes first" in TypeScript is the JavaScript. React exists outside of TypeScript. It does not need TypeScript to have a type or to execute. The TypeScript definitions comes _after_ to define what already exists as JavaScript. The TypeScript types define what already exist. You should be using React without TypeScript and only afterward adding types to verify that your use of React is correct. When you say "this is a Component," TypeScript will tell you if you are correct or not. When you later refactor your code and "this is no longer a Component," TypeScript will correct you -- "You said this was a Component before, but it isn't anymore. Did you mean to change this to something other than Component? Or did you mean to make this something else?" &gt; I‚Äôm sorry but your comment is not helpful at all, in fact it‚Äôs just more confusing as I don‚Äôt know WTF you mean about shape. Shape is not a React word. It is a TypeScript word in a nutshell referring to [interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html). interface Props { x: boolean; } class MyComponent extends React.Component&lt;Props&gt; { render() { return &lt;p&gt;x is {this.props.x ? 'true' : 'false'}&lt;/p&gt;; } } Now whenever I reference `this.props`, it knows that it has the shape `Props`, so it has a key `x` that has a boolean value. &gt;The problem is that it seems a lot of people have figured TS out just fine, and for the basics so have I, but picking up custom types seems like a non-starter if there‚Äôs no documentation. You use it like you would JavaScript, and intellisense typically tells you what you need to know. In JS, I would extend `React.Component`. Now when I do the same thing in TypeScript, intellisense asks me what the shape of the props and state are. If I do not know what that means, I can ctrl-click or otherwise read that specific definition (as opposed to the entire definition file) to see what it wants. When you read the TS definition for Component to figure out what generics it wants, you can see that it thinks `P` means the shape of `props`, `S` means the shape of `state`, etc. I know what props and state are, because I learned React as a JavaScript framework first.
Oh yeah! If it's index then you can omit the "main" property because index is the default. Or you can specify both a "main" and a "types" property in your package.json. One is for runtime js; the other is for types.
&gt; Maybe this is obvious to you, but as someone just starting TS, it‚Äôs not obvious... There is a chicken and egg scenario with TS in general It's not obvious to you, and that's fine, but that doesn't mean it's not clear to somebody else starting Typescript. I learned Typescript and React at the same time and it all clicked fairly easily for me. It's okay if it doesn't for you. We all struggle and excel at different things.
Good call. I will definitely try that. Thanks for the advice!
Thank you, this is a great explanation. I appreciate the in-depth example. I use React a lot already, just so we are clear. I think the issue I‚Äôm having is the learning and documentation approach with TS is a bit odd to what I‚Äôm used to. If I fully understand you you‚Äôre saying that I should be writing my basic JS out entirely, say defining a whole component and methods and later add types rather than write it up front. I still need to work on my usage if intellisense. While I use it to shortcut my typing out of common things in different libs and vanilla JS, I don‚Äôt rely on it at all. Seems like to use TS effectively I really need to change that behavior. I tend to refer to the docs for API definitions and usage, which I grasp well in JS, and then I usually memorize their usage after a few repeat references. This is why don‚Äôt pay a lot of attention to intellisense.
Will it still work if i dont have a runtime? Ie my index.js is empty? I just have types?
yes
3.4.2 isn't related to the perf issue. It enables VS to use IntelliCode.
Typescript becomes hugely powerful once you have set up all types in your project. It's a lovely feeling when you add a required property to an interface and you immediately see all places that use it and can just browse through them and add what's needed. Also whenever you use an interface it makes sure you don't forget anything that's required and suggests available properties. It takes time to get there but once you do you don't want to have missing definitions anywhere. Or at least that's my experience.
I am looking forward to that moment ;).
This does it. type fctor = new () =&gt; any; interface Foobar&lt;T extends fctor, I = InstanceType&lt;T&gt;&gt; { type: T; props: { [k in keyof I]: I[k] }; } class Person { name: string; } type PersonCtor = Person &amp; fctor; const x = new Person(); const fooBars: Foobar&lt;PersonCtor, Person&gt;[] = [ { type: Person, props: {name: 'frank'} }, { type: Person, props: {} } ];
Oh great point! Enabling now. And fixing the npmjs to link to GitHub. Thanks for the feedback!
Those are basic React components / methods. Maybe you should pick that up before you embarrass yourself.
You start with the types everyone is used to: * `string` * `number` * `boolean` * etc. Ok so those are pretty useful! But what if you have more complicated things? Imagine a timer function that takes two parameters: * a `number` that represents the number of seconds that have passed since the timer startes * a `string` for a separator character to put between minutes and seconds. It would look something like this: function makeTimer (seconds: number, separatorCharacter: string) =&gt; {... //timer code}` But maybe we want to pass in an arguments object that looks like this: `{ seconds: 34, separator: ":"} ` Well if we're gonna use that same format over and over again, then we can define an interface: interface TimerOptions { seconds: number; separatorCharacter: string; } Now `TimerOptions` is a new custom "type" we can use it the same way that we used `string`, `boolean`, etc. So then instead we can define our timer like: function makeTimer (options: TimerOptions) =&gt; {... //timer code}` And it will know that options is an object with two keys, one of which is a `number` called `seconds` and the other is a `string` called `separatorCharacter`. Becomes really helpful when you start passing data around from one place to another. Lets say I have a function somewhere else in my program called `MakeTimerOptions`. I want it to check the location and change the separatorCharacter depending on what country I'm in. I know that I want it to take in a `string` of the country name, and to return a TimerOptions object that will work with my timer function. function MakeTimerOptions (country: string): TimerOptions { ... return { seconds: 30, separatorCharacter: ":" } } Because I've specified that the function should return a TimerOptions-type object, if I forget to include one of the keys, typescript will throw an error. This is GREAT for a couple reasons: 1) If I forget to include one of the keys, I find out right away, before I even try running the program. It makes it a lot harder to write code that doesn't work. 2) Lets say I decide to change the timer so it can be stopped and started. Easy enough, I just add a boolean to the interface definition: interface TimerOptions { seconds: number; separatorCharacter: string; running: boolean; } instantly, every place in the entire project that uses a TimerOptions object will throw an error. I can go to each place and add code to deal with the new key, and it forces me to make sure that none of those changes break anything else. 3) When I am writing code in another part of the program, and I want to use my makeTimer function, my IDE will pop-up a tool tip showing that makeTimer takes a TimerOptions object, and that that object takes three keys with their names and types. You don't need to look at the type definitions for react to use react. You really don't -- and actually shouldn't. It's kind of a waste of time. What you should do is think about the types that your code uses. What is it that you want this particular function to return? What types are the parameters? Whenever you define a function, specify the inputs and outputs. If there is something you use all the time, consider making an interface for it. Like maybe you're making a library catalogue so you create a `Book` interface and an `Author` interface: interface Book { title: string; author: Author; ISBN: number; pages: number; averageReview: number; } interface Author { name: string; dateOfBirth: Date; books: Array&lt;Book&gt;; } Notice `Array&lt;Book&gt;` there at the bottom -- that's an interesting one. An array is a "generic" type, because it can hold all sorts of things. You can have an array of numbers, or an array of strings. When you say `Array&lt;Book&gt;` you're telling the compiler that this array will only ever hold books. So if you try and put something else in there it will throw an error. So you can start to nest types inside of each other. Especially when you start to learn about how types can extend each other. So I can have an `Animal` type, and then I can extend it to create a `Snake` type and a `Panda` type, and in my zoo records program I can put: interface BreedingPair { maleAnimal: Animal; femaleAnimal: Animal; } And I can slot either type in there: let snakeMatingPair: BreedingPair = { maleAnimal: new Snake("Mr. Snake"), femaleAnimal: new Snake("Mrs. Snake") } let pandaMatingPair: BreedingPair = { maleAnimal: new Snake("Ping"), femaleAnimal: new Snake("Lulu") } Well lets say later I try and do something dumb like pandaMatingPair[maleAnimal] = new Book("Tale of Two Cities", "Charles Dickens") Then the compiler will say "pandaMatingPair.maleAnimal needs to be an Animal, not a Book. This is REALLY helpful when you work on code for a long time. It takes a little more work up front, but it will GREATLY reduce the amount of time you spend chasing down bugs. So don't worry about reading type definitions. You won't need them. Just figure out what types YOU need for your code. Make sure every function has specified inputs and outputs and you will be golden. Hope that helps.
&gt; Shape is not a react word I‚Äôm sure it didn‚Äôt originate with them, but PropTypes actually uses ‚ÄúshapeOf‚Äù as one of its validations.
Neat. There‚Äôs a typo in the definition of hyper. It says hyper(i,a,1) = recursive definition, but it should be b not 1
Great answer. I applied some of the other suggestions yesterday and I‚Äôll use this one as a guide today. Very much appreciated!!
How about you go fuck yourself? The components and methods part of the answer is clearly not what I was addressing; the TS was what I was unclear on. WTF is with the hostility in this community? Do you think you have some superiority for having learned this without asking any questions? Or maybe because right now, you know it better than me? As though simply knowing before someone else should be awarded? If you don‚Äôt have anything useful to contribute, then fuck off.
Also I‚Äôm curious if there are any practical applications for these?
I know it may look like it from my example. But I have a lot of classes and none of them inherit/extend a common ‚Äúancestor‚Äù. Doing type Classes = SomeClass | OtherClass | ... ; Is exactly what i am trying to avoid.
I feel like this will be huge for react redux. I always had such a hassle trying to make all the types work out with connect.
I don't think it's possible. At some point, to enforce the type safety, you'll either need intersection types or an inheritance chain. What problem are you trying to solve?
A generic way of seeding a database with typeorm entities. I'd like to put the "seed definitions" in an array like mye example. But from the comments here it seems i've gotta look for some other solution, or just ignore the fact that it can't be typed properly as of now.
People still start new projects with AngularJS? Why? It's a dead framework.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/deno] [Build an app using Deno and Drash](https://www.reddit.com/r/Deno/comments/bcqxx9/build_an_app_using_deno_and_drash/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Sounds like that person does not know much about typescript and how it u uses interfaces. Just because it's called an interface, doesn't make it the same thing as a Java interface. Sounds like you dodged a bullet to be honest.
This might be true. However, it is still used for some applications, such as ServiceNow. Which will be eventually phased into something else, probably the latest version of Angular or React
Why not use a flask server?
I typically don‚Äôt see or recommend people starting new projects with AngularJS. However there are still 1000‚Äôs of large enterprise apps written in it. In order to migrate to modern Angular or React I always recommend getting the app up to the latest version of AngularJS, convert to TypeScript, and adopt a modern build pipeline such as Webpack. This makes the eventual migration much easier
I didn‚Äôt even know typescript + flask was a thing.
Well Dash is natively supposed to be deployed on a Flask server
Interfaces aren't bad. I would've asked him why he said that. Either he's down on interfaces (unlikely) or he's down on Typescript (I suspect this). Either way he's going to have to argue against many years of software engineering for (a) or for (for starters) explain why all those clever people at Google are so wrong about Typescript (re. Angular). Doesn't sound like he'd be a good mentor either way.
LMAO
That senior engineer was at best being elitist about something he didn't understand. Don't feel too bad about it - you didn't do anything wrong, you just got a bad interviewer, it happens. Next time if you're feeling bold press him on why he thinks TS interfaces are bad. That gives you an opportunity to defend yourself.
They don‚Äôt know what they‚Äôre talking about as evidenced by the ‚Äútypescript has interfaces now‚Äù line. Sounds like you got one of those interviewers more interested in feeding their ego than actually evaluating candidates. It happens, it‚Äôs not your fault.
&gt; Just because it's called an interface, doesn't make it the same thing as a Java interface. Is it a bad idea to use TS for such interviews? There's already so many variables in interviews to go wrong that I shouldn't allow the possibility of the interviewer misunderstanding terminology.
&gt; Next time if you're feeling bold press him on why he thinks TS interfaces are bad. That gives you an opportunity to defend yourself. My confidence was wrecked at that point. We were going through my take-home assignment (about 400 LOC) to improve it. There were some flaws in the design, I couldn't understand their guidance and couldn't refactor it to his standard. He could see and explain the flaws for every change that I suggested. So I guess I'm a bad interviewee with a bad interviewer haha. Shit show all around.
You use the language you are most comfertable in and enjoy writing in. Do you see yourself in a shop where you're forced to write in something you dislike?
I'm easy-going with languages - if it's not PHP, it's a good language.
I would guess that he was scoffing at JavaScript, not at interfaces, and his bias was justifiably formed when he was using JavaScript many years ago. In his mind, Typescript is "JavaScript with types", and he isn't aware of recent improvements. I did web app development from 1999 to 2003, and then moved on to other areas. As recently as 2015, when someone asked me about using JavaScript on the backend, I remember scoffing "JavaScript is something you use when it's the only runtime that's available. Anything else is better." Because I was experienced with JavaScript's shortcomings, and the difficulty of maintaining software written in it. Now I am working in web development again, using Typescript on front and backend. ES6 and the continuing language development has really improved the JavaScript language, and just as importantly the tools have improved. We can avoid the bad parts. We have modules! And a linter! And Typescript gives me static typing, and compatibility with old runtimes which don't support the language features I want to use yet.
Weird response, as AFAIK Java uses interfaces almost the same as in TS. (Primarily C# dev myself.) I can't imagine he is against interfaces, they are essential in modern OOP (composition over inheritance). He probably just didn't like TS, maybe because it comes from Microsoft. A small subset of mostly older Java developers *really* hate Microsoft.
That's just because he's a moron. Don't conflate position with ability. Somehow, even in spite of the ridiculous testing and vetting we need to go through, there are a bunch of people that somehow manage to climb the ladder in spite of being complete morons.
&gt;&gt; Just because it's called an interface, doesn't make it the same thing as a Java interface. &gt; &gt;Is it a bad idea to use TS for such interviews? There's already so many variables in interviews that can go wrong, I should remove the possibility that interviewer may misunderstand terminology. No, typescript should be perfectly acceptable. However, when possible use the language that the interviewer prefers. Even if it's not your strongest language.
Don't worry about it, you win some and you lose some (no matter how good you are). You'll always come across people you can never win an argument with no matter whether you're right or not. Challenging his belief structure would've just raised his hackles (I suspect). Just use it as interview practise and work on the things you think you didn't do well at.
TypeScript is very popular in JavaScript roles. Use whatever you are comfortable with.
As a frequent interviewer, I‚Äôm not sure I agree with this one. I ask (and genuinely prefer) candidates use a language they are very comfortable in so I get a clearer signal of their overall skill. If I were interviewing somewhere that someone pulled petty language bigotry out in front of me, I wouldn‚Äôt consider that a failure on *my* part. I‚Äôd just go to a company that didn‚Äôt have jerks out front and center.
Yes, globs work. But I want something like eslint‚Äôs overrides: that specific globs will include a typedef (and not including a glob of typedefs): `*.browser.test.ts` to include `browser-types.d.ts` and `*.server.test.ts` will include `server-types.d.ts`
&gt; My confidence was wrecked at that point. That's a point to work on. Why was it wrecked? Could you, right now, outside of the pressure of an interview, explain your reasoning for using an interface? Like, I think you should actually try this. Open up an editor and write it down. Why are you using one? What purpose does it serve? Are there other ways to achieve your purpose? What are the trade offs? In which situations might you choose to go a different route? No offense, but my guess, not knowing you at all so I could be way off, is that you might find you actually do struggle to explain yourself, and don't have clear reasoning. Your confidence being wrecked might be because you did not have reason to be confident, and got called out on it (despite how wrong the other person may have been). If you can, great. Just explain yourself to the interviewer next time. You know you're reasoning. You've thought about it. You understand. If you get called out a bit, and clam up and don't have an answer, of course that comes off poorly. I'm not going to assume you're just nervous. I have to assume you don't actually have a response. Disagreeing, but having a stance, is much better for your interview experiences. Besides, you pretty much already lost the interview at that point. Standing up for you position isn't going to can the deal at that point, and if it's a situation like you describe you might not want to work there ultimately anyway, and then it's just good practice for the next interview.
For someone who's only written a "Hello, World" in Java, can someone ELI5 what's the difference in interfaces?
&gt; complete morons Or perhaps they're really good at plenty of software development, but have a particular bias against JS/TS. One dumb statement doesn't make someone a complete moron.
That is called hubris. The interviewer doesn't know enough to know he doesn't know what he is talking about. First, if you get an interview where you have to do tests to get the job (not take home tests, but tests under duress), you should probably just walk out - unless you badly want this job with this team in particular. They kind of deserve to get the candidate they are sorting for. Remember, you are interviewing them as much as they are interviewing you. To me, they flunked the interview. They did not treat you with respect - in a couple of ways. ========== Interfaces in Typescript are quite different from interfaces in Java, just like prototypal inheritance is fundamentally different from Java's class inheritance. For Javascript inheritance, you really need to go read to go read Getify's books. This will give you a deep understanding of how OO works in Javascript, underneath the es6 syntactical sugar. If you program TS, it will pay off handsomely to know JS very, very well. By the way - JS is different from Java, and Java programmers typically make very bad JS developers because they try to write Java in JS. You can - and often should - do things in JS that Java doesn't even have a concept for. If you want a job in a Java shop, nothing will prepare you for that except practice. And to practice, you need to have a job in a Java shop. Or you need to have a side project that pushes you to use the language. My team has moved from Java to Scala on the JVM, and there is Kotlin. Lots of possibilities there, but Java and company are a beast. You will have to devote considerable effort to get really comfortable.
Well, structural vs nominal typing is kind of a big deal.
The interviewer sounds like an arrogant A-hole who doesn't know how interfaces are used in TS. That's not your fault.
It sounds like you understand more than your interviewer.
Yeah, similar capabilities.. but the difference is primarily in how they're used. In Java your interface is always implemented by a class (because you cannot instantiate it). In Typescript, because of its javascript origins (and as the other commenter said, structural typing), often the interface stands alone to describe the shape of data, and data that conforms to it is produced/consumed without ever having an implementing "class" that corresponds. I go back a and forth with this pattern.. sometimes I just use an interface, sometimes if I have a lot of related functions I will make an implementing class instead or in addition.
The main difference is structural typing in Typescript vs nominal typing in Java. For typescript, something that has the same ‚Äúshape‚Äù as the interface can be used even if it wasn‚Äôt defined as implementing that interface, which is not true in Java.
Please don't put words in my mouth. I never claimed any such thing. It is no secret that there are idiots building software, and while this interviewer may be good at all sorts of things, he is quite obviously still a moron. This is obvious because of how he clearly doesn't understand what an interface is and how he hurtles a derogatory comment at someone he's interviewing for their choice of technology.
Well the interface disappears at compile time so reflection won't work anyway. May be the compiler API would help? https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API
Right, I'm thinking that the multiple tsconfig approach might be a way to accomplish what you want today. Here's what I'm thinking: // tsconfig.server.json { "extends": "tsconfig.base.json", "include": ["test/**/*.server.test.ts"], "files": ["server-types.d.ts"], // etc } // tsconfig.browser.json { "extends": "tsconfig.base.json", "include": ["test/**/*.browser.test.ts"], "files": ["browser-types.d.ts"], // etc } // tsconfig.json { "include": [], "files": [], "references": [ {"path": "tsconfig.server.json"}, {"path": "tsconfig.browser.json"} ], "compilerOptions": { "composite": true } }
I really just need to parse the .ts file directly... Before it's compiled. Then I'm going to use that to generate a new .ts file.
Typescript uses structural typing, so you can write an interface that describes an existing class, without modifying the existing class‚Äôs declaration. In Java, which uses nominal typing, you have to modify the class declaration to say ‚Äúclass A implements InterfaceB‚Äù. Often it‚Äôs not possible to modify the existing class, so something like an adaptor pattern has to be used where another class is written to wrap another and conform to the interface. When you take this to an extreme, a codebase can end up with many useless abstractions, often only used for the purposes of creating mock implementations in tests. Some developers dislike TDD/unit testing because it forces this kind of clutter in your code in languages line Java and C#. Not that I agree with that view.
That's what the compiler api does for you. You give it a ts file, it parses it for you and lets you walk through the ast
Nice... I'll play with that then! Thanks.1
What‚Äôs the end goal? If you‚Äôre trying to turn typescript interfaces into JSON schema that‚Äôs been done a bunch of times.
You can, in fact, do new MyInterface in Java. You are creating an anonymous class though. It was very common for callbacks and event listeners before they added lambdas. But still, only things that say they are the interface are the interface in Java. In typescript, anything that looks like the interface is the interface.
[ts-morph](https://dsherret.github.io/ts-morph/) offers a nice interface to the typescript compiler APIs and easy utilities for generating code.
If the interviewer misunderstands so badly, THEY failed the interview. Remember, an interview goes both ways. You found out it was not the place for you.
There's a certain kind of javascript "purists" out there, that feel that they have built a great relationship with javascript because the language is essentially perfect for them as is. To them, adding explicit types to the mix is just gauche and little more than a crutch when Real JavaScript Coders would simply keep track of what a variable contains the old fashioned way: In their head. They can sometimes be pushed into accepting that adding `: string` after a variable declaration is not completely terrible, but things like type assertions will trigger them as useless crufts that muddy the purity of good JS code. In that line, interfaces are just more of the same. Dozens and dozens of line that compile to nothing, and therefore mean nothing, all the while taking precious editor screen space away from actual honest code. So that's probably what the scoffing was about. It's not you, it's them. On an adjacent path, you will also find people that argue that Typescript makes Javascript look too much like Java, and therefore Typescript coders will be naturally drawn toward writing Java Enterprise^(TM)-style code, ripe with IObserverManagerFactory patterns and generally over-complicating what should have been a small script into a gas factory. That was a more prevalent argument when classes were not generally available in JS yet. Nowadays you could imagine someone writing a beautiful cathedral of JavaScript classes just as well without bringing types into it. I expect that some folks that are primarily Java devs and new to JS may occasionally exhibit those tendencies, but it should be harder to make any of that an argument against Typescript itself (although people still manage to power through it to this day.) Now, one counterpoint to all this: During an interview, time is precious, and I'm vastly more interested in seeing a candidate's ability to solve problems rather than their abilities to write boilerplate. I recently had a candidate that chose to answer my questions in Java, which is fine. I always let them choose their language since I don't want unfamiliarity with a language to come in the way of their performance. However, for a problem that candidates typically solve in one or two functions, they proceeded to spend 80% of their time scaffolding classes, putting getters around everything, and generally making me groan inwardly as I repeatedly tried to prod them to focus on implementing the tree traversal and the 3 goddamn loops the question called for. Perhaps predictably, they didn't get around to finishing the question in time, but at least they did have several pages of beautiful idiomatic Java code to show for it.
Modern Java hasn't required interfaces for mocks for quite a while, mock classes are generated on the fly using things like Mockito, cglib, etc. The same is true for a lot of the transaction wrapping stuff in Spring, etc. So while Java does have and need interfaces, they aren't required for TDD/unit testing. But some developers haven't quite figured this out, and some are still running on old biases.
Considering it was an OOP oriented interview, he may have been thinking of interfaces as a Java interface. I think a TS interface is more analogous to a C struct than a Java interface. &amp;#x200B; After doing both OOP and functional programming professionally for a few years, I probably wouldn't apply to any job that had OOP in the description anyway. So you dodged a bullet there, in my opinion.
You could use git submodules or just have a monorepo for all the code
Thanks for giving solid advice. Not the commenter.
&gt;Typescript has interfaces now &amp;#x200B; I love how this guy is being both elitist and ignorant. TypeScript has literally had interfaces for \*years\*, they're not new to it. &amp;#x200B; My guess is that's not the reason they passed on you, but I'm sorry someone acted like kind of a douche in an interview. I've had some horseshit interviews, it might be a good thing they passed on you.
I'm not sure what a Java person would have against interfaces anyway.
That is certainly one of the more confusing aspects here. Java has tons of interfaces. It's one of the most basic things you can do in Java. Every single Java developer uses interfaces every time they open their editor. I would actually want to meet the dev that doesn't use a List or Map at least once in a day, because I want to know their secret. While typescript interfaces are significantly different from Java interfaces, the fact that a Java dev scoffed at the idea of them is a true wtf moment.
Eh, I think it depends. Using the language they're hiring for shows that you can at least adjust to that language quickly. It may not matter that much to the technical lead in the hiring process, but it's something for the non technical personnel to grab on to. Every once in a while you get a job application where it really doesn't matter. I once submitted solutions to a programming challenge in python, haskell, and rust. (I got the offer, but it required relocating when I couldn't). For other applications, I was sure to use the language they were hiring for. Sometimes they make it clear that they're hiring for good programmers versus good {X language} developers. The latter are obviously worse jobs to aim for, but sometimes you gotta do what you gotta do.
Thanks. I rambled a bit, but I think it's easy to have some intuitive sense of what's good and bad and works well and doesn't - and that can get you pretty far in development - but it's important to develop the ability to be specific and deliberate. You don't need to be terribly specific and deliberate like that with 90% of your day to day, but it's invaluable at times, and is also especially helpful for interview situations.
Thanks! Great advice! I definitely cracked under pressure, but will take your advice to heart going forward.
Thanks for the recommendation on Getify's books! Here's the link everyone: https://github.com/getify/You-Dont-Know-JS
That represents an OOP construct called Generics. &amp;#x200B; Here: [https://www.typescriptlang.org/docs/handbook/generics.html](https://www.typescriptlang.org/docs/handbook/generics.html)
It's not an OOP construct.
Fair enough actually, my bad
I wonder if you know of a way to calculate webpack build time as the codebase grows. I know it‚Äôs off topic but I‚Äôm not ashamed to try to get free advice on this problem that plagues my dev process.
https://webpack.js.org/configuration/stats/
A did find this while Googling: [https://www.npmjs.com/package/speed-measure-webpack-plugin](https://www.npmjs.com/package/speed-measure-webpack-plugin) Additonally Webpack includes some build-analysis tools by default, you can also try them. &amp;#x200B; Although yes, would be helpful to track the build-time. Will likely add this to the configuration.
What about using the constructor function type? const ANIMALS = {[s: string]: new (...args: any[]) =&gt; any} = { fish: Fish, cat: Cat, dog: Dog, };
You are welcome. They are pretty much required reading where I work. :)
its like the typescript handbook is super handy and contains references in a consumable format for all its features O:
Nobody cares about what you look like
Good points all. I agree that if the req is specifically for ‚ÄúPython Developer‚Äù one should probably demo their Python. And someone using a really esoteric language in a coding interview would be offputting.
PHP is a lot better than I expected it to be when I had to work in it. I mean, assuming you're working with something like Symfony and don't have to deal with a lot of legacy junk
I'm surprised to hear that Java people think interfaces are bad now. They're the most natural way to do a bunch fo stuff
Uhh yes.. if you can get something well payed that works in all your first choice techs, more power to you.. but it‚Äôs called a job for a reason. I don‚Äôt think there has ever existed a person who honestly enjoyed C++, but it fits an important niche.
Java interfaces are actually pretty good and well respected abstraction among PL people. So are Java checked exceptions. It‚Äôs widespread use of ‚Äúdowncasting‚Äù that gives Java it‚Äôs bad name, mostly. That, and the insistence of using classes for everything.
I believe it is usually referred to as a "type parameter". And as the other poster mentioned it is used in the context of "generics". Doing some reading on those topics will help you out a lot!
Hahaha that's how I prefer it, certainly :p
I would suggest not typing `ANIMALS` at all and rely on type inference. This way, the inferred type will be { fish: typeof Fish, dog: typeof Dog, ... } Note that if you want to access these values dynamically, you'll need to verify that your key indeed exists in this object. The cleanest way is to use a type guard, something like `isAnimalClassName(s: string): s is keyof typeof ANIMALS`.
A lot of commenters pointed out that the interviewer acted like a jerk and in my experience with interviews and the God complex some interviewers develop, that may have been a hidden test. By not taking him up on his ridiculous claim he probably "deduced" that you are a bad fit for the team because you didn't stand up for your opinion / shy away from conflict / don't engage in healthy discussions. I really wouldn't want to work for someone who acts like this, whether or not that was a "hidden test"
I'm not sure why you need bundling for Node.js projects; also, TSLint is on its way out and ESLint should be preferred for TS.
It's a joke. I've heard some good things about PHP7.
Remove the explicit type definition, and add ‚Äúas const‚Äù at the end of the dictionary declaration. const Animals = { fish: Fish, dog: Dog, cat: Cat } as const; Note that this works from TS 3.4.
Jeez. Post this on Linkedin, tag company and guy. Then laugh hard.
True. Bullet dodget, working with that guy and a company that lets a java-something guy interview for frontend.
"oh wow Typescript has interfaces now, that's so bad" It's possible that he wasn't a native English speaker, or maybe you're not and you're not quoting him exactly, but I don't even know what that quote means. If that's what he said, and you weren't sure what he meant, I wish you had asked. I would have if someone said that to me. Not arguing with him, just asking what exactly he meant, because an interview is not an interrogation. If you have questions, you should ask. &amp;#x200B; Saying interfaces are bad is like saying keyboards are bad. Or gravity. Compared to what? Bad in what way? It makes no sense, but maybe he meant TypeScript is bad, or something else. Who knows? Sure, read more about OOP, but you won't learn that "interfaces are bad". Again, I wish you'd asked what he meant, and asking an interviewer who fails you what you should learn more about is always a good idea, but maybe he was just a bully. Not joining a bully's team is better than joining it, so try not to take anything from it except ideas about what skills to work on next.
Hard to say why he reacted like this but seems like he knows nothing about TypeScript because it has interfaces from the very beginning. On a side note if that is all of your code I don't see how it demonstrates significant understanding of OOP.
Woah! thanks!
While unlikely, he could also prefer that the type was unnecessary because it might have been easily inferred from the returned shape. I usually don't bother with explicitly typing something which isn't too complex and doesn't form a public interface.
Yes indeed. Often this can be inferred by the compiler from other types used so you don't always need it even if a function is generic.
I feel like it takes away the pain of having to install node\_modules during CI/CD and deployment. The build time is higher, but how often do you run production-builds (dev builds are still faster)? Still debating on this with myself. Do you have a specific reasoning as to why it might be better to not bundle everything?
Thanks
There's also ReactPHP (event-driven, non-blocking I/O). Nothing to do with ReactJS.
IMO, TypeScript's type system is light years ahead of Java's. Source: personal experience in managing projects in both languages.
Personally like the second (your) approach better. Arrow functions are usually cleaner and don't mess with the lexical scope. Although if the rest of the code is considerably big and follows the first approach, I would rather also take consistency into consideration.
The first one will declare a named function, it will be hoisted and will not keep track of `this`. It's likely a tiny micro bit faster (just guessing). The second one will create an anonymous function that keeps track of `this`, and that function is then assigned to the local variable. The function is not hoisted. Personally I prefer the first approach.
You can open a PR to fix the definitions. Or you can just declare the module as any and don't deal with the definitions, although then you lose the type checking.
There needs to be a better way to deal with this. Why can't it just infer type information when none is available? Doesn't flow automatically do this??
That metadata about type-stuff has to come from _somewhere_. At some point in the chain, _someone_ has to say that this thingy here is an `AWSResponse`, for instance.
They‚Äôre both right depending on what you are accomplishing in context. So if you need to track ‚Äòthis‚Äô for example you may need arrow functions. Make sure you both understand they work differently, and therefore when you would use one over the other. Then make a contextual decision not an opinionated one.
What could be better than opening a PR to improve the experience for everyone?l
This is the suggestion I think I'm most comfortable with. My code looks like this: &gt;function isAnimalName(name: string): name is keyof typeof ANIMALS { &gt; &gt; return name in ANIMALS; &gt; &gt;}; This is my first type guard and I don't think I fully understand why we use "keyof typeof" instead of just "keyof", but it appears to be working.
I understand that it can't derive type information out of thin air. What I'm saying is that I think that tsc should at least attempt to scan through node\_modules and infer whatever is inferrable. &amp;#x200B; If the way the module's coded is too dynamic for types to be inferred, an alternative approach may be to automatically infer types from usages of the module from out in the wild. For example, the types for a module in the DefinitelyTyped repo would be based on usages of that module in opensource projects. A tool would automatically scan and pick out the types based on usage and type inference. &amp;#x200B; What we have now is basically unusable. Except for a select few popular projects, most of the type definitions in DefinitelyTyped are junk. That's the problem with user submissions.
I see what you're saying. That path, where your attempt to divine type information based on the code itself, or at least, context it is used in, is a very different path than JavaScript (and TypeScript) took. That's how Perl tends to work with its `wantarray` operator and concept of "context". Even then, though, that'll only work with primitives, and you'll just be stuck using "number" and "object" and "any" a lot, which is really.. not all that useful. If you want to figure out a way to make tsc that smart, I mean, [the source code is available](https://github.com/Microsoft/TypeScript)...
This is cool, thanks for posting!
The first one is a function declaration. The second one is a sort-of function declaration hidden behind a variable declaration. Some people say that assigning function expressions to consts is better, because you could theoretically redeclare a function by accident. However, redeclaring a function is an error in JS modules and in TS in general. That point is irrelevant in practice. Also, no one does this in other languages. E.g. in Dart, no one would go with option C or D (A and B are function declarations): a() { return 'a'; } b() =&gt; 'b'; final c = () =&gt; 'c'; final d = () { return 'd'; };
Yes optional typing sucks. I wouldn't bother having everything perfectly typed. If a library is out-of-date or missing the types then I ignore the types and use `any`. If it's super critical to the app to have type definitions then it's worth spending the time to write them yourself.
As a hack I write my own type real quick and cast it.
I think this is fine, though you may want to use `hasOwnProperty` instead, if you don't want `toString` and other inherited keys to be valid. As for `typeof`, the reason is that `ANIMALS` is a value, not a type. Return type of a function can only be defined in terms of other types, not values. `keyof` also works on types. So we use `typeof ANIMALS` to get the inferred type of the object and then use `keyof` to extract keys from this type.
What does "Typescript has interfaces now, that's so bad" even mean? Interfaces were a feature even in TypeScript's first release back in 2012.
This can be done by using `include` and `exclude` properties of tsconfig. ```js { "include": [ "src/components", ] } ```
Whichever of those two individuals like, the second option is safer and more flexible, without loss of performance. 1. Arrow function does not have this of itself. You do not have to abuse JavaScript this these days, and it‚Äôs more dangerous to use the first option and accidentally introduce ‚Äúcannot read foo of undefined‚Äù errors‚Äù 2. The first option allows you to overwrite the variable name without error. It‚Äôs safer to be able to lock the name with const with the second one. 3. The second one allows you to type the function itself, not only parameter and return types. It enables better type inference and less manual type definition. 4. As for performance, V8 developer says there is no performance difference. Also it doesn‚Äôt matter if you cast down to ES5 with Babel or TypeScript. https://stackoverflow.com/a/44031830
Is this better than just tslint/eslint?
We use it. It‚Äôs helpful
I wonder if there's a way to encourage JS library writers to provide type definitions for their projects.
It provides more advanced rules than default tslint, but I recommend not running it locally as it‚Äôs quite resource intensive.
Ill look into it thanks
I agree with the people here who said JavaScript will never support static typing, simply because it would be too much of a radical shift, drifting way too much from its original concept. And I don't think it's a bad thing. In the other hand... It would be awesome to have TypeScript **natively supported** in the browsers. We've seen something similar in the past, when Microsoft introduced VBScript support in Internet Explorer, stuff like that: &lt;script type="text/vbscript"&gt; msgbox "Vbscript" &lt;/script&gt; It was an alternative to JavaScript. Now dream of `&lt;script type="text/typescript"&gt;`...
No, not really. If you want "more advanced" rules for eslint use some of the many plugins created by the community.
Look into [nominal types](https://github.com/Microsoft/Typescript/issues/202).
Make telephone number an enum of all possible telephone numbers. :)
\[Typescript Deep Dive\]([https://basarat.gitbooks.io/typescript/content/docs/tips/nominalTyping.html](https://basarat.gitbooks.io/typescript/content/docs/tips/nominalTyping.html)) covers this pretty well.
What are the specs on the average machine you use at work?
This is a known ‚Äúissue‚Äù. Type checking is resource intensive. Vscode limits the TS server process to 4GB. It‚Äôs faster if you upgrade to at least 3.3, and the team is working on new features to speed it up further (eg. project references)
All are modern Macbook Pros (last 1-3 years)
Seen as you are making the effort to avoid this pitfall, why not go the whole way and make a separate class for each of the types? That way you solve your problem but also have the OOP joy of being able to add relevant methods to the classes when needed.
There‚Äôs a few tricks you can use! One that I use frequently, but is not as strict as it could be is this one: `export type FileId = number &amp; { fileId: ‚ÄòfileId‚Äô }` Zero artifacts after compilation. Assigning anything else to something expecting a FileId will throw compile errors. I did a test talk on this if you‚Äôre interested.
How to make ts-jest just run the tests and ignore type checking phase?
Take a look at this article [https://dev.to/gcanti/functional-design-smart-constructors-14nb](https://dev.to/gcanti/functional-design-smart-constructors-14nb)
Are you using the styled-components package? Since TypeScript 3.4 the types of that package (and other that heavily rely on distributed types) became very very slow. There have been slowdowns of x20 times.
Perhaps he wants to stick to the purer joys of functional programming and avoid the overhead of classes. Wrapping values in domain types is a common approach in functional programming.
&gt; The first option allows you to overwrite the variable name without error. Redeclaring functions is an error in JS modules and in TS in general.
Unfortunately there are only hacks available, e.g. the "Brands" technique. Proper nominal type support is on the roadmap since forever, and the related GitHub issue regularly gets derailed by people not understanding the purpose or just repeating the same crude workarounds/hacks that have been mentioned numerous times already.
Actually yeah, TS emits error for duplicate function declaration. It's allowed in JS though.
It's not allowed in modules.
&gt; it‚Äôs more dangerous to use the first option and accidentally introduce ‚Äúcannot read foo of undefined‚Äù errors Not in TypeScript. Accessing `this` without an explicit definition for `this` results in a warning/error. &gt; The second one allows you to type the function itself, not only parameter and return types. It enables better type inference and less manual type definition. That makes no sense. The type of the function is the tuple of parameters and return type. You can type and infer that equally with both approaches.
Just found this article about Mixins - they also implement!!!! a class: [https://www.typescriptlang.org/docs/handbook/mixins.html](https://www.typescriptlang.org/docs/handbook/mixins.html)
This is the approach I take as well. It's "mostly" fine. I often use these helper types/functions: type Branded&lt;T, B extends string&gt; = T &amp; { readonly __brand: B } type BrandType&lt;T extends Branded&lt;any, any&gt;&gt; = T extends Branded&lt;infer R, any&gt; ? R : never type BrandName&lt;T extends Branded&lt;any, any&gt;&gt; = T extends Branded&lt;any, infer R&gt; ? R : never const asBrand = &lt;T extends Branded&lt;any, any&gt;&gt;(value: BrandType&lt;T&gt;): T =&gt; value as any; type OrderId = Branded&lt;number, 'OrderId'&gt; const asOrderId = (orderId: number) =&gt; asBrand&lt;OrderId&gt;(orderId); const myOrderId = asOrderId(12); Unfortunately `type` alias types do have a name on their own, so the type `OrderId` is always shown as `Branded&lt;number, 'OrderId'&gt;` by the compiler.
This is a bit stricter then what I suggested, which is a tad simpler to implement. I'm sure there's plenty of TypeScript functions you could use to get the strictness vs. verbosity you want.
Ehh.. This is pretty much exactly what you suggested, plus a bit of wrapper stuff. :-) The end result is the same, just the property name is different: `number &amp; { readonly __brand: 'fileId' }` vs `number &amp; { fileId: 'fileId' }`.
I think you want to set ‚ÄòallowJs‚Äô to true. Hope this link helps! https://stackoverflow.com/questions/40089419/how-does-typescript-allowjs-work
The nuance here is that the project files have flow types. Thus even though allowJs is true, typescript complains that there should be no types in js files, only in ts file types are allowed.
I see! Makes total sense. Thanks for clarifying!
You are correct, they are quite similar in their end result. Your helper functions do leave some traces in the resulting JavaScript after compilation without adding direct value, so maybe that makes it unnecessarily more complex. Then again, this feels very subjective and I may just not like the idea of having a helper function for a thing that is quite simple in itself to both read and understand. I like your `readonly brand: 'fileId'` as it explicitly defines what makes it unique as readonly. Could add to be a bit more type safety as the compiler will prevent changes. But I'm not sure where this "safety" would show, or that it's just a more explicit way of achieving the same. It's a generally well accepted solution to achieve a bit more type safety besides the "default" primitive types.
&gt; Your helper functions do leave some traces in the resulting JavaScript after compilation without adding direct value That is true. Theoretically you could add a custom transformer that will remove this function and all calls to it... But that would be too much magic. Personally I accept that this "no-op" function ends in the emitted JS, but I understand the hesitation about it. &gt; I like your readonly brand: 'fileId' as it explicitly defines what makes it unique as readonly. Could add to be a bit more type safety as the compiler will prevent changes. But I'm not sure where this "safety" would show, or that it's just a more explicit way of achieving the same. I always prefix such special property names with `__` to indicate "this is special, do not touch, internal detail". Kinda similar to how the C# compiler will generate names that contain the `&lt;&gt;` characters. The readonly will avoid assigning like `yourFileId.fileId = 'fileId'`. In the case of primitives it's not harmful - it will just not work. But if you consider branding objects, then this could be relevant. On another thought it would be a good choice to expand the type of the brand by `undefined`, e.g.: `number &amp; { readonly fileId: 'fileId' | undefined }`. That should protect from passing `myFileId.fileId` as an argument to a `string` parameter (shouldn't happen, but the more security the better).
Ah yeah that's a great idea! The double underscore seems familiar, but I still refrain from doing it. I see it usually indicating `private`s, which is basically the same as you're describing; internal detail, do not bother. The `undefined` `tuple` type seems like a brilliant idea, and it's also a case for why having a helper function assign this for you is a helpful; you can change this implementation and play with the strictness vs. verbosity without having to touch all your `export type` assignments throughout your project. Good stuff! Interesting!
Since you find it interesting, here's another option I played around with (warning, with double underscores): type Branded&lt;T, B extends string&gt; = T &amp; { readonly __brands: { readonly [P in B]: never } } type FileId = Branded&lt;number, 'FileId'&gt; The resulting type would be: `number &amp; { __brands: { FileId: never } }` The nested `__brands` is just to avoid having the brand name directly on the top level. Using `never` makes sure the virtual branding is never used anywhere in the code. This way you can also combine multiple brands: `Branded&lt;number, 'FileId' | 'OldFileId'&gt;`. This type would be compatible with the `FileId` from before.
@AngularBeginner: Thank you for your feedback. Do you have any source of reference about "export" would effectively enable both "const Button" and "namespace Button" for other source files? &amp;#x200B; P/S: I could test by source code, but I want to read documentation to gain more information.
The TypeScript team has a clearly stated non-goal about this: &gt; Provide additional runtime functionality or libraries. Instead, use TypeScript to describe existing libraries. They want to provide a language that is close to JavaScript and augments it with type information and focus on that. Then leave the rest to the users. You're mixing up language with runtime eco-system.
&gt; abel, The source base which I'm reading is huge, it had complicated interfaces and they are nested multiple levels into each other.
https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces-with-classes-functions-and-enums
You lack experience in JavaScript and try to transplant your experience with C# or Java into JavaScript.
This is excellent material, did you write about any of this? Or have you just been studying the TypeScript documentation for things like this? I'm currently working on a talk on using TypeScript more effectively in Angular and this is definitely already in that list, but I feel it needs more depth and more examples to show the possibilities.
I don't care if this is their official goal or not. Describing this as an official goal does not mean that this goal is right or can not be changed. Modern languages like Kotlin also have their basic eco-system included and that's good so. We have 2019 and it can't be that everyone who needs a Rectangle class has to write his own. &amp;#x200B; \&gt; OOP or functional style? Mutable vs immutable? This shouldn't be the question. Most of the major libs in other languages have mutable and immutable versions. This ist not something new!!!! Almost every language has those basic features/libs. Just take one of you choice, look what they do and provide it for TS (with "you" I mean MS) - and again: I'm sure MS has a ton of those libs internally.
True - and? This will happen more and more. If your first language is JS you don't miss those features because you think it's normal but you if come from another language you know where the downsides of JS are - this is one of them... In general - I'm not talking about JS. I'm talking about TS. JS is in many cases (not all!!) a very ugly beast. TS is so successful because it solve a lot of those downsides. That's why I don't get it why they don't provide such basic libs.
&gt; I don't care if this is their official goal or not. And no one cares if you care about their goals or not. It's clearly stated and it's absolutely reasonable. Adding more stuff than necessary for the stated goals will just increase the risk of conflicts with future ECMAScript versions. &gt; Describing this as an official goal does not mean that this goal is right or can not be changed. Not understanding the reasons behind it won't help you get what you want either. &gt; This shouldn't be the question. Most of the major libs in other languages have mutable and immutable versions. Yeah, and now they have to maintain two versions of each feature. Awesome overhead. Instead of working on the language they're busy writing and maintaining libraries that won't affect the majority of users. &gt; I'm sure MS has a ton of those libs internally. You're not sure, you're guessing. And what additional classes/types are needed is heavily project dependent. A `Rectangle` for a graphics library/tool will be vastly different than a `Rectangle` for something like VSCode where it refers to a text selection. There are plenty of good libraries available out there. Use one of them.
I'm not blogging or anything, no. Considered several times, but I just don't have the drive for it. I just frequently play around with various ideas that pop up in my head and see where / how it goes. My latest project (work related) is Angular, and honestly: I really don't like Angular. They make so poor use of TypeScript (ironically). But I haven't been working with this project enough to see how I can improve things. Biggest issue currently is that Angular Forms builder loses all type safety (perhaps the team just used it wrong).
TS is just JS with types. If JS had the built in classes you want, then TS would have them. That would be like blaming kotlin because Java is missing your desired functionality.
Ah I see! Are you on Twitter perhaps? Some interesting people to follow there to get you connected, ask the right questions I guess. I do like Angular (also use it for both work and private projects), but I agree that type safety isn't used as much as they could. There were plans to like type check the HTML (which it does in a very basic way), but they don't check the `@Input()` `@Output()` variables etc. Hopefully with the release of Ivy this will be improved, but if you run into serious issues with type safety directly from the framework; there may be implementation errors or actual bugs that we could investigate and report. If you have any specific cases, can you make a stackblitz repro and send it to me? I'd be happy to take a look and see what we can improve or report.
But in GitHub one can read: ‚Äútsc-watch is using the currently installed TypeScript compiler. tsc-watch is not changing the compiler, just adds the new arguments, compilation is the same, and all other arguments are the same.‚Äù Thus how can it offer partial builds not already implemented in tsc?
Didn't TypeScript 3.4 drop recently introducing incremental compilation? This should speed things up after a slow initial compilation?
They are generics, you can refer to the documentation here: https://www.typescriptlang.org/docs/handbook/generics.html
Ok. You're confusing things a little bit. First, typescript is not a runtime. You mad because it does not have a "collections" or "shape" module. That's Browser's and NodeJs's fault for not provide them for the language to use. And I'm not talking about TS, but JS. Typescript has NO modules at all. Second, you asking to MS to open source something that they do not write. If you like open source so much and need those classes and modules, why don't you star implementing them in your code base then open source it and push to npm or something, so the next guy doesn't have the trouble you experienced. That's how open source works. I mean. Typescript is a white canvas, as JavaScript is too. Don't focus on what you don't have, but on what you can do with it instead.
One downside I've discovered if you want to use a branded type as an object key type it won't work: type Key = ('a' | 'b') &amp; {__Key: never} const obj: Record&lt;Key, number&gt; = { a: 1, b: 2 } const k: Key = 'a' as Key const n = obj[k] // &lt;-- doesn't work
We were, and did run into that slowdown but we've since reverted back to 3.3.4 for now.
I wonder why tools like https://www.brics.dk/tstools aren't used more often to validate that type definitions accurately reflect the runtime behavior.
Well quite! It would appear that neither proper OOP nor tolerance for other ideas are too in vogue round here.
What.
To expand on /u/ejaculat0r's answer a bit the text in the angle brackets tells the method in question what type to expect, and that provides additional type safety and better code completion.
[https://github.com/tc39/proposal-javascript-standard-library](https://github.com/tc39/proposal-javascript-standard-library) with the types added and everyone is happy :)
Dunno if it helps y, but for me in my project i was able to fasten the chcking by expolict importing \`\`√¨mport merge from "lodash/merge"\`\`\`\` instead of \`\`\`import {merge} from 'lodash'; By this. TS didnt need to check whoe lodash, whereby lodash is only an example for your libs
What framework are you even using? There's like zero information to go on in your original post for us to start helping you. May I also suggest stackoverflow.com? üëç
Interesting, would this help even if we're using @types/lodash?
dont' be mad if i link you [my article](https://dev.to/janpauldahlke/how-to-improve-material-ui-speed-in-react-typescript-1199) from [dev.to](https://dev.to). also read the comments, there should be a babel plugin for this. but i prefer expiclity on imports since then. It helped me likei said, i hope it will help you :-)
More like generic questions get generic answers, eh. üòé
I did not know that existed. Very cool, thanks for sharing.
That's a great question. I've been jotting down my thoughts on it for a few weeks. I'm still exploring scenarios, but at the moment, I'm leaning towards the sentiment that there's not that much fundamental overlap. It really does depend on the application though. If we can trust that what comes back from an API is a valid aggregate (which is something that we should be able to trust since the business logic and rules are held server-side), then we've mitigated a huge DDD issue: model encapsulation. Topics that come to mind are: \- model validation (requires a round-trip to the backend or done client-side. Generally done on both sides with the backend having the final say). \- majority of react/redux logic is oriented toward hydrating view models- not usually a lot of business complexity here. I think if DDD is fully necessary on the front end is dependent on who has the final say on business rules (front or back) and just how much domain complexity the front-end is responsible for. Eric Evans and Vaugh Vernan have both written that the Smart UI is an anti-pattern for DDD. That's a blanket statement though, and we don't like those. I've got this book on my list to take a look through: [https://www.oreilly.com/library/view/javascript-domain-driven-design/9781784394325/](https://www.oreilly.com/library/view/javascript-domain-driven-design/9781784394325/).
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/deno] [Drash (a Deno microframework) v0.8.0 released](https://www.reddit.com/r/Deno/comments/bdxygg/drash_a_deno_microframework_v080_released/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Type definitions (or lack thereof) is what got me into open source. I quickly realised how terrible it was to complain about other people's code that is often written in their free time, for no commercial incentive. It's to be expected anyway, a huge number of libraries pre-date TypeScript.
That was a terrible joke but I laughed.
So it's normal for people to get very delayed feedback within the editor (via Typescript Language Service) on large TS projects? That seems so frustrating :(
You'll have to write the default value logic manually. Instead of using default value syntax, make both arguments optional -- with a question mark -- and then write the default value assignments in the function body.
The more I use asp.net at work the more I miss typescript. I tried writing a function with generics and overloads that I knew would work in TS but I couldn't for the life of me get it to work the way I thought it should. It was too strict. Obviously it's because I am not trained in csharp but I feel like TS is so much more forgiving and intuitive
I take it Lisp is your favorite language then?
arr.reduce is a generic function and React.ChangeEventHandler is a generic type. That means they can be parametrized with another type. The type in angle brackets is a type parameter. For arr.reduce it sets the return type, for the event handler it specifies what element type the event came from, hence what properties it has. In the first case it‚Äôs mainly useful for checking your work, because IIRC tsc should infer the return type correctly. In the second it lets you access the event‚Äôs properties without the compiler complaining.
Almost all the academic work is behind on the list of supported types. TypesScript adds new features at a faster rate than people can write these validators for.
Hm what does void 0 mean in the if statement?
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void
Thanks for the correction! I must have been thinking of something else.
Why not if(!max)?
That will also trigger on `0`, which might be a valid value (e.g. min -5, max 0).
&gt;I guess there is some obscure way to override what undefined refers to. Yes, seems like this the reason: &gt; ... global variable undefined can be used instead (assuming it has not been assigned to a non-default value).
Does void 0 not equal falsy just like 0 would? Isn't that what the code wants? Basically anything larger than 0,so 0 is also invalid. Right?
`void 0` will **always** return `undefined`. So when you check `max == void 0`, you will always compare `max` with `undefined`. Only if `max` is `undefined` it will yield `true`. However, your `!max` will also yield `true` when `max` is `0`, because `0` is falsy as well. What he wants in this code is to have a default value set for `max` if `max` was not provided. If a parameter is not provided it has a value of `undefined`.
Ahhhhh ok you're right. Thanks!
Small correction here, Electron (Not VSCode itself) currently limits the TS Server process to ~2GB. The issue does seem to be known, but I‚Äôm not sure there is a solution in sight. The long wait times are mostly a result of non-productive garbage collection cycles when a node process reaches its memory ceiling. https://github.com/Microsoft/TypeScript/issues/30981 We‚Äôve had this issue in our TS project for some time now and so far, have not found any solutions. Next steps for us is investigating the possibility of splitting the project into smaller parts to try to keep the memory usage below the allocation limit.
You can fix this problem in your projects with Module Augmentation http://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation This allows you to easily augment or override types for a module without forking/changing anything in @types Hopefully you can then create a PR for @types once you get everything working!
I would KISS and use something like sed or awk.
Well yes, but I would need to automatically resolve the path to the files since they differ depending on where I want to import them. Basically I need the same thing VS and VSC already do when you hover a missing import.
Oh right, of course. I forgot. I don't know any tools to do this off-the-shelf. You could compute the path in a js script and add it programmatically. The nodejs "glob" library makes it easy to get a list of files, and the "path" module can do the path computation.
I personally bundle whenever possible because it makes docker images super tiny (and the final docker image becomes super simple)
Using it right now - come from Entity Framework/NHibernate background. It gets the job done for POCs.
Yeah I had a really weird bug this morning where it was saying saved but it really wasn‚Äôt saving all my changes. Like a variable that I switched to false remained true when I actually ran the program. I thought I was going crazy.
Webstorm / Intellij can do it at least for a single file. SHIFT + ALT + ENTER adds all missing imports in one action.
if you are talking about import foo from '../SomeClass.ts' compared to import foo from './SomeClass' then tsconfig-paths / [webpack resolve.alias](https://webpack.js.org/configuration/resolve/#resolvealias) could help solve this and let you copy paste the same import in all those files
Well, you can write a Webpack-loader which will use \`#relative\` function from \`path\` module to calculate relative path (of module to be imported from the actual module), and then you can append that path to source and write the file back to disk. &amp;#x200B; 1) This'll be but of a pain, but not a lot (I know cos I have done this before). 2) Its not worth it. Your code quality and readability/maintainability goes down the drain once you start this stuff. 3) Spend time to cleanup code, it'll be worth it. And even if there are thousand such errors with missing imports, its worth it to solve them properly than do this. &amp;#x200B; Now that being said, there is a clever and proper way to do this. &amp;#x200B; 1) Write the loader I mentioned above. Run it, add all required imports, and write the files to disk. You can also use any other tool like \`sed\` for this, but loader is honestly easier IMO because you can then use \`path\` module to get the correct relative path of module to be imported (as I mentioned above). 2) Run TSLint on those files; this'll organize the imports and also remove the unused imports. 3) Remove the loader from first step from source code so future maintainers don't deal with this hacky-whacky stuff. 4) Commit to source-control.
Try this one: ``` function foo&lt;T, B extends () =&gt; T&gt;(a: (b: B) =&gt; T) { const b = (() =&gt; value) as B; const value = a(b); return value; } const v = foo(b =&gt; 'a'); ```
&gt;We could of course click on every error in Visual Studio, hover the class and manually click import missing files but that would be tedious. So any suggestions on how to go on about this? Visual studio has a shortcut: ctrl+space to automatically add the import. Click the error, hit the right arrow key once if the cursor is not in the class name but is just before it instead, and then hit ctrl+space. As long as the class name is unambiguous it will add the import statement properly.
Perhaps make Size and Position interfaces, eg `interface Position {x:number, y:number}` Your api then looks a bit nicer, eg `hero.position.add({x:1,y:2})`
I‚Äôve been staring at this for a long time, but what is it supposed to do? The way the value const is defined to have the value of a function call that returns value itself looks like a sadistic interview question, or just something out of Lovecraft.
I prefer the former if at the top level, the latter if inside any other function or method definition.
&gt;const hero = new Hero(new Position(0, 10), new Size(10, 100)); Sorry I am a bit confused, bit new to TS. You mean get rid of the classes \`Size\` and \`Position\` and replaces with interfaces? How do I implement the \`add\` method? Could you expand your answer? Cheers!
Your reuse of variable names confuses any discussion of the code. Hopefully renaming them makes it clearer. function foo&lt;T&gt;(gimmeAString: (callback: () =&gt; T) =&gt; T) {` const throwAnException = () =&gt; value; // will throw because value is not declared const returnValue = gimmeAString(throwAnException); return returnValue; } const v = foo(unusedCallback =&gt; 'a'); // since unusedCallback is unused, throwAnException is not called `throwAnException` does not return a T. Ideally that would cause a compile error to help you identify the problem, but apparently it doesn't.
 public add(p: Position): void { this.hero.position.x += p.x; this.hero.position.y += p.y; }
here's one way to do it: // // VECTOR STUFF // type Vector2 = [number, number] const vectors = { add(a, b) { const x = a[0] + b[0] const y = a[1] + b[1] return [x, y] } multiply(a, b) { const x = a[0] * b[0] const y = a[1] * b[1] return [a[0] + b[0], a[1] + b[1]] } } // // CHARACTER // interface CharacterOptions { position: Vector2 size: Vector2 } class Character { position: Vector2 size: Vector2 constructor({ position = [0, 0], size = [1, 1] }: CharacterOptions) { this.position = position this.size = size } } // // HERO // interface HeroOptions extends CharacterOptions { color: string } class Hero extends Character { color: string constructor({color, ...characterOptions}: CharacterOptions) { super(characterOptions) this.color = color } } // // USAGE DEMO // const hero = new Hero({ position: [1, 2], size: [3, 4] }) hero.position = vectors.add(hero.position, [1, 1])
Ha ha! I'm sorry. I reduced the code to this example and the example doesn't really accomplish anything. It just shows the strange behavior.
Thank you!
That headline made me think the article would actually describe Webpack changes. It does not.
My two cents, default position and size to same defaults, remove them from the constructor. hero.position.x += 1; Or hero.position = {x:0,y:0} Are both common. It's very common for position to have an x and y. I'm not sure why you'd need an add function.
I didn't think about that, good suggestion. Thanks!
Bear in mind that prettier is very opinionated (not configurable) so you're not really enforcing your team's style, you're enforcing prettier's.
TSLint is obsolete, don't use it. Use ESLint.
You can configure Prettier with \`.prettierrc\` file [https://prettier.io/docs/en/configuration.html](https://prettier.io/docs/en/configuration.html)
The goal of prettier is to stop "style" from being a thing people argue about. Generally I find an obsession with style belies poor coding fundamentals. The people who are a lot about style are the ones who write code like ObjA += +b.c(attr) * C.a.B(32)
Can you explain why? Does ESLint handle Typescript? I recently created a new project, using CRA, and TSLint works fine.
A lot of things are not configurable. He's right that prettier is very opinionated.
It might not be as configurable as I'd like but saying you cant configure it at all is doing it an injustice.
There's more info from the TSLint team here: https://medium.com/palantir/tslint-in-2019-1a144c2317a9
Yes, the TypeScript team is working with ESLint to implement TypeScript support, [and so will the TSLint team](https://medium.com/palantir/tslint-in-2019-1a144c2317a9).
I'll do an example when I'm home tonight.
Never really liked Palantir trying to look like a good guy company.
Thanks for this amazing code! This seems REALLY good, there were I few typos I corrected to get it running. You say this is one way of doing it... I can't see a better way, it is strange I have not seen anyone else using a `vectors` object like this, all the other online example have a Vector2 class, including the TypeScript game engines. I am not sure why you included default values `{ position = [0, 0], size = [1, 1] }` for the character constructor? Are you foreseeing something I am not? Every character must have a `position` and `size`, and this is enforced by the interface. I can't see how I could leave the `position` and `size` out and allow it to go to default values... the interface gives an error. Here is the working version with a few little mods and added types: ``` type Vector2 = [number, number]; const vectors = { add(a: Vector2, b: Vector2): Vector2 { return [a[0] + b[0], a[1] + b[1]]; }, multiply(a: Vector2, b: Vector2): Vector2 { return [a[0] * b[0], a[1] * b[1]]; }, }; // // CHARACTER // interface CharacterOptions { position: Vector2; size: Vector2; } abstract class Character { public position: Vector2; public size: Vector2; public constructor({ position, size }: CharacterOptions) { this.position = position; this.size = size; } } // // HERO // interface HeroOptions extends CharacterOptions { color: string; } class Hero extends Character { public color: string; public constructor({ color, ...characterOptions }: HeroOptions) { super(characterOptions); this.color = color; } } // // USAGE DEMO // const hero = new Hero({ position: [1, 2], size: [3, 4], color: 'red', }); ```
I enter the page and immediately get one huge ass layer about my data, **and** at the same time a chat bubble. Wtf.
I am not sure how I can add the vectors without an add function? I would like all the variables that have an x and y to live in a \`type Vector2 = \[number, number\]\` &amp;#x200B; I thought about this quite a bit, it must be the right abstraction, almost the definition of what a tuple should be used for? [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html) &gt;Tuple types allow you to express an array where the type of a fixed number of elements is known What do you make ofthe @[ChaseMoskal](https://www.reddit.com/user/ChaseMoskal) solution? Thanks for taking the time to help me on this!
Cheers! Looking forward to it.
use TsLint while they work it out
Chase's solution is fine. You can research how position is maintained in Unity3D, Unreal, Game Maker, etc for reference. Add and multiply are fine member functions, but they're not required. https://docs.unity3d.com/ScriptReference/Vector2.html Here is some ideas for a very rich api. In fact, there is an underlying tuple like structure here as well...x and y are effectively just getters and setters for element 0 and 1.
I have stopped using prettier because I don't like how they format some things on multiple lines when I really want it to be a single line.
OP, stop spamming your shitty website.
Cheers! Funny you should mention the Unity engine, I only just used their idea of the base class being called GameObject and having position, rotation and scale an hour ago :) I have done some more modding for the defaults and optional parts: ``` type Vector2 = [number, number]; const vectors = { add(a: Vector2, b: Vector2): Vector2 { return [a[0] + b[0], a[1] + b[1]]; }, }; // // CHARACTER // interface GameObjectOptions { position: Vector2; rotation?: number; scale?: Vector2; } abstract class GameObject { public position: Vector2; public rotation: number; public scale: Vector2; public constructor({ position, rotation = 0, scale = [1, 1], }: GameObjectOptions) { this.position = position; this.rotation = rotation; this.scale = scale; } } // // HERO // interface HeroOptions extends GameObjectOptions { alive: boolean; velocity: Vector2; color: string; } class Hero extends GameObject { public alive: boolean; public velocity: Vector2; public color: string; public constructor({ alive, velocity, color, ...characterOptions }: HeroOptions) { super(characterOptions); this.alive = alive; this.velocity = velocity; this.color = color; } } // // USAGE DEMO // const hero = new Hero({ position: [1, 2], // rotation: 0, // scale: [1, 1], alive: true, velocity: [0, 0], color: 'red', }); ```
Starting to look pretty good!
Agreed, I find prettier to be a pretty useless piece of work that tries to optimize code styling where it's not needed. Like if I have an array of 10 items. I want to format them each on a single line so I can easily read what's in the array. But prettier will decide that it's easier to read when all 10 items are on a single line. Blah!
That just means Kotlin is more opinionated than TypeScript. Just like how WordPress is more opinionated than Laravel. What you're looking for is available with various npm modules.
Microsoft treats TypeScript as a first class language with .net functionality available. Check it out, it may be what you're looking for.
You're expecting a little much. Maybe investigate other languages? If this is browser side work you won't have much else to choose from, though.
Nothing like writing a line way bigger than 120 chars and have to scroll to read.
Thanks, I check it out.
If you love long lines, just set printWidth = 200 to your heart!
It's not that I love long lines. Prettier would change this line of text: someMethod({ data: "somedata" }); to: someMethod({ data: "somedata" }); (something like this, not exactly, just an example) I just find it annoying sometimes.
You dont get it. The big point of prettier is using format on save. So you just write code in the ugliest way possible, then hit CMD+S. Saves you big time fiddling with spaces, returns and tabs. Even better if you use things like react and typescript which are quite a pain to format. If the formatting different from what I‚Äôd manually do? A bit sometimes. But I dont care, just hitting CTRL+S offsets that by a bog margin. Nowadays I largely miss prettier when going back to a language without a decent formatter (python), indenting manually is slave job.
TS oficially pointed out that ESlint is going to be the default linter (so that JS rules from another scopes are also reused), but implementing it nowadays is still a bit harsh. Will get better with some time.
I think MS brings out something similar to prettier in one of the next releases. No sure where I red it but it sounded like they want those tools to be better. Prettier is just too opinionated in some cases. (My workaround is to mark those sections with \`// prettier-ignore\`)
I switched off early on because I refuse to support Palantir or their open-source projects, tslint being one of them. Using eslint has worked out fine for me, you just have to set no-unused-vars to false because there are too many false positives. Once they figure that out it‚Äôll be ready and in the meantime you can use the `noUnusedLocals` and `noUnusedParameters` in your tsconfig to true. typescript-eslint is ready and used lots of places and the sooner you switch, the sooner we can stop having typescript be associated with this deplorable organization https://theintercept.com/2017/03/02/palantir-provides-the-engine-for-donald-trumps-deportation-machine/
I've used Prettier, but only because it's a necessary evil with multiple developers. You can build in a lot of nuances into your code, that Prettier will absolutely destroy. For example: 1. I use single quotes for machine-readable strings, and double quotes for something the user might see. Prettier makes you choose. 2. I use 3 new lines in between functions to differentiate code blocks. If everything is a single new line, it's harder to tell what is a new function, and what is whitespace within a function. Prettier collapses more than 1 newline. 3. Per #2, I also use 3 newlines between TS imports and any class/function declarations. It's nice to see where the definition of a class begins. Since prettier 1-lines everything, it becomes a homogeneous blob of imports, class, and function definitions. I would be happy with Prettier if they allowed more configuration options. I get that they want to remove any style conversations from code review. However, programming is a craft. In my opinion, a completely automated and opinionated tool enables lazy coding habits.
 interface Position { readonly x: number readonly y: number } interface Size { readonly width: number; readonly height: number; } export abstract class Character { protected constructor(protected position: Position, protected size: Size) {} public move(delta: Position) { this.position = {x: this.position.x + delta.x, y: this.position.y + delta.y} } } export class Hero extends Character { color: string constructor(position: Position, size: Size) { super(position, size) this.color = 'red' } } const hero = new Hero({x: 0, y: 10}, {width: 10, height: 0}) hero.move({x: 1, y: 2}) Something like the above would work. As well as using interfaces I've: * Made some fields protected as may be they don't all need to be public * Used shorter form a constructor to make the code a bit more compact * Moved the move method up the to Character class (Law of Demeter) &amp;#x200B; Hope this helps.
I thought format on save was a feature native to VS Code, not Prettier. But at least I know I can do it with jsbeauty anyway. I gave Prettier a shot after using Beautify for a whole and the problems described above are exactly why I just stuck with jsbeautify
I like working with prettier because as code style goes, the only thing worse than code being ugly is inconsistency. I do sometimes wish there were more configuration options for prettier but at the end of the day my personal preferences on code style don't matter half as much as producing code that fosters productivity, maintainability, and interoperability due to the style of code being predictable and consistent. I think prettier is following the lead of things like `go fmt` or `terraform fmt` in the sense that rather than allowing devs to shape their code style to fit their preferences, it's pushing devs to confirm to a single code style for the language for the sake of interoperability. Sure I disagree with some of prettier's styles but by familiarizing myself with that one single code style I can become comfortable and productive working on any other codebase that has adopted prettier
&gt; EDIT: I think we just need to add optional ?'s to the interface, as I did in the latest code in reply to @yaxamie above? ahah, yes, i had forgotten to add the `?` optional marks you might opt to not have defaults and make the properties required abstract class Character { you don't need to make the class abstract until you use an `abstract` member like an abstract method or abstract property also, i thought you'd be intersted to see, in [my own game engine project](https://github.com/monarch-games/engine), i too use typescript, and my game entities have [some interfaces like these](https://github.com/monarch-games/engine/blob/refactor/source/core/interfaces.ts#L74): export type Vector = [number, number, number] export type Quaternion = [number, number, number, number] /** * Spatial relationship with the world */ export interface Bearings { position: Vector rotation: Quaternion } /** * Physical characteristics */ export interface Physique { mass: number size: Vector friction?: number damping?: number restitution?: number } this is just nerd-gore: but i like to think of an entity's "physique" (intrinsic qualities) as distinct from its "bearings" (relational qualities) &gt; I can't see a better way, it is strange I have not seen anyone else using a vectors object like this, all the other online example have a Vector2 class, including the TypeScript game engines. yes, i think it is mostly a matter of taste, whether vectors should be thought of as instances which have their own methods, or to think of vectors as information which we have functional tools to perform operations with the differences in terms of performance are probably negligible, slightly favoring the functional approach
Not necessarily. I intentionally don't bring up style issues in code reviews, though the following to me is objectively harder to read due to lack of spacing: `{property:'value'}`
You can, and that's really what I enjoy about knowing how my workspace works. Some people are just a bit more lazy than others.
Prettier rules are predictable. For instance, either an array fits into one line, either each item will get its own line. It wont split 2 items per line, since it is just not predictable. In case you want to do your own creatove formatting, you cam still use //prettier-ignore, but that mostly means that you are being creative but not consistent.
From reading the other comments, looks like people listed the technical differences and then it comes down to style. Personally I prefer arrow functions everywhere. Heck, even my React components are arrow functions. I don't do OOP at all, but if I did, my class methods would be arrow functions. For me it's arrow functions all the way down. Consider the following classical code: export function getStuff(param1: string, param2: string | null) { if (param2 === null) { return defaultFrom(param1); } else { return param2; } } Simplified, it becomes: export const getStuff = (param1: string, param2: string | null) =&gt; param2 === null ? defaultFrom(param1) : param2; I find the second option far more readable. You only return a single string
Coming from a Java background, I have to say, I prefer TS 99% of the time.
&gt;The goal of prettier is to stop "style" from being a thing people argue about. Until someone makes a competitor to Prettier and there become two standards for style.
it's not about having one global standard of style, but consistent style for your team. most developers don't care about style, but more so consistency. it's not easy to nudge your lazy co worker to put more effort into their work...
most developer's don't care. they just want consistency. otherwise those lazy developers fugly code starts to pollute the code base making it harder to understand code, investigate issues, etc.. style still doesn't solve all the problem with people putting in low effort into their work (variable names, method names, class names, file/folder organization, and of course architecture and good practices (SOLID, etc).
Just curious but why do you refuse to support Palantir?
You are a monster!
That's not the point. Prettier isn't trying to become the one style to rule them all. However, if its style is to your liking, then it is a tool you have available to enforce consistent style across your projects.
sure you can and in fact you can even make a lightweight SPA without Angular lots of libraries out there for that. Just be aware you'll have a lot to setup or alternatively just look for a good boilerplate on github.
Yup, TypeScript is its own thing which isn't tied to any framework/library. You can use it with regular JS, other frameworks like React, etc. You can even use it on the server-side with Node. If you haven't already, install node/npm here: https://nodejs.org/en/ Then, install TypeScript globally by running this in your terminal: $ npm install -g typescript Then, just navigate to your project folder and run: $ tsc --init This will automatically create a `tsconfig.json` file for you which will allow you to start using TypeScript. If you want to customize how TypeScript works with your project, you can change settings in the `tsconfig.json` file. You can see specifics on what you can do here: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html
But how do I go about doing it? That was part of the question. I'm interested in one thing, I want to learn about what I can and can't do with TypeScript/JavaScript without the overhead of having thousands of files just to play around. You will admit that for this purpose starting an Angular project would be a bit overblown.
Also, check out the [TypeScript in 5 Minutes](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) guide if you haven't already.
Yes, you can‚Äôt have the code exactly the way you like it with prettier. But not having to deal with formatting is such a boost for me, that I use it even in my hobby projects. I just type in everything on a single line, and let prettier handle the rest. I never realized how much time I wasted on formatting until i tried prettier. Now I can‚Äôt work without it.
so of coarse TypeScript is JavaScript so you can do anything JS can do. with a simple google search here you go https://medium.freecodecamp.org/how-to-set-up-a-typescript-project-67b427114884
Thank you very much! I don't know why I didn't think of looking for a subreddit on TS in the first place. I have asked elsewhere and the usual response is "Just start an Angular project when you want to use TS. " Which in some circumstances is kind of a bit much.
Here's the command I use to create (almost) blank ts projects. `yarn init &amp;&amp; yarn add typescript ts-node &amp;&amp; yarn tsc --init &amp;&amp; mkdir -p src &amp;&amp; echo 'console.log("hello world");' &gt;&gt; src/index.ts` Run `yarn ts-node src/` to run the project.
This is my opinion as well. I am happy with the default formatter in VS code 99% of the time. It's a tool, not an end-all, be-all solution. &amp;#x200B; I know my situation isn't the same for everyone, so I'm biased against something like prettier. I will hulk smash a lazy developers code during code review, before I let fugly code get into master.
If you are willing to step out of the browser, you can use typescript with node to just "do stuff." A nice way to get started is to install ts-node, write some typescript, and just run it. Super simple, fun, and you are up and running fast.
I really like `ts-node` to start coding quickly. Then I use `tsc` to generate the final JavaScript files. https://github.com/TypeStrong/ts-node
Because they do with for the US government and the US government deports illegal immigrants. Basically the same reason why Google and Microsoft employees tried to steer the companies from large government contracts. Everyone is just trying to be _woke_
I‚Äôm a C# developer and like the idea that I can format my code at least on the surface like it looks in C#.
The point of prettier is that you can "unstyle" it however you want after you open the file. You can write code however you want, but then you save it and it's all the same style. Also, the more people use it, the more it becomes a standard.
I'm very suspect that the migration will go as quickly or easily as planned. The reality is, tslint and eslint are implemented in a completely different way, and reaching parity between the two is going to be a painful process. For huge projects that have a lot of tslint rules, switching over is not simple or even worth it at this stage.
Code styles are like pizza. Yeah some pizza is better than other pizza, but ultimately it‚Äôs a matter of taste. Your favorite pizza will end up being the pizza place that delivers to your house because it‚Äôs the most familiar.
The single / double quotes thing is nice, I guess, but you can just as easily use variable naming to get the same information across in a way that doesn‚Äôt require people who work on your code in the future to decipher your particular ‚Äúflavour‚Äù of Javascript. Plus future developers are likely to open the code in development environments which will destroy that information, so relying on it is a poor strategy in the long run.
On of my favorite things is copy pasting some garbage code off the internet and then saving the file and being like ‚ÄúOhhhh that‚Äôs what it says!‚Äù
How many pages did you go through on google to find that? The first page I looked at was nothing but "Why we should use TS. " I figured the rest was more of the same and quit after that. Never fails, post a question on reddit it will be downvoted. Always. Because.
Haha it‚Äôs kinda funny that you wrote: &gt;I wouldn't work at Palantir on principle. They are a company based around SJWs. in another [reddit comment](https://www.reddit.com/r/cscareerquestions/comments/b6075f/palantir_vs_zendesk/ejh5djg/?context=3) 22 days ago, and were harshly corrected. I‚Äôm assuming your opinion of Palantir has been changed since then or maybe you just have no concept of what a ‚ÄúSJW‚Äù is meant to insinuate. Also, you‚Äôre gonna have a real tough time finding a job somewhere that isn‚Äôt West Bumblefuck, Texas if you keep posting political reddit comments under the same username as your github profile, just saying.
This kid is the textbook STEM caricature.
&gt; not configurable Looks pretty [configurable](https://prettier.io/docs/en/options.html) to me.
better still, prettier could always be run in CI, allowing that picky to have their own personal config locally.
I'm using TypeScript in a really lazy way: I have my WebStorm IDE transpile the `.ts` to `.js` in place (that is, in the same folder). I literally just create a new project, copy the `tsconfig.json` from another project and start editing `.ts` files. I write the `.ts` code, while `node` (or whatever) runs the resulting `.js` files. I actually do this both with a Next.js project and with a Node.js one with GraphQL.
&gt; I just create a new project, copy the tsconfig.json from another project This is probably the reason why I often see projects with outdated configuratons, e.g. the `strict` flag missing. &gt; I have my WebStorm IDE transpile the .ts to .js in place (that is, in the same folder). Great way to mess up your workspace and accidentally add js files to source control. Build artifacts belong to their dedicated location.
&gt; e.g. the `strict` flag missing. ...unless you have the `strict` flag in your configuration, which I do. &gt;accidentally add js files to source control ...unless you use `.gitignore`, to blacklist all `.js` files unless those you specifically whitelist. In my full TS projects I have absolutely no `.js` files at all.
Did this comment really require it's own post?
&gt; ...unless you have the strict flag in your configuration, which I do. It was an example, hence the "e.g.". You need to be aware of additions to the config file, which many users are not.
It might give people who are on the fence about TS a nudge to go ahead and try it in their existing project. That's how I got into TS, I just created a `.ts` file in my original JS project. Then I got hooked and changed everything to `.ts/x`.
Except it's really not a very good suggestion. A beginner should get comfortable with the tooling and not just let the IDE handle it for them like it's a magical black box. Littering your source tree with build artifacts is also strange and pointless, and you should rarely if ever have to even view the generated JavaScript.
Of course..
This is my first post on dev.to. I've since written a second one, which is shorter. Would appreciate any feedback, whether technical or not.
Be vary of using the `instanceof` operator and ideally don't rely on it. The reason is that object literals are implicitly compatible with classes when they match, but `instanceof` does not work on them (it checks the prototype chain that is not present in object literals). Take this example: // Just two dummy classes. class FirstClass { a: number = 12; } class OtherClass { b: boolean = true; } // The variable is typed to be either FirstClass or OtherClass, // but it actually gets assigned a FirstClass compatible object literal, // and not an instance! const someClass: FirstClass | OtherClass = Math.random() &gt; 0.0 ? { a: 12 } : new OtherClass(); // The type guard will return false, because the value is not an instance of FirstClass. if (typeGuard(someClass, FirstClass)) { // ... } else { // The type is inferred to be "OtherClass" due to type narrowing: // it's either FirstClass or OtherClass, and the type guard did not confirm that it's FirstClass, // so it must be OtherClass. someClass; // However, we know it's the object literal compatible with FirstClass. // So accessing b... results in undefined. console.log(someClass.b); } [Try it out yourself](https://typescript-play.js.org/#code/JYOwLgpgTgZghgYwgAjATwA4QLJw8gb2QHpjkYB7KZAWzw1AHNyoKbkBnMKJj1C1JggcAUMk7cmALgk8QjANxjkIAK40ARtBlrN0JeI0UKAGwhwQMo6fMglAXxEj0WZAAUeNYGGAA3CADyUADCFCBcUKoIYFTIALwkZADkEUxJyAA+yEm6WlDpWUnWZhYFyAhhEVExUMpZRCAQAO7IABQAdJ1wUIwcMhZoANoAugCU-SBoyI7iWQDWEGgUMIJYuBhKIqTIoDDQqAAWKIyq3QAmEGerKDCs7HCcWAjAMMAI5XAcKMvunt5+gRClW41SoziEyAA4qcoBczgAVIQAHnhyAgAA9ICAznwPMAvD5-EFQuEQdEqAA+eLIVEYrE4wgqZodLo9PrIAYjcY7EB7agAVQU02QAH5kPzkDJaZiINi+AslisXDg8KLrutBvDhpKmf4oJttq8QHATCY0AAaZAnc7IACCABl7YcUMqOABCEQwVQgaLAMLXaHnFFomVy374-5EoGkyLkqAU1oUS0IEyfDgAOTgNAgUvGygEwD4gdhl0RWBRVIIynEFVJyBMFAQJrxBIBxOBsZqMhbkcBJKqcepKbTmezBnEOxWrWVPwbTZMPcJfY7oOocXX2VS8iSo0I1eQUAgYFUUBA1x+AnXCTnzb+S-bMdX45mB6PJ7PBdJFiQs8bt4j97RgONQOE4WzEE42wAFKqFwqBNAIZzqDQUzDhwXwcO0IhoXwABiwBQFwwSpuhjJwDo6h5NSACMABMQqODhyABGARwhCRfBEBoVjGCUZ4JCCEAMZBZDwkcyC+N0wBwBoZg7HwypXDEyBaGi3hscg+GEWAxFpsgsQsWxunoea4EqaoYA7JZiDHiaZpWkefBpsAjCNFcDxaURHHlGwGBwD4snfBoABWEDRPW3jQCapnbBYVwgBQ1lnqAXDfhAHq1nBHBsBAxnsp5OneVkhnQHl1K4Kx7RQHFbCtLuVIAAztA1apEORyB0cKOjNMxrGlRxdUGqJ4nKlaMJXE0wCmq+x6nuQJpfJaWhNrBLriZJJiqCghYqIlHLJV+PrfCsBV5VhLxtMqxZnK02XZnllqnRxoy7lWE6JMgnRYfYaImF8e7vdsYkuhCO27NAh5KQIqkAEQlexaYw8gSEugIo3GlArCTfIUj7ts3gpGpfXUE9ekGcTD37UpI0QtasLI8A8V7bWrxQOwrH+VZhOkyZeNkNlVm0LBlmqfDZ37nduUceO4h88gAASFBNBAeqWsryBzAlLQEwp4kUCFYWWSYkXVSYPk0H5AVyZNrGaQRXlplhgNkAAygIiBIOhTAqV9r4cKoJhgHwoDIN6FxGpcTsTplNjtA2jC3TlZ0aKMoEiEAA) Another reason why I'm not a fan of OOP in TypeScript.
A bit exaggerated, by your logic you shouldn't use angular and Typescript cause Microsoft and Google DO work for the US government
That's true, and my solution would only be safe if the user knew that in all use-cases the function would be working with objects that were created by a constructor. Alternatively, I think some global mapping between types and their custom type guards could be used, to check for matching shape as specified by the programmer, rather than relying on `instanceof`.
Type guards aren‚Äôt checked across the board, so the unsoundness is somewhat orthogonal to OOP.
What is the point of bundling server code?
Then learn to google. The linked article is the first hit. https://lmgtfy.com/?q=How+to+setup+a+typescript+project
&gt; What is the point of bundling server code? Tree-shaking is often applied during bundling, reducing the size of your code, thus reducing the amount of code that needs to be parsed and compiled. You can also remove module load calls, resulting in faster code.
Gotcha. I do this for my web projects, but never really thought about doing it for backend code. I guess my projects don‚Äôt really require the performance tuning to justify treeshaking on the backend.
This is why I hate Reddit. People like you. I asked the logical question of google and didn‚Äôt get the expected response and you treat me like an idiot because I want help. Must be nice knowing everything.
Bundling in one file just seems like needless complexity to me. I am normally not concerned about server startup or node_modules size. I would worry that all the libraries that I use might work slightly different when run through webpack (env vars, webpack ordering, webpack node polyfills) Not that it can‚Äôt work properly I just don‚Äôt want to think about it when something goes wrong. Unfortunately I have to maintain a project that uses webpack to bundle server side code and even though newrelic was the first import it still didn‚Äôt instrument all the libraries property.
Yeah seems like unneeded complexity for not a lot in return. I get it for client side, but will probably never do it for server side.
Note that some may deem your attitude toxic
I use typescript with AWS lambdas so start up time and size are an issue for me in the back end.
I'm not advocating for anything. I think you and I are on the same page. TSLint was great. It is unfortunate it is being deprecated. I love writing TS
Author here, it doesn‚Äôt bundle node_modules, it just bundles your user code, this is because it supports both JavaScript (through Babel7) and TypeScript codebases, which helped us to move projects from JavaScript to TypeScript *incrementally* without complicating the build setup. Your projects can still be compiled through `tsc` with minimal changes, it‚Äôs just that this tool helps you to deal with things like custom path mapping, tslint, and tests without hassle.
That's pretty good advice. I was promptly corrected. I already have a job but thank you for your concern. I'll consider deleting my Reddit account.
I added some types to some of the variables. If you have any specific questions please don't hesitate to ask. ``` const audioElements: {[fileName: string]: HTMLAudioElement} = {}; const imgElements: {[fileName: string]: HTMLImageElement} = {}; function getExtension(url: string): string | undefined { return url.split('.').pop(); } function getFilename(url: string): string { return url.replace(/^.*\/(.*)$/, '$1'); } const assetURLs = [ './assets/zombie64-final.png', // './assets/tweet.png', // './assets/shoot.wav', // './assets/invaderkilled.wav', ]; const promiseArray = assetURLs.map(assetURL =&gt; { const promise = new Promise(resolve =&gt; { let asset: HTMLImageElement | HTMLAudioElement | undefined; let eventType: string | undefined; let targetObject: {[fileName: string]: HTMLAudioElement} | {[fileName: string]: HTMLImageElement}; if (getExtension(assetURL) === 'png') { asset = new Image(); eventType = 'load'; targetObject = imgElements; } else if (getExtension(assetURL) === 'wav') { asset = new Audio(); eventType = 'canplaythrough'; targetObject = audioElements; } if (asset === undefined || eventType === undefined) { return; } asset.src = assetURL; asset.addEventListener(eventType, function onAssetLoad() { if (asset !== undefined) { targetObject[getFilename(assetURL)] = asset; } resolve(); }); }); return promise; }); Promise.all(promiseArray).then(_ =&gt; console.log(`assets loaded!`)); ```
I ran into this issue of using an interface from another module where I had "declare module 'mymodule'" accidentally in place which was making any actual types that I tried to import from mymodule fail spectacularly [https://github.com/Microsoft/TypeScript/issues/27311](https://github.com/Microsoft/TypeScript/issues/27311)
This is fantastic! Thanks so much! I was wondering a few things about your reasoning... 1. You have 3 extra undefined checks, if my `assetURLs` array is pointing to at least one valid file, is this necessary? Any other reason we could get an undefined other than a file not existing or being corrupt? 2. What made you switch to the `asset.addEventListener` format using `canplaythrough` and `load` rather than the way I had it? Was this to do with typing or as a general improvement? 3. Could you add the return types? I am not sure about them. Cheers!
Typescript can't know anything about your data that you don't tell it. What would happen if an asset doesn't have the extension `png` or `wav`? What value would `assetURL` have then? The same goes for `eventType`. I changed the event listener from the on-format to the `addEventListener` in order to help typescript figure out what the callback function as for. When verifying that `eventType` isn't `undefined` we can fall back to the generic `HTMLElement` [`addEventListener` type information](https://github.com/Microsoft/TypeScript/blob/1a4c15fb1159a61acfb75f42707f331ef268fa15/lib/lib.dom.d.ts#L6320) and all will be fine as long as `eventType` is any string. When using the direct property access you would need to declare the two event names in a way that typescript can understand. This can be done using a `"oneventa" | "oneventb"` type over `string`, as you noted in the OP. The issue then becomes that typescript doesn't know what type `asset` has and will tell you that `"oneventa" | "oneventb"` isn't available on `HTMLImageElement | HTMLAudioElement`. The reason we again check if `asset` is undefined in side of the event listener is because typescript is not able to assert that its value can't be changed by some other code before the callback is executed. As for return values; as far as I can tell all functions have return values except for the function inside of the map and typescript can imply from the return statement that it should be `Promise&lt;any&gt;`.
Thanks for this explanation. I will spend a good amount of time studying this tomorrow, it is very helpful.
I‚Äôm currently in the process of converting a large project at work to a monorepo. Lots and lots of tedious busy work but the actual monorepo concepts and lerna are rather straightforward. I‚Äôm excited to finish because the ergonomics already seem a lot better.
Nice. Thanks. Short and sweet too.
The one thing I haven‚Äôt been able to figure out is, can you use monorepos in situations where you are using Bitbucket/GitHub to host your private packages? I have a case where we don‚Äôt have use of a internal npm repository.
absolutely. a monorepository is just a normal (git) repository, but you put several projects/packages inside. this also allows linking on local file level (you do not necessarily need to reference your published packages).
I guess my real question was around deploying and using those projects in other projects. It would have to pull in all of the monorepo code, only if I wanted to use a single package with the monorepo? That is the part that kind of turns me away from doing it, without an internal npm repo.
Ah ok. You can publish each package of the monorepo as usual. In JS/TS projects the packages would be normal npm packages with their own package.json. You decide if, how and where you publish these packages. &amp;#x200B; Also you can set up a "multi-mono-repo" [https://www.jannikbuschke.de/blog/git-submodules/](https://www.jannikbuschke.de/blog/git-submodules/) with git submodules (or alternatively git subtrees). This allows your packages to be used in multiple monorepos. It comes with slight learning curve and there are a reasonable amount of people who dislikes this approach. I however think it is fantastic.
&gt;A beginner should get comfortable with the tooling I don't disagree that a beginner might want to do that, and might even benefit from understanding what's going on, but can't he or she get started just fine *without* that? Of course, your understanding of how these systems work should be deeper than just being comfortable with the high level API. But I see nothing wrong if they don't *have to* go through initiation rites just to get an idea of what TypeScript is all about. If you're not an IDE / library / build tools designer, that is, if you're just writing business code on top of established frameworks, once your build process is automated is there any point at which you'd need to do anything more involved than editing your `tsconfig.json` file? I wouldn't be surprised if an important barrier keeping people from trying TS is them being presented with *"well, there's this command line..."*.
Thanks. The part I will have to think about is publishing. I suppose I could have separate git repos to just host the ‚Äúpublished‚Äù packages.
Since 3.4 you can use `const myArray: readonly string[];`
On mobile, so finding appropriate links is hard, but you could google the necessary flags for the typescript compiler to compile to es5, which is a spec of javascript before class syntax was introduced.
`target` is the prop. `"ES5"` is the value (or `"ES3"`, I suppose).
That blog post is wrong. It's about **readonly**, not about **immutable**. A huge difference.
An easy way to examine emitted Javascript for some Typescript input is to use the [Playground](https://www.typescriptlang.org/play/#src=class%20Hello%20%7B%0A%20%20%20%20constructor(private%20greeting%3A%20string)%20%7B%20%7D%0A%20%20%20%20greet(name%3A%20string)%3A%20string%20%7B%0A%20%20%20%20%20%20%20%20return%20%60%24%7Bgreeting%7D%2C%20%24%7Bname%7D%60%0A%20%20%20%20%7D%0A%20%7D). For example this class: class Hello { constructor(private greeting: string) { } greet(name: string): string { return `${greeting}, ${name}` } } when compiled to the ES5 target looks like this: var Hello = /** @class */ (function () { function Hello(greeting) { this.greeting = greeting; } Hello.prototype.greet = function (name) { return greeting + ", " + name; }; return Hello; }());
thank you much, I had forgotten about this, thanks for the reminder!
thank you!
excellent, thank you!
Typescript classes are just ES6 classes. There is nothing about them that is specific to Typescript (except, of course, the typing). If you are compiling to ES5, that is like transpiling from ES6 JS to ES5 JS. If you compile Typescript to es-next, the classes remain.
For practical immutable programming in Javascript and Typescript, immutable.js is great. I love having proper immutable collections!
`arr.reduce&lt;Something&gt;(`
Man, if it‚Äôs that simple, I‚Äôm gonna be kicking myself for some ugly workarounds I wrote a few months ago
Or the ever hated `array.reduce(...) as any as Something`
It‚Äôs definitely that simple üòÇ
You are technically returning `Partial&lt;Something&gt;` since in case of an empty array, the initial value is returned.
I know its not the target platform, but this website is complete cancer on mobile
Thanks, that works. There was a small error still after but with voidvector's answer, I realized that if propA is required, I needed to initialize it as well in the object. So the answer can either be: const func = (arr: number[]): Something =&gt; { return arr.reduce&lt;Something&gt;((acc, val) =&gt; { // ... }, { propA: 0 }); }; or const func = (arr: number[]): Partial&lt;Something&gt; =&gt; { return arr.reduce((acc, val) =&gt; { // ... }, {}); }; Learned two new things today!
Thanks for bringing up `Partial` - that was a huge help in understanding my problem.
Check out functional programming libraries like fp-ts.
Should not the result type be `Promise&lt;[RES, null] | [null, ERR]` so you get either result or error? If go with the try/catch way the error will be automatically re-thrown upward the global scope if you don't catch the specific cases somewhere and that's a good thing. Means you don't have to try/catch each call but only specific cases where error handling is a part of the business logic. There is a practice to process/log/alert the uncaught errors by a global catcher at the top level. There is a way to ignore the error, but you have to do that explicitly using try/catch construction. But your way is the opposite one, the error is ignored by default. So the error is not re-thrown up automatically and this approach will lead to the hard revealing bugs as if you don't explicitly handle the error it will be ignored.
Thank you, I will. Am definitely a fan of FP. This is just a zero dependency code snippet that solves a simple problem and doesn‚Äôt require adding external libraries.
That‚Äôs one way of looking at it. My solution doesn‚Äôt ignore the error, it lets you handle it locally. It is also not an absolute (not a sith) alternative, you can use it where it makes sense for you. For example axios calls from a react app where you might not want to throw but instead show the error message in a pop up or the fetched data, whichever resolves.
Is there a good solution for typing a reducer to a full interface? Given an interface with non-optional keys and an empty initial value, you need to type the reducer as `Partial&lt;T&gt;`, but by the end you expect it to be `T`. You can assert, or you can add a filter with a type guard at the end that lazily checks the keys. Is there a better solution?
There's also `purify-ts` which is much easier to get started with.
Are you using strict null checks?
Very good, there is a real demand for standard mono repo setups, especially around TypeScript projects. Commenting as a reminder to read through in depth. Good work.
Yes, strict everything.
You could pass in an initial object that implements the interface with default values. It‚Äôs still a bit hacky, but if you can guarantee the underlying array is valid or if the default values wouldn‚Äôt be hiding any nasty bugs, you could avoid the final type guard
I don't think it's possible. The reducer function needs to return `Partial&lt;T&gt;` in order to build up to `T`, but the type system has no way of verifying that you're actually adding each property of `T`. How could it know that you're not just returning an empty object (which satisfies `Partial&lt;T&gt;`) every time? What I would do is pull the code out into its own function and use an assertion in there. Then your function can be properly typed and the rest of your code doesn't have to care about what you do inside.
If I explore new Typescript project I first locate if `strict` mode is used and there are not a lot of warnings https://lgtm.com gives to me. Coding standards, patterns, and stuff alike is a general thing which lies above Typescript or any other programming language.
RxJS for sure
Blueprintjs
I'm porting my codebase over from Dart to TS and I miss almost nothing. One of the few things is that Dart allows tripple slash comments for documentation. /// My function ist really cool /// /// function coolThing(): String { } http://dartdoc.takyam.com/articles/doc-comment-guidelines/ Does anyone know a doc-that support the same style for TS?
Thanks to your post, I also learned about Partial, and Mapped types. ‚ò∫Ô∏èThanks for posting, and thanks for all the replies from folks!
The ts react starter guide from swyx had a good list (ex: formik)
Visual Studio Code is mostly written in typescript. It‚Äôs probably the biggest open source typescript project but may be very complex.
Angular and (less so now, unless you look in the 'angular' directory) Ionic. Ionic 3 used Typescript heavily which is on a different branch in their GitHub repo.
Typescript is written in typescript, so I would say its top tier project of typescript for sure
I'm using jsdoc currently. It uses block comments but I have used a tool in the past that let's you do XML style /// comments. I can't remember the name, sorry
Tensorflow bindings for Nodejs is a lot written in typeScript.
https://github.com/piotrwitek/react-redux-typescript-guide
Angular ftw! If you want to see top tier TS, Google's own devs is a good resource.
NestJS
You can sort GitHub repos by language + stars: https://github.com/topics/typescript?o=desc&amp;s=stars The projects that jump out at me right away: * [angular](https://github.com/angular/angular) * [ant-design](https://github.com/ant-design/ant-design) * [ionic](https://github.com/ionic-team/ionic) * [prettier](https://github.com/prettier/prettier)
Microsoft is the author of TS.
Some of these have been mentioned already, but these are my favorites (with links) * The [Typescript compiler](https://github.com/Microsoft/typescript) is actually written in Typescript. It's not an easy read by any means, but it is typescript written by the people that make typescript. * [VS Code](https://github.com/Microsoft/vscode) is the best editor for Typescript and is completely written in Typescript by Microsoft (who created typescript) * [Angular](https://github.com/angular/angular) google engineering is top tier and Angular is one of the largest and most mature open source TS projects in existence.
I recently modeled my monorepo setup after GitHub.com/0x-monorepo
I recently modeled my monorepo setup after GitHub.com/0x-monorepo. It was very very helpful
You can easily use Bitbucket or GitHub to host the "monorepo.' That's what they do, is host repos. As for publishing packages, you can privately host npm packages on NPM (if you pay, I think) or you can just not host them, and just use them locally to better organize your project and share code between modules (like between your server and frontend code),
Class properties outside of methods are not supported by ES.
Peertube
MobX (React state manager), NestJS (a great Node.js framework), VS Code, RxJS, TypeScript itself!
I'm pretty sure it was Visual Studio that supported xml style comments in javascript. They dropped it in favor of the more popular jsdoc.
Maybe, I was definitely using VS but it was an optional extension. It also supported regions.
Nothing about Types in this article. Haven‚Äôt looked at the others.
Just declare a function with both signatures yourself. function foo(signature1...); function foo(signature2...); function foo() { implementation... }
i can just copy it but i want to reuse it from @types/storybook__react.
love the rails view helper methods
I really don't see the benefit or the why for this approach. It's just a lot easier to make `users` possibly `undefined` but not having it optional. function List({ users }: { users: User[] | undefined }) { // ... } List({}) // Will error List({ users: undefined })
It appears you‚Äôve rediscovered Maybe/Optional! I‚Äôd recommend learning and implementing fmap and bind. They‚Äôre really useful for Maybe
Wtf is `GeneralCtor`?
Thank you, I'll take a look!
I tried such an approach but it caused me troubles when `undefined` is passed deep through the components tree. I ended up passing the wrong `undefined` and breaking the app.
It shouldn't break anything, it should cause a compilation error. Unless you don't have strict null checks enabled. I see honestly nothing positive in your approach. It just adds overhead for something that TypeScript offers already.
Since `users` is an array, you could just initialize it with an empty array to start. Null/undefined would only exist if there is code/function somewhere that produces them. (i.e. missing initialization) As others have pointed out, the non-array version is [optional type](https://en.wikipedia.org/wiki/Option_type).
Well ctor is often used as shorthand for constructor so a general constructor... But it's a type, so factory class?
I am quite intrigued by dev.to. Many of their posts seem to be from self-taught developers who are rediscovering existing patterns, such as "optional" or "null object" in this case. But, I quite like this; it is reminiscent of the spontaneity and inventiveness of early Internet communities when not everything was cargo cult.
Wouldn't it be clearer code to just have users: User[] | null
Optional type is still necessary since you want to distinguish between still-loading and actually having an empty users array.
Can you give me an example of this?
No idea what a "general constructor" would be. Some army related thing? The code in the blog post can't be tested or checked like this.
Yeah I'm just guessing that it's a base factory class or something of that nature. It's the only thing I can think of that even halfway makes that name make sense.
&gt;Null represents still loading or invalid input. Please don't do this. Don't try to assign a meaning to `null`. Alone by using the word "or" you showed already that it's a bad idea. Instead make use of TypeScripts type system. You can declare a special "loading" and "invalid state" type, and those types can even contain additional information (e.g. loading since when, what of the state is invalid). Then just use a union type to represent your different possibilities. Clear, understandable and maintainable code. No magic hidden meaning behind language keywords.
In terms of the input to `List` I think `null` is fine. The domain of the state of the component is of two classes: one class is displaying a list of users to be displayed, and the other is displaying something indicating a lack of the list. If you are handling everything but the presence of a list of users the same way it suffices to consider any falsy value as meaning that, which is usually an established pattern via if/else to handle them, and `null` is semantically most suitable. OTOH, if the component may load while a list exists, or there are multiple stated for the component when there is no list (e.g. if it needs to represent both loading and retrieval failed, for instance), then it makes sense to use a separate prop for them.
Mixin in TS is total crap. TS forces you to write a helper function + some default implementations in the base classes. OMG! This is a job which should be done by the compiler. In my opinion the way this is implemented is a far more a hack than a language feature.
You're looking for: `type BK = keyof typeof B`
Here's how you can accomplish that: export const myStoriesOf: storiesOfType = function myStoriesOf&lt;T&gt;( ...[name, module]: Parameters&lt;typeof storiesOfOrig&gt; ) { ... }; `name` and `module` will be inferred correctly based on what storiesOfOrig expects
That's one of the ways of representing "still-loading", not the only way. Loading is application specific: * A separate loading state variable - it can capture error / progress as well * A row property - so you can capture row level loading logic * Promise - for naive implementation
It looks much more elegant when you turn helper function into decorator, but yea necessity of default implementation hurts.
&gt;This is a job which should be done by the compiler Exactly. There have been many, many proposals about awesome features like a proper Mixin handling that ONLY impact the compiler (outputted JS staying the same) but for some reasons, most of them all get rejected. I think that's a shame because TS is a fully-fledged language already. There's no point in staying so close to ES specs. I doubt anyone using TS actually cares about the outputted JS, they just want to use TS. The amount of closed proposals on the TS repo is so frustrating. At least if they could allow [custom compiler plugins](https://github.com/Microsoft/TypeScript/issues/14419), we'd be allowed more freedom for our use cases.
`const B` is a value, not a type. Class on the other hand defines both, a type and a value.
Doesn't `any` mean "turn off type checking"? As a understand it, once you add it to an expression everything downstream is also `any`.
One TS rule: anything that involves `any` always return `any`.
Intuitively i felt that the &amp; operator limits the type to the possible types that intersection. Which is how it works as long as it doesn't involve any. Any, the plague of typescript.
I think your problem isn't with the &amp; operator but with any. You need to understand that once you set something to any &amp; WhatEverType that it doesn't matter what other type you added to your type. Any is a top type means it contains all other possible types. So yes your AB type could be set to {b: number} but it could as well be set to function, or string, or whatever. So you can reduce any &amp; B to just any since B is already contained in any.
AB does satisfy the constrains of B because any includes {b: number} in itself too. In fact, if the result was anything other than "any" the constraints of A wouldn't be satisfied, so the logic is completely consistent in that sense.
I do understand how it works. I just find that it is inconsistent. &amp;#x200B; When we don't involve "any" the &amp; operations uses Intersection If we look at the second example I gave, we can view the type string | undefined as the set of types: {string, undefined} but when we do { string, undefined} &amp; {string} we get the intersection which is simple {string}, hence: &amp;#x200B; type S = (string | undefined) &amp; string; And S is equal to string. &amp;#x200B; When "any" is involved though now we don't limit the set of possibilities. What I would of expected for consistency would be this: type A = any; type B = {b:number}; type AB = A&amp;B === type {\[key:string\]: any, b: number}; &amp;#x200B; Am I the one with inconsistent logic?
The difference is. You didnt say something like type a = {a: any} but you set the type to anything possible.
Perfect explanation!
It's true it could be a function. Anyways. I don't really see a way out. I just have to deal with the fact that any means any, and that I can't limit it in the way that I want. Gotta find other crafty ways to make work this type system.
&gt; Intuitively i felt that the &amp; operator limits the type to the possible types that intersection. &amp; is not intersection, &amp; is *union*. If you take the union of anything with `any` the result is always `any`, because `any` encompasses every type.
It's not exactly union. In the first example, the type that satisfies both A and B is the union of The properties of A and B. But in the second it intersects the properties of types. Type S = string &amp; string | undefined results in the intersection which is just string. Not the union. I can't help but feel that they made the operator needlessly confusing. I know how to use it mostly. But it doesn't make things easy to reason about.
Please, format the code...
I think you're right. This is what I would have expected as well. It seems that &amp; usually does intersection on the types of each property, but does union on the list of properties itself. Your example breaks this pattern.
Sorry about that...
What is `routeOptionExamples`?
You want `unknown`, not `any`.
I'm not sure what you're trying to do. Wouldn't it make more sense to export a `Router` from your module and `app.use` all your routers in your server script?
Thanks. Wow. That seems to actually solve everything.
export enum routeOptionExamples { '/getData' = './getData', '/testingRoute' = '/testingRoute', '/userInput' = '/userInput', '/helloWorld' = '/helloWorld' } Ah, my bad i should have included that as well, it's a simple enum for the possible routes. They're all toy examples because i'm just getting into Express with TS and so am just doing baby steps. The reason for it is i thought it'd be nice to clarify all my potential routes in an enum first so that i can get intellisense, more of a sanity check for having a better sense of what my options are. I was looking for regex or string template types so that i could do something like ... type potentialRoute = \`/${nameOfRoute : string}\` , since the / before the string is more specific than just a general string. But it looks like that's not supported yet, though would be an awesome feature. I thought an enum would be the next best thing. Do you think there's merit there, or overkill?
Thank you for your suggestion, yes i think your idea makes more sense and one that i should look into... But it poses a more general question that is still valid to me, can an interface support a Class.method? Sorry for the naive question but i haven't seen that yet ,interfaces that start on a general object and then drill down into specific methods or properties. Thank you for your insight.
Ah! I just noticed a mistake, my first enum option has an accidental dot . in front of the route.
It's an escape valve. C# has it too, but we call it `dynamic`.
There isn't a particularly strong and consistent theoretical story for this. TypeScript's development significantly predates the research of set-theoretic types with \`any\`, which do not follow this approach. &amp;#x200B; The approach in TypeScript is simple but internally consistent (for the most part). The dynamic type \`any\` is essentially a taint of 'unsoundness', and it should not be possible to remove that taint through type operators. Composing something that is unsafe with something that is safe yields something that is still unsafe, which is why \`any\` is effectively the NaN of types (or a no-op).
Thank you for this response. It makes more sense to me. Also someone put me on the track for the unknown type which works more like I expected any to work in this example.
It is what it is, you won‚Äôt easily sway them into migrating the legacy code right out of the gate. So instead, make sure you write actual typescript code in the new stuff. I mean, don‚Äôt write a bunch of jquery in a typescript file, for example. Brush up on using typescript in react. Typescript is lovely to use so I hope you enjoy it!
If you have to integrate with the JavaScript code, see if management is fine with adding type definition files (.d.ts) for the legacy code. It can be done incrementally, too; no need to type everything right out of the gate. Just definitions of commonly used APIs, and/or type / interface declarations for option parameters.
Wouldn't this cause issues if you wish to fire-and-forget? Maybe a better rule would be "all async functions must contain at least one 'await'"?
It's enforced by the return type of the async function. An async function always returns a Promise, so if you don't use await, the return type will be Promise and not whatever value you expect.
Not that I know of. There are situations where you *don't* want to await. You want to store a reference to the promise, or pass the promise somewhere else. So you'd need a nice way to indicate those situations. I guess you could use the standard linter comments, or some wrapper function like `P(asyncFunction())`. (`const P = (a) =&gt; a;` but the linter special-cases it to indicate lint rule suppression)
I can suppress lint errors in the case of fire and forget. The reverse is a bigger disaster IMHO
The function returns void
This is so very important for your sanity. I've finally managed to have this prioritised after 13 months in this job.
If it's an async function, it returns Promise&lt;void&gt;.
I think you're looking for [https://palantir.github.io/tslint/rules/no-floating-promises/](no-floating-promises).
Add //tscheck as comments in legacy code. It'll help at least identify errors in those parts without need for migration to Typescript.
I've had some success in parsing the linter error output to create to specific "make-error-a-warning"-like comments for each file that failed the lint, and then whenever revisiting that code, you knew what was up right at the top of the file and could re-enable the lint for that file (and that file only) at will
This exercise in itself will at very least force you to understand the legacy code, warts and all
Think of it like infinity. +1 and -1 don't really affect it.
A few tips having done this a few things. - Don't start porting shit willy nilly. You will break stuff and you will lose some "capital" that affords you future attempts. - Write type declarations for modules you can't port yet. When the time comes to port it, it'll be much easier to do it with type declarations in place. - Convert tests, if you can; this will be a psychological win as well as a pragmatic step to building out those type declarations - When you do port things, create a process for the team to use oriented around preventing substantial runtime changes. In other words, don't do things like convert a block of code to a class or vice versa. Don't convert a bunch of things to arrow functions. Don't do refactoring *in general*. Just do the bare minimum to get the TypeScript file to compile and get it merged. Refactoring can come later. - You need to listen to your team, especially folks that haven't used TypeScript as much, and figure out their pain when it comes to tooling or dev experience. If this pain goes unresolved, people will eventually resent TypeScript in their project and will imagine that it would just be so much simpler without it. TLDR: Make practical, low risk changes. Listen to what people are saying about those changes and make sure they're are seeing value from TypeScript.
Not the same but this might work for my case
Better to pair with [await-promise](https://palantir.github.io/tslint/rules/await-promise/).
What is the reason \`strictNullChecks\` flag has been explicitly turned off?
`&amp;` is intersection, `|` is union. Union and intersection with `any` both result in `any`.
The proper way now is `as unknown as X`
It's not `&amp;` that you hate, it's `any` ‚Äî it violates the normal rules of types. Read up on [) and [bottom types](https://en.wikipedia.org/wiki/Bottom_type) and you'll realize why this is so weird. A [top type](https://en.wikipedia.org/wiki/Top_type) (`‚ä§`) contains every possible type. It consumes everything in a union (`‚ä§ | T = ‚ä§`) and is consumed by anything in an intersection (`‚ä§ &amp; T = T`). In TypeScript, the most common top type is `unknown`. A [bottom type](https://en.wikipedia.org/wiki/Bottom_type) (`‚ä• `) contains no other types. It is consumed by anything in a union (`‚ä• | T = T`) and consumes everything in an intersection (`‚ä• &amp; T = ‚ä• `). In TypeScript, the most common bottom type is `never`. So why is `any` so weird here? It's both a top type **and** a bottom type! It encompasses every possible type ‚Äî and yet at the same time, it represents no types at all. The weird intersection behavior is because in this case it acts as a bottom type. I think the reasons it acts this way have to do with [covariance and contravariance](https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)), but that's a whole other topic. Most of the time you should just do what the sibling comment suggested and use `unknown`.
Who's going to stop you from migrating the legacy code?
VSCode does it fine. &gt; type Cat = Lion // on mouseover
I would start by asking for a plan! Surely if they are using Typescript, they realize working with plain JS is a chore and more error prone! If it's code no one works on, then who cares. But If you think it's worth porting, then I would do it with someone who is familiar with their tooling. I've ported over 20 repos and the best way to do it is just convert js to ts files and don't use strict (which is still much better than plain js). If you write a .d.ts file or generate some files from .ts files into the normal js files, it's easy to forget and get out of sync. If you know what you're doing and are ok with forgoing strict, you can convert a codebase in a few hours or less, and add types iteratively as you work on the code.