That's why I asked before: &gt; Are you sure your tsconfig is used? And the corresponding documentation: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html - section "Using tsconfig.json".
So you are writing everything by hand and not generating anything from the code and comments?
Dart 2.0 was just released.
I see TypeScript as the documentation generator. When TypeScript code gets compiled, it saves the doc strings attached to the specific nodes in the AST, then inserts it into the produced \`.d.ts\` files. Doing jump-to-definition goes right to this generated document. I'm not sure what anybody needs outside of this, tbh.
I use TypeDoc. Its not perfect and it has a lot of problems but its easy to generate and include in a CI process to automatically upload to something like GitHub pages. I'll also have an examples folder (usually containing some minimal viable working example) and a README detailing some more high level things like motivation. https://github.com/TypeStrong/typedoc https://docs.travis-ci.com/user/deployment/pages/
Are you able to use external markdown files with it? In the documentation it says you can do so with ‘—include’ and ‘[[include:FILENAME]]’ but they seem to not work..
Unless I’d ve writing some big toolkit lib like a new lodash I wouldnt mind automated docs. You may check what the famous libs (ex: jest, react) are using but actually quite most them seem to handcraft the docs. Immutable.js uses automated jsdocs i think, but it quite suites that kind of library.
I have never used it, but I would not be surprised if it did not work. Again it depends on what you are doing, but in the case of GitHub pages, it will automatically render markdown files as HTML, so you should only need to link to the files. TypeDoc should also grab in your README.md and make that its front page too. Also worth noting that it doesn't really detect what is publicly available versus what is not so you'll have to add an exclude flag above all exported functions you don't want to be seen.
This gives me an idea of how we can go even further than this. You can use keyof to specify the keys on a whole object (like the `fs` module). If we can figure out how to "rename" a key in TypeScript, this will give us the ability for actual type-safe promisifying!
Dart is a a Google project so it's likely to be deprecated literally any day. Google is a kid with ADHD when it comes to new projects.
Yeah, I'm pretty sure that this is a bug with nyc because I tried switching from Jest to Mocha and had the exact same bug re-appear. Surprise, surprise - both of them use nyc under the hood.
Well no - Jest uses (I think NYC) under the hood.
Dart is also an open source project, so if it has any reason to live, it'd continue doing so.
I see. Obviously, I had no clue that it wasn't. ;) Thanks!
The link: [https://madnight.github.io/githut/#/pull\_requests/2018/2](https://madnight.github.io/githut/#/pull_requests/2018/2)
I can't believe Go is growing faster.
I'm too busy playing with typescript to learn go! 
Thanks. It seems obvious now that I see it. Actually I was hoping there was a crazy easy way like `function test&lt;T&gt;(l: T): void {` and calling it with one type. That doesn't appear to work but `function test(l:IHiJson) : void {` does
Typescript can infer the type of j. However, if you define the test function as `function test&lt;T&gt;(l: T): void {` then the problem is T could be anything including primitive types which clearly do not have a name and data property. This is why the second example narrows the type variable to only things that are structurally similar to IHiJson.
I can't believe Go is even used at all, lol no generics, lol if err != nil, lol pause times are the only things that matter.
Sounds interesting. Can you please give me some details. How do you run jsdoc on compiled js?
https://github.com/yamdbf/core This is the project in question. I have an npm script for running jsdoc over the compiled JS. I compile the project with gulp. If you look at any of the files in `src/types` you can see what I was talking about regarding documenting types and having to keep the documentation block from touching the compile-time construct. I've toyed with tsdoc on a couple occaisions, and its great for what it is, but it doesn't really seem to fit with how I've structured this project. It just kind of populated everything under global, it's really weird. But jsdoc seems to accomplish what I want, and I have a fairly heavily edited (hackishly so) jsdoc template for my [docs site](yamdbf.js.org) that ties it all together.
I don't think you can do quite this, because if you did for example: const input = Array.from(document.querySelectorAll('div')). map(x =&gt; x.textContent); myfunc(input, "hello"); There is no way the typescript compiler could guess what the elements of `input` might be. However, for completely static arrays, you can pass it as the type parameter: function myFunc&lt;T extends string | string[]&gt;(item: Flatten&lt;T&gt;) { // Snipped } myFunc&lt;["hello", "world"]&gt;("foo") // bad myFunc&lt;["hello", "world"]&gt;("hello") // ok You could even do: type ValidInput = ['foo', 'bar']; const input2 = ['foo', 'bar'] as ValidInput myFunc&lt;ValidInput&gt;('bar'); // ok myFunc&lt;ValidInput&gt;('hello'); // bad myFunc&lt;typeof input2&gt;('foo'); // ok myFunc&lt;typeof input2&gt;('hello'); // bad But in that case, you might as well just do: type ValidStrings = 'hello' | 'world'; myFunc&lt;ValidStrings&gt;('foo'); [TSPlayground link for better highlighting](https://www.typescriptlang.org/play/#src=type%20Flatten%3CT%20extends%20string%20%7C%20string%5B%5D%3E%20%3D%20T%20extends%20string%20%3F%20T%20%3A%20T%5Bnumber%5D%3B%0D%0A%0D%0Afunction%20myFunc%3CT%20extends%20string%20%7C%20string%5B%5D%3E(item%3A%20Flatten%3CT%3E)%20%7B%0D%0A%20%20%2F%2F%20Snipped%0D%0A%7D%0D%0A%0D%0AmyFunc%3C%5B%22hello%22%2C%20%22world%22%5D%3E(%22foo%22)%0D%0A%0D%0AmyFunc%3C%5B%22hello%22%2C%20%22world%22%5D%3E(%22hello%22)%0D%0A%0D%0Aconst%20input%20%3D%20%5B'foo'%2C%20'bar'%5D%0D%0A%0D%0AmyFunc%3Ctypeof%20input%3E('bar')%3B%0D%0AmyFunc%3Ctypeof%20input%3E('hello')%3B%0D%0A%0D%0Atype%20ValidInput%20%3D%20%5B'foo'%2C%20'bar'%5D%3B%0D%0A%0D%0Aconst%20input2%20%3D%20%5B'foo'%2C%20'bar'%5D%20as%20ValidInput%0D%0AmyFunc%3CValidInput%3E('bar')%3B%0D%0AmyFunc%3CValidInput%3E('hello')%3B%0D%0AmyFunc%3Ctypeof%20input2%3E('foo')%3B%0D%0AmyFunc%3Ctypeof%20input2%3E('hello')%3B%0D%0A%0D%0A%0D%0Atype%20ValidStrings%20%3D%20'hello'%20%7C%20'world'%3B%0D%0AmyFunc%3CValidStrings%3E('hello')%3B%0D%0AmyFunc%3CValidStrings%3E('foo')%3B%0D%0A)
[TypeScript 2.9 added a --resolveJsonModule flag](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html), which will extract some basic type information from JSON. I've never used it, but you may be able to leverage it to get typed JSON in your tests if you import it.
That's pretty awesome
&gt; To format code properly on Reddit: Woops, sorry about that. I was posting from the new Reddit design with markdown. Looked fine there but now that I see it on mobile it's all goody. I understand what you're saying about the `string[]`, that makes sense. I've been stuck on TS 2.4 until the last week, so I wasn't sure if the newer conditional types made it possible to pluck out the literal string values from arrays. Oh well, it would have been something nice to have for package consumers but it's not super critical. 
Thanks for explaining that! I'm writing a package and wanted to do something similar to what I wrote in the OP, but since I don't know what the input strings might be I can't do static arrays. I was hoping it was possible to pluck out the string values with conditional types, but this at least confirms that it's not possible for now. Luckily package consumers could still define their string types if they wanted to, so it's not the end of the world. Thanks again!
&gt; literal string values from arrays. That's the common misconception. Values and types are different. It's possible to pluck out string literal types, but it's not possible to pluck out values - as values can be **any** string.
lol I think lol he is lol referring lol to the lol garbage collector tuning lol but I can't be sure lol because he wrote it lol like an 8th grader lol.
Just realized that I can do something like this: type Omit&lt;T, K&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; type Test = Omit&lt;SendMessage, 'chat_id'&gt; &amp; {chat_id?: ChatID}; Basically remove `chat_id` from `SendMessage` and then add it back as optional. Still, looking for more elegant solution if possible (right now I have to manually write property and its type).
Use `Pick&lt;Partial&lt;T&gt;, 'chat_id'&gt;` to make the prop optional. Then wrap the whole thing up as a `MakeOptional` generic.
Go was made to compete with C for safety and iteration speed, and Java/C# and Python for performance, simplicity, reduced runtime dependency, and GC latency. It more or less succeeds in those regards. As a long time C# dev, I could have seen myself occasionally using Go if C# hadn't moved to .NET Core.
Solution: type Overwrite&lt;T, K&gt; = Pick&lt;T, Exclude&lt;keyof T, keyof K&gt;&gt; &amp; K; type Test = Overwrite&lt;SendMessage, { chat_id?: ChatID }&gt;; Allows to override any amount of types (if I'm not missing something).
Came up with [this](https://www.reddit.com/r/typescript/comments/95l6ml/any_way_to_make_particular_fields_optional_in/e3tiew1/).
Go and TS are my 2 preferred backend languages! I must admit, Go has been favored lately. 
&gt;That doesn't appear to work That should work. The problem is probably that you didn't define what type `j` is, so it defaulted to just an Object. You can set an Object's name to a number and data to a string. If you were to define `j` as `IHiJson`, you'd be telling TypeScript that those changes are invalid, and then you would see the error you expect. By default, they are perfectly valid, so there is no reason TypeScript would throw an error.
This is the entire source code: ```typescript export type TJsonValue = string | number | boolean | null | TJsonArray | TJsonMap export interface TJsonMap { [key: string]: TJsonValue } export interface TJsonArray extends Array&lt;TJsonValue&gt; {} export const jsonParse = (str: string): TJsonValue =&gt; JSON.parse(str) export const jsonStringify = (value: TJsonValue): string =&gt; JSON.stringify(value) ``` What problems does it solve? It's not actually validating the types at runtime. It doesn't even validate types. Usually when you get JSON data, it's type is `any`, and you can still get it wrong by assigning an array of numbers to a string. Here, you've just moved that layer into your library and hid it from the developer using it.
I suppose this could be used with type guards to decode to specific types. Something like this: const result = jsonParse('[1, 2, 3]') if (Array.isArray(result)) { const numbers: number[] = result.filter((x: any): x is number =&gt; typeof x === 'number') } else { throw Error } 
in my opinion it's still better than `{ [key: string]: any }`
it helps when you have a deep structure, it's yours, but you don't know exactly what's inside, but you know for sure that it's going to be send as JSON. instead of using something like `{ [key: string]: any }`.
You can also check [Typed JSON parse and stringify for TypeScript.](https://github.com/deepsweet/typeon) out.
I was thinking the same... `const x: MyType = JSON.parse(data)` seems enough... If I parse something then I know upfront what I expect and thus can have a type for it... And if I don't have any, I'd better use `unknown` (TS 3.0)
Better make a real type representing what you'll parse...
No, it doesn't help anything. Not trying to be rude, but it's actually worse than keeping it typed as `any`. At least with `any`, you know that you still need to place your expected shape over it. Your code gives them a very, very thin version of that shape, and if they want to go any further than that, they have to replace it with another shape (custom interface).
It happenes because this: const input = ["hello", "world"] is inferred to be of type `string[]`. TypeScript _widens_ the type of some _concrete_ strings into _any_ strings. To make it type safe, you need to tell TypeScritpt their literal types should be preserved. type AllowedKeyword = | "hello" | "world" const input: AllowedKeyword[] = ["hello", "world"]; Complete solution: type Unboxed&lt;T&gt; = T extends (infer U)[] ? U : T; function myFunc&lt;T&gt;(input: T | T[], item: Unboxed&lt;T&gt;) { // Snipped } type AllowedKeyword = | "hello" | "world" const input: AllowedKeyword[] = ["hello", "world"]; myFunc&lt;AllowedKeyword&gt;(input, "foo"); // Fails (correct) myFunc&lt;AllowedKeyword&gt;(input, "hello"); // Works (correct) myFunc&lt;AllowedKeyword&gt;("hello", "world"); // Works (correct) myFunc&lt;AllowedKeyword&gt;("hello", "foo"); // Fails (correct) 
Go was made because the developers who wrote it are good at making languages, but working at Google they had to write servers using C++. And being language people, they hated C++. So their solution was to write a language that let them write servers using something that's not C++ (or Java).
&gt; Go definitely has it's uses No, it really doesn't. In 99% of cases, Java 10+ is a better choice than Go. In the other 1%, C++ is.
Bit late, but don't let java experience confuse you, classes are noise unless you have a strong case for them.
Can you enable inlineSources and disable inlineSourceMap?
Probably a better idea to use ```{chatId? SendMessage["chatId"]}```
Nope, inlineSources requires inlineSourceMap to be enabled.
Yes, Nashorn allows to ingest dynamically, without any restart or refresh. You can also see it in the video, where I'm publishing the script and in the next step I'm configuring it in the JIRA. If the script would already exist and if I did republish, it would only refresh the script, no additional steps would be needed. As far as I know, Nashorn does not have a proper sandbox mode. So technically script writers could access classes that you didn't intend to give access to. In case of JIRA, it is a good thing, as there are simply so many APis and stuff, it's best to give keys to the whole kingdom, rather than start white listing APIs. Nashorn has some API limitation, you can read about it [here](https://stackoverflow.com/questions/20793089/secure-nashorn-js-execution). I guess if you did use the IntelliSense the same way as I'm doing it, then you can only include APIs you intend to publish, that way script writers can easily use those APIs, but it won't stop them trying to do something nasty. If you are running on .NET platform, then MS has equivalent runtime for JavaScript called [ClearScript](https://github.com/Microsoft/ClearScript), and this one should have proper sandbox mode. And if you want to provide keys to the kingdom you have to explicitly configure it to do so. 
No set date, but we're thinking about it
Isn't Nashorn deprecated and about to be removed soon?
Heads up, Nashorn is being deprecated and being replaced by this stuff: https://www.graalvm.org/ You may want to see if your stuff can work with that.
Good point, I haven't tried it yet. But technically as I'm not using any of the Nashorn added features in terms of additional syntax for JavaScript, exception being Java.type (which looks to remain the same), then Graal should be able to continue executing JavaScript in the similar manner.
It's still React after the conversion. Magic!
&gt; Does anybody know to change the project type from node.js to typescript? If you already have a Nodejs project in Visual Studio, this is simple. Open up your \*.njsproj as a regular xml file. Search for the `&lt;/NodejsPort&gt;` tag. On the line below it add` &lt;EnableTypeScript&gt;true&lt;/EnableTypeScript`\&gt;. Then open up your solution, right click on the project and select "Properties", and you should be able to set a few typescript options. I found this by creating both a ts and a js project, and doing a diff between the generated \*.njsproj files.
Sorry but this isn't an issue with NPM. NPM literally just runs the commands you specified, something somewhere in your config is wrong
This. This is the solution. Thank you so much. 
I dont have a use for this right now, but this is truly incredible. 
Originally TypeScript can not acquire type information, but I noticed that by creating type information in DSL, we can do the same thing as reflect by generating the type of TS from there 
In the case of the JSON schema, it is not possible to check that the schema and type are the same, which causes a bug However, you can prevent such bugs by generating types from type information
Sure, that's great and useful in some cases. It's just not reflection.
 I will study the definition of words Thank you for teaching me
This is not reflection, but it is very interesting anyway so here comes my upvote.
DSL?
Domain specific language
Reflection can also be taken to mean "compile-time reflection", as a [quick Google search](https://www.google.com/search?q=compile-time+reflection&amp;ie=utf-8&amp;oe=utf-8&amp;client=firefox-b-ab) clearly demonstrates. See for instance [https://root.cern.ch/blog/status-reflection-c](https://root.cern.ch/blog/status-reflection-c) and [http://pfultz2.com/blog/2012/07/31/reflection-in-under-100-lines/](http://pfultz2.com/blog/2012/07/31/reflection-in-under-100-lines/), which refer to compile-time reflection as just reflection.
/u/kgtkr this webpack plugin I made might be of use to you [https://github.com/Objectivco/ts-class-meta-generator](https://github.com/Objectivco/ts-class-meta-generator) It takes all the classes (recursively) in a folder and associates them with a "global" object. This allows for referencing classes via strings. Not sure if it would be useful for you or anyone else but its nice to be able to instantiate classes via string in your code. Use case for me was dynamic context generation from the back end to the front end. I couldnt find anyway to do it with the current versions of TS
Have you taken a look at [fp-ts](https://github.com/gcanti/fp-ts)? Here is an explanation of how he constructed higher kinded types. https://github.com/gcanti/fp-ts/blob/master/HKT.md
Example output: [https://pastebin.com/yAqYB3r2](https://pastebin.com/yAqYB3r2) I had a use case where we needed dynamic class generation post compile time and it seems unless you specifically tie the objects manually to something you can access via an array you cannot just simply new "ClassName". This webpack plugin analyzes a folder directory and generates the class hooks to a main object. This way you can just do new Site\["ClassName"\](). We pass a context from the backend to the page in question which generates a class based on that context name "FrontPageActionSet" or "SingleProductActionSet" would be an example. Instead of having to manually make these associates it does it dynamically. Like I said, not sure if there was a better way to do this but I couldnt find any way of instantiating classes via strings in TypeScript.
I'm off of work here in like an hour let me download the google maps api / types and give it a go and see if it helps. I think I understand the problem, but im not 100% sure if this will help. I will see if I can create the same scenario. Are you trying to just create a child class from the main google class? Is there a repo I can take a look at of your project?
you most certainly can [https://github.com/wdunn001/angular-google-maps](https://github.com/wdunn001/angular-google-maps) the code involved creation of custom overlays The relevant code to the issue is [https://github.com/wdunn001/angular-google-maps/blob/master/packages/core/directives/custom-marker.ts](https://github.com/wdunn001/angular-google-maps/blob/master/packages/core/directives/custom-marker.ts) and [https://github.com/wdunn001/angular-google-maps/blob/master/packages/core/services/managers/custom-marker-manager.ts](https://github.com/wdunn001/angular-google-maps/blob/master/packages/core/services/managers/custom-marker-manager.ts) and line 79 of [https://github.com/wdunn001/angular-google-maps/blob/master/packages/core/services/google-maps-api-wrapper.ts](https://github.com/wdunn001/angular-google-maps/blob/master/packages/core/services/google-maps-api-wrapper.ts) essentially I am passing the overlay to the api wrapper and building the class once google maps is ready. but the problem is I can't then go back and reference that class in the custom-marker manager because I cant declare an object of that type until after the map exists so I use &lt;any&gt;.
Haha just saw this too. Ill give it a look!
Actually unfortunately from what I can find i'm prob going to have to do the exact same thing you are doing. Not quite sure why google structures their classes this way. Pretty retarded.
&gt; m what I can find i'm prob going to have to do the exact same thing you are doing. Not quite sure why google structures their classes this way. Pretty retarded. ah well thanks for taking a look
No problem! Sorry this wasn't much help for you
The incoming parameters does not have any typeinfo. Try adding :string after stateName
I did not know that it already existed；；
I couldnt get what is this supposed to do. Auto generate typings from javascript?
I've update the script just now. The only remaining problem for me are rest parameters (types that somewhere have the form `[T, ...R[]]`). All other things seem to work fine. If you find any problems, feel free to point that out and if you can solve rest parameters, I would really appreciate that.
Maybe using \`namespace\` solves your problem? My guess is that you are using TS in a codebase without modules (i.e. you are not using webpack and top-level imports/exports). \`namespace\` is an old TS construct that is meant to help organizing module-less codebases. If you feel that you are writing a module system yourself (checking for existence of global classes is a sign of that) maybe it is time to switch to modules and webpack...
What in particular needs more explanation?
A tuple is implemented as an array. So a tuple of `[string, number]` will always have a string at index 0 and a number at index 1. But since it's an array, it could have an element at index 2 or beyond. For those elements, the type is a union of the earlier types.
This library bundles its own types. You don't have to download them yourself. They should just work.
Thanks!
No I don't think that quite solves it. I am familiar with namespacing. The issue is, is that if you do not pull in the definitions you need into the class structure where the rubber meets the road so to speak the class definitions are not available on the JS output side. I guess I could pill every possible definition into the context class but that goes back to the original problem of having to know about every possible class on runtime which brings it back to the same issue. I'll try namespacing again tonight but I'm pretty sure like the first time around I ended up manually defining what was needed which defeated the purpose. Thank you for your I put
Yeah Ts namespaces are merged when declared with the same name, they also allow nesting (namespace A.b.c) and they do some magic for acessing variables inside them. It brings help in structuring “webpackless” projects, but they wont require files for you. TS has also outFile which provides some sort of bundling functionality, but that is sorta not recommended
Fair enough I'll try it out here in a bit and let you know the results! Just looking to bring a little sanity to this massive project
Or `undefined`.
Well. You might always get an undefined out of an array if you index beyond the length of it. But it will not be typed that way. Apparently, that was deemed too annoying to deal with. 
There are three main ways you get types. 1. Library itself has a .d.ts file and will work right after installing it. 2. Library doesn't have typings and you have to download them by `yarn @types/package-name`. 3. Library doesn't have typings nor community created one. You are either out of luck or need to create your own.
Top is a function that returns a function (that return void), bottom is a function (that returns void) 
&gt; Are those interfaces similar? **No.** The first one is a function that returns a function, the second one is a function that returns `void`. &gt; how are they implemented? [1](https://www.typescriptlang.org/play/#src=interface%20ILogger%20%7B%0D%0A%20%20()%3A%20()%20%3D%3E%20void%0D%0A%7D%0D%0A%0D%0Aconst%20logger%3A%20ILogger%20%3D%20()%20%3D%3E%20()%20%3D%3E%20undefined) [2](https://www.typescriptlang.org/play/#src=interface%20ILogger%20%7B%0D%0A%20%20()%3A%20void%0D%0A%7D%0D%0A%0D%0Aconst%20logger%3A%20ILogger%20%3D%20()%20%3D%3E%20undefined)
Not to mention pointless - unless you also want to prefix your class names with `c` and your variable names with `v`
&gt; it look really ugly. As a c# developer I think it looks better that way the implementation just drops the `I`. However interfaces and classes are used differently in TS so I can see the difference in convention. 
I didn't know you could use `()` to define an interface as a function. Learned something today. Sometimes JS/TS really frustrate me because you can do things in so many ways. It makes consistency on a team really difficult.
Exactly. One of the many gotchas in TypeScript where the more sound and robust type-system was deemed "too annoying to deal with".
I try to avoid indexing arrays at all. Or I type them as containing string|undefined manually. Any other gotcha you had in mind?
Depends on the project. All of vscode uses this convention and it is clean. Typescript seems to use it whenever there might be multiple implementations. Also pretty clean. 
- Spreading a `Partial&lt;T&gt;` results in a `T`, despite values potentially being `undefined`. - Indexers may return `undefined`. - Indexer can be used to assign wrong type to well-known properties of indexed types. - `Cat[]` is assignable to `Animal[]`. To name a few.
I can't' agree with you, see here: [https://github.com/Microsoft/vscode/blob/master/src/vs/vscode.proposed.d.ts](https://github.com/Microsoft/vscode/blob/master/src/vs/vscode.proposed.d.ts) [https://github.com/Microsoft/vscode/blob/master/src/vs/vscode.d.ts](https://github.com/Microsoft/vscode/blob/master/src/vs/vscode.d.ts) Interfaces without I prefix, conclusion? Vscode is HUGE project with not pretty clean code... by the way... see TypeScript Coding guidelines: [https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines](https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines) "Do not use "I" as a prefix for interface names."
I guess you missed the text at the top? STOP READING IMMEDIATELY THIS PAGE PROBABLY DOES NOT PERTAIN TO YOU These are Coding Guidelines for Contributors to TypeScript This is NOT a prescriptive guideline for the TypeScript community
I agree, but a linter would probably help with that a bit
Looks like they have to add another header :D
&gt; Though less so than when people do InterfaceImpl. That upsets me to no end. That's the worst I agree. &gt;My issue with this is the interface name should tell you what it is and the implementation should tell you how. I get where you're coming from. I find that the majority of interfaced design has two implementations: the 'real' one and one for testing. So it's `IDataFetcher`, `DataFetcher` &amp; `TestDataFetcher`. Again, I'm coloured by C#.
Hungarian notation.
Hungation. *** ^(Bleep-bloop, I'm a bot. This )^[portmanteau](https://en.wikipedia.org/wiki/Portmanteau) ^( was created from the phrase 'Hungarian notation.'. To learn more about me, check out this )^[FAQ](https://www.reddit.com/78ilq0).
[removed]
"The" implementation? You shouldn't even be using an interface unless there's going to be more than one implementation.
Hey sorry it took me a day later than I said to get back to you. So I tried everything according to [https://www.typescriptlang.org/docs/handbook/namespaces.html](https://www.typescriptlang.org/docs/handbook/namespaces.html) with no dice. It actually doesn't even seem to work anymore. So either I'm doing something intrinsically wrong or I'm not sure to be honest. I'll just dump everything I did out here and let people be the judge. Step 1: Follow everything according to the split file namespace guide of the link above. I have a folder called TestSet and inside I have 3 files: TestSet, ATestSet, and BTestSet. All are wrapped in the namespace TestSet with ATestSet and BTestSet having 2 exported classes (respectively named after the files) and an exported function in TestSet.ts Screen shots are here: [https://imgur.com/a/niMBAkU](https://imgur.com/a/niMBAkU) (It's an album with 3 images) In my Main.ts file I reference them all like so: [https://imgur.com/a/06SvZY6](https://imgur.com/a/06SvZY6) I console.log above the class declaration, I've also tried it in the constructor (Doesn't make a difference). No matter what I do I get this error on the page during runtime: [https://imgur.com/a/WSzGgpg](https://imgur.com/a/WSzGgpg) I have tried alternative things as well like exporting the namespace, importing the namespace and assigning it to a variable. I tried assigning the namespace to a variable. No matter what It seems to not know what to do with any of it. While my IDE recognizes it and the compiler happily compiles it. It does not work. I was really hoping to retire the code I wrote, but it seems namespacing is not a solution here either. /u/scaleable I would love your feedback on this if you have time. If not I might make a new thread asking for help because I am following the docs pretty closely unless I am missing something really obvious. It's really strange
I've never been a fan of that whether tbh
Me neither, see edit.
I mentioned two: one for 'real' use and one for testing.
Ok here we go again! ## javascript modules (skip if you already know it) When you write "vanilla" JS in browsers, you store variables in the global scope (which is the "window" object). Example: jquery adds "window.jQuery" and "window.$" when you run it. Later when node.js launched it adopted and made popular something called "commonjs modules", which roughly means: each file has a separate scope. If you declare "var a = 0" in a file, "a" wont be available in the other files. On "commonjs modules", in order to use a module you have to call "require('./module')" to read from the same path, or "require('module')", which reads -- by convention -- from the node_modules path. And you also need to export public variables through "module.exports = ...". On node.js when you write "require('express')", it wont just read express, but will also load aaalll of the things express requires, recursively. When I say "module system", I'm mostly talking about this functionality. `&lt;script&gt;` tags arent really a module system because they can't do that (you have to manually add every dependency, ex: materialize asks you to add jquery script tag). **summary:** there are 2 ways of writing javascript, with and without modules. ## webpack Next whats webpack's main purpose? Browsers DONT have modules at all. Webpack converts a "module-y" javascript file into a browser-friendly javascript -- or actually, it figures out all of the requires and concatenates everything into a huge result js file. ## typescript, finally Typescript needs to know if you are writing in "node.js style" (with modules) or in "browser style" (without modules). If your file has absolutely no top level imports, it will treat is as a browser-style javascript. Otherwise, it treats it as a module. That changes the way he handles the types (since one has access to global scope, the other not). You got two paths: either you use modules or not. ## With modules - You won't use `tsc` to compile the files. You hand it all to webpack; - You include the webpack generated bundle on the `&lt;script&gt;` tag - You dont use either `///reference` or `namespace` ## Without modules - No webpack at all. Just plain ol browser javascript. - You compile the files with "tsc" - You manually add script tags for each generated file you wish to use - If you put the whole folder in `tsconfig.json &gt; includes`, everything will be on global scope and you wont probably need `///reference` tags - If you dont put the TS source into the `include` setting, then you probbaly will need to add reference tags - Since everything is global, it may be a good idea to wrap your files into `namespace`. - On old javascript, it was a recommended pattern to wrap files inside an IIFE for scope isolation. `namespace` is mostly just a syntax sugar for that, and replaces that pattern. Give a look on which code it generates on the typescript playground to get a clear idea of it.
 // file1.ts namespace MyClasses { export class Person {} } //file2.ts namespace MyClasses { export class Cat {} export namespace FarmAnimals { export class Cow {} export class Chicken {} } } //file3.ts namespace MyClasses { export const chicken = new FarmAnimals.Chicken() } const cow = new MyClasses.FarmAnimals.Cow() (if you are using modules, you dont need to wrap each file in a namespace because the module insulation itself already does the same job, and because namespaces wont get merged)
omg i replied the imagebot check it there lol
Still it's a good hint. It's like following Google Styleguides for C++. I really like to do it unless I really have a reason to do something else.
Hahaha no worries. I'm looking into these after food. 
So there isn't a way natively to do what I want WITH modules. I need modules. We have other things we pull into everything and webpack is a Godsend.
https://medium.com/@mvaldesdeleon/using-ixmonad-to-enforce-good-hamburger-building-in-typescript-bcd584236dd4
Yes I get all that. Sorry you had to write it up. I forgot that namespacing was more pre webpack
Thanks for the help rubber ducking (actively) with me
Yeah youd need to do something like creating a file to merge the classes and reexport them all :(
Gahhhh yea. Heard. Ty again however!
There's a compilation flag to emit also typings
You want nominal types. Unfortunately, TS just doesn't have that, so it's hard. There are a few techniques here to get something like what you want: https://michalzalecki.com/nominal-typing-in-typescript/ Brands may seem hacky, but note that even the TS team uses them in the [implementation of TypeScript itself](https://github.com/Microsoft/TypeScript/blob/c5b74db78bad78722aa6336b7db1df7be4bd2ecf/src/compiler/types.ts#L4).
I would start by making your function parametric. const betterConnect = &lt;T,Q,R,S&gt;(mapStateToProps: T, mapDispatchToProps: Q, mergeProps:R , options:S) =&gt; { //*defines your custom behavior as types return connect&lt;T &amp; Custom1, Q &amp; Custom2, R &amp; Custom3, S &amp; Custom4&gt;(mapStateToProps, mapDispatchToProps, mergeProps, options) }
Can you explain what you mean by \`parametric\` here? I see this often in typings for libs (i.e. Reselect), but I don't understand what it means - does it mean just to take parameters? Doesn't this function already do that? Thanks
Typically, you'll see this applied to functions or data types that are containers. Essentially, these things take a type as parameter. The idea is that these functions or objects generalize over many types of objects. The classic example is the function Id. function id&lt;T&gt;(x: T): T { return x } It accepts any type and returns the same type. 
Another example of a parametric type is Arrays. You are probably familiar with using [] to create array types like string[] or number[]. But typescript offers an alternative syntax Array&lt;T&gt; which lets you specify that the array will take a type variable. You can also do T[] but I think the former more clearly shows the parametric nature of arrays.
So getting back to your example. My version says whatever type is coming into your function parameters should get used by connect. I'm also using intersection types, which says that this type is both type T and type Custom1. Based on my assumption that you were adding things inside the function that were not present in your function parameters.
&gt;const betterConnect = &lt;T,Q,R,S&gt;(mapStateToProps: T, mapDispatchToProps: Q, mergeProps:R , options:S) =&gt; { //\*defines your custom behavior as types return connect&lt;T &amp; Custom1, Q &amp; Custom2, R &amp; Custom3, S &amp; Custom4&gt;(mapStateToProps, mapDispatchToProps, mergeProps, options) } Hmm, that does get me a little further! How would I start massaging these types so that everything fits?
&gt; pe 'MapStateToPropsParam&lt;T, R, {}&gt; Just make it line up. &lt;TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}, State = {}&gt;( mapStateToProps: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;, mapDispatchToProps: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;, mergeProps: MergeProps&lt;TStateProps, TDispatchProps, TOwnProps, TMergedProps&gt;, options: Options&lt;State, TStateProps, TOwnProps, TMergedProps&gt; ): InferableComponentEnhancerWithProps&lt;TMergedProps, TOwnProps&gt;; return connect&lt;MapStateToPropsParam&lt;T &amp; Custom1, R &amp; Custom3, S &amp; Customer4&gt;, ....
So I would have to copy/paste the entire definition? I was thinking I could reuse the existing `Connect` interface somehow...that's not possible?
&gt; e the entire definition? I was thinking I could reuse the existing Connect interface somehow...that's not possible? I only copy pasted the whole definition so I could see the parameters of each function argument as I plugged the types into the type variable for calling connect. I suppose you could try to define an interface or a type which matched connect. ``` type ConnectType = typeof connect; const betterConnect: ConnectType = (mapStateToProps, mapDispatchToProps, mergeProps, options) =&gt; { ``` Not sure if that will work. 
So with Typescript 3.0 you can have rest parameters with tuple types, we can use that to make Variadic functions. Varadic is similar to Parametric but instead of having a set number of types you can have any number (Ideal for function args!). There are some proposals open talking about Variadics in typescript, The rest tuples almost gets us to full variadic. This is prop how I would do it. Everything should be types by doing this. The magic is the `U extends unknown[]`. unknown is similar to any but type-safe, and the [] is saying we are making a tuple. It's type is infered from args. function connect(mapStateToProps: string, mapDispatchToProps: number, mergeProps: {prop: string}, options?: {extra?: string}) {} // Helper func. function wrap&lt;U extends unknown[], V&gt;(typeFunc: (...args: U) =&gt; V, newFunc: (...args: U) =&gt; V) { return newFunc; }; // Implementation. const betterConnect = wrap(connect, (mapStateToProps, mapDispatchToProps, mergeProps, options = {extra: 'stuff!'}) =&gt; { connect(mapStateToProps, mapDispatchToProps, mergeProps, options); }); Good luck!
If there's only one "real" implementation, you shouldn't be using an interface.
Cool! Will give this a shot!
How do you test components without a test implementation/mock that satisfies the interface.
Not sure what exactly you want, but you can export types: export type Path = string; works just fine, and can be imported, iirc. You can also create a `window.d.ts`-file where you define those types globally, and then include that file with a `///&lt;reference /&gt;`-comment.
You just mock the class (or function, etc.). Exact syntax will vary according to your mocking library of choice. For TypeMoq, it's `const mock = TypeMoq.Mock.ofType(Foo)` for class `Foo`. There would be no reason to create `IFoo` and make `Foo` implement it just so you can mock the class in tests.
Thanks, this is very helpful!
I don’t know why it works like it does in my projects; but if I make a .ts file (whatever its name) in my projects that don’t export or import anything, all interfaces/types declared in that file are useable anywhere else in my project without having to explicitly import them.
You have lowercase "login" in the first file and use it as capitalized "Login" in the second file. Change it in the first.
You are correct, I missed this, but even still it doesn't work.
You probably should wrap the describe call in a method. You're missing a constructor which is likely were you want to define userCred as a data member. Currently the describe is executed immediately and only once when the file is imported.
I see what you're getting at. I rarely use classes to structure data, I prefer interfaces as they can be satisfied with object literals. So I rarely implement my interfaces.
From the [docs](https://www.typescriptlang.org/docs/handbook/modules.html): &gt;In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module. Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).
The `references` feature was introduced in Typescript 3.0 and is called "Project References." I believe that it optimizes what the `paths` option had done... it allows for smarter compilation by typescript and smarter path references. For instance, you should theoretically no longer need to include the "/build" or "/src" in your referenced project's path 
Completely missed that when reading the announcement. Sounds really nice. `tslint` does list `typescript&gt;=2.1` as peer which should include 3.0 but from my experience npm packages are not very thorough with their peers and considering they still have `~2.9` as a dev dependency I wouldn't expect this to work. I would try having both paths and references in your tsconfig and see if you run into any problems. If so I would stick with the old pattern. I'd rather have unoptimized build times than an unlinted package. If you also have problems with vscode itself (not the tslint extension) you should check at the bottom right (while having an open ts file) if vscode uses your typescript version or its internal one i.e. verify that vscode uses ts &gt;= 3.0
Thanks will try tomorrow
Hi Daniel, I have been attempting to integrate Project References into my monorepo project and VSCode/TSLint are not finiding the referenced packages properly. I am not sure whether my code is wrong or if VSCode and TSLint simply don't support TS 3.0 yet. Do you know if the latest versions of VSCode and TSLint should be able to index Project References? Does a watch/build command need to be running in the background?
Yeah I agree, unit testing is messy and a pain. Especially in JS which IMO still lags a bit in the sophistication of the unit test libraries. Part of why I like Typescript is to replace the need for the more trivial tests (is my number really a number?) with type assurances. Have you tried a base class for your unit tests so that you can just set up one mock of each type and reuse the setup for all your tests? That's my usual first line of defense.
You're doing it wrong. You don't unit test routes. You integration test routes and run the integration tests whenever someone pushes. Superagent/supertest makes it really easy for any node framework. Including the bloated pile of shit that you use (express).
That doesn't change the fact that OP needs to wire up mocks.
It's tempting to copy and paste, feel free to create test helper funcs that abstract that away.
&gt;You're doing it wrong. You don't unit test routes. You integration test routes and run the integration tests whenever someone pushes. Superagent/supertest makes it really easy for any node framework. Including the bloated pile of shit that you use (express). Thank you for commenting. Do you mean that I should use supertest and make a request to the endpoint to test it, without mocking anything? I don't know how I should deal with authentication then. Should I, in the tests, retrieve a JWT before sending requests to endpoints that require authentication? And, how do I deal with IO, like writing to the database? Maybe a test database?
Should find a way to do it without mocks. If you're replacing everything with mocks, what are you even testing?
Yeah, if you're doing integration / e2e / functional / "whatever you want to call them" tests, use a test database. It _might_ be worth mocking any external services you would have to use. Maybe. Depends on the service. Are you just running your integration tests locally, or are you using CI? I'd recommend using CI, if you aren't. Pretty much every CI provider will give you access to temporary databases you can use, or access to docker containers you can use (and then you can just use containers with the databases you need). Also make sure to use environment variables to set up your connection strings.
I'm not sure where the js community stands on it, but we use plain objects with methods instead of dependency injection. DI is a relic of languages where you can't just stub or override methods. We have AngularJS too, but at least it's built into the framework so you often don't have to write stubs. So my recommendation is get rid of the classes. Use sinon to stub methods like you're doing but only as necessary (like it the function makes an http call), and supertest is flat out the best library for testing express routes. Only unit test things that have logic, like these services you are injecting.
I think you are confusing unit and integration tests. Unit tests should mock literally every dependency and only test the logic in that specific class and therefore shouldn't blow up if your dependent classes have broken logic. Integration tests should be testing multi class *integration* and be doing what it seems like you are describing.
If you're not using dependency injection, how can a class depend on a stateful instance? You can `require`/`import` the instance but then you're using a shared/global singleton, which is not a good pattern. Stateful instances are things like a database connection. Depending on non-stateful "instances", basically classes is of course fine using ES6 `import`.
For things like that, where I am using Mongoose to talk to Mongo or the Google API npm package, I make a wrapper and it's exported as a pre-instantiated instance. 
Actually we reuse database connections rather than open new ones for every query. I would like to know why this isn't a good pattern, generally. I think it depends on the case and in my experience, it's much easier to test and think about when your file just imports "queuehandler" and the instantiation is abstracted away in a small wrapper file. Much easier to test too when you can just stub out the get and send methods. 
DI doesn't mean opening new ones for each query. You can inject that queuehandler. If you're importing a queuehandler then you store a singleton state in the wrapper file.
I think that my tests actually aren't unit tests, but integration tests. I am creating an express app, router and body parser and sending requests to them, and then mock everything the router does. This is testing more than the routes themselves. They are a dirty hybrid.
This is exactly what's happening. The definition file adds `chrome` as a top-level property on `window`, not as an importable module: interface Window { chrome: typeof chrome; } You can also see that's being used as a global property in the type's tests: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/chrome/test/index.ts You should be able to access the `Tab` interface via `chrome.tabs.Tab`: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/chrome/index.d.ts#L5908-L5931
I can see di being much more manageable with a framework. Nest's interface looks pretty cool too, thanks for the share
Nowadays I don't really trust projects anymore that don't utilize TypeScripts strict compiler flags.
Oh I see; this works, thanks. 
Anybody used this? Is it any good? Documentation is super lacking so I have no idea what I'm looking at
Haven't tried it out but I think it's because you explicitly declare `node` as `BaseNode` which overrides the possibility to infer the type later
I made an api with it, but didn't like the Angular style for backend. Switched to ts-express-decorators, which i find better. Though you have to do a little digging, as the docs are lacking.
It works if i dont specify types for `node`, but i want the type of `node` to be `BaseNode` outside the if-block;
The way type-guards work is that you define a function that communicates whether the object is of a specific type (this is the `node is CircleNode` part of the deceleration of `isCircleNode`. TypeScript doesn't look into the function and check the logic and then assume this logic is true elsewhere. So when you say `if (node.kind == NodeType.circle)` this doesn't communicate anything about the type of `node` to the compiler (it only tells it about the value of `node.kind`). The type-guard function doesn't enforce that the object is of that type it just tells the compiler to treat it as if it was. The following function is a syntactically valid type guard although it's obviously wrong. let counter = 0; function isCircleNode(node:BaseNode): node is CircleNode { return !!(counter++ %2); } Then the output of: let node: BaseNode = { kind: NodeType.point, pos: [1, 2] }; if (isCircleNode(node)) { console.log("first: ", node.size) } if (isCircleNode(node)) { console.log("second: ", node.size) } Would be: &gt; second: undefined
The problem is that `BaseNode` is open and could be arbitrarily extended: there is no guarantee that a value of type `BaseNode` with kind `NodeType.circle` is a `CircleNode`, and not some other type created elsewhere. Your user-defined type guard is making the promise that the kind `NodeType.circle` is used uniquely and it is therefore safe to narrow, but in general TypeScript cannot assume this so the literal type guard does not narrow. If you want narrowing you need to ensure the type is closed, you can do that by using a union type instead of inheritance. type NodeUnion = PointNode | CircleNode let node: NodeUnion = {kind:NodeType.circle, pos:[10,10], size: 10} as CircleNode; if (node.kind === NodeType.circle) { console.log(node.size); // ok, node is CircleNode } 
Thanks, that makes sense.
I wrote one of our microservices with nest. It’s been running flawlessly in production for a couple months now. Totally in love nest and I would certainly write future apps with it. Reminds me of my rails day when everything is batteries included. Also, I don’t think the documentation is that bad. It could certainly be better but the community is very welcoming and helpful.
Please also have a look at this r/https://dinoloop.com
how it is better than r/http://dinoloop.com ?
can you also please share your thoughts on r/http://dinoloop.com
Yeah, the docs are great. There are also a ton of [samples](https://github.com/nestjs/nest/tree/master/sample).
It only looks like a thin decorator wrapper over Express rather than a complete framework. Perhaps because I only found two code examples. Things I usually expect from a framework: routing, validation, forms, orm, event dispatcher, security, template engine, access control, caching. The framework does not have to implement all of these itself but rather pick and choose the best and integrate in its framework. 
Well, the name for one.
Wow, this is sad.
I’ve used it for several projects. The angular style DI container is actually great, if people can get off the “Angular Hate strain” long enough to give it a try. Overall, I prefer nest for larger server side node projects, as opposed to using express. Nest wraps express so anything you can do with express, you can do with nest. So basically you have the full nest documentation which is good, and then the express documentation is just as useful. 
can confirm, your getPlayerInfo is itself returning a promise
Use an await on the nba,getPlayerInfo call, or actually await the promise by using nba.getPlayerInfo().then((foo) =&gt; {})
So then a better question might be then, how do you assign the value from the promise to a variable? Right now, all i've really been able to do is print out the result from the function call, I haven't been able to successfully assign the value from a promise to a variable.
Can you assign a variable the value of foo? Every time I try that, I get the result of undefined
Only within a `then`'s callback.
You can use `DefinePlugin` if you build your project with webpack. There might be an easier way I'm not aware of.
What I've seen is people including a boolean flag or configuration object which can be set on the class, or on an instance of the class, to change those sorts of values. As an example... const mySdk = new MySdk({ host: "dev.mysdk.com, port: 3000 }): Usually each option has a default value (which would be the prod config) so some or all options can be omitted. This allows others to use it easily in any environment. Would that work for your use case?
Basically you want to run the code that depends on that variable in the `then` callback
Some guy desperately trying to advertise his own framework, like "try me, try me!"
Oh
I know this might be late but I just recently finished an assignment with the same structure. [Link to the GitHub repo](https://github.com/szszoke/scoreboard)
in TypeScript/js just use `JSON.parse()` and `JSON.stringify()`. It is built in. It would work something like const jsonString = '{"name":"Joe"}'; const obj = JSON.parse(jsonString) as IMyObject; I make it a personal rule to always parse as a very basic interface, and never a class. Remember, TypeScript is not a typed language in the way C# is, so `as IMyObject` is only telling TypeScript what type it should presume the result is, it will not construct an object of that type. If you have a class with custom methods or properties, they will __not__ accessible after `JSON.parse()`. Shout if I didn't answer your question, or you need more help.
for validators I like yup, theres also io-ts and a couple of others (you wont be always validating data, but when you do , some types are inferred from the schema defs, reducing duplication)
Yup looks fantastic. Thanks
So the problem is i often need to coerce data into a common format for some certain properties. As an example some customers push up some datetime fields as strings, while others push them up as a timestamp. In C# land i would just slap a JSONConverter on the property with a custom function to massage it. It would be like "If i am a string, do X, otherwise do Y". So i guess what i am looking for is more closely related to serialization and deserialization of the JSON blob for typescript. 
Please format your source code correctly. Here is it in a fiddle [https://jsfiddle.net/L9u2qnw0/1/](https://jsfiddle.net/L9u2qnw0/1/) You used "this" in a function scope. Convert the onmessage function to an arrow function and it will work. Just try to avoid functions inside typescript classes. `this.ws.onmessage = function(message) {` becomes `this.ws.onmessage = (message) =&gt; {`
Thanks for that \^\^ Sorry about source, looked right on my screen before posting
The first thing I think of is using the deserialised object as a parameter for a constructor or factory. That can hold some logic on what or how to create the object you need.
This looks interesting, thank you. Is it just (or mainly) for validating the schema of an object? In TypeScript this could be interesting to use in a factory, a sort of if schema1 validates return `object as type1`, and if schema2 validates return `object as type2`.
It behaves the same as in JS. 
I prefer https://www.typescriptlang.org/play/ for TypeScript code
https://github.com/mojotech/json-type-validation has been working very well for us. From the README: ```js import {Decoder, object, string, optional, number, boolean} from 'json-type-validation' const petDecoder: Decoder&lt;Pet&gt; = object({ name: string(), species: string(), age: optional(number()), isCute: optional(boolean()) }) const lyle: Pet = petDecoder.runWithException(croc) ```
for bigger testing i use [https://codesandbox.io/](https://codesandbox.io/) But that was an overkill for that code formatting \^\^
Can't you make the property a union? string | Date ?
There is no universal conventions. Use whatever make most sense to you. I personally use `FooBar.ts` for React components and `foo-bar.ts` for the rest.
You are making a difference.
If `FooBar.ts` has inside class `FooBar` then name of file should be `FooBar.ts`, if file has inside function like function `className () {}` then name should be `className.ts`, here you can read more about file names [http://beginwithjava.blogspot.com/2011/01/javas-file-names-and-class-names.html](http://beginwithjava.blogspot.com/2011/01/javas-file-names-and-class-names.html)
I mean you could just literally initialize the object with default values of you didn't want to go through all of that. Without knowing more of the context in terms of why you're taking that approach or why values aren't optional that seem to be optional (the partial is the object with optional fields), I can't say anything more.
My approach would be to define a `Car` as a union type of e.g. `WithWheels`, `WithEngine`, `WithSteeringWheel`, etc. You can then use generics for the input parameter and use the specific type in the return type, e.g.: const installEngine&lt;C extends Partial&lt;Car&gt;&gt;: (car: C) =&gt; C &amp; WithEngine = // ...function definition... `finishedCar` can then simply be of type `Car`, and TypeScript can deduce whether all the required functions have been called on it. (In practice, I'd probably avoid getting in a situation in which different functions together build up a single object, but we don't have enough information about your code structure to suggest an alternative.)
That link is about Java, not JS or TS. 
Have a look at the JavaScript [reviver function](https://alligator.io/js/json-parse-stringify), it can be used to perform custom conversions. "JSON.parse() can take an second argument for a reviver function that can transform the object values before they are returned."
Dealing with asynchronously created objects is fine, that's why you use setters in addition to a constructor. Getters are great for things like hasEngine. This allows you to continue to supply the Car object, but gatekeep areas of functionality that requires an engine. You can also provide a getter that rolls the other validators up as something like completeCar with some event emitters to allow you to move forward when the car is valid and whole where that is required. Then I have a standard Car that behaves the same way always instead of partially compete objects that I need to know about their status in construction to be able to work with at all. 
Related links: Yup https://github.com/jquense/yup io-ts https://github.com/gcanti/io-ts
So I just noticed that the server is also not making use of the tslint.json file which is in the same place as the tsconfig.json... any advice?
Good :)
I more often see dash-case file naming. But since the introduction of the “extract to function” and “move to another file” refactors, camelCase may become really tempting since it saves you some file renames (move to another file will create a camel cased file, since variable convention is camel case)
Fluently working on [ts-auto-guard](https://github.com/rhys-vdw/ts-auto-guard). It automatically generates type guards for raw data from your interfaces. Still WIP but I'm moving towards putting it into production for validating our server supplied redux store. Should work for this too.
It might help https://github.com/typestack/class-transformer ``` import { Type, plainToClass } from "class-transformer"; export class Album { id: number; name: string; @Type(() =&gt; Photo) photos: Photo[]; } export class Photo { id: number; filename: string; } let album = plainToClass(Album, albumJson); // now album is Album object with Photo objects inside ```
When using Yup, how does this work with client-side business entities? In other words, I've always created typed classes like "Person" and had a Person.toJson() and Person.fromJson() to go from Json/DTO to business entity. Would the Person class have a schema? or IS the Person the schema? Does Yup obviate the need for the to/from Json methods? The documentation dances around these questions a bit.
I use the backbone.js implementation for my site, and I recently changed everything to use camel case with a suffix of what it represents. E.g. DashboardView.ts, DashboardCollection.ts, DashboardModel.ts They are in separate packages, but I use Eclipse (don't kill me) and the resource finder makes it easy to type in and find what I'm going to work on. Also makes it easier for noobier developers to know what the purpose of the file is.
You've got a couple simple options off the top of my head: Put your definitions in index.d.ts in the project root, ala the DefinitelyTyped packages (or just re-export them there) Populate the `types` field of your package.json, as shown in the [docs](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)
Just solved my issues by doing just this, thank you so much :)
This topic has been in my head also for a while. I have a (redacted prefix for practical reasons) library full of utility types to help development cross projects and have found no real standard outside ambient module typings.
The simplest option is: put the types in a file called `index.ts` in the same folder as `package.json`. publish it to npm, install it via npm in the projects that need it. Use ES6 exports and imports. For example, `export namespace MyCompany {...`
I have just started using https://github.com/Microsoft/node-jsonc-parser and can absolutely recommend it. I have not explored it's ast plugin system but it seems more than capable of what you're looking for if you are open to write plugins (might already exist for what I know) I found the basic documentation to be lacking but I will answer what little I can and probably other people with more knowledge on here.
My quick solution: interface Car { engine: Engine; wheels: Wheel[]; } function addWheels&lt;O&gt;(o: O): O &amp; { wheels: Wheel[] } { return undefined as any; // todo } function addEngine&lt;O&gt;(o: O): O &amp; { engine: Engine } { return undefined as any; // todo } function buildCar(): Car { return addEngine(addWheels({})); }
I tried \`export namespace MyCompany\` but it becomes invisible internally. The references to those dissapear.
Hey, BurritoBashr, just a quick heads-up: **dissapear** is actually spelled **disappear**. You can remember it by **one s, two ps**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
index.d.ts export namespace MyCompany.Common { export interface User { id: string; full_name: string; first_name: string; last_name: string; npi: string; color: string; } } consumer.ts (inside same package) import User = MyCompany.Common.User // Namespace `MyCompany` has no export `Common`
&gt;You need to use import and export statements to access things exported from other files, even in the same package. Thank you! That helped and I got it working!
 /** * Your domain model. */ type Engine = {}; type Wheel = {}; type SteeringWheel = {}; type Chassis = {}; type Seat = {}; interface Car { engine: Engine; wheels: Wheel[]; steeringWheel: SteeringWheel; chassis: Chassis; seats: Seat[]; } /** * Enhancers. */ const addWheels = &lt;T extends Partial&lt;Car&gt;&gt;(base: T): T &amp; { wheels: Wheel[] } =&gt; { return Object.assign({}, base, { wheels: [] }); } const addSeats = &lt;T extends Partial&lt;Car&gt;&gt;(base: T): T &amp; { seats: Seat[] } =&gt; { return Object.assign({}, base, { seats: [] }); } /** * Some seed for your car. */ const base = { engine: {}, steeringWheel: {}, chassis: {}, } /** * Our assembly line. */ const main: Car[] = [base] .map(addSeats) .map(addWheels) [TypeScript Playground](https://agentcooper.github.io/typescript-play/?target=5#code/AQ4egKggoUQ4BNA9gVwE7ACbILYEMBLAO2F2SwFMAbAOljgjAZABcBPAB0uAFFiA5iR4BeYAG8AvgG4WwDt2AB1ABaUawMVNlwFPAMqt16EgNXrqmiTLl7gAYRX4Azs8LOr221wOV8rTxs5EiN0ADN8AGMee3xMcTk4SkFhAC4+FOJKHThQAHc1Gmd08xoAbQBdHNzgZyNKE0FS6nTDY1Nm6tzIp1d3dMcXN2cuuGc-VmLgfQnKrsloOUgYXIR+J2Jo9Gd6VeY4SORiOuB8LCxmjzEAHgAVYEoADyNiLA8ABTjWQnxqa9j0AA+QEACgARi5KOlbgBKaHAABkEmABQsU2alWAkk0gIkiVA6EorAwpAA8mCAFaUSKsWhDQgCYggqQAGmAEPGbPEKMK1CmmMkMPmiwORxOZywM38V2Adwez2Sb2An3Q31+-ziwPBkOhcOA9yR3PG0taswqWJxeJqIEJxPQZMp1Np9MZzMkbI5lC5tQm-PNguFSygiQQ+jwPHGlCwwDCyEw7DQmEicV2jH2oEOxwCns8+JAySEWXSrLztXqjTMvOL7tLPXpUxLcAWQZWjGApIwp1clFwYOo7GA1GEqdATDkmZOBBIAzimJEcjKnoqpdoBE4IIlUsmMJXa4350uO6AA)
 /** * Your domain model. */ type Engine = {}; type Wheel = {}; type SteeringWheel = {}; type Chassis = {}; type Seat = {}; interface Car { engine: Engine; wheels: Wheel[]; steeringWheel: SteeringWheel; chassis: Chassis; seats: Seat[]; } /** * Enhancers. */ const addWheels = &lt;T extends Partial&lt;Car&gt;&gt;(base: T): T &amp; { wheels: Wheel[] } =&gt; { return Object.assign({}, base, { wheels: [] }); } const addSeats = &lt;T extends Partial&lt;Car&gt;&gt;(base: T): T &amp; { seats: Seat[] } =&gt; { return Object.assign({}, base, { seats: [] }); } /** * Some seed for your car. */ const base = { engine: {}, steeringWheel: {}, chassis: {}, } /** * Our assembly line. */ const main: Car[] = [base] .map(addSeats) .map(addWheels) [TypeScript Playground](https://agentcooper.github.io/typescript-play/?target=5#code/PQKhCgAIUhNB7ArgJ0gE3gWwIYEsB2km8aApgDYB0UIw4ALgJ4AOpkAovgOYFsC8kAN4BfANwMWbAOoALUhUgCR4pq0gBlevOQEus+eUVCxEtQGEZ2AM5XcVo8tNt1pbPQcnwBLcgBm2AGM2M2xUQShISNJuXgAuDhj8UnFIyIB3OQoreP0KAG0AXRTUqy1SHW5c8njNbV0q4siAyxs7eItrWytGyCtXemyNfsLxYXBwUAhoBMt8IOQramg6APh8UshsNDQq+wEAHgAVSFIADy18NHsABVD6XGxyfZDkAD5XgAoAI2tSeMOAJT-SAAMiEkAyBkGVUKkGEileQgikWQpHoKEIAHkvgArUgBeiUTq4Lj4D4iAA0kB+fSpgghmXIg1hwgBo3Gq3W7i2aBcbj2kCOJ3O0SukFuyHuj2eoXe31+-yBkGOYPpfX5NWGBThCKRqUgqPRyCxuPxhOJpPJwipNNIdN6-WZ2tZ7ImYBoGiwbD6pDQkF88FQjCQqACoSWtHAnI2tocyJOiT+xgp8dKdUqjPilPjzWJg2zYzdUxgmJQmxspEwX3IjEg5F4EZWaw2OAI7VCsL48bytoK8f1lBwzA+PL5AwB-dSg+ww55uwnQA)
Sounds like an interesting problem. Have you thought about bundling your depependencies? I think that might work as during bundling you'd be using Node's module resolution and don't need everything in the individual node_modules of your packages. I'd also check out Rollup. You can define multiple configs in a single file at the root level and build all your packages at once. Works great with the watch mode as well. If you can share some code maybe we can look at it together :)
I've started converting my client-server project into a monorepo with three packages that used to each be a separate git repo. I've been running into a lot of the same issues you mentioned, so it's good to know I'm not going crazy. So many things seem awkward with this new project references feature. My project is a client server model so the client package uses webpack to generate a bundle while the server code needs to be able to run directly in node without any loader or bundler. This means I have to use these massive relative paths because I can't use path mapping (that's a loader/bundler feature). It's really ugly having "../../../../../../shared/src/index" for my imports but it's the only way that 'Just Works' even though it pollutes the code. It would be so nice if TypeScript was able to support some kind of "virtual package" system that was like path mapping but it would resolve the path during the build step back to normal relative paths. It would allow the TS code to be clean while still compiling for maximum compatibility. I'll have to take a look at Yarn workspaces. I've been using Lerna for hoisting but it doesn't seem like a production ready solution.
TypeScript aside - though I did write the typings for this library - there are simpler state management libraries such as `react-copy-write`. (Better typings are coming - no more any! - just haven't been merged yet.)
I'd recommend [class-transformer](https://github.com/typestack/class-transformer) and [class-validator](https://github.com/typestack/class-validator)
[joi](https://github.com/hapijs/joi) is the standard object schema validator in the JS world. If you want to turn the json into classes then you may want to check out [class transformer](https://github.com/typestack/class-transformer) and [class validator](https://github.com/typestack/class-validator).
Would you mind posting the task? Another person suggested that lerna can be used to bundle the specific dependencies. Basically, you would publish the packages, retrieve the packages, and then install the result. They also suggested the npm "bundleDependencies" flag, but I'm not familiar with that.
Apparently lerna might be useful for publishing packages, retrieving them, and then running install. Also, npm has a "bundleDependencies" config option that I haven't yet looked into
`const install = require('gulp-install');` `gulp.task('include-runtime-dependencies', [], () =&gt; {` `return gulp.src('./package.json')` `.pipe(gulp.dest(paths.dist))` `.pipe(install({` `production: true,` `noOptional: true` `}));` `});` 
Thank you. Can't believe that this isn't supported as a standard feature 
"npm install --production" is still there, but we're not looking for easy ways, plus it makes no sense to run inside lambda
Thanks! I'll look into it.
I just realized that both Lerna and Yarn create symbolic links in a project's node_modules if it defines a local package as a dependency in package.json. I didn't realize this at first because I thought dependencies in package.json meant it would retrieve them from npm registry. This solves my issue with massive relative paths. Although, I'm still having issues with Lerna and Yarn playing nice with private git dependencies on Windows. It's giving me a headache. https://github.com/yarnpkg/yarn/issues/6295
i don't think there is a link to the project on the blog post?
I just added further links to the blog post.
It would really help me to have a tl;dr in the article with bullet points of why this is better than the alternatives.
That's what the many code examples are for. Wouldn't you agree that they are more simple? But yes, I should probably sum it up! 
There was like 5 of them and they were each 3 blocks of code 5-7 lines long, so that's like 75 LOC to read through.
But isn't it the code that matters? How would you else describe the benefits?
Code shows the concepts in action, but first we need to see what the concept is that's new here and why it's better than the alternatives. It saves us mental time/work.
But the big tradeoff is the syntax primarily, and being able to mock interfaces secondarily. 
Thank you for the suggestion, I have added some points in the first example section. As for how it does it, it does so by using ES6 proxies. Interfaces aren't emitted to the code, so it is technically impossible to evaluate at runtime. However, since proxies are used, the runtime object is created as you use it. Does that make sense? 
This looks awesome. We just switched to using NSubstitute for C# code too, so this would fit in nicely. 
yeah I couldn't tell what one should do for forms either. 
TypeScript 3 is not needed for that reason. It's needed in order to express the functions in a strong typed manner. More specifically, the new rest tuple features is what is needed. Let me know if you want me to be more specific. 
Probably not, tbh. It's not that often that I deal with type unions with more than two types and I'm happy to use if statements or other native constructs.
I do something like this to create generic inputs in a dynamic form creator. createGenericFormInput(key) { let input; switch (typeof this.data.properties[key]) { case "string": { input = new DynamicInputModel({ id: key, label: key, value: this.data.properties[key] }); break; } case "number": { input = new DynamicInputModel({ id: key, label: key, value: this.data.properties[key], min: 0, mask: [/\d/, /\d/, /\d/, /\d/] }); break; } case "boolean": { input = new DynamicCheckboxModel({ id: key, label: key, value: this.data.properties[key] }); break; } } return input; } 
Good idea. If you use a *typeof-like* function that returns a type enum with string values, it's even clearer.
This setup will lead you to a lot of problems in the long term. What I do, which has worked really well, is to have two top level directories like "server" and "client" and just have two totally independent project roots, each one with their own concerns, configurations, dependencies, scripts, etc. If for some reason you want to share code somehow, you can always create a third root "shared", or even better, extract a library, publish it to npm and add it as a dependencies of your two independent projects.
Oh, and BTW, the trick with the editors is to open two different windows, one on each root, so they pick their correct tslint rules, nom scripts, etc.
I haven't tried it yet but seems like getting back a tuple of {tag: type, value: value} where type was the same type union that I passed in, and value matched the type, would be nice as I could do a switch and tag and get an exhaustiveness check. So the typeswitch return type would have to be something like {'int', Val: int} | {'string', Val: string}, etc. 
Why is comparing with a string bad?
I don't think it is. The advantage to this though will be simplifying get Generic types with T so for example I might be able to switch between Array&lt;ModelA&gt; and Array&lt;ModelT&gt; . I am not sure how easy that is to do with typeof (I haven't actually tried) where this would be easy to define Array&lt;ModelA&gt; in the switch case. in the end its just better at describing the intentions of the developer.
do you u mean, you want to compile the TS import syntax to ES6, instead of cjs?
Anyone using Firebird in production?
Just FYI, avoid constructs like this in performance-sensitive regions. The construct: if (typeof obj === 'string') {...} gets optimized by the JITter to a very simple numeric comparison operation against obj's type flag. But const t = typeof obj; if (t === 'string') { ... } Requires a much more expensive operation to actually manifest the `typeof` string, and then a string comparison to check it. The same happens with your `switch` statement - the physical string must be manifest and then compared with each `case`.
hrmm well, this is actually a pretty often run item in the application it's performed everytime a user focuses a different node in a diagram editor. is there a more performant way of performing this task?
Why don't you just bundle all these files together? 
Once per user interaction is fine, it's more something you shouldn't do 1000x per click. The performant way would be: const t = typeof this.data.properties[key]; if (typeof t === 'string') { ... } else if (typeof t === 'number') { ... } else if (...) { ... }
How can I do that? Can the TypeScript Compiler do that for me? I got this only to work with CommonJS / AMD Modules inside this one js fiel 
I think the issue is that T is typed as the union, and First can't be assigned to that. You can either use a typeguard function that will force T to be typed more narrowly, or use a type assertion to assert that First is type T. 
"T extends FirstOrSecond" doesn't have the same implications as "type T = FirstOfSecond". The former means that if you replace T in the code of your class with any type assignable to FirstOrSecond, the code should compie.
Imagine a language that has only two types (`A` and `B`) that are incompatible with each other. `A` is assignable to `A | B` but not necessarily to a type that is itself is assignable to `A | B`. To illustrate, these are fine: (A | B) &lt;-- A (A | B) &lt;-- B (A | B) &lt;-- A | B But then consider the generic case: (A | B) &lt;-- T &lt;-- A In this case our generic `T` could be *any* of the valid cases we just came up with. Meaning `T` could be `B`, and `A` is not assignable to `B`. IE (A | B) &lt;-- B &lt;-- A Which is obviously not valid. There's a name for this idea, but it escapes me at the moment.
It was initially written in Go, but rewritten due to worries of GC contention (between Go and V8).
As I understand it, the guy behind this is the same guy behind NodeJS.... so its not total amateur hour.
The guy who created this project is the same person who created the nodejs project. For information you can see [his talk from JSConf](https://www.youtube.com/watch?v=M3BM9TB-8yA).
I recently came across [nest](https://github.com/nestjs/nest). I love the framework and the code base seems very well written.
Could be cool. I do love typescript. That said, &gt; No package.json I'm still not convinced that's a good thing. I guess we'll see.
That's correct. He's fixing the problems he sees in Node.
Are you already using typescript 3 in a production environment?
Thank you.
Thanks
Thank you.
I suppose that would work. Don't get me wrong, it's definitely not a dealbreaker for me. I'm just skeptical that ditching a standard package definition file in favor of requiring dependencies from URLs strewn throughout your code is the best choice. I wonder why he has such a strong opposition to it. 
Ok the second was worked, thanks :)
Not in production but building a prototype
But with a `package.json` file, the complexity becomes externalised, which is what I want from anything that's handling packages for me. Otherwise I'm handling all the packaging details myself - and NPM has shown repeatedly how easy it is to get packaging wrong. I can imagine it becoming a lot harder to implement versioning -particularly with regard to bugsfixes and security updates - when people are pinned to a particular external resource. I can understand the idea that a package manager might be created at a later date that would build the externals file automatically, but I think the success of both Rust and Go have demonstrated that bundling a package manager by default will significantly help build up the ecosystem surrounding a new project. The recent packaging issues in Go also demonstrate that it's best to try and get packaging right the first time, and not rely on a best-effort version. I'm going to watch some of his talks that have been posted here later, because I'm sure he's got some good reason for doing this, but I just can't work out what it is at all. This seems like it's taking a half-dozen steps backwards in an area that is currently seeing a huge amount of progress.
Do you have a link to the thread?
Blog is the best source of info for newer features: https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/#controlling-output-structure
Haha the good news is that I was able to deploy yesterday for the first time (the hard work was done by somebody smarter). The solution is actually very straightforward, stable, and should be easy to set up but requires some thought to understand because there are some new paradigms. The bad news is that it's a little bit slow to build/deploy depending on your environment. Still uses Lerna, Workspaces, and either Serverless/CloudFormation/AWS SAM for deployment. Key Concepts: 1. Use Lerna for package management. This allows you to reference your "shared" code from your lambda functions by doing `import @my-namespace/shared` in your lambda function. 2. Enable "nohoist" on your lambda function directories. This will force your lambda functions to keep all of your code in their own node_modules. (in the repo, lambda functions must have a namespace of "sls-...", then package.json does "nohoist" on the sls-... folders) 3. Use Typescript 3.0's new project references, which operate independently of Lerna and simply compiles the code in order 4. You need to do a little bit of wonky work when it's time to deploy. Are you using a build server or building from your dev environment? Get started, here: https://github.com/tommedema/serverless-mono-example.git Let me know when you get stuck, I should be able to walk you through it 
Not having `package.json` (or similar) means less coupling between your runtime and your dependency manager. The manifest is really an npm data file, and Node itself doesn't use anything except the `main` field. 
Thanks for getting back to me, I got very frustrated with it, it seems just so ridiculous to me that you have to jump through so many hoops for such a basic use case. I started to look at Lerna etc and thought to myself "Its just not worth it". So I'm straight up duplicating logic in each service and sharing type information by declaring a shared.d.ts. The class that I am sharing is a simple wrapper to call Service C Lambda function from Service A or Service B and return the correct response typings. As much as I hate duplicating code, I am only duplicating about 20 lines that will most likely never need to be touched again, and as much as I hate repeating code, I prefer repeating myself than adding a shit load of complication and build tools into the environment. Again, I find it absolutely ridiculous that it's not possible to import a shared class in typescript. I'm using dependency injection, so the class doesn't even have dependencies and a need for its own node_modules. I feel like there might be some easy solution out there that maybe im not aware of. But I searched and tried a bunch of different options and nothing worked or was way over complicated
Duplication probably makes sense if you only have 20 lines of unchanging code. If you expect your codebase to grow and for there to be a lot of dependencies, it's probably worth setting up lerna &amp; project references... The initial setup is confusing but once you understand how it works, it should be very stable and reliable moving forward. It's complicated until you understand it and then it's simple
Yea, I was kind of hoping it would be easy so that when the time comes I need to share much more code it would be easy, but I guess when that time comes ill look into lerna, thats for the link tho ill look into it
If you want to use an unknown variable as a key, the object needs an index signature. 
What are the values of element and varString? Can you console.dir them?
I think you're asking about Lookup types or Indexable types. https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html https://www.typescriptlang.org/docs/handbook/interfaces.html
yeah they are defined correctly. i console logged them
\`{ something: 27 }\['something'\]\` will give you \`27\`, and \`{ otherthing: 37 }\['something'\]\` will give you \`undefined\`. Is that what you were expecting?
I figured it out. Should have posted my exact code but it was in a quicksort function. Was probably more confusing than my bad example.
Don't be that guy. Post what you did to resolve your issue. 
There's a whole section on testing async functions in the Angular documentation. Have a look there.
"nevermind, it's working now" wtf
Yes? 
I've been enjoying this: fnThatExpectsSomeClosure( (...args) =&gt; someFn(addMeToClosure, ...args) ) Pretty sure this only works in the nightly builds at the moment, but it's a lot better than the old way: (a, b, c, d) =&gt; someFn(addMeToClosure, a, b, c, d)
how would the server serve the client in this directory set-up? is the client served by something else and then targets the server?
You could check out ‘class-validator’.
Given each directory has its own package.json, I have also a "build" and a "deploy" script.The client's deploy command will just copy the output to "../server/public/app" or similar. Then when you deploy your server you will be also deploying your client. Usually what I do, is to add also a top level package.json which contains only the scripts section which are wrappers to run client and server build and deploy scripts in the required order.So that at the root of my project an "npm run deploy" will build and deploy client and server in the right order. You could also in the future decide to deploy the client as a separate app, and the only thing you will need to adapt is the client/package.json deploy script. 
Have a look at io-ts - provides runtime types and validation. The learning curve is a little higher due to building on top of fp-ts.
I use [io-ts](https://github.com/gcanti/io-ts) for validation a lot, and I love it. I don't know how convenient their runtime inspection API is, but you should check it out.
Glad to hear that. io-ts types are fully introspectable (and in a type-safe manner) which allows for interesting things beyond validations. Here's a bare bones example: [automatically building a form from a io-ts type](https://gist.github.com/gcanti/6c178fb79e2bbc273796e7263d2ebcf1)
I currently have my front end and back end in the same project, with a shared package.json. Your recommend approach makes a lot more sense, I'll be migrating to this set-up asap. thank you for the detailed response, it's exactly what I needed!
Thanks for building so many awesome TS tools:) I've only just started using io-ts, but it's been absolutely amazing so far. Especially writing my own types, and having them tie into your library seamlessly.
Yep, this sure looks like what I was looking for. Thanks!
Look at your Subject. If the component that is waiting to receive the broadcast isn't awake when the subscription message is sent, then that component will miss the message. Use BehaviorSubject to have the message heard when the component wakes up. BehaviorSubject is like having a mailbox. It'll hold the most recent message. ReplaySubject allows you to save more than one message in the mailbox. 
&gt;Personally, I found it hard to get consistent code coverage results with Istanbul when I used it. It's interesting to hear you say that. I've had coverage results from Jest(which I think uses Istanbul for coverage) that are alllllll over the place....maybe that's why
Any chance you'll support npm instead of yarn?
Glad you found it helpful. The only trade-off I've found so far is you might end up with different versions of the same package if you use it both in the server and the client, but for me that's even a feature more than a problem, given I can update major versions only for the server and later for the client, etc. Let me know if you stumble into any issue, I've been using this setup for a couple years now and maybe I already solved whatever you get stuck with.
It's just a boilerplate, so it's agnostic. If you replace "yarn" with "npm" in the `package.json` file, it'll use npm. Then, if you delete the `yarn.lock` file, it'll be cleaned up for npm.
I think overall, the jury is still out on what's causing the inconsistencies. I've followed GitHub correspondence between the creator of Istanbul and Microsoft, and they have plans to work closely together soon to see if they can get to the bottom of it. But even then, I've read some things on the internet that indicate there shouldn't be any problems at all, provided you wire up the source maps properly. I have little patience, so while I respect the work the `ts-node` devs do, I'm choosing not to use it for now.
&gt; I've read some things on the internet that indicate there shouldn't be any problems at all, provided you wire up the source maps properly. I'd love to know how one is supposed to do that... 
Out of curiosity - what makes airbnb configs so popular? Is this the same as the ... company.. airbnb? In other words - why do I keep seeing "airbnb" mentioned in relation to linters/code prettiness? etc.
That's actually the setup we have at work that I'm trying to find an alternative to. It worked fine until we started experiencing weirdness. The specific problem is that 90% of the time when you run the tests, it reports lower than actual coverage, even if the tests pass. That odd time you run it, it will report the correct coverage. We have a 90%+ coverage goal so this was causing our CI builds to fail. A smaller issue that annoyed me in particular was the fact that you had no compiler help for the tests (just VS Code's TSLint) without setting up the `tsconfig.json` file for both `src` and `test`. So when you start ts-node, you get non-colored compiler errors out of the blue (I think you mentioned that there) and you can't ctrl-click the errors from that output and jump to them. So it was enough to irk me over time and want to come up with something better. xD
I have a working TypeScript, mocha, chai setup that generates reliable code coverage using nyc/istanbul. It uses ts-node for testing. What is the advantage of this boilerplate? 
Another one is Runtypes [https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)
Thanks! and yeah, that sounds like a major feature to me, nice to know that my front-end packages can use completely different versions of packages without conflicting with one another! I've followed you on here, if I run into any additional problems I'll PM you.
What's the difference with RxJS?
Or callbag or xstream?
It's for when the code coverage results aren't reliable anymore. I created this to solve an issue where sometimes when I hook ts-node into Istanbul to run my tests and report the coverage, the results are way off. The tests would always either pass or fail the same way, but sometimes the code coverage would come back as 60% when in reality it was 95%. My CircleCI builds would fail sporadically and it got to the point my team would have to sit there manually rerunning the tests both on their machines and on Circle until they got the true coverage and we could consider the build "passing". This wasn't acceptable to me so after lots of debugging and research trying to figure this out, I decided to just cut out the middle man and not bother using ts-node when there's no need to.
Interesting issue. I have yet to encounter it, but I know source mapping can trip things up for certain setups.
That's a good point. It does take longer to run the compiler and then run the one test you want when doing TDD this way. I'm going to keep looking into the ts-node issues in the future.
Cycle is more of a framework and uses stream library underwater (I believe it is xstream).
I'm working on [ts-auto-guard](https://github.com/rhys-vdw/ts-auto-guard) that's similar to those suggested. The use case is different though. It doesn't add runtime types, but instead generates type guards from standard TypeScript types. Not yet production ready but I'm getting there! My intention is just to use it in development/CI to ensure we're correctly typing our untyped server data, and then strip all the generated code in production.
You're not exporting your namespace. If you export it, you get a form that can be included. `export var ABC;`.
Cycle.js is a view library. Similar to React and Vue etc. But unlike the others it's completely based on event streams. So the workflow is different.
I'm using Bacon 2 in a project. The big advantage over RxJS is that it's easier to understand by only reading the documentation. I've had a very hard time understanding RxJS (but now I do understand it). And if you take the entire library, Bacon is a lot smaller than RxJS* but also lacks some operators, but the most important ones are available. *) If you configure your code bundler (e.g. Webpack) to use tree shaking the opposite is the case, though.
If the file doesn't have a top-level export or import statement, the Typescript compiler doesn't recognize it as a module. It gets compiled to global scope instead.
Look on the ts compiler options page: https://www.typescriptlang.org/docs/handbook/compiler-options.html, specifically for `--module`. I usually use `esnext`.
RxJS will be shaken by default as well if you're using pipes. But I got your points.
It's not quite that simple. When you use Webpack in combination with Babel or TypeScript tree-shaking doesn't work out of the box. As I wanted to find out what's causing this I tried Rullup "just for fun" and found this line in its documentation: &gt; First, we're setting `"modules": false`, otherwise Babel will convert our modules to CommonJS before Rollup gets a chance to do its thing, causing it to fail. Then I've tried the same thing with Webpack und suddenly the size of my bundle which uses RxJS has been cut in half (from ~200kb to ~100kb). It seems said conversion to CommonJS performed by Babel and TypeScript takes away the chance for Webpack to perform tree-shaking successfully.
Thank you. I've already tried setting to: "module": "ES2015", "target": "ES2015" But that alone was not enough. Toplevel export was the missing piece.
Cycle.js by default uses Xstream (by the same authors), but can also work with RxJS, Most.js and others.
There's a small section on the page: &gt; Bacon.js is quite similar to RxJs, so it should be pretty easy to pick up. The major difference is that in bacon, there are two distinct kinds of Observables: the EventStream and the Property. The former is for discrete events while the latter is for observable properties that have the concept of "current value". &gt; &gt; Also, there are no "cold observables", which means also that all EventStreams and Properties are consistent among subscribers: when as event occurs, all subscribers will observe the same event. If you're experienced with RxJs, you've probably bumped into some wtf's related to cold observables and inconsistent output from streams constructed using scan and startWith. None of that will happen with bacon.js. &gt; &gt; Error handling is also a bit different: the Error event does not terminate a stream. So, a stream may contain multiple errors. To me, this makes more sense than always terminating the stream on error; this way the application developer has more direct control over error handling. You can always use endOnError to get a stream that ends on the first error!
Funny you say that, as I kinda reckon I’m more confident contributing to a typescript project given I can easily understand the interfaces that I’m adding to/using etc, and I’m way more likely to become aware of breaking some other functionality at compile time especially if test coverage is poor
Yeah I think it's starting to change as more and more potential contributors are no longer scared off or even encouraged by TypeScript.
Interfaces are still part of the .d.ts files.
[https://github.com/typestack/class-validator](https://github.com/typestack/class-validator) &amp;#x200B; [https://github.com/nestjs/nest](https://github.com/nestjs/nest) is a full solution that might be worth checking out 
Same preference here, and I agree that anything is fine. Plus, with TS writing all my import statements for me, I don't worry so much about perfect filenames. I use named exports for everything and the language service helps with the rest.
Check out https://github.com/lukeautry/tsoa. Payloads are validated according to their implementation to TypeScript interfaces/classes.
Okay but for example TypeScript cannot check that if some email is actually valid. I have to check that too 🤔
&gt; You can still abuse union and any types to avoid true strict typing. How would you abuse union types to avoid strict typing? Unions are still typed.
&gt; With CLR now cross-platform drop the C# ball and write us a Typescript Native compiler. In my opinion Microsoft has better odds of success with a huge community that already understands and writes Typescript! The CLR does not support many features that TypeScript offers, e.g. prototypical inheritance and union types. And changing the CLR to support such things is beyond any reasonable scope.
To support specific features you need CLR support. C# can't just add whatever it wants either, some changes require CLR support. Just in the same way that TypeScript can't do things that are not possible in JavaScript.
You don't need that support for everything. TypeScript is diffrent because it wants be good JavaScript not just another lanugage so it doesn't break rules. Look at IronPython or F#. You could say you can't make F# without changes to CLR.
I suspect they mean unioning a type with any. I.e type ‘MaybeMyType = MyType | any;’ It really does defeat the point though and should be treated as a major code smell 
`MaybeMyType = MyType | any` is not a union type. It's equivalent to `MaybeMyType = any`.
Yup, which is why it’s a bad idea. I just suspect that’s what the OP meant given it uses the union operator to coerce a type into any
I have the following code: main.ts: /// &lt;reference path="./ABC-model.d.ts" /&gt; export namespace ABC { export class X { constructor(public data: ABC.K) {}; ==== }; } ABC-model.d.ts: declare namespace ABC { export interface K {}; } When I run "tsc" I get: '"/path/to/file/main".ABC' has no exported member 'K'. So the error happens in TypeScript, not JS. I have underlined the area in the file (using "====") where the IDE also highlights the issue.
It would be nice. I love Typescript, I've been rooting for it since 0.9 came out and I realized I didn't need to suffer legacy Javascript anymore. I'd gladly write a middleware API in Typescript. But I take issue with the author's slagging on Java (&amp; C#, which is essentially MS-Java). I like Java 8+ just as much as I like Typescript. Why? Because it's evolved well over the years. The Java we can write now bears little resemblance to the overly verbose syntax we had to write 10 years ago. And the library maturity is second to none. And a good IDE practically writes the Java for you! The only thing I hate doing in Java is manually parsing XML and Json, but even that isn't so bad if you use a few tricks. I never left Java for Node.js because I understand what makes a large backend codebase maintainable over a span of years... and it's easy, safe refactorability, which Java has in spades and Javascript IMHO does not. 
This driver was started from scratch by a core firebird contributor Adriano , now that is stable there will be more users (you can watch the download counter). The advantage for this one is that is based on Firebird 3.0 new OO api with a few advantages (speed , clean interface) compared with legacy api There are more downloads (2k) for previous driver (pure javascript) that is using firebird remote protocol https://www.npmjs.com/package/node-firebird 
&gt;Not every library you use will use TypeScript. This means that you'll either have to build your own [Declaration File](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html) or lose the advantage of strong typing in the part of your code that interfaces with the third party code. &amp;#x200B; You are forgetting the third option of using @types over at npmjs
sry. i got mixed up. i always fuck up namespaces in ts, so i avoid them.
It seems that this is not true any longer with Babel 7. Adding `"modules": false` doesn't change anything. In fact tree-shaking works either way. That's nice, I guess.
Not every library has a @types package created for it though. Especially niche packages.
They basically wanted to make using Typescript as easy as using Flow, so they collaborated on a plugin for Babel. Ordinarily you’d use Babel + Flow *or* Typescript, it’s somewhat odd to have Babel transpile from TS, which has its own transpiler, but it makes it a very easy switch if you’re frustrated with the type definitions of Flow and want to consider Typescript instead. 
For me this is great because tsc is extremely slow. I’ll use it in a pre-commit hook, but this will make using typescript in a large project much faster.
I don’t know a lot about TS, but a quick flow check was always nice and easy. Is TS that much slower?
I recently setup a typescript SAM project, and I used these 2 projects as examples: [https://github.com/alukach/aws-sam-typescript-boilerplate](https://github.com/alukach/aws-sam-typescript-boilerplate) [https://github.com/Giftbit/sam-scaffold/tree/master/typescript](https://github.com/Giftbit/sam-scaffold/tree/master/typescript) &amp;#x200B; They both seem to use webpack for what you're talking about, which has worked fine for me so far.
One case this can be useful is [where you have a ES6 JS library you want to compile](https://medium.com/dailyjs/refactoring-an-old-and-broken-library-to-using-async-await-with-tdd-90157de268a2) - before I converted the project to Typescript, I actually used tsc as my preferred JS compiler because it worked and output the required features I needed. Could be a good step to help with conversion as you gradually move JS to TS.
I still don't get why people use babel with TypeScript. TypeScript can already transpile modern JS down to the oldest runtimes, and a basic TS project setup is really simple. Why bother adding another million packages and build steps?
Also there is one great library https://github.com/gcanti/io-ts.
Guys, this is the real answer. Upvote that man!
Hmm, I inherited a js based React Native project and am gradulally migrating the components to .tsx files and putting typing in. I don't have any problem consuming the js components, though admittedly there are (thankfully) few SFC. Could you maybe give an example of how you're trying to use them? 
In general, yeah - but there are use cases: 1) Babel transpiler is faster. You can do typecheck in ide/cli like you would do linting but then save this ~40% on build time. Esspecially with larger codebases ts loaders are bottleneck and you can actually get rid of unnecessary build steps by using Babel. 2) Babel ecosystem is rich with really useful and sometimes necessary plugins. 3) And, most importantly - you can easily make non-typescript projects work with typescript codebase by installing just one small plugin (instead of some build time hacking or maitaning whole separate fork like it's done e.g. with create-react-app-typescript) - just drop ts plugin and voila (i.e. like Gatsby v2) - all simply works. And with Babel 7, setting up the project is also a breeze. If I'm starting a new project I would do it in regular typescript way, but I'm glad that I have this tool handy for when I need it. 
My use case is really simple ¯\_(ツ)_/¯ // Button.js const Button = ({ onClick, theme, children }) =&gt; &lt;button theme={theme} onClick={onClick}&gt;{children}&lt;/button&gt; Button.PropTypes = { onClick: PropTypes.function.isRequired, theme: PropTypes.string, // &lt;-- Not required here either children: PropTypes.node.isRequired. } // Some newly converted to TS Component import { Button } from './Button' const NewComponent: React.SFC&lt;Props&gt; = (props) =&gt; ( &lt;div&gt; // Button complains here because it doesn't have the `theme` prop &lt;Button onClick={() =&gt; {}}&gt;Click Me&lt;/Button&gt; &lt;/div&gt; ); Error: Property 'theme' is missing in type '{ children: Element; onClick: Function; theme: any }'. ^^^ Error suggests that for some reason TS has parsed the parameters and defaulted everything to `non-nullable` // Output in the VSCode tooltip (alias) const Button: ({ children, theme, onClick }: { [x: string]: any; children: any; theme: any; onClick: Function; }) =&gt; JSX.Element 
Typescript also has no built in tree shaking while babel does, so there was already a use case for mixing typescript and babel before this release. 
If you're having problems with speed, I'd be curious to hear about your setup. Usually we hear about people running TypeScript on way more files than they should be. You can test this out with `tsc --extendedDiagnostics` Or using the `--listFiles` or `--traceResolution` flags.
Babel doesn't tree-shake as far as I'm aware? There's Babili but that's it.
So the components you import from js are typed? When I did the same thing, anything from js would be typed as any. Either way, start from the leaf nodes in your dependency tree. 
So how would you use it with express? For example if I want to check that phone number is valid phone number? 🤔
If they can figure out a way to keep innovating the typescript language while also maintaining a typescript AST native code generator, I'm game. I'll live with whatever runtime library is necessary if I can link it with C. The #1 thing I've loved typescript for is definately the release cycle and tooling based on the amazing progress they've made over the last few years alone. And for all of the people saying that we should just target WASM, I'll say that there's lots of people who couldn't give less of a shit about running WASM on their server. The main focus here is platform native code like Rust or Go --- no VM. 
&gt; Java has a better runtime It's weird, seems like C#/CLR has so much potential and the ability to really shine where Java has failed, but the tooling always sucks balls, and the damn runtime wasn't even cross-platform until recently, and if I want to use any third party packages on, say, Linux, I'd better hope there's no unsafe Windows code in there. Oh, another package manager... another damn build system to maintain? Is there a Java to C# converter that can actually help me migrate my project? I mean that was at least half of the hype behind the language geeks designing C# to begin with -- writing compilers to do that. Lol. I'm glad I don't really work in the native code world anymore... typescript all the way down.
I am confused on what do you mean by a valid e-mail and password. Are you checking if this is "any" e-mail, or one from a database? Do you have a list of valid or invalid e-mails that you want to check against? Regularly you want to have a middleware that received the posted data, and in the body of the middleware check using your list / database. If you just want to validate the data structure or type /u/Move_Zig already mentioned joi that I would suggest as well. This would help you use the same validation code on the browser, and return errors (e.g. mistypes) immediately without sending a request to server and getting a response. However, if you want to validate against your own data on the server, then you should first keep a map of valid e-mail addresses and passwords and validate that way. What are you planning to do once you have validated the entry? I think a good starting point would be to use [passportjs](http://www.passportjs.org/docs/username-password/) middleware.
I would guess the question was fundamentally wrong and if you have a problem, probably it is somewhere else. I.e. the issue never existed in the first place.
This might help: https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files If you want type checking but also want to make some props optional look at adding JSDoc comments to your components. TypeScript pretty much fully understands the type information provided in JSDoc.
I'm using it in a large React monorepo that has been ejected from create-react-app and modified a bit. `extendedDiagnostics` tells me that there are 819 files, with 224542 lines
Your component is an SFC component. Basically it is a function that gets an object that has three properties. When you call `&lt;Button onClick={() =&gt; {}}&gt;Click Me&lt;/Button&gt;` you are calling `Button({onClick: ()=&gt;{}})` and the object you are passing doesn't have theme (It gets children from React). A possible solution is to do something like this: `type ButtonProps = { onClick: () =&gt; void, theme?: any}; const Button = (props: ButtonProps) =&gt; &lt;button theme={theme} onClick={onClick}&gt;{children}&lt;/button&gt;` And this should solve your issue.
Yeah I would like check that the email is any valid email. For example \`asd@asd\` is NOT valid email but \`asd@asd.com\` is. &amp;#x200B; So do you recommend Joi also with TypeScript?
Certainly, with its type definitions. Alternatively, you can also check yup (which is minimal joi). The reason I use Joi is to create the templates from json-schema which is shared among c++, c#, nodejs and browser (angular) projects and this is very easy with Joi.
He coulda said that then. He didnt even respond to me.
It does some out of the box, however, while some libraries require special plugins(like lodash) to properly treeshake, also have to configure typescript to not transpile the imports for it to work, I had great success with it on a project last month, dropped my 11 Meg blob of js down to like 2 megs with no side effects. 
I suppose doing something like `type A = string | number` to support JS code that has been (accidentally) written to work with both.
C# can emulate prototypical inheritance with `dynamic` type and `DynamicObject`. F# has discriminated unions. Both compile to CLR.
Old habits die hard I guess. I couldn't imagine going back.
I can think of a few reasons. &amp;#x200B; 1. Typescript can be very painful if you're using JS libraries that don't have, or worse have inaccurate, type definitions 2. Gradual typing hasn't stood the test of time yet. 3. some people prefer dynamic typing and there is little empirical evidence that static typing is a clear winner. 
&gt; 1. Typescript can be very painful if you're using JS libraries that don't have, or worse have inaccurate, type definitions This is probably the single largest pain point for typescript. The world is still collectively learning the best way to type libraries. This means that they often start broken and then move on to breaking changes.
I'm not sure if Babel transpiling faster is correct, I haven't seen any benchmarks. TSC is very fast with \`--transpileOnly\` flag set. &amp;#x200B; I think the only reason Babel 7 supports typescript is for projects who already have a babel build system and are slowly moving their projects into TypeScript.
&gt; some people prefer dynamic typing and there is little empirical evidence that static typing is a clear winner. I think there is quite a lot of empirical evidence supporting static typing. Simple things in TypeScript make this really clear. Dynamic typed languages end up reinventing what is basically a shitty version of a static typing system through syntax checking and tests. Just the feature of being able to rename a property and have it cascade throughout your codebase with a high degree of certainty that it actually **worked** is a really big deal. In the cases where devs claim they are more productive with dynamically typed systems, I end up finding that they're using a statically typed language like it's a dynamic language, e.g. using magic strings to control program flow. The productivity doesn't take off until you embrace the type system.
There isn't any clear empirical evidence that TypeScript is better than Brainfuck, but all indications are that it is a more productive tool. How are we able to say something like that and be reasonably sure that it's true? It's very, very difficult, maybe impossible, to make causal claims about languages on a large scale, e.g. Language X results in 10% fewer bugs. The best you're going to get is observed correlation on the part of professionals that have a lot of experience with different languages. I've spent untold hours looking at and modifying Ruby codebases, vanilla JS codebases, Go, Java, C#, Python, and TypeScript codebases, and there are just certainly classes of mistakes that I make in the dynamic languages that are literally impossible to make in static typing land.
I’ve been coding at scale for over two decades, and I’ve led large teams for over a decade. I’ve seen very little difference in project outcomes across different languages. If it makes any difference at all it is dwarfed by many other factors. I say this as someone who prefers typescript over JavaScript. 
Don't think Babel does tree-shaking. Seem's like in the domain of WebPack. 
Eventually `Button` will be converted to TS, but it'll be component by component so the goal is to be able to start gaining more type safety as things are converted over. If I keep running into problems like this, it feels like I'd have to convert the entire codebase at once.
If you are going for a quick conversion just do: `const Button = ({ onClick, theme, children }: any) ...` Perosnally I don't like this and I suggest fixing it later and not using `any` like that but it is a solution for now.
Button will get proper types when converted, but since its still a JavaScript file, I shouldn't need to give it types
How much code do you reuse? 80%? I'm doing a mobile app with Flutter and I need to create a web app too. For my backend I'll use a BAAS. I was looking forward to start with Angular Dart but the learning curve is a little steep. I'm learning Vue and I find manageable. If you were to pick one, which one would you recommend? Vue or Angular Dart? Btw, we're a 2-man team with basic JS knowledge.
Oh sorry, did demoran's solution of using `theme = undefined` work? 
I have a webpack and TypeScript project and it tree shakes! Might be a configuration issue!
Looks great! I've been using mst-react-router, which is an adaptor to using react-router with mobx-state-tree. It works rather well for my use-cases.
Yep, just sucks that I can't seem to tell TS to stop guessing at JS files
Seems like a useful package! One of the reasons that pushes me to write this boring router instead of to use react-router is the weirdness having to sync history with state. While it could just be a simple location-state-view flow.
If all you need is to re-export something you can do export { BaseRequestType, SomeComplexType } from 'projectA';
Does tsc only compile files with diff from previous build? If you only change 1 file, all 818 other files shouldn't have to recompile.
Thanks, I actually had a weird experience with this, where `makeRequest` had a "type not found' error when I immediately exported those things. I'll try and reproduce and submit it as a bug. 
Oops! Wasn't paying attention to the fact that you were using the types as well.
That's our use case. But we'll probably keep Babel in production build for `babel-plugin-lodash`.
FYI your example actually is a valid email by the spec.
Just had a quick look and was wondering if there is anything preventing the children of not-shown routes from being executed even if they aren't shown?
Yes, I think you may use route component: [examples/route-component](https://github.com/makeflow/boring-router/blob/master/examples/route-component/main.tsx). And I guess something like [react-loadable](https://github.com/jamiebuilds/react-loadable) should just work out of the box if you want some asynchronous stuffs.
Do you mean something like: ```tsx &lt;Route&gt; {props =&gt; &lt;div&gt;&lt;/div&gt;} &lt;/Route&gt; ``` Currently no, but you can do that with `component` property if that looks acceptable to you: ```tsx &lt;Route component={props =&gt; &lt;div&gt;&lt;/div&gt;}/&gt; ```
Yea, something like that. Thanks for your responses
There is a famous [paper](http://web.cs.ucdavis.edu/~filkov/papers/lang_github.pdf) that analyses the correctness achieved with various programming languages and while there is some correlation between statically typed languages and less bugs, it's nothing convincing. For example, Clojure and Erlang are less error-prone than C# and Java, for example, even though they are dynamically typed. &amp;#x200B; P.S. Ignore TypeScript in this paper, it's actually C++, but GitHub mistakes Qt translation files (.ts) for Typescript. 
&gt; For example, Clojure and Erlang are less error-prone than C# and Java Yeah, I'm familiar with this paper. I've known the sorts of programmers that are really into Clojure/Erlang/Elixir. A very, *very* rough heuristic is that anyone using those languages is doing so because they want to. A much larger portion of the C#/Java userbase is phoning it in, adding patch after patch to some Enterprise bloatware they don't care personally about. I actually think JavaScript/TypeScript is in a unique position to be studied on this topic since it's fundamentally the same language, but TypeScript is just the static typing layer on top. It would be a good way to test the proposition, "all other things equal, does static typing help". And I would guess that it does because people who start using TypeScript often refuse to go back.
I… don’t actually know 
Just curious - are you already using [https://www.npmjs.com/package/fork-ts-checker-webpack-plugin](https://www.npmjs.com/package/fork-ts-checker-webpack-plugin) ?
A large part of the interesting ecosystem is built with Babel. Things like Prettier, JSCodeshift, etc. You also have all of the babel plugins that do more than just compile stuff to ES5. Things for performance optimization, invariants, various form of instrumentations, etc. Having one platform to do it all is great. But you also want to use TypeScript. So before, you'd do things like use TS to strip the types and compile to ES6, then use Babel to process the ES6 with all its plugins. You end up needing 2 compilers, and you unfortunately have not solved all of the issues with tools that do more than compiling (the Prettier and JSCodeshift of the world). Babel with TypeScript support to the rescue. For typeschecking, you can use TypeScript separately and do just that. For example, a Babel + fork-ts-checker-webpack-plugin is a great setup in Webpack land.
all you need for tree shaking to work is for the ES6 import/export to make it in the output somehow. If you compile them away to CommonJS with TS then yeah, won't work. As far as I know thats configurable though.
Compiling to ES5 isn't the interesting feature of Babel. As mentioned in the other comments, Babel has a pretty rich ecosystem and its API is well understood and easy to use to build your own. Anything from processing legacy code to make it work with some exotic system, to performance enhancements, removing code that's only there to ease development, adding instrumentation, you name it. I also mentioned it above, but some tools rely on Babel to do things like reformatting (Prettier) or refactoring (JSCodeshift), and until TS support was added to Babel, TypeScript users were stuck in the stone age as soon as you were talking at tools that went beyond types and editor support. No more.
[removed]
I know that tagged unions are narrowed down when you test `if("prop" in data) {`. It's a slightly different situation, though. I don't have an answer to your exact question.
If you narrowed the type then it would not be possible to set the property to undefined later. There is also the issue that the reference might be captured elsewhere and mutated under your feet.
&gt; f you narrowed the type then it would not be possible to set the property to undefined later. This is not an issue when passing arguments though. 
Nope, but you would need to do call site narrowing in addition to retaining information from the property test, which is most likely expensive. Though the main issue is that this isn’t safe unless you have significantly more complex flow analysis.
adal_angular I’m looking at you
This is not safe but as I pointed out TS already accepts the non-safe version if you pass the property itself rather than the object. Passing the property is in no way more safe.
I see. Interesting ergonomics issue then and a case where the type system is problematic for something with extremely low risk of bugs that the dynamic typing allows.
Which file was this ? I get these "problems" in the code generated by the VS templates in the components FetchData.tsx and Counter.tsx.
Use ` "moduleResolution": "node"`. It'll tell TypeScript to look within "node_modules" just like node does, and you won't need to explicitly reference any @types packages. If you still need the triple slash reference, instead of reference path, use ` /// &lt;reference types="angular-mocks" /&gt;`
&gt; he reason that someFunction(data) fails is that you're passing a reference to the data object, which is mutable. But someFunction({ prop: data.prop }) works because you're taking a reference to the non-undefined value of prop. If you mark `prop` as readonly it still fails. Mutability does not factor in here.
The real problem is aliasing of mutable references. My example was contrived but there are many easier ways to manifest the problem.
If the object was completely immutable then the narrowing would be safe. Mutability and aliasing means it is not.
Even disregarding the desire of TypeScript team to follow the ECMAScript standard closely, I'm not sure this is a good idea for a language. While I rarely use `this` in Java or C#, I certainly see its benefit in distinguishing between local/global/closure variables and class instance properties. In my opinion, always using `this` is superior to occasional omitting and adding it for disambiguation of name conflicts. It also feels somewhat less clear for beginners, because variables and fields have important differences, so it makes sense to use different syntax for them.
All of TypeScript's additions break JS syntax. As long as `this.` is still valid (though optional) I don't see why that would be a problem in that regard. But it would add complexity to the compiler for perhaps dubious gain, since it wouldn't really help with correctness or tooling.
&gt; All of TypeScript's additions break JS syntax. TypeScript is a superset of JavaScript. Remove all type annotations and you end up with valid JavaScript.
For those wondering - this is correct, the downvotes are for the snarky tone.
This isn't quite true. TypeScript also adds enums, which aren't at any stage of proposal, as I understand it. That said, enums were an early addition, and I don't think the philosophy of "JS + Types" had fully been stated at that point.
Sure, but part of the TypeScript philosophy is to only add type annotations. They could add anything they liked - bind operators, new methods, matches - anything they liked, but it would take away from the stated philosophy of the TypeScript project, which is to add types and only types. (And also enums, but you've got to sort of ignore some of the older decisions like that...) One specific issue with the suggestion here is that it would be a major breaking change, and probably quite a difficult one to implement, because there's a lot of completely valid and idiomatic code that refers to variables in places where the type of `this` is known. You could potentially filter the change in over a couple of major versions (one providing deprecations and warnings, the other actually implementing the change) but that would take months to years, and even then could cause all sorts of issues. Of course, the other issue is that there isn't really a lot of need for this. It's just syntax sugar, and it's very questionable syntax sugar at that - it doesn't make it easier to do anything that's particularly complicated, it literally just shaves five characters off some variables. There's not a lot of incentive to make that sort of change.
I agree that it would add complexity to the compiler as well as mental overhead of knowing where it's save to omit `this.`, but it wouldn't be a breaking change. I think an assumption in the question is that it would be implemented in a non-breaking way. If there are local variables shadowing `this.` variables of the same name, then it simply couldn't make those replacements. 
I'm not supporting the idea, only saying that "TypeScript is a superset" (and now, "it would be a breaking change") aren't valid objections to it.
I asked this on day one when I first started with Typescript 0.9. I got some nonsense answers about language design that didn't pass the smell test. It's slightly annoying because, as you said, a language can be designed perfectly well with this-less class vars with local var overrides, and this. as a disambiguator. It's definitely more pleasant that way. AS3 does it. Java does it (for method arguments) Sadly, it is what it is, and since Javascript doesn't work like that, Typescript is never going to work like that. It's a minor (well medium sized) annoyance that I still get caught by sometimes, but my IDE tells me I goofed and I move on.
Use the declarations generated by typescript. Make sure your package.json's "types" field points to them (just like how the "main" field points to your main js entry point, "types" points to the main declarations file corresponding to the entry point js). Declare all your @types dependencies as regular dependencies, not devDependencies. That way, when someone npm installs your library, npm will also install the necessary devDependencies. The declarations generated by TypeScript will refer to them, `"moduleResolution": "node"` will do the right thing, and everything should "just work."
I usually generate type declarations and include them using the “types” field in your package.json. If you don’t want declarations for internal functions to be emitted, you can use the @internal jsdoc comment and the —stripInternal compiler flag. If your library is already written in typescript, don’t rewrite the types separately. That just increases the chances of errors and then no one can use your module correctly. As for including types, if you use the “types” package.json field and make sure the .d.ts files are packaged, then tsc will pick them up automatically. Your current trick should work, but it’s definitely not the optimal route. I only do that when I’m working with someone else’s untyped module and I haven’t yet published the types I wrote for it to DefinitelyTyped
Suppose this feature were added in some way, to some degree. If you could still rename `file.js` to `file.ts`, compile it with TypeScript, and get the same program back (with perhaps some superficial changes), then it's still a superset of JavaScript. If the new compiler still compiles old TypeScript code and produces the same output, then it's not a breaking change. Making *previously invalid* code into something valid isn't a breaking change. One question is to what degree the feature could actually be implemented with those constraints. Little or none? That would be a strong, valid objection. It would certainly add complexity to the compiler, making it slower and more prone to bugs. That's a valid objection. It would potentially make code harder to reason about in some cases. That's valid. And I don't see how it would improve Intellisense, code navigation, refactoring, etc., so I would say another valid objection is that the feature would have limited value. 
Sure, I get that, but that's not the point I'm making. Regarding the superset thing, TypeScript isn't just a transpiler, it's a project that aims to add nothing but types. As this is not types, this isn't therefore something that's really suited to the TypeScript project. Regarding the breaking change thing, the fact that a proposal would have to either be a breaking change, or a deathtrap waiting to happen, means that it is entirely valid and sensible to reject the proposal as too large a breaking change at this point. These aren't arbitrary issues. Sure, that a non-breaking version of this proposal would make code extremely difficult to reason about is an issue itself, but so is that the proposal would go against one of the core philosophies of TypeScript.
You're counting namespaces and reference comments as types, then?
Reference comments are types, they're a mechanism to state where types can be found, and namespaces are a mechanism to be used largely in type definition files to mimic the more complex modular structures of regular JavaScript libraries. The example you *should* have used was enums, which, unlike the things described above, are a non-zero-cost abstraction that adds more than simple types, and do not map directly to any JavaScript concept. That said, it's worth pointing out that enums were added to the language before it had even reached 1.0, at which point the designers weren't quite so strict about ensuring that TypeScript was just JavaScript with types.
Thanks for the response; looks like I'll be going forward w/ using the generated declarations. I'm aware of the other points you bring up, perhaps I was not clear. What if I wrote my own declarations for an external dependency in a custom `@types` directory at the root of the project? Types don't exist for it, and creating a typings package for it would not be ideal (I only wrote declarations for the bits I'm using).
&gt; If you don’t want declarations for internal functions to be emitted, you can use the `@internal` jsdoc comment and the `--stripInternal` compiler flag. Thanks for this; I'll give it a shot. &gt; If your library is already written in typescript, don’t rewrite the types separately. That just increases the chances of errors and then no one can use your module correctly. That makes sense. &gt; Your current trick should work, but it’s definitely not the optimal route. I only do that when I’m working with someone else’s untyped module and I haven’t yet published the types I wrote for it to DefinitelyTyped Yeah; that's what I'm doing. The only reason I haven't published to DefinitelyTyped is that I have only written declarations for the pieces of the module that I am using... Thanks for the help!
Namespaces are syntactic sugar to reduce typing (as in fingers-on-keyboard typing) like the OP is requesting, which were added long after 1.0 to replace internal modules after modules were added to the ES spec with conflicting syntax. So that's another reasonable objection: that ES could someday allow omitting `this.` in a way that's subtly incompatible with the way TypeScript might do it today. I didn't mention enums because you already gave that example, and enums are technically types anyway. Reference comments are just not types, no matter how you look at them.
I think if this is a medium sized annoyance to your daily work, you should consider yourself a quite lucky and happy person. :) 
Haha, well maybe it's a smedium, for dramatic effect. And I work at home so I am lucky!
I definitely think this is necessary. You already answered why. Leaving it off makes it a local/global variable. Not having a local/global of that name does not mean you intended to use a member variable. You maybe meant a local/global that isn't defined, and debugging that sounds like a major pain because it worked with the wrong value instead of throwing an error.
Oh I see, I misunderstood. I think you'll see problems if you bundle incomplete declarations for "libfoo" and then someone tries to depend on your library *plus* libfoo plus @types/libfoo. (assuming someone publishes DefinitelyTyped declarations in the future, or bundles their own) You might have conflicts between the two sets of declarations. In my informal testing, the incomplete declarations shadow the other ones. So I get errors trying to import things omitted from your incomplete declarations. I think the fix is pretty easy, though. In your project, make 2 files, "libfoo.js" and "libfoo.d.ts". // libfoo.js module.exports = require('libfoo'); // libfoo.d.ts // Put your incomplete declarations here declare export function libFooFunction() {} declare export type LibFooTypeEnum = 'foo' | 'bar' | 'etc'; Then when you want to use libfoo, import it via the relative path. import {libFooFunction} from './libfoo'; This ensures your bundled declarations remain local to your library.
The example does not work. &gt; git clone https://github.com/tswistak/react-inversify-example.git &gt; cd react-inversify-example &gt; yarn &gt; yarn build Results in: &gt; Failed to load tsconfig.json: Missing baseUrl in compilerOptions
You'll love angular then. 
The project I used it in was a Node Express project. It felt useful for injecting the stateful resources– database connections etc. But then I think I ended up over using it. Though, it feels like it has a lot of buy in, and it's easier to just use it for everything. Repository pattern.
I love it. I will admit inversify is _probably_ overkill for most projects, though. Setting your code up to use composition is by far the most important part, and you can do that without any sort of IoC container.
I see, that makes sense; I hadn't considered the potential issues of shadowing declarations that may be added down the road. Thanks for the help! I'll give your example a shot and play around with the problem some more.
Haven't tried in React but my before TS I did a lot of C# and Java with DI. I honestly don't like it. I try to write TS more functionally, I think it fits the language better.
[https://www.npmjs.com/package/itiriri#benchmarks](https://www.npmjs.com/package/itiriri#benchmarks)
I've played around with it in a Node/Express app and I loved it. I always felt like it was easy to come back to the existing code and add a cross cutting concern (ex. logging) because all I had to do was register a new class as a dependency and then add constructor parameters to anything that I wanted to use it. This felt nicer to me than sending down the dependencies from the app's entry point. I'm sure I could have gotten by without it, since my layers weren't that deep anyways (**entry point -&gt; controller -&gt; service -&gt; dependency** is usually as deep as it went) but since I'm already familiar with the pattern, it felt like common sense to take advantage of it.
&gt; Do you think using 'this' is absolutely necessary? No. I rarely use `this` because closures are usually better than classes.
How about creating a `projectA-common` which is shared by both?
I recently started a backend project with inversify, and felt the same way. Luckily, I discovered Nest shortly after and haven't looked back. It's literally Angular for the backend. Using Nest and Angular I can't even tell if I'm working on frontend or backend code half the time. All TypeScript all the time.
There's a specific design goal which says there shouldn't be new value level syntax added that's not there in Js.
I've started to use `this` more often in C# now, because it helps me see more clearly what kind of state I'm dealing with.
Just include the folders you don't want to commit in your .gitignore file. I include my build directory as well as node_modules/ and typings/
But if i don't include the output of the build directory, my library is not importable. When adding it to another project. If i do this ts-node complains complains that it cannot import the library, because it doesn't understand import. (ts-node does not compile stuff under node_modules). 
Are all of the apps consuming this library guaranteed to be TS? If you have any potential consumers that are just regular JS then you have to commit the files built by TSC. another way would be to have a repo for source code and a separate repo for the built files
With an npm package, the transpiled code is inside the npm package, not inside your repo. See `prepublishOnly`: https://docs.npmjs.com/misc/scripts To sump up: the npm package content is different from your Git repo. If you import directly the repo (`git+ssh://`), well you don't have a choice: you need to have the transpiled code inside your repo (or the app that uses your library needs TypeScript).
It’s not that big of a deal though, are you configuring tsc to put all the files in a single directory like dist/ or build/ ? If not, I highly recommend. Then you won’t really have to look at them. You can even configure your text editor to ignore the directory if you want. 
You either have to publish the output to an npm registry as a package or commit the output to github, the former is preferable imho, but involves more work setting everything up.
Back in the day (a few years ago) people would commit the JavaScript files under a different branch or tag to "reduce the mess," but ultimately you should look at a private npm repository instead.
Try putting your build stuff in the `prepare` script of your `package.json`: { "scripts": { "build": "tsc", "prepare": "npm run build" } } From the [npm 5.0.0 changelog](https://blog.npmjs.org/post/161081169345/v500) : &gt; Git dependencies with prepare scripts will have their devDependencies installed, and npm install run in their directory before being packed.
That’s awesome! I had no idea that existed. 
Overall it seems pretty nice but I do have a few minor comments: 1. Style is of type `object` which isn't great IMO. If it's styling to be passed for react they have a type for that (I think it's `React.CSSProperties` or something like that), if not, I think you should use an interface or type (If possible). 2. Color is `string`. Is it limited to a certain type of colors? if it is a **short** list I would consider using it as a type instead of `string`. 3. This is more of a React thing and depends a lot on your code but for me the type `string | number` is a code smell. In many cases there isn't a need for one of them and it just creates a lot of extra work. With that said, this comment could be completely irrelevant in your case. &amp;nbsp; All of mycomments are pretty minor and are more suggestions, but other than that it looks nice!
You and I have differing ideas about what constitutes a superset, which I suppose at some level is a Ship of Theseus problem. With enough syntactic sugar, TypeScript could be made to optionally look nothing like JavaScript but still allow JavaScript to be valid TypeScript. You could probably even make Dart a subset of TypeScript, given that Dart can also transpile to JavaScript.
##r/javascript --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
I really wish something good like this existed with the same API as ramda.
I'm using it in the same sense as YAML being a superset of JSON, C++ being a superset of C, etc.
public abstract stuff?: Array&lt;keyof IProperties&gt;; that's where i'd start looking
Co author here. We didn't take ramda in consideration when creating it. If you have any suggestions feel free opening an issue or just writing me a message. 
You can just assign the type to stuff and it will typecheck. interface IProperties { name?: string; } abstract class Model&lt;T&gt; { public abstract stuff?: Array&lt;keyof T&gt;; } class AwesomeThing extends Model&lt;IProperties&gt; { public stuff: Array&lt;keyof IProperties&gt; = ['name']; } Typescript has some problems detecting that array containing a string is an array of only a string literal unless you add the type to the variable. It widens the type to string by default. 
You could look into backstopjs or exquisite-sst. You generate "reference" pictures and will notify if something changes when you run the tests again.
type `name` != value `"name"` which is of type string
I figured this is what you meant. And I think what you are saying is the accurate way to describe the relationship. Perhaps a better way to have made my initial point is that TypeScript is a *semantic child* of ECMAScript, and that it is largely understood by its relationship to JavaScript. But as I think more about the relationship between C and C++, I will concede that this does not really even matter for something like removing "this" conditionally.
It's also possible without the explicit declaration. ``` function specifize&lt;T extends string&gt;(p: T[]): T[] { return p; } abstract class Model&lt;TProperties&gt; { public abstract stuff?: Array&lt;keyof TProperties&gt;; } interface IProperties { name?: string; } class AwesomeThing extends Model&lt;IProperties&gt; { public stuff = specifize(['name']); } ``` The `specifize` function converts an array of string literals to an array of the union type of the literal types it contains.
Post what you've done so far somewhere, give people a place to start. 
the first and second issue is because you specified foor and Baz is of type { name: string} which is means that the name property is required. If you defined you type as {name?: string} then it wouldn't throw an error.
&gt; type Bar = string | { name: string } | any[]; Try putting the `string` part at the end; maybe it's positional
Okay sure.. ill update the post
Just a guess: In the first example, it's obvious when you specify an object literal that you're trying to make an object value, not a string. There are only 2 options in the union. Easy peasy. But in the second option, an object literal could be either an Array-like object or an object-like value, since Arrays are just a different kind of object. (non-primitive). So maybe in the second case, TS can't narrow the union to a single option, so it falls back to matching on the union's 3 options in order. Since they all fail, it shows the failure for the first one.
Okay, updated
Updated.
I'm intentionally omitting the \`name\` property because I'm simulating a real mistake The first and third give me helpful error messages, and the second gives a weird one.
I think you're right, and it makes me think there's a hidden ordering to the inferred fallback type that places the primitives ahead of the object. I have no idea if that's fixable without worse consequences. The fact that both the first and third examples give good errors seems to suggest a true bugfix is possible, though. By the way, the same issue occurs with `number` instead of `string`, so it's not due to `string` being array-like.
He wasn't saying it was due to a string being an array like object. He was saying an array is just an array like object. In js an array is basically: { [0]: first item, [1]: second item, .... prototype: array methods }
When your value is not assignable to any of the unioned types, it just picks one for the error message. The error message is not _wrong_, although a more complete error message might be "Type {} is not assignable to type 'string', nor is it assignable to type { name: string } -- Property 'name' is missing in type '{}', nor is it assignable to type any[]. There is definitely some logic that helps choose the more likely of the unioned types that you are trying to match for the first and 3rd examples, but for the second, the inclusion of that array type is aborting this logic and causing it pick a different type. I have no clue what this logic actually looks like, but I'm curious, so I had a look at the compiler source. All snippets below are from [checker.ts](https://raw.githubusercontent.com/Microsoft/TypeScript/master/src/compiler/checker.ts). if (reportErrors) { const bestMatchingType = findMatchingDiscriminantType(source, target) || findMatchingTypeReferenceOrTypeAliasReference(source, target) || findBestTypeForObjectLiteral(source, target); isRelatedTo(source, bestMatchingType || targetTypes[targetTypes.length - 1], /*reportErrors*/ true); } // and later function findBestTypeForObjectLiteral(source: Type, unionTarget: UnionOrIntersectionType) { if (getObjectFlags(source) &amp; ObjectFlags.ObjectLiteral &amp;&amp; forEachType(unionTarget, isArrayLikeType)) { return find(unionTarget.types, t =&gt; !isArrayLikeType(t)); } } So that's pretty interesting. Source is your `{}` and target is `Foo`. So, in `findBestTypeForObjectLiteral`, IF there is an array type in the union, it returns the first non-array type. In your second example, this would be `string`. But if there are no array types, that function returns nothing, so when `isRelatedTo` is called, `bestMatchingType` is undefined, so it falls back to the _last_ type in the union (seems a bit inconsistent, but it's an arbitrary decision anyway so it probably doesn't really matter). My guess is that they do this because assigning an object to an array is probably not correct. However, I was still perplexed why adding the array causes `findMatchingTypeReferenceOrTypeAliasReference` to fail. I was about to the point of giving up or hooking up a debugger when I found this: // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction // flag is specified we also reduce the constituent type set to only include types that aren't subtypes // of other types. Subtype reduction is expensive for large union types and is possible only when union // types are known not to circularly reference themselves (as is the case with union types created by // expression constructs such as array literals and the || and ?: operators). Named types can // circularly reference themselves and therefore cannot be subtype reduced during their declaration. // For example, "type Item = string | (() =&gt; Item" is a named type that circularly references itself. function getUnionType(types: ReadonlyArray&lt;Type&gt;, unionReduction: UnionReduction = UnionReduction.Literal, aliasSymbol?: Symbol, aliasTypeArguments?: ReadonlyArray&lt;Type&gt;): Type { Yay! A nice comment. Specifically, "we also reduce the constituent type set to only include types that aren't subtypes of other types." My guess is that the `source` type that gets passed around in the first snipped is REALLY only `string | any[]` when the `any[]` is included, which causes the logic to fall to the third method of finding the "best matching type".
Right, but in the 3rd example, `object` is correctly inferred instead of `array`. It's only when a primitive is included that the inference makes a poor choice - and my last sentence clarifies that the choice is obviously poor because it fails the same way with a `number` as with a `string`. I could see more of a case for it failing with a `string` because it's array-like and harder to disambiguate, but there seems to be no valid reason `number` should ever be assumed over `object` in the second example.
Thanks a bunch - subtype reduction looks like the answer. Do you think it's worth opening an issue on GitHub? Changing this behavior looks like it'll have consequences to a lot of code, possibly with a big performance impact.
I don't see anything, are you sure you updated it? Or you can create a top level comment with more info.
I work for a company that uses typescript and ramda a lot, but not for things like iterators, because they're not supported. I'm sure something like this exists, just seems like it would help a lot with processing very large lists of things pulled down from some rest api progressively for transforming/piping to another... which is something we do a lot in some integrations we have. For now, we just use async generators with for...await syntax to process things from generator to generator. Got used to doing things that way from Python, except now with async, it's really cool. Works well, just verbose. Ramda's currying, transducers, evolvers, etc... and overall functional style just really is awesome for things like that. 
Pixelmatch or jest-image-snapshot are similar tools that might do the trick: visual snapshot testing.
Oh, just opened it in browser. something is wrong with Relay for reddit. I'll check it out later.
I think if you open an issue they'll just close it with working as intended.
Just a side question. Difference between types and interfaces ?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/relayforreddit] [This post doesn't have content when viewing in Relay but has it when viewing in browser](https://www.reddit.com/r/RelayForReddit/comments/9d65be/this_post_doesnt_have_content_when_viewing_in/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Probably: - Union types are sorted by id. - Id's are created in ascending order when you create new types. - Primitive types like `number` or `string` are created when the checker is initialised so always have low id's. - Therefore primitives are always the ones that get reported first.
Interfaces are a form of type declaration. Using the `type` keyword versus the `interface` keyword _can_ be functionally equivalent in many cases, but each can do things the other cannot. For example `extends` can be used with interfaces and the `&amp;` and `|` operators can be used with the `type` keyword. [The handbook section on interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html) might be a good starting point to learn more.
You can just get the jmagedata and assert the pixel values. If it's about subtle color difference which you can't really prevent you apply some CIE magic and calculate color difference. Everything under a certain threshold (JND) is okay. But probably the best solution is instead of really drawing on a canvas just record all instructions and then compare them if they are in the right order
It sounds like you want to use TypeScript to interact with the DOM. You're in luck! TypeScript has the DOM types built in! All you need to do is add 'dom' to the lib configuration in your tsconfig and you'll have access to all the DOM types. [Here's an example of a tsconfig](https://github.com/jmptr/ephemeral-dough/blob/master/tsconfig.json) I use for my front-end projects. You'll notice I use the dom, es2015 and es2016 libs. Check out the [compiler options on the TypeScript site](https://www.typescriptlang.org/docs/handbook/compiler-options.html), too.
Its fairly easy to setup for simple JS compilation once you've experimented a bit with which options you'd like. You can run "tsc" either whenever you need a build, or in watcher mode. Sounds to me like your use case would probably fit watcher mode best. I know VS Code also has some TypeScript watching functionality built in but I can't tell you too much more about it because I haven't used that feature much. Will you be using webpack? If so you might like "ts-loader" or "awesome-typescript-loader". Best of luck!
Thanks I’m new to TS still got lots to learn. 
Thanks will take a look. 
I use this boilerplate - https://github.com/lomboboo/webpack-typescript-boilerplate it's certainly overkill for what you seem to be looking for, but it's the best that I've found that includes TS, SASS, Bootstrap and a nice testing suite.
Great!
hmmm interesting.. you are using the "infer" keyword alot. I didnt even know that was a thing! Ill have to research that some more
Hey, cannyshammy, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Read that in Clippys voice. 
Thank you for this suggestion. I hadn't considered either of these. 
Working as intended ;)
Maybe something like? declare namespace ReturnCode { type Ok = 1; type Cancel = 2; type Abort = 3; type Retry = 4; type Ignore = 5; type Yes = 6; type No = 7; type TryAgain = 10; type Continue = 11; } declare function MessageBox(message: string, title: string, type: 0): ReturnCode.Ok; declare function MessageBox(message: string, title: string, type: 1): ReturnCode.Ok | ReturnCode.Cancel; declare function MessageBox(message: string, title: string, type: 2): ReturnCode.Abort | ReturnCode.Retry | ReturnCode.Ignore; declare function MessageBox(message: string, title: string, type: 3): ReturnCode.Yes | ReturnCode.No | ReturnCode.Cancel; declare function MessageBox(message: string, title: string, type: 4): ReturnCode.Yes | ReturnCode.No; declare function MessageBox(message: string, title: string, type: 5): ReturnCode.Retry | ReturnCode.Cancel; declare function MessageBox(message: string, title: string, type: 6): ReturnCode.Cancel | ReturnCode.TryAgain | ReturnCode.Continue; declare function MessageBox(message: string, title: string, type: number): number;
Ah, right, of course. That works. Thanks!
Ugh why a namespace? Why not just use an `enum`?
Enums generate code and I thought this was for a .d.ts file where there may not be an object that holds all the codes.
 declare function pick&lt;T, K extends (keyof T)[]&gt;(obj: T, ...keys: K): Pick&lt;T, K[number]&gt;; 
Ah yeah I guess he did specify a d.ts. My mistake.
That's exactly what I was looking for! Thankyou. Just to follow up on this, because I had no idea about this "K[number]" syntax- what exactly does this do? Does this syntax work with other data types? (string, symbol).
The operation `K[number]` will return the type you get for indexing into `K` with any possible number. If `K` is a array it will return the array type; if `K` is a tuple it will return a union of all the tuple elements (because we assume indexing with `number` could access any element so we have to return the upper-bound which is the union of all tuple elements). You can write `K[string]` provided that `K` has a string indexer, and in that case it will return the type of the indexer. Usually though, you'll probably want to access an interface type using something like `K[keyof K]`, which will return the union of all property types (because like the tuple, we range over all possibilities so we have to return an upper bound). I don't think `K[symbol]` is valid.
That's all very interesting. I didn't know you could use "K[keyof K]" to flatten out interface property types into a union- that's a neat little trick! Well I can refactor other declarations (that include rest parameters) now using this syntax to be fully type-safe like I hoped so that's really great! I appreciate the advice. Cheers
It is necessary. TypeScript would not be able to reliably transform code in order to add `this.`. There's no reliable way of knowing what global variables exist, that may cause conflicts. For example: ``` Class Foo { $: number; get$ () { return $; } } ``` There isn't a reliable way to know if `$` refers to `this.$` or jQuery. If you were to transform all instances of `$` within the class that would be a breaking change. There will undoubtedly be existing TypeScript code out there that references global variables which match the name of a property.
It is more discoverable, as in when you’re typing the reducer you can type ‘ActionTypes.’ And your IDE will prompt with all the possible actions on that enum. This also helps in your components where the action is dispatched
valuesOf is simple. Return value is `Array&lt;T[keyof T]&gt;`
`isObjectEmpty` has to be boolean. The problem is that type {} is compatible with {foo: any}. The type system never forbids an object from having additional runtime properties. So even if you made a conditional typing hack to detect when the type doesn't declare properties, it wouldn't match runtime behavior. Plus the type system doesn't differentiate between enumerable and non-enumerable properties.
The built-in typings for `Object.assign` preserve any function or construct signatures of the first argument.
I think a problem with your Object.assign is when the same property exists on Source and Target types, but is optional on Target, the result would keep the Source version whenever the Target version of that property is undefined. 
Thanks! For anyone else, this works too! The following returns the type "(string | number)[]". ```typescript declare function valuesOf&lt;T&gt;(obj: T): Array&lt;T[keyof T]&gt;; ... const object1 = { foo: 1, bar: 2 }; const object2 = { bar: '', baz: 3 }; const merged = { ...object1, ...object2 }; const valuesOfResult = _.values(merged); // (string | number)[] ```
Thanks, this is the kind of answer I was looking for
Perfect, thanks. I've managed to improve these typing's based on this. I'll update the post with the final code for anyone else. Cheers!
I think to give a useful answer, we need to know what situations you need this for. Do you have an example? The examples you posted all use object literals, but that's not realistic, since you'd never need to call `isObjectEmpty`; you already know it's empty. In a realistic situation, the value passed to `isObjectEmpty` should be coming from somewhere else. You could write type declarations that understand when `isObjectEmpty` is guaranteed to return `false`. For example: function foo(a: {bar: string}) { return isObjectEmpty(a); // &lt;-- type system knows this is `false` } But I'm struggling to find a situation where this is useful. Also, you used `_.keys` in your implementation. This is limited to own enumerable properties. Is that important? Again, can you post a realistic example where that behavior is important?
Not truth, better look here r/http://andswer.gipertone.info
You're not actually constraining the type of the function passed into your constructor. `Function` will allow literally any function of any shape. Since you have a desired shape for your function you need to specify that because right now you could still instantiate any version of your class with any function (ie `new MyClass&lt;[number, string]&gt;((a: boolean) =&gt; { foo: 'bar' })` will compile). If you tell the type system what you actually want, it's usually pretty good at inferring from generics: class MyClass&lt;T extends any[], U extends any&gt; { func: (...args: T) =&gt; U; constructor(func: (...args: T) =&gt; U) { this.func = func; } getValue(...args: T) { return this.func(...args); } } const add = new MyClass((a: number, b: number) =&gt; a + b); add.getValue(1, 2); // 3 const cat = new MyClass((a: string, b: string) =&gt; `${a}, ${b}!`); cat.getValue('Hello', 'world'); // Hello, world! 
Framework for what? Headline doesn't give any indication.
It's not necessary, I just like explicitly writing them in on class definitions.
you might be able to use `{ [key: string]: never }` to simulate empty.
Following on from @cspotcode's answer; `isObjectEmpty` only makes sense at runtime because at compile time Typescript is trying to make compile time guarantees. Imagine the type .. ``` type A { name: string; } ``` If you passed an object/instance which satisfies `type A`, you are telling Typescript that this object *definitely* has a property `name` which has a value. There is no way for an object of type A to be empty; unless it's not actually an object of type A. It may make sense for something which has only optional properties, eg. ``` type B = { name?: string; age?: number; } ``` This allows for `isObjectEmpty` receiving `{}`, in the same you could assign `{}` to `type B` as well. `const b: B = {}` is a valid assignment. I'm not sure how this would work for a similar, but slightly differently stated type B ... ``` type B2 = { name: string | undefined; age: number | undefined; } ``` Because looking up a value which isn't defined will give you `undefined`, but, when making an object of type B2, Typescript will force you to give the properties values, but you *can* give them the value `undefined`.. eg. ``` const b2: B2 = { name: undefined, age: undefined }; ``` This obviously plays out a little weird at run time ... is this object empty or not? JS `for..in` still shows them; which makes sense, to me anyway. And the generated JS code matches up as expected. Some playing around in this playground link ... http://www.typescriptlang.org/play/#src=type%20B%20%3D%20%7B%0D%0A%20%20%20%20name%3F%3A%20string%3B%0D%0A%20%20%20%20age%3F%3A%20number%3B%0D%0A%7D%0D%0Aconst%20b%3A%20B%20%3D%20%7B%7D%3B%0D%0Aconsole.log('b%20..')%3B%0D%0Afor%20(const%20k%20in%20b)%20%7B%0D%0A%20%20%20%20console.log(k)%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Atype%20B2%20%3D%20%7B%0D%0A%20%20%20%20name%3A%20string%20%7C%20undefined%3B%0D%0A%20%20%20%20age%3A%20number%20%7C%20undefined%3B%0D%0A%7D%0D%0Aconst%20b2%3A%20B2%20%3D%20%7B%0D%0A%20%20%20%20name%3A%20undefined%2C%0D%0A%20%20%20%20age%3A%20undefined%0D%0A%7D%3B%0D%0Aconsole.log('b2%20%20..')%3B%0D%0Afor%20(const%20k%20in%20b2)%20%7B%0D%0A%20%20%20%20console.log(k)%3B%0D%0A%7D%0D%0A
Are interfaces not enough? You describe the methods you expect to see and the arguments you expect them to return. What about that doesn't work (if possible provide an example)?
Well it is more clear but your venturing outside of typescript. What your asking has more to do with node or npm or this cli. And fundamentally yes you need a way to register these plugins with the instance that runs. Generally I'd probably prefer specifying it in my own code. So I can install plugins and feed them into the library as I see fit. Maybe I have 2 versions using the same repo so therefore the same node modules. So I'd prefer something explicit where somewhere in my code I do something like: scrapper.init([fooPlugin, barPlugin]) Or you could also accept a json file and parse it where I can feed in: { plugins:[fooPlugin, barPlugin] } I'd rather not have your code automatically include any potential plugin that happens to be in node modules. But that might just be me. 
From the article, it’s a typescript web framework like Koa: 1. Curveball is a very minimal, like Koa. It largely follows Koa architecture and API design, with some subtle changes. Middlewares will look very familiar. 1. It’s completely written in Typescript. 1. It embraces modern HTTP features, it has built-in support for HTTP/2 Push, and 103 Early 1. Hints and integrates these in a way that feel like they are a native part of the framework. 1. It’s easy to do ‘mock’ HTTP requests inside the framework, without having to go through a real HTTP stack.
They have intentionally designed the language so that type information doesn't affect emitted js code, or in other words, correct type information is neither used not required for code emit. They do, however, use type information to suggest when you accidentally omitted `this.`, so you can click or hit a key and the language service will add it for you.
We need more people like you.
I'm unfamiliar with SAM, but have you told AWS to include node_modules in the .zip file? It's a node-specific concept (e.g. python doesn't use it) so I'm just guessing that SAM doesn't bundle it unless you specifically configure it. Is there somewhere you're listing all the files that should go in the zip?
It looks like he forgot the return statement inside the forEach function. 
Thanks for this recommendation @esamatti. As a newcomer to Redux, I've been struggling with the complexity of updating deeply nested structures in an immutable way and the use of string paths in immutable.js just seemed nuts to me. 5 minutes after trying immer I'm hooked. Feels a lot simpler! 
[I have](https://github.com/jschr/vscodethemes). Happy to answer any specific questions you might have.
As far as I can tell, you wouldn't want or need to get webpack involved since in Node.js there's little/no advantage to minifying/concatenating. As far as production dependencies only, couldn't you just use the normal dependencies/devDependencies fields in package.json? Specifically on the build machine, do a full `npm install` and then generate the js from the ts using the TypeScript compiler (`tsc`) for your build step, then package up the whole directory using `npm pack` or whatever and upload it to AWS, which I assume will run `npm install --production` in the Lambda's container.
That is basically the way you would hope that things would work but it's more complicated in practice. "There is little/no advantage to minifying/concatenating." Yes, AWS Lambda actually does have a few benefits to smaller code footprints. Aside from a limited maximum bundle size (250 MB... which is surprisingly easy to hit when using several dependencies), the code executes more quickly when it's packaged. The npm pack &amp; npm install --production have been fairly buggy &amp; surprising when working with a monorepo
I'm not publishing any of the packages to npm so [yarn workspaces](https://yarnpkg.com/en/docs/workspaces) does everything I need to link local dependencies. I'd probably still use lerna if I were though. Deploying production-only dependencies was tricky, which is why I used webpack to bundle them before uploading to Lambda. Terraform handles deploying the backend but you could just as easily use something like [Serverless](https://serverless.com/) for a similar setup.
What npm problems are you seeing? I've had problems we the dedup argument in some specific versions that were running in AWS Codebuild but nothing apart from that.
I've learnt so much from [this](https://github.com/Microsoft/TypeScript/issues/5453#issuecomment-419680547)
To be honest, I don't find myself doing this with tuples very often. If you need to utilize these actions, why use a tuple and not an array / list?
Correction: why not use an interface? Tuples have a long and illustrious history in formal type systems, all of which are way overcomplicated for production systems engineering. Also I have no connection to the article or post, just wanted to give any amount of information after OP declined to say what was interesting or useful.
I mean, you also can't really use `First`, `Last`, `Reverse`, `Append`, or `Prepend` on an interface either. I guess I'm just lost as to what the use case is, here. Maybe OP will chime in.
&gt; declare function isObjectEmpty(obj: object): obj is { [k: any]: never } Thanks, I got this working with a minor change. As @cspotcode pointed out, this behavior is here for a reason, but for anyone else looking for a temporary workaround: (In this case, I want to return a boolean literal instead of a boolean). ```typescript declare function isObjectEmpty&lt;Object&gt;(obj: Object): Object extends { [key: string]: never } ? true : false; ``` ```typescript const isEmptyObjectResult = _.isEmpty({ test: 1 }); // Return type: false const isEmptyObject1Result = _.isEmpty({}); // Return type: true ``` 
The Serverless framework will do all of that for you - they even have a template with that exact setup - use ‘serverless create -t aws-nodejs-typescript’ 
Pretty sure you should be using the lowercase object type
You essentially have two options - convention or configuration. Either import all things based on a naming pattern or location (convention) or provide a way for the user to configure the plugins (a config file, programmatically). Fonts available in Windows is an example of convention. All fonts in the fonts folder are available to the user. Your includes at the top of the TS file are an example of configuration. Simply putting the modules in node_modules will not make their symbols available in the file, you need to `import` them. (ambient modules/namespaces are mostly convention)
What is this for, exactly?
Noooooo. The more I learn about TS3.0 the more I hate being stuck on 2.4. Damn you for showing me this! Take your upvote you barbarian
Benefits: - Because it forces you to use enum value, you can change it's value in one place vs. find+text replace, makes refactoring super easy. If you are disciplined about using the constant then pretty much the same. - Exhaustive checking, can verify all actions are covered easily - Gives you a runtime obj to play with Downsides: - When you compare the enum to string for some reason, can be tricky - In TS2.4 at least, objects can only be keyed by string or number, not enums. This is a huge PITA. So a mapping from action types will not be possible easily e.g. {[enum.ACTION]: () =&gt; ...} Will throw an error in most cases. Personally I find the benefits of using enums (as string unions with a runtime element) outweigh the downsides, and even moreso in TS3.0 
From what I saw it's a library for type-level programming in TS. It's similar to projects like [typelevel-ts](https://github.com/gcanti/typelevel-ts) and [typical](https://github.com/tycho01/typical/)
Hmmm alright, thanks
To properly format code on Reddit: - Have an empty line between code and regular text. - Indent every line by 4 spaces. The ```-syntax does not work here. Reddit is not using Common Markdown.
Instead of callback, use Promises, or better yet use Observables (rxjs). The problem with callback is that your code can get very messy. Promises/Observables on the other hand result in much more readable code. 
You never declare any relation between Dog, Test, or TestProps, so TypeScript thinks they're all unrelated. I think this is not a TypeScript question, but rather a question about how to use this vue-property-decorator thingy.
Thanks for the reply; I looked into it a bit deeper and it appears that what I'm looking for isn't actually supported yet. There is an open pull request for Vetur but it could take some time to be merged in. &amp;#x200B; [https://github.com/vuejs/vetur/pull/681](https://github.com/vuejs/vetur/pull/681)
I've found the only way to get compile-time checking of props with vue is if you use jsx and render methods (would not recommend). import { Component, Prop } from 'vue-property-decorator'; import { Component as TsxComponent } from 'vue-tsx-support'; interface Props { foo: string; bar?: boolean; } @Component({ name: 'Foo' }) export default class Foo extends TsxComponent&lt;Props&gt; { @Prop() foo: string; @Prop() bar?: boolean; render() { return &lt;div&gt;Test&lt;/div&gt;; } } class Bar extends TsxComponent&lt;{}&gt; { render() { return &lt;Foo foo={'bar'} nonExistantProp={'Should Error'} /&gt;; } } 
Totally valid point about using React if we're going to be writing it this way; however, this is a legacy project at work that's using Vue and so switching to React isn't feasible in the timeline that we have. That being said, thanks for this; I'll give it a go!
Oh, alright. That's too bad - it looks like it's working on my machine. I wonder what the difference is?
Aren't they typed already?
Nope. The `EventEmitter` class provided by [@types/node](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/v9/index.d.ts#L553-L569) uses `(...args: any[]) =&gt; void` for listeners and `string | symbol` for event types, which is *not* as good. Give this library a try and you'll see what I mean. And this library is isomorphic (works in browser and Node).
You might also like [`emittery`](https://github.com/sindresorhus/emittery) which also is type-safe, but has other benefits like being fully async.
Great library, but: - larger API (not as great for subclassing) - `emit` only supports one argument - synchronous `emit` is sometimes required - async `emit` is rarely useful (other than [the whole "Zalgo" thing](https://medium.com/@bluepnume/intentionally-unleashing-zalgo-with-promises-ab3f63ead2fd), which can be avoided by wrapping a synchronous `emit` in `process.nextTick` or `Promise.resolve`) - `emit` should rarely be concerned with when its listeners' promises are resolved (and when that is necessary, you can use the `listeners` method for full control in `ee-ts`) - lack of default handlers (see `EE.unhandle` in `ee-ts`) - verbose `Emittery.Typed` for type-safety instead of it being the default - `on` returns an "unsubscribe function" (which is often unwanted) Interesting parts: - promise-returning `once` method - the `onAny` and `offAny` methods (might add a `*` event to `ee-ts` just like `off('*')` removes all listeners of all events) Just my 2 cents.
Types don't exist at runtime. There are libraries to validate the structure of objects though: [io-ts (for example)](https://github.com/gcanti/io-ts).
Generally having a generic parameter only appearing in a covariant position is a red-flag because you're asking the program to conjure everything out of nothing. You need a way to inform the program what you expect `T` to be at runtime: something like: function request&lt;T&gt;(url: string, check: (val: any) =&gt; T): Promise&lt;T&gt; { return fetch(url) .then((resp) =&gt; resp.json()) .then((result: any) =&gt; check(result)); } Note that there is now a `T` in a contravariant position, this is where information flows in. The `check` function can be implemented in a multitude of ways (JSON validation seems to be the 'in' thing right now with a wide variety of libraries, I'll just write a basic function). function checkChar(val: any): Car { if (typeof val === "object" &amp;&amp; typeof val.model === "string" &amp;&amp; typeof val.year === "number") { return val; } throw "not a car -- you'll want to handle this gracefully!" } This is the function that checks if an object is a `Car`. A more type-safe version would be to replace `any` with `unknown`, but the narrowing for `unknown` is pretty sparse currently so it's not that easy to work with. Now I can do a request and validate the response, with no cast on the result: const car: Promise&lt;Car&gt; = request("/api/car/1.json", checkChar); I'm not entirely sure this is what you meant, but I hope it helps!
&gt; Those packages Plural, implying there must be many, what are those? Anyway, TypeScript 3.0+ release brings a couple of features so I just want to have fun with it :) 
Sad. I have hundreds of models loaded in this way. &amp;#x200B;
Already researched. But I can't make it work with generics.
Neat; I'll have to give it a whirl when I have some free time. I'm most curious about your approach to the "blueprint" feature implementation. BTW, you have a typo in the last paragraph where you mention "blueprint". I've actually been working on something similar as a personal typescript boilerplate: react (w/ ssr &amp; code splitting similar to next.js), redux &amp; rxjs for state, hapi.js, socket.io, redis for pubsub across cluster, postgres, and nginx. I'm using docker-compose for local development, and kompose for kubernetes deployment.
Feel free to have a look and see if you can see improvement - those sorts of ideas are certainly what I'm looking to cover too, but I haven't had a chance to look at kubernetes properly. I had to drop the React app, but I'd have loved to have been able to get users to select their flavour and it build the app dynamically (so Angular, React, Vue, etc) - I just didn't have time to maintain. But yes the blueprint idea makes it easy to do. Just replace the frontend-app and hook up to the same APIs and view, put it on github - you have a blueprint. Backend can easily be replaced with Express, Koa, etc - or even a Go, PHP or Rust backend. Database is pretty easy to swap out too. Ideally all of these would be fully extendable and export all the types nicely. But my goal is to get this V2 pretty solid with one stack for now.
maybe you'll find this TS mono repo setup useful: http://thi.ng/umbrella - I'm using scoped packages, yarn workspaces &amp; Lerna to be able to work on different packages at the same time, then compile them all in topological order into CJS modules. Take a look at the 25+ standalone example projects, which all use Parcel to bundle &amp; minify. Also look at `scripts/build-example` for additional post-processing of bundles...
I use a no-op decorator to statically enforce constructor interfaces. [https://github.com/cspotcode/typescript-toolbelt/blob/master/src/classes-and-mixins-values.ts#L7-L23](https://github.com/cspotcode/typescript-toolbelt/blob/master/src/classes-and-mixins-values.ts#L7-L23) You can install it from here, along with a bunch of other goodies: [https://www.npmjs.com/package/typescript-toolbelt](https://www.npmjs.com/package/typescript-toolbelt) ...but it's just a one-liner. Usage looks like this: import {AssertConstructorImplements} from 'typescript-toolbelt'; AssertConstructorImplements&lt;CMyClass&gt; export class MyClass implements IMyClass { //... If you really don't want to enable decorators, you can do this: import {AssertConstructorImplements} from 'typescript-toolbelt'; // wrap in a function that is never executed, because we only care about the static typecheck, and we want to write this near the top of the class, not wait till after the class body when it's declared () =&gt; {AssertConstructorImplements&lt;CMyClass&gt;()(MyClass);} export class MyClass implements IMyClass { // ... Or if you're ok placing the assertion after the class body: } // end of MyClass body AssertConstructorImplements&lt;CMyClass&gt;()(MyClass); Let me know if you have any questions.
Nice! Lots of cool stuff here, and I learned something new checking out the code: you can index into `SomeTupleType['length']` and get a numeric literal type.
Did you figure out a way to remove the last item from a tuple? I occasionally need to do this with APIs that accept a callback as a last argument, if I pass them through a promisifier. I guess I can do this: type Tuple = [1, 2, 3, 4]; type AllButLast = Reverse&lt;RemoveFirst&lt;Reverse&lt;Tuple&gt;&gt;&gt;; // [1, 2, 3] type RemoveFirst&lt;T extends any[]&gt; = ((...args: T) =&gt; void) extends ((a: any, ...rest: infer Rest) =&gt; void) ? Rest : never; Also, why is there a utils namespace and then other types with the same name that delegate to utils? Is it to make type tooltips look cleaner?
The TypeScript compiler is written in a merged namespace style, but they don't use es6 exports or imports. So all the code is essentially concatenated together.
You can also do `SomeTupleType['map']` to get a map function.
&gt; Did you figure out a way to remove the last item from a tuple? I haven't try as my needs have yet to require it. Contributions are welcomed. &gt; Also, why is there a utils namespace and then other types with the same name that delegate to utils? Is it to make type tooltips look cleaner? It is to reduce number of type parameters, user should only concern with parameters that actually matter. For instance: The ideal `Reverse` should be `Reverse&lt;Tuple&gt;` but its implementation requires `Reverse&lt;Tuple, Holder&gt;` but user do not and should not concern of `Holder`. 
Thank you! This is great. This is absolutely what I was looking for! I don't use annotations yet but this might be a good reason to start!
Does something like this work for you? yourFunction(handler: (...args: any[]) =&gt; void) { // function }
If I'm understanding you correctly, [hopefully something like this is what you mean](http://www.typescriptlang.org/play/#src=%2F%2F%20%22some%20keys%20who's%20types%20are%20easy%22%0D%0Ainterface%20WellKnownObj%20%7B%0D%0A%20%20a%3A%20any%3B%0D%0A%20%20b%3A%20any%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Bar%3CT%20%3D%20\(...args%3A%20any%5B%5D\)%20%3D%3E%20any%3E%20%7B%0D%0A%20%20\(fn%3A%20T\)%3A%20WellKnownObj%20%26%20%7B%20originalFunctionArgument%3A%20T%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20Foo%3A%20Bar%20%3D%20\(fnArg\)%20%3D%3E%20%7B%0D%0A%20%20const%20wellKnownObj%3A%20WellKnownObj%20%3D%20%7B%0D%0A%20%20%20%20a%3A%201%2C%0D%0A%20%20%20%20b%3A%202%0D%0A%20%20%7D%0D%0A%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20...wellKnownObj%2C%0D%0A%20%20%20%20originalFunctionArgument%3A%20fnArg%0D%0A%20%20%7D%0D%0A%7D). 
Can you explain for someone who is struggling to grasp this concept of T and extends?
Something like this maybe? interface ResultInterface&lt;T extends (...args: any[]) =&gt; any&gt; { fn: T; } function someFactory&lt;T extends (...args: any[]) =&gt; any&gt;(fn: T): ResultInterface&lt;T&gt; { return { fn }; };
The `extends` keyword is a type constraint. It says "T has to look, at the very least, like this". So if I know something has an `id` property, I might say `&lt;T extends { id: string }&gt;`. Now I can use `id` within the function or whatever, and I can use T as the return type (or derived types, etc). So I might be like const logIdAndReturnT = &lt;T extends { id: string }&gt;(T item) =&gt; { console.log(item.id); return item; }
So, T is just a placeholder? This gives me errors regarding item? Should there be a colon between T and item?
Sorry, C# was creeping up on me there. Should be `item: T`. I'll correct the original.
You could do this with io-ts and class constructors instead of generics. It would require quite a bit of plumbing and your request api would have to change slightly. Using https://github.com/jgreene/io-ts-derive-class the code would look something like: import * as t from 'io-ts'; import { ThrowReporter } from 'io-ts/lib/ThrowReporter'; import * as tdc from 'io-ts-derive-class'; const CarType = t.type({ model: t.string, year: t.number }); class Car extends tdc.DeriveClass(CarType) { } function request&lt;T&gt;(klass: new (...args: any[]) =&gt; T, url: string): Promise&lt;T&gt; { return fetch(url) .then((resp) =&gt; resp.json()) .then((result) =&gt; tdc.decode(klass, result)) .then((decodeResult) =&gt; { if(decodeResult.isLeft()){ throw ThrowReporter.report(decodeResult); } return decodeResult.value; }); } const car: Car = await request(Car, "/api/car/1.json"); Anyway, it's fairly intrusive on how you define your data model but it should get you what you are looking for. 
Yup that's possible using conditional types and tuples. `ReturnType&lt;T&gt;` is a built-in utility type, and we can create a similar type (`ArgumentsType&lt;T&gt;`) for extracting arguments as a tuple. From there we can do pretty much anything: type ArgumentsType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer A) =&gt; any ? A : never; interface ResultInterface&lt;T extends (...args: any[]) =&gt; any&gt; { fn: T; fnPromise: (...args: ArgumentsType&lt;T&gt;) =&gt; Promise&lt;ReturnType&lt;T&gt;&gt;; } function someFactory&lt;T extends (...args: any[]) =&gt; any&gt;(fn: T): ResultInterface&lt;T&gt; { return { fn, fnPromise: (...args) =&gt; Promise.resolve(fn(...args)) }; }; It does lose the argument names though.
My lordie lord, this is pretty darn great. You sir are a gentleman/woman and a scholar ! If I can bother you once more, can you explain the infer keyword ? Thanks a ton. 
Here's [a TypeScript a tuples implementation][tuplerone] for runtime. How difficult would it be to adapt these helpers to work with that custom tuple type? [tuplerone]: https://github.com/slikts/tuplerone
First and foremost, thanks for introducing to that amazing library, I'll probably use it in the future :) As for your question: I have taken a look at the code (file `src/types.ts` to be precise). Is `TupleN` (`N` is a `number`) the only thing you're talking about? If so, it should be relatively easy using `Repeat` generic from my library. There're 2 ways to do this: #### 1. The unsafe way ``` interface Tuple&lt;T, N extends number&gt; extends Repeat&lt;T, N&gt; ``` "Unsafe" means that infinite loop with TSC is possible, by having user give `N` a floating point or negative value. #### 2. The safe way ``` type ReasonableNumbers = 0 | 1 | 2 | 3 | 4 | ... | 100 interface Tuple&lt;T, N extends ReasonableNumbers&gt; extends Repeat&lt;T, N&gt; ``` This does not allows user to have tuples pass 100 limit, but who gonna do that right? 
I'm not sure if this fits your spec but I gave it a go. enum Toppings { pepperoni, cheese } function toArray(x: { [idx: number]: string }): string[] { const result: string[] = []; let i = 0; while (x[i] !== undefined) { result.push(x[i]); i++; } return result; } const asArray = toArray(Toppings); // asArray = [ 'pepperoni', 'cheese' ] 
The only issue with this is Toppings.pepperoni returns a number rather than 'pepperoni' :(
I'm new to typescript, so I'm gonna throw out my thinking for commentary: &amp;#x200B; I think what you're looking for is Enums (enumerations), a common pattern that describes a group of unique items: [https://www.typescriptlang.org/docs/handbook/enums.html](https://www.typescriptlang.org/docs/handbook/enums.html) &amp;#x200B; The problem with enums is that you can't add info/functionality to them. So later if you want each topping to also have a "applyToPizza" method, you're SOL unless you want to use a switch/case statement which will have to be edited for each new topping type. In general, I would suggest an OOP hierarchy like: const toppings : object = {}; interface ITopping { name : string; } class Pepperoni implements ITopping { name : string = "pepperoni"; } Now you can add new features to ITopping and know exactly where to implement it. If you want Intellisense, just make that \`class ToppingPepperoni\`. If you really want to remove this duplication, you can make a class-generating factory. function createTopping(name : string) { // Create an anonymous class let clazz = class implements ITopping { name : string = name; } // Add to your list of toppings (though this wouldn't auto-generate a list for you) toppings[name] = clazz; return clazz; } // No duplication :-D createTopping("pepperoni"); Consider that (even in the basic Enum case) your issue is not really duplication, though, in the DRY sense. DRY refers to repetition in functionality, not merely the code itself. The class name and static property "name" have different functions: to communicate info in two different domains, one human-readable and the other type-checkable. &amp;#x200B; Again, I'm also new to TypeScript so would love commentary (since I use this approach). I do hope this helps, though, OP. Cheers.
Ah yes true though you can do `Toppings[Toppings.pepperoni]` to get the string. Another solution that might work (though building an array is not as easy). // Could be initialised with anything that is short to type, basically the main thing // is getting the topping varieties into a type. const toppingSource = { "pepperoni": undefined, "cheese": undefined }; type ToLookup&lt;T extends object&gt; = { [K in keyof T]: K }; function populate&lt;T extends object&gt;(source: T): ToLookup&lt;T&gt; { const out: any = {}; for (const k in source) { out[k] = k; } return out as ToLookup&lt;T&gt;; } const toppings = populate(toppingSource);
Yea, I wanted to avoid the word duplication since they're going to be the same regardless, I guess it'd be combining functionality in that case. I actually realized something silly which changes up what I need to do and makes the implementation different and much easier. &amp;#x200B; I appreciate your response though, thank you! &amp;#x200B;
`infer` is something you can use in the `extends` clause of a conditional type, and the inferred type is then available in the rest of the conditional. So for example, `ReturnType` looks something like this: type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never; Under the extends bit we have `(...args: any[]) =&gt; infer R`, so the type is basically "if `T` is assignable to `(...args: any[]) =&gt; any`, infer the return type as `R` and return it, else return `never`". A bunch more info is available [here](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html), especially the section "Type inference in conditional types".
Glad you're back on your way! Maybe I'll make a post out of mine too since I was looking for commentary.
It does. Look up the `abstract` keyword. You can have abstract classes and methods in it.
https://www.geeksforgeeks.org/difference-between-typescript-and-javascript/ This source states otherwise
https://www.typescriptlang.org/docs/handbook/classes.html This source states otherwise
Someone is wrong.....we need to ask Microsoft as to who is right and who is wrong.
I'm sorry this doesn't answer your question and is just an unsolicited personal opinion. &amp;#x200B; I try not to treat typescript as a "full" OO language. Minimal usage of inheritance class state. I write more functionally because I think it's a style better suited to the language.
No we don’t. Because they explicitly state in their documentation that abstract classes are possible. -something a quick google search would have told anybody. The article you posted is low quality, unsourced and wrong in many cases. 
yeah that ^
Bishal Kumar Dubey is really not a good trustworthy source. Especially not one over the official TypeScript documentation. There is also no date in that "article" you linked. It could be from a very early version of TypeScript which did not support `abstract` yet.
&gt;Given all of this, we felt that it would be better to make TypeScript a bit “smarter” about these sorts of patterns. In TypeScript 3.1, for any function declaration or const declaration that’s initialized with a function, the type-checker will analyze the containing scope to track any added properties. Nice.
Really not liking the breaking change regarding function type checking. Why wouldn't that code work? This seems like they couldn't fix a bug, so they called it a breaking change. Solid stuff otherwise, but I just don't understand why typescript should choke on the example given. Could someone explain if I am misunderstanding? 
The example in the webpage is kind of poor because `unknown | () =&gt; string` is equivalent to `unknown`, so the function type there is a bit of a red herring as `x` just narrows to `Function`. The better example is: function foo&lt;T&gt;(x: T | (() =&gt; string)) { if (typeof x === "function") { let a = x() } } Previously this would filter out `T` from the union when narrowing, but this isn't sound because `T` could be instantiated with a function type such as `(a: boolean) =&gt; number`. Instead, the safe thing is to assert that `T` is a function, so the type narrows to `T &amp; Function | (() =&gt; string)` which is sound, but there are no safe way to work out the correct signature. You don't know that a value of type T &amp; Function | (() =&gt; string) can accept zero arguments.
Great explanation, so the issue here is really that the generic type could be a function with a different arity/arg types. So that's even more type safety then!
Nice
if i understood you correctly, you want to split each line ( on the comma ) into an array of columns, and process the resulting data whichever way your heart desires... take a look at this module: https://www.npmjs.com/package/rawiki-parse-csv hope it helps.
Am I missing something? Can't you just split the row with a comma and then the 4th index will be the translation?
You can do exhaustive checking with the strings, as long as you have a union type for them (used, for example, in reducers)
Calling TypeScript "object oriented" doesn't seem right. It has object oriented elements, in the same way it has functional elements. Its not as multi-paradigm as C++, but in a similar vein. As others have mentioned. TS definitely has the concept of abstract classes; however I tend to not use them in preference of interfaces as its easier to initialize from them since they more accurately represent JSON.
I appreciate the help, but I'm confused as to how this can help me. &gt;The TypeScript compiler's source can merge namespaces across multiple files because they never `export` anything from the top-level of a file nor do they import anything. Assuming 'typescript compilers source' means my source code as input to the compiler, it doesn't make sense because you're saying that source is merging namespaces... However, if I assume you're talking about the source code to the tyespcript compiler, that also doesn't make sense because I'm not running its source code. So that all has me confused. However, you appear to suggest a solution, with merging everything into an 'all-activities.ts' file. But this also won't work because I need the definition of a type that exists in one file, in order to create the second file, unless I throw code reuse out the window. At the very least, I think your example kinda bypasses the whole point of using namespaces, I think. Now if I just do something like this in my second file: import {de} from "./activity"; export const de.bpmn.ComplexGateway = de.bpmn.Activity.extend({}); then it complains that the de in 'export const de.bpmn...' "individual declarations in merged declaration 'de' must be all exported or all local" Maybe the thing to do is assume that namespaces in typescript are broken, and to avoid using them?
I think the other people here already pointed out how you could achieve it but in my opinion you should just use a library for that (if it isn't about just learning stuff). CSV is an old topic and there are probably hundreds of libs for that. What I would also propose is to use a library that directly works with buffers &amp; views because that will be a lot faster than string manipulation. A quick Google gave me this: https://www.npmjs.com/package/csv-parser
Hey it's a me! ❤️ Hopefully these are useful for someone! 
Anything will work if you cast to \`any\`. Even things that will throw runtime errors, for example \`(null as any).foobar = 123;\` But if you try to access \`ComplexGateway\` somewhere else, the compiler will tell you that it doesn't exist. I was referring to the typescript compiler's source code, because it is an example of a project written in a merged-namespaces style. If you prefer to learn by example, you can look there. Notice that there are \*no\* top-level export statements. Everything's wrapped in a \`namespace ts\` and it all gets merged. TS namespaces aren't broken, but they do work differently than you're expecting. If you're using top-level \`export\` and \`import\` statements -- aka ES6 exports and imports -- , you cannot add stuff to a namespace that was declared in another file. That's simply not supported. If you stop using top-level \`export\` and \`import\` statements, you can. Most people use ES6 imports and exports instead of namespaces, and that's also what I recommend. Below I'll try to explain how ES6 exports and imports are similar to namespaces and how you can make them mimic the style of namespaces that you prefer, if you really want to go that route. If you want to create a single namespace containing items from different files, you have to import and re-export all those individual items in a single file. With ES6 imports and exports, each file is its own flat namespace. If you want a namespace hierarchy, you generally use the filesystem to organize your files into directories. Here's a working example: // activity.ts import {TextBlock} from './joint/shapes/basic'; // &lt;-- Not shown: basic.ts exports TextBlock as a top-level export, *not* in a namespace export const ActivitySize = {width: 180, height: 36}; export const ActivityLabelSize = {width: 135, height: 36}; export const Activity = TextBlock.extend({}); // extendedActivity.ts import {Activity} from './activity'; // &lt;-- import the things you need by name. They are bound to an identifier in local scope export const ComplexGateway = Activity.extend({}); // &lt;-- now you can access Activity // all-activities.ts // This file is basically our "namespace." We re-export a bunch of things here, so they can all be imported from this file. export * from './activity'; export * from './extendedActivity'; // example.ts import * as allActivities from './all-activities'; // allActivities is imported as a namespace, albeit one that is only one level deep new allActivities.ComplexGateway(); This is different from namespaces in other languages. Again, if you're using ES6 imports and exports, you \*cannot merge namespaces declared in different files.\* But you \*can\* re-export a bunch of things in a single file, effectively combining multiple files into one. (what I did in all-activities.ts) Here is a complete example of using ES6 imports and exports, with a bunch of re-exporting, to build up a namespace in the style you're expecting. Most people do not take this approach, but here's proof that it's possible. [https://github.com/cspotcode/ts-namespace-example](https://github.com/cspotcode/ts-namespace-example) Hope this helps!
Read some documentation in typing, then dive right in. TypeScript is pretty good at telling you what it expects.
It's pretty easy, I imagine when you write code you already think in "objects" but now you don't have to Ctrl+f all the time to remember what it looks like. And writing advanced types is fun. I think of them like a little puzzle, I could use a bunch of anys and pass but if I want to get a gold star and 100% I figure out how to do some advanced types. 
If you want some help from the compiler, set some [strict flags](https://www.typescriptlang.org/docs/handbook/compiler-options.html) like 'noImplicitAny' and 'noUnusedLocals'. That helped me when converting old JavaScript to TypeScript. Other than that, start making some classes and functions with explicit typings, and import them around. Try some abstract classes and interfaces as well to get some good architecture going. Once you get those designs down, you can start some advanced features like optional parameters. 
Types describe the shape of an object. Generics are simply types baked into the class or function definition, to describe the stuff that goes in or out. For example, I have a generic post method to help build my api methods: export async function apiPost&lt;TDto, TResult&gt;( path: string, dto: TDto ): Promise&lt;TResult&gt; { const init = await getInit('POST'); init.body = JSON.stringify(dto); return api&lt;TResult&gt;(getApiUrl(path), init); } This way the stuff that uses apiPost knows what goes in and what goes out. In the case of React, you'll move away from using PropTypes and into `Component&lt;Props, State&gt;`, which will give you strong typing on your component. 
If you've been using a lot of the es6 features already, you're most of the way there. The type system is pretty easy to get the hang of, just avoid using 'any'. I agree with others that the feedback you get from the compiler will have you up to speed in no time.
This is great: https://basarat.gitbooks.io/typescript/ - in fact one of the best guides I've found on any subject about anything. I'd recommend reading through all of it if you can, even the sections you might already know about. Will probably pick up some extra tips along the way. The amount of detail for something like this is "just right" I think... covers the kind of stuff you want to know while getting into TS, not too little, or too much. For more detail, you can go to the official TypeScript docs afterwards (some of which I found confusing when starting with that as my 1st source of info). That's one issue I've found in general with a lot JS documentation in general, and even the one-liner NPM package descriptions... they assume you know about a bunch of other things before you read their stuff, it makes it all very confusing when getting started when there's about 10 terms being used that you're not familiar with (I'm coming from 19 years of PHP, and this has been a bit of a frustration with JS doco/READMEs in general). I've found this TS guide makes much fewer assumptions like that. Also, so many guides explain the "what" and "how", but miss the important "when" and "why" explanations that help you remember stuff. I find it very hard to remember much if I can't envisage what I would actually use it for.
Echoing what everyone else said, also use VSCode. It's the best editor for typescript (it's made by people who made typescript and written in typescript).
And while some people would say that's why they don't want to use TypeScript, I agree that that is exactly why I enjoy it!
Extremely easy, just read the manual
Thank you everyone for your time and input. I had a feeling that I am over complicating things. Nice to hear other people opinion and their approach on the same topic. Much appreciated!
This. Just read through the documentation on the typescript website, and write some practice code on your local.
It does support abstract classes (untested); export abstract class Person { protected readonly firstName: string; protected readonly lastName: string; protected constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } public greet() { return "Hello, " + this.firstName + " " + this.lastName; } } export class Student extends Person { public constructor(firstName: string, lastName: string) { super(firstName, lastName); } } Then: const student = new Student("John", "Doe"); console.log(student.greet()); 
Where can I learn to understand this stuff like you do?
Agreed its the best editor for typescript, but it's two separate teams and they are actually 1000s of miles apart. (I used to work at msft in the office next to the typescript team) 
I think this is the case *if* you're using a text editor (Sublime, Atom, etc). If you're already using an IDE, particularly a Jetbrains one (Webstorm or IDEA) the TypeScript services provided by those can easily be on par (or in some situations better) with those provided in VSCode. That said, definitely use some sort of TypeScript-aware environment if you want to get the full benefit out of the static types - it means that all types can be fully traced back to the source, and usages can be found really easily, just like in a more traditional statically typed language like Java.
Thanks, I'll do that :)
Cool, that's a really great way to approach advanced types. Thanks for the response :)
VSCode is my favorite editor, love it. 
&gt; https://basarat.gitbooks.io/typescript/ Thank you for the detailed response. I'll be sure to read that guide :)
Cool, I'll give that a try. Thanks for the response :)
Will do. No type any at least until I get the hang of it. Thanks for the response :) 
Will do :)
Cool, I'll check it out. Thanks for the response :)
Interesting, I'll have to practice a bit to really understand how to do that. Thanks for the response :)
About extending the Error object and filter by "instanceof", it doesn't work. You will need a workaround. Read more here: [https://stackoverflow.com/questions/47941324/inherited-exceptions-and-instanceof](https://stackoverflow.com/questions/47941324/inherited-exceptions-and-instanceof) [https://stackoverflow.com/questions/41102060/typescript-extending-error-class](https://stackoverflow.com/questions/41102060/typescript-extending-error-class) I created a new class "BaseError", then manually set the \_\_proto\_\_ property (like they described in those posts), and have all my custom errors extending the new BaseError class. Then it worked.
Nope no CS education, self taught. 
Probably, but that would fail on a,b,"c,d",e
This is an empirical question that's very easy to test. We don't need to ask anyone anything, we can just try it. [Here you go](https://www.typescriptlang.org/play/#src=abstract%20class%20Abstract%20%7B%20%7D%0Aclass%20Concrete%20extends%20Abstract%20%7B%20%7D%0A%0A%2F%2F%20const%20thisIsNotAllowed%20%3D%20new%20Abstract()%0A%20const%20thisIsAllowed%20%3D%20new%20Concrete()).
Feedback is welcome. Also, I'd love to see what themes everyone makes with these, especially if you end up publishing them to the VS Code marketplace/Sublime Package Control. Here's a link to the live site: [http://pictheme.herokuapp.com/](http://pictheme.herokuapp.com/) &amp;#x200B;
is it normal that the colors in the code editor don't change when I click "use palette 2"?
Yes, that's normal. The palette doesn't actually get used until you start pressing the randomize button.
Looks like it was bumped to 3.2: https://github.com/Microsoft/TypeScript/wiki/Roadmap
Setting up a webpack config to bundle your node code isn't crazy complex and should only take a couple hours to tweak, unless you have a lot of code doing stuff that webpack can't magically bundle. E.g. relying on `__dirname` relative paths to read files via `fs` calls instead of `require()`. Or some third-party dependencies might use native modules which webpack can't bundle. For those, just declare them as an "external" in the webpack config and include their directory in the Lambda zip. So most of you code will be bundled and minified, but those will be copied verbatim and loaded externally. No need to compile your typescript via webpack's ts loader unless you really want to. You can just `tsc` like normal and webpack the output in a second step. But as others have mentioned, "serverless" is a tool to take care of all this stuff, and it sounds like exactly what you're looking for.
Looks pretty shit to me.
Yeah, go ask Microsoft something that you can find out by yourself by opening CodePen (you don't even need an IDE) and typing an abstract class and two subclasses in TS: public abstract class Animal { public abstract doSound(); } public class Dog extends Animal { public doSound() { console.log("BARK!") } } public class Cat extends Animal { public doSound() { console.log("MEOW!") } } const myDog: Animal = new Dog(); const myCat: Animal = new Cat(); myDog.doSound(); myCat.doSound(); 
Mainly through following on github and contributing . The spec and handbook are significantly behind the actual feature set. I should probably write a post on some of the narrowing details!
Please do!
Re: // If your compiler or linter isn't checking for unused variables, you can do an exhaustiveness check manually. // However this won't be necessary if you have strictNullChecks enabled. // const _exhaustiveCheck: never = pasta; It might be worth highlighting the case where you have a switch that does something in each case but doesn't necessarily return, in which case you cannot use implicit exhaustiveness checking and you might want to do it explicitly to ensure each case gets handled. Something like: export const placeOrder = (pasta: Pasta): void =&gt; { let company: string; let tel: string; switch (pasta.name) { case PastaName.Spaghetti: case PastaName.Linguini: company = "Strand Pasta Co."; tel = "111111111"; break; case PastaName.Rigatoni: case PastaName.Shells: // Set some variables, do some side-effects break; case PastaName.Ravioli: case PastaName.Tortellini: // Set some variables, do some side-effects break; default: const _assertNever: never = pasta; } order(company, tel); } (Sorry if this is covered and I missed, and also sorry for the horribly contrived example).
Updated. https://github.com/Pilatch/grannys-alimentari/commit/ee052038e1423e2e295e7551dfb927b453393a33
NP :) Cool presentation btw
Yeah, build a time machine, go back a week or more, and start preparing then
I did start preparing two weeks ago. ಠ_ಠ
Looks like someone else needs to build a time machine and go back ~4 hours and avoid making a Reddit post.
This is really interesting. It seems like that you're using method decorators to automatically transition states. The two things I'm not sure about are why you're using a gene analogy and when this would be useful
Oops, I was prototyping and forgot to turn them back on. I'll fix it in the next commit.
You have a type bug because you use `Partial&lt;T&gt;` to create a full `T` at: https://github.com/voodooattack/when-ts/blob/master/src/historyManager.ts#L66 `Partial&lt;T&gt;` is not suited for this case.
It's possible! You can run TypeScript modules directly by using [ts-node](https://github.com/TypeStrong/ts-node). I'll sometimes do this because it's easier to attach a debugger, but I suspect most folks will want you to transpile your code and run it on node proper in production.
Two projects exist in this realm. TS Node acts as an interpreter for TypeScript, so you can run a server with `ts-node thing.ts`. It will compile internally. https://github.com/TypeStrong/ts-node Deno is still very much in development. I don't know much about it, but as far as I know, its supposed to be a true TypeScript runtime. https://github.com/denoland/deno
ts-node is still transpiling, it just happens on the fly.
I fixed it in my working copy and it will be in with a later commit. TypeScript 3 handles it just fine, though. No error messages from TSLint either. What version are you using?
Because the pattern allows for DNA-like recombination. If you combine the code of two independent `when` programs, the resulting program can exhibit the behaviour of both. Bad example: Combining a server application and a desktop application can potentially give you a functioning desktop application that listens on a port and serves request, while also displaying a graphical user interface. This is assuming that there are no variable name clashes, and that neither of the original programs tries to exit early or rewind the state. 
TypeScript is intentionally unsafe here. This is an example of the issue: interface MyType { readonly a: number; } function merge(full: MyType, partial: Partial&lt;MyType&gt;): MyType { return Object.assign(Object.create(null), full, partial); } const full: MyType = { a: 5 }; const merged: MyType = merge(full, { a: undefined }); merged.a; // Compiler tells me type is only "number", but never "undefined", but at runtime it's undefined.
Take a look at deno. Still in progress but it will probably make it's way to a mature platform.
Aha. Thanks for telling me. It should at least warn against this kind of thing. I’m making the public interfaces stricter now.
Looks great. Nice job!
Looks good man, thank you :) 
I'll let you know when I'm done
Thanks, star on GitHub if you like it and feel free to leave any feedback :)
We've got a team of 30 devs, all needing to learn TS so can't wait!
I'd love that, can you send a link? 
[Here's the link.](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
That's sorta what I meant by `For production deployments, I would recommend against both of these.`. Deno is nowhere near prime-time ready, especially at an ecosystem level. 
[https://github.com/seanpmaxwell/JobApp](https://github.com/seanpmaxwell/JobApp)
ts-node is your best bet. It *technically* transpiles each file on-demand as it loads, but the transformation is totally in memory, so you can kinda think of it like a JIT. Kinda. Regardless, it works really well and I use it as a replacement for `node` on most projects.
Any differences with \[TypeStack's routing-controllers\]([https://github.com/typestack/routing-controllers/](https://github.com/typestack/routing-controllers/))?
Looks like making a type like this `type Callback&lt;T&gt; = T extends undefined ? (param?: T) =&gt; void : (param: T) =&gt; void;` makes it completely unusable. Probably bug, but not sure.
I don't think there is a sound way to implement the class (with using `as`). But here is a possible solution that lets you use the class in a way that might work: type Callback&lt;T,Default&gt; = T extends Default ? () =&gt; void : (param: T) =&gt; void; declare const dispatchDefault: unique symbol; type Default = typeof dispatchDefault; export class Dispatcher&lt;T = Default&gt; { listeners: Callback&lt;T, Default&gt;[] = []; addListener(callback: Callback&lt;T, Default&gt;) { this.listeners.push(callback); } dispatch: Callback&lt;T, Default&gt; = ((param: T) =&gt; { for (let i = 0; i &lt; this.listeners.length; i++) { const f = this.listeners[i] as (param: T) =&gt; void; f(param); } }) as Callback&lt;T, Default&gt;; }
He actually uses it's own type parameter, shadowing global Object type
If the arguments of dispatch are described by a tuple, you can use conditional types to figure out the tuple. It might work. Something like `dispatch (...args: ConditionalTuple&lt;T&gt;)`
Use a tuple to describe the desired parameters. This version will work for any number of arguments (note your generic type argument should be a tuple for this one): type Callback&lt;T extends any[]&gt; = (...params: T) =&gt; void; export class Dispatcher&lt;T extends any[] = []&gt; { listeners: Callback&lt;T&gt;[] = []; addListener(callback: Callback&lt;T&gt;) { this.listeners.push(callback); } dispatch(...params: T): any { for (let i = 0; i &lt; this.listeners.length; i++) { this.listeners[i](...params); } } } const noArgDispatcher = new Dispatcher(); const stringDispatcher = new Dispatcher&lt;[string]&gt;(); And this will work for zero or one arguments: type OptionalArgTuple&lt;T&gt; = T extends undefined ? [] : [T]; type Callback&lt;T&gt; = (...params: OptionalArgTuple&lt;T&gt;) =&gt; void; export class Dispatcher&lt;T extends any = undefined&gt; { listeners: Callback&lt;T&gt;[] = []; addListener(callback: Callback&lt;T&gt;) { this.listeners.push(callback); } dispatch(...params: OptionalArgTuple&lt;T&gt;): any { for (let i = 0; i &lt; this.listeners.length; i++) { this.listeners[i](...params); } } } const noArgDispatcher = new Dispatcher(); const stringDispatcher = new Dispatcher&lt;string&gt;();
For his case, your playground implementation is perfect. Never thought of using tuples to change method signatures based on generics.
I am looking for suggestions to overcome the limitations stated in the code comments. I didn't expect to get this close to a working snippet. Variable length tuples seemed way out of reach, but this shows it could actually work! Do you guys know of similar attempts? Did anyone succeed in making a useful framework out of something like this?
After an entire fruitless day I discover the fact that I have to keep it non-strict. This is what it looked like when I tried: https://twitter.com/voodooattack/status/1042615850233200640 Apparently TS doesn't make use of decorator type information in contextual type inference. So I'll have to leave it this way for now. It's sad really. :(
It would've been much nicer if we could have proper recursive types in general. That would make it possible to recurse over regular tuple types instead of hacks using interfaces. In one of the recent design notes, there's a mention of this but they rejected the idea for now with some explanation. Meanwhile, they've added special case for mapped types over tuple types which makes them a bit nicer to use but doesn't allow full expressiveness with tuples.
How does the implementation of `unwrap` work? If the input is a Promise, does the type not saying that it pulls the value from the Promise?
Wouldn't generics for the first example be a little simpler? function colorShade&lt;T extends RGB | string&gt;(color: T, percent: number): T { ... } Type inference works properly, TypeScript will prevent you from wrong type, etc. For isDirty example, I'm not actually sure if this is better, but it could be a cool use case for conditional types, e.g. const isDirty = &lt;T extends boolean&gt;(id: number, asObservable: T): T extends true ? IObservable : INotObservable =&gt; { return {} as any; };
Thanks, that is a nice workaround.
I like to promisify my whole codebase :-), thanks for the Unwrap types. TypeScript is just awesome. This kind of typemapping should also be available in C# &amp;#x200B; `import { BehaviorSubject, Observable } from 'rxjs';` `type primitive = Date | string | number | boolean | undefined | null;` `type Unwrap&lt;T&gt; =` `T extends Promise&lt;infer U&gt; ? UnwrapSimple&lt;U&gt; :` `// Optional` `T extends Observable&lt;infer U&gt; ? UnwrapSimple&lt;U&gt; :` `UnwrapSimple&lt;T&gt;;` `type UnwrapSimple&lt;T&gt; =` `T extends primitive ? T :` `T extends Array&lt;infer U&gt; ? UnwrappedArray&lt;U&gt; :` `T extends object ? UnwrappedObject&lt;T&gt; :` `T;` `interface UnwrappedArray&lt;T&gt; extends Array&lt;Unwrap&lt;T&gt;&gt; { }` `type UnwrappedObject&lt;T&gt; = {` `[P in keyof T]: Unwrap&lt;T[P]&gt;;` `};` `export const unwrap = async &lt;T&gt;(val: T): Promise&lt;Unwrap&lt;T&gt;&gt; =&gt; {` `if (val === undefined || val === null) {` `return undefined;` `}` `if (val instanceof Promise) {` `return await val;` `}` `if (val instanceof Array) {` `return &lt;any&gt;await Promise.all(val.map(a =&gt; unwrap(a)));` `}` `// Optional unwrap first element` `if (val instanceof Observable || val instanceof BehaviorSubject) {` `return await val.toPromise();` `}` `if (typeof val === 'object') {` `let result = {};` `for (let key in val) {` `result[&lt;string&gt;key] = await unwrap(val[key]);` `}` `return &lt;any&gt;result;` `}` `return &lt;any&gt;val;` `};` `export const example = async () =&gt; {` `let unwrapped = await unwrap({` `promiseTest: new Promise&lt;number&gt;((resolve) =&gt; { resolve(10); }),` `arrayTest: [123, 'Hello', new Promise&lt;string&gt;((resolve) =&gt; resolve('abc'))],` `anything: new Date()` `});` `let numb: number = unwrapped.promiseTest;` `// Tupples do not work :-(` `let array: number | string = unwrapped.arrayTest[0];` `let array2: number | string = unwrapped.arrayTest[1];` `let array3: number | string = unwrapped.arrayTest[2];` `let anything: Date = unwrapped.anything;` `};`
I'm not talking about at the type level. I mean: how do you write a function: `unwrap&lt;T&gt;(x: Promise&lt;T&gt;): T that doesn't use `async`?
A while loop with a delay until the promise resolves? ;) 
I'll try that now. Will get back to you once my promise has resolved!
Surely I'm not the only one who thinks that api paradigm is completely insane.
To be more precise, with conditional types [https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html)
Building something complex with pure JavaScript is insane, but TypeScript brings sanity into the area of Web/JS development.
That code does not resemble the article, so I’m assuming there isn’t a way. IMO they should have included that code in the post. Seeing how these types are *actually* used is very interesting to me.
So simple, and yet it requires two dependencies...
There is a middle ground between JavaScript and using over complicated type abstractions.
You’re right, that’s quite confusing 
It's a [generic](https://www.typescriptlang.org/docs/handbook/generics.html). Those are classes that can manipulate a certain type of object without needing to be explicit about it. For example, an `list: Array&lt;string&gt;` is an array of strings, which means that doing `list[0]` will return a string. Generic parameters apply differently to each class. `Promise&lt;string&gt;` means that the promise's resolved value is a `string`. `React.Component&lt;string&gt;` doesn't make sense, since normally for React components the first generic is the Props type declaring the interface for the component's props (e.g. `React.Component&lt;IProps&gt;`).
https://www.typescriptlang.org/docs/handbook/generics.html
What do you mean by that? It has in total three dependencies, which are all pure .js code. No native code is involved.
They are essentially creating a complex pseudo-any type to avoid having to type things.
Parametric polymorphism.
1) This is function overloading. A few function signatures can be joined into one interface. &amp;#x200B; 2) In javascript "this" is dynamically scoped, you might have heard about it strange behaviour. Since you call get method on your own server, it will see your Server as it's "this" instead of a Router. &amp;#x200B;
Because it is part of the DOM API, previously as a de facto implementation by browsers but it does have a WHATWG spec now. Node happens to also implement a couple methods from DOM land, for example this and `setTimeout`/`setInterval` You don't have to include the DOM TypeScript definitions though to get it working, [`@types/node`](https://www.npmjs.com/package/@types/node) has definitions for the console global, as well as all the builtin modules
I agree, without a working example this is just a nice idea. But the linked code seems to be similar enough. At least it shows, that it does runtime type matching. And the conditonal and infer typed magical function makes it play nice. Because it helps avoiding the return type "any" problem. Though, I'm also not convinced it's possible to write the function to deal with both Promises and primitive types in a sane way. However, maybe the return type matching helps with exactly that.
Unfortunately you lose type information in the passage from the middleware to the controller. I my projects I follow [this approach](https://federicoferoldi.com/2017/12/28/using-the-typescript-type-system-to-validate-express-handlers.html) for maximum type safety (compile time checks for requests params and response types).
While that's a really cool word, and it sounds really smart, it really doesn't answer OP's question and could probably lead to even more confusion. 
It's actually exactly the answer. However, obviously OP ours unfamiliar with the concept, so some more reading material suggested would be nice.
TypeScript is just annotations - casts don't exist at run time, so you're just filling the `children` array with plain objects. You have to go through the child array and instantiate an actual `Panel` instance for each one.
`this.jsonPanel` is a string. Your constructor expects a `Partial&lt;Panel&gt;`.
use [class-transformer](https://github.com/typestack/class-transformer) it's made by the same guy who made class-validator and they're designed to work together. This may be a little off topic but you might want to checkout [nestjs](https://nestjs.com/). It's a framework that that make's what you're doing (plus some other things) easier and much more elegant, compared to what it would like using express by it's self
Hey, thanks for the response! I actually tried various versions of that and it didn't seem to work I still was unable to call addPanel(). I updated my example I made a mistake adding quotes to the json object. 
well holy shit. TIL Console is a property of the DOM [https://www.w3schools.com/jsref/obj\_console.asp](https://www.w3schools.com/jsref/obj_console.asp) I never really thought about it a guess
Look into package class-transformer
The better way here would be to separate your logic from data. OOP is not the best use-case for tree-like pure data.
&gt; TypeScript is just annotations - casts don't exist at run time That's why it's called "type assertion". But most people just wrongly call it casts.
[removed]
Good point! Looks like I'm guilty of this too.
After installing the addon and reloading, then entering `npm i --save lodash` into my VS Code console, it get an error when I try to import lodash: import \* as \_ from 'lodash'; Error: \[ts\] Could not find a declaration file for module 'lodash'. &gt;'c:/Users/Exac/Documents/example/node\_modules/lodash/lodash.js' implicitly has an 'any' type. Try `npm install @types/lodash` if it exists or add a new declaration (.d.ts) file containing \`declare module 'lodash'; Using React &amp; Typescript. &amp;#x200B;
You should get a UI message saying "Installing: @types/lodash" Are there any errors in the developer console? (`cmd+option+i` on Mac)
I'll take a look tonight
Does your example project have a `tsconfig.json` module and `typescript` in its `"devDependencies"`?
It has 2 dependencies, and so what if it does? It saves you from having to type console.info([colors.green](https://colors.green)(util.inspect(content))) repeatedly, instead you can just say "cinfo(content)"
package.json excerpt: `"devDependencies": {` `"@types/jest": "^23.3.1",` `"@types/node": "^10.5.4",` `"@types/react": "^16.4.7",` `"@types/react-dom": "^16.0.6",` `"@types/react-router-dom": "^4.3.0",` `"typescript": "^3.0.1"` `}` tsconfig.json: `{` `"compilerOptions": {` `"allowSyntheticDefaultImports": true,` `"baseUrl": ".",` `"outDir": "build/dist",` `"module": "esnext",` `"target": "es5",` `"lib": [` `"es6",` `"dom"` `],` `"sourceMap": true,` `"allowJs": true,` `"jsx": "react",` `"moduleResolution": "node",` `"rootDir": "src",` `"forceConsistentCasingInFileNames": true,` `"noImplicitReturns": true,` `"noImplicitThis": true,` `"noImplicitAny": true,` `"strictNullChecks": true,` `"suppressImplicitAnyIndexErrors": true,` `"noUnusedLocals": true,` `},` `"exclude": [` `"node_modules",` `"build",` `"scripts",` `"acceptance-tests",` `"webpack",` `"jest",` `"src/setupTests.ts"` `]` `}` &amp;#x200B; &amp;#x200B;
You could do worse to start with than going through these blog posts for the various new features: https://blog.mariusschulz.com/archive
I prefer [types-checker](https://github.com/salimkayabasi/types-checker)
Looks nice. What do you prefer about using the CLI instead of VS Code doing it for you?
Because my VS Code uses a ton of extensions (107 currently) and takes 7-8 GB of RAM at blank page. Don't want to raise memory consumption!
Definition files are necessary for Typescript to know what members are exported by modules, and their types. Without them, you lose some or all of the type safety, which is the entire point of Typescript in the first place.
So just importing the javascript library (I do not know how to) is not good?
Pretty much - the compiler can't properly perform type checks without a definition file. There are ways to make it blindly accept them without definitions as well IIRC, but at that point you're pretty much just using JavaScript.
You can import javascript libraries, you just don't get help from the compiler to insure your code is correct unless you also give it a definition file. Either you create definition files for you libraries or convert them to typescript. Example 1: ./project/-/src/ -/js/ -/js/utils.js -/js/utils.d.ts or ./project/-/src/ -/js/ -/js/utils.ts 
Also, if those js libraries you are using are third party libraries there are probably already type definition files available on npm. Search for `@types/${LibraryName}` on npm
I understand. It is obvious a "must" One more question, how to create definition files by my own? Any good guide?
https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html
You can’t ‘import’ js files because js is dynamic - there’s no way to tell what the definitions are of the things you’re importing. You don’t have to use definition files if you don’t want to, ‘declare var jslib: any’, but if you want the benefits of static typing you either need to find or create them.
Fixed in v0.1.3
If you can't find the declaration files for those that you need and don't have time to build your own, don't be discouraged! Just declare them as \`any\`, add a \`// TODO\` and move on with your day. I found getting started to be a little overwhelming at first but remember TypeScript is intended to overall assist your day to day, not hinder. You can still use those libraries like you always did with the proviso that you won't get any benefit \*for those libraries\*. The \_rest of your code\_ will still benefit greatly, and it won't get in the way of learning the language.
You can `declare module "yadda-yadda";` and it'll stop complaining about the yadda-yadda module.
You can if there's a declaration, and the declaration can be as simple as declaring the module to be type `any`.
Still does not work after uninstalling and re-installing and reloading v0.1.3
Strange. Could be Windows-specific? I used your exact setup, and it worked in v0.1.3. I added a short delay before reloading the `package.json` when changed. Might be the delay is not long enough? (currently `0.25` seconds)
I spend a lot of my spare time working with Rust and when I come back to JS/TS I miss a lot of things, but by far the biggest are the `Result` (values being `Ok(T)` and `Err(E)`) and `Option` (values being `Some(T)` and `None`) ADTs. In essence, these are enums that hold values. For example: let x = do_sth(); // returns e.g. Result&lt;String, Error&gt; Now there is a lot of flexibility with what you do with this. If you're inside a function that returns a compatible error, then you can unwrap and return and propagate the error very ergonomically: let x = do_sth()?; Perhaps you want to continue execution regardless, but do something only if it unwraps to an `Ok`: if let Ok(val) = do_sth() { do_sth_else(val); } Options are similarly ergonomic: struct Example { id: i32, name: Option&lt;String&gt;, } let example = Example { id: 0i32 }; // Now have access to a lot of helpers: example.name.is_some(); if let Some(name) = example.name {} // matches are exhaustive and force you to provide an arm for every possibility, though there is a catch-all available for other situations match example.name { Some(name) =&gt; name, None =&gt; String::from("fallback name"), } // etc Above all else though, it's nicest because the entire ecosystem - from the standard library to third-party crates - utilises them. I also really love the fact that the type system is runtime. If you've ever written a backend in TS and had to resort to using io-ts, Joi, etc to verify external data, you'll know how unergonomic that is. I really enjoy learning new languages, you always learn new concepts!
&gt; type system is runtime What do you mean by this? I'm not sure I follow.
TypeScript has no runtime type information. That means even if you declare your property to be of type string, nothing prevents code from assigning any other type to it at runtime. That means essentially you can't ever trust external data and need to manually validate it first, including type validations that otherwise the runtime would do for you already.
After you compile a TS project it's literally just JS. None of the types are in the compiled JS. It's possible to have incorrect types at runtime that a typechecker would catch, but as there is no typechecker they go undetected. Basically, the types are for compile time checking only.
I understand what it means by for a type system to have *no* runtime information. But I wasn't sure what was meant by the converse: type system *is runtime*. I'm guessing the author is talking about something to do with Rust but I'm not really familiar with that.
Think about the edge of your application and the data that comes in, for example from an API call. In TypeScript, you _assert_ what the data is. You either do it lazily and just hope for the best, or ideally you manually verify what it is with a tool like Joi or io-ts. The latter implies effectively defining your interfaces twice in not necessarily compatible ways. Either way, your project's type safety lives and dies by the assertions your developers make at the edge of your application. In a language with a runtime type system like Rust, the two concepts are effectively brought together. You _directly_ test the incoming data against a struct (think interface) and from there the compiler forces you to handle both possibilities, that the data is compatible and that the data is not. You only design your interfaces once, and you're completely type-safe. Here's an example of how it looks in Rust using the [serde_json](https://crates.io/crates/serde_json) crate (sugar over Rust's type system for (de)serializing foreign values, maintains the same level of safety): struct Person { name: String, age: i32, nicknames: Vec&lt;String&gt;, } let data = api_call(); let parsed = serde_json::from_value::&lt;Person&gt;(data); The magic is the last line; it strictly parses the data against the struct we have defined and returns a `Result` (generic enum). Now we can be 100% sure that `parsed` is either an `Ok(Person)` that perfectly adheres to our struct, or an `Err` that we will handle differently. To be clear, the broader point about the benefit of a runtime type system is not unique to Rust, however it is something that sadly JavaScript lacks beyond its comparatively useless `typeof` and similar, and that TypeScript lacks because of the devs considering it a non-design goal. They aren't necessarily wrong, however there is a ton of value to be had in a (strict) runtime type system.
Thank you for the detailed response! This is what suspected you meant, but wasn't really sure. As far as I can see, the only difference between that Rust example, and say something that uses [runtypes](https://github.com/pelotom/runtypes), is that you don't need to construct the value level version of `Person`. Instead, `serde_json` seems to be using some kind of meta-programming to generate the contracts during compilation. You can do essentially the same thing with a TypeScript plugin or tool.
Microsoft answers your questions in the [Readme](https://github.com/Microsoft/tsdoc) On JSDoc, they say (my emphasis): &gt; &gt; Why can't JSDoc be the standard? Unfortunately the JSDoc grammar is not rigorously specified, but rather inferred from the behavior of a particular implementation. **The majority of the standard JSDoc tags are preoccupied with providing type annotations for plain JavaScript, which is an irrelevant concern for a strongly-typed language such as TypeScript.** TSDoc addresses these limitations while also tackling a more sophisticated set of goals. 
Which one to follow? There are two repositories.
TypeDoc is a generator project, and TSDoc is the actual documentation spec, so the latter is what you want.
That is up to you. The tags have a lot of similarities, so if you only use a subset of them, it could work with both. My instinct would be to stick with Microsoft's, since they created Typescript, but it makes sense to try a couple of options and pick whichever fits your workflow and documentation needs the best.
I am the author of the library, 2 months ago was the initial release, after a lot of back-and-forth with the TypeScript type system I decided that it's time to release a new version that addresses the issues people most commonly had.
&gt; The package was renamed from `pure-ts` because of NSFW search results. Hahah! 😂
Just out of interest, and I don't mean to sound rude, but why did you not contribute to fp-ts instead?
I do not agree with the design decisions made for \`fp-ts\`. I wrote about that in the discussion for the initial release of purify: [here](https://www.reddit.com/r/typescript/comments/8y20no/pure_010_released_a_functional_programming/e29e4yl/) &amp;#x200B; I also think that in the future TypeScript will provide a feature that will make working with HKTs easy and then purify will be able to take advantage of that without increasing overhead like fp-ts does.
Well [compodoc](https://github.com/compodoc/compodoc) is amazing and what I use. But it's angular centric. In fact I don't even know if it works on non angular code bases. But for angular it's flat out amazing. With just the absolute basic options it produces documentation that looks like [this](https://tme321.github.io/UAT-DynamicViewKit/index.html). But that might not help you much...
Thanks!
Not op but I haven't been able to figure out how to contribute to `@types/express`. It doesn't account for being able to define routes with regexp not functions. 
The webpage has these \lambda signatures for the functions but they are largely undocumented. In the signature for `equals` (a, b) ~&gt; (a, b) -&gt; Bool what is the difference between the arrows `~&gt;` and `-&gt;`? I think some of the examples without purify are abit contrived, for example: let port: number let config: Config | null = getConfig() if (config &amp;&amp; config.port) { port = parseInt(config.port) } else { port = 8080 } Is that really a fair representation? It could easily be written as const config = getConfig(); const port = config &amp;&amp; config.port ? parseInt(config.port) : 8080; 
Are you trying to compute multiplication ahead of time? 
I want to be able to ask for obj1.computed and get 6.
You could use an IIFE: const obj2 = (function() { const o = { prop1: 2, prop2: 3 }; o.computed = o.prop1 * o.prop2 return o })() console.log(obj2.computed) // 6
This is something that grabbed my attention too...
In TypeScript, I always get an error if I ask for obj1.computed. 
This is not what he asked for. He wants `computed` to be a computed get-property, not a regular assigned property.
It works as you provided it in your code already: const obj1 = { prop1:2, prop2:3, get computed(){ return this.prop1 * this.prop2; } } You don't access `this.obj1` in the getter, because `this` refers to the object literal you create, and that object literal has no `obj1` property. `obj1` is just the variable you store the object reference in.
Very interested in this package. I was *just* looking for something that strikes a balance between functional convenience/expressability but is easily adopted and communicable for people not familiar with the FP approach.
Could you give me an example?
Oh shit I put the wrong library. I meant `@types/socket.io`
It seems like a trivial type definition to create. Make a PR and people will surely give feedback.
The type `AlwaysJust` is essentially a *brand*: a brand is a type that typically has no run-time value but is used to represent some information to the type-checker. This information could be the "name" of the type (turning a structural type into a nominal one), or it could be some other proof of some fact, which is the case here. Given a value `x` of type `Maybe&lt;T&gt;`, then applying the type guard `isJust()` adds an assertion that this maybe is actually a value wrapped in just, rather than nothing. This assertion takes the form of an intersection type with a brand. So we have: const x: Maybe&lt;T&gt; = .... if(x.isJust()) { // in this block, x has the type Maybe&lt;T&gt; &amp; AlwaysJust } In the `if` block the brand is used to state that we now know that `x` is a just, rather than a maybe. Basically, we have added a fact to the type of `x`. The library uses this fact to change the type of certain operations: /** Returns the value inside `this` or null if `this` is `Nothing` */ extract(): this extends AlwaysJust ? T : T | null { return this.value as this extends AlwaysJust ? T : T | null } The type of this function basically says, if we know the maybe is a just, because it has been branded with the fact `AlwaysJust`, then we don't have to worry about `null`, just return the value in the just. If we don't have this fact available then the the maybe *could* be nothing, so we might have to return null.
`~&gt;` is for showing the type of `this`. I've seen this notation used in a couple of libraries but I admit that I'm not sure of the origin. As for the examples - are they really that contrived? I mean I tried to think of an example for Maybe and just wrote out an implementation without thinking about it much, your example one-liner will get a lot of strange looks for sure.
Found an article about [TSDoc in InfoQ](https://www.infoq.com/news/2018/04/tsdoc-format-announced) &gt; The TSDoc format states the following goals: &gt; - Design a grammar for TypeScript while extending JSDoc &gt; - Allow Markdown within comments &gt; - A common set of documentation tags &gt; - Extensible mechanism for adding tags &gt; - Interoperable, so custom tags won’t break parsing of non-custom tags and handling Markdown ambiguities &gt; - Cross-referencing between packages and dependencies &gt; - Open standard &gt; Additionally, the TSDoc reference parser also aims to provide: &gt; - Strict and lax modes, with lax attempting to parse existing JSDoc-based grammar &gt; - Bi-directional round-tripping between doc comments and abstract syntax trees &gt; - Self-contained, no dependency on the TypeScript compiler API, allowing the abstract syntax tree for comments to be a simple JavaScript object tree &gt; TypeScript developers should expect that JSDoc type annotations that are redundant with type information already provided &gt; by TypeScript be optional with TSDoc.
I was saying idk how to contribute
Cheers. I was ok reading everything else, just got stuck on `~&gt;`. Contrived is probably a bad choice of adjective. I just think the way the Non-Maybe code is written makes it look worse than it should, and is slightly unfair. I think the example on the home page with all the early returns is more compelling and realistic of real code, but that's just me.
The [Monad spec in fantasy-land](https://github.com/fantasyland/fantasy-land#monad) defines `&gt;&gt;=` as `chain`. Since purify is FL compliant and I don't like aliases, this is the name of the method in purify too. I also think that `chain` is more clear than `flatMap` or `bind`, so there's that.
Gotcha. Thanks.
This library is interesting because it contains and is based around a scheme for encoding Higher Kinded Types in TypeScript. This is a feature which TypeScript does not natively support. I think it is interesting to learn about how to use higher kinded types using JavaScript and explore the patterns using those with type safety. More over this library is quite complete and thorough covering functional programming abstractions. 
My understanding is that the `@types/*` packages come from [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped), and pull requests should go to that project. You might take a look at their [contribution guide](http://definitelytyped.org/guides/contributing.html).
It's a great resource. There's also a #typescript channel in the Reactiflux discord.
Another fairly active channel is the TypeScript channel in the functional programming slack. 
oh golly can you DM me a link to that?
https://fpchat-invite.herokuapp.com/
It's completely fine to use this even without any need for HKTs and typeclasses. Just look at monocle-ts and io-ts. 
I don't doubt that you can. In fact I know that generic types can take you a long way. My point is if you want to learn about or use higher kinded types in a familiar language then this library is the best around. 
That's not what he is trying to do. He wants a getter.
Tell Uber to use OvernightJS instead of NextJS
Cmon guys irc is where it’s at 
/u/gigobyte /u/-jvv The \`\~&gt;\` symbol typically represents a Natural Transformation. [https://wiki.haskell.org/Category\_theory/Natural\_transformation](https://wiki.haskell.org/Category_theory/Natural_transformation) 
Hey thanks for this, I never heard of Compodoc. Really easy to use I've already generated my company's project documentation in just a second!! Thanks a lot!!
I have to agree. Most other serious languages have their freenode IRC as their focus point for instant discussion. While there shouldn't be an enforced rule that only one platform is to be used, IRC should be highly encouraged.
The main problem I see with the IRC channel is that history is not logged/maintained. A person has to sit in the channel for long time to get value out of it. Gitter and Slack allow one to scroll back through the history and maybe find something of interest. 
Is @types/node something I should immediately add when using typescript and node in pretty much all cases?
it was rewritten completely into typescript and it's hugely popular tool. I'd say it's related.
Yep, add it right from the start of the project, otherwise you'd get errors for missing modules/variables.
where ?, I don't see it in typescript, not in master nor development branches
I can see it in Typescript in the master branch when I looked just now. Anyway, I think it would have been nice for this reddit posts title to be a bit more informative, but ah well.
oh, I see, my mistake, it still says 100% javascript in github 
Can we have a rule that requires direct links to github repositories come with some context? - What does the code do? - What is an interesting feature to look at at? Otherwise we might as well get a bot that crawls github for high star, high % TypeScript projects.
Anyone here used this, either as a student or mentor? Would be interested to hear about it!
That would be great!
Well, I (OP) have used it as both a student and a mentor and obviously love it. I've also introduced it with success in my company, as a way of practicing an existing or learning a new language.
Basically, there are students that go through exercises and then submit their solution to the website. One of the mentors can then choose to mentor that solution and engage in a dialog with the user on the solution. If the mentor thinks the solution is okay, he can approve, and the user can continue with the next exercise. If not, the mentor can give the student pointers on how to improve the solution and submit a new iteration. A common question is how much time it will take, and I would argue that that is completely up to the mentor. It would be great if you could do 20 reviews in a week, but if you can only do a couple, that is still great. Also, you as a mentor can decide which exercises to mentor, so you could focus on one or two simple exercises to get started with. If you need any help, feel free to contact me!
Appreciate the kind words! As for the exercises being recycled: that is a valid point. We are in the process of reviewing the exercises, and some language tracks have already started adding language-specific exercises.
This doesn’t need to be here, most of the readers already know and use TypeScript.
Not to mention it's very poorly written. Under "Why should we use TypeScript?" points 1, 4, and 5 are identical: &gt; 1) TypeScript simplifies JavaScript code which is easier to read and debug &gt; 4) TypeScript makes code easier to read and understand &gt; 5) With TypeScript, we can make a huge improvement over plain JavaScript They don't even get to "Supports static typing" until 14 points in, which is the whole point of TypeScript. The article looks like it was phoned in from beginning to end by someone who hasn't heard of either TypeScript or JavaScript until this morning.
Great to have you on board!
Any chance we'll get an updated specification? It's still stuck at 1.8. The last update was 2 years ago. It's really a pity, as the documentation is often really lacking. Only way to find out if a behavior is intentional is to dig through the documentation and search through thousands of GitHub issue comments.
Specs are for pussies - TS Core Team probably
The video of refactoring from promises to async/await won't play on my iPhone. Broken for anyone else?
Works fine for me on mobile. The feature is pretty cool (go Elizabeth!), but I think the video doesn't capture it very well. For instance, how are \`.catch\`'s handled? Also there's a big chunk of renaming in the beginning that doesn't add value to the video.
The the thousands of github issue comments
we want pattern matching already!
“Just read the source code” -0.1x programmers
Really like this. Especially how it defaults to strict mode.
Doubt they'll add it anytime soon as it's still [stage 1](https://github.com/tc39/proposal-pattern-matching). Another awesome stage 1 proposal for folk to check out is the [nullish coalescing operator](https://github.com/tc39/proposal-nullish-coalescing)... :-)
I believe `export = FooBar` is correct. `export default FooBar` is the equivalent of `module.exports.default = FooBar`. 
What about `allowSyntheticDefaultExports` and the new `esModuleInterop`? Also, using `export default FooBar` potentially gives a better experience for the user. They can do this: import FooBar, {Options} from 'foobarlib'; With `export = FooBar`, they have to do this: import FooBar from 'foobarlib'; import Options = FooBar.Options;
We need an updated spec. Microsoft has done good recently but I’m not ready to forgive them
Your site says 404
https://formidable.com/blog/2018/typescript-second-coming-node
For starters, your syntax is all over the place. None of it is valid typescript. Either way, it's possible. type NottableFn = (...args: any[]) =&gt; boolean | NottableFn; function not&lt;T extends NottableFn&gt;(fn: T): T { return ((arg: any) =&gt; { const value = fn(arg); if (typeof value === "function") { return not(value) } else { return !value; } }) as T } &amp;#x200B;
 FYI: As of TS 3.0 introduced project references to fill the "monorepo" need. I don't know what that means for Lerna, but my understanding was the native TS solution would be preferable moving forward. [https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/](https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/)
Typescript is not the second coming of node.
These are totally different things. Typescript builds javascript files but lerna sets up symlinks with multiple projects. You can use them together to build separate node.js packages [https://github.com/Quramy/lerna-yarn-workspaces-example](https://github.com/Quramy/lerna-yarn-workspaces-example)
Did you even read the article?
It's a nice 404 page
You're original function works just fine you just need to add the correct syntax for function types. function not&lt;T&gt;(x: (t:T) =&gt; boolean): (t:T) =&gt; boolean { return (y: T) =&gt; !x(y); } https://www.typescriptlang.org/play/index.html#src=%20function%20not%3CT%3E(x%3A%20(t%3AT)%20%3D%3E%20boolean)%3A%20(t%3AT)%20%3D%3E%20boolean%20%7B%0D%0A%20%20%20%20%20%20%20%20%20return%20(y%3A%20T)%20%3D%3E%20!x(y)%3B%0D%0A%20%7D%0D%0A%0D%0Afunction%20test(x%3A%20string)%3A%20boolean%20%7B%0D%0A%20%20%20%20return%20x%20%3D%3D%20%22foo%22%0D%0A%7D%0D%0A%0D%0Alet%20fx%20%3D%20not(test)
Have you tried debugging this? my guess is the child objects aren't actually getting constructed. They must still be plain objects because otherwise they would have the Panel prototype and could call add panel. Perhaps you could do something like thing. &amp;#x200B; constructor(json?: Partial&lt;Panel&gt;) { if (json) { Object.assign(this, json); const { children } = json; if (children &amp;&amp; children.length &gt; 0) { this.children = children.map((c) =&gt; new Panel(c)); } } } &amp;#x200B;
The strict compiler flags disabled? Why use a language for type safety and throw away the best type safety features it offers?
&gt; TypeScripts goal is to stay compatible with ES how about this scenario? What if ES recommends adding feature X and published some draft syntax for it, and TS implemented it. Then ES decides to scrap that feature, or re-implement it using a slightly different syntax? That's a divergence, would TS change its syntax to be compatible?
ES will not scrap established features. They have different stages for new proposals, and TypeScript will only add support for it if it's in an advanced ES proposal stage (basically it's clear that it will be added). But yes, if ES adds syntax that exists in TypeScript already, then TypeScript will very likely introduce a breaking change (probably behind a compiler flag). This happened before already.
That is interesting! Thanks for sharing the knowledge, I think I'm a lot more confident in adopting TS now for my team's sourcecode. I'm thinking I will adopt TS and mainly use it as ES7 with typing. I'll add TS types to some of my existing JS code, and then compile the TS to the same location, such that myFile.js is right beside myFile.ts. And since I'll write my TS like ES7 with typing, my teammates can easily still understand, debug, and modify my TS code. Plus, we use Visual Studio Code, so some of the TS typing hints will also be useful when my teammates require() some of my TS libraries into their codebase.
&gt; ES recommends adding feature X and published some draft syntax for it, and TS implemented it. That doesn't happen. Language features make it into ES through [a number of stages](https://tc39.github.io/process-document/), and TS typically only implements features in stage 4 ("finished") or stage 3 that are unlikely to change. In other words: when TypeScript implements a feature, browsers will also start implementing it, and it will no longer change.
That's good to know! Do you know of any major syntax difference in TS that *isn't* in the stage 3 or 4 proposals? Apart from static typing?
There are a few, such as [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html), which are only at stage 2 - these were added because the Angular team very much wanted them. However, they come with a note that they might change, and you have to explicitly enable them with a configuration flag (which I wouldn't recommend). Likewise, [JSX](https://www.typescriptlang.org/docs/handbook/jsx.html) is not on track for being standardised as well, but since it's heavily used by virtual-dom-frameworks like React, they added it behind a flag as well. I guess about some other features like enums and interfaces you could argue whether they're part of type annotations or just important to them. I wouldn't expect them to make it into Javascript unless Javascript would start doing something with types as well (in which case they'd surely look at and involve the teams behind TypeScript and Flow), but if they do and it conflicts with the way TypeScript does things, I would expect TypeScript to change along as well, hopefully in a backwards-compatible way, like they did with their custom import syntax.
&gt; &gt; &gt; Btw, how does one develop in both TS and JS? Do i have to keep invoking the tsc compiler everytime i make a small change to my TS libraries while working in a JS codebase? I haven't combined JS and TS so far, but you can run the TypeScript compiler in watch mode, so that it compiles your code as you save it. &gt; Can TS use JS libraries easily? I recall seeing a lot of TS variants of existing popular libraries, like TS react etc. Why is that so, i would have thought they were interoperable by default? It'll be troublesome if i couldn't find the TS version of a JS library i depend on It depends. TypeScript has the `any` type, which basically turns off type checking for any code referencing variables with that type, which can be useful if you want to use Javascript code without too much effort. Otherwise it's popular enough these days that many, many libraries either include type information themselves, or a package named `@types/&lt;package-name&gt;` is available that provides the type information for you. If that is not the case, you'd have to write type annotations for the library yourself (either with `any`, or properly), which indeed is the greatest pain in the behind when interoperating with Javascript.
Hey! Thanks for the reply I will definitely be checking this out!
Hey thanks for your reply. I thought about what you said I your probably right added function to each item in the tree might not be the best practice (lots of extra repeated code?)
 &gt;explicitly enable them with a configuration flag (which I wouldn't recommend) That's great, flags are the way to go. Power to flexibility. :) &gt;other features like enums and interfaces you could argue whether they're part of type annotations or just important to them I feel they can be considered to be different from type annotations, but enums by themselves should be easily readable enough for any developer trained in statically typed languages (my team works in Java too). So my colleagues can prob read and edit them no problem. 
&gt;many libraries either include type information themselves, or a package named `@types/&lt;package-name&gt;` is available that provides the type information for you. &gt;If that is not the case, you'd have to write type annotations for the library yourself (either with `any`, or properly), which indeed is the greatest pain in the behind when interoperating with Javascript. Ah, that sounds kinda like MyPy in Python. Making type definitions was really tiring sometimes, so i opted to leave things as Any sometimes, especially for reference return values. Thanks for the really informative post!
Yes, I think MyPy and TypeScript have the same goals for different programming languages :) And you're welcome :)
There actually is a static typing [proposal] for JS, just in very early stages. [proposal]: https://github.com/sirisian/ecmascript-types
ohh no problem this is call [object desctructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring), I don't want to say definitively it's syntactic sugar is all cases but in this case const { children } = json; const children = json.children are identical statements. The keyword const are one of the three variable declaration keywords `var let const` where const has block scoping and prevents reassignment. &amp;#x200B; Looking at your original post more. What I believe is the problem is in. constructChildren(children: Panel[]) { children.map( p =&gt; { new Panel(p); if (p.children.length &gt; 0) { this.constructChildren(p.children)}; } ) } What appears to be happening is a new panel is created in the map function but not returned. Therefore it destroyed when it leave this iteration of the map function. the map itself is also not returned so this function will essentially create a bunch of panels that disappear after it finishes running. &amp;#x200B; What my little snippet does is essentially does an object copy with the Object assign. At this point the child panels are just plain objects and don't have the addPanel method. Then I grab the json for the children if it exists and proceed to recursively override the child property with new Paneled versions of themselves.
That's kind of what happened with modules.
That sounds typically Microsoft:. "Embrace, Enhance, Eliminate". To try and take over the design of Javascript. TypeScript was supposed to copy JavaScript. They made changes to the modules/namespaces to reflect ES6 so that might be true!
It's really no different than working in a code base that uses modern JS and a transpiler like babel. Most toolsets have a "watch" option that leaves them running and will automatically compile when save changes in your project directory.
Oh, could you elaborate what happened? I know browser modules and node modules are a mess, but what of TS?
I believe Node/npm was first with modules. They used the `require` function. When npm started being used for client side code as well, the js bundlers like webpack would treat this function like special syntax to make it all work. Typescript initially took this route, but then es modules started to become a standard. Typescript adapted this new syntax, even though no js runtime had support for it yet. This transition, coupled with that typescript didn’t have a standardized way of supplying 3:rd party typings for js libraries left quite a mess behind. It is mostly cleaned up now, though. 
At the rates things are going if they aren’t compatible with TypeScript nobody will approve it. Too popular. 
Personally, I'd recommend not having TS and JS files sitting next to each other. I did that on one team and it just caused a number of nuisances with the wrong files accidentally being checked in, or a file not being deleted properly. I think it's easier to have a build folder, and only publish that build folder. That said, your idea seems reasonably sound in principle, so I guess see how well it works for you!
The article is disappointing because it discusses the new features that I understood fine in the release notes but not the one that I didn’t, project references
What if a library I use does not have a definition file? It seems so hard to create a definition file to cover it.
You should read the ES4 spec. Then you'll have your answer
You don't need to create a definition file for an entire library. You can add local definitions that cover just the things you are using. For example for a project I was made I created a file named declarations.d.ts and put the following definition in it. declare module "snabbdom-to-html/init" { import * as snabbdom from 'snabbdom/vnode'; export default function init(a: any[]): (input: snabbdom.VNode) =&gt; string; } Ultimately, you can continue to update the local definitions as you learn the type system and as you add features that you use. The TS compiler will tell you if you get it wrong, so you can keep trying until it is good. 
Ah icic. I think although it's a breaking change for TS, conformity with ES syntax will help TS a lot in the long run. Thanks for sharing that history tidbit! Glad to know TS has demonstrated its commitment to its design philosophy of staying aligned with ES.
Very much agree on the points. As a quick conversion rather than modify all of the issues (such as lambdas for rendering etc..) i left most of the auto-generated as .js files. I went ahead and changed the last issue file to a .js and reverted the scritNullCheck since for learning they should probably work with the null checks enabled. And left a mark on the readme about changing the strictness for production quality code. Thanks!
You don't need to recompile TypeScript when you change JavaScript.
Yeps! I was referring to changing TS, not JS haha.
Can you show us some code ?
[removed]
Why do you want your variables to be global?
- Global variables: You can't define globals in JAVA, so why try it in Typescript? Do what you would do in Java: Declare a static variable on a class. - One class per file: That's perfectly fine and I do it all the time. You have to explicitly import files though. I usually have 1 class per file, and an `index.ts` that exports all these things. EG: ``` // core/user/IUserService.ts import { IUser } from "./IUser" export interface IUserService { getUserById(id: string): Promise&lt;IUser&gt; } // core/user/IUser.ts export interface IUser { id: string; } // core/user/index.ts export * from "./IUserService" export * from "./IUser" // core/index.ts export * from "./user" // http/HttpUserService.ts import { IUserService, IUser } from "../core/user"; export class HttpUserService implements IUserService { constructor( private endpoint: string, private fetch: Fetch, ) { } async public getUserById(id: string): Promise&lt;IUser|null&gt; { const response = await this.fetch(this.endpoint + "/users/" + id); return response.status === 200 ? parseUserResponse(await response.json()) : null; } } // essentially a prive function // no need to embed it in the class since it won't be using `this` either function parseUserResponse(data: any): IUser { return ...; } // http/index.ts export * from "./HttpUserService"; // index.ts export * from "core"; export * from "http"; ```
Once you go TypeScript you never go back :)
[removed]
Seriously! The compilations are so much faster too!
True!!!
When this happens I'll switch
Take that TS haters! Hahahaha I know many vue lovers who say they hate TS HAHAHA!!!
this is exactly the kind of thing I was annoyed back when I learnt JavaScript a few years back. To answer your question, now I think the "this." is absolutely necessary, not for the compiler to work but for you to be really aware of the dependencies that your methods have on the instance. Over time I learnt to go out of my way to reduce the amount of states that I jam on the instance, and typing "this" every time I do so is a good reminder. Another reason this is good is when you code review some big class on github you can actually track where thing comes from at the first glance, and not have to run a compiler in the brain to infer the context.
I'm lazy too. So my favorite part is that I know have the courage to actually refactor large projects because it doesn't take hours of figuring out what goes where anymore.
I'm just going though Max's "Understanding Typescript" course on Udemy for the second time (as a refresher after a break from coding). It's a good course especially if you know another language and mostly need to learn the syntax and nuances of TS. You can usually get the course for about 10 (insert currency here).
I am quite familliar with JS, does the course include building practical projects?
Great, just when I masteres Angular because it has native TypeScript.. while I preferres Vue. Oh well! Not gonna complain. All aboard the TypeScript trolly!
The availability of browser typings is based on your tsconfig. See `--lib` in https://www.typescriptlang.org/docs/handbook/compiler-options.html
Hope that the TypeScript migration works out for y’all. Big fan of it myself.
In JS (incl/ TS) we tend to use modules and import what's needed wherever it's needed. Global variables are virtually always considered bad practice. I think the only exception for me would be high-level types that wouldn't be out of place if they were in TS' standard library.
Thank you very much. Just a doubt, that whole first piece of code is just index.ts?
["Prettier" is similar to Standard.](https://github.com/prettier/prettier)
I've used Prettier before. I just stopped using it because of StandardJS. And sometimes it stood in my way just a little too much.
Oh, it works awesome for us so far, and we don't have any doubts about it staying that way.
Are you talking about Node or the browser? For the former you can just \`declare global\`, for the latter you'd have to do that or extend the \`Window\` interface. If you can present some examples, I will show you how to do it.
The Max is the man. Not dumb or strange, I just feel most people who post to these subs don’t even know what the docs even are. 
Probably a user defined type guard can help: https://basarat.gitbooks.io/typescript/docs/types/typeGuard.html
Maybe I am missing something, but wouldn't function not&lt;Args extends any[]&gt;(fn: (...Args) =&gt; boolean): (...Args) =&gt; boolean { return (...args) =&gt; !fn(...args); } do the job?
You simply need to cast it. Try using the `as` keyword.
This works for a single order function, but not arbitrarily higher order functions. When using this function with a function of order greater than one the `!` operator would just return the truthiness value of `fn`: `true`.
Typescript is basically just stricter Javascript. If you're used to statically typed languages then I would recommend starting with Typescript. You'll have a bit more to learn, but it will be more familiar and the compiler will help prevent you from doing things wrong.
Older Javascript relies heavily on closures and callbacks which are unnecessary/antipatterns in Typescript. Seriously.. don't even look at any Javascript dating back more than about 3-4 years because it will just confuse the issue. If you're talking about just looking at very modern ES6+ javascript then, well you could. But as BeansPatio said, you have experience with static typing .. so go right to Typescript.
 if (foo instanceof TypeB) { console.log("this is a B") } libFunction(foo);
I'm longing for the day that Javascript will get the honorable place in programming languages that it deserves. If anything is a conventional programming language it should be javascript. Having said that; I would say learn Typescript, since you will work on personal projects. However, do realize that you will have a hard time to understand many of the javascript projects that are out there. Which are build with classical prototype systems, callbacks and the likes. Very ugly and weird to understand if you are used to an OOP style of JS with typescript. Either way, typescript is the way forward. Especially now that 2 of the 3 major front-end frameworks are (will be) build in typescript.
I agree, I see no reason to need to learn Javascript before Typescript. By learning Typescript you are more or less learning Javascript at the same time with just a few extras.
 const foo = TypeA | TypeB; function usesTypeA(value: TypeA): void { // do something. } function usesTypeB(value: TypeB): void { // do something. } // this is a "type guard" function isTypeA(value: any): value is TypeA { return true; // do whatever you need to do to test if a value is type a } // via type guard (safest way) if (isTypeA(foo)) { usesTypeA(foo) // YES: foo is TypeA usesTypeB(foo) // ERROR: foo is TypeA } // via type assertion usesTypeA(foo as TypeA); &amp;#x200B;
I suppose by callbacks you mean the continuation-passing style which lead to callback hell and has been outmoded by promises and async/await, and to a lesser degree async iterables and observables. You might have also meant IIFEs used as modules, which is outmoded by module systems, but callbacks and closures on their own are anything but unnecessary; for example, the array iteration methods take callbacks.
No, i added comments with filenames above it :) 
You should not do Typescript without knowing Javascript, because Typescript IS JavaScript, but with added features (typing, accessibility modifiers, interfaces, etc.) Other than the things that make it Typescript, the language follows the same ECMAScript standards and keeps up with each new ES release. You won't be able to really follow a good Typescript course without knowing the underlying Javascript.
That's handled with incremental compilation in watch mode
It is best to learn C# first.
If you hover over default JSX typedefs you may end up on typedefs from the DOM, it is all reused.
If you are writing typescript, you need to know both javascript and typescript. 
Strongly agree. Besides the type system being extremely different, the internal semantics of supposedly related things like classes and Tasks/Promises are just different enough such that trying to pattern match C# knowledge I think would lead to *more* confusion down the road. 
If TypeB is not a class this won't work. You need to either use guards or explicitly assert the object (using `as TypeB`)
I'm open to any questions on this! A big potential concern I have is that I come from a Haskell background, and I'm hoping this blog post makes sense to programmers coming from a Javascript/Typescript background
Learn typescript first. Typescript is what Javascript is supposed to be, and should actually replace it as the standard. &lt;/opinion&gt; Seriously though, Typescript fits on top of Javascript like a glove and I've all but forgotten about JS' existence after coding in TS for more than a year. I can't start a new project unless I choose Typescript. Even small scripts for node.js to do things for which I would have normally would have chosen bash or python in times past.
If you declare the type as `TableColumn&lt;T,V&gt;`, do you need to specify either `T` or `V` when using? Won’t they both be inferred from the signature of the `value` property lambda?
They are in fact required since I am not defining the argument types when creating the objects.
I think you want to use returnType&lt;T&gt; instead of V in this case. Give ít a try. It might solve your problem :) 
Can you give an example? 
 export type TableColumn&lt;T extends (...args: any[]) =&gt; any&gt; = { label?: string; numeric?: boolean; value: T; format?: (value: ReturnType&lt;T&gt;) =&gt; any; } const column: TableColumn&lt;(s: string) =&gt; string[]&gt; = { value: item =&gt; item.split(','), format: value =&gt; value.join('____') }
Thanks. I'm looking to define multiple columns like this: \`\`\` const columns: ColumnDefinition&lt;Pair&gt;\[\] = \[ { label: 'Pair', value: pair =&gt; (all ? pair.code : pair.second.code) }, { label: 'Price', numeric: true, value: pair =&gt; 0 }, { label: 'Change', numeric: true, value: pair =&gt; 0 }, \]; \`\`\`
Closures are usually nicer than classes. There's no `this` to worry about and you don't have to worry about binding if you want to use a "method" in a callback. As a bonus you get much better inference, less verbose code.
&gt; Power to flexibility. : Power to shoot yourself in the foot. Not only are decorators not an advanced stage at the standard bodies, the implementation in TS isn't even compatible with what the standard is proposing (they were based on an old version). They unfortunately were not advertised as such, so now there's an immense amount of code that will need migrating. If its in your app: no biggy. There will be codemods around to clean things up. If its in dependencies and libraries that you may not be in a position to update though...not fun.
Yes you’re correct; I’ll fix that
Nice article! I have seen posts on parsers in Javascript, but only rarely. It is a topic that deserves more visibility. The intersection of combinators and Typescript is especially useful. I think that date parsing is a great choice for illustration.
``` interface Formatter&lt;T extends (arg: any) =&gt; any&gt; { getValue: T; format: (value: ReturnType&lt;T&gt;) =&gt; string; } const fmt = { getValue: (x: boolean) =&gt; x ? 0 : 1, format: (val: number) =&gt; '' + val, }; function useFormatter&lt;T, U extends (arg: T) =&gt; any&gt;(formatter: Formatter&lt;U&gt;, item: T): string { return formatter.format(formatter.getValue(item)); } useFormatter(fmt, true); ``` [TSPlayground version](http://www.typescriptlang.org/play/#src=interface%20Formatter%3CT%20extends%20(arg%3A%20any)%20%3D%3E%20any%3E%20%7B%0D%0A%20%20%20%20getValue%3A%20T%3B%0D%0A%20%20%20%20format%3A%20(value%3A%20ReturnType%3CT%3E)%20%3D%3E%20string%3B%0D%0A%7D%0D%0A%0D%0Aconst%20fmt%20%3D%20%7B%0D%0A%20%20%20%20getValue%3A%20(x%3A%20boolean)%20%3D%3E%20x%20%3F%200%20%3A%201%2C%0D%0A%20%20%20%20format%3A%20(val%3A%20number)%20%3D%3E%20''%20%2B%20val%2C%0D%0A%7D%3B%0D%0A%0D%0Afunction%20useFormatter%3CT%2C%20U%20extends%20(arg%3A%20T)%20%3D%3E%20any%3E(formatter%3A%20Formatter%3CU%3E%2C%20item%3A%20T)%3A%20string%20%7B%0D%0A%20%20%20%20return%20formatter.format(formatter.getValue(item))%3B%0D%0A%7D%0D%0A%0D%0AuseFormatter(fmt%2C%20true)%3B)
Was the title of this supposed to be "Help Wanted Items in TypeScript's GitHub"?
I found this stackoverflow thread. &amp;#x200B; [https://stackoverflow.com/a/41307319](https://stackoverflow.com/a/41307319) &amp;#x200B; What happens if you change the webpack.config.js to this instead: &amp;#x200B; module.exports = { // ... resolve: { extensions: [".js", ".json", ".ts"], alias: { prismjs$: path.resolve(__dirname, "src", "vendor", "prism"), }, }, }; All I did was remove .js from the prismjs alias. I'm just spitballing here. Let me know if it works or gives you any hints.
Learn JavaScript first
The next thing I would do is try to add the type declaration file manually to your project. Play around with location by putting it in your project source and in the prismjs directory you created. You can find it in node\_modules/@types/prismjs or you can download it on github here: [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/prismjs/index.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/prismjs/index.d.ts) Again let me know if you get any different results but I'm at a loss otherwise.
since your architecture is build upon es5 and the dirty global scope style, I doubt there's no simple way to convert it. Bite the bullet and do it the clean way. your benefits: * you will be able to find out your dependencies. even those that are not intended * bundler like webpack &amp; co. will even be able to do more optimization (tree shaking etc) * nobody will hate you anymore 
Have you checked out codemods via recast or js-codeshift? They might do the trick.
Actually, ignore my other comment. I think your "one fell swoop" approach can be made a tad smarter without a ton of effort. Programmatically add an export to all top-level functions, classes, and variables. Also make a list of each export along with the file it's declared in. Also add `export {}` to every file that doesn't otherwise have an export statement (if there are any) to force it to be a module. Run the typescript compiler and grep for all "this is not declared" errors. Those should be the imports you need. Based on your previous list, you know which file to import them from and can generate a specific import statement. Does that sound like it would work?
so that you can spot js footguns and understand other people's code that (ab)use low level js concepts: \- hoisting of var \- lambda vs function (bound vs unbound) \- prototype \- mixins (... there should be a couple more but those should be the most frequently encountered, in that order) There is no need to be gradually transitioning though given your background. My advice is to look up articles about problems in es5 that ts fixed then make sure to use tslint when you write ts.
Hmm... I don't think function hoisting is due to Javascript being compiled; AFAIK, Javascript even started out with interpreters, who only later started adding JIT. (Which doesn't really have much to do with TypeScript, though, except that JIT might make the term "compile time" more confusing...) Otherwise, excellent article - I think there is a need for introductions like these.
Compared to Facebook's DataLoader, BatchLoader is composable and further reduces round trips by handling duplicate keys.
Do `npm run tests`, or `jake runtests`. This may cause things to fail if you have added new test files, or the baselines change. You then need to do: `jake baseline-accept`, which will copy the changed baselines from your local directory to the main testing one. **Before committing: thoroughly go over any baseline changes to check that they are expected.**
For me the order of things is somehow confusing. You start asking if it's interpreted or compiled but you never really say that most engines use a Just-In-Time-Compiler. Instead you jump on a example and start talking about hoisting. Would confuse the fuck out of me if I didn't knew better.
This is, from a PL perspective, a lot of misinformation. The examples of what "compiled" and "interpreted" mean are very unhelpful - other people have already pointed out the fact that interpreted languages can very easily use hoisting. The later distinction of "runtime" and "compile time" is particularly wrong, given that the JIT interpreters used in most JS engines do their compilation at runtime! On top of that, the example given of being able to assign values of different types to the same variable is definitely not "the very definition of a “dynamically typed language”". In fact, it's almost completely orthogonal. Rust (statically typed) allows reassignment of multiple types to the same variable, Elixir (dynamically typed) doesn't allow *any* reassignment of variables, and TypeScript allows union types to contain as many types as they like, meaning that the code as written, if decorated with the correct types, is completely valid TypeScript code. There are other cases of odd terminology that aren't particularly helpful either - for example, it isn't the "parser" that allows you to rename things, it's the binder that takes the AST and then applies the semantic symbols that determine what variable refers to what other variables. Moreover, I strongly disagree with describing this as "the missing introduction". That implies that this is all stuff that hasn't been explained, but needs to be. A good amount of the content is simply inaccurate, some of it is unnecessary (explaining how interpreted and compiled languages work, for example), and the stuff that is relevant isn't really introductory, but more an attempt to explain the behind the scenes of things that aren't hugely important to understand (at least as a beginner TypeScript user).
Yes, it's that Airbnb. They maintain a very popular [style guide for JavaScript](https://github.com/airbnb/javascript) and publish packages such as [eslint-config-airbnb](https://github.com/airbnb/javascript) based on that guide.
Oh cool! Thanks for that insight :) 
I managed to figure out the solution and I feel pretty silly now... By setting up the `paths` in `tsconfig.json` the way I did, I made it so that TS should look at `src/vendor/prism.js` when looking for typings for the `prismjs` module, which obviously makes no sense since `prism.js` isn't even a declaration file. I removed the `paths` property entirely from my configuration so TS would resolve it by itself from the `@types` directory within `node_modules`, and everything works perfectly now.
I think you can get rid of `MappedBatchLoader` by adding a `map` method to `BatchLoader` public map&lt;B&gt;(f: (value: Value) =&gt; B): BatchLoader&lt;Key, B&gt; { return new BatchLoader( async (keys) =&gt; { const values = await this.batchFn(keys); return values.map(f); }, this.keyToUniqueId, this.batchDelay ); } 
i like your ambition
Thanks! That's much simpler. Why didn't I think of that? I guess this is why you open source it. :)
Now I think about it, there is a problem with this approach that there are now two batch queues that may cause two separate calls to batchFn which is suboptimal.
I guess you know that ES6 exports and imports eliminate a lot of (not all) circular reference issues since they are immutable bindings. That is, unlike `const {foo, bar} = require('./other');` which retrieves `foo` and `bar` at the time of import, ES6 imports retrieve every time `foo` and `bar` are used.
My preference would be to create normalized and denormalized types for the two (probably an interface for the base type, that the UI type would extend), and then create [selectors](https://github.com/reduxjs/reselect) that produce the denormalized types. Something like: ``` interface Group { id: GroupId individuals: IndividualId\[\] } interface Individual { id: IndividualId, } interface IndividualUI extends Individual { groups: Group\[\] } type State = { groups: { \[id: GroupId\]: Group } individuals: { \[id: IndividualId\]: Individual } } const getGroupUI = createSelector( state =&gt; state.groups, state =&gt; state.individuals, (\_, props) =&gt; props.groupId (groups, individuals, id) =&gt; ({ ...groups\[id\], individuals: groups\[id\].individuals.map(individualId =&gt; individuals\[individualId\]) }) ) ```
This approach results in a denormalised (and nested) state shape. You will need to sync \`individualIds\` and \`groupIds\` in both entities. Since it's many-to-many-relationship, it makes sense to link the entities together using a \`GroupIndividual\` (or even better: \`Member\`) type.
 js-codeshift (and tscodeshift) looks interesting. I'll check it out.
&gt;My preference would be to create normalized and denormalized types for the two (probably an interface for the base type, that the UI type would extend) \[..\] Agreed. Came to the same conclusion in [this reply](https://www.reddit.com/r/reactjs/comments/9lhoyo/designing_typescript_flow_types_for_react_state/e7895kr/). FYI, since there's a many-to-many relationship, it makes sense to introduce a `GroupIndividual` (or `Member`) type to keep the state normalised. Also not really sure yet about the difference between extension and intersection... more things to learn. :-)
No....just no. This code is a needlessly complicated mess.
It's enough for the groups to have a list of memberIds. If you run into performance issues with getting groups for each individual, then you could do the same on the individual side with groupIds.
That could work, but I believe it’s far from ideal for a couple of reasons. IMHO, state should be normalized. There should be a single source of truth for each fact. 
I like this approach and use it myself. I've even extended it to automatically extract the action types from the reducer and provide proper types for connect, checking that mapDispatchToProps uses matching types from the reducer. [Here is the code](https://gist.github.com/wuzzeb/e8502a6efb4160fa1c20ddf4080968c2). I am working on a blog post describing the approach.
This is a great writeup. Thanks for posting this. &amp;#x200B;
I have once written an article following similar lines, maybe it is of your interest &amp;#x200B; [https://github.com/wkrueger/wkrueger.github.io/blob/master/md/redux1/20180715-downhill.md](https://github.com/wkrueger/wkrueger.github.io/blob/master/md/redux1/20180715-downhill.md)
There’s also the [typesafe-actions](https://github.com/piotrwitek/typesafe-actions) package that handles this for you. 
You should post the actual code, because what you posted is not valid code. Expanded by the necessary "class" wrapper and adding the properties it works just fine: class ClassName { private name: string; private id: string; constructor(name: string, id: string) { this.name = name; this.id = id; } } var myClass: ClassName = new ClassName('p', '123');
ts is still new to me and the compiler wasn't very helpful. I never imported the class I created but I was able to get some data out of the class somehow, it would always allow me to pull the first argument passed to the constructor but it would under the data property only as well as the classes meta data. &amp;#x200B; In other oop languages, if the class is within scope its typically usable and doesn't have to be imported, only instantiated. A console.log printed out the class meta data so I thought it was already there. &amp;#x200B; the compiler should spit out a different error, something along the lines of your class was never imported rather than the class takes 0 arguments, but x are present. 
&gt; In other oop languages, if the class is within scope its typically usable and doesn't have to be imported, only instantiated. That is no different in TypeScript. If the class is within scope it's usable. Just in the languages you mentioned it's often that types are implicitly in the scope (e.g. same namespace in C#). &gt; the compiler should spit out a different error, something along the lines of your class was never imported rather than the class takes 0 arguments, but x are present. It would spit out an error that the type is not known. But apparently a type was found here. Either you imported something wrong, or it was a "global" scoped type. And the type that was found did not accept any constructor arguments.