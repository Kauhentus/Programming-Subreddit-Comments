a screenshot of the white page...? i'm just using the example that came preloaded. https://imgur.com/a/v9fzT okay what the heck..i was gonna paste you the JS error (something about .map on undefined I think), but when i refreshed the page it started working, so i dunno what the heck.
&gt; Does not support conditional types at all. Does not support number literal types at all. To be fair, its really hard to encode those in C#. Is there any other mainstream language other than Haskell where you could encode conditional types? Even in Haskell, it would look really weird and you'd have to use pretty advanced stuff (functional dependencies and what not). I'm genuinely curious.
We'd also have to represent them in C++, Ruby, Objective-C, Java, etc. Obviously, TypeScript has an awesome type system but how we'd translate all of it into Objective-C is not one of our current goals.
Now those are a lot of buzzwords in just one small title
Not really important or urgent, just curious...?
I don't think it's strictly about the mutability. If you change it to `b = 'A' as Union` it also works. I think that the problem is just that `'A'` is *not* of type `'A'`, it's of type `string`. So you have to cast it in order to assign it to that type, either implicitly by assigning it to a readonly/immutable field, or explicitly by assigning it to a typed field or casting it.
I mean, thats an inference behavior from a recent version (something around 2.6). const A = ‘A’ //infers A let B = ‘B’ //infers string
Thank you.
With a cast you essentially turn off type safety for that code.
Your index.d.ts does not define ErrorRequestHandler so it is assumed to be `any` by the TypeScript tooling. It also sounds like you might have some type checks turned off, perhaps in d.ts files.
Sodium is focused on the Functional aspect, that is, it really has all the advantages of fp (like compositionality). It's similar, but it guarantees several things, such as a deterministic merge primitive.
Funny, but I get an empty page and the browser runs like crazy. Also: "added 144 packages". Heavy.
No, you're telling the compiler that you know better than it does. Which is true in this case since it's inferring the type incorrectly in certain situations.
Yes, it has happened to me a few times. It is still an alpha release at the moment it crashes very easily :( about the number of dependencies I don't know if we will be able to do anything. We do need all the dependencies.
sorry! my bad. When I was editing the example for Stackoverflow I removed the `ErrorRequestHandler`import for some reason. I am actually importing it at the same point I am importing `RequestHandler`. It also doesn't matter if I try to restrict `middleware` to just `RequestHandler[]`
Given the other error talks about about two different definitions, I suspect you have two different definitions.
Use webpack with a typescript loader, rather than tsc directly.
So, I think the miscommunication here is you're referring specifically to explicitly casting as an override. I agree, that definitely breaks type safety. I don't think that necessarily applies here, though. This, for instance, works fine: type Union = 'A' | 'B'; interface Src0 { a: 'A'; } interface Dst0 { a: Union; } const src0: Src0 = { a: 'A' }; const dst0: Dst0 = src0; The original issue was just that the compiler automatically infers `'A'` as type `string` instead of `'A'` which was causing an error in OP's class. That's why I mentioned explicitly *or* implicitly casting it. I agree with you that implicit casting is the better practice.
Also, a class must provide an implementation of an interface. This is not the same thing as extending a class. If 'Bar' was a class, then if 'Foo' *extended* it, I would expect you to not have to re-annotate 'b'. When you implement an interface, you still have to construct your class members as normal. All implementing the interface probably tells the compiler is that your class members satisfy the interface contract, however the compiler will NOT assume just because you are to implement an interface that it will inherit those members (if you want inheritance, make a base class and extend it instead).
Thanks, I'll have to read up on Webpack! Hmm so it sounds like I've approached this incorrectly I thought that I was supposed to use the compiler to produce .js and .map files and those lived in the build folder :-/ . At this point I think it might be a bit risky to introduce yet another thing into this project so I think I'll just give up on loading libraries and save it for the next project otherwise this'll never get finished! thanks for the pointer! Next time Webpack :-D
I will try this - looks cool. Thank you!
awesome! let me know if you have any issues (or feel free to file issues there)
Cool, thanks! I'll check it out, might be useful.
You're not alone. In regards to Redux and TS, I feel the boilerplate is a bit much as well, which is why I opt for [MobX](https://mobx.js.org/) in personal projects instead, which works excellently with TS. However, I'll add that the extra boilerplate is probably not as bothersome (and even beneficial) when working on a large project in a team. That's where both TS and Redux shine best, after all. But yeah, definitely overkill for just one person hacking together an app slightly bigger than a todo list.
There is no getting away from the fact that properly typed redux is super verbose. You can make some helpful generic types that reduce it a little, but it will still feel boilerplatey. There are some nice benefits though - the biggest for me being properly typed actions within different switch branches in a reducer. I outlined my approach to typing with redux here: https://stackoverflow.com/questions/47640189/how-to-maintain-action-creator-types-in-connected-components-with-redux-react-a/47643972#47643972
You can actually reduce the Redux boilerplate a *lot* in TS 2.8 but it requires a bit of magic. This is how our action creators look like for example: // actions.ts export const enum ActionTypes { LoadTodoList = "todos/LoadList", SetTodoList = "todos/SetList", AddTodo = "todos/Add", CompleteTodo = "todos/Complete" } export const addTodo = (description: string) =&gt; action({ type: ActionTypes.AddTodo, payload: { description } }); export const completeTodo = (id: number) =&gt; action({ type: ActionTypes.CompleteTodo, payload: { id } }); import * as actions from "./actions"; export type Action = CreateActionType&lt;typeof actions&gt;; The exported `Action` type is completely type-safe and its `type` property can be used in a switch statement in the reducer. As for async actions we use redux-observable with some overwritten type definitions (which is luckily pretty easy to do). With these async actions are a breeze: // epic.ts export const loadTodosAsync: TodoEpic = actions$ .ofType(ActionTypes.LoadTodoList) .switchMap(({ payload }) =&gt; TodoApi.list(payload.userId)) .map(setTodoList); With [this patch](https://github.com/redux-observable/redux-observable/pull/459) applied to the redux-observable typings this is also completely type-safe: `ofType` narrows the action type and you can only return actions in the end. /u/alsiola this might also be interesting for you, if you're willing to move to TS 2.8 you can cut almost all of the redux boilerplate. Most of the things I mentioned can be found in [this gist](https://gist.github.com/Gustorn/50071757fa8e88195d215acd877117ae), except I changed the `createAction` wrapper to an `action` wrapper to allow generic action creators. The definition for the latter is: export const action = &lt;T extends string, A extends { readonly type: T }&gt;( a: A ) =&gt; a;
I've yet to find a situation where Redux is actually a better choice that Mobx with state trees.
Yeah IDK I think I actually hate this idea
Check out redux-guards: https://www.npmjs.com/package/redux-guards That should help alleviate the boilerplate a lot :) And also my boilerplate which already includes it: http://ts-react-boilerplate.js.org/
Naw, it's a pretty common complaint! Some cool new features in Typescript 2.8 look promising.
This is useful for migrating to a new stricter tslint config.
Redux is confusing you. Get rid of it for the moment: focus on learning Typescript and React. 
Redux is verbose and boilerplatey without Typescript, too. I can't help you make it simple, unfortunately, except to suggest that you might only really need Redux on *big* (bigger than you probably think apps). There are alternatives from Formidable, and of course MobX and MobX State Tree. 
Did you switch to MobX State Tree from Redux? What pros/cons have you found? MST seems to me like what Redux should have been, but it gets almost no mentions. 
Why can't we just declare all the actions as big type union, instead of rewriting the action name 3 or more times in different variations (UPPER_CASE, camelCase and camelCaseCreator)? Sometimes it feels like these "evangelists" are constantly fighting to achieve new levels of verbosity. ``` export type ActionTypes = | { type: 'ACTION_ONE' name: string } | { type: 'ACTION_TWO' count: number } ```
Consider not using TypeScript or not using Redux.
I've never migrated between the two, I've just used both. I'd say MST comes across to someone new as a little more abstract, and it's not obvious to them how they plug it into their React/TypeScript boilerplate project. The reality is that it's a general tool for storing state and having views - whether they're React or simply functions that have to be run - respond when that state tree changes in relevant ways.
That's the part I need to learn. Using TS and React I can manage, but not when adding librairies.
I think it's a very common problem. Redux is quite hard to use in a type safe way. I have my own take in how to tackle this with https://github.com/paulkoerbitz/typeful-redux . It gives you a fully typesafe and low boilerplate way of using redux. However it is also pretty opinionated and doesn't work with the various side effect managing tools (thinks, sagas, observables, ...), This is currently in the works.
You don't need to be overwhelmed by boilerplate. Action creators: https://github.com/ihsw/sotah-client/blob/master/src/actions/index.ts And the corresponding reducer: https://github.com/ihsw/sotah-client/blob/master/src/reducers/index.ts
You don't need to be overwhelmed by boilerplate. Action creators: https://github.com/ihsw/sotah-client/blob/master/src/actions/index.ts And the corresponding reducer: https://github.com/ihsw/sotah-client/blob/master/src/reducers/index.ts
Here is an example of this. https://github.com/ihsw/sotah-client/blob/master/src/actions/index.ts The action-creator boilerplate really is *much* lower. I know exactly how you feel regarding UPPER_CASE, camelCase, and camelCaseCreator. You still get UPPER_CASE and camelCase but that's only because reducers need consts for switch-cases.
Not bad, but I still prefer MobX ¯\\\_(ツ)\_/¯
I'll have to give a hard look at it then.
I've been enjoying redoodle from palantir for redux everything, definitely cuts down on boilerplate. https://github.com/palantir/redoodle
 class None&lt;T&gt; { isSome(): this is Some&lt;T&gt; { return false; } } Should this be `this is None&lt;T&gt;`? 
Thats my current react learning playground (a mess), it violates tons of Dan Abramovs dogmas but the typings are working efficiently without much boilerplate. https://github.com/wkrueger/muderrrno/blob/new/src/timesheet/actions.ts
I was liking it until OP got the descriptions of the strict flags dangerously wrong. Couldn't finish it after that.
This is great! I also cam across [StackBlitz](https://stackblitz.com/) which is also awesome for larger projects and the ability to import modules, but I like yours a lot for quick code snippets. Much better than the TS Playground. I'm also not sure that StackBlitz gives you all the compiler flags. One suggestion: might be nice to include the compiler settings in the URL? 
Thank god, the old one launching a separate tab every time was annoying
Thank for sharing. I already wanted the authors new book and didn't realize it was him till the end.
It happens to be third-party (both the .js and the .d.ts), but it's not installed through npm (and it's not an option). Furthermore, I'm also interested in the general case, not just this particular library. If npm can set it up so the definitions and scripts are separate, I want to know how npm does it so I can do it too in the future. It looks like your second option (using typeRoots &amp; the .js path for imports) is compiling and running correctly. However, I still have a couple of questions. - First, it looks like Typescript is not actually getting any types for `CoolThing` in the import statement. All its properties are typed as `any` and I can reference non-existent properties (which still gets compiled). So the definition file doesn't seem to be doing anything? - Second, you mentioned that the definitions file needs to be named the same as the .js file. What about e.g. .min.js files? Is there no way to get around that restriction? 
Seems fine. I'd point you can replace many of the strict options from tsconfig with just "strict: true". In some places you added unnecessary annotations which would have already been inferred (when a type needs an anotation, noImplicitAny will yell at you). Ex: ast.traverseByType('number', (node: TreeNode) =&gt; { `TreeNode` is not needed there.
But it doesn't harm either and imo improves readability of the code.
Yeah, it often depends on readability as perceived by the author. For example, I always define return types for my methods explicitly because I think it's more readable, though AFAIK that could be inferred.
What does **never** mean in ts?
The library is Axios, using the standard DT definitions file. But I'm more interested in getting this type of thing figured out regardless of the exact files. Can you explain a bit about *why* some libraries would behave differently than others in this setup?
never is the empty union type.
Just thought the amount of generated code here was comical: https://imgur.com/a/H67bx
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/HHeP1g7.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dx7x0ib) 
I've just added an select to control compiler target. If you open [async/await example](https://agentcooper.github.io/typescript-play/#example/async-await) and switch target to ES2017 you get identical output. I might later change default target from ES3 to something more modern.
I'm familiar with conditional types but not with the `infer` keyword. Do you have any reference on what it does? All I could find was [this](https://github.com/Microsoft/TypeScript/issues/21705) but it wasn't very enlightening. 
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html https://blogs.msdn.microsoft.com/typescript/2018/03/27/announcing-typescript-2-8/
So basically `infer` introduces a new name? type Foo&lt;T&gt; = T extends { a: infer U, b: infer U } ? U : never; Is like: type Foo&lt;T, U&gt; = T extends { a: U, b: U } ? U : never; Except it doesn't require the user to specify `U` (and thus isn't worthless).
Great way to explain that. Thank you.
I stopped at the top one. Why should we not use as? This is just mental. I think writer is confused... There no problem with as.
I wonder why we can't just use it in the type parameter without using conditionals, something like `type Foo&lt;T extends {a: infer U, b: infer U}&gt; = U`
&gt; type Foo&lt;T extends {a: infer U, b: infer U}&gt; type Foo&lt;T extends { a: any, b: any }&gt; = T["a"] | T["b"];
Have you tried [tslint-config-airbnb](https://www.npmjs.com/package/tslint-config-airbnb)?
Yes, but it doesn't seem to be the same thing. Eslint shows me everything in my vs code problems console, like trailing comma missing, but tslint doesn't. If I run webpack watch I see them as warnings, but it's not as seamless as clicking on an item in vs and being taken to the line.
Daft question maybe, but have you installed the tslint extension?
I'm using `infer` to create types which translate synchronous functions to returning promises without losing argument types or return type So `AsyncFn&lt;(a: number) =&gt; string&gt; // (arg0: number) =&gt; Promise&lt;string&gt;`
Do you have two files that pretty much lint the code in the same way? Mind sharing them? 
Have you tried using https://www.npmjs.com/package/tslint-eslint-rules ? I’ve been meaning to do this when I get some time and just use tslint only but with the eslint rules. 
GP’s answer is correct. I have a similar setup with eslint and tslint, both using Airbnb configs, and prettier formatting to match. As for why you aren’t seeing lint issues in your error output window, check your tslint.json and tsconfig.json and make sure they are valid JSON, and make sure tsconfig.json includes your source files.
You can use eslint with typescript, https://github.com/eslint/typescript-eslint-parser Couple of rules doesn't works, but this way you can use same configuration for both ts and js files
A bit out of topic, but enforcing the use of prettier (format on save) also solves your issues, and you don't even need to bother about linters anymore.
I was playing around with this tonight and it looks like I got something working. const classes = { Add: 'pr-add' as 'pr-add', Edit: 'pr-edit' as 'pr-edit', Delete: 'pr-delete' as 'pr-delete', }; type actual = typeof classes[keyof typeof classes] const x: actual = 'abc'; So the key here is to explicitly cast your values as their own string literals, rather than as general strings. This constrains them and allows them to be used in type checks.
As an aside typing out class names explicitly isn't so bad when you're working with a discriminated union of strings (eg `type Classes = 'pr-add' | 'pr-delete'`)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [npm link and @types and duplicate deps mess](https://www.reddit.com/r/webdev/comments/8cqior/npm_link_and_types_and_duplicate_deps_mess/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Are you on windows? I ask because the symbolic links, or lack there of, can be troublesome in windows. I would recommend using Yalc. It has its own ‘link’ functionality, in addition to some other simple functions that I think might get you around that issue. It worked for me when npm and yarn link both failed with similar issues. It works by publishing your packages to a local repo, and you consume from there. https://github.com/whitecolor/yalc
You might be interested in this issue that's been open since 2015: https://github.com/npm/npm/issues/10343 The gist is that `npm i` breaks the symbolic links up by running `npm link &lt;package&gt;`.
[yarn link](https://yarnpkg.com/lang/en/docs/cli/link/) might work better, instead. I've had better luck with yarn's version. I don't use it often, though, and I am on windows at the moment.
I was able to solve the duplicate types by setting: ``` types: ["node"] // cuz we need node ``` in the `tsconfig.sjon`, however the duplicate instance of `sharedDep` still happens.
I am on a Mac at the moment
You could change the argument to params: IQueryParam | any = {}
I love it. Can I make a feature request? One thing I really wish the playground did was allow me to see the .d.ts produced for a given code example.
Thanks! This does the trick, apologies for being dense what exactly does 'any = {}' do here.
You can add a cast to assert that the string array you reduce over only contains keys of `IQueryParams`. export function convertParamsToQueryString(params: IQueryParams = {}) { const keys = Object.keys(params) as (keyof IQueryParams)[]; return keys.reduce((accumulator, key) =&gt; `${accumulator}${key}=${params[key]}&amp;`, ""); }
That is essentially turning the typechecker off. That is equivalent to writing: `function convertParamsToQueryString(params: any = {}) { ... `
The union of `any` with anything is `any`, so `IQueryParam` is redundant in this case. 
Except for the intelliSense
TypeScript interfaces define shapes that are structural subtypes. This means the following is perfectly valid: `let x: { foo?: number, bar?: string } = { baz: "hi" };` This also means that the type returned by `Object.keys` will *always* be `string[]`, even if the value passed in is a defined interface. The error indicates (rightly) that if someone passes `{ foo: "val" }` into your function, the key "foo" is not guaranteed to exist in an `IQueryParams` object. This may even be a bug in your code (if you expect the function to return query parameters that adhere to a specific subset of values). Perhaps you should instead use a whitelist of known potential keys, and iterate through them to build the result string. Also, unrelated, but you should probably use `encodeURIComponent`.
Thanks!
One technique I used that really helped my integration test coverage was using typeORM's ability to switch backend database drivers depending on production. My tests run on a travis\-CI environment which does not include a postgres database. To get around this limitation, I have a switch that causes my application to load a SQLite driver when the NODE\_ENV variable is set to 'TEST'. Since SQLite runs in\-memory, I can not only run end\-to\-end tests from my controller all the way to my data store, I can reset the database in between tests if I like. You are using knex.js which has a similar driver available for SQLite3. With a bit of config\-level switching, you could set it up. Then your integration tests could really give you complete coverage.
Have you seen nestJS? It might be cool to work that into what you have 
Sounds like OP went for more of a domain driven design approach. So for example having your controllers for a particular feature in your app in a directory for that feature, and other controllers in another feature directory.
Thanks! Makes sense. Could you please create a GitHub issue, so that I don't forget? https://github.com/agentcooper/typescript-play/issues/new
I just started using and it looks great
I'd like to hear more. My (admittedly limited) impression of DDD is that it focuses more on a layered architecture like an onion, where inner items aren't aware of outer items. For example the models don't know about the providers, and the providers don't know about the controllers. This means everything flows towards domain logic and their domain model representations. I've also encountered domain models living side by side as different microservices, which looks a little similar to the file structure shown here, but on a larger conceptual scale. Each service has it's own onion shape and the controllers can call out to each other as needed. In any case, file layout isn't the most important aspect of this project. I was just curious to see if this was something that was common elsewhere
I'd prefer to be explicit, so I'd pick the last option.
How would this affect imports after the project is built into an npm module? For example, if `MyProject` has that `baseUrl` and `paths` setup could I import as `import { Thing } from 'MyProject/modules'`?
Unfortunately I never had the opportunity to publish an npm module. My guess is, since it's specific to typescript, custom non relative dependencies will be converted to relative one.
Try this: const result = clients.reduce((total, customer) =&gt; { const totalOfUser = customer.items.reduce((totalUser, { price, disc }) =&gt; (disc === 0 ? 0 : price - disc), 0); return total + totalOfUser; }, 0); 
Not really a typescript question but here's my attempt in "functional style". const totalSpentOnDiscountedItems = clients.map( // For each client client =&gt; // For items of each client client.items // For each discounted item .filter(item =&gt; item.disc &amp;&amp; item.disc &gt; 0) // Calculate amount paid (price minus discount) .map(item =&gt; item.price - item.disc) ) // Flatten total values for each client into one array .reduce((a, b) =&gt; a.concat(b), []) // Sum the values in the array .reduce((a, b) =&gt; a + b, 0); console.log(totalSpentOnDiscountedItems); Answer: 380
Git (i.e. GitHub, GitLab, Bitbucket, etc). Also referred to as version control. If you aren’t using version control for software projects, I would highly recommend adopting it.
That's what I was referring to in the second paragraph. So you have commits that are just "moving to desktop"? And leave em there? Cause, unless I learned incorrectly, amending pushed commits, is bad practice.
Some SCM's have a shelving or stashing feature that lets you put a bunch of changes away for later without creating a commit. This would work perfect for moving between devices. Which SCM (version control) are you using?
No. I would only use git, and not involve any of the cloud services you mentioned. I typically follow a “feature” branching strategy where all branches start from and eventually get merged back into master. All collaborators do the same. Master is always the latest, stable, working version of the project. I will also typically set up all branches to require a a build from a CI (Continuous integration) server first to make sure the build (tests, linting, transpiling ) are all good before the branch gets merged. Here’s a good article (IMO) on the subject https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow
I use a working branch in Git for my projects until I'm "ready". Many of my commits are "kid needs a diaper" or "there is something horribly wrong with me" or "refactoring for fun and profit again! Yah for churn!". When I think I have something, I use a squash commit for the actual PR or to check in. That way, all of my horrendous mistakes, swearing, and day-to-day is removed from the public eye and my humiliation is just stuck inside my head.
That makes sense. Thanks for the article. Depending on how often one switches between devices, wouldn't the resulting push still contain a history of "switching to desktop" commits on master? Do you just ignore those?
Ahh, this is what I've been looking for. That command is new to me, is it pretty much as described here? https://stackoverflow.com/questions/5189560/squash-my-last-x-commits-together-using-git
So to be clear, in the feature branch workflow, one repo is designated the origin (like when you make one in GitHub). All collaborators would be working off the one repo. So given that, if you are always pushing your latest work (whatever feature branch you’re working on) to that repo , anyone with access can just pull those branches down to their own machine and do whatever they want with it. In this setup you typically protect the master branch so only certain people can merge into it, typically via the PR process. So long story short, there should never need to be a “switching to desktop” commit message. 
[removed]
Awesome! I've been using typeorm a lot with my latest project and it's a huge improvement over my last favorite ORM, objection.js. Obviously that's biased since my new project is written in typescript, but I'm having less sporadic bugs with typeorm. My only critique has been with the docs an expressing so many ways to do something -- query builder, active record pattern, entity manager, repository pattern, etc. It seems like the repository pattern is the defacto way of doing things (my co-worker who used to be in C# land says that's probably where it was influenced from). Given that, the guides could use a refactor to always show a repository example and then stuff the alternatives into an Advanced section.
Why would the source of your program change when you work on a different device?
This project keeps looking more and more like Doctrine, and I'm 100% okay with that. Pretty much every feature Doctrine (or its extensions) has, and I want, is getting implemented. Great work.
I'm just here to eat.
On desktop: - finish task Y - start task X commit "Finished task Y, started working on task X." On laptop: - pull latest commit - finish task X - begin task Z commit "finished task X, began task Z" Back on desktop: - pull latest commit ... you see what I mean? You should just use meaningful commit messages that describe the changes you've made. It shouldn't matter _why_ you're committing. 
I would say the bad practice is not pushing code off local storage frequently. Nobody ever lost company money by making frequent commits, but I have seen too many fools not commit their code for a week, and lose their drive and say "oooops, sorry". Those people tend not to get promoted. I also agree Git commits in a working branch is the way to go, squashing on merge if it matters to you.
Worst case is ”start of x” wouldnt even compile but you need to go and have your work available. I think its pretty bad practise pushing broken code. Working in a feature bransch and squashing the broken commit later should be ok though I suppose.
OK so what I think is going on here is, rather than *executing* those methods, the code is testing for their *existence*, as a means of determining what type `temp` is, since it could be `any`. Personally this seems quite hackish to me.
you're right. is there no better way to make that determination? it feels like a sloppy way of going about it. 
Hah I originally wrote (and edited out) that this seems kind of hackish to me too; they might have considered using `Number()` instead. But you can't necessarily use *any* method that works with a number type, only one that *only* works with a number, otherwise you still can't be sure.
There are better ways to check the type, but since the code in this function is only *using* those two methods, that is a reason to only test for their existence. It would be even better to test it those members were actually callable functions with typeof === 'function'. Yes, you could use any function you know exists on number and not string, for example, but that does not help you if some other object is passed in that happens to have the same methods. My main objection to your example, though, is that it does nothing to demonstrate Typescript's strengths, which include making sure your types match. Instead, the code has a bunch of type testing going on, making it harder to find the actual business logic.
I'm always looking for a great book to sink my teeth into.
I'm not a huge fan of ORMs that obfuscate too much of SQL away from code. I'm a heavy knex.js user but it has no type support. How does this compare?
Great stuff, OP. I actually bought your first ed. book with office funds and read through the whole thing. Don't know what the process is for perhaps getting a copy of this ed., but I'm a fan and would love to have one. :)
Great stuff, OP. I actually bought your first ed. book with office funds and read through the whole thing. Don't know what the process is for perhaps getting a copy of this ed., but I'm a fan and would love to have one. :)
`typeof temp === 'number'`, will also narrow down the type and makes the cast not necessary. The code above is either old, or just bad.
I disagree with the idea of doing unit conversion *and* formatting in the same function, but if one must, I'd write the whole thing like this. function convertFtoC(temp: string | number): string { let value: number; if (typeof temp === 'string') temp = parseFloat(temp); return ((temp - 32) / 1.8).toFixed(1); } Yes, I know the behavior is different. I took out some of the insanity. Temperature is zero when a non-value is passed? What sense could that possibly make?
Disagree. This is a bug in tslint. The types are available. Passing a number instead of undefined is not equivalent.
That should not be an autofixable error.
Overload order deserves a linter rule.
Huh, thanks. I'd not seen this pattern with 'get' before
blushed :(
Looks like a great book, wish it had a VueJS chapter. 
Checkout GitKraken and read about GitFlow. GitKraken has a great UI for using GitFlow methodology. It's a good, simple way to start using git, I know alot of people struggle with the command line and git in the beginning.
Hey, mfraser27, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
This makes a lot more sense and is a lot more similar to how it would be done in other languages 
I would personally recommend you to prefer the method to the accessor if there no memoisation of the value whatsoever. I think that a bit of processing can be acceptable as part of a property only in a context of lazy initialisation of an underlying backing field; a method is much better in conveying the meaning of "possibly expensive operation".
I take note for the next edition
If you have cheap `O(1)` processing I think that's fine to put in a property as well. For instance providing a `Celsius` and `Fahrenheit` property, with one being derived on the fly. 
Interesting take. Am I to understand that, in practice, even though you would find using a getter acceptable in certain situations, your personnal preference is to always use a method?
I tend to do more methods instead because: it's clearer for the reader of the code that a function is called and it's easier to debug. Especially the memory mapper and GC have more troubles with getters and setters.
&gt; Should I instead be compiling my TypeScript to JavaScript and then running the JS via Node? That's quite literally the only way to do it.
Ok, here is a synthesis of the various ideas so far. // Decision process for choosing whether // to use an accessor or a method if (you don't give a damn about debugging AND function is O(1) AND function is pure* ) { use accessor } else { use method } * A function is pure when, given the same input, it will always return the same output and when it produces no side effects. Would you agree that this is a good heuristic? Thinking about this, you would pretty much never use accessors. Unless you don't give a damn about debugging. Then the only use case for a getter that I can now think about is for something like this: class WeatherData { constructor(private fahrenheit_: number) { } get celsius(): number { return convertFToC(this.fahrenheit_); } } In this case, the convertFToC function is O(1), has no side effects and given F Fahrenheit will always return the same C Celsius value. Therefore it makes sense to use a getter.
I think that placing any kind of computation that is not O(1) inside of a property can be misleading,and may easily lead to hard to detect performance issues for no good reasons. 
I compile it down to JS for releases. For development I use nodemon and ts-node. See here: https://github.com/locnguyen/typescript-node-starter
ts-node also removes the need for worrying about dist and src dirs, how to keep them in sync and when to import from which one. I use ts-node in a fairly large production project by having a file `start.js` like require("ts-node/register/transpile-only"); require("./server") // ts file So I can directly run it via pm2 / `node start.js` and never have to worry about the typescript compiler, source maps, cleaning up the build dir etc at the cost of slightly longer startup times (which don't matter for long running servers). The advantages might not be large for a single project but they become more and more visible when you have multiple projects that reference each other that would otherwise each need their own `tsc` watcher process and directory structure. It also makes it easier for js people to use, since they don't have to worry understand ts compilation and can just see `.ts` files as `.js` files with extra features.
“Best child” doesn’t sound like a reasonable property of something, so initially the method signature looks more appropriate. But then I assume the result would not change once the object is constructed, no matter how many times you call getBestChild(), so you could calculate the best child in the constructor and assign it to a bestChild property. 
It's a nice setup thanks for sharing 
Can't it just be a single function that you call, rather than an object you instantiate?
Nest.js!
Yeah I did. I generally don't make classes in TypeScript, I haven't found them to be that useful. I'd just pass the tree in to a function each time if it needed to be persisted. There are exceptions though.
This. Solves your build issues and it gives you a wonderful framework
Another way to view this is that getBestChild should be findBestChild as it's not really an accessory since your doing an action, not retrieving a stored value.
Does it even have to be in a class? A standalone function on []Node would be more flexible.
You've got a few things muddled here, I'm going to make some assumptions so feel free to add more details and I'll clarify. First, you're wondering where the `selectNode()` function should be, in the `Algo` or `Node` class? The answer is neither. You have a `Node` structure but not a `Tree` one. This is comp sci 101 stuff but a node represents a single element in a data structure, you could even re-use your `Node` class for a tree, linked list, stack etc. You've indicated you want a tree, so you need one of these: class Tree&lt;T&gt; { readonly nodes: Node[] constructor(nodes: Node&lt;T&gt;){ this.nodes = nodes } find(data: T){} expandNode(node){} // possibly, I'm not sure what you want this fn to do } Now you also have some sort of function called `simulate()`. Well that's neither the `Node` nor the `Tree`s business. That's up to your `T`. So you'll want your `Algo` class to make sure it only works with classes that be simulated. If there are multipled implementations that can be simulated then using generics is the right choice for `Algo` you just need to change it to look like this `class Algo&lt;T implements Simulatable&gt;` where this exists interface Simulatable { simulate(){} } or if you think about it and realize there's really only one kind of simulations then drop the generic on `Algo` and simplify it to look something like this: class Algo { private tree_: Tree&lt;MySimulationThing&gt; run(data: MySimulationThing): Node&lt;MySimulationThing&gt; { // ... do stuff here } } That map to what you're trying to do?
I don’t get what you mean?? Typescript doesn’t touch runtimes. Typescript is a developer tool for writing JavaScript. You have to transpile (I notice people say compile a lot, are these interchangeable?) it to js and run the js with the node runtime. 
Six of one, half dozen of the other. Personally when I'm in the TS/JS sphere I see it as a more functional than OO so I tend to write my code more functionally. Or in this case functional-like, so treating functions are first-class objects so I write code to make it look like them, i.e. an accessor. That said I'm not expert-level in this space so I'm not aware of low-level run-time differences.
How does this solve build issues? 
I compile with webpack+babel because Typescript can only specify the target version (es201x) but 'babel-env' can generate code optimized for my exact node version
Not sure. You probably have the source maps in memory but I think you can disable that. Other than that, I'm not sure if there's anything unnecessary in memory. You should probably ask the author of ts-node about that.
Yep, same here. It's not like an algorithm is a "thing" that needs to hold and encapsulate state or anything - it's a process that receives some input and produces an output. It's not really clear what problem a class would solve here.
Nest CLI gives you a build setup out of the box
&gt; The class could hold a version of your algorithm, then you could have different classes that hold other versions and have an interface that all these classes implement You can do the same with a function, though. The functions will have a type similar to `&lt;T&gt;(data: T, tree: Node&lt;T&gt;) =&gt; Node&lt;T&gt;` and you'll be able to pass those in as arguments without needing to create a class.
Why not just make different functions with the same function signatures, except for the names?
Inversion of Control works for both classes and functions. That's what I meant when I said "You can do the same with a function". type Algorithm&lt;T&gt; = (data: T, tree: Node&lt;T&gt;) =&gt; Node&lt;T&gt; let doY = &lt;T&gt;(algo: Algorithm&lt;T&gt;, data: T, tree: Node&lt;T&gt;): something =&gt; { ... } Don't have `doY` directly call `doX` if you need a swappable implementation. Pass the function in just like you would w/ the different class objects.
The aim of this post is mainly to gather comments concerning the usage of fast-check. - Is the REDAME enough to start playing with the tool? - Are there enough examples? - Can you easily use it? Or is it too difficult to use? - if so, please put a comment in this thread so that I can work on it Thanks in advance for the feedbacks 
Webpack is a way to create a bundle or a package to distribute. If you're creating something simple with just Typescript code that you wrote, you probably don't need it. If you want to create a something that you'll distribute with minified sources for your own code, with external libraries, or package other resources with your app (images, css, sass, etc) then you might want to consider Webpack. If what you're doing is simple, then you don't need it. If you're creating something moderately complex then give it a look.
Some practical examples: * Avoiding too many network connections: If you're writing your code for the browser, you don't want to serve each of your compiled files separately over the network. You would use webpack to bundle all of your compiled files into a single file. * Polyfill: You might compile from Typescript to ES6 and have webpack polyfill that code for use on older browsers. * Code-splitting: You might want to "code-split" or separately bundle a web page's code or a certain feature of your application's code together to dynamically load only when needed. webpack would help you create those bundles. This applies to both the browser and server-side rendering. * Minimizing overall size: webpack "walks" through your code from an entry point and packages together only its dependencies. It would avoid bundling code from large packages that most likely have files you don't use in your application. This is obviously beneficial in the browser, but also useful if you're using something like AWS Lambda where start times matter. If you're writing code for the browser or any other environment where size and/or start times are matter, you'll most likely need webpack. Some tools, e.g. [create-react-app-typescript](https://github.com/wmonk/create-react-app-typescript), automatically handle this for you.
Browserify and Rollup are also alternatives, maybe easier. The main advantage is being able to use npm libraries.
I've also found that Webpack has good support for including source maps. I've used Webpack with the TypeScript loader and other loaders used to compile bundled JavaScript where in the browser dev tools you get to debug the actual separate files TypeScript. It works brilliantly.
This is a really great response
Just to clarify on a couple of points: &gt; Avoiding too many network connections: If you're writing your code for the browser, you don't want to serve each of your compiled files separately over the network. You would use webpack to bundle all of your compiled files into a single file. TypeScript can do this by itself using the 'outFile' option. &gt; Polyfill: You might compile from Typescript to ES6 and have webpack polyfill that code for use on older browsers. With TypeScript, you can use the option 'target' and set to 'es5' for TS to transpile it down to run it on older browsers (like IE10). For TypeScript-Webpack combos, take a look at [awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader). 
&gt;With TypeScript, you can use the option 'target' and set to 'es5' for TS to transpile it down to run it on older browsers (like IE10). That's true for syntax features like classes, arrow functions and async/await, but it won't polyfill API and stdlib additions like Map, Symbol or Array#find. Webpack&amp;Babel will allow you to add those in more easily than ts by itself 
If you are using some packages from npm for example and want to use them in the browser, webpack "emulate" node API (process/fs/path etc...) Bundlers like parcel, rollup, browserify are doing the same way
&gt; With TypeScript, you can use the option 'target' and set to 'es5' for TS to transpile it down to run it on older browsers (like IE10). One disadvantage of doing this: Typescript doesn't know what to do with Object.assign() if transpiling to ES5. Webpack can handle Object.assign() without any problems whatsoever. 
I'm a C# dev and I found this book useful Pro TypeScript: Application-Scale JavaScript Development https://www.amazon.co.uk/dp/1484232488/ref=cm_sw_r_cp_apa_aCn3AbXHX24T6
Thanks!
easy: https://github.com/redplant3d/best_typescript_nodejs_docker_container
Learning the language is the way part. Which framework are you considering for the front end?
I don't know if I'll use this, but I like the idea. Kudos.
I don’t have any feedback for you yet, just wanted to say great work, and thanks for sharing! Also very glad to see you’ve cut a major version. I’ll feel a bit more confident getting a project set up using fast-check now.
Hi, the source maps are generated. You could simply add the --inspect:0.0.0.0:9229 param to the nodemon config. The port is already mapped in the dev compose file. - "${EXAMPLE_NESTJS_SERVICE_DEBUG_PORT:-9229}:9229"
The repository is more like a discussable concept to find a great solution. Any feedback is welcome.
Maybe it works great with this docker template for ts in docker: https://github.com/redplant3d/best_typescript_nodejs_docker_container
Is anyone using TypeORM on large production sites? How are you finding it?
If your tsc takes 40 seconds to compile them so be it. AFAIK there’s no way to query the service.
Lol
You should be able to query the service by creating a [language service plugin](https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin) that provides a socket to query information. I was thinking about writing something like that for a different purpose, but I think it should work for this.
Thanks a lot for your answer. I will definitely be glad to have your opinion on fast-check when you will use it.
I know VSCode has something like this in their repo, it’s a pretty big project but the hook doesn’t add any significant time. Might be worth looking at how they do it. 
The other libraries I'm aware of are: http://leebyron.com/testcheck-js/ https://github.com/jsverify/jsverify I originally tried jsverify and could get it to work, but I found working with it or extending it a bit clunky. Testcheck is easier to work with and had typescript bindings. It's compiled clojurescript though so extending it is not so encouraging.
What is the advantage of using this over core-js directly?
In my package.json file, I have this: "precommit": "./scripts/git-pre-commit-hooks.sh", And then in my scripts folder I have the git-pre-commit-hooks.sh script which does a tslint check on all files I'm about to commit. I know it's slightly different to what you've asked, but it always catches any ts errors before I commit them. #!/bin/bash # exit immediately if any command fails set -e # set indent function indent() { sed '/^\s*$/d; s/^/ /'; } # navigate to top level cd "$(git rev-parse --show-toplevel)" # lint check echo "TypeScript lint check..." TSLINT="$(git rev-parse --show-toplevel)/node_modules/tslint/bin/tslint -s tslint/formatters --config tslint.json" FILES="" for file in $(git diff --cached --name-only | grep -E '\.ts$') do FILES="$FILES $file " done # lint check any typescript files if [ "$FILES" = "" ]; then echo "No files to check" | indent echo else eval $(echo $TSLINT $FILES) | indent if [ "$PIPESTATUS" = "0" ]; then PASS=true else PASS=false fi # exit if lint checks fail if [ "$PASS" = "false" ]; then echo "Lint tests failed" | indent echo exit 1 else echo "Lint tests passed" | indent echo fi fi # all done echo "Done 👍" 
Basically none. However if you use `core-js` directly, you must either: - Import everything, which may be bad for bundle size... - Or import required polyfills for respective libs one-by-one, [which is what I did](https://github.com/ryanelian/ts-polyfill/blob/master/src/es2015-core.ts)... I did the tiresome effort of sweeping through all the TypeScript lib APIs, then group the import by each lib, so you don't have to. Simply import the lib polyfill for the corresponding TypeScript lib and you're good to go. 
 * `let` - use this when you are declaring a variable to be used in a scope and possibly re-assigned later. * `const` - use this when you know you never need to re-assign to the variable. assign when you declare and never again. * `var` - don't use this. it's old and pointless. That's it!
You should never `use` var. it's like `let` but has scoping issues. `let` is just like a regular variable in any other language. You can use it to declare a variable whos value you can change. `const` is like `let` but the value of the variable can't be changed You should always use `const` as your default choice and *only* use `let` for variables who value needs to be changed
Rule of thumb: start with `const`, if you need to change the value later, change to `let`, and forget about `var`.
I kind of still prefer: if (x) { var y = 1 } else if (z) { var y = 2 } over let y if (x) { y = 1 } else if (z) { y = 2 } 
How about let y = x ? 1 : 2 Less scary!
If you try hard enough, you can almost _never_ use `let` as well!
When I look at the first snippet, to me the intent seems to be for that `y` variable to only exist inside of the branch of that `if`, even if the behavior is different at runtime. The second makes it clear that the variable will be used in both branches.
 let y = x &amp;&amp; 1 || z &amp;&amp; 2 || undefined; :)
I get what you mean but once I understood the scoping of `var` it kind of made sense to me to write it that way. It makes for more approachable code to write it with `let` for sure. I just kind of think it looks better and does make sense to _me_. 
const y = x ? 1 : 2;
I'd prefer const y = x ? 1 : 2; If you wanted to depend on multiple variables I'd do const setter = (x, z) =&gt; { if (x) return 1; else (z) return 2; return -1; } const y = setter(x, z); That solution has the benefit of separating your logic and makes your state immutable. You could argue it's a bit more verbose but it's the same number of lines of code.
Haha I think we’re back to having hard to read code at this point, but oh so concise
&gt; You should never use `var`. it's like `let` but has scoping issues. `var` doesn't have scoping issues, it's function scoped. That's the difference. If your if checks were functions instead, they would both have similar behavior. If you're under a `'use strict'`, I believe they'd be identical.
Really need the [do expression](https://github.com/tc39/proposal-do-expressions)! 
You should `const` by default, because if you need to change it you can do so, whereas if you don't you'll likely forget to and therefore harm readability.
The issue I was referring to is the fact that `var` is function scoped instead of block scoped. I call it an issue because it's unusual and unexpected behavior. If you using strict mode `var` is still function scoped and not block scoped.
or: let y = x ? 1 : (z ? 2 : undefined)
&gt; unusual and unexpected behavior. Unusual and unexpected for *whom*? That's how it works, that's how it's always worked. Telling people it's broken isn't helping them understand why it's different from the other options.
&gt; Unusual and unexpected for whom? People coming from languages that have block scope (so pretty much every language). &gt; Telling people it's broken isn't helping them understand why it's different from the other options. I showed how it's different. The why isn't really important but if you really curious it's because Brendan Eich didn't have time to implement block scope in the 10 days he was given to develop JS. 
FYI var, let, const are from JavaScript. They are not exclusive to TypeScript. TypeScript has them because TypeScript is a super set of JavaScript.
Hm. That's interesting -- so in: ``` let x = do { let tmp = f(); tmp * tmp + 1 };``` x is equal to the result of the last statement?
&gt; People coming from languages that have block scope (so pretty much every language). Except [the other reason why was how other languages handle scope](https://twitter.com/BrendanEich/status/349768501583548416?s=09). &gt; I showed how it's different. You just said it had issues, you didn't even really explain that it *was* different.
i guess I should clarify that it's not necessarily about enforcing the props at runtime but making sure that when Router is of a certain type that props associated with one type will cause a transpilation error when used with a Router of a different type. Trying to tightly enforce that if type A is associated with prop foo and type B is associated with prop bar that trying to use bar with type A and vice versa will raise an error.
You can use a pattern like type Param = ( { group: "red" } &amp; RedGroup &amp; Not&lt;BlueGroup&gt; ) | ( { group: "blue" } &amp; BlueGroup &amp; Not&lt;RedGroup&gt; ) Both or-groups need to list all params but you if you don't want some params in one group, set them to be undefined. Let me know if that doesn't make sense, I'm on mobile so typing code is particularly annoying.
yep
Live that immutable life! Let that garbage collector figure it out. 
I use `let` so infrequently these days that it feels weird seeing it in my code when it is. Not that I'm preaching about immutability though. I use plenty of objects with public members or getters and setters. I just prefer my variables in each block to not change.
The ternary operator is something I learned to love. You can pry it from my cold, dead hands. :3
Python also uses function scoping. And I guarantee the reason isn’t “Guido wanted to be done with Python in 10 days”. The fact of the matter is some people just prefer their scoping rules one way, and others prefer them another. 
Yes I have seen Babel preset env. Unfortunately, doing that costs you in terms of build performance (TS -&gt; JS -&gt; Acorn AST -&gt; JS again), which is what I'm trying to avoid. I'm also trying to maintain code safety by limiting what the programmers in my team CAN actually use. (`tsconfig.json` lib setting) Good discussion in the TS repo about this (shim vs polyfill): https://github.com/Microsoft/TypeScript/issues/3101
Exactly, this question would be better posted in r/javascript.
Fairly low effort blog post, could at least talk about why you would choose one over the other. This also doesn't discus TS at all, here is how to do the faster loop in TS: const x = [1, 2, 3]; for (let y of x) { alert(y) } If you need your JS to be so performant that this change is meaningful, then by all means do it! However readability of `forEach` vs the `for` loop and the ability to use closures makes this a wash in my book. The 95% slower is okay for 95% of the arrays I'm working with. 
&gt; This also doesn't discus TS The code you cite is just ES6 and not necessarily TS
_Extremely_ low effort and clickbait-y to boot. Tried this on multiple computers, browsers and devices and can't replicate 95%. Worst was 10%.
That compiles to indexed for loop?
Yep, only difference is that it reassigns the variable. var x = [1, 2, 3]; for (var _i = 0, x_1 = x; _i &lt; x_1.length; _i++) { var y = x_1[_i]; alert(y); } 
This is so sweet. I've been living a lie
And UglifyJS will fix the reassignment for you.
This is a post from over a year ago. Did you even read the comments? And how they explain that this is a very bad genaral advice? It's tested wrong, it matters almost never and it can be even faster in certain other testcases? 
Just a little extra: placering the .length in a variable, so you dont do multiple counts? Or is that only on c++ thats the case? 
nit: `let y` could be `const y`, even though it initially feels like `y` is being reassigned (at least it did to me). I agree with your points. To maybe expand on the OP blog post: I have lately been preferring `for` loops whenever applicable vs `forEach` or even `map` (as in, `for` loop that pushes to a newly constructed array). Besides the perf gain, I occasionally found myself falling for a trap with `forEach`/`map`. Consider the example from OP's post: arr.forEach(function (item) { someFn(item); }); Given just this code, it seems natural to instead write it as arr.forEach(someFn); as it's much more concise and doesn't produce an unnecessary function ref. However, seemingly innocuous changes like this can have unintended consequences. For example, what would the following piece of code output? ["1", "2", "3"].map(parseInt); Did you guess `[1, NaN, NaN]`? Cause that certainly wasn't my first instinct. The issue here is that `parseInt` accepts a `radix` 2nd arg to specify base, and `map` provides the callback with a 2nd arg of the index in the input array. I still agree that there isn't 1 best style, and it's very dependent on your code. Array scale and context around the loop are very important in informing which you should use. Doing two maps and a filter? Just do it in a single for loop instead. Mapping data to render? `return fooObjects.map(this.renderFooObject)` certainly seems more readable than creating an array of renderable nodes, pushing to that, and returning the result.
Well said. Performance isn’t an issue until it is. Always prefer readability when possible. I.e. don’t prematurely optimize. 
Just to get you started, a domain is an area of knowledge. It is quite similar or the same as the concept in math. A house might be an entity that has properties, for example, in the United States a house should have an address - well an address can be encoded into another entity. In a model-view-controller application such as asp.net mvc - the controller calls the business layer which does everything that doesn't need to know about the asp.net framework. The business layer generally calls the data layer which directly accesses the database. SQL stored procs could be considered a lower layer on that. Look up the term 'business logic' - that is the code that usually is inside the business layer. The controller passes data off to the view - that is the presentation layer. Now if you are using angular, there is another set of layers that can correspond to those above. Not all of these layers are in all applications and they likely have a few different names. The more to confuse you with.
Thanks for this very thorough answer. Honestly, this has helped a lot.
No problem, domain modeling is a completely different beast than typical mvc/mvvm/mvp/whatever style. I struggled a lot with the words and concepts in the beginning. gamenight is the first project where I've decided to go all in and just do it. I'd recommend checking out "Domain Driven Design: Tackling complexity in the heart of software" by Eric Evans if you'd like a much more in depth exploration. 
Just wait 'til everyone says that middleware shuffling around mysterious stateful untyped objects is a great idea to build large scale web service projects.
I find for much more readable than forEach. It's easy to find loops when for is the first thing in a line, unlike foreach that is somewhere in the middle.
So lets say `order` is the actual order. JSON.stringyify will stringify it: let stringifiedOrder = JSON.stringify(order); &gt;&gt;&gt; "{"price":31.5,"trackerId":"sadfadsfasd"}" We can parse it to get back the original order let parsedOrder = JSON.parse(stringifiedOrder); Now that its not a string anymore, we can add the new key value pair as normal. parsedOrder.products = [1,2,3,4,5]; &gt;&gt;&gt; (5) [1, 2, 3, 4, 5] Then we can stringify it again: JSON.stringify(parsedOrder); &gt;&gt;&gt; "{"price":31.5,"trackerId":"sadfadsfasd","products":[1,2,3,4,5]}"
You Night wanna try "object rest spread": { productlist: [1,2,3,4,5], ...order }
Look at [path mapping](http://www.typescriptlang.org/docs/handbook/module-resolution.html) where you can define symbols directly to directories you specify. Their example isn't the greatest because it points at node modules which clearly isn't necessary or helpful. But with my projects I usually end up creating ones like paths: { "@common": ["./src/app/common/**/*"], "@foo":["./src/app/features/foo/**/*"] } Then my imports look like import { FooComponent } from "@foo/foo.component"; import { SomethingCommon } from "@common/something-common"; Combine that with a vscode plugin that will find imports for me and it makes the import statements uniform and easy to create. 
Sure but he's using vue which most likely implies a bundler. It's possible he isn't using webpack but if you are using webpack it just works and has never been a problem for me.
Yup using webpack
Thanks
Thanks this definately looks like it can help clean up my code.
You probably meant ***DEFINITELY*** -not *definately* --------------------------------------- ^^^Beep *^^boop. ^^^I ^^^am ^^a* ^^bot ^^whose ^^^mission ^^is ^^to ^^^correct ^^your ^^^spelling. ^^This ^^^action ^^was ^^^performed ^^automatically. ^^Contact ^^^me ^^^if ^^I ^^^made ^^^A ^^mistake ^^or ^^^just ^^downvote ^^^^^^please ^^^^^don't
Hey, Defiantly\_Not\_A\_Bot, just a quick heads-up: **definately** is actually spelled **definitely**. You can remember it by **-ite- not –ate-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Stack overflow incoming
these dumb bots are replying to each other
How does tooling do with that approach? Do things like intellisense, find references, go to definition, etc., Generally work well?
Bad idea. It won't work without bundlers (not an issue for OP). It won't work if you modularise your code into npm modules. It won't work for nodejs apps. I'd rather not use this approach at all instead of refactoring all the paths later when project grows.
&gt; a vscode plugin that will find imports for me Link? I've been doing this for ages but vscode always complains that it can't find the file. 
VSCode handles it very well, I can't speak for other IDEs
yes definately!
Hey, prodaim, just a quick heads-up: **definately** is actually spelled **definitely**. You can remember it by **-ite- not –ate-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
You probably meant ***DEFINITELY*** -not *definately* --------------------------------------- ^^^Beep *^^boop. ^^^I ^^^am ^^a* ^^bot ^^whose ^^^mission ^^is ^^to ^^^correct ^^your ^^^spelling. ^^This ^^^action ^^was ^^^performed ^^automatically. ^^Contact ^^^me ^^^if ^^I ^^^made ^^^A ^^mistake ^^or ^^^just ^^downvote ^^^^^^please ^^^^^don't
Actually now not even in c++ it's the case because your compiler is gonna optimize that itself before execution, so it is not really useful anymore except if you are working in a very low level code (think about assembly) and you need these types of optimization because the compilare is not gonna do it for you
I already pre ordered the book some time ago. Just waiting for it to come out :)
Or [pattern matching](https://github.com/tc39/proposal-pattern-matching).
[No](https://stackoverflow.com/questions/36110070/does-typescript-have-operator-overloading?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa). It isn't supported at all by the underlying spec.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://stackoverflow.com/questions/36110070/does-typescript-have-operator-overloading?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa) - Previous text "No" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I hope this is a joke... 😕 
When you come back to this code in a year your future self will hate you.
I don't understand why people hate ternary if so much, for me it's simpler
factorial(0)=1, not 0
You're right
I don't mind the ternaries, I like em better than bulky ifs for constants or for short epressions. But for me the double lambda expression took me a lot longer to read than if it was written as a more traditional typescript function definition.
&gt; For me it’s simpler That’s fine and all, but if you’re working on a team, everyone will hate you for writing code like this. Legible code is the best code. 
Yes but don't indent them
Three problems: * You're defining the function type at the point of declaration so it LOOKS like the type declaration is the instantiation. * You're using nested ternaries. * You're declaring a function reference with "let" instead of "const". Unless the variable "factorial" will be reassigned away from that function, at some point, use const or use a named function. so: const factorial = (x: number):number =&gt; [0, 1].includes(Math.max(0, x)) ? Math.max(0, x) : x * factorial(x-1); 
the problem is that it's kind of unreadable. Sure it works for a factorial because everyone knows what a `factorial`function is supposed to return, but in a business setting you're going to have all sorts of different business rules intertwined (is that a word?) and using a ternary operator becomes a mess, like, really fast let factorial = number =&gt; { if (x &lt;= 1) return 1; return x * factorial(x - 1); } That's shorter and imo more readable
Nested ternaries are really hard to read because... * Everyone uses different whitespace to distinguish the blocks * If you need to add more complicated logic in the branches, it gets _more_ confusing to read * You haven't saved any lines of code anyway; it's just a more dense way of saying the same thing with `if-else` * Regardless of how you do it, nested ternaries are probably increasing the indent of the code. This also makes it harder to read and scan. But mostly, using them when no one else does means you are being a jerk to everyone else who has to read your code. It being simple for _you_ is completely irrelevant. Case in point, I recently had to split up nested ternaries that were over 76 lines long with something like 4 distinct branches. I finally had to institute a ban on nested ternaries in our code because people couldn't figure out when too much was too much. Being clever with Javascript syntax is almost always a bad thing. Ternaries are more clever than they have any right to be.
Love your last sentence. And also yeah when you start nesting ternaries you know something is wrong
I can see why people would dislike it but I find it easy enough to easy 
No, ternaries exist so you can put compact conditional logic on a single line. Why else would they exist? This might be useful in a obfuscated code contest. In production code this might get you murdered. 
I'm completely ok with this style. Very functional. Nested ternary operators are a bit iffy, but I get why you would use them here - Typescript doesn't have pattern matching or case-expressions like other functional programming languages.
Use a regular conditional if you want separate lines like that. 
It looks very programming 101. Why a lot of new programmers think that fewer lines of code is "cool" ? R.E.A.D.A.B.I.L.I.T.Y. Our CPU run in 4 GHz and GPU are even more powerful thanks to their parallelization. If an algorithm has the same complexity as another one, I will always take the more readable. And if it's less performant I will take the more readable anyway and try to make it better.
In that case, please do not write code this way. Sure, it works and looks / feels cool, but it's not maintainable because it's hard to read. If I look at it a few months from now it'll cost me lots of thinking before I understand it, let alone feel confident enough to know where or what to change. The more comments, the better! Also this kind of if-statements will can be messed up pretty bad by auto-formatters.
But it's just one line!
This is very good question. I've been using ts for back end only for more than one and a half years now and it's jus brilliant. But I also question myself why almost ts jobs are front end only. Let's see the opinions.
We use TypeScript with React on the frontend and have a few services written in TypeScript with Node + Express. 
I think I’ve seen some TypeScript+Ember jobs 
There’s a saying you have to be twice as clever to debug clever code. Don’t be clever, it’s a pain for others to understand and debug. Code is only the how, it is not the why. Write comments to tell others why your doing what your doing. You think it is obvious, it is not.
The problem is not the nested ternary operators per se. It's that there is no convention on how to format them. Compare that code with nested if elses with the same formatting: let factorial: (x: number) =&gt; number = 15 (x) =&gt; 16 if (x &lt;= 0) { 17 return 0 18 } else if (x === 1) { 19 return 1 20 } else { return x * factorial(x - 1) }
I write typescript for react, react native and node every day :) any self respecting company should switch to ts.
&gt; There’s a saying you have to be twice as clever to debug clever code. Don’t be clever, it’s a pain for others to understand and debug. Again, I have a feeling that we aren't on the same page with what qualifies as "clever" code here, but I'll go ahead and assume that you're referring to the sort of syntactical tricks that obfuscate behavior and not literal clever code. If that's the case, then we're in agreement, even if I don't particularly like that definition of "clever". &gt; Code is only the how, it is not the why. Write comments to tell others why your doing what your doing. You think it is obvious, it is not. When it comes to average, everyday code, the "why" for anything you write should be immediately obvious to any capable developer. If it isn't obvious, and we aren't dealing with one of the few exceptional situations where things need to be explained further than is possible for the code itself to do so (implementation of a mathematical formula, for instance), then you most likely just haven't put enough thought into how you've approached solving the problem. It could be architectural, or it could be as simple as confusing nomenclature. Writing obvious, easy-to-follow code is crucial. Writing non-obvious code and covering it up by explaining things in comments that may or may not be kept up-to-date with future changes is the lazy way out.
I'd say 65% are non angular based on nothing other then old man intuition
Given all the indecipherable code I’ve had to slog through in my career. Written by people who thought their code was sooo obvious. Please write comments just in case you aren’t as great as you think you are. Or for the mere mortals like me who must have a reading comprehension problem. 
Yeah Vue’s TypeScript support definitely isn’t perfect yet. But I’m really liking the combo regardless. 
Yeah I’ve found myself trying out new things that I think might be possible but just aren’t documented yet. Like trying to configure vue router to be a class instead of configuring from new VueRouter({}). Probably not something that’s really necessary but I like working from classes if possible. Haven’t even started refactoring my Vuex store to TS but I assume I’ll have similar hopes for a more OOP solution that won’t work exactly as I expect it to. 
Likewise where I am, only Hapi instead of Express. Plenty of legacy vanilla JS as well.
Same. Only Koa instead of Express or Hapi.
I don't have a numerical answer to your question, but there certainly are quite a lot of projects and therefore jobs that meet this description. We use TypeScript on nearly all of our Node work, and some non-Angular client-side work, in addition to our Angular work. TypeScript had a substantial community before Angular existed, although I suspect that Angular (which has a very large user base at this point) has substantially increased total TypeScript usage. 
If you know Typescript, though, you're pretty much good for any Javascript job. 
Wow, that's probably a worse idea than invading Poland.
I use TS with Node for server side 
Adoption for backend is much slower than frontend imo. This has to do with the business decision many make that client/customer facing things are easier to sell. To quote some previous COOs of mine: "How do i sell the backend to the client?" Obviously from a programmers perspective, this is indicative of mangers not understanding tech debt, but that is very rampant in the industry. For another example, look at all the adoption of an angular frontend with a java ee backend.
Yeah, but then you have to use JavaScript, not TypeScript. There are fates worse than death...
Tech debt is when you have to change your entire back end platform because you thought it would be hip to use JavaScript on the server for an app that's anything more than a low traffic toy.
My comment wasn't suppose to be a debate about if javascript is good for the backend. It was more about how business handles backend projects. Which is the reason why backend adoption, whether good or bad, takes a back seat to the frontend.
I'm quite aware of what TypeScript is. What I'm getting at is that TypeScript is such an improvement over vanilla JavaScript that working with vanilla JS is a lot less productive.
Can even merge those two conditions: if(x &lt;= 0 || x === 1) return x;
To me, the opposite has been true. I see the *need* for a system *like* Typescript to provide for the safety of projects with multiple programmers working together as a team. But there are just so many things that are a simple short line of code in JS that are so annoying to implement in TS. It also *really* guides you in the direction of object oriented programming (instead of functional programming) - not that you can't do functional programming in TS, but that what the TS core team has chosen to prioritize more object oriented features compared to the vanilla Javascript and Node.js teams. So if you're coming from a background where you're trying to write as functionally as possible and believe that the fewer lines of code you write, the fewer places there are for bugs to hide, you can see why one might be tempted to avoid using a system like Typescript until it's absolutely necessary to do so. 
I'm not sure I agree that the TypeScript team has prioritized OOP over FP. The type system in TypeScript is, more than anything, designed with the goal of expressing types as they can exist in JavaScript. I doubt features liked mapped types or string literal types would make it into the language if it were completely decoupled from JavaScript - these are there purely to provide a logical bridge from JS to a static-typed system. The features that are heavily OO - classes and inheritance - are not TypeScript features, they're JavaScript features that TypeScript is able to express. I have entire TypeScript projects where there are no classes, and even where the usage of classes is completely banned by the linter. As far as the correlation of fewer characters to fewer bugs, I would probably agree with a caveat that type annotations are rarely the source of bugs, and they are never the root cause of software defects. As an absolute worst case, type annotations may mislead developers if they're *wrong*, but the extent to which they mislead developers should be juxtaposed with vanilla JS, where the developer is given *no* information about the shape of data they're working with.
At Indigo, we use TypeScript + React for all of our front end apps and Typescript + GraphQL for all of our APIs (except data science). Being able to generate types from the GraphQL schema and share them in both the front and back ends is a game changer.
Maybe I'm oversensitive to this. The thing is, I *like* typescript. But what I don't like is the *typescript community.* Javascript had really crappy beginnings but has evolved into a rich, full language that is powerful enough to handle sophisticated applications but straightforward enough to encourage beginners to give it a try and get into programming. But attitudes like: "There are fates worse than death..." to apply to a job that uses Javascript instead of Typescript really rubs me the wrong way. First, Typescript is *NOTHING* without Javascript. I think people forget that. It's not "better than Javascript". In fact, I'm not even sure it's *better than [other typing systems](https://flow.org/) for Javascript.* What it *does* do is give you a way to introduce static typing into Javascript, and in so doing, forces you to write code that other programmers can tie into more readily. It's a nice tool. But that's what it is, a tool. Maybe it's my knee jerk reaction to people saying that Javascript is a stupid language because the truthy/falsey rules aren't consistent, or it doesn't distinguish between floats and integers, or it doesn't have static typing, and you know what? Those are *fair criticisms.* But obviously there ARE other languages that do all those things - C#, Java, C++. Obviously, there's something you LIKE about Javascript, otherwise there wouldn't be a want to improve it with static typings. I know I'm changing the subject here - but my entire point is that it's ridiculous to ask: "Are there any jobs that use Typescript but not Angular?" I'm sure there are, but who the hell is going to be that picky? To me it's like snobs who say that Californian sparkling wine isn't "real Champagne," or like Edina from Absolutely Fabulous: "I won't have Javascript darling. Only LaCroix Typescript." 
Not to be pedantic but (proceeds to be pedantic), factorial(-1) is not -1 according to OP's implementation.
Whoops! Never mind me.
I think you're right about the formatting being the main problem here (also many people are simply less familiar with ternary expressions *and* their formatting, compared to `if` statements). For instance, I think this makes the original code fairly readable (a bit like `if`-`else`-`if`-`else` is typically formatted): let factorial: (x: number) =&gt; number = (x) =&gt; (x &lt;= 0) ? 0 : (x == 1) ? 1 : x * factorial(x - 1) &amp;nbsp; Unfortunately, [prettier](https://prettier.io/) currently just puts the expression in one long line: let factorial: (x: number) =&gt; number = x =&gt; x &lt;= 0 ? 0 : x == 1 ? 1 : x * factorial(x - 1); But there are some other nice suggestions in the comments here though: https://github.com/prettier/prettier/issues/737 eg this style from TypeScript's source code: let factorial: (x: number) =&gt; number = (x) =&gt; (x &lt;= 0) ? 0 : (x == 1) ? 1 : x * factorial(x - 1)
&gt; I'm not sure I agree that the TypeScript team has prioritized OOP over FP. According to Anders Hejlsberg's Wikipedia: https://en.wikipedia.org/wiki/Anders_Hejlsberg &gt; He was the original author of Turbo Pascal and the chief architect of Delphi. He currently works for Microsoft as the lead architect of C# and core developer on TypeScript. Delphi(Pascal) &amp; C#(Java) are both strongly OOP languages. So it's only natural that TypeScript(JS) prioritize OOP. Actually, TS doesn't seem to offer any extra FP features like it did for OOP. 
&gt; Actually, TS doesn't seem to offer any extra FP features like it did for OOP. What OOP features do you think TypeScript has that aren't just part of JavaScript itself? This is where I think there is some confusion. The first time many people saw ES6 style classes was with TypeScript, but TypeScript didn't come up with classes, it just implemented a future ES spec. JavaScript already supports FP to some extent - TypeScript just has a type system that maps onto that. I don't know what else TypeScript would add.
That's true. TS offers interfaces, abstract classes, declaring non-static fields outside the **constructor()**, etc; which aren't part of JS yet. But all of them are OOP stuff which were and still are very important eye-catching TS features. CoffeeScript also had classes as 1 of the reasons to use it over vanilla JS. The only FP-ish feature I can think about is those E6 fat arrow lambdas. :D 
TypeScript with React really is a boon for large React codebases.
Strict mode is a pretty huge improvement. Good job on that! Tho I'm surprised that such a change is released as a patch-release, but it seems you're simply not following SemVer.
Not my package, so I can't really comment on the specific reasons they're not following semver here, but I have seen that in a lot of other places. Lots of people don't seem to follow semver for type definition changes. It can be hard to know exactly what a breaking change is, and it's arguably counter productive - it means any time you want to tighten the types to be more accurate you need a major bump, which often discourages people from doing so (rightly or wrongly). Actually, I think there's an argument that as long as the types are accurate, changes like this _can't_ be breaking. Any code that's now rejected by these types (assuming the types are good and the real API hasn't changed) is code that wasn't correctly using the API, so had no guarantees anyway, and now at least people know about it.
Depends on how you format it. If you format it a bit different it suddenly becomes "*more*" readable: x &lt;= 0 ? 0 : x === 1 ? 1 : x * factorial(x - 1); Tho it's still a bitch and often harder than just simple procedural style. And it's a bitch to debug.
i don't think this intuition is worth anything
What is the nature of these "huge TypeScript improvements"? What kind of impact can one expect to see by upgrading?
It adds support for TS's strict mode, adds type definitions for a very long list of things that didn't have types at all before this release (e.g. *Capture methods, the 'preact/debug' package, svg animation properties and a lot more), and adds a lot of fixes to many existing types too, to better catch problems, give you better inferred types, and relax some overly tight constraints that could cause incorrect errors. There's links to each PR involved in the release notes if you want the full details.
Got anything better to add?
If the library devs aren't Typescript devs it's probably better to keep them separate. Despite versioning issues it's easier to release type updates this way.
Oh of course. I understand that not everyone is into TypeScript. The onus is then on the community to provide types. I'm just saying that as a TypeScript dev, I'm personally hoping to see more NPM package devs also use TypeScript.
It's fairly bad practice, you should really remove it. If you want to give an example with explicitly mentioning `ICanaryConfig`, then use a variable: const canaryConfig: ICanaryConfig = { probability: 50, canaryScriptUrl: '...' }; const canary = new Canary(canaryConfig); By overriding compiler type checks using `as ICanaryConfig` you decrease the type safety of your application. If you now add a new property to your `ICanaryConfig` that is required, the compiler will not give out an error anymore, even tho the required property is missing in your object literal (assuming `strict` / `strictNullChecks` enabled). Additionally, you will not get any notification about excessive properties. If you remove a property from `ICanaryConfig` you'd get an error by the TypeScript compiler informing you about the additional property, because object literals may only specify known properties. That way the user knows the property is not needed anymore and can remove the code. If you use the `as`-cast you don't get this kind of check. So let's construct an, perhaps arbitrary, example: You decide to rename a property in your config. Of course you follow SemVer, so you release a major-version update. The user now updates the package.. And cool, everything still compiles! But during runtime he gets errors.. accessing undefined, why? The user provided all properties... seemingly. He will not notice the error because he followed your poor quality example. **tl;dr: Don't use `as`-casts.**
The TS compiler can emit ES5 JS code, there is no need for anything else for this.
In your tsconfig set “lib”: [“es2018”] or you could do es2017 or esnext. All of that stuff is already supported by the ts compiler.
TS and Babel make syntactic changes, but they don't polyfill built-in methods like Array.prototype.includes and Object.assign on their own. If you want to polyfill missing built-in methods, then you'll need to bring in something like core-js, which is what babel-polyfill does for you. So to answer your question, set "lib" appropriately in your tsconfig, then pull in the polyfills that you want from core-js, and you should be good to go. You can import core-js's "shim" if you want a blanket set of polyfills. Another answer mentions the "lib" setting in tsconfig, but that just tells TypeScript which type definitions to use. It doesn't affect the compiled output or bring in polyfills. You'll still want to use it to something like "es7" so that it won't complain when you use Array.prototype.includes.
The point is that if you set target to "es5" in tsconfig.json, you are unable to use Object.assign or Array.prototype.includes, as well as other language features of ES6+ in your .ts files. 
Yes, the TS compiler can emit ES5 JS code by setting the target to "es5" but it will not transpile Object.assign or Array.prototype.includes, which are ES6 features. 
That's not really a language feature, just functions , you just need to use a polyfill for it. 
Thank you. This is the answer I was looking for. target: "es5" lib: ["es2018"] 
I prefer flow but typescript has better support at this time. 
Note that this only means that TypeScript thinks that `includes` is a method on array and doesn't complain about it - that doesn't mean it actually _is_ a method on an array when you're executing the code. That's only the case when e.g. the browser it's running in has implemented it. If it hasn't, you still need a polyfill like core-js. (This is similar to how you need both a library's typings and the library itself.)
So, how do I include Core-js in my transpilation step? 
Use the"lib" option in tsconfig to enable typechecking for those new features. Use a polyfill at runtime to add the necessary methods. Last I checked, core.js is still a good choice.
(looks like the link doesn't maintain flags, but just set "strictNullChecks" ant it will work as intended)
Thank you for pointing this out. 
Oh, so looks like there exist two decks, and this one is for TS 1.x. The TS 2.X deck mentions strict null checks. However, the TS 2.X has similar inaccuracies regarding uninitialized values.
Little busy today, anyone want to sum it up in exchange for a curt thanks from a stranger?
\`\` export * as File1 from './file1' export * as File2 from './file2' \`\`http://2ality.com/2014/09/es6\-modules\-final.html
Ok that's sweet, but I forgot sometimes the path is nested export * as First.Second from './file1' doesn't work =/
This is quite old, npm @types were not even a thing. My TL;DR: * Flow has \(or is expected to\) more consistent typing at a cost of a slower analyzer and less work on editor support/language service/etc; * Flow doesn't erase types if a function argument is "any" \(is is analysed at call site for each call\); * Flow is usually ahead on advanced typing things \(ex: controlling inference, variadic types\) but TS is always catching up; TS team is very cautious on adding features that will increase the complexity of the analysis. Flow is more focused on correctness. * Flow has nominal typing on classes; * \(From personal experiences\) Flow server keeps hanging up while TS server is usually very fast and stable. * If you're migrating existing codebases, flow was supposed to be better \(better tools\), but the server keeps hanging. * I've seen people complaining about weird bugs and/or lack of support for flow \(in a couple of talks\); * TS has better editor tooling; * TS is becoming sort of a community standard, a lot of new libs are already coming with TS typings; * Even if a bit behind in the type checking department, TS keeps progressing with strong community and maintenance
As one of the maintainers in a large monolith Rails app (OpenProject) that mostly worked on backend, but transitioned into an AngularJS frontend and ending up including Typescript 1.5 years ago, my recommendation is to just try it out. It is easy and straightforward to add to your existing project , however large it is. It allows a smooth transition to it, letting the app become more and more typed as you go on. It has improved my frontend development experience manifold and for the foreseeable future all of my projects will run on Typescript. Thanks to the earlier transition to TS, we have started migration to angular that finally fully embraces it and is just a breeze (for a large full stack app, that is.) We will likely complete the migration within a few months.
Providing runtime functionality, including polyfills, is one of TypeScript's stated non-goals. https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals
Right, but if I'm writing a node app, I'm not using an HTML file with which to append a &lt;script&gt; tag to. 
 import * as file1_Second from './file1'; export namespace First { export {file1_Second as Second}; } Does that work? Or can you tweak it to work?
Ah, I see. Then you can just add a `require` to your file loading the necessary polyfills, depending on the version of Node you're targeting.
I wasn't recommending Flow, I was suggesting using Typescript just for "adding types to javascript", not for transpiling, which is how Flow operates.
That should work. Thank you. 
 import * as file1_Second from './file1'; export const First = { Second: file1_Second }; You'll need to build the object you want to export, as above. The `export` statement may only appear at the top level of the module.
export statements are allowed within namespace. Also, your solution won't work if any of the things being exported are types. You can only export a type from a namespace. (Or from top level of a module)
Good point
(Object as any).assign(foo, bar) should let you tap into those prototype methods.
Could you elaborate upon your first 4 bulletpoints? As someone who loves TS but has never tried Flow I'm curious!
This would probably exist as a TypeScript transformation rather than a Babel plugin because it requires type information.
I have started to much prefer the HttpClient service inside of angular that returns an observable.
Is that still true after 2.7? https://github.com/Microsoft/TypeScript/issues/8476
The 2.X slide deck contained code that it claimed would inaccurately not throw an error in either TS or Flow. However, that code does indeed throw an error in TS as provided in the TS playground, which I imagine is 2.8. class Person { name: string; constructor() { // why no error? } } const olli: Person = new Person();
(that code throws an error in the TS playground, even though the slide deck says it doesn't and never will)
If this is targeting nodejs then https://nodejs.org/api/modules.html#modules_require_resolve_request_options will return the path.
I just published my library like linq to npmjs. Thanks for reading.
You might be able to work it out from the value of `__dirname`, assuming you know where your current source file is relative to the files you're importing.
Those packages are compiled into nodejs and don't exist on the filesystem.
I'm not sure what you mean by not existing on the file system. If you run npm list -g would this not show you where they are on your file system?
{ bar: 'abcdef' as 'abcdef' } will allow you to get typing on the values rather than just `string`.
I'm actually fine it being a `string` in this particular case, I am more concerned about associating keys and values. For example, right now I need to map an object of several hundred functions while preserving type-safety. I can write a mapped type for it and make the actual transformation logic work with `any` values, but I really want to avoid this.
[Let me know how close this is to your goal](https://www.typescriptlang.org/play/#src=type%20Test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20number%2C%0D%0A%20%20%20%20bar%3A%20string%2C%0D%0A%20%20%20%20baz%3A%20boolean%0D%0A%7D%3B%0D%0A%0D%0Aconst%20test%3A%20Test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20123%2C%0D%0A%20%20%20%20bar%3A%20%27abcdef%27%2C%0D%0A%20%20%20%20baz%3A%20true%0D%0A%7D%3B%0D%0A%0D%0Atype%20Wrap%3CT%3E%20%3D%20%7B%0D%0A%20%20%20%20data%3A%20T%0D%0A%7D%0D%0A%0D%0Atype%20Wrapped%3CT%3E%20%3D%20%7B%0D%0A%20%20%20%20%5BP%20in%20keyof%20T%5D%3A%20Wrap%3CT%5BP%5D%3E%3B%0D%0A%7D%0D%0A%0D%0Aconst%20mapTest%3A%20Wrapped%3CTest%3E%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20data%3A%20123%0D%0A%20%20%20%20%7D%2C%0D%0A%20%20%20%20bar%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20data%3A%20%27abcdef%27%0D%0A%20%20%20%20%7D%2C%0D%0A%20%20%20%20baz%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20data%3A%20false%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Afunction%20mapObject%3CT%3E\(obj%3A%20T\)%3A%20Wrapped%3CT%3E%20%7B%0D%0A%20%20%20%20const%20newObj%20%3D%20%7B%7D%20as%20Wrapped%3CT%3E%3B%0D%0A%20%20%20%20for%20\(let%20k%20in%20obj\)%20%7B%0D%0A%20%20%20%20%20%20%20%20if%20\(obj.hasOwnProperty\(k\)\)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20newObj%5Bk%5D%20%3D%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20data%3A%20obj%5Bk%5D%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20return%20newObj%3B%0D%0A%7D%0D%0A%0D%0Aconst%20finalTest%20%3D%20mapObject\(test\)%3B%0D%0Aconsole.log\(finalTest\)%3B).
Thanks, this goes in the right direction, but ultimately, I want to make this transformation an arbitrary function (instead of hard-coding wrapping with `{ data: ... }`) and avoid writing out the definition for `Wrapped&lt;T&gt;` manually. I guess `mapValues` function from `lodash` does what I need, but its typings seem to be incomplete (they do not preserve key-value association, which is the most important thing for me).
This looks closer, though I still need a custom mapping function here. I've updated my post, and for now it seems like the proper solutions would require HKTs. I'm not sure if it's possible to implement what I want without them.
I'm not sure if you looked at the last one I shared, but why wouldn't this work? It works more or less identically to how `_.mapValues` works, from what I can tell, and just requires you to add a type annotation to the mapping function type Wrap&lt;T, P&gt; = { [V in keyof P]: T } function mapObject&lt;T, D&gt;(obj: T, trans: &lt;V&gt;(o: V) =&gt; Wrap&lt;V,D&gt;): {[P in keyof T]: Wrap&lt;T[P], D&gt;} { const newObj = {} as { [P in keyof T]: Wrap&lt;T[P], D&gt; }; for (let k in obj) { if (obj.hasOwnProperty(k)) { newObj[k] = trans(obj[k]); } } return newObj; } Here's how it actually looks when used: // Usage Example function transform(o: any) { return { data: o } } const mappedTest = mapObject(test, transform); And `mappedTest` has all the right type annotations that match test.
If you had to ask then no.
Please stop with MongoDb when 99% of the time what you need is SQL
Do you?
Not that I don't believe you, but when you make claims like that, it's better to support it with some credible sources or data
Your welcome, although now I think I got some of the details wrong. You can't `export {A as B}` within a namespace. You can, however, `export const B = A; export type B = A;` which will achieve the same result. Or, if the thing you're re-exporting is itself a namespace (or a wildcard import) then you can `export import B = A;` For your specific example: import * as First_Second from './file1'; export namespace First { export import Second = First_Second; }
The only way to input code in medium is via a special keypress combination. Medium is pretty anti\-developer when it comes to blogging, and has been for years.
Thanks, but my goal is to have `Mapped` inferred from the transformation functions. I'm not sure this is possible without HKTs.
I accept suggestions
[ ] You understand REST. [x] You don't understand REST.
[x] I don't give a shit about REST.
If you're using typescript like in this tutorial, and want an SQL backend, I recommend [Typeorm](http://typeorm.io/).
So why do people post there? Clearly there are better alternatives?
Hey, is that `$ExpectType` from some lib or just something you came up with? I've been looking for something to add this sort of checking to my tests.
Rewriting the OP's question. Can `lodash#mapValues` be strictly typed/inferred with current language features? Last time I checked the typedefs for that still didn't do the work... https://lodash.com/docs/4.17.10#mapValues
You can mock HKT's using an interface that act's as a dictionary of the HKT's you want to use. Link [here](https://www.typescriptlang.org/play/#src=type%20Test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20number%2C%0D%0A%20%20%20%20bar%3A%20string%2C%0D%0A%20%20%20%20baz%3A%20boolean%0D%0A%7D%3B%0D%0A%0D%0Aconst%20test%3A%20Test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20123%2C%0D%0A%20%20%20%20bar%3A%20%27abcdef%27%2C%0D%0A%20%20%20%20baz%3A%20true%0D%0A%7D%3B%0D%0A%0D%0Atype%20Wrap%3CT%2C%20P%3E%20%3D%20%7B%0D%0A%20%20%20%20%5BV%20in%20keyof%20P%5D%3A%20T%0D%0A%7D%0D%0A%0D%0Afunction%20mapObject%3CT%2C%20D%3E(obj%3A%20T%2C%20trans%3A%20%3CV%3E(o%3A%20V)%20%3D%3E%20Wrap%3CV%2CD%3E)%3A%20%7B%5BP%20in%20keyof%20T%5D%3A%20Wrap%3CT%5BP%5D%2C%20D%3E%7D%20%7B%0D%0A%20%20%20%20const%20newObj%20%3D%20%7B%7D%20as%20%7B%20%5BP%20in%20keyof%20T%5D%3A%20Wrap%3CT%5BP%5D%2C%20D%3E%20%7D%3B%0D%0A%20%20%20%20for%20(let%20k%20in%20obj)%20%7B%0D%0A%20%20%20%20%20%20%20%20if%20(obj.hasOwnProperty(k))%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20newObj%5Bk%5D%20%3D%20trans(obj%5Bk%5D)%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20return%20newObj%3B%0D%0A%7D%0D%0A%0D%0Aconst%20finalTest%20%3D%20mapObject(test%2C%20%3CT%3E(o%3A%20T)%20%3D%3E%20%7B%20return%20%7B%20data%3A%20o%20%7D%20%7D)%3B%0D%0Aconsole.log(finalTest)%3B), adapted from HeinousTugboat's solution.
Why use strings with typescript? The language could be used so much more effectively.
This.
That.
User input comes in the form of strings, but objects can be passed as well.
That makes sense. I don't know if you've seen this issue, but some of the discussion might be useful for you: [Suggestion: Units of measure #364](https://github.com/Microsoft/TypeScript/issues/364)
While I agree with most of your points, not really sure about the `advanced typing` part. TypeScript recently have exceeded flow in that matter IMO, given now it has things like mapped types and conditional types. On the former flow is not doing well (It doesn't allow mapping on a union type), on the latter flow doesn't support at all. On the community side I would also like to add that, flow's transparency and responsiveness have been very bad. They don't respond to any issues on Github, the community is mostly talking with each other. I think this in the long run, would make TS win.
It's stage 0 right now, so you won't be able to use it for a while, but there is an open proposal to add pattern matching to JavaScript (and thus TS too), which seems like it'd be right up your street: https://github.com/tc39/proposal-pattern-matching Example: const res = await fetch(jsonService) const val = match (res) { {status: 200, headers: {'Content-Length': s}} =&gt; `size is ${s}`, {status: 404} =&gt; 'JSON not found', {status} if (status &gt;= 400) =&gt; throw new RequestError(res) } 
Yes, it does! You can just import from "typescript" package and compile stuff! Check this out: https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API
I've definitely been using this page thus far, but I haven't been able to find exactly what I'm looking for. Do you know where I should look for something that can help me break down an expression?
Perhaps a custom transform plugin. Perhaps this tutorial might help? https://dev.doctorevidence.com/how-to-write-a-typescript-transform-plugin-fc5308fdd943 (Note, this is *not* my work or blog).
I remember finding that tutorial helpful but I soon switched to [ttypescript](https://github.com/cevek/ttypescript) for working on my transformer. 
REST definitely has it's issues but I think you're on the wrong track if you think it dictates how you need to structure your code. REST principles influence how you structure your API contracts by modeling them as 'resources'. In my experience, this covers 90%+ of what you need a web service to do. In which case REST is simple, well-understood and has a huge amount of library support across many languages. You're still free to structure your business logic however you want and really it shouldn't be coupled to your decision to use RESTful interfaces.
This seems really cool. Thanks for sharing. I wonder if it works with redux-thunk? 
Since this only cares about plain reducers, it's independent.
I agree that it looks like TS should be able to do it too. Since leaving that comment, I found [this](https://github.com/IRCraziestTaxi/typeorm-linq-repository).
It has a nice interface for input of non\-code, and okayish sharing &amp; syndication options. Overall, its easier to just post there randomly, than it is to start a wordpress blog with no viewers. Think of it like long\-form twitter.
Check out the "Traversing the AST with a little linter" part of the page. In the code, inside delintNode function, there is a switch that is comparing the `node.kind` to various values available from `ts.SyntaxKind`object. `node.kind` is the kind of the current AST node that is being traversed - and you can ask if it's some kind of an expression through comparing it with e.g. `ts.SyntaxKind.BinaryExpression`.
Calling a function carries an unnecessary cost, though.
My point is that there is no benefit to the cost. String literals are typed.
So you're proposing that, for example, if you've got one post, many paragraphs, and one post, many comments, you could do something like this? db.posts.include('paragraphs').include('comments'); Because the type of the associations allowed could be `'paragraphs' | 'comments'`?
If the library doesn't bundle it's own typings, install them from @types/ on npm. The @types/ scope is auto-published from DefinitelyTyped, the official community repo for declarations.
A bit off-topic, but, I'd use generics and inference there. 3x less code for the same (or even better) accuracy. ``` function convertModel&lt; M extends { properties: any; componentType: any; foo: string } &gt;(model: M) { const newModel = { something: 22, properties: { componentType: model.componentType }, } if (model.foo === "bar") { return { ...newModel, foo: model.foo } } return newModel } ```
I don’t know how far your project is but for future projects you can consider using immerjs. Fully type-able.
I think you're remembering [typings / TSD](https://github.com/typings/typings). There was a push to move from DT to Typings, which was an improvement in a few ways. That was short-lived though, and scrapped a while back. Typings is deprecated, and instead types now get distributed through npm, like everything else. You either want a `@types/package-name` packages, or preferably types stored in the package itself (using a `types` or `typings` field in package.json), where possible. Those `@types/*` packages are autopublished from the DT github repository.
Why is this question getting downvoted? To me it seems to be a very legt question.
`foo` does not run asynchronously. It runs synchronously, because you don't have an `await` statement.
You mean the `async` is useless unless used along with `await` which triggers the asynchronous behavior ?
The `async` keyword doesn't do what you think it does. The actual function body will be synchronous up until the first `await`, and the result will be wrapped in a promise. For example: async function foo() { console.log(1); return 3; } foo().then(console.log); console.log(2); // 1 // 2 // 3 Unless you use an `await` the behavior is equivalent to just returning a promise yourself. // This is equivalent foo function bar() { console.log(1); return Promise.resolve(3); } bar().then(console.log); console.log(2); // 1 // 2 // 3
The `async` forces the function to return a Promise. So even if the function never uses the `await` keyword, the return value or thrown error is wrapped in a Promise. (as resolution or rejection, respectively)
Yup exactly. It's still node, same event loop and single thread. 
That depends on your target.
To add to my previous comment: When assertion `node.kind == ts.SyntaxKind.BinaryExpression` is true, then `node` is of type `ts.BinaryExpression` and you can use it like `const expr = node as ts.BinaryExpression`.
Doesn't it make more sense to use Web API and swagger/swashbuckle to solve both problems?
Nice to see an advanced guide here. Thanks. 
React Virtualized although it may not be very easy to use. 
I couldn't get the code in the first part to work. Had to change it to this export interface MyYear extends String { __my_year__?: never; } I was getting &gt; 'string' only refers to a type, but is being used as a value here. and interfaces dont use = 
Ye there are some typos in the example (an `=` in the interface definition too). The (semi-)canonical way to make these things nominal is to use an intersection. type MyYear = string &amp; { __my_year__: void };
We first try typewriter to generate contract, so it is a natural choice for us to also use it to generate a contract. But I think it would be worth to try swashbuckle and some swagger ts client.
Recently heard about agGrid; looked pretty good.
Yeah I glanced it ss well. Looked kind of massive though and proprietary as well.
This is a shortcoming of TypeScript's type inference algorithm. `Map.has` returns a boolean, but the type inference algorithm does not understand the actual meaning of that boolean (that Map.get(someVar) returns a defined value). A workaround would be to get the key before the if sentence: const x = this.mySet.get(someVar); if(x != null) { const y = x.blah; } 
Another option is to use the non-null assertion operator (!) for cases where you know the value cannot be null/undefined. mySet: Map&lt;string, IObjWithBlah&gt; = new Map(); if (this.mySet.has(someVar)) { const x = this.mySet.get(someVar); const y = x.blah!; // undefined/null union case is stripped out } 
mySet.get() has return type IObjWithBlah | undefined. It cannot retroactively check the condition above. Maybe use something like: mySet: Map&lt;string, IObjWithBlah&gt; = new Map(); const x = this.mySet.get(someVar); if (x !== undefined) { const y = x.blah; // do something here } Or: mySet: Map&lt;string, IObjWithBlah&gt; = new Map(); if (this.mySet.has(someVar)) { const x = this.mySet.get(someVar) as IObjWithBlah; const y = x.blah; } 
Yeah. I would think static analysis alone .... the fact .has returned true for "someVar" before entering the block, would signal .get for "someVar" is defined. :\-/ 
They have an open-source version.
Yeah, that's how I was doing it. It just felt like TS should already know ... like the way type guards work.
We've been using ag\-Grid for a couple of years now. Though the last few releases have started to become more buggy than in the first year or two of the project \(and you have to wait up to 2 months for reported bugs to get corrected these days\), it's still a very great grid.
If you're using Typescript 2.8, you can just do something like this: ``` type ConnectedState = ReturnType&lt;typeof mapStateToProps&gt;; ``` This will let you use the inferred return type of `mapStateToProps` as a named type.
Incredible! Thank you very much!
Oh, I had no idea that was a thing, thanks!
They're doing it themselves. The code is available online to check. The TypeScript compiler has a staggering amount of zero dependencies. In the world of NPM that's a miracle.
It does not use Babel as Babel can only transpile JS. You can look at their dependencies to see they are not using it: https://github.com/Microsoft/TypeScript/blob/master/package.json You can see how they are transforming the TS in this folder: https://github.com/Microsoft/TypeScript/tree/master/src/compiler/transformers A simple case is here: https://github.com/Microsoft/TypeScript/blob/master/src/compiler/transformers/es2016.ts You can see on line 45 they are transforming x**y into Math.pow(x, y).
Note, you can also use the inferred type of `mapDispatchToProps`. Here is what a full example container might look like: ``` import { connect } from 'react-redux'; import { toggleMenu } from '../state/modules/menu'; import { Store } from '../state/store'; // or wherever you have it interface OwnProps { // These are the props that get passed down to the container from the parent. // This can be omitted if there are none } const mapStateToProps = (state: Store, ownProps: OwnProps) =&gt; ({ open: state.menu.open }); const mapDispatchToProps = { toggleMenu }; type StateProps = ReturnType&lt;typeof mapStateToProps&gt;; type DispatchProps = typeof mapDispatchToProps; type Props = OwnProps &amp; StateProps &amp; DispatchProps; // This component will receive StateProps, DispatchProps, and OwnProps class MyComponent extends React.Component&lt;Props, null&gt; { ... } // This will export a container component that only takes OwnProps export default connect&lt;StateProps, DispatchProps, OwnProps&gt;(mapStateToProps, mapDispatchToProps); ```
That's how I do it for 100&amp;#37; type safety and decent readability. \`fetchSomethingRequest\` is an action creator, \`getSomething\` is a selector. interface OwnProps { /* ... */ } interface ConnectedProps { something: string; } interface ConnectedDispatch { fetchSomethingRequest: typeof fetchSomethingRequest; } interface State { /* ... */ } type Props = OwnProps &amp; ConnectedProps &amp; ConnectedProps; class MyComponent extends React.Component&lt;Props, State&gt; { /* ... */ } export default connect&lt;ConnectedProps, ConnectedDispatch, OwnProps, Store&gt;( state =&gt; ({ something: getSomething(state), }), { fetchSomethingRequest, }, ), )(MyComponent);
It's pretty odd in the world of NPM! Could not they easily use Babel or any other relevant tools instead of writing their own transpiler?
So, do you mean they use just their own transpiler (transformer)? Does not this make it hard for them to always keep up to date with different versions of JavaScript? Also, they need to spend a lot of time to keep the transpiler good, and fast inside their team
It would be nice if tsc had this knowledge somehow already, though it does feel like a kind of specific thing for the compiler to know about (vs, say, type guards, which is much more general of a concept). Something like this _may_ be possible by overriding some `Map` definitions. The following example doesn't quite work (`typeof k` is `string`, so once in the guard any `get`'d item will be defined -- also the type guard casts `this` to `never` in the else case for some reason). However you can see how the construction works in a simple case (be sure to check "strictNullChecks" in options): https://www.typescriptlang.org/play/#src=interface%20DefinedMap%3CK%2C%20V%2C%20T%20extends%20K%20%3D%20never%3E%20extends%20Map%3CK%2C%20V%3E%20%7B%0D%0A%20%20get(k%3A%20T)%3A%20V%3B%0D%0A%20%20get(k%3A%20K)%3A%20V%20%7C%20undefined%3B%0D%0A%20%20has(k%3A%20K)%3A%20this%20is%20DefinedMap%3CK%2C%20V%2C%20typeof%20k%20%7C%20T%3E%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20const%20foo%3A%20DefinedMap%3Cstring%2C%20%7B%20x%3A%20string%20%7D%3E%3B%0D%0A%0D%0Aconst%20a%20%3D%20foo.get(%22bar%22)%3B%0D%0Aconsole.log(a.x)%3B%0D%0A%0D%0Aif%20(foo.has(%22bar%22))%20%7B%0D%0A%20%20const%20b%20%3D%20foo.get(%22bar%22)%3B%0D%0A%20%20console.log(b.x)%3B%0D%0A%7D%0D%0A%0D%0A
Even if they could, why would they add a dependency to a third-party system to rely on in their compiler?
They really do it themselves. Typescript is designed and implemented by Microsoft\-\-\-you know that multi\-billion dollar company who also has compilers for C#, C\+\+, C, F#, Basic, etc. They're more than capable of writing a compiler without relying on 3rd party efforts. 
Babel was one monolithic, and it was probably determined that it's easier to write your own purpose built monolithic compiler, than to use Babel, then pastiche a leaky abstraction layer atop it. The upside is that Typescript\-\-\-thanks to their language server, can have typechecking, refactoring, and introspection in any editor fairly easily.
Um... the Typescript team is larger than Babel's. They're vastly better funded as well as its a Microsoft project, I think you're working off some bad assumptions here. Microsoft can't just push off the concept of compiling Javascript to another company. They're a browser maker\-\-\-Internet Explorer / MS Edge. They \*have\* to have the skills to write Javascript compilers in\-house.
It's also important to note that the main person leading the type script effort is [Anders Hejlsberg](https://en.wikipedia.org/wiki/Anders_Hejlsberg). Anders is pretty famous having designed several languages (including C#). He's a really smart person who brings a lot to TypeScript. Also it's important to note that typescript was always meant to be an extension of javascript. So it keeps "to date" with javascript always because it IS javascript. It just adds layers on top and as those features become available in the core language, the typescript team shuts off the transpilation piece as needed.
You're asking the wrong question. Why didn't Babel's team use TypeScript? TypeScript has vastly more resources.
I just parse t to json with any of the available libraries and cast to the known interface. 
How do you deal with arrays? For example when only 1 array item is returned, a „dumb“ xml parser returns it as object or wraps all nodes in arrays, which is rather ugly.
Compiler does it
If you can't find anything XSD \-\&gt; TS you can look into intermediate formats, like: XSD \-\&gt; JSON schema \(or swagger, which is a subset\) \-\&gt; TS.
&gt; In the world of NPM that's a miracle. This is my favorite part of this post, and also absurdly true, haha.
TIL something! I learned C# in school but had to use Typescript for my first job and the transition was pretty painless. Makes sense now.
You need a schema to know the shape of your XML. Then you can parse it into JS objects, which can be strongly typed in TS. Without a schema, there can be no type-safety. Even if your XML responses can be in very different shapes, you can type it with disjoint unions.
I guess that in the early days of TS, Babel \(or other similar tools\) weren't really a thing, so it made more sense to roll a compiler from scratch.
I just wrote some code to extract the data I needed to a sensible format. 
How is the XML generated? If its from java entities you could use a tool like this: https://github.com/dzuvic/jtsgen 
The XML endpoint is from an external company. But i've created a XSD for it. I found https://github.com/peerlibrary/node-xml4js, maybe i'll try that and write the TS interfaces separately.
Can you provide any example code on github? Would be great!
No, sorry. I’ve only done it for work, closed source. But it’s veeeery simple stuff. Like const customers = jsonData.cusomer.map(...);
Near the end of the [opening remarks](https://www.youtube.com/watch?v=wpgKd-rwnMw) (all worth a watch IMO!) at TSConf the chap mentioned demoed something that might be of use to you, though I don't think it's landed anywhere usable yet. It's called composite projects and it's at the top of their [roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)!
Nice feedback thanks
It's not about paying a fee for something that I will use. That's totally fine if I decide to go that direction. It's about being an situation where I need to try a few things for a new project and customization is usually waiting for me in the corner :\) This is why I asked for something simple, lightweight and customizable. From what I understand AgGrid is big and not customizable \(because of the proprietary thing on the full version\). On the other hand I am a bit skeptical with 2 tier products \(paid \- non paid\) because of bad previous experience \(another company, another product\). But I see that AgGrid gets a lot of recommendations here, so I may need to consider it. 
Also Microsoft has a vast teams of people that write JavaScript parsers and design programming languages. I’m fairly certain Babel and 6to5 predate TS anyhow. 
We have one shared common module at my work. I build that with "declaration" [1] set to true, which will print out a bunch of .d.t.s files along with the compiled js and source maps. Then when you import the module, typescript will see all your types in vs code. Havent used atom but I have been telling my team to just switch to vs code. [1] https://www.typescriptlang.org/docs/handbook/compiler-options.html
It definitely works in Atom as well.
I'm using DOMParser (https://github.com/jindw/xmldom), no problem with it.
Thats the (non-null assertion operator)[https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator]. Basically tells Typescript to remove possible null or undefined values from a type. Generally useful when trying to access a nested property or method on something that may be null in some cases, but you know won't be in a given context.
I got this working a few months ago using a combination of VSCode, Yarn, Webpack, and Lerna. It’s very possible, though (at least a few months ago) pretty finicky to keep the build going with all the updates coming in to everything - specifically yarn. Works well though in the end, though my build is a tad slow. Right now, all of my modules are yarn workspaces in the same GutHub repo, though, using git submodules you could actual maintain them in separate repositories and get an integrated build going. Or, if you don’t want an integrated build, then you pretty much just upload your modules to npm with types and depend on them in your other modules - that’s what npm is for after all. Hope any of this helps:
wow I didn't know that yet, cool stuff
Great article. Useful stuff!
Publishing to NPM works the best but I don’t want to share our code with NPM. Ill check if you can add NPM sources...
Nice decorators. Seems useful in certain situations. In your lazy-loading example, you mention that load request might fire twice. Here is how you could implement it without that race conditions. The key is to push the promise type to the `users` property. class UserOverview { private users: Promise&lt;User[]&gt; | null; async getAllUsers(): Promise&lt;User[]&gt; { if(this.users == null) this.users = await this.loadUsers(); return this.users; } async getUserById(id: number) { const allUsers = await this.getAllUsers(); return allUsers.find(user =&gt; user.id === id); } private loadUsers(): Promise&lt;User[]&gt; { return myUserStore.getUsers(); } } 
I see the appeal to this if you are developing in a heavy OOP style. My preference, however, is to keep state out of my classes so I don't encounter the need for this in the first place. The neat thing about the JS ecosystem and everything it brings is the flexibility to do things many different ways. Pretty neat.
I believe you mean: async getAllUsers(): Promise&lt;User[]&gt; { if(this.users == null) this.users = this.loadUsers(); return await this.users; } \(Note the `await` keyword.\)
I now have 2 packages: `thbb-client` and `thbb-core`. In package.json for thbb-client, I have: "dependencies": { "thbb-core": "file:../thbb-core" } When compiling thbb-client, I get: ERROR in /Users/hinloopen/Projects/Test/thbb-client/src/components/TopicIndex.vue 8:24 Cannot find module 'thbb-core'. 6 | 7 | &lt;script lang="ts"&gt; &gt; 8 | import { Foo } from 'thbb-core'; 
Here's my Typescript tutorial: Write JavaScript and every time you declare a variable or a function, add ': &lt;that thing's type&gt;'. You're 90% there. 
Yes, thanks
This is a holdover from my python days, but I usually try to organize my imports into groups separated by a blank line, where the groups are Standard lib imports 3rd party imports Organizational imports Current project's imports The 3rd group would be for packages that have been implemented by your organization, but outside of the current project. By organizing it this way you can keep each group sorted alphabetically without having them mixed up. The only thing I do differently for Javascript is add another group for resources like images and css. 
I have been loving working in this framework. Pumped for v5!
I haven't actually considered to separate the groups by a new line which prevents tslint from complaining when they are not alphabetically ordered. That is a nice side-effect since I include a bootstrap file in two sources which must appear first and can omit the tslint disable comment. I like your structure and will give it a thought. In fact I am even considering to automate the Smart Column Indenter VSCode plugin to indent the above imports like this: import { Commandlet } from "@cli/Framework/Commandlet" ; import { Manifest } from "@cli/Framework/Manifest" ; import { PackageJson } from "@cli/Framework/PackageJson"; import { VerbsData } from "@cli/Framework/VerbsData" ; import { IPackage } from "@cli/Schemas/IPackage" ; import { IPackageJson } from "@cli/Schemas/IPackageJson" ; import * as fs from "fs" ; import * as path from "path" ;
You seem fine. Your code is an "end-point". By "declaration" I meant turning on the "declaraction" flag in tsconfig.json.
It's not clear what you are trying to accomplish.
You're trying to do this at runtime? Or are you doing static analysis?
Given a chunk of AST, I want to replace all occurrences of some specified identifier (specified by the identifier's text) with another identifier according to a set of rules. For example, if the identifier to be replaced is the LHS of a certain BinaryExpression. Ultimately the transformer seemed to work, it just wasn't quite as clean as I would have liked.
I'm using the compiler API, so this would be static analysis. I ended up using something similar to this: https://github.com/nwolverson/blog-typescript-api/blob/master/src/examples/transform.ts
A transformer is the way to go, yes. You want to transform the code while it's being compiled, so the results of your transformation will be visible in the emitted `.js` files, right? TypeScript transformers must treat the input AST as immutable and return a *new* AST. The language service needs to be super-fast, and ASTs are reused. With incremental parsing, most of the AST is kept around; only modified parts are replaced. Hence the immutability requirement. (someone correct me if I'm wrong about this part) Fortunately, the transformer API takes care of creating a new AST for you. When your visitor function is called on the identifier node, return a new identifier node to replace it. You can either use `ts.createIdentifier()` or `ts.getMutableClone(oldIdentifierNode)` to create a new identifier. Here's a simple transformer which shows how to use the visitor API and return replacement nodes. https://github.com/kimamula/ts-transformer-keys/blob/master/transformer.ts#L37-L40
I would recommend using string enums if you use them.... E.g. enum MyEnum { BLAH = "blah" }. It generates just a straight up key / value map though, which means you can't convert from the string to the enum very easily. But the benefits you list of using string literal types apply to string enums as well. It is also much nicer to use MyEnum.BLAH everywhere instead of "blah" everywhere in your code...
The string enums are cool but is that really easier than the string literal? VSCode is smart enough to autocomplete the literal everywhere I need to type it and the painless interop with JSON is such a win.
You can also autocomplete an enum.... But off the top of my head, two reasons are slightly cleaner code: You have no random string values floating around, and don't have to worry about conflicting usage \(e.g. "foo" can mean different things in different contexts\). It is also a lot easier to refactor an enum and its value. Although you do lose out on painless interop with JSON. However, with something like [class\-transformer](https://github.com/typestack/class-transformer) that isn't a big issue.
You could also make an argument that it’s more performant since it doesn’t instantiate a new string.
Yup. This is the way I use them in my code. I wish there wasn't an insane amount of ways to handle enums but this is my preferred way since it's very elegant with the implementation. Just a sample from my code: ``` enum ReportStatus { success: 'success', inProgress: 'inProgress', failure: 'failure', timedout: 'timedout' } ``` Then somewhere else I can do: `Repo-&gt;Tab to autocomplete and import.inP-&gt;tab to autocomplete` and then you easily get `ReportStatus.inProgress`
Just drop the `Arguments` type and you can do it simply with a conditional type: type AlterReturnType&lt;T extends (...args: any[]) =&gt; any, R&gt; = T extends () =&gt; any ? () =&gt; R : T extends (a: infer A) =&gt; any ? (a: A) =&gt; R : T extends (a: infer A, b: infer B) =&gt; any ? (a: A, b: B) =&gt; R : T extends (a: infer A, b: infer B, c: infer C) =&gt; any ? (a: A, b: B, c: C) =&gt; R : T extends (a: infer A, b: infer B, c: infer C, d: infer D) =&gt; any ? (a: A, b: B, c: C, d: D) =&gt; R : T extends (a: infer A, b: infer B, c: infer C, d: infer D, e: infer E) =&gt; any ? (a: A, b: B, c: C, d: D, e: E) =&gt; R : never; 
Ah, for some reason I haven't thought of this! Thanks, this works perfectly. I really hope TypeScript gets variadic generics some day, though (I encounter cases like this very frequently, where you need to explicitly list function signatures for every number of arguments).
Someday, maybe. Could think of some features that would improve TypeScript, but often they're too complex to implement (their compiler is not very well structured). Only bad thing with this solution is that the argument names are not mapped.
See my comment above re: interop. Not sure what you're referring to but string union types as quasi-enums (which is how most JSON APIs are designed if you think about it) is completely typesafe (assuming you've got tsc configured properly).
&gt; simply 😨
if you put them in a json file you'll have to read that from disk, depending how often you read it from disk and at what scale you need to support this process it could be expensive to do so. I/O is typically one of the more expensive operations an application can have depending on a variety of factors. 
Good point. So it seems like what I'm looking for is more of an in-memory cache? Would that be achieved by simply having the values that I know will be persistent stored in `consts` in a dedicated file of the library?
It needs to be read from disk either way right?
Like I said in my original comment, depends on how you set this up. If you read it once during a bootstrapping process on startup it's probably not a big deal. If you are constantly reading it from disk then yeah it's worse. If you create it as TS file and export and import it will cache the data in memory. I assume since we are talking about reading from disk this is being run by NodeJS so the module caching would take affect and every time you called the constants class or exported object it wouldn't be from disk but from memory. 
Just using basic strings feels...wrong to me. I agree with all your statements and both techniques are adequate. Let’s just agree to disagree.
Out of curiosity what's your programming background? Seems like ts attracts as many Java/C# people as js people.
`C++ -&gt; Ruby -&gt; Javascript -&gt; Ruby -&gt; Javascript -&gt; Typescript` When I was younger, I felt so restricted by types. Now I want them back. Building scalable production apps are easier to maintain with types.
I was there at this talk. Great to hear the history and design goals
Such great news to see that they are working on composite projects. Really nice.
Yep. Node can `require` JSON. So you'd just need to provide a corresponding `.json.d.ts` for TypeScript. I don't think it would make any difference.
&gt; The neat thing about the JS ecosystem and everything it brings is the flexibility to do things many different ways. Also the worst thing about the JS ecosystem!
I see what you're trying to do but it's written like crap. I'm going to refactor it in the same language with fewer lines. &gt; Fact: I'm scared of new things until they become familiar. There, it's mine now.
tl;dr: - use "baseUrl" in tsconfig.json to let tsc know where your packages are located - use the "NODE_PATH" env variable to let node know where your packages are located - be extra careful with the "types" property in package.json - Use GNU Make to handle dependency tracking and build tasks - Deploy or publish to an npm compatible artifact repository, you need to script your deployment sequence to inject dependencies and version numbers into each package.json This is a collection of tips I gathered while trying to put together a decent multi-package TS project architecture, and it works pretty damn well. However, the way I figured this out seemed extremely DIY and I wonder if there is a popular way to achieve the same result. How are you guys doing this?
We have multiple multi-package repos that are all fully TS. The way we do it is with yarn workspaces (be warned the docs are not very good, but it has everything you’d need) along with a root and per-package tsconfig files. I’ve actually been mulling setting up a simple cli that can orchestrate multi package repos with common files that sync across packages and common deps and so-on.
Nice post! I've used `yarn workspaces` for this. Worked really great out of the box for me. 
 return class WithDeepCompare extends React.Component&lt;Props, null&gt; { Where is `Props` declared?
Within the same file I have a Props type. type Props = { data: FormState; } &amp; ReturnType&lt;typeof mapStateToProps&gt; &amp; typeof mapDispatchToProps; 
I can't remember exactly what was wrong with my own HOC but I eventually got to a solution by inferring the generic type arguments with connect() example: &gt; connect&lt;IPropsFromState, IDispatchFromProps, IOwnProps&gt;(...)(...) you could also use a generic connect (which i'm using and if i remove the type arguments from it it doesn't work) &gt; export default function funcName&lt;T extends sometype&lt;any&gt;&gt;() { return connect&lt;IPropsFromState&lt;T&gt;, IDispatchFromProps&lt;T&gt;, IOwnProps&gt;(...)(...); } 
Something like this should do the trick: function withDeepCompare&lt;WrappedProps&gt;(WrappedComponent: React.ComponentClass&lt;WrappedProps&gt; &amp; {name: string}) { type WithDeepCompareProps = WrappedProps &amp; Props; return class WithDeepCompare extends React.Component&lt;WithDeepCompareProps, null&gt; { Make it a generic to extract the type of WrappedComponent's props. Derive a new interface for Props based on the extracted type, with any modifications introduced by withDeepCompare. (in this case, just add additional props, but you could also do funky things like removing or replacing props via mapped types, `keyof`, `Exclude`, or `Extract`) Then declare and return the HOC class.
&gt; - Use GNU Make to handle dependency tracking and build tasks I'd just use TypeScript for it. The syntax is familiar to everyone in the project, it's easier than Make, and it's more flexible.
Link to VOD?
https://www.twitch.tv/videos/260411913
What do you mean? Do you write TS scripts to dispatch build commands and stuff? It seems rather verbose, unless you have some sort of npm module that mashes up the work for you.
I had never heard of this feature. Would it replace all of the stack I talk about in the article or only parts of it? In particular, how does it work with respect to types resolution and deployment/publishing? I'd love to see a comprehensive example of yarn workspaces being used in a TS project.
I'd love to see such tool. I've looked at things like lerna but they have too much features on by default. And then you do not know what is going on under the hood, which eventually causes you lots of troubles.
I just have TypeScript files that I execute with `ts-node`. And some utility functions that assist me in whatever I need to do. It's a format every dev knows (as this is a TypeScript project), you can do pretty much anything, and you can debug it easily. Much to prefer over the cryptic syntax of Make.
``` const BEHAVIOR_TAG = Symbol(); interface Behavior&lt;T extends string | symbol | number&gt; { [BEHAVIOR_TAG]: T; } type RetrievableFromDatabase = "@RetrievableFromDatabase"; interface BaseModel { id: string; updatedAt: Date; deletedAt: Date | null; } // Not an Entity but a Subpart of Category so no id and timestamps here interface Bar { something: string; } // A sample model interface Category extends Behavior&lt;RetrievableFromDatabase&gt; { name: string; color: string; foo: Bar; } // Another related sample model interface Item extends Behavior&lt;RetrievableFromDatabase&gt; { name: string; price: number; category: Category; } // Decorate our type with metadata from BaseModel (recursively for all relations) declare type FromDB&lt;T&gt; = T extends object ? { [K in keyof T]: T[K] extends Behavior&lt;RetrievableFromDatabase&gt; ? FromDB&lt;T[K]&gt; : T[K]; } &amp; BaseModel : T; let localCopy: Item; // = createLocalCopy() // Normal attributes from local copy can be accessed localCopy.category.name // Attributes that are set by the server/api/db are not yet present localCopy.id // error: Property 'id' does not exist on type 'Item' // Lets pretend we fetch a specific model from the server/api/db let itemFromDB: FromDB&lt;Item&gt;; // = await getItemFromDb({ id: 123 }) // Normal attributes from remote copy can be accessed itemFromDB.category.name // As well as all the metadata itemFromDB.id // This is also true for all relations that inherit from RetrievableFromDatabase itemFromDB.category.updatedAt // But not for objects that don't inherit from RetrievableFromDatabase itemFromDB.category.foo.id // error: Property 'id' does not exist on type 'Bar'. ``` Similar pattern but you can have multiple "behaviors" with this.
Thanks!
I really like Make now. I learned it for the sole purpose of compiling JS... it's not like I knew it from my C days. Now all my projects compile with one simple command, \`make\`. You don't have to have anything installed beforehand, not even the node modules. It just builds. Even if the projects are setup completely differently. Whether its TS or JS. Maybe it needs to extract a few zips or optimize some images, or create a few directories first... all very easy with Make. And it won't redo any work if everything's already set up, or if it's half built, or you delete some stupid folder because you're having cache issues and it's driving you bonkers... just run \`make\` again to get back to a happy state; it'll rebuild what it needs to.
This is so relatable. I've been caught in the grunt, gulp and what not craze when these were the new hip thing, and in the end I've found that they take way too much effort and time away from the actual development (don't even get me started on gradle!) Make does seem daunting at first but there really isn't much to learn, and, as you said, you mostly use it to bootstrap stuff. It does have its own caveats (glob patterns, ahem ahem), but man is it quick to set up and change your build system with Make. Make is a stupid program, and as such its greatest strength is to prevent you from over-engineering. There are much greater risks when you use an actual programming language for such purpose.
Creating properties that don't exist at runtime is known as "branding." The TypeScript compiler's source code uses the branding trick. https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html
I'd recommend the .json file. Once it's deployed, you can always change the json and restart the app. If you put it in as a const, you'll have to recompile your .ts. If it's an object and you know what the type will be, you can require it in from the json and give it a type. Both ways will have the affect that the values are set once at the first time they are referenced. If you have a ton of static data, you can benefit from a sqlite or other in-memory databases. Doing an array find will go linearly through the data set whereas an indexed table can get there quickly with the right key info. 
Thank you for your example! Yeah I also prefer the markdown way of declaring blocks of code and was suprised that reddit does not support that
Tanks for pointing me in the right direction!
Let Anders Hejlsberg answer on FP/OOP (tsconf.io): https://youtu.be/MxB0ldQfvT4?t=41m8s 
1. if by non-static fields outside constructor meant instance fields, it is already in Stage 3 in standard (https://github.com/tc39/proposal-class-fields) so it is supposed to be implemented in TypeScript according to their public goals/non goals. Babel also implements them (https://babeljs.io/docs/plugins/transform-class-properties/). 2. interfaces are very useful in FP world, I would say, even more useful. 3. at ancient days when the last es was es5, classes attracted (and keep attracting nowdays) developers with OOP background, while TypeScript itself is just a JavaScript with types, you can use any *-programming. 4. lambda itself is a part of JavaScript standard. Pure FP features are for example structural type system, discriminated unions, conditional types, mapped types, type literals. More on FP in TypeScript by Anders Hejlsberg: https://youtu.be/MxB0ldQfvT4?t=41m08s
&gt;So of the many types of enums which do I recommend using? Trick question: none. Strongly disagree with this. TS enums are actually one of the main reasons I made the switch from Flow. * Much nicer to declare * Better completion in IDEs \(really just more IDE\-friendly in general\) * Arguably more readable * They can be iterated over \(with some effort\) You can pry my enums from my cold dead hands.
I also love ts enums, they work exactly how I want
They're very good for the common use case, but string literals work much nicer with more advanced TS features like `keyof` and the like. Each have their own use-cases, and they do overlap.
Go to Udemy.com , download the latest React Redux course by Maximilian Schwarzmuller or Andrew Meade, solve the challenges and make frequent commits, fix their code as you go, and when you are done, build a few production quality apps in couple weeks and keep reading learning hacking :) I think you will like Typescript + React more though. 
"fix their code"? Are you implying that these courses teach bad practices or is it more like programming books have samples on their CD's that sometimes don't even compile?
I think you best bet is learning TS/React/Redux separately from their docs and "getting started" guides (which are quite good), at least this works for me much better than any tutorials and allows to get the fundamentals quickly. After that, if you don't have a good idea of how to do this yourself, you may refer to a guide ([like this one](https://github.com/piotrwitek/react-redux-typescript-guide)) to integrate all 3 technologies in one app. You may refer to [this article](https://medium.com/@martin_hotell/improved-redux-type-safety-with-typescript-2-8-2c11a8062575) for the most concise way to get typesafe Redux actions at the moment (with TypeScript 2.8). You may use an approach like [ducks](https://github.com/erikras/ducks-modular-redux) for large-scale Redux apps (tl;dr split your project to domain-related modules instead of "actions"/"reducers"/etc folders; make each module export its own actions, reducer, views and other stuff).
I learnt vue from Schwarzmuller, a pretty comprehensive course， your advice sounds sarcastic. 
Don't start with react/redux/ts together! First try React. It is probably most unique thing, and you probably didn't develop in something similiar to it. Good starting point is DOCUMENTATION! It is really well written and really that big, please make sure you understand state/props, some lifecycle methods and function/class componenents. Wes Bos has also some good videos about it. Good thing would be to build something like todo list (on react state!). Then move to redux. Documentation is also very good, but I will recommend you eggheads videos by dan abramov (redux creator, now developing react @fb). Use app you built before and change it so it now uses redux state - you will see that react components will stay the same, only logic will move somewhere else. Finally! Typescript. Don't know about any good resources beside docs. Just try to type your whole app. Overall it shouldnt take u long. For experienced dev, learning React is 2-4 days (just to use it, best practises and hacks take longer), redux might take more.
I suggest grabbing one of the boilerplates listed below. Build it. Run it. Dissect it. Modify it. If you have a breadth of knowledge I am guessing you'll start to see how the pieces fit together through this process. One of the online courses can also help, for sure.
I didn’t see this mentioned yet but Visual Studio Code is outstanding. It has excellent support for TS. It will feel comfortable to you with your VS background. I’m using it for Angular and a Node backend. Also agree that Max’s courses on UDemy are the way to go. 
Everyone is pushing redux, but after using it on a big scale project and seeing what kind of nightmare it becomes, we switched to mobx-state-tree and couldn’t be happier. Mobx is also written in TypeScript, not just typed as an afterthought.
why not just provide the defaults for constructor parameters? at least that way you'll save yourself the inevitable head scratching trying to remember if it's import PasswordSecurity from './PasswordSecurity'; or import { PasswordSecurity } from './PasswordSecurity'; but still it's a poor man's DI. "works, but"™
I'm interested in a comparison to RxJS. The examples strike me as things I'd typically use RxJS to solve. I'm curious if LINQ has any advantages (e.g. how are errors handled). Neat project.
Yeah, thats what ‘typeof’ does, but since we’re working with structural typing, this actually means “any object which agreed to the same shape/imprementation” instead of “this exact class reference”. Isnt it beautiful?
Great idea :\)
Redux is very simple, so in order to grow it into a big app with a lot of moving parts the boiler plate really quickly becomes too much, especially given the fact that a lot of it is unnecessary. Mobx State Tree framework has most of the benefits of redux (including time travel), while at the same time giving the application a certain structure that developers can expect and rely on.
 why not just provide the defaults for constructor parameters? at least that way you'll save yourself the inevitable head scratching trying to remember if it's import PasswordSecurity from './PasswordSecurity'; or import { PasswordSecurity } from './PasswordSecurity'; Great idea :\) I updated my post to reflect this. I think it greatly improves the solution &gt;but still it's a poor man's DI. "works, but"™ I'm curious when you think this solution would be troublesome 
RxJs? Don't you mean underscore or lodash?
RxJS is more for event processing whereas LINQ is more for data processing.
Thanks!
The lines blur a bit since a stream of data can and is commonly processed by RxJS.
No, never tried VSCode. I mostly work in Java and as I use IntelliJ for that WebStorm seemed like the natural choice. Are there any benefits to VSCode?
https://www.youtube.com/watch?v=anwy2MPT5RE
https://www.youtube.com/watch?v=anwy2MPT5RE
https://www.youtube.com/watch?v=anwy2MPT5RE
https://www.youtube.com/watch?v=anwy2MPT5RE
/r/typescript This redditor has posted 5 articles to in a row to their own blog
r/typescript This redditor has posted 5 articles to in a row to their own blog
r/typescript This redditor has posted 5 articles to in a row to their own blog
r/typescript This redditor has posted 5 articles to in a row to their own blog
r/typescript This redditor has posted 5 articles to in a row to their own blog
https://www.youtube.com/watch?v=anwy2MPT5RE
/r/typescript this makes 6 -- this user is a nuisance, I even think this behavior is enough to get entirely banned from reddit (let alone a single subreddit)
Really is problematic.
Well the above comment should result in the mods getting messaged. When he/she posted a *sixth* article I pointed out to the moderators that this behavior is almost enough to get entirely banned from reddit, let alone a single subreddit
[removed]
 type Foo = Extract&lt;MyType, { kind: 'foo' }&gt;;
Thanks, it works perfectly! I haven't thought about using conditional types for this.
Just learn React and Typescript separately, putting the 2 together is as simple as applying a prop and state type to your components. You don't need a video for it although [egghead](https://egghead.io/courses/use-typescript-to-develop-react-applications) do have a short course 
I'm actually very frustrated by this feature currently. I've enabled it in my tsconfig but am not seeing any compiler errors as a result of it. I was looking forward to that reminder when writing new classes, and taking care of that cleanup for all of my old classes but it just doesn't seem to work. When I say it's not reporting errors, I mean via gulp-typescript, the typescript server itself in vscode, and directly via `tsc`. Nothing.
Do you have --strictNullChecks enabled as well? (And are you on TypeScript &gt;= 2.7?) Strict property initialization checks require that flag in order to have any effect.
Oh, there it is. I didn't resize strictNullChecks was a requisite. Thank you. Honestly I have a ridiculous amount of refactoring to do if I am to incorporate strictNullChecks (187 compilation errors 😥) but I suppose now is as good a time as any. Safer code never hurt anyone.
After you’re done refactoring the strict null checking errors, consider setting --strict for maximum strictness settings :)
I definitely think I will. I've already made a considerable dent in the total errors. Regrettably, I started this with not enough time to finish in one sitting, so I will have to leave the remainder for later. Thank you again for your help.
Plenty of the LINQ methods assume a finite collection of elements. For example Max or Min functions don't make sense on a event listener transform.
No - there isn't. It would be interesting to do though. One note though, LINQ to TypeScript is designed to be lazy whereas lodash is not. 
How easy is it to integrate this with React? I can't see any mention of that anywhere, but it's pretty key for a lot of modern web projects.
I am not a fan of the decorator syntax, but that's more of a personal taste issue. Otherwise, the framework is fairly simply and easy to follow. It's a definite improvement on bare ExpressJS, and the only suggestion I'd make is that you should have an opinionated default as to templating\-\-\-if templates are to be used at all. If not, then, having some kind of helpers for return values like JSON serializers/deserializers would be nice.
I checked it out. On NPM, there appear to be dozens of similar LinQ implementations, but out of the top 10 by popularity, I think yours is the best. I prefer your syntax of lowercased method names; it seems to embrace JS style more. Also, I love that you've added quite a bit of documentation rather than assuming everyone knows C# LinQ to begin with. Lastly, your examples are compelling\-\-\-and existant which many packages don't seem to have. Overall, awesome job.
Thanks for the awesome feedback! Opinionated templating is something I’ve been considering but your feedback really pushed me over the edge. I think it would be useful in this context and will start working toward that goal. Motivation was after building several express js apps (using additional frameworks and not) I have ended up with lots of repeated and spaghetti code to handle things I was doing frequently, boilerplate code, etc. Also just wanted some practice as this is my first framework (as a passion project). Thanks again.
Calling `reject` is pretty much the same as throwing an exception if you think about it. The consumer has to explicitly call `catch` to handle reject, just like thrown exceptions are handled with and explicit try-catch block, and it can be unclear where the `reject` was called, just like it can be unclear where the exception was thrown.
You can't type the error case of a promise. It's always `any`, because you can throw any value in JavaScript (even number). I prefer the functional approach where you have a result object that is either a typed value or a typed error, and you chain calls using a map function that applies a method if the result is a value and just returns the original error if it's an error. Unfortunately functional programming has not yet arrived much in the JavaScript world (except of the poor man's map and filter).
Promises are for delayed action, and difficult to compose. E.g. if I wanted to call your function five times in a row, I couldn't do: ``` for (var i = 0; i &lt; 5; i++) { foo().then(... // how do I wait for it to complete before the next // iteration of the loop? ) } ``` The answer to that is making the function async, but that is a lot of extra code and allocation.
&gt; eptions are handled with and explicit try-catch block, and it can be unclear where the reject was called, just like it can be unclear where the exception was thrown. Can you provide an example of how this might look with multiple calls?
Do you have an good example of mapping the result?
Similar to the example in the link you provided, you could have a promise that looks like this: async fooBar() { const foo = await runTask1(); const bar = await runTask2(); .... } If `reject` is called it may be unclear whether it was called in `runTask1` or in `runTask2`
I like to use a Result wrapper as a return type from functions that may fail. I get where you are coming from with Promises, but I would be wary of (ab)using them here. Firstly, it could well confuse anyone else who works on your code to use them in an atypical manner, secondly (as mentioned in another comment) the error cannot be typed, and thirdly you may get some edge case bugs because the functions passed to "then" and "catch" will run on the next pass through the event loop. A Result type like the following gives a nice (to me) interface to work with. interface MapFns&lt;T, E, TResult, EResult&gt; { success: (a: T) =&gt; TResult; failure: (e: E) =&gt; EResult; } class Result&lt;TSuccess, TError&gt; { public static Success&lt;T&gt;(success: T) { return new Result&lt;T, any&gt;(success, null, false); } public static Failure&lt;T&gt;(error: T) { return new Result&lt;any, T&gt;(null, error, true); } constructor( private success: TSuccess, private error: TError, private isError: boolean ) {} when&lt;T, E&gt;(mapFns: MapFns&lt;TSuccess, TError, T, E&gt;) { return this.isError ? mapFns.failure(this.error) : mapFns.success(this.success); } } Which you can use something like: const foo = (): Result&lt;number, string&gt; =&gt; { if (Math.random() &lt; 0.5) { return Result.Success(5); } return Result.Failure("oh no"); }; foo().when({ success: result =&gt; console.log(result), // result typed as number failure: error =&gt; console.log(error) // result typed as string });
In fact, that's what the promise-based case would look like using `async`/`await`: import { foo } from 'bar'; async function whatever() { try { await foo(); console.log('Good to go'); } catch (err) { console.log('Had an error:', err); } }
Wow. This is incredibly well described. I really dig this especially the pattern matching behavior.
Not DRY, production code. Andrew does sort of TDD but the others don’t. So as you go along the course, rewrite the app to reflect years of programming experience. You will see anyway. Inline styles etc; and there is only one “Typescript” react lecture from Max in his Typescript course. The courses are sometimes outdated and won’t compile, that’s normal with the state of web development these days, new versions of libraries have breaking changes, so you read the docs and fix that as well. It’s not 0 effort watch and learn; you have to read docs, google error messages and rewrite their code to be reusable and dry, it’s code for teaching, you wouldn’t pass the coding task of a company you apply to with that code. You should read YDKJS book series and Clean Code as well as doing these courses. That s the difference between coding in your bedroom and getting hired in 8-10 months for 100k €. (At least for me. Did their courses, applied to jobs and interview in skype, got hired for dream job , relocated overseas , now I m surprise that I keep spending my salary and I can’t finish it by the time I get my next salary, mainly because no time to spend; when your job is satisfying and you keep making commits and pushing when you go home and also on weekends)
But we already have nestjs??
You can pass your error through a type guard, then control flow analysis will have your error type figured out. ``` function isApiError(err: any) : err is ApiError { return err &amp;&amp; err.meta = 'API_ERROR' } async function doit(input) { try { await callMyThings(input) } catch(err) { if (isApiError(err)) { //err will have ApiError type inside this block } } } ```
I needed a way to unit test my type operators. dtslint does this, but I couldn't find a really good description on how to set this up \(the readme was a bit lacking IMO\), so I wrote this up. Hope that somebody finds this helpful.
Sure, but the approach is still a pretty bad one. It's not clear from the API that this function can error out. You would need to point this out with a comment in which you also refer to your type guard... But yeah, no. That's really bad. Instead just make use of the great type system that TypeScript has to offer and actually type your result object. That will implicitly document the error cases of your function, as well as force the user to acknowledge and handle the error case.
I'm waiting for higher-kinded types [TS github issue](https://github.com/Microsoft/TypeScript/issues/1213) to be implemented before going fully down this route. Currently libraries like Ramda (and even lodash to some extent) can't be properly typed, which makes them significantly less appealing.
There is a definite similarity there, in that we are using a function (or in this case an object with function values) as an argument to another function. There are a couple of advantages of this approach over callbacks: 1. The foo function no longer has any logic regarding result processing - this has now been abstracted into our Result class. This is good for separation of concerns - now "foo" knows about how to do it's job, and Result knows about applying functions to results. 2. We have a compiler-level guarantee that the error case has been handled. By enforcing the use of "success" and "failure" pattern matches via the type system (MapFns interface), it is now impossible to write compiling code that doesn't explicitly deal with the failure case. There are of course negatives as well. 1. Once you start using types like these they will get into lots of places in your codebase, and it will be difficult to change your mind if you don't like them. 2. Not everyone likes or is comfortable with this style of code, and it may make working in a team, or onboarding new colleagues more difficult. For me, the advantages outweigh the disadvantages, but your decision may be different.
I've been banging my head against this wall for the past week or so and haven't had any luck on StackOverflow. Hoping someone here may have some insight!
I stumbled upon the same issue this weekend, but using comments for tests seems a bit nasty. My solution was just to use the TypeScript compiler API. I have my regular Jest test suite, and in there I have calls like: it('MyOperator&lt;T&gt; always resolves to string', () =&gt; { const typeName = getResolvedTypeName(` import { MyOperator } from './src/index'; type ##Test_01_number_is_not_string = MyOperator&lt;number&gt;; `); expect(typeName).toEqual('string'); }); The `##` prefixes the node whose type I want to get.
The error is telling you you're passing a generic param to something that doesn't accept generic params. Can you diagnose from there?
I implemented a Rust-like `Result` type for my personal projects. I don't have the latest implementation right now but here's approximately what it looks like: [gist](https://gist.github.com/Gustorn/e76e876390bf1df6a77f7a6f61bf9cff). It's basically your idea, only with a few more helper methods and a bit of sugar for accessing values. Here's an example of how one could use it: const openFile: (fileName: string) =&gt; Result&lt;File, Error&gt; = null!; const readContents: (file: File) =&gt; Result&lt;string, string&gt; = null!; const parseDocument: (str: string) =&gt; Result&lt;Document, string&gt; = null!; const doc = openFile("foo.txt") .mapErr(error =&gt; error.message) .andThen(readContents) .andThen(parseDocument); if (doc.isOk()) { console.log(doc.value); // You can access doc.value since you checked if it's present first }
RemindMe! 4 Months
I will be messaging you on [**2018-09-22 14:43:12 UTC**](http://www.wolframalpha.com/input/?i=2018-09-22 14:43:12 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/typescript/comments/8l0grf/awesome_charting_library_written_completely_with/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/typescript/comments/8l0grf/awesome_charting_library_written_completely_with/]%0A%0ARemindMe! 4 Months) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
We've been using AmCharts in production react applications for a couple years now, which required building some simple wrapper components to provide nicer prop signatures and actually render the charts. Been working great. The new version looks really nice and we're already using it in new products currently under development. We've hit a couple type errors that we had to workaround (had to disable strict mode and some implicit type checking), but sounds like they are working toward support of stricter compiler settings for the release. All in all we've been pretty happy with amcharts and really look forward to first-class TS and React support. 
Wow. This is an incredibly insightful answer. The compiler level guarantee is a huge win IMO. Thanks for your help!
You can use [`f.name`](https://f.name). [Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name)
The short answer is no. It might be possible to extract the `this` type from a function signature using conditional types, but that would not do what you want. It might do something *similar* in a few specific situations. But probably not.
I don't believe this is possible. Properties on a Javascript object have no concept of their parent. Math.pow is just a reference to a method. When you set f to = Math.pow, f now references that same method directly. 
Does it help if Math.pow is being passed to a function as an argument? So I have access to it inside the calling function. If there was a way to capture the arguments to a function as a stein that would solve this I believe. 
That makes sense, thank you for the help. 
For the time being, "imports" are module bundles that would include exported components. "exports" are components with routes. So in the example above, Version component's routes would be located at that module's level. Items, People, Orders modules would similarly "export" their own components at their level. So let's say VersionComponent looked like this: ```typescript class VersionComponent { @GetMapping({ path: 'version' }) getVersion(res) { res.success({ major: 0, minor: 1, patch: 0 }); } } And was included in AppModule like this: ```typescript // ... @LitModule({ path: 'api', exports: [ VersionComponent ] }) class AppModule ``` It would produce a single route: GET /api/version Whereas, if you had another module: ```typescript @LitModule({ path: 'items', exports: [ ItemsComponent ] }) class ItemsModule ``` And that Items component looked like this: ```typescript // ... class ItemsComponent { @GetMapping({ path: ':id' }) getItem(res) { res.success({}); } } ``` And your app.module now looked like this: ```typescript // ... @LitModule({ path: 'api', imports: [ ItemsModule ]. exports: [ VersionComponent ] }) class AppModule ``` It would register two routes: GET /api/version GET /api/items/:id Thanks for taking the time to look at it, I will try to make the docs a little clearer on the difference there. 
Looks like there's a 4 year old feature request for that which is still open: https://github.com/Microsoft/TypeScript/issues/449
No, typescript doesn't contain preprocessor directives. However there are packages you can use as part of your build system to do it, for example: https://www.npmjs.com/package/gulp-strip-code My word of caution would be to use it sparingly. Preprocessing makes a lot of sense for fully compiled languages with multiple build targets. For example you might want to do something differently if it's a Windows or Linux build or a 32-bit or 64-bit. That could apply to TS when targeting various JS versions but I'm hesitant. I think it's a change that needs to be considered very carefully. If you're using it for something like omitting test code or something like that I think what you really need is better environment configuration.
1. Messy code. Take a look at the first 30 lines of `AsyncEnumerable.js`. Those first 30 lines are helper functions for ES7 to ES6 transpilation. Matter of fact that whole class is near unreadable compared to the source code. The code would look even worse, a lot worse, if I targeted ES5. 2. IE11. Stop using it. Edge, Firefox, Node, and Chrome all support ES6. 3. Any respectful bundler will use the source code and transpile it for you to ES5 if you want. 
I think your job is awesome base on your commits and docs. Bcoz also developing a lib same like your lib: [https://github.com/jinhduong/linq\-fns](https://github.com/jinhduong/linq-fns) but it more simply than yours and provide some drivers to work with db like as `firebase` `gists files` I think because almost input data is `Promise` so we will face and should be focusing about `Promise` like as ```js .from(Promise).join(Promise).join(Promise) ``` I using `Promise.all` to do it and which way you use to resolve it? Thanks.
let's assume this: class Dep { } class A { constructor(someDep: Dep = new Dep()) { } } export class B { private a: A; } now imagine you'd like to construct B in your unit test. How do you pass the mocks to the A? The only way is to make the constructor of B accept the same stuff as A (even though it might have nothing to do with those). Now imagine your composition goes 10 classes deep. That'll get hairy. new Toaster(new FalconHeavyBecauseTheToasterWillNeedAResistorFromTesla()) the toaster example is actually an example of bad class design, but it demonstrates the problem :)
Little off topic, but typeful-redux seems nice. Typing redux has always been a major pain for me - to the degree where I sometimes just.. don't.
You can definitely tell that TypeScript isn't a first class citizen in the facebook part of the eco-system. Though fortunately nowadays it should work in RN via the wonderful [react-native-typescript-transformer](https://github.com/ds300/react-native-typescript-transformer) - not sure about using custom transformers in CRNA though!
Promises do not allow you to retrieve their resolution or rejection synchronously, so you're forced to wait an extra lap around the event loop. This can be a problem for performance and also makes it impossible to write synchronous code in the style you're describing. You could always write your own, synchronous return value class that mimics promises' then and catch methods.
Sourcegraph runs language servers to understand code in Github and offer the same IDE intelligence right in the browser. So you can be reviewing a pull request, hover over an identifier, and SourceGraph will give you the same documentation and type info that TypeScript does, because it's running the same language service. It integrates with Github via a browser extension. To use it on private repositories, you need to host the sourcegraph server yourself. The browser extension will then connect to your private sourcegraph server to get code intelligence.
Looking a lot like Swift, I love it.
It's amazing, since I fully started adopting it in all my projects I can't imagine a better way
How does one go about writing this in a .d.ts? /** * @typedef Tiles * @type {Array&lt;number&gt;} */ It seems I can delcare classes OK in an external file, but not definitions of simple types.
Haskell dev here. Conditional types are supported for sure. As for type mapping, it's hard to give a short answer, on one hand if you use heterogenous lists / dicts \(i.e if you intentionally use structural types\) then it's very easy, but if you use the more nominally\-typed standard types, then it's a little weirder, but probably still possible with Template Haskell / Generics and friends.
Yes, OCaml.
Interesting... Haskell is one of those languages I keep hearing about and always considered 'fringe'... how practical and widely applicable is Haskell these days for things like web development?
Great! Would you mind telling me what these features are 'called' in these languages? I don't know them by any other name than 'type mapping' or 'conditional types'...
Haskell doesn't have subtyping (at least in the style of TypeScript), so there is no exact equivalent of a conditional type. Haskell does have type-level booleans and type-families, that let you do something similar, but it's less ergonomic. As for mapped types, I believe they could be emulated but as with conditional types, they will take quite alot of work to define and will not come out as crisp. These features are unique, precisely because TypeScript is trying to solve a unique problem of assigning types to a highly dynamic and reflective language. Consequently it offers these built it and very useful operators that work well for JavaScript code. Something like Haskell started from a place where all programs had types that were strongly enforced, relying more on data abstract and parametricity, where conditional types and mapped types are less useful. 
Hey, -jvv, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
You can use the Mixin mechanics of YS to achieve this. Sadly, native "traits" can't be added as it seems the TS team do not want to include non-standard grammar for things that aren't types. That said someone took the applyMixins idea and made it into a lib. Maybe that works out? Seems like it allows for both inheritance and function composition which is great. Php's traits work really well and this seems to be inspired by them. https://www.typescriptlang.org/docs/handbook/mixins.html https://github.com/michaelolof/typescript-mix/blob/master/README.md
Yes it is. Click the link next time: https://www.udemy.com/typescript/?siteID=.XqkIVhyVYw-6sAPmvvGOlUN.SmnTgM1wg&amp;LSNPUBID=*XqkIVhyVYw
There's no way to access the course for free. You have to pay with your data. &gt; - Market and administer surveys and promotions administered or sponsored by Udemy; &gt; - Learn more about you by linking your data with additional data through third-party data providers or analyzing the data with the help of analytics service providers; &gt; - Identify unique users across devices; &gt; - Tailor advertisements across devices; &gt; - Improve our Services and develop new products, services, and features; &gt; - Analyze trends and traffic, track purchases, and track usage data; &gt; - Advertise the Services on third-party websites and applications;
In a .d.ts file that would just be type Tiles = Array&lt;number&gt; or just type Tiles = number[] 
The main difficulty in writing decorators is that you can't augment your types so all your types need to be defined in the decorated class. Also if you have it enabled, the linter may throw errors if your variables aren't initialized in the body.
Oh, so you mean like the rest of the entire internet?
Any language with a type system strong enough has conditional types, even C++ (via SFINAE and template specialization), not to mention Haskell, D, Rust, Idris, Agda, Coq, OCaml... As for mapped types, it's a bit trickier. Technically, all those languages support mapped types as well. However, they do not by default have a notion of type-level dictionary/map, because, unlike JavaScript, most objects in these languages are not dictionaries. So you need to define a type-level dictionary and a corresponding runtime data structure first, and then you can define a mapping over its entries. It's a bit more clunky with templates than with builtin syntax of TypeScript, but surely doable, and probably more flexible. Strong macro systems, like those of D and Rust, make it much easier to define these sorts of transformations.
I haven't used Haskell for the last few years, but it can surely be used for back-end web development. The ecosystem may be not as mature (or, rather, as stable) as in other languages, because Haskell is a niche choice (I think among the largest players, only Facebook uses it). But the language itself is very powerful and is worth developing in. As for front-end, there's PureScript and Elm, which are Haskell-like (former more so than the latter), they are both good, but among the functional languages, ClojureScript is the most popular and well-developed choice. All of these compile to JavaScript.
Sadly it's not but TypeScript continually adapt and get better
The ecosystem for web backend is incredibly mature. I would have zero doubts about that. And among the largest players it's definitely not just Facebook that uses it, Microsoft and Google both use it. For front end Haskell itself works just fine (I am using it in prod as we speak) via GHCJS.
Thanks for clarification! I haven't used it for some time, and it's good to hear that things have changed in a positive way.
Ah damn. Should file an issue with expo then!
Your questions is awesome at showing how Promise is part of a wider, more general abstraction - monads. While the idea to use Promise for error handling might have some drawbacks (as mentioned in other comments), there are other data types that can be used exactly for that. The type is called Result (or Either) and can either hold a successful or failed result. Simillarly to Promises, you can provide a callback to do something with the result with either `map` or `flatMap` operations. If you'd like to learn more, I wrote an article about it on my blog: https://codewithstyle.info/advanced-functional-programming-typescript-functional-exceptions/ 
This feature seems to be great in combination with `readonly` modifier. Interestingly, TypeScript in strict mode allows me to do this: ``` export class Cat { readonly name!: string; } ```
&gt; Contributors will be rewarded with Mount Olympus token, MOT There's no upper **or lower** limit on the reward Fixed that for you. If you believe in your project, put up some cash to go with the tokens. 
I love it. Queue "Bitcoin was worthless once too!" argument.
Soooo you want free labor/ideas essentially?
Crypto is a scam 
Bitcoin was the first of its kind and only became worth something because it became a speculation object.
I was supporting your argument bud.
&gt; Queue Cue* (A queue is a sequence; a cue is a signal/prompt)
I like to imagine that they pop their arguments off of that queue later, when the moment calls for it. 
&gt; &gt; Olympus Labs team (olympuslabs.io) are bulding a decentralized marketplace for crypto-financial products (proof of concept already implemented in form of crypto indices) as part of the Project Hermes update and are looking for proposals, ideas and suggestions on how to make it more effective. &gt; &gt; Contributors will be rewarded with Mount Olympus token, MOT There's no upper limit on the reward so it all depends on the creativity of the suggestion and ease of implementation &gt; &gt; I have never seen this incorrectly used this way.
No it's not. It's just massively hyped and overvalued but it's not inherently designed to be a scam. They both just wind up the same way!
Now you're being ridiculous.
Stick the tokens up your butt and get out.
I understand that, but it's not exactly what I'm looking for. The data might not always contain page and author. One time you might have page and author as in my example above, but the next time it could be anything else. Maybe thisexample is a little better. interface SomeData { page: number; author: string; } interface SomeOtherData { isbn: number; someInfoObject: { layoutDesigner: string; totalPages: number; }; } const bookData: SomeData = { page: 1, author: "Someone" }; const book = new Book({ data: bookData }); book.data.page = "Some string"; //This should not be possible as page is defined as a number const bookData2: SomeOtherData = { isbn: 12345678, someInfoObject: { layoutDesigner: "Jack", totalPages: 323 } }; const book2 = new Book({ data: bookData2 }); book2.data.isbn = "isbn"; //This should not be possible as isbn is defined as a number book2.data.author = "Someone"; //This should not be possible as author is not defined in book's 2 data interface 
You want to use genetics I think class Book&lt;T&gt; { constructor({ data }: { data: T }) { this.data = data; } public data: T; } 
The point of types is to have a concrete guarantee of which fields etc. may or may not be present available at compile time. Here you are expecting the type system to infer types from data being handed to it at run time. Using `any` will tell the type system that anything can be in that position, the type system doesn’t look at any runtime code to make ‘intelligent’ guesses. If you have a finite set of interfaces then look at [tagged unions](https://blog.mariusschulz.com/2016/11/03/typescript-2-0-tagged-union-types) - you could maybe add a tag to help the type system know which interface you’re passing in.
Well all types are known at compile time, none actually get dynamicly generated or anything. It's just I want to give a developer freedom combined with the power of typescript. In reality the code is about a Modal, this modal is highly reusable and the data on that modal is can be different for each modal. I know I can just put any in there and be done with it, but that removes the power of Typescript. I could also do those tagged unions but then for each new Modal the developer needs to mess with the Modal file to add it in the union, I'd like to prevent that. 
Ah I see - then you probably want a generic. Where the developer has to pass in the type they expect to see in the data field.
Be really careful with a pattern like this. You can shoot yourself in the foot. const bookingSettings: BookSettings { data: { page: 50, author: 'Bob' } }; const key: string = 'page'; bookSettings.data[key] = 'oh no'; typeof bookSettings.data.page; // TypeScript assumes number, but it's actually string.
My team uses a generic definition. `abstract class Model&lt;DetailsT&gt;` Model has a constructor that takes one `DetailsT` and assigns it to the class as an element `public data: DetailsT`. Then all of our models extend that. Optionally, I suppose DetailsT could be fulfilled as any but I wouldn't recommend it.
No, it would not. The flag you probably think of is not one of the strict ones, but `noImplicitAny`. But that flag does not apply, as the type of the indexer is explicitly any.
Ah, right, missed that this was in reference to verticalellipsis' suggestion to use `[key: string]: any`. Carry on c: &gt; The flag you probably think of is not one of the strict ones, but noImplicitAny. The `strict` flag does enable `noImplicitAny`, though.
It does enable it? Good. `any` is evil in 99 % of the cases.
Are you able to post a complete code example in a Github Gist or PasteBin? I'm curious exactly how you're moving expression nodes from one SourceFile to another. I think I can give you a better answer if I can see the code. One super-hacky thing you can do: create an identifier that's actually not an identifier but prints some code verbatim. Something like `createIdentifier('2 + 2 - getNumber(w5)')`
Oh wow. That totally works! I will post a gist a little bit later so you can see what I'm doing, as it's very possible I didn't even articulate what's going on very precisely. What's actually going on with that `createIdentifier` hack? I'm now using it like: `ts.createIdentifier(exp.getFullText())`, where `exp` was the `Expression` from a different SourceFile that was not printing correctly. How does the TS compiler interpret it the right way, say if the `exp` was a `BinaryExpression`? Thanks a ton, you just alleviated about 6 hours of frustration.
&gt; How does the TS compiler interpret it the right way I don't think it interprets it at all. If you say that's the identifier's name, the compiler trusts you. Identifiers are valid expressions and they are printed by printing their name verbatim. So even if the identifier's name is totally invalid and would never have been generated by the parser, the printer will still do what it normally does.
Well, it doesn't make sense to have an uninitialised `readonly` field, but still TypeScript allows you to disable the check.
Pretty weird to use `Array.prototype.reduce.call(list, ...args)` instead of `list.reduce(...args)`.
Only reason I can come up with is if you really really want to make sure you're calling that specific function. imo, that's silly as you can't benefit from a more specific implementation up the prototype chain - basically harming flexibility. Of course it's a great way to show how JavaScript smart you are to just use it for no reason other than the plebians don't understand it. /s
I edited and expanded that it's actually bad and harmful practice to call `call()`.
Well the "!" mark only means "I have initialized this somehow, don't you worry about it, it is never undefined" to my knowledge. So that typescript stops checking it within the constructor. I don't think it provides any runtime check, just fooling the compiler. 
I have no idea what the heck this is but this is cool.
There's close to no content in this post. And there's no explanation why you'd want to opt-out of those tslint rules.
This is a very clever and useful idea. I imagine a ‘jquery for the typescript ast’ could result in some great new tools popping up.
You don't really need that, though. The TS compiler API is very good.
If it's not read by anything else, it might as well be plain text. They're using their own parser, so they could just as well call it `tsconfig.typescript-json-file`, as it's not read by any official JSON parser with any official JSON parsing standards. Don't matter what the file name is, as long as you aren't trying to read it as a file that it's not. If no other parser is reading it, you're good to go.
It's not, I bring up JSON 5 in my comment and point to the source...
I'd say if you only need the tsconfig to be used by tsc during development, go wild. The default tsconfig generated by `tsc --init` already uses comments.
I apologize. I fleetingly responded because I've regularly run a freshly-generated tsconfig thru a JSON5 to JSON converter I'm order to help 3rd party tooling (ie. FuseBox). I'll shut up now.
Considering `tsc --init` constructs the file with comments, you should be able to use comments too. Anything that doesn't parse the file with comments will most likely fail on many projects as the default behavior is to generate the file with comments.
You mention that Typescript use their own parser for the config file, but isn't it JSON5 compatible? Reading over the feature list at https://json5.org it sounds like they cover all the examples you mention (trailing commas, comments). It's possible they have their own parser so as not to have any dependencies.
OP is asking if they should expect any other parser to read it at any point in the future.
It's JSONC (Json with comments). But like has been already said. It's their own parser, it doesn't fuckin matter.
It's basically JSON with comments, nothing that I'd consider so scary as to rename the file extension. File extensions don't have a 1:1 mapping with parsers. Remember they could've called it \`ini\` and basically put anything they liked in it, even automatically executed code \(see Microsoft for more there\).
That's really up to OP, isn't it?
I just copied the example from JSON5 and ran it through the Typescript parser. Here's a short list of unsupported features from JSON5: Not Supported: * Object keys may be an ECMAScript 5.1 IdentifierName. * Strings may be single quoted. * Numbers may begin with an explicit plus sign. * Numbers may be IEEE 754 positive infinity, negative infinity, and NaN * Additional white space characters are allowed. Supported: * Strings may span multiple lines by escaping new line characters. * Numbers may be hexadecimal. * Numbers may have a leading or trailing decimal point. * Single and multi\-line comments are allowed. So not *quite* JSON with comments like I said earlier, but it's not so different.
Yes, use comments as much as you want. `require('typescript').parseConfigFileTextToJson()` exposed TypeScript's config parser for any third-party libraries who care to use it. As far as I've seen, it's understood that tsconfig files usually contain comments.
Sorry, I should have been more specific. I meant that a JSON5 parser would be able to parse tsconfig files, not that the parser from the Typescript code would be able to parse arbitrary JSON5 files. 
I agree with this. To add, I've had a case where I need to turn off a setting so a dependency would play nice and added a comment so I know why that setting is off moving forward. 
You need to ask the TypeScript what the intended format actually is, and which format they are going to adhere to in the future. 
If someone in your team is using an IDE like webstorm for example. It will probably have a built-in validator for json files. So this people will open your file with comment and will have loads of errors. Not really cool for new comers in the team.
Solid writeup, fumbled my way through this a while ago, something like this would've been quite helpful
Cool but any realistic project will use webpack/etc. And there's still no way for webpack/etc to generate a nice typings file for you yet :S
JSON doesn't support comments which makes it unsuitable for configs. Comments are often supported where "JSON" is used for configuration. Pretty annoying, really. Crockford really screwed this up. Omitting comments was a huge mistake.
you're making the assumption the author is writing a front-end package. His approach is perfect for node packages.
FYI - after doing some more searching, this is close to what I wanted https://github.com/google/ts-style
I guess you're right my bad.
I thought JSON was supposed to be a machine\-to\-machine transport format, which incidentally was also readable by human beings. Humans writing JSON to be consumed by machines is far from what Crockford was thinking when he came up with the format. Now, at the time XML existed, and so he did know that machine formats would eventually be used for configuration, thus he excluded comments from the spec so as to disincentivize its usage as a configuration file written by humans.
I gotta say, I love how frequent these updates are. This is nothing like the old Microsoft.
But even if you are making a library for the front end, should you distribute it bundled into one .js file plus .d.ts files, or should you leave it as separate js and d.ts files and let the user of the lib bundle it when they bundle their whole app? Also another thing which I've been trying to figure out lately is should TS libs expose their contents via a index.ts file which imports and then exports the classes etc from the other source files? That seems to give the best results at the moment. 
I'm new to ts and was going to dedicate today to learning this concept, but this popped up on my feed and I learned it on my morning deuce. Thanks! 
&gt; Humans writing JSON to be consumed by machines is far from what Crockford was thinking when he came up with the format. http://json.org/ First paragraph: "It is easy for humans to read and write. [... It] uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others." He didn't include comments because he feared that some people would abuse it for directives and things like that. https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr People have done exactly that and it caused compatibility issues. Very funny, Crockford. Very funny indeed.
I can really only speak to back-end, but TS libs shouldn't actually contain any `.ts` files at all. Only `.d.ts` files. Is that what you're asking about in the second paragraph? Like if you should leave the typescript compilation down to the application?
I'm very interested in a runtime where TS is a first class citizen instead of transpilation 
No, that is not quite what I'm asking. It is more about bundling. My question is: Which is preferable? 1) compile .*ts to multiple .js + .d.ts files and distribute the .js and .d.ts files. (We assume that the end user will bundle the lot with their app via one call to webpack.) or 2) compile .*ts and bundle the result into ONE big bundled .js file plus one or more .d.ts files. In the second option, the `main` field in `package.json` points to a single file and that file must export the contents of the lib. (i.e. an index.ts may be used to import and export the rest of the lib, it would be compiled to a .js file and distributed). A lot of big JS libraries distribute multiple bundled and minified .js files using different builds and bundling options. But it is not clear what TS libraries should be doing. 
Oooh partial type argument inference
Its still built on V8, so I'm not sure how it doesn't use some transpiling.
Hmm that's probably true, in that case I wonder how it differs from using something like [ts-node](https://github.com/TypeStrong/ts-node)?
I'm still not sure of my comment. Does v8 consume javascript or some kinda bytecode like java runtimes?
Eagerly waiting for it.
&gt;When V8 compiles JavaScript code, the parser generates an abstract syntax tree. A syntax tree is a tree representation of the syntactic structure of the JavaScript code. Ignition, the interpreter, generates bytecode from this syntax tree. TurboFan, the optimizing compiler, eventually takes the bytecode and generates optimized machine code from it. https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775
Seems like a good opportunity to have better concurrency. 
One thing at a time, mate *No pun intended*
Is there a need for this? I've never found typescript build times to take very long.
It uses transpiling, more precisely the TypeScript language service from what I can see: https://github.com/ry/deno/blob/master/main.go#L95 https://github.com/ry/deno/blob/master/main.ts#L49 https://github.com/ry/deno/blob/master/runtime.ts#L219 https://github.com/ry/deno/blob/master/runtime.ts#L185
Neat. I sincerily believe TypeScript + Node is the future of backend. I can see it being dominant in 10 years, maybe sooner.
I've been surprised Microsoft hasn't jumped on this earlier.
Why not just use Graal ?
thank you ryan for choosing typescript and not flow
If it had run-time types it would be a lot more interesting, otherwise yeah you can do this already with ts-node.
super cool
Focus would appear to be on having a more secure runtime option. Specifically, being able to have a runtime for running your code that doesn't need network access or filesystem write. &gt; File system and network access can be controlled in order to run sandboxed code. Defaults to read-only file system access and no network access. Access between V8 (unprivileged) and Golang (privileged) is only done via serialized messages defined in this protobuf, this makes it easy to audit. To enable write access explicitly use --allow-write and --allow-net for network access Since it uses his https://github.com/ry/v8worker2 as well and given the example, the main use case would seem to be as a typescript runtime to use from go, one that you can use more securely (and efficiently) than a full instance of node because of the sandboxing and improved Go binding layer.
Could you give an example of a use case for this? 
Presumably, whatever Ryan's creating that's using this. "I have a running Golang program and I need to securely and efficiently run some typescript code in a sandboxed runtime". Since he didn't just use V8/node, presumably the sandboxing and efficient message passing are important enough for his needs to have made v8worker2 and deno.
Whenever i start a "real" project i always pick TS as a default, with strict mode. It catches so many bugs, and the dev exp. is sublime. This goes for backend with ts-node, and in the frontend with webpack. As a bonus i can share code on the back and frontend. On the backend i dont event compile to js first, i just run ts-node with trasnpile-only option.
This is completely misunderstood OP. You can't run a different language on V8. 
I hope they don't add too much more because it's gotten past the point where I understand what they're doing now. Just fixing up the limitations and problems would be enough going forwards. The language has enough already.
This appears to be more of a sandbox than anything else. There is also https://github.com/AssemblyScript/assemblyscript which compiles a subset of TS to web assembly. 
Not a thing that Microsoft would benefit from. If they were to do something similar, it would be a Typescript to IL compiler, to run it on the CLR.
Until JS can scale across cores and do multi-node clusters the way Elixir/Erlang can, I don't think so.
But it means there is no runtime types, right? like kotlin on jvm? or Java generics.
Honest question: what advantage does built in scaling have over load balancing across separate instances?
I will use it definitely, I like the package importing, as a Chinese, download repo from npm in terminal is not a very good experience, this feature will makes the life easier. The sandbox and the executable are good for desktop app. Thought the size will be significantly big. 
Off hand? Zero downtime without losing state. I guess you could replicate it with having all your instances talk to redis and rabbitmq, but when you can scale vertically and horizontally with redis/rabbit built into your runtime you get some nice reliability :) Also being able to have 50000 websocket connections on a 1gb DO VM is nice.
What do you use for testing? I'm killing myself trying to figure out globalSetup/teardown in jest using typescript as my tsconfig doesn't allow any js
Interesting. I tried learning Elixr a while back, but there were a number of things that really bothered me about the language. Something about lambdas and named functions being highly disparate? I made a gist describing all my pain points, I’ll have to look for it. As for different instances vs a parallelized single instance, I think if single jobs need significant parallelism, then Elixr sure. But if there are many different independent jobs that all need a small amount of computation, load balancing is certainly not worse, right? In those cases can’t we get away with just running 32-64 typescript processes on that one CPU?
I try to have as pure functions as possible, all mutations that are neccessary (the functions that do not return anything) i usually keep in a diffrent file and i dont even bother testing them becuse its pointless. Just edit them with caution when needed. All pure functions are tested and i usually go with mocha, so i can run my tests in pure typescript via ts-node.
Hey, saltupz, just a quick heads-up: **neccessary** is actually spelled **necessary**. You can remember it by **one c, two s’s**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hmm ya, going with jest is probably not the best bet seeing as Facebook hasn't really adopted ts yet. I'll check out mocha
I really wish flow and typescript would somehow combine forces. TS has already won the typed js race, having two options just slows down progress. I totally get however if someone else hates TS and loves flow! To each its own i guess...
Flow has better inference support. It's essentially "I want type support without doing any work" and if you're already using babel it's plug and play. That probably makes a lot of projects easier to migrate than ts. Starting with ts is the better option imo though. My days of writing js are over
I definitely read the announcements and often don't know what any of the new features are, but sometimes I'm going to leave a comment that something will improve type inferance or error checks and I'm happy.
Actually there is Node-like software based on ChakraCore. Not sure how active it is though, probably abandoned - but they tried.
The new features added are meant to allow for expressing the oddities of various javascript libraries as best as possible. Which allows you to include typings written by someone else, that make you more productive. So I have to strongly disagree with what you are saying. Anything they can add that makes types more accurate and flexible, are very welcome. If you don't need them for expressing types in your own code, then don't.
Ryan Dahl gave a talk at JSConfEU today about “10 things I regret about node.js”. Really nice honest talk about the things he would do differently now. My sense is that deno is an experiment in what could be done by learning from those lessons. 
I really love Erlang/Elixir. I have not yet had the chance to build anything real with it though. The beam is best suited for heavy soft realtime apps, and most apps are crud, so node is a good option for that. Last time i checked the elixir deployment story eas kind of weak. Maybe its gotten better in the past years...
That's fair enough, V8 is a javascript engine. I suppose my text could be improved, but it's Ryan that's calling it a "TypeScript runtime", not me. :\)
I opted for the 1st one, even if Microsoft tslint rules discourage it. In my current setup it makes more sense. Method 3 and 4 will probably allow a better tree shaking... Although `namespace` is preferred over modules ( https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html )
My preference would be for top-level exports in a module file: // helpers.ts export function helperMethod1(): void {} export function helperMethod2(): void {} export function helperMethod3(): void {} // main.ts import { helperMethod1 } from './helpers' helperMethod1() If a module system isn't available for whatever reason, the object (fifth option there) would be my next preference. Reason for both being, it aligns most with how it would be done in normal JS, and using a class for it seems unnecessary.
repost? https://www.reddit.com/r/typescript/comments/8nk87m/announcing_typescript_29/
I wouldn't consider TS to be approaching enough until it can adequately type the most depended upon package in NPM (lodash)
There are other options * Just export functions - there is no need to make everything an object in JavaScript * Use a DI framework - if somehow you like OOP and want to isolate side-effects for testing or whatnot, so you make helpers injectable
This is what I do for the tree shaking.
I don't see any reason to prefer namespace over modules in the referenced articles.
 &gt; A note about terminology: It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with ECMAScript 2015’s terminology, (namely that module X { is equivalent to the now-preferred namespace X {).
That's referring to the syntax referenced being preferred, not that concept of modules vs namespaces
It's actually the opposite. They recommend modules for new code &gt;&gt;Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism
It's actually the opposite. They recommend modules for new code Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism 
I was talking about syntax indeed... Where did you found this ? 
Same link - https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html 
This is more than just another `ts-node`. What Ryan Dahl is building actually skips node entirely. And he’s making backwards incompatible changes that address some of the regrets he had about how node was built. Particularly around requiring and package management. I was at JSConfEU this last weekend where he introduced it. Here are the slides: http://tinyclouds.org/jsconf2018.pdf Pretty excited about this. 
my diagonal reading skills aren't that good ;\) I missed that one, thanks pointing it out... 
In the first example you write: &gt; There is no way to guarantee that your property is going to be on the source object. But actually the compiler **does** emit an error, if you enable sane options in your tsconfig: &gt; Element implicitly has an 'any' type because '{ a: number; b: number }' has no index signature.
These "squared letters" are not a problem of Unicode. They are valid code points. The problem lies in the font you are using to display them. If your font does not support the unicode code points you are genrating, they are displayed as "squared letters". Best way to avoid this is probably to define ranges of code points your font supports. and then just generating in these ranges or converting your random number to a number in these ranges.
So even if I see them only as boxes they are actually valid character kind of things? Don't you know of a font that would be able to show all Unicode characters correctly?
Compiled so many angular hello world applications
There is none. The font with the most unicode characters I know of is Arial Unicode MS. But this is not a free font - even if it comes with most Microsoft Office installations, I believe. There are a ton of fonts each covering different code points. The official recommendation for when you have to cover a lot of subsets is to use several fonts and switch the font according to your target code point... But... the real question is - why are you trying to make a unicode password - the troubles you now know are probably the reason why there are none :) Like I said: use a font with a good coverage or lookup the coverage of the font you are using and keep the ranges in that.
Wonder if it does non-divergent forks, too.
This is really interesting! The title is a bit misleading though. You _parsed_ 1,000,000 files, not compiled. There is no typechecking, code generation, module resolution etc.
Hey /r/typescript – I've been working on a Bitcoin/Bitcoin Cash library written in TypeScript, and I just released the first production\-ready feature: a WebAssembly version of Secp256k1, the digital signature and verification system used by most cryptocurrencies. You can find more details and benchmarks at the link. If you're interested, please watch/star the [`bitcoin-ts` project on GitHub](https://github.com/bitjson/bitcoin-ts). I'm also happy to answer questions here. Thanks!
"Magic string", that is a fancy way to say "variable name".
This is just a small experiment, so I don't care how well it is applicable in real life. Thank you for your help :\)
actually, just for you - here is the exact count: 2536 my two favorites are: ["Environmental Disasters Goggles"](https://github.com/ArchangelX360/EnvironmentalDisasterGoggles/blob/master/frontend/src/app/app.component.ts) and ["ya sé cambiar la tontería esta del título"](https://github.com/Agfeynman/2DAW-Entorno-Cliente-ejercicios/blob/master/Tema7/AngularTesting/holaAngular/src/app/app.component.ts) and this is the selector I used: `ClassDeclaration:has(ExportKeyword)[name.name=AppComponent]:has(Decorator PropertyAssignment[name.name=selector][initializer.text=app-root]) PropertyDeclaration[name.name=title]:nth-child(1):last-child`
I thought it was obvious, but it's worth pointing out that modules are recommended over namespaces, without a doubt. The issue is having a build system that can deal/parse them &gt;&gt;Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html 
Could someone explain to me the Redux prescription of basically inverting typical OO style, and not having the methods on the Redux state object itself?
What a waste.
&gt;What a waste. Sorry, not sure if I follow. What do you mean?
Sure, I think the answer for why reducers are described in terms of actions/action creators as opposed to the other way around is that a goal of Redux is - like React - to represent a series of pure operations on immutable data, and produce some new data out of that. Actions being serializable JSON makes things like time travel debugging (rewinding and replaying the Redux store state) super simple to implement: just reload an old snapshot of the store to go back, or play back actions (dispatch them to the store) to go forward.
Waste of time, waste of energy, waste of electricity, waste of resources, waste of the environment. Bitcoin is a horrible, horrible pollution-causing delusion. 
Thanks for sharing, I was worried you had an issue with my implementation.
Fuck, why didn't this exist six months ago? I had to manually create TS type annotations for like the entirety of the bcoin library.
Couldn't agree more, I'm happy I am seeing more and more sensible people relating to cryptocurrency and the complete uselessness it provides us and the atrocious waste of resources it consumes. However I think its cool somebody did something with typescript :D
But am I wrong to say that whether your functions are in a separate file, versus on the object itself, is just a syntactical and ergonomic difference to you, and not a logical difference? That's just name-spacing. You are still operating on data in a functional, unidirectional style.
😂We should have [worked together](https://github.com/bitauth/bitauth/blob/master/lib/src/vendor/bcoin.d.ts). Note, I wanted to get something valuable and stable out as quickly as possible, so this is very far from replacing Bcoin. It's currently just Secp256k1. Though hopefully we'll be able to slowly build out the rest of a more purely\-functional, well\-typed library over the next few months.
But.. but.. it's money! And banks are bad, it's free of banks! Future money! Fuck capitalism, hooray bitcoin!
Depends on a context of your task. If you're creating a set of helper functions, then use simple functions, no need for name spacing. But if you're creating factories and you want to know the context behind the function, then I prefer option one.
Hey r/typescript! Just some background; I raised this issue over a year ago and I find it to be really obnoxious in my own TypeScript projects, but I understand that the team has some reluctance to really discuss it till more people weigh in. To that end, I'm posting this here hoping to get a better read on the temperature for what I perceive to be a flaw in the enum implementation. Also, if there's a better workaround I haven't thought of, please let me know! Thanks!
I can see your point and how it could be useful, though I've personally never felt the pain, but you have to ask yourself - if the Typescript team could only work on a single issue until the next release, would this be it? 
Well, for me personally, I'd say 'yes' :) I do understand -- thanks for weighing in. I just find it hard to believe that only 13 people have this frustration
Personally I'm not a fan of any sort of bare words being converted to strings. It's an anti-pattern in most languages that allow it like Ruby. I'm not too familiar with React+Redux, but couldn't you just assign your enum values to a string representation of a number? It's not elegant in most languages, but it seems to be a pretty normal idiom in JavaScript to do stuff like this, hence why actions are denoted as strings. 
Yeah, I need to try that again, clearly. Thanks
Yeah, like 1 week ago... 
I think the solution to this may hide in: enum test { A, B } type stringenum = { [K in keyof typeof test]: string }; A helper function would compose an object to use in place of the enum from the enum itself.
Really useful. Thanks for the submission :)
You can see an example with the [Mario](http://debug.elm-lang.org/edit/Mario.elm) example in Elm's time-traveling debugger. The motivation for making Redux actions plain objects is the same as in Elm: plain objects can be serialized, rewound, replayed, etc. In the Mario example you can play the game, then use the debugger to rewind, change the `physics` function, and replay the same set of actions to see how code changes play out differently with the same series of actions. I have not actually used any features in my own projects that require actions to be serializable. But it is nice to have things like the time-travelling debugger available, which open up new possibilities that would be impossible magic without a functional, immutable design. On the other hand if you want to manage state in an object-oriented fashion I think that [Unstated](https://github.com/jamiebuilds/unstated) is nice, and it works quite well with Typescript and Flow.
You're welcome, more articles are coming :) 
To summarize the click bait title: Set `module`=`esnext` in your tsconfig file to allow webpack to recognize the dynamic import statement for code-splitting. 
Btw TS is going to support "composite" projects starting from 3.0, see Anders Hejlsberg's talk at TSConf 2018 here [https://youtu.be/wpgKd\-rwnMw?t=3294](https://youtu.be/wpgKd-rwnMw?t=3294)
Ryan talked about it a bit during his recent talk https://youtu.be/M3BM9TB-8yA?t=998 /cc /u/Rhyek 
This reminds me of [redutser]( https://github.com/wkrueger/redutser) although this seems more flexible but maybe a bit more complicated. Good see new projects poping up in redux+typescript scene. 
I've changed it to a `function` instead of `const` declaration, since it's more idiomatic. But here you go. function toggleInSet&lt;T&gt;(xs: Set&lt;T&gt;, x: T) { (xs.delete(x) &amp;&amp; xs) || xs.add(x); }
I wonder, why is the function keyword for idiomatic for generics in TS? I've always preferred the other means of defining a function in JS.
OK, I though let's just do that. To be honest it took be a bit longer than it should have to make it all go, so I've decided to wrap it up in a library and thow it on npm: https://github.com/paulkoerbitz/resolve-types It's tiny, but it seems like more than one person wants to do this so theres no harm in packaging the solution. Thank you very much for the inspiration.
It's idiomatic because it's commonly used. If you don't like it, here you go. const toggleInSet = &lt;T&gt;(xs: Set&lt;T&gt;, x: T) =&gt; (xs.delete(x) &amp;&amp; xs) || xs.add(x); 
Hi r/typescript! About two weeks ago I posted a link on how to use dtslint for testing type operators. That approach had a few drawbacks. u/AngularBeginner had a great comment on he used type typescript compiler API to get the resolved types of some type definitions. This works much better with existing test suites. It took me a lot longer than it should have to throw together this solution, so I decided to wrap it up as a library and put it on npm for the next guy. Here it is. All credit to u/AngularBeginner for the idea ;)
This is a great post! You inspired me to write another one that goes into a little bit more detail about how to effectively use dtslint: [https://medium.com/@danvdk/testing\-types\-an\-introduction\-to\-dtslint\-b178f9b18ac8](https://medium.com/@danvdk/testing-types-an-introduction-to-dtslint-b178f9b18ac8)
thanks :)
Thanks for the warm words! I think your post takes this a lot further - very nice!
Don't use a `class ` unless you want it to be instantiable with `new`.
AFAIK it's not possible, but I've often wondered...
I've found Immer to be the best solution for immutable updates with Typescript. Not a collection library but it's even better as it uses just regular js objects. https://github.com/mweststrate/immer
Sure, you're welcome. :-) I'll make sure to check out your version later and see how it performs.
looking at your example, i would say that you should use a plain typed JS object, using object spreads to add items to it? // definition const m = { foo: 1, bar: 'a' }; // adding elements const m2 = { ...m, baz: -1}; // removing elements const {foo, ...m3} = m2; that's gonna be 100% fully type-safe. I don't know about having super-precise key types for "general-purpose" maps. What you want is pretty much a static object it seems to me, compile-time known, so JS objects seem a nice fit to me. regarding immutable.js loose types, I felt the same frustration (well, for me it was more about its awkward types, and yes sometimes weak types too), and I also wanted an Option type, so I wrote a [typescript immutable collections library](https://github.com/emmanueltouzery/prelude.ts). It does have a `HashMap` but in this case I don't know if I would advise it. Reading from it would return Option&lt;number|string&gt;, because it doesn't know if the key's inside, so in fact it's even worse for your than the immutable.js one :-)
[monolite](https://github.com/kube/monolite) if you don't need to target browsers without Proxy support (no IE.)
Generics are absolutely the correct solution but there's an alternative, pretty gimicky method as well: type ElementTypeOf&lt;T&gt; = T extends Set&lt;infer E&gt; ? E : never; function toggleInSet&lt;T extends Set&lt;any&gt;&gt;(xs: T, x: ElementTypeOf&lt;T&gt;) { (xs.delete(x) &amp;&amp; xs) || xs.add(x); }
You are right, my usage of the Map() type is silly. Somehow I got confused into thinking that the spread operator prevented structural sharing... which it doesn't. Then I guess the real advantage of using a library for immutability would only be when dealing with large arrays (where a naïve immutable array would have catastrophic performance vs. a clever implementation) ?
well i mean in my example, m, m2 &amp; m3 don't have structural sharing, they are completely duplicated objects. it's just that the spread syntax lets us get a copy-with-a-change easily. so yes if you use the spread syntax for objects &amp; arrays, you get convenient copy-and-modify, but: 1. as you said, performance will be poor for large number of items (as in runtime, and memory use) 2. in the specific case of dictionaries, when using javascript objects, the key can only be string, number, boolean. A library like immutable.js or my prelude.ts can take any object as key, as long as it has `equals` and `hashCode` methods. So you can have like a `HashMap&lt;Customer,List&lt;Invoices&gt;&gt;` 3. this is probably less important in the case of typescript, where we have strict null types, but I think it's very appreciable if a library has the `Option` type, so you can do for instance `map.get(key).getOrElse(-1)` and so on. 4. obviously a full-blown library can offer much nicer methods than what you get in plain JS, and all tuned for immutability in mind. If you decide to go with the standard JS structures, you must always be careful that you or one of the members of the team won't start using mutating methods, like Array.push or `delete` on an object. it's just, in general, if you're going to have a large collection that you'll change frequently, you're not going to track the types as you expected in your original post. In real-world code, you'll very quickly have `if`s and loops and external inputs, and it's basically intractable for the compiler to statically determine what values are or are not in the map.
If you want JS objects but with Immutable.js's benefits you should take a look at the [`Record`](https://facebook.github.io/immutable-js/docs/#/Record) type instead of `Map`. Make sure that you use the latest RC (v4.0.0-rc.9), it has _far_ better TS definitions than v3.
https://github.com/emmanueltouzery/prelude.ts
Read literally any of the other comments on this post.
TIL `infer`
I've been using [icepick](https://github.com/aearly/icepick) and it's been working well for me. I wrote my own [typings](https://github.com/tscholl2/cookbook/blob/master/frontend/typings/icepick.d.ts) so that I could get the docstrings to appear inline in VSCode. There are still places that could be improved, but it's been working well. Like some of the others mentioned, it also acts like plain js objects.
Indeed, the Record type is what I should use in my example above. But even then, it does unexpected things: "Records always have a value for the keys they define. removeing a key from a record simply resets it to the default value for that key." :/
How would an immutable Record type achieve better structural sharing than regular objects? If you have a nested structure like this: const m = { foo: 1, nested: { bar: 2 } }; And you "update" your state with the spread operator: const m2 = { ...m, foo: 2 }; Then they both share the same instance for `nested` right? Therefore, assuming your state is deep enough (so you avoid having too many references to copy at each level), you should get similar, if not better, performance than what a library could offer. This is what I meant above, and also that this argument doesn't hold if you have arrays. Other than that, I think I would favor your library over immutable.js, because it's actually written in TS, and also because I feel like development on immutable.js has been quite slow (they've had v4 in release candidate for over a year now!)
I don't quite buy the programming model they offer. You are mutating something but not really... I find it harder to read than code written in a more traditional approach.
Yeah, kinda agree as it is bit magic, but it is the only tool I've found so far that doesn't sacrifice type safety or isn't too verbose (spread hell). So I think it is good enough trade off for now. 
hmm well nested updates get ugly pretty quickly. immutable.js has [setIn](https://facebook.github.io/immutable-js/docs/#/setIn) for that purpose, others uses lenses for that purpose. Aside from the question how to do these nested updates, in terms of performance, when you update a nested value, you must copy the parent object too. but it's really not a performance concern in the end: for such records you're not going to have 10.000 fields. It's really more a concern how you're going to achieve it without too much verbosity (through setIn or through lenses). Except if you really do video games and have a budget of live 20ms to compute a frame or something, these kind of things are not worth worrying unless you really have 1000 of values in your container (object or otherwise). But yes, nested updates get pretty ugly pretty fast in terms of API. Note that immutable's `setIn` work on normal objects too, not only on their records. As for myself, I would check lenses first, but honestly so far I didn't hit that issue yet. And yes, frustration with slow development on immutables.js was a factor for me too.
What? Bitcoin inherently supports capitalism.
No license, and thus not usable by anyone.
package.json specifies AAL as the license. 
I see, I did not look there. I'd still expect a license file in the repository.
As much as I hate littering LICENSE files everywhere, agreed. 
Will add one 🙂 thanks for the feedback!
How about this? class EndObject extends BaseClass implements A, C { // error: type EndObject does not satisfy the constraint "B" public prop = new PropRequiringB&lt;this&gt;(); You have to pass the generic param, but you use `this` so it always looks the same and shouldn't ever require refactoring. EDIT: better yet, you're going to pass a reference to `this` to the prop, right? So you can pass `this` to the constructor and bind the generic that way. public prop = new PropRequiringB(this);
I kept adding useful one-line type declarations to a markdown file on GitHub, until I finally published it to npm. Most of these are purely typed -- no runtime overhead -- but a few have a runtime component. This will be an identity or no-op function, so it compiles down to `function(a) {return a}`. These shouldn't be a problem for any VM to optimize or minifier to compress or remove. A very notable omissions is `DeepReadonly`, `DeepPartial`, etc. I know various implementations have been posted here and there; I need to find a good one and include it.
I believe you can import them from the file: ```ts import { oneType, twoType, RedType, BlueType } from ./types ``` You can also rename the file to just `.ts` or `.tsx` and use it as a module, exporting the types from that. Can you show me how you're trying to use the types?
Some really clever stuff in here mate, nice work. Not sure when I would use half of them but good to know that they are there regardless :)
That is one of the common answers I see, and it doesn't work. It's never worked once for me. &gt; (1,28): File '.../src/components/types.d.ts'is not a module. is what I get back every time I've tried that. Same if I change it to `.ts` or `.tsx`. Still not a module. This is exactly what I'm frustrated about. // types.d.ts declare interface ThisType { firstPart: string[] } // Header.tsx const Header = (props: ThisType) =&gt; (&lt;div/&gt;); Pretty basic use of types I would think, but there doesn't seem to be anyway to actually do it that gets past BOTH ts and tslint, unless I want to define every type in the file that uses it (which means dozens of lines of duplicated type declarations, which would obviously be stupid). The only thing that has ever worked was `/// reference`, but react-ts complains about that. *shrug*. I'm about ready to just give up on Typescript completely.
You don't need to `declare` those types, you should export them. "Declare" is used in an external module setting where you're trying to define types for other module that doesn't exist.
It’s terribly confusing to figure out how all of this works the first time. I spent many hours trying to figure out how to provide types for a library whose @types were out if date and wrong. 
You only add type definition files for NPM packages you use that don't include their own type definition files, and who don't have a type package on DefinitelyTyped (@types/...). For the types you want to create for your own code, you create files wherever you want in your source code and export the types so that they can be imported by your other source code files that need to use the types. People generally fall into one of two styles: * Put types in their own area of your source code, and import them everywhere else. * Put types next to the parts of your source code that use them most directly, exporting them so that they can be used by other parts of your source code if necessary.
Are you writing .d.ts files by hand? Tsc will generate those for you, and you only need to do that if you need to expose your types (library, npm package, etc). When your dealing within your own code you just import `import { OtherClass } from './Other class.ts'
Just built an API using tsoa for generation, but it has a few issues around model definition not accepting Pick or Partial interfaces. Maybe this will work better? Anyone used it?
Just to be clear; are you trying to create a custom type for an existing js module without typings? Otherwise, you should not use a .d.ts file, nor the declare syntax. 
//lalala.d.ts export interface Blabla {}; export enum Blehbleh {}; // app.tsx import { Blabla, Blehbleh } from “./lalala”; interface Props extends Blabla { ble: BlehBleh[]; } ;)
You should add a LICENSE file..
&gt; Only Type where Necessary Be sure to **always** explicitly type variables that are initialized with an object literal. Do not use the inferred type here, that's just bad practice.
Yep makes sense for object literals, but the post talks about a different example where Typescript can actually infer the correct type.
&gt; where Typescript can actually infer the correct type. TypeScript infers the correct type when using object literals. It's just not the type you want.
 The particular error message you are confused by suggests to me that you should read https://www.typescriptlang.org/docs/handbook/modules.html "In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module. Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well)." However, as others here are saying, it also sounds like you don't need a .d.ts file at all.
The problem with the *no inferable types* rule is that you push your specification into the inference engine rather than your program. If inference changes between versions, the specification of your program changes. Omitting annotations also makes it harder to read code in plain-text. I think there is a balance; personally, I'm against blanket rules like this.
Export all the argument types functions e.g. `ArgumentNType` seems quite verbose. Is it possible to export a single type that accepts a number literal type `N`?
Oh yeah! Good idea, I'll add that. I think I'll leave the others at least for now, just in case. I'm still not 100% sure how and when conditional types affect performance. I've written a few in other projects that tanked performance of the language service and I want sure why.
Yeah conditional types seem slightly unpredictable perf wise, at least for large ones. Though, you can do this without conditional types: ```ts interface ArgumentType&lt;Fn extends (...rest: any[]) =&gt; any&gt; { [index: number]: {}; 1: Argument1Type&lt;Fn&gt;; 2: Argument2Type&lt;Fn&gt;; 3: Argument3Type&lt;Fn&gt;; 4: Argument4Type&lt;Fn&gt;; } type GetArgumentType &lt;N extends keyof ArgumentType&lt;any&gt;, Fn extends (...rest: any[]) =&gt; any&gt; = ArgumentType&lt;Fn&gt;[N]; type X = GetArgumentType&lt;2, (x: string, y: number[]) =&gt; boolean&gt; ```
Why?
Should I make them zero-indexed like the arguments array? I really don't want to, but I'm open to a second opinion. I can't think of a good use-case where that would be important.
Will do. In the meantime, it is / will be MIT.
This is a very primitive example, but it describe the issue: interface Data { data: string; value: string; } function getData(): Data { const result = { data: 'data', value: complexSlowMethod() }; return result; } Assume that `complexSlowMethod()` is a method that aggregates the data for `value`. The type of `result` is inferred to be `{ data: string; value: string }`, it is **not** inferred to be `Data`. Now when returning `result` the TypeScript compiler will check if the type of `result` is compatible with the return type, which is the case. Sounds okay, so far. But if you later decide to remove the `value` property from `Data`, then the code will continue to run just as is. If you're explicit with the type of the variable `result` by writing `const result: Data = {..}`, then instead the TypeScript compiler will complain: `Object literal may only specify known properties`, so the TypeScript compiler supports you and tells you about an unknown property, about (potentially slow) code that can be removed because it's not needed anymore. If you infer the type, compatibility is just checked, and it's compatible. By being explicit TypeScript will support you in eliminating unwanted properties.
I see your point, but it seems like a valid tradeoff to not type result and just return a compatible type. It totally could be that you have extra keys that are expensive, but my experience is that it is rare and it’s hard to enforce explicitly typing on every object literal with an interface.
It just leads to dead unnecessary code that no one has a sane overview over anymore.
That’s fair, I wonder if it’s possible to use conditional types to create interfaces that disallow extraneous types.
I’ve done something like this. I use yarn workspaces though, but for the TS part, you need a root tsconfig that covers all code within subpackages. That’s how you get your editor to properly see everything. Then in each subpackage, you can extend a base tsconfig and properly sets paths relative to that subpackage. This allows you to go into a subpackage and run tsc. You can opt not to have per package tsconfigs but you will lose some flexibility and may have trouble with the relative paths. 
Yes essentially conditional types are super powerful.
I see, can you generate an individual out dir per package?
Import everything directly into that file from a and b and export from there. What you want is export * from “../a” Which I think is being considered but not standardized.
In my experience, now that we have string literal types, string enums have fewer use cases. I rarely see string enums being used heavily in TS code. I think the biggest reason is that string literal types have the most idiomatic translation to regular JS while enums do not
I don't think so, at least not in any reasonable manner. The issue is that you're fighting against a fundamental rule in the type system that lets you provide more information than necessary. To get a decent solution you really need `Exact` types that turn off subtyping.
What the root tsconfig does in ours is generates a directory with each subpackage as a sub directory. With multiple tsconfigs, you can do it per sub package.
Gotcha thank you
You might have a "base" tsconfig and extend it using other tsconfig files - see extends property of the tsconfig options. Then the rest should be easy. tsc accepts an argument called --project which expects a path to a tsconfig file. 
It was actually easier to set up Babel 7. Thanks though
Except that you don't have type safety if you are not first using typescript but that is of course a matter of decision. 
Eh I have a tsconfig.json in the project root with noEmit=true, and running tsc in the terminal works perfectly. And VSCode still shows type errors so
I wouldn't trust vscode since it sometimes cannot show errors before you open a file. Seen this behavior many times. What's is more one's code doesn't always get packaged in an IDE environment. I get my packages packed using CI tools for instance. So vscode displaying errors is of no help there. I wrote "if you are not using typescript first" but obviously you are since you mentioned tsc running fine. Problem solved I believe. 
Basically: - If you're typing an untyped npm module, use `d.ts` with `declare module`. - If you're trying to add types that are globally available, use a `.d.ts` anywhere within the project scope. You may have to reference it in your `tsconfig.json`, I'm not sure. I don't think so? - If you're trying to create a module of types (as you would "regular" code), then just add them to any `.ts` file and export/import like you would anything else.
It's confusing because the documentation is garbage that assumes you already know the answer to your question.
No. I'm trying to define types that are used internally to MY OWN PACKAGE. I have a large block of data that is passed down the react component tree as props. I'm trying to define the types of that data.
I read that, and it is entirely orthogonal to my question. This is what I mean about the documentation being garbage. It just doesn't answer this (fairly basic) question, and instead assumes you already know this before moving on to other, more complex issues. I have data being passed as props down the component tree that should have a fixed type. I'm trying to define the type(s) of that data and then use it in a dozen different components.
The second option is what I want to do, but that solution doesn't work, or is incomplete.
This is what I needed to do. Now it works. Thank you.
Try `global.d.ts`. I just realised that's the only filename I've used for option 2.
 export * from "../a"; export * from "../b"; export as namespace myNamespace; There's always that, but it makes `myNamespace` a global entity.
Then just do that using a regular module? Why would you need a type definition file for that? 
Good article but I am not adding webpack or similar tool so I can have short relatives paths in server side code. It is fantastic for client side code and pretty easy to set up. I wish they would add a feature so it could transpile `utils/config` to `../.../../utils/config` but I don’t think ts will ever implement this. 
You wrote: "Same if I change it to .ts or .tsx. Still not a module." I linked to the specific documentation and even quoted the section that explains whether a file is treated as a module or not. I'm sorry you are frustrated, but thousands of other people find the documentation adequate.
Just use regular typescript. .d.ts is ONLY for adding types to existing js libraries. You should never use them if you are writing new code. Just write normal ts. // types.ts export interface ThisType { firstPart: string[] } // Header.tsx import {ThisType} from "./types"; const Header = (props: ThisType) =&gt; (&lt;div/&gt;); See? No declare, and no .d.ts. 
This looks great! I was thinking of this feature as _variadic generics_ after C++'s variadic templates but from my understanding it has the same functionality. &gt; With these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists (such as JavaScript's `bind`, `call`, and `apply`). I see it says that it's _possible_ to strongly define `bind` et al. Will TypeScript actually change the definition for these functions? It will greatly improve the safety of the language but I fear it will break many existing programs. Arguably these programs are already broken without knowing it, I hope they don't shy away from making the change.
Is "make it a flag and default on" not an option? There's already a few tsc features that, when turned on, cause existing applications to produce compiler errors. Seems there's value in the feature and precedence for a flag as solution.
Sorry, I didn't reply! While TypeScript doesn't provide any static checking of the `arguments`array I prefer 1-based. Anyway, it's easy enough to provide a zero-based wrapper later.
For option 2, create your `.d.ts` file, like you already seem to have done, and then make sure the compiler can find and includes the file. Assuming a layout like: ``` tsconfig.json src/*.ts ``` (I.e. a project root with your TS configuration and a `src` directory with your source code (including the `.d.ts.`)) In your `tsconfig.ts` add an `include` section: ``` { "include": [ "src/**/*.ts" ] // other configuration omitted } ``` That will ensure the compiler can find the definitions which will then be globally available. If you like to keep your definitions outside the `src` directory, just include all paths in the `include` array and you should be fine.
pretty cool mate
So unlike the Typescript Quickstart for Node.js this doesn't automatically setup a template engine, password with facebook, and a bunch of other unnecessary things?
Tiny but very useful library my boss wrote. I use it all the time. Great for Redux reducers. 
I can't figure out what the use for this is. It says it saves a line, but it seems to me, you can just take the entire `case` out and not even use a library. It seems to work even with `strictNullChecks`. I don't get it.
you can use paths: https://youtu.be/hO7mzO83N1Q?list=LLDmHNdr-U0RcaVqt-ICIQ7Q&amp;t=2662 https://stackoverflow.com/questions/43281741/how-to-use-paths-in-tsconfig-json 
This is a library of one function, with two short statements. This should be a blog post or a tweet, not an npm package.
This looks like it could really help out with some of my project ideas. I'll keep it in mind :)
Maybe of time more useful functions will be added.
Pretty cool of your boss to share this with the public.
The function doesn’t really do anything, but that’s not the point. What makes it useful is the typing. It ensures you don’t forget any of the possible cases. If you don’t handle each of the cases, you get a compilation error. Hence the name. 
Can you reproduce this compilation error? I can't.
Have you tried removing one of the cases from the example?
Yes, I did, like I said in my initial comment. To be excessively clear, here's the complete code I'm using. interface Square { kind: "square"; size: number; } interface Rectangle { kind: "rectangle"; width: number; height: number; } interface Circle { kind: "circle"; radius: number; } type Shape = Square | Rectangle | Circle; function area(s: Shape) { switch (s.kind) { case "square": return s.size * s.size; case "rectangle": return s.width * s.height; case "circle": return Math.PI * s.radius * s.radius; } } console.log(area({ kind: "square", size: 10 })); No package dependencies. No compilation errors. Great.
This is a variant of a function I've simply written in every code base. Definitely not worth adding yet another dependency. And using `JSON.stringify` for something like this is fairly silly. The data structure might not be serializable.
I like this. I'll definitely be using it.
Yeah but that doesn’t transpile correctly for node unless you use webpack or another tool. 
I highly appreciate it. Thanks
Your example is relying on exhaustive switch checking, but you might have a switch that is just collecting data but not returning. In this case you won't know if you've missed a case: declare function assertNever(x: never): void; function collectBad(s: Shape): void { // No error for case we forgot to process switch (s.kind) { case "square": break; case "rectangle": break; } } function collect(s: Shape): void { // Good switch (s.kind) { case "square": break; case "rectangle": break; case "circle": break; default: assertNever(s); } } function collectSafe(s: Shape): void { // Error caught! switch (s.kind) { case "square": break; case "rectangle": break; default: assertNever(s); // Circle to of type never; } }
It wasn't my example. It's from the repo. Weird choice since it's unnecessary in that code. 
You are not using the exhaustive check. Of course it compiles. The whole point is to make it NOT compile if you miss a case. If you don’t care about handling all cases, you don’t need this lib. 
Sorry, you're right -- I didn't mean to miss attribute.
I too found TypeScript really tedious and hindering to start with. My first eye-opener was turning "noImplicitAny" to false. It really helps the flow of the code get going. Now, I never even consider doing a project without TypeScript, it's just so extremely fast and easy to write. It's also a dream when handing over a project, fewer hidden bugs and really easy to read once you get used to it. 
Couldn't agree more! The amount of possible bugs drastically went down just by switching to typescript... And the debugging is way easier!
Could you explain a little bit more? Normally I heard the reverse advice, which is to relax constraints as much as possible, and gradually add typings.
I'll copy my comment from there here if someone has something to add: It makes sense on larger projects in the long run. I have been working on a Node + React app for almost a year now, there are around 4 programers in the team on average (there were some changes in the team structure a few times) and I can't begin to describe how happy I am we are using TS. A lot of new functionalities the client asks from us involve adding or refactoring something in a controller you haven't touched for a month but someone has possibly refactored it completely, or reusing a complex component with around 20 props that you took no part in developing. And from experience, the more specific the types were in the code (no any, or Object, or Function without parameters and returns defined) the easier and faster I could write the new feature. And if the task was a bug fix, half of the time somebody somewhere wasn't specific with the types and another person made some wrong assumption on what something is and the thing propagated God knows where and caused some unpredicted behaviour. And yes, we had typing issues, around once a month we add something larger to the project or do a major package update, but losing that 1-2 days of a single persons time to fix the typings (or write our own) and possibly refactor something is a lot better than losing around 3-4 days of everyone's time on finding an error that could have easily been avoided or noticed earlier by using types. 
To the down-voters, I posted this primarily to show just how clueless some people are. Anybody that refers to "silly ... errors" emitted by *any* programming language, probably needs to find a new craft.
Noimplicitany and strictnullchecks are a must. Without them, you might as well use js. 
I agree with you - I want to love TypeScript but it’s frustrating to even set up with any tools in the React ecosystem, let alone use. I’m trying to use the TypeScript with common React tools &amp; it fights me every step of the way due to lack of documentation or Typescript-friendly version of tools. I'm convinced no one has ever successfully set up, say, a basic (unejected) Create React App + TypeScript app with basic tools such as Jest, Emotion/Styled Components, and Storybook. Something that should be so simple with the vanilla Create React App. 
When I first started using strict = true, I have also disabled that. It definitely strikes a good balance between practicity and some type checking. On the other hand, you can't trust regions of your code and imports get silently typed into any. I think noImplicitAny = true is a good starting point, but later you should move to a stricter setting.
Copying my comment: I wouldn't expect Ionic to be hard to get on typescript, since Angular is a lot simpler in terms of typing (OOP). ( ... ) On the other hand, React on typescript definitely feels quite immature. The type system itself is still lackluster for some of the heavy inference cases of React (mostly HOCs); You rely on 3rd party typings that sometimes are not first-class for the developer who wrote the lib; The language is constantly adding new features to address item 1, yet the 3rd party typings have to follow up. Also, DefinitelyTyped has no thing like a "type definition TS version target", which makes things even more messy.
`create-react-app my-app --scripts-version=react-scripts-ts` gets like 90% of what you mentioned working out of the box. Do you always spout uneducated opionions without doing a quick google search? 
One thing that's interesting is: as a library author, how strict are you going to make your public interfaces if you also want your library to be used by ES users? For example, let's say you have a public method like this: publicMethod (someValue: SomeInterface) { /* ... */ } Now, if `publicMethod` is to be called from a TypeScript codebase, this is fine. However, since it might be called from a Javascript codebase, you might want to also check whether `someValue` is not `null` or some other unexpected value. Would you then update the public interface to be publicMethod (someValue?: SomeInterface | null) { /* ... */ } ? Or would you do a cast inside the implementation, then do your assertions to get it back to `SomeInterface`? Or would you not do the cast at all and simply add the assertions and hope you don't forget any?
What I like most about TS isn't just the type declarations (I don't mind the occasional `any`) it's the forced consistency. I come from statically typed languages which tend to be a lot less multi-paradigm than JS. Ten random C++ or Java projects will look more similar to each other than 10 JS ones. I find there's just too many ways to write JS and that's not a good thing for a shared code base. By having types you start by writing data models and contracts first, I find this makes code stylistically more similar which is great when you don't want to say 'who wrote this? Ah Steve so everything is tiny functions inside a model. Oh this part is Jane's code and she uses ES6 classes'
Damn it, this is strong excuse to for me to learn ts.
Respectfully, I've done more than a quick google search, I'm talking precisely about how `react-scripts-ts` doesn't play well with things. It doesn't come with `babel-plugin-emotion` out of the box. Or `storybook`. In fact the wmonk User Guide instructions for setting up `storybook` is incorrect. Have you tried implementing those 2 things properly? Let alone without ejecting? I've experienced countless babelrc issues with it playing nicely with the `ts-jest` config that comes with `--scripts-version=react-scripts-ts`.
I would let it pass, and do sanity checks in dev mode at a deeper level. For example, in Python basically no one does type checking at the interface level for a library.
The compiler can still just do it for you. noImplicitReturns would catch that with zero extra code. I can now imagine where it would be useful. I just don't think the given example is one of those cases. 
I would not specify null unless the consumer _should_ be able to pass null. On a public API layer, null checks should happen and probably throw an exception or log out a warning that nothing will happen (on void return functions) but the rest of the private codebase shouldn't need them as the compiler pretty much guarantees state (as long as strict null checking is enabled!)
Right, I don't think I'd specify that in the public interface either. I'd like to make it explicit internally that we _can_ expect `null` and other misdeeds, however, so I guess I'd opt for an internal cast?
No, I'd handle it at the public api layer - fail fast, fail early and keep the internal codebase clean.
This is actually great news! I'm an angular guy because of TypeScript. I'd love to see more competition. This coupled with the endorsement of TypeScript that Ryan Dahl just gave makes me really happy. It's the only logical way forward. Dynamic language is here to stay, especially for web-projects. And JavaScript does it best. Add an optional type-safety layer on top, to act as IDE support and mini unit-tests is just common sense. With the optional benefit of creating pretty decorators and things like implementing common programming paradigms. Looking forward to the release!
This is great. One of the reasons I left Vue was TS seemed like an afterthought and it was a real pain to get it working. Hopefully now that it's a first class citizen, the TS support will be much better.
Have you used [vetur](https://github.com/vuejs/vetur)? I haven't personally but I know they guy that makes it and the demos I've seen look very neat. 
Just do it. If you have any experience in any strong typed language you learn 80%of it in 20 minutes
Do we know if there's any word on timescale for the 3.0 release?
If you have the latest VS2017 along with ASP.NET Core 2.1, you can create an Angular project (In VS) that has everything setup to be able to use Angular CLI.
I haven't tried the angular template inside VS2017 yet but my preference is to maintain 2 separate projects. One for the front-end (angular in VS Code) and one for the back-end (asp net core web api in VS2017). If I ever felt like I needed to switch back-end technologies like PHP Slim or Python Django or Ruby Rails or Java Spring. I can just throw away my old back-end and switch it out with another one. That should be one of the advantages of a SPA. That your front-end and back-end are decoupled and not so tightly coupled that you need to rewrite the whole thing.
I plan to only have the web application project as I am still learning.
The vs2017 angular template has a very steep learning curve to it, it does both server side and client side rendering, hot module replacement, disabled on save typescript transpiling in favour of webpack instead. It’s a very good template but not for beginners imo. You’d be better off learning angular first in visual studio code, when your comfortable with that, learn webpack. Once you’re comfortable with that, then have a look at the vs2017 template
Pass your `IState` as the second generic argument to React.Component.
That works! Thanks!
Typescript is after transpiling pure JavaScript. You need to validate data by yourself or use libraries. 
I have generally been doing that, but what I'm trying to do now is be able to pass an interface / class as a generic type parameter to another class, and have that class be able to validate some JSON using the type parameter somehow. I'm sort of getting the feeling this isn't possible in TS.
You can write a user-defined type guard function that manually checks the properties of the object to determine if it has the properties of the interface.
You can use [io-ts](https://github.com/gcanti/io-ts). It works well.
Yes that is what I was saying. When you run your code it is not TS anymore,it is then pure JavaScript. Imagine TS is just like a comment. Everything you declare typescript specific will not exist in runtime. 
As long as you implement that command. Don’t let the program run you, while you smile.
You can try this: https://github.com/typestack/class-validator
Class validator and class transformer.
Thanks, will have to check this out!
What's the first generic parameter?
Props i believe -- `React.Component&lt;Props, State&gt;`
Here's my recommendation: JS -&gt; TS -&gt; Framework 95% of TypeScript is just normal JavaScript, the rest is learning how the type system works and how to use the tooling around it. On frameworks: it doesn't really matter which one you start out with, since most of them have a lot in common nowadays (components, one-way dataflow, reactivity of some kind). If you want something easy to start with and pick up, go with Vue. Vue also works well with simpler setups that have less build steps; you can throw a script tag on a page and roll with that, if that's your thing. If you care about the size of an ecosystem with lots of support/tutorials, go with React. React is my personal favorite, which happens to work especially well with TS. If you want a cohesive framework with lots of functionality and conventions out of the box, go with Angular. A lot of people aren't a fan of rigidly having to do things "the Angular way", but for some, it's nice not having to make all of the architectural decisions yourself. Others, feel free to correct me on any points here, or add anything that's worth a mention.
You *could* learn first TypeScript, but I think it might be hard to come to JavaScript to unlearn some TypeScript features. TypeScript is more than just adding types to your JavaScript code, but it is made so that you can slowly progress integrating it's features. You can use the TS config file to tell it to accept normal JavaScript files for example. Basically use a TS config file that allows you to start with less strict features. Quoting the TS site: &gt;TypeScript starts from the same syntax and semantics that millions of JavaScript developers know today. Use existing JavaScript code, incorporate popular JavaScript libraries, and call TypeScript code from JavaScript. That means you can learn JS and TS at the same time, just make a note in your mind what is TS. **Disclaimer**: I love TS, specially for big code bases.
Thanks, I was looking into Vue since it reminded me of Flask since it seemed less opinionated and easier to start with. Wasnt sure how well it worked with Typescript. React and Angular sounds cool, I suppose it might come down to what current good projects or guides I can find that use both a python backend and JS frontend that I can learn from. Ill definitely focus on learning JS first tho thanks!
Ill definitely have to focus on learning JS first, sounds like the right way to go about it thanks!
I used to be mainly a Python programmer (before I moved to *mostly* JS), I love Flask and Django! Vue will probably feel easier to understand since you have "templates" and you can separate the code/controller into another file. I usually like to do something like this in my \*.vue files: &lt;!-- here is the template --&gt; &lt;template&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/template&gt; &lt;!-- here is the code --&gt; &lt;script src="./component.js"&gt;&lt;/script&gt; React instead feels more like code and template together, and Angular gets a bit complicated too. Don't get me wrong I love them all, but Vue is easier to start with in my opinion. Integrating with an API (in your Flask backend for example) could be as easy in Vue as a `fetch` in your component code.
The Angular [Tour of Heroes](https://angular.io/tutorial) gives a pretty good walk-through of what a Typescript/Angular project can look like. If you'd like to see a personal code base with a working example you can check out [my project's codebase](https://github.com/jmcdo29/zeldaPlay) and [corresponding web app](https://zeldaplay.herokuapp.com]. 
Assuming you have read the official TS documentation, it will be easier if you provide what you understand and which part you don’t understand...
The main draw of Typescript is that it allows object oriented practices like classes, inheritance, and interfaces that pure JavaScript doesn't understand. Then it compiles into pure JS and runs with no problem. It also allows for more declarative typings, meaning when you say `const name = 'some string'` you will not be able to later assign it the value `508` because it is not a string. Really helps you from assigning bad values to your variables and makes your code (usually) run smoother.
JavaScript is loosely typed; programmers do not declare a type when defining a variable. TypeScript is a strongly typed superset of JavaScript. Here are some bits from a book I'm reading. [The Essentials of Object-Oriented JavaScript Programming](https://www.amazon.com/Pro-JavaScript-Design-Patterns-Object-Oriented) &gt;The interface is one of the most useful tools in the object-oriented JavaScript programmer’s toolbox. The first principle of reusable object-oriented design mentioned in the Gang of Four’s Design Patterns says “Program to an interface, not an implementation,” telling you how fundamental this concept is. The problem is that JavaScript has no built-in way of creating or implementing interfaces. It also lacks built-in methods for determining whether an object implements the same set of methods as another object, making it difficult to use objects interchangeably. Luckily, JavaScript is extremely flexible, making it easy to add these features. 
[joi](https://github.com/hapijs/joi) worked fine for me, last time I needed that (you'll need to add `@types/joi` too, though). 
I've found JSON Schema invaluable. There are tools that will convert a TS interface to a JSON schema. You can then validate using the schema.
\&gt; when you say const name = 'some string' \&gt; you will not be able to later assign it the value 508 \&gt; because it is not a string. You will not be able to later assign it to anything, because it is a const. 
You're totally right! I should've used `let` instead. My bad
No, you shouldn't have, becouse TSLint would go all "You should use const for variables which are never reassigned" and I'm like "I DIDN'T EVEN HAVE TIME TO REASSIGN IT, I JUST FUCKING INITIALIZED IT". Anyway...
There really is no point in learning js as a separate language. Ts is just js, but with a compiler helping you avoid mistakes. And I do not agree with enabling ts features one by one. The great benefit is having all the safety checks at once. And learning how to code in js *without* types is a big hurdle in itself, since you need to rely on your own discipline a lot. Having the types makes it *easier*, not harder. 
Been there, dealt with that struggle. VSCode helps with the line that makes tslint ignore that
Having the type to help you is amazing, and having a great ide like vscode is even amazinger. It will show you exactly what type everything is, and what they should be. 
But encountering the limits of not having static types in Javascripts helps you understand when to use them (and when not to) and what they bring you.
This is spot on, in my opinion. Not only is this the easiest way, but it will also help you get the firmest grip on what each technology brings you, and also what their limits are and when to use what. I might recommend `JS -&gt; Framework -&gt; TS`, or insert an extra step `JS -&gt; TS -&gt; JS+Framework -&gt; TS+Framework`, since setting up TypeScript with a framework can get cumbersome, though getting easier over time.
It gives you an appreciation of them, for sure. But there isn’t really any situation where you shouldn’t use types. 
In a similar situation (I was writing Java backends), I learnt Typescript + Angular. I didn't, and still don't, feel any need to learn pure JS as a task in itself. I've had to learn some aspects of JS that aren't covered by the usual TS manuals but not often enough to make it worth doing as an initial task. I went with Angular specifically because its opinionated. For what its worth I'm doing TS back ends now as well.
An appreciation, and you're able to use them better. So a situation in which not to learn types is: when working on a project in which you're learning JS, too restrict the surface area of things you need to learn, to know what is TS and what is JS, and to know where to add what kind of annotations.
http://lmgtfy.com/?q=typescript
In simple English: Typescript is almost the same as javascript, but it has some extra's. These extra's will make it more strict for you to prevent you from making simple mistakes. Example: In javascript you can only created untyped variables, meaning; variables that allow it have the value of type text, number, boolean etc. In typescript you can say: well this is my variable, BUT it can only be a boolean and nothing else. If you then try to say that the new value will be some text, typescript will say: "You said it can only be a boolean, so this is an error". There are a lot more rules you can setup for yourself which prevents a lot of errors and you having to check the type of stuff. Typescript in the end always compiles to normal javascript. So it's mostly helping you, the developer.
About restricting the surface area: I think there are a lot of non-ts specific stuff you don’t need to learn if you stick to ts only. Not that it really matters, since you should learn them booth in depth. 
&gt; it allows object oriented practices like classes, inheritance, and interfaces that pure JavaScript doesn't understand. Most of that is just **modern** javascript, not typescript.
&gt; Typescript [...] allows object oriented practices like classes, inheritance You can do that in JavaScript
Then just edit your first comment
&gt; Java Script Maybe learn JS first
What made you move to mostly JS, work? Seems like ill definitely be giving Vue a try in the near future, thanks again
Interesting ill have to keep that in mind
So do you think it turned out pretty good for you skipping learning JS by itself? Is Angular the best front-end to pair with TS? Seems like it is better integrated with ts vs Vue
I agree with this poster, as I'm just learning ts as well. I highly recommend Google ts style guide, the code formatting is a little weird but makes sense. It's essentially pair programming with someone who knows ts better than you 
I will Google that, never heard of it before now thank you
The possibility of writing code for the backend, frontend, desktop apps (electron), cloud, etc. without having to context switch between languages or tech, the re-usage of libraries in all environments, modern language features (even tho Python has some, it's not the same), development tools (hot module replacement, etc), vscode, typescript, the community and the many many npm packages (some Python libs are just outdated). I used to write some Python here and there, but now when I do I miss some things from the JavaScript world. 