I asked the same question as above, but what is the actualy difference between fat arrow and using function. I was always under the impression that they were the same, and fat arrow was just a shortcut.
A function defined with `function` has an implicit `this` which is set based on how the function is called while a fat arrow function does not get an implicit `this` so can use the one from an enclosing scope.
An arrow function maintains its parent’s scope. Traditional function is scoped to root/window. 
You can format code like this: \`\`\` codeHere() \`\`\` Or if you're in the "Fancy Pants" WYSIWYG editor, highlight some text, then click the "..." on the controls, and the button that looks like a "T" with a square to make a code block.
A classical function, as far as I understood, is an object and "this" refers to functions object. Arrow function is no an object an it refers to the class.
Is it ready to use yet?
Read up on lexical scoping. The fat arrow ensures the this pointer points to the class rather than the function instance
From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions : &gt; An arrow function expression has a shorter syntax than a function expression and does not have its own this, arguments, super, or new.target. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 
Maybe [that article](https://github.com/udebella/blog/blob/javascript/dev/javascript/2-arrow-functions.md) I wrote can help you understand better `this`.
Got there eventually. Still irritated that this seemingly-basic thing took this much effort to figure out. "lib": ["es6", "es2015", "es2016", "es2017", "es2018"]
I feel your pain. I had to install graphql and it needed special esnext Libs and when I would add them I would get errors like Boolean not found. Number type not found. One of the more annoying things about typescript is how configuration based it is, and the lack of documentation around that. 
I haven't used TS for about 12 months, and the documentation was basically exactly the same back then. Kind of surprised nothing has changed in all that time...!
Man I wish I hadn't had to use TS for the past 12 months. 
Very cool! In Angular, we handle these the Async-Ray case with Zone.js and the Promise all with RXJS.
I agree that Typescript configuration is too complicated, and is under-documented. I work around the lack of documentation by looking at the [source files](https://github.com/Microsoft/TypeScript/tree/master/lib) for the library options. &gt; I want to use ESNext. Why can't I just specify one thing to include all the core things in the TC39 ECMAScript 2019 specification? You can simplify your `"lib"` option like this to get the latest core language features: "lib": ["esnext"] The lib for each ECMAScript version automatically pulls in the previous version. You do not need to list every version. For example [`lib.esnext.d.ts`](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.esnext.d.ts) includes this line: /// &lt;reference lib="es2018" /&gt; And [`lib.es2018.d.ts`](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es2018.d.ts) has a similar line that references `es2017`, and so on. &gt; I don't want DOM references in my Node.js project but if I use the defaults, I have to put up with them. It seems like you already noticed, but if you do not specify a `"lib"` option then the default set of libs includes `DOM`. To avoid loading the `DOM` lib use a `"lib"` option that does not include `DOM` or `es6`. For some reason [`es6`](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es6.d.ts) automatically includes `DOM`. `es6` is the one ECMAScript lib that is not automatically included by the other years/versions. It looks like Typescript's `es6` definition does not add any core language features, only iterable interfaces for DOM types, support for WebWorker imports, and the Windows Script Host API. Once in a while I see an awkward reminder that all of this was written by Microsoft 😛 &gt; And why is there an explicit promise option for each different ES year? There are actually only two promise libs, [`es2015.promise`](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es2015.promise.d.ts) and [`es2018.promise`](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es2018.promise.d.ts). The 2018 version just extends the 2015 version to add the `finally` method. Oddly `es2018.promise` does not include a reference line to include `es2015.promise`, so you will not get the result that you probably expect if you include one without the other. But as long as you include either `esnext` or `es2018` in your libs you will get both promise libs automatically.
You can just set "target": "esnext" in your config to get all the supported definitions for ESNext, right? From the [documentation](https://www.typescriptlang.org/docs/handbook/compiler-options.html): &gt;If --lib is not specified a default list of libraries are injected. The default libraries injected are: For --target ES5: DOM,ES5,ScriptHost For --target ES6: DOM,ES6,DOM.Iterable,ScriptHost They don't list what --target esnext does, so had to [check the code](https://github.com/Microsoft/TypeScript). I think this is it: // tsserver.js:12412 case 6 /* ESNext */: return "lib.esnext.full.d.ts"; case 5 /* ES2018 */: return "lib.es2018.full.d.ts"; case 4 /* ES2017 */: return "lib.es2017.full.d.ts"; case 3 /* ES2016 */: return "lib.es2016.full.d.ts"; case 2 /* ES2015 */: return "lib.es6.d.ts"; // We don't use lib.es2015.full.d.ts due to breaking change. default: return "lib.d.ts"; You can find these definition files in `/node_modules/typescript/lib`.
Note that `esnext.full` (and the other `.full` variants) include core features, but also DOM, Web Worker, and Windows Script Host APIs. These are for when you want all of the type definitions available.
Isn't there an option to just provide esnext? "lib": ["esnext"] 
Glad you're liking it. I've been using TS for about 10 months now and I found I went through a lot of phases as I ramped up on it. There were times when it made me ecstatic, and times it made me want to punch my monitor. There's definitely a learning curve and lots of frustration when you get into more advanced types. I'm still learning and so still find myself getting frustrated at times. But overall it's incredible and totally worth it. I'll never start a plain JS project ever again now.
Try SonarTS on a somewhat large project and you'll see the real awesomeness.
I've been using it for 6 months, and for 6 months i have wanted to punch my monitor. Here's to hoping it passes. At least I have some smaller cli tools in vanilla js to keep my sanity in check.
What are your biggest pain points? &amp;#x200B;
Looks cool, will try it!
Here's some in no particular order: - error messages are terrible and unreadable - interfaces and types are poorly designed in that they overlap completely over the problem spaces they try to handle. Should i use an intersection type or extend an interface? or create an interface that extends a type? How are they even meant to play? - void type is poorly named. We already have the void keyword in js. Why not nil? Who thought overloading a keyword was a sane idea? - language libs are configuration based. If i want to use Object.values i need to change target or add libs? but then it breaks something else in my code and then i need to change typescript versions? kk cool beans but that makes no sense. Either support language features or do not. - Idiomatically OOP - Lots of valid js is deemed incorrect in TS or causes errors. Promise.all of arrays of different types, or promises and not promises create warnings i cant get rid of, [].concat.apply creates warnings so i have to use Array.prototype.concat.apply because it assumes a never[] in the first case. Really dumb to infer that but ok. - The nail in the coffin: typescript is typed but not typesafe. Who knows at the io-boundaries of your application the data is what you typed it to be? Makes debugging programs really hard to understand what the problem is when subtle changes in data occur. The types are basically semi reliable documentation that lets your editor go vroom vroom. - debugging is less reliable. Variables will sometime be unaccessible because they have a new name, or the line mapping is off. Anyways I am sure i could go on. But at the end of the day, I think we are throwing away one of the best dynamic languages out there for one of the worst static languages. Typescript is basically vroom vroom juice for your editor, and a trap if you think it makes your code actually better.
I found that turning off a select few of the compiler options made it way easier to build prototypes/smaller apps in. I’d recommended playing around with the tsconfig until you’re happy.
I made it as strict as possible, or else I find it has the least worth. But it makes it very frustrating. This is the joy of ts.
checkout [https://github.com/LeDDGroup/typescript-transform-jsx](https://github.com/LeDDGroup/typescript-transform-jsx)
Yeah, I'd like to see an implementation too. I realized today that because Iterables can only be used (iterated) once, they would really benefit from some kind of linear typing like rust has. I just have no idea where I should start to add this.
I agree with most of your post ( especially type vs interface, what the hell). However, I disagree strongly with the end. Even though, I kind of love javascript, it's an awkward language. Many dynamic languages are better than it. Python or Clojure, if you like the functional paradigm. Typescript's type system is also pretty great, it allows to express some advanced concept pretty greatly. It's also greatly tailored for js. Even the multiple pain points ( bugs, super complicated error messages, very slow compile time). And I'm not event benefiting from the vroom vroom part
I see a lot of your points. There is still room for improvement, especially in some of the error messages, but it's already so much better than blind JS where you have no hints at all in the editor, and you just have to constantly have the library's documentation open to remind yourself what order those function parameters are in, or what the name of that one property was. Interfaces vs types is just a preference really, since neither exist at runtime. What's the correct way? Whatever works best for you and your code. I personally use interfaces by default but use types for things like complicated unions or intersections. The flexibility isn't a bad point in my opinion; there's just more than one way to do things. JS is full of that isn't it? The configuration-based language support is because of the nature of web development - they don't know what browsers you're targeting or what is available, so you need to tell it what you have to work with. I don't know why you had to change TS versions to fix problems in your example, but it seems annoying. Still, it can't just "support language features or don't", because there's just too much variation in what your project could be targeting. Why use \`\[\].concat.apply\` when you can just use the spread operator? Still, you can always tell the compiler to shutup just by declaring something as \`any\`, which makes it work like old blind JS. Your nail in the coffin, TS is typed but not typesafe; what's the alternative? JS that is neither typed nor typesafe. How is that better? 
you have to set vroomVroom to true in your tsconfig. I don't know anything about clojure, but JS slays python. I mean sure, python has its place, and definitely a lot of great libs out there especially for data science and AI. But JS is excellent at currying and most things functional. It's got a top tier concurrency model, much nicer than python's GIL. But how do you emotionally get over the fact that typescript is not type-safe? I like how the types make it easier to refactor things in your code, but validation is much less common in typescript than in javascript, but just as necessary. And i don't blame people. I don't even validate as much as i used to, because its hard to decide to validate something when you told the compiler to tell you that it is of a certain type. But really, in a 100% of typescript programs, there are types that we defined poorly, places we got weak and returned any, and accidently typed it as the wrong thing, io boundaries that have changed slightly over time, etc. The type system is little more than unreliable documentation and editor power boosts. I can understand on the front-end you have little choice until wasm matures, but on the backend where i work, I find typescript as the language choice abhorrent. 
ok. Let me try and tackle this. One of the key characteristics of a well designed programming language is orthoganility of features. A features should not overlap as best as possible in the problem space they intend to solve. This way the developer only needs to focus on solving the problem not on which way to solve the problem. It also creates edge cases and misunderstandings, and leads to to developers not understanding your language well. In the case interfaces and types, they aren't exactly the same. I don't remember in what usage they weren't interchangable but they aren't the same. But they are interchangable in 90% of cases. So in some small but very real sense most developers don't know what they are doing when they choose to use "type" vs "interface". That is incredibly bad language design and not the fault of the users. Flexibility is the ability to change things ie malleable code, not the ability to write the same things differently. As for the configuration based development, I understand there may be a good reason for it being the way it is. In general i don't see it though, since you are transpiling down to es5. It should have most modern features available and transpile to the target you choose. Object.values, Object.includes, etc is ridiculous that you can't use them by default. They may have good reasons but it is still a giant pain point especially when the things are more obscure than those 2. [].concat.apply and the spread operator aren't interchangeable. there are still valid cases where you need to use the former. I was transforming a dynamic array of arrays into a single array. The spread operator isn't so useful when you don't know how many elements ypu need to spread. JS is a dynamic language. It doesn't offer type safety but it offers its own benefits. True flexibility, simplicity, no build steps, direct source code, and most importantly doesn't lull you into a false sense of security and bad practices. With JS you need to validate your inputs and your code, and you need to test things. With TS you absolutely need to do those things just as much as in JS because the types mean less than nothing at runtime. But people don't feel like they need to. So one could make a case that it is worse. Js is a great dynamic language, Ts is a mediocre static language. If you need a good dynamic language there are plenty to choose from. Typescript is a code smell.
You should try extending tslint:recommended then remove any rules you feel are too strict. Soon you’ll have a rule set you like. And your coding style will be more consistent. I always install tslint as a project dependency unless I’m just gonna hack together a quick test. I usually add it later on if I keep working on the project though.
Maybe you're right about those details, with types vs interfaces, configuration, and concat. Those are implementation details that can be updated with future releases. But the point here is that TS augments JS development; it is not meant to be a standalone language. TS would have no use if it weren't for JS. And my point is that it augments JS in a way that heavily speeds up development time. If your project is small, then it's overkill if you don't want to use it. But TypeScript shines brightly for large codebases. Refactoring is much easier than primitive find-and-replace. You find out immediately if you made a typo in a property name rather than at runtime, which reduces the amount of times you have to run the project during development (recompiling and re-running after fixing a typo is a huge waste of time). For integration with APIs, you create interfaces for endpoints, and if an endpoint changes, you just change your interface, and the rest of your code is forced to follow. But again, TypeScript is only meant to augment JavaScript -- and support applying types to all the crazy code structures JS devs have created over the years -- not be a standalone language. If you aren't targeting web platforms or something that needs JavaScript, then don't use JS or TS at all.
Tslint checks for things that typescript's compiler doesn't check. So I would check out the list of rules on tslint's website. If you don't need those things, you're fine.
TSLint extension for VS Code is about to deprecate. (See [https://marketplace.visualstudio.com/items?itemName=eg2.tslint](https://marketplace.visualstudio.com/items?itemName=eg2.tslint)) Use [vscode-typescript-tslint-plugin](https://github.com/Microsoft/vscode-typescript-tslint-plugin) instead. The latest can even lint rules that required type information. Very nice.
If you're using VSCode you can set it to use checkJs in settings for JavaScript and it will automatically type check your JavaScript for those basic type errors without having to write a line of TypeScript. You can read all about it in their documentation: https://code.visualstudio.com/Docs/languages/javascript#_type-checking. The days where JavaScript developers have to worry about wrong type returns or wrong parameter types for functions are long gone. And this does not require switching to another language like TypeScript, Flow, ClosureScript, Elm, ReasonML, etc. Most modern editors provide these features using type checking in the background through inference or by using the TypeScript language service in the background. I wrote an extensive article about how to have robust type safety for JavaScript using just JSDoc comments. This lets you write normal JavaScript that passes TypeScript type checking: https://medium.com/@trukrs/type-safe-javascript-with-jsdoc-7a2a63209b76
Tell me about your experience, if you like.
Typescript type vs interface, first hit on Google: https://www.educba.com/typescript-type-vs-interface/ (Skip ahead to the infographic, past all the article filler.)
Try Prettier before you add linting. Having the code automatically formatted is amazing. I no longer even bother with indentation or newlines. I just type and auto format. 
Prettier and Autofix on save is a given. I had it set as eslint rules before so alternating between that and the extension is kind of a pain but a good motivator to just stay in typescript land. 
Autofix looks scary. The sugested fix is usually not the correct one for me. What is your experience working with it?
I meant format on save, I can’t recall off ha d whether I have autofix on. If I remember correctly, it only auto-fixes errors with relatively objective solutions. 
&gt; With TS you absolutely need to do those things just as much as in JS because the types mean less than nothing at runtime. But people don't feel like they need to. So one could make a case that it is worse. If you think it's valuable to validate data at the boundaries of your app, you can choose to do so in both vanilla JS and TS. Some people might choose not to, and that's up to them and the context they're working in, but I'm struggling to see how this is some special critical flaw in TypeScript.
It's because that is the most common point where you lose type safety. In a truely static language, you would need to unmarshal the data into your type, and that could fail if the data is incompatible with your type. So in a truely static language, if you managed to unmarshal the data, then you know your variable is of the correct type and can base your program on that fact comfortably. If it fails to unmarshal it's because the data and your type are incompatible, and you know that you need to change the type. Of course JavaScript doesn't do any of this as it's not typed, but a set of good practices and validation has grown around that. In TS people write code like their types mean anything. You could of typed the return of the API wrong, the API could change in subtle ways. So really it's a criticism of people using TS like the types do anything other than unlocking ide features. It always boils down to js good dynamic language, TS mediocre static language.
Hey, davidmdm, just a quick heads-up: **truely** is actually spelled **truly**. You can remember it by **no e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
`**`
Delete 
&gt; truly static language That's a bit like saying that ES5 isn't a "true" object-oriented language because it uses prototype inheritance instead of class-based inheritance. While it certainly does things differently from languages like Java or C#, TS *is* a statically-typed language. That has its pros and cons. &gt; So really it's a criticism of people using TS like the types do anything other than unlocking ide features For sure, some developers will misunderstand, much like people with prior experience with Java get confused with prototype inheritance in JS. I don't think it's super fair to judge a language by newcomers being confused by ideas they haven't encountered before. &gt; It always boils down to js good dynamic language, TS mediocre static language. I think it boils down to what you want out of static typing. I want types to document the shared understanding of what kinds and shapes of values are present in data in the program, to provide rapid feedback for typos, and to make tooling more effective. It sounds like you're very interested in having cast-iron guarantees of correctness, which is fine (although it's not clear how your life is any *better* with vanilla JS on that front...), but not the only reason for having types.
If I am to trade in the expressive freedom (although bought at a price) of a dynamic language like js, then I want the type system to be well designed, and to ensure that the types I declare and the data being used at runtime coincide with the types I programmed. Otherwise the trade isn't worth it. I've heard people describe coding in JavaScript like playing with silly putty. Sure it's hard to have it keep its shape, but it's fun and lets you model tons of awesome things simply. Typescript is like playing with snow, if compacted right it seems really solid. But it melts in your hands. The type system doesn't do much more than upgrade your editor. 
This. &amp;#x200B; And the main point of TypeScript - avoid TypeErrors and give an application type-safety - are just wrong. I write JavaScript now for many years and what I can tell is, that if your JavaScript application (which for browsers is any front end application) is written by JavaScript Developers, developers, which know the language, TypeErrors are errors you encounter at least. And type-safety is gone after compiling with the TS compiler. So there is no benefit to use and learn a language if you can reach the same quality of code with other tools like linters.
That article is outdated, iirc the only difference in recent versions of TypeScript is declaration merging.
Too bad that TypeScript documentation generators are the opposite of awesome.
I voted "should respect tsconfig.json" but my true vote would be: I don't care, as long as it is documented and consistent.
Cool on both sides. I would prefer intuitive to documented. * Documented and unintuitive means I gotta look it up, at least once. * Intuitive means it just works as I would expect, which means less looking things up and more just working. Granted in this case, with a minor modification we could have documented and intuitive. That's the goal here.
I can't vote because I don't have Twitter, but the answer is: No, it should absolutely not change. That would be a heavy breaking change. Instead the should output an information about this when there's a tsconfig in the working directory present.
You should **really** use strict null checks.... Still amazed when people don't use it.
You realize it's all semvar. When you upgrade from TS 3 to TS 4 there are going to be breaking changes -- by definition? So we can ask how we create better more intuitive programs, and you can stay on TS 3 at the same time. ;)
&gt; You realize it's all semvar. You realize that TypeScript does not follow semantic versioning, right?
Didn't. Surprising. [It's even worse.](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes) Then break between minor numbers. Point being. Lots of breakage, seems arbitrary to state that a new flag `--ignore-tsconfig` would be the straw that broke the camels back.
&gt; would be the straw that broke the camels back It wouldn't. But it's overhead that is just not justified to create. It breaks numerous build environments, the added code must be tested and maintained, and the new behavior must be documented. This is **intentional** behavior. You either use the project format (the tsconfig) or the compiler CLI. And by my opinion it's not unintuitive.
&gt; to ensure that the types I declare and the data being used at runtime coincide with the types I programmed. What's stopping you from validating your data at your app boundaries? 
Ignore config. You're just transpiling a single file, not a project for which config is used for.
I mean I do my best to do so. But there could be a discrepancy between my validation and my types. I have to maintain them together in tandem. That by itself is a lot of extra overhead. Also even if I was super diligent, almost all typescript code I've encountered in the wild has extremely poor validation. And I don't blame the developers. It's hard to feel the need to validate something when you told the compiler to tell that it's alright here's the type of the thing. Especially when you are somewhat deep in your code and not directly next to the io boundary. The problem is that typescript parades around like a proper static language, and that's what people think they are using when they write typescript. Unfortunately that's not the case, and it would be better if people were aware of how poor of a static language it is, so people wouldn't rely so heavily on it. Typescript is one hell of a crutch. 
"I carefully validate incoming data in TypeScript, and then I'm really worried about that data not having the type I just verified it to have. That's totally a crippling flaw in the language. I much prefer plain-old JavaScript, where it's almost impossible to reason about the type of values anywhere in the codebase." Sometimes language design choices cause genuine problems. Sometimes things just irk us and we assign disproportionate importance to it.
I am less upset with flow because it depicts itself as just a tool to help structure your types in JavaScript. Typescript really portrays itself as this superset language with type safety and the new way to code js. It way oversells itself and has tons of drawbacks. It would be helpful if the TS community was able to acknowledge it and work towards better understanding of its limitations instead of blindly trying to reimplement dot net and patting itself on the back. 
Well... "intuitive" eventually is a matter of opinion. - "Well, I'm compiling from the folder from a typescript project, so obviously it should compile it according to the typescript project's rules." - "When I'm compiling the file from this folder, it compiles this way; when I run the exact same command for the exact same file, but from another folder, it suddenly compiles another way" What if you run `tsc ../other-project/my-file.ts`? Does it use `../other-project/tsconfig.json`? What if `../other-project/` doesn't have a `tsconfig.json` but the current directory does? Which one does it use then? What about `tsc tests/my-test.ts` when both CWD have a `tsconfig.json` AND `tests/tsconfig.json` exists?
Your concerns don't make a lot of sense when examined dispassionately. That's pretty much how most programming language opinions go, sadly.
Well if you want to play the opinion game, then that's just your opinion. 
&gt; In a truly static language, you would need to unmarshal the data into your type, and that could fail if the data is incompatible with your type. You can do the same in TypeScript. Are you just complaining that TS doesn't *force* you to do that?
How do you do that with TS, if you can solve it for me then most of my frustration with the TS is gone. Suppose I have a type T, and I make an HTTP GET request to some resource of type any, and want to assign it to a variable of type T, how can I make it fail if the underlying data does not fit that type?
If it's not clear it should show me a warning/error so that I could specify the one I want via cmdline option
There are libs to help out with this. You can try [runtypes](https://github.com/pelotom/runtypes), [io-ts](https://github.com/gcanti/io-ts), or [class-validator](https://github.com/typestack/class-validator), depending on your taste.
You might be underclassifying the scope of type errors. TypeScript speeds things up immensely, saving you time when refactoring, deleting unused legacy code, instant documentation, and in-browser error messages. Linters pale in comparison.
Io-TS seems to address a lot of what I don't like about TS, except you really need to commit to using their type system. Class-validator might warrant some looking into. Thanks for the information. 
No problem, good luck.
I don't use twitter, so I can't vote, but my answer is unequivocally: *Yes.* Why? Because I consider my a pretty experienced developer, while I am still somewhat inexperienced at typescript. Trying to help some person out on discord that was having issues, the fact that they were invoking `tsc file.ts` was the sole reason why their project wasn't compiling correctly and we literally went down all sorts of rabbit holes only to find some obscure github comment that mentioned this behavior. Incredibly unintuitive. 
Set the `noImplicitAny` compiler option to true in your `tsconfig.json` and you will have the behavior you would expect. It will disallow assigning null to types that do not have null as a union constituent.
Maybe you want to use the "--strictNullCheck" compiler flag. It is explained in https://www.typescriptlang.org/docs/handbook/basic-types.html under the "Null and Undefined" section.
Great read! Would you mind clarifying a bit your word choice for "asynchronous operations aren't inferred." You do a good job explaining that TS can't infer the shape of external JSON loaded from a server, but that's not really related to the fact that it's an async operation. Even a synchronous operation like accepting a manually-typed JSON string from a user would have the same limitation. Async operations can be inferred just as well as any other JS operation, usually as type \`Promise&lt;Foo&gt;\`. Maybe a better way to put it would be "Data from external sources aren't inferred."? &amp;#x200B;
&gt;the fact that they were invoking `tsc file.ts` was the sole reason why their project wasn't compiling correctly Does their whole project only consist of the one file? If not, then, well.. he was not compiling his project. He was compiling a single file in isolation, which is a different deal. &gt;we literally went down all sorts of rabbit holes only to find some obscure github comment that mentioned this behavior. Incredibly unintuitive. It's in the official documentation, under the section "using tsconfig.json".
&gt;Set the `noImplicitAny` compiler option to true You mean `strictNullChecks` (or `strict`). `noImplicitAny` is unrelated to this...
&gt; Does their whole project only consist of the one file? Just ask if a Perl Script just consist of "one file." And, then ask yourself what all those scripts that are in perl that get rewritten in TS? Yes. They're just one file. No not every or even most programs get rolled into "projects." As if everyone using TSC is using Visual Studios and rolls a project for everything. Do you work for Microsoft out of curiosity?
That's exactly what I was looking for, thank you very much! 
&gt; Do you work for Microsoft out of curiosity? Lol. "People don't agree with me so they must be MS shills." I don't work for MS and I gotta say the only thing I would change about tsconfig is rename it to `typescript-project-configuration-file.json` so people like you can better understand what the file does. Or, wait, no. Just can read the fucking manual: First Google search for "tsconfig", first paragraph: ```Overview The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways: Using tsconfig.json By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain. By invoking tsc with no input files and a --project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file, or a path to a valid .json file containing the configurations.```
This claims: "When inferring variable types, TypeScript takes into account only the line where the variable is declared. Other lines, where you might assign some attributes are ignored. Only the first line, no exceptions. " However, this isn't true. In this code: ``` function f() { let x = []; x.push(3); return x[0]; } ``` observe the return type of the function in the TS playground (with --noImplicitAny turned on): it is number, so the .push() affects the type of x. 
What if you have a thousand tsconfigs on your drive and you `tsc folder/folder/folder/file.ts` from root?
... Just read his fucking comments.. &gt; I think Gist (by Microsoft) is a much better option: https://gist.github.com/ Who says Gist.Github is "by Microsoft"? They just paid for it. The acquisition just happened in June. [His other comments are busting people for trademarks infringements at Microsoft,](https://www.reddit.com/r/typescript/comments/a3odt2/ive_created_an_npm_package_typescriptblue_in_case/ebf96lb/?context=0).
Then it would use the config in root which is your current **working** directory! Just like git, npm, babel, eslint, make, and others.
The best solution is the one with the least amount of assumptions. No default config is the least amount of assumptions.
Fewer assumptions is a blank file. Assuming a machine that can execute code is BOLD.
You can read more on [the actual documentation page][type]. Some excerpts: &gt; Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand. &gt; Aliasing doesn’t actually create a new type - it creates a new name to refer to that type. etc. Even more info on the [differences][diffs] section. [type]: https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases [diffs]: https://www.typescriptlang.org/docs/handbook/advanced-types.html#interfaces-vs-type-aliases
Yes, their application at the time consisted only of a single file. They were converting a javascript project to typescript and were testing on a single file. Besides, depending on what you're used to, it may make sense to only have to invoke/build a single file because that file contains information about its dependencies, so it's not something that's nonsensical. As I said, I not very experienced with typescript development at that point the tooling ecosystem was one of my weaker points. However, digging through the documentation and such to help fix this issue ended up teaching me a lot, so there's that. &gt; It's in the official documentation, under the section "using tsconfig.json". I'm sure it is, but somehow I missed it. But the question is really whether the current behavior is unintuitive, isn't it? Not whether it is documented. In my opinion, the fact that this question is even being asked means that the default behavior needs to change. If the default behavior weren't unintuitive, no one would be asking for this change.
&gt; the fact that this question is even being asked means that the default behavior needs to change. That is such a narrow minded naive thing to say. If the behavior is changed, then the question will come up again, just the other way around. Then it needs to change again.
I don't agree because I think that if the behavior was the other way around, it would be more intuitive for most people and it would not come up again, unless it was people who had gotten used to the old behavior. But obviously, I don't have any empirical evidence to support that claim, but presumably you don't have any empirical evidence to support the opposite either.
&gt; it would be more intuitive for most people And I'd argue that it would be less intuitive for most people. That this particular subject rarely comes up in the issues shows that it's not a very important case.
1. I don't "underclassifying" the scope, I just said, that this error type is a rare one. If you try to avoid TypeErrors with TypeScript, than you should ask yourself, why YOU have so much TypeErrors in your application instead of blaming JavaScript as not "type-safe" or not being statically typed 2. TypeScript don't speed up development. I totally disagree in this point. If you starting from scratch (e.g. a own library), you will write more around TypeScript than writing code for the library. Espacially if you use an exisiting ecosystem (React, Vue, and so on) which is not built in TypeScript, you spending more time to get a "TypeScript-compatible" version of some of your dependencies, if they have no declaraton file. 3. instant documentation: using type annotations is not documentation. Instant documentation doesn't depend on a language or an (dis-)augmenationof it. if you write a function, the name of the function should describe what it does or what it returns and the name of parameters should be, what is expected. You want documentation, use JSDocs instead, much more reliable and flexible way. 4. Linters: TypeScript also uses a linter, which tell you, that code is not used or warn you if you deleting legacy code, which is in use - thats not the TypeScript compiler.
It would be a nice addition to talk about the \`infer\` keyword ([https://dev.to/miracleblue/how-2-typescript-serious-business-with-typescripts-infer-keyword-40i5](https://dev.to/miracleblue/how-2-typescript-serious-business-with-typescripts-infer-keyword-40i5))
Thank you for taking your time to write this guide, but you didn't actually explain how inference works. It would be useful to have a guide that explains const vs let inference, type widening inferred type in object/array literals, inference order and priority (and how there's a clever trick with NoInfer&lt;T&gt; that abuses the fact that intersection type is a lower-priority inference site than object literals) etc etc. Your examples are mostly very basic rules for inference (variables and functions) and from then on it goes into completely different topics like "async operations aren't inferred" which makes no sense. Another topic you touched upon is "composition is not inferred", which is kind of valid, considering that functions get their generic types resolved to \`{}\` when composed, so in a sense inference is not working as expected, but you didn't mention that at all, instead you wrote about function overloading and TypeScript's lack of variadic types which has nothing to do with inference.
Thanks for sharing, I purchased it immediately!
So hyped for this 😃 When are you releasing it?
February 11, 2019
I'm working on the last bits with my editor. The current target date is the 11 February
Right, you're saying it's rare, which is why I'm suggesting you're underclassifying. The kind of bugs you run into *during* development (i.e. the ones when you're working on a feature, not the ones after you've committed and pushed) are almost always type errors. They're the kind of bugs that give you runtime errors when you refresh the browser or rerun your tests. Being able to fix these small bugs *before* running your code is a big time saver. &gt; If you starting from scratch (e.g. a own library), you will write more around TypeScript than writing code for the library I'd be curious to hear about your experience on this. In my experience, TS-specific code represents a small percentage of the codebase. You can also just write `var x = require('some-lib')` if you run into a library with no declaration file. The `any` type exists for a reason. &gt; instant documentation: using type annotations is not documentation Type annotations *are* documentation. You should have more than just that, but you can't call them "not documentation". It's instant because you can hover over a variable at any time and see what shape it is. Much less need for console log and debugger, again saving time. JSDocs and TypeScript is not a "one or the other" situation, people can and do use both. JSDocs enhances your TS variable-hovering experience. &gt; why YOU have so much TypeErrors in your application instead of blaming JavaScript as not "type-safe" You should try to refrain from using an accusatory tone, especially on points I didn't make. &gt; TypeScript also uses a linter A linter is a static analysis program. So I agree, TypeScript's "linter" gives you these things, and on a deeper level. But it's incorrect to say "that's not the TypeScript compiler" – this analysis is part of the whole process.
you're absolutely right, I will surely make an update soon. Thank you.
The documentation is also outdated...
Oh, yes, it would be a nice addition, but I think it really deserves another, separate article. Infer is, on one hand, pretty sophisticated, on the other - it's a big topic itself. So many usecases it'd overbloar this article. Probably I'd link the future article in this one. But, yeah, initially I've had it on my list :)
You're right. What I wrote is a simplification. (1) thank you for your time to point this out to me. (2) as you can see the post is already measured to 18 minutes read, which is really long already. Decisions on making it even longer, or omitting some topics is difficult. In this case I chose to simplify, but you're right, this simplification ignores a real case. Thanks for both reading and for ur feedback!
Thank you for reading my post. Everything you wrote would be really nice to have, but again, the post would be not 18 minutes read, but twice as much. I'd say there are even more topics not covered yet, like various type guards which also relate to how a type of an expression gets evaluated. Anyway, I will surely take your input into account when I update the post - thank you!
I look forward to reading it :) 
Source?
Do you even use TypeScript? Or do you just believe everything on the internet is 100% accurate? Here's 3 things the documentation says are differences between types and interfaces 1. Types can't be extended 2. Types can't be implemented. 3. Types don't create new names. If you actually try them, you will see the documentation is wrong... 1. Type aliases can be extended with intersection types using `&amp;`. 2. Type aliases can be implemented in classes the same way as interfaces, using the `implements` keyword. 3. Type aliases do create a new name, create a type alias and a function that returns that type alias. If you hover over the function in VSCode it will show you the type alias name.
You should mention that type inference is not a good thing when you create object literals and assign them to a variable. In this case type inference renders the excess property checks feature of the compiler useless. Example: interface Fubar { a: string; b: number; } const inferred = { a: 'test', b: 0, c: true // this property is not wanted }; const explicit: Fubar = { a: 'test', b: 0, c: true // now the compiler will warn about this additional property }; In most cases it's negligible, because the inferred type will be assignable to `Fubar` (because all properties defined in the interface are present). But maybe, during refactoring, you removed the `c` property from the interface, and behind the object literal creation is an expensive computation for that property. It's essentially dead code, but you don't notice that it's still in your code base because the type is inferred.
You might want to look up the Non-null assertion operator, that flag could cause you to use them a lot when the compiler can't figure out if something is not null.
First of all, yeah you're right: you never blamed JS to be not type-safe, so I have to apologize on that point. &gt;Bugs *during* development Thats what I mean - I rarely run into TypeErrors *during* development. The most bugs I have are misbehaving UI, which wasn't specified enough before development. If I have a function that expects a Number as parameter then I have to guarantee that either it gets a Number or can be converted to a Number. And thats a programming paradigm, you have to do either with or without TS. &gt;JSDocs and TypeScript JSDocs enhances your TS variable-hovering experience. It's instant because you can hover over a variable at any time and see what shape it is. With JSDocs you get the same result. &gt;JSDocs and TypeScript is not a "one or the other" situation, people can and do use both. Yes, you *can* use both, but whats the point of writing the same documentation 2 times. If I want to use a documentation generator, I would choose JSDocs because the most generators for TS documentation are more or less in a *beta* state and doesn't match the expected quality. The other point here is that if you want to use documentation in a company it mostly is unfortunately a *"one or the other" situation*. &gt;You can also just write var x = require('some-lib') if you run into a library with no declaration file. The any type exists for a reason. Same as before: whats the point to use TS anyway, then? It makes no sense to me to use TS on the one hand and on the other hand use no types or use `any`. Then I don't need it at all. In the end, I stay with my statement: you can reach the same quality of code (and tooling assisstance) with other tools without TS and with less effort.
No worries. I find this particular behavior of TS pretty surprising and I would find it easier to reason about TS if your post's simplified claim were 100% true, so that's why I noticed it!
My impression was that `interface` is there for OOP users while `type` is there for functional programmers.
Well lets just agree to disagree and call it a day :D 
Would the built in InstanceType type help? https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html
&gt; If I have a function that expects a Number... I see, maybe I'm just working with more complicated data structures than you. &gt; With JSDocs you get the same result. Does it also give you autocomplete? &gt; whats the point of writing the same documentation 2 times [You don't](https://microsoft.github.io/tsdoc/). &gt; Same as before: whats the point to use TS anyway, then? Ultimalety to increase the speed of development. Realtime type checking, intelligent autocomplete, "goto definition", project identifier renaming... all such features contribute to you getting things done faster (once you get past the learning curve, of course).
Alright. I will try those things. Also, could you come off as less of a condescending, hyperbolic douche? It doesn't suit you. 🙁 All the best.
Uh... Where's the project?
subViews is optional &gt; subViews?: Views; But is passed in as views during recursion and not null checked. &gt; const currentView = Object.values(views).find(view =&gt; view.route === currentPath); 
I can totally relate. My first react experience was with TS, starting July/August of 2018. At first I really struggled, but recently I’ve started to really enjoy it and feel it helps me write much better code. I’ve even started using it for a recent personal project. 
To be honest Im not sure. I tried the following: ``` type AllDataSources&lt; T extends { [K in keyof T]: IGraphQLModule&lt;any, any&gt; } &gt; = InstanceType&lt;T[keyof T]["dataSources"]&gt;; ``` But that seemed to allow the type to be anything. I've also tried a bunch of variations using `new` with no luck.
Crap, thank you for pointing that out; I think its fixed now!
Thanks a lot for the idea. It worked as expected with typesVersions :) 
Thanks very much for your reply. The compiler actually complains first about the `path` parameter possibly being null. How could that be? I'm at dinner right now but about to head back and will review your reply in regards to the second parameter. I think in my code it is not possible for subViews to be null/undefined if findActiveView has been called from itself.
Personally, I dislike the style that prettier uses. TSLint will also autoformat the code but give you much greater control over how it looks.
One problem comes from calling the `find` method on each of your `View` objects. The compiler can't be sure that this matches anything, so `currentView` is possibly `undefined`, before you even get to the fact that `subviews` also might be `undefined`.
That looks really interesting, good job!
interesting. will keep an eye on this project.
It's complaining because subViews is optional. If currentView.subViews is undefined then you are going to end up calling `const currentView = Object.values(undefined).find(view =&gt; view.route === currentPath)` which doesn't make a lot of sense. You need to decide a way of making sure that you can detect whether or not subviews exist. You also haven't allowed for the path not being found so you need some more checks in there anyway. Without actually trying to execute the code, you're going to end up with something like const getActiveView = (paths: string[], views: Views): View | undefined =&gt; { const basePath = paths.shift() if (!basePath) { return undefined } const baseView = getView(basePath, views) if (!baseView) { return undefined } if (paths.length &gt; 0) { // There's more of the path to deal with so we must have subviews defined if (baseView.subViews) { return getActiveView(paths, baseView.subViews) } else { return undefined } } else { return baseView } } const getView = (path: string, views: Views): View | undefined =&gt; { return Object.values(views).find(view =&gt; view.route === path) } As you can see there are a lot more checks in this code than the original. This stops it falling over unexpectedly and forces you have have the correct types defined.
&gt; I see, maybe I'm just working with more complicated data structures than you. That was just a simple example. That has nothing to do with complexity, handling data is your responsibility as a developer and not the language. &gt; Does it also give you autocomplete? Yes, it does. If you use a plugin, which you should do to write proper JSDocs, that plugin not only helps you write it, it interprets it and gives you autocompletion. &gt; [You don't](https://microsoft.github.io/tsdoc/). Yeah, hurt more than it helps. [https://github.com/Microsoft/tsdoc/issues/120](https://github.com/Microsoft/tsdoc/issues/120) [https://github.com/Microsoft/TypeScript/issues/10#issuecomment-49659516](https://github.com/Microsoft/TypeScript/issues/10#issuecomment-49659516) &gt; Ultimalety to increase the speed of development. Nope, totally disagree with this point. Espacially if working with developers, which have another language background and don't understand JS. &gt; Realtime type checking, intelligent autocomplete, "goto definition", project identifier renaming... all such features contribute to you getting things done faster (once you get past the learning curve, of course). You already have all of these features **without** using TypeScript and without any learning curve.
&gt;The compiler actually complains first about the path parameter possibly being null &amp;#x200B; `shift()` is defined as returning `string | undefined` so calling paths = paths.shift() paths.length() will make the compiler complain that paths may be undefined when you call length. &amp;#x200B;
Thank you very much, I truly appreciate your help - this is quite the learning curve for me
Thanks so much for both of your replies. This absolutely helps me understand the issue. I need to take a much harder look at how often and thoroughly I'm null checking.
Thank you very much for your reply, it's very helpful
Thanks. Apart from decent unit test, one technique you might want to play with is using empty collections. Rather than using undefined is something doesn't exist, use an empty collection instead. You'll often find you can then do away with a lot of the checks. eg in this case subviews would be defined as subViews: Views and your test data would be something like const viewData = { home: { key: "home", route: "/", subViews: {} }, more: { key: "more", route: "/more", subViews: { submore1: { key: "submore1", route: "/submore1", subViews: {} }, submore2: { key: "submore2", route: "/submore2", subViews: {} } } } } &amp;#x200B;
I love this tip, thank you. I think this maybe solves the issue I was having when I wanted to define an object like this: const uiElements = { pageContainer: { selector: 'test', node: undefined }, otherElement: { selector: 'other', node: undefined } }; and can't initialize the nodes because they don't yet exist.
Finally! https://github.com/muon52/TypeScript
Finally! https://github.com/muon52/TypeScript
Holy sh*t so you actually forked the whole TypeScript repo lol. Haha great...I'm busy on something for the next few days but I'll definitely check it out when I find the time. Thanks a lot for sharing =). Maybe I'll be able to tweak it too.
Your code should work. Did you try it and get an error?
If you want a class type (and not an instance of the class), you can use: const foo = &lt;T: {new(): Bar}&gt;( baz: T ) This will accept derived classes too, as their constructors also produce something that can cast to Bar. 
You can use a `Constructor&lt;I&gt;` generic to represent something that is a constructor of `I`. ``` type Constructor&lt;I&gt; = new (...args: any[]): I; ```
Yes I just doubled checked to make sure I didn't just make some silly mistake, but the code above will only check that an instance is derived from Bar and not the class
This doens't appear to be valid syntax in TS. this does look an awful like like the parameter-less constructor constraint in C# generics. though. Any idea if I just missed something?
Ohh awesome, this did the trick! I'm assuming this is the [blog post](https://blog.mariusschulz.com/2017/05/26/typescript-2-2-mixin-classes) your talking about. But a quick check and the compiler is giving me the expected result
Actually this is the one I was thinking of. https://blogs.msdn.microsoft.com/typescript/2017/02/02/announcing-typescript-2-2-rc/ But it looks like they actually use a slightly different type in that example, so I bet your blog post is a better resource. Regardless, I'm glad the code is working!
I left off the rest from your example. Here's an example from stack overflow: https://stackoverflow.com/a/39393087
Try T extends typeof Bar
Some testing shows that typeof Bar seems to be working! Looking through my use cases I realized a generic type parameter was not my ideal though. I essentially an making a wrapping object around these classes that get passed somewhere else. 
It's 2019. You should be starting new projects with VueJS &amp; Vuex.
Everything you can do with js you can do with ts, in term of functionality. So you won’t lose anything (: There’s no particular reason to wait
But will I confuse myself if I start learning new syntax on top of Js that Gad barely settled into my head? I feel confident with Js but I’m worried I’m running ahead of the horse.
From the get-go, TypeScript requires some configuration to build your code into JavaScript and to be able to run tests written in TypeScript. Personally, TypeScript made it easier for me to understand JavaScript along with TSLint to find potential errors as I wrote them. TypeScript handles plain JavaScript, so you can start using the additional type syntax at your own pace.
I think if you can understand the difference between a type annotation and a javascript declaration, then you'll be fine
Will i be able to run through my React and Node tutorials by using TypeScript? Will it be the same in terms of using these libraries?
There isn’t much to learn afaik, someone will correct me if I’m wrong 
You may want to search for React tutorials that use TypeScript. See [https://facebook.github.io/create-react-app/docs/adding-typescript](https://facebook.github.io/create-react-app/docs/adding-typescript) to add TypeScript to a React app. The only thing I can think of that would be different from the JS tutorials is the import statement. In JS tutorials you’ll mostly encounter ‘require’ statements, while TS mostly uses ‘import’ statements. They’re practically the same, though with certain older npm packages that don’t have TS typings, you may have to use ‘import pkg = require(“...”);’. Certain npm packages have typings made by the community which can be added to your devDependencies. You’ll usually find them by adding ‘@types/package-name’.
I can't speak to how to how to refactor your observables (I assume you're using rxjs?). So, my only suggestion is that you could do an early return to save one level of nesting i.e. if (!user.offers) return; This could all probably be refactored to multiple methods to allow a more flat structure. Something like: class YourClass { private userService: any; private offerService: any; private searchEvent: any; showResults(form: any) { this.userService.getUsers(form.searchBox).subscribe(users =&gt; this.handleUsers(users)); } handleUsers(users: any[]) { users.forEach((user) =&gt; { if (!user.offers) return this.handleOffers(user.offers); }); this.searchEvent.emit(users) } handleOffers(offers) { offers.forEach(offer =&gt; { this.offerService.getOffer(offer).subscribe(offer =&gt; { console.log(offer); }); }); } } 
I've already thought about doing it like that. I need the first get request regardless, it has now ties to anything else I need. Then, I can write a separate method that makes another request. I was just kind of curious to see if there was an actual adhere methodology that people recommend when doing something like this. so far, I've read about forkJoins which is like a promise.all() and if the data was all independent, I think that would be fine but the one of the http requests is tied to another. There is something called a mergemap which I might play with though.
If there is something he should then it’s to not follow some random opinion on Reddit
You could wrap your subscription in a promise, then you could use async/await and it would be really flat. class YourClass { private userService: any; private offerService: any; private searchEvent: any; async showResults(form: any) { const users = await this.getUsers(form.searchBox); users.forEach(async (user) =&gt; { if (!user.offers) return const offers = await Promise.all(user.offers.map(offer =&gt; this.getOffer(offer))); console.log(offers); }); this.searchEvent.emit(users) } getUsers(userId: any): Promise&lt;any[]&gt; { return new Promise((resolve) =&gt; this.userService.getUsers(userId).subscribe(resolve)); } getOffer(offerId: any) { return new Promise((resolve) =&gt; this.offerService.getOffer(offerId).subscribe(resolve)); } } 
But seriously, why would anyone use React over Vue for new projects? Vue is faster, easier and has built-in styling capabilities.
Maybe its easier for you. Not for everyone else. While I can write some vue I prefer reacts functional style. Why do vue devs always feel the need to preach?
Setting up typescript is pretty annoying plus some types errors can be really complicated to understand and the syntax can be hard to grap. I'd still highly recommend to try Typescript though
hmm, I think this answer is viable as well. Is there an actual preferred method though that is suggested? I know programming has a lot of answers, but sometimes there is just a preferred way because it can prevent headaches down the road.
Typescript is good for incrementally opt-in. Nothing scary. 
There is a lot to learn to write advanced types imo. But learning writing type aliases is a great start and the advanced stuff can be learned as you go.
It will be better to use the syntax: `import pkg from 'pkg'` since it's the same in JS and TS and is a standard syntax.
It looks like you are using rxjs. Notice that you have a `subscribe` inside of a `subscribe`. If you read this article - and most importantly watch the embedded video - you will learn that when you have a `subscribe` inside a `subscribe` you probably want to change your code to use a map operator with a flattening strategy, such as `mergeMap`. https://medium.com/@shairez/a-super-ninja-trick-to-learn-rxjss-switchmap-mergemap-concatmap-and-exhaustmap-forever-88e178a75f1b In general you will get more expressive power from rxjs, and less nesting, by using `pipe` with higher-order operators instead of using `subscribe`. Try to save `subscribe` for the very last step. It can also be helpful to break up code into helper functions that return intermediate observables. Here is how I would write this example: import * as rxjs from "rxjs" import * as ops from "rxjs/operators" class YourClass { constructor( private userService: { getUsers(q: string): rxjs.Observable&lt;User[]&gt; }, private offerService: { getOffer(id: string): rxjs.Observable&lt;Offer&gt; }, private searchEvent: { emit(x: unknown): void } ) {} searchForOffers(query: string): rxjs.Observable&lt;Offer&gt; { const usersObservable = this.userService.getUsers(query) usersObservable.subscribe(users =&gt; { this.searchEvent.emit(users) }) return usersObservable .pipe(ops.concatAll()) // transform observable of arrays to observable of individual users .pipe( ops.mergeMap(user =&gt; { if (user.offers) { // create an observable from the user's offers which forwards one // offer at a time to the next `pipe` step. return rxjs.from(user.offers) } else { // if there are no offers for this user then there is nothing to // return from this step return rxjs.NEVER } }) ) .pipe(ops.mergeMap(offerId =&gt; this.offerService.getOffer(offerId))) } showResults(form: any) { this.searchForOffers(form.searchBox).subscribe(offer =&gt; console.log(offer)) } } 
Oh, I didn’t know TypeScript supports that now. Thanks, I’ll be sure to use that from now on. I was using the answer from [https://stackoverflow.com/a/43622363](https://stackoverflow.com/a/43622363) .
Plenty of reasons \- Doesn't have the time to learn a new framework \- Has developers that don't know Vue and no time to train them \- Company doesn't approve Vue \- React has a larger ecosystem \- React is backed by a large company I could go on
yea, I mentioned in a post in here that mergeMap looked like a viable option. For now, I think that is what i'll go with. Thanks
I've never gotten this many downvotes before. Some people are very devoted to React :D &gt;Doesn't have the time to learn a new framework &gt;Has developers that don't know Vue and no time to train them Agreed. But Vue *is* the future. &gt;React has a larger ecosystem Agreed. But Vue will surpass React some day. &gt;React is backed by a large company How is that beneficial? Community-backed projects are arguably more stable, since companies can make decisions to discontinue or abandon projects, while communities tend to stay together. Other evidence: * HipHop, a PHP-to-C++ compiler, was discontinued abruptly by FB. FB is not reliable. * Apache is more popular than Nginx even though Apache doesn't have corporate backing and Nginx does. * Dart is backed by a large company. Dart is neither popular nor stable.
Here's what I came up with: type Pivot&lt;T extends object &amp; Required&lt;T&gt;&gt; = { [K in keyof T]: T[K][] }; function pivot&lt;T extends object &amp; Required&lt;T&gt;&gt;(arr: T[]): Pivot&lt;T&gt; { if (arr.length === 0) { throw new Error("pivot() only works on non-empty arrays!"); } const result: { [key: string]: T[keyof T][]} = {}; Object.keys(arr[0]).forEach(k =&gt; { result[k] = arr.map(obj =&gt; obj[k as keyof T]); }); return result as Pivot&lt;T&gt;; } interface Sample { foo: number; bar: string | undefined; } interface BadSample { foo: number; // optional property would break pivot() implementation // if first item in the array does not have this property bar?: string; } declare const sample: Sample[]; // this works const result = pivot(sample); declare const badSample: BadSample[]; // this is a compile error const badResult = pivot(badSample); Some notes: * The implementation depends on iterating the keys of the first item in the array, so there needs to be some protections to ensure that the run time implementation will actually iterate all keys of the type: * Run time check to ensure there is at least one item in the array. * Compile time requirement that the type of element in the array does not have any optional properties * Code like this where you are using a generic algorithm to transform types can be tricky to make the compiler happy. Try not to get too specific with the types in the implementation, and use type casts to tell the compiler to trust you after the work is done. See how my `result` variable is a very generic object with a string index whose type accepts ALL properties of T, rather than being a more specific mapped type. This makes it easier to write the the transformation code in a way that the compiler likes, then I cast it to the more specific type at the end. You know you're doing it right when you don't have to use type `any` or force cast through type `unkown` at any point.
Love it, Was looking for something like this the other day. Excited to give it a try
Following!
Is it correct though? Person interface doesn't have a 'weight' property so it should throw an error. If anything this seems like an mistake in the TS design. Hopefully they can fix it in the future.
My advice is to take 1-2 days to learn the basics to angular. If you have it installed, you need literally 3 console commands to have a blank site up and running. Then you can add any typescript files easily (you don't even need to run tsc, and don't have to worry about any js files)
Angular seems to take over the complete workflow. I will need to ask my boss if we can use that. I have seen many libraries suggested like that. &amp;#x200B; 'use \[library\]! its so easy to set up and will solve all your problems!' &amp;#x200B; new problems arise. All libraries don;t play well together. You can't use \[library\] because another library already is taking over the whole project. &amp;#x200B; &amp;#x200B; I appreciate the help but this seems like yet another 'golden sword' to fix javascript. Nonethe less i will read about angular now ... Also is polymer.ui not the same but different? Someone else told me to learn polymer instead of angular. But all those BIG libraries seem to completly take over everything. Why can't i just code in a normal language without 10 helper libraries just so i can include something? &amp;#x200B; I feel liek i totally misss something here! Its just an include! nothing fancy. I havn't even started coding!
Hey, ToplessTopmodel, just a quick heads-up: **completly** is actually spelled **completely**. You can remember it by **ends with -ely**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Its not about react. Its about your completly out of context reaction to a react library.
Hey, dulac91, just a quick heads-up: **completly** is actually spelled **completely**. You can remember it by **ends with -ely**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
In this context, node js is used for things like dependency management, building, etc. Angular will get compiled down to vanilla js that can run in the browser. I would suggest you step back and read more about modern JavaScript development workflows and frameworks. You may not need one and I wouldn't suggest trying to learn one as your first foray into front end development. There are A LOT of moving parts, and trying to figure out all of them at the same time will just overwhelm you. I would try to do this with vanilla JavaScript before attempting to work with typescript. Or at least do some prototyping and more learning about typescript before trying to build a complex app with it.
I thought this was for a demo/prototype, not for a job. Yeah...you need node installed for development, but you can then build the site into html/js/css files.
obj[k] as keyof T is a really neat trick! i’m gonna roll up my learnings into a blog post. this stuff is too hard to learn elsewhere. thank you thank you thank you.
Take a step back and breathe. You are being completely irrational. This is not how you approach a language and you know that. Stay humble, read up on the basics and slowly move into what you are trying to do instead of diving in the deep end and complaining about water 
importing is the 'deep end' ? &amp;#x200B; i actually want to write code and learn but for this i need to import first. there is no step inbetween. you have to import before you can code. 
All of your knowledge transfers over as TypeScript - more or less - __is__ JavaScript. If you install/use appropriate developer tools (VSCode is great for TS), you can treat it as "JS that constantly nags you when you're about to do something mildly stupid". 
The "more generic type" of `result` in the implementation is admittedly confusing to discuss because we are also talking about a function and types than make use of generics. The word "generic" is a bit overloaded here. I think the main point is that it's much easier/cleaner if the type(s) of your structure(s) in the implementation are no more specific than makes sense for the algorithm/code that is processing the data. Since the implementation of pivot() involves "generically" iterating over all properties of the object (rather than directly referencing individual properties by known-at-compile-time names), your implementation can't possibly deal with knowledge about specific properties having specific types. Maybe the general rule is that it makes more sense to type private/internal/temporary structures to match the algorithms/code that will be managing/building those structures to allow for the implementation code to be cleaner/simpler (minimal typecast hacks). Save the type casting for when you need to expose the result publicly. This makes it easier to understand the implementation code and have confidence that assumptions are correct for the type casts. 
Good Bot
No. Because Typescript interfaces are inclusive. When not assigning directly it does not matter if there are other properties present. I believe this is what works best, considering Typescript is a superset of JavaScript and not a new language.
You are making incorrect assumptions about things which you have no knowledge of. 
Angular is a framework. No backend server. You picked typescript because everything has to be in browser? Like others have said, why not use js. 
Also, it's very helpful to add a comment at each type cast to explain the assumptions and/or justification for why the type cast is safe/valid. 
I don't use pipe generally, but I believe it's intended to use with an arbitrary number of operators and only one should be needed. Otherwise, `.pipe(ops.concatAll())` and `.pipe(ops.mergeMap...)` is no different from simply calling `.concatAll().mergeMap(...)`
When you want to use the results from one request in another request, you want some variant of `flatMap`. A flatMap has type flatMap&lt;Observable&lt;T&gt;, Func&lt;T,Observable&lt;U&gt;&gt; Observable&lt;U&gt;&gt;. FlatMap assumes it's operating on the "happy path" of observables and it wants a function that will glue two observable functions together In this case, this.userService.getUsers() .filter(user =&gt; user.offers) .flatMap(user =&gt; Observable.from(user.offers)) .flatMap(offer =&gt; this.offerService.getOffer(offer) .subscribe(offer =&gt; console.log(offer));
Assuming you're using Angular, you generally want to stick with Observables over Promises largely because that's the Angular norm. They're altogether more powerful and flexible, but there are rare cases where a Promise is a more straightforward solution.
JS + d.ts is usually the go to for npm packages, since you have no idea what the build environment is for a general consumer. In a more defined environment that you have more control over, it \_could\_ be OK to not compile .ts, but I'd still err on the side of js + d.ts
We have a totally defined environment. Not only we and only us will use these tools, but we also control the build environment and even the hardware. Do you know some modern example of working js + d.ts approach where one repo depends on another? I was looking but there are so many examples and they are usually made completely different ways.
You have 3 seperate modules (Framework, Application and Theme) Framework: Code is never used by itself in a bundle, use tsc to compile it with d.ts files, then import it from the other modules. Application: This one has a weird naming, it sounds like a library as well, since it doesn't depend on framework, but Theme depends on it. I would say run tsc on this one as well. Theme: Aka Application, this is the final step, which will use the previous libraries and and bundle everything in webpack, so that it can be used.
Hey, Pavlo100, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Yeah, the true names are different but this is very business-specific and would be less clear. You are almost completely right though. Framework is never to be used on its own. It makes no sense. Application depends on the Framework and can be fired on its own, for developing entirely new one. In theory we might one day make a single App without any themes, but let's simplify this by considering we would add an "empty" theme to have unified build process. Now, the question is: Can webpack and ts-loader be used in such scenario? I was not able to find a working example in the net. We can also make our own bundling tool but, honestly, webpack is great since we have A LOT of various additional assets, configs to be merged and few other non-TS-related steps. So if we could scavenge webpack + ts-loader it would be great. Thanks for the input, I am even more skewed towards d.ts now...
I assume this is frontend Does application ever render itself on the frontend for the end user, or does it always require a Theme (or empty theme to work)? If so, then Theme should be the only webpack
Thank you for pointing that out! I edited my comment. &amp;#x200B; I have very little experience with rxjs. (I have mostly used kefir.) I heard that \`pipe\` is useful because it allows tree shaking to remove unused operators from a compiled bundle. But I don't know any more than that.
Yeah it is frontend. The app would be rendered only during development, before themes are developed. So far it does not require a theme but the more I think of it, the more I believe it should have an empty theme to have consistent build process. One thing though, I would like to run tests on all three levels of the project. For now webpack handles compiling TS for the tests, but this should be relatively easy to do in karma-typescript or similar solution. Tests do not require any assets or external connection, just the .ts sources. In such case is it still the best idea to have webpack only in Theme?
The only hard thing is to setup webpack for frontend correctly in my opinion. On backend you can simple use \`ts-node\` and execute your program. But it is true that you need to always consider more (e.g. \`jest\` configuration needs to use \`ts-jest\` etc.). &amp;#x200B;
Yeah you don't need webpack to run tests. If you Application runs theme based on framework interfaces. And theme uses framework interfaces, which Application can call, then application can be Webpack. Then it sounds like you are rendering 2 bundles, but you can't use refer to the application bundle, because it calls you and not the other way around.
&gt; Update examples to less OO-heavy/ESNext style So TypeScipt is moving away from Object Oriented programming? That's sad to see.
Fairly sure the industry is moving away from OO, honestly. 
It does not sound like that is the case. It sounds like the examples are going to be more aligned with -- or at least more representative of -- the JS community's coding patterns.
&gt; Given this, our editor team will be focusing on leveraging ESLint rather than duplicating work [with TSLint]. Great, they are looking into better TS support with ESLint! This will also leverage the community of ESLint, which means less bugs and more features 😁 
JS in general is not very OO. So have more Real-world JS examples makes more sense. I doubt TS will drop anything that already exists. They have a pretty strict forward-compatibility rule.
I'm sure it's simply to broaden the appeal and instant recognition among people who are not coming from that background. TS is solid gold for good OOP patterns in the browser, and they'd have to really F things up to change that! But I am glad they are looking at more than one programming style.
When TypeScript first appeared a big selling point was 'wow you can use classes in JavaScript!'. That's not really such a big deal any more. I think that's all it is. Regardless TypeScript isn't and can't move away or towards any particular paradigm as its still just JavaScript with types. It goes wherever JavaScript goes.
Did I read that right? Are they willing to implement the pipeline operator? That would be amazing.
Like this, ... ? [example from official docs](https://imgur.com/a/yUbWhVV)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/kXkGnNr.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20edisiq2) 
Yeah. I personally prefer type alias `type Something = { foo: string }`, but many people prefer interfaces.
Since one of TypeScript's stated goals is to align with ECMAScript proposals, it's in their best interest to participate in the planning and design. [Here's the pipeline operator draft](https://github.com/tc39/proposal-pipeline-operator).
and a ton more potentially super annoying lint rules
You act like they're mandatory or something. Just turn off the ones you don't like.
Fairly sure not
At this point, compiling ts libraries from node_modules with ts-loader does not work. I'm trying the exact same thing as you do right now, but hit a wall with this. There are at least two open bugs, one in ts-loader and one in typescript itself. But hopes are high this is fixed soon. I'd favor not having to compiling dependencies separately, since they are mostly developed in tandem with the actual app. Compiling individual libraries is very impractical in this scenario.
I think the reason is the lambda inside filter (validation =&gt; validation instanced Error) is not a proper guard of type Error. Try adding a function that looks something like function isError(x: Ok | Error): x is Error { return x instance of Error; } And use this function as argument to filter?
We have a working setup for compiling ts libraries, but it blows up every time we update typescript, webpack, ts-loader, karma or one of the supporting packages. In most recent iteration for example, imports coming from symlinks are treated differently from real path imports and I get two class definitions for physically the same class file. So far we know one working combination of versions of each package to make this setup works. However. If everything blows up every single time we update something, it clearly means we're going against the flow and do something which is not supposed to work. Which is why I asked which way is better, knowing d.ts is more popular but rooting for pure ts approach getting any traction. Since semantic versioning rules are generaly not followed within JS community, though, I suspect updating packages will always cause problems.
Yup, as the author I can confirm that that's the intent.
Not exactly - we're just invested in the design space in TC39, but have no plans for an early implementation to be released.
&gt; TS is solid gold for good OOP patterns Ehh... I would not call it solid gold. Solid gold would prevent passing unbound methods around.
I suspect that the need to use a function with an explicit `x is Error` return type is due to a limitation in the way type narrowing can be described in type definitions currently. This is the relevant overload of `filter` (from the [es5 lib](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es5.d.ts)): filter&lt;S extends T&gt;(callbackfn: (value: T, index: number, array: ReadonlyArray&lt;T&gt;) =&gt; value is S, thisArg?: any): S[]; Note the callback return type, `value is S`, which relates the type guard narrowing to the type of the output array. The expression `x instanceOf Error` does work to narrow a type in a conditional block. But without an explicit annotation Typescript infers to return type of OP's filter callback as simply `boolean` which does not match the pattern in the type-narrowing overload of `filter`. I think that another way to fix the problem would be to add a return type annotation to the inline callback like this: filter((validation): validation is Error =&gt; validation instanceOf Error)
Are you a dev on the team?
&gt;The annoying part is to setup typescript TBH, I just use the IDE to transpile TS to JS and haven't changed anything from when my code was JS-only.
It's an option yeah I haven't tried that It would not work in a team with people with different IDEs unless everyone setup his own to output the same thing though
&gt; The expression x instanceOf Error does work to narrow a type in a conditional block It does work to narrow a type in a conditional block. But the narrowing does not flow to the outside of the function. &gt; I think that another way to fix the problem would be to add a return type annotation to the inline callback like this: Yes, that would work. It's essentially the same solution as /u/shivawu proposed, just with a fat arrow function.
I work alone and pay for WebStorm. I can see the argument for having it standardized.
typedoc is better, but I think relevant people agreed on review jsdoc for typescript syntax (for things that are not supported in JavaScript) and make tsdoc the "official" so if this is true, typedoc will be kind of obsolete in the future (not 100% sure), Nevertheless, they are compatible in syntax so should be just changing the output generation script and the dependency. 
I changed all my domain models from classes to types and then enabled strict mode in the compiler, just as an experiment, to see what happens. The tsc compiler is encouraging me to use interfaces instead of types so I guess I'll give that a try. Your advice has been very helpful. Thanks again. 
In this article: &amp;#x200B; "Generics exist" &amp;#x200B; Saved you a click.
thank you Mr Pickles! You're really awesome for taking the time to teach me. Not so useless after all! It would be great to collate "typescript advice" like youve given here. maybe it exists somewhere already but i havent seen advice like you give on how to do type specificity.
Also: `TypeScript can infer types`
&gt; tsc compiler is encouraging me to use interfaces instead of types That's weird. Could it be tslint? tslint's default rules have such a rule enabled: https://github.com/palantir/tslint/issues/3248
&gt; That was just a simple example. It's a simple example that shows a lack of imagination. Static typing helps most when passing around and manipulating complex and nested data structures. I agree that if you're just working with strings and numbers, then it's probably not worth it. &gt; That has nothing to do with complexity, handling data is your responsibility as a developer and not the language. Of course handling data is the responsibility of the developer! We are in no disagreement here. &gt; Yes, it does. Please excuse my ignorance. If you hit autocomplete at the following point, would this plugin give you the correct set properties? var x = items.map(item =&gt; [item.foo, item.bar]) x[0][1]. // &lt;--- here &gt; Yeah, hurt more than it helps. Valid issues, but I'd say it helps more than hurts. Types are documentation that don't lie to you :) &gt; Nope, totally disagree with this point. Espacially if working with developers, which have another language background and don't understand JS. Of course, if they don't understand then there's a learning curve, and of course a learning curve slows down development. I'm talking about after that learning curve. Out of curiosity, what is this learning curve you have in mind? What makes TypeScript more difficult to use than JSDocs?
Oh. Yes. You are correct. 
I was, now I'm a PM.
It looks very similar to redux. Is there any particular reason to use this instead of redux? I personally think redux is an anti-pattern, but i'm still curious.
Also: Buy my book
It is different from redux since you can have multiple stores at once (in order to avoid the god object). The idea is to have a store for every application domain, so you can load your state progressively and not at once. Actions have a precise contract and in future releases, actions will mutate the state once they are subscribed to a store (aka events). The alter the state you have to use an updater signal, which can be subscribed to for detecting state change. Thanks for the feedback! 
Another instance of the \[Meiosis pattern\]([http://meiosis.js.org/](http://meiosis.js.org/)). I like the composability of sub-states. More lightweight then Redux. Good job!
1. it would be helpful if you linked your code 2. how are you determining you have a memory leak?
You didn't post your code.
This. Remember node doesn't have a garbage collector. Google it. 
Thanks! It will get even better in future!
What the fuck? Of course it does.
You're right, I asked a colleague who told me this, and I believed him too much. I just googled it myself, and it does have a GC. sorry OP
What did you think it had? It just continuously gathered more memory until termination?
Nah, we use a node app to index our database with Algolia, and recently it used too much memory on serverside during the indexing, so we had to force it to run the collector. See [https://stackoverflow.com/questions/27321997/how-to-request-the-garbage-collector-in-node-js-to-run](https://stackoverflow.com/questions/27321997/how-to-request-the-garbage-collector-in-node-js-to-run) I was under the impression that Node definitely had some garbage cleaning, but that it was required to measure performance and decide when to run the gc, if the app workload became too high at a certain point.
I was about to unload a bunch of questions on you. Maybe the best single question is, have you or anyone on the team considered doing an AMA? I know I'm interested in some of the being the scenes stuff and learning how a team makes a language. Also, is the team based on the US?
In my experience, it's quite easy to find memory leaks using the [heap snapshots](https://marmelab.com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs.html).
Hi, here is a code. I would be super grateful if you could check around if you see some mistakes in my code. It's my first time writing typescript. https://bitbucket.org/GroundZeroCro/html_game_2/src/master/
Hi mate, sry, here it is. https://bitbucket.org/GroundZeroCro/html_game_2/src/master/
Fantastic article /u/mariusschulz! I have to ask - what color theme are you using?
Great article. I already knew how conditional types worked because I've been using them daily for a long time, but it was a thorough and very accessible overview. And I learned about some new built in types, which means I don't need to recreate them with every new project :)
The thumbnail is so ridiculous, no wonder people say js is shit. (I’m not saying js is shit)
I personally use `const`. But some people prefer `let` everywhere because they think that `const` values should have been immutable. Matter of a preference in the end.
&gt;because they think that const values should have been immutable this is bonkers.
no, you dont have to ask. 
I don't think `const` provides a huge amount of value.
`const` tells the developer that the variable won't be reassigned `const TEN = 10;` Now we will know that on line 264 that it will still be equal to 10
mean
It’s Dracula!
I like how you assume that the person just doesn't know how it works or what its used for, because his opinion differs from your own. Lol. &amp;#x200B; But you're right, "const tells the developer", the problem is it doesn't actually enforce anything it tells the developer. So its mostly a stylistic choice.
Doesn't your compile go "BOOOOOO" when you reassign a const value? Mine even suggests me to turn a let into a const cause it's not being reassigned anywhere.
Just to illustrate few underused cases: ```js const arr = []; arr.push(0); ``` and ```js const arr = ['a', 'b', 'c'] for(const char of arr) {...} ``` No reassignement. 
&gt;Generics exist brb texting my gopher friends
I just do it in the blog posts and the handbook because it's shorter, but by default I'll use `const` the codebase.
You have? I stopped to early then.. But I sure hope this is coming soon, for example for monorepos this is essentially the only usful thing. 
Fun fact: Typescript will infer more precise types when you declare variables with `const` or class properties with `readonly`. In particular Typescript will infer literal types in those cases. For example: const x = "increment" // type of x is `"increment"` let y = "reset" // type of y is `string` class A { readonly type = "increment" // type is `"increment"` } class B { type = "reset" // type is `string` } This is because re-assignable variables and properties are "widening" locations, and read-only ones are not. For more details see https://blog.mariusschulz.com/2017/02/04/typescript-2-1-literal-type-widening
Thats typescript
I wish `let` had the behavior `const` does right now.
TIL. Thanks!
&gt;it doesn't actually enforce anything It is enforced. Typescript compiler gives an error. You can ignore it but if you do, the runtime (nodejs or the browser) will throw an exception and crash your application. The only way to get away with it is if you transpile typescript to older javascript, which people usually do, so that might be why you think it isn't enforced.
I certainly hope that isn't possible :D Why not add `Command.Like` and `Comment.Loader` as static properties in the class?
I don't believe you can have `type` alias declarations as static properties on a class. I have two other similar sections to the `Command` section of my library, but they don't use a class so they are only namespaced without any merged declarations. For consistency reasons I would prefer not have another separate namespace.
Use a type instead of an interface. export type barKeyType = keyof typeof bar; export type fooKeyType = keyof typeof foo; &amp;#x200B;
Thank you, this worked!
This is a pretty nice start, but I think your test cases are confusing, so bear with me. It looks like what you're doing is that when you execute a decorated function, your mutate the state of the object, then put it back once execution is complete, and you do so recursively. That's not exactly what dependency injection is - DI is specifying your dependencies up front, usually by Constructor Injection (specifying dependencies via the object's constructor), or Property Injection (specifying dependencies via changing properties). Your project somewhat does the latter, but I think you have something more akin to snapshotting, where you snapshot the state of your object at the beginning of your methods, then stuff happens, then stuff gets restored at the end. This is an interesting capability in and of itself, but I don't think it's DI.
I'm pretty sure declaration merging across files is only possibly for types, not values. Types can be fully resolved at compile-time whereas values are instantiated at runtime, so you get issues with the loading order of files, which is related to your runtime and how things get bundled. However, using imports and re-exports, it's possible to merge namespaces from multiple files together. You can also declare a new class that extends from an imported class and also includes extra static fields or a merged namespace. So either of those strategies might achieve the desired effect.
That's a useful feature but it's not a monad.
https://www.typescriptlang.org/docs/handbook/declaration-merging.html
How is this different than \`tsc --watch\`, which not only does incremental compilation but also doesn't ignore type-checking dependent files? As a simple example, file \`interface.ts\` can declare an interface, and file \`impl.ts\` can contain a class that implements it. If you change \`interface.ts\`, it's actually \`impl.ts\` that needs to be compiled again - its compiled output won't change, but it could have new type errors if the interface was changed and the implementation wasn't updated along with it. This incremental compiler would not catch this error unless you happened to change the\` impl.ts\` file at the same time - otherwise you'll end up with strange crashes at runtime. Thus it kind of defeats the entire point of TypeScript - strong type checking.
&gt;This incremental compiler would not catch this error unless you happened to change the\`impl.ts\` file at the same time Yes, this is exactly what I wrote [in the README](https://github.com/timocov/incremental-typescript#how-it-works) (see 2nd "but"). In a short - for now it's known thing, which can be fixed in the future. We need to store dependencies tree (and invalidate it, for example, if you recompile your project with \`tsc\`) somewhere to solve this issue, but I'm don't think that it's important for very first version. &gt;How is this different than \`tsc --watch\`, which not only does incremental compilation but also doesn't ignore type-checking dependent files? \`tsc --watch\` should work all time to achieve fast incremental compilation. If you stop it, and then run again, you'll need to wait the first compilation some time. This compiler you can run time-to-time to recompile only changed files. Yes, there is caveats, but I didn't say that it is "full replacement" for \`tsc\`. You can use it in additional for \`tsc\` in case, if you didn't want to recompile the whole project but only a changed file(s). &gt;also doesn't ignore type-checking dependent files There is another case, when this compiler may "won't work *as expected*" - if you have global variables (or extend some interface/module) in some file, which isn't changed too. See [https://github.com/Microsoft/TypeScript/issues/22576](https://github.com/Microsoft/TypeScript/issues/22576) for example. Here you can get an error about \`TS2339: Property 'X' does not exist on type T\` in a changed file unexpectedly. But in this case I would say that it is a feature, because quite possible that you don't have a needed import here 🙂 To be clear - this *is not* full replacement for \`tsc\`. This *is not* a compiler you need/should use in the production. I would say that it's a helper compiler, which you can use time-to-time to update your output files quickly and don't wait until \`tsc\` compile the whole project.
Great question. First of all: do you have any experience with typed languages? (Java, C#..). Because if so it's gonna be a breeze to learn. However, since you ask why you would wanna learn it i'm guessing you don't come from a typed language so I list a few benefits: * Way less bugs at runtime. The compiler will scream at you if you supply a string to a method that would expect a number for example. This is a pretty big one. You also need to write less unit tests because of this. * Much better autocomplete. Since your IDE knows what type your object is it will only suggest methods that are actually available on this object. For example if you type "asda" and press "." you see only string methods. * Which leads to better self documenting code. When I use a typescript library I rarely need to see the docs since I can just press a shortcut and I see what arguments something expects. * Allows you to use the newest JS features since it's compiled to "normal" js in the end. (kinda like babel * Pretty easy to pick up the basics. The advanced stuff can be tough but you don't need to use it at first. A great resource to learn it is this: [https://basarat.gitbooks.io/typescript/content/docs/getting-started.html](https://basarat.gitbooks.io/typescript/content/docs/getting-started.html) &amp;#x200B; A word of caution: You can configure ts in a way which allows you to write regular Javascript. Don't do this! Enable strict mode in typescript from the get go. It might be frustrating at first but otherwise you loose a lot of benefits. &amp;#x200B;
Thank you for answering. I'll take a look at the link you provided me.
Basically what he said. Typescript is just another tool to enforce some kind of checking of your code. There are a lot of other similar tools like Google's closure compiler but the way typescript does it makes it work like a breeze. Still it's a little bit of overhead you don't had before and with some special topics you also need help of even more tools to get it working (e.g. wanting to work with es6 module as output, you will have to bundle or rename files/imports). But for most projects it's just a great tool especially when you come from a typed language Background.
You can get most of the benefits of type safety for JavaScript without having to write TypeScript. You just need to define your types using JSDoc comments. Then have TypeScript check you JavaScript. Visual Studio Code uses TypeScript behind the scene to automatically check the types of JavaScript code to provide feature-rich Intellisense. VSCode uses this to live check your JavaScript and flag erroneous type usage, typos, wrong or missing parameters, code completion, refactoring, etc. You can learn more about this here: https://medium.com/@trukrs/type-safe-javascript-with-jsdoc-7a2a63209b76
We do this in our typescript config rather than in webpack. 
I figured it out. You can pass an extension list to the constructor of TsconfigPathsPlugin. Cool, I figured it out. Passing extensions to the constructor worked. new TsconfigPathsPlugin({ extensions: ['.js', '.jsx', '.ts', '.tsx'], }) 
I figured it out, but in a different way. But now I'm curious how I could've done it with tsconfig tho! I've looked around in the docs, and `allowJs` should resolve `.js .jsx` files. It does just fine in VS Code but not after compile.
I'm starting to learn TS, do I need to enable strict mode if I'm also using TSLint ?
Yes. Maybe its on by default but Id double check
I can't know why you should use it, but here is why I use it. I quite like the idea of functional programming, and with some Haskell knowledge, I love typescript for declaring the types of a functions inputs/outputs and, then for my editor (Visual Studio Code) to tell me which types I need for a certain function. But I use javascript for other proyects, since the fact that you know how to use it does not means that you have to use it all the time. &amp;#x200B; To your other question, you should learn it because if you know javascript, it's not more than a couple of minutes to get started, you can learn more advanced stuff, yes, but I believe that just learning the basic type stuff should let you know if it's your thing or not &amp;#x200B; Before I leave, here is a very simple typescript function, the same function in javascript and the typescript one after compiling. typescript `const kiloToPound: (input:number) =&gt; number = input =&gt; input * 2.204623;` &amp;#x200B; javascript `const kiloToPound = input =&gt; input * 2.204623;` &amp;#x200B; compiled typescript `var kiloToPound = function (input) { return input * 2.204623; };` &amp;#x200B; Note that not only did the compiler removed the type declaration, but also changed my es6 arrow function declaration for an older (but also old browser friendly) function declaration as well as `const` for `var`.
&gt; components/button Might be that you were missing the trailing slash?
Could you show an example? 
Do you maybe mean generics? Like myVariable: T
Generics can be difficult to read if you aren’t used to them, but the bright side is usually they are used in small enough snippets of code that you can work through it
I think this is just a legacy computer science convention. Typically generic types are T, U, V... unless you have a better name for them. But even then, it's usually one letter. In my code I often use longer generic names especially while I'm prototyping. Once I figure out the design, I might shorten them back to one letter for readability.
TSource and TResult are also common :)
Generics are commonly one-letter. Why? I dunno... maybe it's to emphasise it's a generic type, not an interface, abstract or concrete type.
A simple example here: [Redux thunk index.d.ts](https://github.com/reduxjs/redux-thunk/blob/master/index.d.ts). I can infer that S is state and A is action. R might be return? E is weird because it seems to be for then optional configuration, but its 2nd in some of the type defs, so that makes me think it's not. This is a small example because you can easily dig through it, but when there's 20 or 30 types using 2-4 generic arguments each, they become hard for me to follow. I dont have any problems breaking regular code down.
When you say "for readability", do you mean readability for you or for other people? Do companies that use typescript and this style have a list to give while onboarding or are devs supposed to memorize them? It seems like so much cognitive overhead.
I'm not familiar with any standard practice or style guide that would recommend naming things like this. This just looks like bad naming to me. But I'm not too familiar with React stuff. I'm sure it's scarce consolation, but I find it difficult to read too.
It’s a convention like i in for loops. You get used to it after a while.
It depends entirely on the situation; there's no cut-and-dry answer. "I might shorten them back" For example, if I simplified the type so that it only has a single generic parameter, and its role is obvious, then I might simplify it to `T`. `T` is immediately recognizable as the first generic parameter, since that gets ingrained over time during a computer science degree and job experience writing various languages. If there are multiple generic parameters and their roles aren't clear, I would probably stick to longer names. And, where appropriate, I clarify within JSDoc. To me, "for readability" *always* means "for other people" or "for my team specifically." I think that's software development common sense.
I understand the one-letter versions in some cases, such as P (props) and S (state) for React. It makes perfect sense because they are core concepts. But my "prettier" type defs are definitely not pretty because of the long type names, a disadvantage for sure.
Single letter types are almost always generic. Usually a “T” but lots of letters may get used in a generic heavy section of code. 
R is reducer.
I also agree. Terrible convention.
When I see `T` to me this represents that it requires a type. For example in C# `List&lt;Of String&gt;` is documented as `List&lt;Of T&gt;`. Same with TypeScript with `Array&lt;string&gt;` is defined as `Array&lt;T&gt;` Im on mobile so the syntax may be completely correct. 
That is simple and easy to understand. Chained generics like Foo&lt;S, E extends F, A&gt; and Bar&lt;R, F extends Foo&gt;. I essentially have to dig through source code to see what the initials may be if they aren't function arguments, obj properties, or there aren't any docs.
That makes so much more sense. Thanks for the help.
Oh ok, gotcha. So TypeScript allows you to provide generics but with constraints by providing the `F extends Foo`. Essentially the generic you provide for `F` must contain the members defined in `Foo`. The [TypeScript documentation](https://www.typescriptlang.org/docs/handbook/generics.html) has some simple examples of this such as the one below: ``` interface Lengthwise { length: number; } function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T { console.log(arg.length); // Now we know it has a .length property, so no more error return arg; } ``` The section below this example also provides an additional example similar to your `Foo&lt;S, E extends G, A)`. Essentially this is the same as above except `E` has a constraint. Example from the TS docs: ``` function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) { return obj[key]; } let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, "a"); // okay getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'. ``` Technically you could write these as a single letter or as descriptive as you want, it comes down to preference and coding style. I hope that helps. 
Thanks for taking the time to explain. I'm rather familiar with OOP (started with Java and python) and static typing (did some Java and C). If the type names are clear or initials are obvious, I can read types well. I bet your explanation will help others. My issue is knowing exactly what each letter represents if it's not stated anywhere. An example that showed up in another comment was me thinking R in a generic was "returns" (it was an async action, so I was thinking Promise&lt;R&gt;), but another suggested "reducer". It's not so bad in a generic by itself but compounds confusion when 5+ different types using 3-4 vague generics are tied together. I can dig through the code to figure it out, but it's time-consuming for each library. Even a simple docstring with "takes reducer R, action A, and enhancer E" would do wonders.
I would personally use longer type names in these more complex cases, even though I use T and U for simpler, more abstract definitions.
It is because functional programming originated in algebra, and algebra uses only single letters for variables, since letters together imply multiplication: "ab" means "a\*b".
If it's not a generic, that just breaks my heart.
So much more readable
Simple generics benefit more from terseness, e.g.: type UnwrapPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : never; Whereas complex generics full of context do benefit a lot more from longer type names. IMO.
A generic type doesn’t need to be more than one letter because they don’t have a meaning (they are generic), they are just symbols that you can follow through the code. If a template is expected to be of a certain type, you’d usually see things like “T extends MyType” when it is defined for the first time. For example a generic List like List&lt;T&gt;, the T can be virtually anything, so there is no incentive to have it more explanatory. But now say you are making a class that expects a specific kind of object, you’d do MyList&lt;T extends MyModel&gt;. On the other end, one can argue for more verbose generic types, like GenericType List&lt;GenericType&gt;, MyList&lt;GenericModel extends MyModel&gt;. Which in some case might be more readable. But the doc or the code should be self explanatory enough.
Correct for sure in making longer names. More descriptive is good. If something is TRUELY generic for any type T makes sense. Past that, be descriptive!
How does it benefit? I literally understand nothing in that line :/
Attracting talent is vital for any company, especially software companies. I’m sure they also want to improve their image in web developers eyes since IE is an anchor on the whole industry.
Open source tech by big companies contribute to their stock
Companies often make languages because they need what the new language gives them. By making it open source you get a larger pool of people who know how to use it to hire from. You get involved with the open source community. Now you get free libraries. More users means more people testing the libraries you write. Big companies often rent out consultants. Hire out their experts on a technology they made. 
They use TypeScript internally.
Also VSCode For a lot of people their reputation is in the toilet, they are trying to repair it, or make amends. [halo effect](https://en.wikipedia.org/wiki/Halo_effect)
That'd just be because you don't understand generics and/or conditional types/inferring well enough. It's simpler than it looks. We define a generic type called `UnwrapPromise` that accepts one type argument, we're calling it `T` because it can technically be anything (we need to define it this way due to the quirk that you have to use conditional types to leverage the awesome `infer` keyword). We then check if this type extends a Promise. If it does, we assign the inner type (e.g. the inner type of `Promise&lt;string&gt;` would be `string`) to `U`, and return that following the ternary. If it doesn't, we return `never`, which essentially means the compiler stopping you in your tracks and forcing you to pass it nothing other than a promise. You could assign longer type names, for example `T` could be `TypeArg` and `U` could be `PromiseInnerType` or something, but when you understand the syntax well enough it's easier to follow with smaller letters. It's identical to how a traditional `for` loop is easier to follow with single character counter variable (e.g. `i`: `for (let i = 0; i &lt; 10; i++) {}`).
Azure TypeScript is better than JavaScript. And VS Code is the best IDE for working with TypeScript. And which hosting platform had the best integration with VS/VS Code? Azure. Doesn't matter if any of this is true, so long as you believe it enough to send them your precious cloud dollars.
Hm do you have a piece of example code using this typing? I'm still not sure I understand :(
WebStorm I think is just as good for working with Typescript, maybe a little better in some areas. But VS Code is free, can’t beat that if you’re on a budget. 
This is one of the big reasons. MS is making azure and TFS online, which are extremely heavyweight applications. Making those using JavaScript would be significantly harder
So here's how I like to think of enterprises that fund open source projects: it allows the companies to choose what their competitive focus is, while commoditizing everything else. Microsoft isn't interested in charging people money for TypeScript. It wouldn't be a particularly great business. But they are interested in attracting and retaining as many customers as possible to Azure and similar services. They also have an interest in there being a large pool of potential hires already familiar with the languages they use. Funding TypeScript gives them influence over a larger community in a way that compliments their service offerings.
Sometimes it's not about making money, but saving money! Kind of like a smart thermostat, it costs money up front but in the long run you spend less.
It's something intangible but seems like tech companies are good at making these judgments. Only works for large companies.
An anchor can be a good thing. IE is cancer!
They get to define the language instead of having to negotiate on some standards committee.
What are some areas that WebStorm is better at?
Not necessarily. Sometimes it is the best decision for a small company to create their own programming language. https://www.joelonsoftware.com/2006/09/01/wasabi/ Though to fair, this is becoming less and less common as the baseline languages become more powerful. It was much easier for Joel's company to write something better than .NET in 2006 than it would be today because .NET is just to much better than it was back then.
Read the first 2 paragraphs and feels like Go is for them.
Auto-suggestion. Responsiveness. Refactoring files. Refactoring variables. Moving between files. Git GUI. Docker management. Secure, out-of-the-box features that VS Code requires 3rd-party-plugins to use. Font ligatures. Editor familiarity when switching between languages. TSLint support. Auto-fixing. Superior “go-to-definition” and “find usages” and “show usages”. Superior inspection. Did I mention that it isn’t an electron app? API testing suite. Task tracking. Coverage display. Distraction free mode.
I feel VScode is more responsive. Electron apps are not more bloated than Java swing or what ever java frame work they use now. The go to definition and Tint works fine for me. None of that other stuff you mentioned I care about.
Lol this is cynical. Just to be clear, Typescript strictly follow standards and adopts them from phase 3. Also they help champion new standards. 
I wonder what sort of influence Google has with Angular being TS based.
https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish
"Embrace, extend, and extinguish", also known as "Embrace, extend, and exterminate", is a phrase that the U.S. Department of Justice found was used internally by Microsoft to describe its strategy for entering product categories involving widely used standards, extending those standards with proprietary capabilities, and then using those differences to strongly disadvantage its competitors.
I don't know, but if they want to increase their reputation/respect among web developers after the IE6-11 nightmare, it's working for me.
Early on, they announced they created typescript because many large customers asked for it. So, it wasn't directly about making money, but rather part of an large ecosystem that helps them keep their biggest customers.
Auto-imports for libraries much better in WebStorm - VS Code only seems to import your own files and ignores node_modules. Intellisense with libraries from typings seems to work much better, and hovering over methods gives you a nicely presented documentation panel. I guess WebStorm is full featured out-of-the-box whereas I needed to look into a number of extensions to do the same stuff in VS Code. I like both of them, and use them for different things - WebStorm definitely has an edge in terms of Angular development that I don't think even the Angular VS Code extensions beat - stuff in WebStorm like having a GUI menu to make components, services, etc... But the most important thing for me is intellisense in html templates...that's a particular gripe I have with VS Code - I can never seem to get intellisense in html templates in an Angular project. Might be user error though! 
I feel like maybe you haven't used VS Code much, I know for sure it has most of those features and I just haven't cared about the other ones (or don't understand them i.e. what secure out of the box features?)
I agree with most of this - for me it's not that it's an electron app, I just think WebStorm has more conveniences out of the box than VS Code. I use VS Code to write markdown and do smaller projects because it's less to fiddle with, less cluttered. No complaints about the interface on WebStorm, but sometimes VS Code is nice because it is simpler. One major drawback of VS Code though is the inability to pull the source control, console, dubugging or other panels out of the main window. Kind of makes using it on multiple monitors a bit difficult for me - WebStorm lets you do this with ease.
Microsoft's big shift towards open source is making it a very cool workplace to work at. No wonder many people are leaving other big companies to work there.
That doesn't really work when the product is open source. &amp;#x200B;
This might sound stupid, but as a WebStorm user that's been having to use VSCode for the last few months on and off, WebStorm just manages to reduce the amount of keystrokes I have to make the most. There's just something that feels off with VSCode, and I can't explain it. There are also some minor issues with indentation that annoy me.
I use WebStorm in my day-job and VS Code for my hobby projects. I vastly prefer WebStorm for all the reasons mentioned, and can work much faster on it.
I’m the opposite. Much prefer VSCode to webstorm 
It definitely is more of a text editor than an IDE especially if you like to keep it lean and not have too many extensions. But hey either way the best dev tool is the one you are most comfortable with. I trace my web dev roots back to building table-based website layouts in Notepad so editors like Sublime and VS Code are home to me. 
Guess what didn't exist in 2006?
[removed]
It whores itself out to Microsoft developers
Typescript doesn't make money. It's open source and sponsored by big tech giants like Microsoft and Google that use it extensively internally and in tools they provide developers that use their platforms and products. Microsoft has a HUGE development platform it makes money from: servers (cloud), operation systems, MSDN, commercial tools like visual studio, sql server, etc etc etc. It's in their best interested to get developers onto their platforms and using their tools. Nowadays you get a lot for free and if you need it you can pay for enterprise versions that offer more things like clustering and scaling and the likes (using SQL Server as an example). The freemium model is pretty common for open source technologies.
Using TS over JS doesn't make anything less heavyweight or easier. It just adds compile time type safety..
It's been roughly said below, but I feel this needs to be stated explicitly: They're NOT types. They're parameters. They're parameters of type "type". Think of them as a variable, which value is some type. Like you could write "T = int" in much the same way you would write "i = 0". This could be confusing because the "program" in which these are variables is "executed" at compile time. You can't actually assign a value into a generic type. But you can use it in a function-like call. e.g. you have: myFunc&lt;T&gt;(s : T) : void And then you can call: myFunc&lt;int&gt;(0) Here, we first assigned (at compile time), through parameter specification, "T=int", and then assigned (at run time), in the same way, "s=0". Just as you'd normally have short-named variables and parameters for "regular" types like "i", "j", "n", "x", "y", etc, you also use short names for generic types, as in, variables of type "type". One might argue that even for regular variables, it's better to have longer names. I'd counter argue with this: for (var indexForRunningOverArray = 0; indexForRunningOverArray &lt; arrayImRunningOver.length; indexForRunningOverArray++) { if (arrayImRunningOver[indexForRunningOverArray] === valueImSearchingFor) { return true; } } return false; Verbose is often the opposite of readable. That's why the word "brevity" exists. So yeah, these are parameters, their usage is understood from the context where you find them (like with any parameter), and they're short for brevity. As a rule of thumb, long names should be reserved for things you export/use across files/APIs.
Exactly this. Creating top developer experience to lead devs to Azure. 
More explicitly, during the Windows 8 development cycle, the Windows and DevDiv orgs were heavily promoting HTML/JS application development. Microsoft had a bunch of C# developers. TypeScript was a more comfortable transition because it addressed a couple of the common complaints about JavaScript. 
tsc sounds to me like the easier option just because it means less moving parts total. Configuration seems easier, too, since you create a single tsconfig for each build target. But I don't know which is faster.
Agreed. tsc is straight from the Typescript developers. So, I feel it's generally going to be more reliable and consistent. Using the babel plugin also has some limitations, like no namespaces. My team and I really like namespaces.
One thing to consider is that if you’re using react hot loader you have to use Babel loader anyway
Thanks that is helpful to know. Does TS support all the ESNext feature that Babel would? I am wondering if that's not the case, have to use Babel anyways
What would they be using react-hot-loader for in a utility library?
For a library, especially one of JS utilities? Dude, tsc (as rollup-plugin-typescript) + rollup. Dead simple to configure with multiple target/bundle options.
Author here. I wrote this post to discuss Typescript's differences with other type systems through the implementation of several methods that would be rather difficult to write in stricter systems. I'm not much of a writer and I haven't really attempted since I previously wrote about using flux and redux together several years ago. If anyone has any questions or suggestions, or notices anything egregiously wrong in what I've said, please let me know. I hope some of you might find this helpful!
I don't know, but if you use anything that requires a polyfill, then you will have to use Babel.
TypeScript generally supports anything in stage 3 or better.
I'd probably roll plain tsc for a lib. Output the js, .d.ts and source maps into the same folder (different from source folder). Babel for "endpoint" code since one would use things like HMR, useful babel plugins, etc
Thanks. That sounds good. By endpoint, you mean the consumer of the library ?
Yeah. Some downsides of webpack and babel are quite flaky sourcemaps (or I havent researched enough). And unreadable async/await generated code...
Thanks this was a great read. I find the Typescript type system to be one of the most powerful out there. Some of the things you can do are mind bending. Varadic type support looks like another fantastic feature that will only cement my belief here. 
[This emulator](https://github.com/GoogleCloudPlatform/cloud-functions-emulator/wiki/Debugging-with-Visual-Studio-Code) seems like it might help. Regardless of that though, generally VSCode needs to attach to a process to use the debugger, so it really depends on how you are testing your function.
Note that Babel doesn’t support all features as tsc does. emitDecoratorMetadata is not supported to name one. 
Uhh... No. Absolutely not. I use several features that require polyfills and I don't use Babel.
Interesting post! For the future I recommend not using images for code snippets, they don't scale and are basically impossible to read on mobile.
They also can't be easily copied.
 GitHub gists are ideal alternative for medium.
Thanks for the feedback! I will try to update my code snippets today to gists. 
Free Software does not refer to an economic model, just a distribution method and ethos. Not everything needs a direct business model, either.
You realise MS is company not a charity right?
This things was creating for test, you can provide component method, and just in that method redefine Injections
this is like adding // TODO: fix later and hoping that you’ll actually come back and fix later
One thing that tripped me up, when using `--module=esnext` and `--target=es5` for dynamic imports with webpack, I had to bundle core-js polyfills
nestjs - [https://github.com/nestjs/nest](https://github.com/nestjs/nest) routing-controllers - [https://github.com/typestack/routing-controllers](https://github.com/typestack/routing-controllers)
A framework to do what exactly?
Sure, but that's not really dependency injection. It's something else entirely, which may be useful for your test scenarios.
Counter productive, since types makes it EASIER to refactor, not harder. 
Except that the author proposes naming your `any` aliases according to why you used `any`. This makes it easier to eliminate an entire class of problem (`anyUntilTS28`) when it's possible. My understanding is that Google uses this for TypeScript version updates.
Nest has been absolutely amazing to develop in!
&lt;3
A framework like Koa but build for Typescript.
Yes, with a few differences that makes it easier to come back: * all problems are listed in a single file (`temporaryAny.d.ts`) * if you delete single `temporaryAny`, `tsc` points you to all occurrences 
By writing a declaration file, you are telling consumers of your code what the api of your package is. So it's not really a case of "best", but instead reflecting reality and making the declaration file match what you are offering. Your API looks straightforward so I think you're going to learn the most by trying to do it yourself! The docs to read start at [https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html). You'll find lots of examples in there. You can look at what other packages have done (typings for all major npm packages can be found on npm under `@types/{packageName}`).
This was a fun case study to read! Also, TIL `unknown`.
Take me a moment to spot the difference there. You could've just show the last line. 
Just to avoid any possible confusion for people with less experience, ES6 is not exclusive to Typescript.
True, but r/js doesn't allow memes haha
I think you can do ``` import { ClickParam } from "antd/lib/menu/index"; ``` I believe there is a setting in webpack for aliases, but I'm not sure.
https://stackoverflow.com/questions/38601592/typescript-import-path-alias `import { clickParam } from "antd/lib/menu"` You don't need `/index`
[ClickParam](https://github.com/ant-design/ant-design/search?q=ClickParam&amp;unscoped_q=ClickParam) isn't exported at a higher level. You'll need to pluck it from that file.
&gt;`type UnwrapPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : never;` We want to "unwrap promise". We read `extends` and ternary operator as in runtime code, so *if T is a Promise of U, we return U* (and we totally don't care what U is), *else we return never*. 
This is the type of value you get as argument of Promise.then callback. const promise: Promise&lt;number&gt; = /* ... */ promise.then(val /* val is UnwrapPromise&lt;Promise&lt;number&gt;&gt; so number =&gt; /* .. */) And some (really silly) runtime code in which you would need this type here: ``` function waitForTwo(): Promise&lt;2&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; resolve(2), 1000); }); }; type UnwrapPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : never; type MultipliedPromise&lt;T&gt; = Promise&lt;Array&lt;UnwrapPromise&lt;T&gt;&gt;&gt;; function multiplyPromise&lt;T extends Promise&lt;any&gt;&gt;(promise: T, n: number): MultipliedPromise&lt;T&gt; function multiplyPromise&lt;T&gt;(promise: T, n: number): MultipliedPromise&lt;T&gt; | "wat" { if (promise instanceof Promise) { return Promise.all(new Array(n).fill(promise)); } return "wat"; } const promiseForTenTwos = multiplyPromise(waitForTwo(), 10); promiseForTenTwos.then(console.log); // [2, 2, 2, 2, 2, 2, 2, 2, 2, 2] ```
If you specify an absolute path for the import, it is read from node\_modules so you don't need the "../../../node\_modules" `import { ClickParam } from "antd/lib/menu/index"` will be exactly the same. [https://www.typescriptlang.org/docs/handbook/module-resolution.html](https://www.typescriptlang.org/docs/handbook/module-resolution.html) has all the details. However, beware of using the path mapping in the compiler options to make the paths shorter. That will work for the compiler but it won't affect the generated javascript so you can find that the paths don't get resolved as expected at runtime.
That's a good rule. This subreddit should adopt it.
Looks fine, what are you expecting to see? You won't see the logging in your A B C ... order if that's what you're expecting? 
Fuck yes. I had issues with their configuration files beeing in js and I lost many hours because of this since my project is in ts and I import other ts classes. Hopefully this is solve all the workarounds and hacks I did and my code base will be cleaner!
Is this the first Facebook project to use TypeScript?
Yeah, I think so.
Nice! We just started setting up Jest tests for our Angular and Nestjs project!
And hopefully next they'll get rid of the magic global variables and instead provide modules.
I don't see any console.log in the code, so not sure what do you expect to be the result. However, this code seems suspicious: ```ts let allSymbols = await getSymbols(document); await Promise.all(allSymbols); allSymbols = allSymbols.filter(symbol =&gt; symbol.kind === 5 &amp;&amp; symbol.location.range.start.character === 14); ``` Here `await Promise.all(allSymbols);`, you don't use the result of the awaiting, but use `allSymbols.filter` later which should be an array of promises and not an array of resolved results. I assume `allSymbols` is an array of promises because you are awaiting them in the previous line. I don't know VSCode's API so maybe I'm wrong. Also, you don't need async/await in the first 2 functions. It functionality equivalent to return the promise normally.
Although Create React App has integrated support for TypeScript, and I believe Jest had already added support for zero-config use of TypeScript. Not the same as actually using TS themselves, but the writing was on the wall.
Unrelated: You probably don't want to use `return await`. [See here](https://jakearchibald.com/2017/await-vs-return-vs-return-await/).
Regarding `return await`, it may be helpful to [read this](https://jakearchibald.com/2017/await-vs-return-vs-return-await/).
Honestly though, this^. My projects are either from my set of boilerplate or they're not getting testing. TS is my unit test
Excess property checking probably doesn't apply to union types. That's my guess.
yes I'm familiar with asynchronous/await, but OP doesn't use try/catch.
Hey. This article was useful to me. Thanks! &gt; Outside of try/catch blocks, return await is redundant.
It only applies to *discriminated* unions: https://github.com/Microsoft/TypeScript/issues/20863 
TypeScript is lenient on plain unions. As long as the property exist *somewhere* in the union, it'll let it pass. [For example](https://www.typescriptlang.org/play/index.html): type A = { x: number } | { y: number } let a: A = { x: 10, y: 20 } // This passes If you want more strict checking, you need to use a **tagged** union. This is a union that is differentiated by a key. [Modifying your example](https://www.typescriptlang.org/play/index.html#src=interface%20A%20%7B%0D%0A%20%20%20%20myTag%3A%20%22A%22%3B%0D%0A%20%20%20%20a%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20B%20extends%20A%20%7B%0D%0A%20%20%20%20myTag%3A%20%22B%22%3B%0D%0A%20%20%20%20shared%3A%20boolean%3B%0D%0A%20%20%20%20b%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20C%20extends%20A%20%7B%0D%0A%20%20%20%20myTag%3A%20%22C%22%3B%0D%0A%20%20%20%20shared%3A%20boolean%3B%0D%0A%20%20%20%20c%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Atype%20ABC%20%3D%20A%20%7C%20B%20%7C%20C%3B%0D%0A%0D%0Alet%20test%3A%20ABC%20%3D%20%7B%0D%0A%20%20%20%20a%3A%20%22%22%2C%0D%0A%20%20%20%20%2F%2Fshared%3A%20true%2C%0D%0A%20%20%20%20c%3A%20%22%22%0D%0A%7D): interface A { myTag: "A"; a: string; } interface B extends A { myTag: "B"; shared: boolean; b: string; } interface C extends A { myTag: "C"; shared: boolean; c: string; } Here our tag property is `myTag`. It can have any name, as long as you use string literals for its type. With this change, your `let test` example will now fail. It requires a `myTag` property that equals `"A"`, `"B"`, or `"C"`. Once you add it, TypeScript will throw a type error on invalid properties.
Comment was for the benefit of OP 😀
gotcha
Nice article! I did not know about the `-?` syntax in mapped types to turn an optional property into a required property. For context, this is the example from the article: type Required&lt;T&gt; = { [P in keyof T]-?: T[P]; }; It looks like that feature was added in Typescript v2.8, and the `readonly` modifier can also be removed. From the [v2.8 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html): &gt; TypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a readonly or ? property modifier in a mapped type can now be prefixed with either + or - to indicate that the modifier should be added or removed
Top one seems more readable 
This is a horrible recommendation. The guy said he’s a complete noob, and obviously doesn’t completely understand Typescript by itself, let alone understand how to use a framework on top of that. Also, it doesn’t even sound like this is a project that requires a heavy front end framework like angular. OP... Don’t listen to all the people telling you to learn frameworks you’ve never heard of. Just learn the basics of JavaScript/TypeScript first. If you try to jump into a framework you don’t understand using a language you don’t understand, you’re basically working in an environment where you’re guessing at everything. Things might start working, but you won’t be able to explain why. Learn the language. Then, once you understand it, you can start adding things on top. 
Lol why is this being upvoted, it doesn't even compile. You cant extend A like this. `myTag: "B"` is in direct contradiction with A interface. 
thx, the link links to other issues that describe what I too found out today. I actually think this is a rather serious issue because the compiler lets you happily run into a TypeError exception: interface A { a: string; } interface ICommonProps { blabla: string; } interface B extends A { b: string; shared: ICommonProps; } interface C extends A { c: string; shared: ICommonProps; } type ABC = A | B | C; let test: ABC = { a: "", c: "" }; if("c" in test) { //Compile Time: Fine for TypeScript //Run Time: Uncaught TypeError: Cannot read property 'blabla' of undefined console.log(test.shared.blabla); } This is even with strictNullChecks :(
Yup, you're correct. A cannot have myTag in it if it is the base of B and C.
The \[\] syntax is kind of shorthand, you can declare arrays using Array&lt;&gt;. Here you want: `reports: Array&lt;ReportA | ReportB&gt;` Additionally, typescript has a ReadonlyArray type that can be used to be sure you don't accidentally call any functions that mutate the array. `reports: ReadonlyArray&lt;ReportA | ReportB&gt;`
Thanks a mil for this. The templating with keyof is exactly what I needed. Much appreciated!
Hey, so when I don't have the await, it doesn't work, even though the article linked below indicates it should. Let me show you my original spaghetti code, in which the console.log works: public async provideCodeLenses(document: TextDocument, token: CancellationToken): Promise&lt;CodeLens[]&gt; { return await new Promise&lt;CodeLens[]&gt;((resolve, reject) =&gt; { // make another function that takes the getsymbols and returns an array of codelenses instead. const codeLenses = new Array&lt;CodeLens&gt;(); // get promise for all symbols in current document getSymbols(document) .then(symbols =&gt; { symbols.forEach(symbol =&gt; { // symbol is global function if (symbol.kind === 5 &amp;&amp; symbol.location.range.start.character === 14) { // get promise for all reference locations (Location[]) getReferences(symbol.location) .then(references =&gt; { // need to double check, but no reference functions return a size one array (reference to themselves afaik) if (references.length &gt; 1) { // this bool will be used to track for any external ref let externalRef = false; // external references would likely be the last in the array, but I don't know if I can guarantee that. references.forEach(reference =&gt; { externalRef = externalRef || symbol.location.uri.toString() !== reference.uri.toString(); }); // if we didn't find an external ref, we can localize the function if (!externalRef) { // add to list codeLenses.push(new LocalizeLens(document, symbol)); console.log("Codelens maybe local: " + symbol.name); } } }); } }); }); resolve(codeLenses); }); } I've tried to take this apart and reassemble it, but I can never return the codelenses accordingly, but the print line works great.
Disclaimer: I'm the maintainer of the framework. Depending on what you need, you might be interested in [FoalTS](https://foalts.org). It is written in TypeScript, offers built-in dev tools and has a large set of integrated components useful in common situations (password encryption, authentication, validation, etc). 
I believe this matches type A actually? You have a valid “a” property which is sufficient 
Do you have a small code example? I can't really help without seeing what type you're intending on narrowing and where.
Yeah that is had.
This seems pretty serious issue indeed, would be interesting to know details why this is possible
Great post.
I have an ExchangeInformation class like so (i left unecessary information out for brevity): `export class ExchangeInformation {` `private _exchangeFilters: ExchangeFilter[] = [];` `constructor(obj:ExchangeInfoResponse) {` `for (let index of obj.exchangeFilters) {` `switch (index.filterType) {` `/* Here I would like to be able to use index as the constructor for my filter classes without having to do` `new Filter(index as SomeFilterClass) but it's not letting me. */` `}` `}` `}` `}` filterType is unique string for each filter. The ExchangeFilter interface looks like this: `export type ExchangeFilter = ExchangeMaxAlgoOrdersFilter | ExchangeMaxOrdersFilter;` and both ExchangeMaxAlgoOrdersFilter and ExchangeMaxOrdersFilter are classes that expect a similar but different constructor (property names are slightly different). Looks like this: `import { Filter, FilterConstructor } from '../Filter';` `export interface ExchangeMaxAlgoOrdersFilterConstructor extends FilterConstructor {` `maxNumAlgoOrders: number;` `}` `export class ExchangeMaxAlgoOrdersFilter extends Filter {` `private _maxNumAlgoOrders: number;` `constructor(obj: ExchangeMaxAlgoOrdersFilterConstructor) {` `super(obj);` `this._maxNumAlgoOrders = obj.maxNumAlgoOrders;` `}` `get maxNumAlgoOrders(): number {` `return this._maxNumAlgoOrders;` `}` `}` &amp;#x200B;
Do you have a type for ExchangeInfoResponse (let's call that E from now on)? I may be off-base, but what it seems like you're trying to do in the ExchangeInformation constructor is assert that an element of E['exchangeFilters'] is a class, when actually it's a plain JavaScript object matching the FilterConstructor interface. That doesn't really work because all Filter expects is FilterConstructor
Here's the whole ExchangeInfo module if it can give you clearer picture. What i'm trying to do is have the code determine which class to use to build the filter object/class. Index will always be the constructor but typescript doesnt agree unless I cast it like i've done below. Is there a better way to do this? import { ExchangeFilter, ExchangeMaxAlgoOrdersFilter, ExchangeMaxAlgoOrdersFilterConstructor, ExchangeMaxOrdersFilter, ExchangeMaxOrdersFilterConstructor } from './Filters/ExchangeFilters'; import { Limiter } from './RateLimiter'; import { Symbol } from './Symbol'; export interface ExchangeInfoResponse { exchangeFilters: ExchangeFilter[]; rateLimits: Limiter[]; serverTime: number; symbols: Symbol[]; timezone: string; } export class ExchangeInfo { private _exchangeFilters: ExchangeFilter[] = []; private _rateLimits: Limiter[] = []; private _serverTime: number; private _symbols: Symbol[] = []; private _timezone: string; constructor(obj: ExchangeInfoResponse) { this._serverTime = obj.serverTime; this._timezone = obj.timezone; for (let index of obj.exchangeFilters) { switch (index.filterType) { case 'EXCHANGE_MAX_ALGO_ORDERS': this._exchangeFilters.push( new ExchangeMaxAlgoOrdersFilter( index as ExchangeMaxAlgoOrdersFilterConstructor ) ); break; case 'EXCHANGE_MAX_NUM_ORDERS': this._exchangeFilters.push( new ExchangeMaxOrdersFilter(index as ExchangeMaxOrdersFilterConstructor) ); break; default: break; } } for (let index of obj.rateLimits) { this._rateLimits.push(new Limiter(index)); } for (let index of obj.symbols) { this._symbols.push(new Symbol(index)); } } get filters(): ExchangeFilter[] { return this._exchangeFilters; } get rateLimits(): Limiter[] { return this._rateLimits; } get serverTime(): number { return this._serverTime; } get symbols(): Symbol[] { return this._symbols; } get timezone(): string { return this._timezone; } } &amp;#x200B;
Your ExchangeFilter type is essentially a discriminated union, with filterType being the discriminator. For typing to narrow correctly, filterType must be unique for each member of the ExchangeFilter union. So the following should probably work: interface FilterConstructor { filterType: string } // ahh, that is such a long name interface ExchangeMaxAlgoOrdersFilterConstructor extends FilterConstructor { // here we use a string literal type to indicate that filterType will always have this value. // This is what enables the discrimination filterType: 'EXCHANGE_MAX_ALGO_ORDERS' // ...some other stuff } interface FilterC2 { filterType: 'ExampleFilter' } type ExchangeFilter = ExchangeMaxAlgoOrdersFilterConstructor | FilterC2 // now if you switch on filterType switch (index.filterType) { case 'EXCHANGE_MAX_ALGO_ORDERS': // type of index should be narrowed to ExchangeMaxAlgoOrdersFilterConstructor break; case 'ExampleFilter': // index should be narrowed to ExampleFilter break; default: break; } The real key is to have that discriminated key (filterType) be unique in each member. I use string literals, but you can use any type that is disjoint (enums, number literals, etc). I would recommend string literals because that's most likely what matches your json data from the server (an enum has an actual value in typescript, one of the only - or the only? - runtime constructs that the compiler creates)
A discriminated union is what I was going for yes. I'll give it a go, thanks for the help!
Ok so I thinkered a bit with it and now my filter classes look like this and typescript is not complaining anymore but it looks kinda weird to me, do you see a problem with the following? &amp;#x200B; export interface ExchangeMaxAlgoOrdersFilterConstructor { filterType: 'EXCHANGE_MAX_ALGO_ORDERS'; maxNumAlgoOrders: number; } export class ExchangeMaxAlgoOrdersFilter { private _filterType: 'EXCHANGE_MAX_ALGO_ORDERS'; private _maxNumAlgoOrders: number; constructor(obj: ExchangeMaxAlgoOrdersFilterConstructor) { this._filterType = 'EXCHANGE_MAX_ALGO_ORDERS'; this._maxNumAlgoOrders = obj.maxNumAlgoOrders; } get filterType(): 'EXCHANGE_MAX_ALGO_ORDERS' { return this._filterType; } get maxNumAlgoOrders(): number { return this._maxNumAlgoOrders; } } &amp;#x200B;
FoalTS looks really good.
Google's Closure compiler can use TS type information if used with https://github.com/angular/tsickle
I have never declared an enum, i just export them and that works fine. export enum SomeEnum { value1 }
Angular can be a good starting point, easy to jump in, easy to experiment. Your advice is 100% true if you have a couple months to learn the fundamentals (JS), but sometimes you have to adapt, and learn the things on the fly (in my opinion). Also, &gt; you’re basically working in an environment where you’re guessing at everything that's literally what every programmer does every day
Unless you've actually created the enum somewhere else, this wouldn't work. A const enum should work if you're compiling with \`tsc\`
I'm not 100% sure but to place a binary bet on it, I'd bet that it is a type-checking bug in TypeScript itself. It would be fair to raise an issue on it over on TypeScript GitHub but whether or not it gets accepted as a bug or otherwise explained away is another matter.
Yikes, can you add that case to the linked issue? I think the TS team would appreciate seeing a super simple test case like this that shows a real runtime error
Assuming your declaration file is correct, what you've got there is a numeric enum. In JavaScript that's an object with six properties as follows: `{ [value1]: 1, [value2]: 2, [value3]: 3, [1]: 1, [2]: 2, [3]: 3 }` So if you are assigning members of the enum to other variables, it will work if those variables are typed to be numbers; if not then you will get an error. Doesn't sound like the definition of the enums is in your control, but if you want strings as output then you have to define those in the enum eg `enum Foo { value1: "value1", value2: "value2", value3: "value3" }`
If the script adds something to the global scope, use augmentation to declare it. 
I again disagree. Not every developer is lost because they’re working on technology they never actually learned... many developers put in the time to know what they’re doing. Learning in the fly is a great skill, of course, and extremely useful in our field, but to say every developer is guessing all day is simply not true.
I again disagree. Not every developer is lost because they’re working on technology they never actually learned... many developers put in the time to know what they’re doing. Learning in the fly is a great skill, of course, and extremely useful in our field, but to say every developer is guessing all day is simply not true.
If you do use webpack, you need to find its exported name And https://webpack.js.org/configuration/externals/ 
It does add something to the global scope. I'm not sure what augmentation is though, can you share a resource?
That didn't seem to help. I should point out that i'm not getting this error, if i use the global methods i'm trying to access, in a .js file. This is happening only in .ts files
You can \`declare\` variables as \[described here\]([https://basarat.gitbooks.io/typescript/docs/types/ambient/intro.html](https://basarat.gitbooks.io/typescript/docs/types/ambient/intro.html)). But before, try to add \`@types/packagename\` to your dependencies, because the declaration might already have been made for you. &amp;#x200B;
You still need to npm install the same version as used in the CDN or type definition only and import it as is. Or you could just define a global variable and it's type definition as in other comment. Like `declare var $: any` But the first method is preferred.
\&gt; You still need to npm install the same version as used in the CDN The library i'm using doesn't exist as an npm package, there is no other way to use it apart from a cdn link or maybe saving the code the CDN serves in a local .js file
Did you create a type definition file? If not you just need to declare var any or something like that depending on your external file 
The library i'm using does not exist as an npm package, nor does it have type definitions. However adding a global declaration like this: ``` declare const libName: any; ``` Seems to solve the missing name error. Thank you.
The first line shows the type definition of "props" (it defines "foo"), so it's relevant
Lots of convenient "new" syntax seems harder to read at first, until people get used to it and end up finding it more readable or more convenient. The main advantage is so you can easily do something like const { foo, bar, baz } = this.props which is a very common thing when working with react.
One thing that's too often missing from these articles are concrete examples of how these advanced features can benefit you when writing real applications. Obviously, we benefit from the increased power when creating abstractions, but it's kind of hard to demonstrate their usefulness if the example is going to be "well, imagine this huge and complicated hierarchy of classes and how they relate to each other -- advanced types lets us do this and that" because it is simply too.. extensive. Anyway, let me share a concrete example of something I did just recently to make my life easier. I've been working on this pretty straight-forward CRUD application for a client. For the most part, it's about filling out a rather complicated form, for which I use `redux-form`(I'm not sure I can ever do forms again without it -- what a great library!). There are *a lot* of fields and several subforms, but they all get throw into a rather large datatype which can also have other nested object types: interface ICase { someField: string; anotherField: number; // .. lots more simple fields .. nestedObject: { // filled in a subform nestedSimpleField: boolean; anotherNestedObject: { // .. } }; // .. more simple and nested fields .. } For a lot of the fields, my client wants tooltips, and he's asked me to make it possible for him to add these tooltips himself(just by editing code), and I figured I would try to make this process as foolproof as possible. Preferably, it should be impossible for him to try to add a tooltip to a field that doesn't exist(or to make typos and so on). Using some of typescript's functionality, I was able to take the type above, and create another type which matches it in structure except every field should now map to a string, except for nested fields -- this transformation should be applied to nested fields again, recursively. Before explaining this, a minor digression is needed: When you create a `Field` component using `redux-form`, you have access to the name of the field. For example, for `someField`, I would be given `"someField"` via the props, and for a nested field, or an array field, I would be given `nestedObject.nestedSimpleField` or `nestedArray[0].someNestedField`. In my case, all the nested complex fields in our main `ICase` object are actually arrays of objects. What I would like to do is take this field name, split it up so that we would get `["nestedObject", "nestedSimpleField"]` and `["nestedArray", "someNestedField"]`, and use these arrays as paths into some object that contains our tooltips and display tooltips for the fields for which tooltips have been defined. To accomplish this, I came up with the following types: // filter all keys that are arrays and not arrays, respectively type AllArrayKeys&lt;T&gt; = { [K in keyof T]: T[K] extends any[] ? K : never }[keyof T]; type AllNonArrayKeys&lt;T&gt; = { [K in keyof T]: T[K] extends any[] ? never : K }[keyof T]; // If a type is an array, just return the element type -- unfortunately, conditional types cannot be self-recursive so we can't remove an arbitrary number of array layers type RemoveArray&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T; // transform all array fields using TooltipType again(after transforming them to their element type) // and otherwise transform all non-array fields into string fields type TooltipType&lt;T&gt; = { [K in AllArrayKeys&lt;T&gt;]?: TooltipType&lt;RemoveArray&lt;T[K]&gt;&gt; } &amp; { [U in AllNonArrayKeys&lt;T&gt;]?: string }; These types make the following possible: interface INestedExample { nestedField: number; moreNested: Array&lt;{ moreNestedField: number }&gt;; } interface IExample { someField: string; anotherField: boolean; nestedObjects: INestedExample[]; } const tooltipExample: TooltipType&lt;IExample&gt; = { anotherField: "this is a tooltip for another field", // nonExistentField: "whatever" --- this would be a type error nestedObjects: { nestedField: "another tooltip", moreNested: { moreNestedField: "third tooltip", }, }, }; This means that my client can now go into the code, and he can add tooltips for all the fields he wants and it is impossible for him to make a mistake by adding a tooltip for a field that doesn't exist. Currently, I don't have any type-safety when creating redux-form `Field` components, so it's possible to make a typo there, and I also just drop type-safety on the floor when I split the field names and look them up in the `tooltipExample` object by treating it as `any`, but it's still a lot better than the alternative. This got a good deal longer than I expected, but I hope this is useful for someone, at least. There are certainly improvements to be made, and I'm still grokking the typescript type system properly. The `AllArrayKeys` and its counterpart are kind of hacky -- ideally, I would like to be able to find all "non simple object types" without having to look for array fields, but I was not sure how to accomplish this, and in my scenario, all our nested objects are in arrays, so I went with this hack for now. If you have a better solution, please let me know. 
You can still install the types that the library uses by running `npm i -D @types/library-name`
&gt; How can I properly type this so that only the first two overloads are exposed to the class users? This is already the case. The line with the implementation is not presented as a choice. It's only visible to the implementer, and the signature must be compatible with all overloads.
Yes you can do that if the types exist, but they don't (in my case). There are still lots of libraries without TS definitions unfortunatelly.
Oh... for some reason I though it was exposed as well, but I was probably confused by my IDE. Indeed, it seems like the implementation line is excluded from the overloads. Thanks for clarification!
In that case, just use the \`any\` type for whatever you're doing.
The issue i was having wasn't related to missing type definitions. TS didn't pick up a variable name, because it was injected in the global scope by a CDN library. This was the solution that helped me - https://www.reddit.com/r/typescript/comments/agx62z/how_do_you_use_libraries_imported_via_cdn/ee9qm1h
Yeah, that's what I meant by using the`any` type. Nice to see that you resolved it, though.
The \`user\` param in the implementation needs to be marked as optional to make this compile correctly. The signature of the implementation must be compatible with all overload signatures.
Thanks for noticing, corrected it. I actually made it optional in the real code, but mistyped here.
This is handy. I still prefer the 3 line method of doing things in this situation, though. I don’t see myself ever jumping on this syntax... not for me. 
Some general feedback: I would suggest changing the way you implement the functions. Rather than having the implementation contain logic based on the parameters, I would expose `removeUser(line: number, user: User) {}` which removes a specific user from that line, and then `removeUser(user: User) {}` that loops over all lines (or however else you want to do it) and calls into the first method. This gives each function a specific responsibility, and isolates them from each other. To take it a step further, you could name one `removeUserFromAllLines()` and the other `removeUserFromLine()` to help callers distinguish at a glance what they do differently.
Thanks for your response anyway! In a real project a would probably use different methods, and making one of them build upon the other is certainly a good idea.
It's fair. Personally I felt exactly the same way, but eventually had to use it to make my life easier with all the props (especially the long named ones). It felt dirty at first, but eventually ended up liking it. Now it's second nature and it feels wrong to see the previous way of doing it.
I cleaned this up and now im not nesting promises. ``` import * as functions from 'firebase-functions'; import * as admin from 'firebase-admin'; import * as https from 'https'; import axios from 'axios'; export const updateForecasts = functions.https.onRequest((request, response) =&gt; { admin.initializeApp() const db = admin.firestore(); db.settings({timestampsInSnapshots: true}); const agent = new https.Agent({ rejectUnauthorized: false }); const fetchForecastsPromise = (spotId) =&gt; axios.get(`http://api.spitcast.com/api/spot/forecast/${spotId}`, { httpsAgent: agent }); const spotIds = [1, 2, 3, 4]; Promise.all( spotIds.map( spotId =&gt; fetchForecastsPromise(spotId) .then(resp =&gt; db.doc(`spots/${spotId}`).update({forecasts: resp.data})) .then(resp =&gt; db.doc(`spots/${spotId}`).get()) .then(resp =&gt; resp.data()) ) ) .then((results) =&gt; { response.status(200).send(results); }) .catch((e) =&gt; { response.status(500).send(e); }); }); ```
As is mentioned above, the actual implementation is not exposed to the users. However, if you really want the signature of the implementation to be strict (or to be precise, correct, because the current signature is WRONG, because it allows both params to be of \`User\` type), you can write in the following manner: &amp;#x200B; \`\`\`typescript removeUser(...params: \[User\] | \[number, User\]) {} \`\`\` &amp;#x200B; &amp;#x200B;
Thanks, I haven't though of the possibility to make it more strict like this. The only downsides are that the parameter names are lost (but since the publicly-exposed overloads still have them, it's a minor issue) and this causes an allocation of `arguments` object in the compiled code. The latter usually doesn't matter except for stuff like performance-tight game/simulation loops. But I think overloads wouldn't be used in performance-sensitive places anyway.
\&gt; I believe Jest had already added support for zero-config use of TypeScript &amp;#x200B; Do you have a source on that? I don't think that's true.
The strict flag is not enabled. No thanks.
Yes! See this PR: https://github.com/facebook/jest/pull/7533
Nice article, my team has a very similar setup and have been happy with it so far (this is a team of TS devs learning RN for the first time). I also have my own template for setting up such a project, while also adding Detox for e2e testing: https://github.com/solkaz/react-native-template-ts-detox-jest
Neat.
Why would that be better? This library is isomorphic.
Why would that be "better" exactly?
Compatibility with code using NodeJS' EventEmitter's interface?
I bet you can change your library to be reduced to only type definitions, so that there is 0 runtime overhead &amp; the standard NodeJS EventEmitter can be used. See examples below: https://pastebin.com/embed_iframe/ALntBpSn Commenting out the invalid call that correctly triggers an error, the code is then compiled to: ``` "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); const events_1 = require("events"); const ee = new events_1.EventEmitter(); // ee.on("login", (invalid: boolean) =&gt; {}); ee.on("login", (user) =&gt; { }); //# sourceMappingURL=index.js.map ``` That way you can have the best of both worlds: More strongly compile-time checked EventEmitter, without reinventing or reimplementing any existing features. (Note: that any-cast is dirty, I know that; Maybe there is a way to fix that without runtime overhead?)
Even better: Actually using NoteJS's EventEmitter implementation. Otherwise, you'll have to ship 2 EventEmitter implementations: One from OP, and the NodeJS one that is a dependency of some other library.
At that point, you might as well take the types from \`ee-ts\` and contribute them to \`@types/node\`. :) &amp;#x200B; But \`ee-ts\` is not aiming to be identical to the built-in NodeJS \`EventEmitter\` class. For better or for worse.
Just FYI, mocha does not look at tsconfig. Read the ts-node readme and search for “register”.
Are you the author of this package? I would love to try it out in my assemblyscript test suite. 
Nice. Have you looked at json schema to do the verification? 
Another pattern I've seen for this is json decoders. You should look at those too OP. 
I think this is extremely exciting. It seems to do the type-checking by importing the file with the types at runtime (also at a 1-2s performance hit the first time, ouch!). I wonder how something like this would work in e.g. a bundled web application. Perhaps you can improve all of these problems by leveraging the typescript transformer API, and generating the checks at compile-time?
Pretty similar to a schema validator.
Add the following to your test command. Note: I also use tsconfig-paths for my custom absolute import paths: -r ts-node/register -r tsconfig-paths/register
Nice looks pretty interesting, have to give this a try sometime.
It doesn't look very close to being ready for production use.
Just use nest.js dude
Looks cool! Most frameworks seem to be internally written in TypeScript nowadays, giving the user the option to build their app / library in TypeScript as well. I would be curious as to the benefits of this and what unique problems it solves. &amp;#x200B; One project I am particularly excited about is [https://stenciljs.com/](https://stenciljs.com/) with TypeScript support.
I use next.js but thiss framework is different. Its more like next.ts
Nest isn't the same as Next
Sorry, little typo. My head is stuck in a client job, for which I am using next.js.
You made my day. This is the exact library I've been looking for. I am now gonna rewrite two days of work with this and watch how many lines of code my project drops
What do you see as the advantage of Odi over Nest? I've seen Odi pop up a few times, but it's always seemed like a less mature version of Nest. I appreciate open source projects and the work done by the Odi team, but it seems like the authors of Odi have just duplicated a lot of the effort that went into writing Nest. Now we have 2 frameworks that look basically the same when you squint, but are going to have slightly different ecosystems around them.
I make the same mistake all the time haha
Is this what a shill smells like?
Check out nest as a bit more mature alternative. [https://github.com/nestjs/nest](https://github.com/nestjs/nest)
&gt;https://www.npmjs.com/package/odi Looking through odi's quick start guide, it's completely devoid of Angular's weird, confusing, needless module thingy. I'm not busting on Nest.js as it's a great super, "batteries included" framework. I am just not a fan of Angular Modules. I've seen comments in GitHub issues where others agree, that thing's gotta go.
As I mentioned in another comment, perhaps this framework is useful for those that don't want to write Angular on the server. I use a decent amount of Spring Boot, so I'm not a stranger to annotation heavy frameworks. But Nest's module pattern is really distasteful to me. I'm not saying it's bad, or that people shouldn't use it... just that \*I\* don't like it. And it's nice to have options. I currently have been using my own blend of TypeScript, Node, Microsoft's TSyringe DI framework and some TS-monocole/fp-ts. I might give this one a spin,
Nest.js contributor here. For those who never tried out Nest.js, maybe I can show you some of the benefits and the main reasons why I started using it in the first place. - You can see Nest.js as an additional layer of your Express application. You can **easily integrate your existing Express instance** (or Fastify) with Nest.js, making it easy to refactor your existing app and also allows you to use Express libraries, which are not integrated with Nest.js yet. - **Nest.js integrations always use an underlying library** (e.g. `@nestjs/swagger` =&gt; [swagger-ui-express](https://www.npmjs.com/package/swagger-ui-express) `@nestjs/mongoose` =&gt; [mongoose](https://github.com/nestjs/mongoose). The advantage of this is, the learning curve is easier since you're probably already familiar with the libraries. You will also encounter fewer bugs because the integrated libraries usually have a lot of contributors themselves. The downside which comes with integrated libraries from the pov of the developers is the documentation. The most critique I hear from Nest.js users is that our docs are sometimes not understandable for "newbies". The problem is from our side that we do not want to copy/paste the documentation of the library, because that would be really hard to maintain and redundant. But we try our best and I try to improve the docs as good as possible! - **Good TypeScript support**, because almost all our internal libraries use TS themselves, and also Nest.js is off course also written in TypeScript. We also support JavaScript though, be I definitely recommend TypeScript! - **Nest.js** has a CLI which bootstraps your application or add additional modules etc. The CLI even supports [Nx](https://github.com/nrwl/nx) thanks to the Nrwl guys! But this addition is pretty new, so there is not a lot of documentation yet. But here is a [nice blog post](https://blog.nrwl.io/robust-backends-with-nx-7-3-and-nestjs-8fe1611375e6) by Jason Jean, one of the developers of Nx! 
I am the author of this package. You are more than welcome to try it out in your assemblyscript test suite.
I'm not sure what you mean by the question. The library does use `ajv` to perform JSON Schema based verification.
Watch this space https://github.com/usabilityhub/ts-auto-guard
Cool idea! I was thinking of doing something similar but I was going to generate JSON Schemas instead of custom code.
Could you explain a little more about the 1-2s hit on initialisation? Also, io-ts does provide a lot of automatic validation. 
sort of off topic question. i've never seen this syntax before: @Get async '{id}' (id: string) { const foo = this.fooService.getFoo(id); if(!foo) return NotFound(); return foo; }​ i just pulled this from the github page for this framework. specifically, i'm confused by the '{id}' syntax. is this a way to have a dynamically defined function name in a class, or is this framework adding some specific transpilation rules??
I added in some simple benchmarking for this library. You can run it yourself by checking out the repository, just `yarn benchmark` like so: ``` bash $ yarn benchmark yarn run v1.9.4 $ ts-node src/benchmark.ts ## Slow Typescript Cast mean 0.9730756522857142 - deviation 0.08641687849699445 variance 0.0074678768891643 Margin of Error 0.0799251618237157 Relative Margin of Error 8.213663720387498 ## Fast Typescript Cast mean 0.006884263141551797 - deviation 0.001473178144025377 variance 0.0000021702538440340546 Margin of Error 0.00033121084013298084 Relative Margin of Error 4.811129867100371 ## Simple Typescript Cast mean 0.006208691539609053 - deviation 0.0003816062390265102 variance 1.4562332166395803e-7 Margin of Error 0.00008310535872132888 Relative Margin of Error 1.3385325747164085 ## Slow Schema Cast mean 0.005294744537947376 - deviation 0.000334626113983338 variance 1.1197463615958991e-7 Margin of Error 0.00007287413148970471 Relative Margin of Error 1.3763483954214712 ## Fast Schema Cast mean 3.6148529754223726e-8 - deviation 1.3659899330297327e-9 variance 1.8659284971385736e-18 Margin of Error 2.7614656366408855e-10 Relative Margin of Error 0.7639219784086034 ``` The bit to pay attention to is the `Slow Typescript Cast` vs the `Fast Typescript Cast`. The only difference between the two is that in the Slow version we run the `TypescriptSafeCast` Constructor on every iteration of the benchmark and in the Fast version we use an already constructed `TypescriptSafeCast` object to do the casting. The `safeCast` function, internally, creates and caches `TypsecriptSafeCast` objects in order to avoid paying this cost for every cast. As you can see in my testing, this initial cost is just under 1s on my machine. If your app runs on dedicated hardware then this will not be an issue; it's a one time cost that your app will pay than it will only pay once per deployment/restart. However, if your app runs in a Lambda (Function as a Service) environment then that performance cost may be an issue. It's for that reason that I'm planning on extending the library to have a `safe-cast-schema-generator` or something like that so that you can generate all of the schemas at build time and package them into your app. That way you will never pay the cost at runtime and it will always be super fast. If you have any further questions just ask away.
It's a great way to do client-side web programming for people coming from a Java/C# background. Pure Javascript is a nightmare to deal with when you've spent a career using strongly typed languages.
Not exactly, but close enough. 
Nice. Well this package is currently working, but it's found so many bugs that we haven't been able to merge it into master yet. As soon as we're dogfooding it I'll release 1.0.0. The main delay is that it's hard to find errors in large objects when they just reduce down to a bool, so I need to create a debug mode.
&gt; Unlike Java and C#, dart has promises (Futures) build in for concurrency and compiles to readable JS. In Java futures have been around since 2004, first in a more retarded form, then in a less retarded form since 2014. 
Same dude. Never understood Angular.
{id} is a part of the request url. In express it like localhost:8000/post/:id This :id is {id} I went through the docs and found this.
Nest is best. But this framework is trying stuff differently.
Dynamic and 'any' are similar but I'd recommend avoiding using 'any' unless you have a really good reason. Just like in C# there is a limited preferred number of use cases for dynamic. Here are some reasons to use 'any' in typescript: - interoperability between systems e.g. *i dont know what types the outside system will provide, and will determine them and handle them at run time*. Even then typescript supports [union types](https://www.typescriptlang.org/docs/handbook/advanced-types.html) which are better than using 'any'. - User input that a type cannot be determined before runtime Reasons not to use 'any': - Clarity of intention for the code - Rely on type script compiler to find static typing issues for you instead of at run time - You can use a generic type instead if you want code to operate over different types - Easier to reason about the code Think hard about it whether 'any' is a good idea. Usually you can leverage typescript to your advantage where 'any' is unnecessary. 
Aw yes baby!
I believe "unknown" is better than any in almost all cases
Yeah, I honestly wouldn't use 'any' unless you are working with some strange edge case. You are right, unknown is still preferable to any. 
Angular modules are useful because you can see them as a bundle for providers, components, etc. Therefore an external Angular package can only export their module and the user can then import it into their own module. This is good because you have a normalized way to import internal or external modules into your application context. For huge teams modules can be really beneficial, because one team can concentrate on module and use the other modules from other teams as a blackbox. 
I know some things about TS but I’ve never come across such a syntax? Looks like the child of CoffeeScript and TS. Can someone explain what this is?
fantastic! I'm already familiar with ASP.net MVC so this lib looks pretty easy to understand and use!
They fit a certain taste for sure. I write services in a few different languages (Java/Kotlin - Spring Boot, Elixir, and now recently, Rust) I see the same patterns emerge in those languages/frameworks. I’ve worked on teams of 2, and teams of 12 Java devs (in companies with 100s of devs - on a monolithic app).... and we somehow managed to make things work elegantly without inventing a new module format. The problem that these modules claim to solve can often be solved in a more idiomatic way. In the JavaScript community, both React and EmberJS manage to wrangle large scale applications without inventing a new module format. I try to be very careful in my criticism however. I want to be very clear that I’m sure this pattern works well for some. Some probably really enjoy it. I frankly do not. And I say this as someone who has multiple enterprise JavaScript apps in production (serving millions per day). Importing other packages from other teams or sharing application context (we used Redux) just wasn’t that difficult. But the very spirit of my comments was directed at the fact that I was grateful to see a different approach than Nest.js takes. (I have a microservice written with that in production as well). I’m glad that Angular Modules exist for those that feel it solves their particular problem. I’m also happy to see more options. Thanks for sharing the benefits of Angular modules as a response. I suggest devs try them out if they feel they’ll solve a problem that they have. (Or, just to get familiar with the landscape). 
What about `never`?
Never is for impossible code paths or paths that emit errors
I've been working on [immer-reducer](https://github.com/epeli/immer-reducer) which has very similiar goals so it might be of interest to you. It's a bit more opinionated as it autogenerates the action types and creators too.
Seems very similar to https://github.com/piotrwitek/typesafe-actions
I work with the guy who made this
Hey, everyone! I'm the guy that wrote this library. Glad to answer any questions!
related [https://github.com/LeDDGroup/reduxs](https://github.com/LeDDGroup/reduxs)
Also worth mention is redux-starter-kit, written by the Redux people themselves, which was recently rewritten to typescript.
This is actually pretty cool. The Typescript story has been historically somewhat painful with Redux. So looking very much forward on this.
Looked over the Readme, looks amazing.. Is there a way of using this with redux thunk so I can do promise based actions? 
Totally agree - what is the purpose of modules in nest when you have a perfectly good module system with ES6?
Calm the hell down like algo suggested and take a methodical approach to solving your problem. &amp;#x200B; Don't start mashing a bunch of technologies around and complaining when things don't work well together. Solve your problem with the minimum amount of infrastructure you need and build from there (this is common to ANY new language or ecosystem you may enter in the software world)
You know, it's been so long since I've used thunks that I wasn't really thinking of them when I made this library (I use [sagas](https://redux-saga.js.org/) myself). I guess I would ask if you actually need the functionality provided by this library? My understanding of a thunk-based architecture is that the action returning the function would not typically (ever?) be handled in a reducer. The focus of this library is in inferring the payload type in reducers based on your action creators, and additionally inferring the type of the state in your reducers. Basically I would just define your thunk actions on their own (plain ts) and then use this library for actions that you have to handle inside the reducer. Is there something you're looking for that this library would provide? Am I overlooking something in the thunk-based architecture? const myReducerHandledAction = createAction('FOO'); const myThunkAction = payload =&gt; dispatch =&gt; { // Use payload and dispatch here };
As mentioned on reddit and elsewhere the main problem you're going to run into with redux starter kit and TypeScript is their use of selectorator. You might as well not be using TypeScript. For more information, see [this reddit thread](https://www.reddit.com/r/javascript/comments/ahnpqi/redux_starter_kit_v040_the_one_with_typescript/eegk0hi/?context=3) as well as the [Design Philosophy of `redux-ts-actions`](https://github.com/knpwrs/redux-ts-utils#design-philosophy).
I like this one too, thanks for sharing!
cc /u/acemarke
Yep, [we already chatted over in the /r/js RSK thread](https://www.reddit.com/r/javascript/comments/ahnpqi/redux_starter_kit_v040_the_one_with_typescript/eegicji/). Thanks!
Note that I'm seriously considering swapping Selectorator for Rereselect. Also, Selectorator still allows you to pass in "standard" selectors as inputs, it just also lets you pass in string keypaths.
Typescript does not provide any type safety at runtime. Type guards do work at runtime, however they are only a function which returns a boolean, and at runtime are equivalent to a javascript function as the type assertion is removed. When dealing with remote APIs (or any input data) it's really up to you to decide how to do the validation of that data, and you would do it the same way for typescript as you would for javascript. Typescript is not opinionated about how you do this. Some libraries will do this for you, e.g. Apollo's GraphQL libraries will do runtime validation based on the schema, and also are capable of creating Typescript types for the queries. I don't know of any general solution for REST APIs, although I suppose if there was a json-schema available for it you may be able to use something like `ajv` for the validation and find a another tool to create typings from the schema.
What would you like to do if the response doesn't have all the needed properties?
I think i did pretty much the same thing as you here, no idea why it works, but it works :P [https://www.typescriptlang.org/play/index.html#src=type%20Selector%3CInputType%2C%20OutputType%3E%20%3D%20(input%3A%20InputType)%20%3D%3E%20OutputType%0D%0Atype%20OutputTypes%3CSelectorsType%20extends%20Array%3CSelector%3Cany%2C%20any%3E%3E%3E%20%3D%20%7B%0D%0A%20%20%20%20%5BK%20in%20keyof%20SelectorsType%5D%3A%20SelectorsType%5BK%5D%20extends%20Selector%3Cany%2C%20infer%20OutputType%3E%20%3F%20OutputType%20%3A%20never%0D%0A%7D%0D%0A%0D%0Afunction%20combineSelectors%3CInputType%3E()%20%7B%0D%0A%20%20%20%20return%20function%20%3CSelectorsType%20extends%20Array%3CSelector%3CInputType%2C%20any%3E%3E%3E(...selectors%3A%20SelectorsType)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20null%20as%20any%20as%20Selector%3CInputType%2C%20OutputTypes%3CSelectorsType%3E%3E%0D%0A%20%20%20%20%7D%20%20%20%20%0D%0A%7D%0D%0A%0D%0Aconst%20baz%20%3D%20combineSelectors%3Cstring%3E()(%0D%0A%20%20s%20%3D%3E%20s.length%2C%0D%0A%20%20s%20%3D%3E%20s.trim()%0D%0A](https://www.typescriptlang.org/play/index.html#src=type%20Selector%3CInputType%2C%20OutputType%3E%20%3D%20(input%3A%20InputType)%20%3D%3E%20OutputType%0D%0Atype%20OutputTypes%3CSelectorsType%20extends%20Array%3CSelector%3Cany%2C%20any%3E%3E%3E%20%3D%20%7B%0D%0A%20%20%20%20%5BK%20in%20keyof%20SelectorsType%5D%3A%20SelectorsType%5BK%5D%20extends%20Selector%3Cany%2C%20infer%20OutputType%3E%20%3F%20OutputType%20%3A%20never%0D%0A%7D%0D%0A%0D%0Afunction%20combineSelectors%3CInputType%3E()%20%7B%0D%0A%20%20%20%20return%20function%20%3CSelectorsType%20extends%20Array%3CSelector%3CInputType%2C%20any%3E%3E%3E(...selectors%3A%20SelectorsType)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20null%20as%20any%20as%20Selector%3CInputType%2C%20OutputTypes%3CSelectorsType%3E%3E%0D%0A%20%20%20%20%7D%20%20%20%20%0D%0A%7D%0D%0A%0D%0Aconst%20baz%20%3D%20combineSelectors%3Cstring%3E()(%0D%0A%20%20s%20%3D%3E%20s.length%2C%0D%0A%20%20s%20%3D%3E%20s.trim()%0D%0A)[)](https://www.typescriptlang.org/play/index.html#src=type%20Selector%3CInputType%2C%20OutputType%3E%20%3D%20(input%3A%20InputType)%20%3D%3E%20OutputType%0D%0Atype%20OutputTypes%3CSelectorsType%20extends%20Array%3CSelector%3Cany%2C%20any%3E%3E%3E%20%3D%20%7B%0D%0A%20%20%20%20%5BK%20in%20keyof%20SelectorsType%5D%3A%20SelectorsType%5BK%5D%20extends%20Selector%3Cany%2C%20infer%20OutputType%3E%20%3F%20OutputType%20%3A%20never%0D%0A%7D%0D%0A%0D%0Afunction%20combineSelectors%3CInputType%3E()%20%7B%0D%0A%20%20%20%20return%20function%20%3CSelectorsType%20extends%20Array%3CSelector%3CInputType%2C%20any%3E%3E%3E(...selectors%3A%20SelectorsType)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20null%20as%20any%20as%20Selector%3CInputType%2C%20OutputTypes%3CSelectorsType%3E%3E%0D%0A%20%20%20%20%7D%20%20%20%20%0D%0A%7D%0D%0A%0D%0Aconst%20baz%20%3D%20combineSelectors%3Cstring%3E()(%0D%0A%20%20s%20%3D%3E%20s.length%2C%0D%0A%20%20s%20%3D%3E%20s.trim()%0D%0A)
It looks very similar to typesafe-actions
https://dev.to/remojansen/data-fetching-in-react-the-functional-way-powered-by-typescript-io-ts--fp-ts-ojf
You could use something like [class-transformer](https://github.com/typestack/class-transformer) to transform response into proper expected models.
It will also increase compilation time and complexity by introducing another tool in the chain.
Here's the code properly formatted for the ~~old~~ good Reddit layout: const baz = combineSelector([ (s: string) =&gt; s.length, (s: string) =&gt; s.trim(), ]) baz // should be (s: string) =&gt; [number, string] - type Selector&lt;A, Z&gt; = (a:A) =&gt; Z type Selected&lt;T&gt; = T extends Selector&lt;any, infer U&gt; ? U : never; type MappedSelector&lt;S, T&gt; = Selector&lt;S, { [Y in keyof T]: Selected&lt;T[Y]&gt; }&gt; const selectedNumber: Selected&lt;Selector&lt;string, number&gt;&gt; = null as any selectedNumber // is number const baz: MappedSelector&lt;string, [Selector&lt;string, number&gt;, Selector&lt;string, string&gt;]&gt; = null as any baz // is Selector&lt;string, [number]&gt; !!! - interface InferableMappedSelector&lt;S&gt; { &lt;T extends any[]&gt;(...values: T): MappedSelector&lt;S, T&gt; } function createInferredSelector&lt;S&gt;(): InferableMappedSelector&lt;S&gt; {return null as any} const inferredSelectorCreator = createInferredSelector&lt;string&gt;() const baz = inferredSelectorCreator(selectors) baz // is Selector&lt;string, [never]&gt;, not Selector&lt;string, [string, number]&gt; - interface InferableMappedSelector&lt;S&gt; { &lt;T extends Selector&lt;string, any&gt;[]&gt;(...values: T): MappedSelector&lt;S, T&gt; } const baz = inferredSelectorCreator(selectors) // doesn't typecheck due to: // Argument of type '[Selector&lt;string, string&gt;, Selector&lt;string, number&gt;]' is not assignable to // parameter of type 'Selector&lt;string, any&gt;'. // Type '[Selector&lt;string, string&gt;, Selector&lt;string, number&gt;]' provides no match for the signature // '(a: string): any'.
How is `selectors` defined? That is missing in your code and relevant.
Hmm, it might've been good to mention that, if TypeScript is not responsible for transforming your code, it can actually run in parallel with Babel. That's what Create React App does, for instance, using [ForkTsChecker](https://github.com/Realytics/fork-ts-checker-webpack-plugin).
Quite like this solution, but the only problem I can see with this is having to define your domain model (types) twice - it seems like a fair bit of waste. Any ideas of getting around this hoop?
&gt; it can actually run in parallel with Babe Which does not invalid my point. It's still increased compilation time and complexity. More resources on the system will be occupied.
It doesn't, but it does provide additional context that might be useful to people considering the two.
We used TSC for production build etc, but we used babel with plugins to extract intl messages automatically from react app.
https://www.typescriptlang.org/docs/handbook/decorators.html
Why aren't you using a schema validator? You could either use an existing one or implement your own. TypeScript is designed to help your productivity/maintainability and not to cover problems occurring during runtime.
write a generator. Should be doable.
Oops, it's defined as: const selectors: [Selector&lt;string, number&gt;, Selector&lt;string, string&gt;] = [...]
Thanks!
You could use [io-ts](https://github.com/gcanti/io-ts) for this.
Hi, I use a library called 'RunTypes'; it's very easy to use and incredibly useful. Here the link: [https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes) &amp;#x200B;
A lot of people have said that but I don't really see the similarity beyond "it has a function called `createAction`." With `typesafe-actions` you need to create a tagged union type with your actions and manually switch between the cases. There is also a much larger API surface with `typesafe-actions`. My focus with `redux-ts-utils` was simplicity: a small API surface and minimal manual typing while still maintaining complete type safety.
I find typesafe-actions much more verbose and hard to follow.
There's a fantastic [redux-thunk-actions](https://www.npmjs.com/package/redux-thunk-actions) library that offers a lot of what I want, but has zero typing available to it. 
I'm pretty sure you can extract typescript types from your io-ts model. It's not as nice as just writing typescript, but you still only have to specify it once.
After reading about them in the official docs, it helps to read code in existing projects: - Examples - https://gist.github.com/remojansen/16c661a7afd68e22ac6e - More examples - https://github.com/NetanelBasal/helpful-decorators - TypeORM - https://github.com/typeorm/typeorm/tree/master/src/decorator - TypeGraphQL - https://github.com/19majkel94/type-graphql/tree/master/src/decorators - Warthog - https://github.com/goldcaddy77/warthog/tree/master/src/decorators
Hey, thanks for reminding me that existed. I'm actually considering adding something _exactly_ like that to Redux Starter Kit: https://github.com/reduxjs/redux-starter-kit/issues/76
Yup is an excellent object schema validator. https://www.npmjs.com/package/yup It is exactly what you are describing.
I'm a little confused what this would look like with the above example given in io-ts. Could you provide an example of what it would look like?
We use protobufs for client to server RPCs, there are great libraries for generating Typescript definitions from the proto specs, and easy to integrate into existing setups as you can pass them around as base64 encoded strings. One of the best things about them is the data format is not tied to property names, making refactoring and backwards compatibility very easy to deal with.
You can define a type like so: ```typescript import * as iots from 'io-ts'; const axiosResponse = iots.type({ name: personName, phoneNumber: iots.string }); ``` Now you can use it like so: ```typescript if (axiosResponse.is(response)) { // Correct } ``` You might need to create your own type for `PersonName`, depending on the way you serialize it.
Can you give more details? Do you want to run an API call periodically? Do you have a chain of them that you want to happen in a specific order after some time?
this is the google cloud function i have created: import \* as functions from 'firebase-functions'; import \* as admin from 'firebase-admin'; import \* as https from 'https'; import axios from 'axios'; export const updateForecasts = functions.https.onRequest((request, response) =&gt; { admin.initializeApp() const db = admin.firestore(); db.settings({timestampsInSnapshots: true}); const agent = new https.Agent({ rejectUnauthorized: false }); const spotIds = \[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 106, 107, 109, 110, 111, 112, 113, 114, 117, 118, 119, 120, 121, 122, 123, 126, 127, 128, 129, 130, 131, 132, 133, 136, 137, 138, 141, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 156, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 171, 173, 177, 178, 179, 180, 181, 182, 183, 185, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 211, 212, 213, 214, 215, 217, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 387, 388, 391, 392, 396, 397, 398, 399, 400, 401, 402, 592, 593, 594, 596, 597, 599, 600, 602, 603, 604, 605, 606, 607, 608, 609, 611, 614, 620, 621, 622, 623, 625, 629, 630, 633, 635, 637, 638, 640, 643, 644, 645, 648, 649, 651, 694, 697, 699, 708, 717, 718, 720, 724, 732, 743, 745, 747, 749, 751, 754, 756, 759, 762, 800, 801 \]; axios.interceptors.response.use( config =&gt; config, (error) =&gt; { console.log("Axios interceptor error - " + error) // if (error.response.status === 408 || error.code === 'ECONNABORTED') { // console.log(\`A timeout happend on url ${error.config.url}\`) // } return Promise.reject(error); }, ); const log = msg =&gt; console.log(msg) const fetchForecastsPromise = (spotId) =&gt; axios.get(\`http://api.spitcast.com/api/spot/forecast/${spotId}\`, { httpsAgent: agent, timeout: 20000 }); Promise.all( spotIds.map( spotId =&gt; fetchForecastsPromise(spotId) .then(resp =&gt; { log(resp.data); return resp.data; }) .then(forecasts =&gt; db.doc(\`spots/${spotId}\`).update({forecasts: forecasts})) // .then(forecasts =&gt; db.doc(\`spots/${spotId}\`).get()) // .then(forecasts =&gt; forecasts) ) ) .then((results) =&gt; { response.status(200).send("The forecasts were updated."); }) .catch((error) =&gt; { response.status(500).send("Promise.all error - " + error); }); }); There are api requests that are timing out. I would like to add retry logic and exponential backoff is possible. I dont know if i also have to delay the time between making api calls.
Hey, lawloretienne, just a quick heads-up: **happend** is actually spelled **happened**. You can remember it by **ends with -ened**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
this is the google cloud function i have created: ``` import * as functions from 'firebase-functions'; import * as admin from 'firebase-admin'; import * as https from 'https'; import axios from 'axios'; export const updateForecasts = functions.https.onRequest((request, response) =&gt; { admin.initializeApp() const db = admin.firestore(); db.settings({timestampsInSnapshots: true}); const agent = new https.Agent({ rejectUnauthorized: false }); const spotIds = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 106, 107, 109, 110, 111, 112, 113, 114, 117, 118, 119, 120, 121, 122, 123, 126, 127, 128, 129, 130, 131, 132, 133, 136, 137, 138, 141, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 156, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 171, 173, 177, 178, 179, 180, 181, 182, 183, 185, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 211, 212, 213, 214, 215, 217, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 387, 388, 391, 392, 396, 397, 398, 399, 400, 401, 402, 592, 593, 594, 596, 597, 599, 600, 602, 603, 604, 605, 606, 607, 608, 609, 611, 614, 620, 621, 622, 623, 625, 629, 630, 633, 635, 637, 638, 640, 643, 644, 645, 648, 649, 651, 694, 697, 699, 708, 717, 718, 720, 724, 732, 743, 745, 747, 749, 751, 754, 756, 759, 762, 800, 801 ]; axios.interceptors.response.use( config =&gt; config, (error) =&gt; { console.log("Axios interceptor error - " + error) // if (error.response.status === 408 || error.code === 'ECONNABORTED') { // console.log(`A timeout happend on url ${error.config.url}`) // } return Promise.reject(error); }, ); const log = msg =&gt; console.log(msg) const fetchForecastsPromise = (spotId) =&gt; axios.get(`http://api.spitcast.com/api/spot/forecast/${spotId}`, { httpsAgent: agent, timeout: 20000 }); Promise.all( spotIds.map( spotId =&gt; fetchForecastsPromise(spotId) .then(resp =&gt; { log(resp.data); return resp.data; }) .then(forecasts =&gt; db.doc(`spots/${spotId}`).update({forecasts: forecasts})) // .then(forecasts =&gt; db.doc(`spots/${spotId}`).get()) // .then(forecasts =&gt; forecasts) ) ) .then((results) =&gt; { response.status(200).send("The forecasts were updated."); }) .catch((error) =&gt; { response.status(500).send("Promise.all error - " + error); }); }); ``` There are api requests that are timing out. I would like to add retry logic and exponential backoff is possible. I dont know if i also have to delay the time between making api calls.
So I've got the following, where I'm wanting to have methods on an interface. It's not working (each of the methods is unused - even though it's compiling fine). I've got a memberDetails object, can call each of the helper methods on it, but am getting error that the method is not a function. How should I go about fixing this? *const* IOMarginLender = t.interface({ accountNumber: t.string, name: t.string }) *const* IOMemberDetails = t.interface({ memberName: t.string, memberNumber: t.string, divisionName: t.string, email: t.string, homePhone: t.string, address: t.string, mySuperStatus: t.string, dateOfBirth: t.string, marginLender: IOMarginLender, status: t.string, pendingTransactions: t.boolean }) *type* MemberDetailsType = t.TypeOf&lt;*typeof* IOMemberDetails&gt; *export interface* MemberDetails *extends* MemberDetailsType { getFormattedDateOfBirth(): *string* getFormattedMarginLender(): *string* getFormattedPendingTransaction(): *string* | *undefined* getFormattedEmailLink(): Renderable } *export function* getFormattedDateOfBirth&lt;T&gt;(*this*: MemberDetails) : *string* { *return* \`${*this*.dateOfBirth} (${moment().diff(moment(*this*.dateOfBirth, 'DD/MM/YYYY'), 'year')} years old)\` } *export function* getFormattedMarginLender&lt;T&gt;(*this*: MemberDetails) : *string* { *return this*.marginLender &amp;&amp; \_.join(\[*this*.marginLender.accountNumber, *this*.marginLender.name\], ', '); } *export function* getFormattedPendingTransaction&lt;T&gt;(*this*: MemberDetails): *string* | *undefined* { *return this*.pendingTransactions ? 'Member has pending transactions' : *undefined* } *export function* getFormattedEmailLink&lt;T&gt;(*this*: MemberDetails): Renderable { *return this*.email ? &lt;a *href*={\`mailto:${*this*.email}\`}&gt;{*this*.email}&lt;/a&gt; : ''; }
Glad I was able to point you in a good direction, looking forward to seeing what you come up with! 
[removed]
Nice library! I've been trying to find the best pattern in terms of verbosity for enabling type narrowing in reducers. One quick question, One of the benefits that redux affords us is the ability to write state changes as pure functions. `handleAction` requires you to make mutations to the state parameter that's passed to it. Was this an intentional API decision? Was there a specific reason you didn't make the callback to `handleReducers` return the new state? 
Nice library! I've been trying to find the best pattern in terms of verbosity for enabling type narrowing in reducers. One quick question, One of the benefits that redux affords us is the ability to write state changes as pure functions. handleAction requires you to make mutations to the state parameter that's passed to it. Was this an intentional API decision? Was there a specific reason you didn't make the callback to handleReducers return the new state?
Yes, that was an intentional API decision. Under the hood the library is using [`immer`](https://github.com/mweststrate/immer) to achieve immutable state updates. With my initial attempt at this library ([`redux-ts-actions`](https://github.com/knpwrs/redux-ts-actions), note _not_ the library this post is about, `redux-ts-utils`) I was having a heck of a time getting the type inference to propagate into the `immer` callback, leading to no net benefit over writing everything out manually. Since `immer` is more or less becoming the de-facto standard for immutable state updates (type-safe, strong typing (unlike ramda which gives you string-typing), and performant), I decided to just build it in to this library. I'm looking at deprecating `redux-ts-actions` in favor of `redux-ts-utils`. The former has some issues that have been addressed in `redux-ts-utils`. That is why under `Design Philosophy in the README you can read the following: &gt; The closest thing to an opinion you will find in this library is that it ships with immer. The reason for this is that immer has proven to be the best method for dealing with immutable data structures in a way which is both type-safe and performant. So basically in order to use `immer` and provide the same level of type inference that I had in `redux-ts-actions` I had to make a single abstraction covering both concepts.
Here's the code formatted for the ~~old~~ good Reddit design: const isProd = String(process.env.NODE_ENV) === "production"; const isTest = String(process.env.NODE_ENV) === "test"; module.exports = { presets: [ ["@babel/preset-env", { modules: isTest ? "commonjs" : false }], "@babel/preset-typescript" ], plugins: [ "@babel/plugin-syntax-dynamic-import", "@babel/plugin-proposal-class-properties", "@babel/plugin-proposal-object-rest-spread" ].filter(Boolean) };
Are you defining the `process.env`? Because webpack uses a different set of env variables (called webpack.env I think?). IMO, I personally don't like adding extra logic on the .babelrc files, I'd move to awesome-typescript-loader and perform all the logic switching from webpack.
Thank you for your help, the issue ended up being one of Webpack's dependencies: [https://github.com/webpack/webpack/issues/8656](https://github.com/webpack/webpack/issues/8656)
[Whelp](https://www.youtube.com/watch?v=cF44OPOEfYY)
Username sounds trustworthy lol
A chart like that sounds impractical. Learn what you need to use it well. You don’t need to learn something to be called an expert.
is it this one [http://www.techladder.io/?tech=typescript](http://www.techladder.io/?tech=typescript) ?
Does not include the hardest part - fighting with webpack, npm and other tooling configuration on the local machine and in CI
If i wanted to reduce boilerplate, could i just use `person.type === PersonType.Wizard` everywhere instead of creating these separate type guard functions? The helper functions look clean with higher order functions and are readable, but are there other benefits?
Do not get me started on the magic required to get ts-node working with mocha on anything more than a trivial project.
But its so cool so we bookmark and forget about it later
Yeah, type guards are pretty useless if you already have a tag like that `person.type`. Except to keep the guarding logic in one place, I guess. What if you change the enum sometime later? But I don't know why would you add unnecessary prop to a class. If you removed the `type` property, type guard *would* be needed.
Sheesh, lots of small typing fixes but they still can’t introduce the elvis operator.
Perhaps give Jest a try. I've had no problems at all integrating Jest + Typescript.
Can you use something like: const thatValue = oneValue || "None" Its not quite as nice, but it usually gets the job done.
The problem is more at the ts-node end.
implementation-wise it's pretty similar to https://github.com/tc39/proposal-optional-chaining/blob/master/README.md which is in stage 1. i read in a previous patch that they would only implement something from stage 3 and onward, so since the Elvis operator isn't in the proposals, then they won't do it.
&gt; still can’t introduce the elvis operator. They can, but they won't. Their design goal is to align with ECMAScript.
It's kind of hilarious that "Partial type argument inference" gets pushed from release to release on the roadmap. They should just place it under "Future" if it's not foreseeable in any of the releases, instead of teasing/fooling everyone release by release.
&gt; Yeah, type guards are pretty useless if you already have a tag like that person.type. They're actually harmful, as the compiler won't make sure the logic in your type guard actually makes any sense. You could write: function isRavenclaw(person: Person): person is Ravenclaw { return isWizard(person) &amp;&amp; person.house === HogwartsHouse.Slytherin; } and it would compile just fine.
That’s correct. They don’t wanna implement early and then be in a position where their implementation does not match the eventual JS implementation. They’re already in that boat with decorators and private fields
Well there is the active PR they are working on. The other future stuff does not have related PRs at all at least not by the core team.
That's fine until you're going multiple levels deep, and even worse if you need to perform a find which could return undefined.
It is an open source project. Please feel free to add items to the list [https://github.com/remojansen/TechLadderIO/blob/master/technologies/typescript/typescript.json](https://github.com/remojansen/TechLadderIO/blob/master/technologies/typescript/typescript.json)
FWIW, I use require('ts-node').register() with some inline config and it seems to do the trick. Pass -r ./init-stuff.js to mocha via mocha.opts.
It seems like `--outFile` is exactly what you need.
Referential transparency has nothing to do with type inference, and while that doesn't make any points in his article invalid, they have nothing to do with referential transparency and everything to do with type inference. Referential transparency is about semantics. The idea is that replacing a pure function with its result should not change the meaning of your program. The problems the author is having can be laid at the feet of TS not having global type inference. That is to say, if you have a program like function foo(x: number) { return x; } declare let a; foo(a); Then TS will not infer the type of `a` to be `number`. I would prefer they did, since I am used to Haskell, but it is what it is. So, while this article may an interesting look into TS' type inference semantics, it is blatantly false to say that it breaks referential transparency. 
On JavaScript projects, I like to write everything as TS and run it via ts-node. I also want to be able to run code without fixing *every single type error* -- especially when prototyping or experimenting -- so I use ts-node's `--transpile-only` flag. Linux shebangs, unfortunately, can't have CLI flags. It's a kernel limitation. So I wrote `ts-node-to`, a binary that behaves like ts-node but with `--transpile-only` enabled by default. This makes it easier to write shell scripts in .ts. It's also useful when the shell script is .js but it require()s some .ts from elsewhere in my codebase. ``` #!/usr/bin/env ts-node-to // Typescript goes here... ```
I want a discriminated union of strings as key restrictions!
Lenses allow you to immutably modify an object with a path, e.g.: &amp;#x200B; `mod('user', 'name')` `((s: string) =&gt; s.toUpperCase())` `({user: {name: 'john'}})` &amp;#x200B; `{ user: { name: 'JOHN' } }` &amp;#x200B; But any string based path system is risky. What if you make a typo? What if you produce a value that is incompatible for that type, i.e. change a string to a number? With shades' new TS bindings, this won't happen, and all updates are checked on deeply, so: `mod('user', 'mame')` `((s: string) =&gt; s.toUpperCase())` `({user: {name: 'john'}})` &amp;#x200B; and &amp;#x200B; `mod('user', 'mame')` `((s: string) =&gt; 10)` `({user: {name: 'john'}})` are both errors. &amp;#x200B; This extends to custom `map` and `filter` (and many more) functions: `map('name')` `([{name: 'john'}, {name: 'obadiah'}])` produces `['john', 'obadiah']` &amp;#x200B; but `map('name')` `({user1: {name: 'john'}, user2: {name: 'obadiah'}})` produces `{user1: 'john', user2: 'obadiah'}` &amp;#x200B; And in both cases, the type system knows what the shape of the output will be without casting :) &amp;#x200B; There's many more things you can use besides just strings, such as constraints, but you'll have to checkout the README for those. &amp;#x200B; TL;DR: Use string paths and constraints to update objects and collections, but like, safely.
we are using ts-optchain. pretty good alternative until proper natuve implementation
As I said "anything more than a trivial project" – this setup alone is all fine until you gain any dependency that provides an ambient declaration. `ts-node` has different module resolution to `tsc`, which specifically does not search for ambient declaration files, so all hell breaks loose. You can theoretically provide 'typeroots' in your `tsconfig.json` to point to all the modules that contain ambient declarations (it is tedious to track down all of these), but there is an infuriating bug where the 'typeroots' gets ignored on every run after your first one; this is due to ts-node's caching problems. ... So now not only do we have to provide 'typeroots', we have to disable ts-node's cache. This requires getting acquainted with how to pass environment variables to ts-node... and because you're registering ts-node from the mocha process, you'll have to learn how to pass those environment variables via mocha. Now you need to invoke mocha with `--require test/mocha.env.js` and provide the following environment variables: process.env.TS_NODE_CACHE = "false"; HOWEVER, now that you've disabled caching, the whole point of ts-node's quirky module resolution (faster startup) is rendered useless. So you might as well force it to resolve modules just like `tsc` does: process.env.TS_NODE_FILES = "true"; You may find that the cache still buggers up when you do a refactor, so for the easy life, you'll just disable cache even in this mode. And boy are you in for a world of fun trying to get code coverage to work on top.
We avoid this by running ts-node with `transpile-only` and running `tsc` separately to handle type-checking. I suppose you might hit issues with const enumerations but we haven't yet.
Does `transpile-only` output JS files? Not really sure what it does.
It skips the typechecking step but still compiles each .ts into .js using TypeScript's transpiler. So .ts files can still be require()d and executed, and ts-node doesn't look for or care about type declarations since it's not running a typechecking step. I think you might hit issues if there's a `const enum` and `preserveConstEnums` was turned off, since `--transpile-only` can't inline the values of const enums. So if you `MyEnum.foo` then the compiled .js will say `MyEnum.foo`, and that'll fail if `MyEnum` isn't an object at runtime. IIRC we have `preserveConstEnums` turned on, which might explain why we don't hit this issue. But I'm not 100% sure, maybe someone else knows.
Author here. What would you call the equivalence of these? purchase('Macbook Air'); // Inline const product = 'Macbook Air'; purchase(product); // reference Substitution Principle? Referential Transparency? I spent a fair amount of time looking around online for precise definitions of these terms but didn't find much consensus. Depending on how you frame it, you could say this is or is not an example of RT. Since TypeScript's output (and hence runtime semantics) is [independent of the type system](http://neugierig.org/software/blog/2016/04/typescript-types.html), the distinction between passing/not passing type checks is the most significant one there is in the language.
i loved this syntaxe in ruby and swift
It's important to be specific about what "equivalent" means. Firstly, if we treat your example as JS, then we both know that both will behave the same -- so in that way, they are equivalent. They have the same semantics. If we ask: Are they equivalent in correctness, as typescript programs? Then the answer is obviously no, since the TS compiler allows one but not the other. But that doesn't make the program invalid. In this case, the compiler is simply not using all the information it has to infer the types, so it has to reject the program based on the information it does have. As I explained before, this is because TS does not do global type inference. In your second example, it does not use the fact that `product` is used to call `purchase` which presumably has some type `(arg: "Macbook Air" | ..) =&gt; ..` to infer `product: "Macbook Air"`. It only sees you initialize it with a string literal and thus infers `product: string`. There is no violation of referential transparency. For all intents and purposes, we can treat both `product` and the string literal in the first example as constants -- one could certainly imagine a compiler(like the TS compiler) simply inlining the value of `product` in its call site, if it's only declared and then used immediately. The difference, however, is that in one example it is inlined as `purchase("Macbook Air" as string)` and in the other it's already a constant of the type `"Macbook Air"`. 
replace the second line with return `${namespace}/${name}`
You're agreeing with everything in the post, just saying it differently. Global type inference would be one way to deal with this issue, but so would having a way to declare something deeply `const`. It's up to the TS team to decide how they want to resolve the problem. But like I asked, what would you call the property I'm describing if not referential transparency or the substitution principle?
I'm not sure how I can make this any clearer. This has nothing to do with referential transparency. Referential transparency has to do with behavior. There are two scenarios: one in which you view the program as a javascript program, in which case the behavior is the same -&gt; there is no violation of referential transparency. The other is where we view them as typescript programs, in which case one program is no longer valid, and it no longer makes any sense to talk about the equivalence of behavior of two programs where one program is no longer valid. I'm not sure if there is a name for the property you are looking for, but it is not referential transparency. It's just a quirk in the type inference of typescript. That's literally all that is going on. If you wanted to demonstrate typescript violating referential transparency, you would need some program function foo(..) { // this function is pure } const res1 = bar(foo(..)) const res2 = bar(&lt;result of evaluating foo&gt;) Where `res1 !== res2`, roughly speaking. That is, it had to mean that somehow tsc compiles `foo` to something that isn't really referentially transparent. 
I'm extending because I want `namespace` and `name` to be inferred as `string literals` not generic `string` Also the issue I'm having isn't with the functionality, both return `${namespace}/${name}` and return namespace + '/' + name work the same. it's the type it returns that's the issue, in my example I want the typeof `objKey` to be a string literal `"admin/home"` not `string`
Yes - thanks!
Doesn't `Record` do that already?
You can do it with mapped types (like `Record`), but not interfaces or in class definitions.
Do you run your code in ts in production too ?, or is it just for development ?
Right now I'm using this mostly for developer tooling and test scripts. For example, we have a dockerized test environment that runs emulations of various AWS services to support our automated tests. Interacting with that environment involves a mix of shell scripts to create databases, reset s3, restart docker containers, etc. Some of those are written in .ts, since using the AWS SDK from TypeScript is AWESOME! Everything tab completes. It's easier than using the AWS CLI. Also, for a personal monorepo, I have a few scripts to update package.json files, generate README templates, etc. They use lodash and do JSON manipulation, so they're also written as TS. These are the places where this is most useful.
why not just run \`ts-node -T\` ?, also do you have any examples where you use it ? I'm just curious, I think the package is good
`ts-node -T` can't go into a shebang because it uses an argument, and my team is used to putting `#!/usr/bin/env node` at the top of scripts. So if I want to convert a legacy .js script to .ts without my teammates feeling like I'm making their lives harder, I do `#!/usr/bin/env ts-node-to`.
What do you think of [https://github.com/gcanti/monocle-ts](https://github.com/gcanti/monocle-ts) ?
Finally got it to work yesterday. Everything is in the latest version now, and seems to work really well. The important things were: 0. Patience. 1. Every project should build on its own, have their own proper tsconfig etc. This is because ts-loader will search for the config, and it won't work with explicit "context" or "config", dependencies, node_modules etc. 2. Projects actually build somewhat on their own.. Sometimes. And sometimes it trips up, some race conditions I would guess. Adding "instance" and have separate ts-loader configs in webpack rules solves that. 3. You need includes and aliases in tsconfig, same aliases in webpack config. 
What are the final versions of typescript, ts-loader and webpack you have ended up with? 
Also doesn't work with falsy values such as 0 or ''.
The type system won't do string concatenation, so it's not possible to derive a string literal type from multiple string literal types. Anytime you use the + operator to concatenate string types, the inferred result will just be `string`. Depending on your project, you might be able to use code generation to create a mapping, enumeration, or other kind of lookup with the concatenated string literal types.
Compilers get fooled by ~~strange logic~~ magic once again
This is neither strange, nor magic. It's simply a design decision, and one that makes sense. Type-guards are a crutch to support the compilers type system. If the compiler could always infer the type, then type-guards wouldn't be needed.
Another one from Facebook. Now having React re-written in TypeScript in the future doesn't seem like a stretch.
Maybe rewrite React in TypeScript, like everyone normal frotnend framework nowadays
Hmm, considering they are both arrays and you are looking for a value match, not a key - I can't think of another way to handle this that will impact performance. The only thing that...maybe?...could help on large datasets is creating a cache object like: let docCache = {}; let idArray = this.docList; let compareArray = this.dataSource.documentList; for (let id of idArray) { if(id in docCache){ this.docsForAssignment.push( { 'docId': id, 'tags': docCache[id] } ) } else{ for (let data of compareArray) { if (data['docId'] == id) { this.docsForAssignment.push( { 'docId': id, 'tags': data['tags'] } ) } else{ docCache[id] = data['tags']; //adds object to cache but with id now as key compareArray.splice(data, 1); //removes object from compareArray } } } } Essentially this would mean you're only iterating through the compareArray once in the end. Every time you iterate over an object that doesn't match it gets removed from compareArray and added to the cache array that you can then reference first on the next iteration of idArray. This is an idea, but other feel free to shoot me down as I'm still an amateur programmer - also wrote this in JS so not sure if it needs any typescript conversion. 
Functional TypeScript allows you to deploy serverless functions without having to deal with HTTP, parameter validation, or encoding / decoding. **You just write normal TypeScript functions** that are then callable remotely over HTTP. Coming soon... a @zeit/now builder, adapters for AWS, GCP, and Azure cloud functions, as well as a gRPC transport that can be swapped for the default HTTP transport.
This is drifting towards metaprogramming/code pre-processing territory. https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API TS does have a (very beta) compiler API for manipulating the AST of your code to do what you want, but this is not for the faint of heart.
At a first, somewhat superficial level, it's syntactically very clunky to have to manually construct lenses and compose lenses. It's also (usually) unnecessary to make the user add a type annotation to every lens. Monocle's example from their docs of: `import { Lens, Optional } from 'monocle-ts'` `const company = Lens.fromProp&lt;Employee&gt;()('company')` `const address = Lens.fromProp&lt;Company&gt;()('address')` `const street = Lens.fromProp&lt;Address&gt;()('street')` `const name = Lens.fromProp&lt;Street&gt;()('name')` `company` `.compose(address)` `.compose(street)` `.compose(name)` `.modify(capitalize)(employee)` would in shades be `import {mod} from 'shades'` `mod('company', 'address', 'street', 'name')(capitalize)(employee)` &amp;#x200B; At a deeper level, I have the same problems with `monocle-ts` that I have with all other lens libraries in JS/TS (Ramda, Calmm, etc.): It copies the implementation style from Haskell/Scala (from Ed Kmett). This style works very well in strictly typed languages that have a pass of compiler optimizations, but it's unnecessarily clunky JS. The biggest drawback is that this style will not allow you to mix lenses and traversals together in one lens. For example, in shades, I can do this: `import {get, matching} from 'shades'` `const users = {store: [{name: 'jcdang', color: 'RED'}, {name: 'con_mustapha_mond', color: 'BLUE'}]}` `get('store', matching({color: 'RED'}), 'name')(users)` and get back `['jcdang']` My whole philosophy has been "Don't design a Haskell library in JS" &amp;#x200B; Granted, I'm biased because I wrote one of these libraries :) &amp;#x200B;
This is really cool. I came here expecting some "fp" library, so maybe you should think about changing the name? :D
Stoked on all of this typescript adoption. Has made my life so much easier
try out `option` from [fp-ts](https://github.com/gcanti/fp-ts/blob/master/docs/Option.md). It's more verbose than the elvis operator, but gives you a whole lot more than just chaining.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/reactjs] [How to refactor three TypeScript class components, which asynchronously load and display data into one?](https://www.reddit.com/r/reactjs/comments/ajhgb3/how_to_refactor_three_typescript_class_components/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Same.
You can use typeof operator to check if the param is undefined, string or number and then call the appropriate API function. You will end up with one component which loads appropriate data in componentDidMount.
The same is true with mapped interface types such as `{ [key: string]: T }` where indexed access returns T. I think its simply a trade-off between usability and correctness. Its very annoying to work with needing to constantly add `myArray[3]!` to indexed accesses. Also requiring it at this point would be not only a major version change but also a lot of changes across most codebases.
My first thoughts are this.... if docList has unique strings you can make it a ES6 set (polyfills available for older browsers) to achieve O(1) Lookup and still be iterable. Second advice is my personal opinion that is steer clear of for loops, for in loops, forEach loops and swap them out for reduce, reduce is immutable and Array.prototype.reduce can be used to solve ALL POSSIBLE array based problems. ` const docList = new Set(['string1', 'string2', 'string3', 'string4', 'string5']); const dataSource = { documentList: [ {docId: 'string1', tags: ['stringy', 'thingy'], otherProp: 'otherVal'}, {docId: 'string7', tags: ['stringy', 'thingy'], otherProp: 'otherVal'}, {docId: 'string3', tags: ['stringy', 'thingy'], otherProp: 'otherVal'}, ] }; /* i think this is what you want, from here you'll have to mutate docsForAssignment yourself with the result of this reduce, I.E docsForAssignment = docsForAssignment.concat(RESULT OF REDUCE) */ console.log( dataSource.documentList.reduce((outputArray, doc) =&gt; { if (docList.has(doc.docId)) { return outputArray.concat({ docId: doc.docId, tags: doc.tags }) } return outputArray; }, []) ); ` 
I don't think you need to duplicate all the code for rendering etc. You can create a base component that has the repeated stuff like render and create a new method for fetching your data. \`\`\`import \* as React from 'react'; interface State { loading: boolean; displayedEntries: string\[\]; }; export class EntriesPage extends React.Component&lt;{}, State&gt; { constructor(props: any) { super(props); this.state = { loading: false, displayedEntries: \[\] }; this.getEntries = this.getEntries.bind(this); } async getEntries() { return Promise.reject('Override me please'); } async componentDidMount() { this.setState({ loading: true }); const entries = await this.getEntries(); this.setState({ loading: false, displayedEntries: entries }); } render() { if (this.state.loading) { return &lt;div&gt;loading&lt;/div&gt;; } else if (this.state.displayedEntries.length === 0) { return &lt;div&gt;nothing found&lt;/div&gt;; } else { return this.state.displayedEntries.map((entry, i) =&gt; &lt;div key={i}&gt;{entry}&lt;/div&gt;); } } } export class EntriesPageOne extends EntriesPage { async getEntries() { return await api.loadAll(); } } export class EntriesPageTwo extends EntriesPage { async getEntries() { return await api.loadByStringParam('my param'); } } export class EntriesPageThree extends EntriesPage { async getEntries() { return await api.loadByNumberParam(123); } }\`\`\`
Excited for native TS runtimes (deno). Would be cool to run TS natively in the browser also.
What's the benefit of running TS in browser?
All the benefits of writing a codebase in TypeScript + no need to transpile to js, no need for polyfills, etc. I’m not sure it’ll ever be supported natively in the browser though. Deno is very much a thing though. Native TS runtime. 
Typically you transpile TS to JS which runs in browser. Majority of the benefits are developer ergonomics because TypeScript provides the possibility of powerful IDE tooling and static analysis. (It also polyfills for you as another commenter pointed out.)
Here's an official answer from the TypeScript team: https://github.com/Microsoft/TypeScript/issues/13778#issuecomment-277104502 You can read the rest of the thread for more context, where they also share possible workarounds if you really need to change the index signature of arrays to include `undefined`.
Right, so why would that be useful running natively in browser? Seems like you'd be sacrificing size and speed for little to no gain.
If I deploy some of these serverless functions, FTS will create a client for me right? Given your example `function hello` I should be able to get an auto-generated client and then do `const response = await hello('Newman...');`?
I'm so happy more and more library opted out from flow to typescript
PR welcome!
yeah, i can definitely see that. thanks for the feedback! :)
Exactly :)
Awesome! Is there an example of this? I tried to find one in the README, but I'm only finding the `curl` example.
Docs are definitely still a WIP, but there are some more fleshed out examples in the \`examples\` directory.
Been wondering this.. I get why we initially wanted to use Yarn for predictable builds but now that npm can do the same thing can someone maybe give me some idea of why I should use yarn now?
If it's gonna act like how it does on compile time. Then it might be useful as it'll throw the moment a type incompatibility is encountered, if somehow you tried to forcibly cast a string instance to an number it'll complain first hand on runtime like how it works on compiled .Net, you'd have runtime type enforcement as well. Also the type information could be used by the browser VM to optimize more out of the code as it'll have more information about the code base through it's given types.
What is the benefit of throwing more type errors than you need to in browser? If your app was compiled from well-written typescript, any type error surfacing on the frontend is probably due to unexpected data. Also, I'd bet that the cost of type checking outweighs any optimizations you might get out of it. Also, it's a bigger bundle. Also, you'd still need to bundle it.
Agree, it makes a lot more sense on a server than in a browser.
Agree, it makes a lot more sense on a server than in a browser.
I only PR on TypeScript projects
Oh, tbh I don't know much about that. Theoretically you could remove all the overhead of dynamic type checking when the type of an argument/variable is guaranteed at compile time, just like any strictly typed language.
Latest, typescript@3.2.2 and ts-loader@5.3.3
I used to be all about pure JS. It took me a few months of working with TS for it to click for me. The thing about TypeScript is that it is just JavaScript with the latest features and a few sensible extras (currently in proposal). Types are optional. The addition of types only increases the rigidity of the code you write. TS allows for fewer mistakes when code spans multiple people/teams. It also improves how the code documents itself. I also find types take care of a lot of unit tests. I've been spending a lot of time writing Go recently. It's changed how I write my Node applications. A cool feature of Typescript is you can have functions take interfaces as parameters. Which is something I think is incredible!
https://github.com/AssemblyScript/assemblyscript Coming soon to a theater near you
Thanks. So if I understand correctly, you ended up with not compiling TS sub-projects within node modules, but you compile them before and link ts and d.ts files?
What does the exclamation mark syntax do?
No benefit except compitation
Sorry, did not make myself clear apparently.. What I wanted to do, was compile the main project, and only the main project. No build step for subprojects required. At first I did not think that was possible (see my first comment). Thanks to your motivation I investigated further ;-) And now it's a bliss: One click and everything, main project and libraries, are built, packed and served with webpack and ts-loader. I can edit a ts file in the linked library, and the main projects webpack-dev-server will pick it right up. No additional tools necessary. 
If TypeScript was natively supported in the browser, TypeScript runtimes could more easily perform some optimizations that it couldn't do without assuming certain types. For example, the implementation of JavaScript on GraalVM heavily relies on type assumption to improve performance of the runtime. 
I'm very thankful that Typescript uses private fields in a normal way, and I hope that #proposal dies in the arse.
Not necessarily true. There is [an issue](https://github.com/webpack/webpack/issues/8656) on Webpack's GitHub that was caused by NPM's dependency system. Yarn works fine. 
&gt; We actually don't need the default case because this is an exhaustive type-check, but it's still good to be defensive in case someone upstream uses an any. It's also necessary if we integrate this with redux. Yes, yes you do need the default case. Reducers receive every single action, they just choose to ingnore most of them. Without the default case, you will clear you state to undefined. Although I think TS will tell at you since your function no longer matches the signature of combine reducers. Unless of course. Your state management discards undefined returns 
That's an indexer type, not a mapped type.
It's the non-null assertion operator. It removed null and undefined from the type union, essentially reducing type safety by telling the compiler "shh... Trust me.. it won't be null or undefined". It's the same principle as with type assertions (often mislabeled as casts).
Ahhh nice :) didn’t know this existed, thanks
If your PR is accepted, then it's a typescript project.
I'm copy and pasting this from a different post. Here's why I'm sticking with yarn: I'd rather use yarn because they've proven themselves to be experienced, competent developers. NPM developers only make improvements or follow the best practices that every other dependency management solution follows when they're forced to by avoidable, public fuckups or when yarn embarrasses them. Even then they often don't fix the root problems.
It seems unlikely since it’s already stage 3 and being implemented by browsers (it’s already available in chrome). Although if you use typescript, you can still use their syntax since they likely won’t remove it.
I wouldn’t go as far as to say native. It has the ts compiler builtin. You’re code will still run as js. However I agree that it’s really great regardless.
Yeah, this makes sense and it's not surprising. I understand their reasoning, forcing us to check everything would push us into some Go-like \`if (val !== undefined)\` boilerplate hell, but I'd really like a better option for this than adding an \`| undefined\`. Thanks for linking to this, it's interesting to see the debate around it.
FWIW there's a `fromPath` API import { Lens } from 'monocle-ts' const name = Lens.fromPath&lt;Employee&gt;()(['company', 'address', 'street', 'name']) name.modify(capitalize)(employee) 
You don't want to server your plain source code to the client though. What you want is to "minify" it at least. So why not throw transpiling in the mix?
I started using TS for personal projects about a year ago and I'll probably never go back. It solves so many problems when it comes to maintainability and (team) scalability.
Ya this is why before when I built [this](https://github.com/amilner42/kleen/) which was just a tiny project and probably not something I recommend other people use (although I've used it in production) I also built this [website](https://amilner42.github.io/kleen/#generator) to auto-gen the boilerplate from the typescript types. If you paste like: ```typescript interface bla { bla: int; blo: int | boolean; }``` you'll see it generates an object.
Best I could come up with: (with `-strictNullChecks` enabled) const coalesce = &lt;TArgs extends any[]&gt;(...args: TArgs): NonNullable&lt;typeof args[number]&gt; | null =&gt; { for (let i = 0; i &lt; args.length; i++) { // args[i] === args[i] is to avoid NaN, because NaN !== NaN if (args[i] != null &amp;&amp; args[i] === args[i]) { return args[i]; } } return null; }; let foo = coalesce(null, undefined, NaN, 'maybe', 123, true); // foo is of type: string | number | boolean | null To my knowledge mapping tuple-types isn't possible yet (?). I know, `NonNullable&lt;typeof args[number]&gt; | null` looks a bit weird, but it's the most compact way to remove `undefined` from the union of all args-item types. If you don't use the `-strictNullChecks` compiler flag, then `typeof args[number]` as the return type will be enough. Also, I couldn't filter NaN as its type is just `number`. Hope that helps.
Agreed. I used it to build an API for interacting with one of Enterprise web apps and even people who don't have typescript experience can use js in a TS file and get a whole slew of typescript help not even writing typescript (most end users use primitive types or pure functions so inference is all we need)
To add to the other points: no type erasure
The problem is not that it returns void, but rather than fooMethod is a function and not a string, so it doesn't match the index signature. Try [key: string]: string | Function
You can get rid of the nested-ness of this by simply grabbing the documentList objects you're interested in up-front: ```js for (let d on this.docList) { const relatedTagsList = this.dataSource.documentList.find(doc =&gt; doc.docId === d).map(doc =&gt; doc.tags); relatedTagsList.forEach((tagList) =&gt; { this.docsForAssignment.push({ docId: d, tags: tagList }); }); } ``` If we know that `documentList` will only ever have 1 match (in other words, it will never have 2 objects in it with the same `docId`), this can be simplified even further: ```js for (let d of this.docList) { const relatedDocument = this.dataSource.documentList.find(doc =&gt; doc.docId === d); if (relatedDocument) { this.docsForAssignment.push({ docId: d, tags: relatedDocument.tags }); } } ```
This is very concise, thank you! I did not know about `.find()`. Seems very useful!
This seems like a really great solution. Thanks and thanks for the explanation and tips, as well! &amp;#x200B; &gt; array processing will almost never ever be the bottleneck of performance in your application That's great to know. As a pretty new programmer, I have very little knowledge of what actually causes performance issues, I just know it's something that one needs to be aware of. 
Your string index signature says that if I index into an `Ifoo` with a string, I'll get a string. But that's not true, because if the index is `fooMethod` then I'll get back a function, not a string. ``` const value: Ifoo = giveMeAnIfoo(); const extractedProperty = value['fooMethod']; // &lt;-- indexing with a string should give me a string typeof extractedProperty === 'function'; // &lt;-- incorrect, I got a function, not a string. The interface is wrong. ```
I publish the sourcemaps. It's possible to inline source code into the sourcemaps, but I don't see much point. It seems easier to leave them as separate .TS files.
It's not "!:", it's just "!", the other stuff is part of whatever else you're doing there. This is the "non-null assertion operator": https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator You're telling Typescript "I promise this value will never be null, so don't nag me about not checking it before referencing".
Specifically, it's a "definite assignment assertion". More info: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html It's only necessary if you use --strictPropertyInitialization. Otherwise it's a no-op.
My favourite issue on this topic: https://github.com/Microsoft/TypeScript/issues/14951
If we’re just transpiring into wasm then I’ll stick to C#!
Yea, “native” as in you, the developer, do need to worry about transpiring your TS to run it. Instead, deno handles that internally as part of the runtime. 
It's a free country and you're free pick your poison
This is the correct type, I'd stick with it if I were OP. Though if you really want to get rid of `| null`, you can either cast null to never (`return null as never`) or rethink app behavior in case no correct values were found: maybe throw an error instead of returning null?
Yes, I’m aware..?
Like others have noted, your function does not conform to index signature. `[key: string]: string` means "all fields are strings" and on the next line you declare one field with function in it. This can be solved by using union types: `type IFoo = { [foo: string]: string } &amp; { fooMethod(fooParam: string): void }`
``` function coalesce&lt;T&gt;(...args: Array&lt;T&gt;): Exclude&lt;T, undefined&gt; | null { // ... ``` Infer a union type of all args as `T`, then remove `undefined` and add `null`. The type system doesn't distinguish between `number` and `NaN`, so there's always the possibility for this function to return `null`.
Why not? Helps debugging.
The other commenters are right about the potential solutions. However, it is actually considered a best practice to move the object with the index signature to a nested property. Said differently: No property in the object with the index signature should depart from how the index signature is typed. Check this out for more details: https://basarat.gitbooks.io/typescript/docs/types/index-signatures.html Section: Design Pattern: Nested index signature Obviously, in some situations you may be forced to have all the properties in the same object (e.g. when working with an external dependency). But I found the above pattern to be very useful when I control all of the code myself. 
I’m on mobile and I can’t read the article. It’s just blank with a tweet. Am I missing something?
Looks like it is a link to a news letter.
&gt; https://github.com/ioanungurean/forge-react-app/blob/master/templates/TypeScript/tsconfig.json Really? No strict mode enabled?
Thanks! I missed it!
You have to supply a type for what you want the accumulating value to be. TS isn't going to run through the iteration to figure it out itself, it only does static analysis. That's why something like this even fails: ```ts const arr = [1,2,3,4] arr.reduce((acc, x) =&gt; [...acc, x], []) ``` You can supply the type as a generic type to `Array.prototype.reduce` like so: ```ts arr.reduce&lt;[number, number][]&gt;( (acc, cur, idx, src) =&gt; idx &gt;= src.length - 1 ? acc : [...acc, [cur, src[idx + 1]]], [] ) ```
Thanks! Didn't know `reduce` takes generic types.
I enjoy react and learning TS now definitely will use this 
* Laughs in angular *
Sounds like a path issue. If you're using nvm or a normal node install, the `bin` folder has to be in your path to use globally installed packages. If I `echo $PATH`, I can see the following: `/Users/user/.nvm/versions/node/v11.6.0/bin`
Custom transforms are precisely the part of the JS/TS ecosystem that I think needs to be developed much more. Types dramatically reduce the amount of checks and assumptions the transformer needs to make about how the code, assuming that TS is used in its strict mode and the developer takes responsibility for `any` casts and other workarounds. The program flow analysis is still needed, but it is much easier to tackle with the type info available. Most of the projects I work with are performance-sensitive (complex apps and tight game loops that should work on mobile), so even micro-optimizations often matter, and they are also the best candidate for automation via transforms. I really hope to see more stuff like this in the nearest future.
To be fair, React with TypeScript is a much more pleasant experience than Angular with TypeScript. Angular makes pretty bad use of TypeScript in many cases.
I have no idea what a circuit breaker pattern is, and while I'm sure the library is great, I'm really missing a compelling example in the readme that would actually use the breaker ref for something. 
Please, elaborate.
I disagree, but I also think jsx/tsx is an abomination so we probably have very different taste in engineering practices.
You might have better luck asking on a node or npm subreddit, since this is an npm issue, not specific to TypeScript.
It sort of just doesn't make sense to solve this at the language level. There's no language on earth that can tell you at compile time whether an index is out of bands for a dynamic size array. In the cases where it is possible to know the size, or a range of sizes, you can express this pretty well, e.g.: type MyArray = [string, string, string]
That is valid .ts code, so one option is to let the compiler generate 
Use declaration merging: class Foo {} namespace Foo { export class Bar {} }
Definitely recommend looking into vanilla JS Array.sort ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Array/sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)). About a quarter of the way down are some examples of writing your own comparer.
Ah okay. Thank you very much.
Something like this? interface Book { title: string; } [{ title: "My Title" }, { title: "Another Title:" }, { title: "Yet Another Title" }].sort((a: Book, b: Book) =&gt; a.title.localeCompare(b.title))
I am pretty sure you have to use `sudo npm install -g typescript`
That's a good idea, thank you. I will add a little more elaborate example. 
This might solve the immediate issue if the original installation had failed due to insufficient permissions, but it sounds like it didn't.
I know, but in all my time working with mac I do not remember never succeeded in install a global npm package without sudo. And when I was starting I didn't even notice sudo errors. A couple of downvotes are OK if my answer maybe helps.
&gt; jsx/tsx is an abomination Mind sharing why?
How do you deal with bad ts support for so many React libraries. Even huge libs like react-spring don't have definitions
Check lodash or underscore for such utility functions
This probably isn't the response you were expecting but there are some really awesome tools that can make your life way easier. If you use fish and node-binpath (I'm sure there's other options without having to use fish) you can map the executables in your node_modules to your path. The reason you would want to do this is because different typescript projects will use different versions of typescript - you don't want to couple that to your global environment.
This is a repost... By yourself: https://www.reddit.com/r/typescript/comments/aiyu1t/ts_tricks_type_guards/ Also, this is partially bad advice. You shouldn't introduce user-defined type guards for cases that the compiler can figure out just fine.
Yeah, I would recommend installing node, python etc in one's home directory with some version manager or package management system. Sidesteps this whole issue and especially with Python prevents accidentally clobbering mac system python libraries. 
I'd personally prefer to type the array as `Book[]` and let the following methods infer the types themselves.
Worked perfect. Thanks!
This is actually really a solid idea I like it thanks
Nest is great, needs more exposure
What others said, it's useful when you're initializing a class property after it's been instantiated. With strict checks on, TypeScript doesn't like when you have properties that aren't initialized upon declaration or in the constructor, like if they're assigned via binding from a parent component in some front-end framework or through dependency injection.
Create a class implementing the interface then Auto create all the methods, then mock this class with ts-mockito or test double
Another way to handle this is to create a spy of the object and tell it the specific return value. I do a lot of work with Angular, and this is their preferred way to handle this situation. I'm not familiar with ts-mockito, but that is another option that another user brings up. It may be better than using a spy. 
This seems useful for interfaces, but can't you just do: typeof any data == "string" for all the primitive types?
I learned something, thanks a lot. I loved the example, too. Anything that isn't another todo list or car reference...
Sure you can, it *is* mostly useful for interfaces. For example, I specify a backend API for an app with TypeScript interfaces. These requests can get quite complex, put() calls often include strongly-typed domain entities, etc. So in the API code, I use typescript-is to get request shape validation for practically free, and then after successfully calling `is&lt;T&gt;` I can use the thing as if it was of the right type. Another use-case is the frontend for the very same app. I use typescript-is to verify that the shape of responses from external APIs matches what I expect to get/use from them. It's much better to get a failed typecheck error when the call happens, than a "Cannot read property x of undefined" somewhere random down the line.
To create real object I need database connection, and this is not preferred
That's pretty amazing. What's the performance like compared to say Express or Hapi?
Looks pretty nice. How would you compare it with NestJS?
I do know that nest is amazing. But let's not compare X with Y . Let's just think about how we can take X or Y and make something which someone would appreciate.
Thanks so much! I'm actively writing for my blog, if you subscribe I can promise an endless stream of Harry Potter sample code
What about i18n routing?
Damn, I'm going to do a deep dive into this! Looks amazing. Currently using Java EE 8 w/ VS Code: the Intellisense is *okay*, but having the full TS experience will make developing backend code a breeze :)
FoalTS and NestJS are both Node.js frameworks that support TypeScript natively. They have some differences though: \- NestJS architecture is greatly inspired by Angular. Foal's architecture aims to be simpler and easily approachable from non-Angular developers. You'll only find three "components" in Foal: controllers, services and hooks. The goal is to give more freedom to developers. They don't spend time trying to understand how the framework wants them doing what they want to do. Instead, the framework lets them build their app in their own way. \- Then, FoalTS is more than a TypeScript framework. Not only does it bring architecture. But it also offers many dev tools and utils out-of-the-box useful in many scenarios. For example, in FoalTS, you have utils to encrypt passwords, validate and sanitize request bodies, control access through groups and permissions, write and run unit tests, generate database migrations or manage configuration variables between several environments.
Definitely not trying to compare per say but try to understand more the differences as the way to write (decorators etc..) seemed close :)
Thanks @maxfontana90. I felt like most i18n stuff were done on the frontend nowdays (with Angular/Vue/React). But maybe I'm wrong. Do you think it is still relevant to handle i18n routing in the backend? Thanks!
Seems much more what I'm looking for, thanks for the details!
Nice, I've been using nestjs extensively and this looks like a good competitor. One thing: I clicked the github icon on the top right on the page and I get forwarded to https://foalts.org/undefined . Opening in a new tab opens the repo.
Well, from what I could see FOALTS is not intended to be used to build rest APIs only. You could write server side rendered applications too. So i18n is also important when it comes to routing capabilities. Probably integrating foal with an existing template engine would be nice too. I personally like Twig, just in case you are interested.
Thanks ReactManiac. If you mean response time by performance, I haven't done checks yet (although I do not feel slowness on my applications). Definitely something that I should benchmark in the future! The framework is based on express
I'm not 100% sure what you're asking for, but it sounds like you want a typescript runtime? In which case, you're probably looking for something like [ts-node](https://github.com/TypeStrong/ts-node)
Those are honest questions. - Why inverting the semantics of a context? Graphql, express and many frameworks have a notion of context, but it is the context of a request, and not the request of a context. - Why should I use an object creation for the response? It looks less convenient than an error code + plain object. - Can we use anything but JSON for responses? - Why do we have to provide a string to the ACL? Is it the name of the rule? - Why are the annotations inconsistent in naming between PermissionRequired and ValidateBody? (should be something like validateBody, validateJWT and validatePermission...). - How do I interact with the ACL from the body of the controller? (like users can only modify their own products...) - What are the design guidelines? Why would I use this framework instead of xxx ? 
Sorry, should have been more clear. I basically just want to be able to put breakpoints, walk through functions step by step, "step into" functions, inspect variables, etc in the TypeScript files, just like I did with Javascript files before. And right now, if I put a breakpoint on a function call (say, in `main.ts` a function a function `login()` is called from `client.ts`) and step into it, VSCode takes me to the compiled .js file instead of the original .ts file, so it's harder to debug what's going on. I'll look into ts-node though, thanks for the suggestion.
Okay, I'll take a look into this. Regarding the template engine itself, the framework uses [EJS](https://www.npmjs.com/package/ejs) by default. But it can also support others like Twig. The way to do so is to create a npm package that exports a `renderToString` function and specify the package name in `config/settings.json`: `"templateEngine": "my-package-name"` (see [here](https://github.com/FoalTS/foal/blob/master/packages/ejs/src/index.ts)). If you feel like to open a PR btw, I'll be happy to review it ;)
Thanks for your feedback and thanks for reporting the website problem! I opened an [issue](https://github.com/FoalTS/website/issues/24). Didn't know about objection.js. I'll take a look. Are the TypeScript types well-maintained? About the default ORM, every new Foal project starts with TypeORM installed. This lets developers quickly build a new app without configuring or searching for an ORM to use. However, you can get rid of it pretty easily by uninstalling the `@foal/typeorm` and `typeorm` packages and use `objection` instead. The framework core and its other packages (jwt, etc) do not make any assumptions about the ORM that is used. Further versions will also offer a `foal/mongoose` package.
&gt; Didn't know about objection.js. I'll take a look. The documentation is super awesome. Whenever the ORM (objection) gets in your way with overly complex chaining, you can just switch to knex.js and go almost pure SQL without having to know SQL. And the graph inserts/upserts are awesome, too. Last time I've checked out typeorm, I had issues with a createdAt/updatedAt column and there was no real upsert. The documentation was really bad, too. &gt;Are the TypeScript types well-maintained? They are maintained in the [official repo](https://github.com/Vincit/objection.js/blob/master/typings/objection/index.d.ts) so I'd say so. &gt;The framework core and its other packages (jwt, etc) do not make any assumptions about the ORM that is used Ah, that is nice. I assumed it does. If you can just switch them out, it shouldn't really be a problem :)
It sounds like you either aren't generating source maps or they aren't being loaded correctly. To generate them, you need a couple things in your setup: * tsconfig.json needs to include "sourceMap" set to true. * webpack config needs to have "mode" set to "development" * webpack config needs to have "devtool" set. You can look at the dozen or so different options in the webpack docs, I normally use "eval-source-map"
I tried it out. I am doing the Simple To-Do List tutorial. I ran into a problem. Please look into it. In the 4th step, I ran into the problem, You have mentioned it as, " Note that if you try to create a new to-do without specifying the text argument, you'll get the error below. " But I did as you say and still got the error.
Thanks for the reporting this. Could you give me precisely the command you're running? Thanks
Great work, can't wait to try it out. Tried Nest, but it was too fat and Angular-y for me, so this seems to be up my alley.
Any reason you used express instead of koa? 
I've got sourcemaps set up in the tsconfig.json. I'm not using webpack, just node.js with typescript installed globally. Do I need to be using webpack? (Sorry, I'm pretty new to most of this) (This project won't be run on the web. Eventually in Electron, but right now, it's just cli)
Fuck. I saved a great medium post but I can't find it. Lookup setting up typescript jest and nodemom specifically medium pages. I know that doesn't sound applicable but he has a section about seeing up the inline debugger with tsnode. The other parts of the article will help you search for it easier since the debug part was a tiny section
This library makes it really easy to create and use languageService / compiler instances based on a project's tsconfig. Normally tsconfig discovery and parsing is annoying and requires more steps than you'd think. This library makes it easy. It gives you the parsed tsconfig, a list of all source files matched by your config, and a languageService instance for the full TS compiler API.
I guess that both are possible choices. The main reasons why I chose Express were: * For developers using sessions, Express has [a lot of compatible stores](https://github.com/expressjs/session#compatible-session-stores) for its `express-session` middleware. * Express is maintained by IBM and has "regularly" security patches. * Some of the Koa middlewares are just wrappers around Express middlewares (see [koa-helmet](https://www.npmjs.com/package/koa-helmet) for example).
Amazing 
Thanks!
Thanks for being honest /u/batmansmk!. This way the framework can be improved ;). * I'm not sure to understand what you mean. Could you give me more details or references to read? What do you find annoying? Regarding the Foal `Context`, it has three properties (user, state and request). The request property is actually the express \`Request\` object that is passed through the `Context`. * The main reasons were to be able to send cookies and headers and to improve testability. Here's an example: &amp;#8203; @Post('/login') // ... async login(ctx: Context) { // ... const response = new HttpResponseOK({ message: 'Successfully logged in!' }); response.setHeader('Token', 'my token'); return response; } The test: it('should log the user in.', () =&gt; { const controller = createController(AuthController); const ctx = new Context({}); const response = controller.login(ctx); if (!isHttpResponseOK(response)) { throw new Error('The response should be an instance of HttpResponseOK.'); } deepStrictEqual(response.body, { message: 'Successfully logged in!' }); strictEqual(response.getHeader('token'), 'my token'); }); However, it's right that it might tedious in simple situations. I guess we might also accept these options: @Get('/movies) async readMovies(ctx) { const movies = // ... return ok(movies); } // OR @Get('/movies) async readMovies(ctx) { const movies = // ... return [ movies, 200 ]; } Would it be more convenient? * Yes, you can send strings or booleans for instance. * It is the name of the permission. A permission allows a user to perform a certain action (like accessing a route). A user may have several permissions and may belong to several groups (sets of permissions). Using groups and permissions is suitable in complex apps where you have different users (admin, read-only, etc) and plans (Free, Premium, Enterprise, etc). These permissions and groups are defined as rows in the database to allow more flexibility. However, you might not need to use this feature. Depending on your needs, you might want to have a simpler authorization system or build your own. This is entirely possible by creating your own *hook* (i.e. a decorator that execute logic before/after your controller method). &amp;#x200B; Here's an example with an application that has only two kinds of users: admins and non-admins. The model: @Entity() export class User { @PrimaryGeneratedColumn() id: number; @Column() isAdmin: boolean } The hook: export function AdminRequired() { return Hook((ctx: Context&lt;User&gt;) =&gt; { if (!ctx.user) { return new HttpResponseUnauthorized(); } if (!ctx.user.isAdmin) { return new HttpResponseForbidden(); } }) } The controller: export AppController { @Get('/movies') @AdminRequired() readMovies() { // ... } } * `ValidateBody`, `ValidateQuery`, `ValidateParams` and `ValidateParams` validate the HTTP request against a schema (using [AJV](https://github.com/epoberezkin/ajv#api-validateschema)). `PermissionRequired` and `JWTRequired` do not deal with validation but with authentication and access control. * You can return errors in the controller body: &amp;#8203; @Delete('/:id') async deleteById(ctx: Context) { const movie = await Movie.findOne(ctx.request.params.id); if (!movie) { return new HttpResponseNotFound(); } if (!movie.userId !== ctx.user.id) { return new HttpResponseForbidden(); } // ... } If you are using groups and permissions, you can also access some interesting methods such as `User.hasPermission` * FoalTS is meant to be *simple*, *testable* and *progressive*. By simple, I mean that it keeps away complex abstraction layers that make the application hard to understand, maintain, secure and extend. Each part of the code is designed to be testable whether you wish to write asynchronous unit tests or perform e2e testing. Eventually, the framework lets you start small and then grow big: everything is provided and pre-configured so that you can fastly bootstrap a new project. But you're not stuck when it is time to extend and customize it. If this is not clear or want to emit suggestions / objections / advices or ask other questions, feel free to reply back!
Thanks for answering.
You need to use source maps.
I am using source maps. [Here's a screenshot of my directory structure with mapfiles shown.](https://i.imgur.com/bPAB1NS.png) I've also updated the `launch.json` to remove the deprecated `outDir` parameter, and replaced it with `"outFiles":["${workspaceRoot}/bin/**/*.js"]`, though nothing has changed.
I haven't really used TS with node beyond a couple simple scripts, sorry. :\ If you are generating the source maps it must be an issue with loading them. You may need to set the outFiles property in launch.json? AFAIK there's no particular reason to use webpack with node unless you're using javascript and want to get support for language features that node doesn't natively support. This isn't an issue with typescript.
At a glance, this looks excellent. Very concise code for handling extremely common scenarios.
I've run debugging directly on the TypeScript code using ts-node before with Webstorm. The command ends up being something like this (: `node --inspect-brk=55992 -r ts-node/register main.ts` Have you tried adding \` "runtimeArgs": \["-r", "ts-node/register\]\` to your launch.json? I took a glance at some examples [\[1\]](https://medium.com/@dupski/debug-typescript-in-vs-code-without-compiling-using-ts-node-9d1f4f9a94a)[\[2\]](https://fettblog.eu/typescript-node-visual-studio-code/), I'm guessing you've also tried those configurations?
Nice job, but this seems somewhat easier to grok: https://dev.to/busypeoples/notes-on-typescript-pick-exclude-and-higher-order-components-40cp
In the tutorial for the simple Todo. I ran the command `foal run create-todo text="Read the docs"` and this is giving the error.
Looks like a nice framework but I have the same question of when I looked at nest. What is the advantage of “Spring” looking classes as controllers? I know they can provide some clean decorators but overall they can be clunkier than standard express code. 
This looks very exciting! One problem I had was using JWTs as I don't use a static secret - so I can't just put a string value in \`settings.json\`. Maybe there's another way to get that value? &amp;#x200B; Fantastic work though, I'll be keeping an eye on this! Thanks for sharing.
When you duct tape a problem like Typescript does, run time becomes fun time!
Holy crap. Non side effect controller handlers. I've dreamed of these. I hate testing Express/Koa controllers, having to observe what the handler does to the response object. I'd rather just assert on what was returned. I am definitely going to try this out.
I'm just running into problem after problem lol. Adding `"ts-node/register"` to the launch.json runtimeArgs causes it to say in the terminal it can't find the "ts-node/register" module. That's fine, so I install it globally, and then it gets past that, but then when it actually tries to run, it says it can't find it again, but in the debug console. 
Hmm. I wonder if there is not a special character hiding in this command. Could you re-write the command manually in you terminal to see what happens? Also, did you play with the definition of the schema previously? If so, you might have forgotten to re-run the `npm run build:scripts` command. Let me know!
I also don't believe in dynamic typing. It makes me feel less confident. 
No I don't forget to npm run build: scripts. I will type the command in place of pasting it and check it.May be it was weird character set issue.
I would like to agree. Using TypeScript was wonderful in that it gave me code hinting, static analysis, and let me catch bugs that were hidden for so long. But it was also a pain trying to create union types, do casting, and force-suppress what would have been a perfectly fine JavaScript pattern. It was as if I was using C# for the web.
&gt; and force-suppress what would have been a perfectly fine JavaScript pattern. Well that's your problem. If you want to use TypeScript effectively, you have to use it the way it was intended. Stuff like union types are largely there to make it easier for TypeScript to consume non-TS libraries. They shouldn't be your first choice and even casting should be relatively rare. If you want to stay with JavaScript design patterns, then by all means stay with JavaScript. You'll be much happier.
VB's motto was "Statically typed where possible, dynamically typed when necessary". I'd like to see web programming adopt this as well. 
Install ts-node locally, it's a separate package. Also you should generally keep TypeScript installed locally to your project to ensure the version is correct.
&gt; If you want to use TypeScript effectively, you have to use it the way it was intended. I'm doubtful if *full* TypeScript would be super effective, but I agree it'll be more effective. I enjoy dynamic typing and static typing, but it feels messy and over-complicated to use TypeScript sometimes. My background is in ActionScript, Java, C#, Python, so it's not a fear of classes, but rather a personal preference for the flavor of each language. I'm working with a JavaScript-first codebase, as well as small open-sourced non-TS library dependencies. We have a bit of isomorphic code on back-end and front-end too. Maintaining code as JavaScript/ES6 is very important for my work. Personally, I prefer, and am using, TypeScript as a JS-doc assisted linter/code hinter in VSCode. I get to retain valid JavaScript, both on deployment and development side, while using a standardised commenting style with minimal tooling.
It does, it's called Typescript.
Hi /u/tobegiannis! Thanks for your feedback. I guess that it is a matter of taste and I can understand that some people might not like it. I like the class approach because it allows for a more elegant code using decorators and it also makes testing easier with dependency injection. &amp;#x200B; Let's say that I want to test this code in Express: router.get('/movies', async (req, res) =&gt; { try { // thirdPartyService.find makes a HTTP request to a remote API. const movies = await thirdPartyService.find(); res.send(movies); } catch (err) { res.send([]); } }); Writing a unit test here is not easy. How can I test the route `/movies` of the router? How can I mock the `thirdPartyService` not to make a request to the remote API? &amp;#x200B; Here's how it would look in FoalTS: class MovieController { @dependency thirdPartyService: ThirdPartyService; @Get('/movies) async readMovies() { try { const movies = await this.thirdPartyService.find(); return new HttpResponseOK(movies); } catch (err) { return new HttpResponseOK([]); } } } The tests: it('should return the movies from the remote API.', async () =&gt; { const movies = [ { name: 'Back to the future' } ]; const serviceMock = { find() { return movies } }; const controller = createController(MovieController, { thirdPartyService: serviceMock }); const response = await controller.readMovies(); strictEqual(response.body, movies); }); it('should return an empty array if the service throws an error.', async () =&gt; { const serviceMock = { find() { throw new Error(); } }; const controller = createController(MovieController, { thirdPartyService: serviceMock }); const response = await controller.readMovies(); deepStrictEqual(response.body, []); }); &amp;#x200B;
The title is unfortunate because it actually explains how to use JSDoc annotations to provide types.
Thanks for you feedback /u/fix_dis! Glad you like it. In which case are you using a "dynamic" secret? Currently the hook only support static secrets (or RSA keys).
That's just the tool, actually embracing the idea is another thing entirely. I'm not so sure we're there yet. 
Even when writing JS only code, I'd never change the type of a variable. So I just use TS to remember what that type is.
I installed your framework, what worked like a charm. Opening the website I was to be honest a little disappointed by only seeing a blues site with 3 outbound links. May be it is just me but I would prefer to see some implemented bootstrap and business process basics as user registration and a profile page, which is needed in any application. &amp;#x200B; Then I had a quick view at your [https://foalts.gitbook.io/docs/tutorials/simple-to-do-list](https://foalts.gitbook.io/docs/tutorials/simple-to-do-list) tutorial. The whole process from installation, documentation experience underneath and testing took me 32 minutes. I especially liked your use of decorators for securing the post routes. &amp;#x200B; Assuming (!) to be a newbie to TS I would have had following "errors" from your 4 months old example: \* does not create the script file "create-todo.ts" in "src/scripts/" $ foal generate entity todo CREATE src\\app\\entities\\todo.entity.ts UPDATE src\\app\\entities\\index.ts &amp;#x200B; \* The copied source of "create-todo.ts" does not end with new line &amp;#x200B; \* Context, HttpResponseNotFound, HttpResponseNoContent, HttpResponseCreated, Context, Delete, Post is not imported in "src\\app\\controllers\\api.controller.ts" on site "[https://foalts.gitbook.io/docs/tutorials/simple-to-do-list/5-the-rest-api](https://foalts.gitbook.io/docs/tutorials/simple-to-do-list/5-the-rest-api)" &amp;#x200B; I guess it should be: &amp;#x200B; import { Context, Delete, Get, HttpResponseCreated, HttpResponseNoContent, HttpResponseNotFound, HttpResponseOK, Post } from '@foal/core'; &amp;#x200B; and: &amp;#x200B; \[tslint\] " should be ' \[quotemark\] --&gt; ts-lint error so replace " with ' &amp;#x200B; \* [https://foalts.gitbook.io/docs/tutorials/simple-to-do-list/6-validation-and-sanitization](https://foalts.gitbook.io/docs/tutorials/simple-to-do-list/6-validation-and-sanitization) needs 2 more imports from @foal-core -&gt; so add 2 more imports from core &amp;#x200B; import { .... ValidateBody, ValidateParams } from '@foal/core'; &amp;#x200B; and Decorator object props should be aphabetically: &amp;#x200B; @ValidateBody({ // The body request should be an object once parsed by the framework. // Every additional properties that are not defined in the "properties" // object should be removed. additionalProperties: false, properties: { // The "text" property of ctx.request.body should be a string if it exists. text: { type: 'string' } }, // The property "text" is required. required: \[ 'text' \], type: 'object' }) &amp;#x200B; So it is a start but very essential parts like, menu, built-in design framework and user administration I do miss. &amp;#x200B; All in all a very professional framework that works. Having more time I'll go further... &amp;#x200B; \*thumbs up\* &amp;#x200B; &amp;#x200B; &amp;#x200B;
&gt;Stuff like union types are largely there to make it easier for TypeScript to consume non-TS libraries. That's nonsense. DUs are a very commonly used in TypeScript.
[removed]
 Learn how to use DevOps from beginner level to advanced techniques which is taught by experienced working professionals. With our **DevOps Training in Chennai**, you’ll learn concepts in expert level in a practical manner. [DevOps online training](https://www.gangboard.com/operating-system-training/devops-training)
Nothing screams professional quality like advertisment through spammy Reddit comments.
I feel like if you have to use union types a lot, then there must be something wrong with the surrounding architecture. It is possible that these perfectly fine Javascript patterns are the things that make me go "WTF were they thinking and how does this even run at all"?
When writing a game as a prototype, i suggest making it work first. The dirtiest, most stupid way possible. In any way possible. Just make it work. Make it playable. Figure out how to make the code pretty/better later.
Never? Not even to e.g. do `if (somePotentiallyUndefinedString)`?
&gt; Well that's your problem. If you want to use TypeScript effectively, you have to use it the way it was intended. TypeScript _is_ intended to capture perfectly fine Javascript patterns... (Although in my experience, it does so pretty well - I'm not usually running into the problems described by GP.)
I currently have a system that fetches a dynamic secret and caches that for 15 minutes, and then "rolls" that key. It would be nice (perhaps inside of some other configuration) to be able to specify where the secret comes from (whether a static file, config value, some other value that might be dynamic) &amp;#x200B; Regardless, great work!
babel doesn't know about BigInt so it is treating it like a normal number. You could make a function BigIntPow and define it yourself in a polyfill.
My two primary languages are JavaScript and go and I also dabble in C. So one static and dynamic language. I love both for what they are. But when we talk about type systems, the best thing about go is the types feel natural and robust, and similar to C, as if the types are just a way of you to structure memory. The code is explicitly safe because when you get a slice of bytes you need to unmarshal it into the type you want and if it succeeds you have that type. The reason I am talking about go is to highlight why I do not think typescript is a good static language. I have been working with typescript on the backend for 8 months now. The types do help catch silly mistakes, and they do allow your editor to work better for you, say when refactoring code. It's nice to have better more reliable autocomplete. But typescripts type system is super complex, not orthogonal in the least, prone to error. The lack of validation I see in typescript projects because somebody (even myself) wrote a type makes me want to pull out my hair. That type means nothing at runtime. The error could occur somewhere deep in the code in a super obfuscated and hard to debug way. When now you have frameworks built on top of express, in typescript, just so it looks more like java spring with decorators, you have essentially taken a language (nodejs), built a framework (express), wrote a transpiler (compiler) typescript, wrote another framework (routing controllers or others), activated experimental features of stuff that doesn't even comply with the proposal (typescript decorators are an old implementation of the proposal). What you've got is a nice house of cards. Good luck if anything doesn't work as expected. I wrote a simple graphql server in nodejs. Was about 4 files long of about 50 lines each. Had to rewrite it in typescript with the companies scaffold and tool chain, ended up with a giant repo with patterns everywhere. The code doesn't do anything different. It's just way more obfuscated. But you have type information if you hover above a variable! To cut it short, typescript type system is so easily broken and mistreated, that it's the furthest thing from type safety. It's a nice editing experience, and a deep dive into abstractions you don't need. It's a pill that makes you forget to validate your code, because at the end of the day your running JavaScript. Use it if you like, I am and I wish I wasn't, but I would like it if people woke up to it instead of worshipping it and being blind to its deep deep flaws. 
Nice video production for this type of thing, but I don't think the message is very useful. He has a specific workflow that doesn't benefit from Types (and he seems to actively hate them) and is recommending broadly that TypeScript isn't needed. Many developers and teams are working on projects that don't have GraphQL or the capability to auto generate code. He also admits he doesn't work on teams of the size that normally see the benefits. His points aren't wrong (for his examples JS makes sense), they just don't seem broadly relevant.
Thanks! I was hoping there might be other people in a similar situation. Also, I don't hate types, as I said in the video, I love using them in this particular project, but I wouldn't start every project in TS.
Oh never mind... I can create my own hooks. (I should have read more of the documentation before replying here)
I disagree. The architecture of your data is the most important thing going forward because it's the hardest thing to change, it should be the _first_ thing you do. From there 95% of typing costs you nothing and will only aid in development.
I'm concerned that you necessarily associate idiomatic TypeScript with classes.
I can write C# using mostly goto's, dynamic typing, and explicit memory management. That doesn't mean it's necessarily a good idea.
&gt; Dynamic typing allows you to save time and efforts at the beginning of the development, whereas static typing gives you a boost at the end of it. Does it really? Personally I haven't found that to be the case, as the time it takes to modify a class is trivial compared to the amount of time I spend thinking about where I'm going to get the data I need. 
But should they? Or should it be considered a code smell. &gt; I feel like if you have to use union types a lot, then there must be something wrong with the surrounding architecture. -- blakflag
Yes, they should. They're not code smell, they're a very useful construct that is used to represent: This data can be one of these N types. I couldn't think of a cleaner approach than a DU, and data like this is very real and common (and not code smell either).
Why are you frequently sending data that has nothing in common, not even enough to create a shared interface, down the same pathways?
And if you create a shared interface, how do you do distinguish the two derived interfaces? With a discriminator. And bam, you're back to a DU.
If you need to distinguish between the two derived interfaces, then the shared interface clearly isn't being used. So my question remains.
Let's take the Reddit API as an example and model the data types. For a regular union case: https://www.reddit.com/dev/api/#GET_comments_{article} Here the `sort` property would be a perfect case for a union type: It can only be one of those 8 strings. Using the type `string` would be a bad case, as it allows for too many values, so instead a union type with the string literal types would be used. Or for a DU case the widget call: https://www.reddit.com/dev/api/#POST_api_widget Depending on the `kind` property a different set of data (properties) can be sent. For each widget case you'd have a different interface with a `kind` property, then overall say "one of these types". You often have the case that API returns data that either matches specification A, or matches specification B and can be distinguished based on a discriminator. DU are also used in functional programming, e.g. the `Maybe&lt;T&gt;` monad, e.g. interface Some&lt;T&gt; { readonly isSome: true; readonly value: T } interface None { readonly isSome: false } type Maybe&lt;T&gt; = Some&lt;T&gt; | None; And if you check for `isSome` in a conditional, then the compiler can determine the actual type (`Some&lt;T&gt;` or `None`) based on the check.
that's not changing types, that just to check if it's null / undefined (which is common in every application that accepts user input, no matter the language)
Ok, that argument I believe.
You need to set your target to `esnext` - that pretty much means that your code will only work in latest Chrome/Opera with native BigInt support. See https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#caveats-1
You're actually casting it to a boolean there - `null` and `undefined` happen to cast to `false`, but so would `0` (which would also fail that check). Which, of course, you can only do with dynamic types. That's why you do `if (somePotentiallyNullValue != null)` in Java.
Well, I'd appreciate it if you could tell me why it's not a good idea then. I've been using Javascript patterns all the time (although obviously skipping some `null` checks and the likes), so I probably have a lot to learn then.
I'm not saying that it is necessarily bad either. Each JavaScript pattern that you want to adopt in TypeScript needs to be considered on its own merits. Some clearly defeat the purpose of using TypeScript. A good example of this would be declaring every local variable as type `any`. Others like using unions all over the place are debatable. u/blakflag thinks that's an indication that there's a design problem, u/AngularBeginner treats them as necessary since JS/TS don't support overloads like we'd see in C#.
Classes (or data structures if you prefer) are the foundation of static typing. And since TypeScript was primarily designed to add static typing to JavaScript, I find it hard to believe that classes aren't associated with idiomatic TypeScript.
&gt; u/AngularBeginner treats them as necessary since JS/TS don't support overloads like we'd see in C#. Wtf no. Overloads would not solve what union types provide. Unions are a way to model **data** that can take different formats. They're very commonly used in functional programming (e.g. in F#).
I wouldn't personally consider classes, which imply an object-oriented architecture, to be solely data structures. I've had this argument before though, it's really semantic. My reason for saying that classes, in the language feature sense, are not necessarily idiomatic is only because there's a lot of people mistakenly thinking that they are, and that if they adopt TypeScript they're expected to start treating their code as if it were in Java.
Just twisting your ear 'cause I'm bored. I wasn't going to leave it that way.
&gt; Classes (or data structures if you prefer) are the foundation of static typing. Data structures, sure. Classes? Not necessarily. You can write idiomatic TypeScript without using classes just fine, simply by following a more functional approach. Just have data structures (objects that **only** represent data) and functions (code that takes data and outputs modified data). Object oriented programming is not the only way.
I wonder about that. The people who created TypeScript were heavily involved with C#, so wouldn't be surprised if they expected a more Java/C# style of code. That said, what they intended and what turns out to be the best way are not necessarily the same.
&gt; Am I getting the error message shown above because Math.pow() needs a number, instead of a BigInt? Yes, see the [other exceptions](https://github.com/tc39/proposal-bigint#other-exceptions) section of the proposal. Also, see [this PR for babel](https://github.com/babel/babel/pull/6015), and [this open issue](https://github.com/babel/proposals/issues/2). That said, if you want maximum compatibility, you should probably turn to Math.js for now.
Yes, you could use either style. But what is the 'best' way in your opinion?
Related [https://github.com/LeDDGroup/ts-types-utils](https://github.com/LeDDGroup/ts-types-utils) :), there are some many of these packages, they should be unified
DU’s are an amazing feature of the type system - far from a code smell
We write idiomatic Typescript and our code does not use classes at all. None. 
This seems to blur this lines about the difference between functional and OO programming and the difference between static and dynamic type systems. You can have an OO language or use OO concepts in dynamically typed and statically typed languages and the same with functional languages/concepts. 
Personally, I just use TypeScript on its own (without Babel). So far I've not required any Babel features and I feel that it adds an unnecessary extra dependency, transpile step and complexity to my build process for very little gain.
Why do you think the type system is complex? Because it has to model the various less structured paradigms of JavaScript. It does an incredible job at that, it’s probably the most advanced type system I have ever worked with. 
I don't think typescript has done a bad job at doing what it tries to do. Typing JavaScript sounds like a nightmare. They've done a great job at that task. But still, it doesn't make for a good language. Or superset, or whatever. It might be useful to mention that I am a backend developer. I understand that on the front end you have very little choice. But as a backend developer I am frustrated to be stuck with typescript. I would use node, or an actually robust static language. 
So if I understand you, you are saying if you set out to write a language from scratch that’s statically typed it would not look like typescript. Well, I bet even the typescript team would agree with that. 
More so than that, I would say that the desire to accommodate typescript to supporting everything JavaScript can do, actually hurts typescript. I've written a npm package which does function memoization and has a LRU queue, and can do argument currying, tons of very fun stuff. I wrote it in js but wrote a index.d.ts for it. It was by far the most complicated part to write, and is still by far the hardest thing to read. If typescript focused on type safety as a built in to the language and was less all over the place in the syntax and overlapping features, I think it would be a much more solid tool. 
Sure, but then it would no longer be JavaScript. As for your library. I agree writing the types for something like that would be complicated and since it’s quite advanced, hard to read. What language/type system, would do a better job in your opinion?
I like simple type systems like with Go. But that's a preference in style and aesthetics. The problem with typescript is it really is just a type bandaid stuck on top of your code. Without serialization of data into types (unmarshaling) or something analogous when passing from any to a type, I just can't help but feel the language is just an editing experience (autocomplete and the likes). I use Joi as my validation library for my objects. But I have to maintain my validation and types alongside each other with no guarantee that I am not making mistakes. I would rather just write my validation and keep the flexibility and simplicity of JS. Meanwhile what I commonly see is typescript types and no validation. Yikes. A language that lulls you into thinking things are typesafe when they aren't is no good. I would rather have typescript be a superset of a subset of JavaScript, if it was simpler and typesafe, than the mess I believe it currently is. Do you feel I am being unfair? 
I agree; I've asked about how to unify under TypeStrong but haven't received much response yet. 
I think you may be overemphasizing the validation part, but it really depends on your particular use case. Also there are validation libraries that let you define the validation then use it as a type - preventing the duplication. Have you looked?
Pretty clean. Good work
Just a guess, but check your target in tsconfig.json. It needs at least ES5
If your goal is to make extensible, testable, maintainable backend application, I would recommend you to use https://nestjs.com/ Recently discovered and I am very happy with it.
I have never wanted to commit to any of the libraries that I have looked at. I find them too complicated, like they are micro-validation frameworks in and of themselves. The reason I have never tried to commit to one, is that it pollutes the code too much, and it would a pain to switch out for a different one. Validation is an essential part of a project. With a proper type-safe language, your types are validated via the serialization process. In typescript you have nothing to replace this. In javascript you write good validation. typescript code with types but little validation is one of the main reasons i feel that most code written in typescript is garbage. Its the norm for typescript. And i dont blame the developers. Its hard to decide to validate something you told the compiler to tell you is a type you know.
I tried running the command similar to what the instructor ran(he's on mac, I am on Windows) tsc --target ES5 For some reason it just gave me a huge list of options for commands, including the target one so I have no clue why it didn't do anything. 
UPD: I wrapped Response in ``` class ResultResponse&lt;R&gt; implements Response&lt;R, null&gt; {} ``` and now I get ``` TS2348: Value of type 'typeof ResultResponse' is not callable. Did you mean to include 'new'? ```
Are you running just `tsc --target ES5` ? It's expecting the files you want compiled.
Using typescript doesn’t remove the need for validating foreign data like web services, but if used correctly it should mean you don’t have to validate the data internal to your application. We agree on that, right? Getting accurate types is a challenge, I guess not everyone likes doing it. 
I am more than happy to accept any PRs. As with ts-essentials I keep on adding types that I found useful and community memebers.
Given that `fetch` returns a promise, you don't need to manually create a new one. So this: export const http = &lt;T&gt;(request: RequestInfo): Promise&lt;T&gt; =&gt; { return new Promise((resolve) =&gt; { fetch(request) .then(response =&gt; response.json()) .then(body =&gt; { resolve(body); }); }); }; Becomes this: export const http = &lt;T&gt;(request: RequestInfo): Promise&lt;T&gt; =&gt; { return fetch(request) .then(response =&gt; response.json()); }; Or even more short-form: export const http = &lt;T&gt;(req: RequestInfo): Promise&lt;T&gt; =&gt; fetch(req).then(res =&gt; res.json()); 
Yeah. Those are nice things. I whole-heartedly agree. But I still feel that the type system even internally is much too easy to break. And I think type validation should be builtin to the language. Without these things fixed I don't think it's a good candidate for a language. I just don't find it robust enough at the cost of the strengths of JavaScript.
\^\^
Ok. Progressed to the next error anyway, I suppose. [I updated the launch.json](https://github.com/wolfinabox/Entropy-API/blob/master/.vscode/launch.json) with those args again, and reinstalled typescript and ts-node locally. Now when trying to debug, in the debug console, I get `Error: Cannot find module 'bin\main.js'` before my code actually begins. Is it still trying to run the javascript for some reason? I'm not sure why it can't find it.
I'm confused by the commenters who said "data structures with a type" as distinct things from "classes". As well as you consideration that TypeScript isn't defined by its ability to do strict typing. Could you clarify? Isn't enums, interfaces, type definitions, classes (and its access modifiers) - all a kind of class type, aka classing? *PS: I'm not including ES2018 features - i feel that's JavaScript. So things like promises, closures, getter/setter, destructuring are not TypeScript IMO.*
Very nice, well-written article. My only feedback is to capitalize "TypeScript" correctly!
why does it matter typescript uses structural typing meaning if mapped types === interfaces === class definitions if the structure of the mapped type is the same. &amp;#x200B;
Great article! It very clearly explains some of the more set theoretic features of typescript, which I find many typescript developers ignore or are unaware of. Knowing the theoretical reasons for why a language is the way it is helps write safer and more readable code.
Thanks ClutchHunter, yes, this makes it nicer.
I'm sorry I don't know the answer, in fact I've never done what you're trying to do, I just knew what your last round of errors meant. I would suggest trying the TypeScript Gitter if you have no luck here.
Came in to read how \`never\` and \`unknown\` works. Came out also knowing more about type union and intersection. &lt;3 this kind of articles.
&gt; A good example of this would be declaring every local variable as type any. Hmm, well... I consider the use of `any` a red flag too, but since Javascript doesn't have static typing, I wouldn't call that a Javascript pattern. But yes, of course, if you forego static typing in TypeScript, that's a bad pattern (and closer to Javascript).
Thanks for your reply /u/fix_dis. I'll take a look at JWKS to see what could be done. Do you use Auth0 for that? If so, someone opened [an issue](https://github.com/FoalTS/foal/issues/320) here that might be related. Feel free to add a comment / suggestion if you feel like it.
Thanks you so much for this feedback /u/deniercounter. It is really valuable to me. &amp;#x200B; &gt;Opening the website I was to be honest a little disappointed by only seeing a blues site with 3 outbound links Copy that. &amp;#x200B; &gt;I especially liked your use of decorators for securing the post routes. Nice. &amp;#x200B; &gt;does not create the script file "create-todo.ts" in "src/scripts/" `create-todo.ts` is created in `src/scripts` only if the command is run at the project root directory. Looks like it's a problem. I'll see how to fix this. &amp;#x200B; &gt;$ foal generate entity todo &gt; &gt;CREATE src\\app\\entities\\todo.entity.ts &gt; &gt;UPDATE src\\app\\entities\\index.ts Why this command? &amp;#x200B; &gt;\* The copied source of "create-todo.ts" does not end with new line &gt; &gt;\* Context, HttpResponseNotFound, HttpResponseNoContent, HttpResponseCreated, Context, Delete, Post is not imported in "src\\app\\controllers\\api.controller.ts" &gt; &gt;\* needs 2 more imports from @foal-core -&gt; so add 2 more imports from core &gt; &gt;\* Decorator object props should be aphabetically Ok, I'll open a PR to fix all these things. &amp;#x200B; Thanks!
I think you, and some other downvoters, missed the crucial part of my message: "When writing a prototype". When you're building a game, you don't just start writing the perfect game right away. You'll be writing some thing and find out it'll have to change drastically at least 100 times. By focussing on architecture rather than features, you'll spent more time on creating pretty code rather than creating a fun game. Especially when writing an application that will change a lot, you'll be writing a lot of throwaway code. The only thing you'll have to care about is modularity - make sure you can throw away &amp; replace stuff. Make sure your components touch very little other components, otherwise it's hard to change. 
In that case, I'd go for the explicit: if (typeof somePotentiallyUndefinedString === 'string')
&gt; For some reason it just gave me a huge list of options for commands, including the target one so I have no clue why it didn't do anything. In the second line it clearly prints: &gt; Syntax: tsc [options] [file...] The "syntax" refers to the format of the command line arguments you can provide. You passed the single option `--target ES5`, but you did not provide a single file.
Fair enough!
For the record, I wouldn't recommend casting responses to types without first validating the data. TypeScript types are erased and there's no guarantee the data returned by the API you are calling actually matches your design-time types so the response is not actually "strongly typed". A better idea would be to always return `Promise&lt;unknown&gt;` from the fetch and then pass that to a type guard to ensure the data matches the type at runtime.
Great post! How does the `{}` type relate to these? Should it be avoided?
Actually, I just built a hook that takes care of it perfectly. Maybe it’s better for you not to cover every case. The system you’ve built seems to be a pretty good foundation. While I don’t use Auth0, I imagine the case would be the same. I’ll take a look at the GitHub issues. 
I can't see myself using this often, but it does look useful, especially for type checker internals.
I really like how advanced the type system is. This doesn’t seem like regular use stuff, but good for those really tricky typings
Once you're comfortable using TS there's not really any downside. I use it for small projects because I'm lazy and I don't want to look up APIs when I could autocomplete, nor do I want to waste time debugging runtime errors.
`{}` is equivalent to `object`, and is the set of all possible objects including arrays and functions. Like every other type it is a subtype / subset of `unknown`. `{}` is more specific than `unknown`: every value of type `{}` is truthy, supports property access, etc. But it is one of the most general types; I usually find it useful to use a more specific type, following the rule of using the most specific type that works and is convenient for your use case. When possible I recommend saving `{}` for code that really works on all objects. There are plenty of cases like that; for example the type for `Object.keys` in Typescript's standard library looks like this: keys(o: {}): string[]; `{}` or `object` works well in a type bound. For example a `WeakMap` can use any object type for its keys. In other words the key type for a `WeakMap` must be a subtype of `object`. The definition looks like this: interface WeakMap&lt;K extends object, V&gt; { delete(key: K): boolean; get(key: K): V | undefined; has(key: K): boolean; set(key: K, value: V): this; } 
Agreed but I just wished there was a tutorial covering those kind of types. I understand how most of them work but most of the the tutorials don't give real world examples and excercises so I can't really apply them to my own projects.
The best example is code for me, so I will often look through the more challenging libraries to type to see examples. I think to understand the utility of this you need to first understand conditional types. 
Thanks! I usually prefer not to use camel-case names in prose for stylistic reasons. But that does lead to inconsistency with official documentation, and with other articles. I will examine my life choices!
I do understand conditional typed but never had a real use for them. Your tip is good. Ill try to understand code from well written libraries
Thank you! Do you think it would be useful to have a post dedicated to the set theory description of types, instead of putting that information inside a how-to post like this one?
&gt; `{}` is equivalent to `object` Primitives are assignable to `{}`, but they are not assignable to `{}`. 
I thought it might be intentional because the grammar of the rest of the article is impeccable, and you even got the correct capitalization of JavaScript.
Update: Microsoft is addressing this issue by adding an `as const` syntax to create deeply immutable values https://github.com/Microsoft/TypeScript/pull/29510
&gt;but they are not assignable to `object`
I did? Whoops! I'd like to at least be consistent in my style choices...
thanks!
Thank you for catching that, and for educating me! I have edited my comment. Please let me know if you notice any other inaccuracies.
Just no. I like and use typescript but the only thing good thing about it is Intellisense and being able to use the future Javascript libraries/methods/EcmaScript (whatever) and being able to compile to a JavaScript every browser can read. 
What is the end result you want? 
I want to use cappWrap somewhere else. There is also going to be callWrap2, callWrap3 with other expected promises Promise&lt;C&gt; and Promise&lt;D&gt;, where C and D extend A as well.
[removed]
... and the type-checking right?
May I humbly suggest my tutorial on the `never` and `unknown` types? I tried to put in a balance of theory and practical examples. https://blog.logrocket.com/when-to-use-never-and-unknown-in-typescript-5e4d6c5799ad That post does not relate to this proposed negation operator. But it does discuss some of Typescript's special features, and a mental model for understanding them.
No problem, it was a minor nit. Great article though! A couple of things: &gt; If we had used unknown then the type of stock would be `{ price: number } | unknown` which does not simplify. This does simplify to `unknown` as `unknown` absorbs all elements. &gt; Type narrowing works with `any` the same way that it does with `unknown`. This is no longer strictly true; `unknown` narrows under `===` while `any` does not. &gt; `"foo"` (singleton set) Literal types aren`t restricted to being singleton sets, they could be infinitely big in the presence of name subtyping (TS does not have this).
You can't solve it, because it makes no sense. `call` returns an `A`, but the definition of `callWrap` says it will return a `B`. Not every `A` is a `B`. How would you expect this to work?
It helps, but Javascript already has a way to check if the data is what you expect. 
Good points, thanks!
Even if it did why would you want to write that code when the type-checker can do it for you?
Thanks ill check it out
Thanks! I'm glad it was helpful.
That seems to be my mistake... a function foo(A) would happily take also a B or C because they're always an A. But the other way round can't work... thats too bad. :/
This is not correct. TypeScript isn't better at functional programming, or object oriented programming, or structural programming than javascript, it is more or less the same. TypeScript is just JS witth typings. I would say that it is for beginner even worse option as correct typing in functional approach is much harder than in oop. TypeScript is the language trying to cover all possible dynamic js usecases while fp programming stands on very strict and quite simple rules, but typing those rules without right dedicated tool is just hard, some things that are very simple in haskel are super hard to do correctly in typescript (in terms of typing). But if you ask if for a large scale project which uses fp, oop or whatever is better to choose Ts over pure JS? Then yes it is, that's why TS was created in the first place, to enhance productivity and certanity while refactoring large codebases, that's main reason why typing system exist in other languages too.
&gt; The major benefit of static typing is that it gives you guarantees. If you use it in one module and choose to not use it in another, then you just waste your time and energy on describing and designing those types, without getting any guarantees whatsoever. This is precisely the issue sound gradual typing (read: typed racket) aims to solve.
&gt;&gt; Type narrowing works with any the same way that it does with unknown. &gt; This is no longer strictly true; unknown narrows under === while any does not. Oh, it looks like this behavior changed [yesterday](https://github.com/Microsoft/TypeScript/pull/26941)? Good to know! I made some small changes to the post. Thank you again for your help!
\&gt; The design patterns themselves are cross-language concepts, but can anyone tell me why on earth I’d need the State pattern in a dynamically typed language? What about Builder? These patterns have nothing to do with development, they are primarily about types. Types and OOP have a tight link. &amp;#x200B; What? Patterns are about organising your code, you want to do that with or without types. 
Thanks for sharing! I'm thinking that writing what actually equates to types tests is a bit redundant in strictly typed code itself, but it'll really come useful for me in fixtures/ tests :) Just yesterday I was tempted to use dtslint style $ExpectError in some stories and now I have idea how to nicely do it without setting the whole infrastructure. 
The differences are on the definition side of things rather than in the actual type checking. You can't do declaration merging with type aliases, so there's no way to extend or merge a mapped type (try defining a class with mapped properties).
No problem.
TS makes writing maintainable code easier, because precisely what was pointed in the article: it is far easier to read due to the types - provided, of course, the codebase is not riddled with "any" or "string | number | object | undefined" lazy types. Functional is initially hard to grasp. Having it typed is a great help, and this is why this helps.
Have you noticed any perf hits now that methods (closures) are created per instance of the datatype, rather than on the prototype? I prefer the objects + closures style more, but I'm always worried about memory overhead.
I haven't ran any benchmarks, if issues arise switching to a prototype implementation will be easy to do without breaking anything, so I'm not worried at the moment. 
I made some libraries related to writing test in typescript: [https://github.com/LeDDGroup/typescript-conditional-types](https://github.com/LeDDGroup/typescript-conditional-types) and [https://github.com/LeDDGroup/typescript-test-utils](https://github.com/LeDDGroup/typescript-test-utils), they kind of overlap
Not that it really matters, but `x !== undefined` or `x != null` is clear enough.
Types may well make things easier to understand, but that point is largely orthogonal to functional vs OOP. The claim that FP is harder to understand than OOP, and therefore more in need of types, seems somewhat unsubstantiated.
They may be technically, semantically, but what most people picture when you say "class" is the object-oriented model that Java uses, something a lot of JS devs don't want imposed upon them. When I say object-oriented I mean in the OOP paradigm sense (versus say functional).
What is your test code? Because it's definitely not what you have in `Test.ts`
Why would I use it instead of jest or mocha ?
Nope, calling databasewrapper in test.ts actually works. When accessing /api/cities the problem happens in WeatherController. I don't have unitary tests because I'm a disaster. I wanna do them asap tho. 
Looks really great, gonna try it tomorrow
I'm not sure I understand the point of the decorators. They're the same as the function names 
cause it has decorators!!!!
I just checked how they work and it looks like each function you add a Before\* or After\* decorator to gets pushed into an array and all the functions are called when the hook is initiated. &amp;#x200B; So you could do something like the following: @TestSuite() export class TestingSuite { @Test("Add User", [&lt;test cases&gt;]) addUser(username: string, password: string) { ... } @BeforeEach() clearCache() { ... } @BeforeEach() clearDatabase() { ... } }
At some point you're calling `something.dbw` but the problem is that at that point your variable `something` is undefined. When you try to get a property of an object, but that object is actually undefined, you get this error
Ahh that makes sense. Kinda cool
Am I the only one thinking this isn't a great library name? Looks nice though 
I understand that, but that something.dbw is instanciated in the constructor so it should be not undefined. That's my problem :(
reviewing your code, I see that youre passing one of the router methods as a call back. When you pass a normal method as a function call back, it loses context of `this`. To prevent that from happening, you can find the function either by using an arrow function to define it (instead of a regular class method, it would be an instance property of type function.) When you declare something with an arrow function, `this` inside that function cannot change. Another way would be to say in the constructor `this.method = this.method.bind(this)` `.bind` is a way to say that `this` inside the method will always be whatever I'm passing to bind right now. Once bound, `this` cannot be changed for the given function.
Does anyone know if a good blog post or tutorial on composite projects?
Use Parcel or Webpack to transpile and bundle everything up. 
Do you want to make it read only at compile time or run time? 
That was it. Thank you so so much! Gave you a gold award for the time spent reviewing :) 
I’m looking at webpack now. It looks pretty good. Do you know anything about TS-loader for webpack? 
+1 For example with a decorator on the post function checking the schematic.
Const contexts just got merged into master, so you can write. `const _foo = { bar: "...", baz: "...", } as const;`
Great, at least that will be available in a month or two.
Compile.
They can’t all be blockbuster releases!
Yes, that's what I used. Parcel may be simpler to configure.
Anyone know how `--build --watch` compares to babel in terms of speed?
Looks interesting. I'd be interested in a write-up of the components involved.
Does anyone know why Array#forEach and Array#map are so different here?