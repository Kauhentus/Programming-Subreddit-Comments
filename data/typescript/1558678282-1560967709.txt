&gt; Here are the built-in types in TypeScript: There are **many** more built-in types than the ones listed. They probably mean primitive types, but even then it's not complete. &gt; There is a data type in TypeScript called any. It should be mentioned that it is implicitly assignable to any other type, which is a huge issue. That's why the `unknown` type was introduced, which is not even mentioned. &gt; What they have in common is that they cannot be used to reference the type of a variable and can only be assigned as a value to a variable. Before `null` and `undefined` were introduces as **types**, now it says it can't be a type and is only used as a value. With `strictNullChecks` enabled they are available as types. &gt; They may not contain spaces or special characters, except the underscore (_) and the dollar ($) sign This is wrong, depending on what you see as special characters. `‡≤†_‡≤†` is a valid identifier for a variable name. An identifier must start with $, _, or any character in the Unicode categories ‚ÄúUppercase letter (Lu)‚Äù, ‚ÄúLowercase letter (Ll)‚Äù, ‚ÄúTitlecase letter (Lt)‚Äù, ‚ÄúModifier letter (Lm)‚Äù, ‚ÄúOther letter (Lo)‚Äù, or ‚ÄúLetter number (Nl)‚Äù. &gt; We use the keyword var in order to declare a variable. **NO** JavaScript code should use `var` for variables. You should use `let` or `const`. &gt; The syntax is pretty simple‚Äîjust put the target type in side the greater than/less than symbols &lt; &gt; and put it in front of the variable or expression. The `&lt;Type&gt;` syntax is discouraged. Instead the `as Type` syntax should be used. &gt; Variable Scope Missing the module scope.
I do not use TypeORM professionally, still I think it's rock solid and there's no reason not use it.
You really answerd his question precisely üëç
Related recent article [https://code.visualstudio.com/blogs/2019/05/23/strict-null](https://code.visualstudio.com/blogs/2019/05/23/strict-null)
According to the official TS handbook, as Type is only used for JSX.
The `as T` syntax can be used in ts and tsx files, the `&lt;T&gt;` syntax can only be used in ts files, but not in tsx files. That's why the `&lt;T&gt;` syntax fell out of favor, to just have a common approach.
Dear mods, /u/vexator , /u/Bartvds Endtest is spamming up tech subs, including yours, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus) (same person I imagine) with focused self promotion spam that clearly breaks [reddits self promotion rules](https://www.reddit.com/wiki/selfpromotion.) Banning the above users is a start, but given that if you ban this user he will just create another account I recommend the following options: Use Automoderator on your sub, and use the following rules: #This will automatically remove posts to endtest domain: - endtest.io action: remove action_reason: "Banned domain" --- #Cover comments too body (includes): ["endtest.io"] action: remove action_reason: "Banned Domain" --- # this will remove posts to endtests youtube account domain: - youtube.com - youtu.be media_author: ["Endtest"] action: remove action_reason: "Banned youtube account" Users like this also link to blogs like medium/dev.to that promote their site, more could be done to combat this. This is also not the only spam on tech subs. If you need help irradiating this please contact me, thank you.
Question - what's the difference between this and inversify?
Just ca 600 to 700 byte gzip, it resolves all dependency lazy, it does not need reflect-metadata (50kb). I had some problems with inversify to understand what it does exactly because sometimes i had some problems that lazy decorator doesn't work and on the other side the default inject decorater doesn't too. So i decided to make my own lib with less functionality and beeing more straight forward. Even circular dependencies are possible (if you donot access them inside of the constructor). If you mess around and build a circular dependency which will fail, then it will fail directly and not silently. I had sometimes the problem that inversify gives me an undefined instead of an error. &amp;#x200B; The most important thing was the bundle size because i need a very small app bundle for a project at the company i am working for. And at least i just wanted to do this since a while ago. ;)
&gt; Just ca 600 to 700 byte gzip, it resolves all dependency lazy, it does not need reflect-metadata (50kb). oh nice! &gt;I had some problems with inversify **to understand what it does exactly** Fucking preach. I actually gave up on it, and ended up using something else because I legit couldn't make sense of the docs. &gt;The most important thing was the bundle size because i need a very small app bundle for a project at the company i am working for. And at least i just wanted to do this since a while ago. ;) Cool. Can you share any details?
Its juts a technic to add widgets inside of iframes (for decoupeling of 3rd party components) into an webapp. But these widgets need everything a normal app has: A View Renderer (i choose Preact), State Management (not sure at the moment, because i want something wich works well with ioc and preact, but maybe i use ootb unistore), View Elements, i18n, dependency injection etc. To make them as small as possible i decided to reimplement a few libs like dependency injection. I am working on the i18n implementation too. It is just not ready to be pushed to github. I do this in my free time because it is more a thing i want to do than our customer wants, i think ;-)
Although you shouldn't have to use it often. We have some large apps where I work and I've never needed it.
This is a blind guessz but you should also look for @types/ module that usually comes along. These type of modules belong to devDependencies, so you should use npm install --save-dev @types/... in your case look for @types/client-oath2
 I've tried both your suggestions, no luck. Looking at the client-oauth2 directory there is a index.d.ts file,, I started to think it is to old and no longer represents a valid typings file.
Interesting... On their GitHub site, I have seen the import for JavaScript being `var ClientOAuth2 = require('client-oauth2')`, so I assume with TypeScript it should be `import {ClientOAuth2} from 'client-oath2'`. I will check it once I get home, because I am kind of surprised it doesn't work for you. I remember we had similar issues where I work, solution was trivial...
Depends how its exported... if import {x} from "y" doesnt work try import * as x from "y"
Ahhh seems to work.
One alternative to embedding a javascript spreadsheet in your web-based application is: [https://bossanova.uk/jexcel](https://bossanova.uk/jexcel) [https://github.com/paulhodel/jexcel](https://github.com/paulhodel/jexcel)
Awesome. I had the same problem when I first started with typescript and unfortunately all different packages that you pull in, all export in different ways. Glad I could help!
That's pretty much every automatically generated migration for every tech stack. Anything beyond manually edited migrations is just asking for data loss and headaches.
It is ok. I currently use it. However, because it is not that extremely active maintained, you sometimes experience bugs with no fix coming in the future. I encountered some. Today I wasted a half day with typeorm, because distinct queries are not 100 % working with no real fix for me. Gave up.
You might want to check out ts-optchain too. It allows you to easily traverse deeply nested objects safely even if they are possibly null.
I've been working on these declarations to allow L√ñVE 2D to be another game engine that can be used with TypeScript thanks to the TypeScriptToLua transpiler Declarations: [love-typescript-definitions](https://github.com/hazzard993/love-typescript-definitions) Transpiler: [TypeScriptToLua](https://github.com/TypeScriptToLua/TypeScriptToLua) Game Engine Home Page: [L√ñVE 2D](https://love2d.org/)
Been discussed here [https://www.reddit.com/r/typescript/comments/bfm6i2/my\_take\_on\_concise\_promise\_handling\_in\_typescript/eleqtw4/](https://www.reddit.com/r/typescript/comments/bfm6i2/my_take_on_concise_promise_handling_in_typescript/eleqtw4/)
Looks cool, I guess it's an alternative to io-ts when you don't need error reporting
No, though it's essentially JavaScript with static types so you'll be learning both simultaneously. Remember, the TypeScript compiler is essentially just a fancy, strict linter - runtime code does not change. It's all just JavaScript once you strip out the type annotations, so while you're learning you'll probably be faced with more JavaScript challenges than TypeScript ones.
Although not required, I would personally prefer to at least know a little bit of Javascript then learn Typescript. It would be beneficial to know where is the line drawn between Javascript and Typescript, and also it wouldn't take long to first learn JS then go to TS since TS is a (almost-proper) superset of JS.
Echoing what other people have mentioned, TS is compiled down to JS at the end of the day. Although it's not essential starting out, eventually you'll need to know it if you want to do it professionally. You can compare what the resulting JS is using https://www.typescriptlang.org/play/
It also depends on what languages you already know. I came from c# and found it super easy to pick up.
I went straight to TS without any experience in JS. As a Java dev it was a pretty easy learning curve: the async stuff was a bit of struggle conceptually (observables in particular,) but overall I went from novice to productive dev in about 500 hours of practice.
I like the type generation-how does it work? Also you should provide a way to see all the invalid errors. I did something similar w/ project moodysalem/jointz
Thanks. I didn't know io-ts. I will look into it.
The following my Japanese post describes how it works a little. [https://qiita.com/nwtgck/items/1cc44b6d445ae1d48957](https://qiita.com/nwtgck/items/1cc44b6d445ae1d48957) Unfortunately, it is written in Japanese. Google Translation can be useful.
Typescript is Javascript just with typisation. You have to realice that even if you use strict typings, javascript dosn't care about. I would recommend Typescript as an entry, if you are familar with other typed languages. And ofc it makes many things easier because you see many mistakes before you compile and you can better analyse what a variables data should be. Since i am using typescript i can write code for hours without the need to run it.
Hey, haukeb, just a quick heads-up: **familar** is actually spelled **familiar**. You can remember it by **ends with -iar**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
delte
delete
Agreed. It's crucial to know what parts are just JS and what parts are TS (and eventually what parts are React/Angular/etc). You'll be glad you can make that distinction 3 years later when all these frameworks come and go but JS stays.
It was a bit hard to follow with the translation but it looks like typescript magic. Anyway this solves a problem I always had with typescript validation libraries-having to define the type twice. I‚Äôd love to see if this could be adapted the typescript special type to work with Joi. It would be amazing if you could use this magic type generation with a widely used validation library.
No. My first programming job straight out of Uni was working on an Angular Typescript front end. I had zero javascript experience prior. I just watched some tutorials and started coding - the best way to learn. Picked it up within the first few weeks. Don't compare yourself to what others are doing, at the end of the day it's just another language - the only way you learn it is by doing it regardless of prior experience. You see JS/Node JS guys moving to Typescript because it is a small jump for them, but there is nothing stopping you from learning Typescript outright like I did.
JavaScript is a strange language when coming from other compiled OO based languages. If you go straight to TS you will certainly get tripped up and not understand why. `this` is a subject unto itself. The way prototyping work, should be fundamental to understand too. Finally there is the fact classes are essential syntactical sugar, even in JS. Starting with TS you‚Äôll come from design using OO technique, but JS is way more flexible. I come from many OO languages, both New and old. JavaScript can be super frustrating without types, but knowing the fundamentals will serve you. There is an excellent series called ‚ÄúYou Don‚Äôt Know JS‚Äù. I would start there and move to TS ASAP üòâ
Congratulations, you just invented the Either and Maybe types.
If you don't know JavaScript, I would say it makes Typescript more dangerous than helpful. I look at TS as a means to improve documentation and maintainability, but even with strict enabled, it cannot protect you from inconsistencies from outside your own code at runtime. So you won't be as prepared to think ahead about what could go wrong at runtime. Also there's some features and patterns, like 'this', that TS may not comprehensively address. That said, you're going to end up learning both. It's just going to be harder cause without knowing the foundation, you'll only learn these nuances from observing unexpected behaviors.
Not everyone is familiar with `Either` and `Maybe` and this article tries to explain the idea in simple terms, without mentioning monads (which tend to scare people off).
This is awesome. I kind of had the same thought when they introduced the new const assertions in 3.4. If you are looking for contributors let me know, it would be great to add non-type based validations like range or string format, and some way of logging errors.
**FUCK OFF WITH YOUR STOLEN CONTENT!**
Others have said this as well, but if you are coming to Typescript from one of the statically typed OO languages, you will actually need to unlearn some stuff to use JS and TS correctly. Definitely pick up the "You Don't Know JS" books (free online or pay for the paper versions).
I feel like you make some points here about things that 'can' happen. But your tone essentially turns the response into gatekeeping. having taught green developers from zero both javascript in one case and typescript in another I would say that typescript is a great place to start because types tend to steer new developers towards writing more explicit code. Javascript's inherint flexability tends to lead new devs to shoot them selves in the foot more often than not.
agreed, if anything learning typescript will naturally teach you alot of js
Your lib is nice because it's tiny, has no dependencies and isn't really opinionated how it works. With io-ts you have to buy into the use of Either types and it's a bit hefty. Getting a reason for the validation failure (path to the property/properites that failed) would be great. Eg the path: `['abc', 'def']` would mean that `myobj.abc.def` failed. It would also be nice if you could create a validated object from the original. So if I send `{x: 0, extra: 'abc'}` to a validator that expects `{x: number}`, I would get back `{x: 0}` (stripping away extra properties.)
Ok that's fair. I agree it probably is a good way to get into both "languages".. in my case we have a large Node.js ecosystem at work. We have Scala devs who ran into issues and frustration thinking that VS code could tell them the whole story.
Thanks. &gt; stripping away extra properties Good idea. I think it's possible. Currently, the validation is very simple, and types in runtime and validation system are completely separate. This means that you can use the runtime type and create a function using the runtime type. The following code is an eample to show how to use `JsonRuntimeType`. https://github.com/nwtgck/ts-json-validator/blob/39fcb67d66dc832693948336f4bdf1bb2907c9c6/src/index.ts#L144-L178
To everyone saying "no": Can you even know TypeScript without knowing JavaScript, considering the former is basically a superset of the latter?
&gt; stripping away extra properties I made a shallow strip as follows. You can define this function in your code, not in ts-json-validator, outside of the library. ```typescript const obj1Format = obj({ x: num, }); type Obj1 = TsType&lt;typeof obj1Format&gt;; // You can define this function in your code, not in ts-json-validator, outside of the library function shallowStrip(format: Json, anyObj: any): TsType&lt;typeof format&gt; | undefined { const runtimeType: JsonRuntimeType = format.runtimeType; switch (runtimeType) { case 'null': case 'boolean': case 'number': case 'string': return undefined; default: switch (runtimeType.base) { case 'object': if (anyObj === null || typeof anyObj !== 'object') { return undefined; } const stripped: Partial&lt;TsType&lt;typeof format&gt;&gt; = {}; // Enumerate only field in run time time for (const key of Object.keys(runtimeType.keyValues)) { stripped[key] = anyObj[key]; } return stripped; default: return undefined; } } throw new Error(`Unexpected error in isValid(): ${runtimeType}, ${anyObj}`); } const myObj1: Obj1 | undefined = shallowStrip(obj1Format, {x: 0, extra: 'abc'}); console.log(myObj1); // =&gt; {x: 0} ```
In essence I agree with your response but the ‚Äú... makes TypeScript more dangerous than helpful.‚Äù piece may give the wrong impression. You can learn both TS and JS at the same time and it will actually be easier IMO because it‚Äôll protect you from some of the runtime dangers. When they occur the new dev will learn the gaps in the ‚ÄúJS‚Äù part. Whether you learn JS first or JS at the same time as TS you‚Äôre still going to learn the foundation. A new TS dev should also follow a couple of JS tutorials because TS is just and extended JS... just like ES6+ built on top of the old JS foundation.
I don't think anyone can give you a good answer on this without knowing more about your background and how you approach software. It's worth learning. It could enhance your understanding of JavaScript, or you could get confused about what is TypeScript and what is JavaScript and attribute things to TypeScript that are actually properties of JavaScript, or vice versa. There's no one path.
``` interface IRegistry { [type: string]: IConfig&lt;any&gt;; } ``` Why not indexing by `symbol` itself? So then you don't do `type.toString()` in `get / _add` methods. ``` type IRegistry = Record&lt;symbol, IConfig&lt;any&gt;&gt; ```
I think you want to build a UMD module. This works with `require` (other commonjs modules can import your exports) and as a standalone script with specific globals exported to the window object.
&gt; Well, TypeScript is nagging at me within this sort function saying that each parameter implicitly **has an 'any' type**. Yes, since you haven't specified the type of the parameters used in your code snippet. This should work: // Home.vue // ... .then((json: Thread[]) =&gt; { this.threads = json.sort((thread1, thread2) =&gt; { // TS can infer thread1 and thread2 are typeof Thread isBefore(thread1.dateCreated, thread2.dateCreated); // ('isBefore' is a method of 'date-fns' library) }); }) // ...
Ok, so classes can also be used as types. Thanks for the help.
Why not use an enum?
Why not do this? Fruits(filter) { return filter.fruits.includes(fruit); }
`type Fruit = 'Apple' | 'Pear'interface FruitFilter {fruits: Fruit[];}const f: FruitFilter = { fruits: ['Ap', 'Apple'] }` &gt;I noticed that if you enter an invalid string, it marks all of the strings in the array as invalid with the error It doesn't.
Because enums suck in TypeScript.
&gt;Is there a better way of doing this so that only the offending string is marked as invalid, or is this as close as I'm going to get? I'm not sure I follow. The compiler is just telling you that you are attempting to put a string where a union of value types is expected, the code won't compile beyond that with some appropriate values you'd be putting there, because it'll stop at error. The compiler is naming the mismatching types for you. So you are dealing with type `string` and type `'Apple' | 'Pear'` If you mean you'd like to see the exact string itself in the error message, it'd have to also be a value type, instead of a string. It doesn't take much for 'A' to be widened to string type, but you can try it like this type Foo = 'A' | 'B' const foo: Foo[] = 'C' // Type '"C"' is not assignable to type 'Foo[]'
&gt; because enums suck in TypeScript I mean - your next sentence makes total sense, but this felt unnecessary. And if he could use an enum here, this feels like a completely appropriate use case.
Interesting. If I type a field just as you are, I get the same error, but if I create the object inline it is different. `Fruits({ fruits: [ 'Ap', 'Apple' ]})` Highlights both 'Ap' and 'Apple' and says "Type 'string' is not assignable to type 'Fruit'" on both strings.
I cannot modify the code.
enum StringEnum { "Apple" = "Apple", "Orange" = "Orange" } This compiles to: { "Apple": "Apple", "Orange": "Orange" } enum Enum { "Apple", "Orange" } This compiles to: { 0: "Apple", 1: "Orange", "Apple": 0, "Orange": 1 } Yeah they're great. And typing something doesn't require an enum at all and types are much more flexible. I would NEVER use enum here.
That makes sense. I suppose the compiler is widening the type to try and compile it then showing the error based on that, rather than on what caused it to try and widen the type to begin with. More than the error message itself, the part I was hoping to improve is that it marks every string in the array as incorrect, when really only one of them is.
I think this is because `[ 'Apple', 'Apple', 'Pear' ]` can be considered of type `Fruit[]`. `[ 'Ap', 'Apple' ]` can only be considered to be of type `string[]`. So the whole array is the wrong type, not just the `'Ap'` element. All elements of an array must be the same type. So if every element is of type `Fruit`, then the array is of type `Fruit[]`. If even one is not a `Fruit`, then the whole thing becomes an array of `string`s.
&gt;I cannot modify the code. ...whut?
Yup - this is a limitation of Typescript's inference. If you declare the variable on its own line you'll need a type hint for it to realise that's it's not just any strings in the array, but only the ones you've specified in your Union. i.e. `let f: Fruit[] = [ 'Ap', 'Apple']`
Please explain why they suck? I rarely need to use them in the front end but dont think they suck.
This is, indeed, a more correct way of error handling. With that said, if you apply to your code-base rather than, say, typical exception throwing, it's not clear that the end result is easier to reason about or work with.
I mean enums kind of suck in general. About TypeScript: [https://www.reddit.com/r/typescript/comments/9r1gzi/ts\_enums\_and\_how\_they\_feel\_odd\_to\_me\_in\_a\_js/](https://www.reddit.com/r/typescript/comments/9r1gzi/ts_enums_and_how_they_feel_odd_to_me_in_a_js/) If only you could assign them a function without namespacing them. Or assign objects and not just strings/numbers. They are not extensible, hard to work with and more or less useless. More often then not I just use string literals or TS type unions when I can.
Love2d was fun
First day with TypeScript? That's okay, we all started somewhere.
`['Ap', 'Apple'] as const`
You have no tsconfig and don't make use of the strict compiler flag.
Why no strict mode? I really don't get it.
I think I must use it. In next version this will be fixed. &amp;#x200B; When I started I didn't like "noImplicitAny", but now I realized my mistake.
Even if you don't like the noImplicitAny (which is still an excellent flag that I would always keep enabled): You can disable individual flags again. But `strictNullChecks` is an absolute must for me.
I'm on mobile, but I don't think that interface makes sense. You can't have a single function with different signatures, unless you added overloading. Maybe they're supposed to be named methods?
It's valid. There is even an example similar to this interface in the typescript language documentation under functions in interfaces.
In TS interfaces are not necessarily meant to be implemented by classes, the interface can be used to just define a shape/structure. In your case, Searchable expresses the shape of the overloaded function/method but not the class. So you could do something like this: ``` interface SearchableAware { searchable: Searchable; } class ProductSearch implements SearchableAware { searchable(...) { ... } } ```
I think this defines Searchable as a method (so not a class) that you can run with 3 different (overloaded) signatures
Is this the example you're referring to? [https://www.typescriptlang.org/docs/handbook/interfaces.html#function-types](https://www.typescriptlang.org/docs/handbook/interfaces.html#function-types)
This is just a copy of the release notes with some words changed. For example, both literally contain: &gt;Similarly, you could write a utility type like Writable mapped type that strips away readonly-ness, and that would convert readonly array containers back to their mutable equivalents.
If it's supposed to be a function overload then you can get started with this: function searchable(id: number): object; function searchable(desc: string): number[]; function searchable(low: number, high: number): number[]; function searchable(...args): object | number[] { // implement here }
You will implement this with a plain function
Ah, okay so this works then. Thank you! interface SearchableAware { search: Searchable; } class ProductSearch implements SearchableAware { search(id: number): object; search(description: string): Array&lt;number&gt;; search(priceLow: number, priceHigh: number): Array&lt;number&gt;; search(...args: Array&lt;any&gt;): any { if (args.length == 1) if (args[0] instanceof String) { return [0]; // replace with search items by description } else if (args[0] instanceof Number) { return { }; // replace with find item by id } return [0]; // replace with search items by price } }
Yes!
The article focuses on making **Go to definition** in an IDE and the publishing process work without surprises. Feedback is welcome!
Sorry if this is a dumb question, but do you have to publish the packages to npm to leverage tools like lerna or yarn workspaces? Also how would the module resolution work with docker containers?
You don't have to publish the packages in order to build locally. lerna/yarn symlinks your modules the same way you would do manually with npm link. Module resolution won't be different in a docker container as long as your folder structure remains the same as on the host.
Thank you very much :)
AFAIK if you just do private: true in your package.json, lerna won't publish to npm.
https://github.com/topics/typescript
Thanks. The projects appearing there are unfortunately mostly either libraries (usually not using webpack) or desktop apps (using electron), so I was hoping someone here would know something more specific.
There are gotchas to this. The directory context that Docker pulls in when it builds an image does expose any parent directories from the host system. So symlinks to packages outside of the context will not resolve. I ran into this gotcha because I was using Lerna to manage several JavaScript microservices under the same repo. Each subproject had its own Dockerfile and were orchestrated with docker-compose.
i tried it in the beginning. `interface IRegistry { [type: symbol]: IConfig&lt;any&gt; }` But typescript complains "An index signature parameter type must be 'string' or 'number'". Here is a open issue about that: [https://github.com/microsoft/TypeScript/issues/1863](https://github.com/microsoft/TypeScript/issues/1863) when i try your snippet it gives me "Element implicitly has an 'any' type because type 'Record&lt;symbol, IConfig&lt;any&gt;&gt;' has no index signature." when i try to access `this._registry[type]` &amp;#x200B; Thank you for your comment and reviewing my code :) You can make a pull request if you can implement this. I would be very happy if my lib can use symbols as index like it was intended at the beginning of the work.
What about watch? How to watch all packages at once without need to manually recompile?
What's your use case for watching? I think the solution with project references described in the post would allow you to run 1 watcher per package as each watcher would build its dependencies.
That's a good point. I'm guessing you could expand the context of the Dockerfiles to the entire monorepo, bootstrap inside, build/watch and then start just the desired service.
Or you could have another tsconfig for watching that would include all packages and still set up the path aliases, though I think this would build to a single `outDir`.
We are using lerna and typescript at work, but I have one major annoyance with it that I haven't figured out how to fix. The types from each package's dependencies get hoisted by default (which is fine), and then when other packages that aren't dependent on them build they are somehow reading these. The issue from this comes when a package we use, say `graphql` has a type definition that uses `asynciterable`. The package directly using it has that enabled with `esnext.asynciterable` in the tsconfig, but the other 16 packages don't, because they have no dependency on it. Even though that is the case, the 16 other builds throw errors about not understanding the asynciterable type. I spent a few days on an off on this and just gave up and took our packages with this issue and set them to `nohoist` with lerna.
We have a watch command in each package at my work, and the lerna cli has the ability to parallel run the same command in all repos. `lerna run --parallel watch`.
Ideally you don't need 16 separate typescript project configurations, but one at the root. It would have settings that match every project, and this wouldn't be an issue. Same thing as setting it 16 times, but without the copy and paste
Highly recommend using yarn instead of npm with a monorepo. It‚Äôs much better. Lerna delegates the heavy lifting to yarn and yarn is faster and less buggy. Also yarn workspaces and module hoisting works very well. This is especially pertinent if you‚Äôre coding in react. Lerna+npm means you can easily add 2+ copies of react to your bundle. With yarn workspaces it‚Äôs basically a non-issue.
`tsc` will by default read all `*.d.ts` files and `@types/*` packages in a project. You can disable this by setting `types: []` (or just the ones you really need) in `tsconfig`. I also recommend setting `skipLibCheck: true` to improve speed and avoid errors in `@types` packages. &amp;#x200B; I suspect that this could also be solved by limiting the scope of compilation via `tsconfig`. If each package has one and it sets sensible `include/exclude/files` directives, and each package installs only the `@types` packages it needs, then I would expect no surprises, but I don't have a repo where I could reproduce this.
Just want to point out that, while yarn may be faster, using it will have the same problem described in the blog post and will require the same solutions.
This turned out to be a useful read, since I didn't know that last bit about computed properties.
https://github.com/vuetifyjs/vuetify is a library but already uses fork-ts-checker-webpack-plugin
This article is perfect example how articles should look like. Every information is given clear and simple, no useless code shown, simple examples. 10/10
Thank you for very kind words.
You are welcome. I am glad that you learned a thing :)
Great article, thanks. It seems to be that interfaces, when you can use then given their restrictions, are preferable simply because they have a name and provide better compilation messages. Is there any downside to using interfaces, besides their restrictions?
While yes, typescript has good support of classes and whatnot, you really should just follow reacts paradigm. Typescript is still perfectly fine being used functionally. If you would prefer a more OO approach, you could try angular (and it is typescript native), but I say that purely as a suggestion, react is a very good framework too.
Good Explanation. You could commit a pull request, to update the mentioned section of the Handbook. &amp;#x200B; Pro-Tip: TSLint can validate and fix, if you should use a type or an interface: [https://palantir.github.io/tslint/rules/interface-over-type-literal/](https://palantir.github.io/tslint/rules/interface-over-type-literal/)
I wouldn't' use TSLint for TS projects anymore. https://pawelgrzybek.com/linting-typescript/
Cool article, I think there are some errors in your code examples, mainly the bottom/final one in the \`toDTO\` and \`toDomain\` methods
Who says that you have to pick one or the other? Use whatever pattern best solves the problem in front of you and stop worrying about being functional or object oriented. They aren't mutually exclusive.
Personally I think it makes sense to continue using it until ESLint has feature parity with TSLint.
And **another** project that does not make use of the `strict` compiler flag... I really don't understand it. Why use TypeScript for type-safety, but then not make use of the awesome type-safety features that TypeScript offers?
This feature is called "Mapped Types". A bit advanced but very powerful feature that allows you to express a lot of JavaScript pattern in type-safe way in TypeScript. You can read about it here if you want: [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html) [https://github.com/Microsoft/TypeScript/pull/12114](https://github.com/Microsoft/TypeScript/pull/12114) It gets some time to fell comfortable with it. At beginning you will most likely use it from some external library's type definition and wonder "how TypeScript can model it in its type system". If you'll understand how these feature works and relates to each other: literal types, union of literal types, index type queries (`keyof T`), Indexed access types (`T[K]`) and of course mapped types then you can do magic ;) Add some [conditional types](https://github.com/Microsoft/TypeScript/pull/21316) and it will blow you mind how TS type system is powerful.
Maybe your comment will be useful for someone else, but what I meant was learning that there was a difference between types and interfaces with regard to computed properties.
You are quite right. I'm totally agree with you. It will be fixed.
You mention in your article that despite type aliases being more powerful, you still find yourself using interfaces more often. Any particular reason? Great read. Easy to follow.
A legacy project could continue using TSLint, but a greenfield project should use `typescript-eslint` as well as `@babel/preset-typescript`.
Feels more natural for me and because I work a lot with open source and client facing API it comes with some additional benefits (extending).
There are features in TSLint that are missing from ESLint. Until ESLint is caught up and TSLint is officially deprecated (it's not yet) I think it's perfectly acceptable to use TSLint on new projects.
I'm talking in context of live reload for example. So if I have a watcher on Project A that has Project B as a dependency using project references, will changing src of Project B trigger rebuild of Project A?
Sounds interesting, I didn't notice this feature of lerna before, thanks.
Another important difference is when a type is resolved by the compiler. Resolution of an `interface` and its members is deferred, while resolution of a `type` is eager. This is very important when it comes to recursive types. For example (taken from [here](https://github.com/Microsoft/TypeScript/issues/3496#issuecomment-128553540)): type JSONValue = string | number | boolean | JSONObject | JSONArray; interface JSONObject { [x: string]: JSONValue; } interface JSONArray extends Array&lt;JSONValue&gt; { }
Thanks for the reply, and where would you draw the line between OOP and Functional paradigms? Would you pass class instances into to react view components for instance?
Using ESLint now is just planning ahead, since both TS and TSLint teams have announced that their focus is on ESLint now, and it's in a usable state already.
Fair enough. I think it's still valid to use TSLint for new projects if there's a missing feature in ESLint currently, but if ESLint covers all the rules you wan't to use, it should definitely be used.
We've been working on turning our disparate github projects into a single monorepo, but it's still far from perfect. We use to have one project for each lambda (11 total I think), 1 main node project, and 2 ui ones (legacy angular 1, and a react one). We started with just moving them all into lerna and fixing things as they broke, but this seems like it would be a great idea. I'll see what it would take to make this change and have all packages work with it's config. Right now they are all wildly different.
Thanks for the help, I'll be trying this later today and see how it goes!
Does extending buy you anything that intersecting (&amp;) doesn't? To be clear: i've come around to feeling that types are more natural, but I'm not sure if that's just familiarity.
This is a really good point. I may consider to update my post in the future. Thanks a lot for very valuable input.
Why not both?
Nice, I'll definitely take a look! Thanks!
According to the docs (https://www.typescriptlang.org/docs/handbook/project-references.html) it should, but I haven't tried it myself.
Has anyone played around with --incremental yet?
Hello Omit
How do you find the TS native Pick and Exclude compare to a helper like lodash?
These are type-level things, rather than actual value-level functions (there is no runtime behavior). If lodash has these for some reason, it wouldn‚Äôt effectively be any different.
ah, ok. I'll hope TS team will make mapped types also working on interfaces. Seems like artificial constraint to me (not much love for [this](https://github.com/microsoft/TypeScript/issues/13573) issue for now :()
i messed around a bit. Maybe Map will work with symbols. But i am not sure if there are downsides of this implementation. \^\^ [https://github.com/owja/ioc/pull/19](https://github.com/owja/ioc/pull/19)
I just want to know when the behavior of path aliases is going to be addressed so that the transpiled ECMAScript contains resolvable paths instead of keeping the aliased path that requires further transpilation or interpretation systems. The existing libraries and tools I have found like ts-paths, tsconfig-paths, rollup, and webpack are all more hassle to involve than the path alias feature alleviates, for my purposes at least.
Wether TSLint or ESLint-Typescript doesn't matter. The point is, as you described: always use interfaces when possible, a type otherwise. A linter can check and automagicly enforce it :)
https://github.com/microsoft/TypeScript/blob/c5c869f673044d7e0daa27e194103409251d89dd/src/lib/es5.d.ts#L1404
Couldn‚Äôt agree more. Such a pain that the compiler has all the information necessary to resolve those paths and could emit them with relative imports, but instead leaves them with aliases. I ended up forking tscpaths so it could be used programmatically via gulp... ugh.
It actually doesn't have all the information, since the compiler might find a `.d.ts` but not a `.js`. The `.d.ts` can be placed in a way that would effectively be resolved the same even if the `.js` file was located in a different place. e.g. think about an import of `"./foo/bar"` which TS can find at `./foo/bar/index.d.ts` even though the `.js` file might be at `./foo/bar.js`
Curious about how you guys set default props for function components. Default parameters? That could be verbose if there are many default props.
I tried to do this and [almost succeed](https://github.com/heoleoy/hyperoop/tree/useStrict), but not for TS tests. There is a problem with JSX that I don't know how to solve.
I updated my post to include an information about this. Cannot than you enough for pointing this one out! &amp;#x200B; [https://pawelgrzybek.com/typescript-interface-vs-type/#deferred-type-resolution-of-interfaces-vs-eager-type-aliases](https://pawelgrzybek.com/typescript-interface-vs-type/#deferred-type-resolution-of-interfaces-vs-eager-type-aliases)
Thanks a lot again! I updated my post and not it contains a reference to "Mapped types" documentation part. Have a lovely day ! &amp;#x200B; [https://pawelgrzybek.com/typescript-interface-vs-type/#type-aliases-can-use-computed-properties](https://pawelgrzybek.com/typescript-interface-vs-type/#type-aliases-can-use-computed-properties)
Typescript is great for functional stuff and works great with React. Here's how you'd type props: export const MyComponent = ({name}: {name: string}) =&gt; &lt;&gt; {/* your JSX */} &lt;/&gt; Then just use it fully typed as `&lt;MyComponent name="asdf" /&gt;`. You can, of course, extract the type and have optional or advanced props. type MyType = "TYPE1" | "TYPE2" type Props = { name: string type?: MyType } export const MyComponent = ({name, type}: Props) =&gt; /* your component */ If your IDE is smart, it will communicate with TypeScript and tell you that the `type` sent to `&lt;MyComponent type="" /&gt;` needs to be either `TYPE1` or `TYPE2`. In my code I'm using functional components with Hooks. Of course, Hooks are also typed (and most of the time the types are inferred automatically). e.g. if you have: const [checked, setChecked] = useState(false); TypeScript will infer that `checked` is a `boolean` and `setChecked` is a function that accepts a boolean (or a function of the form `boolean =&gt; boolean`).
I wouldn't wrap my component in a hoc just to get this though. First you are getting runtime costs of having another component in between. Your tree will get more nested. You will sometimes get worse types for the component that gets out. One example is when using connect (redux), you can't get the component props type with the built in helper React.ComponentProps or something like that (on my phone). Just no.
Lanugages
&gt; CREATING Cooking your project ! Please wait ... &gt; &gt; ERROR File Not Found, Internal Error.Please Report an issue Works well.
&gt;aboutcareerspressadvertisebloghelpthe reddit appreddit coinsreddit premiumreddit gifts content policy| privacy policy Thanks for your reply. Will look into the matter. Its still in the development stage. Please Report an issue in the Github repo.
Can you please share the your answers for those questions. ? Thanks
Entered project name, picked the template with TypeScript, rest default. On a Windows system, using the GitBash and NVM.
ok. looking into it
It didn't work for me on a particular large project until 3.5.1 (failed with "Maximum call stack size exceeded"; also didn't work in 3.5-rc), and now it works but takes twice as long: 45s with `--incremental` vs 19s without. I've not been able to look into it more.
I noticed that exact scenario just played out in the latest release of Swift: https://github.com/apple/swift-evolution/blob/master/proposals/0235-add-result.md https://forums.swift.org/t/se-0235-add-result-to-the-standard-library/17752
To begin with, thanks a lot for your detailed feedback! &gt; First you are getting runtime costs of having another component in between. Your tree will get more nested. Actually, the component is wrapped in a [function call](https://github.com/Zzzen/with-default-props/blob/78467d81b329ec02b143415ea5d8eb0fe22d19bd/src/index.ts#L27), which will not introduce extra `React.createElement` calls. Anyway, I will try to benchmark thier performance. &gt;You will sometimes get worse types for the component that gets out. One example is when using connect (redux), you can't get the component props type with the built in helper React.ComponentProps or something like that (on my phone). I am not a redux user so I might not fully understand this problem. I've tried following code on [stackblitz](https://stackblitz.com/edit/componentprops-wdp). `React.ComponentProps` works. Could you give a more specific example? ```jsx import React, { Component } from 'react'; import { withDefaultProps } from 'with-default-props' interface AppProps { req: string; opt: string; } function App(props: AppProps) { return &lt;div/&gt;; } const WrappedApp = withDefaultProps(App, { opt: 'Im default' }) type WrappedAppProps = React.ComponentProps&lt;typeof WrappedApp&gt; const props: WrappedAppProps = { req: '1' } ``` May I ask you something. What's you preferred way to set defaultProps?
What I actually wanted to check is what kind of TypeScript project is generated, and looking at the source my fear is confirmed: https://github.com/buildtip/create-web-app/blob/master/generators/app/templates/TMEN/tsconfig.json The `strict` flag is not set to `true`. Why? Please spend more time learning TypeScript and stop promoting less type-safety. :-\ You should instead use the `tsconfig.json` file that is generated by the TypeScript compiler as a template `tsc --init`.
waiting for ts-loader support the tsbuildinfo
\`interface Props { greeting?: string } const App: React.FC&lt;Props&gt; = ({greeting}) =&gt; { return ( &lt;div className="App"&gt; &lt;h1&gt;{greeting}&lt;/h1&gt; &lt;h2&gt;As you could see, React already has a solution for default props.&lt;/h2&gt; &lt;/div&gt; ); } App.defaultProps = { greeting: 'Hello stranger!' }\`
Not sure it fits your requirements but this is ~20k LOCs typescript app (react-native), it uses babel and tslint: https://github.com/teamdigitale/io-app/
Do you turn on `strict/strictNullChecks` in `tsconfig.json`? If so, you should see that `greeting` in `App` is `string | undefined`, which is bad since we have provided a default value.
I can't keep up with all this fancy shit
I tried it on my large project when 3.4 was released. The improvement was not significant enough to be even noticeable. So I gave up at that time. Will try again sometime next week.
gonna take a look, thanks a lot!
Any information on how it actually works?
*deletes all tests* - "finished"
I did this test using codesandbox which I guess is not strict by default. In my own code I avoid using optional params, but when I do I just merge props on my default props if it's a bunch of them, otherwise just check inside the component.
Endtest spam.
Dear mods, OP (Endtest) is spamming up tech subs, including yours, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus) (same person I imagine) with focused self promotion spam like this that clearly breaks [reddits self promotion rules](https://www.reddit.com/wiki/selfpromotion) Banning the above users is a start, but given that if you ban this user he will just create another account I recommend the following options: Use Automoderator on your sub, and use the following rules: #This will automatically remove posts to endtest domain: - endtest.io action: spam action_reason: "Banned domain" --- #Cover comments too body (includes): ["endtest.io"] action: spam action_reason: "Banned Domain" --- # this will remove posts to endtests youtube account domain: - youtube.com - youtu.be media_author: ["Endtest"] action: spam action_reason: "Banned youtube account" Users like this also link to blogs like medium/dev.to that promote their site, more could be done to combat this. This is also not the only spam on tech subs. If you need help eradicating this please contact me, thank you.
What part is the machine learning part?
please say simple less
Lol, they posted a link to a "comparison" article which only links to endtest and not it's competitors, and is negative about all the competitors as well... Their marketing guy isn't really good at hiding their strategy
It's terrible from every angle. They are negative in reddit comments too when they receive criticism
Nice, is there an npm package and if so can you add it to the readme?
I think you want something like this: let number1: number = parseInt($('#number1').val()); if (number1 &amp; 4) {}
This is a nice reference for what can be done with the type system, I will have to study this for a bit.
Can you explain the " &amp; 4 " part?
`&amp;` is the [bitwise AND operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#(Bitwise_AND). This will return a number with only the bits set that match in both numbers. If the second number only has a single bit set (e.g. `4`, which only has the 3rd bit), it will only return a truthy value (`4`) if the first number also has that bit set. So `2 &amp; 4 === 0` (falsey) because no bits match, but `5 &amp; 4 === 4` (truthy) because they match at the 3rd bit.
As I understand the suggestion, `&amp;` is the `bitwise and` operator, checking what bits are set and the same. From Mozilla mdn: ``` console.log(5 &amp; 13); // 0101 &amp; 1101 = 0101 // expected output: 5; ``` 4 in bits would be represented as 0100 So if number &amp; 4 returns 4 then the third bit would be set. You can [check more out here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)
Thank you, this helped so much! Btw "truthy" and "falsey" kind of sound cute, i haven't seen it like this before, but I am also new with coding :D
Thank you
[Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) [Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)
So kind of you to show me this :) Now I learned something new again
Thank you. Yes. I've added readme to the repo. [https://github.com/joonhocho/tsdef/blob/master/README.md](https://github.com/joonhocho/tsdef/blob/master/README.md)
https://basarat.gitbooks.io/typescript/
Thanks! It took me time and debugging to come up with the list. TypeScript can be tricky and frustrating sometimes. For example, check out IsAny or IsUnknown. For such simple functions, you need to know how to get around things.
I think this thread on StackOverflow might help you out: [https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type](https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type)
It is casting productId to a number.
Best thing to do is go to the Typescript project on GitHub and read the feature discussion issues. There is simply no better resource.
That's quite complex. One of my main goals writing code is readability. Complexity is a big contributor to making code unreadable. I'm totally sold about the advantages of using typescript in big enterprise apps, where the code is mainly composed of high level abstractions without high complexity. Libraries though, where we have to manipulate low level constructs, the complexity of the type system seems to just get in the way. Not sure what to think about all of this yet, though.
```ts const adds = [ { name: "one", fn: (n:number) =&gt; n &gt; 10}, { name: "two", fn: (n:number) =&gt; n &lt; 10} ] as const; declare function ourFn&lt; F, S extends ReadonlyArray&lt;{ name: string, fn: (...args: any) =&gt; any }&gt; &gt;(x: F, y: S): { [P in S[number]['name']]: S[number]['fn'] } &amp; F; ``` If you can make `adds` as const...
I tried to cover most of the typings and as I said it is still under development. I have covered most of it may be. Sure I will consider the \`tsc --init\` thanks. Also, Can You try this package again? I have fixed that error you mentioned
I didnt get this ..
 [https://scotch.io/tutorials/javascript-unary-operators-simple-and-useful#toc-unary-plus-](https://scotch.io/tutorials/javascript-unary-operators-simple-and-useful#toc-unary-plus-)
A FrontendMasters course by Mike North is very helpful. &amp;#x200B; [https://frontendmasters.com/courses/typescript-v2/](https://frontendmasters.com/courses/typescript-v2/)
Is there a good reason why `type` can't have circular references, or is it just an arbitrary design decision?
Then i‚Äôd suggest using any where needed and focusing on keeping the public api typed. Though if typing your code gets too complex it might be valuable to re-evaluate it‚Äôs flow and interfaces. For example, in your example: Is it strictly necessary to have both a ‚Äúname‚Äù and ‚Äúfn‚Äù property for the add object ? If not then it‚Äôs really just making union types more difficult to use. And if you then merged the name and fn property (the name is the key, fn is the value). Then you could drop the array of add objects and instead the consumer of the function could use the object spread operator if they had several add objects. Then the return type of your function would simply be a union of base and add object. To me it seems like your adding unnecessary complexity to the function signature which in turn makes typing it more difficult. Though I don‚Äôt know anything about the actual use case or where it‚Äôs supposed to get its input from.
When I first started working with TS this would have intimidated the fuck out of me, however once you know the type system a little better this really isn't complex. Most types I've written have been used countless times without ever thinking about them again, I think that's the hardest part to grasp for beginners. The type inference for all subsequent uses will handle the rest! Don't fret about one complex type.
That's close, but not quite. The max and min function are the disjunction of all function signatures inside the adds array. &amp;#x200B; const t: { max: ((n: number) =&gt; boolean) | ((n: string) =&gt; boolean); min: ((n: number) =&gt; boolean) | ((n: string) =&gt; boolean); } &amp; { someNumber: number; } &amp;#x200B; I didn't know about the const assertion. That's great. Thank you for letting me know.
Good tips. Thank you for your input. I really appreciate it. &amp;#x200B; About the use case; If I'm coding an object that doesn't need many instantiations, I find it more intuitive to work with functions then classes. &amp;#x200B; I was trying to push the "open for extension, closed for modification" principle (SOLID) by using a function to extend my modules, instead of class subtyping. That why if I want to add a new function to module, I just add it to an array, instead of directly modifying an already constructed class. &amp;#x200B; It's very easy to wrap my head around the code without types, but with types is another story.
One thing that is missing that I could be included is a [recursive version of Partial](https://stackoverflow.com/questions/41980195/recursive-partialt-in-typescript-2-1). I actually use that one quite a bit.
OP (Endtest) is spamming up tech subs, including yours, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus) (same person I imagine) with focused self promotion spam like this that clearly breaks [reddits self promotion rules](https://www.reddit.com/wiki/selfpromotion) Banning the above users is a start, but given that if you ban this user he will just create another account I recommend the following options: Use Automoderator on your sub, and use the following rules: #This will automatically remove posts to endtest domain: - endtest.io action: spam action_reason: "Banned domain" --- #Cover comments too body (includes): ["endtest.io"] action: spam action_reason: "Banned Domain" --- # this will remove posts to endtests youtube account domain: - youtube.com - youtu.be media_author: ["Endtest"] action: spam action_reason: "Banned youtube account" Users like this also link to blogs like medium/dev.to that promote their site, more could be done to combat this. This is also not the only spam on tech subs. If you need help eradicating this please contact me, thank you.
Well, the types would definitely be easier if your lib used classes that consumers could extend. But yeah. If you do a single ‚Äúextension‚Äù parameter instead of an array a union type would solve your problem.
Followup on this (May Release): FoalTS can now dynamically retrieve a secret to authenticate users with JWTs. It also provides a new function to facilitate the recovery of public RSA keys from a JWKS endpoint. &amp;#x200B; More information here: [https://foalts.gitbook.io/docs/topic-guides/authentication-and-access-control/jwt#retreive-a-dynamic-secret-or-public-key](https://foalts.gitbook.io/docs/topic-guides/authentication-and-access-control/jwt#retreive-a-dynamic-secret-or-public-key)
Tslint is being deprecated.
Honestly, I think eslint isn't quite there yet for typescript. I've tried eslint on a few projects, and I've had a lot of trouble finding plugins that work correctly. For what it's worth, here's the modules I'm using in a project, and the eslint config I used. package.json { "devDependencies": { "@typescript-eslint/eslint-plugin": "^1.9.0", "@typescript-eslint/parser": "^1.9.0", "eslint": "^5.16.0", "eslint-config-prettier": "^4.3.0", "eslint-plugin-import": "^2.17.3", "eslint-plugin-react": "^7.13.0", "eslint-plugin-simple-import-sort": "^3.1.1" } } .eslintrc.js module.exports = { parser: '@typescript-eslint/parser', extends: [ 'plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier/@typescript-eslint', ], plugins: ['import', 'simple-import-sort'], parserOptions: { ecmaVersion: 2018, sourceType: 'module', ecmaFeatures: { jsx: true }, }, rules: { 'no-restricted-imports': [ 'error', { paths: ['styled-components', 'lodash'] }, ], 'react/no-unescaped-entities': 'warn', 'react/prop-types': false, '@typescript-eslint/no-empty-interface': false, '@typescript-eslint/explicit-function-return-type': false, '@typescript-eslint/explicit-member-accessibility': false, '@typescript-eslint/no-explicit-any': false, '@typescript-eslint/no-use-before-define': [ 'error', { functions: false, classes: true }, ], 'import/first': 'error', 'import/newline-after-import': 'warn', 'import/no-deprecated': 'warn', 'import/no-nodejs-modules': 'warn', 'import/no-useless-path-segments': 'warn', 'simple-import-sort/sort': 'warn', }, settings: { react: { version: 'detect' }, }, };
Yeah I know that. Was just wondering if I should transition now or wait.
Wow that's a lot of packages. I'll wait for now.
Yeah, especially compared to tslint { "devDependencies": { "tslint": "^5.12.1", "tslint-config-airbnb": "^5.11.1", "tslint-config-prettier": "^1.17.0", "tslint-react-a11y": "^1.0.0", } }
We have quite a few projects built in TS and using tslint. We don‚Äôt really have a need to move to eslint yet, especially since we also adopted prettier. We will wait until the support is more stable.
Would it be possible to set tsc to only allow one option so that it *did* have all of that information? I'd rather have nice paths than be able to do inconsistent things with my project file structure, honestly.
Thanks! that seems very useful. I will add it to the list.
\`\`\`ts if ('color' in this.GraphicsAssets) { ... } \`\`\` Inside the \`if \` block, \`this.GraphicsAssets\` will be narrowed down to the first type
Don't bother, not worth the effort yet.
That's... Smart but also yikes.
I've found it a bit buggy (in Webpack) so far, where non-TS ESLint and TSLint haven't been. I'd wait.
just remove elements from the dom if they arent visible, performance will be always 60fps
Those aren't built in TypeScript classes. They are built in web browser classes. You can use your own Node and Element classes but you will have to carefully manage the importing and namespace management yourself. If possible though, don't do that. Save yourself the confusion.
You can namespace. This is a common problem across languages. Those symbols have to be unique. I'm on my phone so I'm not typing code but you can do a Google search.
What is stopping you from using a different name? Why would you choose to give up on an entire language over having to choose a different class name?
Typescript should represent what things are, but that shouldn't come at the expense of making ambiguous what was designed to clearly be clear (those existing Javascript reserved words). You can Namespace as others have said, but in the majority of cases the best practice would just be to be more specific. WHat kind of Node is it? 'TreeNode'? 'LinkNode'? Shouldn't be too hard and certainly not significant enough to drop Typescript over.
Another project without the strict flag. So sad.
Yep I know, I will add it soon
tslint
eslint [https://github.com/typescript-eslint/typescript-eslint](https://github.com/typescript-eslint/typescript-eslint) works great for me, but setting it up to work with 3rd party rules has been painful. I say go for it (unless you need certain rules that are not yet converted)!
I was initially grumpy about this too (given that the effective reserved keyword space is much larger than other programming environments I've used), but avoiding `Option` and `ProgressEvent` has turned out to not be a big deal. Either don't pull in the front-end libs, if the codebase is backend-only, or use synonyms.
So, first shallow read, (an obvious statement) react-spring loops over your entire list calling an update on every single item on every frame, which is plain bad. Now I didnt look much further on the code but it seems that whatever you do to your "bind" function wont fix the issue because it wont prevent that loop from happening. &amp;#x200B; I guess you already did it so, but if not, have a look on the "performance" tab on chrome, which allows you to dive on the CPU usage of every JS line. &amp;#x200B; Not the most polite type of plug, but if you dont feel like reimplementing a drag and drop from scratch, try having a look at "react-beautiful-dnd". Since it is a library made to cover a specific case of interaction (instead of a generic one), it probably already has that sort of issues optimized for you.
I‚Äôve started migrating myself and am so far liking the experience. Basarat recently added a section on eslint to his TypeScript book https://basarat.gitbooks.io/typescript/content/docs/tools/eslint.html if you need a simple getting started guide. If you‚Äôre a Create React App user, eslint is now enabled by for new TypeScript projects. I like this config because it‚Äôs fairly un-opinionated and focuses instead on just trying to find bugs and accessibility issues. You can use it outside of Create React App by following its guide here https://github.com/facebook/create-react-app/blob/master/packages/eslint-config-react-app/README.md
This looks like a worse designed rxjs. Why would I want to use this instead?
couldnt you just class Example { service = wire(this, TYPE.MyService) // type is automagically inferred! }
Not sure. I first tought it is not possible, but i tried something and it works 50% ;) I tried to assign the property to a temporary class and return its property like this: ``` export function createWire(container: Container) { return function&lt;T&gt;(type: symbol, ...args: symbol[]): T { const temp: {t: T} = {t: undefined as any}; define(temp, "t", container, type, args); return temp.t as T; }; } ``` and adding the dependency like this ``` class Example { service = wire&lt;IMyService&gt;(TYPE.MyService); } ``` but in this case the uncached tag is not working as expected and the test fails. I will take a look at this tomorrow. :)
but i think it does not work because \`service = wire\[...\] \` does assign to the property value itself. I am not sure, but maybe i can't exchange the property this "dirty" way. \^\^
Just for info. The define function is this: ``` function define(target: object, property: string, container: Container, type: symbol, args: symbol[]) { Object.defineProperty(target, property, { get: function() { const value = container.get&lt;any&gt;(type); if (args.indexOf(NOCACHE) === -1) { Object.defineProperty(this, property, { value, enumerable: true, }); } return value; }, configurable: true, enumerable: true, }); } ```
Another minimal example of this error, with the error message: function makeSecondary&lt;C extends React.ComponentType&gt;(Component: C) { const WrappedComponent: React.FC&lt; JSX.LibraryManagedAttributes&lt;C, React.ComponentProps&lt;C&gt;&gt; &gt; = (props) =&gt; { return &lt;Component {...props} /&gt;; }; return WrappedComponent; } Type 'PropsWithChildren&lt;LibraryManagedAttributes&lt;C, ComponentProps&lt;C&gt;&gt;&gt;' is not assignable to type 'IntrinsicAttributes &amp; LibraryManagedAttributes&lt;C, { children?: ReactNode; }&gt;'. Type 'PropsWithChildren&lt;LibraryManagedAttributes&lt;C, ComponentProps&lt;C&gt;&gt;&gt;' is not assignable to type 'LibraryManagedAttributes&lt;C, { children?: ReactNode; }&gt;'
Not interested in react-beautiful-dnd it only solves dnd problems and comes in at like 200KB, react-spring solves animation problems and comes in at like 10KB. First load means nothing to me, i just need the performance of drag to improved to run at 55-60 fps at 250 items, i'm aware of chrome dev tools performance and i benchmarked it at 36ms per event when it needs to be 16ms per event for 60fps.
new to most of the libs there, but at a glance `onGesture` and `setSprings` seem to be the culprit. `setSprings` is the guy who runs a transform in the whole list, and should not be called on a `pointerMove` event (unless theres some parameter to filter who in the list will get transformed). Also notice it is a side-effect setter since it is a hook, even it if it returns something to be used elsewhere. Only the affected items should be updated instead of the whole list (the card being moved and the 2 cards below it), maybe by using `setSpring` instead of `setSprings` and a bit of measuring you can achieve it. Just by calling `onGesture` you seem attach a global event handler to `pointermove` (independently if you just pass `mouseDown` to a component). react-with-gesture docs says it has ways to distinguish which event is being triggered, tough not much clear, maybe you dont need it tough.
You can also infer the props: ``` const withExtraStuff = &lt;P extends React.ComponentType&lt;P&gt;(Wrapped: React.ComponentType&lt;P&gt;) =&gt; { /* has access to props as P */ } ```
Do you have the `incremental` flag enabled?
A node that can be a element node and it can contain also various other nodes. To be honest, TypeScript should have used a ts_Node prefix for all their stuff. It's very unlikely that someone will use ts_Node in their project.
I don't like to confuse myself. What name should I use then? The node class consists of various nodes so it's kinda hard to come up with something different than node.
Yes, I have all my modules `composite` enabled, which infers `incremental`.
You can try setting `types` to an empty array so that it only loads explicitly referended `node_modules` types.
Thanks for the suggestion. Unfortunately, tried adding `types: ['node']` doesn't really help...
Either add an \`export {}\` statement to your file or otherwise put the class in a nested scope. Or turn off the DOM typings; that's where \`Node\` comes from. It's a browser thing.
Huh, I didn't realize that it could infer generics like that. I'm wondering if a hoc would even be something I want to do any more, I'm still hitting a bit of a wall with it. I might actually just write a script to auto generate the alternate component than try go go generic with this. Or maybe there's a library creator that's figured this out somehow
what BithTree said is correct. Also, if you run into issues typing props.children I‚Äôve had success with : { children: React.ReactNode | Element } ...or just { children: React.ReactNode } And as a render prop- { children: (props: thePropType) =&gt; React.ReactNode}
I personally have a hard time getting typings to work well with hocs. I've seen some advanced generics just to get them to play well. Hooks and render props have been easier to type, on the other hand.
It's about half prop typing and half return type of the inner wrapping function. This is about as close as I've been able to get, but I have to convert to unknown first which I'd rather avoid: import * as React from 'react'; import { withStyles, createStyles, WithStyles } from '@material-ui/styles'; import { List, Theme } from '@material-ui/core'; const styles = (theme: Theme) =&gt; createStyles({ root: { backgroundColor: theme.palette.secondary.main, }, }); function makeSecondary&lt;P, C extends React.ComponentType&lt;P&gt;&gt;(Component: C) { function WrappedComponent({ children, classes, ...props }: React.PropsWithChildren&lt;P&gt; &amp; WithStyles&lt;typeof styles&gt;) { type WrappedProps = JSX.LibraryManagedAttributes&lt;C, P&gt;; return ( &lt;Component classes={{ root: classes.root }} {...(props as unknown) as WrappedProps} /&gt; ); } return (withStyles(styles)( (WrappedComponent as unknown) as React.FC, ) as unknown) as C; }
Unless there's a linter for it, `this.props` is valid JavaScript in a function Component. If you are using TypeScript, it might let you know earlier rather than later.
I've been writing HOCs in typescript for a few months now. It was definitely cumbersome at the beginning (a lot of cast-to-unknown then cast to the type I want the HOC to be: ``` export default (withStuff as unknown) as React.ComponentType&lt;HOCProps&gt; ``` Here's an example that I wrote, `withContext`. You supply the context you wish to use, the component you want to wrap and a function for mapping the context to props to supply to the wrapped component. If you are familiar with redux, it's the exact same pattern (`mapStateToProps` is very similar to my `mapContextToProps`). ``` import * as React from 'react' type MapContextToProps&lt; CtxType extends {} = any, CtxProps extends {} = any, OwnProps extends {} = any &gt; = (args: CtxType, props: OwnProps) =&gt; CtxProps const withContext = &lt; CtxType extends {} = any, CtxProps extends {} = any, OwnProps extends {} = any &gt;( Context: React.Context&lt;CtxType&gt;, mapContextToProps: MapContextToProps&lt;CtxType, CtxProps, OwnProps&gt; ) =&gt; ( WrappedComponent: React.ComponentType&lt;CtxProps &amp; OwnProps&gt; ): React.ComponentType&lt;OwnProps&gt; =&gt; { const WithContextHOC: React.FC&lt;OwnProps&gt; = hocProps =&gt; ( &lt;Context.Consumer&gt; {(ctx: CtxType) =&gt; { const ctxProps = mapContextToProps(ctx, hocProps) const propsToPass = { ...hocProps, ...ctxProps } return &lt;WrappedComponent {...propsToPass} /&gt; }} &lt;/Context.Consumer&gt; ) return WithContextHOC } export default withContext ``` Writing HOCs in typescript is an exercise in writing good generics. Be liberal with generics and declaring types along the way. Being explicit with: 1. The type returned by your HOC function (what type of component is returned by withXYZ?) 2. The type of intermediate components, and their props. Keep those separate from the WrappedComponent's type and the "Final" component's type. You'll need to do this if you're applying other HOC functions in your own HOC. 3. Some libraries just don't play nice with HOCs. If you open up the definitions of some libraries you may be using, you'll see there's just no simple way use them in your own custom HOC without casting them to something else in between. I'll post another example below that highlights this (`composeRouter`) Here's another example that shows all of the above. This HOC's purpose is to be an intermediate step between `react-router`'s `withRouter` that organises your props into something more explicit. For example, if your route contains `/enterprise/...` then you can use this HOC to inject the boolean prop "isEnterprise" instead of having to do that inside of your component wrapped by withRouter. ``` import _ from 'lodash' import * as React from 'react' import { RouteComponentProps, withRouter } from 'react-router' export type MapRouterToProps&lt; RouterProps extends {} = any, OwnProps extends {} = any &gt; = (args: RouteComponentProps, props: OwnProps) =&gt; RouterProps const INTERMEDIATE_PROPS = ['history', 'location', 'match', 'staticContext'] const composeRouter = &lt;RouterProps extends {} = any, OwnProps extends {} = any&gt;( mapRouterToProps: MapRouterToProps&lt;RouterProps, OwnProps&gt; ) =&gt; ( WrappedComponent: React.ComponentType&lt;RouterProps &amp; OwnProps&gt; ): React.ComponentType&lt;OwnProps&gt; =&gt; { type IntermediateProps = OwnProps &amp; RouteComponentProps const ComposeRouterHOC: React.FC&lt;IntermediateProps&gt; = hocProps =&gt; { const { history, location, match, staticContext } = hocProps const ownProps = _.pickBy( hocProps, (v, k) =&gt; !INTERMEDIATE_PROPS.includes(k) ) as OwnProps const routerProps = mapRouterToProps( { history, location, match, staticContext }, ownProps ) return &lt;WrappedComponent {...ownProps} {...routerProps} /&gt; } // withRouter doesn't inject generic props hence the awkward casting return (withRouter(ComposeRouterHOC) as unknown) as React.ComponentType&lt; OwnProps &gt; } export default composeRouter ```
Wow, thanks for the write-up! That definitely helped me, especially the part about casting to unknown. I know that it's me helping the compiler out at a certain point, but still I wish that these things were a bit easier to compose. That's the cost of generics everywhere I guess. This was my final HOC that compiles and runs (although the autocomplete for VSC doesn't seem to like it too much): import * as React from 'react'; import { withStyles, createStyles, WithStyles } from '@material-ui/styles'; import { List, Theme, Drawer, StyledComponentProps } from '@material-ui/core'; const styles = (theme: Theme) =&gt; createStyles({ root: { backgroundColor: theme.palette.secondary.main, }, }); function makeSecondary&lt;C extends React.ComponentType&gt;(Component: C) { type P = React.ComponentProps&lt;C&gt;; type IntrinsicProps = JSX.IntrinsicAttributes &amp; JSX.LibraryManagedAttributes&lt;C, { children?: React.ReactNode }&gt;; type WrapperProps = P &amp; WithStyles&lt;typeof styles&gt;; type WrappedProps = P &amp; IntrinsicProps &amp; {}; const WrappedComponent: React.FC&lt;WrapperProps&gt; = ({ children, classes, ...props }) =&gt; { return ( &lt;Component classes={{ root: classes.root }} {...(props as unknown) as WrappedProps} &gt; {children} &lt;/Component&gt; ); }; return withStyles(styles)( (WrappedComponent as unknown) as React.ComponentType&lt;StyledComponentProps&gt;, ) as C; } I know that I don't necessarily have to explicitly render the children but I wanted to make it clearer what I was doing.
Noimplicitamy will catch that, or annotate this: void
I got it to work, definitely not as fun as other things I've been able to do with ts. Still, this is (hopefully) a write once type of function
Um.. this is /r/typescript so yes, I'm using typescript
Thanks to your answer I also found noImplicitThis which is more specific than noImplicitAny
It‚Äôs just a dynamic object right? It allows you to put any key (that‚Äôs a string) and any type assigned to that key. Item.name = ‚ÄòJohn doe‚Äô is allowed Item[0] is not allowed
Ohh that makes heaps of sense, I'm running with someones code and just trying to work out what they are doing. Thanks so much :)
So because you don't want to be more specific, hundreds of thousands of programmers around the world should ts_Blah this and ts_What that? No way, you be more specific.
Published with strict flag, thanks for the feedback!
Thanks for the feedback, what do you think should be improved? I think it is differente from rxjs, since effepi is not an implementation of the observable pattern.
My node can become anything, it can be a div, img, input, form anything. Same as TypeScripts NODE can prob be anything as my node.
What are the cons in that? How do I mess up this?
Great, so you're using Node exactly as intended, and it has nothing to do with Typescript. Here's the definition directly from lib.dom.d.ts: &gt; /** Node is an interface from which a number of DOM API object types inherit. It allows those types to be treated similarly; for example, inheriting the same set of methods, or being tested in the same way. */ &gt; interface Node extends EventTarget {
&gt; I still don‚Äôt feel like I‚Äôm fully leveraging TS You feel the right way, replace all the `require`-like imports with ES imports and you will realize why.
WebStorm is in general, unfortunately, becomes an unusable piece of shit if it comes to work with huge/complex TS code base. It just freezes as hell and the suggestions menu, the one you get after putting dot, just freezes the whole IDE so often, literally a nightmare. VS Code works just fine on the same code base. Still like using it though but not for the huge/complex TS projects.
Well if you're running your code in a web browser, your code would still break even if you weren't using Typescript.
ah, ok, there is still quite some work to do here. thank you!
Can you please explain more on this?
I have recently read this book its totally awesome https://www.amazon.com/Programming-TypeScript-Making-JavaScript-Applications/dp/1492037656
What is the work? Also learning ts here, would be a valuable tip
See this code [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/ed98af237f2f47f34175622c147dfa7ef987065a/types/node/globals.d.ts#L190-L193](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/ed98af237f2f47f34175622c147dfa7ef987065a/types/node/globals.d.ts#L190-L193). So if you use "require" imports you widen the module to "any" type which makes TypeScript use pointless.
So when I change the requires to import syntax, typescript now requires typedefs from the libraries I‚Äôm importing. So installing those and if they don‚Äôt exist writing then. Then I‚Äôll have to update my use of them to comply with those types if I‚Äôm out of spec. For example with inquirer, the questions that I pass are typed, and they now throw errors, so I have to dig in and figure out why that is. I may not need to be using yargs as well and that will simplify the application. So much to do!
You can usually find types for js npm modules. For example, boxen has types so you can `npm i -D @types/boxen` and now you'll get types for `import boxen from 'boxen'`
Thanks! I‚Äôm finding most of that pretty straightforward, actually the compiler says that right in the error, which is really nice. The types for inquirer don‚Äôt seem to like the questions object I pass so I‚Äôll have to get that worked out. And shit the boxen types don‚Äôt like me passing objects for margin or padding which are valid based on their docs. Is it normal for typedefs to be incomplete or am I maybe doing something wrong?
No, sometimes typedefs are wrong or out of date. It depends on how many TS users of that library there are I guess. I have been pretty lucky most of the time but yeah sometimes you need a lib with bad types. I usually clone my own repo of types and make fixes that work for my app. Then later if I have time and feel it's worth it I'll clean it up and submit a PR to DefinitelyTyped.
Thanks you so much!
You might've forgotten the code, unless I'm mistaken.
Here's the code. A bit jank since I need to forcibly cast to unknown, but since I'm casting back to a functional component that takes the same props at the end, I believe that it should be sound. import * as React from 'react'; import { withStyles, createStyles, WithStyles } from '@material-ui/styles'; import { List, Theme, Drawer, StyledComponentProps } from '@material-ui/core'; const styles = (theme: Theme) =&gt; createStyles({ root: { backgroundColor: theme.palette.secondary.main, }, }); function makeSecondary&lt;C extends React.ComponentType&gt;(Component: C) { type P = React.ComponentProps&lt;C&gt;; type IntrinsicProps = JSX.IntrinsicAttributes &amp; JSX.LibraryManagedAttributes&lt;C, { children?: React.ReactNode }&gt;; type WrapperProps = P &amp; WithStyles&lt;typeof styles&gt;; type WrappedProps = P &amp; IntrinsicProps &amp; {}; const WrappedComponent: React.FC&lt;WrapperProps&gt; = ({ children, classes, ...props }) =&gt; { return ( &lt;Component classes={{ root: classes.root }} {...(props as unknown) as WrappedProps} &gt; {children} &lt;/Component&gt; ); }; return withStyles(styles)( (WrappedComponent as unknown) as React.ComponentType&lt;StyledComponentProps&gt;, ) as C; }
Please avoid writing stuff like: "This series focus on how to correctly use TypeScript in React application." There's no `correct way` to type stuff. There are practices that evolve with time and it's a big trigger for people reading your content. Anyway: `shadow: theme.shadows[1]` would've never passed a code review in my company. What's 1 supposed to be? It's a hardcoded value that may or may not exist at runtime so it's not type safe. E.g. you could've used a const enum maybe?
&gt; It's a hardcoded value that may or may not exist at runtime so it's not type safe. While this is generally true for context values it's a bit misinformed with regard to material-ui. `theme.shadows` is typed as a tuple. It's coupled to elevation in Material design. There is nothing semantic about elevation. It can be made meaningful by following the Material design guidelines i.e. some components are at 2 others at 4 etc. So yes without domain knowledge this looks off but not in the context of material-ui. Agree with the rest: there is no way to type React correctly (yet).
Where is it typed as a tuple? https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/material-ui/index.d.ts
DefinitelyTyped is not necessarily the official typings, but rather community created types, no? If I am not mistaken about that, then that could explain why it isn't typed as a tuple there.
DefinitelyTyped is not necessarily official typings, correct? This is community driven, so that could explain the discrepancy. More info on the structure of theme.shadows can be found here if anyone is interested: [https://material-ui.com/customization/default-theme/](https://material-ui.com/customization/default-theme/)
Those types are for an older version of material-ui, I believe. Type for `Theme.shadows` of `@material-ui/core` is defined in [here](https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/styles/createMuiTheme.d.ts#L38) and [here](https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/styles/shadows.d.ts).
Avoid using `String`, use `string` instead.
Those are some god awful types tho.
Neat! I did not know about that `strictFunctionTypes` would enforce variance, or that Typescript would allow subtypes in a contravariant position without that option.
Maintainer of those types here. Anything in particular that makes those awful?
&gt; Maintainer of those types here. I guess this is as good a time as any to say thank you for your work! Work on open source can be a thankless job sometimes, but we really appreciate it!
I notices a problem using String, I read it‚Äôs an object and not the primitive I‚Äôm actually looking for
Webstorm amd VSCode should have everything you mentioned.
No, this will not work. I can't assign a variable without accessing it. This way i will lose the laziness of the injection. Only \`wire(this, "service", TYPE.MyService);\` will work. But maybe there is a way, but i don't found it ;)
Intellij has both java and typescript support, though its pretty much what you get with webstorm which you say you didn't like. In general, as long as you stay away from using 'Any' and use the *.d.ts from any javascript libraries you need it autocompletes well.
&gt; The function should return a correctly typed object with all the properties of the base object combined with all the functions from the Array (second parameter) named with the "name" property. If `adds` is some dynamic object (e.g. provided by user of library, coming from JSON file, etc.) then this is of course not possible; you don't know what values you are going to get, how can TypeScript help you? If `adds` is not dynamic (i.e. you have some control over it) then just hard-code the type as you've done here. If some of these keys won't always be in the object then make them optional.
The one limitation with typescript is that it is only statically typed, which makes it very easy to break the type system (ie have the type system misrepresent the actual types of values) when deserializing data. To mitigate this, I write all my api contracts in json schema and validate responses against the schemas, then generate ts interfaces from the schemas.
I know some of those words!
Thank you, that's exactly the kind of thing I was looking for! I thought TypeScript had type inference?
It does but that's a static type system feature and unhelpful if you broke your static type system.
It cannot infer the type of a runtime piece of data, like a Json deserialized object from an API request. Typescript types only help at compile time.
Hey all, I'm new to Typescript _and_ writing, and since I love Typescript I decided to write one about strict mode. I'm open for ideas and feedback. Let me know! Thank you.
[Here](https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance) is another great explanation I read about.
Don't think you can given the output and flexibility of the library. If material-ui wasn't theme-able I could see an argument for a string literal, but then I look at what the actual value is and would disagree. And thank you! I love material-ui and thoroughly enjoy typescript as a first class feature!
Hi Sean, nice work and I am interested in deploying this. Couple of questions here: 1. How do I define multiple GET parameters in the @Get decorator? 2. How do I add express middleware like helmet, compression, and a JSON body parser?
What is templating? VSCode has code snippets, which might be similar? Typescript refactoring might not be fully feature complete yet, but most of the JS refactoring has been possible in VSCode/Visual Studio/Webstorm. I'd say performance could be better, but compared to a Java IDE it's probably greased lightning :)
VSCode is pretty popular. I use IntelliJ IDEA Ultimate.
Middleware is passed as an array to the @Middleware decorator. Not sure what you mean by multiple get parameters. Do you mean having multiple routes call the same method?
In both lamguages you have to run a piece of inbound json through a validator to make it typed.
I just tried java support for vs code this week (it uses eclipse on the back). Had my vscode using 1,5GB with just a single java file open. So like, language services are the things that make IDEs heavy. But Vscodes interfaces are quite well designed, you will rarely get UI unresponsiveness due to a language service locking out. Contrary to intellij or eclipse which may freeze the whole window
TS language service is very complete, they take ‚Äúintellisense‚Äù very seriously, just like they do to the vanilla VS languages. It has the potential to bring very similar editing experienced. Of course it is a different experience in the enf. Its javascript after all and you rely on a community thing: one has to write a type definition to an existing js lib, lots of things are not born typescript.
I want to implement something like this: router.post("/upgrade", (request, response, next) =&gt; { const { token, itemId } = request.body; } this /upgrade path takes 2 parameters, token and itemId. How would I implement this in overnightjs?
Oh sorry I misunderstood you the first time. There is no change in how you do url-parameters. What you want to do would look like this: `import { Controller, Middleware, Get } from 'overnightjs/core';` `import { Request, Response } from 'express';` &amp;#x200B; `@Controller('upgrade')` `class UpgradeController {` &amp;#x200B; `@Get(':token/:itemId') // Or @Post doesn't matter` `@Middleware([helmet, compression, etc]) // There is also a @ClassMiddleware decorator, which will apply the middleware to every route` `private upgradeTokenAndItemId(req: Request, res: Response) {` `const { token, itemId } = request.params;` `}` `}` Please star the repo if you find OvernightJS helpful.
Here's an example of a class which actually does just what you asked. [https://github.com/seanpmaxwell/express-generator-typescript/blob/master/express-generator-typescript/lib/project-files/src/controllers/user/UserController.ts](https://github.com/seanpmaxwell/express-generator-typescript/blob/master/express-generator-typescript/lib/project-files/src/controllers/user/UserController.ts)
IIRC there are libraries that can generate JSON schemas from TS types (at compile-time ofc).
This is so elegant. Thanks Sean.
In my experience, even after recently starting a new project, VSCode is slow for imports and doesn't handle renaming well. Plus add in the fact there are always weird bugs from release to release, for example, long invalid imports like ../../../../../../blah/blah when they should be ../blah/blah and it easy to see how much this free tool actually costs. Webstorm, when I trialed it, was far superior in terms of speed and reliability although the Live mode didn't seems to work for me. Eclipse, so far as I can remember, has many more refactoring then VS Code and IntellIj, Webstorm's big brother, has even more. I don't miss Java but the tooling was much better than what I am using now.
Yes but schemas are more powerful than TS types so I prefer to covert my schemas TS types instead of the other way around. For example, adding regex string validation.
Ignore the moron -- thanks a lot for your work. I've been using TS with MUI and it has allowed me to rapidly develop sweet prototypes which my work has been very impressed with, and if there were no types I wouldn't be using it.
Weird, I have none of those issues. Renaming files and variables/types is going surprisingly well for me, and it handles my relative and absolute path resolving really well. Maybe it‚Äôs your project config?
Renaming still sucks in vsCode but you should be managing your imports better anyway. In my projects imports are always something like { component1, component2 } from "@app/components/core" In terms of plugins, I haven't noticed any instability but I also prefer to be pretty lightweight and not use hundreds of plugins. I personally have more experience in Visual Studio compared to Eclipse, and I do miss some of the more heavyweight features like better unit testing support and other tooling.
What's that supposed to mean? https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/styles/shadows.d.ts
It's a fixed length array of strings. More specifically strings used for css `boxShadow`. We could express this with types but types don't add that much because TypeScript doesn't support nominal typing. And so far nobody has complained. Seems like everybody using it understands what this means.
I spent several years writing Java in Eclipse and the last year with TypeScript in VS Code. You get the core features you are used to and they work well - auto completion, type checks, basic refactoring tools (rename, move classes and variables etc). Because Java is opinionated where TypeScript is often not (imports and import resolution, single public class per file, a number of built in naming conventions etc) - some of the more advanced refactoring and IDE features don't work well if at all, or require extra plugins. Automatic imports has never worked for me, formatting requires extra plugins, major refactoring operations such as renaming packages and folders still requires a lot of work. Despite that, VS Code + TS is still a lot better than any experience I've had with JavaScript (obviously) or Python IDEs!
That's why React uses a `bivarianceHack` to make function's arguments checked bivariantly even if `strictFunctionTypes` is set to `true`: type EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; = { bivarianceHack(event: E): void }["bivarianceHack"];
Hi, renaming variables is normally fine. The problem with renaming is normally that imports don't update properly after renaming files. Importing is slow and figured it was just that my app had grown so large but I started a new project recently and it was still slow. TSX files are worse than TS files although all are slow. The suggestion popup shows the right import but when I tab to enter to select it the import doesn't work. I need to wait 10 seconds and then run the intelli-sense again to actually import. I have workaround this somewhat by creating a snippet with common imports and then bulk removing the ones I don't need.
Can you elaborate on what you mean by imports? Is this "@app" doing something? Otherwise, my imports are like your ie named imports from mainly TSX files. TS files are slightly faster but still slow. I am running about 10-15 plugins and have to rename a plugin that ran Prettier as it was too slow and gave some weird copy-paste behaviour.
Ah sorry, I'll elaborate. The @app is an alias for a folder, you can define it in the tsconfig (if you're using typescript) and in webpack. Aliasses replace text in imports basically, so you can make an alias for any folder you're using often, for example: alias: { "@app": helpers.root("src/modules"), "@assets": helpers.root("src/assets") } helpers.root just resolves the root folder of the project. I also like putting index.ts files in folders so I can import multiple things, so for example my core index.ts exports all the components located in subfolders in the core folder. It looks like this: export * from "./module1"; export * from "./module2"; Thats how I can import any components from the core folder like this: { component1, component2 } from "@app/components/core" I hope that makes it a bit clearer. I'm using the prettier addon and it doesn't slow down my machine, but I'm using a relatively fast Mac. I fixed the weird copy paste behavior by correcting my spaces setting and turning off the format on paste options in vsCode.
Thanks for adding this.
Typescript types don't contain enough information to generate a complete JSON schema (eg title, description, min value, max value etc). It's bit like trying to generate audio from a GIF. You can't because the information just isn't there, JSON schema to TypeScript types is perfectly possible because you're removing information that TS types don't need.
 &gt;Hi, renaming variables is normally fine. The problem with renaming is normally that imports don't update properly after renaming files. They do for me when I use the "rename file" option from the context menu in the explorer. ü§∑‚Äç‚ôÇÔ∏è &gt;Importing is slow and figured it was just that my app had grown so large but I started a new project recently and it was still slow. TSX files are worse than TS files although all are slow. The suggestion popup shows the right import but when I tab to enter to select it the import doesn't work. I need to wait 10 seconds and then run the intelli-sense again to actually import. I have worked around this somewhat by creating a snippet with common imports and then bulk removing the ones I don't need. Very strange. Sounds like a hardware issue maybe? What kind of system do you have? Version of VS Code?
It's possible but it'd be more more expensive, and it wouldn't necessarily work for everyone's setup either, and it'd be another flag which isn't ideal.
I was a long time (almost 20 years) Java developer, much of that time in an Eclipse environment. I took a job about a year and a half ago where I had the opportunity to learn Typescript and several other non Java technologies. I feel like WebStorm products actually work well with Typescript. Haven't used VS code much.
I'm getting a lot of UI unresponsiveness with VS Code, forcing a reboot (linux). IntelliJ and Eclipse are worse for me. I need to upgrade my computer badly - 4/4 core/thread AMD CPU + 32 Gb ram. I know having one of the new NVMe PCIe SSDs instead of a mechanical HD would help a lot, IDEs are heavily constrained by disk speed.
I first used TypeScript on an Angular project, where it's strongly recommended. After that, I was hooked, and I bring it into any project where I feel that (1) the project will be long-lived, and (2) the code will gain a certain level of complexity.
We had a large and long lasting Python team project and the pain taught us to not create a code base without static types again.
Static typing is the only reason I ever need, but the being able to do async/await in the language, generics, interfaces, etc. are all even better.
We wanted to go serverless for our application. So we made the choice to implement rest apis with AWS lambdas. That ruled out Java because of the start up times, even though we're mainly a Java shop. Of the other lambda runtimes, node+Typescript was the obvious choice as the language is close enough to Java so we can be productive quickly and our front end was in Angular which also pushed us down the Typescript route. It had the added benefit, over Java, of simplifying a lot of our JSON parsing and reflection methods that it turned out we needed to implement.
I meant to add that I don't consider using plain JS for anything, small or otherwise. The tooling now makes it pretty simple to use TS and the older argument of TS overhead being an important consideration has mostly receded to zero for me.
I had seen too many bugs get released because of stupid things like misspellings and forgetting params, especially during refractors. These are things humans shouldn‚Äôt be dealing with. Humans should be building logic and solving problems, not ensuring type safety. TypeScript solves this problem. The only bugs I see now are logic bugs or similar. 10/10. I use TS over JS for anything bigger than ‚Äúhello world‚Äù. IMHO, it‚Äôs the clear next step for JS, but browsers will likely never support uncompiled TS :/
Generics and interfaces aren't really different reasons. They are some of the things you can do with static typing. Without static typing, they're meaningless.
I wasn't using it. Joined a new company which was using it. Did my first project there in JS as I wasn't confident to set up a TS project. I did a second project full TS. Now I can't go back: it gives a lot more confidence in your code by describing and knowing what is expected and catches mistakes early: you are a lot less in the dark.
Using javascript without any kind of static guarantees feels, to me, like drowing in a sea of chaos. *None* of the code you write has had any kind of static verification done, and is 100% impossible to refactor with any kind of certainty, barring a ridiculous amount of tests and/or copious run-time type checking. I also think that most javascript programmers didn't really ever want a dynamically typed language. They just wanted solid type inference, for the most part.
Yeah, static typing is key. In my opinion, an important part of static typing is TSX type-safe views. They are a massive step forward over stringly-typed templating garbage we had before, such as jQuery.tmpl or Knockout.js templating.
The codebase was getting pretty confusing and causing errors that were near impossible to debug
Seems wrong to base future decisions for a project that doesn't exist on past decisions and a separate project altogether.
I decided to convert an existing project to TS yo see what it was all about and immediately caught several bugs. Never went back!
Aside of all the other answers it allows me to programming by proof. I can describe the entirety of my program in types and then only prove it by actually implementing it. Imagine having to go from triggering an ajax call to rendering a graph component. Typescript allows me to describe the entirety of this process in terms of types and function signatures and the correctness of my program without having to implement it.
Yo, same here for me.
typescript is great i'm a long-time typescript user, and in recent years, i've been finding: - **i prefer typescript when i'm authoring a library,** where the code will be consumed as an npm package -- typescript is a big help in creating self-documenting code, and offers excellent autocompletion features to the users - **i still use typescript if i'm rigorously maintaining a codebase with a team.** thinking in terms of interfaces is very beneficial for team collaboration, interfaces can be provided as an acceptance criterion and writing tests can be done concurrently - **i tend to use pure javascript for smaller non-consumable projects,** because maintaining the typescript build and worrying about watch mode can be a minor annoyance. as time has been rolling forward, typescript's role has become less about polyfilling and more about type safety -- and the type safety becomes more important as your codebase scales in complexity, the team scales in collaboration needs, or as the level of rigorousness for the codebase increases since i try to package most of my code into consumable open source npm libraries, probably most of my code is in typescript however wherever the level of complexity and such is low enough, and i'm not trying to create the optimum developer experience for npm consumers -- i will opt for pure javascript because being free of a watch routine is liberating like dancing without underwear
Because when 98% of your app crashes are caused by "cannot read property xx of undefined" you start seeing some real value in typing. Of course this is not the only reason but it's still the main one
I want to be able to catch errors at compile time instead of runtime. If I refactor a data structure, I want every file that requires a change to account for that refactor to identify itself. "Hey, I no longer work! Hey, you expect me to have {property}, but I don't any longer! Hey, you assume I don't have {property}, but I do now!" Static types are like unit tests. When I change something, they tell you what broke without you having to find it yourself.
Similar here, we wanted ES6 stuff and Typescript also offered static types. The desire to type API data structures was pretty key since those get big and unwieldy fast.
It is human nature to reduce chaos and Typescript helps with that.
They are quite different reasons. Whilst generics and interfaces are meaningless without static typing, static typing is by no means meaningless without them.
https://www.thesaurus.com/browse/node I'd go with "burl" or "knob" probs srsly, though, maybe https://en.wikipedia.org/wiki/Glossary_of_graph_theory_terms#vertex
I thought python does have typing now? Or was this before it was added?
Before. And our environment dictates Python 2.
&gt;browsers will likely never support uncompiled TS :/ What would be the point of browsers supporting uncompiled TS? That would be TS without a compile check....which is the reason for its existence.
Looks good but I'm personally one of those people who likes to use express-generator *because* it sets up a view engine, not despite it doing so. Also, I'm not a fan of OvernightJS. According to the readme, it exists partly because other tools like express-generator-ts add in other libraries like an ORM. You can do routing in Express without a library like OvernightJS, so why does it make the cut but an ORM doesn't? Seems strange.
1. ORM's are huge libraries and determining whether or not to use an ORM isn't immensely relevant to whether or not you are using TypeScript. 2. A view engine can be configured with very few lines of code (like 5). 3. Overnight is a very small library (not a framework) and let's you apply many more features of TypeScript to an express application.
Ya I phrased that first part poorly. I meant that you‚Äôll never be able to use TS as easily as you can write JS inside of a script tag in an HTML file. You‚Äôll always need a precompilation step. But that‚Äôs pretty damn easy these days too, so TS all the way ¬Ø\_(„ÉÑ)_/¬Ø
Having come to javascript from years of experience with other traditional oop languages such as java, C#, C++, I have some major pet peeves about the "shortcomings" of javascript. Typescript does away with some of them. But most importantly, we're using angular 2-7, which made the choice for us.
Been writing TS a long time. Async/await was the first reason (especially when targeting ES5 environments), another is writing React without propTypes, another is the type system itself (including union types and genetics.) It's hard not to like TS. Yeah these reasons are pretty much applicable to Flow and Babel too but eh whatever.
TBH pretty much every injection system I‚Äôve seen for TS is garbage because it‚Äôs not at all type checked. It relies on you using the correct combination of type and type-tag (some kind of string or ID) everywhere. You might as well give up on static types if you‚Äôre going to use such crap.
Python‚Äôs typings are still optional, IIRC. They work, but most ides don‚Äôt handle them as nicely as VSCode/tsconfig/webpack handles Typescript‚Äôs typings. My biggest reason for my choice on my Python/Flask/Jquery rewrite (now express/react) was both the typings and the same code for front end and server work. I considered Blazor/C#, but the startup time is too slow on mobile. Maybe in a couple of years üòé
That's fair. Adding a new flag just to make half the crowd halfway happy doesn't sound super ideal when you put it like that :)
The biggest plus comes when refactoring existing code: let's say I want to change the signature of a method which is used all around the codebase. With Typescript I can change it, go over the compilation errors, update all call sites and be sure that a) I found all of them b) I updated them correctly. The feeling of safety this provides is amazing. It significantly lowers the barrier for even substantial refactors which I wouldn't even dare to try in plain Javascript. The editor knows the signature of functions so I don't have to consult the API reference too much. The source code of a class/method/function is just a click away. It's much easier to navigate and understand the code this way. If a Javascript lib has a type library (.d.ts), I can get a pretty good understanding of its API by studying it. Seeing the types lets me also infer the dependencies between the parts (who uses what) which is not trivial in plain JS. If a string variable can have only a limited set of possible values, let's say var textAlign can be only 'left', 'right', 'center' and 'justify', Typescript lets me express this and check at compile time that I don't use an invalid value anywhere. (It's instructive to study the d.ts file they provide for the Javascript DOM API, it shows a lot of interesting ways how to typecheck stuff you wouldn't believe could be typechecked.)
we actually converted to TS from flow. Flow tooling is subpar-we often had instances where the flow server just ate 16 GBs or memory and had to be killed and restarted in our daily dev workflow.
Good point! It's a nice example of when bivariance is actually desired. There is a good explanation here: https://stackoverflow.com/a/52668133
Great stuff! I created a gist with scaffolding code to create code that supports as much params as you want! [https://gist.github.com/regevbr/57f3b4d798fb4642eb4a1c6ed667320d](https://gist.github.com/regevbr/57f3b4d798fb4642eb4a1c6ed667320d)
There are reasons, there are optimisations that could be made at interpreter level with strict typing. But that's another topic.
Just to throw one out that isn't mentioned enough: contextual autocomplete. Saves so much time. The ability for your IDE to reason about your code is powerful enough. But having type guarantees at build time, especially when merging or refactoring is an outrageous time saver. Code reviews become so much cheaper, just focusing on logic and structure, instead of syntax. We have no unit test coverage on a sizeable ts code base in a heavily used web app, we do multiple releases each week and maintained a very low error rate. In contrast our Ruby server code has become quite rigid and requires much more careful attention. Sweeping improvements become difficult as it's much slower to "prove" correctness. As a result it tends to be less well factored.
If there was a prize for reinventing the wheel this you be the winner.
There are some people who are seriously intimidated by try/catch. *Disclaimer, did not read article
I've been diving more into the kinds of things you can express with type definitions and this is brilliant!. Thank you.
The big advantage is when maintaining/extending your code. Say you have a person class that has a first name, a last name, a phone, and an email, and all are guaranteed to be strings (not null or undefined). Later on, you decide to allow people to sign up without a phone (so phone is now `string | null`). With strict mode, the type checker will automatically tell you every place that will break if phone is null, so you can be sure that you caught them all. Without strict mode, you might catch most of them, but there will probably be at least a few edge cases that you don't catch, and at best, that will translate into bugs that your testers catch. If you are unlucky, that will mean crashes in production.
Use a functional lib such as ramda and you have that there for you. Done.
Would need to do something like this: (making the tag static) [https://www.typescriptlang.org/play/#src=class%20TestParentElement%20extends%20HTMLElement%20%7B%0D%0A%20%20%20%20static%20tag%3A%20string%3B%0D%0A%20%20%20%20constructor(childClass%3A%20typeof%20TestParentElement)%20%7B%0D%0A%20%20%20%20%20%20%20%20super()%3B%0D%0A%20%20%20%20%20%20%20%20window.customElements.define(childClass.tag%2C%20childClass)%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20TestChildElement%20extends%20TestParentElement%20%7B%0D%0A%20%20%20%20static%20tag%20%3D%20'test-element'%3B%0D%0A%20%20%20%20constructor()%20%7B%0D%0A%20%20%20%20%20%20%20%20super(TestChildElement)%3B%0D%0A%20%20%20%20%7D%0D%0A%7D](https://www.typescriptlang.org/play/#src=class%20TestParentElement%20extends%20HTMLElement%20%7B%0D%0A%20%20%20%20static%20tag%3A%20string%3B%0D%0A%20%20%20%20constructor(childClass%3A%20typeof%20TestParentElement)%20%7B%0D%0A%20%20%20%20%20%20%20%20super()%3B%0D%0A%20%20%20%20%20%20%20%20window.customElements.define(childClass.tag%2C%20childClass)%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20TestChildElement%20extends%20TestParentElement%20%7B%0D%0A%20%20%20%20static%20tag%20%3D%20'test-element'%3B%0D%0A%20%20%20%20constructor()%20%7B%0D%0A%20%20%20%20%20%20%20%20super(TestChildElement)%3B%0D%0A%20%20%20%20%7D%0D%0A%7D)
That's exactly why I can't (or don't want) to write js anymore. So much time is wasted on simple problems that just do t happen with ts
I figured out how to solve it. In case anyone has the same problem just add { read: true, static: false } to ViewChild Ex: @ViewChild('scroller',{ read: true, static: false })
To avoid such things in the future, when you're upgrading to a major or minor version, search for a migration guide.
The if / else part makes some good points about splitting code out, but you don't need to make some generic re-write of if/else to accomplish that. In fact, literally nothing has been gained vs. just using a regular function, and a regular if / else statement. In fact, you've probably _lost_ clarity, _and_ flexibility in doing so. Take your example code again, it can be rewritten using plain if / else like this: const hasGoodRating = rating =&gt; rating &gt; 4; // Or ... const priceChange = rating =&gt; hasGoodRating(rating) ? 1000 * rating : 1000; const getDescription = rating =&gt; hasGoodRating(rating) ? "good car" : "bad car"; // Or ... function priceChange(rating) { if (hasGoodRating(rating)) { return 1000 * rating } return 1000 } function getDescription(rating) { if (hasGoodRating(rating)) { return "good car" } return "bad car" } function getCarConfig (car) { return { newPrice: priceChange(car.rating) + car.price, description: getDescription(car.rating) } } Let's run down those 4 points: 1. Separated concerns, done. 2. Improved testability, done. 3. Adheres to SRP, done. 4. Principle of Least Astonishment is preserved, done - and moreso. One major difference about the code above is that you can actually see everything that is happening, right there. If you import some `conditionally`, you don't actually know without looking at it what it's doing without assuming what it's doing. For something as simple as this, this is actually makes things more difficult to understand. Another disadvantage to the FP approach suggested in your article is that if you did use this everywhere, you might find performance suffers too - perhaps only marginally, but still measurably I'd be willing to bet. FP style is excellent at certain things, but if it's abused I think it can be really damaging to readability and productivity. I'm not against using FP by any means, but this is not a helpful use of FP.
I don't think that was /u/antedaeguemon's point
Static typing comes with many advantages. 1. Easier to scale app, as many errors can be checked at compile time 2. Intellisense code is really good, improves productive a lot 3. Write less tests, as many tests can be checked with types. 4. Etc etc... After using TS with React + Redux, I can't go back to JS anymore.
the documentation and the actual api in d.ts is out of sync. You need to specify at least static: false|true to make it compile.
Good article - I was expecting another content marketing article that just does a copy/paste of the doco. &amp;#x200B; First straightforward explanation of React reducer hooks I've seen (actually probably the best explanation of Reducers I've seen at all, sorry Dan). Does the hard yards of breaking down and explaining the concept and showing the benefits itself - not a single reference to Redux . &amp;#x200B; Simplifies the type signatures in order to clarify the core concepts (obvious in retrospect, but not something I've seen before) and in the end gives you a solid example of doing something practical (even down to dealing with dis-mounting).
Not the sub for this... See https://www.typescriptlang.org
love to allocate and deallocate closures all the time, everywhere
Couldn't agree more. But I want to underscore one thing. Your alternative implementations are every bit as functional as the weird suggestion in this article. They are pure total functions. I love functional programming and doing functional programming is not about making code as clever as possible. It is about controlling mutation and side effects.
Author here. Thank you, I'm really pleased to hear that you've found it useful!
Hah!
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner) with focused self promotion spam like this that clearly breaks [reddits self promotion rules](https://www.reddit.com/wiki/selfpromotion) See for yourself. Vote and report accordingly.
Go away
&gt;export const myStoriesOf: storiesOfType = function myStoriesOf&lt;T&gt;( ...\[name, module\]: Parameters&lt;typeof storiesOfOrig&gt; ) { ... }; thanks!!!! it worked
How awful, I shall be sure to avoid all your products going forwardüëç
Types?
If you're already experienced in JavaScript and React, this is probably your best resource: [https://github.com/sw-yx/react-typescript-cheatsheet](https://github.com/sw-yx/react-typescript-cheatsheet)
I'm not sure. I think I have the same answer.
Why the question mark? Is that the sole feature of typescript?
The editor tools. Fast and exact intellisense suggestions. Precise "go-to-definition" and reference counts. Real-time code checking. Types? Nah. Javascript still have types without Typescript. Type-tagging can be done in other ways: JSDoc comments. Hungarian notation üòß! Nothing that hasn't been done before.
One of the best guides I've ever seen on any subject in fact: https://basarat.gitbooks.io/typescript/
I would cri @ this more
That's unusual.
All these editor features are available because of types and across multiple IDEs. Othet types solutions for JS were not so popolar and flexible. My vote is also fot types üòã
I disagree, Types is clearly the best feature
It's probably the one that's most fundamentally useful and affects everyone. If the question were "what feature of TypeScript do you wish was in C#?" I'd possibly say union types, and how they are used to deal with null and undefined
Script!
OO and inheritance
I'd say the types are not only for documentation, but to catch errors during compile time (actually moreso in my personal opinion).
How it improves plain old JavaScript as well as TypeScript, letting you use it's features incrementally.
Union Types and Intersection Types, combined with Structural Subtyping. I wish that every dynamically typed OO language has them. If only TypeScript has runtime type checking - what a great language would it be!
The down level support (types are most obvious). Been able to use modern stage 3 features reliably and target es5 is just magic.
`class MyClass implements MyInterface`
Function type overloads.
or `class MyClass extends MyAbstractClass`
Interestingly, this is my least favorite part
Mapped types, conditional types and `infer` allow for some really powerful stuff, some of which is novel even compared to other languages known for their type systems (and it‚Äôs certainly the most popular language which this novel a typesystem). Just waiting on `infer` to be usable in more places so we can have existential types, and heck, maybe HKTs will be done someday too.
Strict null checking
Ability to keep me busy. You know, programming types instead of code logic.
keyof
It's always heard to learn a code base. It's even harder if they made mistakes or sacrifices in code style or quality. But even the cleanest, greatest code will take a while to learn. You will spend a lot of time learning and confused at the start, contributing little to no code. Then towards the end of the two weeks, you'll be a master of navigating it and its features. Try to spend less of this early time actually writing code, and instead focus on learning. Ask questions, why decisions were made, what the code paths look like. Don't think you have to write much today. Spend a few days building a mental model of the code.
The point is that those systems that you mention are just half-assed, badly specified, incomplete implementations of an actual type system. They're all trying to make up for the lack of them.
The more powerful features of the type system like mapped and conditional types are definitely my favorite. They allow you to do so many cool, useful things, like demand a type of a certain shape based on another type by mapping over it, or splitting it up or removing parts of it. Obviously this is useful in a lot of places that are somewhat opaque to most users, like all the typings for some of the more complicated libraries, but they're also useful for all sorts of everyday stuff. Short story example: I once had a client who insisted on helping out. He was rather terrible and I'd regularly have to fix mistakes like typos and such. At one point, there were a lot of hardcoded tooltips that he wanted to add. The only problem was that my initial solution was just a simple JS object containing these tooltips. Using some type level magic, I was able to demand a type that was shaped like the gigantic interface that represented our data for which we wanted tooltips, except I demanded a string for every key instead of the original value type. This meant that he could write tooltips for every part of the the data(including nested objects), and any typo or duplicate entries or what have you would result in a type error.
Honestly, I think that learning a large code base quickly is one of the hardest tasks in professional programming. In practice, I mostly pick one area to focus on at a time. Figure out what one thing is doing, and don't worry about everything else. And I spend a lot of time reading code. &amp;#x200B; In your case, find an existing service that is set up similarly to how you'd want to set your up (hopefully your coworkers can give you tips), figure out how it works, and figure out what it needs to hook into in order for everything to get set up properly.
Second all of this. Also this is one area where good tooling is frequently underestimated. Find usages/Goto definition etc that are actually semantically aware (think IDE not editor) are massively useful to answer those OK, so this is a Foo, where is the Foo used, ah right I see, Foo is used for that and that. Debugger as well, put a breakpoint in early and then single step all the way through to the end point will give you a good view of the architecture, anything methods or things you don't understand make a note off and circle back and look more closely.
That's a misnomer, isn't it? There's no typescript runtime because tsc compiles to typescript before anything can actually run it?
Yep that was it. I'm a little unsure of how we've done our inheritance, but that was just what it needed to get it working.
Eh, I prefer `as any`
This. Copying working code and adapt it to your needs has less pit-falls than creating something new within an existing framework. Use the references to the copied service to find and identify important code that your new service should also provide/be used in/make use of.
Strict null checks
What idiot manager expects new material in 2 weeks from a new hire? You started under a poor manager.
Convert a project from javascript to typescript.
Modularity. Type checking.
1. Examine the data model via database tables, and understand what the different major pieces. 2. Read the tests to see what different modules are supposed to do. Don't stress, do the best you can. If you give it genuine, hard effort, no one can criticize you / it doesn't matter, not good people to work with. A new job working out isn't the end of the world.
I like literal types, and making unions of them. Pretty cool.
You don‚Äôt need to understand everything at once. For me the best approach is to find something existing that behaves _similarly_ to what I‚Äôm building, and trace the pattern to see if it‚Äôs worth repeating. You won‚Äôt understand everything but little by little you will build your intuition on how everything works. If there aren‚Äôt any flow or system diagrams then start building some rudimentary ones and improve so your knowledge is fixed on your brain.
Partial
Don't be stressed out. Absolutely NOTHING makes the ole Imposter Syndrome flare up like starting a new job with an existing code base. Just keep plugging away, take notes, and ask lots of questions. If you can, see if you can fix some bugs that have been sitting in the queue or write some tests for areas with low coverage. Try to do some basic refactoring if you can. Tasks like those are great to get your familiar with small pieces of the project without also having to make architectural decisions that you couldn't understand without more context.
Im a fan of Marius Schulz‚Äôs blog: https://mariusschulz.com/blog It has good, byte size, posts that each cover one TS concept.
the bread and butter of typescript: \*\*interfaces\*\*
+a + +b = number
This is helpful. Thanks.
I second this. Focus on defining and understanding the code base in small "silos" of functionality. And, nothing will help you learn a new code base is writing tests.
Parameter properties... It's the simple things. https://www.typescriptlang.org/docs/handbook/classes.html
Ask other developers for help when you get stuck for more than 30-60 minutes. A few minutes talking to someone who knows the code can save you days of trying to understand the wrong code. It doesn't feel great because you're exposing your lack of knowledge to the people you're trying to impress, and it will be annoying for them if they have to explain simple things to you. But in 2 weeks time it won't matter when A) you're moving onto more advanced questions; and B) you actually finished building the new service. Also the more complex Types are genuinely hard to learn, so don't be afraid to ask if reading the docs and stack overflow doesn't get you anywhere.
They asked you to create a new service in 2 weeks right after you started the job? Something is *very* wrong there.
It took me about two months until I felt comfortable in a 10k+ loc codebase. During the learning period I refactored almost all of it (fortunately that was allowed) and this was key to understanding it.
I know, it's like "I like these features that are only possible because of the types, but types? Nah I don't care about types." Lol
I almost said yeah, all features of typescript stem from it having types. But I guess there's also the transpilation from new language features like async/await into more supported es5. It's the types though that separate it from other things that can do that such as babel.
Maybe not a master in two weeks though..
Structural typing.
Index and mapped types
typescript: *has types* u/Im_Not_Antagonistic: *uses "as any"* typescript: *Pikachu meme*
I like to go about it by looking for the "main" elements (in a web application, this would be the router, in a mobile app this would be the root view, etc.) and start going through each view or each component of the project. It helps to take notes about each for easy reference.
You need to ask a senior developer that works there for help. When a company takes on a new developer they know that it will be a couple of months before a developer is fully productive. Look at the dynamic in your team, is there a time that you can ask for help? A morning standup? Code reviews? Or some sort of pair programming. Building software is a team effort whether people like it or not. When you ask the senior over for help, make sure you have everything worked out. Like how you intend to tackle this task and please write some code before asking for help (It doesn't have to be 100% correct). Nothing worse than being called over and it looks like no attempt has been made.
Ts does have runtime checking. In a sense. Type narrowing means you are forced to check the type of a tagged union with an if or a switch, before you can access the properties.
Types when using Redux with React. This is pure magic, sure you need some typings but genetics and tuples are helpful a lot.
Thank you!!
Thank you!!
Thanks!
Dev: uses any Program: has bugs Dev: Pikachu face
That's their point.
I've been using TypeScript in production since 2013 when it was in Alpha, and I have produced a few tutorials covering various topics from web services to graphics, all implemented from scratch in TypeScript 3. Here are a few: * [https://itnext.io/building-a-paint-app-in-typescript-1ce42c5b1698](https://itnext.io/building-a-paint-app-in-typescript-1ce42c5b1698) * [https://itnext.io/building-a-camera-app-in-typescript-f1981f5ce960](https://itnext.io/building-a-camera-app-in-typescript-f1981f5ce960) * [https://itnext.io/build-a-snake-game-in-typescript-8bee5b9f1ec6](https://itnext.io/build-a-snake-game-in-typescript-8bee5b9f1ec6) * [https://itnext.io/server-side-typescript-with-node-c5cef1584684](https://itnext.io/server-side-typescript-with-node-c5cef1584684) * [https://itnext.io/intro-to-generics-in-typescript-f7536375bc68](https://itnext.io/intro-to-generics-in-typescript-f7536375bc68) &amp;#x200B; I'm an R&amp;D engineer and technical writer by trade, so if anyone has any requests for topics or open-source example projects, I would be glad to incorporate these suggestions into my upcoming work. I hope this helps and let me know if anyone has any questions or needs any assistance with any of the example projects. Thanks!
His comment is optional
Wow these tutorials look good, gonna try them. Thanks, nice work!
Thanks! Let me know how they work out for you and if you have any ideas or suggestions, I'm glad you like them.
Async await and obviously types
Probably a start up
Thanks for these! I just read into to Generics. Very good. I am still a bit unsure about what is a generic, what is a type annotation and what is a type assertion. I associate `&lt;&gt;` with generics, but is there any difference between `Array&lt;Vehicle&gt;` and `Vehicle[]`? It gets quite confusing all these different ways to do the same thing. Then we have `as Vehicle[]` as well.
Interfaces are ‚Äúmutable‚Äù through ‚Äúaugmentation‚Äù and can define both a callable and object part, but for the rest they are mostly the same. Both are there mostly due to the way TS evolved (I guess) ‚Äî in the beginning there were only interfaces. They may also show up a bit differently on tooltips.
https://stackoverflow.com/q/37233735/7436489
A few tips that work for me: 1. Learn the hierarchies first. Get good insight into how things, specially data, are organized, and the relationship between the parts. Bonus tip: write/draw this down on actual paper. This works miracles for me. Try to get the whole picture into a page, then a lie refined picture. Learn hierarchies and relationships and you're half way there. Put greater focus on the parts that are more related with the service you need to write. 2. Feel free to ask questions. Don't get stuck at trying to figure everything by yourself. Sometimes there's subtle but key details. Or there could be parts that rely on things you don't even know about yet. Heck, I've even seen code that was working out of coincidence. 3. Ask for code reviews, and don't take them personally 4. Use automated tests whenever possible 5. Try not to stress. This is hard for everybody, not just you
Ah so basically if you rely on merging.
Different error messages. For interfaces: Type '{}' is missing the following properties from type 'Y': b, a For types: Type '{}' is not assignable to type 'Y'. Property 'a' is missing in type '{}' but required in type 'X'.
Fair play!
https://github.com/denoland/deno
Negative types would be awesome too. x is not string ? typeof x : number
Deno doesn't actually do runtime typechecking; it's more like ts-node. The types are still stripped and it doesn't do runtime validation.
Check out Type Guards: https://www.typescriptlang.org/docs/handbook/advanced-types.html
I don't find validation with io-ts annoying at all. At some point you're gonna write some mock from your data I mean.
Hmmm.. How should it work? Say you have a interface with 10 fields, and some of the fields were other interfaces with 10 fields. Now we should validate this against a json like payload. If it fails then what? Now you get a runtime error, but what should happen when that error occurs? Its a state of no return anyway as i see it. Probably the best way would be to go all in and have the same types on backend and client, but not all apps have node as a server. Webassembly could be an alternative, but this is long in the future.
Runtime type checking is rare. Most languages don‚Äôt do it or do it in minimal situations. If all TS code was written in TS (instead of creating types for existing JS code), there wouldnt be too much need for runtime checking. Languages like Java check for array out of bounds and accessing null references, but that‚Äôs usually about as far as they go. JS makes those types of checks too.
Agreed, what even happens in a situation like that? Runtime safety is usually more about preventing security holes like buffer overruns. And JS runtimes already have pretty good measures here.
Even if it could be done, which you know with enough effort anything can done, it might not be a good idea. It would be a lot more work for the interpreter and also quite simply would just make larger source files to work on. Also this is something most people never really think about but javascript/typescript doesn't have many datastructures, or even ways of declaring datastructures in a way that it would be easy to deserialize data into memory. &amp;#x200B; At the object level in javascript/typescript there is only one data structure and its a hashmap. Even arrays aren't actually arrays. They're maps of strings that are numeric keys, and a length property, with the Array prototype attached to its \_\_proto\_\_ chain. &amp;#x200B; I am no expert, far from it. However the point I am trying to make, is that even if types were to be baked in to the runtime, the nature of what this would imply would be very different than for a classic c family language, or rust and go. &amp;#x200B; At least that's my impression.
Any language with type information available at runtime can be used to build parsers. Super important for web service development when you want to validate that information which comes off the wire conforms to a type.
Wouldnt the source be the same size. Do you mean the runtime memory requirements? I could see that
What languages have that, out of curiosity?
I would agree. I guess what I am saying overall though, is because of what a JavaScript engine is, the performance costs of introducing a typescript like type system into the runtime would be higher than for most regular static languages by virtue of design. Hence what you are suggesting although interesting might not be desirable in practice.
There is no difference between Array&lt;Vehicle&gt; and Vehicle\[\] - just different syntax for expressing the same thing. I would say that &lt;&gt; is not out of date for clashing with JSX as it's a common language feature in many languages from C# to C++, Dart, and others, all of which are far more heavyweight long-term contenders than one front-end framework. A type annotation - a word that basically means "note" - is effectively a note to the compiler that a variable or class property is of a certain type. A type assertion is something performed by the compiler using those annotations, to make sure the developer isn't trying to assign the string "asdf" to a type that can only accept integers. This is important because in languages like plain JavaScript and PHP, a huge weakness exists in which developers can willy-nilly perform operations of any kind on any variable, which ~~can~~ does lead to strange bugs and runtime errors when the engine tries to do something like call a method expecting an object, getting a boolean instead, and then crashing while trying to enumerate properties on the boolean. Hope this helps, and thanks for checking out my work! Let me know if you have any other questions.
Hm. I think there is maybe a misunderstanding here. Java has quite stricter runtime typechecking than that. Java has "type casts" which are checked at runtime, TypeScript has "type asserts" which are not checked at runtime and the user has to do the checking. See [this Java example](https://repl.it/repls/AdmirableOriginalCharacters) vs [this TS example](https://repl.it/repls/OffshoreInsistentMetrics). It may seem trivial but in the Java example the error shows up when you attempt to assign an `A` to a `B` where as in the TS example the error shows up when you attempt to invoke `foobar`. In practice I find this has a large impact, earlier errors are always better IMO.
There is definitely runtime type checking in Javascript, otherwise we wouldn't have `TypeError`. For a convenient deserialization with type checking, generally languages need support for [Reflection](https://en.wikipedia.org/wiki/Reflection_(computer_programming\))--which requires additional runtime type information. Adding additional runtime type information is [listed as a non-goal for Typescript](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals).
Yes, you are right. I misspoke. Thanks for clearing it up and the examples.
I won't risk trying to come up with an exhaustive list but presumably any statically typed language with reflection support. The most widely used example I can think of is Java. &amp;#x200B; Here's an example of a JSON parser for it: [https://github.com/google/gson](https://github.com/google/gson) . You can create a \`Foo.java\` class and parse some JSON in a single line \` Foo example = gson.fromJson(json, Foo.class); \` Boom, single line parsing.
&gt; Hmmm.. How should it work? Say you have a interface with 10 fields, and some of the fields were other interfaces with 10 fields. Now we should validate this against a json like payload. To make sure I understand correctly I have this: interface Foo { one: string two: number three: boolean four: Bar } interface Bar { one: string two: string three: string } asd And I get a JSON payload like this { "one": "hello", "two": 42, "three": true, "four: { "one": "hello", "two": "my", "three": "friend" } } &amp;#x200B; Then with a runtime that supports reflection and has type information available I should be able to call a fictional parse like this \`const a = JSON.parse&lt;Foo&gt;(json)\` and have a variable \`a\` which it ensured to be of type \`Foo\`. &amp;#x200B; &gt;If it fails then what? Now you get a runtime error, but what should happen when that error occurs? Its a state of no return anyway as i see it. That's fine. I deal with it. The point of this is to make deserializing data that comes from outside my application (entered by a user, sent via an HTTP request, read from a database, loaded from a file etc) easier. &gt;Probably the best way would be to go all in and have the same types on backend and client, but not all apps have node as a server. Webassembly could be an alternative, but this is long in the future. &amp;#x200B; And sometimes you don't control the client. Say you've got customers/partners/friends/lovers integrating to your API. You've given them great documentation and examples but you still don't trust them to post the right thing.
I put type definitions in a folder called `types` whose content is picked up automatically (I think).
Runtime checking is against TypeScript's philosophy sadly. I do understand why. If you want to validate incoming data, you might want to try [typescript-json-schema](https://github.com/YousefED/typescript-json-schema). It generates a JSON schema from your types (it's best to do this as a build step so the type information isn't out of date). When you have the JSON schema, you can use [ajv](https://github.com/epoberezkin/ajv) for validation.
C# does type checking alot :) which ianwhat typescript is based on and same creator Andera himself
C# and Rosyln compiler are good examples
You are going the wrong way about this. This should not be a runtime check, this does not even have to do anything with the language. You are talking about input validation, which can be easily done in ts. Sure, it may require some manual work without macros, but i've written a code generator for that, it's not that hard.
Thanks!
And exactly those type casts would be near impossible to implement in TypeScript.
Any language that uses structural typing, like TypeScript?
If you have a `code.ts` file already, then it makes no sense to add another `code.d.ts`. Why do you want to duplicate your definitions?
Rust is a good example of this (see e.g. the `serde` crates).
For a lot of deep data hierarchies that you need to validate within incoming payloads you'll have to resort to something like `io-ts`, and that's just not very ergonomic. The plugin for the `ttypescript` compiler (`typescript-is` if memory serves) gives a good idea of what could be possible.
I think there is a MAJOR lack of decent docs on creating tests. It is just the wild west out there for JS and TypeScript. Where is the official advice or tools for testing?! Imagine TS had it's own official library test runner... why not?! [https://docs.python.org/2/library/unittest.html](https://docs.python.org/2/library/unittest.html) Also, why is there no up-to-date specification for TypeScript? It stopped in 2016. [https://github.com/microsoft/TypeScript/blob/master/doc/spec.md](https://github.com/microsoft/TypeScript/blob/master/doc/spec.md) I think maybe people are addicted to this rapid pace development. It is not so much fun to just take a deep breath, forget all the new features and just go back to the docs and specs and get everything in order.
Reflection isn‚Äôt type checking though. It‚Äôs more like type ‚Äúdiscovery‚Äù.
replace REST with graphql and you won‚Äòt need runtime types.
We‚Äôre doing what you mentioned. Move data objects, services, etc into a private npm and share amongst all of the projects.
I still don't get what's your problem. You NEED to validate the incoming data. Since typescript has structural typing, if you validated the data, you don't need to do anything after that. You can just use the data as-is.
Why is the runtime type validation needed if you got your code compiled from the TS with the strict mode enabled? Deserializing a raw data that is coming from the external/untrusted sources is a different case. Regardless of using the static checking in runtime or not, you would still need to deserialize a raw data using custom deserializer, same applies to JS, Go, Rust or any other programming language as the data you get from external sources is the same raw type of data.
I don't, I want to declare all my types in one file and use them in another file. Keep my codebase largely ES6 compatible, adding typescript support via a related types.ts file or something similar. That said the reason I'm keeping the code files *.ts and not *.js is for the intellisense mostly.
&gt; I don't, I want to declare all my types in one file and use them in another file. Then either don't use modules (types are implicitly available everywhere), or export and import your types. Your approach with the `.d.ts` won't let you do anything else either.
Runtime type checking might prove useful to your specific use-case. However, if it is not natively implemented into the engine, it will definitely pose significant performance issues. Perhaps a pluggable interface like BinaryAST but perforated for TypeScript would prove great. Meanwhile, you might wanna checkout MemScript. It is an idea I had as far as runtime type checking is concerned. However, runtime memory management is its main goal so that will differ to your needs. It is a WIP so I would really like any ideas on it (comment in the gist). https://gist.github.com/undefinedbuddy/abe918374d394e6380361fb9dcdc3745
Can function signatures be imported? I managed to get a function declaration to be detected, but instead of erroring an incorrect function declaration it assumed it was overloaded... :(
In your `file-a.ts`: export function mySuperFunc(): string { return 'bla'; } In your `file-b.ts`: import { mySuperFunc } from './file-a'; console.log(mySuperFunc()); That's the basic principle.
Yes, you need to validate it. If you have reflection, or on some level the types aren't merely for the compiler and erased at runtime, then you can use those types you've already defined inline without having to resort to unergonomic third party libraries.
Sure, just do this: const characters = { heroArray: [] as Hero[], zombieArray: [] as Zombie[], }; Yay, perfectly typed. If you want to be able to assert that every member extends drawable, I think you'd have to use generics. Or at least some type of helper function for building this object. Here's an example: function assertDrawable&lt;T extends Record&lt;string, Drawable[]&gt;&gt;(o: T) { return o; } const checkedCharacters = assertDrawable({ heroArray: [] as string[], // Type 'string[]' is not assignable to 'Drawable[]' zombieArray: [] as Zombie[], }); Demo: [Typescript Playground](https://www.typescriptlang.org/play/#src=export%20interface%20Drawable%20%7B%0D%0A%20%20update(\)%3A%20void%3B%0D%0A%20%20draw(\)%3A%20void%3B%0D%0A%7D%0D%0A%0D%0Aexport%20class%20Hero%20implements%20Drawable%20%7B%0D%0A%20%20update(\)%20%7B%7D%0D%0A%20%20draw(\)%20%7B%7D%0D%0A%20%20whatever(\)%20%7B%7D%0D%0A%7D%0D%0A%0D%0Aexport%20class%20Zombie%20implements%20Drawable%20%7B%0D%0A%20%20update(\)%20%7B%7D%0D%0A%20%20draw(\)%20%7B%7D%0D%0A%20%20moreWhatever(\)%20%7B%7D%0D%0A%7D%0D%0A%0D%0Aconst%20characters%20%3D%20%7B%0D%0A%20%20heroArray%3A%20%5B%5D%20as%20Hero%5B%5D%2C%0D%0A%20%20zombieArray%3A%20%5B%5D%20as%20Zombie%5B%5D%2C%0D%0A%7D%3B%0D%0A%0D%0Acharacters.heroArray.push(new%20Hero(\)\)%3B%0D%0A%0D%0Afunction%20assertDrawable%3CT%20extends%20Record%3Cstring%2C%20Drawable%5B%5D%3E%3E(o%3A%20T\)%20%7B%20return%20o%3B%20%7D%0D%0A%0D%0Aconst%20checkedCharacters%20%3D%20assertDrawable(%7B%0D%0A%20%20%20%20heroArray%3A%20%5B%5D%20as%20string%5B%5D%2C%0D%0A%20%20%20%20zombieArray%3A%20%5B%5D%20as%20Zombie%5B%5D%2C%0D%0A%7D\)%3B)
because you've set the characters object to an indexed type which has string properties and Drawable[] values. When you now try and access one of those string properties (heroArray in this case) it returns a Drawable[] which hence has a [0] element which is a Drawable object. If you want to get back heroArray[0] as a Hero[] then you can do (characters.heroArray as Hero[])[0].whatever() or (characters.heroArray[0] as Hero).whatever()
Don't use the declare keyword. That informs the typescript compiler of the existence of something it can't know about . Using 'declare function' informs the compiler that a function called ' dummyFn ' exists and can be invoked. To declare a type signature use export type dummyFn = (argA: string, argB: number) =&gt; number; You can then import that into your code.ts file
You defined characters.heroArray as type Drawable but are using it as if it were type Hero. You should give it type Hero instead of Drawable.
You put an explicit type annotation on `characters` which overrides whatever you put on the right hand side of that assignment expression. You want the type of `character` to be inferred from the type of your object literal on the right hand side of the assignment expression, which means removing the type annotation that immediately follows `character: `
I suspect its because the heroArray type assertion within the characters const declaration is scoped. Typescript is OK with the hero-to-drawable push due to inheritance.
where?
So the reason this happens is because TS only knows that the items in there are `Drawable`s, and not that they are `Hero`es. You basically have two ways of fixing this: a) Remove the explicit type declaration for `characters` (or define all keys explicitely) so TS infers the type automatically as `{ heroArray: Hero[], zombieArray: Zombie[]`. Then TS knows that this object has only the keys `heroArray` and `zombieArray` and the types of those, respectively. b) If you want to keep it as a collection of `Drawable`s, the quick and dirty way is suggested by /u/blood__drunk below; Just cast it and tell TS "I know better than you". The more beautiful way is writing a so called "User Defined Type guard" [Docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards): const possibleHero = characters.heroArray[0]; if (isHero(possibleHero)) { possibleHero.whatever(); } function isHero(drawable: Drawable): drawable is Hero { return typeof (&lt;Hero&gt;drawable).whatever === 'function'; } This allows you to programmatically decide if the variable is a hero, a zombie or whatever and then call these specific methods on it.
Meant to reply to OP, who defined heroArray as Drawable after const characters.
Thanks to you and everyone who replied so quickly and helpfully!! Now I get it :)
Can also do both if they wanted to add more Drawable arrays in the future (though adding new explicitly typed arrays to the characters type would be better): const characters: { [key: string]: Drawable[]; heroArray: Hero[]; zombieArray: Zombie[]; } = { heroArray: [], zombieArray: [], };
Runtime type checking requires runtime type definitions. TS strips type information on compilation. https://www.npmjs.com/package/yup This provides the best compromise between ease of use and expressiveness.
Why would you need any library for this? Serialization and validation does not need reflections. It can be done, but it's a horrible idea. &amp;#x200B; I think are suffering from a heavy case of the X-Y problem. &amp;#x200B; &amp;#x200B; &gt; types aren't merely for the compiler and erased at runtime Java and C++ 's Type erasure would like to have a word with you.
How do you validate very heavily nested, complex data structures?
At my day job, usually Json schema. I wrote a small utility that can parse classes, and create a json schema that will match those. Json schema can refer to other schema files, so each model / class will only have it's own schema. &amp;#x200B; So no matter how complex anything can get, validation is only applied one-by-one.
Haskell is notoriously good at parsers iirc.
@FengShuiAvenger If you check out this issue: https://github.com/Microsoft/TypeScript/issues/6579 - you'll see that many people would be very happy to be able to do that (particularly with regular expressions)
**All** `@types` dependencies should be `devDependencies`. That your library is using another library shouldn't concern the user of your library. If they need the types for the nested dependency, then they can add that type.
No no, not functions, function signatures, as in: MySuperFunc(): string; /u/toasties1000 got something pretty close to what I want to do, and will be using that. -------------------------- At the moment I've got a types.ts file where I have code like: ```declare type AddComponent = (store: IStore, compType: ICompType, compDef: ICompDef): IComponent;``` Then in another file I actually implement it as: ```const addComponent: AddComponent = (store, compType, compDef) =&gt; { ... }```
 export type MyFunctionSignature = () =&gt; string;
Amazing, this is pretty much what I'm trying to achieve, thank you!
That's incorrect, and a common misconception. When your tsconfig has `"declarations": true` then the .d.ts files emitted by TypeScript may `import` those transitive `@types` directly. Thus they need to be declared as dependencies. Otherwise the bundled .d.ts files will fail immediately for someone consuming your library. This is necessitated for exactly the reason you cite: "that your library is using another library shouldn't concern the user of your library." Here's an example of this being discussed: https://github.com/apollographql/apollo-client/issues/713 It links to an explanation from the TypeScript team: https://github.com/microsoft/types-publisher/issues/81
&gt; According to #typescript roadmap strongly typed generators and iterators will be available in the next release. Sorry to disappoint, but the entry being on the roadmap for the next release means **nothing**. It **may** be part of it, but it doesn't has to. At least "Stricter types for IteratorResult" has been in the next version for several versions, but always gets pushed to the next.
My mistake. I stand corrected.
That's exactly the question I'm asking: is there a tool to automate the "except" detection and update \`package.json\` accordingly? I can do it manually, or a tool can be written to do it automatically. Does such a tool already exist?
You can find the PR here: https://github.com/microsoft/TypeScript/pull/30790
I did some more research and came across npm link. One of my main concerns was that I'd have to keep pushing and pulling this npm package into all of my projects. With npm link however it creates a symbolic link of the package folder into each of the node module folders.
Still, he‚Äôs not defining heroArray as an array of Drawables. He defines heroArray as Hero[]. What he does do is defines the value of the keys of characters as an Array of Drawables. He can‚Äôt change that to Hero, because if he does, then zombieArray would be type Hero[]. Your proposal misses this.
No, he explicitly defined characters as a map of strings to Drawables. The heroArray property is never defined to be Hero. It's defined explicitly to be Drawable, and that's precisely the problem.
We agree about the ‚Äúdefined characters as a map of strings to Drawavles‚Äù. Yes, that is the problem. But your solution initially was ‚Äúyou should give it type Hero instead‚Äù. But characters also contains zombies. So that wouldn‚Äôt work for his use case. That‚Äôs all I‚Äôm saying.
heroArray does not contain Zombies. My solution was to define the heroArray property as Hero[], not to define characters as a map of string to Hero[].
I didn‚Äôt say heroArray contains Zombies. I said characters does. I thought your proposed solution was this: const characters: { [key:string]: Hero[];} = { ... }; Which obviously doesn‚Äôt work because then zombies is also type Hero[]. The correct solution is the reply that you originally responded to. Is that what your proposing, also?
Doesn't that imply writing your interfaces and essentially documenting your data structures via a third party library, or writing them twice? In Rust for example you define structs (essentially more concrete interfaces), and you can feed that type into libraries like serde so that it can directly attempt to deserialise into that form.
I mean, haskell can do similar things without any reflection to speak of. Typeclasses and strong type inference essentially lets it decide what parsing logic to use based on the type of the variable you are assigning it to. You could do something similar with typescript, if you are willing to manually pass in the parsing logic. You'd end up with something like function handleArray(innerHandler) { return function (args) { // parse the array structure and call innerHandler for the elements } } function handleFoo(args) { // parse a single foo } and then if you want to parse an array of foos, you call `parseJson(json, handleArray(handleFoo))`.
I proposed interface Chars { heroArray: Hero[]; [key: string]: Drawable[]; } As I edited, I did not mean to reply to the person at the top level. I meant to reply to the OP, but clicking the wrong reply icon on the mobile app.
Is redux-saga superior to redux-thunk? I'm yet to hit a problem that can't be solved by async thunks.
Seems that‚Äôs limited to local development, no?
It does seem that way however everything is transpiled for deployment so I guess it's not a huge issue. It really only adds an extra step in setting up the dev environment.
Redux sagas are all about describing side effects in a way that is unit testable, and it's sort of similar to how effects can be described in advanced type systems like Haskell, but not at a type level. It also gives you great options for long-running background tasks that can be triggered by actions or simply started immediately on load. It also has easy mechanisms for throttling and debouncing action triggered tasks. Thunks are a fine choice for simpler, less demanding apps when it comes to side effects, but sagas are ideal for apps with heavy side effect needs, or for any sized app. Sorry I couldn't elaborate much better, wrote this on my phone. Hope this helps :)
Firstly, great job! Why would I use FoalTS over NestJs?
For very complex use cases, I think yes. In one app I've written with sagas, I have some pretty complex network interactions from user actions. The user does something, and it requires a few network requests that may or may not fire depending on some parameters, each of which has a failed and a successful action that gets emitted. Sometimes you also really want to emit multiple actions simultaneously too. Sagas make this pretty straightforward. They are complex to work with in general though. It would be much more complicated without sagas in this particular use case. There's nothing stopping you from using both though, other than bundle size. If you need sagas, use sagas. If you need thunks, use thunks. The world isn't that binary, use what you need and nothing more. If you can solve the problem cleanly without sagas, then don't use them. If you can't solve the problem cleanly without sagas then use sagas.
We have at least one similarly complicated interactions, but I just moved everything into separate async functions. Might consider it in future.
A line like this from your typescript source has all the information needed: `constructor(public readonly methodName: string) {}` You just need to tokenize this, and create the validator automatically, and save that as a validator next to your model, or you can even make it generate that inside the class, that's something that you only need to write once, put in your build script. Probably libraries, tools exist for this, but i didn't bother with it, since most of them didn't do exactly what i wanted to, and it took only a few hours to write.
Thanks, this was really useful!
You are correct, the \`sum\` function is there just for example. The real code I was writing had React hooks in mind and this example was much simpler to use.
The comment section really divulged last time, so I'll take an early jump on this. The title is a bit clickbaity, although I don't think intentionally. In addition to the client not paying, the client decided not to launch the product at all. As a result, there is no leaked IP here, such as confidential information or business logic.
And the project boilerplate is clean af üëåüèΩüëåüèΩüëåüèΩ
I have a client I've been helping out for the past 6-7 years, rebuilding their website/server/database. They're a non-profit adoption resource exchange, and wouldn't have been able to afford a quality developer, so I made a deal with them that if we open sourced the project, I'd build it for free on my spare time. It's not at all like your story since your client screwed you over, but... yay open source.
Well, for some reason I wasn't impressed as the people in comments. Look like an average project boilerplate, but well, not so many production ready code getss open sourced, so I guess it's a breath of fresh air for those who are watching those endless useless tutorial videos.
The server side is not making use of TypeScripts `strict` flag (none of them actually). That's something I definitely don't want to miss anymore.
I have been using in production for months, and so far, no regrets! love it
I've been looking for a good example project and been having a hard time finding one that uses the strict flag. Most graphql server boilerplates don't use strict and when I turn it on they get pretty loose around the resolvers. Do you have any good recommendations?
Yeah thanks, I suspect we could use them to formalize our more laissez faire approach to these operations.
If I understand correctly, you can just `switch` on the classToInstantiate instead of a string, which removes the need for a string identifier. You can also add multiple overloads for type-safety if these classes are supposed to have different parameters: public instantiate(classToInstantiate: typeof Zombie, options: ZombieOptions): Zombie; public instantiate(classToInstantiate: typeof Hero, options: HeroOptions): Hero; public instantiate(classToInstantiate: typeof Zombie | typeof Hero, options: ...): Hero { // common implementation } However, I'm not sure you really need this common factory. If you just need a quick way to create a bunch of characters, why not write a generic function which calls another function repeatedly and use it like this: var characters = repeat(100, () =&gt; new Zombie({...})) Or even with built-in means (ES6): vat characters = Array.from{ length: 100 }).map(() =&gt; new Zombie({...})) There is some garbage collection overhead, but you can use the first option and move out the anonymous function to avoid it. Also, if your game objects end up with lots of common but also some different properties or methods, consider switching to a component-based approach (not necessarily ECS, just composing your objects out of several game components would also work).
&gt; . Regardless of using the static checking in runtime or not, you would still need to deserialize a raw data using custom deserializer, same applies to JS, Go, Rust or any other programming language as the data you get from external sources is the same raw type of data. &amp;#x200B; Custom per data type maybe but not application. Many languages have JSON/XML/whatever serialization libraries which can be handed a bunch of types and validate data against them.
&gt;Many languages have JSON/XML/whatever serialization libraries Exactly. Event if you have type checking in runtime you will still have to use custom libraries for serialization based on some scheme. Such libraries exist for TypeScript too.
 &gt;This should not be a runtime check, this does not even have to do anything with the language. You are talking about input validation &amp;#x200B; Sorry, like I mentioned my experience around programming language theory is rusty, I used the wrong terms. I want types available at run time. Yes, for input validation. &amp;#x200B; &gt;which can be easily done in ts. &gt; &gt;Sure, it may require some manual work without macros Sometimes easy and simple don't overlap.
This is exactly what I do. &gt;Runtime checking is against TypeScript's philosophy I'm hoping Typescript changes it's philosophy with more acceptance. From making JS better to replacing JS. Unlikely but that's what dreams are for.
Can't help you with that unfortunately. I mainly write LOB applications, and for those GraphQL is unsuitable.
Thank you! Foal and Nest are both Node.js frameworks using TypeScript that may look similar at first glance. Here are the main differences: \- NestJS architecture is very inspired by Angular and so comes with some complexity. Foal's architecture is meant to be simpler and so easier to learn and use. There are only three types of components in FoalTS: controllers, services and hooks. \- FoalTS comes up with *batteries included*. Not only does it bring architecture like Nest but it also offers a lot of built-in components to handle common scenarios. For example it includes tools to manage variables in multiple environments, shell scripts to execute Node scripts from the command line with validation of the arguments, CLI commands to generate and run databases migrations, generators to quickly build REST APIs, hooks to authenticate users with JWT with blacklist support, tools to debug the app with VSCode, etc.
Thanks for this excellent information! I thought I could switch on `classToConstruct` too, but there is something wrong. If I use `switch (typeof classToConstruct)` and `'Zombie'` I get `Type '"Zombie"' is not comparable to type '"string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"'.ts(2678)` I have been experimenting with using your suggested function overloads, but I get an error with `options: ...` of `Type expected.ts(1110) Rest parameter '(Missing)' implicitly has an 'any[]' type.ts(7019)` Prettier counts this as a syntax error and crashes. I am not experienced with overloads, any idea? The idea of a component-based approach is a good one, but the main purpose of this game is to act as an educational resource on programming and needs to be as simple as possible to illustrate certain programming concepts, inheritance in this case. I have been playing about with different ideas for this factory all last week. I don't think your generic/map function idea is suitable as there is going to be a lot of different options and logic in the factory. As an example, the original one I am trying to improve on looks like: import { Character, Vector2, Hero, Zombie, Bullet } from './game-objects.js'; const middleOfScreen = (ctx: CanvasRenderingContext2D): Vector2 =&gt; [ ctx.canvas.width / 2, ctx.canvas.height / 2, ]; const randomSpawnPoint = (ctx: CanvasRenderingContext2D): Vector2 =&gt; { const pointToSpawnAround = middleOfScreen(ctx); const variationInR = 400; const minimumR = 200; const theta = Math.random() * (2 * Math.PI); const r = Math.random() * variationInR + minimumR; return [ Math.cos(theta) * r + pointToSpawnAround[0], Math.sin(theta) * r + pointToSpawnAround[1], ]; }; /** * ============================================================================= * Factory * ============================================================================= */ export function factory( characterOptions: Partial&lt;Character&gt;, numberOf: number, ctx: CanvasRenderingContext2D, ): Character[] { // should be return type Character const newCharacter = (): any =&gt; { switch (characterOptions.kind) { case 'hero': return new Hero(middleOfScreen(ctx)); case 'zombie': if (characterOptions.image) { return new Zombie( [characterOptions.image.width, characterOptions.image.height], characterOptions.image, randomSpawnPoint(ctx), ); } throw new Error('No image supplied for zombie'); case 'bullet': if (characterOptions.position &amp;&amp; characterOptions.rotation) { return new Bullet( characterOptions.position, characterOptions.rotation, ); } break; default: } }; const characters: Character[] = []; for (let index = 0; index &lt; numberOf; index += 1) { characters.push(newCharacter()); } return characters; }
stats of proof?
For one of the project I'm working on it allows reduce bundle size on ~15% min and ~5% min.gz (from 43kB to 41kB min.gz or from 186kB to 157kB min). https://twitter.com/timocov_/status/1138043113728032768
My first gut instinct is that this seems scary
Why? :(
&gt; I thought I could switch on classToConstruct too, but there is something wrong. Because you're doing it wrong. When you call `typeof classToConstruct`, then the result will **always** be `"function"` - because `classToConstruct` is a class constructor (which is a function). When you then check a case for `"zombie"` it won't ever be true. Instead switch on the **actual constructor**, and have your **specific constructor** as the case, e.g.: switch (classToInstantiate) { case Zombie: ... }
Cheers! It runs, but has introduced two problems. Now I get: case Zombie: ---------- &lt;&lt; error squiggle Type 'typeof Zombie' is not comparable to type 'new (...args: any) =&gt; T'. Type 'Zombie' is not comparable to type 'T'. 'Zombie' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'Character'.ts(2678) So it does not like my construct signature? How can I also add a call signature it accepts, or maybe I am misunderstanding? characters.push(new classToConstruct(options.x)); ---------------------------------------------- Cannot use 'new' with an expression whose type lacks a call or construct signature.ts(2351) But it had one a moment ago? THANKS!
You're not using method overloading, as he suggested.
Only because of the error with the rest parameter `options: ...` , if you have any input on that it would be gratefully received. It does look like weird syntax. I will start this function again now and rebuild it bit by bit with the great advice I have been getting. I am trusting that the insane amount of time it takes to do anything in TypeScript will decrease as I get better, it seems like it is one step forward two back sometimes.
I really like the idea of doing more to treat "private" class members as private. But I can play devil's advocate a little bit on this one. What if JS consumers of my library have decided to write code based on the private members of my classes? Are the manged identifiers stable between subsequent compiles? What if a consumer of my library ALSO uses your minification plugin, and extends one of my classes. Is there any way to ensure there are no name conflicts between the two classes' private members? Is adopting this going to make it more difficult to move to [ECMAScript private class fields](https://github.com/tc39/proposal-class-fields)? That all being said, this project sounds awesome to me--even if it's just a proof of concept that explores the idea.
&gt; What if JS consumers of my library have decided to write code based on the private members of my classes? But it's a private one, not even protected. I'm not sure that it's a good way to achieve something... &gt; Are the manged identifiers stable between subsequent compiles? For now minifying should be done by external minifier (like terser/uglify), but in the future, if the transformer will generate "random" names, I believe, it should generate stable names between compilations of course. &gt; Is there any way to ensure there are no name conflicts between the two classes' private members? Good question. I'm not ready to anwser right now (I don't know whether does this check any minifier right now or don't), but one thing can try to avoid this - use custom prefixes for "random" names. I know that it isn't enough to be 100% sure that everything is fine, but possibly it might help. &gt; Is adopting this going to make it more difficult to move to ECMAScript private class fields? afaik transpiling private fields will be done by WeakMap, and it might reduce performance of the app (also some non-modern browsers doesn't support WeakMap's).
But anyway, thank you for your comment and feedback üëç
Typescript would be a good one.
This is my second reply, in case Reddit reorders it. 5 hours later I think I have it! I did what you recommended, but had to change your syntax and use an optional parameter instead of a rest operator. There are no errors in strict mode and it seems to do exactly what is required... which is why I am naturally suspicious there is a hideous error! Could you have a look and confirm it is good? I am assuming i need the `const characters: any[] = [];` and function return value of `any[]` as the overloads are doing their magic? Could the types be tightened any further. THANKS so much for your help. // VERSION 2 // INTERFACES interface Character { sayHello(text: string): string; } interface ZombieOptions { x: number; } // CLASSES class Hero implements Character { public sayHello(): string { return 'hello Hero'; } } class Zombie implements Character { constructor(public exampleOption: number) {} public sayHello(): string { return 'hello Zombie'; } } // FUNCTION OVERLOADS AND MAIN FUNCTION function instantiate( classToInstantiate: typeof Zombie, numberOf: number, options: ZombieOptions, ): Zombie[]; function instantiate(classToInstantiate: typeof Hero, numberOf: number): Hero[]; function instantiate( classToInstantiate: typeof Zombie | typeof Hero, numberOf: number, options?: any, ): any[] { const characters: any[] = []; for (let index = 0; index &lt; numberOf; index += 1) { switch (classToInstantiate) { case Zombie: characters.push(new classToInstantiate(options.x)); break; case Hero: characters.push(new classToInstantiate()); break; default: break; } } return characters; } // TEST const result = instantiate(Zombie, 3, { x: 12 }); console.log(result[0].sayHello()); // hello Zombie console.log(result[0].exampleOption); // 12 result; const result1 = instantiate(Hero, 3); console.log(result1[0].sayHello()); // hello Hero
Probably the easiest way to get into it is to find a library that you use with no/lacking TypeScript definitions and add submit a PR. Either through the library itself, or DefinitelyTyped.
Thanks for the cool project! Can the same not be achieved with Closure compiler in advanced mode? There is a Rollup plugin to automate too: [https://developers.google.com/closure/compiler/docs/api-tutorial3](https://developers.google.com/closure/compiler/docs/api-tutorial3) [https://github.com/ampproject/rollup-plugin-closure-compiler](https://github.com/ampproject/rollup-plugin-closure-compiler) I know you need to change your code around a bit. I played with it a while ago, it is not plug and play in advanced mode, but I can't imagine any better results could be possible... almost everything is minified mercilessly!
I've done this in Pixi.js &amp; webpack based games by having an environment variable for dev mode that creates a global variable containing an object with references to the root game class and other useful components. I've not used Excalibur, but I'd assume that something similar would be possible there. If you build in dev mode you get it exposed to the console, the rest of the time it's nicely encapsulated in the modules. I'm not totally sure what you mean about using typescript in the browser directly, though, I've always compiled it either through typescript or webpack with a typescript loader.
Vue 3 is going full typescript internally. It was going to support class based components natively as well but they failed that back (vue-class-component is still officially supported though so it‚Äôs more of a semantic point).
I have created a template that might be what you are looking for: [https://github.com/David-Else/zen-typescript-starter-project](https://github.com/David-Else/zen-typescript-starter-project) Everything is using ES Modules, no messing about with legacy junk for you any more :) I have started to write some Docs in the readme.md , but they are not finished yet. I am using Fedora Linux with VS Code and the live-server extension along with the Chrome debugger extension. I can just run that and set breakpoints in VS Code and the whole thing pauses in the browser and VS Code so I can inspect stuff. It has taken me so long to get this all working how I want it! I am using Chromium rather than Chrome and it works fine. The template has Rollup in there for the final production version, but it is not needed for development. Just run the `"start-typescript-development"` script and it should all just work. If you have any suggestions for improvement, or problems please let me know. I am using it myself to build a game in TypeScript right now, that is why it has all the Mocha browser mocks hidden in the config. You can add your own tests easily in the test directory, and it will work with browser stuff like Canvas (fingers crossed)
&gt; Can the same not be achieved with Closure compiler in advanced mode? Of course you can, and even more than just minifying private members! Google Closure Compiler is awesome tool to minify/uglify/make optimizations for your code, all the more in advanced mode. My memories about Google Closure Compiler are inspiration for this project (I've seen how it works in advanced mode and I was amazed). But as you said it requires specific changes of the code. We're not Google. Last time I checked how to use Google Closure Compiler in project written in TypeScript I've faced with https://github.com/angular/tsickle. But running tsickle first and then Google Closure Compiler just doesn't work. I don't know to make it work together, and I don't know a living person who know how to do this. Unfortunately. If you know how to do this, please tell me and I will be happy. Google Closure Compiler does a lot of work and optimizations we want to have, but it requires sometimes a lot of work and changing the current DX and approach for development (afaik). &gt; There is a Rollup plugin to automate too: I'll try to play with it, thank you!
I wouldn't build on your ec2. Deploy the already built project to your ec2. I have had success with this
TypeORM, NestJS, class-validator, class-transformer
This is exactly what I need ! Could you please give me some info on how you did it ? Where did you create the global variable ? I tries in webpack.config.js because I think it's where you get webpack's environment variables, but my object is not accessible in my web page.
Thank you very much for this precious resource !
Option 1: Run the build using CodeBuild and save the artifacts to S3, then deploy the compiled code to your box. Option 2: Just use the babel-typescript plugin to strip out the Types at runtime and just use the Types while your coding locally to check for correctness
can u show me an example of option 2 please...
This is good! &amp;#x200B; My recommendation: Add `class-validator` and some sort of validation middleware. I honestly cannot think of a reason not to use it when you're in a ts+express environment. It feels *very* typescript-y to feel confident about the content of `req.body` &amp;#x200B; Also since you're already buying into viewless for SPAs, maybe add a CORS wildcard in development mode, as everyone who uses this will have to do that
Dojo! https://dojo.io
Actually, option 2 is not recommended - here's the plugin with a big warning against using in production: https://babeljs.io/docs/en/babel-node And here's the plugin for stripping the types out, just in case you're interested: https://babeljs.io/docs/en/babel-preset-typescript So, overall, I'd suggest building elsewhere (perhaps CodeBuild, or maybe just on your local machine) then export the resulting js files to your server. Side note ... TypeScript doesn't tend to use up too crazy an amount of RAM, so it's possible that there could just be a bug somewhere that's causing it to hang, or maybe just a weird edge-case with recursive types. Also, it might be worth looking at the TSC options and see if you can avoid it checking the types for all your modules too.
Hi guys, xpost from /r/javascript! Spent most of my weekend creating a Neural Network for snake üêç. Made using üëâ Typescript üëâ Tensorflow üëâ HTML5s canvas element üëâ React You can check it out over here: https://snaike.dries.io/ Source code: https://github.com/driescroons/snaike A video: https://www.youtube.com/watch?v=kBjSyOzhUYk A gif: https://gfycat.com/separateapprehensiveafricanparadiseflycatcher If you have any questions, let me know!
You just need to add variables to `window`. Then you can access them through the dev console in your browser. For example: ``` const foo = { bar: 'yay'; }; window.foo = foo; ``` Then in the console, you would be able to type `foo.bar` or `window.foo.bar` and see `"yay"`. Typescript might yell at you about `foo` not being a property of the class `Window`, but you could monkey patch it like this (there's probably a better way): ``` const foo = { bar: 'yay'; }; (window as Window &amp; {foo: typeof foo}).foo = foo; ```
I've never heard of it. I'm mostly wondering what Crui brings to the table that I can't already get from React or Vue.
Would you mind sharing a list of articles/tutorials u read?
All of the articles and repos are linked in the github readme! I'll add a more elaborate description for each reference linked. Make sure to star the repo for updates üòÄ
Thank you very much ! I feel dumb for not having thought about it ^^ I'll write `(&lt;any&gt;window).foo = foo`
You could look into front end masters though it‚Äôs a subscription site.
Only comment I have, is that original snake could change direction. I.e. going north can't change to south.
Another article compiled from the official changelogs.
Enums are used for many different things, but we can define them like this: En enum is a group of enumerable values. In other words it's a category for a finite number of elements. Ex: { YES, NO, MAYBE }, while those values could be represented using strings or numbers, it is easy more typesafe to use a datatype with a limited number of possible values.
In your particular case you could just write: &gt;characters.push(new classToConstruct(options.x)); Since javascript doesn't care about the number of arguments passed to a function.
Editor integrations for things like intelisence in VSCode
The snake learns pretty fast that you can't change direction unless you have length of 1.
Looking at how I did it, I used Object.defineProperty(window, "dev", {/* stuff goes here */}), but (window as any).dev = {} should also work
Also give [material-ui](https://github.com/mui-org/material-ui/) a look.
But TypeScript does and it complains loudly. I am trying to make my app type safe, but thanks for the input, you are correct.
Is your Webpack configured to emit sourcemaps? If your dist folder includes sourcemaps then the browser should pick them up automatically and the debugger tab should show TS instead of (compiled) JS, which will let you set breakpoints. When execution is paused you can alter state within the current stack context, e.g. pause the execution during the `MyGame.render()` function and you'll have access to all the members of your `MyGame` instance in the console. Of course this doesn't solve the issue of manipulating state from the console while running, but as you've already seen, you can attach global state / singletons to `window` with `(&lt;any&gt;window).gameInstance = myGame`.
Yes I have source maps, the only thing I lacked was the global variables which I solved with the `window` attributes. Thank you very much !
If you write closures instead of classes I think you can minify even more without any additional code transform since you're not typing `this.` everywhere and "private" variables can be minified normally since nothing else accesses them.
I enjoyed the read. I did something similar in Java and it‚Äôs interesting to see it spelled out in a different language
That was awesome.
Hey there, it's just normal that you never heard of it, I've been developing it for around 1 month and mostly during weekends ;) &amp;#x200B; I've been using React for quite some years and I've sometimes felt too constrained by it. I think React is super useful, but some of the architectural choice limit its usefulness. The thing that bother me most is the inability to somehow delay the unmounting of a Component. &amp;#x200B; I'm not well informed on Vue, but it also looks an amazing library/framework, even though I personally dislike the template based approach and feel more comfortable using a plain typescript. &amp;#x200B; As far as I can tell, the best advantage of CRUI over React is its core simplicity which achieve a great deal of flexibility and composability. A CRUI component is just a function: type Component&lt;C&gt; = &lt;N&gt;(dom: DOM&lt;N&gt;, context: C) =&gt; Rendered&lt;N&gt; DOM is just a thin abstraction layer on top of the browser DOM and it make sure that Components are easily testable and that further abstraction can be derived. The second parameter is just a Context that is automatically threaded down the tree. Rendered is just: type Rendered&lt;N&gt; = { node: N onMounted: () =&gt; PromiseLike&lt;void&gt; onUnmount: () =&gt; PromiseLike&lt;void&gt; unsub: () =&gt; void } This simple foundation has been more than enough to build something that is as useful as React &amp; Vue and in quite a short amount of time. &amp;#x200B; So I'll say that what you can get from CRUI that you can't from React or Vue, is a library that doesn't get in your way, but rather helps you achieve whatever you need ;) An example of this is how easy it was to add in-out transitions, either in CSS or through third party libraries, like GSAP. Same for the Suspense API. The cool thing is that anybody could have done it, without the need to wait for the library maintainer to actually cook up what you need. &amp;#x200B; As a bonus, CRUI reactivity is currently based on reactive streams and do not use the Virtual DOM, usually achieving better performance than React :) &amp;#x200B; That's said, what do and don't you like about Vue, React and CRUI?
with a presumptive clickbait title :(
It looks like writing a code in that way might be "a little bit" not-maintained sometimes. But if my aim was code-golfing I would be choose something like that, yeah. This project is about almost free optimizing size of generated code, not about minifying everything you have.
Of course. This is how they do business these days.
TypeOrm always need some
What do you want automated? Building a package and consuming it in a separate package, and seeing if that secondary package builds? Build errors are programmatically consumable and you can check to see if there are errors relating to missing typings.
Use lerna. https://github.com/lerna/lerna You can put your shared typings and functionality into a core subpackage that the others depend on.
Ive seen that mentioned elsewhere as well. I'll have a look into it cheers
I'd like to automate the process of moving an @types dependency to be a devDependency or vice versa, based on whether or not it's referenced in any of the .d.ts files emitted during compilation.
Nice! These insights will really help with a project I'm working on.
Awesome! You should post this over at /r/nestjs_framework!
man, i wasn't able to avail the free promo.
The similarities are not just that Microsoft made both - Anders Hejlsberg was/is the same lead designer for both languages.
Reddit\_free doesn't work
Yes it safe
Let me know what exactly you would like read about. I'm the author of that article.
Safely typed even.
Then why I typo?
We actually have a [prototype](https://github.com/exercism/java-analyzer/blob/master/src/main/java/analyzer/exercises/Twofer.java) for the Java track. What was your use-case?
But there are plenty of breaking changes. A few can be avoided with a config flag.
Upgrading from 2.5 to 3.1 has quite a few changes, read the release notes as your first compilation will report errors because it will validate things you may not required in the past. We constantly upgraded our project to minimise conflicts yet we found the sporadic type definition that needs to be regenerated because it breaks in the new tsc
[Here](https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md) is a list of TypeScript's "breaking changes" with each version. Go through all of them from 2.6 until 3.1 (or might as well go to the latest while you're at it) and make sure they do not apply to your project. If they do, update your project. You can also just do the update and see what happens. The new error messages, if any, may already be self-explanatory or easy to fix with the previous link as a guide. If you are legitimately unable to update your project to TypeScript 3.1, you can always just downgrade back down to 2.5.
You will hadly find transpilation issues, but you will get a ton of new typecheck errors (which is normal)
Well, fix it. It's not hard to paper over these "breaking changes". The only thing broken is compiler errors where there should have been before.
Looks pretty cool to me. It seems to hit most of the boxes that I care about. Now I just wish that I could find a server-side routing setup that had similar levels of type safety.
yah i would like to try this course fo free, bummer promo seems expired
Safe? What's the worst that can happen, an explosion?
or maybe even not, if you coded correctly
I don't have anything to add yet but I wanted to let you know that I wanted this as well, so thanks for sharing your findings.
Well, I think that there are not-so-many articles and tutorials on the AST trees. And looking into code with code is a really interesting topic. Right now I'm implementing something like a backward depedency checker, it works via regexes, after reading your article I realized that it is not so hard to rewrite it by parsing AST instead of using regexes and that it would be more "correct".
**Pardon the interruption.**
Please, stop writing on Medium... Cancer platform.
It‚Äôs not at all. It‚Äôs free to write. No ads. They have turned on subscriptions to monetise but you can always open in incognito mode
It's only that you see like 10% of the page when you open the article. Cookie agreement, App Ad and Sign in with Google bullshit take up the other 90%.
I like it. When you write an article feel free to put it somewhere else
Something I still haven't figured out for our own apps is how to share types between front-end and back-end. I've been able to do this with a node\_module, we're using ambient types and I have a .d.ts file that is just: \`\`\` export \* from 'common'; // has our core models, etc. export as namespace common; \`\`\` Now, I can use \`common.PersonModel\` and it's been HUGE having our front-end type-safe with our database models. But I really want type-safety on all the server endpoints. Our server and client folders are part of the same package.json but with separate tsconfigs, and if I try importing or referencing types from the server folder using relative paths, Typescript yells that I can't read files outside the rootDir, which makes sense. I'm considering trying to make our server its own node module which I can import, but wonder what other people do.
So we do have this and it‚Äôs due to the fact that we use graphql and auto generate types on the client for all the queries we use. An alternative is something like Lerna js.
I'm pretty sure you can import types outside of the root directory. I think I do it.
They literally hijack the browser history stack to make it harder for you to back out of their shitty platform.
Ah yes, you're absolutely right. Another example is that I often see people trying to match/find certain HTML using regular expressions, which is very difficult if not impossible depending on the RegExp implementation to do spec-compliantly. I often tell people to use a lexer/parser, but they then tell me "okay but how, I can't find much about it". If you have concrete example or question you'd like me to explore, feel free to ask!
Just use Lerna, and put 3 packages into it: server, frontend, common.
So you have some build step to generate the types? That would allow me to dump them in the client folder. I'm looking for an easy way to define types on the POST body or response type of an Express route. What's the tool you use? Maybe I can find more inspiration
Thanks I'll look into lerna
Graphql code gen. It has generators for lots of libraries. I think it has a mongo one too which is potentially the sort of thing you‚Äôre looking for. To make it get the types on the client you run a command in the command line. You could potentially just write a script that copies your server types to your client as well.
Never seen people so worked up. Haven‚Äôt experienced that with medium myself but who the f cares if there‚Äôs a site where you can‚Äôt hit the back button. I hope those are the worst of your problems.
What do you prefer?
Can confirm, lerna is wonderful for a TS-based mono-repo.
We define the types in the frontend package and use them in both places
Do you consume the types from the front end as a node module? Also, any pros/cons you've found by having frontend define the types? I for some reason would have assumed to define them in the back end near the api.
I believe it can be done with [project references](https://www.typescriptlang.org/docs/handbook/project-references.html)
It‚Äôs annoying to make 2 pr‚Äôs for coworkers to review on api change but it works great in the frontend and backend
If you're writing about full stack development, why not make your own blog? I don't mean this in a gatekeeping or put-up-or-shut-up way (making a static site doesn't prove anything) but really this is a sacred and beautiful tradition since the inception of the web.
Your audience (which you asked for by posting here) is giving you valuable feedback (about a component of your work you didn't expect) and you are responding like they're children ("you can play with the radio when you own a car"). I don't understand your reactions.
I think Medium is pretty scummy these days, especially around integration, but I also think of them as a distribution platform more than for publishing online. Writing a blog is easier than getting people to read it.
I made a blog entirely to avoid Medium. It really is an awful platform and your attitude stinks. Grow up, kid.
As recommend by me. I am still experimenting with the \`@typescript-eslint\` ruleset in relation to how it works with airbnb. It seems really good at the moment. &amp;#x200B; I recently ditched the ESLint VS Code extension and went back to just seeing the results on the command line, saying goodbye to all the red squiggles was liberating! \`\`\` "scripts": { "eslint": "eslint --cache -f unix --ext .ts src/ test/", }, "devDependencies": { "@typescript-eslint/eslint-plugin": "\^1.9.0", "@typescript-eslint/parser": "\^1.9.0", "eslint": "\^5.16.0", "eslint-config-airbnb-base": "\^13.1.0", "eslint-config-prettier": "\^4.3.0" }, \`\`\` \`\`\` { "extends": \[ "./node\_modules/eslint-config-airbnb-base/rules/best-practices.js", "./node\_modules/eslint-config-airbnb-base/rules/errors.js", "./node\_modules/eslint-config-airbnb-base/rules/node.js", "./node\_modules/eslint-config-airbnb-base/rules/style.js", "./node\_modules/eslint-config-airbnb-base/rules/variables.js", "./node\_modules/eslint-config-airbnb-base/rules/es6.js", "plugin:@typescript-eslint/eslint-recommended", "plugin:@typescript-eslint/recommended", "prettier", "prettier/@typescript-eslint" \], "parser": "@typescript-eslint/parser", "parserOptions": { "project": "./tsconfig.json" }, "plugins": \["@typescript-eslint"\], "rules": { "lines-between-class-members": "off", "no-empty-function": "off", "no-useless-constructor": "off", "@typescript-eslint/no-unused-vars": "off", "@typescript-eslint/no-useless-constructor": "warn", "@typescript-eslint/no-parameter-properties": "off", "@typescript-eslint/no-unnecessary-type-assertion": "warn", "@typescript-eslint/member-ordering": "warn", "@typescript-eslint/unified-signatures": "warn", "@typescript-eslint/explicit-function-return-type": \[ "warn", { "allowExpressions": true } \] }, "env": { "browser": true, "node": true, "mocha": true }, "globals": { "assert": true } } \`\`\`
 But now you don't get that dopamine boost when you clear all the swiggle lines away. That's like the only thing that keeps me going some days
No one cares if you like it. If they don't like it, they're not going to visit it, and half your audience vanishes. Not that it looks like you care smh.
You can also generate types with swagger
[https://github.com/krzkaczor/TypeStrict](https://github.com/krzkaczor/TypeStrict)
How about dev.to?
I wonder if there's a way to read these without having to visit the site - Like a script that will wget the page and strip all the medium BS out of it. I won't even open medium articles anymore.
I haven't used these hooks yet, but looking at the type definitions for [useDispatch](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react-redux/index.d.ts#L507) you probably need to pass the type of your thunkDispatch to it as a type parameter. @types/redux-thunk exports a [ThunkDispatch](https://github.com/reduxjs/redux-thunk/blob/master/index.d.ts#L20) interface. You could do something like: export type ReduxDispatch = ThunkDispatch&lt;IMyStoreType, any, Action&gt;; export function useReduxDispatch(): ReduxDispatch { return useDispatch&lt;ReduxDispatch&gt;(); } Customize `ReduxDispatch` to be as loosely or strictly typed as you prefer.
Thanks a lot! It worked!
Habr.com is one of the best
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner) with focused self promotion spam like this that clearly breaks [reddits self promotion rules](https://www.reddit.com/wiki/selfpromotion) See for yourself. Vote and report accordingly.
I do care. Which is why I post there. I like the extra reach that Medium gives me.
The platform I posted on is not the feedback I‚Äôm looking for. It‚Äôs code feedback I‚Äôm open to. Thanks for trying though.
I am so proud of you for creating your own blog. I could create a blog off Medium or post to something like dev.to. But I like the additional reach it gives me, kid.
Yes, I'm saying that was naive and your responses (including that one) have been really confusing and disappointing.
How did I confuse you? I like Medium. No ads. They extend my reach. I understand it‚Äôs annoying when they ask you to sign up for premium. It‚Äôs a hit I‚Äôm willing to take. It has its pros and cons. That much should be clear.
Some bad JavaScript developers in there shitting excuses
Sometimes I think about how I could prevent 100% of all the bugs by working in the field instead.
Without more info on how they define "bug" and in what context the bugs were found and fixed it's hard to judge this slide. I'd be interested to see a breakdown of time spent fixing the bugs instead of the raw number of bugs fixed.
Typescript is definitely useful for businesses, but I personally hesitate learning it as an individual because it's clearly a victim of its own success: ECMA will deprecate it and every feature it brings.
There are tons of bugs in the field.
ECMA can't deprecate it because it's not an ECMA standard.
I haven't seen ECMA indicate any interest in adding even 10% of what TypeScript offers. I'm not sure where you're getting that argument from, but I am willing to be proven wrong.
&gt; deprecate: be usable but regarded as obsolete and best avoided, typically because it has been superseded. Deprecation doesn't require any kind of intra-relation. We can also use the word "replace" if it satisfies you.
Just an inference. TypeScript is exploding in popularity, it doesn't seem likely that ECMA will ignore that, and it's definitely helpful for the language to reduce external dependencies. They can easily integrate elements of TypeScript and functionally execute it with in the course of one standard, like CoffeeScript. You may disagree with me, and that's fine. I'd say it stands likely, though.
&gt;who the f cares &amp;#x200B; &gt;you can always open in incognito mode &amp;#x200B; &gt;When you write an article feel free to put it somewhere else &amp;#x200B; &gt;Thanks for trying though &amp;#x200B; &gt;kid. &amp;#x200B; These are confusing because no one has been rude to you. These are people whose opinion you asked for. And sure, you got feedback you weren't prepared for (which is the highest rated comment, so obviously people here do actually care), but your responses are just out of place. Apparently anyone with a dissenting opinion is a child to you, but instead of taking the high road you are acting like a child yourself. If you don't want to talk about this then don't respond - that would have been far more respectful than your choices so far.
I understand, but we are exactly the people who should not be just accepting the status quo when we don't agree with their strategies. It is our community (informed Internet users) continuing to post there which keeps it a powerhouse. There are other options. We can build more options. And I don't believe that a few hundred extra claps is worth their shitty platform. That's my vote.
Definitely one of my favorite reposts
It's always important to point out that TypeScripts type-system does not allow to specify immutability, which really is a pity.
Very good point. Have an upvote!
You too kind stranger
The first comment is cancer platform. That‚Äôs first rate Reddit trolling
And the kid thing. I was quoting the comment before. I didn‚Äôt start calling people children üòÇüòÇüòÇ
Another library that does not make use of the `strict` flag. Why use TypeScript for type-safety, but then not make use of the type-safety features?
Again, exactly my point. You seem to feel quite self-righteous about acting just like the people you are shitting on.
So.... you're saying the knowledge is transferrable? Sounds ideal
Do you write perfect code every time? Nobody does. Even the greatest minds make mistakes. JavaScript is a dynamic language. There's no safety net. Only in runtime you will know if it works. Companies like Airbnb have big codebases. It's really hard to make constant changes without breaking things. I'm assuming (because you're in this subreddit) that you're aware why TypeScript is useful. I love it when TypeScript catches those stupid mistakes like accessing a property that doesn't exist or forgetting await when I call an async function. That saves me precious time. It's the internet, you are free to say what you want and I don't blame you. Please think before you write a comment like that (like writing code). Cheers!
I think you are mistaking the polyfilling that TS with its typing, TS already implements stage 3 Emma‚Äôs script features so in that sense it‚Äôs not crazy, its just ahead of the curve. To quote you, you may disagree with and that‚Äôs fine. I‚Äôd say it stands likely though.
Oh go fuck yourself, ‚ÄúOnly bad programmers make mistakes‚Äù is such total bullshit. It‚Äôs also the attitude that people use to justify doing things that aren‚Äôt safe because ‚Äúthey don‚Äôt fuck up‚Äù and then they do.
ECMAScript won't add types.
TS is amazing. We have started porting old legacy code to TS and runtime exceptions are down drastically. Basically we have issues when the server sends wrong kind of json. I truly think TS is one of the best things that have happened to frontend and node development.
I love TypeScript, I'm a huge fan. But honestly, this sounds like they had poor JS discipline prior to implementing TS?
QuickType is amazing for this (and it supports about a dozen languages, generates both interfaces and runtime validation, is clever enough to infer date times and enums (if you want them)). It has a nice vscode plug-in as well. https://app.quicktype.io Not affiliated just a massive fan, it made writing C# Clients again a REST API vastly more pleasant.
Yeah this just smells of cheap outsourced frontend work, or junior devs led by non-technical PMs thrown into the fire with little oversight.
Found the 100xer.
The main feature of typescript is static typing. I'll put up a wager that TC39 never ratifies any form of static typing.
In OP‚Äôs defence, 38% is a HUGE number. I understand how much value types bring to a large code base, but if you don‚Äôt have types, you should have a sufficient amount of test coverage to not allow this to happen. Not having that coverage is a failure.
Check out io.ts for run time type validation. Should make those issues a lot easier to identify on the client side.
I'm currently arguing pretty strongly for TypeScript at work (the stated argument of some folks is they dislike it because it turns JavaScript to Java) , so I have a new piece of evidence to use in my arguments.
Here's a study that actually specifies methodology and concludes that TypeScript is in fact valuable for identifying bugs, as well as quantifying it. https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/
The TS team actively avoids introducing anything that might conflict with future ES standards. Your prediction will never happen.
Thought i was in R/programmingcirclejerk for a minute
The other 90% could be prevented by using semicolons.
"turns Javascript into Java"? I would love to hear the logic behind that argument O_o
Lol they must REALLY hate strict typing
Who hurt you?
That speaks to how much better typescript is as a language. &gt; Correct JavaScript can only be written by extraordinarily experienced teams with everyone cross checking each other's work. Or we can use another language. - One that makes the work easier. - One that makes mistakes easier to detect. - one that prevents mistakes before they happen - one in which one junior developer can be as productive as team of 10-year veterans.
Typescript is just JavaScript. Except when you feel like it, you can add a `: Number` after a parameter name. You can get as much or as little of it as you want. It's like adding types to python. you can still write the exact same code you wrote before, except now you are allowed to add an annotation.
https://github.com/airbnb/javascript They are using semicolons.
All you need is some discipline and there will be zero bugs? Non-nullable types catch a lot. I'm sure you've heard of the "billion dollar mistake". https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions
hell even a linter than errors on build helps a ton
Nobody, in fact I mostly like when this happens at companies that I am not employed at, because it means theres more chance they will have to hire me (or someone like me) to fix their mess ;)
38% of the bug could be prevented by refractor. You can always look at a bug, and say that's preventable.
38% is not a small number, and yeah I use typescript too.
You can specify it, but it‚Äôs overly verbose
No, you can not. There is no way to specify immutability in the type system.
You cant say everything is immutable, keep it that way, but you can say this object is immutable. You could also define your own helpers to allow you to create new immutable object from previous ones, but again, it is more verbose than a language that naturally supports it, like purescript
&gt; object is immutable Again: You can not specify immutability in TypeScripts type-system. Please provide an example if you believe so.
I think /u/frankleeT means that TC39 will add typing to Ecmascript. I think that's misunderstanding the benefits of TypeScript though, which is: catching potential errors at built time, rather than at runtime. Since TC39 specified Javascript behaviour at runtime, whatever they might introduce won't make TypeScript superfluous.
Even good discipline tends to lead to defensive programming. It's also much harder to onboard new devs when they have to ask what this endpoint returns, what goes into this function. How often have you seen a perfectly well documented (e.g. JSDoc) JS codebase? I've literally never come across one at work or in the wild.
Sounds like they have the common misconception that TypeScript inherently forces you to adopt a more object-oriented approach full of classes and such.
Hey AirBnB if you are reading this, hire me. Sincerely, Year 1 student
Just like most of you guys here, I've got a very good opinion of TypeScript. For a while now, we've been developing an open-source framework for automated E2E software testing\* and, in the beginning, we were using JavaScript. Even though JS is an untyped language, we were able to keep this framework's architecture clean. Why? Because only two people were working on the project. :D As you can probably guess, when the framework got bigger and more and more people started helping us with it, problems started arising. Long story short, we decided to move to TypeScript and while it, of course, wasn't totally painless, we couldn't be more happy with the final result. In fact, my colleague Adam wrote a short article on the subject, so if you're thinking about moving some projects to TS, you can read about our successes and failures here: [Why did we convert our open-source tool from JavaScript to TypeScript](https://tsh.io/blog/convert-from-javascript-to-typescript/). &amp;#x200B; \* ‚Äì The framework is called Kakunin. It's not really important for the whole story, as I didn't come here to advertise it, but if you're curious, here's the link: [www.kakunin.io](https://www.kakunin.io)
You have to define types in java and don't in JS
It takes more thought to write, but is waaaay less work to maintain. Even just the presence of intellisense makes jumping into an unfamiliar system no big deal.
Might be a misunderstanding of the \`interface\` keyword.
I love that the community is investing in this area! I feel that similar solutions can be achieved using only standard tooling though--there are pretty established json schema to typescript interface compilers and json schemas can validate at runtime with more powerful validation than just type checking. JSON schemas are also declarative, as opposed to the imperative code inside a type guard JSON schemas can also be produced by their associated API. Why not optimize the flow around JSON schema (with TS and JS) instead of RTO?
Here is what I currently have: interface IAnimArgs { indexOrder: number[]; down?: boolean; originalIndex?: number; currentIndex?: number; y?: number; } interface IAnimProps { y: number; scale: number; zIndex: string; shadow: number; immediateTransition: boolean | ((transitionTarget: string) =&gt; boolean); } type IAnimFn = (index: number) =&gt; IAnimProps; const animFn = ({indexOrder, down, originalIndex, currentIndex, y}: IAnimArgs): IAnimFn =&gt; ((index: number): IAnimProps =&gt; ( down &amp;&amp; index === originalIndex ? { y: (currentIndex! * 100) + y!, scale: 1.1, zIndex: '1', shadow: 15, immediateTransition: (transitionTarget: string) =&gt; transitionTarget === 'y' || transitionTarget === 'zIndex', } : { y: indexOrder.indexOf(index) * 100, scale: 1, zIndex: '0', shadow: 1, immediateTransition: false, } )); const DraggableList = ({ items }) =&gt; { const indexOrder = useRef(items.map((_, index) =&gt; index)); const [ springs, setSprings ] = useSprings(items.length, animFn({ indexOrder: indexOrder.current })); const gestureBinds = useGesture(({ args: [ originalIndex ], down, delta: [ , y ] }) =&gt; { const currentIndex = indexOrder.current.indexOf(originalIndex); const currentRowIndex = MathService.clamp(Math.round(((currentIndex * 100) + y) / 100), 0, items.length - 1); const newOrder = ArrayService.swapItems(indexOrder.current, currentIndex, currentRowIndex); setSprings(animFn({ indexOrder: newOrder, down, originalIndex, currentIndex, y })); if (!down) { indexOrder.current = newOrder; } }); return ( &lt;ul&gt; {springs.map(({ zIndex, shadow, y, scale }, itemIndex) =&gt; { const item = items[itemIndex]; return ( &lt;animated.div {...gestureBinds(itemIndex)} key={item.guid} style={{ zIndex: 1, boxShadow: shadow.interpolate(s =&gt; `rgba(0, 0, 0, 0.15) 0px ${s}px ${2 * s}px 0px`), transform: interpolate([ y, scale ], (y, s) =&gt; `translate3d(0, ${y}px, 0) scale(${s})`), }} &gt; {item} &lt;/animated.div&gt; ); })} &lt;/ul&gt; ); }; Which causes a type error when calling setSprings(animFn({ indexOrder: newOrder, down, originalIndex, currentIndex, y })); Which I'm assuming is due to the function currying... Argument of type 'IAnimFn' is not assignable to parameter of type 'number'.ts(2345)
Here are some more for you: * Of the [top 10 most common errors in JavaScript projects](https://rollbar.com/blog/top-10-javascript-errors/), 8 are type errors * The Blub Paradox‚Ñ¢ [[source]](http://www.paulgraham.com/avg.html): &gt;Programmers get very attached to their favorite languages, and I don't want to hurt anyone's feelings, so to explain this point I'm going to use a hypothetical language called Blub. Blub falls right in the middle of the abstractness continuum. It is not the most powerful language, but it is more powerful than Cobol or machine language. &gt;And in fact, our hypothetical Blub programmer wouldn't use either of them. Of course he wouldn't program in machine language. That's what compilers are for. And as for Cobol, he doesn't know how anyone can get anything done with it. It doesn't even have x (Blub feature of your choice). &gt;As long as our hypothetical Blub programmer is looking down the power continuum, he knows he's looking down. Languages less powerful than Blub are obviously less powerful, because they're missing some feature he's used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn't realize he's looking up. What he sees are merely weird languages. He probably considers them about equivalent in power to Blub, but with all this other hairy stuff thrown in as well. Blub is good enough for him, because he thinks in Blub. &gt;When we switch to the point of view of a programmer using any of the languages higher up the power continuum, however, we find that he in turn looks down upon Blub. How can you get anything done in Blub? It doesn't even have y. * The Blub Paradox‚Ñ¢ in the context of convincing people to use TypeScript [[source]](https://www.jonathanturner.org/2016/01/rust-and-blub-paradox.html): &gt;As a programming language PM at Microsoft, I worked on TypeScript, a typed version of JavaScript. Without fail, if I was speaking to an audience of predominantly JavaScript developers, I would get many frowns as I tried to enumerate the advantages of adding a bit of type-checking to JavaScript. Even if it was optional. Even if I showed half a dozen powerful advantages. As Paul notes, it just looked ‚Äúweird‚Äù. To a JavaScript developer, TypeScript would often just seem like a language that was equally expressive with ‚Äúhairy‚Äù stuff thrown in. &gt;As I talked to more language PMs, and I met more and more people at conferences, I learned that Paul‚Äôs observation was not only accurate, it was also surprisingly universal. Most programmers will struggle when looking at a new language they don‚Äôt use. Often, they‚Äôll have allergic reactions to features that are foreign. It takes time to work with the features enough to understand why they aren‚Äôt just unnecessary ornamenation gumming up the works. &gt;In short, the Blub Paradox is something that as programmers we actively need to assume we‚Äôre falling into and then work to get ourselves out of. If you want to make them willing to try TypeScript, you'll probably need to point this out to them and make them critically challenge their own knee-jerk reactions.
JSON Schema is honestly not a very good specification.. the optional default value doesn't even has to be valid according to the schema, how crazy is that.
are there cases where we still need iframes? (serious question)
Yuppppp, my company has a ton of web apps that don't play well together. We use at least 2-3 iframes per site
What does this do that postmessage API does not
Maybe not 100% immutability but you can define all properties as `readonly`, which I would argue gives you most of what you need. Though you have to be careful because typescript allows you to pass one type to a losely compatible type, then you can modify based off of the loser type even though you're also actually modifying the original outside of it's original type definition.
there are several projects out there that will generate typescript declarations and API clients for various JS/TS frameworks for you, which can help close that gap. NSwag's libraries for doing this on .NET WebAPI projects are pretty impressive. Their clients will construct instances of the generated classes when processing the response JSON (so instanceof checks will work), and it automatically parses dates.
And that's exactly the point. readonly does not mean immutable. It just means **via this interface** you can't modify, but as you said: It's compatible to mutable types. There's no way to mark a type as immutable. This compiles and works just fine: interface MutableData { data: string } interface ImmutableData { readonly data: string } function mutdateData(data: MutableData): void { data.data = 'fooo'; } const immutableData: ImmutableData = { data: 'bla' }; mutdateData(immutableData);
Very interesting. Do you know if that issue is in the latest draft and if it's being tracked somewhere?
https://json-schema.org/latest/json-schema-validation.html#rfc.section.10.2 &gt; This keyword can be used to supply a default JSON value associated with a particular schema. It is RECOMMENDED that a default value be valid against the associated schema. `RECOMMENDED`!= `MUST` I don't know if it is tracked somewhere, I don't follow the extraordinary slow development of the JSON spec. But this seems to be an intentional decision.
# 1. &gt; You should always listen to responses on YOUR window and send them on the OTHER window (iframe, opener, parent, worker, etc). If you try to listen to a message on the OTHER window and the origin differs from the current one, an error will occur. What are you trying to say? Only ever call `window.addEventListener(...)` and never call `window.parent.addEventListener(...)` or `iframe.addEventListener(...)`, or are you trying to make a deeper point? # 2. Any insight as to how to unit test this? I have a react app that I have failed to successfully unit test this scenario with.
This is just plain bad style. By inheriting from a class, you specialize the type - your new class is the base type, but also something more specific. But with your code a `SavedUser` would be a `PendingUser` at the same time. This doesn't make much sense, does it?
Thanks for the reminder! &amp;#x200B; I'm forking this library and improving it, so, I have some work to do.
&amp;#x200B; &gt;But with your code a SavedUser would be a PendingUser at the same time. This doesn't make much sense, does it? &amp;#x200B; Yes. It's a basic OO principle, a \`Dog\` is an \`Animal\` at the same time. If you're suggesting that hierarchy doesn't fit my use case, it's possible perhaps I'll find that something from a \`PendingUser\` drops an a \`SavedUser\` isn't a superset of it. I'm not too worried about that as I'm more trying to figure out a coding style problem than worry about how I'm modeling my data. If it helps to be more generic we could think of it like this: Pretend I have an assembly line that makes cars and boats and I'm writing software for the robots or something. We start off with just the engine (why? doesn't matter, that's how the factory works) and then later we add a part to make it specific depending on what the next available part is: \`\`\` class Vehicle (engine: Engine) { makeCar(wheels: Wheel\[\]): Car{} makeBoat(rudder: Rudder): Boat {} } class Car extends Engine () {} // .. used like this const vehicle = new Vehicle(engine) const nextPart = getNextPart() if(part is a rudder){ const car = vehicle.makeCar(); }else{ const boat vehicle.makeBoat(); } \`\`\`
You're doing the same mistake again. A car HAS an engine, but it IS NOT an engine. A more fitting example would be `class Lamborgini extends Car {}` or something. And then it's still relevant what I said: Every inherited class is responsible of providing all constructor arguments to the base class. For the inherited class to accept an instance of the base class in the constructor doesn't make much sense generally (and especially here).
&gt; And you're doing the same mistake again. A car HAS an engine, but it IS NOT an engine. Sorry, typo. `Car extends Vehicle` &gt;Every inherited class is responsible of providing all constructor arguments to the base class. For the inherited class to accept an instance of the base class in the constructor doesn't make much sense generally (and especially here). Yes I know. I'm asking how I can provide those parameters in a clean way. &gt;Also why would a vehicle be responsible of creating cars or boats? Why? Because they could. I'm playing around and trying to make this work. Why? Because I don't want to make a factory to create my car. Why? Because the parent class already has all the properties defined. Why? I like types that tell you what to do. So when you type `vehicle.` you get intellisense that says "this can become a boat or a car" instead of having to find a utility function called `vehicleToBoat(vehicle): Boat`. &gt;IMO you're completely over-complicating things. Maybe but I didn't ask for your opinion. I asked if there's a way to pass the properties of a class into it's own constructor without listing them out. I made it very clear that I think it might be too complex and boilerplate-y but I'm trying to figure out options for a specific to a data mutation and seeing what option I like better.
&gt; Yes I know. I'm asking how I can provide those parameters in a clean way. The clean way? class Vehicle { constructor(vehicleProp1, vehicleProp2) {} } class Car extends Vehicle { constructor(vehicleProp1, vehicleProp2, carProp1) { super(vehicleProp1, vehicleProp2); } }
yeah I get that. Legacy stuff that doesn‚Äôt get updates. But I meant more like, is there anything that cannot be solved unless using iframes
Just a clarification: I've only submitted this URL to this subreddit, I'm not the author of this piece.
The English link for the readme gives a 404 :(
io-ts is also worth checking out.
My company uses iframes for most of our apps. It could be solved without iframes, but that's not how it's solved. And it's probably not changing anytime soon. Sometimes that just be how they do.
&gt; it means that your files stay plain old Javascript What happens if my JavaScript is inside script elements in HTML documents? I want to upgrade to typescript, but I can't let anyone know it's typescript. I would be okay with changing it to: &lt;SCRIPT language="typescript"&gt; //... &lt;/SCRIPT&gt;
react-spring typing's for typescript have been shit for awhile, until they're fixed just cast as any, and add a TODO.
If your team members will not notice those added files, then it's time to re-evaluate your choice of workplace.
I'm sorry, I'm not the author, I've only submitted the link. I notified author of the original, I hope he will fix it.
can you provide a link to that? is this what you mean: [io-ts](https://github.com/gcanti/io-ts) ?
No worries! I am really interested in this lib so would love English docs. I‚Äôve found a similar one called Windtalk and I‚Äôm wondering what the differences might be.
Browsers don't support TypeScript. You have to preprocess the files with tsc, then include the resulting output in your HTML.
Think anyone will notice every page in the website getting a major overhaul?
Thanks so much, you were completely right. You rock.
Your code does not render properly in the good Reddit design. To properly format the code have each line indented by 4 spaces, and have an empty line before and after the code.
I did as you asked, is it OK now?
Now it's readable in the good Reddit design, yeah.
Personally I prefer plain objects and functions over classes. There are simply less gotchas to be aware of, e.g. the `this` handling. For example: console.log(zombie instanceof Zombie); // true This doesn't has to be `true`. Take this example: const fakeZombie: Zombie = { x: 0, y: 0, name: '', renderer: new BitmapRenderer(), render: () =&gt; {} }; console.log(fakeZombie instanceof Zombie); // falsse I'm also an advocate of functional programming, where you usually keep your data structures immutable. The code turns so much easier to reason with, and the flow of data is more clear.
Thanks for the feedback. I agree that often functions and objects are easier to reason about than classes, and less boilerplate, but as TypeScript is primarily an OOP language, when would you use classes? I am currently thinking whenever inheritance based polymorphism is beneficial is the main use case.
&gt; as TypeScript is primarily an OOP language ... it's not.
Well they took JavaScript and added all the OOP features it missed. I suppose this does not make it an 'OOP' language, but we would just be debating semantics :) Maybe we can just agree it is 'more of an OOP language' than JavaScript.
&gt; Well they took JavaScript and added all the OOP features it missed. Like...? JavaScript had classes already, that's nothing that TypeScript added.
1. Interfaces, the most vital of all 2. Private properties (to allow proper encapsulation, not some closure hack) 3. Abstract classes 4. Abstract properties 5. Abstract methods
Those all 5 are just type information.
Why does that matter? I am talking about language features, not the compiled code.
Just trying to clear up that harmful misconception that TypeScript is primarily an OOP language. ü§∑üèº‚Äç‚ôÇÔ∏è
Title is just click bait... :) ‚Äöeveryone‚Äô will notice only that nothing‚Äòs gonna break.
You don't have to change the HTML. Just make sure the resulting file has the same filename. üëç
Yeah, sorry, I got interrupted when I was writing the comment so I never dug up the link.
Thanks for taking a look. Yeah - don't know of anything off the top of my head that would be the equivalent on the server.
Now there is a documentation site for the project too: [type-route.org](https://type-route.org).
What do you mean a typescript object? An object that respects a typescript interface? There is no such thing available once your code is complied, you'd need to write your own methods to traverse the objects and verify integrity. Typescript will help during development of this.
That's just your opinion. I never had problems with wrong types using inversify or my library. You can keep hard coded dependencies, that's fine for me. I don't want them. ;)
Exactly.. I'm aware of the above. Sorry for the lack of clarification. I mean a typescript object instantiated in TS and validated against an interface. If it's created in TS it's harder to break the interface definition. I think with the TS reflection stuff you can find this at runtime and there must be a project that does it for me.
Look up io-ts
debatable, something always breaks
The type inference is good but not that good üòÖüôà
I use a tool that converts TypeScript interfaces into a JSON schema, then use a JSON schema validator. The code generation is all wrapped up in our build process.
This is correct though. The `value` object could have getters that are stateful and return undefined for some values. If your type does not guarantee that it will never be undefined then calling the getter once and then using that (so storing in a variable) is the only way to be sure.
You could rewrite it as "fn!()" since the compiler cant see you already did the null check. Otherwise, if `fn` is of type `Function | undefined`, you can use a utility like this to get the compiler to agree with you that it can't be undefined. /** * Used to assert that a value is not null. Throws an error if the value is null. */ export const notNull = &lt;T&gt;(x: T | null | undefined, message?: string): T =&gt; { if (x === null || x === undefined) { throw new TypeError(message); } return x; }; Rewrite "const fn = value[sub]" to "const fn = notNull(value[sub])" And then the if check becomes if (notNull(fn) {
I‚Äôm no Ts expert (or even Js) but just changing all your .JS to .Ts files is totally fine, you‚Äôll get warning errors but your app isn‚Äôt going to break. Of course you have to configure the tsconfig file properly. Just built my first Ts app and I think it‚Äôs cool.
Dude.. URL? :)
The second screenshot is exactly like the first one but i assign \`value\[sub\]\` to a constant and then it works without an error. So "const fn = value\[sub\]" works. "value\[sub\]!()" would be a option, but i forbid it to myself in this library ;)
[https://github.com/microsoft/TypeScript/issues/11483](https://github.com/microsoft/TypeScript/issues/11483)
This sounds logic. The first time i got this explained and i understand it :)
Typescript doesn't use this reasoning though, and will happily narrowing other things that could be getters.
There is a different in TypeScript between strong access and direct property access. You need to type your things for the use case you‚Äôre coding.
Check out class-validator and class-transformer. Both are great libs to handle object validation/transformation. You write a typescript class and define the restrictions with decorators. With class-transformer you can then create an instance from a plain object or json string.
I have no idea what strong access and direct access are...but the reason this example doesn't type check is because of perf, not correctness.
I meant string.
If you've already made a runtime assertion that it is not null I see no problem with telling the compiler explicitly that it is not null with `!`
Oh, glad then that storing the reference can make the compiler happy. I must have been switching between the two screenshots without realizing it.
Yeah this is probably one of the more controversial features where TypeScript and Flow differ, actually. TS would be fine with the first check had they implemented it, but like they say in the issue you linked, it would be too costly.
But this is not related to the issue. interface Foo { d: string | number; } function bla(f: Foo) { if (typeof f["d"] == "number") { const d = f["d"]; // Narrowed to number } else { const d = f["d"]; // Narrowed to string } } Using string access, but narrowing still works.
This should work in TypeScript 3.5. Which version are you using?
No. As Poltras says the object property could change the value it is returning. If it is a getter it could return undefined after the first result i tested. I was never thinking about that, but it is logic.
You probably didnt get the point of the post. He showed that the control-flow analysis sometimes doesnt kick in depending on the type of the variable, and you have to help the compiler by reassigning it.
I was on phone so it was harder to explain. If you do (see [here](https://www.typescriptlang.org/play/#src=interface%20Foo%20%7B%20d%3A%20string%20%7C%20number%3B%20%7D%0D%0Afunction%20bla(f%3A%20Foo)%20%7B%0D%0A%20%20%20%20const%20x%3A%20string%20%3D%20'd'%3B%0D%0A%20%20%20%20if%20(typeof%20f%5Bx%5D%20%3D%3D%20%22number%22)%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20d%20%3D%20f%5Bx%5D%3B%0D%0A%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20d%20%3D%20f%5Bx%5D%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A)): ``` interface Foo { d: string | number; } function bla(f: Foo) { const x: string = 'd'; if (typeof f[x] == "number") { const d = f[x]; } else { const d = f[x]; } } ``` You'll see that `d` becomes `any` in both cases. If you remove the typing you'll see it works like you said. That's because the typing is different. Now in OPs case, he could solve it a few ways. I copied a simplified example of OP's [here](https://www.typescriptlang.org/play/#src=interface%20Foo%20%7B%0D%0A%20%20%20%20%5Bname%3A%20string%5D%3A%20string%20%7C%20(()%20%3D%3E%20number)%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Afunction%20doTheThingJooLee(value%3A%20Foo)%20%7B%0D%0A%20%20%20%20for%20(const%20sub%20of%20Object.getOwnPropertyNames(value))%20%7B%0D%0A%20%20%20%20%20%20%20%20if%20(typeof%20value%5Bsub%5D%20%3D%3D%3D%20'function')%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Will%20print%201%20and%202%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20console.log(value%5Bsub%5D())%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0AdoTheThingJooLee(%7B%0D%0A%20%20%20%20subscribe%3A%20()%20%3D%3E%201%2C%0D%0A%20%20%20%20maybeSubscribe%3A%20()%20%3D%3E%202%2C%0D%0A%20%20%20%20notSubscribe%3A%20''%2C%0D%0A%7D)%3B%0D%0A) if you want to play with it. The cleanest way is to store it in a variable and use that forth, like in the post. That's what I do. Another way is to properly type your interfaces and remove the use of string index signature entirely, like [here](https://www.typescriptlang.org/play/#src=interface%20Foo%20%7B%0D%0A%20%20%20%20subscribe%3F()%3A%20number%3B%0D%0A%20%20%20%20maybeSubscribe%3F()%3A%20number%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Afunction%20doTheThingJooLee(value%3A%20Foo)%20%7B%0D%0A%20%20%20%20if%20(value.subscribe)%20%7B%0D%0A%20%20%20%20%20%20%20%20console.log(value.subscribe())%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20if%20(value.maybeSubscribe)%20%7B%0D%0A%20%20%20%20%20%20%20%20console.log(value.maybeSubscribe())%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20v%20%3D%20%7B%0D%0A%20%20%20%20subscribe%3A%20()%20%3D%3E%201%2C%0D%0A%20%20%20%20maybeSubscribe%3A%20()%20%3D%3E%202%2C%0D%0A%20%20%20%20notSubscribe%3A%20''%2C%0D%0A%7D%3B%0D%0A%0D%0AdoTheThingJooLee(v)%3B%0D%0A). This is not always possible or easy to follow/read. Another is to use `any`, but this is not recommended. Also I think TypeScript 3.3 fixed some of it (not all), though I'm slightly unsure of which version actually had the fix as I skipped a few minors.
3.5.1 in strict mode. But like Poltras says it could be that the property is a getter and returning some other value with the second access.
&gt; it could be that the property is a getter and returning some other value with the second access. While this sounds logically (and is true), it is completely unrelated. class Foo { get bar(): string | number { return Math.random() &gt; 0.5 ? "string" : 0; } } const foo: Foo = new Foo(); if (typeof foo.bar === "number") { const n: number = foo.bar; console.log(n); }
While it is true what you say, it is not the reason for why this is not working. This compiles just fine, but produces wrong results at runtime: class Foo { get bar(): string | number { return Math.random() &gt; 0.5 ? "string" : 0; } } const foo: Foo = new Foo(); if (typeof foo.bar === "number") { const n: number = foo.bar; console.log(n); }
Are you using Angular by chance?
I don‚Äôt have hard-coded dependencies either. There are ways of doing this without missing the point of static typing.
dang... why is this working and why dosn't my snipped work? I can't get it to not(!) compile. ^^ ``` class Foo { get bar(): (() =&gt; void) | undefined { return Math.random() &gt; 0.5 ? () =&gt; undefined : undefined; } } const foo: Foo = new Foo(); if (typeof foo["bar"] === "function") { foo["bar"](); } ```
yea i have answered in the other tread. I am currently thinking that... no i don't know what i should think :D
tell me more :)
No. I use Preact and i am working on a dependency management similar to InversifyJS (but more lightweight). This is from a plugin to automatically subscribe and unsubscribe to "update trigger" of services.
Just assign the value to a constant and then do "typeof" with it.
See my other reply but it‚Äôs most likely that you‚Äôre using string indices which TypeScript cannot resolve. This is using property access directly.
hm i don't get the point. [foo.bar](https://foo.bar) is compiling and foo\["bar"\] is compiling too. But in my start post it isn't. I even tried to make an interface similar to that I used for the code in my start post, but even that compiles. You said that it could be a getter which could return undefined or a function and it is not garanteed it is a function after the type test. That sounds very logic but now I really do not understand anymore why my initial code does't compile but this code does.
hm ok, this does not compile because now `foo[y]` is possible undefined. ^^ ``` let x = 1; class Foo { get bar(): (() =&gt; string) | undefined { return x++ === 1 ? () =&gt; "happy" : undefined; } } const foo: Foo = new Foo(); const y = "bar"; if (typeof foo[y] === "function") { foo[y](); } ``` the difference is only ``` const y = "bar"; if (typeof foo[y] === "function") { foo[y](); } ``` instead of ``` if (typeof foo["bar"] === "function") { foo["bar"](); } ```
So i now think that typescript compiling fails because it does not recognize that it checked `foo[y]` before but it does if it is written with `foo["bar"]`. So typescript does not show me the error because the property could possible returning something else then i checked before. It shows me the error because it can't remember it checked it before. Right?
I agree. Even when `!` seems safe, I've ultimately regretted using it. If you're using TypeScript, then in my opinion being extra careful in times like these matches your overall intentions with the code base.
There are a lot of options. In small-to-medium projects it is sufficient to create a factory object that knows how to construct an instance of all the components in the app, by forwarding to their constructors and supply many (or all) of the constructor arguments by calling its other methods. Thus high-level components are built out of lower level ones. But also each component can be directly constructed by a unit test, passing it mocked dependencies.
Haven't tried them but there are various libraries that are inspired by Elm's JSON decoders. For instance: [https://github.com/gaku-sei/ts-json-decode](https://github.com/gaku-sei/ts-json-decode) [https://github.com/ooesili/type-safe-json-decoder](https://github.com/ooesili/type-safe-json-decoder)
That's hard coding dependencies for me. Sure you pass them by constructor instead of directly assigning them, but they are still hard wired. I like it to rebind my dependencies to mocks and to not care about how they get resolved. I worked at bigger projects with all this factories and it was a mess to replace them. Some dependencies where passed over and over again from one to another component. Never again. If you have a better solution i would really give it a try. I know that they are lose wired and it would be nice if a Symbol would know which type it represents (that is the only problem here). But that can not be archived, and it is no big deal because such a heavy mistake will throw an error and crashing your app before release. Sure it isn't perfect, but it is way better than passing dependencies by constructor. And like i said, i never got that problem and i used InversifyJS now for over one year.
TypeScript will only narrow (refine) property accesses if it statically knows *exactly* which property you are referring to. In \`foo.bar\` and \`foo\["bar"\]\` it knows by inspection that you must be accessing the \`bar\` property. In your example you have a computed property \`sub\`, and TypeScript cannot determine exactly which property of \`value\` you are referring to - because of this, it will not narrow subsequent accesses of \`value\[sub\]\`. &amp;#x200B; Here is a small example: interface Foo { x?: (a: string) =&gt; number; y?: (a: string) =&gt; number; } &amp;#x200B; declare const key: keyof Foo; declare const foo: Foo; if (foo\[key\] !== undefined) { foo\[key\]("argument"); // error; } &amp;#x200B; Even though \`key\` is known to be a property of \`Foo\` we don't know exactly which property, therefore TypeScript will not narrow the access in the \`if\`.
TypeScript uses a control flow graph to do type narrowing. I think that unless TypeScript can syntactically identify the property you are accessing it wont build the graph for a property access, and therefore you wont get narrowing even if the type of the key `y` is known to be bar.
In the example you show what you say is true, TypeScript won't enforce immutability. It doesn't check for runtime values also, so it won't help you in cases like this as well // Type Says it's a string, but is a number in runtime const str = JSON.parse('9') as string; I'd say that if you want to use immutable structures with TypeScript you can, and with pretty decent support from the compiler, but again, it won't "enforce" it. This would be a normal way to work with immutable data. type User = Readonly&lt;{ name: string; age: number; }&gt;; const john = { name: 'John', age: 29 } as User; function birthday(user: User): User { return { ...user, age: user.age + 1 } } const newJohn = birthday(john); If you try something like this it will fail, as it should john.age++; // fails You could always escape the compiler, but why would you do it (john as any).age++; And the example you show is true, if you have the same object defined as mutable and immutable, you can pass the immutable reference to the mutable one and TS won't complain, but the real question is why are you defining a mutable and immutable interface of the same type in the first place. If you really want to enforce immutability, JavaScript can help you out with the use of Object.freeze interface MutableData { data: string } interface ImmutableData { readonly data: string } function mutdateData(data: MutableData): void { data.data = 'fooo'; } const immutableData = Object.freeze({ data: 'bla' }); // Doesn't do anything mutdateData(immutableData); But for me, that is an overkill. In conclusion, every law has a loophole. Even in PureScript you can use an FFI to avoid the immutable restriction, which is what the ST type does, it's just a little harder to do.
I have a blog post on using [io-ts](https://github.com/gcanti/io-ts/blob/master/README.md) for this purpose: https://www.olioapps.com/blog/checking-types-real-world-typescript/ Briefly you write validators in Typescript to check that the data has the expected properties with the expected types, and Typescript interfaces are automatically inferred from those validators.
You can use runtypes. https://github.com/pelotom/runtypes
Think it through carefully. When using a DI/IOC framework, at some point in your app‚Äôs codebase, you have to write down a series of mappings that logically mean: ‚ÄúIf they ask for the service `ICar`, create an instance of `Car`. These declarations can be written as a module called `factories.ts`, which just exports functions for creating components: ``` export function createCar() { return new Car( createWheels(), createEngine(), createSeats(), createStereo()); } Note that those other components are just similar such functions in the same `factories` module. So the end result is you are saying in exactly one place how to construct each service. IMPORTANT: you hardly ever have any dependency on `factories.ts` - certainly not from any testable component. The only legitimate place to depend on it is at ‚Äústart up‚Äù or similar entry point to your code. Components just have constructors that accept all their immediate dependencies. This means a component never knows how to construct another component. There is no ‚Äúpassing down‚Äù through layers of constructors. It is one-to-one identical with the simple case of IOC (except with the advantage that the compiler can check all your dependencies are satisfied.) For many apps this is perfectly adequate. You mention the idea of a symbol knowing a type - this is actually possible to build and is the key to generalising the idea further. It works similarly to Reacts new context API, which has exactly the same need to decouple consumers and providers of some service API. You just need a reusable generic type that represents a service, and binds together a compile-time type and a runtime identity.
&gt; I guess I could use json schema of course but that's complicated. Is it though? Based on the spec it took me about an hour to write a re-usable JSON schema for a customer with with address and some additional details, and using [AJV](https://github.com/epoberezkin/ajv) I was able to validate the data against the schema, I even personally inplemented it as a Angular service where I inject AJV and use it inside an app, although your use case may vary. Bonus was also using https://www.npmjs.com/package/json-schema-to-typescript with it's CLI tool and adding 1 line to the package.json to run it - also creating types based on the schema. So basically the schema is one source of truth for both types and validation.
Because you are using generics wrong. I suggest you read the documentation about it again. To answer your question, instead of using the type as a value (``T._url``) you use it to hint the return type of ``get()``: ``` this.http.get&lt;T&gt;(environment.appUrl + this._url) ```
Wow, thanks, that exactly what I needed.
I've been thinking about this a bit myself. My initial thoughts are to have 3 top-level directories - client, server and common (for shared types / utilities). I'd have a separate package.json in client and server, since the scripts and dependencies would be very different.
I'd do this but put all three under /packages/ and use Lerna to build. You can also split out under server to /API/ and /DB/ or something of that nature.
You should be able to put a global types file outside the scope of both projects, below src, and access them from both projects like `../../types.ts` or something along those lines. If Typescript is just a dev dependency you shouldn't have to worry about this file being outside the scope of your project directory because it won't be included in the production build. Another option would be to pick one of the repos as the "master" and have part of your build script automatically clone the types file(s) from the client directory to an equivalent directory on the server project, so technically they are two different files in both repos, but you only update one of them yourself ad you copy script keeps them in sync. I'm sure there's better options out there, but currently the second one is what my team is doing and it's been great, no issues so far.
I made a project a while back, [ts-app](https://github.com/lukeautry/ts-app), which aims to establish a good pattern for full-stack TypeScript development. You can check out the project, but the gist is that client-side stuff goes in 'web', server-side stuff goes into 'api', and dev environment/build stuff goes into `dev`. I've built bigger projects forked from this boilerplate and have commonly ended up creating other root level folders for shared modules/types.
I use something like lerna, create 3 packages (client, server, common / shared).. Dump the shared / common code into the common / shared package, have both client and server depend on it, then import from that package.
The most canon answer will be: they should be separate projects (or at least a monorepo). In practice Ive already sewed small projects with back and front on the same folder, with the added benefits of types sharing between back and front (2 tsconfigs, the FE peeking types on the backend as long as it doesnt import concrete code webpack shall tree shake it). But that is certainly not correct and not scalable.
I do exactly the same thing, but with Next. I make the main project folder for the Next install, with a folder called 'server' in root for all the Node backend stuff.
This is basically what I do. For server, I use Hapi.js which has a nice plugin architecture, so I treat each plugin as its own package. It's certainly more boilerplate, but I find it to be well worth it as projects grow in size and complexity. One huge advantage of this: it is very easy to break out a plugin as its own micro-service to improve load balancing. I also treat static file serving (and server rendering) as a plugin (basically just making the root client package a dependency of the server package). For setting up the environment I typically use Docker &amp; docker-compose (DB, server, load balancer, etc). This is for local/dev/prod, just different config files for each. For deploying, I use Kompose to generate Kubernetes config from the docker-compose files.
After migrating one of my NPM packages to use TSDX, I wanted to share what it is and how to use it. It's a zero-configuration CLI for creating TypeScript library/packages, [kind of like CRA (create-react-app CLI for creating a zero-configuration react project, but for TypeScript)](https://mobile.twitter.com/jaredpalmer/status/1140316145179856896) It lets you create and distribute TypeScript packages easily without the ceremony of setting up TypeScript, rollup, tslint, prettier, etc. I'd also recommend to watch at 1x+ speed as I haven't recorded video this long before (and thus talk slowly making funny faces üòÄ)
I haven‚Äôt watched but I love this idea and was just thinking I wanted it.
I'm in the process of moving one of my API libs over to this now, with only some minor hiccups!
Just be aware that it's not always up to date. It took them quite a while to update from 3.3 to 3.5.
I don't use DI/IOC for everything. Close related Classes referencing each other directly. Sure some factories still exist. The Car would be delivered by IOC, but wheels, engine, seats and Stereo could be exactly in such a factory. Some use cases for me: 1. i18n. Language change, event listener etc. everything is accessible by DI/IoC 2. Models/Repositories. I split out thinks like these from the View Components. 3. Thinks like State. I really dislike Wrapper Components. That's why i don't use them, and so context neither. Not sure what you mean with " I. You just need a reusable generic type that represents a service, and binds together a compile-time type and a runtime identity.". Interfaces don't exist in javascript. \`\`\` @inject(TYPE.MyService) private readonly myService!: MyServiceInterface; \`\`\` Maybe the container.get() in the background could check if the instance class name is the same like the symbols string (not absolutely sure of that). You mean something like that? But this solves not a real problem. I could still mess up if "MyServiceInterface" does not match "TYPE.MyService". They don't know each other and will never do. And on the other side i can have multiple instances of the same class in my registry bound to different symbols by different factories. The main reason a while ago to absolutly decople everything was that refactoring a project was absolutly impossible because everything was hard wired (with factories only). Everything depends on everything. Switching from one View render to another was impossible. Changing the i18n lib was impossible. Refactor the Request Service they build was impossible. Nothing was possible without breaking the whole application. To archive the possibility to kick out something and replace it, even the view renderer (because it does nothing more than rendering) was my goal for further projects. Now i can. \^\^ And thanks to the way i choose i can do replace dependencies at runtime without touching any code. And last but not least with a feature I am working at i can subscribe/unsubscribe automatically so the view gets updated and/or data gets deleted on logout what is done by a plugin. I will never say it is a perfect solution. But it fits my needs perfectly at the moment.
Y'all ever typed "ts playground" into Google instead of "typescript playground"? Good fun.
Any advice on testing React components themselves with this tool? I think I'm just drunk and sleepy but I'm not sure what would be the best way.
I don't really understand what exactly you want to achieve. Below is a code snippet showing how I'd work the type in question: ``` type Maybe&lt;T&gt; = T | null; interface Reviews { dealer_name: string; other: any } type GetDealerNamesQuery = { __typename?: "Query" | undefined; } &amp; { results: Maybe&lt;Maybe&lt;{ __typename?: "reviews" | undefined; } &amp; Pick&lt;Reviews, "dealer_name"&gt;&gt;[]&gt;; } const q: GetDealerNamesQuery = { __typename: "Query", results:[] }; const q1: GetDealerNamesQuery = {results: [{__typename: "reviews", dealer_name:'a'}]}; const q2: GetDealerNamesQuery = {results: [{dealer_name:'abc'}]}; if (q1.results) { // do something with results if (q1.results.length &gt; 0) { // do something with every element } } ```
Links for others https://github.com/palmerhq/tsdx https://www.npmjs.com/package/tsdx
I hate you :(
The awesome part about this is that you can actually pick a specific version if you're trying to e.g. illustrate a bug in one version of TS. Very handy when filing issues...
What are the hiccups you are having?
Thank you for the links~ I will post relevant links next time I post üòÄ
Thanks @sleazyrom. Looks easy enough üôÇ
How about type CallableFunction = () =&gt; Promise&lt;void&gt;
\`\`\` async function showMe(callback: () =&gt; Promise&lt;void&gt;) { await callback(); } \`\`\`
This has been there for ages
Hope this helps: ~~~ type Maybe&lt;T&gt; = T | null; interface Reviews { dealer_name: string; other: any } type GetDealerNamesQuery = { __typename?: "Query" | undefined; } &amp; { results: Maybe&lt;Maybe&lt;{ __typename?: "reviews" | undefined; } &amp; Pick&lt;Reviews, "dealer_name"&gt;&gt;[]&gt;; } const q: GetDealerNamesQuery = { __typename: "Query", results:[] }; const q1: GetDealerNamesQuery = {results: [{__typename: "reviews", dealer_name:'a'}]}; type Unpack&lt;T&gt; = T extends (infer U)[] ? U : T; type ResultsType = NonNullable&lt;GetDealerNamesQuery['results']&gt;; type ElResultsType = NonNullable&lt;Unpack&lt;ResultsType&gt;&gt;; type Without&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; type FinalType = Without&lt;ElResultsType, '__typename'&gt;; ~~~
It does thank you!
CallableFunction is a type that's built into TypeScript. OP shouldn't be mutating it.
An async function is just a function that returns a Promise. `() =&gt; Promise&lt;any&gt;`
Welp, TIL.
Create a discriminated union.
yes i did, at work. i still dont understand why it pulls that up
Could you elaborate? I've tried this but I fail to make it work. My types type BaseProps = { ... } type InternalLinkProps = BaseProps &amp; { to: 'home' | 'about'; } type ExternalLinkProps = BaseProps &amp; { to: string; external: boolean; } type LinkComponentProps = InternalLinkProps &amp; ExternalLinkProps; const Link: React.FC&lt;LinkComponentProps&gt; = () =&gt; ... This will still error &lt;Link external to="test"&gt;test&lt;/Link&gt; // Error: Type '"test"' is not assignable to type '"home" | "about"'.
It could. They decided against it (so far). There's an open issue about nominal type support that frequently gets spammed with the same repetitive comments.
You need to have a property that acts as the discriminator, a property that allows TypeScript to differentiate the types. That property must be present in all union types, but must have different types. type InternalLinkProps = { to: 'home' | 'about'; external?: false; } type ExternalLinkProps = { to: string; external: true; } type LinkProps = InternalLinkProps | ExternalLinkProps; const l = {} as LinkProps; if (l.external === false) { l.to; // type is 'home' | 'about' }
is there a TLDR on why they haven't implemented it yet?
They have been silent about the subject for years.
Awesome, it works! Thanks a lot!
Oh wow, that feature is well hidden. I wasn't aware of it.
It's listed under "Future" (aka maybe someday, no idea when) on their [Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap). It links to [this issue](https://github.com/Microsoft/TypeScript/issues/202).
This will bring the TypeScript playground in my results. Remember that the Google search results are geared towards your previous searches and preferences.
Nooo, don't link the issue! That will only cause new comments (repeating what has been said), and other people responding to it (again repeating what has been said)...
I presume you mean the "branding" hack? ``` type URLStr = string &amp; {__brand: 'url'}; type EmailStr = string &amp; {__brand: 'email'}; ``` What problems do you encounter with this technique?
`&lt;T = unknown&gt;()=&gt;Promise&lt;T&gt;`
I do type AsyncFunction = &lt;T&gt;() =&gt; Promise&lt;T&gt;
serialization...
Sorry. GitHub really should have features where: 1. It automatically converts comments whose only contents is `+1` to a thumbs-up reaction. 2. It allows you to subscribe to only receive updates when a repo owner comments, or an issue is resolved. (I believe there was a website that at least did the latter.)
Future more like means ‚Äúeternally postponed‚Äù
ts-jest comes with a `mocked()` helper that does this for you. https://kulshekhar.github.io/ts-jest/user/test-helpers#mocked
How does this work?
How do you envision serialization with nominal typing working, ideally?
Basically the type is now an intersection of string and the literal object with a key called __brand and a value of 'url' or 'email'. The types are now incompatible so you can't assign a value of one type to the other, but you can easily cast strings as the type, and do operations on the string as normal
Well I don't I guess.. but if you could handle custom serialization it would work just not on interfaces. I'd like there to be nominal typing in typescript directly but that's not going to happen. :-/
It's not clear how the suggestion to use the "branding" hack relates to the response that serialization is an issue.
well I believe if you serialized it as JSON you would get the brand in an object instead of just the raw string. I just want the raw string.
You actually would not get the brand because it only exists in the type system.
Serialization is not a problem here.
Strings can not have properties in JavaScript.
My greatest fear when putting time into one of these posts! This is great to know, though, I think I should bring this up at my work.
You mean how to filter your data? \`\`\` data.filter(item =&gt; item.title.includes("searchString")) \`\`\` This is quite rudimentary coding that should be learned before dealing with APIs IMO.
I could be really vague with it I'm sorry, That could work. Like I said beginner with alotnof these technologies. Was never exactly shown how to do this, and I learn by seeing. Go raibh mileüëç
If I were you I would work through this short book. Good luck. [https://basarat.gitbooks.io/typescript/content/](https://basarat.gitbooks.io/typescript/content/)
I shall do that, Thank you.
Generally I agree, but in this case the team should **really** just disable posting new comments for non-team members (GitHub supports this).
Oh absolutely, one doesn't exclude the other,
I feel nominal typing is less powerful than structural. If you want to have a email field you could have a function return it and create a custom type. Its basically a string thats validated but has a own type.
They both have their uses in different areas. Adding an extra structure to wrap a value just to have it nominal is overkill. And you need to make sure that the structure is not accidentally compatible with another structure, or else the point is missed again.
addEventListener is being given the keyHandler function that belongs to StartScreen. If you change state in Context, that won't change what function you've already given to addEventListener. &amp;#x200B; You could have a keyHandler on Context that then calls the keyHandler of the current state. &amp;#x200B; export interface State { handle(context: Context): void; keyHandler(event: KeyboardEvent): void; } /\*\* \* Start Screen State Machine \*/ export class StartScreen implements State { public handle(context: Context): void { console.log('leave start screen, go to level 1'); context.State = new LevelOne(); } keyHandler(event: KeyboardEvent): void { if (event.code === 'KeyS') { console.log('s pressed'); context.request(); } } } /\*\* \* Level One State Machine \*/ export class LevelOne implements State { public handle(context: Context): void { console.log('leave level one, go to start screen'); context.State = new StartScreen(); } keyHandler(event: KeyboardEvent): void { if (event.code === 'KeyF') { console.log('f pressed'); context.request(); } } } /\*\* \* Context State for State Machine \*/ export class Context { private state: State; constructor(state: State) { this.state = state; } get State(): State { return this.state; } set State(state: State) { this.state = state; } public request(): void { this.state.handle(this); } public keyHandler(ev: KeyboardEvent) { this.state.keyHandler(ev); } } /\*\* \* TEST \*/ console.log('Start Screen - Press S to Begin and change state to LevelOne'); var context = new Context(new StartScreen()); document.addEventListener('keydown', context.keyHandler.bind(context)); document.addEventListener('keyup', context.keyHandler.bind(context));
This is called [method chaining](https://en.wikipedia.org/wiki/Method_chaining) and works by a) returning `this` (an example would be something like knex) or b) by calling methods of the expected result - such as `toArray().map(...)`
Thanks so much! I Can't believe I missed that the event listener was always stuck on the start screen function, cheers!
Dummy code for the above would look like this: ```javascript function DB(name) { this.name = name this.objects = [] } DB.prototype.collection = function() { this.name += 'bla' return this } DB.prototype.find = function() { // do stuff return this } DB.prototype.toArray = function() { return [...this.objects] } ```
Thanks for the reference mate.
Can I call your code like this?: DB.find().collection().toArray(); How can i create code which i can only call in sequence like this?: DB.collection().find().toArray();
that is just returning different objects. You could write it like this const db = new DB() const collection = db.collection() // returns a collections object const object = collection.find() // returns an object from the collection const array = object.toArray() // converts object to array
Great article mate. Just exactly what I need.
I got the idea. Thanks mate.
I'd probably just have the client under a subdirectory in the API repository, since the client is going to be tightly coupled to the API anyway and you're often going to be changing both at the same time.
Thanks for being my rubber ducky. I originally set down this path because I was using my Next.js server as my API, and people said that was a bad idea. So when thinking of splitting it, I went to separate projects. After reading your response, the very obvious conclusion came to me that I could just create a separate server for the API within the same repo and invalidate this entire issue. And as a bonus, a single repo!
You'll probably end up having a third package (be in a separate repo or not, it doesnt matter) and use `npm link` to use that while developing them. Also check out nrwl's nx. It's designed for Angular but it works with React too as far as I know. Even if you won't use it, it might give you a few ideas.
Thanks for the suggestion! Will look it up!
Lerna is great for monorepos, where shared typings and functionality are needed.
* server exposes swagger def (integrated into the framework) * client includes tooling to generate TS from swagger
I prefer monorepos, I would use them over splitting into 2 projects if at all possible. My file structure looks like this: src/ tsconfig.json /client tsconfig.json (extends ../tsconfig.json) /common /server tsconfig.json (extends ../tsconfig.json) And I try to put as much in `common` as possible.
Thanks so much for the guidance on this. I will give this a go!
Beyond typescript, I have always wanted a tool to count references in javascript and highlight dead or orphaned code.
 ErrorType = { isValid: false, errors: Err[] } SuccessType = { isValid: true, errors: null } MyType = ErrorType | SuccessType
Damnit, I went too simple. For the sake of me learning, can I do this with a conditional?
I'm not really an expert on Typescript and don't really know what you mean by "with a conditional", but if you check the value of `isValid`, the compiler will narrow the type for you. const foo: MyType = ... if (foo.isValid) { // TS knows foo is SuccessType and errors is null } else { // TS knows foo is ErrorType }
sorry, I meant with a conditional type [https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/](https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/)
No idea, sorry. You've exhausted my Typescript knowledge.
Sure, but you don't gain much in this situation: `type Result&lt;T extends boolean&gt; = {` `isValid: T;` `errors: T extends false ? Error[] : null;` `};` `function resultor(): Result&lt;true&gt; | Result&lt;false&gt; {` `if (Math.random() &gt; 0.5) {` `return { isValid: true, errors: null };` `} else {` `return { isValid: false, errors: [new Error] };` `}` `}` `const result = resultor();` `if (!result.isValid) {` `result.errors.forEach(console.log);` `}`
For completeness, here's how you could use a conditional function return type: type Err = unknown; type ErrorType = { isValid: false; errors: Err[]; }; type SuccessType = { isValid: true; errors: null; }; type MyType = ErrorType | SuccessType; declare function magic&lt;T extends boolean&gt;( result: T ): T extends true ? ErrorType : SuccessType; const x: ErrorType = magic(true); const y: SuccessType = magic(false); const z: MyType = magic(Math.random() &lt; 0.5); [Playground](https://typescript-play.js.org/#code/C4TwDgpgBAogTnKBeKBXAdga3QewO7oDcAUMaJLAjnACrjQoDexUUAlgM4BqAhgDZsAJgC4oAM34cIJVhCpwOo+HADaAXRIBfEmXpQAyqgDGRiBw50KTFu278ho4HFTSbcuNUVR0qPny065NAAsiCWDJQetHoAPgbGpubhOoIQRnw8cNBiGEbAbDjoUAC2PADmbEYAPDRQEAAewBDoghxQAEY4OHwQPOgAfAAUNlkcvsCiNMQAlJN1jc2tUE4uUAD8kdThUKKGJmYW9DpGhRzAUPVK8tsopRVGgysQ0yQn6GdQILsJBzcl5ZVBhI+FIXsQ3h8AF6iUJ-O6A4I8YAACwAdHA+oIcMVBtMoFUoAAGVEAVjBQA)
No worries, /u/y2bd gave an example here: https://www.reddit.com/r/typescript/comments/c2ah18/simple_conditional_type_question/erivcw7?utm_source=share&amp;utm_medium=web2x
Awesome thanks! Definitely overkill. I just looked at most examples and wasn't getting it. I wanted something simple to bite off and I get this. Thank you! I didn't realize I could but the type condition in the type property, it makes sense seeing it but this is all so new.
I've been away from TS for a while and am wondering if you could clarify why you wouldn't just achieve this with classes, interfaces and inheritence. e.g. interface ResultType { isValid: boolean; errors: Array&lt;Err&gt;|null; } class Err { message: string; } class SuccessType implements ResultType { readonly isValid: boolean = true; readonly errors: Array&lt;Err&gt; = null; } class ErrorType implements ResultType { readonly isValid: boolean = false; errors: Array&lt;Err&gt;= new Array&lt;Err&gt;(); }
typelens
Two differences between this and the discriminated union suggested above: 1. if you have a ResultType and do a `if (rt.isValid) { ... }`, typescript can't tell that errors is guaranteed to be non-null within the body of the `if` block. 2. you actually have to construct instances of SuccessType and ErrorType. This isn't a problem in your own code, but doesn't work as well if this data is coming in as the result of a JSON call. You can easily tell Typescript "I know this response maps to this discriminated union of interfaces" (ie. `MyType`) without transforming the object. However, if you need classes, you'll need to do some mapping logic to turn the response into the classes.
A conditional type does not really make sense for something like this.
My setup is similar. One thing to keep in mind is that if TypeScript makes a breaking change that affects code located in `src/common`, that will result in you having to upgrade both the server and the client TypeScript versions at the same time, which makes that task more daunting. So I take care not to use too experimental features there. Anyway, the main point of my common was that I use this setup in an open source project, so if you want something to take inspiration from, see [here](https://gitlab.com/Flockademic/plaudit/).
Not sure exactly for res.locals, but you should definitely look into Nest.js.
[Koa's pretty good.](https://github.com/koajs/koa)
I'm not 100% sure if this would work in your case, but why not use your own types &amp; extend the types that exist in @types/express?
I wrote a blog post about a similar problem on strictly typing express handlers and responses. Maybe you could adapt it to your needs: https://blog.liangchun.me/express-typescript-handlers/
You may want to use a fully fledged typescript node backend framework. Like NestJS.
**Pardon the interruption.**
Yeah medium is shit. But I haven't seen that popup for a very long time. medium.com##.overlay--light.overlay medium.com##.postShowScreen:style(overflow: auto !important) Sorted.
Not even finished reading yet, but your article gave me a great idea on how I can reduce my response types. Thanks for posting!
Agreed, I'm not using this anywhere. Just playing around with examples to make sure I understand the mechanics of how the feature works.
Express typings exposes a couple of public global interfaces which can be augmented
this is what I did, but I would look into koa as well as another poster mentioned. it has an overall nicer api, IMO.
&gt; by sindresorhus https://github.com/sindresorhus/mimic-fn/graphs/contributors
I recently discovered Nest.js and it looks decent. It reads nicely, is testable and plays nicely with the existing eco system. Nest's [documentation](https://docs.nestjs.com/)is also top notch. You should check out [some demo apps](https://github.com/nestjs/nest/tree/master/sample) and see if you like it.
He created the repository / original idea (I just joined in recently) so I don't want to steal the credits :)
What is the use case for this?
I like that TypeScript declarations included.
Examples of use cases: \- you are memoizing a function with static properties, and don't want to lose those after memoizing \- keeping \`name\` and \`toString()\` after wrapping a function makes debugging nicer
The advertisement in the readme is **really** off-putting.
Just use NestJS. Fully typed, very friendly and you'll be able to add custom typings in no time.