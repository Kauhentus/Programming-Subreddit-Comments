Yes I know what you mean, MS Edge allows it to happen for my tests and its more of a project than an actual site I used parent.frames[1].document.form2.textbox.value=n1; and that worked just need to play with it more thanks
If you don’t already have a package-lock.json, be careful!
Wait you're writing React? You definitely shouldn't be doing things like this with JQuery then, you're going to break your Applications state in a lot of ways because JQuery operates on the DOM and React has an abstraction on top. If you need to toggle classes you should use React's state system to change conditions.
FYI these resources are heavily sourced from what I see beginners recommending right here in reddit /r/javascript. Trying to help new JavaScript developers jump right to the good stuff.
Men, this is a weird moment, because.. i kinda side with the dude everyone's agree is abusive... I mean i saw the comment thread and i'm like wuuut! How can we expect everyone to keep composure under such intense attacks. I do share the view that toxicity is a problem in the community. This feels quite overblown and to be true, i too would of reacted in a questionable fashion on some sense... Maybe i'm an asshole... i'm not sure the world view one's suppose to have to not get a little frustrated by a world of random angry users that use your stuff for free. 
NodeJS and Express can do these things, but what makes you say Django is outdated?
It's not that big a deal, we have ===
They have the only app store where people actually spend money.
I am curious too if theres a solution
I haven’t come across any projects in last year that have been executed in Django. The program however needs Tensor Flow which needs python packages. I was curious if if there is anyway I can Integrate that with JS.
I know there's a bajillion learning resources out there, but I really feel like this list should have included watchandcode.com and The Odin Project, both of those are often and highly recommended entry level learning resources, I'm pretty sure watchandcode is the only resource out of all of those that goes into debugging, testing and how to read code and very few of them go into text editors and git like The Odin Project does. Also I'm glad that the first time one of my reddit comments was quoted was something to do with programming instead of a drunken rant on some other topic.
No I am not, actually. The webpack build has two targets, one is the demo website, the other is the lib. The lib does not use jQuery, the website uses it for demo only. I know the structure is confusing now because they are actually two things in one package file.
BTW - please tell me about any good resources that I missed on this list
Wouldn't it be Beaverton?
Just to be clear, Mike Sherov in that thread isn't associated with `npm`.
You can return any status from the page being requested, even a 404. Return a 200 status. 
Roger that - even as an amateur, I can imagine that it would be a lot easier to create a simpler version of the same thing. My thought was, perhaps this was build to scale more easily. Drcmda's reply (above) indicates this is not so. What do you think?
So. Did you see the #hashtags in their blog post for 5.7.1? http://blog.npmjs.org/post/171169301000/v571 Not to mention they are STILL trying to say "this shouldn't have ever happened to anyone in production if you are using @latest instead of @next" but they won't admit fault that their `ng update -g` command updated to @next without a @next flag. They clearly fucked up and won't admit fault, then release a quick fix with a backhanded blog post, mocking the users who were upset. Mike aside, I have enough evidence there to think NPM are hacks and a terrible choice for crucial tools that my business operates on. 
Depends. Downloading all the HTML upfront is typically faster than dynamically rendering it via javascript, but at some point, it makes more sense to bundle split large sections of an app to reduce the initial page load. For showing/hiding small parts of the page, appending elements dynamically is akin to bundle splitting, but on a smaller scale (i.e. technically slower in absolute terms, but spreads the performance cost over a larger amount of time). However, if you expect a large section of the DOM to toggle visibility frequently, it makes more sense to do it with CSS rather than recreating/recycling the DOM. TL;DR: right away for critical elements and frequently toggled elements, dynamically for infrequently toggled elements. 
Is the resukt any different than using it like this? class Test { fn = _.once(() =&gt; { // do something } } 
Not sure if this meets your criteria, but you could use [`jest-html-reporter`](https://www.npmjs.com/package/jest-html-reporter) to create a static HTML file, then serve it up using something like [`live-server`](https://www.npmjs.com/package/live-server) or [`http-server`](https://www.npmjs.com/package/http-server).
 import fs from 'fs'; class SomeComponent extends Component { componentDidMount() { console.log(fs); fs.appendFileSync(__filename, '\n// it sure can'); } ... also tried: import fs from 'file-system'; and: componentDidMount() { const fs = require('fs'); console.log(fs); fs.appendFileSync(__filename, '\n// it sure can'); } getting this error in console: ProfileView.jsx:21 Uncaught TypeError: fs.appendFileSync is not a function 
And you're for sure executing this in node using jest or jsdom? You're **not** using webpack or a bundler and running it in the browser (such as with react-create-app)? Because if so, node core modules will either be missing or replaced with empty objects so that code can run isomorphically. You understand that inside a browser environment, there is no file system access?
I've created this cli tool about 1 year ago, now its has about 10k downloads according to npm. What can I improve? Thanks in advance to all (PRs welcome!). https://github.com/splash-cli/splash-cli
It was hilarious (and sad, really) literally minutes after Google released the headless version the guy announced "That's it, I have been doing this on my own for ages, I am finally free!" Sad because how many big companies benefitted from it, yet everyone relied on the good will of this lone developer without contributing to keep the project going
Yarn replaces npm so I wouldn't see how
[It's listed in their docs...](https://docs.npmjs.com/all#before-we-start) [Here's a way to fix it tho](https://github.com/sindresorhus/guides/blob/master/npm-global-without-sudo.md)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sindresorhus/guides/.../**npm-global-without-sudo.md** (master → 125f995)](https://github.com/sindresorhus/guides/blob/125f9954d3df3ecfafed2ded48b705defce82e8d/npm-global-without-sudo.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply duqe3qc.)
If a standalone function ever gets reassigned in the first place, that's quite a code smell that probably indicates there are many issues elsewhere as well.
I prefer being able to describe the most abstract parts of the code first. For example, at the very top: buildUI(); parseData(); displayResult(); function buildUI() { // ... } vs function integrateComponentA() { } function integrateComponentB() { } function integrateComponentB() { } function buildUI() { integrateComponentA(); integrateComponentB(); integrateComponentC(); } buildUI(); function parseDataComponent1() { } function parseDataComponent2() { } ... function parseData() { parseDataComponent1(); parseDataComponent1(); ... } parseData(); I like being able to see a high-level overview of *what's* going on first before going into the deepest details of *how* everything is implemented.
Just look at network tab - server is still responding with 404 (and "nope").
[removed]
Nope. I just prefer the decorator syntax, and the decorators *should* (I haven't tested this) play well with other decorators (such as [mobx observables](https://mobx.js.org/refguide/observable-decorator.html)).
Right, I'm not saying there's nothing to criticize about how they handled this. I'm saying your specific point, &gt; [They] became abusive against the people reporting the issue implies that `they` is npm, which is patently false and misleading. &gt; Did you see the #hashtags in their blog post for 5.7.1? I admit I thought it was pretty funny. Literally every developer in the world has had bugs in production code. Pretending that this specific case somehow makes the people at npm hacks is totally unreasonable. &gt; They clearly fucked up and won't admit fault I don't know, it seems like they fully intend to fix `update` now. https://twitter.com/ReBeccaOrg/status/966739473462472704 I agree that if it didn't work right it shouldn't have been there in the first place though. It's certainly unfortunate, but again I'm not how how this is a massive issue in general. &gt; I have enough evidence there to think NPM are hacks and a terrible choice for crucial tools that my business operates on. I'm clearly not going to convince you, and I don't particularly think I even want to try, but it really seems like some moderation is helpful here. Really nothing about this situation is a big deal, it only affected a small percentage of users, and they dealt with it in a timely manner. Seeing people deal calmly with a complex situation if anything makes more _more_ confident in them. I feel like people are just using it as a means to attack a company they already hate. It's _so_ much easier to criticize from the outside of anything. It seems like people have zero empathy and I just don't get it. 
This question would probably be better suited in a Stackoverflow's post.
Don't paste code here if you can't format it, use JSFiddle instead. (also, /r/learnjavascript) Also, don't ever inline your JS; using inline event handlers is bad practice and results in poorly factored, hard-to-manage code. Seriously consider attaching your events with JavaScript, instead, eg: https://developer.mozilla.org/en/DOM/element.addEventListener
This is lots of fun, I have been volunteering through [TEALS](https://www.tealsk12.org) this year, doing a high school level Intro to CS in Snap! and Python remotely for an inner city school. The delta between the first week of school and today is amazing, even the kids doing the poorest have learned so much and have usable skills for when they need to script something in the future. The top students have all expressed interest in perusing Computer Science in college.
Thanks for the mention! It’s probably better to link to the website for all of my books instead of just to the first book. http://exploringjs.com
`Intl.RelativeTimeFormat` Will it work for comparing seconds from Julian dates in Russia to modern leap second adjusted dates? :) (https://www.youtube.com/watch?v=-5wpm-gesOY) Seriously though this is very nice. I dread to think how vicious the polyfill will be.
I've been quietly following the progress of the Intl proposals and there is indeed a lot of interesting and useful stuff in there, keep it up. One question: these are considered language/standard library APIs right, not just browser ones?
It's also not very transparent about where it gets the conversion from which is fairly critical. I've sent a PR for that.
(But not if you're doing a serious financial applications or depending on the values for pricing stock).
I think currently it just formats, it doesn't calculate the actual difference between two dates. ICU can probably do that though.
Ah okay, that makes more sense. Still nice to have.
What I am trying to point out is that you can definitely have fractional yen, just as you can have fractional USD below the cent. It just depends on what you are trying to convey. `toLocaleString` is a string formatter and nothing more. If you (designer, developer, data provider, or whatever) have reason to display the number 0.42 as a yen value, then the correct format is ¥0.42, not ¥0 or ¥1. Think about what a nightmare it would be if your JS engine had to keep track of what was a "sensible" minimum value for all currencies? Would we need weekly updates for the Venezuelan bolivar?
Sure, but it doesn't make sense in 99% of situations to display $100.421832 &gt; Think about what a nightmare it would be if your JS engine had to keep track of what was a "sensible" minimum value for all currencies There's "sensible" and then there's "minimum". JS apparently at least has an internal list of how to round, so that's good enough IMHO. I'm currently in Bali, Indonesia which has one of the weakest currencies on the planet (~13,500 = $1USD). The smallest "sensible" denomination depends on who you're talking to. For most westerners it's 1,000 or 500 since those are the most common coins and are close-ish to 10¢ and 5¢. For locals that earn ~$1/hr on average it's 50, which is the smallest currencies in circulation. I think it's fine to show 100,521 instead of 100,500 here, but 100,521.39? meh.
What does an iOS user's statistical willingness to spend more money on apps have to do with WebViews? I don't see how these are related. 
The stock market would like to have a word: [Nikei closes up 0.42 yen](https://jp.reuters.com/article/idJP00093400_20161117_03120161117). So would wholesalers: [Plastic pine sprig for 10.25 yen per unit](https://item.rakuten.co.jp/takuho/01-35-200p/). So would historians: [0.01 yen was 1 sen and 0.001 yen was 1 rin](https://en.wikipedia.org/wiki/Japanese_yen#Yen_in_the_early_1980s). So would farmers, commodities and currency traders, utilities providers and so on. Language designers can't assume that the most common use case is the only use case, particularly for something so basic as a string formatter.
As I said, in 99% of cases. The vast, vast majority of prices displayed anywhere are for consumers, not mass markets. [edit] Sorry, thought this was a different thread so I didn't say that you :) But still, same point
I believe you’re right. 
I've lived in Japan for over 15 years. Fractional yen values are shown everywhere. I'll see it on newspaper headlines at the corner store. I'll see it on the TV news multiple times an hour. I'll see it on price lists. I'll see it whenever I check exchange rates. Ask anyone else in Japan if it's an edge case. It very, very clearly is not. Whether it is the USD, JPY or IDR, fractional values are valid requirements for a *string formatter*, regardless of the currency.
Years ago I taught my son's grade 7 class how to build things in Flash. That was a lot of fun too.
you need to download the driver for your computer for the Wacom tablet. Then it will work in browsers, it doesn't work out of the box unfortunately.
Awesome, thank you. This really helps clarify my approach: learn a framework to build things, study frameworks to understand underlying systems. I'll check out that egghead course. If I may ask, the thing that is on my mind here still is: what is up with all the callbacks? Trying to follow a path (and track the relevant parameters, etc.) in the VanillaToDo app is maddening, as it jumps from file to file at every other line. How much is this exemplary of other larger-scale coding patterns? Is that just how frameworks are? Or is there something different about this particular app? 
I always appreciate your posts on all the upcoming JavaScript features. Helps me to keep ahead of my own students.
Eloquent JavaScript is great and freely available on the web. The 3rd edition is in beta and now covers ECMAScript 6. 
CLI tools, for example. Node makes a great cross-platform alternative to bash scripts.
I’m not sure I agree, but I think I see the argument. Any web site/web app that wants to support iOS needs to support WebViews because it is so common for OTHER apps to open links in a WebView (and in fact are barred from opening in an alternative browser like Chrome). Thus, if you expect people to reach your content from following a link from the Facebook/LinkedIn/Snapshat/Hangouts or WHATEVER, you need to support WebViews. Something something more paid apps -&gt; more support for iOS ecosystem-&gt; more developer buyin to WebView support -&gt;more WebViews. Dunno.
I've lived in Japan for several years and no, they're not. Yes, if you look up stuff on stock and exchange rates but you will never see a fractional yen value in every day life. You're just lying to try and "win", so bye
Yes
Neither is inefficient enough to affect your decision to use one over the other. Use `===` to check for strict equality - what you want most of the time. `==` is useful to check for "nullish" values (null or undefined.) var element = document.getElementById('foo') if (element == null) { // element doesn't exist Or some people might just write: if (!element) { // element doesn't exist 
Yes a framework would be useful. Yes, React is the most popular. But lots of frameworks can work just as well for you. Personally I like Mithril because it's tiny, requires the least tooling and does the most for you out of the box. It also makes state management easier than pretty much any other framework. I use it extensively for UI in games or other game-like projects. But yeah if you want to transfer those skills to other job opportunities then React is a pretty good bet.
I have the drivers installed lol.
Oh yes - would love to know how you guys are preventing the bots. 
It's generally considered good practice to always use strict equality, ===, and to never permit implicit type coercion with ==. It's not for efficiency's sake, but for the sake of clearer, more predictable code.
Are you looking for `event.currentTarget`? If not, can you explain a bit more what you're trying to do?
I believe we were using this on one of our internal projects and using toLocaleString() l caused massive performance decreases compared to a custom formatter we wrote.
Anyone in the Denver area should reach out to the IDEA Lab at the central public library if they're interested in doing something similar, because they hold camps around the city in the summer, targeted at underprivileged communities. Kids spend a week on a team of peers with a professional mentor (that's you), crafting a site. The kids start out mildly interested, but on the last night, they tend to get competitive &amp; want to work all night hackathon style to out do their friends' teams. It's a profoundly gratifying experience, and the kids start to learn a skill that could change their lives. Seriously, reach out to Nate at the IDEA Lab in the Denver Central Library today,… like now. Tell him thisguyfightsyourmom sent you—it'll really confuse him. 
Depends on if you want to support old browsers or not. Current browsers support html templates using ``.
Hi /u/ReGGaeBAWS, For javascript help, please visit /r/LearnJavascript. Thank you!
Devs shouldn't intentionally use outdated coding styles in order to adapt for old browsers - that's what Babel is for.
Have you asked them about it or are you assuming they won’t listen because you’re an intern? It’s far from best practice today and frameworks like React and Angular have made this pattern obsolete but your company may have a significant amount of legacy code but not enough resources to update it even if they wanted to. If you haven’t asked, do so. Ask why, ask if there are plans to change it, ask if you can help.
Well basically I have a window mousemove listener, and when hovering certain elemens I want to add different classes to the body. But it only works if the target element doesn't contain any child elements. What Im doing is basically if(e.target.tagName.toLowerCase() == 'a') { ..do something..} 
I guess I could add eventlisteners to all the elements instead tho? What would be most performant u think? Thing is that many of the elemens are dynamically attached to the dom.
Those “lightbulb moments” are the most addictive to me. Being a teacher is very rewarding. I hope you keep volunteering, and if you ever want to chat about lesson prep or opportunities, reach out via PM.
You'll have to figure out how high you want to recurse. For example, if the target has no children and is not an `a`, and you want to check if its parent qualifies, you can recursively call the verifier function to see that it does - but there should probably be a limit of some sort, and do you want *all* elements to have the same limit? Maybe not, in which case, you'll have to code your way around that too.
Did you had to explain html to them?
That's just the added overhead if you wanted to make your own in vanilla. All this stuff falls out. You just need components, each describing what it can do and how it looks. Later on you compose these components into an application.
Sounds awesome. 
Use the ES6 template literal. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals You current approach would be considered as the "right" way before ES6.
The only thing that comes to my mind is propelml that implements some if not all of tensorflow, I hadn't use it but I have heard it's great
Check out Josh Comeaus work, it's truly something ... Key &amp; Pad (React, Redux, Saga): http://keyandpad.com/ ([source](https://github.com/joshwcomeau/key-and-pad)) Waveforms (React, styled-components, canvas, and SVG): https://pudding.cool/2018/02/waveforms/ ([source](https://github.com/joshwcomeau/waveforms)) And yes, React is [hugely popular](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core-vs-polymer-cli-vs-stencil-vs-lit-html). It's a small javascript centric pattern, you can get away with learning it under an hour ([for instance on egghead](https://egghead.io/courses/react-fundamentals)). I'd recommend starting with it because it's the smallest abstraction and the knowledge is actually useful as you're mostly not learning "React" but javascript.
As a user of PhantomJS, painfully aware of that fact. But unfortunately not feasible right for our team to update right now :( But shimming it with a simple window.Intl works.
I am not sure if you know about node.js very well or not. But node.js by default uses only one core. So if your server has like 8 cores system your node js is not going to use 7 cores. For that you have to use node.js Cluster to be able to scale your node,js app across all cores of your system. Just check out some documentation. For example this one: https://nodejs.org/api/cluster.html
He's pointing out that vertically scalable is a silly thing to claim because pretty much everything is vertically scalable. Claiming it makes you sound like you're just using buzzwords without understanding what they mean. 
Yep it is but it is not very easy to scale your websocket app through node.js Cluster and this framework allows you to do so. You can scale your node.js on different cores but your websocket app wont be connected across all node.js instances and you wont be able to communicate between two users which are connected to different instances of your node js app . That what is main peruse of this framework.
I built a framework because I tried to do everything in vanilla and eventually utils.js turned into a whole thing. So now a couple years later [rilti.js](https://github.com/SaulDoesCode/rilti.js), so yeah I've got that going. Heres my &gt; 180 loc [TodoMVC with rilti.js](https://github.com/SaulDoesCode/rilti-todomvc)
Pretty much that, yes. If you're targeting mobile and you need to support web content, you pretty much cannot get away from indirectly needing to support Safari. That said: I don't think supporting Safari is anywhere near as difficult as the top of this thread makes it out to be.
solved https://stackoverflow.com/questions/48960800/how-to-send-js-string-from-chrome-extension-content-script-to-php/48961164#48961164
But clusters are horizontal scale. If the framework supports clustering that's fine! But as the other guy said I was referring to vertical scale. There's no such a thing as a "vertically scalable framework".
I don't know of any such tool at this moment. You might be able to build such a thing with an AST transformation tool, such as [recast](https://github.com/benjamn/recast) or [jscodeshift](https://github.com/facebook/jscodeshift). But if you do, take into account two things: 1. That transformation looks somewhat delicate. There's a change of scope and that may have some implications to consider. 2. Is it _really_ an "optimization"?
why would symbols be considered metaprogramming? I'm having difficulty seeing why those things are not just "programming".
 Vertical scale means ( clustering when u scale across cpus on your single server) Horizontal scale ( is scale aross difderent machines so few servers are connected together) So this framework just make it all do to much easier with websockets. 
No, clustering is still horizontal. You're running parallel processes. Vertical means getting better machine. Which in the case of node, you'd also need to horizontally scale to take advantage of the cores that you add when you vertically scale.
I just realized my good old ASTWalker can be used to transpile also React JSX (thanks to one OS contributor) https://github.com/terotests/ASTWalker Example is here: https://codepen.io/tero_koodia/pen/EQegKY?editors=1000 What is the point? Well, if you don't need the full Babel -transpiling, yet you want to compile and run some JSX code in your browser, that approach can be faster and more lightweight alternative. Maybe. Anyway, it was fun to notice at least simple use-cases are possible.
hmm. guess I don't really agree with the categorization. the article you linked doesn't explain or provide an argument for the categorization, just more tutorials on es6 features. When I think metaprogramming in JS, I think esprima/escodegen. Calling function prototype methods like call/bind/apply "metaprogramming" really stretches credulity for me.
&gt; “wait where is that function defined?” And then you either: 1) Trust that the function actually does what it says it does, and move on, or 2) Let your IDE show you the function definition The interaction of components is more likely to create both useful behavior *and* bugs than implementation details are, especially if your code is reviewed and tested, so I find it useful to see those first.
&gt; In computer science, reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.[1] https://en.wikipedia.org/wiki/Reflection_(computer_programming) If you change the @@iterator of an array, you change the way for ... of loops work for that array. You are not merely, say, extending Array and adding methods to it. You are basically rewriting the way JS works, so to speak (of course you aren't, because metaprogramming itself is part of JS). That is metaprogramming. You are programming the program
Only some implications? This kind of transformation requires understanding of the surrounding "global" context, among others. Just simply moving out variables seems harmless enough on the get go, however, factoring in variable shadowing and others, it can be catastrophic. In other words, such transformations are mostly harmless, if the code is finished, and you introduce no side effects. Thus, at least retesting after optimization/transformation is in order. This is only accouting for the code-reuse/"simplification" aspect. Pair it with memory consumption and potential memory leaks, and you've a dead system on your hand. 
I'm wondering if you can't enforce a coding style, where would you expect any of these annotations (which I think might be critical to do something like this correctly) to come from?
man you are god I follow you on youtube your videos are awesome 
This is pure opinion. My team's style guide says exactly the opposite of this. I prefer to put control flow/logic at the top of the file, and definitions at the bottom of the file, hoisting achieves this. Using named functions also helps tremendously in debugging. I can't think of a good argument for why you'd always prefer anonymous assignments using const.
Can you show a full example of the code which doesn't work? 
Wish I had the courage to do this. Good for you!
In my example, `storage.get` is implemented by ourselves and usually used directly, whereas `doStuff` is implemented by the user. If we annotate `storage.get`, the tool would be able to optimize a lot of user code. Of course, it won't detect more complicated cases, but this particular function is most convenient to call with an inline array, so the simplest case to detect is also the most common.
Take a look at something like this in the config too https://facebook.github.io/jest/docs/en/configuration.html#coveragereporters-array-string
Thanks for your response, I'll look into building a custom solution myself. &gt; That transformation looks somewhat delicate. There's a change of scope and that may have some implications to consider. I am mostly talking about inline allocations in pure functions, so I don't imagine a lot of problems with scoping. Detecting this list declared as a separate variable is also possible, but this is a less common use case, and it gets more dangerous indeed (considering mutations, variable shadowing and so on). &gt; Is it really an "optimization"? I think it is. In our case, GC and allocations (which happen thousands of times per second) are a major problem, whereas variable lookups that need to check the scope 1-2 levels up are not.
I'm mostly talking specifically about inline allocations in annotated pure functions. Considering that the arrays like the one in my example contain static objects which exist for the whole program runtime anyway (I should've mentioned it, but wanted to keep my question more general), I don't imagine a lot of problems with either leaks, shadowing or something else. Is that really safe, or am I missing something? Detecting allocations that are written into variables and passed around is certainly more difficult and dangerous, but the inline case is the most common for us.
I made a game using the SpeechRecognition API and Vue, there is a little surprise if you name all 50 states ;) https://codepen.io/nickforddesign/project/full/XVkvqe/
Just use [the pastebin demo code that I linked to](https://pastebin.com/iWAPXGng) and remove the try/catch statements I added to get the full stack trace. const wait = delay =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(), delay)); const fnError = async () =&gt; { // IF YOU REMOVE THIS wait(1) STATEMENT a full stack trace WILL be created // That's what I meant with "fake async" (it still is a promise-producing function) await wait(1); throw new Error('Ooohhhh my god, this went wrong!'); }; const fnA2 = async () =&gt; { // with or without "return", this just assumes the caller wants the data // important is to "await" or the context of the calling function is lost and // there will be no stack trace in any case return await fnError(); }; const fnA1 = async () =&gt; { return await fnA2(); }; const fnA0 = async () =&gt; { return await fnA1(); }; fnA0().catch(console.error); Result: Error: Ooohhhh my god, this went wrong! at fnError (&lt;anonymous&gt;:4:11) at &lt;anonymous&gt; &amp;nbsp; Because of the `await` the actual exception occurs at a point when the context of the calling function still is available, so in theory - and what the linked V8 developer blog post says - this would make it easy for the runtime to create a stack trace (not true if you omit the `await`!). Because suspended functions are removed from the stack and placed somewhere else (and put back on the stack when they are resumed) this will only work when the runtimes add a bit of code to the stack trace generation, it is not exactly the same mechanism as a synchronous one. That code does not seem to be in any of the runtimes yet although the developer blog post sounds as if it's "soon"^TM. &amp;nbsp; Compare to the result from the pastebin code where I added the local stack at each step manually using `try/catch` in every function: Error: Ooohhhh my god, this went wrong! at fnError (&lt;anonymous&gt;:5:11) at &lt;anonymous&gt;Error at fnA2 (&lt;anonymous&gt;:13:23) at &lt;anonymous&gt;Error at fnA1 (&lt;anonymous&gt;:24:23) at &lt;anonymous&gt;Error at fnA0 (&lt;anonymous&gt;:33:23) at &lt;anonymous&gt; 
I think the point was: if you cannot enforce coding style (no inlines) you won't enforce inserting annotations.
What does this functionality have to do with React?! Soon: react-string, for having strings in React!
Why do you feel like punishing them so young?
OP's defined in global space, doesn't need a computer.
I read in a few places that the garbage collector has a problem cleaning up constants but I have no idea how much truth there is to that. Would love to know. 
oh awesome! what is happening when you use the tablet? what isn't working? we can open an issue pressure if it isn't working. also may be a limitation of what the browser is passing in, the APIs are finicky and support is sparse :/
Ah, right. I would've guessed it was inlining the functions, but that shouldn't affect the stack trace, should it?
Great links, thanks! Brilliant stuff.
Edit: formatting Unfortunately I cannot point you to any tools that would help because I am unaware of any, but I want to point something out. The "optimization" in your example produces semantically different code from the original. Consider: let Foo = 'a', Bar = 'b', Baz = 'c'; function doStuff() { var things = storage.get([Foo, Bar, Baz]); // ... } doStuff(); Bar = 'z' doStuff(); vs let Foo = 'a', Bar = 'b', Baz = 'c'; const query = [Foo, Bar, Baz]; function doStuff() { var things = storage.get(query); // ... } doStuff(); Bar = 'z'; doStuff(); In the former the second call to *doStuff* will use ['a', **'z'**, 'c'] but in the latter the second call to *doStuff* will use ['a', **'b'**, 'c'] As presented this is not a transform you can apply generally. It would only work if you can prove that *Foo*, *Bar*, and *Baz* remain constant during the lifetime of *doStuff*. Since javascript isn't typed, an optimizer can only do this in very limited scenarios. For example, if *doStuff* is aliased, e.g. by returning it to a caller or assigning it to a property on some other object etc., it quickly becomes intractable or impossible to compute whether or not those variables remain constant for all calls to *doStuff*. The example you give doesn't work generally, but there may indeed be some patterns that can be optimized. Scoping and name binding is statically analyzable so if *Foo* et al were const, then I believe your example would be safe to do, declaring the query at the declaration site of *Foo* et al. Still this is specific, and would require all elements of the array literal to be constant. Not sure how often this would occur in code and I'm not sure if there are tools that do this. const Foo = 'a', Bar = 'b', Baz = 'c'; const query = [Foo, Bar, Baz]; function doStuff() { var things = storage.get(query); // ... } doStuff(); // Assigning to Bar would be a runtime error so we know // that doStuff will always use the same value for Bar // Bar = 'z' doStuff(); Code analyzers and transformers are certainly a big space, babel, users of acorn.js, esprima, etc. So there may be tooling that does something you need. Again as I mentioned at the beginning I am not aware of any tools that do this so cannot help you there. Source, I was a dev on the [Microsoft Chakra engine](https://github.com/Microsoft/ChakraCore/pulls?q=is%3Apr+author%3Aianwjhalliday+is%3Aclosed) for many years (mostly before we open sourced, hence my low PR count).
Is it guaranteed that all of these functions are pure, or do you expect the tool to do that for you? In you example for instance, what if .get mutated the input array somehow, or even just relied on it having a unique object identity?
If your concern is about allocating the array, can you change `storage.get` so it doesn’t require an array? `storage.get(Foo, Bar, Baz)`
It would be more accurate to call React a library instead of grouping it with true frameworks. It does one thing and does it well. Quoting the React tagline "A JavaScript library for building user interfaces".
Finally made a starter repo with my FE stack of choice webpack, mithril, and modular-css. https://github.com/kevinkace/starter
LOL. Thanks edward! Your God asks you now to go forth and gather more followers (subscribers) to my cause. :)
React is a big one. Highly recommend you learn it. However, Vue is probably a better first framework to learn. It has a gentler learning curve.
Async stack traces don't work on 32-bit machines. But you aren't using one of those, right?
:) I loved ActionScript 3 back in the day. I also found that using Flash was a great way to teach object oriented programming and classes. It gave students something to visualize as the instance. Like, we have a class for a blue circle. It has instance properties for diameter and x and y position. when there was something to see on the screen after instantiating a class it made it a lot less scary for many students. 
No it would not. Try it with small synchronous functions in long loops that will be inlined for sure (you can actually use some V8 switches to get debug messages about what is inlined, not sure about other runtimes).
It performs the currency conversion too
No. As far as I can see they don't work anywhere - unless you use the "fake async" examples. See my other comment. When you remove the `await wait(1);` statement it still is an async function but apparently no longer "truely async" (the removed command decoupled processing by going through a `setTimeout`). It appers there is an internal optimization for this "minimally-async" case, in that case you do get a full stack trace.
Is it something JS noob can be interested in?
Currently no but hopefully in the future
I made a webapp that lets your friends control what song is playing on Spotify. Uses React on the front end, Express backend, Firebase, and Zeit Now for deployments! [https://partyhero.io](https://partyhero.io)
What does that have to do with React?
It doesn't work consinstently like other browsers. I found it when i needed that to format a number into italian format (from 1000000 to 1.000.000). Try .toLocaleString('it-IT') on Chrome and Safari: it simply doesn't work on the second case.
Literally. Half of my CSS work lately are only to deal with Safari scroll quirks and SVGs.
The error handling is the part what I'm least happy with, that thing is ****ing hard to do properly. Any tips on that? Blocking the search when there's no results is something I thought about doing, but didn't implement. Maybe I will in future versions. 
Simple and elegant. Nice job!
Sure, you can be interested in it... But you really should have a strong fundamental on all things HTML, CSS and vanilla JS. D3JS is super powerful, but there's a steep learning curve that comes with it. I first picked it up in 2013 and it took nearly a month before I truly understood what was going on. Since then, I've built tons of powerful visualizations and apps using it, so it's definitely very valuable. Then you try to integrate it into a framework like React. While not hard, you'll still need to learn that framework, which is also a high learning curve for a JS beginner. 
Clear the entire canvas, and redraw everything from back to front.
Thank you. I have decent understanding in CSS and HTML but as for JS I am still on the beginner projects part (weather &amp; random quote apps) so I will give it a little more time before jumping the gun on visualization tools and libraries like React. I feel it’s way over my head for now and afraid to get unmotivated because of too difficult tools. But damm it look like such a cool tool. 
You may want to ask this on r/asknetsec
Yes. If your timer is in an area where nothing else can ever be in front of or behind it, you can exclude that area from the general redrawing and redraw it once per second instead, but there are probably more important issues to worry about. It is generally much easier and less error-prone to redraw everything, than to keep track of what needs to be redrawn.
have you tried using python
I had a combination of my laptop projected on a pull-down screen, and a whiteboard which I used for the first introductory part. Each student had access to a Chromebook, so there was no hot-seating or sharing required, and everyone got a chance to try things out themselves.
Another way would be to monitor your outgoing requests and see if you can catch your password being sent to a sever. If you’re on a Mac you can use Charles.
Basically spent last summer experimenting all the approaches mentioned by the author. At the end I felt most comfortable with the "React for the DOM, D3 for Math" way. It basically lets d3 and react do what they are best at. Like the author mentioned, the problem is that you really need to know exactly what d3 functions are for. It actually made me understanding d3 better. Animation is still a pain, because you can't really do transition() unless you stop react from handling the dom.
Since this was a first introduction to a potentially-career programming language, I took a deeper dive into computers, technology and software as a whole, so that the students could get a feel for 'why' what I was teaching them was important, rather than just "do this, and see this result". 1) What is a programmer? - Got the kids to discuss what they thought a programmer did or was involved with. This summarized into things like "solves problems", "entertains people", "shares knowledge", etc. 2) Where have programmers been? - Had the students rhyme off different things they thought programmers did (along with my own revelations), like computer graphics, website stuff, business applications, entertainment/apps, office apps, etc. - I intended to also have a few of the students list off what their parents did for a living, so I could show them what portions of those careers were likely impacted by software that had been written by a team of programmers, but it totally slipped my mind. Wished I'd done this. 3) What tools do programmers use? - involved the students providing suggestions for what tools they thought I used in my job (computer, language, dev environment, debugger, compiler/interpreter, etc). I was surprised when one of the students suggested I needed a place to "put my programs such that the computer could understand", which turned out to her conceptualizing an IDE. 4) What do programmers do? - Here I switched over to my computer, and demonstrated different applications, coded in JS, which showed them the breadth of what was possible with the language (speech synthesis, 2D and 3D graphics, a nutrition app, and an astronomy app). 5) Where do programmers start? - Here I covered the very basic fundamentals (variables, strings and numbers, functions, objects and attributes) - Other items I had planned but ran out of time included arrays, loops (for, while) - For this section, I wrote out a quick sample program in jsfiddle, and the kids would type out what I'd written to try it themselves. Then I'd go around the class and make sure they'd gotten everything right before moving on to the next section. I was with them for 2 hours, and was able to get through most stuff. It was a lot of fun.
The async stack trace Mathias is talking about is the one DevTools shows, e.g. when break on exception is enabled. Not the regular Error.stack.
Could it be a TCP issue, rather than a node/express one? e.g. https://stackoverflow.com/questions/410616/increasing-the-maximum-number-of-tcp-ip-connections-in-linux
Two issues as far as I can see: 1. The buttons all share the same id, id’s MUST be unique. You’ll probably find the event only binds on the last button. Change the Id to a class or data attribute. 2. You’re attempting to read the button text using val(). Change it to .text(). Better still bind the click event to a data attribute, but also set the attribute value to the value you want to pass to your other function (in jquery You can read it via .data(‘&lt;camelCasedAttrName&gt;’) ). That way the button text will be independent of the value you want to pass. Hope this helps! 
I hate to leave nothing but negative feedback but I can't think of a single positive thing to say about this article. First of all, the approach of introducing variables by wrapping code in a function, just so those variables become arguments to a function rather than regular variables makes no sense and it's not the kind of thing functional programming encourages. Even if variables are made function arguments, they suffer from the same problems as regular let bindings in that they can be reassigned to. Compare this to using a simple const binding in place of let, which would at least get you some useful warnings if you try to reassign a value to the const binding. Aside from the lack of technical understanding of the author, the article is also written rather poorly. The author's motivations aren't at all clear to me (I don't know what he is trying to accomplish). Furthermore, there are spelling and grammar mistakes abound, and incorrect acronyms being used- though these are obviously much more minor concerns. I sincerely hope that no one reads this and thinks it actually has anything to do with functional programming or even idiomatic JavaScript for that matter.
If I had to guess, I would say the $w function is aliased jQuery function, if thats so and jQuery is present on the page, you should be able to modify the text on the #text1 and #text2 by writing: $w('#text1').text("Upload successful"); ..and so on. Hope that makes sense.
Yeap, in case it isn't clear, the code now says: "#text2".text("blabla"); While it should be: $w("#text2").text("blabla"); 
Adding the $w() did not change anything. I'm wondering if it is related to how things are ordered or something, since that code used to work until I added in the lines about saving the uploaded file to my database. 
Thank you
Also try StackOverflow site... That's the purpose of it. Do take a look at their short guides on how to ask a good question... 
Actually, that's on a much earlier node version, and they're talking about concurrent connections rather than requests per second. Thanks, though :)
Turn activeFilters into a standalone object, then: const queryString = Object.keys(activeFilters).reduce((partialQueryString, property) =&gt; { return partialQueryString + `&amp;filter[${property}]=${activeFilters[property].join(',')}`; }, ''); Also, /r/learnjavascript
If you happen to be using jQuery, it has a function for that: http://api.jquery.com/jquery.param/ If you use some of the other solutions listed in other answers, remember you need to `encodeURIComponent()` each of the values incase it contains `/` or `&amp;` or some other values that need to be escaped.
Haha good question. I have an app that uses this with the sun and moon and orbital rotations. Could add those in here as well!
So I found that instead of teaching a language, teach the kids fundamentals. Such as what is a variable, What is an array, If statements For loops While loops Etc..... This can be done without computers in many fun ways. I found especially with 5th/6th graders that you will loose so many of them bc of sentex errors and just plain silliness. An example of this might be https://curriculum.code.org/csf-1718/courseb/6/ 
Don't post code here if you can't format it (or at all, go to /r/learnjavascript instead), rather, put your code in JSFiddle, that way people can actually read and interact with it. (also, explaining what you're trying to do will help)
Thanks I'll check it out
I know this isn't the question asked, but why are you using node/express for this when things like nginx exist and are much faster?
Also check your OS networking limits. On *nixes there's the ulimit command.
This looks like a strange querystring.... usually arrays are represented by `[]` or by the same key showing up multiple times. Typically in nodejs you'll either use built-in `querystring` module or the contrib `qs` module - the difference is `qs` supports deep objects while querystring will coerce to blank string. I'd use one of those - considering your expected querystring, it looks like `qs` makes the most sense. qs.stringify({filters: { "product_filter_series": [ "product_line_a", "product_line_b" ], "primary_applications": [ "application_a" ] }}) filters[product_filter_series][0]=product_line_a&amp;filters[product_filter_series][1]=product_line_b&amp;filters[primary_applications][0]=application_a You can use `qs.parse` to turn the string back into the object. If you are using express, it will do this automagically. Should interop pretty well with `parse_str` in php as well.
This is a good question and I never want to dissuade anyone from asking questions like this particularly when starting out, but it's worth mentioning here that in literally any app code you're ever going to write, you're going to use either a library function or a util function written by your predecessor. I mean, sure, you may eventually be greenfielding a new project and wanting to write your own util function, but by then it'll be trivial for you. 
&gt; I'm using Express to write a little reverse proxy at work It sounds like the OP just wants a reverse proxy. 
[or you could just use this](https://www.npmjs.com/package/lodash-decorators)
[Reinventing the wheel](https://www.nginx.com/blog/nginx-caching-guide/). No reason to make it harder on yourself.
Don't believe this drivel. It's not functional. An **actual** functional approach to mutable state is the [State Monad](https://egghead.io/courses/state-monad-in-javascript), but even the State Monad's use case is more for when you want to depend on state without having to always pass it around, and mutate it declaratively. Just an aside - even in functional programming, variables aren't all that bad. Everyone understands them. Don't go obscuring their meaning in some bullshit attempt to be clever.
Lodash would probably be faster, but Ramda is better suited to functional programming. Yes, there is a functional variant of Lodash, but that is all it is, a functional flavour of the standard methods. Ramda goes the extra mile with autocurrying, support for the transducer protocol, and awareness of monads. But I would suggest not going the route of functional programming in an open source library. If you do, you reduce the chances of someone being able to contribute code to your project, because functional JS is still very much a new trend so there are not a lot of JS programmers who understand it quite yet. 
how are you running the load tests? if its all from a single machine then you could be hitting the open file descriptor limit for your OS. Try running it from two different machines at the same time.
Yeah I'm wondering this too. Reverse proxies are one of those things where I specifically do no reinvent the wheel. The solutions for this are already performant and fool proof. 
yea that is fair. its not horrifyingly bad now.
I highly recommend using indentation, or your code will be quite difficult to comprehend when you read it later. Avoid for loops if you can. ECMAScript's Array contains a number of built-in methods for iteration (e.g., map, reduce, every, some, filter, and forEach). They relieve the need for manual iteration, provide better abstraction than a `for` loop, and make it clear what your iteration is doing. See https://gist.github.com/ljharb/58faf1cfcb4e6808f74aae4ef7944cff &gt; I really don't know why the call back function does not work. Where? If you can provide a live example, it'll make debugging a lot easier
Did you check your CPU usage? How many workers were you running? Really you should run at most one worker per hardware thread. Also, you should just use nginx
this is the web page: http://www.identifyinglakesuperioragates.com/agatemap.php
How well does Nginx work on Windows 7 when you don't have admin permissions?
Ok, so in your code, where are you trying to use a callback? I still don't understand what your roadblock is
In your PaginatingList.js component, is there no error being thrown by the word 'while' in defaultMessages.loading?
It is in fact a very common querystring. Backends take this and either turn it into an object or an associative array
&gt;I think you can get the picture from the video titles: dealing with trees, linked lists etc. Specifics will help greatly, since we haven't bought the course. Knowing how to set up basic data structures sounds like quite a reasonable expectation, but without details of what's concerning you, it's a bit hard to say.
Can someone explain the use case for this?
I am just trying to run my JSON data through a loop so I can end up with googles format for heatmap points: var heatMapData = [ **{location: new google.maps.LatLng(44.940426, -93.292641), weight: 3},** **{location: new google.maps.LatLng(44.972668, -93.301674), weight: 2}** ]; once the loop correctly outputs the json data into google's format i then have all of my data points ready to go and they will work dynamically with the form page as users submit entries.
I just added a bit more detail above: "using different methods for traversing trees and describing each method in big O terms, building and performing operations on linked lists etc". Sorry, I know that's still not very detailed. I wouldn't say I'm concerned--I want to learn this stuff either way--I'm more curious than anything.
I second this.
All of that is pretty fair-game for interviews at both startups and major corporations.
Good to know. Better get back to the course :) 
The only way to make an API for a game is to he one of the developer s making the game
Did you try `document.getElementById("text2").text = "blabla";` ??
Ahhh okay 
Almost _certainly_ a Windows issue, where TCP performance is abysmal, but I wouldn't rule out programmer error either, given the EADDRINUSE message... My guess there is that EADDRINUSE is trying to tell you you've [exhausted all local ports](https://blogs.technet.microsoft.com/askds/2008/10/29/port-exhaustion-and-you-or-why-the-netstat-tool-is-your-friend/) - Swap the codebase into a virtualbox Linux instance and try again :)
This doesn't answer the Express question at all but where people are recommending nginx, you might also consider Caddy. https://caddyserver.com/ Since its written in Go is might work cross-platform on Windows easier. (never tried myself, just speculating based on the platform support they have on the download page)
It can, it's just disabled my default. You can enable it in js.
What I would do personally is run the codebase through https://github.com/prettier/prettier and then add https://github.com/prettier/eslint-config-prettier and any eslint rules (such as https://www.npmjs.com/package/eslint-config-airbnb , but I think the process of adding eslint will have adding the airbnb config as an option, so just install eslint :) )
Our networking team is of the mind that nginx is old school and wants to use newer solutions (dynamic discovery/mesh), though admittedly they're a bit far off from being available. I'm not opposed to using nginx but the thought was that this node-based service can be very lightweight and do our load balancing/caching in one piece, the latter being a bit custom.
This is just my local testing, naively didn't realize that OS limits on Windows 7 would be an issue. Never developed on it before. Our actual servers are suitably beefy.
Another point that the article should mention is breaking apart the fixes into separate commits. It’s really easy to run eslint and see which rules are broken and then fix individual rules via command line. This allows you to find and easily fix any bad fixes that might affect functionality. For example: eslint ./ —no-eslintrc—rule ‘semi: [2, never]’ —fix This fixes a single style rule allowing you to keep commit history clean. It also lets you avoid any rule disabling in files unless you absolutely need it.
I got that. I don't know why someone would use this over standard async code.
I see, yes, in the dev.tools I get a stack trace. He does not say (write) that? What is the reason the regular stack trace does not have it? The same applies - it is pretty cheap to produce that stack trace with the calling function context still there. I would like the full stack trace in code when running normally because the unexpected error is harder to find. For example, I have a low-level storage method called from many places in the code. When it says "File not found" I have no idea which part of the code this came from (I have many types of files representing types of objects, from direct user data to various meta data files, all of course handled by very different parts of the code). That's why I added the try/catch traps and added the respective local stack trace at each step of the call hierarchy - now I get a full trace during (non-debug) runtime. In my last big industry project (lots of PL/SQL and a big JS frontend, as so often an old project grown for years by many changing people) I added automatic logging of exceptions to the database. Since the project was huge and had quite a history - it even used two different GUI libraries since somebody had started switching form an outdated one to a more modern one but that switch was never finished (and it never will, and on the bottom line that's actually okay believe it or not) - there always was the occasional error from a very diverse user base that had very diverse use cases (it was a frontend for cost control and everybody only saw what they where allowed to, and that was very different between different organizational roles). In practice it would be next to impossible to reproduce most errors in a debug environment. You had the stack trace and error message that you got - and you have to work with that.
Hey maybe check out Traefik? (https://traefik.io/)
Thank you!
Try use keepAlive agent for the proxy, otherwise it will open new socket for every request instead of reusing.
Asynchronous code is just a single thread: `asynchronous !== parallel` Webworkers (used by that library) run in extra threads. The use case is anything that benefits from true parallelism... I mean, this is such an ancient thing, so the exact same reasons apply... look at your app. If you have to ask you probably don't need it. Heavy (parallelizable!) computations, for Javascript, which is I/O oriented, any CPU intensive work in general. The more important question is, why use a frontend library instead of just webworkers, *that* is the question hamsters.js needs to answer. Yes of course, "convenience", but I'm always the skeptic who tries NOT to use an additional lib and use just the standard methods, and only use an additional layer when it really adds a benefit. I think they don't talk about this aspect enough (or at all), they just show what you can do with the lib but not the *additional value* compare to someone using plain webworkers.
I mean, the style can be enforced in our team, but not for our target users. We can expect to have correct `pure` annotations for all our functions, but not for our users' functions.
Yeah, the repo is listed on the demo, but here it is: https://github.com/k1sul1/wp-pwa The sidebar intentionally leaks out, swipe to pull it out nd swipe in the other direction to put it back. Developer design.
Probably would be if it weren't JSX. 
Noted. Thank you :)
One worker per physical core, yep.
Certainly not all backends. The specific one you're working with apparently does but I wouldn't call it "very common".
&gt; interviews for junior positions I think you'll find that what defines the type of question you get asked at an interview varies _a lot_. Many things may influence the questions (the specifics of the position, the culture of the company, industry trends, the preferences of the people conducting the interviews, what part of the world you live in...) and you'll find many people who have never been asked this type of question and many others who have. Not that long ago it was _fashionable_ and super-clever to ask such stupid questions as how would you move Mount Fuji or why are manhole covers round. But then again, how _common_ was it to actually be asked this? Well, not that common, fortunately.
If you don't solve the perf issues, you could also reconfigure nginx on the fly from node. Make an nginx template or two, fill the dynamic values in, sudo service nginx blah, done. 
ah! brilliant! never thought of this. THANK YOU!!!! 
thank you!!! will try charles first, then give an ask!!! 
I think big performance improvements are much more exiting than an oil change for a car.
In the JavaScript world, everything wears out eventually without staying up-to-date.
HTML, CSS and JavaScript are client side programming languages. If you wish to become a backend developer that writes server side programs, then I would recommend learning PHP or python, I have found these to be the best languages to start out with. In your case there isn’t a need to learn JavaScript. There are countless tutorials on python and php on the web. 
If Node is something that seems appealing to you, then yes, you should learn JavaScript. 
Do you know what? I have learned Python and I am currently learning Django on Team Tree House! Would you suggest me anything other in this?
I am learning Django! Is it better than Node.js??
Python/Django and Node are both perfectly valid backend technologies. If you're already working on learning Django, there's no real reason to switch now. Learn Django properly, and then think about whether you should look into Node.
No.
Agreed. But in general if you want to become a back-end developer JavaScript isn't the best language choice. Always do what is appealing to you IMO. 
Those terms are outdated. It used to be that if you wanted to work on business logic parts of the application, you'd get a "backend" job. Want to work on building UI? That was "frontend." But all "backend" means is server-side, and all "frontend" means is client-side. And JS, despite being a client-side language, is used as an application language now. You can do business logic stuff in it. Hell, it runs on the server these days, even. Learn some Node and NoSQL. By the way, JS jobs are often now called "full-stack," though I've yet to meet a full-stack who understands CSS past "it's gross, let's make it be JS." I don't think, though, even if you get a job where most of your day is PHP or Ruby or some other server-side language, that you can avoid learning JS. So to answer you: yeah, learn some JS.
You shouldn't rely on errors for flow control
I disagree. A more accurate comparison would be that you woke up one morning and wanted to change the oil in your perfectly functional two year old car and add a trailer hitch. Then you found out that you'll have to completely disassemble and reassemble your car first because "everyone" decided to use left hand threaded screws and bolts with triagle shaped heads. And all cars are powered by apple juice now instead of gasoline.
[removed]
Does this mean *npm run watch* will run faster and reload my browser faster on safe? Because that would be cool!
Yes.
All I want is a nice 3 to 4 migration guide and I'll be happy. 3 had some really nice documentation that made it almost painless.
I love how this article bashes Redux without naming it :D ... love the work.
My suggestion is to follow some nodejs tutorials and try getting a basic web server running. Try expressjs for a very simple framework. It’s nice to work in the same language for both front and backend development. Cheers! ask if you have questions.
I would love to answer your questions about what the library does for you, javascript multithreading and parallelism is sill in its infancy. Even after 3 years of development the mass majority of users out there do no see the benefit of parallelism in their applications or does not quite understand the need for multithreading but that is likely to change as web applications become more complex and moores law is coming to a close (single atom size transistors). The library abstracts a very large amount of complexity for you and allows you to put individual functions on their own threads or allows you to write individual functions that are parallelized across multiple threads simply by referencing the library in the right manner. It includes a built in thread pool system and work queue system allowing you to run a parallelized workload optimized for say 32 threads across any system even if they only have a single thread, the library will simply keep that single thread busy until all 32 execution pieces have finished processing. The library also includes legacy fallback supports and works with browsers IE9+, Node.js, ReactNative, Shell Environments, and the library will function inside of existing web workers (threads inside threads, using SharedWorkers). While you could certaintly try to write your own abstractions or use the native web worker spec it is unlikely you will be able to provide the same level of backwards compatibility and the same ability to parallelize a task by changing a single argument without a significant amount of work. You can write a single function to run on its own thread like so now... ``` var results = hamsters.promise(params, functionToRun); ``` by simply changing the params object to look like this ... { threads: 2 } the same function will now be parallelized across 2 cores. The library also handles communication between threads for you so you don't have to worry about coordination between workers and you don't have to worry about the method of communication being used between those threads. When I started the library in 2015, there was even less literature about how to accomplish these things and there was no javascript libraries that revolved around parallelism, some existed to allow multithreading but they were not optimized for parallel workloads like Hamsters.js. JavaScript multithreading has an uphill battle because many people see it is sacrilegious to the way JS was supposed to work (in their minds) so it has not been easy to change the ecosystem to make multithreading something people even think about using in their applications, you will likely find that the majority of application out there are not using native web workers or any form of multithreading. 
https://github.com/webpack/webpack/releases/tag/v4.0.0
A day late but I finally released my first React Native app, rebuilt an old ionic project of mine. It’s a collaborative writing app based off on [Story Wars](https://www.storywars.net) - [the app](https://itunes.apple.com/se/app/story-wars/id1010560424?mt=8)
I thought async code like Promises we're handed off by the JavaScript engine to the browser allowing multiple threads to execute in parallel and then resume synchronous execution once those promises resolve. Is that not true?
I can try to answer this, using asynchrounous code does not allow you to execute across multiple threads. Try to keep in mind that JavaScript by its nature is a single threaded language by design, with promises we are not increasing the amount of work we can complete in a given amount of time (say 10 seconds of time) we are simply telling the browser to execute that logic when it is free to do so but continue moving forward and whenever that task completes give us our result so it's more of a way to gain better control and saying "get it done when you have the time, Ive got other things to worry about right now", where using multiple threads is more "Get this done now and get it done as quickly as possible using as many cpu cycles as my machine can muster" With Hamsters.js when you make use of the library and follow the guidelines you can execute multiple functions concurrently (1 on a thread, 1 on another thread, or 1 on multiple threads) in any combination of different threads used per function so you can run many single functions on their own thread while also executing many individual functions that use multiple threads, this allows you to increase the amount of work you can complete in a given amount of time (the same 10 seconds as before) since we can do 2 tasks at the same time or we can get a single task done in a fraction of the time. Hopefully this makes sense, async is more like time-slicing this is a good read that will help you understand how the timers actually work behind the scenes as Hamsters.js uses setTimeOut to simulate threading for legacy devices. https://johnresig.com/blog/how-javascript-timers-work/
I am currently learning Django!
Thanks aloooot bro I am looking forward to your opinion !
A Node.js application will never match the performance of a tuned C/C++ application like Nginx. However when your benchmark maxes out at 1.1k req/s what does your resource utilization look like? I highly doubt that you are I/O or CPU capped. Would recommend generating some flamegraphs to pin the problem down. Most likely some innocuous looking synchronous operation wrecking performance.
Interesting. Still a bit foggy on this though. If I executed: `const test = (async () =&gt; { // Do lots of work here return answer })` const test2 = (async () =&gt; { // More heavy work return answer }) Wouldn't that do all the processing in the background without blocking the single threaded the JavaScript engine is executing? Or am I misunderstanding something?
Kill -HUP REStarts nginx with new config. I do that to dynamic route I watch a folder mounted in a dockerized nginx that has socks. The render as they come in. Ngnix isn't old school
Cool idea.
can someone give us speed comparisons. I'm sticking will rollup.js for now.
Elixir. 
Well figured this out that I missed a dev dep called "@vue/cli-plugin-pwa". Installed it and built again, simply worked.
I have not tried this inline test style. Three issues I could see running into: - Noise. Some functions have a lot to test, whether they can be rewritten or not. Reading through the code, I think people would have to go with a single `Tests` per function with unique export or concat them into a single `Tests`. (How to test classes/objects with methods?) Reading the code could be hindered by a large amount of tests. (Do I really care to sift through the covered edges when I am looking for a function I already know to use?) - Test complexity. As much as we all want unit tests, when we move into more complex tests (perhaps with setup/teardown boilerplate), `Tests` will have to create a more full featured testing system. Certainly code I don't want to own. - Scope. Modules/files do effect variable scoping. I think the biggest problem with colocating tests and code is that the tests can use the internals of implementation to valid correctness, which is a really bad coupling. The implementation and tests have access to the same variables if they are in the same file and developers need to be very aware of that when writing tests. Tests should be decoupled from the implementation they test. I think without good discipline developers would fall into the trap of writing tests for what the implementation does, not what the implementation should do. (That already happens, but I don't want it to happen more.) I see other languages doing inline testing so it can't be all bad. These are problems I think I would run into if I found myself on a JavaScript project doing things this way. Good luck with the open-source runner, I can't say I know of another inline-test oriented runner (maybe Ava would let you..) so paving new ground is a good thing for everyone.
Because it might be easier for cross-platform usage on Windows. (one of the concerns raised when people brought up nginx)...
I think you might be mixing up the purposes so when you say &gt; Wouldn't that do all the processing in the background without blocking The goal here isn't so much to avoid blocking, though that is one of the benefits. The goal here is to increase the amount of work you can do in a given amount of time or reduce the amount of time it takes to complete 1 test or do both tests at the exact same time. 
It's definitely not as a strong when compared to Django and a lot of other languages to be honest, but in my opinion the Phoenix framework for Elixir is poetic and it's just so minimal, sufficient and its FAST. To answer your question, you should 100% learn JavaScript.
Found another reason for you. nginx is limited to 32-bit on Windows. Caddy can make full use of the available memory on 64-bit systems.
No.
From the windows nginx known issues: &gt; Although several workers can be started, only one of them actually does any work. &gt; A worker can handle no more than 1024 simultaneous connections. http://nginx.org/en/docs/windows.html#known_issues
Okay, thanks!
And if you had read any of the thread you would know that OP is having this issue on **Windows**...
And if you'd read any of the thread and paid attention you'd know that he's _developing_ on Windows but in production his company uses proper servers 
AFAIK, the documentation and migration guides are forthcoming. I think it's kind of hard getting a release like this out the door - especially from a large OSS project not sponsored by a business (e.g. react/fb). The team opted to get the functioning code released (purposefully over a weekend) to get some initial hands on time from tinkerers.
Finally? When I last used it (July 2016), I thought 2.x was still in beta. 
I've been using "zero config" webpack via next.js for a bit now, and yeah, sensible defaults are like 90% of the time all you need. It's a really good call
Depends on your current configuration. All I had to do was add a `mode` option for `development` or `production`, remove the `CommonsChunkPlugin` in favor of the new `optimization` options and upgrade/remove any plugins/loaders that I found that hadn't been migrated (removed with the intention of adding them back later). This last one, here are some common TypeScript/HTML plugins and their upgrade version: "extract-text-webpack-plugin": "4.0.0-alpha.0", "fork-ts-checker-webpack-plugin": "TypeStrong/fork-ts-checker-webpack-plugin", "html-webpack-plugin": "webpack-contrib/html-webpack-plugin", "ts-loader": "~4.0" The existing configuration I had, just kinda works after messing around with it. I think most of the new stuff is so you don't need to be explicit about every little thing.
Rollup and webpack are for fundamentally different things (library vs project), right? Looking forward to seeing speed benchmarks as well
I saw those somewhere, will report back if I come across them again. AFAIK, rollup and webpack are geared towards different use-cases - libraries vs applications - but that may not be totally accurate.
That's traditionally been the case, but Rollup recently shipped an experimental code splitting feature (which works very well IMO, no overhead like webpack), so it might be changing.
If you come to r/javascript and ask if you should learn Javascript, you're inevitably going to get people telling you to learn Node... "Should I learn" is a subjective question. In terms of employability, Java is probably your best bet for backend (relatively easy language, very widely used). Yeah, "it's outdated", "eww", "boohoo", we've heard all the whining against it. Still popular. C# is also popular, and Go is gaining some popularity. For Node, yes you need Javascript, but in my experience, you're inevitably going to do some frontend (or will be expected to know it) if applying for Node jobs, whereas that's often not the case with the other languages. Python and PHP are also options but my anecdata is that they are falling out of fashion - I know at least Uber and Duolingo are moving away from Python (towards Java/Go and Scala, respectively) for similar reasons (performance and lack of typing being big ones). You can read about the Duolingo effort here: http://making.duolingo.com/rewriting-duolingos-engine-in-scala If you want a programming job and specifically want to avoid frontend, I'd suggest learning about tools like databases, protobuf, elasticsearch, jenkins, docker... not necessarily master them, but at least know what they do and some basics.
Thanks for replying. Ok, I think that I understand the link you gave. I guess I would set the crossorigin tag on the script element of my injected script?
That sounds about right--I've been getting mixed messages talking to different people. I guess the best way to go is just to prepare for anything. It will make me a better coder, regardless. 
No problem, if you want to see the library in action and get a better understanding, play around with this example and use your activity monitor and watch your cpu usage as you select different numbers of threads. If you set a really high number like 50 million, it can take several minutes to complete completely maxing out a Core i7 https://www.hamsters.io/examples/collatzconjecture
Yeah I didn't even think to look for an existing solution before writing this. I kinda just used it as an excuse to learn more about the decorator syntax. There is something to be said for the code size though. lodash-decorators is a significantly larger code-base, and my approach isn't specific to Lodash: const myDecorator = easyDecorator(fn =&gt; { return function decoratedFn() { return fn.apply(this, arguments); } });
Isn’t the `arguments` object always allocated? You make a good point on your other concerns though. This also prevents you from having additional positional arguments, although you might still be able to have those if there’s a reliable way to know when the “first” arg is finished. 
Objection is pretty great with what it does. If you need a lighter weight query builder, do try knex. If you are looking for something closer to rails Active record then try Adonis framework Lucid ORM, only downside is, it can only be used with the framework
http://lmgtfy.com/?q=png+to+bmp+javascript
thank you ! :) we browsed it for 2 hours before posting. any idea?
In that case simply use an nginx docker image and spin up as many nginx instances as you like
IMO whether front or back end dev, it’s still important to at least have a basic knowledge of front end languages to include HTML, CSS and yes JavaScript. If you don’t plan on being a front end dev, no need to go crazy learning all of the intricacies of JS, but understanding how it works in the browser is important.
I think using plain HTTP requests in your examples is better than an SDK example. It makes using your example code easy in other languages.
I think I'm going to have to make an extension that looks for all h1-h6 tags and remove emojis from them...
It depends on how you are adding the image to the canvas. As an example, if I wanted to add an image to the Canvas I would do something like this: //c is my canvas //context is the 2d canvas context let img = document.createElement('img'); img.crossOrigin = 'anonymous'; img.onload = function(ev){ //context add the image to the canvas here } img.src = 'https://www.example.com/image.png'; Now the important thing that this script does not show is that the server, www.example.com, needs to return the Access-Control-Allow-Origin header, and it has to have the value equal to the domain of the page that contains the canvas OR "*". Without that header the image will be tainted.
Why stop there? Any HTML tags...
One of the things we did was split apart main code from test code. In general we treat tests as first-class-code but if you're focused on shipping you don't want to block releasing code when adding new tooling to catch theoretical errors on code that works okay for users in prod. So we focused on linting production code first (which gives you an immediate benefit in terms of shipping less bugs) and then expanded it to test code once we'd fixed all the production code.
Interesting! That makes sense. 
Docker not usable yet at my firm. Big mega firm so some stuff is slow to evolve.
EmojiPack 4
Thanks for the response. When trying this, it did not recognize "document" and displayed an error. Maybe because I'm using Wix. The weird thing is that the code DID work before, so it might be an issue with order or placement? 
Not all heroes wear capes
Better to put code in JSFiddle so people can interact with it, and to use JSFiddle instead.
I saw yours and also tried to make one as an example for my frame work [rilti.js](https://github.com/SaulDoesCode/rilti.js). [rilti.js Pexeso CodePen](https://codepen.io/SaulDoesCode/pen/VQELvM)
Ok, thanks never heard of it.
please do!
The basic functionality works for me here: https://jsfiddle.net/nzrb2b5m/ You should check out Javascript scoping. When you define an (ES6) variable inside a block, it won't be accessible outside the block. If you want something async to be accessible outside of its block, then the easiest way is to assign to an outer variable. In other words: define `botName` and `oauth` at the top level, and then assign to them later.
I also can't change the readOnly boolean property of the fields to true, if I try and press enter on the fields they are still editable.
put `&lt;script src="jshook.js"&gt;&lt;/script&gt;` after `body` tag. It is not the best solution, but that should solve your problem. Better solution, initialize variables when page is loaded. https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload wrap all the code in jshook.js in `var init = function(){ ...here... }` and call it window.onload=function(){ init(); } 
Huh, it works for me on that fiddle (with all the invalid stuff taken out)... By the way, since you're using ES6, it's probably recommended to use modern module syntax: https://github.com/airbnb/javascript#modules--use-them You can export just with `export { botName, oauth };`, it's a bit easier.
Did you just assume he *wasn't* wearing a cape?
A nicer way is to put the script tag in the header (where it semantically belongs) and use `&lt;script src="jshook.js" defer&gt;`.
Perhaps I did not explain my use case well, or more likely I do not fully understand: I am making a chrome extension that injects code into a 3rd party webpage that I have no control over. It loads the canvas, I only want to inject script to call toBlob on it and then save it to disk. If I understand your kindly code above, you are requesting an image from the server, while I want to save an image that the page has already requested and loaded into a canvas. I feel I am missing something here..
I copied your javascript code and it works now.. odd. Thanks.
As long as you use webpack, for our next release post, I'll include a screen cap of this response ;)
I'm sorry if it seems like I'm trying to attack y'all or anything--I mean nothing against you or webpack at all! I love using it and [donate to it on OpenCollective](https://i.imgur.com/OlpldbM.png) (one of the first, actually!). I'm not just a fan of emojis in headings and it kind of strains me when I'm just trying to read the announcements.
There are a few studies out there suggesting performance issues with proxies. Here, for instance: http://thecodebarbarian.com/thoughts-on-es6-proxies-performance 
That's pretty fair. Honestly it sounds crazy but it's for marketing reasons. Statistically we've seen mulitple-fold more engagement in our articles by simply adding emoji. Sounds absurd I know. How about this: what if we had a separate, "more accessible non emoji" version that we link to at the top if it does cause strain?
I mean, I'm the one being picky here so I think the onus is on me to do something about it. If it really does bother me that much I should be the one changing _something_, either myself or something else. To say that y'all should go out of your way to accommodate me just isn't the way I like looking at things, honestly. That said, I'm not going to stop using or donating to webpack just because of some emojis—I like to think I'm not _that_ petty :p
I'd like to help... if I can. You're right blockchain isn't just about cryptocurrencies. 
These are not incorrect, but they lack context. They compare the fastest (static, monomorphic) property access with Proxy performance, which is prime example of a microbenchmarking. Try to add any common JS operation - like function invocation or object destructing - to the mix. Proxies are slow compared to one of the fastest JS operation, but they add a minimal overhead in real word front-end use cases - with a lot of different operations. I measure and profile performance after every single release and it is as good as Redux and better than MobX. (See the link I sent before.)
Is your production environment windows?? 
Since others have gone over the “help” part of your question, I just wanted to point out that if you’re doing a reverse proxy in Node you’ll do way better using standard `http` instead of express: https://raygun.com/blog/node-js-performance-2017/ Generally you’d only use something like Express if you have api routes and lots of middleware. But a simple reverse proxy will basically just pipe streams all day, so just use plain http. 
This code reselects the `&lt;title&gt;` each time, does it inefficiently (use querySelector to select a single element), and fails when there's no initial `&lt;title&gt;` tag. Rather than manipulating the HTML, it's probably better to set the title directly.
Thanks for your review. The problem is I tried ES5/6 native methods and they are slower than ever with Babel set to Node 6 (Methods like add/remove takes 2X) ... I still don't know how my library could be found by someone else yet^^
I know but I found strange that native methods are in my test up to 2X slower than Lodash stuff ... 
&gt; It's already at the bottom of the fact, it doesn't work. `defer` is better, but it is a new feature, some browsers may no support it. More important probably is to explain what is the problem: variables `botNameField` and `oauthField` are initialized before page loaded. There are other problems with them. By the way, that code module.exports = { botName = botName, oauth = oauth } what it expected to do? 
This was the most wholesome interaction I’ve ever seen on Reddit
okay maybe i should start over. i can load geojson data and i can access the values just fine shown here: https://jsfiddle.net/mooncheese69/69e1yntm/33/ so knowing that, i want to create a function that loops through my data set and outputs data in an array like this format below: **var heatMapData = [ {location: new google.maps.LatLng(37.782, -122.447), weight: 0.5}, {location: new google.maps.LatLng(37.782, -122.443), weight: 2}, {location: new google.maps.LatLng(37.782, -122.441), weight: 3}, {location: new google.maps.LatLng(37.782, -122.439), weight: 2}, {location: new google.maps.LatLng(37.782, -122.435), weight: 0.5}, {location: new google.maps.LatLng(37.785, -122.447), weight: 3}, {location: new google.maps.LatLng(37.785, -122.445), weight: 2},, {location: new google.maps.LatLng(37.785, -122.441), weight: 0.5}, {location: new google.maps.LatLng(37.785, -122.437), weight: 2}, {location: new google.maps.LatLng(37.785, -122.435), weight: 3} ];**
Webpack 4 is definitely a lot easier. `CommonChunksPlugin` was a huge pain in the ass and with http/2 push coming up its not a big deal at all. Although now that I think about it you might want to periodically check that the same numbered files are still being creating before trying to push them.
`module.exports` doesn't work in browsers `botName` and `oauth` - are global variables references on HTML elements with those IDs (open debug console F12, type oauth+enter) jshook.js var formValues = { } function init(){ document.getElementById("botName").addEventListener("keypress", (event) =&gt; { let key = event.which || event.keyCode; //console.log(event); if (key === 13) { event.target.readOnly = true; formValues.botName = event.target.value; } }); document.getElementById("oauth").addEventListener("keypress", (event) =&gt; { let key = event.which || event.keyCode; if (key === 13) { event.target.readOnly = true; formValues.oauth = event.target.value; } }); } html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Kierans Chat bot Front end&lt;/title&gt; &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"&gt; &lt;!--- Scripts --&gt; &lt;script src="jshook.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function(){ init(); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col"&gt; &lt;/div&gt; &lt;div class="col-6"&gt; &lt;form&gt; &lt;div class="form-group"&gt; &lt;label for="formGroupExampleInput"&gt;Bot Name&lt;/label&gt; &lt;input type="text" class="form-control" id="botName" placeholder="Insert the name of your bot"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="formGroupExampleInput2"&gt;Oauth token (starred out): &lt;/label&gt; &lt;input type="password" class="form-control" id="oauth" placeholder="Oauthentication token goes here.. (keep secret)"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="col"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 
Usually in a situation like this where the page's JS needs to get a data value, your page's JS would call an API on the server - are you sure your other script should be `.js`? Javascript should be loaded statically, and not conditionally. If your main script might use some information only available in another .js file, include them both on your page (or, even better, use a module bundler, if the data doesn't change).
I created a project to allow easy creation of simple icons. www.faviator.xyz
You ought to use the watching provided by webpack instead, it keeps a cache in memory that you lose from running the process repeatedly via for example npm watch
Nope, RHEL.
That's pretty eye opening, thank you. The one thing this little service will do aside from just piping around streams is caching, so we do take a look at the JSON getting POSTed before sending on the request. I suppose I could go back to node's req.on('data', fn) and whatnot, but man that syntax is so ugly. But, if that's where the performance is, I'll test it out.
Hi /u/MungoProudFoot, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/LDDb8, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/jewishrambo12, For javascript help, please visit /r/LearnJavascript. Thank you!
Remember the request object is a stream. Embrace that instead of using the .on(‘data’) events. If you’re caching, and you have control over the clients, use a header to indicate a cache key (ex: the md5 of the request body) so you don’t have to buffer or parse the json (slow and expensive). That way you can just look up the header, check the cache, and intercept the request without even ever parsing the json unless you really need to. If you must parse the json to determine if it is cached, do it as a transform stream and a streaming json parser if your data format fits (you may be able to avoid the wait for the whole json object to come through).
this would be great! would the answer or links to relevant information to find the answer be included?
That's what I plan. Plus community discussion.
Yes, it's a great idea.
Native reduce is really slow yeah, but the performance isn't worth bringing in a massive lib by itself, plus future V8/Turbofan stuff can always change this. Dig into Lodash internals and you'll find that in many areas they fall back to native methods in the end.
It's not strange. When you call `.map` on an array, the array is iterated and a new array is returned. If you then call `.filter` on the returned array, the returned array is then iterated and a new array is returned. That's 2 iterations for 2 intermediate collections. Lodash sidesteps this by making your transformations lazy - resulting in the array only being iterated once. That's where the speed increase comes from. Of course, the logic to manage this laziness has a performance downside as well, but it's not as bad as multiple iterations - far better, in fact. Transducers however, have the benefit of no intermediate collections without the need for laziness. They are eager, just like for/while loops and native map/filter, but the idea behind them is that you essentially group all the logic inside one call to `.reduce` (usually this happens for you, you need only care about calling `into` or `seq`) and compose different functions together into a "transformer" that does your filtering/mapping/etc. Each map/filter function will return a function that accepts a reducer and returns a reducer (the fact that the input type is the same as the output type is why they can be composed), that controls how elements are transformed/filtered and controls whether or not a reduce is called on the accumulated value or even if the entire operation should be short-circuited (in the case of `takeWhile`, `takeUntil`, etc). In the case of a short-circuit, the proceeding elements are left untouched and the iteration exits early. There's another benefit to transducers whereby they're essentially data-structure agnostic. The same logic/functions that you use to map/filter arrays can be used to map/filter objects, generators, iterables, ImmutableJS collections, RxJS event streams, etc, as long as they implement the transducer protocol (and even if they don't, you can add it yourself).
The little kids face in the headline image is *precisely* the opposite of my expression when I realize I need to think about Webpack again
Ok. Now I understand what you are asking. The problem is with the image that is being loaded into the Canvas. IF that comes from a different domain that the Canvas then the image will be tainted and you will not be able to retrieve the data with toBlob(). IF the image is coming from the same domain as the HTML file that holds the Canvas then you should be able to do it. The fact that your script is from somewhere else shouldn't matter.
Oh I didn't know I can do that, do you know how?
That's not true. The PHP code escapes the user input safely. The reason this XSS works is because it's possible to get the PHP to output a valid Vue expression inside of a Vue template. Try it, take the `index.php` file and remove the line that includes vue. Try injecting whatever you want it won't work.
Code bro, don’t apologize. Quite frankly you can achieve this is so many ways with some many different technologies. If you’re looking at composing this in elixir you’re stepping into functional territory which is different to MVC territory, which is how you’d go about it with PHP. If you decide to go Elixir route, using the Phoenix framework you could pump out a JSON API in a day (even less) and that API is going to be fast, its going to be like Usain Bolt fast 💨 but it’s new and still gaining respect. With the Elixir Phoenix API you can easily modify Phoenix to handle a SPA with a few edits in the config (just don’t install brunch, that shit is lame) - use webpack or my Rollup (Rollup is my preferred, saves those kb’s son) In terms of your client side (front-end) it always smart for career choice to follow the trends and the sheep, but if you’re a wolf, instead of going balls deep on React or Vue, you can always try my and many others personal favorite JS framework “Mithril.js” - this 8kb (gzip) framework is poetry and while it hasn’t seen the popularity Vue, Angular or React have seen, it’s just as powerful imo and is actually faster then those 3 and the gitter chat is basically a family, those geniuses always helping out everyone. My closing advice and suggestion would be as follows and how I would handle this: Use Elixir on Phoenix for your API, use Mithril.js for your client side SPA and for your bundling use Rollup.js. However, don’t take my advice as gold, it is very opinionated and most people would advice otherwise, especially the circle jerkers and Zuckerberg fan boys (smh), however if you’re looking for speed and you don’t want to pull in 20+ additional modules, then you’re going to enjoy this approach and you don’t want to end up with some 350kb production file, like most these tech tards are outputting these days (no offense guys) that’s how I’d recommend you do it. With any project of your type, things are always bound to change, so more take this opportunity to get comfortable with whatever your choice might be! Best of luck. Code on my bro! Code on. 
Sounds more like a PC issue than a JavaScript one. Here's a list of things you probably need to do (in no particular order): 1. Restart your computer 2. Re-install your browsers 3. Run an extensive virus scan 4. Defragment your hard drives 5. Run a disk cleanup utility 6. Empty out any temporary folders 7. Update all your device driver software
Hi /u/collegeapps2018, this sub is for talking about the language, not support. You might try in /r/techsupport.
I can't say for others, but for me email once a week is more convenient. And Friday is perfect day.
I'm so confused as to why this bothers people. 
i did all of these things repeatedly i’ve done ip resets and SO MUCH MORE i still can’t fix it 
It's a great idea. Will be more awesome if an app can built for that
I had this idea a few weeks back but I haven't done any work on it yet, would you be open to collaboration?
No thank you. This is what I have reddit or twitter for. 
The fact that you are mixing server side code within front end templates is already code smell.
You can add ASP.NET+SQL Server+IIS to your choices.
So basically not sanatizing, the server is passing user inputted data. It's a typical XSS vulnerability. 
How are you going to create blocks: PoW, PoS, permissioned block creation?
I know you link to sites that use the icons, but you should really add a screenshot to the readme too.
use https://www.npmjs.com/package/midi-sounds-react if you need sounds in React
Hi /u/StreamSniffing, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Yes.
On backend stuff? 
Yes. ASP.NET handles the controller and model with C#, SQL Server is the database and IIS serves as the web server. I picked it up very quickly at work.
Thanks! I'll keep that in mind. But C# jobs here in my place are not that frequent.. 
The meat of the "vulnerability" is that the server code is using a blacklist (the htmlspecialchars function) to sanitize user input, but that function doesn't sanitize Vue expressions since those are delimited with `{{}}`. This can be fixed by replacing htmlspecialchars with a variation of it that also escapes curlies. The problem on the Vue side, from a library design standpoint, is that it defaults to enabled evaluation of expressions, and this design makes a fundamentally bad assumption that all HTML is not just trusted, but also _executable_. By contrast, with a system that does not evaluate templates (such as React), HTML is inert (i.e. effectively treated as untrusted and non-executable), and the only way to inject shenanigans in the page is by literally importing code somewhere (which any half-decent code review should catch), or via a script tag (which a properly configured CSP should catch). Of course, one could inject malicious code into some deep deep dependency and sneak past code review, but that's a different can of worms. 
Language doesn't really matter. You will be able to adapt no matter what technology you use as long as you understand the fundamental concepts of software development and programming.
Sounds good to me :) but every day may be too often. 
Honestly, I think styled components might be broken by design. If someone has some good arguments for why this library should be used, please tell me.
Legato also means thecat
Went in expecting yet another crappy comparison article, but instead found it a thorough and enjoyable set of articles. It's nice to be out of the echo chamber for once. Thanks for taking the time for writing these!
- When contesting whether to learn React or Vue, learn both. They are both equally simple to "get a rough idea of". Vue is easier to master than React, since it has a smaller API surface area (you don't have to learn as much as you would with React at the very beginning). React has bigger market share though, and also dominates the mobile app tech space. Vue has Weex and there is also NativeScript which puts Vue as a contender in the mobile app space, but React Native far surpasses it in market dominance. So for hireability it is important to understand React enough to use it in practice, but you will definitely benefit from understanding Vue as well. I normally use React for extremely large projects, but for small weekend projects, I find Vue to be a better fit. Angular is not as important. Yes, it's used a lot in enterprise, but with the popularity of React and Angular's track record of changing core concepts, I'm around 83% certain no one is starting a new project and deciding "Hey, let me use Angular for this". I think it'd also benefit you to do some light reading on Svelte, Inferno, Re:DOM, CycleJS and Choo (what you do after that light reading is entirely your prerogative). - When choosing a backend, it really does not matter. All web servers will 90% of the time have the same concepts regardless of language or framework. This can be carried over between technologies. As an example, consider the similarities between Laravel, Ruby on Rails, ASP.NET MVC, Grails, AdonisJS and so on. The real interesting stuff that lives on the more cutting edge with more modern architectures are frameworks you'll find for Go, Rust, Erlang and Elixir (which runs via the Erlang VM). The latter 3 especially, and especially when you're dealing with real-time concurrent connections (all four of them are adept at coordination of concurrency). None of them have the same amount of corporate presence as Ruby, JS, .NET, Python or Java - however - a lot of companies are adopting these technologies. I know Discord uses Erlang/Elixir and Python for their backends. All of this being said, I will put emphasis on the fact that exposing yourself to multiple programming languages, architectures and so on will make you a better programmer and more hireable. Even if it is not practical experience but just some involved reading, it will still be to your benefit. I actually have an example to share - the other day I was swimming in a 90k+ line of code JS project that uses currying (via RamdaJS) extensively and I was finding it difficult to determine whether a function being called was an *actual* function call or just returning a curried function. I remembered an old Python basic koan: *Explicit is better than implicit*. Knowing that RamdaJS supports a placeholder symbol (`__`) for curried functions, I re-factored all of the curried calls I possibly could (in the code I touched at least) to use this symbol. Now, I know exactly which calls are curried and which are not. If I hadn't been exposed to Python, I probably would have never made the connection. - The learning curve of GraphQL is not steep at all. It is in fact very easy to understand. It is just not immediately obvious how one would implement caching, authentication or recursive queries for tree-like hierarchical structures of unknown depth. ApolloJS' GraphQL client makes 90% of this "grey area" a lot easier, conceptually. As for the remaining 10%, in my mind it's a tradeoff. You're trading cacheability for portability. A GraphQL backend is 100% entirely decoupled from any frontend. Any frontend can use it. A REST API that supports caching might need to have separate endpoints for separate devices. Learning GraphQL will absolutely be to your benefit. It is effectively a game-changing technology, and even if short-lived (which I doubt it will be), the knowledge you gain from involving yourself with it will put you at an advantage over your competitors (whether they be other job candidates or companies). - I covered a little bit of this in one of my previous bullet points, but again it doesn't really matter. You could just choose to further your own understanding of what you already know and are comfortable with (which I'm assuming is Object-Oriented PHP), which will still benefit you - you'll become better at it. However, I highly recommend you expose yourself to other varieties of architectures and design patterns (regardless of what language you pick) as it will make you more capable. In multi-paradigm languages, extra knowledge of alternate architectures can really shine. For example, Aspect-Oriented programming can really help with getting rid of cross-cutting concerns (e.g. you want this function to calculate a total but the boss wants it to be logged but now your `calculateTotal` function is concerned with logging which is not ideal). Functional programming can help with re-using code, making logic more modular, preventing race-conditions and making code much easier to automatically test. Domain-Driven Design can be exceptionally useful when you need your code to have a strong "core" set of logic that can be extended or augmented by third-party code, etc. It would also be beneficial to learn about data structures and algorithms that can be transferred between languages. Things like Communicating Sequential Processes or the Actor model for coordination of concurrency, Binary Trees or Tries for quick classification and searching, Monads for abstracting repeated logic away (like Maybe/Option for Null guards, Future/Task for eventual values, etc), sorting algorithms like Heap/Bubble sort, and how things like depth-first (as opposed to breadth-first) searches can help with performance. I realise this sounds quite daunting, but it is absolutely necessary if you want to be a top-notch developer. That being said, life is not a race. Don't rush it. If it takes you a long time to get to the point where you feel like you know all this stuff, then that is 100% okay. Any learning you do along the way will still be there if you take breaks. The key is to enjoy what it is you do. If you feel like you are lacking in enjoyment, then don't be afraid to stop for a strong minute and breath in some fresh air.
I love nestjs, so clean
I was originally going to pick some random frameworks - including one for NodeJS for some reason - and then wrote out their "features" from Wikipedia, along with some preconceptions of my own. Then I was going to conclude by saying "You should make up your own mind" or "it depends". Damn, now I wish I'd written **that** article.
Wait why is a map of routes needed? Next.js will just use pages, no? Also I hear they are moving to RR4.
- You don't type the parentheses when you pass a function to another function. You're giving `setTimeout` the return value of `timeoutTrigger()` here. - `setTimeout`, like most things in JavaScript, isn't blocking. If you call it a bunch of times in a loop, all of those timers are going to trigger their callbacks at the same time. You need to account for this.
still the same.
The first parameter to setTimeout() should be a function: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout Your code is executing timeoutTrigger immediately and passing the result to setTimeout. Now I am assuming timeoutTrigger doesn't return a function, so what you actually need to do is the following. setTimeout(function () { timeoutTrigger(); }, 1000); 
webpack-dev-server
It is a matter of taste. Nest has that enterprisy object oriented lasagna feeling that appeal so much to hardcode MVC Java and .Net devs. Don't like it where I can get elegance and leaner cleaner code with FP constructs.
I assume you just want to open a page every 1000ms or so. You should do it using setInterval, it's the easiest approach to the problem. `clearTimeout` - check this out, it will not be infinite loop anymore
[removed]
You're not alone, it makes it look like an article about a kid phone app and not the powerful tool that it is.
did what you said, used i*1000 and window.open() is now inside timeoutTrigger and it solved my problem partially. Now pages open after the given time interval, but the same page opens multiple time, the page which is supposed be at canList[last].href opens in all tabs.
 function timeoutTrigger(href) { window.open(href); } for(i=0;i&lt;canList.length;i++) { setTimeout(timeoutTrigger.bind(this, canList[i].href), 1000); } instead of for loop it's easier to use forEach in this case: canList.forEach(function(href){ setTimeout(function(){ timeoutTrigger(href); }, 1000); });
still all the tabs open at the same time.
Word! Daily is too overwhelming and I will end up skipping most. 
First of all he doesn’t need an arrow function. He’s not executing the function in his code anyway. He just passed a ref of the func to setTimeout which is fine. And your example can be just simplified with setTimeout(timeoutTrigger, 1000 * i) assuming he just needs to open pages one second after the last
Ah, now I see what you want to do. if you can use async/await, then it's easier to use [this answer](https://www.reddit.com/r/javascript/comments/80bpri/settimeout_not_working/duuevut/) If you need the "classic" js, then you can use a recursive function: function openPage(list, i) { i = i || 0; // check if the index is still in the bounds if (i &gt;= list.length) { return; } setTimeout(function(){ // open the page window.open(href); // setup next page opening openPage(list, i+1); }, 1000); } openPage(canList); 
yeah this is good and simple code, never thought about this.
Why email?
Make it optional which day to receive an email and frequency. 
If it was me I'd introduce "handlebars" or something similar so I could seperate the html out into its own file. Advantages this gives you are; * more programmatic control over the output * less cognative load when reading code Would be pretty easy to put in too - you should suggest it 😀 
Hi there, I'm John from ag-Grid, we are the only datagrid that supports 8 major JavaScript frameworks and also delivers all of features within the one component. You can use our Community edition for free or get in touch with us to take the Enterprise version for a two month trial - info@ag-grid.com Hope this helps.
The first was just to demonstrate that sTo wants a function. The reference is fine of course, but you'd need the other if it needed to pass further args, like the index for instance. &gt; And your example can be just simplified with setTimeout(timeoutTrigger, 1000 * i) That, for me, wouldn't be a simplification. The function is behaving asynchronous and it can easily be expressed as such. Upside is also that the entire thing can now be awaited from outside.
I can't find the linked sites??
Like most examples out there, I've implemented proof-of-work (asynchronously, btw. Most examples out there use synchronous hashing) I actually don't think I've seen a proof-of-stake example yet. I would say PoS is also more appropriate for coin-based blockchains, since their value is your "stake".
Any help is welcome. Issues, pull requests, ... :)
Maybe your selector is called before all the elements are loaded into the DOM?
my script loads on document_idle(default setting of chrome) so all the elements should have been loaded by then.
guess maybe my selector was getting called earlier than expected. I moved it inside a function which gets called on a button(custom button I added) click and now it works as expected.
Why do you think it is broken? I have not have any problems with it. Decorate your component using a named template and get a namespaced styled component. This puts all that is needed for that component inside its file. I have had more issues with specificity in vanilla CSS. Without styled components, I like to use functional CSS (utility classes) with a few BEM components.
What about private repos?
Oh OK I will look after it
Hii ! Thanks for it! I am currently learning Django from Team Tree House :)
I am learning Django :)
When you run in local, origin is localhost? (or 127.0.0.1 ?) Also about the cert, it seems weird that I could make any request to an https server from a "local non https server". When I try in local with my apache it does not work (can't do request from http to https and vice versa, or I miss something).
Agreed. Daily is way too frequent 
RSS would be nice.
I literally just updated to 3 last week. :(
I’ve always found browser based IDEs to be rather clumsy or to suffer due to their design. On windows for example I can batch up a pile of files I’d like to edit: (Files.bat) C:\path\to\editor.exe c:\path\to\file1.js C:\path\to\editor.exe c:\path\to\file2.js C:\path\to\editor.exe c:\path\to\fileN.js Then run the batch file and my editor populates with all the files. However doing this simple action with an Electron app like VS Code fails. :-(
Make sure the DOM is ready before you run scripts like this. 
Wow, guys, that's impressive feedback, I think this night will be long :).
Let me know what you guys think. This is my first attempt at writing a tech blog post and would love feedback.
Zero-config is a lie and hidden configs are one of my biggest pet peeves. Yes, it'll work for whatever hello-world example you develop it with, but as soon as I need to do anything remotely complicated, the "zero-config" falls flat. It very quickly becomes "proprietary-config", where I'm jumping through hoops with your janky, halfbaked solution, to do simple, well documented things with established tools. Even worse with "hidden config" since I have to spend hours poking around your source to fingure out what the hell you're doing in the first place and how the app is running. Why people think hiding information is a feature is truly beyond me. Maybe if we started calling it "obfuscated build system", it'd be more obvious what an utterly stupid idea it is. If you want to be helpful, provide well documented, decently written and sensibly structured project templates.
As far as I can see, styled-components works by injecting css into the document in runtime. This means you have to enable unsafe-inline in your CSP, making you vunerable to style injection which is sort pretty bad. Styles are pushed to javascript, requiring the client to parse and execute it, delaying first paint. Finally the auto-generated classes, while nice for avoiding conflict make debugging quite a vit worse imo. I like the idea of styled-components. The dev ergonomics are great, but I think the price that you pay for it is simply not worth it.
Actually I don't know why the people do like "zero-config", and don't like to extract the build config in CRA (create-react-app). May be it goes from the "frustration" about Webpack's configs and linking other libs and deps into the project all together, I guess. 
You can absolutely make a request from an http served page to an https server, but not from an https served page to an http server. What I meant about the origin was that you will need to make the allowed origin match your local origin. During dev, just make it * to keep it simple. In production, you will absolutely want to serve your client with https and limit the origin to match the client. 
Not for email but for these questions😂
the second part: https://blog.softwaremill.com/it-depends-on-the-registry-8fa9d9c5a3b
What about this? https://stackoverflow.com/questions/2163828/reading-cookies-via-https-that-were-set-using-http Cookies will be unsafe isn't it? And for the origin in local dev mode I use 127.0.0.1 it's working fine, but I was saying this because of the "executable" part. When you make an executable with JS, the origin is??? Localhost or 127.0.0.1. Maybe it's pointless I don't know but it seems to be an issue to me.
Nice explanation of what I consider to be one of the biggest gotchas on JavaScript. My one criticism is the way you are describing as deeply copied object as being immutable, it’s still a mutable object, you have just broken all of the nested references. If you want the object to be immutable, you have to use ‘Object.freeze’ to prevent any mutations. The catch there is you have to use Object.freeze every time you copy, and if there are nested objects, you have to make sure to do the same on all of them down the tree.
I think people assume that they can use a script and not have to learn webpack, especially when they just want to get up and running. Plus, most of the project creation tools seem to create massive, over engineered solutions, so they can provide the generic functionality and fancy features. So if you do later decide to dive into them, they are really complex and intimidating. Always seems like a false economy to me. You're better with a simple build system you actually understand, and can improve/expand over time.
https://phrasegenerator.com/politics https://lukerissacher.com/battleships
&gt;In "true immutability" you do not mutate. You construct new values. Deep copying, or really copying at all, evaporates as a concept because a reference to the old value is just as good. you still copy, it's just that every copy can become a shallow copy because you don't need to worry about mutation.
Yeah Electron is serving from files and I see some people getting troubles with https on github. About the link yes http =&gt; https works only if you set "unsecure" cookies. Why am I using Cookies? For sessions. First a JWT is created from server A then transmitted to server B (not the same domain, so I'm doing SSO). Then server B check the JWT and create the session, express set the cookie and store the session in redis. Because the client is talking with 6 servers to do the job, each of them require the cookie to be able to load the session from redis. But if I don't store the cookie inside the native application maybe it's fine enough (aka destroying the cookie when closing the app, user will have to re-login and session is preserved only when the connexion is alive, but does it will work for all servers? Because only the auth server is decrypting jwt, create the session and cookie).
I don't know of a way for a malicious user to pull cookies OR localStorage out of an Electron app. That doesn't mean it's impossible, but it might not be an issue. If that is the case, then it's arbitrary how you store the tokens. I have no idea what you are even asking in your last question. You are going to just have to try it and see if there is a problem!
Lots of in tandem, carefully orchestrated transforms, scales, fades, and a few other effects. With this much going on, it might be simplier to render the scene with the canvas rather than html elements.
I think that I will have to test all cases lol. I already wasted 24 hours in a row to correctly set the cookie for all servers (all are on the same server) because documentation on express is not correct / not complete lol (I created an issue ^^). My last question was "if I destroy the cookie when the user leaves the native application, it should be ok because we don't store any credential, we just consume them to create the session and destroy everything when the game is closed" (not really a question, I will try this way lol).
Fair point. I guess I got a bit muddled with the definition of immutable. The point was more that the copy creates an object that cannot mutate the original. Immutable is the wrong word here as the copy is still a mutable object. though I'm not sure what the correct word to describe it would be. The point of the article was more to highlight that simply using `const newObject = {...oldObject}` isn't as immutable as it's often claimed to be. 
Redux is already super lightweight and easy to implement. Does this really have that as an advantage?
I'm not sure I follow what you're getting at here. Is deep copying not constructing a new value? Unless you're making a similar point to /u/CNDW ? The point of the article was to dispel the notion that using the spread operator (or Object.assign) creates an immutable copy of an object and the dangers of never thinking about the difference between deep and shallow copying.
That funny there isn't so many transducers library ... typescript-transducers and Transducers.js seems to be the best one
He’s making the same point I was. Immutability is an attribute describing a variable’s ability to be changed. Sure, by making a deep copy you are simulating immutable behavior, but both the copy and the original are still mutable. The copy can be mutated just like the original, you just copied the values without references to the original so if you mutate the copy it doesn’t mutate the original.
Definitely a nice proof-of-concept, and the simplicity is very appealing for small projects that don't anticipate scaling. I think the most enticing part for me would be having all 'bound' 'action creators' available to all connected components without having to manually import them and add them to connect. Makes me wonder what would happen if I created a HOC to bind all action creators to all my components in a Redux app. Assuming action creators were highly structured so that it was easy to access the one you wanted, that *might* not be a bad idea... but I'd have to get a feel for it in practice. Not sure how that would affect customized action creators which were bound to `ownProps` values, for instance. Could probably create those using `recompose`'s `withProps`.
The spread operator is how you work with immutable data. The only thing that causes data to be immutable in JavaScript is programmer discipline in not mutating anything.
The world doesn't need more apps.
I was thrown by this as well. I thought maybe the author doesn’t understand what immutability means, and the paradigm of programming as if all objects are immutable — used by React, Redux, et al. — in which you don’t ever do any deep copying, because there are no mutations to defend against. On reflection, the author may be talking about a situation where you need to take an object that may be mutated by other code — it is not being treated as immutable — and put a copy of it into a Redux store, say. I can’t think of when you would need to “blindly” shove a JSON-like deep-copy of a mutable data structure into an immutable data structure, without writing code that walks one and produces the other fresh, but it could happen.
I preffer MobX. It's simple and has additional functionality to handle derived data.
No, the title is definitely accurate. See my analysis on my other comment.
Hi /u/donyd4, For javascript help, please visit /r/LearnJavascript. Thank you!
http://processingjs.org Processing is really handy for things like this. I've used it for several projects.
Hi, Author here. I feel the message of the post has been lost. Part of this is due to my incorrect use of the word 'immutable'. The data isn't immutable, and you're right, with **actual** immutable data you don't need to worry about deep vs shallow copying. What I was getting at is that it's often touted that simply using the spread operator, or `Object.assign` will make your copy doesn't mutate the original. This is not the case. I'm not suggesting you ever use the deep copy methods outlined in the post. Though on reflection it can come across that way. The end of the article says you really shouldn't be doing deep copies, and if you are, you should be looking at your data and seeing why you're needing to do it. I feel I've opened a can of worms here. I may have to write a follow up to this and try and get some of them worms back in the can.
My main beef with online IDEs is that js code editors suck. Bob wants vim key bindings, Joe wants flow integration, Mary wants custom eslint+prettier setup and I want something that doesn't lag on large files. My criticism of code collaboration is this: why would anyone want to work in a codebase that can randomly lose stability as other team members write code, refactor, etc. A dev environment needs to be buffered from irrelevant breakages, and this is one reason why we don't work straight on production servers anymore.
Good idea, just added a couple - didn't want to pollute the repo with documentation images but looks like I can store them in a branch.
I actually don't bother with any libraries if I'm using transducers only for arrays. I find this to be enough: function compose2(fn1, fn2) { return function() { return fn1(fn2.apply(this, arguments)); }; } function compose(...fns) { return fns.reduce(compose2); } function arrayPush(array, item) { array.push(item); return array; } function transduce(collection, xform, reducer, accum) { return collection.reduce(xform(reducer), accum); } function into(accum, xform) { return function(collection) { return transduce(collection, xform, arrayPush, []); }; } function map(fn) { return function(reducer) { return function(accum, input) { return reducer(accum, fn(input)); }; }; } function filter(fn) { return function(reducer) { return function(accum, input) { return fn(input) ? reducer(accum, input) : accum; }; }; } Usage: const xform = into([], compose( filter(...), map(...), ... )); xform(data);
Ah, nice. You seem to have good students!
From the docs, [document_idle shouldn't run until after the dom is ready](https://developer.chrome.com/extensions/content_scripts), but that's the *initial* dom. Maybe there's some JS on the page that hooks into the load event and inserts more of your elements after that.
Thanks. I'll have a read. React is pretty cool. :) I'm an angular/angularjs guy.. so it's not all magic to me, but it's still significantly different enough to throw me off.
Just give me VSCode in the browser with google docs mutual editing
Well, that's cool to see, now that I've spent multiple weekends trying to get the hang of Redux. FML.
You can also host them on any other website (gyazo, imgur, etc.) And just link them
Because I was interested in what people use nowadays I just googled for „js canvas library“. https://konvajs.github.io/index.html looks interesting. I also use easeljs some time ago. But honestly: I would build it with vanilla js, maybe throw in some react for the ui. Drawing on a canvas[1] is already pretty simple and it should not be that hard to support touchscreen devices. [1] https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API
I’ve been looking for a resource to introduce state machines to others. This does much more. Thank you 
So much of it is state management and learning one-directional data flow. You'll notice early on that two-way binding is not really a thing.
Not having actually done this, my first guess would be to just create a series of divs and add a class that brings color via css to the div on mouseover.
Ok sir!
Does anybody else thing that the Context API conceptually awfully looks like Angular services?
Thx for sharing.
I'm a Redux maintainer. No, the React team is definitely not doing anything with Redux themselves :) That said, the Redux team is looking at updating React-Redux to use the new context API to make the store accessible to connected components. We're also going to need to do some work to deal with some of the upcoming async-related changes in React. The new React context API is not _directly_ intended to replace Redux, but I will agree that it can help solve some of the use cases for making data available to deeply nested components without "prop-drilling" through all the intermediate components.
Any particular aspects of Redux you're having trouble with? Any areas of the docs that aren't sufficiently helpful? Let me know if there's any specific questions I can help with. You may want to check out [my list of suggested resources for learning Redux](http://blog.isquaredsoftware.com/2017/12/blogged-answers-learn-redux/), the [Learning Resources docs page](https://redux.js.org/introduction/learning-resources), and the [Redux Tutorials section](https://github.com/markerikson/react-redux-links/blob/master/redux-tutorials.md) of my [React/Redux links list](https://github.com/markerikson/react-redux-links).
This sounds similar to something I've thought about creating (but not for stock prices per se). Can you upload your gif to imgur or similar hosting service, and post a link here? There are lots of general purpose online graphing/plotting tools, not sure of any specific to stock price history though. Try posting in one of the data visualization subreddits for more suggestions on stuff like that.
Some of you might know [quicktype](https://quicktype.io/) for inferring TypeScript types from JSON. We've now added support for [Flow](https://app.quicktype.io/#l=flow) as well as [plain JavaScript](https://app.quicktype.io/#l=js). For the latter we obviously don't generate type definitions, but we do generate verifiers for it (for Flow and TypeScript, too). quicktype also take JSON Schema as input, and [our CLI](https://www.npmjs.com/package/quicktype) generates types for GraphQL queries, too. Let us know what you think!
There's always a few who keep me on my best game. :)
Great article. I can't help drawing a comparison with Redux. With it, the state transition rules are colocated to a) the affected state value and b) the action that affects said state value. const balance = (state, action) =&gt; { switch (action.type) { case 'DEPOSIT': if (state.status === 'open' || state.status === 'held') { return state + action.amount } else { return state } // ... } } With Redux, you might get some duplication of `state.status === 'held'` checks, but with the approach in the article we get duplication of `deposit` methods. I'd argue that if the implementation of `deposit` were to be different between `open` and `held` states (either by requirement, or by mistake), that distinction would be crystal clear in Redux, whereas probably not in the article. Also, I think the problem with both approaches arises when a transition isn't as clean as doing some state changes after reading from some local state. Let's say `close` required the user to specify another account to transfer funds to if the balance was non-zero. Said account could be closed, have deposit limits, or it might only be available asynchronously due to being in another bank. This means we might need to introduce time and error handling into the equation. Redux skirts around the issue by not handling async at all (which might be fine to keep Redux clean, but doesn't really help me as a consumer of the abstraction). The approach in the article abstracts away state checks by making `account`-specific assumptions, which would make it difficult to extend to include arbitrary checks. It seems like a more holistic approach would be to use something like streams.
Can't agree with this enough. I hate how people release "yet-another-0-config-batteries-included-webpack-based-webpack" and think it's an upgrade compared to learning how to correctly configuring webpack in the first place. It's exactly how you put it: It works for hello world. But anything different becomes a nightmare. 
You'll thank me because you will be debugging some hellish bugs if the two states get too out of sync.
Yes, it's hard to find an example small enough to illustrate the mechanism, but complex enough to explain the real-world considerations. A colleague pointed out that it would be useful to talk about low-cohesion models, and I'm giving that a serious hard-think.
Heya, Mathias from the V8 team here. I’m the author of the blog post under discussion. &gt; Unfortunately the author didn't respond to questions via comments or Twitter, so I'm asking here. Can you please point to the comment or Twitter post that I neglected to respond? Generally, I try to respond to every single (legitimate) question I receive. &gt; Does anybody know why there is such an optimistic blog post when it does not work anywhere? As you point out, the blog post mentions that it is not yet implemented. I believe there is value in talking about optimization *potential*, and not just optimizations that are implemented. It sounds like you disagree with me on that. The underlying message of this post is that **new ECMAScript features are often more than just “sugar” — they tend to enable optimizations at the engine level**. As such, [we shouldn’t transpile them away](https://twitter.com/mathias/status/914891668536659970).
If you squint really hard, maybe... You could argue that yes you could can use contexts to swap injected things for testing, but that's about it. Angular's DI, as far as I can tell, uses a standard type-based pattern for declarative injection that is commonly used in Java/C# frameworks. The Context API is more for hiding things from intermediate components. AFAIK it doesn't have a concept of dependency graph resolution (thus it's not really suitable for service-style architectures), and it's more geared towards imperative programming (it's basically a one-off getter/setter with a continuation-passing style API).
Keep in mind that Error.stack is not standardized. But you do have a point that it would be possible to create a stack trace based on the async call chain. It just was never implemented. How about filing a bug to crbug.com/v8 ?
So js isn't exactly the go to language for these type of things. Usually people gravitate towards python/R as they have better tools and have a larger more developed community. However, believe it or not in just the last few days a new machine learning framework for js was released! You can check it out here - http://propelml.org/
Did angular services add tight control over visibility? Last time I checked anybody could just randomly inject services into everything..?
I know you're asking for a framework, but before you go down the path of rebuilding this, let me leave this here as food for thought: Functionality-wise, you could add a listener for touchstart and touchend events over the "drawing area", and use those coordinates to determine where the user was drawing with their finger (and which squares to color). If you're having display issues, I'd argue that your Javascript should be fairly agnostic of the CSS, and a framework might not be a magic bullet. $0.02
You might want to look at [this project](https://github.com/mattdiamond/fuckitjs) first as it shares your ideology. Seriously though, errors exist so that when things go wrong you know where, when and why they went wrong. Making invalid code work is not a solution, it's a menace. If Data.info *may* be undefined and it's expected, write `Data.info &amp;&amp; Data.info.numbers`. The same result, but everyone looking at the code knows Data.info is *expected* to be undefined sometimes. Oh and you also get to not screw with core types. I bloody hope you can't extend undefined but if you find a way then we all die.
It's very bad practice to meddle with the base structures of the language like that... you should either explicitly test to make sure the properties in question exist first (preferable), or use try-catch, or use a function. https://github.com/tc39/proposal-optional-chaining The above proposal might eventually exist officially, though.
https://www.reactiflux.com
/r/learnjavascript
What theme is that??? 
`?.` is long overdue, but to override `.` is silly on so many levels.
Redux is excellently documented. Very thorough.
CSS
I don't normally respond to troll comments, but since I'm the semi-official keeper of the Redux docs: do you have any actual legitimate complaints about them? If so, please file issues (or even better, PRs to help us make them better)! I'm always open to actual constructive ideas for improving the docs.
There is no undefined prototype. It's a primitive. And neither will an undefined literal be implicitly converted to an object, because the spec specifies that a TypeError be thrown instead.
What about applying a proxy to the data you get from api?
Yes, you know what I would have liked giving examples as parallels in other frameworks. For example this is what helped me understand redux (I haven't use it in more than 1 year so I'm sure I'm rusty). Redux has many similarities with a pubsub system. Actions are a way of publishing the reducer is subscribing to this. If you want an excellent example of quality documentation and easy to understand say no more: https://vuejs.org/v2/guide/ 
Add an event listener inside a function that runs when the slider changes
you could do it without recompose. whatever is done in withProps can be done with the same render prop style as the article is doing. hook into whatever functions you want then export that, and wrap your jsx with `&lt;WithProps&gt;({ stuffYouwant }) =&gt; ... &lt;/WithProps&gt;` that being said it's a style thing *for the most part*. I'm definitely seeing a trend moving away from hocs
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [didierfranc/react-stateful/.../**index.js#L20** (master → 45475b1)](https://github.com/didierfranc/react-stateful/blob/45475b144afa89049eed8021896ec042064a0af1/src/index.js#L20) ---- 
redux is a pretty small library. you would probably get more mileage from just reading the source than worrying about the docs
&gt; I bloody hope you can't extend undefined but if you find a way then we all die. You can't change the global ```undefined```, but you can change it inside a function (It doesn't say it anywhere in MDN but I think that trying it in strict mode will make your computer catch fire)
Fair, I'm just thinking of the easiest way to adopt the idea into the current design of my Redux app, which already includes a lot of `compose()` chains. I haven't quite gotten in the groove of render props yet, although I'm excited that the 'movement' has finally spurred a v1 of the context API.
Literally impossible. ;) const inp = document.querySelector('input[type="range"]'), btn = document.querySelector("button"); inp.addEventListener("input", () =&gt; btn.disabled = false);
Wow, thank you for the effort and time to write this up man. Appreciate it. I'll be reading it off after work so I would understand better.
I don't want to sound rude, but this is a problem that just about everyone who has ever worked with API data has already solved. There are ways to deal with it, but trying to change the way undefined works is not one of them.
Better yet try Nuxt! It makes the already-simple-to-use Vue framework way better!
Shirley you jest, MoTTs_. I just read earlier today _everything_ in JavaScript is an object! So... there's that.
did you try to ask the creator?
Yes. This is how you would do what you're explaining: Proxies.
Ouch. Sorry. Interesting :-? There's gotta be some way.
It should solve the problem where react-redux essentially implements its own version of `shouldComponentUpdate`, no?
Use Flash ;)
TypeORM works well. Have app in prod with Postgres+TypeORM
Here you go: https://codesandbox.io/
Nope. There are no SSR, can not use any loader, no issue tracking integration, no private projects, etc.
Hey thanks for posting this - this is pretty much just what i was looking for.
Running in the browser is not suitable in this case. We need an integrated development system, and not a component playground.
Just added with a simple time travel middleware https://twitter.com/DidierFranc/status/968238160755994629
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [didierfranc/react-stateful-example/.../**devtool.js** (master → 9cc9a70)](https://github.com/didierfranc/react-stateful-example/blob/9cc9a70db059767b3d45d63c3fa4ea427dbd395a/src/devtool.js) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply duvhuqu.)
Should have stated that I thought I read, wasn’t sure indeed ;). But I think if you are able to replace Redux with the context API you did not need Redux in the first place. Or at least that’s what I hope for, because otherwise it seems to me React is getting out of scope.
Hi, Thanks. I've tried it and it works. I didn't use hardcoded anchor tags instead I used post so I wouldn't need to affect every paragraph on my page. postEls = document.getElementsByClassName('post'); for (var i = 0; i &lt; postEls.length; i++) { postEls[i].innerHTML = autolinker.link(postEls[i].innerHTML); } 
This looks like after effects. You can jut make a photoshop file with all of ths layers and animate it in after effects.
Eeee i don't see it being applicable to large scale applications. I think author completly missed the point of Redux as state manager and might not have experience with larger React projects. I agree that Redux is not always the answer. But author's solutions seems like reinventing the wheel and doesn't really give any benefit especially since it's more like event management than state.
&gt; Also you’re not supposed to have multiple Redux stores, not that it’s hard. Exactly, that's a huge problem with this implementation IMO.
I contacted the code creator, Greg Jacobs and he was the one who wrote the postEls code. One more (unrelated) question please, do you have any idea how to instantiate [this github repo](https://github.com/herkyl/ingredients-parser) and use it to fetch the ingredients on my website. I tried but it seems like there are too many files. Do I add all the js codes in the files to instantiate them and also would the postEls code work for something like this? Thanks.
I find baffling the sentence just after that one. &gt; These properties are referred to as own properties i.e. properties set and gotten from an instance of an object rather than the object’s prototype or another object in its prototype chain. I'm afraid this article does more harm than good when trying to remove confusion. That sentence there subtly introduces this idea of "an instance of an object" without any care about it. Maybe, I don't know, do objects have instances? One? Various? Is it any different from the object itself? What is it then? Later it introduces some _vague_ explanation of `this`: &gt; Whenever the inherited function is called, the value of this will refer to the inheriting object and not the prototype where the function is defined. And then uses an example with: words, two boxes which are not connected to each other in any way, tiny pieces of code that suggest the `step9` is somehow _duplicated_ (i.e. exists in both boxes) instead of being "inherited" in any way. Is this really helpful? --- Maybe the author should have started by avoiding the idea that all this is somehow "magical".
Yeah, I've certainly seen Redux compared to "a pair of pubsub emitters". Obviously `store.subscribe()` is one, and you _could_ view `combineReducers` that way if you squint hard enough. What other framework parallels are you thinking of? We have lots of people who are very happy with the Redux docs the way they are right now, so just throwing out a link to the Vue docs isn't very actionable for us. But, I do genuinely ask that if you have any concrete suggestions for improving the Redux docs, please do file an issue or PR.
Possibly? Depends on what kind of "resources" you're looking for. The Redux docs definitely don't cover anything about GraphQL, because that's outside the scope of the Redux core. On the other hand, I know I've seen several community-created libraries that will fetch data via GraphQL and insert it into the Redux store - try searching through my [Redux addons catalog](https://github.com/markerikson/redux-ecosystem-links).
no thanks
What I’m saying, is how is that an advantage, if Redux is purposefully designed the other way? Not like it was some oversight.
JS is not going to be fast enough at-scale to do anything outside of toy problems. I've written a few by hand and have used a handful of the available ones and unless you are doing some pretty state-of-the-art tech, I'd go with `python` and the myriad of tutorials that walk you through the packages. If you are dead-stuck on using JS, I'd start with just creating the functions yourself and using RxJS or some other observable/stream library to keep your "neurons" in sync. Past that, it's all `MapReduce` from there on out and RxJS makes that trivial.
Yep. The main thing the author doesn't seem to get is why reducers are called reducers (i.e. the turtles all the way down way that Redux works). With the event emitter approach, you only ever get access to the root of the state tree, which makes things like fractal state (or any deeply nested state, for that matter) a pain in the ass to deal with. It's also not very clear how an event emission is supposed to be consumed from within React. With Redux, you use `connect` to select the slice of the state that you want and compose an HOC, which admitedly is verbose as hell, but with this, I don't get what the alternative is at all.
How is this different from classical inheritance in other languages? Isn’t it essentially the same as having parent classes, child classes, inherited methods (or properties), etc.?
Also, http://statecharts.github.io is a great intro to statecharts!
Hashtags are pretty neat when you use them the right way :-D 
Yes
Codesandbox.io
What’s the source? This sort of looks like a concept animation. Could be that it’s all done in After Effects and rendered as a video. Any proof this interface exists?
Heya! CodeSandbox author here, we're working on some of the features that you highlighted here, including server side evaluation. If you have time I'd love to talk a bit more (maybe via Discord? https://discord.gg/KE3TbEZ), because I really like the ideas you suggested. Also, we're pretty bad at showing what features we have. We do have loader support and the possibility to create private projects.
Maybe I'm an idiot and/or maybe it's changed but I found the "use with react" section not very clear, it didn't even cover use of `connect` when I was learning it and the parts on `connect` (wtf up with that name, I don't understand why it's called connect. doesn't seem obvious to me.. but I digress...) Kinda left me asking wtf does this do. That was a while ago so hopefully it's updated. I'm on my phone and walking home so I don't wanna look ATM. Also I hate JS destructuring... It's so damn confusing, probably just takes getting used to but I really don't care for it and could see how it might confuse people starting out.
Codesandbox.io is VSCode in the browser. Literally.
Carefully
Yeah, I opened up an issue a while back [suggesting we completely revamp our docs on connecting Redux to UI layers](https://github.com/reactjs/redux/issues/2591). I unfortunately am busy with a bunch of other things right now and don't have time to work on it myself, but I'd gladly give direction for anyone who wants to tackle it. Similarly, the React-Redux API docs have been semi-buried in a Markdown file in that repo. I've got someone who's interested in completely restructuring them into more of a "getting started" / "advanced techniques" / "API reference" structure, and we will hopefully publish them using the same toolset as the main Redux docs. As for the syntax... we have to pick _some_ level and go with it. We _could_ just write everything in plain ES5, but the JS language spec is far past that, so there's no reason to limit ourselves there. ES6 came out the same year as Redux did, and destructuring is part of the ES6 spec. Plus, the community isn't staying back with ES5, either. With tools like Babel, people routinely use language features that are still in the mid-stage approval process. We _do_ have a docs page explaining what the object spread operator is and how to leverage that, but since that is now part of the ES2018 spec, that page can probably be updated and/or go away entirely.
Thanks. Yeah I'm sure I'll get used to destructuring but it's so confusing at first. Been in Java land doing Android last year or two so I haven't played that much with that aspect of es6
No, you can only consume things if you control the producer or the producer allowed you to consume it in a very specific way. That’s fundamentally different from how a generic / global DI system works.
I've reimplemented this [using ES6 classes](https://gist.github.com/aynik/27a48644b813e8aa15be27d77644964d).
Hi /u/sahil_kumar1339, For javascript help, please visit /r/LearnJavascript. Thank you!
Yeah this is a prototype not a full developed app. Most likely made in principle or flinto. Both have trial version, give them a shot. 
But you can have just one if you want though. This doesn't require multiple stores
Really depends on what you're building. One of the downsides of redux is when you need to merge or nest multiple redux dependent components / applications. Redux is good for what it does, but these types of solutions are great for potentially different concerns. 
Loop through the labels using a class. let labels = document.querySelectorAll('myClass'); for(let i = 0; i &lt; labels.length; i++){ labels[i].onclick = function(){ toggleDiv(this); } } For the togglediv function function toggleDiv(x) { if (x.style.display === "none") x.style.display = "block"; else x.style.display = "none"; }
Generally with something like that you would be doing it via a loop in PHP, NodeJS, etc. Unfortunately HTML is a fairly wordy language so if you're stuck doing it by hand
It doesn't have to be an advantage to be. Some people just do stuff because they can, and publish blogs about it because it's kind of interesting 
They listed it as a “pro”.
Ngrx is an Angular implementation of the redux programming pattern. It can be a good way to learn about state management before jumping into it with react. Especially if you already know angular 
But most likely After Effects
It’s so super simple. You can find a minimal implementation of Redux, redux-thunk, and react-redux, with like 100 lines of code. Taking a look at that and implementing it myself helped my understanding a lot.
Ayyyyy, the indiekings affiliate spammer, continuing on another account after /u/youngflash is banned.
@'s are decorators. Not annotation. They are actually functions that execute. So it doesn't really make sense for an @Override decorator to exist. What would It do?
I saw this recently on reddit http://demo.rekit.org Looks good but I haven't tried it out yet. Maybe something like this?
This I like very tidy as well
I forgot to put a .myClass on the querySelectorAll.
&gt; if you control the producer or the producer allowed you to consume it in a very specific way. How's that different than any non-stringly typed DI system? It's entirely possible to do something like @Injectable class NotExported { constructor(a: Foo) {} } @Injectable class TheRealDeal { constructor(notExported: NotExported) {} } and never be able to consume `NotExported` elsewhere since its type never got exported out of its module. Obviously the big difference is that Angular uses type uniqueness as a DI key. A more similar comparison exists in a [Next.js-like framework](https://fusionjs.github.io/creating-a-plugin.html#services) my team has been working on: instead of using string names like Angular.js, it uses unique runtime tokens, which can be exported. A plugin can have as complex a dependency graph it wants and yet it can maintain that entire graph private. This would be equivalent to having an library-internal Provider/Consumer pair.
I think they sound inauthentic :(
document.body.appendChild(createdElementHere);
I’m gonna be “that guy”and constructively criticize your English even though this isn’t /r/English. You meant: &gt; How is this type of illustration made? This is because the verb comes second (or sometimes first) if it’s a question, and because “this type” is singular (isn’t it?). Hope this helps. 
You can use `prompt` to get input from the user. var name = prompt('What is your name?'); You can create an element with `document.createElement`: var div = document.createElement('div'); You can obtain a reference to an existing element by giving it an ID and using `document.getElementById`: &lt;div id="foo"&gt;&lt;/div&gt; var div = document.getElementById('foo'); You can set the text of an element by assigning a value to it's `.innerText` property. div.innerText = 'Here is some text'; You can append an element to the end of another element using `.appendChild` (`document.body` is a built-in reference to the `&lt;body&gt;` element): document.body.appendChild(element); That should be enough information for you to piece this together yourself.
Tweening, and lots of it. The animations themselves are surprisingly simple, but you need to define all element positions mapped to a state hierarchy, which takes some thinking.
I did a tutorial on this recently: https://youtu.be/iWsjJU45nDU
I hear you man, I also spent a week or two trying to understand Redux and when I finally do, then suddenly there are newer, simpler Redux alternatives
Don’t assign onClick handlers for every row. Use event delegation to assign a single onClick listener on the table itself. Look for event.target to match events that come from .myClass
&gt; because I like the visual indication that a given method is from a parent type. Why not just add a comment in that case? class Foo { // Override bar() { } }
Regardless of the actual code and what you are trying to Steve achieve, I find the bashing of other devs really off-putting :/
Ok
This guy is the correct answer
I'd be flattered if someone tried to put me down in a module like this.
Use MDN for reading about DOM and JavaScript plus HTML basics. Essentially your JavaScript will be a script run on an HTML page (loaded via script tag) that listens to html elements through events and manipulates the html.
I can't tell from the readme if this a real thing or some kind of joke. Hard pass. 
Understandable😂. It's for real, I use this for my site https://LessonShop.net It works very well!
Why? If special chars are an issue and you don't need regex matching then just ... don't use a regex in `String.prototype.replace`. From your own example: "SpecialTest .*+?^${}()|[]\\ SpecialTest" .replace(".*+?^${}()|[]\\", () =&gt; "$&amp; $$&amp; $$$&amp;"); If you still want the regex flags like `/gi`, which apparently is the other point of your code, you're probably better off with a function that just escapes regex chars: str.replace(escapeSpecials(/@#$%^&amp;*/gi), () =&gt; "whatever");
Cool, but fell apart on the first thing I tested: sqrt(x) = 42;
Advice: don't treat your audience like they're 5: &gt; At its core, we need to make 3+G+Y = 10002. That sounds impossible, right? G and Y aren’t numbers.
TBH, I think my big problem was figuring out when to use it. Adding state management isn't a solution to the problem of convoluted design. :P Once I tore it down and rebuilt, things went a lot smoother. Now I just have to figure out the reducer--I finally got it returning the info I wanted, but I'm not sure how....? Thanks for the resources!
There are always alternatives, doesn't mean that those alternatives are worth the effort to learn over redux. Everything changes so quickly in js land these days its never a bad thing to hold off until something graduates from a good idea to proven tech. 
That’s really slick! How long did this take from start to finish and what library did you use for the QR implementation?
Do you really believe that your solution is easier than mine? Does Internet Explorer supports () =&gt; ? Is it possible to use variables with your example? Does the below even work? UserInput = "@#$%^&amp;*"; str.replace(escapeSpecials("/" + UserInput + "/gi"), () =&gt; "whatever");
 document.querySelectorAll('tr td').map(elem =&gt; { let el = elem.querySelector('div'); elem.querySelector('label').onclick = () =&gt; { el.shown = !el.shown; el.style.display = el.shown ? "none" : "block"; }; });
lol, aggressive much? My intent wasn't to perfectly duplicate your code, it was to make something useful, which frankly yours isn't. &gt; Does Internet Explorer supports () =&gt; ? It's syntax for a function... the question is just plain ridiculous
Hey, nice to see you here! Sent you a message on Discord.
I made a simple dodging-lasers multiplayer game using node and socketio: laser-game.herokuapp.com. I actually created this a little over 2 years ago as my first real js project and never got around to server side verification of players moves among other things to prevent cheating so the game is extremely hackable. Luckily, I’ve noticed that the data on the server gets reset every so often so any hacking should get erased. It was a fun little project I put together though!
Hehe, ridiculous is what you suggested, Hehe! tried () =&gt; in Internet Explorer, didn't work! Anyway, I discard your alternative, mine is much much better and easier to use!
Hehe, Yha you right, You need to grow up little kid! By the way little kid, a lot of windows 7/8/8.1 users use Internet Explorer! Now go, go cry to your mommy! Bye!
Seriously stop and look how you're acting. Glancing at your posting history this childish behavior seems to be extremely common. I don't know how to help you except to say grow up.
Hi /u/Tlr321, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/deus-bebop, For javascript help, please visit /r/LearnJavascript. Thank you!
what? Are you crying little kid? don't please don't, don't cry little kid, Hehe!
Your parent class `StateMachine` depends on its child class, `Account`?
What app is that?
Should make a graph out of the data rather than text.
That's also a good idea, perhaps better and cleaner
You start it right this instant, then post your specific problem so that people can help you. No one is going to piggyback you all the way.
Not particularly familiar with Java's `@Override` annotation, but this is what I would recommend OP do if all they are looking for is the visual indication that the method is overriding a parent's method. OP could even just use the `@override` [JSDoc tag](http://usejsdoc.org/tags-override.html), and it would accomplish the same thing. /** * @classdesc Example class * @class */ class Foo { /** * @returns {undefined} */ public hello() { console.log("Hello"); } } /** * @classdesc Example child class * @class * @extends Foo */ class Bar extends Foo { /** * @override * @returns {string} */ public hello() { console.log("Hello World"); return "Hello World"; } }
There's a github link in the article. It looks like it's a class you can instantiate and pass as a prop and then utilize when components need to talk to each other. I think the idea is to get rid of switch statements or to not bother with the `connect` and just pull from central store/state. Could be worth a look. It was just something I found on Medium I thought was kinda intriguing.
What have you tried so far? What is your "background script"? Does it have an interface for you to send an array of links?
&gt; Transpiling a decorator doesn't require Babel. Ts already does this. Cool, I use flow which doesn't have the full build ecosystem that TS does. &gt; So it's basically useless I completely agree, but if you read OP's original question I don't think they'd care since they just want is as a "note"
Right now I have the list of links in my content script, can't figure out how to send it to background script. In background script I can use chrome.tabs.create to open the links. But here can't figure out how to check if the last tab has been closed or not and only then open the next link.
IMO that's only worth doing if you're going down the full path of adding JSDoc annotations
thanks for the link
Well, the usual way for one object to talk to another is for the listener to have an exposed method that the other object calls. If the new tabs are on the same domain then you can use an `unload` listener.
Added some code of what I have tried so far.
Ok that's fair that the op mentioned he doesn't care in java that it's optional so if that's the case then yes I suppose a noop would have the same effect. Fair enough.
Yeah sure. I don't mean to downvote you for posting this. I just feel like the author is trying to replace something that they don't really understand. Redux is built the way it is to suite the need of the many and it is a state manager. From what I saw in this medium this Substate is like getting to event listener callback hell all again.
Wow website looks awesome. Congrats on the launch. Also as /u/sieabah said do make a graph.
That’s exactly it. It’s a poor wording choice on my part which has lead to a lot of confusion unfortunately. 
Java's `@Override` is checked by the compiler. If your method doesn't override anything in the superclass then it is an error. 
It would be more elegant to use .map to get the hrefs: const links = Array.from(document.querySelectorAll(".userName.name")) .map(anchor =&gt; anchor.href) Looking here: https://developer.chrome.com/apps/runtime#method-sendMessage https://developer.chrome.com/apps/runtime#event-onMessage the parameter looks to be `any message`, not `your message wrapped in an object` (how would it even know to use the `.sendLink` property?) Probably, just do `function(recLink, sender, sendResponse) {` Disclaimer: I have never done anything with extensions 
Hey /u/sieabah good idea! I will make a more detailed report out of the data that I have.
I made this package called Prompts over the weekend: https://github.com/terkelg/prompts It's a lib to create user-friendly interactive CLI prompts - a lightweight alternative to Inquirer.js.
Should read the post before asking for a graph in 2-5 items lists.
Not really, a `StateMachine` may be directly instantiated, but it would be capable of just doing state transitions. const sm = new StateMachine('a state') assert.equal(sm.state, 'a state') sm.to('another state') assert.equal(sm.state, 'another state')
Also, redux already uses the old context api, it won't be long until it uses the new one.
see my [other reply](https://www.reddit.com/r/javascript/comments/80ixf6/typescript_is_there_something_like_javas_override/duwa82t/)
It's almost like... [He edited his post before your comment and after I wrote my comment](https://i.imgur.com/jFhBM0J.png).
Exactly! Sorry for that. As soon as I have noticed how badly formatted it was, I fixed that. My bad.
In all honesty, even though the transitions are done nicely, it reeks of "hey, look at ne, I'm so unique and smooth" so much that I'm not sold on it. Like, there's so much going on, that it doesn't make sense anymore. If it was toned down a bit, then it would imho look cleaner, but as it is - no me gusta =c
Wow, I've been developing react-native apps for almost 2 years and it's funny to me why "making the app build/run/archive again after instailing and linking a given package (react-native link)" is not there :D
This seems like a very convulted way to do something like ['even', 'odd'].map((print, index) =&gt; print + ' number array is ' + [...new Set(arry)].filter(item =&gt; item % 2 === index))
Thanks for the share, very helpful
Nice to see you doing your research, finding out what your target audience actually wants :)
Shameless gsap plug
Thank you! I worked on this in my spare time on and off since thanks giving. For QR codes I used google’s charts api https://www.gregorystrike.com/2011/01/26/how-to-use-google-charts-api-to-generate-your-own-qr-code/
 // ES5 class Person { } Person.count = () =&gt; "I am a static method." 🤔
This should really just be a function in a module. function evenOddArray (arr) { return { even: arr.filter(i =&gt; i % 2 === 0), odd: arr.filter(i =&gt; i % 2 !== 0) } } With a class you have potential state footguns like: const evenOdd = new EvenOddArray([1,2,3,4,5]) evenOdd.printArray() // wrong 
Isn't Chrome's performance tab sufficient?
No, I want something like this: http://www.hourences.com/tutorialimages/ue3profiling/2.jpg I want a breakdown for each conceptual "action", whose code can potentially be spread across multiple places with maybe some parts in web workers. So just looking at a breakdown for each method doesn't cut it.
JS class is worse in this case because this problem has little/nothing to do with prototyping for performance or instancing with constructors for reflection. What you want is a module, which can act as a namespace with as many functions as you want. Do you come from a Java/C# background, by chance? There using a class would be ok (though lambdas may still be better). This is just a language style/culture thing
You can use [lodash' get](https://www.npmjs.com/package/lodash.get) method. 
Congratulations. Looks really promising and content appears to be highly helpful. I would try it but too poor at the minute :/ Good luck!
Super awesome alternative to Inquirer! I've been looking for something like this. 
Hey thanks! I have fixed it.
Efficient little article!
thanks for pointing out
Whenever you are calling a function, you have to add () after the function name
Actually class is alright but maybe someone who comes from old js school will prefer traditional style as well :) 
In addition to what zakphi said, what you're doing is passing a function to a function. See https://en.wikipedia.org/wiki/Higher-order_function
you indeed got better idea :)
To get the result of function invocation you have to do console.log(getUserChoice()) Also, in your second function you simply return random number and that's it. Your switch statement is unreachable. Everything after return statement is unreachable. There are [other ways](https://stackoverflow.com/questions/5915096/get-random-item-from-javascript-array) of getting random item from an array. Google and Stack0verflow are your friends
Or just use [yarn offline mirror](https://yarnpkg.com/blog/2016/11/24/offline-mirror/) 
nice input m8
Would you prefer "Make software development simple again"?
All variations of “Make ___ ___ again” have been poisoned forever. 
Hi /u/Carrot654321, For javascript help, please visit /r/LearnJavascript. Thank you!
The last time I worked with PhantomJS, it followed redirects and stored cookies. If that is not happening, you may have a configuration issue. Additionally, you might consider using headless Chrome since PhantomJS is no longer being developed. 
Check out flask http://flask.pocoo.org/ It's a pretty easy to use web framework and should be relatively simple to wrap your python script in a web endpoint as long it doesn't have any crazy side effects. You can take input to the script in the form of query parameters, json post body or whatever you want. Check out the docs for flask request for how to access these http://flask.pocoo.org/docs/0.12/api/#incoming-request-data You can send the output of script back json encoded. flask's jsonify ( http://flask.pocoo.org/docs/0.12/api/#flask.json.jsonify ) is handy for creating json responses from python objects From there you can use jquery ajax, or fetch which is available in most recent browsers to make http requests to your flask app.
What does your py script do?
Do you happen to have the code for this by any chance?
The bad news is that we can't really move json parsing to worker, as messaging data to main thread would result in re-encoding it as a string (via json) :-/
Code for what? I’m sure you can find numerous tutorials online. 
This is not a redux replacement for most of the reasons you might choose to use redux But redux has been king for years and JavaScript is constantly innovating so if it does one day get superceded - great! Without that pace, we wouldn't have redux in the first place.
Should i read the first two, before this one ? or this one cover the first two books ? 
Yes, definitely the best one for manual work out there. I use [FeatherJs](https://feathersjs.com/) but i can hardly recommend it, its weird to me and based on older node architecture. Recently i'm keeping an eye on [Strapi](https://strapi.io/) as it generates your services but also generates a backend if need be to edit data. 
Hi /u/RedditGeneralUser, please refrain from personal attacks. Thanks.
Python script loads a machine learning (neural network) model, runs the prediction and outputs the result
bro thank you! i've been looking for an answer like this all day
For me, it was chaining. When i realized how it worked, i was like...oh! It made composition a lot easier in some cases, and reading other peoples code a lot more...clear. [I didn't write this article, but it does a good job explaining it](https://schier.co/blog/2013/11/14/method-chaining-in-javascript.html) 
Promised (at the time, referred to as Deferreds). Man, those headaches were epic. 
When I discovered DOM traversal and entry points/ability to manipulate. When I discovered timers. When I finally kind of wrapped my head around closures. When I learned to do API calls with xhr and then with fetch. When I first learned the why and how of promises. I still get "aha moments" from time to time.. I believe I can still stand to learn more about the inner workings of promises. Generators are still something that I can have a moment from. ... Just reading code and doing projects and trying to look at the very basics of some of the more advanced concepts... that's what has generally yielded "aha"s for me.
The latest version is the only one you should read. They are different versions of the same book, using mostly the same examples, mostly the same chapters, etc.
May god bless you sir.
callbacks
Still a little confusing. I've also come down with the flu recently so my brain isn't really running on all cylinders right now though. What about this metaphor here? https://www.reddit.com/r/javascript/comments/7yki4d/_/dui3yab Maybe any physical metaphor will be bad but playing with the different metaphors helps me grok stuff better.
Yeah that's helpful. I think that makes sense with the broom sweeping bind talked about earlier in the thread.
Mine was catalyzed by learning Canvas. I had a few game projects that I had written in XNA and C# using their sprite libraries, and I wanted to port one to HTML5 to help me learn JavaScript as well as revive the project. What really led JavaScript to "click" as a worthwhile language was when I figured out how to use closures and IIFEs, since they let me make private object variables and thus directly port classes over from my C# projects.
fetch itself doesn't block, it returns a promise. Is there a point to this module, beyond self promotion? 
Errors go to rollbar and source maps are uploaded via the api 
When I finally realized why this didn't work: import java.text;
When I learned about the [event loop](https://youtu.be/8aGhZQkoFbQ)
There was no lightbulb moment for the language. I started with totally incorrect assumptions about how everything worked and mental models that explained what I was seeing but utterly failed around the edges. Over time I gradually weeded these out. One day I learned that a closure and a function aren't talking about different things, every function makes a closure. Another day I learned how `this` works by enumerating all the possible cases. Then one day I realized I had my 5+ years experience and I might as well start calling myself an expert.
The 'ah-ha' moments I remember: * Creating my own UI framework: this caused a whole bunch of 'ah-ha' moments but the bigger ones were 1) why testing is so important, 2) why functions are so dang sweet, and 3) YAGNI is probably the biggest acronym I needed to hear. * Creating my own HTTP framework: this gave the 'ah-ha' moments around the transport layer and what a server really does. * Using Observables: Like. Holy moses. Once I started using them and I had my 'ah-ha', my code has never been the same. Almost as big as learning that functions are values.
When I stumbled across Douglas Crockford's personal website.
Typescript my dude. Classes out of the box.
fook, try sth easier. gonna work on that.
I'll let you know when it happens. 
The difference between asnyc and sync
Related, though they referenced the Oxford Dictionary definition ;) https://www.reddit.com/r/javascript/comments/7wsn4i/is_i_not_the_terms_asynchronous_a_bit_misleading/
I watch this video what seems like every few months. It's truly one of the best presentations about Javascript that I keep coming back to. 
Does that cover the use case of distributing private npm packages within a company?
When I first started, I learned to use js like it was intended : simple small functions attached to events that would manipulate the dom, eg on click expand a tab or change text. Little by little I added a bit more knowledge and did a few more examples, knew I loved it and then bought a js book to learn the rest.
What about timers? Just curious. 
https://stackoverflow.com/questions/16336367/what-is-the-difference-between-synchronous-and-asynchronous-programming-in-node
Thanks! That means a lot :D
I would think he's suggesting the event loop.
Just that they exist.. Tutorials I was doing early on didn't cover them. Then, later, learning about how the fit in to async loops helped to kind of give me an aha moment regarding async in general.
Which observables do you mean? Rx.js, MobX, your own?
This is quite helpful. Thanks!
I'm talking about just the general idea of the Observable type. I personally use RxJS for creating them but as long as they offer me "subscribe" as the interface, the rest is inconsequential
As a (primarily) PHP developer, I had a series of good "aha" moments while reading [Modern JavaScript Explained For Dinosaurs](https://medium.com/the-node-js-collection/modern-javascript-explained-for-dinosaurs-f695e9747b70) by Peter Jang. It's a little more about node.js rather than JavaScript, but it cleared up a ton about what these newfangled JavaScript libraries are all about.
What are your thoughts about JSX?
Classes are a JavaScript feature, no need to use TypeScript to have them. TypeScript is awesome though.
Streams in nodejs combined with websockets and real-time databases - writing an entire application where _everything_ is an event is extremely fun, compared to REST boilerplate (even if at the end of the day the codebase can be equally messy). I've always love frontend developers because they embrace their limitations. Backend developers tend to invent wildly complex distributed systems that are impossible to make reliable. I used to think Erlang was an example of a way forward - a framework for building real distributed systems in a reliable way. But nodejs being single threaded is a "good" limitation in the same way PHP's "one-thread-per-request" is a good limitation, without the painful performance sacrifice that an FPM system implies. Simplicity at all costs. Back in the day I never trusted developers to write safe C - I don't trust them now to write safe multithreaded applications or scalable web services. If storing state in memory is awkward and spanning many processors is complex, web developers don't do it, and that makes my job as a reliability engineer _much easier_.
The asynchronous part of javascript mainly relates to the fact that your program can make a network request, continue executing code and then handle the response when it is ready. A simple way to think of this is to think of a chef in a kitchen who is telling the kitchen hand to peel some potatoes and then once that is done, put them in a pot to boil. The chef (your program) knows that the kitchen hand (a network request) will take xxx amount of time to do the initial task (peel the potatoes). Because of this, the chef tells the kitchen hand what he should do with the potatoes when he is done peeling them (handling the results of the network request). The chef can then continue doing other things, knowing that the potatoes are being prepared elsewhere. This instruction of what to do once the initial task is complete is the key to handling asynchronous activity in any programming language. A lot of beginners struggle with this at first because they try to access variables that are supposed to contain the results of a network request but always seem to be empty. Make sure that you are using callbacks and/or promises to handle asynchronous activity (I would recommend using promises over callbacks, they are a little bit more complex but result in cleaner code). Synchronous code is pretty much all the code that isn’t making requests over a network. I find that youtube is the best source of tutorials for most things, including javascript. Good Luck 
Well I have been working with Java for some time now but I really disliked the lack of type-safety in JS. Recently I got put on a project using ES6/React. I absolutely hated it for about a week or two. Slowly though, things started getting easier (thanks to the help of some of our front-end devs) and now I actually really enjoy the flexibility it gives you (although I still prefer type-safe languages and I can't imagine trying to develop an enterprise app using Node or something like that). Personally, I have found that understanding programming is a series of lightbulb moments. I don't remember any particular moment, but I do remember one day after a few years that hey, I'm actually really good at this now. It's experience and exposure to different patterns, different loops, different methods...it all slowly builds a pattern-matching framework inside your brain that makes subsequent things easier. If you want to get good, the two best things in my opinion are 1) experience and 2) a really, really good mentor/teacher. Find the best person in your organization and get them to teach you everything they know.
Thanks for the detailed explanation!
I'd say if you're having trouble finding a light bulb moment - then you need to work backwards. Find a small problem you know you can solve with javascript and are motivated to. Solving problems is always an "aha" moment. :)
When I no longer had to look things up. One day I was at my desk working and realized I hadn't been to stack for anything but well-known copy-pastas in over 3 months. 
That everything eventually was an object was the first big one I had. Overall its mostly small "aha" moments and not really something that made me completely change my view on it. I'm still waiting for a few of those moments of parts that I still don't fully understand. In the years that I use it, there is still some part of me that thinks I'm still missing a big chunk of it and after that becomes clear it will all make sense. It also makes me feel I'm not that experienced yet, when in truth I've been doing lots of different stuff and can independently build beautiful applications and websites. Somehow I feel there's something missing and its actually quite annoying
Everything's an object. Variables are objects. Functions are objects. DOM is objects. It's all objects. Secondary enlightenment occurred while taking Functional Programming with Scheme in Comp Sci. I learned more about Javascript in that course (currying, returning functions, applying, etc) then I learned Scheme.
Doing Angular 1.x and realizing that all the middleware stuff that I used to do in PERL, PHP, ASP, VB.Net and C# was so much easier with 2-way binding ont he front end with a few AJAX calls mixed in. While I complained about Angular at the time (I was 3 months into the 6+ month learning curve) I still told my other developers that I couldn't ever imagine ever building a post-back based page again.
The article spends a lot of time talking about the author's pet library, but it does address that question in the end: &gt; if you have to do some heavy processing on fetched data, then it would make sense as you’re parsing results and processing them off the main thread. So idea is that instead of fetching on the main thread and incurring serialization/deserialization costs going into a worker, you do the fetch directly in the worker where you're doing the expensive synchronous operation. The article doesn't say what kinds of things can be qualified as expensive sync operations, but some examples include converting markdown to html, resolving a reactivity graph (e.g. think excel formulas), crunching the numbers for a game's pathfinding algorithm, etc
&gt; although I still prefer type-safe languages and I can't imagine trying to develop an enterprise app using Node or something like that JSDocs, `await`, and if you have to Typescript.
Gross
Timers and async? I though the point of async is to do it asynchronously.
In a job interview that went well aside from the js, the interviewer made the remark that "you understand that it's all just objects, right?" Of course I said I did, but I didn't really... After pondering it for a while everything finally clicked. 
This is very false. There exist other primitive types that are not objects, numbers, booleans, null, undefined, for instance. Also variables are pointers to memory addresses, not objects. While I understand what you are trying to get at, it is dangerous to be that loose with your language.
Yes... .. . timers add asynchronicity to the program flow.
For me it was the React tutorial. There's a section in there that shows how to write components in ES5, ES6, functional, object oriented, etc. It made sense of the clusterfuck that is JavaScript.
Thanks. The render props paradigm is interesting. Will look into it more.
- When I saw a labeled picture of jQuery showing the flow of finding the element and then manipulating it. Thats the day I stopped hating and avoiding JavaScript. I jumped 100% in. - When I built my first AJAX backed site and became free of server side PHP rendering - The power of websockets! - When I finally understood what nodejs was. Before I scoffed at the idea of server side JS even though I considered myself good with it. I was thinking about it in the context of jQuery, the browser, etc. - When I realized that callback hell is a choice, promises are horrible, and to wait for `await`. Figuring out that all the examples in the js docs, and years of jQuery had caused everyone to write in a horrible patter for no reason. Name your functions, move them out of the parentheses, go up and left, not down and right. - `node-ffi` - Understanding what nwjs was, pure... power... - Understanding what electron was, I was now no long a mortal skilled web developer with UX skills. I was a noospherian deity that ruled everything from the DB to the DLL interfaces of the operating system. From the UI to the compression method on the HD all but drivers where my domain. - `emscripten`. You can take a chunk of memory and manipulate it like one would with in C, C++. - Object recycling is next tier refactoring. - Found Douglas Crawford and understood the stupidity of `this`. Jslint forever changed me. First taste of functional programming. - Coworker introducing me to JSDocs, taking my code from interesting to poetry! Code walks on my codebases take hours not months now. - Getting a good grasp on functional programming, using it first, and then OOP when needed. FP=micro, OOP=macro. - Do not fat arrow, unless `this` is going to appear with `this`. - `this` once for `.chain().on().forever` and never more.
There's no specific moment for me, but taking Understanding the Weird Parts on Udemy, really opened my eyes about how JS works under the hood. It really helped me with scope, closures, and type coercion. Diving into JQuery and using it as a model to make a "mini-library" helped a bit too.
If you're expecting to wake up one morning and suddenly be proficient in a language, you're gonna have a bad time.
as in setInterval?
OK, what about this: Take the control back! Create and use a new generation of tools that are truly configurable, composable, and automatically installed.
It's not async if you're timing it. The point of calling it async is because the time it takes for a response can vary. That's why promises want a callback function when being resolved.
I do think that is a lot better.
When I really understood what an object was and that JavaScript is made up entirely of objects. Such a simple thing but it didn't click for a while. As others have said I am still experiencing eureka moments!
hell yeah, i came here to say this, knowing it would be the top comment
You're hard on me. I don't speak English natively (I'm French), and writing is not an easy task. Can you help me a little bit? What kind of taglines would you like?
&gt; The last tool you'll ever install &gt; &gt; Make software development fun again &gt; &gt; Forget Grandpa's shell paradigms &gt; &gt; Aren't you tired of installing, configuring, or updating your developer tools? Who cares what I would like? It's *your* project. I was just drawing attention to how cringey and tacky these particular lines feel on the front page of a serious project.
I don't really remember my own lightbulb moment, but I taught JavaScript for awhile and most of my students said the lightbulb moment for them was when we dug into Express. I was determined for everyone to understand the framework and to not just let magic happen so I devised a way to teach it with legos. We dug into the notion of middleware, the req and res objects, the next function, etc. and I repeatedly emphasized that this is JUST an object, or that is JUST a function, etc. etc. I think deconstructing the framework a bit and being disciplined in seeing the pure js underneath it helped a lot of students, and myself. It really helps with the framework churn. Its a shift in mindset from "damn i have to learn a new framework and a new way to do things" to "let me see how someone else used the power of the javascript language."
Understanding closures — that function has access to other things defined in its same scope
It is an open project, and my hope is that some people might be interested and want to contribute. But if you don't want, it is okay, no problem. Thanks anyway.
MVC is just one approach. I would look into Flux derived approaches where data flows only one way. CQRS is also that idea. 
I've done it a few times for interactives, typically I ended up doing three versions with slightly different aspect ratios of the hot spot container ( desktop, tablet and mobile ). All the hot spots were absolute / percentage positioned. Not pretty but a one-size-fits-all with more than a dozen markers was diabolical. I also did a later one using a 100% sized SVG overlay with click events on the markers. I'll try and find links later, but they'd be at least 2 - 3 years old now so they may be gone.
Interesting. I was only looking at the benefits of coding once for all platforms. Now I have to can understand setting up an api and developing front ends for three. Lol. 
Async simply means that the order of execution is not necessarily in line with the order of being written. setTimeout and setInterval are both asynchronous. Now if you mean that firing off timeouts with an estimate of when work should be finished isn't async, well, it is -- it's just a really shitty way of trying to be async, since it won't always work. But it's still asynchronous.
It’s alright but there are a lot of dead ends 
Wow, I think I finally understand JS. Thank you so much for sharing.
If you mutate your arrays and objects, you’re going to have a bad time. Stay immutable (`.slice()` your arrays, copy your objects), and use functional programming. Everything is a predicable and static function that receives input, does a calculation, and gives an output. No globals or external state. If you need something, make sure it’s an input. No magic (mutation and hidden vars) makes debugging so much easier. You just follow the chain of functions until one of them doesn’t give the right output you want for the inputs you gave it.
correct, most of the jobs want some react or angular experience but from what ive spoken to recruiters STRONG javascript is what the deal breaker consists of...
god damn
Decorators, at least that's my most recent aha moment.
Definitely this. I was thinking of this video before I opened the link. I remember my initial click on the link..."this is going to be boring...hmm...almost half an hour long...no way I'll get 2 minutes through this...whoops, there went 27 minutes! wow! that was a fantastic video!" It was so engaging I barely realized the time had passed. And I came away with a much better understanding of JS internals that allowed me to understand callbacks, setTimeout, promises, and all. Really great video. Definitely my "aha" moment with JS.
My boss/mentor gave me a project. I sat down and wrote down everything I needed to do in a mock-up/pseudocode kinda way. Gave it to him and he nodded and said “good now go do it.” Spent the rest of the day googling, searching stack overflow, reading documentation, and most importantly writing code. And then it worked! I was so excited to show him. He congratulated me and continued to give me projects. After a while I relied less and less on his guidance.
This is awesome, thank you!
Everything is an object
Still hasn't clicked for me. I can do anything in Java or python but js feels like trying to pound in a nail with a hacksaw.
Hes backpedaling, just ignore.
Getify's You don't know js book series.
When I stumbled across "Javascript-the good parts" by Douglas Crockford. Coming from a strictly OOPSy background, when i read that book, it was magical. 
When I switched to jQuery.
Probably when I realized how to master the DOM: https://medium.com/re-dom/master-the-dom-bc1a2a06089b https://youtu.be/0nh2EK1xveg
I've had a few different lightbulbs. Figuring out: 1. async 2. pass by value 3. scope 
What's the why and how of promises? This is the part that's getting me these days. . . callback hell &gt; promises &gt; async/await
&gt; 17 people thought this review was funny.
The revealing module pattern, closures, function.call, function.apply, etc.
I read that in the voice of mr poopy butthole from rick and morty.
Same
Well I'm no pro and certainly have more learning to do, but.. Why: easier api with more abstraction, more clean/readable, and they address trust issues associated with inversion of control and callbacks (Yes.. I've been reading Kyle Simpson). How: I just mean how to use them in my code (mainly with fetch when doing http request/responses) and how to write them with clean understandable syntax. 
I want ur class brah
That’s a great one. Then you switches languages and feel like you can’t do anything (without so)! 
Developing a game in HTML5
I didn't real get javascript until I read the book DOM Scripting by Jeremy Keith.
Problem is JS redirects.. headless browsers dont seem to follow them. Example - this type of HTML: https://pastebin.com/zAKZaPMN
I was having a hell of a time going from a traditional program to event driven programming. My lightbulb actually happened when I was learning android 😂
Be careful what you send to third parties because of dpa gdpr and PCI. For us we couldn't use this service or solution.
Yahuda Katz' article on prototypes completely changed the course of my career: http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/ It might not seem as essential with classes now, but it'll teach you about what these javascript objects are made of.
Hey @kefirchik Author of the article here Indeed it's what @lhorie mentioned I'm more interested about teaching people about Comlink and Comlink-fetch Here's an example where it makes sense to run fetch off the main thread: Say you're polling a specific endpoint and you only want to run a specific action once you see a certain value in the response. You could carry this check in the worker, off thread, and then simply signal it back to the main thread so you could run the desired function. There's countless of other use cases, for example if you have to query for a large response, but you're only interested in a subset.
I'm still getting my head around them. Every time I use them I find frustration after frustration, especially when a simple promise will do.
[You Don't Know JS](https://github.com/getify/You-Dont-Know-JS)
That's not a JavaScript redirect. It's JavaScript triggering a form post. Did you try headless Chrome? Given that it's just Chrome, it definitely processes JavaScript. Without seeing your code that invokes PhantomJS (which I don't have time to review), I can't tell you what's going wrong. I can only say that both Chrome and PhantomJS run JavaScript by default.
&gt; @ForScale seemed to suggest using setInterval/setTimeout is creating an async function, but that is not why one would use those. Sure it was, 10 years ago.
When I learned about the "dynamic script tag" back in 2005 or so. This was later named JSONP. This took JavaScript from being used for styling and small in-page changes (expand/collapse etc) to being able to make advanced SPAs with thousands of lines of code client side, even with IE6-support.
Not a JS person nor planning to be one exactly: Is it worth it for people from other areas/languages?
Once I grasped scope, 'this', closures and callbacks.
Been using js for a decade... I'll let you know when I have it. Lol. Every year I feel close and the entire community scraps everything and goes in a different direction. Js changes way too much. 
Functions as first class citizens. 
Mine was when I realized that everything is an object. literally. everything.
I don't know the first thing about printing other than the snippet I just read on MDN, which says it prints the entire document. If your page is intended to be printed, and you only want a particular section to be printed, perhaps put the other section into a container (if it isn't already) and give it `display:none` before calling print(), and then revert it immediately afterwards?
Except for all the primitives. 
Use `@media print { ... }` to set styles for printing only.
I wrote [this about promises](http://tinselcity.net/reddit/promesas) on reddit some time ago. It may help with the whys and hows. Then again it may not :) (no async/await in that, but ask if you need it)
The key to my "aha" moments and the passion to programming at all was reading of books about JS what gave me a right way of thinking. Then I was inspired by my real life problems and I started to solve it using the programming language I know. In summary: just find your everyday problem -&gt; solve it using a JS (you have a lot of tools: React, React Native, Node, etc.) and will get a right feedback of your learning ;) 
Have you tried using Typescript? As (primarily) a PHP developer myself my moment came when I tried using Angular 2 and Typescript. For me it makes JS work more like a backend language like PHP and lots of the structure made a lot of sense. I still would not say I’m a JS expert at all ... for from it... it I’ve been able to do a lot using angular and Typescript without having to learn every aspect of JS. 
Came here to say this. Typescript and Flow give you the safety net you're looking for.
&gt; For example, you’d be surprised that JSON.parse blocks the DOM. I'm not surprised. Why do you expect anyone to be?
Headaches?
I just watched it and I have to say, that exact same thing happened to me! 
My light-bulb moment with JS came when I realized that Promises are just a monad, and obey the monadic laws.
Which react tutorial are you talking about, just curious?
I remember being told one day programming will just "click". I guess this is the same as a lightbulb moment. The thing is for me, after a year of doing JS commercially, I dont think it has clicked. I still really struggle and would be lost without google/the ability to copy code from other parts of the code base. I know googling and copying is a skill in its self, and I am far far more efficient and finding the answers to my problems. But I don't feel like I understand a lot of what Im doing and often cant explain what I have done, even though its working. Its strange. My though often is that maybe coding isnt for me.
Although I'm still no expert at JavaScript, the "lightbulb moment(s)" came first when I was reading the code correctly and just listening to the tutorial video to type my code instead of watching. I also had another moment while watching tutorials, on all the cool things you can use JavaScript with using Node and other dependencies, and realizing every developer has their struggles with JavaScript syntax. The last but not least, and probably the biggest thing that has helped me after that first "lightbulb moment", reading and learning how to use the documentation on JavaScript and other tools that go with it. I think the biggest problem I had was thinking that coding was like in the movies, where you can invent and get a working website with login, registration, validation, etc. up and running in a couple hours. The real truth is, every developer runs into problems that slow them down on a build, so just keep learning while your getting stuck, it will all sink in one day and you'll know the documentation material very well when your "lighbulb moment" does come.
Yes, please share!
Yes, please share!
If you can't name the need for a NoSQL database I would stick to a traditional SQL db, you'll thank me later when you need to create more complex queries than you originally envisioned. &gt;Should I go out of my way to configure this stack and use the classic MySQL as a database I would advise to go out of your way and use a Postgres database. And by 'going out of your way' I mean: pull a docker image, implement your db schema and configure a connection string. 
With no clear vision as to which is a more appropriate solution, I would err on the side of a traditional RDB. Since you’re going to be implementing an ORM anyway, I would be tempted to use Postgres with something like Sequelize. You then have the flexibility to use NoSQL features of Postgres should you wish.
Do you have any material that helped you learn the use of "this"? I've had it explained to me many times in college courses and Lynda courses (for other languages however) and still don't exactly understand it and how to use it.
Is this going to be a long-term project, or just a little fun one? I wouldn't "go out of my way" for a fun project, I'd just use what's easy to configure. If it's something you'll have/want to maintain, then I'd put the work in to do it "right", whatever that is.
It was almost 10 years ago... we had a tricky bug about a property being modified in an instance, something like: ``` function MyClass() {} MyClass.prototype.config = { bar: 1 }; // In some other file var a = new MyClass(); console.log(a.config.foo); // 2; ``` After deeply thinking about it, finally my head got it up: the `config` object was pointed from every instance as a reference. So every instance shared the same "config" object. If one instance changes it all instances will have the modified version. From that day Javascript stopped being a mystery for me. Among the years I made multiple realizations following the same thought process.
If this is your way of sharing your project, you need to work on your marketing skills. Demanding that the community do *anything* is bound to make people angry, and you don't want anger to be the first feeling people have about your project.
Good point - You need it if you are publishing as a Github Page as I'm doing in the project, but should not be a default assumption. Going to update that, thanks!
YAGNI?
Pretty fine talk, but I'm missing the bit most JS rookies don't understand: you're deferring a call with an object as parameter (object could even be an anonymous function, for that matter). Now you're facing call by value vs. reference. It would have been a great opportunity to visualize this.
You could really go either way! I vastly prefer using Mongo with any JS application, simply for the convenience of being able to store and think about data in the same way I interact with it in my code (everything is essentially a JS object). My major concern with Mongo is making relation-intensive queries, but this doesn’t seem to be a major issue for you. If you’re looking to MERN, it’s probably easier to just stick with Mongo
Been thinking about this myself. From the Techempower benchmarks, MongoDB's performance seems terrible compared to SQL: https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=query&amp;f=zik0z3-zik0zj-zik0zj-zik0zj-zik0zj-zik0zj-zik0zj-cn3 Don't know if the benchmarks are flawed or not, though.
I always thinking about , what is the more 'testable'. PostgreSQL is more testable than Mongo. Indeed, making relations with NoSQL is painful. In fact, with the JSONB Field in postgre, you have the power of both world. It's really smooth with Sequelize ;)
you aren't gonna need it [?] i guess means limit the scope of your project.
To add to this, for Postgres there's also the excellent [massive.js](https://github.com/dmfay/massive-js), which personally I find more pleasant than a full ORM (though it may not be what OP is looking for).
"I plan to use the MERN stack, but I don't want to use the MERN stack." What?
The idea behind the post is that it assumes that the MEAN stack was made because these technologies must work so well together that they're a popular combination. The situation is that MongoDB is not necessarily mandatory and would it be better to substitute a different technology or does this standard combination work so well together that it should be religiously followed? I mean for God's sake both databases start with an M. It's a matter of which M is better.
Ok, I had never heard of this stack, there are so many choices for every part of an architecture these days, it just sounded strange to me. Like putting the cart before the horse. I'd say, choose the best technologies for your needs and only then worry about the acronym you happen to end up with. And the better database starts with a P ;-)
I am a java developer. I felt comfortable with javascript syntax until one day when I saw something like this. Then I put more effort to learn javascript. (function(func) { func('hello world') })(function(str) { console.log(str) })
I'll take little headaches during development if it means not getting the flu in production :D
When I finally began to understand currying. It's so powerful and makes code much more expressive.
As someone who started in C#, i can personally say Ive really enjoyed diving i to JS, if nothing else its a really fun language with a rapidly expanding ecosystem
I just answered my own question, and this is why I'm a newbie at Javascript. The else statement doesn't kick in because the = in the if statement doesn't check if the content is the same, it just checks if the content that is already there is a string. Thus in the initial if statement it has to be === or ==. Good job myself. 
Thanks for your message, you are right, my marketing skills are terrible. I am deleting this post.
I recommend Postgres, Koa, React, and Node. But PKRN doesn't have the same ring to it.
You’re right that it isn’t checking if the content is the same when you use a single = but a single = doesn’t check for type. A single = is for assigning variables, not comparing them. When you put one in an if like that, it just assigns the variable to the value on the right every time, then evaluates to “true” and runs the if block, skipping the else block every time.
Ah okay thanks for clearing that up even further! That actually makes perfect sense.
“I plan on doing what everyone else is doing without questioning why.” What?
I agree with the people saying that understanding asynchronicity, the event loop and callstack, and callbacks is probably the biggest one. I would add a twist, and say I never fully understood it until I went native, and built and app with no framework or libraries. Noobs coming in and instantly gravitating to third party frameworks/libraries/modules, and thinking that is programming, are stunting their understanding terribly. Build something big and complicated with vanilla JavaScript.
Please film this!
I meant the opposite. Why would you say you plan to use something when you haven't actually decided that you do?
oh wow, first time being gilded for an article, thank you so much!
Some good libs in that post. I remember when FrontEnd checklist was released, I think I want to create a validator that scrapes a URL and gives you a report rather than self-reporting. Has anyone used that Display JS lib? It looks.... different. Just curious what's the use case for it (I'll read more of the docs once I get to an actual computer, on my phone atm)
"With big project like Vue.js and React, it’s almost becoming a pleasure to design your interface using Javascript." Fucking L O L
Noop Noop was the one who kept saying that.
just watched it, it's very JS specific
I for sure understand the frustration of trying to use an Observable where a Promise will do. In my mind, they represent two different things, even if you can represent the same idea with both: A Promise is a single, *eager* wrapper of a value while an Observable is a lazy wrapper of ( possibly ) infinite values. If you are just making a single `fetch` request and doing a single action after, you probably want `Promise`. 
[You Aint Gonna Need It](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) I wrote a whole bunch of parsers and builders and all this other cool stuff for my UI framework that, when it was all said and told, I didn't need at all. I think focusing on the bare essentials ( TDD helps in a big way with this in my experience ), you can build actual products without the extras.
the variables don't exist, and therefore are undefined. you're still testing undefined. 
[thatsthejoke.jpg](http://i.imgur.com/tEjeMu8.jpg) --- ^(*Feedback welcome at /r/image_linker_bot* | )[^(Disable)](https://www.reddit.com/message/compose/?to=image_linker_bot&amp;subject=Ignore%20request&amp;message=ignore%20me)^( with "ignore me" via reply or PM) 
are you using async / await now?
I think the whole conceit around MERN was to use a NoSQL database, and keep things flat and stateless, so to stray into relational territory may be risky. If your data is already stored as relations then maybe the MERN stack isn't for you, and go with a more traditional LAMP stack. If this is your first MERN, do full MERN, otherwise you may just be setting yourself up for issues that may be best dealt with by appreciating MERN in its non-evolved form anyway. If you're having trouble visualising your data as flat sets, this may be the underlying issue. Reorganise it and go Mongo. 
More specificly: https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub
horses for courses
Netscape claims another victim!
A lot came together with this guide by John Resig: https://johnresig.com/apps/learn/
I followed a tuturial from Travery Media that involved building a little app that saves bookmarks and utalizes local storage. I thought I understood the concept and then I used the concept of local storage and incorperated it into a TeamTreehouse project and thats when I realized I didn’t understand the code until I had to sit down and re write it. From that point forward I am more project focused and less tutorial watching focused. 
I love Python yow 
Is it 100kb compressed? Because that seems pretty big.
Have you considered RethinkDB (https://www.rethinkdb.com/)? It's no-SQL but has extra features such as data subscriptions (ideal if you're building a responsive realtime front end).
In ` this.arrowsHolder = document.querySelectorAll('#js-arrows-holder');` you have used `querySelectorAll` which returns a list of nodes. `addEventListener` can only be invoked on a single node at a time.
That's a mistake. Looks like it's 26 kb or 12 kb minified. https://github.com/arguiot/DisplayJS/releases
+1 for postgres PERN? NERP? and have you considered graphql vs rest? i have come to love postgraphile for publishing my api. it’s a different way of thinking and still getting traction, but i’ve built a couple apps this way and it’s been great. react + apollo on the front end makes consuming a graphql api a breeze
Quokka.js, probably. 
Yup that’s exactly it, thank you. Are you familiar with it and if so is it worth learning/using?
you need a server that starts with O
IMO, is your data relational? It is? Use a relational database. It'll save you the hassle in the future if you have to make complex queries that are relational in nature. On projects I work on we use Postgres, Hapi, React, Node.js. Occasionally we'll throw in Mongo if we have non-relational data, but 9 times out of 10 most data can be modeled relationally. 
But an ID can only be used once so the 'list' of nodes is actually a single one. Or am I wrong?
Like another comment said, querySelectorAll returns a NodeList, not a singular Node. Only Nodes implement addEventListener/removeEventListener (The EventTarget interface). Another thing to mention for your addEventListener callback is that if you plan on referencing your classes `this` context in that function, you'll have to either use class properties (arrow function syntax) for the method definition or bind it in the constructor, i.e. `this.test.bind(this)` 
Why am I being turned off by the blatant advertising? TypeScript is okay, it has its uses, but I fail to see - must be my shortsightedness - the need to do EVERYTHING in it. Yay, types in javascript. 
The `getElementById()` method returns the element that has the ID attribute with the specified value: `document.getElementById('js-arrows-holder');`
It still returns a `NodeList` object.
I use it occasionally. It seems to work well, and there isn’t much to learn. You can check their website for a breakdown of the free/paid features. 
That's good to know, thanks!
How's this different from NPM? Is the idea that everything has a CLI interface?
Thanks for the feedback. May I ask why you might think it’s blatant advertising?
Hi /u/ElCoach77, For javascript help, please visit /r/LearnJavascript. Thank you!
I see the downvote, too. I'm harsh, I know. Why do I think it's blatant advertising? It starts with the notion that a non-statically typed language is less powerful than a statically typed one. Second is the absolute adoration of typescript in this regard. Maybe not paid advertising, just a strong opinion. However, even in that light, I cannot shake the feeling typescript advocates are a bit too cheerful and "aggressive". Aggressive isn't the right word either... I'm not saying typescript is [insert x], but I've seen a surge in developers and kin drum it up in all the places. Sometimes I just want to kick back and relax, not with the kitchen sink in my hand, just the tools I have on me. Maybe it's been staring me in the face the whole time, it's not TypeScript, it's the typescript devs. Oh well. 
if you tests includes the database layer you are doing it wrong. But, just because i am curious, what would make a database more testable then others?
The real question is, why would you pick dynamic typing over static/strong typing? One is far more error-prone than the other.
Don’t give up, you’ll soon learn that broken things are your friend because once you’ve spent 2 days trying to fix some small problem, you’ll never make that mistake again! Or more likely, you will, but you’ll know how to fix it.
Yeah, exactly. That's why I try to make a buttload of exercises, to actually make those mistakes and learn from them. It's the only way to truly master the craft.
I prefer the simplicity, and as far I can tell, progress, experience is pointing in the direction of less verbosity, boilerplate. JS is very lax in this regard. I like that I don't need to explicitly write everything out, and get - usually - the most performant type I want under the hood, while not caring about it superficially. I know this rings a few bells for some people, and some might even jump at my throat. Type inference and such aren't mutually exclusive, and the less I have to bother writing up types everywhere, the better. Let's take Python for example. Code to "production" is fast. Code to "optimized performance" isn't. I'd take Python over typescript, because hinting is more preferable, than rigidly enforcing type-related stuff.
When I was working on https://github.com/OpenEnergyDashboard/OED and I realized that literally any other language would be better. Thus https://github.com/LeoTindall/OED/tree/typescript was born.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [LeoTindall/OED/.../**67fe4cfefcd80193fb5ec0e1b86a7b4c01fa4ca0** (typescript → 67fe4cf)](https://github.com/LeoTindall/OED/tree/67fe4cfefcd80193fb5ec0e1b86a7b4c01fa4ca0) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply duyr801.)
I've just looked at material over the years, nothing in particular helped explain it that I can remember. Learn the prototype model though and it will make sense.
When getting a list/nodes of elements you need to do a foreach loop to add an event listener to all of them, or target a specific node (example to add event listener to first element matching the query; element[0])
Maybe, I did went to Swift for couple weeks and came back to Typescript, maybe that’s the strong love for static types
True - it's weird, but it's also powerful. For example if you don't like working with prototypical inheritance you can write your own single- or multiple-inheritance class system in only a few lines of JS. Or if you really just want to shut your ears and pretend it's a regular class-based system, (*once you understand prototypical inheritance*) just use the ES6 `class` syntax and ignore the prototypical bit altogether. ;-)
&gt; Promises (at the time, referred to as Deferreds). It's a nit-pick, but Deferreds and Promises aren't quite the same thing. A Promise is an async computation that *will* return a result or an error depending entirely on its own internal logic. A Deferred is like a Promise that exposes externally-accessible `resolve()` and `reject()` functions (so other code can resolve or reject the async computation as well as the computation itself), and are generally viewed as deprecated. [This is a useful resource as to the difference](https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred) - notice the Deferred is an object which exposes `resolve`/`reject` methods, whereas the Promise only makes them available within the scope of the function passed to the Promise. Honestly I'm not entirely clear why Deferred is considered deprecated as a pattern in favour of Promise - a cancellable async computation seems inherently more useful to me than one that can't be cancelled by other code, but presumably there's a good reason for it...
+1 for postgress
I was actually upset when ES6 came out because I had invested so much time into learning the prototype model... Lol.
I understand the why, but am wary whenever typescript pops up as the "strongly, statically typed" choice "everyone should take" because "it's magical". I've heard nice things about swift too, then previously about coffeescript, and look where the latter is now. Guess I can say I'm skeptical. 
If Data is the lifeblood of your application (all apps are), then a good data model is the difference between (low storage costs, high throughput, low latency and a flexible application) and (high storage costs, terrible performance and inflexible)... If you are modeling your data, no better way than relational...you are guaranteed to outlive all technologies.... 
That's one of the main issues with transpiling - sometimes things break because we're error-prone. It introduces non-deterministic complexity, which can be hard to track down. I wouldn't exactly call TypeScript a rube goldberg toy, but there are tendencies and potentially unwanted consequences - as with everything else. However, keeping the codebase and the actual production code similar - even if compiled - is easier to debug than relying on a transpiling mechanism that might just have a hiccup on certain corner, edge cases. 
I'm a big fan of Typescript not sure why there is such an aversion to it. When I use it in Angular I have a lot of fun and enjoy coding in it. It's not about forcing people to use typescript.. only to open people's eyes to its existence and the cool and helpful things you can do with it. Every tool isn't for everyone just like I was not a fan of coffeescript
I was nodding along until this &gt;The separation of action creators and reducers is why the concept of an action type exists. Treat the two as one, and there is no more need for large files of exported type strings. That is not correct. The reason actions have a type is because they carry semantic info that can be used by multiple reducers and produce event sourced view state. If you remove all type info from an action how do you observe that action stream passively via middleware? (a hugely powerful capability imo). The action =&gt; reducer relationship is and should be one:many. In trival apps it seems like it's a one:one but as an app grows in complexity this becomes apparent. I went fully down the "ducks" pattern of code organization before I realized this myself. Event sourcing is an extremely powerful concept that has more moving parts than a none event sourced equivalent. It's a trade off of slightly more complexity for the power that it gives. I do agree that the redux API could be improved however, things like the selector reducer asymmetry bother me.
Hi /u/v-dub07, For javascript help, please visit /r/LearnJavascript. Thank you!
At the end of the day, it's your project so pick whatever you want. If your data is more relational, then go with MySQL. If you need ORM, you can use the sequelize package and if you want to write SQL statements, you can use the mysql package. 
Google Packman logo.. I print a source ( 4 A4 pages ) and read it..
What about learning from a tutorial and then attempting to rebuild the project from the ground up and add modifications?
Postgres, OCaml, React, and Node too. Damn the torpedoes
I 100% agree with you that too much verbosity is frustrating and often unnecessary. But you can be both concise and strongly typed. C# does a fairly good job at this. &gt; Code to "production" is fast. Code to "optimized performance" isn't. I'm not sure i know what you mean by this.
SQL is code, so why not test it? https://tapoueh.org/blog/2017/08/sql-regression-tests/
Add Yosomani book forever changed my understanding of JavaScript. Once I started to grasp patterns, the rest came a lot easier. 
you don't do feature testing?, there's plenty of valid reasons to include the database layer in your tests, you don't use the normal database, normally you can either create a testing database that will be truncated and seeded when running tests or use an in memory sqlite db.
I believe so. 
In my code I strongly couple and colocate actions with action creators and reducers with selectors, but when reducers get composed in combineReducers they receive a slice of the state but the general usage of their selectors acts on the global state with no knowledge of the state slice their reducer acts upon. There are many strategies to combat this but I don't feel like any of them are a great answer. I've bikeshedded on this more than I care to admit. [Here's a good blog post](http://randycoulman.com/blog/2016/09/20/redux-reducer-selector-asymmetry/) on the topic.
This is pretty neat, does anyone have any other similar or equivalent libraries to compare this against? It's always nice to see comparisons to gauge the value of a feature or system structure. Thanks! 
Stick to MySQL. You are way better off knowing that the User instance you created a month ago has the same fields as User instance you created today.
my big problem with typescript is, that it doesn't enforce types. This doesn't matter in a small team or if you work alone, but if you work at a bigger company you'll always get those lazy guys don't using types. I guess you could configure eslint or something but still..
Ah didn’t know some features were paid. That’s sort of a bummer but if it will improve my work flow I don’t mind supporting the developers. 
TypeScript is nice, but JS with super powers? That's hype. I've worked on large codebases with both TS and JS. TS is great for documentation (function parameter type annotations and a few objects are usually all that needs explicit typing, I find). It's also great for autocompletion. But this kind of static typing catches very few errors, and the ones it does catch are trivial and would usually been caught anyway. But sometimes TS doesn't work as advertised (I remember having to explicitly cast a value in a reduce function because TS was erroneously refusing to build), and it adds complexity (setup, build).
I'm using sequelize as an ORM, and it seems pretty good so far.
I get the advantages of TS but there are drawbacks. Personally I don't see much value. What I don't understand is TS aficionados and how emphatic they are about it. It doesn't matter if you're developing a tiny form app. If you don't use TS you're wrong. End of story.
TypeScript and/or JavaScript are only as strong as the developer behind it. If you don't know a lot about it, then you might not like it, but when you get accustomed with it, then you start to love it.
I think I may have been unclear here. What I meant by "action types" is the pattern of extracting your action types as a variable. ``` const ACTION_ONE = 'ACTION_ONE' ``` Then the variable ACTION_ONE is often passed into both the action creator and the reducer. Often these variable action types are put in their own file, and imported everywhere.
This is where a tool like eslint comes in handy. 
This is a deceptively complicated question, I think. To begin with, I'm not going to actually argue against types, especially because if I had to pick a side I'd be on the "typed" side. That said, working in a strongly typed language always takes me much longer to get going than a dynamically typed language. Feel free to say, "That makes you a bad programmer", but it doesn't make it less true (also I don't think I'm a bad programmer). If a bad programmer has more trouble using tool A than tool B, that still points to tool B being better (if given no other information). But also... the idea that static typing is somehow more powerful is simply an error, in my opinion. Duck typing is super powerful for tons of reasons that I won't even bother outlining, but it's patently true that you can do more with dynamic typing than you can with static typing (from a functionality perspective). That said, it *is* more error-prone. So it's a give and take. Personally, I tend to prefer strong typing because it allows for better static analysis and tooling.
I use it in Angular too, and since then I refuse to use plain JS in non angular projects, TS for everything! On the backend there is NetsJS that uses TS as first citizen if anyone is interested, very good framework, inspired by Angular: https://nestjs.com/
Sequelize as ORM makes it easy to setup Express and postgress or mysql.
This is very accurate. I was highly averse to the idea of using Flow, or particularly TypeScript, going into my present job. My boss was keen on TypeScript, and the rest of the company used it, so despite this being "my" project in a sense, I felt obliged to integrate it. Besides, it was win/win really; I get to keep (almost) all my ESNext features I was previously getting via Babel, and they get to use whatever they like TypeScript for when they contribute. It went on like this for some months, and with me being the only major contributor to this particular project I never got to see or understand first hand what the point of it was. Then I spent a month or so toying with Rust in my spare time. This was my first time in a strongly typed language with all my prior experience being in JS and PHP. Whilst I learned Rust, I was forced to come to terms with the concept of a `struct`. I then came back to work and began to see the power of the `interface`. Whilst they aren't really the same thing at all, they _do_ both equally help enormously in describing the data structures that make up an application. Around the same time I also started to dabble with strict typing; another thing I really liked about a more "native" language like Rust was specifying return types and argument types. In practice you get all those same benefits out of using TypeScript. It doesn't matter that it transpiles down to JS, you still get the same value back. I'm continuing to learn and other non-JS concepts are creeping into my code and improving it, more recently the `enum`. That thing is great for passing around a predefined list of values. I'm still a TS rookie really, but now I look at the open source projects I maintain outside of work and just despair at the prospect of having to touch an untyped codebase. It does still feel a bit weird that my two favourite projects in the JS ecosystem right now are by two companies I don't really like - React by Facebook and TypeScript by Microsoft - but it is what it is. They're open source, and they are very well managed and maintained at the moment, so that's fine. Same goes for VSCode as well actually. --- tl;dr try TypeScript out seriously for a project and you'll eventually realise how much better it is than plain JS.
https://d3-slackin.herokuapp.com/
well, maybe I'm too spoiled by using elm, where the language itself sets standards ;)
&gt; That said, working in a strongly typed language always takes me much longer to get going than a dynamically typed language. A strongly typed language will have less run-time errors that are more elusive. So the speed gains you get from working in a dynamically typed language can be lost by trying to fix those errors. to put it another way, I can produce more functionality that customers care about in a shorter period of time if I didn't have to write unit tests. &gt; but it's patently true that you can do more with dynamic typing than you can with static typing (from a functionality perspective). Are you suggesting that dynamically typed languages offer more features to the programmer, or offers more throughput to the programmer? Because I have yet to encounter a problem I couldn't solve in either paradigm, but it might take me longer to solve a problem in a strongly typed language. But as you said, it's give and take. Outputting more code in a shorter period of time that is more prone to bugs is not necessarily better than outputting less code in the same period of time that is less prone to bugs. 
Have we lived in a world where there's no setup and build phase for js source code - I'd rather agree. But in 2018 virtually any frontend project has a compilation in some form.
Well, you actually can enforce strictness.
No, I'm saying take everything with a grain of salt. No golden hammer, silver bullet or be it all end all solution exists. "So you're saying" I like the phrasing, it gives way to giving words into my mouth. Where exactly did I say typescript will be supplanted someday? Or that we shouldn't embrace anything? Regardless, "tread carefully". 
I mean that python's idea to production time is very short. Optimizing it is less so. 
"Always bet on Javascript" has served me well over the last few years and another language that compiles to Javascript seems like a pretty poor bet. To my mind Flow is a better way of implementing types than Typescript because it isn't a new language in the same way.
The action you did of talking yourself through your own code is called "rubber ducking" It's a great thing to do before asking for help as it saves everyone's time. Anyways carry on the learning and happy coding ^^
&gt;TypeScript and/or JavaScript are only as strong as the developer behind it. Okay. &gt; If you don't know a lot about it, then you might not like it, but when you get accustomed with it, then you start to love it. There it is! This is the kind of attitude I dislike about typescript "evangelists". If you subvert your expectations, give up what you like, and keep using something else, maybe you'll start liking it! It's great! It's not this negatively clean cut, yet somewhat infuriating. 
&gt; if I didn't have to write unit tests. Well, er, you're more than welcome to write the tests, because that's... just asking for trouble. To put it lightly. 
&gt; The real question is, why would you pick dynamic typing over static/strong typing? One is far more error-prone than the other. I have not seen any massive decrease in the errors in the current codebase I'm working on that's written in TS. This idea that static types is "less error-prone" than dynamic hasn't been true in my experiences with either Flow or TS. This may be a thing with me being the world's crappiest TS developer ( probably not far off ) but I am just not seeing the "promise land" of "less errors". Now, if we wanted to discuss tested code vs untested code, then I am 100% behind you in saying that one is far more error-proned than the other.
&gt; aversion For someone who barely used it, can you help me change my mind? In which way does typescript actually add functionality/ benefits to Javascript? My probably wrong assumption is that it mainly restricts users similar to a too strict/ intrusive Lint. Am I wrong in putting typescript into the Coffeescript category in the way that it will die out in a couple of years with its legacy being that the new Ecmascript versions drawing some ideas from it? 
My main aversion to TypeScript is that while I do see the benefits of typed language, (I use Flow Type) I find it extremely difficult to maintain, well, "the zone". The big problem that I have is that when I'm coding something, I'm often working with third party libraries and database schemas that I didn't write. Often I'll just write what I *think* will work, console log or debugger the result, and from there figure out what assumptions I made were right, what were wrong, and configure the function accordingly. The big difference: If my types are wrong in Flow, I can still make a build of my JS, see that the basic *concept* works, get those console logs to find out where I'm making mistakes in type, then correct any incorrect or missing annotations. Typescript will force you to correct all those type mistakes *before* allowing you even a trial run to see what the function returns. This allows you to "fail quickly" and "iterate rapidly". When I use Flow, if the underlying *logic* doesn't work, I don't have to worry about the types - I change the logic first, and only then worry about type once I have logic that works. Whereas, with Typescript, I have to get the types right *whether or not* the logic works, just to test it. Which means that in TS, I spend a lot of time fixing types for code only to find out that it's not going to work and needs to be replaced anyway. To be fair: Since I moved to typed JS through Flow, I have caught a LOT of bugs I wouldn't have otherwise. My code is more readable and I really do find that it speeds up development. But every time I try Typescript, I get bogged down. So, yeah, that's why I'm *not* a Typescript fan. 
Typescript and flow are pretty much identical.
Nice, altough for my taste this should be the default. I guess they made it not the default so it's easier for js developers without any experience in a static language to migrate.
Go ahead and be skeptical and overly cautious. The rest of us will be using the best tool for the job.
[Take an hour to watch this video](https://youtu.be/Nltqi7ODZTM)
I have [Hacker Newsletter](http://www.hackernewsletter.com/), and I'm subscribed to [Javascript Weekly](http://javascriptweekly.com/) and [Frontend Focus](https://frontendfoc.us/) through RSS, but they should be available through email as well.
TypeScript emits compiled js even in the presence of type errors with default options (it's controlled by --noEmitOnError), so it's certainly possible to run and fix errors later.
Don't worry - that'll still stand you in good stead. The `class` keyword is just syntactic sugar, and you'll never be a good JS dev unless you understand what's going on under the covers. Like I said, the class keyword is great for not having to worry about the intricacies of prototypical inheritance *once you understand how it works*, but it's not a *substitute* for understanding how JS actually works.
Don't worry - that'll still stand you in good stead. The `class` keyword is just syntactic sugar, and you'll never be a good JS dev unless you understand what's going on under the covers. Like I said, the class keyword is great for not having to worry about the intricacies of prototypical inheritance *once you understand how it works*, but it's not a *substitute* for understanding how JS actually works.
Don't worry - that'll still stand you in good stead. The `class` keyword is just syntactic sugar, and you'll never be a good JS dev unless you understand what's going on under the covers. Like I said, the class keyword is great for not having to worry about the intricacies of prototypical inheritance *once you understand how it works*, but it's not a *substitute* for understanding how JS actually works.
You can do both and it'll be even better, then.
Sure. They can both carry meaning, so use each when appropriate.
Javascript: Understanding The Weird Parts over at Udemy. This was after I had already studied basic tutorials in freecodecamp or any other online resource tutorials. Do some basic tutorials first to familiarize yourself with the syntax (like the usual var, for loop, switch cases, arrays, objects, etc.) and then take that udemy course. Also try the CS50x Harvard course over at edx. Actually, I recommend taking CS50x first or watching the videos.
Oh shit you're right. Cool stuff.
Typescript has a `strict` option. You don't even need a config file, just run it with `--strict`.
I work at the company, and we just open source this framework that is being used to develop the dashboard for our clients. I just wanted to share, in case anyone gets interested. 😁
so someone is lazy if they dont want to waste time with useless overhead and contrived complexity. ooookkkk javascript is just fine the way it is. i dont know why microsoft has a stick up its ass about turning javascript into csharp. coming from a shop that decided to use typescript and redux for a stupidly simple calendar app. lead dev didnt really care about effectiveness just dead set on using the latest buzz. not only ts and ngrx redux, graphql and postgres? sure why the fuck not. everyweek even the old csharp guy that was brought onto the project would ask, why do i have to edit 10 files to make a model change? what a clusterfuck
Please read what i wrote before ranting. I said If you use typescript and don't use types you are lazy in MY opinion yeah. If you don't wanna use types obviously don't use typescript lol. 
nice, thanks for the heads up!
TS is designed as a superset of JS. It makes sense for the compiler's defaults to reflect that.
this is the same advice someone would give a beaten housewife. typescript is just plain stupid about certain things. lets say i create a db constant in my server file that i want to export to my models. typescript bitches and moans about naming it db in the model files. for what reason? after webpack and minification it doesn't matter one fucking bit what i name it. but someone with an opinion(the time wasting, anal retentive type) decided 'no fuck you why would you want to call your db, db throughout the project, YOURE WRONG', and your linter yells at you, you have red lines and red filenames as if everything is falling apart. and theres nothing wrong whatsoever typescript is like a the control freak OCD bastard son of clippy.
Same, really disliked CoffeeScript but it had some great features that thankfully made it into the language. I personally really enjoy TS but we use Flow at work instead. Here’s to hoping we get more TS-like features built into the language. A strictly-typed ECMAScript would be the bees knees!
Not your fault at all. Especially if you didn’t learn in a statically-typed environment. I remember how frustrating I found compile-time type errors in university so can totally relate. It’s one of those things, like most language features anyone gets used to, that eventually you’ll wonder how you ever lived without it.
Maintaining a schema and writting mapping in for example Sequelize all the way through JSON seriailization is an effort that I would not underestimate. NoSQL allows you to get started more quickly and provides data in a format that is easily consumable and writable from your React.js app (JSON). Also Sequelize is perhaps not the greatest ORM out there (including the world outside of NodeJS)... If you don't developing a db schema plus the Sequelize models, go for it though...
TypeScript is a lot more popular than Flow: http://www.npmtrends.com/babel-core-vs-typescript-vs-flow-bin (with a very good trend - change the scale to 2 years instead of 6 months). As for TypeScript + React used together, check the npm downloads for `@types/react` (the npm package that contains the TypeScript definitions for React): http://www.npmtrends.com/@angular/core-vs-react-vs-vue-vs-@types/react ([screenshot](https://image.ibb.co/jE95dH/Screen_Shot_2018_02_22_at_13_32_04.png)) `@types/react` is even more popular than Angular 2+ and Vue.js and the trend is very good. I'm using React with TypeScript and it's been a joy.
It is also discontinued.
Agreed, just thought if you're starting from scratch it might be the right opportunity to checkout Postgres.
There's nothing wrong with not using an ORM and just using a library for Postgres that supports prepared statements together with the Repository Pattern. It's battled tested and imho just as easy as writing MongoDB queries in Node, which are also some work to implement as soon as you're doing more than a simple GetDocumentByKey.
I'd rather use TypeScript than not, but my goodness, I feel like Java would blow the author's mind!
important question : why we should use this instead of Scrollmagic? 
Can you share what the drawbacks are?
The equation about the quality of an API made me smile.Because I feel I can make you change your point of view in a positive way. - A gradient descent API like autograd is only one function. Can you get gradient descent up and running in a few hours? - The JS grammar is 1,000 lines long. Can you learn JS in matter of hours? - e = mc^2 is 6 characters long. How long does it take to grasp its underlying concepts? To close my point, I will leave a quote of Pascal: "If I had more time, I would have written a shorter letter." In other words, If Redux has not a lot of lines of code is only but a sign they took the time to make it succint. 
Learning declarative programming by example: A simple react declarative form generator using concepts from Category Theory and Container style programming using Crocks: [declarative form generator](https://github.com/dbagia/declarative-form-generator) 
My flow vs ts breakdown: Flow pros: - Even when arguments are untyped, flow will try do check correctness from each caller, swiping down all the code flow (TS will just “erase” the type setting it to “any”) - Better handling of some edge typing cases (seems a slightly better designed type system overall). Nominal typing on classes - Can use with zero transpiling Flow cons: - Recommends to use the same .js extension - If you put it into a big js project the checker may just die or become really slow (while TS still nails it even on huge codebases) - Lack of 3rd party typings (even TSs ones usually may be outdated with the recent language features) - Really worse editor integration (vscode+ts is far better than nuclide+flow)
Is there a point to typing the ID to a user ID? Is one more readable than the other?
I spent a bunch of time reading through the early Redux issues and design discussions while researching my "Tao of Redux" posts. It's fascinating to see the iteration process and the way they settled on what the final APIs should look like. It's worth the time if you want to better understand how Redux works the way it does now.
You're not surprised. Why do you expect everyone not to be?
For typescript, I'd suggest using an IDE that has good intellisense. You'll never go back to trying to remember property names again! Typing "object." and selecting from a list of methods is much faster and easier for me.
True. TS has downsides too, but some people won't hear it.
They are both great projects, it’s left for you to choose.
He doesn't understand the benefits of strongly typed parameters.
Thanks Mark, we agree. Your posts "Tao of Redux" are top notch. In the article, the writer suggests that the ratio LOC / doc size gives the API quality. Hence my comment.
Everyone has an opinion but it's of little value to express it without the justification behind it.
I actually *do not like* Intellisense. I'm trying to look at another part of the code to get a variable name, and a pop-up blocks my view of it. Then again, that's just a pet peeve, not a real problem with intellisense or the language. 
You could use any number of libraries.. React, Angular, Vue, or if you really want a challenge, vanilla javascript. There are a ton of calculators on codepen. Here are some built with VueJs https://codepen.io/search/pens?q=vue+calculator&amp;limit=all&amp;type=type-pens
&gt;Can I do this with traditional javascript? Sure, for something that simple it'd probably be significantly easier to write in vanilla JS than to learn a framework.
It's also fantastic for refactoring. Change the return type in one place, and TypeScript will draw a thread through your code to every place where that has repercussions.
I have no idea what your setup is, but this doesn't sound like it's working correctly at all.
They're being devoted for their sweeping negative generalizations about TypeScript developers. If I walked into a room full of tuba players and said that the thing I hated about tuba players was that they were all snobs, I'd expect some negativity in return.
Actually this is not necessary, you can use plain strings as action types. The problem is that when you remove or change some action, you will never be sure if you covered all the places it was used. It also covers you when you make a typo, giving a build-time error.
What I like is that TypeScript pretty much hits the sweet spot, in that duck typing is possible (`any`). I barely ever use it, but when I need it, it's great that it's there.
It doesn't prevent you but it makes it seem like something is wrong, when nothing is wrong.
You a right, I should have mentioned refactoring as well.
Thanks - this will come in handy on a current project :) 
Being skeptical is good, but there's good reasons why TypeScript is not as bad an investment as CofeeScript' was. (It's still definitely an investment though, as in: there's downsides that will have to be worth the upsides for you.)
Can you explain then? 
Senior dev here, confirming this is the most used thing in my IDE.
What makes you think Typescript is a perfect bug free piece of tooling? https://github.com/Microsoft/TypeScript/issues 15,000 issues, 2500 currently open. It's opinionated contrived complexity, and sometimes it's just plain wrong. Why this additional layer of abstraction is viewed as a good thing, I have absolutely no idea. Clean, logical, sensible coding that's documented reasonably well following the best practices that suit the project you're currently working on, eliminates the need for all the additional overheard typescript demands.
I didn’t say it didn’t increase development time, although when apps grow large there is the argument you’ll save time fixing bugs. I learned on mostly C and Java at university, every language we touched was statically-typed. I found it very weird coming out of university and working on Node with no types. The biggest loss for me was interfaces. JS objects are everywhere yet very often you can’t discern their shape until runtime, interfaces get rid of that issue entirely while adding an extra layer of safety.
man tuba players *are* such assholes though
Can confirm, right after it "Go to definition"
It isn't just the setup/build complexity. I joined an A2/TS project and all of the dozens upon dozens of trivial value objects in the domain adds enormous complexity to reasoning about the domain. The existence of these value objects adds significance that needs to be groked. Sometimes just being able to create and pass around a simple anonymous literal is all you need.
Protip: If it takes a long time to search, use grep instead.
When I discovered (in Eclipse) right-clicking on a variable/class name and clicking REFACTOR, my Java experience was so much better! I'm a newb, but I'm pretty sure this is what you're referring to... And you're right!
Keep in mind those issues are not all actual bugs. The TypeScript team treats GitHub issues more like a forum, taking formal suggestions and help tickets there, in addition to actual issues. If you filter for just bugs you'll find less than half of the issues are actually bugs, and even then drill down and plenty are duplicates or incorrect. Not saying TS doesn't have actual issues. Like any piece of software it does. To me, this huge number more speaks to how incredibly popular it is, rather than it being huge piece of shit. Also chill dude. The commenter did not claim TS was perfect or bug free before you attacked them.
&gt; TypeScript is nice, but JS with super powers? It's JS with *high quality* duct tape.
Absolutely agree. On the Express codebase I'm working on at the moment, mutation was carried out on a module that was imported with require(). This led to a case where you could have a form validation error caused by one user appear on another user's computer. Of course mutation isn't the only thing wrong with that codebase. The object and array spread operators are a brilliant addition to the language for helping avoid mutation. Unfortunately for some reason, that aforementioned codebase is stuck on an old version of node due to the company's policy which doesn't support them.
You're right. If you could modify the equation to make it true, what would might it look like?
It's much simpler to discover bugs in your code caused by invalid parameters at compile time than trying to figure out what went wrong at run time. Here's a link by someone more articulate than I am that goes into much more detail. https://pchiusano.github.io/2016-09-15/static-vs-dynamic.html I personally have spent much of the past 20 years having to debug other people's shitty code and it's much simpler to find and squash bugs in statically typed languages. 
i think you misspelled ack ;)
yes!!!
The guy plainly said 'i don't know what's going on but you're wrong' and asking him a question is attacking him. You're free to say things that are completely stupid but all it does is invalidate your opinion to me.
I played with Elm back one year ago. Elm promises 0 runtime errors. Elm is great! But i could not get our team onboard. Since then i have converted a large JS project to typescript. And im very very impressed. I have since had less than 5 runtime errors (i use rollbar) and they have all been errors from our API returnig the wrong kind of data. I kind of wish the typed JS community from flow snd ts could somehow merge, as i feel its reudandant to have both around, as the greater community could benefit from there beeing only one option. 
You van still compile with type errors. 
It's licensed under Apache. It was 'dead' in Jan 2017 but then picked up by another party in February 2017 who have open sourced it, and commits are going on regularly; https://github.com/rethinkdb/rethinkdb/commits/next So, it's not discontinued.
Although I am liking the thought of new developers changing class names for lols
One of the reasons I love Vue is it does not require compilation in any form (unless you use single file components).
&gt; I feel like C# or Java would blow the author's mind! Actually I think their type systems would seem pretty underwhelming by comparison.
I use IntelliJ IDEA myself, and no, using regular ES6+ does not give you all of the autocompletion and error messages that TS with good typings provides. If you create a function with regular JS and try to use autocomplete inside the function for any of the parameters, Intellij has no idea what kind of type it is and give you a selection of regular methods/properties. I recommend that you try it out and see for yourself.
Thats sound only like a badly designed codebase. Imagine altering that pile in vanilla JS! Eeeh? What does postgres have to do with typed javascript? 
&gt; TypeScript is nice, but JS with super powers? That's hype. CLEGANEBOWL .. *that's* hype
Its easy! Is your data relational? Can you under no circumstances loose data? —&gt; Postgres Is your data flat? Do you save data like a games score pe day? Or maybe a bulk json blob thats always kind of diffrent? —&gt; Mongo (or any other nosql)
Yes, I was disagreeing that it's one of those "you'll wonder how you ever lived without it" features. Interfaces are great. Traits are even better, if you're a Rustacean. =D
The fact that intellij treats your javascript as if it were typescript. Intellij will now let you alt + enter on your imports to automatically download the type definitions for you.
Why this and not Puppeteer, which is supported by the Google Chrome project itself?
I think you misspelt ripgrep...
You're making other TS devs look bad with these statements. Instead of saying 'oh you prefer speed and flexibility in development over the advantages of type safety' you attack someone as ignorant. I've never met a single TS dev that is capable of understanding how someone can have a different opinion or value different things. Pretty sure TS simply attracts a certain sort of person. It's been a fairly reliable indicator of whether I'll be able to get along with someone or if they have a permanent stick wedged up their bottom.
This is why I, whenever possible, use very unique, explicit, and searchable names for anything that might get referenced in multiple files. It's way easier to search in all files for use of a function called 'applyIncrementalEvent()' than 'apply()'. I *always* think of my class, variable, and function names in terms of this basic question: *will I use this name elsewhere, and will it be easy to find if I do?*
adds complexity, more JS churn. F typescript - if you want a strongly-typed language dont use js. 
A old fashioned pinball. modded * can tilt the ball using accelerometer. * and some changes to the over-ways to spice it up. [prebuilt apk](https://drive.google.com/file/d/0BxX1olTVJjWBS05Mb1FlQ3luZEE/view?usp=sharing) [code](https://github.com/cercatore/Flipper) [original](https://github.com/dozingcat/Vector-Pinball) 
This is more akin to waypoints. Scroll magic is a timeline that plays in sync with the scroll bar. Waypoints (and this, as far as I can tell on mobile) are more like events (that you can connect to animations) that are triggered at certain scroll at positions. 
Run and Docker are trying to solve a similar problem: packaging the dependencies of a project. But Docker is doing it at a lower level, and it might be more suited for deployment. To manage dev environment, Run is lighter and simpler. Also, the way you compose tools is different. With Docker, you generally use a network protocol (through TCP ports) to consume/compose tools. With Run, you compose tools in a straightforward OO way using resources that can inherit from each other, and be nested. I think that Run is more suited for the end user (the developer) than Docker which is more for people building low-level services. In a serverless world, developers will not use Docker, they will use managed services such as DynamoDB, Lambda, etc. And to consume these services, the resource's remote invocation feature might be also an interesting option to explore.
&gt; ...and your linter yells at you... A linter != TypeScript. [TS is perfectly happy](https://www.typescriptlang.org/play/#src=const%20db%20%3D%20%22...%22%3B) to let you name your db "db".
I've used TypeScript a little and I simply am perfectly happy without strong typing. the lack of strong typing is actually what I like about Javascript
Please don't. So annoying.
Or “Go to implementation”
Lmao, when you put it like that, I can't really think of why I was doing this Lmao. Probably because, being such a noob, I was naming things terribly? But great point, haha
Null pointer exceptions, miss-named variables, wrong call signature, wrong expected return type, forgetting to await a promise. Most of these errors are trivial if you execute the code. The big strength of typescript is that you don't need to execute your code to find these errors. Tests can catch these things but no one has 100% test coverage. I view typescript as a "simple" integration test that checks my code for not doing anything stupid. To call these errors as trivial is hyperbole. Is a simple bug that makes it to prod trivial? I have personally seen bugs in js that have manifested for months that would have been trivially caught by typescript.