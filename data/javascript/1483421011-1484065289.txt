... and now we have templates, so that problem is basically solved so long as you use it correctly, and don't fall into traps where the old behavior bites you. 
That isn't a good way to test that. No programmer just reads code and instantly knows what all of it does when debugging something. They run the code and interpret the results. If you want to test whether or not someone can identify a coercion bug in your code, give them source code with a failing unit test and say "make this unit test pass." Asking them to *actually be* the JS parser and tell you what every line of code will do precisely is an unreasonable expectation. But debugging legacy code is a totally reasonable expectation.
See, what you just described *does* make sense, but it's not the way OOP is taught. Your description is analogous to a plain ol' JavaScript object (POJO), which isn't even OOP – it's really just a hash map. Once you start introducing classes... that's when things stop being intuitive.
can you explain what an 'enum' is?
Both yes and no. You want some tests that communicate with a mock database, which will test the complicated logic of your app. Then you want to test your database facades to make sure that they communicate with the database correctly. Easiest way to setup a database programatically would be to use something like docker and docker swarm to set up your test environment locally. 
Enumerator
Also when you build locally you should only do the fast logic tests. And then when you run in your ci/build server you would run the slow database tests. Also make sure your tests are not flaky. There is only one thing worse than a flaky test and that is a test that passes inappropriately. 
&gt; Not sure why anyone would find this disturbing It's a reflection on the amount of implicit behaviour that goes on behind even the most trivial operations in JS, and by extension on how much scope there is for edge cases and surprising interactions. Put another way, it's how you get unhelpful and confusing behaviour like the example that started this discussion. &gt; the spec is so low-level that even if you didn't have implicit conversion and only did numeric addition it would still be at least 11 steps. And yet in a... less complicated... language spec, we might reasonably expect three: 1. Evaluate the LHS expression. 2. Evaluate the RHS expression. 3. Return the sum of the above results. You really shouldn't have to be a language lawyer to understand what `+` means.
still don't know what it is....nor have I ever seen one in real life.
Often, it can help to figure out "am I NOT colliding", and then invert the boolean. Look up the standard method of non-axis aligned bounding box collision.
lol. i did. they aren't a thing.
Treat it as proof of concept for now.
How can you get rid of Views without Routable Components? Last time I used ember was like 6 months ago, and at that time it wasn't possible.
That's nice, but again, they are just trying to follow the other trends out there. What's the point in using a framework without an identity that simply tries to copy what the other do? At this point, better use the libraries that are being copied by Ember so you get the real thing.
No...Number() is more concise. + has so many meanings. Number() has one, and it is still brief.
I would rather someone capable of deducing this behaviour using their debugging skills than someone who happens to know esoteric language quirks.
Although something called "views" is still present in Ember codebase, you won't create Views in your app anymore since 2.0. They were deprecated already in 1.13. So I am not sure which concept you mean. I think currently "the view" is just a prototype for components - components inherit them but you don't use them directly in your app anymore.
Definitely no! That is not to say that you should not have tests that include reading from or writing to a database, but those are **integrations tests** not **unit tests**. A unit-test, when viewed from a strict testing-perspective, is an answer to the question "if everything else in my program works as expected, does this tiny piece of code do what it is supposed to?" (or "if this specific other part of my program fails in this particular manner, does this tiny piece of code respond the way it is supposed to?"). If you include external dependencies in your unit-tests you are no longer answering that question, but rather the question "does this piece of my software integrate with this other software the way it is supposed to?", which is an integration test. In short, the database is an external dependency, and should not be included in your unit tests. 
You have to create a View if you want to create a route. This doesn't mean you have to create the `views/myview.js` file, but just the template is enough. But you are still creating a View. (This introduces us to the next big Ember problem: too much magic, you don't know what the framework does)
Not that many companies have enough good candidates to afford passing on one. If you're Google or Facebook maybe, otherwise a question that randomly eliminates a candidate can be costly. In practice they will hire the dev who happened to have read about this gotcha on reddit a few days ago over the one who can reason and write good code.
Oh yeah, I didn't think about the other server if it handles websocket or not. I will investigate this at some point. Anyway thanks for help and positive message! Sometimes I really get too hard on myself, this is magic for some people, I just struggle :D Anyway here is something I found quickly googling about the nodejs security: &gt;I have seen developers running Node based apps on port 80 and serving static files through it. You should remember that running a Node app on port 80 is not a good idea and is dangerous in most cases. Instead you should run the app on a different port like 3000 and use nginx (or something like HAProxy?) as a reverse proxy in front of the Node.js app. &gt;The above setup protects your application servers from direct exposure to internet traffic and helps you scale the servers and load balance them easily.
In an interview you could have easily deduced what's happening if you had ventured a guess that values were being treated as strings. There's only so many ways to get 9 from 1+2-3
It's a common feature in many languages, your original comment in this thread was "Whats an enum", which if taken at face value makes you just another dumb fuck javascript script kiddie who doesn't know how to program in anything else.
Anyone else think learning Vue was much easier and made a lot more sense than React?
XML elements may noy have a `.textContent` property. I'd try `myAge[0].firstChild.data` assuming it is just an element with some text inside. 
and i said "do javascript have enums? i've never seen one" and you continue to claim they exist, so please do point me to where on MDN they are documented...I'd love to read more about them. Never come across enums in perl, php, ruby, or javascript either. So yeah maybe I'm just a script kiddie...but it sounds to me like some dumb fuck C# guy trying to jump on the javascript bandwagon who is whining about javascript not being C#. But please do point me to where Enumerations are documente in the ecmascript specs or MDN. I suggest you look at the shitscript your overlords created called TypeScript. Maybe that have that shit to appease all these morons.
Run. If they asked you that question in an interview, that is not a place you would like to work for. Imagine having all of your colleagues chosen via trick questions like that, and not on technical skill. 
I actually do it really often in console
Multiple choice 15 seconds timed..
I found it the opposite if I'm honest. I'm not a huge fan of anything over templated which I feel Vue is. React feels more in the direction of true JS in terms of how you mix html and variables. 
For me (personally), Vue is more like "jack of all trades" and React is more "it works this way". So it seems to me quite contrary - leargning React made alot more sense than Vue. But my mind works quite on streams and FP lately, so probably it only suits me. So not trying to be objective, just adding personal opinion since you asked :)
Unit test should not include database (or more generally IO) operation. (but if you write IO library, it probably should). You want to mock DB/IO calls. Reasons are two. Main is, you should test only one layer or "unit" of logic in separate. Second is, IO operations are slow. Tests with database are called "Integration tests"
Hey, until recently I was ignorant to what an enum was. I had heard and knew what it did but never used one. I'm very versed in JS and a few other languages that simply didn't have a true enum implementation. Some now do though (python). But yeah, the response did seem ignorant.
[removed]
Hmm. I can't seem to understand how to use this line bot.on('message', function(user, userID, channelID, message, event) Played around with it to see if I could get a response at least: bot.on("message", function(user, userID, channelID, message, event) { msg.channel.sendMessage("Understood."); }); bot.on("ready", () =&gt; { console.log('I am online!'); }); Getting this error as soon as I type something in the channel. http://i.imgur.com/q59vzGr.png Started out with this from the beginner's tutorial so I had something that worked at least, but can't figure out on how to make it respond on anything typed in the channel. var Discord = require("discord.js"); var bot = new Discord.Client(); bot.on("message", msg =&gt; { if (msg.content.startsWith("ping")) { msg.channel.sendMessage("Pong!"); }); bot.on('ready', () =&gt; { console.log('I am online!'); }); 
Excuse my language, but I stumbled upon this a few weeks ago: http://www.jsfuck.com/
You could run ES6 + JSX in the browser with babel-standalone or an earlier version of babel-core's [browser.js](https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js) (without the console warning). For a quick React study refer to [Egghead](https://egghead.io/courses/react-fundamentals). &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.1/react.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.1/react-dom.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.21.1/babel.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; const Hello = ({ name }) =&gt; &lt;h1&gt; Hello {name} &lt;/h1&gt;; ReactDOM.render(&lt;Hello name="World" /&gt;, document.getElementById('app')); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
People decided callbacks are confusing when there are a lot of them. They wished it was easier to write/read/and maintain. Some people somewhere invented promises and a lot of people liked them and they became standard. A lot of libraries and APIs are being converted so that they return promises instead of using callbacks. Promises are basically just a set of rules or requirements. For an object (or function) to be a promise (or return an object that is a promise) the object has to follow those rules. Rules like, it has to have a .then() method. It has to be 'thenable'. Once you realize that you just have to learn the list of things promises can do, which is as simple as reading any number of examples, tutorials, guides, or the documentation. 
You can try Box2D but it's more for physics. 
Anecdotal but I have a few friends (slightly older than you) that have recently switched to dev from unrelated fields and despite the lower salary due to field experience, they're very happy. Also, 32 isn't old :D
I'm in my 40s! Starting a new job today! Quit my old 'career' 10 months ago to learn like crazy and here I am! Do it! :)
Expired
Report
I definitely agree with your comment, especially with "Convention Over Configuration".
There was an article once about the weird stuff some npm packages do. One package simply did a POST to GitHub on install. Quite clever :) But I can't find it anymore.
I tried looking up that site myself. My response was rather unexpected: http://i.imgur.com/J5kqlps.png
Not really. I've heard there's a lot of buzz around it and have been meaning to give it a go (just need to find a suitable project). What kind of problems does it lend itself well to solving? 
&gt; Connect.setRequestHeader("Content-Type", "text/xml"); This one only set the Content-Type of the Request, not the response (which is useless during a GET request), the server will then respond with its own Content-Type that may or may not depend on the request "Accept" header. To check if the document is null do a `console.log(Doc)`. If it's null and there was something in your `Connect.responseText` that means there was errors when trying to parse your XML file.
32 isn't old. You're like 30% through your working years; of course there's time to switch. 
"This is a plan for making this particular type of box. You can make as many as you like, and you will always know that they will have a color, size, and a button you can press." "You can also make more specific plans based on this one for boxes that will have those same three things plus new buttons and new qualities like weight."
Oops replied in the wrong spot! It was a combination! Self taught but also some paid courses and I did jump into a bootcamp to see how it all came together with a team! :)
I don't think an official scaffold/generator is the answer, really. You still should know how to use the tooling provided on your own. But yes with Vue I also use webpack to run a dev-server with hot-reloading and to build the production files... so that's a valid point regarding webpack's essential-ness.
I agree, i think it makes sense to understand Webpack beyond the scaffolding tools, but it's nice for beginners or bootstrapping a project. That is why Vue ships one also, since setting up Vue and Webpack by hand isn't trivial (it is harder even since you need Vue-loader). Though, like i said, React runs with regular script tags just like Vue does. 
tbh I don't really care about "the big 4". So much is focussed on them and most people don't work at them, so to me it doesn't make so much sense to constantly consider them as the model for everything. 
It is dead. Only use it for legacy reasons.
[removed]
That's why you watch those at 1.35x speed and stop when it's interesting haha.
Maybe you don't, but most tech startups try to imitate them at some point. 
And [yarn](https://yarnpkg.com/) is giving npm a run for its money
Oh yeah, yarn is fucking amazing. It's *so* easy to add as a drop-in replacement into any existing project already using npm, and it's incredibly worth using it on every project for the benefits it brings.
Probably the best thing to do is write your own /s
you're right, `condition` could be anything the way i wrote. i should probably elaborate it better. &gt; It's still branching, even if you've cleverly hid it. yeah, that line should've been ~~a joke~~ a subtle motivation of why i did all this thing. i was basically referring to IFs as the language construct, not the underlying branch itself.
seeing how someone responds to a difficult question can tell you something about the person whether they answer it correctly or not or haven't you seen Blade Runner 
I could, but I wanted this to be more of a learning exercise. I plan on reading up on that next.
Yeah, it was copied from elsewhere and no, I don't really care to support older browsers - especially IE (I have enough stress, thanks). I'll have to check out the fetch API, it could be useful in the future. Thanks!
Interesting discussion here: https://github.com/bower/bower/issues/2298
I have a project (https://www.npmjs.com/package/algebra) where I decided to not transpile anymore. I am using some ES5 features like const that will be supported in most of the browsers soon. While server side it works cause it requires Node.js &gt;v4, it is true that client side I don't care cause it is a side project. But it works! Thank you for share about the UglifyJS harmony branch I did not noticed it. By the way you can install it with npm install mishoo/UglifyJS2#harmony --save-dev
The reason we've moved to a compilation step is because it streamlines our development processes and increases our efficiency at development and deployment. If you've been around at all in the past decade, you'll know that there is a strong move toward minimum viable product. Fast development. Faster review processes. I, and developers like me, do not want to reinvent the wheel every time we have a new project to complete. We want dependency management. We want streamlined updates. Yarn, gulp, and so forth, provide this to us in neat little packages that *just work*, and I'm happy about that. &gt;I can guarantee to you that you don’t actually need these tools. No. You can't guarantee that. At all. Furthermore, git submodules? What in the world are you smoking. 
Only if you have a poor implementation of a hash function. In Java, if you have Map&lt;Object, Object&gt; two initiated objects will not create a hashing collision like this.
Anything worth using on bower is already on npm. npm has better dependency resolution. You can switch fairly easy. You can use Yarn for deterministic installs. I can keep going. There really is no reason to use bower on anything but legacy apps.
Vue : 38499 stars React : 56906 stars 56906 &gt; 38499 no ? You need to update the spreadsheet btw
Hi. Article's content has been changed and title didn't match the title of post.
Yeah, that's true because in JS/Java they're behind references, they're not structural types. So if you wanted to implement hashing you'd actually make sure that you compare pointers as well. It's okay to have collisions as long as you store both objects.
It's for 2016, a lot of react's stars came in 2015.
Also Ember Fastboot, which enables server-side rendering with one command. Only possible because of Ember's emphasis on conventions.
Use yarn, not npm (yarn is just npm but significantly faster, with the ability to do flat dependency trees like bower) Switching to yarn was probably the easiest change we've done as a team to get back potentially hours every week
Neat! 
You generally don't want to be modifying methods in the way that you describe. Doing so complicates implementations and can take away from the robustness of your code. The advantages of the prototype chain are that you have a single implementation (usually, preferably unchanging) that is shared among multiple instances. This means you're not duplicating method definitions for each instance created (= more cpu on instantiation + more memory [albeit minimal]), and methods can easily be overridden in subclasses or the instance level. Methods defined in the constructor are duplicates, created during each instantiation, and if you want to override them, you need to take special care to save off the original implementation somewhere if you want to refer to it later since to override, you're completely wiping out the original. var orig_sayHello = this.sayHello; // to be overridden this.sayHello = function() { console.log("Hello, I'm " + this.firstName); orig_sayHello.call(this); } The real advantage of doing methods this way is that you can have private variables that are captured by the method closure at the instance level which is not possible with prototypes. For example, firstName doesn't have to be a property for the Person class because it can be captured in the sayHello closure using the constructor parameter. var Person = function (firstName) { this.sayHello = function() { console.log("Hello, I'm " + firstName); // instance-specific firstName } };
This can vary wildly as there is no actual standard. **Minimal skills** * Understand that CSS is for presentation, HTML is for human consumable content, and JavaScript is for interaction * Competence is writing CSS. If you don't have this then you aren't needed. A company can retask a Java dev to fake their way through this stuff. * Some basic understanding of programming in JavaScript. JavaScript is not Java. * Personality - a vague interest in solving problems and being creative. **To Be A Market Competitive Developer** * Understanding of code distribution systems like NPM and stuff like Vue or Webpack * Familiarity with some popular framework. This changes about every 18 months. * A fairly advanced understanding of practical HTML. * Some basic (minimal) understanding of Accessibility. * Confident in writing JavaScript. It doesn't have to be vanilla JS and you don't even need to have confidence in the DOM (or even know what that is) * Strong communications skills written, spoken, and in the documentation of code. Also know how communication relates to HTML and users' consumption of content. * Novice SEO/SEM skills * The ability to test code and conform to standards defined by automation tools and team standards. * Personality - A strong interest on keeping things interesting, relevant, and modern. **Rockstar** * Forget all the framework stupidity mentioned above. Wasting your time with that insanity is time not spent learning the technologies. * An understanding of markup theory. This will require some understanding of XML/HTML on the basis of semantics and node relationships. You get a solid understanding of the DOM and a half understanding of accessibility for free. * A modest confidence in ARIA. * Strong confidence in writing vanilla JS. * An understanding of web performance. * A solid understanding of code distribution both in practice (NPM) and theory (how this makes everything slow and less secure). * An understanding of security principles * Strong communications skills in both theory and practice. Everybody thinks they know how web technologies work on some primitive level, but to actual rockstar developers this is bullshit in practice. You need strong communications skills to talk around this without disarming or alienating people. * The ability to test code in a variety of environments, scenarios, and various different validation tools with automation. * Personality - Perseverance. The non-rockstars will frequently tell you how wrong you are for doing things in an extremely defensive way in opposition to current trends. Rockstars don't become rockstars by doing trendy bullshit. Rockstars become rockstars because they solve the problems other people are either incapable or unwilling to solve. **EDIT** I used the word *confidence* several times. Just to be clear *confidence* and *arrogrance* mean almost the very same thing. The difference is that *arrogance* is a quality deliberately shown to other people while *confidence* is never meant for anybody other than yourself.
You were asking why "this was even a quirk," and that's why. Because it's unexpected in most mainstream programming languages and definitely a poor implementation of a hashmap object.
no but not because it's dead, but because it's inferior to npm
You mean [yarn](https://github.com/yarnpkg/yarn), npm is 2016.
Local build times, npm installs, CI environment spin up time. All things that are faster with Yarn.
30 here. lets be friends. where are you with your progress so far?
Use case: Polymer
&gt; not saying I disagree See, when you go off and disagree after saying that, it makes people think you don't know what those words mean.
If your skills are valuable then 32 is not old at all, you're probably in your prime hiring years right now. In my experience there is so much demand for decent devs, especially those with several years of previous career experience, problem solving and soft skills in the bank. I switched career to web dev at 38 (1.5 years ago) after completing a coding bootcamp and it couldn't have gone any smoother.
Serverless is in reference to lambda function on AWS since you don't operate a server, you just maintain functions. That's what they keep calling it, so that's what its going to be called moving forward I suspect.
npm package or it didn't happen.
When do you have the need though?
lol. PERL.
Sure thing! I think you might check my github to have an idea: https://github.com/guimochila 
I'm definitely going for it. =)
Do you see a problem with a student who is learning just sticking with npm? I honestly don't see a need for yarn when I am doing small projects and I only ever need to run "npm install something" a handful of times once at the start. And for the number of tools I already have spent time learning or need to learn for web development yarn seems pretty low on the list right now. I'm genuinely interested in your opinion.
So as a person who is still learning web development I'm probably safe just dropping yarn to the bottom of the list of tools for now, in favor of spending more time on things like webpack or sass? 
Hardly a technique. More like a side effect, and a possible overlooked flaw in integrity of overall language design. But this looseness sometimes has advantages that are inherent to _web_ programming. It's "nice to know," for interviews or walking through the forest of JavaScript code written by someone else.
Gotcha. I recall hearing anecdotally that some people like having npm for tooling dependencies (gulp, etc) and Bower for dev dependencies. That way you can run npm update pretty safely to get your tools updated, but not potentially fetch code with breaking changes for your actual project. But yeah, I've switched to npm for everything too. 
Awesome, thanks! That's what I figured but everyone seems to talk about yarn as if it makes npm so obsolete that I have to learn it so I just wanted to make sure :P
I dont see much of an issue with sticking to npm. However, there is also not much of an issue trying out yarn. Its a simple brew install and then you just use it like you used npm. Not much to learn.
Absolutely, if webpack and sass are on your list then yarn will be below them
Oh, that was exacly that confusing part for me then :D I totally skipped that grunt/gulp bandwagon. I was never against that tools, only didnt seem i/we need "another" tool. Thanks for clarifying :)
I use yarn because installs are faster on my CI environment and I've actually had production problems because of dependencies being resolve differently during a heroku deploy than on my local machine. There definitely is a use case for it, but I generally don't advise spending time solving problems that you don't have.
They aren't necessarily but I honestly can't think of anything worth learning that would be lower priority (except maybe switching text editors or something like that). 
Agreed.
Start in JavaScript and get it done first. Then go back and while reading up on TypeScript, make the conversions. Most of it will simply be adding hints to variables to help identify their type. TypeScript is a superset of JavaScript so if you're writing JavaScript, it's like TypeScript without TypeScript features.
Cool. Why did you stop blogging? Keep it up!
This one? https://medium.com/friendship-dot-js/i-peeked-into-my-node-modules-directory-and-you-wont-believe-what-happened-next-b89f63d21558
As the other poster said. Across the team, you have people doing `npm install`, you have deploys and CI environments doing installs, installing new dependencies, etc. All attempts at trying to speed it up (like using npm-cache) never really made much of a difference. Maybe individually it's 15-30 minutes a week, if that person spends a lot of their time doing deploys or installing new dependencies Installing and using yarn is very, very easy. It works just like npm, and is significantly, stupidly faster. Things that take minutes in npm take seconds in yarn. So given that the pain of migrating is basically nil (I did it in basically 30 minutes one day) and the potential time savings huge, I don't understand why everyone hasn't switched over Seriously, I know churn is a pain and there's a million new things everyday is jsland, but yarn was the easiest tech choice we've made in a long time
touche. Its the exact same process as installing node and npm then: https://yarnpkg.com/en/docs/install#linux-tab
the value, DOM node or otherwise, has no bearing on use of `const` in declarations, only if you expect to be able to assign that value to another or not.
still, i'll take what i can get haha
whether const, let or var... I can change the object properties. So, even though it still prevents me from reassigning: const thisConstant = {&lt;dom object&gt;}; to thisConstant = 42; It does NOT prevent me from reassigning the object properties. thisConstant[0].innerHTML = 'hey wow, i am changing this'; completely works. using const, even though it can be changed like this, feels ugly. Im wondering how the internet feels about this.
[TIL that this comic was about Javascript.](http://xkcd.com/1537/)
Totally worth it. [I'm 34](https://github.com/jdalton) 😊
I had to double check the post date... 
So, maybe, more specifically my question is if it is good practice to assign DOM nodes to a constant, given that it really is not a constant. I am not really confused on how it works, but more curious on how it should be in practice. Should I assume that the next person reading my code knows that const doesn't really mean constant in the traditional manner?
Your github contribution activity is insane! 
Creator of lodash, Unbelievable! 
popper.js.org could use some love 🙂
You use Redux for every single state in your application? Sounds like a big overkill!
Could you tell which ones you consider as barely ever run into ones please? Curious here.
Do you hav experience with C++? If so `const` in these languages is very different. Objects in JavaScript are more like C++ pointers and so `const` means the pointer is constant not the data it points to.
Hey thankyou very much! I now have an object for each hero: Magnus: { inCaptainsMode: true, primaryAttribute:'Intelligence', attributeGains:{ Strength: 2.9, Agility: 2.5, Intelligence: 1.65 }, },
fair. You explained it well.
Yeah, the first part of the answer to the first question rubbed me the wrong way. ```The first thing React will do when setState is called is merge the object you passed into setState into the current state of the component``` That's incredibly misleading, if not inaccurate, since setState is asynchronous, and calling this.setState({ foo: true }); followed by console.log(this.state.foo) will likely not print "true" until sometime in the future. Better wording would be something like: ```The first thing React will do when setState is called is enqueue a request to merge the object you passed into setState into the current state of the component```
Have you made an attempt?
Thanks. That clears things up. So how does the callback receive that string? Because for example if replace was: replace("tree", "flower") it would just search for all "tree" and then replace with "flower" but in this instance it seems the result from the first argument is being passed to the second argument function(char). If true, is this how replace() just works in this instance with an array and an inline callback function?
Is there an easy way to transition from bower to something like webpack/browserify? One of the things I like about bower is that it explicitly lists all my frontend dependencies in a separate file from backend dependencies. Do Webpack or Browserify do that as well, or is there an easy way to distinguish client-facing modules from server-facing modules?
Try building it in a fiddle (http://jsfiddle.net) or somewhere first so people know where you are stuck. Here's a place to start: https://jsfiddle.net/52u5ocy1/
I think it's a mistake to emphasize the render-callback pattern and completely omit higher order components.
JSJ can be hit and miss at times, but I found this one to be outstanding!
I hope so. I never understood why people used it in the first place when npm and browserify (and more recently webpack) exist.
Not OP, but sure. I use react at my job, often times daily (depending on the current project I'm working on). I don't think I've ever written a component where I had to treat children as a function. I've never needed to use a callback with `setState`. I'm not sure I've ever needed to write an uncontrolled component. I try to avoid making ajax calls from components, so I'm not sure how I would have answered that question in an interview. I could go on with more, but you probably get the idea. A lot of these items don't seem particularly relevant for being able to write typical react code. They're interesting, sure, and some of them are definitely useful (arguably required) to know, such as keys, refs, functional components, etc, but I can't imagine myself using a good chunk of these on a day to day basis. I think that's the point, though. Here's what the author states in the intro paragraph: &gt; Things you may or may not need to know in React but you may find helpful none the less. I think maybe titling the article as "React Interview Questions" made some people read the article, and then think "shit, I would've failed that interview" (myself included), which I'm not sure was the intent.
Enlightening. Learnt a lot from this. Especially for a person who never really used vanilla React. 
If you aren't familiar with any 3d libraries yet, THREE is definitely a good way to get started; between desktop and mobile there is no hugely important different when writing for WebGL. Obviously, if you eat shaders and linear algebra for breakfast, low-level libraries like twgl or lightgl might be more your flavor (as you get more flexibility and likely more performance, but they will also be vastly more difficult if you aren't familiar with basic GL style concepts.).
the author built a hyperscript dom generator, where the hardest part was multiple argument signatures. hate to be blunt, but all of this work represents the easiest portion of any virtual dom lib or framework. efficient diffing and patching of the existing dom (redraw) being significantly more difficult, which the author completely doesnt touch on. if you're gonna replace React you gotta do more than replace JSX with hyperscript &amp; state passthrough. disclaimer: a ~5k vdom lib: https://github.com/leeoniya/domvm
edit: nvm misread!
You're rarely expected to know the answer to every question in an interview. Sometimes, questions are asked just to get a feel of how in-depth they know something and it's not necessarily a bad thing if they're not super knowledgeable about a particular subject.
&gt; Why even bother spending time figuring out which OO patterns are supported on which packages? As far as I can tell, only React Router has any issues with class extensions, and that's perhaps only true for RR v3. It may be the most well known router, but like I said---its far from the only one. I posit that RR is probably not useful for your project in the first place, so it'd be best not to tie any design decisions to including its use as a default. About mixins'.... my personal belief lies in agreement with that post. I think that traits are a better implementation, but as far as I know there's no mature, well used, traits library for Javascript, so you'll have to invent your own to get that kind of object extension. 
Swyx.io/blog is mine
A promise is like a written contract stated in code. Party A *promises* to deliver the goods. If they do, *then* party B will do X. If they do not, then party B will *catch* the error and do Y. Or.... new Promise(A).then(B.X).catch(B.Y)
ES6 in general, but especially a lot of the more useful convenience/sugary stuff.. arrow functions, implied return syntax, object/array destructuring, template literals, const.. etc. Also a really solid understanding of asynchronous methodology, including stuff like the event loop. Extend that with a deep familiarity with promises and tie it all up with async/await. Higher order, honest to goodness, _functional_ programming. Start with map/filter/reduce. The language actually blows me away now that I have some idea of what I'm doing. It's quite awesome honestly. 
 &lt;ages&gt; &lt;age1&gt;20&lt;age1&gt; &lt;age2&gt;10&lt;/age2&gt; &lt;ages&gt; **EDIT**: it's *age* and not *ages* 
Yup, that was the case but the last versions of PureScript come with psc-package which will be a replacement of bower More info here : https://github.com/purescript/purescript/tree/master/psc-package
Can you recommend a JS framework in the context of which I can apply these concepts?
I'm finishing up the YDKJS series now, as everyone else says, it's superb. Next up on my list of books to read for non-algorithm books is [https://addyosmani.com/resources/essentialjsdesignpatterns/book/](https://addyosmani.com/resources/essentialjsdesignpatterns/book/)
But wouldn't this do the same? class ClickCounter extends Component { state = { count: 0 } increment = () =&gt; this.setState({ count: this.state.count + 1 }) render() { return ( &lt;div&gt; &lt;p&gt;Count: {this.state.count}&lt;/p&gt; &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt; &lt;div&gt; ) } } * Removed some other things, constructor (class props), this-binding (class props + =&gt; autobind), string literals.
&gt; Forget all the framework stupidity mentioned above. Wasting your time with that insanity is time not spent learning the technologies. What do You mean by that? Mind explaining?
What goes against making it a single page application? One in which you have routes that [System.import their higher order views](http://moduscreate.com/code-splitting-for-react-router-with-es6-imports/), so you don't end up with a huge bundle but many small parts/route-views. You can still authenticate and store sets in a database (firebase, etc) and use SSR for SEO or to avoid flash-of-content. 
Thanks man, appreciate the answer.
You do have "dependencies" and "devdependencies" and versioning with npm, so...
it is explained in the docs, react might collect some setState invocations and execute them all at once, so that withou a callback it would increment only by 1
This is really interesting as someone who just fell in love with Alfred. I'll give it a try later on. Edit: And there's a Homebrew Cask for it! Even better.
It's uncommon, but knowing that it's possible is definitely handy. If you setState twice in the increment function for example, your component will only re-render once !
Just wanted to share my thoughts on building a component with Skate.js. Maybe not the most famous choice right now but for sure a good alternative if you care about using web components and the power of the platform. Thanks!
There's no need to distinguish. package.json is categorized into **dependencies** (Bootstrap, Angular, React, Vue, Jquery, etc), **devDependencies** (Webpack, Babel, uglify, loaders, etc) and **optionalDependencies**. Webpack, being aware of node_modules, adds to your *bundle* whatever your app relies on (through the `import` or `require` statement), and creates split-bundles for things you import lazily (`System.import` or `require.ensure`). It then analyzes what you *really* need and excludes the rest, this is called tree-shaking and can turn a large monolight into a couple of KB if you only need a specific part from it. node_modules is not copied to your server. You simply include the resulting bundle.js in your index.html and that's that. The boundaries between server and client are blurred, it is common to use Node packages in the browser (crypto, zipping, base64. etc). Basically if its on npm, it probably works, unless it really needs Node's system underpinnings. As for frontend and backend, i find it curious that you have both in one repo. Normally you just have two repos, each declaring their dependencies in package.json.
Your component assumes `window.Vue` is available. Is this a common assumption in VueJS apps?
&gt; Hi! I solved my problem by passing a string version of the array into `eval()`. Apparently, `eval()` has a bad rep. Isn't `eval()` just fine in my use case since I can sanitize the input because they are hardcoded as buttons?
&gt; so that's what its going to be called **moving forward** I suspect. I see *someone* is well drilled in corporate-speak here ;)
Thanks for the response but when I used your recommended snippet of code (first one), I got an error that said: **Uncaught TypeError: ages.getElementsByTagName is not a function**. Can you also explain the difference between the *element* and the *child* node?
I think I figured out the issue. It should be: var ages=doc.getElementsByTagName("ages")[0]; var age1Element=ages.getElementsByTagName("age1")[0]; var age1_int=parseInt(age1Element.textContent); var age2Element=ages.getElementsByTagName("age2")[0]; var age2_int=parseInt(age2Element.textContent); 
Ah sorry, yeah, it should be ages**[0]**.getElementsByTagName &lt;age&gt; is the element you're finding, it has 2 child elements, &lt;age1&gt; and &lt;age2&gt;
half is obvious for any more-less experienced JS developer, and half is weird because of weird usage (e.g., `new String` or `Number(5)` is almost never used in real life). `null` has type of object, because it represents lack of object. With the same logic `NaN` has type of `number`
Because it's not a number nor a js object that can be equal to anything AFAIK http://stackoverflow.com/questions/19955898 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN
Actually `null` has a type of `"object"` because of a legacy bug in JavaScript. Here is an excellent explanation of this behavior: http://www.2ality.com/2013/10/typeof-null.html
BTW: "Flow" is very similar to TypeScript so they are some important differences beween them. I lean toward TypeScript because it had better tooling at the time. (Couldn't get Flow to work doing Windows-based builds.)
NaN is defined in [the floating-point standard used by JavaScript](https://en.wikipedia.org/wiki/IEEE_floating_point). In that standard NaN is not equal to anything, even itself. This makes sense if you wind up comparing two different expressions that booth evaluate to NaN. For instance `0/0` and `Math.sqrt(-2)` both result in NaN, but they aren’t the same expression. And, yeah, it’s a Number type because it is generated as a response to input for functions that produce numeric output. It’s how the function says, “I know you want a number, but no valid number can be produced from what you gave me.”
But still it has logic even while it's bug :)
Cool! It would be nice to keep in contact for learning thing and play around with some coding.
You weren't accessing the child nodes, no, you were trying to access a second &lt;age&gt; element, which wasn't in the document. x was an array of all &lt;age&gt; elements, which is your root one. &lt;age1&gt; is a completely different element, and may as well have been called &lt;bob&gt; for all that it matters. You got lucky with the first one, in that x[0] was "&lt;age&gt;&lt;age1&gt;20&lt;/age1&gt;&lt;/age&gt;" which becomes just "20" when you called textContent on it.
this list is really all over the place. some of this stuff you can get building a single react application, some of this is stuff you wouldn't know unless you went deeper than the basic docs and looked at source code and github issues and things like that.
There is a debugger statement in the library code. https://github.com/nemo/twilio-f/blob/master/f/sendMessage/index.js#L54
I think you might have got some wires slightly crossed, but I'm not 100% sure so I'll break it down as much as I can. var x = doc.getElementsByTagName("age"); This makes x an array of objects that represent all the &lt;age&gt; elements. These objects includes any children they have, but they must be accessed separately. x has only one entry. That is the object representing "&lt;age&gt;&lt;age1&gt;20&lt;/age1&gt;&lt;age2&gt;21&lt;/age2&gt;&lt;/age&gt;" var age1Element=x[0].getElementsByTagName("age1"); Take that above array, x, and select the first entry, then when we have this first array entry which is a javascript object which has various methods and represents the XML. We call the getElementsByTagName("age1") on this object to get ALL elements that match, this returns another array of all the matching objects. So age1Elements is an array, which contains one entry in this case, that being the object representing "&lt;age1&gt;20&lt;/age1&gt;" On this object we access the textContent value, and pass this into the function parseInt() which returns the value as number.
I could not find a library / tool like this one anywhere, so I made a small one myself. It's not perfect, but gets the job done. You can give it a div-area, which will be used as a "stage" for making the polygonal areas. Creating the polygonal areas in this fiddle is as simple as pushing the "New path" button and then clicking on the div with the image on it to define points of the area and then pushing the "Export path" button to have it console.log the points in different formats in to the developer console, which can then be used where ever. One (obvious) thing which is currently missing is coordinate scaling. Say you want to define some clickable polygonal area for a 4000x4000 image that you display on your webpage - you cannot currently do that because the polygon coordinates defined with this tool are limited to width between [0, 800] and height between [0, 600]. So that is what I am going to fix next. ______________________ In this example image, I defined a rough polygonal clickable area for the rightmost cloud: http://imgur.com/a/1zN8H The export of this area looks like this: [{"x":642,"y":240},{"x":636,"y":234},{"x":631,"y":233},{"x":625,"y":233},{"x":618,"y":236},{"x":611,"y":238},{"x":607,"y":241},{"x":601,"y":246},{"x":600,"y":251},{"x":602,"y":256},{"x":595,"y":257},{"x":587,"y":267},{"x":586,"y":274},{"x":584,"y":280},{"x":586,"y":286},{"x":575,"y":293},{"x":565,"y":297},{"x":562,"y":303},{"x":562,"y":314},{"x":570,"y":316},{"x":577,"y":317},{"x":582,"y":323},{"x":587,"y":329},{"x":595,"y":331},{"x":608,"y":331},{"x":614,"y":332},{"x":628,"y":329},{"x":635,"y":329},{"x":648,"y":330},{"x":659,"y":328},{"x":664,"y":332},{"x":678,"y":334},{"x":690,"y":336},{"x":701,"y":339},{"x":710,"y":339},{"x":728,"y":340},{"x":738,"y":340},{"x":753,"y":339},{"x":770,"y":332},{"x":780,"y":327},{"x":787,"y":325},{"x":786,"y":316},{"x":787,"y":306},{"x":787,"y":297},{"x":777,"y":288},{"x":772,"y":283},{"x":769,"y":271},{"x":762,"y":261},{"x":741,"y":261},{"x":734,"y":255},{"x":727,"y":248},{"x":713,"y":247},{"x":709,"y":247},{"x":706,"y":245},{"x":704,"y":237},{"x":688,"y":231},{"x":677,"y":229},{"x":663,"y":230},{"x":652,"y":232}] Or this: [642,240,636,234,631,233,625,233,618,236,611,238,607,241,601,246,600,251,602,256,595,257,587,267,586,274,584,280,586,286,575,293,565,297,562,303,562,314,570,316,577,317,582,323,587,329,595,331,608,331,614,332,628,329,635,329,648,330,659,328,664,332,678,334,690,336,701,339,710,339,728,340,738,340,753,339,770,332,780,327,787,325,786,316,787,306,787,297,777,288,772,283,769,271,762,261,741,261,734,255,727,248,713,247,709,247,706,245,704,237,688,231,677,229,663,230,652,232]
disadvantages: When I google Zazu, Lion King comes up ... and now my niece wants to watch Lion King
Good point. But sometimes you can not be picky about your job.
7 actually, still remember Paul Kinlan's tweet, but can't find it atm. http://www.forbes.com/sites/velocity/2010/06/25/google-isnt-just-reading-your-links-its-now-running-your-code/#ec388e03ef88
wait, what??
That's true if you only receive that type of questions. But it's typically something you could ask (among other stuff) if the candidate presents himself/herself as a React expert.
"Too many eventListeners" isn't the only reason that people should use event delegation. Another reason is that the dom could change, and you don't want to have to worry about adding an eventListener to the newly added items.
No. setTimeout is just used as an example of long-running function with callback.
It would also be good to know if the individual was curious about the correct answer as well.
It is regular JavaScript code, but executed differently: it is split into statements and executed statement-by-statement. This allows it to pause between statements and wait for completion of callbacks.
and remove that split
tried this, still not working &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;p&gt;Click "Try it" to display the first array element, after a string split.&lt;/p&gt; &lt;button onclick="myFunction()"&gt;Try it&lt;/button&gt; &lt;p id="demo"&gt;&lt;/p&gt; &lt;script&gt; function myFunction() { var str = "a,b,c,d,e,f"; var strb = for(var i = 0; i&lt; str.length;i++) arr[i] + " "; document.getElementById("demo").innerHTML = strb; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
i can try some insert but idk if there's such a thing in java
i tried this, but it did'nt work neighter, maybe i should use string insert function, there's such a thing in java? &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;p&gt;Click "Try it" to display the first array element, after a string split.&lt;/p&gt; &lt;button onclick="myFunction()"&gt;Try it&lt;/button&gt; &lt;p id="demo"&gt;&lt;/p&gt; &lt;script&gt; function myFunction() { var str = "a,b,c,d,e,f"; var strb = for(var i = 0; i&lt; str.length;i++) arr[i] + " "; document.getElementById("demo").innerHTML = strb; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
You should give [this](https://www.youtube.com/watch?v=Il4swGfTOSM) a watch. It's very applicable to your question, especially the part about the radio (around 14:20).
This seems way more verbose than async/await
&gt; Wasting your time with that insanity is time not spent learning the technologies. Aren't frameworks JS technologies? IMHO, to be efficient in ANYTHING that is written in one language, you have to be efficient in that language. Like You've mentioned Vue - You can't normally use it if You don't understand JS well enough. CopyPasting code samples from SO, without fully understanding it is what makes you stop growing as a dev.
I initially read that second problem as wanting a 3 second delay between each console.log, so I decided to give that a try, and came up with the below. function loopDelay(list) { let i = 0; function counter() { if (i &lt; list.length) { setTimeout( function() { console.log(i); i++; counter(); }, 3000); } else { console.log("we're done here") } } counter(); } loopDelay([1, 2, 3, 4]); Made it a recursive function, curious to hear if someone has a cleaner solution / critiques since I'm still new to JS. 
Is there something wrong with EventEmitter and its various browser ports?
&gt; A crutch implies it's something that hampers your career or slows you down. Crutches are enabling devices. They are not used to cripple people. A crutch helps a person who has trouble walking become mobile and get up quickly. That is the purpose of frameworks. Whether or not a person is slow isn't dictated by the crutch. A crutch isn't going to make a person into an Olympic sprinter though just as devotion to frameworks won't make you a super duper awesome developer. They help to a point after which they become more of an anchor than a lifesaver.
Not sure if you're the author or not but I think I'll stick to async. Can you give any reasons to use this over async.series? 
Thanks very much - but im using photoshop for the development of the actual image, im OK in that department (nowhere near professional, but i know my way around hehe) What I do need help with is the actual code :)
just curious, how is it broken?
ember
Well dang. You should move to Silicon Valley and tell all the architects at Facebook, Google, etc they are doing it wrong :o Try working on the front end of an enterprise app with over 100 UI engineers without a framework, let me know how it goes.
When it said "app" I thought it meant for mobile, and got a little excited about being able to do a presentation with just a phone, and not having to drag a whole computer around.
&gt; Try working on the front end of an enterprise app with over 100 UI engineers without a framework I work for one of the larger .coms. Anyways I will leave you with this from above: &gt; Personality - Perseverance. The non-rockstars will frequently tell you how wrong you are for doing things in an extremely defensive way in opposition to current trends. Rockstars don't become rockstars by doing trendy bullshit. Rockstars become rockstars because they solve the problems other people are either incapable or unwilling to solve.
Depending on the code, `visibility: hidden` is probably better. That keeps the buttons in the same positions.
Express + EJS. 
It's nice to see some effort, but some advice looks a bit vague, for example I fail to see what is wrong with `getClientData` as a function name compared to `getUser`. At least former is used in some of Android and Microsoft APIs and doesn't feel strange to me, most likely requires some documentation anyway. Also I would like to think that the example`var MINUTES_IN_A_YEAR = 525600;` is a WTF in itself, because it fails on a leap year :) 
Thanks, I'll try using this instead. Under what circumstances should it NOT be used?
The more clear the function names the better imo. I have to agree with you.
That might be caused by the response your server is sending. It would help to see the code you're using. There doesn't seem to be anything in that JS library that would work differently in Firefox.
True, we're biased. I still remember trying to explain OO to my friends and getting confused between a Class and an Instance. I think FP is just as hard to understand as OO but no more. FP is easy to explain once we understand to concepts. But because most people, me included we don't know it enough we think is harder to explain/learn. 
The point of your first example is that the three functions `getUserInfo();`, `getClientData();`, and `getCustomerRecord();` are actually about the same kind of data, but uses three different words for it: user, client, and customer. You should pick one word, and stick to it, for consistency. The second example is a valid point, and though only for demonstrative purpose, could be changed to something truly constant. Maybe you should make a pull request with something better? :)
You never actually explain what you want your invite to do... I see that you have "Ctrl + S" in your mockup, are you saying that you want the user to hit those keys in order to save the date? What will that actually do? What are you hoping to save? If you are hoping to save a date to their calendar, this is trickier than just a little JS. One option I've heard of is to generate calendar files, but I'm skeptical whether this will support many different calendar systems, and people use lots of different ones these days.
Still getClientData is redundant IMHO, I remember that there is some part in Clean code's book that says specifically not to use the word "Data" for variable names, everything contained in variables is data so why use that for the name? It's like using Hungarian notation but even with a less meaningful purpose (Hungarian notation at least give you information about the data type, I don't like it either way).
It's an old book, but it's called "The Mythical Man Month" and I not only suggest every programmer read it but everyone who works in the software industry as a whole.
WTF?
 ---- "2 or less arguments" is, generally, good. But it should not be strict. And then, putting all your parameters into one `config` or `options` argument _doesn't solve anything_ by itself. You're just _hiding_ things, not fixing them. A fix, would be defining things _which make sense defining_. Are you passing, say, 3 texts, 3 optional colours and 3 optional font weights? Well, it may be that the problem is you have a hidden structure `{ text, colour, weight }` of which you have three occurrences. Then you should define those `styledText`s as something your application uses. And then, it may make sense to put them in an array and pass that. _Or_ it may make better sense to pass them individually, even though they are more than two, because they have each an explicit meaning, say `(title, subtitle, description)`. Is a signature such as... function createWidget(options); ...actually better than... function createWidget(title, subtitle, description); ...? I personally don't think so, and I even have autocompletion off in my editor most of the time... Also, a `config`/`options` argument usually hides the optionality of some arguments and that is, IMHO, a bad thing. One middle ground I've come to like is having... function doStuff(required, required, optionalOptions); It still hides some information, but at least it's the least frequently used if most of the time you just go with the defaults (because they are _optional_ options). Note: Here, argument destructuring and default values, could be argued. I'll leave that so that this doesn't become too long and boring (probably too late for that, I know xD). ---- "Functions should do one thing" is a confusing mantra to many people. If you just present it as dividing a function into really small things where even an `if` means we're doing two things, you will confuse them. It will because examples are all nice and pretty, but real code is not always so. In particular, real code does not generally compose on doing A, which does B, which does C. Most of the time it composes on doing A, _then_ doing B, _then_ doing C. That is, you can divide it all into one line functions, but at some point you'll have to put all that together into something which does all the things you want. "Functions should do one thing" should always be explained by adding a context or level of abstraction. Functions should only do one thing at their level of abstraction. I.e. `createWidget` may have to do a fair number of things in order to create the widget. But it should only do one thing: _creating the widget_. It should not be responsible for, say, translating the widget texts, but it should probably call to get them and then pass them to the initializer and get whatever it gives back and pass it to the renderer. All that is "creating the widget", at that level of abstraction. Where do we get the translated texts from? We don't care. _That_ is what `createWidget` should not concern itself with. It is a lower level of detail which will be handled by someone else. But still the "one action" of _creating the widget_ may righteously include doing more than one single step. From a different point of view, the example used is also _wrong_. It claims an action should do _one thing_ and still, `emailClientIfNeeded` is clearly doing two things, checking if the client should be emailed (and deciding how that is checked; it decides "if **needed**" means `if(is`**`Active`**`(client))`) and emailing them. I -personal opinion- would find a solution like this much better: function emailActiveClients(clients) { clients.filter(isActive) .forEach(emailClient); } `emailActiveClients` delegates the decision of checking if a particular client is "emailable" or not, but it is still responsible for deciding to check that. ---- The "good" example code in "Functions should only be one level of abstraction" contains a lot of bugs. `tokenize` and `lexer` don't declare any arguments (`code` and `tokens`, respectively). `parseBetterJSAlternative` is calling `ast = lexer(ast)` instead of `ast = lexer(tokens)`. ---- "Never ever, ever, under any circumstance, have duplicate code." This one... well, I have this personal rule: "Never ever, ever, under any circumstance, follow rules that begin with Never ever, ever, under any circumstances". It's good to have rules. It's good to have strict rules. It's usually not that good to make rules so strict, because, yes, sometimes there are perfectly valid reasons to break those rules. In any case, the code here is somewhat confusing. You have two different functions which, though similar, do some small different thing. But the "good code" has one function that unannouncedly does something _different_. `showDeveloperList` expects and shows a list which should contain _only developers_. `showManagerList` expects and shows a list which should contain _only managers_. But then, `showList` will happily show a list which may contain a mix of both developers and managers. Whether or not this change is ok with our business requirements is out of the scope of the example. The problem is that it changes the functionality of the code. (Note also that the "good code" adds a misterious new `var favoriteManagerBooks = getMBAList()` line...) ---- I will stop here, with one last thing. "Avoid type-checking (part 1)" should actually be: "Learn to use polymorphism". You're doing what you do in "good code" because you changed Bicycle and Car to have a `move` method instead of a `peddle` and `drive` respectively... But you didn't point that out. And that is really the key to the "good code". You couldn't "avoid type-checking" if you hadn't decide to use polymorphism.
Sorry if this is really long. I didn't even cover half of it anyway.
Yeah, I see the need for this most often with search fields that auto-update results. If you trigger an ajax call on every keypress, things get a little spammy and it tends to be better to wait until they've been idle a moment.
you could also write it like this: document.getElementById("demo").innerHTML = arr.join(' ') 
It's hard to take this seriously when there's no package.json.
Hadn't touched PHP for many years until a job I got recently required me to. They are a Laravel shop. I must say, it's really quite impressive and I don't think there's anything as complete out there for any other language, sadly. 
The course has just been opened to the public for free! 
Not sure of anyone has said this already. The bit about duplication glosses over an important point raised by Sandi Metz who teaches SOLID Ruby. Brazenly DRYing up code can in many cases leads to bad abstractions. Duplication is easier to see whereas bad abstraction are much harder to spot. I am far more careful when I DRY code since I learned this simple lesson. I am about half way through and it is a pretty impressive effort. Props...
But instead of a transpiler, you're basically running a JavaScript engine in the current JavaScript environment as far as I can tell. Isn't that ridiculously inefficient?
Well, the question asked what setState does. The fact that it is asynchronous was omitted from the answer, and that's a pretty important detail. The way JS event loop works is irrelevant for synchronous functions.
&gt; to display the first array element just do `document.getElementById("demo").innerHTML = arr[0]` no need to loop to get the first element 
Because Firefox is a piece of shit. 
Agree. The very first questions that comes to my mind is - how to regulate communities? If we're the big family, should we follow the state regulations? If we should, what about scenario when you call your relatives by phone and ask - can you give me a ride to N for $X? I'd really like to hear what people think, that's a very good question.
quick and to the point. thanks!
This worked for me. getField("TOTAL").value = getField("SUBTOTAL").value if(getField("TOTAL").value &gt; 175) getField("TOTAL").value = 175;​
Oh, that is a lot simpler than regular notation! Thanks!
it's to keep everything on a single line. But I guess I'll reactor it to simply use Math.floor directly. Thanks for pointing it out! 
This: function myIndex(x) { input.indexOf(x); } is the same as: var myIndex = (x) =&gt; { input.indexOf(x); }; Well almost the same. There is one important difference that has to do with scope. I'll let you google search for the auto scope binding that it does. edit: I love the discussion this caused. I learned a lot here. 
yup that was an additional reason but I suspect babili should already take care of it. If it doesn't, I'm going to write a plugin to make it possible.
Congrats on the release :) It's worth mentioning that the linked benchmark table has a very diverse mix of implementations, most notably, keyed vs unkeyed. Inferno's impl as well as VanillaJS is unkeyed while many frameworks are keyed. This has a drastic impact on perf and should really be split into two tables. [1]. The rules have only recently been clarified that all impls must be keyed but the porting pace has been rather slow lately. /u/localvoid's kivi has the fastest *keyed* impl (1.18) and beats most *unkeyed* impls, which is quite amazing. One way to quickly spot the keyed vs unkeyed impls is to look at the "replace all rows" metric. Any lib that's faster than kivi here (&lt; 142.11) is unkeyed. keep in mind that vanillajs-keyed is not currently correct [2] The latest table is actually here: https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html -- [1] https://github.com/krausest/js-framework-benchmark/issues/104 [2] https://github.com/krausest/js-framework-benchmark/issues/103
I get something called "MessageEvent" when doing it in chrome. In FireFox I get "Message" and Message.data is a string that is clearly base64. MessageEvent.data is an array. I tried replacing the event.data to Message.data and that did not work.
This is a well-known documented issue in regards to JavaScript (and IEEE754 in general.) Any good reference should explain everything you need to know about [isNan](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN) and, very importantly, how it differs from [Number.isNaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)
What's the difference? I'd love to find out more!
A linting tool is exactly what you're looking for. You can personalize the settings for yourself, you don't have to use the default rules. But you are kind of asking for 2 totally different things - you want it to find all of your small mistakes, but not worry about small mistakes. 
No, I've not had time. I've got a lot on my plate right now. I will re-visit sometime in the future once the new job settles!
tcomb is a great project, but it predates flow and doesn't have absolute compatibility with flow as a goal. `babel-plugin-tcomb` suffers from the same problem that my earlier project `babel-plugin-typecheck` did in that if you don't match Flow's semantics exactly you can't coexist with Flow itself. This project aims to totally match flow's semantics and provide a type system that can represent any value, so that people can build other things on top of it.
That's awesome. I wish you the best of luck.
You might dig this blog post on virtual DOM benchmarks: https://medium.com/@localvoid/how-to-win-in-web-framework-benchmarks-8bc31af76ce7#.ly1afqxun
Better start learning your ES6/ES2015: https://babeljs.io/learn-es2015/ Enjoy!
You can also do `'' + variable` for the same result as `String(variable)`.
yep, already have: https://www.reddit.com/r/javascript/comments/5ddwqq/how_to_win_in_web_framework_benchmarks/
I think it's "context", not "scope". It's still function scoped, but the `this` refers to the surrounding context's `this`.
Hey - newish dev here, was curious about "Set default objects with Object.assign" - what is the reasoning behind this? He doesn't give any explanation as to why that's a better way of doing it.
Also I can't access Message.data .. to know what it is i have to look at it in the console. If i type Message.data it gives the error "is not an object"
Here's something similar to your example but more like actual javascript syntax: http://i.imgur.com/5iHe80R.png
If you link something and then install, it'll screw up the dependencies of both projects. Often requires multiple installs, and sometimes even then doesn't work. There's been an open issue on GitHub for as long as it's been an issue but it remains unfixed.
https://en.wikipedia.org/wiki/No_true_Scotsman
It took a while, finished on 29th of December my tiny project: https://github.com/ro31337/libretaxi It's javascript open source alternative for Uber, works on iOS, Android, desktop, web because it's Telegram bot Website: http://libretaxi.org
react has all sorts of patent issues. This is good.
[MDN explains](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) it pretty well. Sorry, can't copy the relevant section, but read through the Description section.
&gt; everything contained in variables is data Not necessarily, if we use the English language to define data. You can think of data as a collection of datums. It follows, then, that `getClientData` might return a collection of datums about the client, like their phone number, age, etc. Edit: that is to say, `getClient` might just return their name (ideally you'd use `getClientName` for that), so tacking on "Data" might make it clearer what it's returning. Better yet, if you have a type system then you don't need to think about this in many situations. This is pedantic, of course, but I thought it was interesting.
Last I tried, it doesn't work on safari, so apps running on iPhones and iPads will fail. 
Your assumption is correct. When I was building the platform I was thinking about smaller regions and how people can benefit from the software. Skills are important, but it was not my goal
IMO mithril.js is perfect (especially the [rewrite version 1.0](https://github.com/lhorie/mithril.js/tree/rewrite).) It gets right out of my way when I don't want it, or I can use it like a full framework. You only need the one npm lib; it comes with: * A fast vdom which will seem familiar to a React user. * A router with a simple mode or more complex mode when you need more control. * A handy http request library that can be as simple as fetch or give you the full power of XMLHttpRequest. * Lifecycle methods that let you get your hands on the DOM. * Redraws are automatic so you tend not to need a state management solution just for redraws. And you can opt out when you need to. * A simple streams library that also might eliminate the need for 3rd party state management. I use it with typescript and browserify for a pretty minimalist dev stack.
explain what the funct a functor is.
lol. I have found @mpjme's explanation here to be the easiest to digest https://www.youtube.com/watch?v=DisD9ftUyCk. tl;dr "Functors are objects that have a map method" -- @mpjme
Care also to elaborate why one would use a keyed framework if unkeyed ones are generally better-performing?
most (probably all) libs are capable of both keyed and unkeyed operation - on a per-node basis, in fact. when nodes are unkeyed, you could end up with subtle bugs when there are adjacent elements that are similar, such as in lists, tables or form grids. sometimes your CSS animations or transitions can stop prematurely cause a dom element gets matched and patched to a neighboring vnode when the list mutates in some way (sorting, removal, insertion). if you add any custom css or attributes to a dom element originally created by a vdom lib that element can be reused for another purpose accidentally. element focus could get lost, the transient values of form inputs may suddenly appear in the wrong input. most libs mitigate the last case in some way even in unkeyed mode cause this would cause major issues. there are probably some other subtle problems i'm not thinking of. you can read more (heh, or less) about it in React's docs [1] typically unkeyed performance is significantly better, but you gotta be aware of these caveats, understand whether they apply in your specific case and - if so - ensure they are sufficiently mitigated. [1] https://facebook.github.io/react/docs/lists-and-keys.html#keys
That help. Putting this at the beginning of the onmessage event fixed it. I just had to add data = data.buffer; before the dataview. It was giving me an error "expecting Arraybuffer getting uint8array" Thanks a lot. Now if i can just figure out why my game crash for me but nobody else. Maybe firefox doesn't like loading stuff from 127.0.0.1
I'm not lying – maybe "quite" was incorrect usage, by a "small" margin was more accurate. Inferno's fastUnmount optimisation accounts for almost all of the performance difference over previous versions of Inferno. Keep up the great work on Kivi/Ivi though :)
Awesome stuff, good luck with your platform!
Got it. MUCH appreciated. Thanks man
That's basically what Vue does.
Can you link me to the correct benchmark table please? I must have been looking at the wrong one. Anyway, keep up the great work that you're doing! I hope you're able to contribute more to Inferno in the future!
awesome work ! , I think that you should implement a decentralized reputation system with a public ledger like blockchain .
The code given is appropriate for ES5, but for ES6, I prefer: const menuConfig = { body: 'Bar', cancellable: true } function createMenu({ title = 'Foo', body = 'Bar', buttonText = 'Baz', cancellable = true }) { // ... } createMenu(menuConfig);
I want something instantly while I'm typing. I have a plugin doing that for typescript when I'm using angular 2. But it does't work with the .js file. Maybe I can simply do typescript on node.js. It may solves the problem. (And probably create another one...)
&gt; My front-ends have had much more complex code than the backend. Its the trend, since requirements in normal applications shifts towards user experience and interactions. Just compare - does normal application need some complex data processing abilies aside from cruds? :D It would be weird, that UI is still not complex enough... 
Thanks I was trying to wrap my head around mobx using their own example but it's quite broken.
Did you try reactjs ? I learn reactjs + redux, and it brings new concept on how to code js and how to create nice ui. 
people do not have to learn a new "syntax" for JSX. Normal HTML looks more cleaner. Look on Polymer, where all is normal HTML. Or RiotJS. 
There's a saying, where there's smoke there's fire. There is a reason [JSX has taken over the web](https://github.com/facebook/react/wiki/sites-using-react). There is a reason pretty much every new framework expresses UI functionaly. Three years ago people described your feelings as "JSX shock" and everyone has had it. Take the [challenge of getting familiar with it](https://egghead.io/courses/react-fundamentals) and it might just change your impression. Personally i think JSX is a revolution, i have worked with UI for almost a decade on native systems, mobile and on the web. If you think it's ugly you're looking at the wrong examples. Just like Javascript it's up to you how you lay out, you can make it as elegant or convoluted as you want, the same applies to templates btw. 
So kivi, vanillajs keyed, dio and inferno all beat vanillajs with inferno being the fastest. That's interesting.
Well I lean towards not encoding logic in JSX, because it reminds me too much of the complexity explosion you can get from doing the same in XSLT. That said... the point I made was that authLogic should be a seperate library in regular JS, not a bunch of functions written inside a React component class. Using the library from within a React component class though... is fine.
I know, but it would point to vanillajs being broken as it's slower than those I mentioned.
I'm confused, do you have the code where the heavyComputationTask function is defined? That is where you'll find your answer. Promises themselves don't run in a separate thread. So the answer is within heavyComputationTask, and whatever approach it uses could also be used with traditional callbacks. It could be batch processing records using setTimeout, requestIdleCallback, requestAnimationFrame, something like that (allowing the browser time to do other things), or it could be sending a message to a webworker and then resolving when that webworker sends the result back. But none of those approaches have anything to do with promises.
Well, clean look is pretty subjective. JSX in React is just thin sugar layer that gets translated to function calls creating virtual dom tree. It's not like they thought it would be cool to put HTML in your JS without a reason; it just makes using React API a little easier and more readable, but you can still use React without JSX.
as /u/throwaway12933428233 said, all secrets are in heavyComputationTask. But if You ask about how Promises/Event loops works: As You said, JS is single threaded. One task at the time. So, browser/node give you a run time environment that has Event loop (and other useful APIs). So, lets say you send an AJAX request to a site. Waiting synchronously for a respond, could hang your app for couple of seconds or more. And here comes the Event Loop - When AJAX is finished (or failed), it passes a function (a callback from AJAX) to an event loop - which waits for **call stack** to be empty, before pushing that callback into it. Then again, when call stack is empty, pushes next callback from event loop. And so on. 
JSX is regular HTML with a few exceptions. There's hardly anything to learn, you can grasp JSX under a minute. Template HTML on the other hand is far from regular HTML and it needs severe study to fully grasp and use it. It is also different in each and every library that relies on it. This is some gibberish: `is="dom-repeat" items="[[items]]"`, `ng-repeat="item in items track by $index"`, `v-for="item in items" track-by="id"`, `v-bind:href`, `v-else-if`, `:prop`, `@click`, `"[[something]]"` `"{{something}}"` `checked="{{hostChecked::change}}"`. 
I worked with JSX, but I dont like it. I dont think it will takes the web. React is a normal JS framework. In 2 - 3 years we will talk about new frameworks and not so much more about react. A few years ago JQuery was awesome. And now we have better options. I think JSX is atm for people interessting but not anymore in a few years. But the clear way of HTML will be there. 
Adding to this, Promises are elegant way of dealing with [callback hell](http://image.slidesharecdn.com/async-131121204456-phpapp01/95/avoiding-callback-hell-with-asyncjs-12-638.jpg). You pass a function to `.then` method of a promise, which will be fired with an argument (respond from a server) AFTER the asynchronous task is completed. Check out [my example](https://repl.it/FBVB)
Given this ES2015: var myIndex = (x) =&gt; { input.indexOf(x); }; I think the closest you can get in ES5 is: var myIndex = function (x) { input.indexOf(x) }.bind(this) The main difference is the use of a function expression in the ES5 version rather than a function declaration which is hoisted differently. It also shows of the scope binding that you mentioned.
You've got to transpile this stuff with Babel down to ES5. As fast as browsers try to adopt new ES6 features you'll still find yourself using new syntax (spread, generators, etc) that hasn't been fully adopted in the language yet.
It should be used for light utility functions. Not used for methods on complex class-like objects.
React as a framework might go away, perhaps. But the underlying, functional principles are more of a natural evolution of the data-bound templating system (Angular, Vue, XAML, handlebars), which itself was a evolution of the layout-inflater (Android, Jquery, WinForms), which was a evolution of layout in code (PHP), which came after code as layout (Gtk, Win32). These progressions came about way slower than your framework of the month. Notice also that each system built on the previous. JSX won't go unless there's something better, and it will likely take the functional cue. We've been waiting for "official, clear HTML" for over a decade, it's been stuck with the inflatable paradigm ever since. The committees handling web-components aren't exactly breaking new ground. Web components do not scratch the surface of what functional UI and JSX already do better. It doesn't even begin to address dynamic structures or data-sources, which is why Polymer itself relies on code-in-HTML directives for which there are no drafts. Meanwhile JSX, having solved all these issues naturally using common JS, is already exploring native and mobile, even universal apps have already been hinted at.
[Creator of Inferno joining React team](https://www.reddit.com/r/javascript/comments/5ke0qr/the_creator_of_inferno_is_joining_the_react_team/) Hopefully both projects benefit.
You are missing &lt;/script&gt; at the end........ edit: more dots.
Hi /u/laratechnologies1, please stop reposting links that are already on the front page. This is the 3rd one. Thanks.
In regards to the number of parameters and using a config object, there is a huge benefit when actually calling the method. If you use `function createWidget(title, subtitle, description);` Then the function call could look like `createWidget('Blah Blah', 'sub blah blah', 'Here is some text');` You lose clarity and potentially have to reference the function each time to check what each parameter means. With a config parameter, you get the keys for each argument const config = { title: 'Blah Blah', subtitle: 'sub blah blah', description: 'Here is some text' }; createWidget(config); And then you can still easily see what is happening in the actual declaration function createWidget(config) { const {title, subtitle, description} = config; }; 
No the var itself is instanced inside your function Budget. If you want to give it to other functions or whatever just take the return instead. Something like: var myNewVar = Budget(); You could also use a global variable, but I wouldn't suggest that.
Async work, like network request or click event. as I said, JS is running in a environment, where JS has access to other APIs (like setTimeout or setInterval). It is that environment that puts your callbacks into Event Loops, which is executed in order and when call stack is empty.
well that didn't last long.
I would definitely take a look at the MDN article posted but ultimately, you can pass in a smaller config object with only the parameters you care about. Imagine if you had a function config with 80 keys in your object. A bad approach might be to create this gigantic config object each time you call the method. If you use Object.assign, you can pass in a config object with only the attributes you care about and then you can create a new object in your method that sets all of the defaults initially and then overwrites the keys using the passed in config. function someMethod(config) { const defaults = { myKey1: 'myDefaultVal1', myKey2: 'myDefaultVal2', myKey3: 'myDefaultVal3' }; config = Object.assign(defaults, config); console.log(config.myKey1); console.log(config.myKey2); console.log(config.myKey3); }; const sampleConfig = { myKey2: 'The value I care about' }; someMethod(sampleConfig); // Prints... // myDefaultVal1 // The value I care about // myDefaultVal3 You can read a little bit more here https://jessejorgenson.com/development/2016/08/14/js-function-params.html#object-assign-is-awesome
Anyone know which version of Ember was used for benchmark? Ember released Glimmer 2 engine with 2.10 and it is supposed to be 1.5x faster. 
Minor point here, but if you are planing on using this solely for data storage and don't need the prototype, Object.create(null) instead of {} gives the object a little less bloat and lets you iterate over it easier depending on how you prefer to iterate over objects. (ES6/7 kind of makes the iteration point moot between destructuring, .values, .entries, etc). Again, this is a minor point and really only applicable if you use for/in (I don't). Otherwise it's just a tiny memory savings, but if you need to create a ton of objects for some reason, it can add up.
Sounds like situations where you should just pick the best tool for the job.
A linter plugin should show instantly while typing.
Your first example definitely does seem more straightforward with a for loop, but it all depends what your'e doing within the loop? For your 2nd example, are you modifying every nth value in place? Or are you going to discard the rest? If discarding the rest, using filter().map() could work nicely. The 2nd argument to filter()'s callback is the array index. The functional array operators like map(), filter(), and reduce() are mostly useful when you're modifying the data, since they let you chain together operations in a nice way. For example: function double(x) { return x*2 } function subtract1(x) { return x-1 } function greaterThan5(x) { return x &gt; 5 } const newArray = origArray.map(double).map(subtract1).filter(greaterThan5) I learned a lot about their uses by doing this interactive tutorial: http://reactivex.io/learnrx/ 
Hyperscript and JSX are dialects of the same principles. I shouldn't have made it about JSX, i actually meant functional UI. I've seen simple HS examples that were downright beautiful, but i can't get over nesting and needy commas, to me it looks noisy for some reason, like callback hell.
Exactly. I was just wondering if the for loop would be the best tool in the examples I described. So far it seems like it might be, but I just wanted to get additional input.
You can simplify that last snippet by destructuring in the function definition function createWidget({ title, subtitle, description }) { // do something }; 
Very helpful, thanks! I'll check out the tutorial
hyperscript with css-selector shorthands, spread syntax and *optional* attrs is nearly as clean as html [1] and doesnt incur significant overhead vs explicit children. but i agree that the overly explicit hyperscript variants with fixed signatures can be annoying to work with. [1] https://github.com/leeoniya/domvm/blob/2.x-dev/demos/bench/dbmonster/app.js#L20-L41
Thanks, is that a performance boost compared to [].slice.call ?
Added two gists to the topic=)
Thanks will have a read=)
[Google has one as well.](https://google.github.io/styleguide/javascriptguide.xml)
Slightly, and it looks better too. basic performance test: https://jsfiddle.net/e3s3p9bg/ (see console for output)
Because you asked for feedback: one more thing that kind of bugs me (but I know is subjective) are the abbreviations. I assume you use some kind of text editor or IDE that has code completion? What is the point of using 'btns', 'el' and 'lBox' when with code completion it's just as easy to write, but it takes more mental overhead to read it. 
While I respect Kyle Simpson a lot, I have to say I disagree with some of his opinions on ES6. I joined a workshop he gave a while back and we had some interesting discussions about ES6 stuff (for example he dislikes using the `const` statement). While generally an awesome guide for learning JS, his opinion is just that: one expert's opinion. That doesn't mean everything he says is true or correct. Anyway, thanks for providing the argumentation to your statement, I'll have to read it thoroughly and play around with it before I can say whether I actually agree :)
Well, dont know why really :) i guess not doing it gives better readabiliity.
I think the reason is similar to why we can't create an instance of primitive objects such as `Number`, `String`, etc. e.g. this won't work var numObj = new Number(123); Object.create(numObj);
I'll be the dissenting voice here and say that 99% of the time map, filter, and reduce will get you where you need, and your code will be more readable, more declarative, and more maintainable. `someArray.reverse().map((x) =&gt; /* ... */)` is extremely clear, and I can I see what's going on almost instantly. Where in a for loop var newArr = []; for (var i = arr.length - 1; i &gt;= 0; i--) { // ... create some value from what's in the array newArr.push(someVal); } ... I have to read several disparate bits and then synthesize them before I can understand how the loop is iterating, and then I have to read a lot more code to understand what it's even trying to accomplish. With map/filter, it's much easier to understand what you'll end up with, because you know you're getting an array at the end. You can do anything with a for loop, and that's precisely the problem. More power is usually a bad thing. With loops, not only can I make a lot of easy mistakes (off by one errors), but there's just a lot of noise and mutable state here. And if you're mutating the array, you should really look into immutable data. I'd also be curious when these use-cases have come up for you. If they are for toy-problems or interview questions, then sure, a for loop might make more sense, but outside of that, I have a hard time imagining why you'd want to only operate on certain array elements based on the index. Reverse makes, sense, but again, that's so easy to do via chaining calls. And it's semantic! Another benefit is that it frees up your brain to think about the problem you're really trying to solve, not writing a bunch of setup code and trying to juggle more than what's needed in your head. I have not written a single for loop in production code, and I don't anticipate ever having the need to. When I have a list of data, I need to operate on that entire list. If I only need certain elements from it, I filter it based on what that data is, not its position in the list. And if map/filter don't get me there, reduce is the swiss-army knife of utility functions. And if I need something else, lodash or ramda. edit: fixed my code block, forgot a word.
At first glance at your code, it looks like you're assigning `valueOf` to the wrong function. `bind()` creates a new function with the new binding. You're adding `valueOf` to the original `addNums` and not the bound version you're returning.
All those libs and frameworks are really good enough performance wise for the vast majority of real world projects. What really matters at this point is developer performance and code maintainability. Like you said, nobody is stupid enough to render thousands of UI elements. Not in JS, Obj-C, Java, C#, or even C++. It would be a UX nightmare, performance at this point is secondary.
&gt; putting all your parameters into one config or options argument doesn't solve anything by itself I wouldn't say it solves nothing by itself. It makes it so consumers don't need to remember the order of the arguments anymore.
I think the important thing here is what are the changes in semantics. If I have to manually add an optimization attribute to a vnode in order to get a benefit, that implies to me that this optimization will break under some circumstances that are not immediately obvious due to the simplicity of the benchmark. I suppose if you're using perf as marketing gimmick, it's kinda understandable that you would want to use every trick in the book to make your own lib look as good as possible, but then we're benchmarking who can sweet talk better, rather than making a fair apples-to-apples comparison, and I feel that's going against the spirit of the benchmark. Otherwise, what's stopping someone from dumping the vanilla implementation into a React component and saying "it's not idiomatic or average code, but look how fast the React benchmark can be!"
Correct. I often use normal parentheses instead to get rid of the return statement. Find it cleaner. const myIndex = (x) =&gt; ( input.indexOf(x); )
[Not sure why you are being downvoted.](https://github.com/facebook/react/issues/7293)
But it does nothing for the fact that you have a function which takes a dozen arguments. You've just hidden them in a bag, but they're still a dozen. It solves nothing _in that regard_. And, I mean, the problem of argument order is a secondary problem here. "functions shouldn't take more than 2-3 arguments" is not in the main about argument order. The problem with it, is that it reflects a poor and weak interface that receives a number of _frequently_ unrelated things. It's also an _indicator_, a sign that your function is doing too many things. Putting things in a bag doesn't deal with the main problem at all. Does it make the secondary problem better? Yes, maybe, depends, for some people it does. But that's not the problem we really want to solve with this "rule".
My personal opinion is that classes are pretty steeped in inheritance. I make every possible attempt to avoid all forms of inheritance except for that which comes with the language natively. I just find inheritance be more code and less clear to read.
for desktop this is true, they are all fast enough. the fact that React has been fast enough [despite how slow it actually is/was] up until now is pretty definitive proof of this. on mobile, though, there is a vast gulf between the fast ones and the slow ones. even React's trivial tic-tac-toe demo suffers from performance issues and a rewrite using a "fast" lib is *much* better but still not fast enough to not have to worry about perf: https://www.reddit.com/r/javascript/comments/5m70ex/reacts_tictactoe_demo_using_domvm/ anything more complicated than this [and most things are] is already performance-bound.
As unpopular as it may be to be critical of YDKJS, I think Kyle's opinions and writings about "class" is based on bad information and bias. Bad information because Kyle used Java as the gold standard for what is or isn't a class or inheritance, and certainly Java's implementation is very different from JavaScript's, but classes and inheritance in *Python* or *Ruby*, for example, are strikingly similar to JavaScript. In Python and Ruby, classes are themselves memory consuming runtime objects (a building, not a blueprint), and inheritance happens at runtime by delegating to a chain of objects... just like in JavaScript. Kyle thought JavaScript's implementation was unlike any other class implementation, but he was mistaken, and he admitted in another discussion that he wasn't aware of how Python or Ruby worked. And biased because he seems to [deliberately write bad code](https://www.reddit.com/r/javascript/comments/4zl2id/if_behavior_delegation_is_so_awesome_why_did/d6wx7su/) when using classes and deliberately write good code when using not-classes, even though it's equally easy to write good or bad code with or without classes. (These are just two examples among many mistakes in his class-related chapters.) /u/ReGGaeBAWS /u/woobaloobadickduck
X-Post referenced from [/r/machinelearning](http://np.reddit.com/r/machinelearning) by /u/Nimsical [Scalable scraper to fetch data from the web (e.g. all TechCrunch article names in seconds)](http://np.reddit.com/r/MachineLearning/comments/5m7ner/scalable_scraper_to_fetch_data_from_the_web_eg/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Awesome, this is exactly what I wanted to know - if for loops are used in production code. And yes, these cases come up when doing toy practice problems rather than projects. 
I thought that but then it should still be containing a copy of `valueOf` and it appears that is the case as when console.log it does give you the correct answer. It's when you try and coerce the result it defaults to using the Object.prototype.valueOf. I believe it's because the type of the result is a function so it's trying to coerce a function to a number or string and you get the expected result. It's just unusual I thought that no processing of the result allows you to get the correct value.
I don't think that matters in production – but fixed it anyway!
They didn't have to implement it async (in fact, it was a bit more work to do so). They *chose* to implement it async so that things like batching or rendering in another thread are possible.
what your logging is `part`, the result of calling `partial`, not `partial` itself, which is what you expect to have the `valueOf`. `valueOf` is not carried over after a call to `bind()`. function addNums(){} addNums.valueOf = () =&gt; 3; addNums.valueOf(); //-&gt; 3 addNums.bind(null).valueOf(); //-&gt; function ... If you want what's coming out of the initial call to `addNums` to have a customg `valueOf`, you'll need to add that after the call to `bind`.
Sure, it's not the main problem, but in situations where you're convinced you need that many parameters, putting them into objects is usually the best solution. There are many well-written modules that *have to* allow a dozen optional parameters (e.g. [express.static](http://expressjs.com/en/4x/api.html#express.static)), and stuffing them into an object is the go-to approach.
&gt; for example he dislikes using the const statement Why? I really like it, can't think of any disadvantages of using it.
&gt; and stuffing them into an object is the go-to approach My point is not that it's not. My point is about the difference from "putting _everything_ into _one_ object" and "creating meaningful object_s_ to put the various things into". Sometimes, yes, it _may_ be just one object, but putting it all into one object by default is not a solution to the problem exposed.
 const string = `ThisIsAGreatText`; const regex = /[A-Z]+?[a-z]*/g; const parse = string .match(regex) .join(` `);
If you want to dynamically load and execute a Javascript module, and receive a promise for that module's exports, then the upcoming version of Javascript, ES2017, has a stage 3 proposal for that exact thing: https://github.com/tc39/proposal-dynamic-import
What is the community of InfernoJS like? My team bet on Aurelia about 10 months ago, and as far as the framework goes, it's excellent in every way, but the community and adoption is not as high as something like Vue or Angular. I remember being impressed a while back seeing some nice charts that showed Inferno's performance, but I know very little about the framework as a whole. What are some Pros/Cons for choosing Inferno over say React or Angular 2 as a potential framework to use in the future?
Can't really comment on #1 - I didn't make it / name it :P As for #2, the examples you gave are all very competent and strong libraries for scraping the web. But you'd have to build your own server infrastructure and handle increasing / decreasing resources. With stdlib - you can scale up scraping millions of pages pretty easily. That's why it's cool :)
A factor in JS takes some input and wraps the input (and whatever else) in a closure. When it's done, it spits out an object that the user can interact with. React components spit out component instances (which have their own state). These instances in turn spit out objects. The author is half correct in their answer. Their statement is false for stateful components because there is an intermediate layer that holds additional information. They are mostly correct about stateless components, but I'd note that stateless components are actually function objects with their own state/properties rather than primitive functions.
Just don't use it to declare a loop counter. ;-)
I think Inferno's gamble is that by offering full (or 99.5%) React compatibility, they don't need their own community since all things React should "just work"* The project itself is quite active, so presumably bugs will get squashed quickly. The project's lead recently joined the React team at Facebook, so it's up to maintainers to keep it alive until React itself catches up in perf (which may be in a year or two, given the circumstances)
Ooh, didn't even know the configurable part. Good to know, thanks
Can't you use `Array.from()` for DOM arrays instead of a spread operator? Personally the spread is less obvious as to what it's doing in that context. 
&gt; in that you can't run arbitrary J's in them You can. It just isn't able to return a component because templates are neither functions nor components. {{ message.split('').reverse().join('') }} As for logic expressed in the template (v-if, ng-repeat, is dom-repeat, etc), it isn't JS, but that isn't exactly a benefit. The reason they do it like this is because there wasn't another way, so they had to invent a weak code abstraction and pad the rest with computed props. &gt; Also: template is a function of inputs to DOM It's just a string that gets parsed. The string you pass into the parser can't be invoked, it can't even be used for composition which is why you prep other components with local registration or register in a global singleton. At no time do you have a function in the common sense. This is a functional component expressed in JSX: const Header = ({ name }) =&gt; &lt;h1&gt;{name}&lt;/h1&gt;; And it can be used as such without further ado: &lt;Header name="hello" /&gt; 
what exactly were you looking for?
Inferno has a really active community, we've got most of React support APIs supported via the inferno-compat library however we're an independent library to React and aren't just planning to wait until React 'catches up'.
No. I was completely unclear when I mentioned native. When I want to use AJAX I have to do something like `var xhr = new XMLHttpRequest()`. I cannot avoid `new` in that case as the language won't let me. If I want to use the feature I must surrender to poly-instantiation, which is the crux of inheritance. I have a list of these such features in my JavaScript parser: https://github.com/prettydiff/prettydiff/blob/master/lib/jspretty.js#L4150 On the other side of the coin native methods are available only because they ride on a type's prototype. Examples are `[].push`, which is really `Array(whatever).prototype.push`. Fine, yes, I will surrender to inheritance in these cases too. Just because `new`, `this`, `Object.create`, `.apply`, `.bind`, and `.call` are in the language doesn't mean I have to use this madness, and so I choose not to. Actually, choice and avoid are the wrong words. I fight them like they are rabid wolves ripping apart my livestock and spreading ebola. Killing them isn't enough. They have to be burned in the controlled fire for a very hot furnace.
When you start reading in each pixel for data, have it check the rgb value and check for a specific color. 
Thanks that is great feedback. Regarding the nodeList. Isn't that a requirement for it to work in Safari/Firefox?
May be a stupid question, but what is an invariant?=) 
Thats the thing, Each pixel has very random data in it. I've read each individual and tried matching and there is never a match. Edit: in addition, each time the image is generated the colors are random, so i have to figure out the color of the dot in order to count.
Very good points, especially about stateful React components having an intermediate step. I hadn't considered that. Ignoring the intermediate step, could it be said that the component instances are actually the spat out object you would normally get from a factory function? This was my initial line of thought.
I understand what you are trying to do now. Each of your dots fade, so it's going to be a little tricky. I would suggest rolling a blunt and smoking it before proceeding.
Are there always only two colors in the images? Are the ones you want to count always the lighter ones?
Further down, he states to use `struct` when `class` wouldn't apply due to his ideal `class` use case. In JavaScript, it just so happens that `class`, `prototype`, and object members tend to behave the same, or have the same capabilities, while there is no `struct`, per se. This means that, to maintain encapsulation in JavaScript, you end up creating a `class`-like structure regardless. IMO, that means either always use `class` or always use `prototype` when you need `class`-like behavior, and plain objects for `structs`. The "problem" is that even plain-old objects behave like classes, so you're sort of stuck with everything being a class anyway (not that this is a bad thing).
So why don't you check the color values and have two counters? Then check which one's smaller and you have it.
This makes total sense. It's what I initially thought. I have it here: https://jsfiddle.net/v0c353u1/5/ But what I don't understand is that `part` is a result of calling `addSums` twice and so what I console.log(part) you would expect to get a function logged. And indeed you do if you remove addNums.valueOf = function() { return parseInt(val); } This is what is confusing me. If I run `console.log(part.valueOf);` I get the function function() { return parseInt(val); } So I expect `console.log(part + 6);` to work. I understand what you're saying but I can't reconcile the two with what I'm seeing. I may still be missing something though. I really appreciate your answers too. 
what's the long term plan for Inferno? is it gonna be an incubator for React ideas? is it gonna maintain React compat indefinitely? what happens when React catches up in perf?
&gt; should always be two colors. vs &gt; its not just 2 colors in the image Which one is it? If it's always the brighter ones, that might help: http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color 
I tried this to no avail...not sure what I'm doing wrong. function drawDate(ctx, radius) { var now = new Date(); var month = now.getMonth(); var day = now.getDate(); var year = now.getFullYear(); // gets the last 2 digits of the year year = year.toString().substr(2,2); ctx.fillText(month.toString, 300, 200); }
I just thought about this as i was sitting down, Thank you. 
Brilliant, that was what I inferred from your original reply, nice to know I was on the right track. Thank for your comments
He just said it's two colors with fades. So not two colors, technically.
Is the background always a single colour? No shades? Shouldn't need to get into worrying about variations in the dots if the background is consistent, just keep a count of each colour that shows up and the one that shows up most is the background, everything else is dots. 
As a general rule of thumb you should always prioritize for readability over conciseness. 
Just piggybacking off your great response to also mention https://regex101.com as a great regex playground
We have a great little community on Slack if you want to say hello – https://inferno-slack.herokuapp.com/. The core team are usually around to help with ideas/questions/issues and no question is a bad one!
Admittedly it's a jargony term. "Invariant" means "doesn't vary", and the thing that isn't supposed to vary -- the condition that must always be true -- is the rules that make an object valid. Let's say I have a class Month that has one property, a number that represents the month. There are rules the object must follow to be valid: The number must be a whole number from 1 to 12. That rule must not vary, and the object's adherence to that rule must not vary -- it must be invariant. A constructor is said to establish the invariant... which is to say a constructor ensures the month's property is initialized to a whole number from 1 to 12. And each method must maintain the invariant... which is to say, after each method finishes running, the month's property must *still* be a whole number from 1 to 12. Next let's say I have a class Point that has properties x and y. *Any* number is a good x value, and *any* number is a good y value. Since x and y can be any number or combination of numbers, there's no such thing as an invalid Point object, no rules that make a point valid or not, and so there's no invariant. Again, I fully acknowledge it's a jargony term. When we say the purpose of a class is to maintain an invariant, that means the purpose of a class is to keep data valid. If there are no rules that make data valid or not, then there's no reason for a class or methods or private data. https://en.wikipedia.org/wiki/Class_invariant https://en.wikipedia.org/wiki/Invariant_(computer_science)
True. Even in C++, the only difference between a struct and a class is that a struct's members are public by default and a class's members are private by default. So I suppose the JavaScript equivalent of a struct would be a class with no methods and no private properties.
The problem is with your hard-coding of 300,200 You're simply drawing it off-screen. I changed it to ctx.fillText(month.toString(), 5, 25); And it shows up just fine. Here's a fiddle for reference https://jsfiddle.net/DWMiller/g439yuj7/
I see what you mean by part now. Yes, that is a function too, and with your new fiddle, will get the custom valueOf just like partial before it. Are you saying you're not seeing a function? Because part is a function. console.log(part instanceof Function); //-&gt; true Also + 6 should work, and I'm seeing 12 logged. console.log(part + 6); //-&gt; 12 Which seems right, 1 + 2 + 3 + 6 = 12
Cool proof I suppose. But this website could be created without any Javascript. Also Kotlin looks gross :P
I'm not entirely sure, I thought it was mostly the same as an array except missing a few functions. Its not really a big deal to use the array instead I guess.
 if (input &lt; 16){ //add some exit action } else { //whatever happens if input is over 16, your script continues, I guess }
Kotlin is a sight for sore eyes when you're used to Java 6
Sorry, I managed to get it working as expected by creating the valueOf method on the bound function. This is the strange behaviour I can't seem to explain: https://jsfiddle.net/x2zazy80/2/ Hope I've made it clear. I'm really struggling to understand it. 
Ok, I think I see your problem. Its Chrome. Chrome's logging of a function value with a custom valueOf is basically `"function " + valueOf()`. What you're seeing with `console.log(part);` is the output from that behavior, which for me is "function Hello". On Firefox and Safari it logs `function ()` and `function addNums() { [native code] }` respectively. Additionally, if a function is the result of a bind, Chrome seems to use the target function's (the function from which `bind()` was called) representation. This would explain why the logged output of `part` showed "Hello" from `addNums.valueOf()` even though its not used by `part` itself. `part` instead (correctly) inherits and invokes the default `valueOf` method which gives you the function seen when combined with a string in the final `console.log()` call. This behavior makes sense for named functions since Chrome will show the name of the function when logged, e.g. `function foo(){}; console.log(foo); //-&gt; function foo() {}` and when binding, you have no control over the name so Chrome just passes the logged value through to the target function so you can see that you have what is effectively the original function, e.g. `var bar = foo.bind(); console.log(bar); //-&gt; function foo() {}`. But with this whole use of `valueOf` in a bound function, that approach goes to shit because that information is inaccurate and is cause for the confusing results that you're seeing. Edit: That sounds extremely confusing re-reading what I wrote there... Let me know if you need me to clarify ;)
How about: .replace(/(?!^)[\s_]?([A-Z])/g, '-$1').toLowerCase();
Thanks for the detailed reply. I was wondering, what does Inferno offer over Preact in this case then? What does domvm offer over Preact and Inferno? Also the creator of Inferno is joining React. Do you think that means React will get faster? My company are currently experimenting with Inferno and we've had some really positive results – but we have to ask these questions still!
&gt; I was wondering, what does Inferno offer over Preact in this case then Better speed in extreme cases, since they both target the React API/model. You'll run into slightly different compatibility edge cases in both libs. Some parts of React are simply not present in the libs (e.g.: synthetic events), so the ecosystem is not fully plug-and-play. &gt; What does domvm offer over Preact and Inferno? It has some interesting API features [1]. The main one being that you can create disjoint views of the same model, compose them more freely within other views, and refresh them independently (think of it as exposing `this` from within Components). The patterns for organizing your code become more flexible. You can also extend core functionality since the vtree is not hidden away from you. Also, nice syntax for delegated and parameterized handlers. One of my goals was to be able to use domvm as easily as jquery - just include in browser and start writing. It's pure js so debugging is as easy as opening your dev tools, no need to learn or compile a new template syntax. Its API is small and method names short. You can look at 1.x docs [2] (2.x are not written yet, but the main change was moving the templates from JSONML -&gt; hyperscript and a huge perf boost). The core ideas have stayed the same. &gt; Also the creator of Inferno is joining React. Do you think that means React will get faster? I think React will get faster regardless, it is already much faster than before. I don't know what will happen to Inferno once the speed difference is negligible. But since they're aiming for ~100% compatibility, jumping ship should be easy. [1] https://github.com/leeoniya/domvm/tree/2.x-dev/dist [2] https://github.com/leeoniya/domvm/tree/1.x-dev
Nice write-up Leeoniya! I couldn't have said it better myself and I wrote Inferno! Kudos. Plus I'm glad you did away with JSONML, hyperscript is much better and I personally love using it where possible. @expression100: Inferno has synthetic events like React + controlled components like React, unlike Preact. Inferno also offers lifecycle events on functional components and `linkEvent` to provide state/props/context to event handlers without needing to `bind` or use closures/arrow functions to do the same thing.
thanks :) &gt; Plus I'm glad you did away with JSONML, hyperscript is much better and I personally love using it where possible. Yeah, the opportunities for optimizing JSONML templates dried up pretty fast. v2's jsonml addon actually performs much better (with the v2 core) than the baked-in JSONML in v1 [1]. 0 regrets. [1] https://github.com/leeoniya/domvm/issues/101#issuecomment-260141793
Thx I'll try that later after a huge load of sleep. But that would reduce my code drastically, what I was looking for was a supplement to the already existing code to make it work and not a totally short version that I as a beginner with regex don't understand.
To be fair, React is about about 3 or 4 years old. I expect that the Fiber codebase will be more or less on par with other modern frameworks.
A github profile with lots and lots of examples of javascript projects you've done, even if they are just ones you did through lessons, never hurt anyone's job prospects.
i'm not blaming React, just saying that *since* it has been fast enough for a huge crowd, by extension anything faster that it is also fast enough.
I didn't want to bog it down with details, and figured people will just look for 5-10 minutes. I'll copy what I'm saying now there. Basically a message comes in to the server as this object: ``` { type, result } ``` Then I find the function name that matches the "type" property. I'm using shorthand for objects (valid ES6). As of about 5 minutes ago I thought of a more robust way to do this, incase you are sending bad messages: ``` [ func1, func2, func3, funcN ].filter(f =&gt; f.name === data.type).map(r =&gt; r()) ``` The filter will return an empty array [], meaning no function was found. If a function is found, it will return [ Function ], and execute it in .map(). It then sends back the result of the function to the client with the same function name as the type. The client basically does the exact same thing!
Sure one monolithic regex can solve this, but I think you were on the right track to break it up so it's easier for humans to understand it. I first started along the global match then replace strategy as you had, then thought that just stepping through the string letter by letter is actually simpler. How's this? http://jsbin.com/lucubefevu/edit?js,console const regex = { upper : /[A-Z]/, legal : /[a-z\-]/, extra : /\-\-+|\-$/g }; function upper(char, slugged) { if(!regex.upper.test(char)) { return; } if(slugged.length) { slugged.push("-"); } slugged.push(char.toLowerCase()); } function delimiters(char, slugged) { if([ " ", "_" ].indexOf(char) === -1 || !slugged.length) { return; } slugged.push("-"); } function legal(char, slugged) { if(!regex.legal.test(char)) { return; } slugged.push(char); } function slug(str) { let slugged = []; for(let i = 0; i &lt; str.length; i++) { let char = str.charAt(i); upper(char, slugged); delimiters(char, slugged); legal(char, slugged); } str = slugged.join(""); // remove extra "-" if(str.match(regex.extra)) { str = str.replace(regex.extra, "-"); } return str; } Kinda long, but clear.
It's the `global` flag. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
I've spent the last 2 months tracking the project and the last few weeks reading the docs and source code. I'm really impressed by what you've achieved. I think this project needs more support, so I'm going to list the things that have really impressed me: - You're actively accepting PRs, fixing issues, documenting and helping people on gitter. - The es6 api you've written is super elegant and the source is well written and readable. - You're using modern js features like async await - You're using typescript awesomeness to make the codebase rock solid - You've written a tonne of tests (would be neat if we could get a coverage bot running btw) - You have elegant, strongly typed patterns for event messaging, table inheritance and CRUD. We've choosen to run with your project for a app that we are going to prod with and we couldn't be happier. Thanks for your hard work this has made our project a joy to work on. 
How to make it 'visualize' an arbitrary html file.
&gt;It then sends back the result of the function to the client with the same function name as the type. You'll be sending `[]`, or `[ 0: result1 ]`, or `[ 0: result1, 1: result2 ]`, etc. Note the explicit 0-based indices, rather than the function name which you seem to be saying. I'm also wondering whether it's useful to be sending an array. Since you sem to be using the function's name property as its identifier, shouldn't there always be merely one function running, meaning one result? If so, why send an array?
[removed]
I am returning the results in a callback :) The line you quoted refers to the websocket call. Check out the updated code in the post.
I got around this issue by using a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object. let data = new FormData() data.set('file', file) axios.post('/api', data).then(something)
First you should learn how to do all es6 features in es5. Almost everything in es6 is mostly syntactic sugar. 
Drake don't care. Edit: sorry, that post was taking me to a completely different (Drake Related) URL on mobile. Maybe it also was for the person above me?
The demo is very sluggish for me on FF and Chromium (i3 laptop). I'm just moving the cursor around in the text. There is a bit of debug in the console which probably isn't helping things either. 
Thanks for the hint, apparently there seems to be a problem with the production build as well. Looks like it's using a slower development build. I'll check it out
They're stage-0, but do-expressions are much much cleaner https://babeljs.io/docs/plugins/transform-do-expressions/ const Component = props =&gt; &lt;div className='myComponent'&gt; {do { if(color === 'blue') { &lt;BlueComponent/&gt;; } if(color === 'red') { &lt;RedComponent/&gt;; } if(color === 'green') { &lt;GreenComponent/&gt;; } }} &lt;/div&gt;
This looks great. Thank you.
Indeed, the npm package used a development build which makes things significantly slower. It's updated now, can you try again? :)
Oh dear...
Yeah, I agree. It's super confusing at first, but once it runs, it's gravy. Just gotta keep playing with it like anything else. Takes time and patience.
Tried webpack-blocks? 
I'll add another option to the mix: Iterators and generators. This gets you all the flexibility of raw loops, all the semantics of filter and map, but without the cost of copying the array just to iterate over it. function reverseIterator(anyArray) { // Return an iterable return { [Symbol.iterator]() { let nextIndex = anyArray.length - 1; const endIndex = -1; // Return an iterator return { next: function() { const item = ( nextIndex !== endIndex ? {value: anyArray[nextIndex], done: false} : {done: true} ); nextIndex--; return item; } }; } }; } And to use it... var a = [1, 2, 3]; for (const value of reverseIterator(a)) { console.log(value) } // &gt; 3, 2, 1 Alternatively, we can simplify this with generator functions. function* reverseIterator(anyArray) { for (let i = anyArray.length - 1; i !== -1; --i) { yield anyArray[i]; } } And we still get to use it in the same way... var a = [1, 2, 3]; for (const value of reverseIterator(a)) { console.log(value) } // &gt; 3, 2, 1 All the flexibility of raw loops because, under the hood, it *is* a raw loop. But still semantic because at the point of use, all we see is `reverseIterator(a)`. And also cheap because there's no copying of the array.
To me it doesn't look cleaner at all. By making the conditionals look like any other component, they become harder to spot. It's also more work to read like this than a simple ternary operator. Imagine if in regular JS the if-statements would be syntactically the same as any function call. I wouldn't call that a win...
Thank you for the data! We currently use slatejs.org for text editing which is having some performance issues that are currently being investigated. Nevertheless we'll focus on improving the performance in the next releases by stripping away dependencies (like material-ui) and replacing a few of them with our own, optimized things. When it comes to text editing, slate is only our default choice, it's still possible to replace slate with e.g. tinymce or ckeditor. :)
A couple of ideas: * Use a ['throw'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw) without a 'catch' block. Execution stops. * Maybe the user accidentally entered a useless answer once. Ask one more time ... THEN throw 'em out. 
yes! everyone do this, please. JSX is not a template language, but just a special form of ECMAScript and we should use ES-constructs, not overload components with logic which doesn't belong there.
What do you mean by ignoring "university degrees" postings? 
"library".
I haven't previously seen Trailer, but it looks interesting. It definitely packs a lot of information which is nice, but I can't seem to find if Trailer has none-mac-bar mode? In reality, Trailer currently shows a lot more than Hawk Eye does, but that's okay. Hawk Eye is new, and If you find yourself wanting a feature, file an Issue or better yet, a PR! :) 
@TextOnScreen I've created a gist for you with some working example code: [Hide and show fields based on radio button value](https://gist.github.com/azforeversupporter/32683f243bbabc0decb3feefc9ef8d70) You should watch for the change event on any of the radio buttons and then check the value of the selected radio. Based on the retrieved value, you'll be able to show and hide the fields you want.
So I've been in your position or at least a similar one. I had a project which was written in typescript, and I wanted it to be compiled into another directory, having ALL the assets copied over. Essentially a src/ folder compiled into a dist/ folder. Note that this is a hobby project that is still underway so I haven't been working on it, but I got the main workflow solved. It could be improved by TONS. **Use this as a starting point and fine-tune to your needs** Here's how I solved it: - Use webpack for JS assets - Use npm scripts for everything else (such as copying assets over). I've found it is best to use webpack for very specific things (such as bundling) and letting NPM scripts handle the rest. You can use bash commands (assuming a linux environment for example) which are future-proof (at least more than most other NPM packages). Not to mention, less dependencies required for the build process. I'll copy-paste my project structure along with the npm scripts section from package.json and my webpack.config.js file ### project structure (ignored some irrelevant directories): |── build │ ├── about │ ├── admin │ ├── api │ ├── blog │ ├── cfg │ ├── core │ ├── helpers.ts │ ├── home │ └── server.ts ├── dist │ ├── about │ ├── admin │ ├── api │ ├── blog │ ├── cfg │ ├── core │ ├── helpers.js │ ├── home │ ├── server │ └── server.js ├── package.json ├── tsconfig.json └── webpack.config.js ### package.json scripts section (focus on the build command) "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "cfg": "cd ./build &amp;&amp; cp -R --parents cfg ../dist/ &amp;&amp; cd ../", "assets": "cd ./build &amp;&amp; cp -R --parents core/assets/ ../dist/ &amp;&amp; cd ../", "lib": "cd ./build &amp;&amp; cp -R --parents core/lib/ ../dist/ &amp;&amp; cd ../", "views": "cd ./build; find . -name '*.pug' | cpio -pdm ../dist &amp;&amp; cd ../", "sass": "sass -I ./build/core/styles -t expanded --update build:dist", "js": "cd ./build; find . -name '*.js' | cpio -pdm ../dist &amp;&amp; cd ../", "ts": "tsc", "build": "rm -rf ./dist &amp;&amp; mkdir dist/ dist/core dist/cfg &amp;&amp; npm run cfg &amp;&amp; npm run assets &amp;&amp; npm run views &amp;&amp; npm run sass &amp;&amp; npm run ts &amp;&amp; npm run js &amp;&amp; webpack", "start": "node ./dist/server.js" } ### webpack.config.js You'll want to modify it so that one of the config objects compiles your app.js and the other your vendor.js. module.exports = [ { entry: "./dist/home/client/home.js", output: { filename: "home.js", path: __dirname + "/dist/home/client/" }, resolve: { root: "./dist/" } }, { entry: "./dist/admin/client/admin_app.js" , output: { filename: "admin.js", path: __dirname + "/dist/admin/client/" }, resolve: { root: "./dist/" } } ]; 
&gt; I actually don't understand why webpack configurations are so hard for so many people. The documentation is pretty good, most of the concepts there are self explanatory and the others are easy to find on the web. I think it's mostly because people start by copying a complex and opinionated config and go from there, rather than setting something up themselves using the documentation...
People need someone's library to do this?
I don't have any specific recommendations, but if I were you, I would just use some library that provides good browser compatibility and possibly a nice API.
Cool!
&gt; Bad: &gt; var yyyymmdstr = moment().format('YYYY/MM/DD'); &gt; Good: &gt; var yearMonthDay = moment().format('YYYY/MM/DD'); I'll pass.
Using the web standard (implemented in chrome and firefox) and polyfills for old browser seems like a viable alternative. I found this polyfill: https://github.com/inexorabletash/polyfill/blob/master/keyboard.md Trying it out now.
I expected to drop the same tip and resolve this question but if you check out the stackoverflow link he's already using FormData. The problem he's running into is that the server expects content-type application/json and it's being sent as multipart form-data (?). My first thought here is that axios _should_ be sending the request as content-type json - I'm using this same approach and the server receives it as json. Wish I could be more help.
She goes into it in depth in https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction. Couldn't agree more.
No other configuration other than setting up an authorization token. This SO post seems to be in line with what you're trying to accomplish, hope it's somewhat helpful and not another trail down the rabbit hole: http://stackoverflow.com/questions/24535189/composing-multipart-form-data-with-a-different-content-type-on-each-parts-with-j
Looking good. Some things I noticed. Since you're already using jQuery as a dependency you can simplify some stuff like your reset function and don't need to create new jQuery objects every interval. // reset function for...of is a pretty new function that doesn't work in older IEs. If you need to support them, you could use a foreach loop instead. // prevSlide var prev gets hoisted and it isn't block scoped so you could also define the default state in the beginning of the function and have only one condition. var prev = slideDivs[(count - 1)]; if(count === 0){ prev = slideDivs[showLength]; } $(prev).addClass('prev'); Same goes for nextSlide() Additionally I would put reset(); prevSlide(); currentSlide(); nextSlide(); into one function that you call when initialising the carousel, clicking left, clicking right and when calling isetInterval; You can combine your setInterval declaration and function: var interval = window.setInterval(function() { if(count == showLength){ count = 0; } else { count+=1 }; reset(); prevSlide(); currentSlide(); nextSlide(); }, 2500); Cheers
Hey I have a couple of quick pointers: 1) Use `===` always. Most of the time if `==` works and `===` doesn't then your code is probably doing something misleading. 2) Your click handlers and your `autoScroll` function are pretty much the same. You could abstract the logic into a generic function. The same could apply for your `prevSlide` and `nextSlide` functions. 3) You may have intended this but reconsider the images being loaded as background images. From an accessibility perspective, they can't have `alt` attributes which explain their content. If you consider the images to be your primary content they should be in `&lt;img&gt;` tags. If they are not essential they are fine as background images. 4) Consider making a `main` or `init` or `setup` function. When this function is called it will set up your event listeners and do whatever else is necessary to kick things off. This is good because it marks a clear entry point into your program. 5) Reconsider using jQuery. Using jQuery can be very useful and it can take the pain out of various things but, it seems that you are only using it for adding or removing classes. It's important to always weigh up whether or not it is worth loading a library to achieve your goals. For class manipulation, you can use the [native methods](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList) which even IE has some support for. 6) Your code isn't properly indented. This is a bit nitpicky but if you want other people to read your code it's good to make sure that everything is formatted properly so it's easy to follow. Some good books I'd recommend are Javascript: The Good Parts and Clean Code. The Javascript book is a little old at this stage but it contains a lot of good advice about what to do and what not to do in Javascript. The Clean Code book is a staple in the software world and a lot of its advice is in bits and pieces on the web but it's nice to have it all in one place. Hopefully, some of that is useful to you. This got a bit longer than I intended but if you have any questions let me know.
&gt; If you think you are being clever you are probably not.
**Here's a sneak peek of /r/jquery using the [top posts](https://np.reddit.com/r/jquery/top/?sort=top&amp;t=all) of all time!** \#1: [9 Development Practices That Helped Me Write More Manageable and Efficient Javascript and jQuery](http://joeydehnert.com/2014/04/06/9-development-practices-that-helped-me-write-more-manageable-and-efficient-javascript-and-jquery/) | [comments](https://np.reddit.com/r/jquery/comments/22g01i/9_development_practices_that_helped_me_write_more/) \#2: [Dropzone.js](http://www.dropzonejs.com/) | [comments](https://np.reddit.com/r/jquery/comments/1xotvu/dropzonejs/) \#3: [Hi, everybody. We recently launched /r/LearnJavaScript, and it's turning into a pretty good community. We'd love it if you stopped by!](https://www.reddit.com/r/jquery/comments/1cms05/hi_everybody_we_recently_launched/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot)
1) so, target has to be targeted both on PC and Mobile device. 2) he has to enable Javascript on Tor. I doubt it works outside or theory
Why are you linking to slashdot and not the article itself? https://www.bleepingcomputer.com/news/security/ultrasound-tracking-could-be-used-to-deanonymize-tor-users/
the article itself actually says "could be used" and is presenting the theory. OP decided to sensationalise.
A few quick thoughts: - You could use the config from [Create-React-App](https://github.com/facebookincubator/create-react-app) as a good starting point - My list of [React/Redux links](https://github.com/markerikson/react-redux-links) has categories for [Webpack tutorials](https://github.com/markerikson/react-redux-links/blob/master/webpack-tutorials.md) and [Webpack advanced techniques](https://github.com/markerikson/react-redux-links/blob/master/webpack-advanced-techniques.md). The info in there may be helpful, especially in regards to setting up a vendor chunk. - I personally suggest that you skip using React-Hot-Loader, and just use the "plain" HMR API to reload your component tree from the root. This does work best if you are using Redux, as that allows you to keep your data outside the component tree and maintain app state when the components are reloaded. My blog post [Practical Redux Part 3: Project Setup](http://blog.isquaredsoftware.com/2016/11/practical-redux-part-3-project-planning-and-setup/) gives an example of configuring "plain" HMR, and there's a couple other examples of configuring that in the "Webpack Advanced Techniques" links list category. - The [Webpack-Blocks](https://github.com/andywer/webpack-blocks) library seems to be a nice abstraction layer for constructing a Webpack config. Might want to look at that. - There's several utils you can use to [analyze bundle contents](https://github.com/markerikson/react-redux-links/blob/master/webpack-advanced-techniques.md#webpack-tools) , even after minification. Finally, I'd suggest that you start simple, and work your way up from there. First, just get your app loading, and the file copying working. Then, add a vendor chunk. _Then_ worry about hot reloading.
It is evaluated from left to right so `"08:00" &lt; "12:00" &lt; "16:00"` is equivalent to: a = "08:00" &lt; "12:00" // true b = a &lt; "16:00" // false // true is not less than "16:00"
Ive done this plenty of times. Usually its a much better idea to have a handful of promise helpers such as "do this and return the value" or "log and then throw"
Fair point. :)
Fair enough! I withdraw my snarky comment. Thanks for adding constructive feedback.
I don't believe this was ever suggested to be used in production code; it's a debugging technique, useful to quickly see what's being passed through a promise chain, and immediately removed once you've solved the issue. That's how I use a similar technique, at least. EDIT: re-reading the OP, it doesn't say what the context is. So I'm assuming it's a debugging trick, but maybe not. If not, I'm 100% on your side.
Im reading [testable javascript](http://shop.oreilly.com/product/0636920024699.do) and [Learning JavaScript Data Structures and Algorithms - Second Edition](https://www.amazon.com/Learning-JavaScript-Data-Structures-Algorithms/dp/1785285491/ref=pd_sbs_14_t_0?_encoding=UTF8&amp;psc=1&amp;refRID=KW1CPGSM9GAJXCY9YJGW) Eloquent Javascript is great and I like what Eric Elliot writes in [Javascript Scene] (https://medium.com/javascript-scene), heres a [book list](https://medium.com/javascript-scene/the-software-developer-s-library-a-treasure-trove-of-books-for-people-who-love-code-f9bc92c7883b#.44p9a8ndr) 
Why? Just console log from the response.
An interview? Got a link? Either way, thx!
I'll have to unplug my dolphin.
I think the documentation is a good attempt, but ultimately is not very usable. from [configuration](https://webpack.js.org/configuration/) { // click on the name of the option to get to the detailed documentation // click on the items with arrows to show more examples / advanced options entry: "./app/entry", // string | object | array // Here the application starts executing // and webpack starts bundling output: { // options related how webpack emits results path: path.resolve(__dirname, "dist"), // string // the target directory for all output files // must be an absolute path (use the Node.js path module) filename: "bundle.js", // string // the filename template for entry chunks publicPath: "/assets/", // string // the url to the output directory resolved relative to the HTML page .... } entry is at least mostly understandable. It isn't clear how the array syntax works, and the reader is to assume the object syntax is also naming the bundles of different entry points. That is easy to test with a little experimentation, pass. publicPath itself is not a difficult concept, but we're not even off the first view of the documentation and they've mentioned HTML without ever talking about how webpack deals with that. In the explanation of the module config there is a mysterious issuer parameter that notes test, include, exclude. It is not clear what it does, and the documentation does not really explain it. I'll assume it is just a way to disable/enable aspects of the loader. I've happily ignored resolvers up until now and should be able to do so still. Loaders I understand - they are basically pipes to push different filetypes or paths through and have their own internal behavior. Plugins I also understand. The only issue I have with loaders is that I do not know how to handle index.html with code splitting. The simple approach I have been using is to use file-loader to copy it out of the source folder and into the distribution folder. However, there are no options to modify the file, so I have hardcoded the URL I previously expected the application to find app.js in in the html file. An alternative is [html-loader](https://github.com/webpack/html-loader) which will embed .html files in the javascript as strings (???) and they suggest using 3(!) loaders chained together to copy an HTML file and change a src string inside it. This seems like madness. I had the basics working on v1, but upgrading to v2 and implementing a vendor bundle has broken all that. If I don't try to make a vendor bundle everything works as expected. The [code splitting](https://webpack.js.org/guides/code-splitting-libraries/) doc is broken pretty much out of the gate, as webpack throws an error at [chunkhash], and recommends [hash], but whatever. The doc sets up: entry: { main: './index.js', vendor: 'moment' }, output: { filename: '[chunkhash].[name].js', path: './dist' }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ names: ['vendor', 'manifest'] // Specify the common bundle's name. }) ] } and I use: context: path.join(__dirname, '/app'), entry: { app: './webpack-hook.js', vendor: [ 'react', 'react-dom', 'react-redux', 'redux', 'redux-thunk', 'isomorphic-fetch', 'material-ui', 'react-tap-event-plugin', ], }, output: { publicPath: '/', path: path.join(__dirname, '/dist/'), filename: 'js/[hash].[name].js', }, plugins: [ // Enables Hot Modules Replacement new webpack.HotModuleReplacementPlugin(), new webpack.optimize.CommonsChunkPlugin({ names: ['vendor', 'manifest'], }), ], webpack-hook.js is a file that only has require statements, require('./html/index.html'); require('./images/logoloader.js'); require('./react/client.js'); and logoloader.js just require()s images for file-loader. That has always worked at least at a base level. I can't see what is so different about my config compared to theirs, but deduplication (commonsChunk) does not work, and now index.html does not point to the right .js files.
I don't maintain the entire app state in a global store - several components (e.g. forms) have internal state. I only use redux for information that needs to be shared between components. You waste a lot of cycles propagating changes through actions, reducers, and all connected components for state that only matters to a single component.
I think you're being too harsh. This isn't obscure at all; the `,` operator is as basic as operators like `-` and `!`, and it exists in pretty much every mainstream algol-derived language. The `,` operator is frequently used in initializing declaration statements and sometimes used in while loop tests to incur side effects. It's really not an uncommon operator. Also, in this case, it's actually the correct operator to use within the expression (rather than `||`). It's similar to using `void` in front of an IIFE instead of a leading `;` (or worse, a `!`) - it's being used unequivocally the way it's meant to. In my opinion, in terms of readability, the common idiom `.then(console.log.bind(console))` is way worse because in that case you need to know about the Javascript-specific `.bind` (in addition to having to know about internals of `console.log`), plus understand higher-order functions and point-free style. You mentioned production code, but to begin with this tip is clearly for development. If you want production-level logging, you really ought to be using a proper logging library, and adding some sort of context around what the logged value is.
CRA is spaghetti code to me. start.js alone is a 300 line configuration/loading of dependencies. It seems to be adding a lot of complexity and making it very difficult to reconfigure if you have an issue. Reloading the component tree from the root isn't a preferred solution to me. I do not maintain the entire GUI state in redux as I think that is solving a problem that doesn't exist. I only place information shared between components in a global store, local state like form inputs lives on components and is propogated to redux on submission. If I pushed everything into redux, I would have hundreds of nodes and would spam the reducers unless I used input throttling. Spam is bad for performance and memory usage, throttling is a lot of extra code or adopting something like RxJs, which is going to add a lot of bundle weight for little gain when I've already solved this problem by mixing local state and global state.
I'll repeat the comments I made on Twitter: I respect that different code style opinions exist, but am against making JSX flow control tags like `&lt;If&gt;` or `&lt;For&gt;`. You've got the full power of Javascript available to you - use it, not pseudo-templates! My own preference is to do all conditional/loop logic _before_ constructing the main JSX return structure. Example: https://gist.github.com/markerikson/47fff93c92286db72b22bab5b02e2da3 I feel that putting ternaries or map statements inline in JSX obscures the logic. Again, personal preference, but I feel my approach maximizes clarity.
It wasn't in the interview, just [a tweet](https://twitter.com/inferno_js/status/813485194535575552) as it turns out. But here's a great interview with Dominic: http://survivejs.com/blog/inferno-interview/
Use axioms Imbrium
Some little shop bought slashdot back from dice, so it's been getting a little better recently. Still don't comment anymore because they still haven't replicated reddit's "new mail" feature. I mean, how fuckin' hard is that? 
I was under the impression that they wanted to do it the other way around. It's much easier to get "play sound" permission from tor users than "record microphone".
What does TOR have to do with it? While de-anonymization on TOR is a larger and more noteworthy threat, I am seriously not chill with advertisers casually farming my mobile information just because I keep my phone near my PC.
Does disabling JS disable `&lt;video&gt;` tags?
Thanks for the post! 🙂 Popper.js author here, feel free to ask me anything. This article is also on HN (https://news.ycombinator.com/item?id=13337861)
Are standard speakers capable of putting out ultrasonic frequencies?
You are right, that is a solution to get to the function's formal parameters list. My point was that you cannot access the standard arguments array-like object of the arrow function. Arrow functions simply don't have one. I will make sure to update the article with your suggestion. Thanks for the feedback!
In which chase you need an app or website with "record audio" permission on the mobile device.
Or just mute them. It's not like a JavaScript program embedded in a webpage can unmute them.
Most are if they are of any quality.
They did the jump because some angular router package was already at v3.3.0 while the rest were at v2.3.0. They wanted to align all package versions.
I updated the article with your solution and added some extra links in the "Resources" section, for people willing to go further and see what others wrote about the topic. Cheers!
Thank you so much!
I believe the way the statement `(foo, bar)` works in JavaScript is unique to JavaScript (incorrect: while I was testing, I learned that you can do this in C as well). For example: * C#6 and lower throw a syntax error. * C#7 will create a Tuple, but you need to import a special Nuget package. * F# also creates a Tuple. * Lua throws a syntax error. * Python also creates a tuple, but you can also use it for "destructuring," of a sort. * It appears that PHP throws a syntax error as well, but it supports other weird use-cases for `,`. * Bash throws a syntax error. ~~I'm not aware of any other languages (excluding to-JavaScript languages) that will evaluate each statement within `(` and `)` that returns the final statement~~. A lot of Algol-derived languages do not exhibit the same behavior with the `(v, v, ...)` syntax. For that reason, I conclude that it's a language-specific feature, and is obtuse often enough that using it is problematic for maintenance, especially if many languages are in-use.
About 10 years ago, I'd agree. These days it's like a fight is breaking out in a retirement home for cantankerous right wingers. Anything new is bad, old things were the best, immigrants are evil, and gays should ~~die~~ not have rights. It's tragic what's happened there. I started reading it in the late 90s, and it used to be filled with wonderfully insightful technical comments. Go back and read some of the comments from back then and you can see it clearly. Such a shame.
I dont think its a wall, I think its simply the wrong link. It literally links to /join, and not some article.
Interesting, I wasn't aware the Chromecast did that, though it's pretty neat if true. I thought it just used WiFi.
It's because they introduced politics. But even in politics you can find some very insightful discussion. I agree there are a lot of trolls, but even if the ratio of good to bad is not what it used to be, it's still high enough to keep me reading.
Damn. You really put into words why I stopped reading / about 4 years ago.
Everything written by /u/rauschma is excellent: http://exploringjs.com/ I also have a number of links to tutorials and explanations of ES6 features at https://github.com/markerikson/react-redux-links/blob/master/es6-features.md . **edit** Whoops. Sorry, misread your request. Thought you said you _were_ looking for "general ES6 features and syntax". My bad. Still recommend the links :)
You're right. Geeze.
Yes, exactly like the first paragraph of the article explicitly states they are jumping from 2 to 4 so that all the packages can be on the same version. But I suppose reading the article before exclaiming "What the fuck" was asking a lot.
Right, but generating that server-side would eliminate the need for JS to be enabled on TOR browser, which seems like a big part of why some people think this is unfeasible. 
It does it for transmitting the pin for guest mode. It sends inaudible tones over the TV speakers that the cast app on your phone picks up and then it can send the pin back to the chromecast to verify. It was a clever way to make it so a guest standing right in front of the TV doesn't have to manually type in the pin without broadcasting it to all devices within wifi distance. It's mentioned here: https://support.google.com/chromecast/answer/6109292?hl=en
I was thinking of lower level languages like C, C++ and D, but now that you mention, yeah some languages did hijack that syntax for tuples, good call.
I don't think semver let's you skip versions like that.
While the article is good, this guy comes off as an extremely arrogant and opinionated person. The tone of his articles make me cringe. 
Given how many JS frameworks there are, it may be easier to look for two books: one for ES6 and another one for your framework of choice.
"Advertisers"
Unless you're a state actor who already has access to all of the above. There are many devices with microphones which feature very poor implementations, wide open, in the same way IP cameras are.
Sure, that's all true. My point stands.
The article says to not get hooked up around the lingo, but the article does get hooked up around the concepts. You don't need pure functions to achieve FP and FP can be extremely imperative. A better way to think about the concept is that there are three common ways to write code structures: mostly functional, mostly object based, or just a list of instructions. That last one is called procedural and most people don't code like that anymore. Procedural programming was necessary when the languages and hardware were more primitive. If your code makes heavy use of functions for structure it is probably FP. This implies heavier reliance upon closures, lexical scope, and methods. The code is imperative when it makes no effort describe flow control. In the world FP programming imperatively typically means the code structure closely resembles the flow control so that the flow control is actually described but not directly and probably not intentionally. FP code is declarative when structure is less important than describing a unit of operation to such an extent that flow control may not be immediately clear, but the intention of the code unit is. Expect declarative code to be more wordy and make heavier use of conventions so that parts of the code read more clearly and achieve familiarity. The biggest problem with imperative FP is that you get really big code structures that can be overwhelming at first while declarative FP can be a pain the ass to follow even if it is easy to determine what the bits are doing. If the code is mostly reliant upon objects for structure than it is probably OOP (object-oriented programming). These types of structures are either explicit (like JSON) or implicit through some kinds of linking mechanisms, such as inheritance. I don't like OOP code so I will leave it at that.
Is there a reason no one here is instead opting to extract these conditionals into component methods? I would argue loops in JSX are just fine. Nothing ugly about them unless you have conditionals in your loops. Honestly, most of the time I find my conditionals are just abstractions that I missed. Not always, but it's a pretty common pattern I've noticed.
uMatrix does, I believe. You can block/allow every kind of request the browser can make on a subdomain basis. 
It looks like you're not the only one ^ there's 86 "other discussions" that seem all to be linking to /join too
When i was a kid we called these tooltips!
Nice! :)
No, we still do.
Honestly with react-redux 5.0, if you still load top-down then you are missing out on major performance benefits (react-redux 5.0 finally has a bug free, highly optimized side-down way of rendering. Just make every component a container unless it's stateless. (Even then, it can be one if it needs to be) We keep the entire UI state in a single reducer called our UI reducer (which is just an object of key:value) and then we have our data reducers which are flattened {ids: [], data: {}} models. There is no lag at all and we don't waste time rendering things that don't need it. You can type as fast as you want on an input, it will only update the single component who cares about it. (It will have to re-render the children but I am fairly sure these are memoized internally) (We store inputs in Redux because API requests need to be able to alter the state of that input in some way. Usually clearing it if successful)
So it's not just reddit then?
Poppers is a slang term given broadly to the chemical class called alkyl nitrites, that are inhaled for recreational purposes, including as club drugs used at dance clubs, and that are sometimes associated with preparation for sexual encounters.[1] Poppers were part of club culture from the 1970s disco scene to the 1980s, and the 1990s rave scene made their use popular.[2] Most widely sold products include the original amyl nitrite (isoamyl nitrite, isopentyl nitrite), but also cyclohexyl nitrite, isobutyl nitrite (2-methylpropyl nitrite), isopropyl nitrite (2-propyl nitrite, increasingly, after EU ban of the isobutyl form), and, more rarely, butyl nitrite; however, to the extent that they remain unregulated or illicitly used products, compositions and the implications of altered formulations on user health can change without notice. https://en.wikipedia.org/wiki/Poppers :-D
[removed]
On the other hand, they had email notifications all along (I think reddit added those last year or so). Still, it seems like the on-site feature would be much easier to implement so wtf?
It's the reason I stopped 10 years ago =/
Thanks for your answer. Any thoughts on how I might extend Set without polluting its global prototype, that let's me still use the object with its original Set functionality? I can use a factory approach and then apply a properties/functions to the Set created within that, but would that be memory inefficient (creates multiple copies of functions etc.)? I'd rather use prototype for efficiency and bulk inheritance if possible.
What seems crappy about it?
But malicious advertisers COULD play audio which hypnotizes you and compels you to enter your identity into a form on their site.
&gt; FP can be extremely imperative I can't wrap my head around that statement. Do you have an example?
I agree. Starting with something simple and go from there makes you actually understand what you're doing with webpack and helps you understand it all. In mho. 
Well you're right on some of things you state about documentation. They could actually improve it a bit. Although I think that you can still understand at least the purpose. Regarding file loaded and urls and versioning your CSS and js (for example) I created a plugin that listens to the done event and then use lodash to set sprites, versions, whatever I need... I also create sprites under a custom plugin with svg-speite.
Reddit is for circlejerking left wingers. Anyone old is bad, new things are the best, immigrants are great, and gay rights are supreme.
I only frequent /r/mapporncirclejerk what does that say about me? :&lt;
guess what? there's even a somewhat famous character called Popper J.S. 😵
tooltip is a particular UI pattern, like popovers are another one. The term "poppers" tries to cover them all.
I would expect so, we use ultrasound in our products at work and we have some cheap monitors where the build in speakers have no trouble playing the ultrasound
Where I work, the really secure computers are airgapped, have neither microphones nor speakers, and are kept in insulated rooms with the monitors facing away from the doors. Among other features. Our security briefing specifically mentioned cell phones and ultrasound as a threat vector, which is one reason that phones are left outside and the PA system can't reach inside those rooms. Security is wild
So basically disable sound output when using TOR and I'm immune from this. Correct? 
Bingo. This would never pass a code review. 
I don't get why he modified `double` to change the input type in his `map` example over composing a higher order function https://medium.com/@atticoos/for-the-sake-of-this-topic-i-feel-like-a-good-example-here-would-be-to-compose-a-higher-order-4d38f5318dc2#.hxfddjegh
This is the exact opposite of how these terms are typically used http://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming
You got it right. A lot of people would say use a framework like angular or something to automatically connect up the dom element with the data source. But that's overkill. You're good. 
Semver doesn't say anything about skipping versions. Ember even once released a minor release with NO changes.
Nope, not a one. 
If you can't find opinions on Reddit that differ from that, you really aren't trying!
I wish Reddit would adopt the system they have there where comments are flagged as funny or insightful or whatever. I'd love to be able to filter out "funny" comments in certain threads on Reddit sometimes. It's almost become a habit to me to just automatically collapse the top comment in a Reddit post.
The best mind control defense is this thin metallic headgear I have for sale on my website. Just $19.99! 
And Martians! Don't forget the Martians!!
I use [kee.js](https://github.com/twhb/kee.js), which I made to address this and similar issues. It uses `which` under the hood. `key` and `code` are apparently abandoned, implementations are buggy or missing and progress has been stopped for years. `keyCode` and `which` will never be removed, too many websites rely on them and they're not a security concern. And between the two, `which` has fewer cross-browser bugs, cross-OS bugs, and "subtleties". (Though it does still have some, see kee.js source code for what was fixed.)
laravel mix will solve those problems. Laravel mix is expected to release this month. So i suggest wait for it if you can.
That is a nice feature, but they're not always accurate :)
[js-data](http://www.js-data.io) maybe? 3.0 is in rc and has been pretty good for us.
the difference for nodeType is surprising, but even on my phone i get 15.6M reads per sec. the GC overhead for vdom alone could easily mask this. attribute diffing is gonna be the bottleneck i think. element.attributes iteration could be as slow as element.childNodes interation, except for attributes there are no faster alternatives like firstChild and nextSibling
C(X)ross Site Sound.
Tether is another great library for attaching DOM nodes with nice screen, scroll, and nested tracking.
To be fair, you shouldn't be accessing that "special" object anyway, it's a clear antipattern in js
Mostly Jamsa's C/C++ Programmer's Bible. Between that and figuring out how to modify CircleMUD source code over a telnet client I was pretty much beyond everything taught at my University undergraduate program.
What is a popular datastructure? A map a list a set? Or are you talking crazy trees like b+ trees and red and black trees?
Firefox might be doing aggressive red-herring - removing what it thinks is dead code, so the bench might be measuring nothing on Firefox.
During AdventofCode there was a challenge where you needed a circular list. On top of that you had to remove many elements from the middle of this list which is very expensive on js arrays. My solution was building such a circular double linked list, with remove and insert functions. 
show me a real world example where this is needed with javascript.
A circular list? Implementing a sliding buffer in CSP. Just because it's uncommon doesn't mean no one will [need it](https://github.com/ubolonton/js-csp/blob/52717fb70f6cfaa6c543a131360eb38eb994783a/src/impl/buffers.js#L10). Asking that question during an interview is stupid, though.
Oh sure i'm not saying it is never needed...I'm just saying you will likely never need it on most dev jobs unless you're doing some crazy ass low-level shit. I usually walk out when I get asked this nonsense, especially as a front-end developer.
I don't know about you, but i'd be suspicious when i see the speaker icon, but i don't hear anything (which is kind of unlikely since anyone with good hearing will hear it, because at 20 khz there is a VERY steep filter, so you'd probably hear something.) The only solution is to make websites request permission to output sound, just like the input. The only problem is that it would annoy most people.
"Instead of using MVC/MVVM style patterns, Inferno uses a component-based approach in which data flows in one direction." I never understand this claim. Sure, your view can be (re)rendered from a single datastore or state. But you still need your view layer to collect user input and respond to UI events. That in turn need to update the store and trigger a re-render. How is this "one" direction? One direction would be if you only use an API to modify the store and your view updates. Nothing about MVVM or MVC prevents you from following the same pattern, right?
Hi /u/tracktech, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `Suresh Srivastava - YouTube`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [youtube.com](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27tracktech%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|11|79%
Inferno is great. I just used it as a drop-in replacement for some animation heavy app. And it got significantly smoother. However, FB just hired the Inferno dev and they are working on the next React gen ('React Fiber'). So, I assume that Inferno won't get many more updates in future. Maybe they even rename Inferno to React Fiber. 
I have a USB-bat.
Good old Eric. 
Thanks, I'll try it out!
 class LinkedList { constructor() { this.list = null; this.last = null; } add(value) { if (!this.list) { this.list = new Node(value); return this.last = this.list; } this.last.next = new Node(value); this.last = this.last.next; } } class Node { constructor(value=null, next=null) { this.value = value; this.next = next; } } let newLinkedList = new LinkedList(); arr.map((value) =&gt; { newLinkedList.add(value); }); console.log(newLinkedList); I did it like this: 1. I created a class called LinkedList which contains all the elements in the list and keeps track of the last one. 2. All the methods of the LinkedList will be added here. 3. Created a Node class to construct each LinkedList Node. 4. Used the map function to add each element of the array to the LinkedList using the method add created inside ethe LinkedList.
I'm front end so I don't really care much what the backend is as long its open source. I'm interviewing for a job that uses vue/rails
This isn't going to be the case. Inferno has a large core team of developers who have been driving this project for quite some time now. I've pretty much done nothing for the last few weeks - the team have been awesome! I'll be working on React, but that doesn't mean Inferno is dead.
&gt; "Who the f--- uses linked lists in javascript?!" Who the fuck uses linked lists for anything? They are terrible for virtually all use cases. Even when you think you're doing a lot of inserts and deletes, the gains are usually crushed by the much slower iteration. https://www.reddit.com/r/programming/comments/25xpre/bjarne_stroustrup_why_you_should_avoid_linked/ Linked lists are a simple data structure. That's what they have going for them. They are a decent learning tool.
We use it for automatic pairing between our apps for smartphones and PCs, and our hardware products. It's part of the Cisco Spark ecosystem. Edit: http://www.crn.com/slide-shows/networking/300083506/12-reasons-why-ciscos-spark-board-is-its-coolest-product-ever.htm/pgno/0/2?itc=hp_slideshow
But is there any indication the Inferno team is evaluating Fiber? From what i have seen it is groundbreaking. Inferno may be a bit faster re-rendering countless of rows, though i haven't seen drastic differences when using babel-react-optimize in React. In practice spotting differences has been even harder. I do use inferno-compat, it's small and sometimes i do not need synthetic events. But just like current React, it has absolutely nothing if it would go against a native app.
Neat, check out project Aon if you don't already know it
Why not use CSS transitions instead? This seems less efficient.
That's a good point. I added mutation to it here https://github.com/austinlyons/evolving-expression-with-mutation, but it mutates after adding an operator. I like your idea of mutating an existing operator or removing one in order to not have such long solutions. I will try it!
Returning to a better ancestor is an interesting optimization idea, I will play with it. Removing the last operator would be akin to reverting back one generation.
It helps a lot if you include some snippets of program code. You'll get help in minutes then.
Yeah, put an example of your code into a jsfiddle https://jsfiddle.net/ ... indicate in your comment what you expect to happen and what actually happens and people will be able to help you
Nice you managed to make this more verbose and slower than the 5 line function in the jquery source that does the same thing.
If you want to use ES5 syntax, you should use prototypes ... A good guide can be found here: http://javascriptissexy.com/javascript-prototype-in-plain-detailed-language/. But I recommend you to use ES6 systax, it's a bit less well supported (in older IEs for example), but you can still use babel to transpile it to ES5 for those browser once your project is ready to get shipped and you want to support all kind of browsers. Recent chrome versions support "real" ES6 classes, so if you are just training yourself, use ES6 classes and run your code in chrome. A good introduction to object oriented javascript can be found on the MDN website: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript ... MDN is a good resource for lots of js stuff. Here is the page about classes which is great too: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes. Another good resource about classes (ES5 / ES6) is this article: https://scotch.io/tutorials/better-javascript-with-es6-pt-ii-a-deep-dive-into-classes. For your question about how to structure your code, "do I need more then one class", "how much properties should it have" and "what should be their name or parameters" ... I would say the best way to learn is just to get started, don't be afraid to do something "wrong" you can for example still decouple functions and put them into different classes afterwards. Don't be afraid to refactor your code after having written some code for a while, the more you advance, the more you will find out abiut how the code is best structured and can still change things by then. I mean you are not building a library that gets shipped to millions of projects and needs to have an API that won't change until the next majo version jump ... yet. If you to aquire some know how about how to write clean js code and know what style other devs use, I recommend checking out these two great resources, first the clean code javascript guide by Ryan McDermott: https://github.com/ryanmcdermott/clean-code-javascript and then the airbnb javascript style guide: https://github.com/airbnb/javascript. Good luck ;) 
The code you linked is either incomplete, or just syntactically incorrect. I think what you shouldn't do is the 'document.getElementById("demo").innerHTML=myFunction();' part. By this you are not only executing the code but afterwards recursively calling it again. If you wanted to write the 'good' or 'error' texts to your demo div, then your function should return a value and write that into the #demo paragraph. Kind of like this snippet: https://jsfiddle.net/xzubnh5o/2/
Read the article, you hit the same problems I did with tether -- they weren't too too bad and I was able to work around them but the way tether decided to solve the problem left a lot to be desired. Definitely going to check this out!
Laravel includes Vue as the default right now which is why job listings tend to be tightly coupled 
Have you looked at [chartsjs](http://www.chartjs.org/)?
Sweet! Thanks for the help, pal! :)
I read through that ES6 article and got excited so I tried my hand : "use strict"; $(document).ready(function(){ const pomodoroApp = new Pomodoro(); pomodoroApp.start(); }); class Pomodoro { constructor(){ this.workLength = 25; this.breakLength = 5; } init(){ this.update($(".work-length"), this.workLength); this.update($(".break-length"), this.breakLength); } start(){ this.init(); } update(element, value){ element.text(value); } } 
If you want to be a programmer, stop debating what to learn and just pick one thing and learn it. Best way to do it is hack up a project for something to scratch an itch or something you feel passionate about. If marketing and talking to people is your thing, you can literally go door to door to small businesses around your area and convince them to let you do their website for a small nominal fee. Now, I'm going to be brutally honest: being a programmer requires a lot of perseverence and a (un?)healthy dose of self-teaching, you're pretty much going to need to learn constantly for the rest of your career (initially languages, then APIs, lots and lots of them), so if picking up the basics of a language is a chore, maybe it's not a good career for you.
I've recently used chartist and it was a breeze https://gionkunz.github.io/chartist-js/index.html
The best way to learn programming is with Python since it's so high level and easy to write. Once you understand the concepts and fundamentals, JS is easy. It's a forgiving language so you can get by pretty easily but to answer your question, Python is not old and is still heavily in use today's modern industry 
This is exactly what I was looking for. Thank you.
&gt; literally the most popuar language According to Crockford, that is. Anyhow, it's fairly safe to say that it's somewhere in the top 5. Personally, I'd go with some language which offers good tooling, because all dumb mistakes are immediately caught and because you can look around more easily. E.g. you can just look which kind of methods and fields are available without leaving the line of code you're currently writing. Suggestions and calltips really help a lot when you're working with some unfamiliar (or large) API. The first language doesn't really seem to matter much, though. As long as you learn other languages later on, you'll be fine.
&gt; I'm not sure how old Python is It's almost 26 years old, first released on 20 February 1991.
By the way, modules and classes are always in strict mode. Secondly, the file-wide version of the strict mode pragma shouldn't be used since it's problematic when you concatenate files. If you want to use it, you should put the pragma at the beginning of each function. So, in this case, you'd put one into your "ready" callback to make everything strict.
Javascript might be good, or maybe not. Luckily I already had a decent amount of programming knowledge when I began JS. The problem with starting to learn it on your own now is that it's changing so fast it can be regarded as the "wild west" of programming. So if just starting JS frustrated you I don't think you'll like it very much.
Also according to the [2016 GitHub developer survey](http://stackoverflow.com/research/developer-survey-2016) 
I think everyone is moving away from Bower for quite awhile now.
PlayCode have fully support mobile devices. You can write code and see result. Please try on your mobile. It's work? Easy to use? Rotate phone to album mode for better experience (full keyboard more useful)
Honestly, it's totally worth learning d3v4 if your use case is anything more than simple charting. The learning curve is steeper than derived libs like nvd3 but you unlock a huge amount of features that are impossible to achieve otherwise. 
Don't get me wrong, I personally think that Vue is absolutely the best UI library, and its ecosystem is catching up quickly. But if you look at the jobs on Upwork, 90% of them are related to Laravel and PHP. That's what people should really consider when they start to invest their time in learning another framework/library. 
API's as in frameworks' API's, right?
Yup, it's looking that way. I want to use a sankey diagram and none of the wrappers seem to cover that case. 
My company still uses Angular 1.x and it works great for us.
I know that it has performance implications but until now that was the only way I knew to create variadic functions. If you know a different way that used to work in ES5, please do share. I'll make sure to update the article.
I think OP means APIs in general, including library APIs, framework APIs, backend APIs that may or may not be RESTful, etc. Every API is unfortunately different. You'll have to learn how to interact with a lot of them.
What u/hey-its-matt said: stdlibs (e.g. Node), libraries (e.g. Dragula, Moment), frameworks (e.g. Angular, Express), SaaS (e.g. Twilio, Stripe, Facebook, GA...), CLI tools (npm, webpack). And that's not counting things like breaking changes in existing APIs, configuration formats, protocols, standards, security, performance, architecture, testing, maintainability, algorithms...
https://github.com/Yomguithereal/baobab has been around for years now, what does freezer offer over baobab?
Until browsers support it, the var arg stuff access it as well. Same with default parameters. so with the current limitations it's actually three correct way to vararg. But you shouldn't write your code to that, let it transpile to it :)
By contrast, Javascript is almost 22 years old. First released in 1995. Also, the latest Stable release of Python is about 2 weeks old, whereas Javascript latest Stable release is 6 months. That being said, age of a continually developed programming language doesn't really mean an awful lot.
those were both the minified sizes, so the ratio would still hold assuming they both gzip similarly (no reason to think they won't)
This is my first npm package. It works on Node and *should* work on the browser if bundled (haven't tested). I had my own random word generator running on a VPS that was accessed via an API for generating words in my other projects. I realized there was no point in spending $5 a month on a VPS just to generate random words when it could easily work as a package. I looked around and none of the other outdated random word generators had the features I needed, so of course I made my own. The database itself I got from somewhere a couple years back when I setup my original random word API. I don't remember if I removed all words less than 3 characters and above 10 characters or if it was that way when I got it. I know I also removed words that contained special characters. As of now, the database contains almost 129,000 words. In the future I'd like to add a few more features: - Support generating random words in other languages. - An optional 'family safe' filter to remove words that some people might reasonably want to avoid. Anyone know how to do this without manually going through ~129K words? - Add 'types' to each word (verb, noun, etc) and then allow generating words by type. This would have to come from some other word database of course. - Optionally allow the user to utilize the Random.org API for true random words in an efficient way. I'll probably wait until their API is out of beta so I can see their final tiers and limitations. If anyone would like to help out on these or other features: https://github.com/Xyfir/rword Also does anyone know why the download stats aren't updating? How long does it usually take?
It sounded like an interesting thing to implement so I went ahead and did it: https://github.com/MatisLepik/react-spotlight [Here's the live demo](https://www.matislepik.com/react-spotlight/) Let me know if you need any functionality added, or make a PR if you want, because I whipped this up pretty quickly =P
Yeah, I have a really hard time believing jQuery would be faster..
Plus jQuery is &gt; 0.5 KB 😂
..and I only call prefixer once in the top of modules, so it doesn't make that much of a difference anyway. It's cached in between animation frames so..
&gt; Freezer is made with React.js in mind... I don't think this really fits your use case if you're not a React guy. :)
[removed]
what do you mean? the placements are relative to the reference element
The download stats should appear at the end of the day.
You may be interested in [Backscatter](https://github.com/tweinfeld/backscatter). It notifies you of changes anywhere in your Backbone model tree.
Ahh I was viewing on mobile. They appear on the wrong side compared to desktop.
Angular 1 or 2? 
I think the "What the fuck" was more like "Holy shit being an Angular developer these days is insane". Huge breaking changes constantly, with radical shifts in direction/focus and design that to me the idea of building anything using "it's just Angular^TM" would be insane. It's like &gt; Hey remember 4 months ago when we said "this is the future, this is how things will be done from here on out". . . . well. . . we changed our minds . . . NO NOW CHECK THIS COOL THING OUT!" It's only 600MB file with 6 new experimental plugins, and new parsers! Glad I don't have to deal with it, and I feel bad for anyone who does. 
The tooling or ecosystem etc changes at a very fast pace, but the language does not -- more importantly the underlying concepts commonly associated with programming are static. One doesn't need to use webpack to learn how to write a loop. 
This does look good, and I agree with much of your article. I guess my main question is, at what point is it worth using distilled? You've reduced it down so much that it seems to be essentially a glorified `.then`. 
I'm all for using the tools that fit the job, and can understand that maintaining an existing Angular 1.x app is where a lot of people are right now (my day job included). But, I can't imagine making the call, today, to start a NEW project in Angular 1. I really can't.
I'd say go this route. I've been using c3 and it hasn't been updated since October, with hundreds of open issues. I'm going to be converting our c3 charts into pure d3.
Well in this context you can use events, ex: https://docs.angularjs.org/api/ngRoute/service/$route#$routeChangeStart Also the way you are doing the login implementation, seems kinda off, you are storing the users and passwords in the js? .. Look into JWT authentication should be simple, google for examples of that.
The bench wasn't so much about DOM access perf but about... when you already have the reference to a DOMNode Object, the time it takes to access one of its native properties vs an added property(non-native) vs the time to access a property from a normal(non-DOM) Object.
[removed]
That's not a bad assessment, and if you want more features out of the box existing libraries offer way more. That being said, my normal testing setup goes something like this: When I set up a project, I want to start writing code immediately. I can set up Distilled in less than a minute. There's no config file, I don't have to make decisions about assertion styles, I just start doing TDD write from the get-go. I don't even need a testing harness, I'll just keep my tests in one file and run it manually with ``node ./filepath``. Fast setup means it's more likely you'll test your code. Eric Elliot (in his typically bombastic manner) has written [similar thoughts](https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4#.4nmli029h) before. Distilled doesn't give you much, but (opinion me) you don't need much to start [writing tests](https://gitlab.com/distilled/distilled/blob/stable/src/tests/distilled/assertions.js). Where I diverge from Eric is that I don't want my tests to stay in that state. For a large project, I do want to have complicated harnesses, and I care about being able to have complicated features. If you use Tape, you don't get the ability to do that stuff. You have to stay in Tape's world with Tape's assertion library and Tape's structure, and so on. Different codebases should be tested in different ways (again, opinion me), and when you start a new project, I don't think you're in a position to know in advance what you'll actually need. You should make those decisions at the point where you have enough information to make them well. Then you add extensions, and I do plan to have extensions as separate modules - just haven't written them yet. That being said, I also want devs to feel comfortable writing their own extensions. I don't want an extraction layer because you know perfectly what you need. So you can use my extensions, or somebody else's extensions, or write your own - and Distilled goes out of its way to make that stuff easy. Once again opinion me, it's not actually all that hard to write a testing harness. Even inexperienced developers could handle doing that. **TL;DR:** Distilled is very fast to set up for small projects, and even with its limited features is good enough for small projects. As your project evolves, you'll either write your own extensions or you'll consume other people's. Either way, you're more likely to get a testing environment that suites your needs if you don't make decisions up front. *edit: shortened for readability*
Why not just use Jupyter with JS add on?
What are you looking to do? Build websites, apps, serverside development, node apps? Javascript is a pretty broad language, so it can be helpful to have projects in mind. It might be helpful you explained more about what you're looking to learn and what strengths/experience you already have. That being said, some of the popular books I typically see get passed around are: * *Secrets of the Javascript Ninja* by John Resig * *You Don't Know JS* by Kyle Simpson * *Javascript: the Good Parts* by Douglas Crockford By far one of the best things you can do though is to start writing code. Javascript is great because you always have a dev environment with you, just open up the console on your web browser. So literally whenever you have a thought like "I wonder what would happen if I..." immediately you should grab a browser and test that thought.
Of the many RxJS examples I've read, it wasn't until this conversation and [referenced blogpost](http://blog.edanschwartz.com/2015/09/18/dead-simple-rxjs-todo-list/) that my "ah Ha!" moment hit for implementing RxJS as a state manager. I always see examples like - the classic jQuery comparison: Rx.Observable .fromEvent($('button'), 'click') .map(event =&gt; parseInt(event.target.innerText)) .subscribe(value =&gt; $('ul').append(`&lt;li&gt;You clicked ${value}&lt;/li&gt;`) It was very hard for me to make the connection of how I could turn this into something much larger and more complex to manage "stores" of state in my application. Then he shows this: // The intent() function takes in raw input from the user // and outputs streams of "intents" // which are more specifically relevant to our application function intent({DOM}) { return { chooseEven: DOM.get('button', 'click'). map(evt =&gt; parseInt(evt.target.innerText)). filter(val =&gt; val % 2 === 0) }; } // The model() function takes the user intents, // and outputs a stream of state objects function model(intents) { // create a stream of state objects // eg. [{ numbers: [2, 4, 4, 2, 4]}...] return intents.chooseEven. scan((state, n) =&gt; ({ numbers: state.numbers.concat(n) }), { numbers: [] }); } // The view() function takes the state stream created by model() // and returns a stream of virtual-dom views function view(state$) { const h = CycleDOM.h; return state$. startWith({ numbers: [] }). map(state =&gt; h('div', [ h('div', [ h('button', ['1']), h('button', ['2']), h('button', ['3']), h('button', ['4']) ]), // render each `state.numbers` as a &lt;li&gt; h('ul', state.numbers.map(n =&gt; h('li', [`You chose ${n}`])) ) ])); } function main({DOM}) { return { DOM: view(model(intent({DOM}))) } } // Bootstrap the application Cycle.run(main, { DOM: CycleDOM.makeDOMDriver('#app') }); And damnitall - it makes **so much more sense**. What a beautiful approach. 
Looks pretty cool, but I'm not sure about the use of "forceUpdate()" in the usage with React section. I don't know if it's a good idea to rely on that function (which is warned against in the docs) for future versions of React.
Hi /u/agentf90, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
So sorry, must have read something incorrectly.
http://www.youtube.com/playlist?list=PLw1xVKFbouelUj3g_56CRAUjGGEU13bPF
Codecademy is good for getting up and running quickly but the jump to real world isn't always smooth and you'll want to compliment with some other resources 
FreeCodeCamp.com The price is right, there's a whole community around it now, and it's probably one of the best free resources around. Don't skip the HTML/CSS stuff either. It'll go super fast if you know it, but it will be a good refresher. Edit: It's all in JavaScript. The later lessons even teach you some Node.js. They piggyback on some other good tutorials too.
I made a game in vanilla JavaScript for school. I can link the github for you if you're interested. 
js is a good way to go, you use it on the front end and there's nodejs for the back end so it saves you from having to learn another language for backend programming. You're right there are a ton of jobs for it now too so just get after it
Well, it depends: If you wish to use a chunked-response individual chunks to deliver different payloads then yes, you need a special library. If, on the other hand, you need to deliver one big payload (say large file), you can simply use Node's response stream. Node always assumes the 2nd usage scenario, and delivers 'data' events whenever a data is available on the stream which roughly correlate to the HTTP-chunks delivered, not fully.
Sorry for that. I didn't plan to publish it, but I figured people will stumble upon my unique use-case of http chunked response and probably benefit from it.
A linked list is the most efficient way of implementing a queue: first in, first out.
Make it a public json API. Edit: also, where's the github repo?
Thanks for the help!
Redux is really well written! And it's not a large library.
&gt; A linked list is the most efficient way of implementing a queue: first in, first out. Got an example?
All that React and WebPack bundling nonsense for what could've been done with just &lt;div id="output"&gt;&lt;/div&gt; &lt;input type="text" id="input" /&gt; &lt;script type="text/javascript"&gt; const $ = document.querySelector.bind(document) $('#input').addEventListener('keypress', e =&gt; $('#output').innerText = e.target.value.split(' ').join(' fucking ')) &lt;/script&gt; I mean, I love React and all, but for something as simple as this..?
Wow. This is a well written app despite my banal first impressions. PropTypes and all! 
Ehhhhh.. While it's not nearly as inaccurate as people claim it was in the past, I still wouldn't go so far as to call it a good reference resource. MDN is vastly superior for that.
Fuckinator 3000 now has a json api for some reason. Dont know how much more time im going to spend on this. If anyone wants to contribute, please do.. https://github.com/phenax/f-inator-3000
Screen stays black with me. Nothing shows up after finished loading. Desktop-version doesnt make a difference either. Im on Samsung GT I9300 with CM v12.2 
Hey! So like this? $(document).ready(function(){ "use strict"; const pomodoroApp = new Pomodoro(); pomodoroApp.start(); }); &gt; the file-wide version of the strict mode pragma shouldn't be used since it's problematic when you concatenate files. What do you mean **when concatenating files** ?
If you want to be able to modify the same structure at many different points in the state, while using the exact same code, you need some form of cursor.
Excellent product. Reminds me of [Fuck Off as a Service](https://www.foaas.com/). But I don't think this is intended behaviour: **Input:** Why do you exist? **Output:** Why the fuck fucking do you fucking exist? 
https://developer.mozilla.org/en-US/docs/Web/JavaScript MDN is my go to resource for all basic javascript, especially when working on canvas Edit.typos
It looks pretty. The login modal makes me sad though so I didn't get to try.
Your library has 34 lines of code total, including set up. I wrote the same thing when I was in grade school. Maybe. Sort of. My point is, if one needs someone else's code to do this, and nodejs on top of that, then one needs to start rethinking career choices.
I have to make a client web site for the first time in a while and am just looking into which browsers I'm going to be offering support for (I'm a freelancer). Headlines like this are music to my ears.
Great idea. I would love one for React/Babel/Redux/Webpack etc. I recommend making each item clickable to a simple google search. For example "NodeJs SlowBuffer class". That way you can simply click the item and bring up search for it.
popper.js.org if you want to learn about dom performance optimizations
Hmm, suppose I could add that, but is it worth it? It's trivial to render the component conditionally in your own code. Then you can also control how animates in (such as with a CSSTransitionGroup like I did in the example)
This week I wrote and article about building Web Components with Skate.js, a library built on top of them which provides a functional render pipeline using vdom. Hope you like and feedback is welcome! https://hackernoon.com/building-a-custom-tag-input-with-skate-js-fbd4cdf744f
Thanks i'm gonna test it asap
What I meant by the word "chore" is the attitude that one brings when learning. If learning a language feels akin to cleaning your toilet bowl, it's a "chore", if it feels like reading a comic book, it's not. Typically, self-taught people with lots of techs under their belt got there because they enjoy learning new things. I agree that memorizing a 3rd or 4th for loop syntax can be annoying, but the *first* language should certainly feel exciting precisely because it's new territory. If that doesn't get you pumped, that's a red flag that programming is not going to be a good fit to your personality.
Where were you posting your ideas, the Microsoft support forums?
I've been at it since Netscape Navigator and as soon as Firefox and Chrome came around, there was a breathe of fresh air among all the developer communities I took part in. It was clear that change was happening. By the time IE9 happened, it came off as a failed last ditch attempt from Microsoft. That said, IE's market presence was never underestimated due to intranets and embedded apps and legacy products and mindsets used in business. There was no doubt that it would take many many years for either Chrome or Firefox to dethrone IE. I'm not sure what forums you speak of, but we're they full of business execs or something? Also Reddit? Really?
No way. There were three or so forums I would regularly visit. The only ones I can think of right now is sitepoint, codingforums.com, devshed, and another with a dark brown theme (webmaster something) I can picture but don't recall the name.
This is based on Net Market Share, which always had IE in front for unknown reasons, while every other counter had drastically different numbers. It still counts IE way too high. W3c says IE is at 4%, Statcounter and Wikipedia give 10%. Some sources claim NMS applies to the chinese market or is heavily influenced by it.
I just looked through your history to see what you are talking about and try to find this IE9 post that was down voted. I couldn't find it though because your posts are way too frequently down voted. After clicking through about 25 down voted comments, I stopped searching. It's less about your general thoughts and more about you being an asshole to random strangers on the internet. Calling people knuckledraggers and putting people on blast for liking Visual Studio Code and such. That said, I HIGHLY doubt people were down voting you in praise of IE9 but rather because you are kind of a dick on Reddit. I understand an occasional downvote, but nearly half of a person's comments being in the negatives should be an indicator to that person. 
Weird, I had the rather opposite experience of everyone (who cared enough to talk about it) wondering just how long it would take for IE to die.
Desktop Usage: * Chrome 32 -&gt; 56 * Internet Explorer: 46 -&gt; 21 * Firefox: 12 -&gt; 12 * Edge: 3 -&gt; 5 * Safari: 4 -&gt; 3
I assume you are using something like jQuery to scrape the words? If so you can use nodejs to execute JavaScript in a terminal. And cheerio to get the string from the Facebook page. You could also write it to a file or just process from there. Let me know if you have more questions. 
Yeah, the threads all a little over the place. You can see my example/entry to the discussion - http://jsbin.com/gebuxewayi/2/edit?html,js,console,output When setState() is called in a setInterval it will be synchronous, but when called in onClick (as a reply to SyntheticEvent) it will be asynchronous. AFAIK this is one of the cases, not the only one.
Please write me to telegram: @happierall or skype: duke575. Which browser use?
Just use MouseEvent's offsetX and offsetY properties. They are relative. &gt; var b=document.getElementsByTagName("body"); &gt; b[0].add... Just use document.body.
I can't recommend any good books but you'll want to search for the ISO/OSI layers.
That question didn't start up till maybe five or six years ago.
The "TCP/IP Illustrated" books are wonderful. They were published in '94, but are still relevant to this day. 
If you create some sort of accounts system, this would be useful for me.
*[High Performance Browser Networking](http://chimera.labs.oreilly.com/books/1230000000545/index.html)* by Ilya Grigorik has information about low-level networking protocols as background for making Web apps interact with network resources more efficiently.
&gt; Is it a JavaScript library to make event-driven programming simple? Yea pretty much. To understand why RxJS exists you need to know a little bit about the Observable type, which is (basically) a function that can emit values over time, but more importantly can have its execution cancelled. function timer (listener) { let id = setInterval(() =&gt; listener.next(`hey hey, it's ${Date.now()}`), 1000 ) let unsubscribe = () =&gt; clearInterval(id) return unsubscribe } let observer = { next(val) { console.log(val) } } // subscribe to timer, get back a function that will let me stop it let unsubscribe = timer(observer) Note a few things... * I can call `timer` a bunch of times and each `unsubscribe` method will act for its own timer subscription. * `timer` is merely a description of what will happen over time. nothing happens until I call it. * `timer` is just a function, so I can wrap it in another function to modify / compose more complex functionality That last point is really where RxJS shines. It has **A TON** of these composed functions called `operators` which make it super easy to combine and modify streams in all sorts of ways. Like the `retry` operator will rerun your source observable `x` amount of times if it throws an error (think about trying to make an ajax request that fails due to a network error). or `debounce` and `buffer` which it make trivial to catch a certain number events within a given timeframe (think determining if a triple click happened). The Observable implementation in RxJS is much more complex than my function above, but this is the general idea. Go find some youtube videos by Ben Lesh or Andre Staltz. He's the lead maintainer of RxJS and he explains observables really well. I also have a (kinda crappy) [presentation](https://www.youtube.com/watch?v=zAWB3lPixtk) about the basics of observables I did for work. 
Nice, so did you try out Cycle yet?
Yeah, mostly this. I have a relative whose work laptop won't allow unauthorized installs. It was stuck with IE 8 until last year, when the IT upgraded it to IE 11. For a while, they couldn't watch a basic YouTube video on a laptop made in 2012.
Interesting. I'm curious if there are any implementations in javascript I can look at. What do you typically use a queue for?
[MongoDB's answer](https://www.mongodb.com/blog/post/how-to-avoid-a-malicious-attack-that-ransoms-your-data)
I think the reason its so involved is that its an entire platform full of APIs..more or less an operating system crammed into one program.
Avoiding jQuery at all costs is likely not what any good devs are trying to do, rather its just become obsolete if you're using other tools. When I started using Angular I found that I seldom used jQuery (or Angular's jqlite) since most of the dom updates were happening in framework code, though I would reach for it occasionally in a directive or if there wasn't an existing Angular rewrite of a popular jQuery plugin I wanted to use. Inside my React applications I haven't had a use case for jQuery anywhere, so why bother with it? So myself and some other devs don't need it because the other things we use are better, however that doesn't make jQuery itself bad.. if you want to use, go for it.
sure, this is one choice, and it may be fine for back-office type apps where you can just tell people to use Chrome. but hopefully both you and your client/employer understand that this choice excludes 10%-25% of today's ecommerce traffic (IE11) in many industries. if a business spends a non-laughable budget on Google Ads or other marketing, they would not contract you in Jan 2017 because there's no way to exclude IE11 users from costing you CPC, but you can definitely exclude them from ever making a purchase. supporting IE11 is not _that_ much work unless your business is WebGL bitcoin mining with integrated WebRTC and ServiceWorkers. hell, even IE11 runs over HTTP2 in Win10. i know this because i live it. **EDIT:** I spoke too soon, IE11 has WebGL.
jQuery fills multiple niches including browser compatibility and DOM manipulation. As time has gone on better solutions for some of those niches have become available and so jQuery is less useful today than it has been. Today I only find it useful to smooth over a few browser inconsistencies.
Doesn't matter. Use the tools that are best for you.
So there's a virus going around that nibbles your brain and makes you not able to stand up??? What's it called? Is it contagious?? 
backend is the server. frontend is the browser. they are never combined. sometimes they both use javascript, so you can use some of the same code for some things.
You have to understand the separation between the client and a server. Any client code is public, meaning anyone can see it. Now In order to run any meaningful application that humans will use, you need to store that data securely, this is where server come into play and your "backend" exists. Servers often times talk to a database and retrieve records. Once your client securely authenticates with a server then your client code can call upon the backend. This is just one simple example but to answer your question yes there is a need for both. Server-less computing is becoming more prevalent but there will always be a need for a "backend" and "front end".
Yes. In short, you need a server to 'serve' your html/javascript/css to the frontend. As u/ASAP_ROCKY stated, you generally use a backend (server) to store stateful information and retrieve it with the frontend for display.
oh ok. for example your server can create html and reply back with `&lt;p&gt;Hello&lt;/p&gt;`. OR you can create the same thing using Javascript in the browser `var document.createElement("p"); p.textContent = "Hello"`. when people say they are moving something to the backend they almost always mean moving some functionality from being done in javascript in the browser and instead doing the same thing on the server and simply returning the result to the browser. it is faster for a browser to get the entire page already made and render it for you than it is for the browser to get only part of the page and do additional work in javascript to create the rest of the page (possibly making even more requests to the server). on slower or low power devices this difference can be noticeable and affect battery life and speed. other times you can go the other way and let the browser do more work because it knows more about where the user is interacting on the page, where they are scrolling, what their window size and screens size are at any moment.
is this an equivalence of separation from frontend to backend?
Hi! Thank you for the answer Yes!! Actually i'm using pure javascript to scrape the words. I'll give a look in this alternatives, thank you very much! 
the broadest definition is: are you running code in javascript in the browser or are you running code on the server (in whatever language the server uses). any more specific answer will depend on the context and the problem being solved.
o_O
thanks. glad to know we almost share the same opinions.
A front end is what the user interacts with A back end can serve a front end (for example index.html) Some back ends build the HTML (like jsp) You can build a back end that does not serve any HTML. Like an API that only outputs json So, I can build a front end completely separately that interacts with the API. If I want to change the front end, there is no need to re deploy the API. These are separate front ends and back ends
Internet exploder, lol
Good.
I think the node part is basically just acting as a gateway. "I'll serve the HTML and files. I also know about the different APIs we use and I'll aggregate the data from several sources, specifically for the purpose of serving _this_ UI"
To be fair, IE6 was nicer than its direct conpetitor: Netscape 4 :P
but there's no need for nodejs to be a gateway unless you insist on writing your UI code in JS on the server, which really only makes sense in the context of SPAs and SSR/hydration...or if you _really just love js_. nothing has ever stopped people from splitting their codebase to properly isolate data fetching and structuring from the UI code that would consume that data structure to build and serve html. this has been possible and done for decades.
jQuery is an excellent swiss army knife for letting the developer directly manipulate the DOM. * If you need to do *ad hoc* direct manipulation of the DOM, jQuery is an excellent library, and you should totally use it. * If you do *not* need to directly manipulate the DOM, jQuery is pointless and you will have no need for it. I (and many other developers) find that it's best to try and arrange matters so you don't need to worry about tinkering with the DOM, eg, by using libraries such as React, Vue, Knockout, etc., and in most cases this obviates any need for jQuery. But in cases where you need to do direct DOM manipulation, sure, I use jQuery. &gt; I saw a lot of devs avoid JQuery at all costs I believe you'll find they're trying to avoid *needing* jQuery, rather than avoiding jQuery itself. Often the best way to solve a complicated problem is to convert it into a simple problem, and then solve that instead. :)
I didn't think of putting the search thing inline. That's a great idea, will do. But the scores don't persist for you? What OS/browser?
Welcome to the future of optimized javascript bundling. 
It's the .js version of "DLL hell". jQuery versions and third party libraries.. God..
Developers hate him!
It's frustrating some countries still must need IE for online purchase!
https://ilearnsmarter.com/learning-meme Application for learning German language through images. It is similar to Memrise. Several modes included. All of them are turned of by default: - Movie mode - automated entering of the answers and proceeding to the next question - Clock mode - a new character is inserted in the inbox every 3 seconds if the used don't type during these 3 seconds - Extra mode - showing two translated words from the database - Bookmark mode / Bookmark icon - those features are for logged users - Random mode - randomize the order of the questions Build with Express, React, Redux Saga
jQuery is not "bad" for large sites however jQuery is bad for large applications with developers who don't follow good practices. Hell there is a movement to drop all the frameworks and go back to raw JS with all the tooling these days to enforce practices and standards. Imho, frameworks have their place to keep new or inexperienced developers along a path but there are many ways to skin a cat and just because it is harder to move rapidly at first doesn't mean it's bad.
All your points are valid when you look at solid senior developers and wanting to stay away from jQuery but I would guess most "seniors" OP is dealing with are 4 years into it and only used frameworks without realizing most frameworks have a version (jqlite, jq, etc) of jQuery "sugars" embedded in their roots. I personally don't mind jQuery if the requirements are to support ie9 and previous as I don't readily have the backwards compatible code for normal sections of websites that go with modern web however jQuery 3 has improved speed and dropped old browsers so for quick and dirty POC it is a nice thing to utilize. 
This question intrigued me enough to write a Medium post explaining how objects are converted to primitives, and how "+" and "-" operators work with non-primitives. -- Serious JavaScript Fun: [1] + [1] - [1] = ? https://medium.com/@vvkchandra/serious-javascript-fun-1-1-1-bb5b8ed916d0
Even effing Blizzard is neglecting to allow *any* purchases other than through IE11 only Active X solution with craploads of bloatwares that rely on yet another input hijacking tools here. In other words, you cannot buy anything on mac/linux what so ever. This is stupid.
Not a book, but here's [an introduction](https://en.wikipedia.org/wiki/Internet_protocol_suite).
Depends a bit on your use-case: * Are you looking to save the information locally to the client's computer (ie, user preferences)? * Are you looking to save the information remotely so you can access it later (ie, editing a document stored on a server)? * Are you looking to give the user a finished file (ie, doing something like markdown generation)? * Are you looking for a purely local utility (ie, a tool you'll use on your own computer and won't run from a website?) * or something else? You've basically got three options (someone jump in if I'm forgetting something), but they've all got pros and cons: * NodeJS on the server (or client) * localStorage/cookies in the browser * data URIs in the browser
[ISO/OSI](https://en.wikipedia.org/wiki/OSI_model) is a comprehensive architecture for networking. TCP/IP are the protocols that are actually used in the internet. One can view TCP/IP as a (partial) implementation of OSI/ISO, but, IMHO, while valuable conceptually I feel you're better off studying TCP/IP. In addition ISO/OSI doesn't specify an API like [sockets](https://www.amazon.com/Unix-Network-Programming-Sockets-Networking/dp/0131411551) which you need to write programs. 
Yes. These are [good books](https://en.wikipedia.org/wiki/TCP/IP_Illustrated).
You sure proved him wrong.
Makes sense! And I want to be clear: I wasn't bagging on you, or trying to question your motive or anything like that. I love that you were thoughtful of the community and took the time and effort to write your thoughts and share your work. I'll definitely have to keep this in mind. Thanks for sharing!
and that's minified code
Actually 11mb is pretty easy to do from a pre-optimization perspective. Edit: The number of people in this thread assuming everyone has good enough internet speed to handle 11mb makes me sad. Unless you are some kind of internal app, that bundle size should be in the kb. Try to download that 11mb in regions where 3g is the norm (like india) or in a rural location that only offers DSL internet. 
I have to agree. Using `defineProperties` and adding unnecessary get/set magic is clever but inconsiderate to everyone else (including the author when they forget). Defers are the way to good here. You aren't breaking the promise of Promises. And it really is not much more code. In my package tactic, defer is only a few highly reusable lines: https://github.com/andrejewski/tactic/blob/master/src/defer.js
My vote goes for this book as well. 
The native app is probably the web app dropped into chromium with electron.
I use mostly angularjs, but there are times when ng-repeat is just a dog performance wise and I have to use straight JavaScript. In these instances, I prefer to use full jQuery over jqLite. It's also go when I need to capture a document click event to close out a modal window, or do a right click context menu.
this is rad dude, awesome work
I've been using Teams pretty heavily lately, and it does quite a bit. Without having seen the codebase, I can I imagine two big ones are document rendering for office documents and skype integration (including integrated video chat).
You say $('id'), and I say $('#id'). You say $$('.class'), I say $('.class'). You say $F('input'), I say $('#input').val(). Let's call the whole thing off!
Bad dependency management
Maybe you missed my edit. The average 3g connection still pulls in around 100kb per second in real world usage. Try checking the throttling settings in chrome dev tools even. And I can definitely calculate the speed at which you downloaded the file. That is ~55kb per sec. That is very slow. You have other things going in the bg or your internet company is throttling you. Your thinking is that the 2mbit is the same as 2mb. There are 8 bits in a byte, so you have to divide your mbit rating by 8 to get the maximum rate your connection can handle. Then normally you will get somewhere around 60 to 80 percent of that because of external factors. edit: dev tools is saying a regular 3g connection will get around 750 kilobits per second which is roughly equal to 100 kilobytes per second. More like 94, but very close.
Why not show examples instead of a dump of the property names and values? I'm trying to figure out how this is useful.
This may be the best buzzword-y description I've ever heard
Sorry I don't see how this is more than a mobile clone of codepen/jsfiddle/plunkr. If you provided a console output mobile would be 100x more enjoyable. Also, if you support es modules and possibly include a babel compiler, it would be hugely popular. Then maybe support a full npm package support and background scripts for linters, hot reloaders, test runners and build processes.... you could put everything within reach of the mobile web dev. GitHub integration would be awesome too. This could be an amazing stab at cloud web dev. 
This example is really not that good... You should have accessed a property of the component in the greet function to show if the this inside the function is working. 
[removed]
As i think a bit more about this: Your second example will only work, when you are using babel-plugin-transform-class-properties. And then the this will also be bound correctly! That's a huge win because with this we can use the es classes without the annoying binds in the constructor! This plugin needs to be mentioned in your blogpost.
jQuery can become a crutch. It's not really needed any more, it used to be helpful when xhr requests had to be done differently in different browsers, or before querySelector/All existed. The difference is if you're building a simple static website or if you're building a SPA. If you're making some small thing it doesn't really matter what you use, go ahead use jQuery if you need it. If you're building a web application/SPA then state is very important and you want your SPA framework to be in control of what's going on. jQuery and jQuery plugins may not interact with your framework in expected ways, leaving the page in a bad or unexpected state. This can lead to bad side effects and trouble debugging. Also, jQuery will add bulk to your application bundle, it's increasingly important to trim the fat. 
I'm curious about the real use case for this, and whether it's actually a wise direction. If the resolution is synchronously controlled, why use promises at all? Why not just call the effect you want instead? I ask in part because I used to do this very thing in my code a lot, but almost always ended up refactoring it into a different, usually more straightforward pattern. Would be interested in seeing a fuller set of use cases to think thru.
Yeah agreed. It annoys me to no end when I see a stack overflow question about how to do something simple on JavaScript and the top answer relies on jQuery... No you don't need an entire library to do one thing. I still use jQuery from time to time, but jesus the dependency that some people have with it is incredible...
2mbps is nothing... It sounds like you're blaming slow load times on file size instead of your internet connection speed. It's 2017 - most people with a modern internet connection won't find 11mb unreasonable, or even see a noticeable wait before page load.
11MB is excessive but what internet connection takes 2.4 minutes to download 11MB? That's a 0.6 mbps connection. On a 20 mbps connection, that would take 4.4 seconds to download.
What if the top suggestion was always the thing on the list that most other people say they know, but you don't?
Whatever its hindsighted design faults and its diminished relevance today, it's silly to pretend that jQuery wasn't a huge and incredibly successful project. It took an extremely painful and difficult dev landscape across tons of buggy and opinionated browsers and standardized tons of basic selector and traversal operations, which was itself a big reason many of those better native apis came into existence in the first place! It made a tremendous amount of web functionality possible, imaginable, and within the reach of an entire generation of developers. It fixed and smoothed over tons of extremely subtle bugs and gotchas that people constantly missed with vanilla js. Of course there are plenty of nits to pick and choices to question in the modern dev world. And of course some things and usages got out of hand. And of course many native apis have supplanted a lot of what it did. But that doesn't change the fact that it had a huge positive impact on the scene. And before we get to cocky about some of the problems with deferreds, let's not pretend that there aren't serious problems with the design of Promises, fetch, and a heck of a lot of the tools that have replaced jQuery. 
If i need to do something quick for a very easy site, i'm gonna use jQuery because its super easy to get going and will work without a hassle on any platform with no need to setup build pipelines and whatever. Just an HTML-page with CSS and Javascript. Like i said: for very easy things. But lately things haven't been easy so i'm not using jQuery anymore. But that doesn't mean i hate jQuery or anything. Just that my priorities changed. Say my mum asks me to help her theme a Wordpress page, i would definitely use jQuery for that.
Exactly this - by the time you've learned all of it a new standard will be coming out. Also, why memorize it instead of setting up a tool like [Dash](https://kapeli.com/dash) and making it a few keystrokes away?
It's always best to avoid these things if you can. If you absolutely have to, consider an eval function inside a web worker. You wouldn't be able to set global variables, though.
Another thing this reminded me of: I also studied Chemistry in undergrad. The Organic Chemistry professors told us never to memorize the reactions, because that was a sure path to failure. Study the concepts and the movement of the electrons, and you can generalize it to any reaction you've seen the general shape of. Yet there were always a group of students that never followed that advice and tried studying from flash cards. Every exam had completely novel reactions based on what we'd learned, but applied to entirely different molecules. Those unfortunate pre-med students had the hardest time because they refused to pay attention to the bigger picture. 
I need it because I'm building a multi-language REPL in the browser. Web worker is 100% secure?
You're right about TypeError, I wrote my answer with `return this;` in mind instead of original `return this.x;` upd1: But still `var x;` will define `global.x`, just re-checked it in node console (v6.3.0) upd2: ok, it also depends on where you put your code – into the node console directly, or into some js file and run it via node.
jQuery does not have a bad rep
Have you ever programmed raw ajax ? Manipulated "low level js" (array buffers, typedarrays etc...) ? Ever used webworker ? How about making / using 3d framework ? A good way to improve is to just learn from the framework codes. Try to reproduce features, etc... If you already done all that, then by the last part of your post, I get the feeling you're confusing code knowledge and project development. I'll sound a bit obvious there but these are two separate jobs that require different skills. So your "not competent enough" feeling comes from that. try to learn UML stuff, things like that. You might want to learn about the new tech, try to search a thing that you would want to make. What's your hobbies ? Music, game, anything goes with website/apps. My comment is a bit random as your question, I hope you'll find something that inspires you in this mess.
That can be said for the whole platform
The short answer is "No." This is one of the questions where I'd start asking: What do you want to achieve in the end, and why do you think eval is the best way to get there?
Like i said, if its still something easy and small for stuff like a WordPress theme that needs a small change, i'd still use jQuery. And there is a high likelihood of the theme already using jQuery because lots of themes for the commonly used free CMSses still use jQuery.
Sign up is a must I think. Else same person can vote multiple times.
Thank you for your comment. I suggested an pretty, fast and scalable alternative for write more than 2 rows of code. It's have babel compiler (select in right top corner in every editor tab).
How did you replace the many good jQuery plugins in jQuery? Like date pickers and sliders. Are you recoding all of them from scratch? 
Arrow functions are a syntaxic sugar that still use closures under the hood.
No problem, it's not like I was lying awake hoping I hadn't just announced this to the world and it was horrendously broken. (Thanks for the update)
Yup
Hello! &gt; ...your whole "thing" can't be easily integrated into an existing website. Can you please expand on this? Why is it and how do I make my code work like that? &gt; Have you thought about learning React or a similar data driven view library? I have not, actually. I'm still a relatively newbie in JavaScript, so I'm trying to get as much plain-old-vanilla JS knowledge.
It depends. Many jQuery plugins are doing something quite simple which, when you're building against a higher level abstraction, doesn't actually need to be a seperate chunk of code. Something which might need a decently complex jQuery plugin might be six lines of code when working with React. For more complex things, basically everything that exists for jQuery has an equivalent in React (and Vue, and Angular, etc.), so there's no need to recode it yourself. &gt; Like date pickers and sliders. I usually use React these days, so if I need a date picker, I could use the excellent one from ant design [here](https://ant.design/components/date-picker/), or Fabric [here](https://dev.office.com/fabric#/components/datepicker), or Material-ui [here](http://www.material-ui.com/#/components/date-picker), or any of the 19 datepickers [here](https://react.rocks/tag/DatePicker), or one of the many, many others on npm, or if none of those do what I want, sure, I could code my own. But it's been a long time since moving away from jquery seriously limited my choice in terms of fancy UI widgets.
Too easy to cheat: var a=alert; a(1) is not detected by the no-alert rule 
I would not call 74kb(min+gzip) "close to zerop overhead".
I am building an embeddable repl 
You are probably right about the cache to a certain degree (**x** versions on **y** different CDNs results in a not-so-small trivial number of possible file-versions to cache, especially since the average user doesn't visit that many different websites, really.), but that code still has to be parsed*? ---- (*): Yes, some modern JS engines cache the compiled code for a while, as well.
What is your occupation at this place?
So I certainly haven't gone through the whole thing but I'm not really compelled to use it. Essentially there are a lot of pure functions in here (which is great!) but a lot of them are also only 1 or a few lines (in which case just re-implement / copy into your project and avoid the dependency). Also I think many of these functions should not exist in a library such as `has()` (which only wraps `hasOwnProperty()` and yes I know lodash does it do and I content it's not useful on their part as well) or `wrap()`. There is such a thing as too DRY. I don't need to worry about the `has()` having a security update in the future because it's just wrapping existing language functionality that, if it really does change, would likely break my app anyway. I also didn't see a ton of unit tests; have you checked how much your test coverage is? Strive for as much as possible. BTW I was checking some of your implementations of UUID, HSL to RGB, etc; many are different from top StackOverflow answers. I would be curious to the benchmarks between yours and theirs and if yours is found to perform better, submit as an answer to some of those questions :)
Cordova just turns a webpage into an app. It adds some additional functionality that can be used to access native features in the device, but that can be safely ignored. So just use Onsen UI to create a page as always, and then use Cordova to turn it into an app. If you need to know how to do those things, there are plenty of tutorials on the web and Google will find most of them.
It has a bad rep because it's simple, flexible, and it actually works great. Big companies push anti-JQuery sentiment in order to get everyone on their library that completely takes over your application and holds you hostage on their framework plantation.
The answer is probably yes, but does it support Function.bind now? I remember trying to use it for writing e2e tests, but Function.bind was not implemented. Was a long time ago.
 &gt; So basically what you are saying is "i don't want people botching my profession as a means to express themselves and to not use it as a platform with endless possibilities". Quite the contrary. I love the fact that the net is open and is available to everyone. I love the fact that HTML and web technologies can be gotten into with a minimal investment. What I am saying is: _You've started to learn this cool tool and these cool technologies. I expect you to spend time understanding them._ Same way I expect people to understand any other tool they use, from an automobile to a oven. &gt; You know jQuery is also one of the reasons that browsers now act similarly A contributing factor, no doubt, but nobody knows just how big of a role it played. If jQuery really was a good solution, no doubt the modern APIs would look a lot like jQuery does.
Reading this has me thinking where is the closure example...
&gt; The people going here know what hey are getting into Holy assumptions batman! For a lot of users, this app is effectively going to be facebook for work stuff. Facebook loads super-quickly, so why can't this?
only sith deal in absolutes. use the correct tool for the job. the main issue is that when all you have is a hammer, you use it on everything. add that to the chaotic and random ecosystem of cheap wordpress themes and plugins, plus some cut rate offshore work, and you get spaghetti.
Hi /u/SomeRandomBuddy, keep it civil please.
you shouldn't care about it, use `async` functions! if you don't want to use `async` functions, return with `Promise.resolve(res)`, so you can avoid [releasing zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).
Thanks! I completely forgot about yeoman, I will start using it.
You should never have a function accept a callback that can be both synchronously and asynchronously invoked. If you use promises it's not a problem, since the `then`-callback is always async (unless you use an old version of jQuery's promises). Just make sure to return a promise for the value if it's cached with `Promise.resolve` or a library equivalent. The reason for this is that it becomes really hard to reason about the flow of the program and the context of the callback. Consider this very simple case: let value = 'Some value'; maybeAsync(() =&gt; console.log(value)); value = 'Some other value'; What will happen here? It's very hard to know, since we can't be sure if the callback is called before or after the second assignment. It's important to note that you *can* write working code using this pattern, it doesn't automatically fail. It just becomes a lot easier to introduce bugs, a lot harder to find them and more convoluted to change the code later, so most people would (rightly) tell you to avoid it.
What I meant was there is no explicit use of a closure, just afunc
In fact, what are you looking for ? Some Firebase DB Schemas ? Javascript implementations ?
&gt; I don't know how to progress further. Write an application. Do something new and solve valid problems (problems that you have). Eventually other people will start using it too once you publish it. I have come to the conclusion that **fragile people write fragile software**. If you really want to advance don't be afraid of really hard problems. Even if your skills aren't there now they eventually will be, but only if you keep trying until you stop failing. If you are the kind of timid fearful person who is easily intimidated your software will reflect this. If, on the other hand, you are the kind of person who is willing to climb a mountain to visit a sage master and submit to enduring hours of excruciating punishment you are something called *resilient* (quicker to recognize your own weakness and you don't give up easily), which means will likely write more resilient and durable software. This isn't to say your software won't, at first, suck, but that you are determined to find excellence. Resilient people aren't deterred by trendy bullshit designed for fragile people looking for a quick convenience.
Hi /u/djengle2, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
OP is making a repl. As long as you cant share the code there is no problem. That way you can do evil things to yourself only.
&gt; The sheer fact that jQuery comes with a noConflict option so you can run OTHER VERSION OF JQUERY ON THE SAME PAGE is simply insane. noConflict was created to avoid naming conflicts with other libraries, like Prototype. &gt; You never needed jQuery simply for the selectors -- the sizzle engine that drove it was usable stand alone. I don't think this was initially true, the sizzle engine was never as well known as jQuery itself, and if you are already using sizzle why not take advantage of all the extra goodies full jQuery brings? &gt; My understanding is that real world support for fetch is still lacking. Not everyone is using transpilers and a complex build chain just for their js code. jQuery still provides a better and easier to use API as opposed to XHR. A few points you missed: The DOM API is overly verbose and a pain to deal with. `document.getElementById('id')` vs `$('#id')` `document.querySelectorAll('.tag')` vs `$('.tag')` `el.addEventListener(handler)` vs `$(el).on(handler)` I could probably go on with examples forever. The first thing anyone dealing with the DOM directly does is write their own shorthand wrapper functions to avoid the verbosity and boilerplate. If they are smart, they find a well written and tested library that already does it. Voila: jQuery. jQuery was also helps avoid memory leak issues that are often encountered when dealing directly with the DOM API. Particularly in older IE versions. As to the culture argument: Angular is a bodge, and along with React and other view frameworks that are trending toward web components they actively encourable slamming together plugins/components of unknown quality. These people with minimal skill and knowledge use your favorite language and framework too, it's just not as popular so there aren't as many of them.
I've never tried Onsen UI, so I can't directly help with the confusion. However, you could perhaps consider using Ionic Framework instead? It also uses Cordova, but their tooling and docs are great and should help you avoid at least some confusion. 
Quickly answer could be something like : * A date picker with event capabilities * A table to show logs For Firebase, I am on the thought to query all the datas with update capabilities. And do the magic of filtering wich data to show client side.
Hi! The dates are stored under the user's log node, I was under the impression that individual elements cannot be queried without getting the entire object, I am most likely misinterpreting you. I apologize, I am new to firebase. I like the table idea though, but how would a user select a date from let's say last year?
Simple make sense.
Your loop was almost correct. Instead of calling to get the element by tag name again within the loop, your loop variable access `a[i]` should be the element. So just as you checked the title with `indexOf`, you should call click the same `a[i].click();`
Bully for you if you had in your head all of the hundreds of quirks and bugs that jQuery normalized with its api. But for most people, especially most learners, figuring out every browser quirk was a huge barrier to entry and an ongoing nightmare that jQuery solved better than any other DOM library+ out there. And yes, that meant it opened things up to the "plebes." And part of the result was certainly a lot of sloppy crazy code by beginners. But a much more important result was also an explosion of javascript jobs and functionality across the web that helped get us where we are today in the first place. Heck, most JS devs today still probably couldn't write an proper implementation of something like document.querySelectorAll(`#blah`).children() off the top of their head... and for all the advances in native apis, it's still javascript under the hood, complete with wackadoodle non-Array node-lists and then wackadoodle Arrays (which of course lack basic methods like flatMap). jQuery was part of the reason that javascript succeeded as a language of the web.
Tried it with the block copy-paste (*window.open(document.getElementsByTagName('a')[34].href);*) and in the loop. It still only downloads the first one. At least it got some response out of the for-loop one though!
In this PR, I'm adding this implementation to Calypso. Wordpress.com's frontend https://github.com/Automattic/wp-calypso/pull/9386 It does not use the library directly since the library has been extracted from this PR. I have another repository using it, but not ready to be shared publicly.
If the string you're evaluating doesn't come from your own code, you'll need to sanitize it. This means parsing the string to determine which is safe and which is unsafe. But if you're going to do that, might as well evaluate it along the way. If the string you're evaluating come from your own code, there's no point on securing them.
something like * components * state * routes * theme * utils Single-direction circular data flow: state -&gt; view -&gt; actions -&gt; state
Yeah pretty much, though "years to come* is always optimistic
Use this. var eles = document.links, i; for (i = 0; i &lt; eles.length; i++) { if (eles[i].title.indexOf('Link to ZIP file') &gt;= 0) { eles[i].click(); } } 
Probably. Regardless, React encourages some good habits that I'd argue have benefit on their own. Not sure if the same can be said for Angular.
Honestly, neither are likely to be relevant in 3-5 years time. I recommend Learning react first in order to find a job, but then pick another framework and learn that, then another and so on. Read about why the frameworks are made to work the way they work, rather than just how they work. The real skill you need to learn is to pick up a framework and learn to use it efficiently as it's required, and you'll only learn that after learning to use a couple frameworks and swap between them, and learning the reasons they were built the way they were.
what is the best way to sanitize js code? What are the list of bad things that I should check for? On one hand, I want to allow dom manipulation. On the other hand, I don't want to allow access to cookie.
It's a toss up, there are a lot more "legacy" AngularJS apps out there in the wild, and even though ReactJS is on top right now, there is a lot more competition than there was when AngularJS was the thing. However if you do choose to learn ReactJS you could potentially never have to learn AngularJS, whereas I don't know for sure that you could say the opposite.
Angular was the new hotness a couple years ago, so lots of stuff was written/rewritten with it. React is the new hotness right now, so lots of apps are being written/rewritten with it. Both of them will produce products that will need support in one fashion. Its not like once you learn one, you'll won't be able to learn the other. 
If you learn one, you would already know the 50% of the other, or even more. React looks cleaner to me
Certainly start with the existing Javascript Sandbox efforts: https://developers.google.com/caja/ http://stackoverflow.com/questions/195149/is-it-possible-to-sandbox-javascript-running-in-the-browser But your other requirement regarding access to `window` is tricky. Is this because you are making something like Js Fiddle but want to export variables to the dev console? 
JsFiddle does export variables to console somehow; it's scoped to its own frame: http://stackoverflow.com/questions/14328963/access-variables-in-jsfiddle-from-javascript-console
You should at least understand both. Realistically a lot of place will have legacy AngularJS code with newer stuff being written in React+React Router+Redux (or some other Flux library). 
As others have said it really doesn't matter. Your ultimate goal should be to stay in top of all the latest frameworks. Might seem daunting at first by eventually you learn them really fast. They're like template engines, they seem very different at first with different practices and syntaxes. Eventually though you start to see how all template engines are just slight variations of the same thing. Frameworks are the same way, they just might take a little longer to learn than a template engine.
Learn React. Regardless of whether or not React itself is around for a long time, the concepts from React are changing the way people think about writing UI and they will remain in future frameworks.
This certainly would make accessing the logs easy, along with sorting. But I am not sure I understand how I would push these different elements to the database 
Angular seems to be on the way out. Angular 2 was supposed to fix a lot of its problems, but has not been well received. If that goes bust, I don't see how it catches up. React is just (in my opinion) better designed, and a better experience to develop with.
This is purely anecdotal, but in my browsing through job listings in the Austin area, it seems like the general trend is for React positions to be for new apps or rebuilds, while Angular positions tend to be for maintaining existing apps.
&gt; [I'm] Seeing more job offers requiring ReactJS than AngularJS That's depressing. Am I the only one who doesn't like React's way of doing things over Angular's ?
Yes very true. Some of the native methods that have a different signature get wrapped to prevent that -- Or the devs change the frameworks method to conform to the native method and then polyfill. For instance `Function.bind()` was a Prototype method before it was a native method. Then it was pulled into the native codebase and the Prototype devs modified the way it was working to conform to the native signature.
Go learn React. Then figure what you like about it and why, and what you don't like, and why. Then go do the same with Angular. Then, do that with Vue. Etc... Rinse and repeat. :-) Always keep driving, keep learning, and stay opinionated but be open to new ideas.
I don't waste any time on named patterns or other memorize as you go cookie cutter (copy/paste) approaches. I organize my code into a hierarchy of functions. There will be a top level function that covers the entire file so as to avoid global scope. Everything else will be inside that top function. Then I will have some references declared to store data from various points across the file accessed as closures. After I have declared all the references I will need I divide major tasks into child functions, typically IIFEs. I will then subdivide those child functions into further nested functions as necessary to achieve separation of concerns and tight organization of code.
A lot of what early days of what jQuery solved are now easily done in vanilla js
There's still old versions of things out there running on sites no one even maintains, so the problem is that fixes to the library don't prevent the web from breaking. This is why lodash and jQuery's approaches are a bit safer, even if it requires extra layers of wrapping.
Sure thing
Working in angular. Nothing but antipatterns everywhere. React does such a better job of helping you build, while angular is still trying to figure out exactly which problem it wants to solve. We'll be switching off of angular instead of going to angular 2 even though we've read up on it.
You can pretty much learn React in a week. At it's core it's really just Javascript. Whereas learning Angular is a thing in itself and you have to learn all angular specific terms. I spent a lot of time learning Angular2 and I regret it. 
Depends, React is the top currently - but more and more web component based applications emerge. There are quite a few interesting and highly paid Polymer Jobs right now - I would learn solutions that use web platforms and new standards - as those will apply to any framework.
Angular does as well, but most people I know fight with it. Instead of doing things "the angular way" they go back to selecting elements the JQuery way or working with http calls directly in a god controller instead of using directives and services or factories and datastores. I think this is where a lot of the big complaints come from, people trying to force a square peg (their programming methodology) in a round hole (the angular way™), so to speak. With that said, I think people have gotten scared by the angular 2 transition and are moving on to more stable environments like React. It'd be worthwhile to invest more time in React at this point.
I always found it easier to "screw up" writing angular than writing React/Redux etc.
I'd definitely go for React. The React community and ecosystem incorporates paradigms and design patterns that I think are great (it draws a lot of inspiration from the functional paradigm). You'll notice that React itself is pretty lightweight and there's a lot of extra components involved, whereas Angular tend to have a more conventional, opinionated attitude. I've only ever touched Angular 1.x so I can't really speak from experience when it comes to Angular 2/4.
Just browsing around the source code I see lots of references to cordova and haxe. I'm *assuming* it's written in haxe using cordova but honestly I don't have much experience with either so I can't tell you much more without spending a lot of time digging. Also references to aspx so assuming backend is .Net. Interesting tech stack choices.
After building large Angular and React apps I could not disagree with you more. Angular does not scale well with ambitious projects, OOP is fine for Java apps but it doesn't really map to UI as well as people think.
How you've hidden them doesn't really matter, unless the elements are off list (not there at all). display: none doesn't get rid of the elements, just prevents them from being rendered. Calling `click()` should work no matter what; its not looking at the render, just the dom, or more specifically the click behavior attached to an element, irrespective of the state of the dom. The dom only comes into play when we walk it to find the related elements with `parents()` and `prev()` etc. It works in your fiddle currently (adding another level showing it unhiding more than one): https://jsfiddle.net/Ltbo1563/7/ . If you want to update it with the conditions by which it doesn't work, we can look at it and figure out why.
How could anyone even ask these types of questions? Lately I've actually seen people going toward Vue now, saying how "JSX is terrible! React doesn't give us enough!" and so on...I've decided to stick with Angular 1.5+ because it has component driven development just like Vue and React and is still popular. Vue is faster because of VDOM? Well, someone has created a virtual dom for Angular too. As we move forward it won't matter which of these choose - only their supporting communities.
I say react benefits a little bit more because of react-native becoming really popular. You practically can start developing mobile applications by just learning a single framework.
I find it depends on the project. One of the biggest pluses and minuses of JavaScript is that it can be structured in essentially *any way you want*. Some languages or frameworks have "magic" which requires you to name things something specific or place them in the right spot but not JavaScript. So I think you'll find a ton of answers here and around the web and they'll all likely to be different. For myself, when I write backend code I like to keep the entry points into the service very clear. So they'll be a top level `main.js` that is the entry point for node then I'll have a folder call `servers` and each type of server I'm setting up will be there in its own file. So maybe `express.js`, `websocket.js` and `database.js` (since the database can be used across any server and it requires connecting to one). From there HTTP routes in folders based on their base url, security stuff in common utils folders, etc. For libraries, well, I try to separate things into executable units as best I can. So one file usually can run without a dependency on another. There are exceptions and it's not easy trying to do this without getting files thousands of lines of code long. One example if you're curious: http://msngrjs.com
Angular has been relevant for 5 years now, and is moving with trends...I think it will be around for another 5.
Agreed with this one. I am currently in the job market with React on my resume and I was surprised how many jobs are looking for Angular. All of them seem to be Angular 1.x so that leads me to believe it is some legacy software.
Well done mate, this is very cool! Maybe something like Highcharts, idk
It's a better framework AND provides more job opportunities. No brainer. Moreover, the way web development works, is things are always changing, so what you learn now may not be relevant in the future. Here's the thing though: if a new framework replacing React comes out tomorrow, all the people who know React will probably be ahead of the game rather than someone starting from complete scratch. A lot of times, similar concepts are used in evolving frameworks, or work around problems you've had to deal with. Baseline understanding in javascript (javascript is only going to get more popular) and one big thing: once you get employed, now you have a way to make money and learn real world experience. So don't worry about "is x viable for x amount of years". If I told you that staring at paint dry for a year could net you a job making 6 figures and that staring at paint dry will no longer be useful at ALL... then you'd still do it. so..... don't worry about things like that TOO much.
Good analogy, McDonald's is ok, I can use their wifi and drink coffee, more than jQuery ever offered.
is there a good path to shift an app out of angular to anything other than angular 2 without a monumental rewrite?
Why not both?
It looks intriguing and potentially extremely useful. I'll definitely check it out when I have time. In the mean time, here are some thoughts triggered by the readme: * This supports messaging between what and what? I assume just message queuing within a client-side browser app or server-side node.js app and NOT message passing between client and server. Or, am I reading this wrong? * Middleware and Persistent messages seem very useful. * The revertible cache seems useful, too. But, I'm not sure at all how merge works. I'm guessing it supports setting attributes within cached objects, maybe. So, set("key",{foo:"abc"}) and set("key",{bar:"123"). Then, get("key") returns {foo:"abc",bar:"123"}. * Your parallel behavior example doesn't show asynchronous results. It looks like the results are returned in the same order as the parameter functions, just as if it is was series behavior. It would be better if it showed that results can be returned out of order. Other than the few bits I found confusing, the API was clear and well thought out with a lot of great features I want to try.
Thanks for looking! &gt; This supports messaging between what and what? I assume just message queuing within a client-side browser app or server-side node.js app and NOT message passing between client and server. Or, am I reading this wrong? Out of the box it's simply within whatever environment you execute it in. I have some code written that can tie it together with web sockets so messages can broadcast in both but it's not ready yet. Ideally middleware should allow it to be expandable and it should contain good, default implementations of common usages. &gt; The revertible cache seems useful, too. But, I'm not sure at all how merge works. I'm guessing it supports setting attributes of cached objects, maybe. So if you have, say, a person stored in cache ``` var mache = msngr.mache(); mache.set("Person", { name: "Mr Person" }); ``` Now say you want to just *add* something. Then you call ```mache.set("Person", { age: 31 });```. Now the data in `Person` is `{ name: "Mr Person", age: 31 }`. &gt; Your parallel behavior example doesn't show asynchronous results. It looks like the results are returned in the same order as the parameter functions, just as if it is was series behavior. Good point. Unless something is affecting it it'll *most likely* return as if it were synchronous but I should re-word that example to make it more obvious.
Very cool. A terrific d3 resource I know I'll use. My only suggestions: * It would be great if data was live (i.e. editable), too, and had its own "switch" instead of having to scroll down to see it. * I'd love to see spider charts and tree maps as well.
Angular sure encourages good habits, but of a somewhat different kind. React tends to gravitate towards functional programming style, whereas Angular (along with Backbone and, I guess, Ember) is strong on object-oriented programming.
You need to explicitly declare the props in your component: 'dashboard-stat': { props: ['testparam'], ... the rest of your component code } More on this here: https://vuejs.org/v2/guide/components.html#Props
This!
mustache interpolation doesn't work in render function. You need to access all variables via `this.someProp`. So you should change in your example to `&lt;div class="name"&gt;{this.testparam}&lt;/div&gt;` Also i think you should wrap the whole code in parenthesis `return ( ... )` And something to read * https://github.com/vuejs/babel-plugin-transform-vue-jsx * https://vuejs.org/v2/guide/render-function.html#JSX
Why do you need to learn one of these frameworks anyway? What's wrong with just writing, for example, an app with express on the backend and JavaScript, HTML, and CSS to make it pretty? Throw in a database and talk to it with api endpoints. 
The parenthesis aren't actually required when the tag is on the same line as the `return`. It's only a convention.
The way I did it was by using the framework and every time I came across something that wasn't intuitive or obvious googling why it was made that way. More often than not you will find a blog post or youtube video. I'd then bookmark those blogs/channels and read through them when I had more time to see if they had other relevant content. After I learnt angular and needed to learn react for a project I inherited was when I did this most, and when angular 2 came out, as I was curious about why certain things work differently in them. 
My goal is to save it on a document stored on a server. Preferably with PHP or something. I know that this is under JavaScript, but I realized JavaScript doesn't really work with this. The code is(php): &lt;html&gt; &lt;? php $myvar = $_REQUEST['FName']; file_put_contents("results.txt", $myvar); print('Thank you for submitting your results!'); ?&gt; &lt;/html&gt;
You could always set a timeout within the script like so... setTimeout(function() { // execute popup stuff here }, 10000) 10000 being time in milliseconds (10 seconds) This only covers adding a delay for new users. You might want to look into just a localStorage key to check if they've already acted on your popup though.
It's so true lol. There's no way to keep up except to get good at learning new things quickly and drawing parallels between the new and the old, unfortunately.
If you inspect the DOM of the demo, you can see that the code is adding &lt;title&gt; elements inside the svg &lt;circle&gt; elements, which doesn't actual show anything on screen. If you wanted to change it, you'd need to do this: var node = svg.append("g") .attr("class", "nodes") .selectAll(".node") .data(graph.nodes) .enter().append("g") .attr("class", "node") .call(d3.drag() .on("start", dragstarted) .on("drag", dragged) .on("end", dragended)); node.append("circle") .attr("r", 5) .attr("fill", function(d) { return color(d.group); }); node.append("text") .text(function(d) { return d.id; }); And then in the ticked() function, you'd also need to change the node part to: node .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; }); This way, you're telling d3 to create an svg &lt;group&gt; which wraps the &lt;circle&gt; and &lt;text&gt; for each node, and telling the d3 force layout to update the group's transform attribute, instead of the circle's dx &amp; dy attributes
React is definitely a great choice to learn. You're likely best off learning the ins-and-outs of ES6 than anything else, though.
Yeah you might want to try coding with a module bundler like browersify or webpack. It's a million times better and you'll never need to think of putting stuff on the window namespace ever again. Also `import / export` are built into the language now, you just need a bundler to use them.
I wish more devs learned the roots and looked past the trendy. I would look at webcomponents.js and learn to build raw components then apply those learnings to trendy frameworks
There's a limit to a framework's ability to shoehorn new features in. This is why people use React and not Backbone/Knockout/Your-Favorite-Soon-To-Be-Dead-Framework with a Virtual DOM plug-in.
Try this: https://github.com/yamap77/TestProject/issues/3
The d3 examples really don't use React at all though. It'd be cool to see them plugged into the whole React lifecycle/state/render methods because I know a lot of people struggle using d3 and React together.
You're dealing with an assignment operator. Return keywords are necessary to return a value from a function, not relevant here.
React native results in a native app though, while ionic is still a webview. I like both frameworks and I usually opt to go with ionic over react native, but the idea of having native performance is very tempting. 
I do both and I say React. It's a simpler concept and pushes using ES6 which is great for the future.
You get native performance with react native and its amazing. If you know android development or ios you can create your own custom plugins etc and connect them to your react native app. I'll choose react native over ionic based on the fact that you are using react and because you get native perfomance. My humble opinion of course.
Just wanted to point out that react native is also write once and run same codebase on ios and android. You may have to do some workarounds sometimes to get things working on android and ios correctly but this doesn't happen very often. Currently working on a big mobile app for a client and we've had minor issues and is same codebase for ios and android.
Really good stuff.
&gt; AND provides more job opportunities. Not true by any measure I have seen. I would go along with there being roughly twice as many Angular jobs right now, though that could be changing as we speak...
It sounds like a header is being appended that you aren't appending. Perhaps the client has a proxy that is doing that?
HTML is easy to inspect and filter. That is a possible vector, but its also the easiest to block. Browsers add and remove elements from html documents all the time, it would be trivial to write a script that disabled &lt;audio autoplay='true'&gt; tags. 
Depends on who you work for I guess. I think more and more companies are learning that you don't need to build your brochure site in React.
how about when you have a legacy ES5 codebase that you are refactoring into ES6? A lot of the code can be just automatically transpiled, no need to waste developer time. Of course this is not 100% reliable and can introduce bugs, but in my experience it's rarely a case and if you have enough unit tests, you don't have nothing to worry about.
You can think of the ternary operator as a function: function ternary (condition, success, failure) { if (condition) return success; return failure; } The difference is that the language construct only evaluates one of the parameters (based on the condition) while this function will evaluate each of them when it is called, but only return one.
These sites are both really cool. I'd love to see a heatmap example for D3. Maybe Pixijs.live?
There's no general solution to this. I'd suggest IndexedDB, but you won't get indefinite storage nor indefinite size with it.
When was the last time you learned a big framework? You can get the basics of Angular maybe in a couple of days but you aren't going to be "fluent". Many of these modern frameworks are pretty complex.
Agreed, I've been developing in JavaScript for 10 years and I have to learn new tools/frameworks every year. JQuery, Dojo, YUI, ExtJS, AngularJS, React, Ember.... there is no "last framework you'll ever need". 
I personally like Angular more, and work with both professionally daily. I like aspects of both of them. React + redux (a standard these days) does feel cleaner, but also more tedious and boilerplate-y. Angular has "more magic" in it, but ends up being a bit more concise in the end.
&gt; Well, someone has created a virtual dom for Angular too Do you have a link for further information? 
Have you thought about setting up a Selenium instance or maybe something like PhantomJS/SlimerJS?
It only took me a day or so of working through a couple tutorials and building sample projects in angular before I was able to take the reigns on a project at work. React took a couple days because I spent the time to learn webpack at the same time. I come from a background in c/c++ and admittedly have been doing this for a while. But learning one of these frameworks, at least to the point that you can contribute at work shouldn't take that long. By no means am I saying I've mastered either framework, but anything I don't know off the top of my head I can reason about fairly easily. If you know vanilla JS, then it's pretty simple to pick these things up. Especially angular in my opinion. Frameworks like react are a little more tricky do to the "black box"-yness that can sometimes be introduced because of the build process. Edit: a word
That all sounds about right. Well said.
It will entirely depend on the job market you reside in or near. Where I am, having AngularJS on your resume guarantees you a job at the your pick of workplace. On the flip side that has lead to a lot of developers having AngularJS fatigue and are desperate to join the rare teams taking a chance on React or even Ember.
Yeah but if they never scroll it mine will keep scrolling? 
Thanks for putting the time in to look at this! Going to have a look at making the suggested changes tomorrow
Thanks for the suggestions! Going to try and use them tomorrow 🙏🏻
doesn't matter either way, native is dead in 3-5 years ¯\\_(ツ)_/¯
&gt; Turns out, breaking MVC and embedding view code in your controller code doesn't scale. That's an absurd statement, the fact both Netflix and Facebook use React with view logic in their code shows that it scales in massive apps. Angular 1.x isn't used in any large code bases or applications, it certainly not used by Google in anything major. HTML and JS are not separate concerns, placing HTML into JS allows easier flow of data through it's container(HTML), even NG-2 has started to embrace this with templates being bound to components themselves [see here](https://angular.io/docs/ts/latest/guide/component-styles.html) 
I will try to refactor and break down some imperative code to a functional style. I have also found this helps understand things better when you see each step to take. In the next post in draft, I am breaking down a common for loop into a functional style.
I understand that they're not currently considered to be useful, however the point of the exercise is not to argue that carousels should be used. Just that I can make one
whynotboth.jpg
I haven't used discord's bot thing, but I can tell you that you should check to make sure lines 2, 3, and 6 all function properly, since any of them would cause the issue. 
90% of my private personal Github repos are set to private simply because of how embarrassingly sloppy they are. 
Learn a language, not a framework!
I would agree with your assumption, but the nature of the trade is always changing and I wouldn't pick up React thinking that it is going to carry me for the rest of my career. Learning React and understanding the fundamentals of Angular isn't a bad way to go.
It boils down to close to the same thing. I'm interested in buying a car, but learning the name and top-selling model of every manufacturer is unlikely to help me buy a car in the future. Instead, I'm going to google a few words describing the car that I want (luxury, sunroof, 18'' wheels, leather seats), and go from there. That's how I discover things I don't know, by deciding upfront what's important to me and what _areas_ of knowledge I should get a rough understanding of. In the previous example, that means I'd dig into what features luxury cars have, and learn the vocabulary first (e.g. hardtop convertible). Then apply that vocabulary when I actually want to buy a car. I think this is what /u/needsTimeMachine was alluding to - that you should know the 'general shape of the solution'. To bring this back to javascript, I'd first identify the areas that I think are high-leverage: - Basic HTML - Basic CSS styling - Basic JavaScript - Layout - JavaScript ['gotchas'](http://bonsaiden.github.io/JavaScript-Garden/) and then study those. The downside to a flat list of things to learn is that you haven't assigned any priority. The vast majority of the DOM api is not high-value, so the net value of each random concept you learn is low.
Learn both
Having written a few apps in angular 1.x, I found that it was a huge step forward from el naturale JS (+ jQuery in the old days). but I always struggled with doing things the "angular way". Mainly because at the time, nobody could agree what the angular way actually was. There were a lot of different ways to achieve the same thing within the framework so it was hard to pick the best way. I've heard they've fixed a lot of these things with Angular2, but I haven't extensively used it. Angular2 has the problem that in order to be employable, you have to learn typescript, the new syntax angular uses and the build chains. And as far as I know not a lot of people are not using it yet (I've heard people are afraid of the versioning of Angular 2, and also are afraid to attempt a 1.x -&gt; 2+ upgrade). Where I found that angular failed was that it was trying to be an all encompassing framework for development of web apps. For the cleanest solution you should always try to do everything the angular way, and as soon as you side-step this, shit gets messy. I've found react a lot better beacuse it's not a fully fledged UI framework. It's simply a view rendering library. Which means there is no "react way" to do most things. You just have a set of components. You can use whatever libraries you want, however you want to create your app you can. This makes it easy to pickup and learn piece by piece (learn react, learn about flux, learn a flux library, learn how to apply routing, etc). People are definitely using react as it's stable, tried and true, and you only need understanding of JS, react, and flux to be employable. (though optionally knowledge of libraries like redux, react-router, etc help be more employable). Personally I've also found react is more fun to use.
&gt;Enter transpilers. We no longer need jQuery because there's a better tool to solve that problem now. jQuery and transpilation are two different problem domains. Transpilers do nothing towards solving cross-browser compatibility, which was one of the main purposes of jQuery. &gt; You're talking some of the world's smartest programmers couldn't prevent it from recurring. Just because they work at Facebook does not mean they are some of the world's smartest programmers. I hear this tired claim made far too often. It doesn't ring true at all, and I know a few programmers that work at facebook. &gt;After react, the bug is gone, for good. That's really not how bugs should get fixed. Also, see my first sentence. 
It's better in terms of employability for the next 3-5 years. Then we'll all move on to something else.
No need to complicate things then; you're right that this doesn't seem like something that needs to be done with Javascript. Any reason you can't use a form? &lt;form action="write.php" method="POST"&gt; &lt;input name="FName" type="text" /&gt; &lt;input name="submit" type="submit" value="submit" /&gt; &lt;/form&gt;
If using newer features makes your life easier, then do it. Don't use something just for the sake of using it. Also, I would be skeptical about a job ad requiring "es7". Sounds like a human resources person writing about things they don't understand. It would be hard for me to imagine someone not hiring you because you don't "know es7". 
I'd interpret "ES7" to mean they want people to be aware of new language features as they arise.
What do you mean by "pros wont use it"? Many 'pros' do use angularJS and many 'pros' are familiar with dependency injection. 
Source?
I would add putting parenths around this. var thingy = (1 === 1 ? "yay!" : "nay"); but that is being nit picky. 
UglifyJS has some interesting things to look at IMO. 
I don't think it's one or the other, I think you should excel at the one that feels the most comfortable to you and be aware of the other trendy frameworks. If you know Javascript, frameworks are secondary. Trying to predict the tech job market in five years is like trying to predict the stock market - its unpredictable. Invest in yourself and never stop learning.
Both will have plenty of work, but neither will be the last thing you learn. Try both and go with what you enjoy. People who like what they do are the most employable
How have you been able to look past the trivia and minor details? When I study a framework, I get caught up in a sort of rote learning process. I want to understand larger fundamentals. Not sure where to start when it comes to frameworks. Most study material is trivia as you put it.
Not sure what's best to learn but the codeschool courses are a good starting point for getting your head around things. 
I think just trying to understand the core principles of a framework and why those principles were chosen would be the place to start. For React+Redux it might be understanding VDOM, components, actions and the state of the app and its components. Maybe if you learn to explain what VDOM or components are and why they are used, it gives a deeper understanding of React. For Angular try to learn to explain controllers, services and directives. The core principles can be usually found at the front page of the frameworks website.
Thanks! I'll look!
&gt; jQuery and transpilers solve the same problem about developers having to solve the same problem more than once to account for browser differences, whether because of different versions or implementations. I still think transpilation (God, I hate that term) is not about “solving the same problem more than once”, but about bringing newer language features before the browsers officially support them. I think transpilation is more comparable to polyfills than to libraries like jQuery. 
You can use redux with any library that you want or even without any Library, but many resources are based on react-redux
If at some point you felt comfortable making an ebook or video tutorial offering an overview of core principles, please do. That isn't to say I can't learn on my own but learning is sometimes very useful when offered from different persons' perspectives.
Actually it looks like the specs are in Working Draft: https://www.w3.org/TR/shadow-dom/ There's a V0 that's implemented by Webkit/Blink and a V1 in process for all other browsers...
My ES goes up to 11. N00bz
 const {export1, export2} = await import('./myModule.js'); This looks dope. Edit: `let` to `const`. Thanks u/ClutchHunter.
Functional programming and immutable state for certain. But functional UI, where a component takes data and returns layout, and given the same data returns the same layout, ... i haven't seen anything like it, neither on the desktop nor on mobile nor on the web: const Header = ({ children, color }) =&gt; &lt;h1 style={{ color }}&gt;{children}&lt;/h1&gt; const App = () =&gt; &lt;Header color="red"&gt;hi there&lt;/Header&gt; Would you please link me to it? 
I hope that’s the case for the future; I don’t want to learn all these bullshit frameworks.
I pulled it down and checked it out. I don't play D&amp;D so the utility of this is unknown to me. But here are some takeaways/advice from the perspective of an open-source maintainer/software engineer: - Evaluate if you [really need Redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367), it's early in your project so things might get complex enough to justify it (or then so big to then unjustify it). - Code-wise, not to shabby I suppose. The build configuration was probably hardest part. Your reducer should be broken up into functions or a switch statement; the `else if (action.type === ACTION)` doesn't need the else because these actions are distinct. Ditching elses when not needed makes breaking up work visually easier. Since you have gone so far in your build process, you may want to investigate a code linting/style enforcement tool ESLint to find yourself some consistency. One prebuilt option for ESLint is [Standard](https://github.com/feross/standard), which I recommend and use. - Don't make people do work. This is a guiding principal that covers a lot of ground, but it's to say keep user experience in mind. Developers are users too. Cloning your project, downloading the dependencies, and kicking off the web browser is a lot of work to see your work. I'd be shocked if anyone here took the time other than me. Take some screenshots or check out [Github Pages /docs for hosting a demo](https://github.com/blog/2228-simpler-github-pages-publishing). You are guaranteed more interest and later in an interview or at a casual party where you don't have your own computer you can pull it up from any browser and brag. Even if the design is not the best, nostalgia alone is good reason to keep track; the "look how far I've come" perspective. - Use a stronger `.gitignore`; your IDE is showing. `.idea`, `npm-debug.log`, and `.DS_Store` should not be a part of your source. [gitignore.io](https://www.gitignore.io/) has some good defaults as does Github when you create a new repository from the web. - Follow naming conventions. In npm packages, "bin" has a special meaning. Usually files placed there are for CLI tools as either scripts to run or helpers for those scripts. Instead of "bin" use "dist" or "out" or "lib." Lib is usually for code only, but dist/out can include other assets (definitely a convention, not a rule). I think you would be best served making this your `docs` directory. Just throw your top-level index.html in there too. If you have questions, you can hit me up via my Github email and check out [my Github](https://github.com/andrejewski), I try to set good examples.
One I got deep into angular it really did help me form my JS (even outside of angular projects) better. React and angular are probably just the flavor of the month. They're both great, but will they be relevant in 2020? The more you learn the more well rounded you'll be and the better you will get at learning the next big thing.
The only new features in ES7 (ES2016) are the exponentiation operator and `Array.prototype.includes`. So they must mean ES7+. Or they mean “latest ES features”, in which case ES.next would be a better description.
Nice, is this on github?
Vue has a render call (templates are now just sugar and get translated into functions) and [can use JSX](https://www.reddit.com/r/javascript/comments/5n0jqt/vuejs_component_props_driving_me_insane/). The library caters to a specific crowd that are used to templates and won't let go yet, that is all. Underneath it is React already or follows its principles at least. 
Not an angular fan. But DI works well with tests
Is know-it-all open source? Forgive me if I'm missing something, tired and on mobile.
"legacy"
Thanks for the feedback, will update it accordingly.
Even if you wont use CDN, 75Kb is less than average header image would have, or about 3 images of products on ebay homepage. It would only make a difference if you would be on 2G connection. Then you could think if using jQuery (or any other library/framework) is good for you.
https://builtwith.com/?Http%3a%2f%2fwww.my5.tv Gets you a bit of the way there. Not much about the front-end though.
a "load" event will only fire for`window` or elements that fetch additional resources (usually ones with `src`). if you just want to poll and re-populate an element from the server... function get_chat() { $.get("refresh_data.php", function(data) { $("#chat_view").html(data); }); } get_chat(); var it = setInterval(get_chat, 1000); // to stop... clearInterval(it); this example also makes the function non-recursive (doesn't call itself), and uses Javascript's built-in `setInterval` that acheives the same thing.
Go for both! Else the parts you don't know will bite you. Knowing two major frameworks and their core concepts will also make you a great asset for Agencies/Freelancing where tech-stacks change from project to project. React Basics (Lifecycle, Rendering, Elements vs Components, Children, Props, Propttypes, ReactDOMRenderer, Webpack and React) With Angular, there is a longer but less steep learning curve. Most of the knowledge is hardly applicable to other frameworks or general programming. Basics include( Components, DI, Interceptors, Directives, Filters, ng-repeat, ng-if/ng-show, ng-annotate, $apply/digest) As a freelancer in 2015/16 i used AngularJS for client apps and started writiing admin/tooling and my sideprojects using ReactJS. That did work out gloriously.
Yes, we would loose tree shaking and whatever compile time optimisation. However, things like AMD (**Asynchronous** Module Definition) already exist and are used. So I can see the point to add the `import()` operator just for the sake of standardization.
While React has definitely left Angular 1.x in the dust regarding what's hot and new, I noticed that a lot of enterprises are investigating Angular 2 + Typescript. These are companies that still heavily use Java/Spring or .NET and don't make tech changes that fast. Having Google and Microsoft behind a product has more weight in the corporate board room than Facebook. Just sayin'
This isn't best practice, you can either add the dependencies in a string array angular.controller("controller", ["$http", function($http){ // stuff }); or MyController.$inject = ['$scope', 'greeter']; I'd recommend having a read of the DI docs - https://docs.angularjs.org/guide/di
I guess you can reuse the logic, but the UI portion needs to be written in platform-specific components. Contrast that with Ionic, in which you literally write the code once, and the app assumes the look and feel of whichever platform you deploy to.
Yeah, I feel you, that shocked me as well. I must confess it wasn't immediately that I realized just how perverse it is that you need to use a certain string that you register as a service name for your variable name, and then laughed at myself for not having realized that sooner. This is one of the things I strongly dislike about angular, that they change the usual behavior of javascript. But like others have pointed out, minification with angular is a solved problem.
In its current status, the survey's pop-up window automatically appears on the homepage **only** when a new user visits the blog. It will stop appearing when said visitors have chosen to **not** do the survey (*Another Time* button) or, otherwise, actually **do** it (*Go Ahead* button). What I actually have in mind is to set some sort of *timer* that makes the survey's pop-up window to not automatically appear in random moments of the day only to new visitors, but to make it appear also to old visitors. But in an exact moment or when the blog reaches a given amount of **Total Pageviews** (as it can be seen in the *Stats* page on Blogger). That means the logic should be something along those lines: &gt; Pop-up Script » show up from » 1 February 2017 » until » 10 July 2017 Or &gt; Pop-up Script » show up only when » Total Pageviews » 2345 » from » 1 February 2017 » until » 10 July 2017
&gt; imported from json file yes, this makes sense. but it means this will be just another hand-made clone of gettext. this case is already covered * https://github.com/alexanderwallin/node-gettext * https://github.com/zaach/jsxgettext * https://github.com/messageformat/Jed
SMH I thought I was all fancy with promises and stuff and then this comes along... So much new JS stuff, and it's all amazing, but JFC if it isn't overwhelming.
Yep I know it's not the best way, but it shouldn't exist at all.
Pros won't use that way to declare the dependencies as it doesn't support minification. The magic way with var name maching is just confusing and useless
The thing that held together [win32 GUI](http://www.win32developer.com/tutorial/windows/windows_tutorial_3.shtm) was the digest loop. Mixture of that, random control flow, events, OOP and API functions. CreateWindowEx does not create components. None of it describes anything close to fuctional UI, i.e. declaring composeable, graphical components like in React or others. In the example above both `Header` and `App` are self-contained *components*. You can draw them as they are, compose, use and re-use them. 
https://github.com/teropa/angular-virtual-dom https://medium.com/@svilen/optimise-your-angular-1-x-app-fast-rendering-with-hyperscript-and-virtual-dom-d76252278ad0#.s0kav3zai I'm kind of fond of the 2nd approach. You can do this for specific directives or controllers that have too many watches and too much weird template logic. Just replace them with a react style h and render the whole block.
&gt; it's 2017 and we have ES6/7 now Well yes, but you cannot run ES6 everywhere (yet), that's why it is not bad to have solutions which are not ES6. But I agree with the rest, the tips &amp; tricks are kinda old and especially weird (like calling a function with just a string). They look more like stackoverflow answers to problems that occured, nothing really common.
That's what I'd do.
Fucking lucky bastard. We still have to write ES9 because 2.5% of our devs work on ES9. Can't wait for ES Edge to be stable so we can don't have to worry about ancient code breaking on cool new features.
Not saying you're wrong, but I'd like to know why? Is it more readable to you?
Hey, four years ago called, they want their article back.
You'd want a `const` for most imports surely?
Could you explain what you mean "nothing g works on its own"? What about createing mocks for those things you're DIing? Also, I'm not knowledgeable enough with React, but how does it parse sub-components with testing?
You're mostly right, but async/await was a lifesaver when it came to working with heavily asyncronous APIs. Firebase for example. This code looked reeeeally ugly with raw promises. export async function uploadImage(imageFile, progressCallback) { if (!state.user) throw new Error('User not logged in.') const id = await generateImageID() const extension = path.extname(imageFile.name) const filename = id + extension const upload = firebase.storage().ref().child(`/users/${state.user.uid}/images/${filename}`) const uploadTask = upload.put(imageFile) if (progressCallback) { uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED, data =&gt; { progressCallback(data.bytesTransferred / data.totalBytes) }) } await uploadTask await firebase.database().ref('/images/list').push(id) await firebase.database().ref('/images/full/' + id).set(upload.fullPath) return id }
Yeah, IE-/Edge-support is not that great though (lacking)..
If you have just a handful of files that you need to concat in a set order, just keep manually ordered list of those files. Optionally, keep a list higher priority ones that must come first, if ordering is less important for some of the files. That said, the use of a bundler tool, such as Browserify, Webpack or Rollup is very convenient, as it'll keep track of the dependency graph for you. Also, if this hobby project has the aim of teaching skills to increase your employability, learning such tools will be very beneficial.
Basically it just creates &lt;style&gt; where there's separate text nodes for dynamic CSS property values. Then it updates just textContent for those, when values change. So it injects certain values to a style sheet.
Use the CSS rule: Overflow: scroll
Good question, I'm not really sure.
Is it compatible with IE 8?
 require.ensure([], function(require) { var foo = require("./module"); });
React is really just the V part of MVC.
This, although I do think that the percentage of framework-specific things you're learning with React vs. its ideas/philosophy is far higher than it is with Angular.
I really like Software Engineering Radio by IEEE.
I added comments, thanks for the tip! :)
Hi /u/PjoyDev, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Thanks for the suggestions so far. Given me something to look into on dinner
The first example relies on some transpiling behavior which seems pretty fragile to me, albeit efficient and fairly clever. The second ("manual") method seems more reliable, but it really is just plain dependency injection. I wish they had considered a mocking system when designing the modules. It's nice to have more options about exporting artifacts, but I spend too much time trying to figure out how to write my code in a testable way since I began using them.
Yeah to me it makes itlooks more like two things happening (a turnary and an assignment). Instead of maybe more than that. 
I feel like if I don't hurry and make my own "fast React-like framework" real soon, I'm going to miss the party! Seriously. It needs to be more than just "fast" and like something else to really get attention.
No you're not. The React faithful are just louder on /r/javascript and in Bay Area circle. It also greatly depends on whether you've swallowed the FP hype (balls and all) or are as wary of it as you were wary of "OO will save the world" ten years ago. I see job listings for React, Angular, Ember, heck, even people rolling Knockout and Backbone still. React will not change the world, after the hype settles down you'll still have camps and I'm pretty sure some fifth option will emerge, embracing Web Components and other emerging standards, and issues like state management, lifecycle management, separation of concerns and project management will be the big sellers and not moving targets such as render performance or ideological metrics such as 'is it pure' or 'is it OO' enough.
OK so this is several things. First of all you just need to put your script inside different if statements. To check if a person has said "later" or if they have already done it you need to use local storage or cookies. Don't store a true or false here. Do something like hasDone = new Date(); that way you can check how long ago someone last interacted with the survey. To check page views you need a backing API. It will just depend on what you are hosting your files on. But make sure you don't use an API that requires credentials because if you include them everyone will have access to them. If you want this pop-up to happen multiple times in a single page view you should use setTimeout(). If you want to do a single check per page view there aren't any timers you should just check the difference between now and the last time someone interacted with the page. 
Works perfectly. Thank you for taking the time to take a look.
So two years old in JavaScript.
While it may look intimidating at first, async/await actually causes async code to be basically identical to sync code. It's very convenient and takes away much of the difficulty in learning promises. Let me give an example from a situation I had recently: You need to create a child object. If some condition of the parent is satisfied, you need to prompt the user for creating a new parent first, and abort if necessary. If everything was syncronous you could just do this (everything that would need to be async is marked as such): let parent; if (existingParent.isInvalid()) { if (!asyncConfirm('Create new parent?')) { return; } parent = asyncCreateNewParent(); } else { parent = existingParent; } asyncCreateNewChild(parent); The solution I came up with using promises was something like (this is of course massively simplified and gathered in a single function): const shouldCreateNewParent = existingParent.isInvalid(); const proceedPromise = shouldCreateNewParent ? asyncConfirm('Create new parent?') : Promise.resolve(true); proceedPromise .then((proceed) =&gt; { if (!proceed) { return; } let parentPromise; if (shouldCreateNewParent) { parentPromise = asyncCreateNewParent(); } else { parentPromise = Promise.resolve(existingParent); } return parentPromise.then(asyncCreateNewChild); }); Much harder to follow since there is no way to really branch or do an early exit. Maybe there is some golden solution I'm overlooking, but I don't see it. Something like a function returning a promise for a valid parent or null if the user declines might work, but it's still not super clear. If you were to do the same with async/await, you just sprinkle some awaits on all the async functions, and you're done. let parent; if (existingParent.isInvalid()) { if (!(await asyncConfirm('Create new parent?'))) { return; } parent = await asyncCreateNewParent(); } else { parent = existingParent; } await asyncCreateNewChild(parent); Much clearer, I'd say.
still waiting for an HTML formatter that isn't complete garbage. Yea, thanks for closing those img tags, that's exactly what I needed you to do. -__-
Before I actually made the jump into React, I spent a few weeks trying to build my own VDOM-capable subclass of Marionette.View, by cobbling together a JSX parser, a VDOM lib, and a couple bits snagged from other libraries. I actually got it mostly working, but somewhere along the way I decided to just bite the bullet and give React a shot. Boy, am I glad I did :)
Yeah, I asked Dr. Rauschmayer about that, and he confirmed `System.import` had been replaced. See https://twitter.com/acemarke/status/818519739345600512 .
Doing this without jQuery isn't too different—the syntax is a little more verbose, but the process is very similar: 1 . Find the button. In your example, you use the jQuery selector `$('#jQueryColorChange')` but in vanilla javascript, you can use a variety of selectors. In this case—since the button has an id—you can use [`getElementById`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) which is available to you on the `document` object: var button = document.getElementById('jQueryColorChange'); 2 . Add a listener. You want the browser to listen for clicks on the button, so you'll want to add an event listener. This method is appropriately named [`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener). The method takes the type of event as the first argument and in this case, that is `'click'`. The second argument is the callback which is executed when the click event is fired (ie. when someone clicks on the button): button.addEventListener('click', function(event) { console.log(event); }); 3 . Toggle the class. In your callback, you'll want to toggle the class of the button. The button is passed to the callback via the [event object](https://developer.mozilla.org/en-US/docs/Web/API/Event) as the `target`, so you will manipulate the button in the callback with `event.target`. The class toggling is done by accessing the [`classList`](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList) and using the `toggle` method: button.addEventListener('click', function(event) { event.target.classList.toggle('selected'); }); 4 . All together now: var button = document.getElementById('jQueryColorChange'); button.addEventListener('click', function(event) { event.target.classList.toggle('selected'); }); Here is a forked fiddle with the updated code: http://jsfiddle.net/pwgtwc27/2/ Hope that helps.