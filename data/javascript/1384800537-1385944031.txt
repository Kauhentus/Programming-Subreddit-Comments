As you learn JavaScript, I recommend using a tool like [JSHint](http://www.jshint.com/) which will check your code for many problems. When it gives you an error, look up the error so you understand exactly why its a bad practice.
It's a Roguelike in the same spirit of Nethack, and I hope to reach its insane complexity. It will have actual graphics, unlike Nethack, but it will be turn based. Not sure if I want to make it 2nd person, or see if I could make a 1st person turn based roguelike. It will also have RPG elements in it, such as more fleshed-out NPC's, side quests, more unique items, and customizable weapons and spells. For now, I'm just setting up the basic classes and essential parts of the combat system. This is going to take a reaaaaaally long time to make, as I'm building it from scratch and I have no previous game development experience.
Clearly if your not going to understand spelling of JavaScript functions on a mobile phone is a non trivial task then what are you even doing on the interent. Tldr; spelling 
You forgot the link.
Hmm, call me crazy, but requiring a trailing dash in class names to achieve binding seems like the opposite of semantic HTML.
Most applications so far namespace all their functionality to one global object and assume its presence (a reasonable assumption). To make it cleaner and more obvious, an IIFE with the global object passed in is the best way to go about it. Given that what you're trying to do is access a global object and pass it to your module, this is a nice way to do it: (function ($, _, GO, undefined) { }(window.jQuery, window.underscore, window.GlobalNamespaceObject)); This kind of code has been common for a while and achieves what you need without the pattern recommended above. Alternatives to this are the [CommonJS and AMD patterns](http://addyosmani.com/writing-modular-js/).
This! Huge learning curve but once you get it, it works so damn well.
That is &lt;iframe name="shoppingcart" src="/shoppingcart/" id="iframe"&gt;&lt;/iframe&gt; If you set "visibility: hidden;" are resize window (to force paint) then it disappears. I don't know why that glitch occures, but hope it helps.
On an unrelated note, Chrome has built in Developer tools, which are more powerful and has better performance than firebug lite.
Hah, touche :-) but the dash is just a convention, the semantic part is that the class name describes what this element represents in the language of your domain model. We could do the same thing with data-value='name' instead of name-, but it's often not the value of the element but the scope of it's contents. We do support data-scope for that scenario though, and the class-name feature is a kind of syntactic sugar for the common use case.
I'm entirely confused as to why this is behaving the way it is. BUT, I have a fix for you: Inside the iframe, add "overflow:hidden" to the body. 
I'll add to this, as it's often overlooked, using a framework vastly simplifies orientation of new developers. If I use Ember, and need more help, or someone leaves and I have to replace them, it's relatively easy to bring in anyone else who knows Ember, and have them hit the ground running, rather than walking them through file organization and naming conventions and style guides, etc.
Learn a framework, like Ember or Angular. You can get where you're going with a ton of trial and error and studying patterns in vanilla JS, but you'll learn more, faster, if you jump into something that gives you some constraints. JS gives you a million ways to do one thing, and with it, a million ways to shoot yourself in the foot. A framework will keep you out of trouble, and teach you architectural things that are just good ideas for general maintenance.
I'm trying to imagine when that would be better than an IIFE? Seems like a code smell, I definitely wouldn't want it in any production code.
Sometimes I tend to throw it in a scope with an explicitly declared window so if someone wants to put something in the window scope they have to explicitly write window.something ... it all depends on who I'm working with and the project: (function ($, _, window, undefined) { console.log(this); //should be a blank new object }).apply({}, [window.jQuery, window.underscore, window]);
This is my point exactly! I'm fairly new to the industry, and until about 4 months ago, I hadn't really learned vanilla JS. The problem is, if you Google ANYTHING with javascript, the internet will give you jQuery. To clarify, by "fairly new" I've been working at an agency about a year now. Only reason I hadn't learned js is because I thought jQuery did everything, until I found out it didn't. 
Added, I thought I linked the title before.
I'd agree with this. I got fed up of jQuery doing everything for me, and I wanted to know why/how. I never said in the opening question that I won't ever use jQuery, or that I hate it. I simply said it has its place, and I don't use it by default (anymore) now I know vanilla JS, because I find a lot of things a lot clearer using vanilla. jQuery is a tool now, rather than an essential thing. I used to love it, now I simply like it rather than think of it as the most essential/wonderful thing ever. 
Google anything with JS and you'll get jQuery tutorials. I learnt backwards because that's how things end up happening. I then learnt vanilla after, as I got bored of not knowing how things actually worked. 
Why make this post when it's posted every day?
Interesting talk, I haven't tried using React yet. I'd like to see how it compares to other similar libraries. Right now the video only compares it to vanilla js. edit: [This](http://www.quora.com/React-JS-Library/How-is-Facebooks-React-JavaScript-library) is an interesting Quora discussion about React with one of the facebook devs answering it
Yes, the white square seems to be the corner between the two scrollbars of the body inside the iframe. http://puu.sh/5mmcl.jpg
This part was the dealbreaker for me: &lt;!-- Load our compiled modules (in whatever order we feel like) --&gt; &lt;script src="js/foo.js"&gt;&lt;/script&gt; &lt;script src="js/bar.js"&gt;&lt;/script&gt; &lt;script src="js/log/index.js"&gt;&lt;/script&gt; I think I'll stick to requireJS in the browser :)
Are you sure about that? JavaScript doesn't have a way to suspend execution, while C++ and C do. Hell, even C# does with the .NET MF. I believe Netduino (as an example) runs a VM to interpret the IL (I'm still new to C#, so bare with me). C#s performance on a microcontroller is probably roughly equivalent to JavaScript, out of the box. JavaScript requires a VM to be running on-chip as well, as it is not compiled to machine language. C and C++ can run "directly on the chip." JavaScript's event loop is arguably polling. C++ and C allow you to write code that can respond to interrupts after suspending execution. Can you do this with JavaScript? These alone make JavaScript less efficient. Take what I'm saying with minimal correctness - I'm not an expert in embedded software development. However, it doesn't seem right to me that JavaScript could ever perform better in any circumstances because of what JavaScript is and how it runs.
It all depends on how much the VM handles. I believe node does real event waiting via epoll.
Next project-- SUPER BREAKOUT in 30 lines :P
Yeah and the fact that its a synchronous API makes it in my eyes unusable for the browser. It means you have to pre-compile every module and send every module to the browser before anything gets executed, right? The big strength of requireJS is, that you can load and execute whole modules of your application at the point you need them and don't have to download a huge application completely before being able to execute anything.
No, that's what I was saying when I mentioned lazy-loading. It's not a built-in feature (because, as I said, I wanted to leave such decisions to the developer using the library), but you could use lazy-loading to load "less used" or "less needed" modules async. Something like this (super simplified, of course): var lazyLoad = function(module) {...}; if (! require.resolve('foo')) { lazyLoad('foo').then(function() { var foo = require('foo'); // Now it can be used foo.doSomething(); }); } That's a bit ugly as it is, but it could be cleaned up: require.lazyLoad('/foo', '/bar').then(function() { var foo = require('foo'); var bar = require('bar'); // ... }); But at that point, you might as well just use requirejs, they're basically just doing the same thing. The point of this isn't to redo what's already been done, but to offer another option. A lot of developers bundle JavaScript as oposed to lazy-loading methods like requirejs; There are arguments both ways with pros and cons. I'm just offering another choice :)
I'm only a beginner in AngularJS, but as I understood it so far, the AngularJS way isn't to do a http request inside a controller. Instead, there should be a service that does the communication with the backend, and the controller should use the service's functions. 
Also, while we're on the topic of lazy-loading vs. bundling, I might as well put in my opinion here. Personally, I'm a fan of a hybrid approach - don't bundle the whole app into one file, but don't load every module separately. Loading every individual file by itself requires a lot of open HTTP connections, which even today, is still a big deal in a lot of cases. That said, like you mentioned, downloading one massive file before doing anything kind of sucks. That's why I prefer creating multiple, smaller bundles that contain certain feature sets; Like having one bundle that starts up the app with just the basics, and more small bundles that contain related features. Lazy-load the smaller bundles as needed, and use CommonJS for individual modules contained in them. But that's just my opinion :)
Ah, neat! That's basically what I tried to do in the first place, not sure why I ended up with the method call. The weird stuff happening when deciding what to log seems necessary here, both FF and Chrome apply some unexpected formatting to the value. I'm sure there's a better way though.
That's a little too meta for me.
I saw the goofy logging — it didn't click at the time. I wonder if anyone would know why that happens?
You also might want to look at Andrea's [blogpost on the same topic](http://webreflection.blogspot.de/2013/01/the-power-of-getters.html) from January 2013 (Thanks Andrea for the hint). 
Curious, what can you do with backbone, ember and angular that isn't available (or easily accomplished) in vanilla javascript?
One of the BIG original problems that jQuery attempted to solve was that the JS runtime was awful in some browsers - some browsers couldn't even implement document.getElementsByClass() correctly, for crying out loud! So, you use jQuery - a big draw was that the jQuery API was designed/tested to work in all browsers, so you could write $('.product').addClass('tasty') and not have to worry about IE 5 dying, for instance. To that end, to a lot of people, jQuery is STILL javascript. Browsers are definitely not dodgy pieces of crap like they used to be, but you can still count on well-written jQuery code to execute across all browsers in a reliable fashion. As strange as it sounds, too, it's almost certainly more common to find someone that knows jQuery better than vanilla JS, so writing in vanilla JS can even be a DETRIMENT in some environments. That all being said, you can't truly know jQuery until you know JS. I think any effort to understand the language at it's most fundamental level will leave you far better off. Good on you!
It would appear that `this` in any execution context can only refer to an object, so it is automatically converted into an object (if it's not one already). In ES5, this is no longer the case. You can force ES5's behavior with `"use strict";` at the top of the scope: String.prototype.thisTest = function() { console.log(this) }; String.prototype.thisTestStrict = function() { "use strict"; console.log(this); }; var stringy = "Hello"; stringy.thisTest(); // =&gt; String {0: "H", 1: "e", 2: "l" .... stringy.thisTestStrict(); // Hello
thanks for the response. multi array looping: (console.log #{ id } - #{ names[i] }") for id, i in ids The IIFE is created once per file, wrapping the whole thing, not around every function. scopeing: why would you ever want to redefine a variable that already exists in scope? This seems more code smell then useful to me. Coffee script doesn't attempt to support all of js, only the 'good parts'.
Well done! (However, it's really "Breakout written in 30 lines of JS, 120 lines of CSS, and 57 lines of HTML.")
Another tool which enables CommonJS Modules in the browser is Browserify. There's two major things Browserify does that this doesn't: 1- Browserify concatenates your modules so you only have one script tag, and no need to load a separate "common.js" library. 2- Browserify provides browser-side versions of the Node.js API when desired. It also supports the Node.js variant of CommonJS Modules, which allows you to use the ".js" file extension and the `node_modules` directory. It doesn't look like Common.js does that. The nice thing about Common.js in comparison to Browserify is that it's drop-dead simple. Less to go wrong, less to misunderstand, very Unix-like in that it does one thing well that you can compose with other tools.
Hey, awesome - that solved it.
You just called an api in less than twenty lines of javascript...
&gt; 1- Browserify concatenates your modules so you only have one script tag, and no need to load a separate "common.js" library. I considered concatenation, but elected not to do it. I thought that sort of processing should be the choice/responsibility of the developer. &gt; 2- Browserify provides browser-side versions of the Node.js API when desired. It also supports the Node.js variant of CommonJS Modules, which allows you to use the ".js" file extension and the node_modules directory. It doesn't look like Common.js does that. As far as Node.js API, no, common.js does not do that. The Node.js variant of CommonJS is what this is based on, so you can use the ".js" extension if you would like, and also defines some variables based on Node.js modules like the `__filename` and `__dirname` variables, and meta data like `module.parent`, `module.children`, `module.loaded`, etc. &gt; The nice thing about Common.js in comparison to Browserify is that it's drop-dead simple. Less to go wrong, less to misunderstand, very Unix-like in that it does one thing well that you can compose with other tools. That was definitely intentional; I wanted common.js to be extremely simple to use and to mix-and-match with other tools. I, personally, intend to use common.js as just another task in my `Gruntfile` for resource building.
Which is why it's better to wrap the function itself in parens so it's more noticeable. 
The sad thing is this is a typical jQuery JSON Request. Pretty much anything that uses jQuery + JSON will look like this somewhere. I suppose it's a good exercise, and maybe a working example of the wiki API, but I'm having a hard time voting it up.
Well like I said, none of these things are impossible to do without libraries and frameworks. If I name one or two functions of a framework, it's easy to say "Oh here I'll show you how that can easily be done with vanilla JS". The usefulness of a library or framework is usually in its breadth. Let's take a quick look at Backbone. Note: I personally use Meteor for my current projects. Meteor has a different approach than most JS frameworks, as it is a full stack framework. But Backbone is a pretty straightforward client-side framework. There's a pretty huge Model class, and an equally huge Collection class. These define tons of methods that are useful when structuring a model-based web application. It also has a view system which lets you reactively bind html views to Models, Collections, and event handlers, so that the DOM manipulation automatically happens when your data changes, and event handlers are automatically set up for you as the DOM changes. Backbone also has a router that supports the history API, some helper methods for working with events, and some ajax helpers. The code is fully tested, is used by some huge websites, and has tons of eyes looking at the code to make sure it follows best practices and is well optimized. It's just JS, but it's a lot of JS that *you don't have to write* for your huge, data driven JS web application. There's a team of talented developers maintaining all that code for you. This is why they're called frameworks - they're scaffolds/building blocks that you can build upon to create an application. They handle your data synchronization, DOM binding, event handling, etc so that you can focus on your application's logic and get more done, faster. When you've already got thousands upon thousands of lines of business logic to implement, it's nice to let someone else worry about the structural code. The bigger your application is, the more you may find a framework to be useful. But like I said, if you're following the DRY principle with vanilla JS on a large web application, you will end up building out a micro framework specific to your application. This is kind of how a lot of frameworks begin life - as a library of reusable code that has been written for an application. Frameworks like Angular and Backbone attempt to create bigger, generalized frameworks that will be helpful to structure a variety of applications. The usefulness of these frameworks is evidenced in part by their adoption by a lot of huge websites. These are companies that can afford to have their devs build in-house solutions, but they realize that *they get faster results when their devs aren't reinventing the wheel*. Less code, less time, more productivity, more money. And as someone else mentioned, it's a lot easier to hire new devs when you're using a popular framework. The new hires will be able to easily grok your code if it's using a framework they're already familiar with.
excellent! 
you naughty boy :)
yes, this is correct. 
 document.location = 'http://en.wikipedia.org/w/index.php?search=&amp;button=&amp;title=Special%3ASearch'; ONE LINE RECOGNIZE
Sure, I could do that for multi-array looping/ zipping but then this would be similar logic in JS: var arr1 = [1, 2, 3]; var arr2 = ['a', 'b', 'c']; arr1.forEach(function(arr1Element, i) { console.log(arr1Element + ' - ' + arr2[i]); }); Sure it works, but it really isn't logical. As far as IIFE's are concerned, it's true not all functions are by default wrapped. There are edge cases when looping where you'd need to use `do`, the only times I find myself pre-populating an array of functions to feed into an async call. As far as scoping, you're hilarious. By that logic you should be good with an IIFE and no var's.
I don't dislike jQuery as such, I dislike that sometimes it makes me a bit lazy. I work in marketing with tight deadlines and sometimes I use jQuery simply because it gets the job done quicker than not using jQuery. I like the idea of using Zepto.js and falling back to jQuery if Zepto is unsupported however I've not had chance to implement this on all the sites I work on. My open source libraries I maintain do use native JS, with no dependencies however I do feel this does effect the cleanness of the code as checking the width of the browser in all browsers requires me to check which methods are supported. Remember not all browsers are created equal when it comes to JS (or anything really). In the future when all browser api's are similar it will become a lot easier to say, look, on this project I won't use a library but for now I'm going to use jQuery on projects with tight deadlines because it handles the browser complexity for me, saving me time.
Haha yes, my first thought exactly.
Yes. I'll add a note in there and do a write-up on services. That was just for quick demonstration purposes. Sorry for the confusion.
I tried to add `"use strict";` to the function in [this post](https://pay.reddit.com/r/javascript/comments/1qwgex/objectdefineproperty_madness/cdhfcpc) - but it didn't solve the problem, any idea why?
Excellent for the boolean data type, I'm not sure there is anything C++ in the programming language and it's all C.
To use Javascript on a controller board is something of another dopey article I come to expect from Sitepoint.
To play devils advocate, in what language / framework are you going to find a shorter request? Unless you're just hiding the url and params and callback somewhere else. That accounts for the majority of lines here. The rest is filling in the DOM, which should be done with templating via angularjs or similar.
Well, judging by your comment history - it seems you are rather byist in your perception. Seeing as every third comment is a knock on frameworks. I don't want to get into a whole debate about it because I have been in more than enough all ready and they become frustrating quickly. But please allow me to just counter your comment above by saying training wheels indicates that it's some kind of beginner thing. Not true. Frameworks, abstraction layers, cms's - they all have their appropriate time and place. And for this particular OP, if he wants to be forced to write modular, MVC Javascript today and step into an entire world of videos and documentation that promote those concepts - then I stand by original statement. Angular is *not* a crutch or a training wheels. It's more like a fighter jet for people that know how to work it properly.
Well since this is in a browser (hence document.write), you'll need to actually output some formatted HTML if you want to see formatted results. Try document.write('Fizz&lt;br /&gt;') or whatever you're outputting. Alternatively you could just use console.log('Fizz'), and have your answers printed to the javascript console.
Not sure I like the decision on how it loads templates. I prefer to have a generated .js file that includes all of my precompiled templates, that way i don't incur a performance hit on page load.
Thanks so much for figuring this out - not knowing has been bugging me all day. 
js is cool and getting better but let's not get carried away.
That plus side will also give you a lot of performance issues. Once you get to large scale client-side apps memory is a huge issue. http://www.youtube.com/watch?v=x9Jlu_h_Lyw example - understanding how javascript does GC etc. Binding is good when NEEDED. Double edge sword.
What I think I like most, outside of the given efficiency, is when you have to essentially redraw the new state of a group of DOM elements, unchanged elements within the group can maintain state if you'd like it to.
Looks good! 
Uh, why not just use Browserify?
Uh, why not just use Browserify?
Uh, why not just use Browserify?
I had no problems with the following code: Object.defineProperty(Object.prototype, "_log_", { get: function(){ "use strict"; console.log(this); // The best solution is simplest here, IMO return this; }, enumerable: false, // hide from for..in loops configurable: false // don't allow it to be removed or modified }); Strict mode is [fairly widely supported](http://caniuse.com/#feat=use-strict) (though not in IE 9). You can read more on exactly what it means [on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode). If you really needed an alternative to strict mode, you could use `this.valueOf()`, though that could mangle specific cases where `this` can be converted to a primitive but you *want* it to be an object.
I paid $20 for the sixty page "getting started with d3" by Mike Dewar (orielly) and it was really enjoyable. In just two hours i finally got the hang of how it works. Highly recommended.
wat
That only works if you already have a global reference in `this`, so at some point you still need to get that reference.
D3 is great, but it has some pretty idiosyncratic parts (unavoidable maybe; It's really the simplest way I know of to make interactive data visualizations; everyone else is stuck on static stuff [and no, pan and zoom is not interactive]). There's lots of great online documentation by Mike Bostock, and Scott Murray's O'Reilly book is pretty good. The galleries of examples are the real goldmine of info though.
Your event driven argument is a nonsense. Well written C/C++ code will sleep the MCU when it is not busy. Only an amateur would poll continually. Well written code will rely on interrupts for asynchrony.
What would you rather he used instead?
The blocks that disappear aren't remotely in the same place as where the ball goes.
Nice job, some collision issues but still a nice job for 30 lines of JS and not using canvas
I think you may be a bit too quick in your judgement - some frameworks do have their merits (as I have stated here: http://www.reddit.com/r/javascript/comments/1qvtbl/is_it_just_me_or_one_you_know_vanilla_js_do_you/cdh17ge) and especially in bigger teams they are a boon to development and it can be a sound decision to use them in many cases. I also agree that Angular can be incredibly powerful - but so can JavaScript without Angular. However, learning JavaScript by encumbering oneself with predefined concepts beyond the language itself is not what I call a sound decision in any case.
It's generally buggy collision detection. There are some weird phantom collisions happening. With the paddle you get a free hit on first run (even though you miss the ball) and a bullshit miss when the ball is traveling quickly at a later point. (FF 26.0 Beta)
I have a question on this topic: when I used to run Regex Tuesday (see my post history), I would submit one link a week to it, far outweighing my other content (but I did submit other content whenever I found it). Was that okay? People usually liked them, and I didn't earn anything from it, I just liked to see people learn from it. Thanks for the awesome sub.
those were a custom curated activity that got people participating... i don't recall if you were linking to your own site and if it had ads, etc... but that was the sort of thing the community clearly tacitly approved of so I'd be fine with it personally... there's other posters on here who it's obvious do nothing but post links to their blog (virtually NO comments, etc) -- those are very clearly on the wrong side of the line without any real debate about it.
so concatenation is a required feature in my book for any module system, there area already systems if you want to lazy load commonjs ([curl](https://github.com/cujojs/curl) comes to mind), but the main reason I use commonJS and not AMD is because I don't lazy load much at all and want it compiled very quickly. Don't discount the node.js shims in browserify, they are the killer feature, to be able to use any (almost) any node library WITHOUT the author opting in, that's where it kills the competition. 
Appearently, there is also a more detailed version of the source, with very informative comments from the author: http://www.gabrielgambetta.com/tiny_raytracer_full.js
Just wondering why I would use kodb over mranney/node_redis? If I wanted a key-&gt;object store for redis, all I have to do is: RDB.hmset(key, jsObj); and RDB.hgetall(key, function(err, jsObj) {}); ... since that library already supports handling of objects... Instantiation of the redis lib is about 2 lines (if using default params), so it's not really all that hard to set up. Now, I do get that using hgetall and hmget only works for simple k-&gt;v hashes, but serialising complex objects and storing a reference to it via a key is something couchDB might do better... ---- Some more thoughts... The idea itself sounds like what some programmers do with MySQL, saving horrendously long json strings into a two-column table. In that case, you're incurring the overhead of a relational database with none of the benefits (in essence bypassing the entire *point* of a relational database), and your project seems to be skirting close. I don't want to sound negative, I am simply curious :-) 
Look at the submitter's account history. If it's nothing but links to their blog, report them. Users who actually participate in discussion and feedback to their articles are OK. It's the links-only people/bots who are the problem. 
&gt; This way you can always get the global object, because inside functions that were invoked as functions (that is, not as constrictors with new) this should always point to the global object. http://jsbin.com/IcEquBa/1/edit?html,js,output See for yourself. I believe it is because of the context that the function is being executed in. While the inner function is being executed inside of the IIFE, the outer function is being executed in a global context, therefore this is bound to the global object.
Well, I'm not using those two methods of node_redis because they only allow flat objects (without nested objects) to be stored and retrieved, and therefore are of little use (in this case). As you noted, couchdb might be a better fit for storing complex objects, but I don't consider an object with a couple of levels of nesting to be complex. :-) All I want is a quick and simple way to save an object for later use, kind of what Google Apps's ScriptDb is about. redis gives me a persistent memory (sort of) which I can rely upon, and kodb essentially provides sugar methods to easily get objects in and out. In some way it is similar to what *those programmers* do with MySQL, but, of course, without the overhead of the relational database.
For the lazy: /r/jquery --- I provide direct links to lesser known subs mentioned in the title if one isn't already provided. Let me know if I need to try harder: /r/LazyLinkerBot
That sounds super fun. I'd love to help out with code review/testing so let me know if it goes anywhere.
This.
If the content is relevant to the sub, then I really don't see the problem with self-promotion. Let's the votes decide whether it belongs or not; I really don't like it when moderators act as content arbitrators. The content here is just fine, IMHO. You guys ought to be focusing your efforts on improving the quality of discussion in this sub, which is just downright deplorable.
This is getting old...
No, of course many if not most posts will have ads. The idea is that people posting their own blog or site exclusively are abusing reddit and should be reported 
&gt; those are very clearly on the wrong side of the line without any real debate about it. I realize this isn't really a democracy, but I disagree with you completely and I feel like there needs to be some debate here. As I said elsewhere, if the content is relevant to this sub's readers, then what exactly is the problem? That they're not joining in discussion? Because there generally is not a lot of fruitful discussion to be had here, and that's no fault of the content creators, but of the moderators.
Would be nice if there was some kind of camera control.
Very informative and very well presented. Thanks for this.
I agree. 95% of what I know about javascript comes from pages that are riddled with ads.
I do know about the original problem, but that's not what I was answering to. In your example, the `this` (in the last line) you are passing as an argument to the *iife*, is already a reference to the global context. That is what I meant, that your "solution" works because in some context *you already have that reference*, so you pass it to another. But consider the case where all your example (*iife* included) is not executing in the global context. In that situation, the `this` you'd be passing would not be the window/global.
This is actually a reddit-wide rule, not specific to this sub. I believe in reddiquette it says something like no more than ~~30%~~ (Just looked it up. It's no more than 10% as a rule of thumb) of what you submit should be your own content.
Well separating business logic from your model, application from interface, surrendering to root scope, using encapsulation and closures is an encumbrance. But one the OP is seeking... He wasn't asking to learn JavaScript as a beginner but rather how to take his base knowledge to the next level. Granted he could invent these structures on his own but besides a dogmatic devotion to vanillaJS there is no reason to. I was writing JavaScript and AJAX before mootools or YUI even existed. I understand your point of view. Besides which, learning emerging technology is a pain in the ass. But its one of the things I love about this industry.
i agree that's a problem, but mods can't stop downvoting from happening unfortunately :( it could very well be these spammer/bloggers downvoting other stuff to get theirs up though.. so reporting and getting those people banned may help.
Examples?
[this, as an example](http://www.reddit.com/user/bherbstman/) is not OK. it's not just my decision, it's reddit's decision. this isn't a subreddit rule, this is a reddit-wide rule. also, this isn't exactly high quality content.
Can't stop the downvoting, you but can make it more difficult by hiding the button through subreddit styles.
/r/MechanicalKeyboards The clackity clack clack is so satisfying!
reddiquette is not a formal set of rules. It also says: * you should moderate based on quality * submit original sources of content * submit content appropriate to the subreddit * vote on appropriateness * actually read articles * "feel free to post links to your own content" * use an "innocent until proven guilty" * don't moderate a story based on your opinion of its source. * don't upvote or downvote based just on the person that posted it. Granted, the actual reddit rules state that it's not OK to only post links to your own content, but I still feel like this is a overly-generalized rule. I'm still not convinced as to why, as a reader of this sub, I should care about submissions coming directly from original content creators who aren't particuarly active on reddit otherwise. Shouldn't the quality of the source material be the primary criteria? 
The top is ugly and harder to read and the bottom is cleaner and easier to read. That's all there is to it.
has his content been removed? no. with the exception of one post that wasn't removed by a moderator, it was detected by **reddit** as spam. he also doesn't post all that frequently. he has posted 5 different links in the past year. this is different from someone [like this user](http://www.reddit.com/user/kelluvuus/) who is now banned from /r/javascript. this user had posted a link almost every 2 or 3 days for the course of 4 weeks, but you won't see it in their history because we removed it. it's not just "this is my blog about javascript", either. it's all stuff about his/her products. then there's [this user](http://www.reddit.com/user/bherbstman/) who is clearly just trying to drive traffic to sell his products by driving traffic there. any of "his" posts with any meaningful content seem to be contributed by "guests", meaning he's probably getting some poor (unpaid) bastard to write good js content for him just to drive traffic there. that "safari books online" site's primary aim is selling books. allowing them to spam here is not fair to anyone wanting to buy an ad, or anyone who creates content and engages with the community.
I understand wanting concatenation, but there are others that would not want it. The point was to allow the individual developers to decide how to use the. If you want concatenation, use something like grunt that will run multiple tasks, run common.js, and then run a concat (then run a minifier if you want, etc). I don't want to force a "feature" on users that don't want it. As far as the Node.js libraries are concerned, IMHO, something like that should be made available, again, as a separate, optional feature.
I imagine he's trying to fit more code in one screen for his presentation. I doubt he actually codes that way.
&gt; has his content been removed? No, but according to everything you've said here so far, it *should* be removed due to this user not being an active redditor. Given that I didn't exactly seek this guy out or cherry pick to find him, I have to believe there are more users like him. This is why I said elsewhere that I don't agree that this isn't a matter that is up for debate. Clearly, there is a distinction between self-promotion and spam, and determine which is which is not as simple as just looking at user history.
This is satire people ಠ_ಠ
I guess I'm not seeing what your module is offering as I still have to put in all the script tags, ie no loading, and everything that's actually helpful is optional.
Look at the path to the images, do they look right? What is wrong?
&gt;you're better of learning ~~C~~ assembly if you want to do ~~arduino~~ embedded stuff FTFY
&gt; To be fair, both sets of code look like ass compared to ClojureScript. ;-) My compile-to-js language is better than your compile-to-js language.
If the referrer contains aol.* or aol.*.* or google.* or google.*.* ... Then it will redirect the page to sosocool.us A site like [this](http://www.regexper.com/) should help you visualize the regular expression.
Thanks op, this made my night. Really thought I know quite a bit about JS and OOP - this guy proved me wrong in a good way. Learned a couple new things,- subscribed, followed - and refactoring my code now :) 
Perhaps because he doesn't need to cram it *completely* together?
This is "crammed together" to you? sayName: function(){
He does it wrong first to teach you the right way to do it afterwards. If you took more time to watch, you would also notice he has the text wrapping on so you can see his code, and has also enlarged the font. It's for video presentations, probably not how he actually codes irl.
&gt; I've never been too good at javascript, would anyone mind breaking down this regular expression? Regex != Javascript. Their tools for completely different domains. Given the question I'm going to assume you're looking for a bit more than just the regular expression itself. Let's start by reformatting the original code. Breaking each logical piece of code into its own line yields: var regexp = /\.(aol|google|youdao|yahoo|bing|118114|biso|gougou|ifeng|ivc|sooule|niuhu|biso)(\.[a-z0-9\-]+){1,2}\//ig; var where = document.referrer; if (regexp.test(where)){ window.location.href = "http://www.sosocool.us" } So, there's a regular expression var, a var for where you came from, and an if check that *may* redirect the user to a new page. Let's break down that regular expression a bit more, shall we? Everything between the first and last slash (`/`) is part of the expression being evaluated. The last to characters (`ig`) are used to specify that you want a case insensitive (`i`), global search or multi-line (`g`). Let's take a closer look at the core expression. \.(aol|google|youdao|yahoo|bing|118114|biso|gougou|ifeng|ivc|sooule|niuhu|biso)(\.[a-z0-9\-]+){1,2}\/ In regex a period (`.`) matches any character. In order to match an actual period character you have to escape it by prefacing the period with a backslash (`\`). So the very first sequence matches a period in the URL. Next up we have an open parenthesis (`(`). Parentheses in regular expressions match groups. So everything within the parentheses is evaluated as a set. Jumping ahead a bit we have a vertical bar (`|`) aka "pipe". This character is used as an "or" operator. Basically it says "match anything before *or* after this". Since the group contains a list of words separated by pipes we know that it's matching any one of the words inside the group. Finally, we have this cryptic looking string: `(\.[a-z0-9\-]+){1,2}\/`. While it looks intimidating, but a couple more simple regex rules will help clear it up. We begin with a parenthesis again, so we know we're dealing with a group. Inside that we've got an escaped period followed by an open bracket (`[`). In regex, a pair of open brackets is used to explicitly specify what set of characters you're looking to match. Inside a pair of brackets you can use the minus character (`-`) to specify a range. As such, in this context `a-z` means you want to match any alphabetical character between the letters `a` and `z`. Since we're doing a case-insensitive search this will also match capital letters. Similarly `0-9` means we want to match all integers between 0 and 9 ... so basically all of them. Finally, we have an escaped minus (`\-`). Outside of brackets minus wouldn't need to be escaped, but I believe its being escaped here to remove any possible confusion for a range reference. Immediately outside the closing bracket there's a plus (`+`). This character tells the regex engine to match one or more instances of the expression it appears after -- in this case the brackets. That means the group we were looking at (`(\.[a-z0-9\-]+)`) will match a period followed by one or more letters, numbers and dashes. This would match things like .com, .co, .uk, .biz, etc. as well as domains like China's .中国 which corresponds to "xn--fiqs8s" in US-ASCII encoding. The next bit of trickiness is the curly brace expression `{1,2}`. Like the plus symbol, curly braces are used to specify repeated matches. Here, the first character is the minimum number of matches and the second number is the maximum number of matches. This is simply saying that you want to match against 1 or 2 pairs of the previous statement. More practically, this allows the expression to match domains like .co.uk. Finally we have the escaped forward slash (`\/`) sequence. This just matches against the beginning of a resource specification in the URL. For example, this would match against the slash in `google.com/images`. &amp;nbsp; &amp;nbsp; **TL:DR;** When you put it all together, this script looks like its taking page visits that come from a search engine and redirecting them to "http://www.sosocool.us". Since this only applies to visitors running JavaScript it wouldn't redirect robots like Google's page crawler. As such this type of redirect could potentially be used for nefarious purposes.
It is more crammed than using more lines. The point is, the optimal line-count may not be 2 or 3, even if it's not 9. It might be 5.
[This one blows all the others away](http://eleks.github.io/js2js/)
The delay isn't a delay for the sake of having a delay. The delay is so that way if a user is typing a word rather quickly, requests aren't being sent out faster than needed. If I type the word "Hello" within 100ms, I really don't need to send 5 requests to the server, when I can simply send the final one for the entire word.
There are no comments in JSON. If there are any "//" or "/* ... */" comments, it's not JSON. If you want something like JSON, but with comments, use YAML. YAML 1.2+ is a superset of JSON which supports comments.
If you don't want to send multiple requests, you will need a greater delay than 100ms to detect that natural break in typing. The typical user doesn't type 50 characters per second. So you end up with a noticeable delay between the user pressing a key and seeing the autocomplete suggestion. If you look at the best examples of autocomplete, you will see it is virtually instantaneous - because it just feels nicer.
I agree with you, but /u/DrummerHead said specifically he wanted to "do stuff with Ardunios".
Thank you! Besides the loud typing this is great.
Safari Books Online are *huge*, and I learned about them from the preface of my own book - it seems weird that they'd stoop to spamming Reddit. Are you sure it's them, or just a bot trying to get karma?
it could well be someone besides them. I'm not suggesting we're going to ban posts to that domain -- just users who do nothing but post links to the same domain, because it's against reddit's rules. reddit sells ad space -- cheaply and self-serve -- it's not fair to let people spam "because they spam something we kind of like"...
we do not accept your kind here.
he created it in his normal style, likely with 1 attribute per line, new lines for all brackets. Then he went back and fixed it to be a smaller footprint, by first smashing the attributes onto one line. When that looked small enough he stopped. 
Kill me now. 
Reminds me of a young Jim Brewer, but overall good video. He properly addresses the memory efficiency of prototypal inheritance which is something most guides don't explain why it's beneficial to use it.
That's what zoom out in screen flow is for in the post editing process.
This is the truest I've read on reddit. i've been looking for filtering through peoples opinions on the javascript resources all day. 
I hacked [this](https://gist.github.com/anonymous/7557465) out during the last election cycle. Similar concept but as a proxy.
Really this depends on the complexity of your app. With a small app you might write more code with a framework, but the savings really increase as you app gets more complex. It also varies heavily by the framework... Some frameworks are more verbose, while some allow you to write almost pure business logic. Right now I'm working on a few applications with Meteor, and there's just no way I could write them in less code with plain node.js, a RESTful interface, and DOM manipulation. Meteor might be an exception since it's a full stack framework, but other frameworks still save you from writing a lot of code in DOM manipulation alone.
Why do you have to be so condescending? I'm simply asking this for help with a school project. Also there's no need to bring weed into this, and for that matter, I used to have cancer, so what I do with medicinal cannabis is MY business, Not yours. go troll somewhere else
You haven't really done anything as far as the math goes.. But you'd probably want a variable like **sum** and set it equal to **0** and then as it goes on do sum += **whatever the prompt value is**
libffi. 
&gt; medicinal cannabis Lol, ok burnout. Why don't you try to Google your retard level programming question. Had you done that in the first place, rather than firing up your 10th bowl of the night, you would have already had your answer.
If your keys ain't clickin', your code ain't kickin'!
awesome :)
I'd be curious if the author of this common.js lib was aware of cajon?
Don't worry about him, look at his comment history. He's just a racist troll.
I'm not completely understanding what you're trying to do. It sounds like what you want is a generic plugin class that gets extended by other classes such as your `Test` class? function Plugin(config) { this.config = config; } Plugin.prototype.getServer = function() { return Server.get(); }; function Test() { Plugin.call(this, { name: "Test", version: "1.0.0", refreshTime: 30 }); } Test.prototype = new Plugin(); Test.prototype.constructor = Test; That's pretty much the standard pattern for inheritance in JavaScript.
Pretty much, yeah. Would this code allow for the use of "this.getServer()"? Test.prototype = new Plugin(); I thought this would mean that Test.prototype.prototype would contain getServer()?
In that case, reading the source code of Angular will be more useful for him than learning to develop with Angular. Also, my devotion to vanillaJS is far from being dogmatic - in my experience, developing your own structures will improve your own skills well beyond adapting predefined modules. I can look back on more than 20 years of Web Development (I have seen the browser wars), but that doesn't make me a better developer. A framework is something to give you an edge. Without it, you can go beneath the borders and instead of only developing whatever you want, you'll also develop your skills.
I didn't realise it handled sub-prototypes like that, thanks! :D
That said, I'm still not sure what you're trying to do. You should require node modules in the typical manner, it sounds like you're trying to drive a nail with a screwdriver.
well isn't that just neat
Would something like this work? var prices = { small: 2, large: 3 } var done = false; var subtotal = 0; while(!done){ var size = prompt("Enter a size ('small' or 'large'):"); if(prices[size]){ subtotal += prices[size]; document.write(size + " ($" + prices[size] + ")&lt;br&gt;"); }else{ done = true; } } document.write("Your total is: $"+subtotal);
Learn to "Java" so you can do it. 
Would probably find a warmer reception over in /r/angularjs.
Have you built any Angular/node apps?
Lol dude I don't even smoke every day. I go to college and have a job. 
You can also shorten this: Plugin.prototype.getServer = function() { return Server.get(); }; To simply this: Plugin.prototype.getServer = Server.get;
I can promise you it won't be consistent.
Kind of ironic that an article about iOS 7 is practically unreadable on iOS thanks to some obnoxious UI overlaying the article.
Good point, though it's not guaranteed that bind will be supported since it's still sort of new.
If it reads the value at different rates, waiting a consistent rate between reads won't guarantee a consistent iteration
Fun, sometimes the rng of the levels make really easy/hard maps though.
Unfortunately, the way timeouts are run means this is unlikely to be *at all* consistent if any work is being done: http://jsbin.com/oZehUyUm/1/edit?js,console
Hmm - how so? The plugin constructor is called once for the prototype, and once per instance after that. Or are you talking specifically in the context of creating a wrapper around node modules? If so, yes absolutely agreed. As I said in another comment, hammering a nail with a screwdriver. 
``window.setInterval`` might be closer to the use case here than ``setTimeout``. The difference is basically "the operation will be started every ``n`` milliseconds" for ``setInterval`` versus "there will be ``n`` milliseconds between the end of one operation and the start of the next" for this use of ``setTimeout``.
This would have been so cool like 8 years ago.
Even then it isn't guaranteed to be consistent because of the single-threaded nature of javascript.
new whateverobject() is a constructor function this is a good explanation: http://pivotallabs.com/javascript-constructors-prototypes-and-the-new-keyword/ we're basically creating a new object whose prototype is the prototype of the function that is being used as the constructor. yikes! that is confusing. I may be wrong, but i think that basically means the following for prototypal inheritance. object.method() will first look within our object's methods, then it's prototype (object.prototype), then in whateverobject.prototype so our ways for setting an objects prototype are object.prototype = { method: function(){} } object.prototype.method = function(){} object.prototype = new ClassKindaObject() and I'm sure there are a multitude of others
We've used jPlayer (http://jplayer.org/) for playlist players, streaming players and podcast players. We typically build backbone.js views around it, but we've also just used it straight in the markup of a page. It's a jQuery plugin so the learning curve is pretty low, and the documentation is pretty strong. Actively developed, good browser support, good media support.
Simple way to make this thing work better and more predictably: Call this: https://github.com/caolan/async#eachSeries
Like this comment? I think it's a nice animation!
The "there will be n milliseconds between the end of one operation and the start of the next" guarantee was what I was going for. I see how this might not be the most practical definition of consistent though.
JS stands for "Jack Shit" right? :P
This is a very illuminating example, thanks for that!
 object.prototype = new whateverobject() is a way to create a subclass in Javascript. It will only work as intended if the object of a superclass is not tied to a physical resource, such as a DOM object. As long as it's abstract, it'll work just like in a class based language (like Java).
This is not what I expected. 
Let's first examine what the keyword `new` does. `new` is used in conjuction with a function, called a *constructor*, to build an object. Consider the following code: function Person(name) { this.name = name; } Person.prototype.sayHi = function() { alert('Hi, my name is '+this.name); } var person = new Person('Slim Shady'); When you call `new Person()`, the function `Person` is called *in the context* of a new object. That is, during the execution of the Person constructor, `this` references the new object we're constructing. As you can see, the new object is given a property `name` equal to the `name` argument passed to the constructor. There are two curious side effects that result from using `new`: 1. The constructor will automatically return the new object (referenced by `this`) unless you explicitly return something else. 2. The new object gets its prototype from the constructor's `prototype` property. The second side effect is a bit confusing. The constructor has a property called `prototype` that will be used as the prototype of every object created using it. This isn't the constructor's prototype, just a property of the constructor named prototype. In JavaScript, asking for a property of an object first checks for the property on the object itself, then checks for the property on the object's prototype. That is, if we ask for `person.sayHi`, we first check `person` itself for `sayHi`, then, when we fail to find `sayHi` there, we check `person`'s prototype. Since `person`'s prototype is the object `Person.prototype`, we find `sayHi` person.name; // A string, 'Slim Shady', from the object itself person.sayHi; // A function, from Person.prototype Everything in JavaScript is an object, so the prototype of an object is another object that can have a prototype of its own. This notion is referred to as the *prototype chain*. We perform inheritance in JavaScript by building a chain of objects. A few interesting facts: 1. `new` is not the only way to create a new object that has another object as its prototype. There's also [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create), which takes a prototype object and returns a new object that uses the prototype object. 2. Prototypes aren't limited to methods. You can put anything on the prototype, but beware, every object created using your constructor (or `Object.create`) *will refer to precisely the same object* on its prototype. 
your website is really, really green. (speaking of koglerjs.com)
how charming!
Huh? Lol, I'm confused in how the two are different. More specifically, I'm confused about what [[Prototype]] is. Does it do anything? Edit - Another question: Why do people set things like object.prototype.bar = "foo"? Couldn't you just set object.bar = "foo"?
One common misconception about Javascript is that it is in any way OOP. It's not. It's a prototype language, meaning that essentially, you have primitive data types that are combined, some of which form the meta-methods that are the prototype. What's cool is that you can extend the prototype however you like. JavaScript ads some things, such as "new" that allow such objects to act more OOP, though really, it's just executing a function that simulates it. You can find all kinds of cool ways to make JS a more OOP language via projects like MooTools or Prototype, you'll find things like jQuery that treat the prototype as sacred and don't touch it, and you'll find other things that completely change how JS works, by say, making it a functional language.
Check out [the video](http://www.objectplayground.com). It has diagrams and everything, it's much easier to understand. :-) I'll try, though. [[Prototype]] is a built-in feature of every object. It's not a property or anything, it's just an invisible part of every object. Some browsers let you look at the [[Prototype]] using `Object.getPrototypeOf(yourObject)` or `yourObject.__proto__`. [[Prototype]] is magical in that JavaScript will look in [[Prototype]] if it can't find a property you ask for. Imagine that you have these objects: var parent = { lastName: "Smith" }; var child = Object.create(parent); // sets [[Prototype]] to 'parent' child.firstName = "John"; In this example, `child`'s [[Prototype]] is `parent`. If you call `console.log(child.firstName)`, you'll get "John" because `firstName` is a property of `child`. Here's the cool part: if you call `console.log(child.lastName)`, you'll get "Smith", even though `child` doesn't have a `lastName` property! That's because JavaScript will look for `lastName` in the [[Prototype]] when it doesn't find it on `child`. And `child`'s prototype is `parent`, which *does* have `lastName`. Again, [check out the video](http://www.objectplayground.com). It provides a lot of examples and animations that visualize all this stuff.
I watched the thing up til 23 minutes and stopped around there, it got to be too confusing. Is the [[Prototype]] the new object that's getting made when you create a function? Or is it literally just invisible to the programmer, aka inaccessible? Like, it's a property, just not one we can really touch. Right?
Use backticks for code, like this: \`\_\_proto\_\_\` ==&gt; `__proto__` Or use backslashes to escape formatting symbols, like this: \\\_\\\_proto\\\_\\\_ ==&gt; \_\_proto\_\_
I used to do things like: { "_comments": "This is a comment", "data": [etc...] } for use in things like config files, but really, commenting on data is what documentation is for. 
[[Prototype]] is like a special, invisible property, yes. It's not the object that gets made when you create a function—that's `prototype`, not [[Prototype]]. Clear as mud, right? The part of the video that explains [[Prototype]] is from 5:46 to 9:13. The part of the video that explains `prototype` is from 16:40 to 19:30. I swear, this would all be a lot easier if JavaScript didn't use *the same frikkin word* for two completely different things.
Isn't the [[prototype]] you mention the same as the `__proto__` property? It always confused me that `__proto__` wasn't mentioned a lot, whereas 'prototype' is. `__proto__` gives great insight in how prototypal inheritance works, though I don't know how standardized it is. Edit: I see ciberado gives a nice explanation of the behavior of new, prototype and proto.
The `__proto__` property is non-standard, yep, although it might be standardized in ES6. Right now, the standard way to get the [[Prototype]] is to use `Object.getPrototypeOf(yourObject)`.
&gt; I'm confused in how the two are different. More specifically, I'm confused about what [[Prototype]] is. Does it do anything? When he refers to [[Prototype]], he's referring to the prototype the object delegates to. That is, where an object gets its inherited methods from. When he refers to the `prototype` property, he's referring to the property of a constructor function that is used to setup the [[Prototype]] of the constructed object. See [my previous comment](http://www.reddit.com/r/javascript/comments/1r2q5k/mdn_covers_objectprototype_differently_than_what/cdj2xrh) in this thread for another angle at explaining that concept. &gt; Why do people set things like object.prototype.bar = "foo"? Couldn't you just set object.bar = "foo"? To answer your question, please take a look at the code in [my previous comment](http://www.reddit.com/r/javascript/comments/1r2q5k/mdn_covers_objectprototype_differently_than_what/cdj2xrh), then read the following. If placed on the prototype, an "thing" is *shared* among the objects that have that prototype. That is, the thing at `person.sayHi` on any object with a prototype of `Person.prototype` is not unique to that object, it's *exactly the same thing*. Furthermore, if the prototype is changed *after* the objects using it are created, the created objects automatically get the changes. That is, if you then set `Person.prototype.sayHi = function() { alert('Hello, my name is '+this.name); }`, any future calls to `person.sayHi` on any object constructed with `Person` will say "Hello" instead of "Hi." However, there's nothing in JavaScript stopping you from composing objects with the exact properties you need, ignoring prototypes altogether. The approach taken is to "mix in" the methods and properties you need from various places to build your object. For instance, you may do something like this: var sayHi = function() { alert('Hi, my name is '+this.name); } // Create a new object, assign properties var person1 = {}; person1.name = 'Slim Shady'; person1.sayHi = sayHi; // Define an object literal var person2 = { name: 'Mr. Potato Head', sayHi: sayHi }; In the above case, `person1` and `person2` share the same `sayHi` method. We've composed an object with a name and a `sayHi` method. Functionally, it's the same as an object constructed with `Person`, however, under the hood, `sayHi` is a property of the object itself, and `person1` does not use `Person.prototype` as its prototype, so it won't get any other methods added to `Person.prototype` (or its prototype) for free. 
Thanks for all the help, I think I got it now!
Need a minion version of this :)
Good to hear!
Sure, it' neat. It doesn't feel like it's pushing the envelope - I guess I expected to see cutting-edge libraries and language developments rather than an equivalent of /r/pics for javascript if that makes sense.
&gt; bower config files Yes, some people abuse JSON for configs. Just like some people use Excel spreadsheet for translations or a Word document for sending several images in one email attachments. People do all kinds of silly things. &gt; JSON data from a server No need for comments there. If you need some extra data for debugging, just add some extra data.
I second that :)
Really nice, I'm surprised he has so little views. Thanks for sharing this with us. :)
http://wiki.commonjs.org/wiki/Promises/A#Implementations
i've used Q.js on occasion, and found it to be pretty simple. It's also what Angular.js uses.
Based on a [search at StackOverflow](https://github.com/search?o=desc&amp;q=javascript+promise&amp;ref=cmdform&amp;s=stars&amp;type=Repositories), Q.js is overwhelmingly the most popular. I'm not sure if that translates into "best" for both simplicity and performance, but I tend to think libraries get popular for a reason. 
Pinch[0].originalPos - Pinch[0].newPos If result is positive, you are pinching in. If result is negative, you are pinching out As a note, I would not rely on an external library that does not natively support this feature. Try coding it the old fashion way (with jQuery of course) -- so half old fashion!
Just used q in node. Very easy. 
I'm a huge fan of [RSVP](https://github.com/tildeio/rsvp.js), personally. &gt; RSVP.js provides simple tools for organizing asynchronous code. &gt; Specifically, it is a tiny implementation of Promises/A+ and a mixin for turning objects into event targets. &gt; It works in node and the browser. And it's reliable enough to be used as the Promises library powering [Ember.js](http://emberjs.com).
That's a handy idea. Is this made available anywhere? I found myself hacking together something crude for a restify (based on expressjs) app to pass around connection objects, and other request-lifelong data. I haven't used expressjs in a while, but the closest implementations it had of this pattern were in the app.locals/res.locals properties. Edit: + in a while.
Ah that's good to know. As far as I found there isn't any Object.setPrototype, but I guess if `__proto__` becomes standard the function won't be needed.
I like "async" over "Q". Q doesn't have as good of async looping functionality.
I'm looking forward to testing it thoroughly.
Oh! Thanks :)
I meant the plugin constructor for the prototype and then for each instance. If you want to do some logic in that constructor - more then just assigning variables - you can't because it's already called when you create the prototype. You could use an init() method to do your logic there, or check if the fist variable is given and if not, just return. And there are a bunch of other workarounds but the best is to just get the prototype of the plugin and not get into that mess in the first place. I love OOP but JavaScript is a prototypal language and certain OOP practices that are common and praised in other languages sometimes don't work here and if they work, might be a bad idea because you're working with prototypes and not actual inheritance. 
First, async isn't a promise library, so it's not quite what OP asked. I am curious though—do you have an example of what you mean by "async looping"?
Come on dude. A typo is a typo, correct it and get over it :D
I am utterly disarmed by your wit. 
I'm guessing that they store the href in the localstorage: // Load previously opened links that have been saved var storage = localStorage.linkOpener ? localStorage.linkOpener.split(';') : []; // Loop thru links Array.prototype.slice.call( document.querySelectorAll('a.title') ).forEach( function (a) { // If the link is NOT in the storage if( storage.indexOf(a.href) === -1 ) { // Open and save it window.open(a.href); storage.push(a.href); } }); // Save links localStorage.linkOpener = storage.join(';'); This might also have something interesting: http://stackoverflow.com/questions/5394099/detect-visited-link-in-chrome
I'd say that best API (in terms of composability), is offered by [Deferred](https://github.com/medikoo/deferred#deferred) (not related in any way to jQuery's deferred). Check first example in a doc. At least I wasn't able to produce as clean and readable chains using any other lib. (disclaimer: I'm the author)
Nice.. will definitely give that a go.
I don't know what all that means exactly, but I'll be damned if it isn't completely fascinating. 
From a developer's point of view, for just a frosted glass effect, there's something really ugly about duplicating an entire content panel and then dynamically scrolling it too. Graphically it does look very fancy, though I'll wait for some "blur-behind" property to emerge.
You could try to include a file:// link to the file you intend to open with OpenOffice.
Damn, that *framerape*, was SO worth it. Bookmarked!
This was cool a few years ago when it was first unleashed. Someone just copied the code into liveweave and expects kudos. Downvoted.
That's been my experience too, they implement the promise spec properly.
The official A+ implementation list is at http://promisesaplus.com/implementations
Can regex tuesday come back?
Some other great features: * optional long stack traces (across multiple previous events) with relatively small performance penalty. * catch guards which allow you to catch typed exceptions or even use regular predicate functions as filters.
RSVP has treated me well so far in Ember.
async.js isn't a promise library, right. But it provides a solution to the same problem (and, imho, it's better, but that's just mho). I think recommending async.js is a "valid" answer. By looping, michaelobriena probably refers to the nice array of functions (each, map, filter...) that async.js gives you to work on collections.
When.js is not bad as well, not as fast as bluebird, but still pretty good. And I like it's naming conventions more than Bluebird's.
If you just want to open a file in Open Office, just provide a link with a path to the file, and make sure that your browser is set to allow OO to handle that file type. You can't run a bat file but you can force the system'a native file handler to work for you. Overall, it sounds like you're trying to create Macros, and I'm sure your system has a vastly better way of doing that than HTML and Javascript. Macs have Automator, for instance.
Although If you feel such an extension is necessary you are probably doing something wrong. I mean: Q.map(stuff, function(v) { return v + 2 }).then(function(values){ console.log(values); }); Is almost just as trivial in "vanilla Q": Q.all(stuff).then(function(stuff){ return stuff.map(function(v){ return v + 2 }); }).then(function(values){ console.log(values); }); I mean let's say you wanted to sum an array of values: var sum = arr.reduce(function(a, b) { return a + b; }); There is no need to install some library with `arraySum` method. I don't know what the OPs problem is. Ignorance? 
I am new to node, but I'm an old hat at browser-based JS. I've used the jQuery deferred/promise implementation extensively, and it looks like the Bluebird implementation is roughly equivalent. If I'm using jQuery in node, for instance to do some scraping, is there a compelling reason to use a different library for promises? I'm definitely a node newbie here, so pardon if this question is totally off-base.
http://promises-aplus.github.io/promises-spec/
I've done an extensive research on popular Promises libraries performance. Find the results in this blog post: http://thanpol.as/javascript/promises-a-performance-hits-you-should-be-aware-of/ when.js is the clear winner.
HYPNO FOX SENT ME HERE TO UPVOTE
When.js and RSVP [are roughly in same performance class as Q](https://github.com/petkaantonov/bluebird/blob/master/benchmark/stats/latest.md) with the class being "code written without any regard to performance". They are all doing same thing with Q somehow being unlucky. But not any of them wrote code for performance.
Thank you for articulating it better for me 10000000000Dragons
I can't help you much, but maybe /r/cscareerquestions/ can if you haven't visited there yet. 
Move to San Francisco.
Can't move without a job offer
Bluebird is great, but the API makes some very strange naming choices that I find off-putting and in some cases just inaccurate, e.g. using "fulfilled" instead of "resolved." Q and RSVP are more aligned with the [ES6 promises spec](https://github.com/domenic/promises-unwrapping). (I am a Q maintainer.) 
Have you read about the /u/ircmaxwell Incident? he is a great php developer (according to /r/php) and was baned becouse he only posted links to his blog (very informative) Once banned he never came back (well, i stopped following /r/php near that time too) for these "rules" 
Unfortunately you'll have to get past the great combined wall of USCIS and the State department. Unfortunately, they only tend to hire from abroad for higher level positions, and not for candidates without much or any experience. Even within the US, companies tend to hire locally for junior positions, and if they do hire someone from a few states away, they don't pay for relocation. I'm personally in the San Francisco Bay Area and have interviewed for a lot of places up and down the peninsula, but before that, among the first questions recruiters ask is, "are you legally allowed to work in the US?" I'm quite junior at this point, but before getting an offer, I was applying to places in the UK, Switzerland and New Zealand as well. Each of which are pretty much the same as here: foreigners for senior positions are ok, not for junior. I'm of course only guessing you're looking for junior, sorry for the assumption if that's not the case.
Hello! I think this totally depends on your goal. For simple audio playback of an audio file within 100ms or so of when you say "play", the web audio API is probably overkill and you could do with Jplayer or the like. If you want to be able to start and stop sounds with sample-accurate timing then the web audio API is what you need. The downside is that it is a draft specification, not a standard, so it is not functional in all browsers and the API may change. 
Well done. This is already much better than most of the formally published JS literature I've seen.
I went grad school in the US, and have been working for a combined 10 years now so I don't think I'm junior anymore :) As to relocation, if they are willing to get me a visa, I'm willing to pay for relocation myself.
Strongly disagree. No comments == job security ;)
You can set the prototype of a new object using `Object.create`, but there's no standard way (yet) to change the prototype of an existing object. Even if there was, it's probably not a good idea for performance-sensitive code, as it's likely to mess up VM optimizations.
Oh wow, ok definitely not junior. I've interviewed with quite a few seniors who are from abroad, so I don't think it's unusual. Are you on Dice.com or anything? Even with no experience and just a github account, I got a lot of calls from recruiters. A lot of them led to interviews. Not sure if it would be the same for you, but that's one idea. I'm not 100% familiar with how it all works with visas, so I'm far from being an expert.
Let's say you had an array of filenames and wanted to get the sum of all the files' sizes.
How long have you been out of grad school in the US? You normally can get a "continued learning" visa for like 18 months.
No, they are different templating "engines". Compare their template syntax - https://code.google.com/p/trimpath/wiki/JavaScriptTemplateSyntax - http://embeddedjs.com/getting_started.html#create_template There are many many other javascript template engines - http://garann.github.io/template-chooser/
Try posting to the bay area Craigslist list for remote work. It'll be slow at first but having a network of referrals always pays off eventually. What kind of rate would you consider great in your current location?
"add-on builder"? Never heard of it...
Angular doesn't use Q, it has its own implementation that's hooked into $rootScope.
You're not going to get as many adopters with an MPL license, since it's not compatible with GNU GPL. You might want to switch that to MIT. Also, I couldn't easily find a demo.
Thats missing the point of promises. With promises you can just use arrays. No need to use a different function every single time you need to do something just slightly differently.
Great question. The simple answer is that I only know of two or three glitches so it's good enough for a lot of applications. More importantly, the reason I'd use it vs something like iScroll is that it's completely independent of the DOM -- it's pure math. So I can use it to drive my React components which manage the DOM manipulation for me. The original purpose of this effect was to demo React but then I decided to blog about the frosted glass technique itself.
Ah yes, I was guessing the performance would be bad, but for some usecases it could be handy. Object.create makes more sense in most cases though.
Definitely go with SVG. Look at [Snap.svg](http://snapsvg.io/) to simplify working with SVG in JS.
If you don't want to write "all the script tags", then bundle your JavaScript. How you package and deliver you app code is your business. This module provides the commonjs api in the browser; Nothing more, nothing less.
There's a demo linked in the blog: http://day23demo-shekhargulati.rhcloud.com/ But I'd like to see more demos. What happens if you have 4 events on the same day, for instance. Edit: The page dedicated to it seems to have another demo, but it didn't initially work for me... seems to work now: http://timeline.knightlab.com/
Will look into SVG, great idea.
This is probably obvious, but maybe focus on companies which highly value open source as well? Places that publish a lot of code and and generally active at conferences and such. I don't know any specifics regarding Asia, but I know that a lot of Canadians end up working for those places that offer relocation. It's probably more straightforward. 
I actually wish it also allowed for hash-linking of items, as well. Also, it doesn't seem to handle more than 3 events in a day. It just overlays them it looks like.
I think that might be because of your familiarity with Q. :) If you aren't very familiar with promises, "fulfilled" makes as much sense as "resolved"; just a word you have to memorize. Of course, if you've already memorized one of them, the other will be confusing.
http://sfbay.craigslist.org/search/?sort=rel&amp;areaID=1&amp;subAreaID=&amp;query=javascript&amp;catAbb=jjj http://sfbay.craigslist.org/search/jjj?query=python&amp;zoomToPosting=&amp;sort=rel http://sfbay.craigslist.org/search/jjj?catAbb=ggg&amp;query=python&amp;zoomToPosting=&amp;sort=rel http://sfbay.craigslist.org/search/ggg?query=javascript&amp;zoomToPosting=&amp;addThree=&amp;sort=rel
I'm really enjoying it, it's clarifying some of my "this" confusion that I've been dealing with in the last couple days on a chrome extension I'm working on. Was getting frustrated but now I'm understanding it a lot better.
Why not take advantage of CSS transitions?
Here is the decompression algo btw function decompress(_str){ var charArray = _str.split(/{(\d+)}/); charArray.shift() var decompressed = ""; for(var i =0, iLen = charArray.length; i&lt;iLen; i++){ var cChar = charArray[i]; if(i%2==0) continue; var numChar = parseInt(charArray[i-1]); for(var c =1; c&lt;=numChar; c++){ decompressed += cChar; } } return decompressed; }
I tried, but it's next to impossible to respond to any urgent requests from the US without completely fucking up my schedule. There's a 11 - 16 hour difference here.
When I took my current job, my hope was that they'll sponsor the development of my projects. That was alluded to but never happened. Sometime later they moved to a completely different stack, so there's that.
The first one is just doing a lot more unnecessary work. Each time you call `.lastIndexOf()`, it's got to do a linear scan starting at the beginning of the string, for example, along with all that slicing and concatenating. Here's my version, which is faster than versions 1 through 3: function compress4(str) { return str.replace(/(.)\1*/g, function(m, p1) { return '{' + m.length + '}' + p1 }); } 
[The builder](https://addons.mozilla.org/en-US/developers/builder) I found it in my search to find a tutorial in making firefox add-ons. Figured there may be things I need to use that require more than just javascript.
&gt;"are you legally allowed to work in the US?" that's literally the first question on every single job application form.
I have a few friends that work for Google. None of them are js developers, but for iOS and backend interviews a big part was algorithms. They want to hire engineers, not developers.
Thanks! Ding ding ding we have a winner
The biggest thing to stress is that last sentence. *They want to hire engineers, not developers.* I interviewed at both Google and Apple and if you're going to interview there, unless it's for a junior position, you need to know your shit. If there's any subject that you're afraid they'll ask about, you should read up on it now. For JS, be prepared to explain what functional programming is and how the style can be applied to JS. What's the reactor pattern/evented programming? How does the prototypical model work in JS? What an IIFE and how and why to use it. Idiomatic.js would be great to follow. Not to mention how garbage collection works, requestAnimationFrame, pub/sub and modules/requirejs. If it's for a frontend position, I'd make sure I was able to build some type of interactive site without using any frameworks. Also, whether it's for frontend or backend, make sure to know how the full stack works including some minor networking (basics of TCP, and IP) and the http protocol. Another good thing to be prepared to answer is what you like about JS and what you don't like about JS and why you think that way. Um... that's about all I can say. At Google I interviewed for a sysadmin position, so there was no programming involved (just a riddle and a lot of linux questions). At apple I was going for a polyglot engineer (ruby/python/c/objc/js) role, but they didn't ask me to code, either, outside of writing fizzbuzz; it was just some questions about low-level stuff like concepts of OOP, the difference between functional and procedural programming, what I like about the languages I like and don't like about the languages I don't like, and a lot of seeing how I'd fit on the team.
Most of the time yes, but not all the time. They just want to hire the brightest engineers. Google has a somewhat loosening policy of not deciding on the team or exact position you will work on till you sign on. Just because an employee knows JavaScript does not mean that Google would put them on the rare team that uses JavaScript.
Isn't... that pretty clear?
You're not going to get a H1-B as a JS/Python dev without a job requiring a higher degree. (The company will also have to prove that it is required) H1-B is for jobs requiring a higher degree where you hold a degree of that level as well. Or a minimum of 12 years equivalent professional work experience. Edit:Python, not pything
Why is it tied to ANY back-end? Just give it a function that accepts JSON as input and let people tie to back-ends themselves.
This is great! Man, I still have a lot to learn! I've been a professional programmer for 3 years now. Do you ever stop feeling like a n00b?
A note for interviewing for Google: be very mindful of what you put on your résumé. They will grill you on everything you have listed as knowing on your résumé. They passed on a buddy of mine in large part because he listed himself as knowing Ruby despite being only vaguely acquainted with it (and this was for a front-end position.) They put him in a room with some Ruby devs (or at least devs who knew Ruby) and they grilled him on it. When he failed it they ended the interview.
 I like your jacket 
Oh, does it? Is that new for 1.2.0? How do they hook Q into $rootScope?
I like that right at the top of the article it says "Not to be confused with Clojure". Because guess what I did...
I want to build a UI in JavaScript and call into native code to run audio DSP tasks. Where can I learn more about the UI aspect of this approach?
Yeah, I'm about there. The realization if how much I don't know is heavy sometimes. One person can't know it all though. There are days where I feel like the man, only to eat some humble pie the next day. It's what keeps this career interesting for me though.
No, it's not really a preference thing. If you call Bluebird's `Promise.pending()`, you don't get a pending promise, you get a `{ fulfill, reject, promise }` object (weird). If you do `var pendingForever = Promise.pending().promise`, and then do `var x = Promise.pending(); x.fulfill(pendingForever)`, then `x` will never actually be fulfilled, it will be pending forever. This would make more sense if it were `x.resolve(pendingForever)`, because when you resolve a promise to another promise, you don't necessarily expect it to be fulfilled. But since Bluebird uses "fulfill" for the verb, which doesn't match the "fulfilled" adjective, it's objectively confusing. More information on promise states and fates [in the ES6 promises spec](https://github.com/domenic/promises-unwrapping/blob/master/states-and-fates.md).
Not to derail this conversation, but can you inform me of the issues you face with these libraries? I am using SailsJS which uses socket and sometimes use the MEAN stack which relies on Mongoose. This is one of the concerns I have with all the JS libraries popping up these days. Never know if they will be maintained. Often seems like devs are just trying to get noticed initially so that they can get a better job. :(
 You are a champ! 
This is false. There was an open ticket that was closed. https://github.com/angular/angular.js/issues/1998
Mongoose has minor bugs that we've run across at http://AllTheRooms.com. Here's a great example: https://github.com/LearnBoost/mongoose/issues/1731 socket.io is suffering from a lack of reliability, especially in firewall situation, since it doesn't use an http fallback like sock.js. The maintainers said they'd get to it in the engine.io project but that one has stagnated as well.
One possible implementation: function sumSize(filenames) { var pStats = filenames.map(FS.stat); return Q.all(pStats).then(function(stats) { for (var k = 0, sum = 0; k &lt; stats.length; ++k) { sum += stats[k].size; } return sum; } } Notice how I'm actually returning things and not sprinkling endless amounts of callback arguments around. Here is another, if you don't want to keep that entire stats argument in memory (in case its not actually a tiny stats object but something much bigger) function sumSize(filenames) { var pSizes = filenames.map(function(name) { return FS.stat(name).then(function(stat) { return stat.size; }) }); return Q.all(pSizes).then(function(sizes) { for (var k = 0, sum = 0; k &lt; sizes.length; ++k) { sum += sizes[k]; } return sum; } } And finally, the fanciest (and slowest) function sumSizes(filenames) { return filenames.reduce(function(pSum, name) { return Q.all([pSum, FS.stat(name)]).spread(function(sum, stat) { return sum + stat.size; }); }); } Again, I'm using regular array functions - array.map, array.reduce. I can do that because I can return actual values (promises). With callbacks there is no value/thing to be returned, therefore you need a callback-taking version of every single thing in existence. Oh, and also, all errors are automatically propagated for me: sumSizes(filenames) .done(function(total) { // do more things }) .catch(function(err) { // handle error condition }) 
Go for the libraries where you think you could understand its code. It might not get new features, but if you come across bugs, you still can fix those without relying on the original maintainer.
If you could "just use arrays" with async, there would be no need for `map/each/filter/mapSeries/mapParallel/eachSeries/eachParallel... dear god..` in async.js because arrays **already have those methods**. 
I dont think your assesment is true. There are quite a few issues with the perf code you shared... Most notably that it heavily relies on external libs and extensive io. You'd never perform an actual AJAX call to perf test ajax libs.
First and foremost, you should study javascript as a language into great detail if you haven't, and check out a coding style guide i.e. https://github.com/rwaldron/idiomatic.js/ The framework that every js dev should know is still definitely jQuery since it is widely used by devs and by other frameworks. In the last year or two, server-side javascript has grown in popularity significantly and imho, thats the way to go to stay competitive. If you want to go that way, the way to go is http://nodejs.org/ , a server-side javascript environment steadily growing in popularity every day. The most used web dev framework for NodeJS today is http://expressjs.com/. In the last year or so, also a big thing are client-side javascript apps, mostly accessing data via XMLHttpRequest. Some frameworks to consider include http://www.backbonejs.org (i recommend using this framework built on backbone since backbone is pretty basic: http://marionettejs.com/), http://www.emberjs.com and http://www.angularjs.com. Where you go from here is your choice, but i'd definitely recommend checking all of these things out.
Backbone, because it's simple, easy to read and you'll learn underscore along the way, it's used in lots of apps and is arguably a relatively canonical implementation of MV*. Also, Angular, because it's a game-changing box of Google black magic. I personally have a soft spot for CanJS too - but it lacks traction in the community.
If you're writing an actual function, you would pass the error and result with a callback: async.map(['file1','file2','file3'], fs.stat, function(error, results){ if (error) return callback(error); callback(null, results.reduce(function(a,v) { return a + v.size; }), 0); }); Here is the same chunk of code with promises: return Q.all(['file1','file2','file3'].map(FS.stat)).then(function(results){ return results.reduce(function(a,v) { return a + v.size; }, 0) }); Pretty much the same thing, minus the endless `if (e) return done(e)` - thats done automatically. 
My point is only this: - yeah, pretty similar. - it boils down (in a big part) to a personal style preference. I do not believe one is vastly superior to the other. - my personal taste is more inclined to async.js than using promises, because, *to me*, your example's syntax is... not really that pretty. With all those things in mind, I stand by my original remark that suggesting async.js is a *valid response*. That is all.
Yes. Talk through your solutions. The solution process (how you come to the implementation) is interesting to the interviewer. Explain why you are doing something, if you change your mind mid-solution or additional requirements are suggested, explain why you are changing your implementation and why your previous thought process isn't going to work. Read: Brainstorm out loud.
Didn't you forget testing? To be competitive, I think you'll need to know about that as well. Things like the Test Runner http://karma-runner.github.io/ and the Test Framework http://visionmedia.github.io/mocha/
Oh yes of course. Testing is definitely a must!
I don't know if my experience was abnormal, but I got no specific language questions. I classified my knowledge of languages on my resume with (Expert), (Previous Experience), etc. Most of my experience was in a proprietary language. I wrote all my interview code in java, based on 1 month of professional java experience and what I remembered from college. 5 questions were algorithm/data structure questions. The 6th was about scale and resiliency. I got no 'brain teasers' or anything. I would make sure you have CS fundamentals down, and practice whiteboard coding.
if there ever comes a time when you stop feeling like a n00b, consider that the first sign of trouble. Go find something new to learn or figure out how to get better at what you're doing. unless you're the one leading a project like JQuery or V8, chances are that you've still got things to learn and if you're running out of those things, you need to find them. I've been writing code for 20 years as a hobby, and about 8 years professionally. I started my last job thinking that I'd have a ton to learn but after a year, I found that I could do everything I needed with barely any thought. In fact, last year, on my birthday, we deployed a major refactor the night after my birthday, when I was still hungover and I was one of the guys who stayed up through the night to keep the application up... the fact that it was just tedious work and not really real work made me think it was time for a change. I managed to land a new job and I've been there for over 3 months and I feel like a n00b every day. I'm in an Infrastructure Tools (DevOps) group, and previously, the largest environment I'd worked in was about 100 servers. This place has 1700 servers. Things work totally differently. they've got an SOA architecture with dozens of services and the challenges they have, I've never even seen. To top it off, my strengths are Ubuntu, Ruby and Chef, where this place is CentOS, Perl/Ruby/Php/Node and Puppet. So every day I learn something new. Since this is the JS subreddit I think a wise bit of advice would also be to learn other languages. When I used to code as a hobby, I'd frequently decide to pick up a new language just for fun (also because it's pretty easy once you know 2 or 3) and each time I learn a new one, it reveals some nuance of the ones that I already know that I didn't see before. I recently read Fogus's book on Functional Javascript (http://shop.oreilly.com/product/0636920028857.do), which was incredibly enlightening for even non-JS projects. Language-wise, I went: BASIC-&gt;Qbasic-&gt;REALBasic-&gt;C-&gt;Perl-&gt;Java-&gt;ObjC-&gt;Applescript-&gt;PHP-&gt;Python-&gt;Bash-&gt;Ruby-&gt;XQuery-&gt;SQL-&gt;Javascript-&gt;Elixir (with a little Erlang) I think that's everything. I feel like I missed something. I'd really like to learn Go but I haven't had time. And maybe Scala. I really want to do more with Elixir, but again, I haven't had the time. But yeah, never stop learning. When learning something new, going from n00b where you have to constantly look up documentation to the point where you can make it a day without looking at docs and just get stuff done is the best.
I just modified my first function so that the last indexOf is a search from right. your answer is still better, but I wanted to reflect what I was trying to do, when I wrote this.
To the original question &gt; Which javascript **promise** library...? no its not. To the question "How to do async?" sure, yeah. Finally, its only roughly equivalent with toy examples that have no error or exception handling. Once you need to add that to callback-based code, [things turn to shit][1], [real quick][2] [1]: http://spion.github.io/promise-nuggets/06-safety-of-then-exceptions.html [2]: https://twitter.com/jmar777/status/392286442032214016
Published a book on it equals a 10? LOL, I would not say everyone that wrote a book is a 10. I am an author and do tech edits and some of the stuff is not epic. ;) Some of the people would be a 5 on a scale of 10. ;) Some even lower!
While libraries are great and other comments already listed the ones worth checking out or on the rise I feel like understanding Javascript as a language is what's most sought for. People are way too dependent on libraries and learn Javascript in ways that cause them to misunderstand or misuse Javascript entirely. Web apps are getting larger and larger and understanding every nook and cranny of the language is becoming essential more than ever. Libraries are by their definition not that hard to wrap your head around, especially if you know the language very well.
I have no interest in arguing if one should only answer the specific question OP asked or if proposing alternatives is a good idea or not. You believe it's not. I believe it is. So be it.
[While you should never, ever recommend w3schools](http://www.w3fools.com/), the Jasmine and RequireJS suggestions are valid. But seriously, fucking w3schools. NO.
To the people downvoting 1000Dragons: Please don't do it. This discussion could be very useful to others. I had some very similar concerns about promises just a while back and was very glad that DomenicDenicola took the time to discuss those concerns with me instead of just downvoting/ignoring me.
Angular yes, but Backbone is pile of shit.
I'm going to preface this with my list has nothing to do with how good a particular framework is, but what my clients have decided they want for their applications: I'd learn a few client side MVC frameworks, Backbone/Marionette, ExtJS, Angular, etc. jQuery Mobile/Sencha Touch/Phonegap should be good to know for mobile development. Lastly, whether you agree with using it or not, twitter Bootstrap has gained traction so you should at least be familiar with it. Really, build up your skill set with things like efficient use of vanilla js, SASS &amp; LESS, Node, and becoming one with a few different IDE's like Sublime Text, PHPStorm, Visual Studio, and the like. Nothing is worse that having to jump into a project that needs use of an IDE that you're not comfortable with.
To add to this, I highly recommend [Addy Osmani's site](http://addyosmani.com/blog/) and, in particular, his books on Javascript design patterns.
Requires Flash.
Nope, it's just become unpopular because people make the mistake of thinking it's a complete framework - it's a pretty canonical implementation of MV* in JS. For someone that wants to be a competitive developer, this is a good start.
Instead of converting it to HTML, why not just convert it to a PNG, straight from the canvas?
[It's from 2009](http://blog.nihilogic.dk/2009/03/javascript-canvas-sm2-milkdrop.html).
[Here's an equalizer](http://vimeo.com/12038405), now just add the rest you want.
 function totalGPA (g1, g2, g3) { var temp = (g1+g2+g3)/3; // parentheses are important return temp; } Not sure if that's gonna fix it for you - would be helpful if you explained the problem.
For the lazy: /r/emberjs --- I provide direct links to lesser known subs mentioned in the title if one isn't already provided. Let me know if I need to try harder: /r/LazyLinkerBot
This was made before browsers had any reasonable audio API.
You know what, I tell myself exactly that every time I see an amazing WebGL demo. But I'm fine with it because of the ubiquity of JavaScript and its global reach on almost every platform thus making me love it even more.
The interface is html5, not flash... they only use flash for playing the audio. 
In my browser, it's just 4 images that do nothing. Do I have to enable flash for anything to happen? 
Work on doing as much as you can without JQuery, then work on learning AngularJS, Backbone, or Ember.
- JavaScript: vanilla javascript! - JQuery: it's still relevant, if overused. - AngularJS: Arguably the best complete framework out there, several large companies in my area are using this and looking for people with skill in it. - lowdash (or underscore): A great library full of useful tools, mostly for dealing with collections of things. - D3: Can be a really powerful tool for data visualization. - NodeJS (basics) - Grunt: a NodeJS-based task library. It's commonly used to concat, minify, lint, test, etc. in JavaScript shops. - Jasmine or JUnit: Most shops I know are currently using Jasmine. Some are using JUnit. Personal opinion: Unless you're a Ruby on Rails developer skip EmberJS. It's an enormous library (230KB minified) and does a bit less than Angular does (90KB minified). It's on a downward path adoption-wise, and that's resulted in a lot of hate from the "Ember community" toward Angular, which in turn had resulted in a lot of intellectually dishonest comparisons. 
everytime I plug in the numbers to the program, NAN comes back
You can say that, but the reason WebGL is amazing is because you send someone a link and it just runs. That's why js matters. Not because it's better in any way than native apps, but because it just works. No dependencies, no arch issues, it just works. (yes there are a few silly cases where you do need to install something else but that's mostly going away with HTML5) You can rage against javascript all you want but it truly is the write once run everywhere that java hoped to be in the 90's. 
Okie dokie. So I hit a proper lucky break and moved from Scotland to California and work as a full time JS person. I see you wrote in a reply that you went to grad school, what level of degree do you have? You also have ten years experience so I think you're actually in a good standing. Now all you have to do is start firing out CVs, make sure you keep it sweet and short and highlight these open source projects. Once you get past the interviews, the company will sort out the background checks and then organize the full visa part. Fire out as many CVs to as many (large) companies as you can find that look good and are after JS devs. Start on page one of Google, do 3 or 4 applications per day and customize your CV/form entries to the role and business. I say large because small studios won't have the dollar or priority to bring in outside of the USA talent. With your experience, open source projects popularity and hopefully a decent level education you sound like you're in the position to just be applying for whatever is out there that appeals.
(╯°□°）╯︵ ┻━┻)
I'm the creator/lead of App Framework (now employed by Intel). Hopefully I can answer/explain a few things. First, there are a lot of improvements under the hood with performance and UI. There are more that will be coming soon too (2.1 beta *should* be out next week). It'd say it's benefited from the acquisition ;) Intel purchased assets (and the team) from a company back in February. The "XDK" was one of the tools. It has been re-written from the ground up and offers a lot of new features. App Framework lives under the "XDK" umbrella with those other tools, but it is also it's own project. There is a basic UI builder tool, called App Starter, that allows you to prototype your UI with drag and drop tools. If you have any other questions, I'm happy to answer them. 
Yes indeed. Nice job on the spec Domenic!
Your names for "xxxFinal" are being reused for the Total GPA calculations. Because of this, the form.xxxFinal is retrieving the wrong input-- which happens to be NaN because it's empty since computing the totals comes before computing the GPA in the test process. Separating your scripts from your HTML will help you to analyze the situation as well. I got you started -- http://jsfiddle.net/8ErWz/ Good job for doing your work! TL;DR rename mathFinal, chemTotal, etc.
The title is not correct. This is MILKDROP in javascript, not Winamp. The code for the visuals is in javascript, which is impressive. The flash is used to play the music and get the audio data from soundManager (flash) plugin so it can synchronize the visuals (in javascript) with the music (flash). I've adapted the "Juicydrop" code to work inside my own app, so I know a bit about how it works. I have it working with a custom NPAPI browser object (see [firebreath](http://www.firebreath.org/display/documentation/FireBreath+Home)) that gives access to the microphone input so that the visuals inside the web browser (Juicydrop) can synchronize with live music. Lots of fun. Juicydrop works with many standard milkdrop presets, I've been able to take them directly from Milkdrop and load them into Juicydrop. Not all of them work though as Juicydrop is somewhat limited, it doesn't have support for 3D effects, etc. 
anyone else sick of this Webix crap? why are they not removed for spam? i see a post about them at least once a week...
No link no proof
Remember that frameworks will come and go. The core JavaScript prototype system and DOM APIs are here to stay. Make sure you learn them first.
I agree with this. Backbone isn't a framework, but more like a starting point for a framework. If you use it right out of the box, you're bound to end up with some pretty messy code. It does take a bit to get started with Backbone and it helps a lot of have a good understanding of MVC before doing so. If you make everything perform it's role, Backbone really works out pretty well.
It appears that the NaN is begin caused by at least "mathFinal" not being read correctly or cleared. When I changed it to "mathFinal2" it seemed to work as expected for the math one anyways, don't really understand why though.
for anyone wondering, I primarily dev inside visual studio and this works really well. vis studio already has pretty good javascript support, you just had to hack together a project type to run a nodejs app, typically just pretending its a 'website'. this node.js support basically brings node.js as a project type, you can launch and debug like you would anything else. really cool stuff. the intellisense didn't seem to work from node_module imported stuff for me though, which i think is their intention, but i expect that to get better
That only happens when people start talking about DOM manipulation. Otherwise everyone always provides vanilla JS solutions (once in a while they'll suggest underscore, or something like it if it's appropriate).
Well, you should still submit feedback so they fix it.
I don't know what you want your final result to look like. You could do something like this: function Person( data ) { $.extend( this, data ); } Person.prototype.toString = function() { return "Name: " + this.name + ", Bid: " + this.bid + ", City: " + this.city + ", ZIP: " + this.zip; }; $.getJSON( "json/list1.json", function( data ) { var items = []; $.each( data, function( key, val ) { var person = new Person( val ); items.push( 'KEY: '+ key + ' VAL: ' + person + '&lt;br&gt;' ); }); $( "&lt;ul/&gt;", { "class": "my-new-list", html: items.join( "" ) }).appendTo( "#list1" ); }); }); Then your output should look like: KEY: 0 VAL: Name: John Doe, Bid: true, City: chi, ZIP: 20031 etc...
A bit biased, but I like [Fresh Brewed Frontend](http://freshbrewed.co/frontend) !
I don't disagree...
Close the reddit bar.
I don't get it, please explain!
jQuery passes key and value the other way around to the callback in $.each 
I can see that this works, can you point me towards why this works?
jQuery docs show: &gt;jQuery.each( collection, callback(indexInArray, valueOfElement) )
You keep repeating completely unsubstantiated opinions as fact. Ember.js does far more than Angular does, so the claim that it does less is a complete fabrication. It's also not on a "downward-path" adoption-wise—we just added Yahoo! to the list of well-known companies that use and love Ember. I can handle criticism, but your arguments are either ignorant or dishonest.
(ノಠ益ಠ)ノ彡┻━┻ 
I've been obsessed with Milkdrop for a decade now... Thank you so much for keeping it alive!!! Any chance webGL can help finish off the leftover features?
From my understanding I think everybody is trying to make their own framework as it's the best thing instead of working as one.
What does Ember do that Angular does not? I would like Ember to make my custom HTML tag function without having to add additional templating beyond the DOM. Good luck. Templating to generate HTML on the client.. A template for generating a template that actually resides within the same templating it's generating, it's just weird. Why not just leverage the DOM? And that file size... Wow that's a lot of typing. Look I know who you are, and I'm sorry, I tossed Ember aside for Angular a year ago because Angular is an evolutionary step ahead. Please name the things that Ember does that Angular does not that justifies the additional 200KB minified.
Sarcasm.
lol hi tom
Haha, I can relate. :)
Titanium for mobile is a personal favorite. It also uses BackBone, moment.js and underscore
It's a [meme](http://meta.stackoverflow.com/questions/19478/the-many-memes-of-meta/19492#19492) and a [repost.](http://www.reddit.com/r/programming/comments/buosj/add_a_number_to_another_number_in_javascript_img/)
It's honestly a bit disheartening to see a reply from you like this. I second the question: what does Ember do that Angular does not? You've stated "far more", but that sounds exactly like a "completely unsubstantiated opinion as fact." Also, you really shouldn't try to name-drop. You're never going to come anywhere close to the official backing Google has given Angular, sorry. It makes you look desperate, when you really don't need to be.
&gt; It really kicks the llamas ass.
Would you fork these kinds of modules or change to other libraries? It sounds like you're saying the grass isn't always greener and we should just fix it.
I think this would be tricky, you may end needing to let jQuery drag across an open area while somehow drawing the drag cursor yourself. Before that though you may want to try a css rotate https://developer.mozilla.org/en-US/docs/Web/CSS/transform
me!
The problem is you may be dealing with "reflection" bots, bots that know that there's a form portal and are just simply sending POSTing data at your form url with known form fields. They may not even be loading the page. You need to add a type="hidden" input field containing an encoded value consisting of a time stamp and a salt. Too much of a deviation between generation and submission, or lack of this field should send your form data into a spam bin. Also, bots love filling out forms. Hiding a form input with CSS and or JS that a human might fill out (E.G. "First name"), and expecting that field to be empty or the data is sent to spam is a valid method.
Bots can submit whatever they want to the server. Your best bet if you want ideal spam prevention is to use a captcha. For example, there's [recaptcha](http://www.google.com/recaptcha/captcha).
I made this and it is some old shit by internet time standards. It could easily be done without Flash today but back then I needed it to actually get the audio data. 
Oh wait sorry yeh you're right. I was thinking of _.each and [].forEach. 
are you not using an actual captcha? you basically can't stop them without one. 
well, 2 cases : - the owner accepts pull request : you dont need to fork. - the owner doesnt care : you should fork of course.
&gt; I would like Ember to make my custom HTML tag function without having to add additional templating beyond the DOM And I would like Angular to not flash my uncompiled DOM on the screen without relying on CSS and `ng-cloak` or `ng-bind` to cover my tracks. Angular has a wonderful API for building/manipulating/managing custom elements. No doubt. If this is what "power" means, then Angular wins. If we shift the focus towards enabling developers to build fully-featured, ambitious, scalable web applications, hopefully we should be asking ourselves a different set of questions; the question of "Can Ember configure custom HTML tags without necessitating additional templating?" might be an important question to ask at some point, but not before first establishing that custom HTML elements with a maximally granular API are actually crucial to solving the problems that plague developers when it comes to issues of scalability and maintainability. So if "power" means allowing developers to build large-scale, ambitious applications, here are some things to consider: - You very quickly reach the end of Angular conventions once you've grokked its primitives. - This is the cause of much fragmentation when it comes to proper ways to, say, build out a Model layer; some say "screw it, we'll just use Backbone's model layer", others say "screw it, we'll hand roll our own and become `$watch` perf experts". - For the few Angular folk that have cracked the nut on building truly large-scale, [Discourse](http://www.discourse.org/)-level apps, they will all tell you the same thing: no one else at that level of sophistication/accomplishment builds their apps using the same patterns/conventions/structure. Whereas - Data-binding is universal to all objects in Ember, and not just at the `$scope`/template level, so even if you're hand-rolling your own model layer (vs just using Ember Data / Ember Model), keeping your data in sync throughout your app is waaaaay easier, way less error-prone, and the API doesn't shift halfway through (like it does between just assigning properties to `$scope` vs creating `$watch`es, or having to integrate with Backbone model change events). - The Ember Router provides Ember apps, large to small scale, with a structure for your app that solves many problems that have traditionally plagued Angular devs: how do I map URLs to application state? How do I manage the complexity of handling both URL based transitions and direct (named) transitions without having to hand-roll my own Angular service with an identity map to prevent needlessly re-loading a model? How do I manage a complex and configurable nesting of views of arbitrary depth with a minimal amount of typing/configuration? How do I manage asynchronous data while keeping my application in a well-defined state? Fortunately, `ui-router` is starting to solve some of these problems (and they will openly tell you that they use Ember's router as reference), but they don't have the same mindshare as the folk battle-testing the Ember Router because 1) `ui-router` is just a stand-alone optional package, and 2) many Angular developers avoid it because they (somewhat correctly) point out that `ui-router` breaks the Angular Philosophy of structuring your application as much as possible with custom elements + directives. I liken what Ember folk say about the Ember Router to what Angular folk say about Directives: "This is what drives Angular, this is what makes Angular amazing. It may not seem like a lot at first, but seriously, you need to try this out to fully grasp its power." `s/directives/Ember Router/`, `s/Angular/Ember` So, Angular's great for certain things, but you don't have to go very far to reach the end of it. It's the answer to "How do I supercharge HTML in a testable manner without needless abstractions that step away from the DOM?", but not so much "How do I provide the necessary tools to build large, scalable, ambitious apps?" Ember's larger than Angular for the reasons described above, but let's also keep in mind that you're not going to notice this weight if you also like building websites with images, fonts, CSS, and other external resources. 
Thanks for the extensive edits, but... As I've said, I've 2 advanced degrees from the US, both in CS and have 10 years of experience. IMNAL but having been near enough to the process (I had worked in the US before I went to grad school), I'm quite sure an H1B will be granted to anyone if the sponsor can show the necessary paperwork (lots of leeway there to satisfy the eligibility requirements) and the quota for that year had not been reached.
No he's right: it's a pile of shit. It conflates the model and the view - guess that's what you get when you leave out the notion of a formal controller. It takes data from the model, and assigns them as attribute key/value pairs, directly to the HTML tag you've specified for a view for which you've likewise specified a controller. The whole idea of MVC is to *not conflate* the model and the view. This is such a mis-implementation of MV* that *NOTHING* can undo the damage it does.
This comparison is great. I've been trying to steer the company I'm currently contracting for away from Backbone due to it's conflating of the model and view, to Angular due to being AFAICT "supercharge(d) HTML" as you put it.
When you set draggable, you can specify the drag() event. I would do calculations in here to ensure that the element is on the path specified, and if not, move it.
Can't tell from your response, but any chance you might give Ember a shot here?
Why do you need a library to do this other than fs? var fs = require('fs'); var files = fs.readdirSync('/my/dir'); files.forEach(function(file){ console.log(file); }); or just fs.readdir() for async..
Possibly yes. I've already got them anticipating me looking into Angular (and have downloaded a book to my wife's nook for reading over the holiday weekend), but I did show them a graphic that shows Ember adoption going up right with Angular (and Backbone adoption going down).
Your ignorance shows in the first paragraph. {{}} is shorthand for ng-bind, and if your "uncompiled DOM" is showing, you're doing something wrong, and/or just stink at structuring simple ui loads. Your ember app is likely going to look like sit while you pull down a quarter MB file and it just sits there with empty holes waiting for your huge library to use templates to generate templates.
&gt; if your "uncompiled DOM" is showing, you're doing something wrong, and/or just stink at structuring simple ui loads Tell that to [T-Mobile](http://www.t-mobile.com/cell-phone-plans/individual.html) You should give me more credit; explicit `ng-bind` in attribute form is a common alternative to when `ng-cloak` doesn't do the trick. I'm well aware of `{{}}` as generalized `ng-bind` shorthand (who isn't?). edit: dejerkifying
If any of you are directly involved with the frameworks being discussed, and I get the impression at least one or two of you are, this mud-slinging gives an un-favorable impression. I developed in ExtJS for 4.5 years, and if you weren't a cheerleader, you were the enemy. If one of these frameworks has a similar community, I will be steering clear just on this basis.
It's quite a lengthy article with quite a bit code samples. __tl;dr__: To me, writing a Backbone application without actually using Backbone.js itself was an interesting experiment and while of course it took some more time to set up (which I could afford due to the nature of the side project) the extra features and flexibility I got were definitely worth it. I even find myself occasionally wishing I had the same stack available during my work projects.
Fair point. Both communities are quite friendly on the whole, but both have their mud-slinging trolls :)
There is nothing friendly about the Ember community right now when it comes to Angular. 
Sure, but this reaches the point of debating taste and how much abstraction you want to use. This is a trivial example, but for complexer chunks of logic I can see howe it'd be nice to remove as much boilerplate noise as possible. Same as any of the iterative (functional?) patterns (like un underscore.js et al): you could do everything with for-i loops or a low-tech forEach() if you *really* must :)
You had me until Ember.js/dependencies: handlebars. Please don't tell me I need to use a templating system, let alone a specific one. This is why Angular's "supercharge(d) HTML" appealed to me. I will say this though; when it comes to: {} || (Ember.)Object.create() I'm on the Object.create() side. Why? I've come to the conclusion that reliance on accessors is the key to data binding. I've been fiddling around on my system for the last week or two and here's a telling line I've written: var view = Object.create($('#pgn_view'), controller(pgn)); 
Well, it is pretty common for memory leaks, IME.
Backbone shouldn't really be compared with pure MVC, it has no controllers as you already noted, and it's not intended to be a 'complete' solution. What damage have you experienced using Backbone? It's still worthy of study merely for the influence it's had, even if the result is that you don't end up using it.
And all for 4 bytes-per-leak. The amount of skill and brain-power that is now captured in that simple looking line fix is epic :)
Forgive me for getting angry, but Shark_Kicker is a serial troll who continues to spread misinformation. Again, I can handle reasoned criticism—but I'm not keen on letting fabrications go unchecked, because people reading will accept them as fact.
I can definitely appreciate the situation, and thanks for clarifying. I had and have no desire to research his posts, so I can't weigh in there. But I am genuinely curious about the situation. Would you mind pointing me to a resource (even strongly biased) that elaborates on the "far more" benefits of Ember? I've used Angular for several projects, but handlebars has prevented me from using Ember. I'd like a reason to overlook handlebars and give it a shot.
Sure. I'd recommend checking out my recent talk from CascadiaJS: http://www.youtube.com/watch?v=BQ6at0addi4 If you haven't seen it already, [machty's presentation](https://docs.google.com/a/tomdale.net/presentation/d/1e0z1pT9JuEh8G5DOtib6XFDHK0GUFtrZrU3IfxJynaA/preview#slide=id.p) does a good job of summing up the differences, but the major thing missing from that presentation is the routing story. In general, I think Angular is fantastic for smaller projects where you don't do lots of swapping in and out of models and templates. But as your application gets larger, I think you really need the assistance of a framework to do that, and Angular currently falls down pretty hard in that area. Lastly, let me apologize again for losing my temper.
What does the `controller` function do here? You can use Handlebars or [Emblem.js](http://www.emblemjs.com) (HAML/Slim-like indented syntax). Handlebars is about as un-invasive as it gets; I'm curious what you find so distasteful about it. It is and will remain a dependency of Ember, but it's little more than HTML with `{{}}` for the dynamic bits, which it has in common with Angular (as a shorthand for `ng-bind`, as mentioned in a sibling thread). 
The only defining characteristic of a "Backbone application" is that it uses Backbone. So, the title doesn't really make much sense, I'm afraid.
Do you have a real life example where it’s better to use such method instead of directly testing the object’s properties?
Strictly speaking, I think that's a valid argument. But the point is that this solution provides a way to write applications that's awefully similar to how you would write a "true" Backbone application. To quite some extent, you can keep using the same API as provided by Backbone, defining your classes just as you would with Backbone, so for practical purposes, why not call it a Backbone application?
I posted this comment to the site, but also posting here for other to see. The implementation using the Function constructor contains 2 syntax errors. Line 11 should have a closing parenthesis, and line 17 should not have one. After fixing those syntax errors and testing the script, the script is a really bad example of when to either use eval or Function. If the source of the expression string is potentially from an untrusted source, such as any kind of user input, then it opens up the possibility of a script injection attack. DO NOT use your script with any user provided data under any circumstances. Try evaluating the string: var input = 'alert("FAIL")' object.matches(input); I would absolutely strongly advise against promoting the use of this terrible technique for the benefit of a few lines of code. Any user input would need to be sanitised thoroughly before passing it to the script, which would result in a script that saves little to no lines of code whatsoever, nor significantly improve performance. 
We use this to query trees of objects, like models or anything else.
You are correct, i forgot to mention that the source should be trusted. Thank you! Edit: fixed syntax error. Thanks again About script injection, code can be executed from the console. Alternatively a user could define a similar function on any exposed objects. These expressions don't get saved and showed to other users. I believe you might have missed the point.
Yeah, you're completely spot on, so I'm surprised you got downvoted (1 up, 1 down at time of writing). The only "correct" way to do this is to basically defined your own DSL and fully parse the expression to generate an AST that you know only contains the constructs you want to allow.
Yeah, no doubt there's some aesthetic preferences that have been betrayed by Ember (does anyone really enjoy `.set('foo', 5)` if `foo = 5` were an option?). If you're interested, check out [htmlbars](https://github.com/tildeio/htmlbars) which will be landing soonish; once it's there, Ember will be able to do away with curlies, and while technically there will still be a dependency on something called Handlebars, you'll just be writing plain HTML at that point. I can't put my finger on it but I think you're incorrect as to limitations for the designers... I can almost guarantee you that what your designers would want to present would never be thwarted by Ember or Handlebars' restrictions, but let me know if I'm missing something.
You claim that `eval` would improve maintainability, due to fewer lines of code. I argue that it would worsen maintainability, because `eval` is (should be?) a red flag any time you see it in any codebase. That means any time a new dev joins the team, they're gonna come to you and say "Hey, I saw you used eval. Are you sure that's safe?" and you're going to have to explain to them why in the specific context you're using it, it is safe. And then, whenever anyone commits **ANY** new code whatsoever, you have to scan through the code they added to make sure that they do not invoke your eval code directly or indirectly, or else they might violate the assumption that the thing you're `eval`ing is already sanitized and or comes from a safe source. For example, if someone commits this ExpressJS code: app.post('/user/register', function (req, res) { app.getModel('User').register(req); }); have fun scanning the entire call hierarchy of `getModel` and `register` to ensure that there's no way any data from `req` ever makes it way into your `eval` code. Have fun doing that for every single commit that ever gets added to your project codebase ever. **edit**: In fact, it's worse than that: The above code might eval unsafe data **even if there does not path in the call hierarchy from `getModel` and `register` to `eval`**. For example, perhaps the above code causes some data to be stored in MySQL or MongoDB or whatever, and then terminates. Looks fine, right? Well, what if some code, somewhere else in the project, eventually reads data from your database and evals that? Simply restricting your search to the call hierarchy is not safe enough. You actually have to review your entire application code base **every single time** anyone makes any commit to it ever.
Arrays are a data structure. They are not intended to be used to connect a system with a host. I suspect the problem here is a terminology one. The only recommendation I can give you is to find out what terms you're using are standard across all JavaScript development, and which ones are specific either to your class, or to the specific tools you're using in developing your app.
This link could not be more oportune for me. Yesterday I got offered to sell copies of an inhouse solution for a Fortune 500, and was thinking on abandon the old code and start a new one just becouse i wanted to follow "best practices" this time.. 
I typically only chain assignment when I want to assign as a property to this or some other object, but then also to a variable, as in: var foo = this.foo = bar();
Check the console (press F12) to view JS errors. Looks like you are trying to load &lt;script type="text/javascript" src="didrik.js"&gt;&lt;/script&gt; at the bottom of the page and that file doesn't exist.
I'm confused here. Was the position listed for a senior-level UI developer and the jQuery questions are too basic for the position? (though this would worry me if you couldn't find the answers.) Did the position not list jQuery as a requirement and/or you did you not list jQuery as a possessed skill? HR people are not technical (by nature.) Shame on them perhaps for not having a technical person interview you, but I don't really understand the frustration in asking you to demonstrate some competence. Maybe they could have asked you to do it before the interview?
Yes. Break it out more, is the file on a server and you want to deliver the page to a client (node.js). Is the file on a sever but you want to request it from the client-side after the page has loaded? (Ajax)
Obviously the videos themselves nor the posters work in the fiddlw but they work great on my dev box.
I've just put it on Github: https://github.com/FrozenCow/unum If you have any questions, please ask!
Depending on your experience, it'll likely be faster to use one of the more template oriented languages for this (i.e. PHP, JSP). However, Node.js can fulfil that purpose since it has both html page generation and file reading capabilities.
I'm going to assume you want javascript in the browser to read in a random line from a txt file. I don't know of a way to do that other than to read in the whole text file off the server and then grab a line, which would be very time consuming. you'd be better off using some serverside code that runs as a webpage that holds the text file in memory and then only returns a random line each time the page is called. use whatever serverside scripting language you are familiar with and then just do an ajax call to your new URL.
Question #14: Witch type of JQuery plugin support chainability? WITCH
The wrapper for the scrolling section had some classes called kenetic-*. A quick googling brought me to this : [JQuery.Kenetic](http://davetayls.me/jquery.kinetic/)
Awesome! Thanks for the followup. I'll check it out!
Calm down, champ. You can argue semantics here all you want, but the truth is Google is paying people to work on Angular full time. While that definitely doesn't guarantee the framework will be perfect, it does help ensure there is at least some level of active, healthy development. Yes, the Angular framework has scalability concerns, and people harp on that relentlessly. But the fact is, not every application has millions of users and petabytes of data. There are MANY applications that just need to work, and according to business needs, need to be live like yesterday. I'm happy that your Facebook team is pushing forward with React, and that Ember is thriving. Competition is great for the consumer. But when you guys get mad about Angular and go on tirades, it doesn't hurt Angular, only your own project. 
Sounds like a good use for a SQLite DB or a Berkley DB. 
Does it have to be a flat file? JSON would be easier. http://coenraets.org/blog/2011/12/tutorial-html-templates-with-mustache-js/
FWIW, you will eventually have issues with Windows MAX_LENGTH and node_modules. We've run into it on test and production environments. 
CoffeeScript costs me to many neural cycles to read. :(
One of the things that angular did a great job with is community building. But one unfortunate side effect is you have people all over the internet spreading misinformation about it. Once you clarified the google comment (that an established company is paying people to work on it which improves its likelihood of success) it seems fair, though I don't think it distinguishes angular from as many competitors as you think. But you have to admit that there is a lot of misinformation and hype out there about this technology and it's really difficult to get these points across without being really direct. If you think there are more constructive ways to do it I welcome feedback. 
You never clearly explained the use case for having expressions written in strings like that, but your examples look suspiciously like the format of a query string from a URL. e.g. http://example.com/?foo=2&amp;bar=3 While your specific use case for that function may obtain the expressions from somewhere else that is secure, other people reading and learning from your article could conceivably use the query string as input to such a function. If that happens, then that would allow for a malicious script to be injected into the page of a by simply following a link. e.g. http://example.com/?foo=2&amp;bar=3&amp;alert("FAIL") An attacker could substitute almost any other code they like in there and have it run.
Sorry about that. All my newer projects are in CoffeeScript. Just have a look at the JS-folder. The compiled files are there.
Good on you! I applaud your efforts; all of us need to be testing more. But no automation? No continuous integration? No code coverage? No end-to-end workflow testing? I think you're working too hard :) You need to look at the following: * [Grunt](http://gruntjs.com/) - A JavaScript task runner. Run your tests the second you hit save for instant feedback. * [Karma](http://karma-runner.github.io/0.10/index.html) - A test runner. Run your tests in multiple real browsers automatically with command-line feedback. Ships with RequireJS support built-in and works nicely with [Istanbul](http://gotwarlost.github.io/istanbul/) for code coverage reporting. * [CasperJS](http://casperjs.org/) - A testing utility that uses headless browser automation to test your end-to-end workflows. * [TravisCI](https://travis-ci.org) - A hosted continuous integration solution you can employ to run your tests on every commit and pull request. You should also take a look at a [testing experiment (github/lazd/wellTested)](https://github.com/lazd/wellTested) I've been putting together that uses all of the above to see how they fit together. I'll be adding more pieces of the puzzle in the coming weeks, and will be sure to document why I chose the solutions employed and how they fit together in the big picture.
I understand, i'll think of a way to avoid possible confusions. Thank you.
Thank you! Within my project I've tried to focus on a test config where you can mock behavior and organize your tests. Usually I'm using Grunt but I have tried to reduce dependencies within this project. Anyway thanks for the other links.
I'm not sure the benefits of CoffeeScript outweigh the additional cognitive load of parsing a less-than-expressive syntax or the fact that the door is closed on many potential open-source contributions because some developers hate it. Remember, everyone who knows CoffeeScript knows JavaScript, but not everyone who knows JavaScript knows CoffeeScript. Consider using [Harmony in node](http://dailyjs.com/2012/10/15/preparing-for-esnext/) and start writing ES6 code right now on the server-side. You'll get all the benefits of [list comprehension](http://ariya.ofilabs.com/2013/01/es6-and-array-comprehension.html), [modules](http://wiki.ecmascript.org/doku.php?id=harmony:modules), [generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators), and more without having to write in a foreign syntax. Check out [Traceur](https://code.google.com/p/traceur-compiler/) to compile ES6 to ES3-compatible code for the browser. You can even automate compilation using [grunt-traceur](http://addyosmani.com/blog/author-in-es6-transpile-to-es5-as-a-build-step-a-workflow-for-grunt/) so your end-users are none the wiser. Also check out [ES6 Module Transpiler](http://square.github.io/es6-module-transpiler/) which can compile to RequireJS-compatible AMD modules, fitting perfectly into your workflow.
When you document.. Please.. Share. Blog posts. Blog posts EVERYWHERE.
My favorite approach to requirejs unit testing is to simply load every single module up front, then load your specs. That way you do not have to worry about dependencies. Check out https://github.com/cloudchen/grunt-template-jasmine-requirejs for this pattern.
Well asm.js is a compiler target and brainfuck is among the easiest languages to write a compiler for. This repo is just to show how the different components of asm.js fit together (the heap, the stdlib etc) to create something that can run, this is a starting point for creating your own compiler. 
You'd be better off just fixing your IE issue.
What versions of IE are we talking about..? If it's IE9+, then you should probably try to fix your design.. Otherwise you could use [conditional comments](https://en.wikipedia.org/wiki/Conditional_comment) to show a message to users of older IE browsers..
Actually the boilerplate here does not increase linearly with complexity. For example if we wanted to throw in reduce and filter - it would have literally no additional boilerplate compared to using qX and qX would look even more useless than in the simple example. Secondly my point was that you don't **need** qX to do looping. Given the above many would not feel that qX is necessary. Your comparison with for loops is ridiculous.
Agreed. I have RequireJS, Grunt, Karma, Travis-CI, Coveralls, etc. configured in the cleanest way I could figure out here: https://github.com/backbone-boilerplate/backbone-boilerplate/tree/master/test This supports QUnit, Jasmine, and Mocha. I've been debating writing back in compatibly between Karma and the browser. So that tests could run in either environment. I think this is very important for debugging.
Don't alert them, add a small banner asking for them to upgrade. No one on the internet likes alerts.
What kind of issue are you dealing with? I'm rather experienced with dealing with IE issues so I may be able to help you out without resorting to browser upgrade prompts.
If you are using IE I would say you can tolerate about almost everything :)
22 CSS Questions 13 HTML Questions 12 JS Questions This should have been called a designer quiz, and most questions edge cases. If I saw anyone writing JavaScript like that I'd have their ass.
There's a few questions here where I'm curious what browser is being used as the standard for how it behaves...
Nice work for a beginner. I don't mean to nitpick here, but you are not "learning JavaScript" by using jQuery almost entirely. I suggest rewriting your code using pure JavaScript from scratch, that'd be the real learning exercise. :)
Stop writing module systems, start building applications! Personally, when I found [browserify](http://browserify.org) I didn't look back.
It's pretty small. The gradient on my navigation buttons isn't displaying. 
Take a look at chrome frame https://developers.google.com/chrome/chrome-frame/. Might work for you
AWESOME!
I'm inclined to agree, but sometimes something like that is important to a design. 
Well thanks for the advice, will go make first Hello World app ;-) Actually the text is not about my module system, but itrrather explains the exact reasons why I made "yet another module loader". And yes, you would not need to browserify your code with it anymore.
11 is wrong. "Sausage" is blue, not red. http://jsfiddle.net/sb6tx/
Brilliant, thanks!
Use this: http://www.colorzilla.com/gradient-editor/ It can generate gradient styles that include the fixes for old IE.
If it means anything, Google has already dropped support for IE9. https://support.google.com/a/answer/33864?hl=en Honestly, if Google doesn't support it, neither should you (unless the project is very specifically targeting those older versions). 
Part 2 (quick-union) [here](http://linorosa.com/11-15-2013/quick-union/)
SORRY THIS IS SO LONG! But you asked and I wanted to deliver. Feedback? Well, from my experience, when people develop JavaScript, they rarely do so without also using a server side language. When they use the server side language (let's consider JVM languages, .NET languages, Ruby, and PHP in this rant since node.js is more complicated), they tend to follow programming best-practices, adhere to quality and patterns, and generally care about their work. For some reason, that doesn't carry over to JavaScript. I don't know why, it just doesn't. The open up the .js file and lose their minds! Or worse, inline all their JS or use silly abstractions--webforms *gag*. I think Angular's marketing is powerful, because it's tricking these people into using more robust patterns and practices by enticing them with the cute features. I found that out first hand, because I admittedly started using Angular for those cute features, but stuck around when I learned about the DI, modularization (directives), routing, services, and testability. Those cute features are also how I pitched usage of the framework; I didn't mention the architectural benefits at all. What I see from Ember and React (although I've yet to use either for a major project) is that your architecture and principles are more forefront. There's no "teaser" for me. There's nothing to make me want to learn more initially, I must actively seek out information and experiment to try and figure out why I should use it. Let's look at taglines: * **AngularJS:** "Html enhanced for web apps" - This is possibly the biggest pain point of web apps -- keeping the DOM in check and in sync. This is immediately appealing to me. I already know HTML, I just want it to suck less and do more. * **EmberJS:** "A framework for creating ambitious web applications" - Well I don't think what I'm doing is ambitious. It's pretty normal, I just want something to help me do it better or easier. This is an alarmingly specific adjective that I would *never* use to pitch a framework to a decision maker. * **ReactJS:** "A JavaScript library for building user interfaces" - So, it does graphics and buttons and stuff? Like Bootstrap, right? Or does it do binding, like Knockout? Or something else? I have no clue what it does, nor why I should care. This reminds me of The Office where Jim and Dwight throw a birthday party and instead of "Happy Birthday!" the banner reads "It is your birthday." Looking at code examples, there's so much introduced on the Angular homepage, with reasons why you should care, familiar HTML syntax with only the unique bits highlighted (and explained via tooltips), and organized to get progressively less tactile and more complex as you scroll down the page. It gives you a taste of ease, with a glimpse of power. Ember has 3 examples with practically no explanation or "sales", and leads off with handlebars: the sole reason I've avoided it this long. It ends with a far too complex example to have no comments and an advertisement asking for donations... not a great way to instill confidence. React is better, but to most people seeing it, appears broken! "There's HTML inline in this JavaScript! That's definitely tossing errors." Then when you realize it's *yet another* precompiler, you let out a long sigh and possibly walk away. At the end of the day, developer time is MUCH more expensive than server hardware, so Angular will win out a bit here. Most high-level architecture thought is given to business logic and backend tiers, not UI tiers. You need to appeal to the mentality of "this is just a sucky thing I have to do" and then guide/trick them into the higher level stuff after a prototype or two, or even on their 2nd/3rd application. After all, the vast majority of people who write JavaScript are *not* JS devs (from my experience trying to hire folks), they're doing it just because it's a necessity for the application they're developing.
&gt; If it's IE9+, then you should probably try to fix your design.. If It's any version of IE, the problem is probably IE, if it works in any other browser. Why should he rewrite working code just for IE's sake? And conditional comments don't work in IE10+ anymore.
And stupid IE users never know what they're missing anyway compared to a good, modern browser.
Everyone should be a lert.
He can't force that on users.
With source maps, which both CoffeeScript and Traceur support, it's not as important that the generated code is readable. My comment refers to the actual code I must maintain on a day-to-day basis. When I'm reading that code, and I see something that looks like this: &gt; `someFunc arg1 otherFunc arg2 arg3` Without any meaningful syntax, I'm forced to think about what's happening. When I see something like this: &gt; `somefunc(arg1, otherFunc(arg2, arg3))` I immediately know exactly what's happening. It may be entirely subjective, but I vastly prefer the latter.
Wow. This is awesome. Bookmarking this for when I need it.
This is simple JavaScript hoisting.
This is really cool, having debugging skills I guess may pay you more than a programmers can earn :D lol I am kidding.
Thanks. I watched your talk and stepped through machty's presentation, twice. It's definitely helped convince me that I should give it a proper go, but I still don't see the "far more" you were mentioning. The routing seems really solid, with nesting being a godsend. And getters and setters have always sounded more performant than dirty checking. But what else am I missing? I feel like based on your defense I must be missing a lot. 
Sorry, they wrote a blog post about why they don't want to use a javascript framework and why only jQuery is ok for them, and the next post is about their own framework
vim/emacs? because f*ck IDE, i want massive text editing features
WebStorm is, hands down, the best IDE for JavaScript and web development out there. It's the first IDE that makes refactoring JS code almost bearable.
Vim + Tmux = IDE
Thanks, copy + paste error :)
jQuery does everything. No proof needed.
Even so, they still represent a significant share of the market so it would be foolish to ignore them.
Sublime Text 3 or Vim all the way.
I totally agree its the best will never go back to other IDE's 
still rubbish, crashed itself 4 times, and wouldn't switch Browser Modes when I was using it on Friday
After Windows upgraded MSIE to 11, I was quite a happy camper. The new tools are great. For example: if you get an object back from a function call at the console, then you can interactively dig into its properties. There's only one major problem with it: the emulation mode of older versions of MSIE *is not 100% compatible* with that on MSIE10. I can see bugs in MSIE10 emulating an older browser, that I don't see in MSIE11 emulating the same old browser. 
Serious question - why hate on a product being written in Java if you never have to actually write Java? I personally don't like Eclipse because it feels super bloated, but I don't really care what it's written in.
I use http://plnkr.co/edit/, Cloud9IDE and nitrous.io as these all let me take my code and workspace with me wherever I have an Internet connection. 
I'll just add that Squire.js is especially useful for mocking more complicated Require setups.
and worse he is confusing the jvm and java really. and hating the jvm is idiocy, the jvm is an incredible piece of software.
you're not the only one, it's nice that they are trying to stay relevant in a market that out developed them years ago, but it would make everyone elses life much simpler if they just gave up, with each iteration of IE it just means more testing for the rest of us - yes we've stopped supporting 6 and 7 finally, but now I have to check 8-9-10 &amp; 11 which all still have their own quirks and fuck ups when every other browser manages it easily The new dev tools are basically a skinning of the old ones, with some simple features added in, there is a lot of useless information being displayed and the browser frequently crashes if you change more than a couple of settings at a time - Chrome is at the forefront at the minute, Firefox has become to clunky in it's old age, and it just isn't up to par, IE is the worst thing about being a FE developer and always will be as far as I can see - I hope with IE13-14 microsoft match chromes current ability, as it will make my life a hell of a lot easier!
If you can write Backbone apps without Backbone.js (ie: you have Models, Views, Collections which you call by something like new MyApp.Views.SomeView()) you can write Backbone app using CanJS :) CanJS' Models are a lot like Laces CanJS' Collections can also have properties like models (for searching, pagination etc) Besides that, CanJS comes with Mustache and you get bidirectional view-model bindings. Its API is more jQuery-esque myModel.attr('name'); // get the name attribute myModel.attr('name', 'My name is...'); // set the name attribute CanJS cames packed with a lot more stuff than what I can tell you here. http://www.infoq.com/presentations/CanJS ... presentation is very old but not out-dated although CanJS has added more new features since than
Never said you should ignore them.
&gt; The new tools are great. Compared to what? Compared to anything else? No.
PHPStorm has many of the features of webstorm. Because I often have to write in PHP, I find being able to have an IDE that can parse HTML/Javascript/PHP in the same file, at the same time. So I use PHPStorm, but it's basically the same IDE.
Look into CSS3 PIE. It surprisingly works quite well! http://css3pie.com/
&gt; I love my Firefox and all of it's customisation I'm interested to know: have you tried the new [Australis builds](https://blog.mozilla.org/ux/2013/11/australis-is-landing-in-firefox-nightly/)? So far I find that in the name of making customization "easier and more discoverable" they've made it impossible to change anything I currently customize.
&gt; Not being javascript syntax is exactly the reason I (and many people I know) despise Coffeescript. It goes both ways I guess :)
Yup, and MS knows this. this is why they release virtual machine images for IE6 up to IE11: http://www.modern.ie/en-us/virtualization-tools#downloads
Missing Eclipse Orion (Not Eclipse in a browser) - Client completely written in JavaScript, supports cloud development or even simple "npm install orion" on Node.js. All open source with committers from IBM, SAP, Pivotal, students, others - http://eclipse.org/orion/ or try it out at https://orionhub.org 
Is the dev tool in Page Inspector the same as in IE? If so, this makes sense, as Page Inspector crashes all the dam time. I was just doing a website and would run locally in Chrome to use the dev tools there rather than in the Page Inspector as it would just crash VS.
I have a theory that wrapping braces and other strong structural elements are used as parsing hints by your brain With strong hints much of parsing the visuals (to whatever happens in your mind) gets done by the visual cortex instead of active cognition (just like you recognize a tiger without thinking). In effect it is like a low-level preprocessor (reverse GPU :) --- I tried this by adding even more visual cue's to my editor: in WebStorm you can do Show Whitespace which will draw vertical lines for Tabs used as indenting (I always use tabs, rendered as 4 space, exactly for this kind of thing), and as little grey dots for spaces. Also show linebreaks (and numbers). Then I enabled Method Separators (de-marking function bodies) and also use *very* aggressive re-formatting (incl eating repeated blank lines), have some fascistic JSHint rules (full style nazi). Then I adjusted my code style and try to never do funky short-hand syntax, always use many parentheses to group stuff (like boolean statements). Code now looks like in code-101. It is *amazing*. And in TypeScript (with it typing annotations and the code ES6 structural features (module/class/export etc) the readability is through the roof. Add Promises with plenty of arrow functions for the asyc and it is time to cream nerdypants. You can now just 'look' at the code and see the flow without actually following the logic. Amaze. --- One day I will post this to /r/askscience.
Google d3js and play with svg triangles for a while.
Anal remark (and spoiler ahead): "Can you set margin-top and margin-bottom on an inline element?" The answer is always yes. Yes, you can set them on inline elements. But will they _have effect_? That's a [different question](http://www.w3.org/TR/CSS2/box.html#margin-properties) ;)
Is this something somebody relatively new to programming can reasonably accomplish ? There is a famous quote by Bill Gates that I like which is: "This is software, we can do ANYTHING!!" If they hire you, it means that after taking the time to evaluate your skills level they believe that you can do it. Something I learned in Software Development in general is that we don't always know how to do something, but with a little bit of research and hard work you can do almost anything. I was hired at my current job to do some I hadn't done before. I was thinking I could do it but I never had, they were also using some technologies I hadn't used such as ASP.Net. But guess what ? I did it! If they hire you, take the job first, then work really hard toward accomplishing what they ask you, You CAN do it!!
If Microsoft is serious about improving their dev tools they need to do a lot more than what they've done already. I see no incentive to move away from my primary testing browser - there isn't a single feature of IE11 dev tools that is done better than in Chrome or Firebug. I'm glad they're improving the situation, but Christ almighty I don't think anyone would complain if they sped up the process a bit.
You're awesome. Thank you!
JavaScript is always the answer. Always. Even when the question is heinous and absolutely atrocious, JavaScript is the answer. Your next meeting, you should be answering every question posed with "JavaScript". When your mediocre child asks a question, and you realize you're raising a functioning retard, you should answer "JavaScript". When your wife asks you "what do you want to do Sunday?" Well, I think you should know how to answer her by now.
There's been a lot of energy poured into Firefox since they shortened their release cycle. Their JavaScript engine is excellent, the memory usage better than Chrome, and the dev tools are improving steadily.
It's consisted of a social phone interview, a technical phone interview, and then an in-person technical interview where he went over code and work samples I had. This is the first interview I've gotten since I started seriously searching for a job last month, and I was told to keep the presentation brief and informative, just discussing the features of existing CMS. I thought it seemed kind of weird compared to the normal interview process I've read about on here.
&gt;"attempting to print any a JavaScript value with the console logger [...] e.g. “console.log( { "foo" : "bar" } )” results in the very unhelpful output “[object Object]“. Boo!" I should point out that this is because you should really be using console.dir and not console.log. I know that'll seriously confuse most people coming from Chrome or Firefox.
* The location of reload/stop and back * Putting any button on a toolbar * Having my add-on icons on an add-on bar at the bottom It's possible that that the toolbar problem may be fixed, but the [reload button is apparently a concious decision](https://bugzilla.mozilla.org/show_bug.cgi?id=755598) as is [the removal of the add-on bar](https://bugzilla.mozilla.org/show_bug.cgi?id=749804). edit: removed mini-rant
That looks like a decent one, I just signed up. Thanks for sharing.
Even as a Firefox fanboi, I still put Chrome above it performance-wise. I can't decide which is faster or uses less memory officially because I haven't run any kind of real benchmarks. But Chrome has a far higher framerate on some graphically intensive pages. They both seem to be able to do the same things, just Chrome is a little smoother. Well... WebKit / Blink is a little smoother. That seems to be the difference now, the speed of the rendering engine, everything else is down to taste and preference. I use the FF dev tools more and more with every release, although I do still have to fall through to Firebug occasionally. Using both in tandem is amazing, it's like having two expert opinions on a problem and you get to pick and choose what you believe. I'd like either Firebug to get sleeker or FF dev tools to get even more functionality, either way, it's a win.
This is a fantastic answer, thank you so much. :)
[NVM, found it.](https://github.com/jbochi/gifstreaming)
I wrote this plugin with 2 goals: * assume nothing about the DOM, styles, javascript where this will be used. It should just work and require no changes in the apps styles or scripts * Support overflow scrolling and window scrolling, do not create invalid HTML I think I have come close to achieving those goals. I am asking for **feedback** on the script and the docs site. Thanks for looking. 
Hey, I'm in SF right now but we can do a google hangout you want.
&gt; However, attempting to print any a JavaScript value with the console logger still behaves like in IE10 (or IE8 for that matter), e.g. “console.log( { "foo" : "bar" } )” results in the very unhelpful output “[object Object]“. Boo! Well, don't think I'm in any danger of switching away from Chrome. Love exploring nested objects in the console!
This times 100000000%. Jesus, the amount of fiddling you have to do with sublime just to get it to 10% of where WebStorm is makes it a no-brainer if you're looking to choose between either one. Only knock is some performance issues once in a while, but that's a tradeoff most developers who value sanity would be willing to take.
Aptana is now my go to IDE for front-end development. The intellisense is pretty good, but my favorite feature is that you can connect to your web server and update code in real time (rather than updating code, then overwrite your current version on the server). It also has it's own ssh client. It's like notepad ++, putty.exe, and winscp all bundled in one window.
*fizzbuzz* made me hiccup a few seconds at my first interview. &gt;++++++++++[&lt;++++++++++&gt;-]&lt;[&gt;+&gt;[-]&gt;++++++++++[&lt;++++++++++&gt;-]&lt;+&lt;&lt;[-&gt;&gt;-&gt;+&lt;&lt;&lt;]&gt;&gt;&gt; [-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;&gt;&gt;+++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[-&lt;+&gt;]+&gt;[-]&gt;[&lt;&lt;-&gt;&gt;[-]]&gt;[-] &lt;&lt;&lt;[[-]++++++++++[&gt;++++++++++&lt;-]&gt;++.+++.[-]&lt;[-]+++++++++++[&gt;+++++++++++&lt;-]&gt;+.. [-]&lt;[-]&lt;&lt;[-]&gt;&gt;]&lt;&gt;&gt;+++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[-&lt;+&gt;]+&gt;[-]&gt;[&lt;&lt;-&gt;&gt;[ -]]&gt;[-]&lt;&lt;&lt;[[-]+++++++++[&gt;+++++++++++&lt;-]&gt;-.[-]&lt;[-]+++++++++[&gt;+++++++++++++&lt;-]&gt;. +++++..[-]&lt;[-]&lt;&lt;[-]&gt;&gt;]&lt;&lt;[[-]&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[ &gt;++++++++[&lt;++++++&gt;-]&lt;.[-]]&lt;&gt;++++++++[&lt;++++++&gt;-]&lt;.[-]&lt;&lt;&lt;]&gt;[-]++++++++++.[-]&lt;[-] &lt;-]
Vim + TernJS + Unite.vim = Master Race
I don't have a webcam on my PC. Not sure if we would need one or how you could see the code. I could do it on my iPhone somehow I suppose.
Nice idea, but why are there *so* many jobs for non javascript developers ?
You can screenshare on google hangouts, if you want to do this today let me know. I should be able to help anytime for the next few hours.
They won't ask about scale for a javascript position - especially not a front end one. I interviewed with JUST JavaScript, no java or C++. Basically you still need to know algorithms and know how to solve them. A lot of the interviewers weren't pure JavaScripters so if you show them a solution that uses some JavaScript magic be sure to explain it. Talking through your process is very important. Beyond that be prepared to talk about the things happening in JavaScript land like compile to languages and frameworks. Specialist knowledge of JavaScript edge cases isn't something you need (how often do you run up against these in day-to-day? One of my pet peeves are interviewers who ask this, you should be aware of them but should not have to know them to the Nth detail). Show you have strong computer science fundamentals, you can solve problems. Know your subject well and you will be fine
It was developed by some mates for the 2013 [nodeknockout ](http://nodeknockout.com/teams/sophilabs)
For those of us without webcams, what is it?
doesnt work, if i type in london i get: http://jsfu.org/search?q=&amp;loc=london&amp;lat=&amp;lon=
[Watch this](http://youtu.be/KDFGBQipNDU)
Can you actually edit and add CSS properly yet?
I agree. Visual Studio (even the free Express version) has by far the best javascript comprehension, and the ability to intellisense your own files is pretty neat too. In my experience IntelliJ is average and the company that makes it are dickheads.
PHPStorm is WebStorm with PHP support. Same exact IDE.
Dude remove your email address!
http://www.browser-update.org/
And if you want to work remotely ? 
Nice project! Personally though I'd call requiring jQuery and underscore assumptions. Certainly not unheard of but if you're presenting it as a no-assumption library I'd avoid god-frameworks like that and maybe use smaller specific projects like `component/query` as a selection engine (uses browser css selector with fallback to sizzle or qwery) Edit: I know that recommending component seems like a huge contradiction to not assuming things but you can use `component build --standalone` and you've instantly got a plain-old script that you can use in a normal script tag like any other library, without forcing a god library on anyone
This works fine for me in the latest Chromium: http://jsfiddle.net/eHLLB/ Would it be possible to see your code?
https://weworkremotely.com/
Looks to be mostly, or only US jobs? Under the about nav at top, "Browse by State" http://jsfu.org/c/states
Magenta_placenta thanks for posting this to reddit, but holy hell it's testing the power of my servers. I'll answer a few of the questions: 1. **Not just Javascript Jobs**. I'm still working on the best way to filter out only javascript focused jobs. It's not working to my liking as it still pulls back jobs where Javascript is only a requirement or nice-to-have. 2. **Non USA Locations**. I'm focusing on the US market right now - yes I know this is silly but I haven't found the right partners overseas. But johnnyvibrant did find a bug, and it's throwing an error when getting non US based countries. 3. **Working Remotely**. This is being worked on, remotely. 4. **JS (fuck you)**. Yes. 
[Just go away IE!](http://i.imgur.com/gFQefj0.png)
 .isEmpty()
I have to assume one could just clone the git repo and have a working installation, but I can't be certain because the readme says I have to use Yeoman. Why would you use Yeoman for a Node JS project, which has its own package and dependency manager?
My favorite was that it wouldn't browse to an IP address until recent updates. I couldn't put in any ip for any address, local or remote and have IE do anything, not even search for the address. It's as if there's no quality assurance at all. I applaud their new direction, but damn do they need better development practices. 
How is that clever? Office.coffees.map(function(){ return this.reFill(); });
I've done this with a couple of projects. All mine have been based on database values (both client side and server side) that then somehow trigger .show() and .hide() jquery events. I can't really give an example because they were both fairly complex projects that I'd rather not try to recreate in a codepen type env but it is definitely possible using JS.
Looks like a direct copy of lesson one from Coursera's [Algorithms class](https://www.coursera.org/course/algs4partI) taught by Sedgewick.
I read "JS(fu)" as: "Jay Ess (fuck you)"
It was definitely inspired by the lessons and the book. Thanks for pointing it out. It reminded me to add a reference to them at the end, which I hadn't done.
Just figure it out... that's half of the fun Try again, fail again. Try again, fail better
Be interested to know now the performance is, in particular if that's been improved (specifically since IE9, which is the newest IE I've used). I've no objections to using the IE Dev Tools when I have to for IE specific issues, but the performance impact opening the Dev Tools has is shocking, to the point where after even a couple of page refreshes everything's slowed right down. May not be helped by the pages being debugged being WebSphere Portal pages including a colossal dojo.js file, but that's not really an excuse given that Firebug and Chrome don't show the same slowdown.
Price point is ridiculous.
I take issue with the organization of this code. `drink` should be a `Person` method, `Coffee` should instead be a more flexible class, such as `Mug`, which should have a `use` method that decrements the current amount by the passed amount. An additional class, `CoffeePot`, which extends `Pot`, should be responsible for supplying coffee for refill operations, and an `Office` class should contain all available pots of any kind. `person.drink` should be passed a `Mug` instance and should call `mug.use(this.sipSize)` successively with a `this.sipDelay` timeout between calls until it returns `false`. Then, `person.drink` should iterate over all of `this.prefers`, and inside of that loop, iterate over all of `this.office.pots`, calling `pot.has(preferredType)` until it finds a pot that has the preferred liquid, then it should call `pot.fill(mug)` before calling `this.drink(mug)` again. The described implementation is more flexible as mugs can contain any kind of liquid and person instances can fall back to other liquid types if their preferred liquids are not available. The described algorithms could be optimized, but care should be taken to avoid code paths that result in the hard-coding of liquid types. To put it all together: var coffeePot = new CoffeePot(); var teaPot = new TeaPot(); var office = new Office({ pots: [coffeePot, teaPot] }); var person = new Person({ name: 'lazyduke', office: office, prefers: ['coffee', 'tea'], sipSize: 2, sipDelay: 7500 }); var mug = new Mug({ size: 8 }); person.drink(mug); But I guess thats a lot of code to put on a coffee mug.
set parameters to the url?? http://domain.com/?page=1, page=2, etc var param = document.location.search; var page = param.split('page='); if(page[1] == '1'){ $('id name').css('visibility','visible'); }
Yes, but it's done on purpose, and done well, so brilliant. And if you look at the HTML, it's not 90's HTML... I think because GIF's have that sort of geocities black background website association why not use that for your neat modern GIF technology? I think it works.
Thanks, you've given me a little bit of hope for this.. Any references you used or remember playing with?
[Docs layout isn't quite right on mobile.](http://i.imgur.com/enWsZWt.jpg)
yeoman incorporates bower for front-end lib management, and grunt for any task running like front-end template generation. I haven't looked at the repo yet, but it is possible that the vendor libs and template-generated files are not stored in this repo and are built via yeoman. Edit: The yeoman generator packages these missing files (you can see the outline in the readme) and provides them.
Thanks, I'll try and get it going myself. Appreciate the advice.
You'd be right... My first fuck you was to print... Printfu, but thats for another story.
why? why use GIF for this and not a format made for video / video-like content?
I'm open to suggestions. There are very few boards dedicated to Javascript, so my price point is based on my other creative / development boards price thresholds.
&gt; I don't think anyone would complain if they sped up the process a bit. Which is the core of the problem with IE, really. Microsoft has boxed itself in with it's current delivery model and that model simply doesn't support the sort of turn around time required to stay relevant in this space. It's not that they *want* to deliver bad, outdated software, but they don't really have much of a choice without someone at the helm who has the internal authority to fix their broken process. 
This is brilliant! Thank you for showing me this. 
I literally had no clue these existed. Thanks. 
You are the man!!!! Thank you. I haven't had too much experience with JS, so I was reading documentation all day. Once again, thank you! 
Well, I was interviewing for a front-end dev position and I got the scale questions. Granted, it's part of why I was extremely dissatisfied with the interview process (the other was that I had two separate interviewers ask me the same question, so clearly they weren't talking).
Github ftw! You can post "gists".
All I see is a blank page...
Cause he wants to target Internet Explorer 6 without plugins/ActiveX/etc? 
No JavaScript required, actually. Internet Explorer v9 and below will read "conditional comments," which look like this: &lt;!--[if lt IE 9]&gt; &lt;style&gt;html{display:none!important;}&lt;/style&gt; &lt;META http-equiv="refresh" content="0;URL=http://noaiee.com/"&gt; &lt;![endif]--&gt; This one will hide your entire site and redirect the browser to http://noaiee.com, which is a hobby project of mine. If you want to pop an alert to browsers running IE8 or below, try this: &lt;!--[if lt IE 9]&gt; &lt;script&gt;alert ('ding!');&lt;/script&gt; &lt;![endif]--&gt; 
This is the one place where coffeescipt would have been useful.
I think it's fine to store the emptiness value in a property, personally.
 i work in intellij with java, scala, groovy and javascript each day. The gradle and maven support is excellent as well. I am pretty happy with them. Visual Studio is excellent, no disagreement there. My friends and colleagues who develop with visual studio tell me Resharper makes it even better (also from the jetbrains guys). I take it you had a bad experience with them? care to share (an informed consumer can make better choices and all that bla bla)
In many cases, it's fine, but you risk getting out of sync. However, you can use a getter and get the best of both worlds: Object.defineProperty(this, 'isEmpty', { get: function() { return this.items.count === 0; } }); 
coffee.isEmpty() would be a nice addition to the inside of my mug :)
So, if it's empty, you'd refill it, but you won't drink any. Secondly, it was just instantiated. Shouldn't its state be known? Is that constructor nondeterministic? Also, the coffee refills and drinks itself? Why isn't it properly indented? Why was a proportional font used?
Missing a rather important loop element. I personally like taking more than one sip of my drink.
&gt; PHPStorm has many of the features of webstorm. if I'm not mistaken, PHPStorm is WebStorm plus PHP syntax support -- so it's a superset of WebStorm. PHPStorm has **all** of the features of WebStorm.
I haven't yet been able to wrap my head around object.defineProperty. You're helping!
Please document this. It sounds really cool
&gt; true and false are objects, but null and undefined are not I am confused. What would be some consequences of that fact? 
WTF is this? http://jobs.pearson.com/mobile/job/San-Francisco-Lead-Mobile-Engineer-%28JavaScript%2C-HTML5%2C-CSS3%29-San-Antonio-or-Austin-Texas-Job-CA-94101/6694600/ This is a Mobile/Web job and a Java certificate is desired? 
var c = new Coffee(), x = c[c.empty ? 'refill' : 'drink']();
Also... var Coffee = function() {}; Coffee.prototype.empty = Math.random() &gt; 0.5; Coffee.prototype.refill = function() { console.log('refill'); }; Coffee.prototype.drink = function() { console.log('drink'); };
From your description this seems more like a Java app than a quick script
CanJS.com is a good alternative. The syntax is pretty similar models: mymodel.attr('full_name') Mustache templates are very close to underscore templates if you used {} instead of &lt;% %&gt; collections: MyUserCollection.findAll(callback_function_to_trigger_rendering_or_whatever); you can continue to use namespaces if you did that CanJS also comes with other goodies (live-binding, 2-way binding, computed properties, web components or "custom tags" etc). The only thing is that you still need a library for DOM manipulation. CanJS offers builds for jQuery, Zepto, MooTools, Dojo, YUI so you'll have to use one of these.
&gt; What about HTTPS? &gt; [...] In this case I believe it is not necessary [...] I don't necessarily agree with this. SSL isn't just for encrypting traffic between the client and the server. It is also for ensuring the integrity of the the app's code. In this case, without SSL, the JavaScript could be modified mid-air through a man-in-the-middle attack so that it could share a user's file or password. SSL would ensure that the JS hasn't been messed with on its way from the server to the client. But nice work otherwise. Looks very clean.
I was just comparing the dev tools under MSIE11 to those under MSIE10. I *was not* comparing MSIE with other browsers. 
This sounds like an arbitrary, and perhaps misinformed or even foolish requirement. Why do you want to remove two of the most commonly used libraries from your code? And what exactly do you think you're gaining by switching from backbone+jquery+underscore to something else? Is this possibly a place where concatenation and minuting your javascript would e a better solution?
[Source code released](https://github.com/sophilabs/macgifer)
I agree, jQuery and underscore are the things that should be kept. The steaming pile of manure that is Backbone on the other hand....
Second this suggestion. It's pretty trivial to convert an existing Backbone application over to CanJS and then just get the benefit of live-bindings for free. You can also go with the new can.Component[1] stuff if you're interested in Web Components at all and willing to do more of a complete rewrite. The amount of code reduction you get with can.Component is amazing. [1]http://canjs.com/guides/Components.html
Super cool project by the way! The HTML5 canvas is a wonderful thing.
reduced lines and made into a switch switch(document.location.search.split('page=')[1]) { case '1': $('id name').css('visibility','visible'); break } add other cases for the other pages 
Warning: plays loud sound automatically, NSFW (in the sense that your office PC will suddenly blare out loud music).
Not necessarily crypto in JavaScript. But crypto in the browser, yes. Due to the obvious risks of the web. Though, it's getting better. Browsers are implementing better APIs for random number generation and if you ask Mega's CTO, he'll tell you that Mega uses crypto in the browser and that it hasn't been cracked so far. So it's probably good enough in most cases. And mostly, the crypto itself isn't the problem. But the delivery of the crypto.
&gt; Why do you want to remove two of the most commonly used libraries from your code? "Most commonly used" doesn't mean I should use it. I don't require jquery + underscore and want to use a micro lib instead of that which will solve only my problem and not everything else.
mug throws an `empty` exception. EDIT: obviously didn't read all the text. Still think `mug` should be filled. Or mug should be passed to `person.setMug(mug)`, and `person.drink()` should not accept any arguments. Still, a lot of dependencies. A mug might not necessarily be filled by the drinker. It might be contained in a `Tray` or `Trolley` instance (implements `MugTransportDevice` interface). var coffeePot = new CoffeePot(); var teaPot = new TeaPot(); var office = new Office({ pots: [coffeePot, teaPot] }); var person = new Person({ name: 'lazyduke', office: office, prefers: ['coffee', 'tea'], sipSize: 2, sipDelay: 7500 }); var mug = new Mug({ size: 8 }); var dispenser = new BeverageDispenser(office.getAvailableBeverages()); dispenser.fill(mug, person.getBeveragePreferences()); person.setMug(mug); person.drink();
Ah but you see, these days, we don't write quick scripts in JavaScript. We write full-blown apps.
The reason I mention "commonly used" is that these are libraries that are provided for free on Google CDNs and most likely already cached in most people's browsers. Changing your SRC attribute to pull them from Google will likely improve your load times far more measurable than any attempt to replace them with strange libraries served locally. 
I also have an issue with this "requirement". What is the true purpose of removing the dependencies. No matter what library you use, you're going to be dependent on something for DOM manipulation (jquery) and something for list comprehensions (underscore). Maybe you're trying to cut down on the size of the libraries to decrease load times? If that's the case, you're actually doing a disservice to yourself by using other libraries. jquery and underscore are so prevalent on the web that most user's browsers already have them cached. This means your site will actually load faster with something like jquery (or underscore) than it will with a relatively obscure library like CanJS. Maybe you're trying to speed up your code? In this case, you might see nominal improvements, but you're sacrificing maturity and reliability. These are not good trade offs. JQuery has a HUGE community of really smart developers that have ensured the library works consistently across all browsers, which, trust me, is no trivial task. To say that you need something with no dependencies simply because you don't want any dependencies is illogical. The word dependency can have a negative connotation, to be sure, but in the context of web development, it's merely a word utilized to express a relationship. There's nothing inherently bad about a dependency. Your JavaScript code is dependent on the browser, and the browser is dependent on the OS, and the OS is dependent on the hardware of your computer. You can change your browser or change your computer, perhaps to a newer version, something that's faster, but you're always going to be dependent on them. That's my $1.02, anyway.
to be even more meta coffee = new Coffee() coffee.refill() if coffee.empty coffee.drink()
Depends on the implementation.
Beautiful.
Interesting to read, but that looks like a lot more code than I would need to do a similar thing with D3.
It's a bit more, but it takes quite a bit of code to do it with D3 as well, here's a 3 part tutorial on something similar: http://bost.ocks.org/mike/bar/
Try something like this: http://jsfiddle.net/Qj9ED/1/
regular expression would be safer var match = document.location.search.match(/page=(\d+)/i), page = match ? match[1] : "1"; 
Should be wrapped in while (true)
Amazing. Wondering how many polygons there are in a scene? i.e.: how much of this is geometry vs. shaders?
I've used OpenGL in C++... Never did something like this before...
Maybe you have to enable WebGL or something. It wasn't on in mine either.
We make them think it's submitted with a lovely thank you page. 
Just looking through the code confirms my fears of 3D programming: Tons of linear algebra.
Oh wow Jeez, how smart do you have to be to figure that out
TIL Firefox doesn't have event.toElement
Not really sure why using divs would be the wrong approach. When using them as rectangles, they'll perform very similar to SVG. If the visualization called for tons and tons of elements, canvas might be better.
One of these moments when being a nerd really shows. This gave me goose bumps :) Try to explain that to my wife.
I worked in an environment once where most news-list-type sites were blocked, which tends to be a big pain for a developer looking for information on the Googles. I ended up using an SSH tunnel to an external server I had running Squid (HTTP proxy), changing my browser setting to point at a proxy on my localhost (defined by the tunnel)... which gets you around the filtering software. Of course, this assumes they haven't blocked outbound SSH connections....
Here's a less functional way: (function () { var obj = {}; location.search.slice(1).replace(/([^&amp;=]+)=([^&amp;]*)/g, function (m, key, value) { obj[key] = value; }); return obj; }()); based on [work by John Resig](http://ejohn.org/blog/search-and-dont-replace/).
I normally would agree with this, biasedly as a CanJS contributor. However, it would really depend on how much getting rid of jQuery matters to /u/jsTea. CanJS does piggy back off of jQuery for DOM manipulation, but it also piggy backs off of a lot of it's utility functions as well. Sometimes straight up, sometimes modified to help with the live binding aspects and memory cleanup ([you can see for yourself here](https://github.com/bitovi/canjs/blob/master/util/jquery/jquery.js)). So if you are really serious about getting rid of jQuery, and you don't want to switch to something like Zepto, Mootools, or YUI, CanJS is pretty much dead in the water to you. If you're okay with keeping jQuery or one of the libraries CanJS supports, on board, then definitely full steam ahead. Transitioning from Backbone to CanJS isn't terribly difficult and offers all the goodies that /u/adrianmiu mentioned (live-binding, 2-way binding, computed properties, web components or "custom tags" etc).
I don't know the exact answer to your question, but why on earth are you trying to use synchronous XHR? You can convert any synchronous use case to an asynchronous one without much hassle. I think the browser makers would love to just get rid of synchronous mode altogether, as it's a constant source of headaches for them because of all the extra special case code required, and the fact that it's so rarely used that it gets very little testing. This is doubly true since you're doing a CORS cross-origin request, not just a regular XHR request. 
Absolutely amazing. To all the people who still persist that JS is just a "front-end language"... what more proof do you need? JS is robust in the front and back. A language to master them all.
why wouldn't drink take any arguments? Surely the speed of drinking can be defined. Drink = { SPEED_SIP = 1, SPEED_DRINK = 2, SPEED_GULP = 3 } person.drink(Drink.SPEED_DRINK); Not only that, but person.getBeveragePreferences() is ambigious. Which breverage are you talking about? You need a base Beverage class. function Beverage(opts) { this.name = opts.name this.additions = opts.additions } The additions of course, are stuff you add to your beverage so function BeverageAddition(opts) { this.name = opts.name; } So, things will start to look more like this: var Milk = new BreverageAddition({ name: "Milk" }); var Cream = new BreverageAddition({ name: "Cream" }); var Sugar = new BreverageAddition({ name: "Sugar" }); var MoreBeer = new BreverageAddition({ name: "More Beer!" }); var Coffee = new Beverage({ name: "Coffee", additions: [ Milk, Cream, Sugar ] }); var Tea = new Breverage({ name: "Black Tea", additions: [ Milk, Sugar ] }); var Beer = new Breverage({ name: "New Castle Brown Ale" additions: [ MoreBeer ] }); dispenser.fill(mug, person.getBeveragePreferences(Coffee)); And if getBeveragePreferences() encounters an addition that doesn't exist in Coffee (say, Ketchup), then InvalidBeverageAdditionException is thrown. 
This is a library that came out of a need I encountered on another project. I know it's a hack, but it seems to work well for some use cases. Does anyone know of a better way to achieve the same behavior?
I think is more related to CORS than to the 302. Since for a CORS request the browser needs to do a preflight one (with the OPTIONS verb), some browsers require you to make them asynchronously. 
I just stumbled across this issue when answering a question on Stack Overflow. I made a similar recommendation about not using synchronous requests. But it just strikes me as odd that a request can fail or succeed based on the synchronicity of the request. I would have expected the spec to say something like "The synchronicity **MUST NOT** affect the outcome of the request."
o man, another good reason for me to learn regular expression. good show.
Where is that mentioned in [the spec](http://www.w3.org/TR/cors/)? The only semi-legitimate failure reason I've heard of is: &gt; `If for some reason the user agent does not want to make the request terminate this algorithm and set the cross-origin request status to network error.` That part of the spec was intended to offer freedom to allow blocking blacklisted URLs or HTTPS-to-HTTP messages (neither of which apply here). The only other cases I know where sync vs. async makes a difference are: 1. `withCredentials` is not allow in sync requests (but that raises an error at property-set-time, not at fetch-time) and 2. Firefox (at least) disallows `Blob`, `File`, and `ArrayBufferView` objects as the arguments of a synchoronus send, to discourage sending large pieces of binary data synchronously.
Thanks I already have support from higher up, due to recent organizational changes the person I've gotten most of my work assigned from is now our department's director. He also understands the potential of the web based apps and reporting from what I've accomplished in the last year, and how much that depends on JavaScript. My direct manager also understands the need, as her boyfriend is a web developer.
Saw this a few weeks ago https://moot.it/blog/technology/riotjs-the-1kb-mvp-framework.html its a 1kb mvc framework with little or no dependencies
So simple, I forgot about that. I'll turn it back on. Hm, it doesn't like their address field though, but I should probably just suck it up and do it. Thanks!
would probably start with something which stores cell values in a hash table keyed off of something like `x + ':' + y`, where undefined indicates no value has been stored, and also keeps track of the maximum x and y values containing a filled cell. the grid then just queries the object by key, and an `undefined` result = an empty cell. inserting or deleting a cell then updates the max x &amp; y values if needed.
Saw this on news.ycombinator.com . Very cool, makes me want to learn some WebGL
Perlin noise(also simplex) is awesome when it comes to generating such cool randomness. Using black to white as 0-1 and applying it to, in this case, polygons to control the elevation and movement is most likely what is happening here. It's not simple but it's far from too hard to grasp through some gradual experimentation.
That too.
Grid looks to be 256x256 quads so 64k quads (eg. 128k triangles). However, most of the magic seems to be through multiple passes of shaders to final displacement and normal maps that are applied to the grid. The code, while not the *most* efficient or beautiful, is actually pretty readable and if you're not familiar with OpenGL quite educational (even if it's without comments) with a reference at hand. 
Here's a use case: I perform the synchronous request inside a Web Worker. There is no need to perform the request asynchronously if you're already in the context of another thread.
The book might be a deep dive but this review isn't
When WebGL becomes commonplace (and the implementations become close enough to each other!), the graphical side of things on the web will turn into something completely new. When WebAudio becomes commonplace, there will no longer be need for anything else, to be honest. Me and a couple of buddies from way back when recently decided to do a '[demo](http://en.wikipedia.org/wiki/Demo_\(computer_programming\))' in JS, for old times sake and to see how it would work out. It took a team of 3 coders, 1 artist and 1 musician ~2 weeks of random spare time work to come up with [this](http://brainlez.org:31337/) from scratch. All graphics in WebGL and audio through WebAudio, requires a pretty recent Chrome. My apologies for the kitschy music, design and crass style, but that's what our little group is (well, was) all about..
Does it work through a proxy?
see also: http://madebyevan.com/webgl-water/
Nice! As you said (and proved), there will come a time where we can create movies with just code. Another really good interactive movie created using WebGL is [Rome](http://www.ro.me/).
Amazing as it is we've been doing this creative, highly visual and interactive stuff on the web on any computer in Flash for *at least* 10 years. Browse the FWA archives and you'll see a cubic tonne of this and much more. It is just since mobile and tablets killed Flash and HTML becomes more capable that we're reinventing all of it based on wider standards that one day might work everywhere. Doesn't detract from your individual achievement of course
Stop being a bitch. Learn some math motherfucker
Hell, that vid is great! It fully explained everything to do with 3D graphics that I never understood before. You should post that!
Now that is cool! Thank you for the link!
This has happened to me at 2 jobs (current and previous), annoying as hell, but I understand why it's there. Both IT departments could add sites to a whitelist and I would just notify my boss with a business reason why I needed access to the site in question. Mu boss would forward it on to IT as a request to allow that domain. I would advise you talk to your boss about getting it whitelisted.
very cool
You over paid a buck. 
I can't find any controls, yet there looks to be some control outputs on the display. =(
The meters/outputs are the controls. That's the CSS 3d part of it, I believe.
Recommended reading: http://natureofcode.com/book/introduction/
Well, it's the eternal cycle of reinventing the wheel on a different platform, I feel. Plugins always allowed you to do 'anything' and Flash definitely was unique due to the crazy penetration it achieved at its peak. However, looking at the state of accelerated 3D in Flash, it doesn't seem to be even nearly at the same level as WebGL is already - Pixel Bender 3D/AGAL seems to be rather cumbersome compared to straight up GLSL. This allows us to do way way cooler stuff than with Flash, like the Ocean example above. Writing it in AGAL - while definitely possible - would've been a royal pain in the ass. I could be mistaken, though, as I'm not really a Flash dude so feel free to correct me! 
just go to the original one: http://jsfiddle.net/
That's what I tried doing originally, jsfiddle.net renders the results panel with fiddle.jshell.net so I get the company "blocked" message there when I click run.
Just remember, IE11 does not support (this was written 27-11-2013) IE conditionals, so &lt;!--[if IE 8]&gt; will not work, not even in emulation
Agreed. Perfect analogy with the browser depending on OS/etc. Hit the nail right on the head.
Works great for me.
Nope, if its in my browser (and can execute) I can de-obfuscate it. View-source fuelled the web so just embrace it. 
TL;DR: it's not worth it. Protect your code through copyright.
Sure, but no one in their right might is going to route their XHRs through "http://korz.tomodo.me/", right? So the first thing you'd do is set up your own proxy instead of using that default. And, if you are savvy enough to do that, you probably don't need help getting around CORS restrictions in the first place.
If you use something like YUI Compressor, you can minify the Javascript and rename variables and methods to things like `a` or `b()`. This will make it a lot harder to understand the code, and possibly more work to steal. It doesn't make it impossible by a long shot, but it might deter a couple people. EDIT: Plus, the script will be smaller and faster to download for clients.
This doesn't really answer your question but you could employ some server side processing that take the code out of the browser. I use JS to call PHP scripts occasionally but you could probably use NodeJS if you want to stay in the JS realm.
Minifying the source (via UglifyJS or Google Closure Compiler) can be an excellent deterrent to casual plagiarism. While it doesn't make it difficult for someone to wholesale repurpose your app's code base, it does present a hurdle to modifying or making partial use of it. In most cases the resources required to reverse-engineer are equitable to what it takes to build from scratch.
Best you can do is beautify, which is a far cry from "de-obfuscate".
Word! I stumbled upon the above link today several times and never did it occur to me that the text delivers proof for the claim in its headline... tl;dr it's a lie!
Didn't read the article, but spent a good deal of my time marvelling at the website. Holy Hell that's impressive.
What could possibly go wrong?
The parallax effect is neat, but a little laggy on my browser/machine.
asm.js is awesome. I can do cool shit in the browser without touching javascript. without even knowing javascript exists. anything that shields me from that monster is a good thing. plus ... it tends to be faster than what i could have written by hand.
No, best he can do is de-obfuscate. Best he can *automatically* do is beautify. But, like it was stated elsewhere in the thread, the effort to refactor source code that's been minified then beautified is non trivial, and may be equivalent to the effort to just reinvent whichever bit was needed.
I know, I'm the one who stated it ;) You have a point. My comment assumed an automated process.
You cannot protect or hide your source code by a technological or encrypted means. This does not mean, however, that you cannot protect your code from weak programmers. Typically people who steal code are shitty programmers or non-contributors and you can easily protect your code from these people by writing the code in way they are not willing to learn. There is nothing you can do to protect yourself against other programmers who are dedicated enough and passably competent. I will likely get down-voted into oblivion for this, but I have been doing this for a while and discovered that most programmers do not understand structure.... at all. The important thing here is that many programmers, especially noobs, think they understand structure really well merely because code or syntax is inherently structured on its own. Case in point: http://prettydiff.com/prettydiff.js The common reaction when people see that code is to throw up and blame every vanity excuse they can possibly think of starting with the single letter variable names. Single letter variable names are more common than people typically complain about and unless the code is a library for some API, in my experience, does not significantly impact readability if the code is already a complex algorithm. Either way, even when the single letter variables are replaced the code is still unreadable to most people because of its nested function structure. This is not a post pleasing short variables and I am not suggesting you do. Proof: http://prettydiff.com/rustdocc/master/rustdoc-search.js In that second code sample 98% of the variables are well named and the code is very short, but people still can't read it and don't know why. There are no vanity issues to whine about and it is well commented. I do not code with structure to piss off other programmers. I do this because it is a highly refined method of programming where I can do more with less code very quickly. If you bind the execution of code like this to the domain in the location.href you are probably pretty safe from code theft. The only fragment of code that I have ever been hesitant about exposing outright is the address for some API that is not mean to be accessed directly. Coincidentally, this is perhaps the only part of code that **can** be hidden from end user exposure. I often use a server-side proxy on my local web server for all XHR requests to bypass CORS. You can put the domain, or some other portion, of the requested address in the proxy so as not to expose it to your users. This is a rare case because it is purely about transmission. I strongly recommend avoiding mixing up execution components between server and client side. If there is any data you are exposing through the web there is very little you can do about protection. You can hide account specific data behind a log in account with TLS, but truly sensitive data should be considered exposed outright if put on the web.
That sucks. My current setup uses these three features. I didn't read our mini rant, but I guess I agree with it: ::rageguy::
Very very nice! Thanks!
I'm wondering: are there already general-purpose JS library that provide Asm.js optimizations? eg an asm.js version of jQuery?
I'm ok with the code, but I'd like to see a bit of recursion in there... I mean, if the coffee was empty I don't even get a drink!
Doesn't look like the matrix multiplication is being used for the simulation itself, only for simple camera manipulation with 4x4 homogeneous matrices. I don't imagine Strassen's Algorithm offers a performance improvement over the naive implementation used in such a small case; the overhead involved actually probably makes it slower.
Its a good practice to minify your code, for performance reasons. This will make it much harder to read, and in most cases impossible to "steal".
try doing a basic thing in a browser using Asm.js, like a textbox where you can type, etc... you will see that it is easier to learn de current API than to reimplement it from your favourite language.
Agreed. 
probably because you need a new, faster machine?
&gt; View-source fuelled the web Amen! I first learned how to make hyperlinks in ~1997 by deconstructing the yahoo.com source. It's the beauty of the web.
&gt;an asm.js version of jQuery? There will never be such a thing. With asm.js, you basically get some typed array as "RAM" and you can use arithmetic to modify it. That's the kind of thing it does. jQuery doesn't contain significant amounts of arithmetic. jQuery itself actually does very little of the work. All of the heavy lifting is done by the browser. jQuery just makes it more convenient to delegate that kind of work to the browser. It provides a nicer more uniform API. Asm.js isn't of any use for typical web applications. E.g. things like Gmail, Google Maps/Docs/etc, YouTube, Twitter, Facebook... whatever. Asm.js doesn't help with any of that. (In fact, trying to use asm.js for that kind of thing would make your life completely miserable.) Now, if you were to write something like Photoshop, then asm.js could be useful for some of the filters. However, if you're starting from scratch, you probably wouldn't want to write the whole application in C. Asm.js' utility is very limited. It's basically only useful if you have existing number-crunching libraries or applications (games, ideally) which you *also* want to get onto the web.
Ok then jQuery was a bad example. [Pathfinding.js](https://github.com/qiao/PathFinding.js) for example, or the [pixastic library](https://github.com/jseidelin/pixastic)... Any such library provided with Asm.js optimizations? wouldn't that make sense?
Firefox's hadware acceleration is known to make [backgrounds laggy](http://support.mozilla.org/en-US/questions/952443#answer-414431).
Interesting, is there any advantage to using this instead of simplex. Could it be a combination of both? One for the larger wave motion and the other for the more detailed depth map.
I was under the impression AGAL was quite capable, enough to do pretty much anything. Flash and AGAL is also an export target for many 3D engines and cross-compilers now (Unity, Madreel etc). the Unreal Citadel thing was first show on Flash (now it is WebGL). What could be causing a slanted impression of capability is that the creative-coding community that made Flash so big for amazing stuff is now moved to HTML5 tech (and so are not making new Flash demos). Plus many OpenGL people who never liked Flash are now coming in to WebGL from the other side and do insane stuff. Flash is great tech but the audience is evaporating. But I'm not clear on the exact details of AGAL vs WebGL, shaders go a little beyond my skillset.
Asm.js isn't a JavaScript replacement. The overlap between applications which were written in JS and things could benefit from asm.js is *very* small. If you want a replacement for the more common cases, try Dart. It's the only option which offers better semantics without negatively affecting your workflow. It's shipped with a build of Chromium which supports Dart natively, which means you get the usual save/F5 dev-cycle and step-debugging also works as usual.
What technologies need to be up to date?
true , it is. but that's not something to be proud of. nor something to cherish. javascript should die a very very very painful death. for the small things dart &amp; friends could be fine. for the bigger things one should be able to write it to bytecode from whatever language.
A wouldn't complain about a common byte code, but which byte code? Get everyone to agree to compile to the JavaVM? The .net CLR? Parrot?
You can get *close* to protection programmatically by minifying -which is a good idea anyhow-, obfuscating and by running your JS server-side in node.js. An interesting idea to help further secure things is using a NativeExtension, per this [StackO post.](http://stackoverflow.com/questions/5951302/node-js-code-protection) achen2345, I'd be curious what you think of that. All that said, I protect my code chiefly by copyright (one of the reasons I formed a LLC). It's the only way to be sure. 
I wouldn't worry about it - Only weak programmers would want to 'steal' your code. Anyone with any ability could figure it out on their own. Conversely - the better you get, the less you worry about people stealing your code.
Well, I've been using the Box2D version made with emscripten and the performance is amazing
For anyone just wanting to see the Unreal asm.js demo, it's buried about 4 sites deep: http://www.unrealengine.com/html5/: 
You will see it, yes. ES6 had a proposal called "Typed Objects" (previously known as "Binary Data") that would, among other things, include the concept of value types which would give transparent integer types. This set would likely include Int64. At the last TC39 meeting the entire Typed Objects work was deferred until ES7, so you won't see it for a bit. The good news is that Dave Herman has done a lot of great work on Typed Objects so I would guess it will be among the first ES7 features to stabilize and ultimately be implemented.
Actually I agree fully, though I note that what everybody else has done in the last 2 decades in the field has been inventing a new bytecode for their specific application. Which is why I find the hating to be funny, as asm.js is a solution that is out there right now that works cross-browser, as opposed to some hypothetical unicorn VM that would solve every problem.
How long did this take to program 
Not fully stabilized, but definitely close. Parts of it can be considered stable (WeakMaps, Maps, and Sets for example were stable enough to ship in IE11). Best place to follow the action is to subscribe to the es-discuss mailing list (or, use the nice [web interface](http://esdiscuss.org/1)). The notes from last meeting were just posted too if you're interested.
which is why i said it's a godsend since i dont have to touch js. the less i have to touch it the happier i am. and it can do quite a lot of shit thins asm.js . 
Have a bit of a question - how many people actually care about this, and why? I minify my code out of good-practice, not out of fear of someone stealing it. The core of where my company makes their money is what is going on with the back-end - even if someone was to completely, 100% rip off my client-side assets, unless they had the back end and the other 'value add' stuff that we provide, it won't be doing them that much good and I don't view it as competition/a problem. I could see an issue if your app was entirely 100% JavaScript, and you intended to make money off of selling it - but even then, copyright and trying to enforce it is a better way to go, and try to have the support you offer for your product be a reason why people would pay for it. So much of my knowledge as a programmer has come from open source projects, viewing-source to see how other people do things, reverse engineering other code, etc that I have no issue if someone was inclined to do the same to my stuff. Even at work, I've had a few people question my push to a SPA for a new application we are building due to how much is done on the client side and and 'can't people steal it?', and I honestly can't help but think "so what?" - if anything, one of my end-goals is being able to split out major parts of the client side application into open-source projects. 
pNaCl uses LLVM IR bytecode.
Javascript is missing one really critical feature, which is hard to replace by adding layers on top of it: a module system. Without the ability to easily import another chunk of code, you're always stuck with the problem of managing all your dependencies by hand. (To be fair, I don't really know how well things like RequireJS work, but my sense is that they're a pain in the ass and kind of hacky.)
Require works pretty well, but it is designed to run in a browser. Common is in my opinion a better solution, and is used in node, but annoyingly doesn't work in the browser as well as require does.
Your original question implies that you're new to JavaScript and web development. Then you say you've got a "very innovative UI" and that the app will succeed because of the UI. No, it won't. There's a naiveté to your posts that leads me to believe you're new in this area, or at least new to JavaScript. You're not going to build anything so innovative that it alone will sell the app, particularly if you don't have a few years of JavaScript under your belt. If your app solves a problem, solves it well, and it's a problem lots of people have, you'll be successful. But UIs alone don't sell apps. And like everyone has already said, you can't really protect JavaScript code, and you certainly can't protect a UI. It's visual. If you display it, I can mimic the idea, with or without your original source code. If all the value is in the UI, you're in for a lot of trouble on multiple layers. I'm not trying to be mean, but we need to pull you back down to the ground. Feels like your head is in the clouds right now. 
Generally, I would have agreed with the rest of the commenters here. You cannot assume that any applied obfruscation of your code is secure, since your browser NEEDS to read the plain source. And if the browser can read it, the user can, too. On the other hand, there is this project that blew my mind: https://jscrambler.com/ I dare to say the encryption/obfruscation they apply is unbreakable for most people. Since I haven't ever used it myself, I cannot give any hints about its performance, tough. But this seems to be the most advanced approach on encrypting Javascript code I ever saw.
Here you go: http://jsbin.com/ezACANA/1/edit
I've fixed your example. You should also enter your javascript and css in the respective frames in jsfiddle. When you are using document.write() it will replace the full page with the contents, thus removing the button to add another wood. You should display the 'total wood' inside a div element and just update the 'innerHTML'. Here is my example: http://jsfiddle.net/3BL82/1/
Thank you!
Thank you!
I'm actually going to get a JS book around christmas already :)
I just jumped right into it. Was asked to make a project and build it. I recommend you read up on jquery as it is very helpful for many things.
Its right choice to learn Javascript after html/css. Following is a accurate roadmap to learn about Javascript as well as Jquery and involved mini projects to build related skills. http://javascriptissexy.com/how-to-learn-javascript-properly/
You can also try with css3 transforms - could work better on low-end devices. As seen in here http://www.spielzeugz.de/html5/compare/ Maybe not the way everyone would like to solve this problem, but surely easier.
Holy crap, I missed this feature in Sublime Text, and weren't really convinced to WebStorm which had this ootb. Thanks mate, great stuff!!
Would be also cool, if it handled several files at once, or all unmerged git files perhaps? For example git st -s |grep ^UU --color=never |cut -c4- |xargs sickmerge -s javascript git st -s |grep ^UU # lists unmerged paths cut -c4- # for having only these paths listed, without "UU " xargs # for running sickmerge on every path listed But it won't work this way, just giving the idea :)
However if you're doing in-browser crypto, then you have no way of ensuring the Javascript sent to the browser is actually the Javascript you sent. There is an IETF draft for HTTP Signatures for a way of addressing this sort of issue (http://tools.ietf.org/html/draft-cavage-http-signatures-00), although it expired earlier this month... 
The code you're using to construct the JSON is messy. Id recommend making an array then assigning the key 'returned_comments' an array and then pushing into that array. *Edit*: It would be helpful to post the JSON output your code is producing aswell.
Post the bare minimum of your code so we can take a look at it.
lol, ignore me, I didn't see your links
I think this ends up being about the same structure as you want? And because it relies on just json_encode to encode the JSON, it should at least parse $json_array = array(); while ($row = mysqli_fetch_array($allcomments)) { $json_array['returned_comments'][] = array ( 'comment_id' =&gt; $row['comment_id'], 'comment_video_id' =&gt; $row['comment_video_id'], 'comment_author' =&gt; $row['comment_author'], 'comment_text' =&gt; $row['comment_text'], 'comment_timestamp' =&gt; $row['comment_timestamp'], 'comment_uuid' =&gt; $row['comment_uuid'], 'comment_parent_uuid' =&gt; $row['comment_parent_uuid'] ); } echo json_encode($json_array); 
Can you post the JSON that's being output by the php script? Also, although it's not really any different, I'd probably use $.ajax() rather than rolling your own xhtml req if all you're doing is grabbing JSON. something like: $.ajax({ url: '&lt;path&gt;/comments.php', dataType: 'json', //jsonp if it's a cross-domain request success: function(data) { $('#output').html(data.returned_comments[0].comment_author); } }); should do pretty much everything you want it to.
Aha yes! indeed [it uses asm.js](https://github.com/kripken/box2d.js/blob/master/box2d.js).
Thank you!
thats why I mention it...
Oh, if you're transferring the JS over SSL you're okay (although at the mercy of whether the browser environment has proper random support, at the very least), and I suppose I can see a use-case where the file is to be encrypted and kept locally, rather than moved between systems... I just tend to presume people see JS crypto as an alternative to SSL, rather than layering the two. 
So is the december 2013 date for the finalization of the spec going to be pushed back?
&gt; TL,DR If you're serious about making money in the software business, freely distributing your source code with every application instance is not a good business model. Redhat seems to do ok.
Sounds really good! I've installed it, hopefully I will remember that I did so the next time I get a merge conflict.
Start using jQuery without a proper knowledge of JavaScript is the worst thing you can do.
Yeah, in my initial question that type of situation is where I could sort of understand the desire for this. But, I also question if that is a viable business model. Maybe I watch Dragons Den / Shark Tank too much, but that sort of seems like 'it's a product - not a business'. Even if you look at companies like Telerik that do have UI-components as part of their business, it is just a part of their business and they offer other services/products to really make a business out of it. It sucks that your friend had some success quickly evaporate because of this, but if a client-side component was his only product/service - just seems a little short sighted from a business perspective. I don't know the whole story, but that sounds like it was part of the reason why it failed in the long run - but not necessarily the only reason.
&gt;And if the browser can read it, the user can, too. let's make that: if a machine can execute it, the user can read it. binaries can be reverse engineered, a bit of js obfuscation is not going to stop anybody. i mean, while we're at it: can you point at any DRM scheme or other form of copy-protection that works at all? they're all just designed to make it harder, not to stop anybody. for perfect protection you would need complete control over the users machine (and still people manage to screen cap in cinemas) or not distribute your work at all.
&gt; I can mimic the idea, with or without your original source code Yes but the point is that if he can with minimal effort make it harder rather than easier for you to mimic a potentially competitive idea (let's just assume for the sake of argument that it is, since neither of us has seen it), then he should probably do so. I think we can all agree that discouraging people from exploiting others' work is a good thing. While you're toiling away trying to reproduce his innovative UI, he stays ahead of the game innovating his next feature and growing his user base. Of course that's a simplified scenario; the factors that play into an app's ultimate success are numerous and complex. But I think a lot of people make the mistake of underestimating the significance of UX in that formula. I agree it's unlikely for a UI to serve as a product's sole basis of differentiation, but it *has* happened. Look at Mailbox. As an aside, I don't get why people get so religious about open vs. closed source. There are good arguments to be made for both, and ultimately it's an author's prerogative/responsibility to decide if and how he wants to share his work product based on what he's trying to accomplish.
let's make that: a bit of js obfuscation is not going to stop *everybody*
But what about a Java applet inside Sliverlight inside Flash inside ActiveX inside Silverlight inside a Phonegap emulator inside a Java applet? I think that'd be pretty secure.
I didn't mean that he should start out using just jquery. IMO it's a good idea to learn as you go along.
&gt; (d) Maybe you were making a joke? ;-) I thought that was clear from the beginning
Why did you make the decision to use classes instead of data attributes? Looks pretty interesting otherwise.
I wouldn't expect to see any changes other than bug fix level stuff after the Jan meeting. Things are mostly final now, just a few mostly minor things outstanding (modules, for example, is coming in hot, and Allen has a lot of spec work to do). AFAIK we're still going to see ratification at the ECMA general assembly in Dec 2014.
No, it isn't. You have to know the language. Syntax, variable &amp; function scoping, object model. Then you can start using advanced APIs and libraries such as DOM and jQuery.
Laces.js is a model-only library i use that with [promise.js](https://github.com/stackp/promisejs) or [reqwest](https://github.com/ded/Reqwest) for xhr/transport and [React](http://facebook.github.io/react/) for views/dom/ui rendering.
&gt; you're going to be dependent on something for DOM manipulation (jquery) If you dont have that requirement, lets say you use React to render the UI parts, then jquery is a bit large just to get the .xhr() method. Then its a good idea to replace it with something smaller if you are concerned about page size. 
Don't quote me on this, but I recall hearing that selecting by class is *way* quicker than data attributes.
What hit me when using React was the striking similarities to the QML language (from the Qt toolkit used to write native application UIs). I would love to see some of their [components](http://qt-project.org/doc/qt-5.1/qtdoc/qmltypes.html) ported over, especially the Animation and Behavior components. I was able to recreate their quite awesome ListView with a mostly 1:1 functionality. And if you are one of those that havent tried react yet, you really should give a chance, its quite enjoyable and you get sucked right in to producing code instead of having to read howtos or manuals. 
That's very fair. Personally I've been trying to define the line between performance and semantics for things like this. I was just curious.
http://microjs.com/ is a great resource for finding micro libraries to swap out for various tasks. I'm partial to zepto as a substitute for jquery. I would also like to note one more time that the size of the library does not necessarily correlate directly to the load time. If a library is widely used, it's likely that it's already cached on the client.
The fuzzy search plugin is pretty great. If you need Knockouts binding functionality etc... Then yes. I could see great potential for some projects I encounter where Knockout isn't being used or going to be used. 
Good stuff. I will eventually use this. Keep up the good work. 
There are a bunch of libraries you could use that create the table for you. Check out slickgrid and jqgrid.
I also learned Javascript by learning jQuery first. It was easy enough to pick up the small things I needed javascript for, and when I needed something more advanced, I learned more. I later had to go back and relearn a lot of the parts that I'd completely missed out on, but from being used to working with jQuery, it became a lot easier to learn. It's not like I could have just told my boss "No, no, sorry, I have to go and learn how to add and subtract things in this scripting language first and learn what closures are and how to take advantage of promises before I write this simple twitter feed for this website. Be back in a few more months when I'll be hirable again!" Granted, it doesn't sound like OP has to do this for his job, but still, it's really not that difficult to start working in jquery now and learning javascript at the same time. I learned C# at the same time I was learning ASP, and I didn't die.
Perhaps the correct word to use would have been "execution". For example: There are countless services that allow you to rent recently released movies and play them on your internet connected device. I bet you've thought of at least 2 by now. The ones I thought of are iTunes and Vudu. Both have the same features. Both probably have the same kind of code base. But one definitely stands out from the others: iTunes. Why? Because of their execution. So, let's start at the beginning of the product cycle: **Step 1: Idea** Who gives a shit? I pop a great idea out by the time I've finished my morning wank. Ideas are a dime a dozen. No one will pay you for you ideas. **Step 2: Development** This part is actually -expensive-. You spend your time (the most precious currency you have) writing the code, or your money on contractors to make the idea a reality. **Step 3: Execution** This is where the product actually becomes a reality. So you've got a product that's not much different from your competitors. How do you differentiate yourself? By having a different business process. At this point, no-one who understands any kind of business would be willing to take on the burden and responsibility of making your idea and code into a money making endeavour, much less trying to -steal- your code and determine how to make money on it. **And one more thing...** And let's go one step further: In this case, you're talking not about the full stack, but just the front end. There's no way to know what your back-end -actually- does. It's completely worthless to worry about the security of your front end code. Also: Security by Obscurity (I.E.: Security due to minification and scrambling) is the worst type of security. But that's an entirely different conversation. **To Sum Up** Stop worrying about the security of your front-end code. No one's going to steal it, and even if they do, it's completely worthless to them. 
With that amount of items, it is going to best best to render the table on the server side. The best thing I could suggest for how to speed it up on the client side is to paginate your results, or use a customized form of infinite scrolling to load more items as the user scrolls down the page.
You went on to point out UI apps that are successful. So, obviously it isn't the issue you think it is. While I don't fully agree with your examples I do believe they exist. Analyzing the apps you mentioned in a reply just above this, none of them do/did anything new as far as the UI goes. Hotmail and gmail didn't invent webmail and their UIs are hated by many. Facebook, most people hate the UI. Flipbook: there is nothing new about skeumorphic page flipping. All of the apps you mentioned (besides Facebook) were venture capital backed (or done by giant corps) before going public. Facebook used genius marketing (exclusivity) to become popular. In addition, if you think that Facebook is only a UI you really need to rethink some of the backend code they write. (Backend code that they also open source.) I think you have unrealistic expectations.
Some good info at these locations: http://www.joelonsoftware.com/articles/fog0000000319.html http://stackoverflow.com/questions/7299010/why-is-string-concatenation-faster-than-array-join 
I built this twitter tool to quickly present a list of "important" twitter users given a topic or list of topics. It determines whether a user is someone worth chatting with based on certain parameters being met. This was intended on being a marketing tool but I figured others may be interested in using it. Any questions please ask i'm interested in seeing what others think.
Yes. The world would be better off with more open source projects and without kooks trying to hide away their "magic" javascript. I also notice you fail to acknowledge that the UI's of those sites are not proprietary.
I use data tables at work. Fantastic product if not a little slow for HTML tables. 
&gt;Before Facebook we had email, ICQ, Flickr. Facebook's magic was it's ability to let us all go to a high school reunion without actually having to go. But at the end of the day, it's implementation is mostly in the UI. The backend is just a database of users and messages and images. Maybe you should see the amount of open-source work Facebook has done. https://developers.facebook.com/opensource/ (Most if it is backend code.) Their UI is easily copied and uses regular minified javascript and CSS. Nothing prevents a person from ripping off Facebook's UI. 
In another comment he stated that many stackoverflow questions link to jsfiddle.
Well you said that it is unblocked now, but if it happens again you could try creating a bookmarklet or browser widget that automatically injects custom js that overrides the #run action. The main part seems to be in Actions.js but it looks like you will have to dig deeper to find the right parts to modify. Edit: I wasn't paying attention when I made this comment. I meant to make it a root level comment instead of replying to this thread, but the OP will see it either way so I'm just leaving it.
php?
Data tables is the shiz
I agree he needs to quantify the necessity. It may be as simple as finding the count of stackoverflow links that he has used to complete bugs/features. After thinking about it though, the mods at stackoverflow are slacking if an answer links to jsfiddle rather than including all the code (or at least all relevant code) in the answer. 
Hey thanx. I've already got my extension made but that phonegap post was really useful. Nice blog.
When I made the first version 2 years ago I thought that classes would feel more natural to newbies, but since then have data-attributes become pretty much standard in the community. But today it's mostly a performance thing. List.js is supposed to be very fast and handle really long lists (check out http://sindresorhus.com/bower-components/ it has 6000+ items) Anyways, I'm experimenting with more a feature rich templating system and who know's what will happen in the future :)
I guess you want to know what to do in JavaScript about different browsers. First, not all browsers (especially older versions) support all features of JavaScript; e.g. IE up to version 9 were unable to select single characters out of Strings by direct address ("string"[2]=="r"), one would have to use .charAt(2) instead. There are two approaches, browser sniffing (finding out what kind of browser you got) and feature detection. Since user agents and all kinds of behaviour can be spoofed, browser sniffing is generally discouraged and feature detection is the way to go (except when the information you need inside your script is which browser is used). For example, you can test the availability of touch-Events (except those of Windows RT) like this: if ('ontouchstart' in document) ... If one finds an ability unsupported, you can either use graceful degradation (feature doesn't work, but page does) or feature enhancement (only provide features and optimisations if possible). Also, the performance of the Scripting interpreters differs vastly. By measuring the time before and after certain calls, one can make assumptions about that performance - and enable or disable certain abilities of the script.
Something about why there even is a difference between browsers. Browsers use an JS engine to interpreted JS scripts and execute them. Almost all browsers use different engines. The reason they use their own is they all want to implement functionality that is specific for their browser. [This wikipedia page](http://en.wikipedia.org/wiki/JavaScript_engine) gives an overview of current JS engines. Having different JS engines directly implies that they will not be 100% compatible. Although the compatibility has improved over the last couple of years (especially Miscrosoft's Internet Explorer), there is still some differences. These differences don't only exist between browsers but also between different versions of the same browser. For example, an update to Firefox's engine some months ago broke a script of mine...
This is the one of the best books that I have seen for learning javascript: https://eloquentjavascript.net/ It doesn't only teach javascript programming, but also it teaches you how to write clean and concise code. I myself started with w3schools. It taught me only the basics but nothing more. Then I read [MDN guide!](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/JavaScript_Overview) and it made me understand a lot of things better. Writing code in some big projects made me learn a lot of things by making mistakes. A lot things that I learnt by mistakes are covered in that book. I suggest the book rather than MDN or W3schools. In case if you know other languages and you have a basic understanding of javascript, then I suggest you read the [JavaScript: The Good Parts!](http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742) I have also heard good reviews from [Nicholas Zakas books!](http://www.amazon.com/s/ref=nb_sb_noss_1?url=search-alias%3Dstripbooks&amp;field-keywords=Nicholas+Zakas&amp;rh=n%3A283155%2Ck%3ANicholas+Zakas). They seem to cover more stuff about other side of things in javascript not just the language(the browser, canvas, performance, maintainability). More focused on web development.
I don't understand the question. It does not explain how you should incorporate your JS scripts into your websites. It just lists which implementations of JavaScript or similar languages are used in which browsers.
My guess is that unless you had a thousand things in a list to sort, you won't notice any performance difference. Especially since it would be handled client side, your server wouldn't know the difference either.
How long is it taking ? It's probably not slow. I don't know what happens when you call :.tablesorter(); But this code doesn't look like it's doing anything that would take longer than .5 seconds. There are two possible places where you would be losing speed: &gt; 1) the getJSON call to retrieve the data &gt; 2) the tablesorter method call Everything shown here is trivial and should happen sub-second. 
The "certain parameters" is really the algorithm used to determine the importance of each user. If you go into the app.coffee file and look at the parseTweet function that is the algorithm determining importance. Any questions or comments please put them on github so we can create documentation, thanks
Thank you Ill have to check it out today 
Thank you Ill have to check it out today
Server side is probably going to be my best option. Pagination is not an option for me, but thanks for the suggestion, I didn't know what pagination was till your post.
I still haven't come across slickgrid, ill check it out today. Thanks!
Best article I have seen on Javascript Objects so far is http://www.kirupa.com/html5/introduction_to_objects_in_javascript.htm 
It's a pretty good overview of the different ways to wield objects in JS. The parts about `this` might need some clarification / separate discussion. Some parts worry me, e.g. the part about hiding the `new` keyword within the constructor ... that's very bad technique, IMO, and not very common to boot. Also doesn't go into common practices for "subclassing" or extending objects, which would seem to be appropriate. It'd be nice to have some discussion of practical use cases for the different breeds of objects, too.
I cant page the data, it has to all be presented at once.
strange it works for me... try http://www.kirupa.com/html5/ and then go down to javascript and see introduction to objects
So I was reading the strict comparison spec, and I don't understand these lines: * If Type(x) is Undefined, return true. * If Type(x) is Null, return true. Why does this condition mean automatic equality? Am I missing something obvious?
Fair enough, didn't think about that
That URL is 403 Forbidden as well. The domain alone shows an Apache 2 Test Page.
has to be something with your computer/network, it works fine for me from home and from work. Try this man, I copied it and gave him credit. http://superiorsolutionsks.com/credit-to-kirupa-com 
Here is a neat site that might be able to help you: http://stackoverflow.com
jquery and underscore use it be as "idiot-proof" as possible, but I'd rather have a check within the constructor that says "you missed the 'new' keyword" (or at least a console.warn), rather than just silently fixing it. 
On the project page, you talk about not reinventing the wheel; so how is this better than existing templating languages? - swig (basically jinja in javascript) - jade - handlebars - ejs (embedded js) .... there are a lot of "full-featured" template engines out there.
Do you know a good article on inheritance in js?
Since you don't have prior programming experience, I recommend [JavaScript: The Definitive Guide](http://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527) and strongly suggest not reading Crockford's JavaScript: The Good Parts. I created a website called [CodeQuizzes](http://www.codequizzes.com/) to teach programming with hands on practice. Here is a [link to the first quiz in the Basic JavaScript series.](http://www.codequizzes.com/topics/26/quizzes/84)
just an idea, if you are looking for ideas or implementation comparison. the source code for angular's widely popular 'ng-repeat' directive might have some interesting things that could be used to build upon this or refine it. looks really cool though!
Thanks! I'll have to give it a read. I'm still learning so I have no way to gauge the quality of articles &gt;.&lt;
I began reading the "The Definitive Guide" book today, what else would you recommend me to become more than just 'familiar' of how javascript works. Meaning, how can I become very fluent in Javascript? Just keep on practicing and repeating the things I know? I would like your advice! And why the suggesting against Crockford's? Is it too advanced? Or poorly written? or etc.? I'll check out your website also!
It's helpful when your library uses method chaining as the new operator has lower precedents then the dot operator 
braille?
Not going to claim superior knowledge of the literature, but I just poked around a little ... * [This](http://markdalgleish.com/2012/10/a-touch-of-class-inheritance-in-javascript/) is an accessible primer to JS inheritance for someone familiar with OOP * [This](http://ejohn.org/blog/simple-javascript-inheritance/) is a solid, short article on inheritance using the `extend` pattern, which is what I use most frequently * [This](http://addyosmani.com/resources/essentialjsdesignpatterns/book/#designpatternsjavascript) is a tremendous resource that gives much more info on / use cases for various inheritance patterns (and a bunch of other stuff) 
That's not true. Try in your console:`new $('body').length` vs `new ($('body').length)` 
Eh the optional new trick has legit uses, the lack of reference to object.create and the lack of discussion on inheritance are bigger problems from my perspective 
I think this was actually a fair point. It's not about making `jQuery` and `Underscore` idiot-proof as it is about concision ... writing `new` for each invocation of these utilities would make the "wrapping" nature less apparent. That said, unless you *are* writing a wrapper library like `jQuery` or `Underscore`, you probably shouldn't hide `new`.
Thanks! Very helpful.
key word is method `new a().b().c()` is not very good especially if b or c are constructors which is not uncommon in things such as leaflet, even if I miss spoke about precedent (which is likely)
I started this, when reading your post. http://golmote.yzi.me/code_playground_converter/
I like this method of "fixing" the a missing new keyword: // object constructor function ObjectConstructor(a, b, c) { if (!(this instanceof arguments.callee)) { return new ObjectConstructor(a, b, c); } this.A = a; this.B = b; this.C = c; this.Total = a + b + c; }
You seem to compute values you probably will not use from line 50 to 57 in this file. Better put that code inside the if true statement.
There certainly a lot of "edit html live" sites out there, but my design with jazzui is to be different =). The main thing is that jazzui's exported code is immediately usable; you can start fleshing out your app without any setup. And I optimized it to my workflow ;) with angular, jade, lesscss and component(1). I also don't know of any others that are open source 
JS passes primitives by copy. You could make an object and pass that around, and it may do what you are wanting (http://stackoverflow.com/questions/7744611/pass-variables-by-reference-in-javascript).
It does nothing of the sort. You've completely misunderstood how it works if you believe that is the case. 
... not sure if troll ...
Yes but you can request the data asynchronously. There is a technique called infinite scroll. Basically you just load the data faster than the user can view it. It has all has to be presented at once is a relative term. You can't fit 5000 rows on a screen at once, so just load the data on demand. Check these stackoverflow questions out: http://stackoverflow.com/questions/12216471/endless-scrolling-on-table-infinite-continious-scrolling-jquery http://stackoverflow.com/questions/11688279/jquery-infinite-scroll-on-a-table Also: https://github.com/paulirish/infinite-scroll Paul Irish is the man. 
Ah, that makes a lot of sense. Thank you for for taking the time to explain it, I really appreciate it. like I said I have only been doing this for about two weeks.
Java is a completely different language from Javascript.
Have you heard of UnGit? This would go well with it. http://www.youtube.com/watch?v=hkBVAi3oKvo https://github.com/FredrikNoren/ungit
You don't really need pass-by-reference to implement what you're trying to do. Pass the `foo` instance to `bar` and store it there: var foo = function() { this.var1 = 0; } var bar = function(foo) { this.foo = foo; } var test1 = new foo(); var test2 = new bar(test1); console.log(test2.foo.var1); // 0 test1.var1 = 5; console.log(test2.foo.var1); // 5 This is not pass-by-reference, because a copy of the argument is still (always) made, but the thing being copied is a reference, so it's passing a reference by value. This is better referred to as [pass by sharing](http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing). 
Not valid in strict mode though.
We've been using browserify which lets us write browser modules in CommonJS style. It lets us share code between the client and server and has been working very well.
I live in Briz, fantastic city, thriving dev community. Check out http://bristolskillswap.org/ and http://www.meetup.com/bristech/ for some get-togethers, hit me up on twitter using the same handle and I'll do some introductions! 
As a relatively new Javascript and Node programmer, this is how I originally expected async to work. I come from the semiconductor side of the world where parallelism is designed into our hardware modeling language (SystemVerilog). SV's [fork and join](http://electrosofts.com/systemverilog/fork.html) structure made the most sense to me, and your implementation is quite similar to the "join" construct that I am familiar with and frankly feels natural.
Good but I prefer the discussion of object creation patterns in Javascript: The Good Parts by Douglas Crockford.
As long as you don't use the article as a "how to do" instruction, it is an excellent overview of how objects work in JavaScript. In my opinion, the best resource on JavaScript and other Web technologies is the [Mozilla Developer Network](https://developer.mozilla.org). Relevant to your interest: [Inheritance and the prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain).
This makes sense, and I do hope it works this way. Thanks.
The "Definitive Guide" is more than a thousand pages and if you make it through the text, you will have a very good understanding of core JS (i.e. JS independent of the web) and client-side JS. While reading the book, I recommend continuously drilling the concepts with quizzes and by building small applications (i.e. hangman, tic-tac-toe, connect-four). Once you get better, try something more challenging like building an app with the Instagram API. Crockford's book is great, but is best for ppl with JS experience. Good luck on your JS journey. It is a powerful and beautiful language once you understand it.
Good luck learning JS - it is an awesome and powerful language. I think you are doing the right thing searching for a programming mentor. I spent a year teaching myself how to program by myself and it would have been much easier to have a mentor when I got stuck on silly things. I live in NYC and might be willing to help. I've had a bunch of friends that wanted me to help them, but none of them were very committed, so I am hesitant to make a time investment again. In any case, this [JavaScript Is Sexy post](http://javascriptissexy.com/how-to-learn-javascript-properly/) and the [Basic JavaScript](http://www.codequizzes.com/) quizzes I made on my website should help you. JS is an awesome language - have fun learning it!
/r/learnprogramming
Node.js is a great one to learn if you want to do some realtime stuff. It's ~~super~~ easy to learn and requires minimal coding to do some really powerful things. I recently learnt it and built http://sidg.tl/sid as a result!
I'd love to do this work but first I need YOU to come and be a part of MY team and help assemble a wind turbine. If I like it, I will use it as part of my front yard and you will be known as a wind turbine assembly expert. Here is the manual: http://www.applied-sciences.net/library/data/zoetrope-wind-turbine.pdf Other sites: http://opensourceecology.org/wiki/Wind_Turbine Thanks, I look forward to being part of each other's team.
jQuery is probably one to learn first. Some JS libraries have a dependency on it (Backbone.js, for example) and it's become VERY widely used. Ordinarily I might warn you not to become too comfortable writing jQuery without knowing what's going on in the background, but I think you probably do know already... For example, jQuery makes ajax easier, compared to creating XmlHttpRequest objects yourself: http://api.jquery.com/jQuery.ajax It's also easier to find elements and manipulate them. If you want a nice helper library, I'd suggest http://underscorejs.org/ (or a faster expansion with less readable documentation, Lo-Dash)
It's really not that super easy. Especially the whole setup process and learning the environment which is quite different on a server from programming client side. But yea, it's great for real time stuff and your experiment is cute.
Start by asking yourself what exactly it is you want to build (web coding is a pretty generic term). Brush up your javascript. Then figure out (by asking/reading/researching) which RandomOtherThings.js you might need. Once you have this figured out, it becomes pretty straightforward. Play with these js libs and build your awesome applications! Good luck.
I don't understand exactly what the `toggle` does. What exactly do you mean by "toggle nested cells"? 
You can see one of the [Matt Cutts](http://www.mattcutts.com/blog/) videos from [their WebMasters channel](https://www.youtube.com/user/GoogleWebmasterHelp/) talking about it here: https://support.google.com/webmasters/answer/139394?hl=en The Canonicalization section is more targeted to situations where you're migrating the content yourself instead of setting up a mirror, but may be of interest: https://support.google.com/webmasters/answer/139066?hl=en
I like James Shore's [Object Playground](http://www.objectplayground.com/) - especially the visualizations and details about "prototype" being overloaded. It was linked by /u/kevinmrr in [Week 2 of JavaScript learning series](http://www.reddit.com/r/learnjavascript/comments/1pei6l/learn_js_properly_week_2_assignments/) over on /r/learnjavascript
OK well I struggle with learning new languages/libraries at times and that never happened with Nodejs, you are correct though the hardest part is the server setup.
npm init npm publish
:)) good one! So you're in?
i think [this site](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_data_attributes) will help you out.
**this** is not the current DOM element, it is the current FancyBox Object. It has a bunch of properties including href and element. So you have to use this.element.data. You can see this in the following [fiddle](http://jsfiddle.net/VJ89M/). Open the dev tools (console) and then click one of the images. You'll see what **this**, **current** and **previous** is.
Hey !!, two related items. First, have you considered that this might be over-targetted as a build system? Is that explicitly the only interest you want to foster in the project? It has an asset pipeline use, sure, but this is just a tool for composing independent little processes cleanly right? Second, have you seen [node-task](https://github.com/node-task/spec/wiki)? It was spun up out of Grunt, and is tools and tech for chained processes. It very similarly took Grunt's specific build-oriented mentality and tried to build a more general untargetted set of tools and capabilities for building/pushing data through/manipulating [Chain of Responsibility](http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) pipes and processes. I'm seeing some very strong parallels: Maven : Grunt :: Gradle : Gulp. I prefer Maven and think it's super easy to author for, and Gradle allows way too much custom one off slop, but in the Grunt to Gulp compare I'm finding Gulp strikes a way better balance than Grunt's cumbersome mechanics do. 
What exactly makes it simple? Where are you storing the data? Is the goal to have something similar to SQL Lite?
ahh. so "element" isn't part of javascript, it's a property that Fancybox added within the Fancybox object. is that correct?
I'm sorry that you didn't take a closer look at the article. It was meant as an introduction on how to use the yeoman generator. There's no reason for me to make an overly complicated example when I'm just trying to illustrate the workflow with the generator, and in fact, I intentionally made it as simple as possible so people learn only what they need to know to use it.
exactly. They're doing it [here](https://github.com/fancyapps/fancyBox/blob/master/source/jquery.fancybox.js#L266) in the fancybox code.
&gt; Where are you storing the data? From a cursory glance at the code, it looks like it uses the Node.js file system module to write to a path that you supply.
 Number.prototype.foo = function () { return 'foo'}; console.log((5).foo()); // "foo" console.log(typeof null); // "object" I don't really see what's supposed to make those "primitive" compared to other objects. Also, if you call default built-ins "primitives", you should perhaps include Array in that list. (By the way, that's not the spec.) Anyhow, from my point of view, everything-is-an-object languages simply don't have primitive data types. They have built-in basic types, but not primitives. Primitives aren't objects. They hold this one value and that's all they do. Having primitives in the language is one of Java's warts, for example. They were added for performance reasons and because it made sense at the time. Nowadays, many view this as a mistake since it makes the language less consistent and kinda messy in spots. Thing is, making primitive-ish data types look like regular objects to programmers doesn't necessarily mean that you have to implement them as such. Under the hood, you can do whatever you want. Modern JavaScript engines, for example, will turn your `Number`s (doubles) into whatever looks more convenient to them. As long as the result is right, you're free to take as many shortcuts as you like.
Radio button labels don't seem to work in the demo.
At which point, it seems like one of the existing options (underscore, lodash, etc) would work just as well? Or am I missing something?
Ruby isn't JavaScript. It's its own language but it's very worthwhile if you're looking to build web applications. It's often used with the Ruby on Rails framework. As for JavaScript, jQuery should definitely be the next step because so many frameworks either use it or allow you to use it. I've been using Angular lately and if you're interested in single-page applications, it's a worthwhile thing to check out. It's surprisingly simple and can simplify your code tremendously. If works directly on normal HTML which can help with the learning curve. I like it a lot. Also, it's maintained by Google so it's got that going for it. Also, it's worth learning the new HTML5 tags and CSS3 selectors and capabilities. HTML5 is a significant advancement semantically and can really make your HTML much more readable. Code School has classes on HTML5, CSS3, beginning and intermediate JavaScript, Backbone, Node and jQuery and is well worth the subscription fee. I haven't used Backbone a lot, but Angular seems easier to me. I'm fairly new still so there's probably some reason to use Backbone instead, but not for what I'm currently doing. Node is mostly for server-side scripting so it's fairly specific for what you're doing. 
That is incorrect. JavaScript does have primitives. Take look at the spec. Number and string for example are not objects.
You are misunderstanding JavaScript types. When you do (5).foo() Javascript is casting a primitive to an object and then calling .foo on the new object. 5 is not an object by itself.
&gt; Number and string for example are not objects. They are. &gt;&gt;&gt; (5).constructor Number() &gt;&gt;&gt; 'foo'.constructor String() They have a constructor, methods, properties, and whatever. They are objects like everything else in JavaScript.
That's an implementation detail. With modern JS engines, you can create objects which behave exactly the same way.
Incorrect. Here is more information, so I don't have to copy and paste. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Distinction_between_string_primitives_and_String_objects . false !== new Boolean(false) // true
Those wrappers are something they copied from Java. They don't actually serve a purpose in JavaScript. They only make things messier. !!new Boolean(false) === true, for example. In Java, you needed them when you wanted to stick, say, some integers into an ArrayList.
Yes, even that part is discussed, but the main aspect here is about the bolierplate that yo creates for you.
Comic Sans
Hey guys, just released a little library for pixelating images or videos. Would love your feedback and help on improving it!
Every primitive type in JS has a corresponding object type. The number primitive value has Number, string has String, etc. In your example, you're taking advantage of the behavior of the [GetValue abstract operation](http://es5.github.io/#x8.7.1) that "boxes" the primitives with their corresponding object type prior to doing property access. This behavior is useful, as you've discovered, because it enables calling methods on primitives. When people say that JavaScript has primitives, they are referring to what the language specification itself calls primitives. You seem to be arguing that they don't meet your definition of what primitives are, which is fine, but I think the only definition that makes sense in this context (comments on a JS-related site) is the definition the language specification uses. Edit: oh, and typeof null is a basically an implementation bug that has to be carried forward for compatibility reasons. Brendan Eich (the inventor of JS) often expresses regret about this wart being in the language, and everyone on the committee agrees (afaik) that fixing it (ie. by making it return "null") would be for the best if it were possible. Unfortunately, Mozilla's investigations showed that it would break the web :(
Our department was tasked to do a desktop screensaver that would display upcoming events. The original plan was to make a web-service and write the desktop program in C#. The problem is, we were all web developers and have very little experience dealing with graphic presentation for native windows programs. We could make it, but it probably won't be pretty. We already had a website version of the event calendar, and I was thinking surely there must be a way to embed a webview in a desktop app. Then I remembered hearing about node-webkit from a JavaScript podcast, looked it up, and had a screensaver up and running in less than an hour.
Weirdly - they didn't work in my version of Chrome, but they did in work! It was coooool!
They are completely unnecessary. There is no point in exposing this piece of machinery to users. Did you ever use one of them directly? &gt;!!new Boolean(false) === true because [...] I know what it does, thanks. Anyhow, as I said, they only make things messier.
To me, it doesn't matter if they only look like objects due to magical auto-boxing. From the user's point of view, they always behave like objects and there is no way around it. They aren't like ints in C or Java.
Boxing only comes into play in a few cases (one is `foo.bar()` where foo is a primitive value). Otherwise, there are a number of ways primitive semantics and object semantics differ. Couple of examples: * primitives are immutable and are passed by value rather than by reference * they cannot have properties added to them * they cannot be proxied using ES6 proxies * they cannot be used in ES6 WeakMaps There are very many other places in the specification where the behavior of primitives and objects differ. Consider the following code sample (try walking through the [spec for property access](http://es5.github.io/#x8.7.1)): var x = 1; x.foo = "hello"; console.log(x.foo); // prints undefined In this example, after line 1 `x` holds the primitive value `1` On line 2, x.foo will first evaluate x which is a reference to the primitive value 1. The next relevant step is the evaluation of the [assignment](http://es5.github.io/#x11.13.1). Since x references a primitive, GetValue will box the primitive in an object. We now hold a boxed primitive, and then add a foo property to it with the value "hello". Notice we haven't stored this boxed value anywhere. In fact, it is eligible for garbage collection immediately because x is still just referencing the primitive value. On the last line we attempt to property access on x again. Again, we box, resulting in a completely new instance of the boxed value. This instance doesn't have any "foo" property, so it returns undefined. 
&gt;primitives are immutable and are passed by value rather than by reference If they are immutable, how would you know? You can't change them either way. &gt;they cannot have properties added to them Yea, you can make objects like that, too. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
I guess I meant in the context of JS, but you're correct that other languages can choose to provide primitives that are objects.
The Wilhelm Scream of fonts.
That's a really cool webapp you have there!
It's nice! but not sure what you're trying to achieve, because there are tons of great libraries out there. For example https://github.com/evanw/webgl-filter.
Love datatables. I've dumped up to 4,000 items in a json file to data tables before it began to really slow down. Also, if you have your data in a .csv file use mr. Data converter to create a json file quickly http://shancarter.github.io/mr-data-converter/
Freelancer, where people go to either get burned, or they sell premade html templates for a quick buck
Love it. It was a steep learning curve for me, but with every new thing I learned, I gained tremendous amounts of productivity. I use it for everything from quick-and-dirty apps (you get a lot out of hooking up a single controller to a single web page) and very large, multi-module applications.
I totally agree with this sentiment, that this is the direction development is going in. More and more logic is being abstracted out with every new tool that comes out, and I find that with Backbone I end up re-implementing stuff over and over again in different projects. I'd rather have some kind of tested, reliable framework to handle this repetition for me. There is nothing stopping you from cracking open the source code for the framework when need be.
I think Angular has a bit of a learning curve, but it is in my humble opinion the best JS framework out there today, it has a lot of parts that helps organize and modularize your app. However other JS frameworks like Knockout, Amber and Backbone are also great frameworks, and in the end I believe it is more of a personal preference. 
Wow, under an hour? You're kidding. That is really amazing. I can't wait to get it installed and start playing with it. No issues getting it to render full-screen?
I can't speak for everyone but I do like Angular. I chose it over several other options. Angular is compatible with my brain and my engineering team. JQuery is emphatically not. Angular lets me extend the behaviour of the browser. This keeps my apps close to the underlying reality and minimizes the fight-the-framework problems. I see no evidence whatsoever that this is a Google herd phenomenon. Angular was, if anything, under-represented at last year's Google i/o conference. While it's true that Google's support of Angular lends confidence it isn't really a guarantee of anything. 
What are the frameworks that you tired by building a proof of concept app?
As someone who learned and liked Backbone first, I started Angular with some skepticism and saw the same issues as you. But after some time, I started to get it and like it. The logic in the HTML can be kept to a minimum, then moved into a custom directive when it becomes complex. The attributes can also be self-documenting for what is declared to happen in that HTML (without need to search elsewhere). The automagical stuff is not actually as complex as it first appears. It's singletons, caches, and parsers with its own life cycles that is similar to the DOMs. Sorta... It does have a learning curve (sometimes a sine curve), but the pieces start to click. And no more hair pulling when I forget to use a setter/getter correctly.
I've never worked with angular and really don't know much about it. I am intrigued. Can someone explain its benefits and how it increases productivity? 
Really the main benefit that Angular provides is that it makes things easier to test. That's what a lot of the "magic" is for.
How do you feel about the Angular documentation? I was involved in a project with Angular for a few months but I found the documentation lacking or very hard to understand at times.
For me, graduating from jQuery to building out an app in Backbone was a revelation, it taught me how good JS could be written, with classes, models, collections, etc. For a non-CS background person this was just the stepping stone I needed to take me from "web developer" to "javascript engineer". With the way the wind is blowing I will probably try to build my same demo app that I built in Backbone, into Angular.
I use backbone/marionette at work, and I agree. It's easy to pop into the annotated source and see exactly why something is doing what it's doing. It's also small by nature and has a better talent pool (been around longer/less to learn/my opinion) which makes on-boarding of new team members less of a hassle. I don't know how long that will be an excuse for though. We have a team of 5, and the backbone/marionette framework is working really well. (Using this combo was decided before I work there.) I also have a large side-project with a thousand users. That was built on AngularJS. Don't get me wrong, there is a learning curve, but once you get past that it's quicker to develop. ----- **Secret Sauce** &gt; Having said that, I feel like there is just too much "secret sauce" involved in Angular's operation, and as an experienced developer it makes me feel a bit uncomfortable It's not so secret. AngularJS docs/videos/source make it easier to figure out what is going on under the covers. Also, **it is the sauce** that makes development so fast. There is a tradeoff that should be evaluated based on team size and project timeline. ----- **PS:** If you choose AngularJS, check out [ui-router](https://github.com/angular-ui/ui-router) which is part of [angular-ui](http://angular-ui.github.io/). The built-in router was my biggest issue with AngularJS. This replacement is top-notch.
It is genuinely quite good. Very terse, and solves a lot of common use cases. It is pretty fearsome to learn, but no more than any other JavaScript framework. Most importantly I have yet to encounter any dead-ends.
The only think I dislike so far is that it is missing a Model definition. That would help. Yes binding is great but still.
You *should* test every few lines of code...
There wasn't a Javascript lib for getting stats from [sc2 ranks](http://www.sc2ranks.com/), so I thought I'd start one. The query builder pattern described in the README has currently been factored out, though I'd like to add it back in. Currently fairly incomplete, but a good start. Feedback / PR welcome.
I don't think it was all google duping us into it. When you first get into using angular, it's quite exciting. A lot of webapp frameworks use object models like traditional desktop GUI toolkits. As a web developer, it can feel like you're throwing away the ability to clearly layout your UI in code, losing some of the benefits of a page of markup. Sure you can have HTML templates, but they're scattered and it takes some hunting to work out what goes where. The you start with angular and it's like coming home. Except that your house has been decked out with the latest home automation systems. It just feels right. You can knock up demos and create a UI that relates directly to the business models you are serving up from your code-heavy Java server. It all feels like the state of the art has turned a corner and fe development will never be the same again. Then one day you realise that the shiny new gadgets in your house don't want to play nice with the old gadgets you have relied on for so many years. Angular is largely incompatible with anything else and the community has taken to claiming this is a good thing, re-writing jquery plugins from scratch. There are some apps that angular just isn't a good match for - they make this clear on the home page - but it's easy to get carried away with it. TL;DR - its not just a fad, its worth learning and using it, but the community does expend a lot of effort ignoring problems with the fundamentals.
Our team has favored [React](http://facebook.github.io/react/) over Angular for one reason: the ability to build components from other components. Has anyone found this possible with Angular directives without having to bend over backwards? We're keeping an eye on Polymer for its composability too. Edit: typo
Except that those pages are minimal, and usually don't even point you close to the right direction of what went wrong. You can't even get a damn file name of where the problem occurred, most of the time, much less a line number. I've done a couple of very large projects with backbone, and am now doing a large one with angular. So far, I like angular a lot more than backbone.
Talk about secret sauce. I read a lot of stuff on the web every day but, today, is the first and second time I've ever seen the abbreviation 'SPA'. Google gives me nothin'. What is that?
What is SPA? I wish people could type out the whole series of words first time, then use an abbreviation. 
what's the distinction? i'm looking for a good wikipedia comparison.
[Single-page app.](http://en.wikipedia.org/wiki/Single-page_application)
[Single-page app.](http://en.wikipedia.org/wiki/Single-page_application)
Single-page application. 
While I think this is really cool, I'd probably stick to just using the [current api](http://www.sc2ranks.com/api/). The query builder is neat, but kind of an extraneous feature imo. Does this do any sort of caching? Seeing that the API has call limits, it'd be neat if your code saved information to reduce calls or something like that. Also, a minified or built version to use (instead of including an entire lib folder) would be desirable.
&gt; Things are done automagically. Bindings are flying around, templates are being loaded etc. This sounds like a good thing, They are breaking up the framework into modules as we speak. For Angular 1.2 route, resource, cookie, touch, animation are all separate modules, with more to come. I hear that two-way data binding will be separate too in the future. Maybe the template engine too. 
Been working with angular for the past year on all of my personal projects while using knockout at work. I've used backbone and a few other frameworks before, but have come to realize I fall more into the camp that prefers the magic (as long as I understand it, and as other commenters have pointed out there are a lot of good videos/docs about angular's internals). The first project, using just the docs, was super painful. I was already sold on two-way bindings from KO, but at that time the docs were really bad (they still aren't great, but are much improved). Starting a project from scratch lead me down a few rabbit holes and resulted in several "bad" habits (against angular-convention). The biggest problem was with organization - angular gives you so many different options for how to structure your apps, and very often you can accomplish things "the wrong way" with greater ease (putting view-logic methods on controllers instead of in directives comes to mind). The next few projects, I started with several of the seeds (angular-express, angular-express-socket.io, angular-bootstrap, etc) - but found that while they provided an example structure that is (relatively) within best-practices, they often make choices that takes fiddling to resolve (I'm not a fan of jade, they don't provide single-point of access for web-apps by serving * to index.html, and other little things). These have little to do with angular, but the lack of scaffolding made it difficult to force myself to do everything "right". Recently, I've done a half-dozen projects using yeoman, and I have to say, it's the perfect companion for angular. You have to subscribe to convention &gt; configuration - but angular is so "deep" that I feel the conventions and scaffolding provide the missing toolset that angular needs to create large-scale projects. With yeoman, I've found angular to be the most "mature" framework for full stack JS web-apps (mongo + node + express + yeoman for angular + bootstrap for UI). In that stack, angular is really the most important piece, and allows the rest of the stack to just pipe data and do a bit of sanity-checking (because angular works with native objects "magically"). This "magic" can be simplistically likened to using Object.observe (without all the boilerplate). The magic with templates and routing is comparable to using backbone's router, requirejs and handlebars. Since most of my projects would use these libraries anyway, it makes sense to look for an all-in-one solution (like ember, ko, or angular). I've come to love angular's logic-full templates, as it makes it very clear what you can and cannot modify in a view without messing up functionality. At some level, you will always have "view logic" inside your templates, even when it's just a class-name. Because classes serve double duty for css, I find it's far *less* clear what is logic vs style - whereas angular bindings (or data-attributes) let you be explicit about the elements the js depends on, and leaves classes to the designers (where they can add/remove without worrying about breaking js). As far as framework bugs, nothing stops you from writing native/jQuery js if you hit a particularly difficult issue - though I have yet to find any bugs that really have required that. I've found if I'm writing a piece of functionality that uses something that doesn't bind well to angular (canvas or audio/video come to mind), writing a standalone library and creating a thin angular directive/service wrapper can work wonders. That way, you stay in a nice native-js comfort zone for very complex pieces of functionality, and have clean testable code inside your angular project. Sadly, I think google needs to take *more* interest in both angular and yeoman. They were shoved to the side at googleIO, replaced by web-components, which are interesting for developers making widgets, but do little for developers building applications. I do feel the learning curve is very high, but after working with angular for over a year, I wouldn't use anything else. 
My biggest complaint against Angular is that it violates the separation of concerns. Necessary functionality is tacked into the markup rather than being written in Javascript. The reason I find this troublesome is that I live and die by unit tests. Allowing functionality to be grafted onto markup makes your unit tests mostly symbolic and not at all something you can trust for the stability of your app as features are added or changed.
You compared angular directly with Jquery when choosing a stack for your app? 
First of all, I don't care if I get downvoted, because this needs to be said. I agree with your statement that it is a problem when it violates separation of concerns. All these newer frameworks and template "engines" that put code in the HTML *are breaking rules*, and would have gotten you in trouble or at least dirty looks in years past. Now all of a sudden it's perfectly fine to mix code inside html DOM element properties, and do all sorts of bad things just to make some noobish design pattern work. I'm forced to work with these new technologies and it grinds me down every day when I'm writing javascript inside DOM properties. I blame the influx of "expert beginners" who think they've got the right idea but really are fucking it up, while the noobs just follow along on the bandwagon. Noobs love Angluar and the like because they've never imagined another way to do it, or have tried to do it themselves and failed. It's easier to jump on a bandwagon that everyone else is jumping on instead of trying to do things the right way when you don't know what the right way is. Mixing javascript inside DOM properties is not the right way.
I can attest to learning from the new docs... they're still terrible.
It is a giant circle-jerk, but if you want a job these days you have to say, "yes I love Angular" (or whatever they want to hear), or you won't get the job. It's really sad. 
I'm in the love-it camp, but not religiously so. I definitely default to Angular when starting a new project. &gt; Pieces of view logic are shoved right into the HTML. Opening up a page and displaying it's code exposes a soup of specialized attributes, tags, class names, expressions etc. This means that some of your view logic is inside the template (using complex expressions for instance), while another part is in the controllers. It just doesn't feel right Use directives. It's easy to write some truly nasty templates using Angular, but it doesn't have to be that way. Including some logic in the template is unavoidable, of course. That's the cost of two-way data-binding. &gt; Things are done automagically. Bindings are flying around, templates are being loaded etc. This sounds like a good thing, but what if you step on a rare framework bug? It might take you forever to debug it. This is fair. At bottom, though, you're working with the same data throughout the application, and [the Angular Batarang Chrome extension](http://blog.angularjs.org/2012/07/introducing-angularjs-batarang.html#!) makes debugging that much easier. Besides, you can throw in a `debugger;` statement, `console` things out, or expose your scopes globally for debugging purposes. It's still just JavaScript, after all.
Why do you feel that you have to "bend over backwards" to put an angular directive inside another angular directive.
I was in a similar place to you. Then I decided to just [build something with it](https://github.com/Vertice/browsr). I found the view stuff downright horrible to work with, and comprehend, until I switched to using jade templates to generate the angular templates that run the system. I found for the most part that the black magic parts I had been scared of, broke a lot less than I expected. Additionally the community knowledge around the ways it could break is vast. While I'm not ready to commit to it full time, I found it interesting in that it gave me a preview of what web development could/will be like in the future, since an awful lot of the experiments in angular are being standardised as part of the language/environment in the near future. It also made me more aware of things in the backbone/marionette code I am working with most of the time that just wouldn't be a problem if I were building with angular. I kind of resent having to wrap data objects in backbone models/collections to have them be properly event-ed now, but I also don't think that the current observable shims are clean enough to depend on. That all said... In the work I seem to do most often, the user interface is not even remotely the most complex or challenging part of the problem. All my real work seems to be with the models, and the server side code, and the user interface happens almost as a side effect. So settling on a proper Finite State Machine implementation made far more difference to my life than angular ever would.
Neat library, but not the most well-designed source code.
Better than Backbone. Anything is better than Backbone, actually.
I ain't a big fan of their module system/dependencies injection. I find that it works awkward with other systems. If you don't use a module system and concat your files it can be annoying trying to find a module when your project grows. That being said almost all javascript module systems and delivery methods have their trade offs.
Still, Angular makes a point of being testable, even setting you up with a bunch of tests in the tutorial. See http://docs.angularjs.org/tutorial, point 4 in step 1 installs Karma. It breaks tests up into two different domains; unit tests and integration tests. The unit tests only test directives, services, etc., the integration tests are for actual DOM on screen. Unit tests are fast and run with every code change, integration tests are slower and rely on the browser to display stuff. This leads me to observe that concerns are well separated after all. My directive supplies the view with some data; the view displays the data in the correct way. The service should not "know" of the way data is displayed. On the other hand, it's fairly easy to create a overly coupled system with Angular, as it is with many other frameworks. 
jquery is mainly just a facade for browser DOM manipulation and ajax. It's doesnt have classes/utilities for building modular mvc apps
This is some good advice. Finding complex logic in templates, whilst it works - it's a total pain to maintain and near impossible to comment. Breaking out into a $scope function makes this much easier.
It is hard to break the declarative event attribute habit as there is over a decade of articles using onclick/etc.. it just seems more intuitive.. it is a fine line to see that data binding (XAML, Knockout, etc), while still events, are not the same and data binding is ok. Oh wait...
Isn't one of the biggest reasons to use two-way binding so your controllers are actually a lot easier to test because they have no notion of their view? 
&lt;H1&gt;Cost Calculator&lt;/H1&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt; Which courses are you taking?&lt;/b&gt; &lt;br&gt;&lt;input type="checkbox" id="trip1"&gt; Calculus&lt;br&gt; &lt;input type="checkbox" id="trip2"&gt; Physics&lt;br&gt; &lt;input type="checkbox" id="trip3"&gt; Statistics&lt;br&gt; &lt;input type="checkbox" id="trip4"&gt; English&lt;br&gt; &lt;input type="checkbox" id="trip5"&gt; History&lt;br&gt; &lt;input type="checkbox" id="trip6"&gt; Computer Science&lt;br&gt; &lt;br&gt;&lt;b&gt;Do you need books?&lt;/b&gt; &lt;br&gt;&lt;input type="checkbox" id="book1"&gt; Yes&lt;br&gt; &lt;br&gt;&lt;b&gt;Do you qualify for financial aid? (Please type "Yes" or "No") &lt;/b&gt; &lt;br&gt;&lt;input type="text" id="price" &gt;&lt;div id="error"&gt;&lt;/div&gt;&lt;br&gt; &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&lt;b&gt;Captcha&lt;/b&gt;&lt;br&gt;&lt;td&gt; &amp;nbsp&lt;img src="http://i.imgur.com/YysI6Ws.png" alt="Smiley face" height="42" width="124"&gt;&lt;br&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="text" id="capt" &gt;&lt;td&gt;&lt;div id="error2"&gt;&lt;/div&gt;&lt;/table&gt; &lt;br&gt; &lt;button onClick="calc()"&gt;Calculate Schooling Cost&lt;/button&gt; &lt;br&gt;&lt;br&gt;The cost of your schooling is: &lt;font color="red"&gt;&lt;div id="result"&gt;&lt;/font&gt;&lt;/div&gt; &lt;script&gt; function calc(){ var price = document.getElementById("price").value; var capt = document.getElementById("capt").value; var t1 = document.getElementById("trip1").checked; var t2 = document.getElementById("trip2").checked; var t3 = document.getElementById("trip3").checked; var t4 = document.getElementById("trip4").checked; var t5 = document.getElementById("trip5").checked; var t6 = document.getElementById("trip6").checked; var b1 = document.getElementById("book1").checked; var f = isNaN(price) var error; var capt1="EXXTENHK"; var capt2="Yes"; var capt3="No"; var x1=0,x2=0,x3=0,x4=0,x5=0,x6=0,xtotal=0,final=0; if (capt == capt1){document.getElementById("error2").innerHTML = ""; if (f == false){ document.getElementById("error").innerHTML = "ERROR: Please say 'Yes' or 'No'" document.getElementById("result").innerHTML = ""; document.getElementById("error").style.fontStyle="italic"; document.getElementById("error").style.color="red"; return } if (f ==true){ document.getElementById("error").innerHTML = ""; } if (t1 == true){ x1=1; } if (t2 == true){ x2=1; } if (t3 == true){ x3=1; } if (t4 == true){ x4=1; } if (t5 == true){ x5=1; } if (t6 == true){ x6=1; } xtotal=x1+x2+x3+x4+x5+x6; final=xtotal*995; if (b1 == true){ final=(final+(xtotal*50)); } if(price == capt2){ final=final*.7 } if(price == capt3){ final=final } var result = final.toFixed(2); document.getElementById("result").innerHTML = "$" + result; } else{document.getElementById("result").innerHTML = ""; document.getElementById("error2").innerHTML = "You failed, try again"; document.getElementById("error2").style.fontStyle="italic"; document.getElementById("error2").style.color="red"; }} &lt;/script&gt;
if (price != capt1 &amp;&amp; price != capt2) {error message} The conditional you wrote read like this: If price is different from capt1 OR capt2 is something of positive value, send an error message.
I've used Angular and React as well and the main reason I am liking React is because there are a lot less concepts to grasp. I've also fiddled around with Polymer (web components) and as a delivery method for getting your components inside your html it's really great. Been thinking of making a test project with polymer and react to see if it's possible to work together. Only down side of Polymer is that it's not really usable in production yet depending on which browsers you have to target. An other reason to use React is that they only give you the V in MVC so you can fill in the other parts as you like. It's also harder to write code that has performance issuse while with Angular that's rather easy.
Comments are ok, functions with self-explanatory names are better. A $scope function allows both.
Forgive me of I've misunderstood; you shouldn't be putting JavaScript in the DOM with Angular. Only references to methods. The time when it was good practice to put event handlers somewhere in a JavaScript file, to be attached on some element in the DOM, in my opinion was a dark time. I'm not saying Angular gets everything right but putting a reference to behavior with the element you want to deal with makes a lot more sense to me. ... Let the down votes begin! ;)
Angular is amazing.
There are two points at which I disagree. The first is that Angular, as a framework, isn't designed in such a way as to encourage the creation of testable code -- you have to consciously make specific software design choices in order to have testable units. And for the second point, I guess at a certain point, it becomes a question of *how* separate your concerns are. When a functionality demands that some attribute be added to a tag, you end up filling your unit tests with fixtures to mock the necessary HTML. Some may argue that's inevitable in any code, but frankly that's an argument I'm not interested in. My point stands without the distraction.
I've heard Angular described as the first js framework backend developers can get behind. As a java developer, I constantly make design choices (and compromises...) that lead to better testable code. From a TDD point of view, this is logical and worth the effort. Besides Angular, most of my experience is with jQuery. This is an example of a very tightly coupled library. You have to tell it which DOM elements to work on, making it just as bad as Angular's attributes in html in my opinion. Worse even, since it's all hidden in a bunch of chained calls. jQuery apps are therefore harder to unit test, unless you make the aforementioned design choices. 
&gt; that tools can be designed to encourage proper use, as opposed to being designed too open to misuse. Agreed. However I don't class angular among those tools that lead coders astray. &gt; A more well-designed framework would implicitly encourage such ... design for testability. I find that angular encourages design for testability. You don't find testing controllers and the data fields and methods on them easy? You don't find that breaking down an app into services and factories encourages testability? Dependency injection isn't your idea of testability? You mention separation of concerns, [I agree with the mention of it here](http://stackoverflow.com/questions/14994391/how-do-i-think-in-angularjs-if-i-have-a-jquery-background/15012542#15012542). Do you agree with the methods set out there? I'm not sure if you have read that much on angular before. The angular way is not to manipulate the DOM, but to manipulate the $scope object and bind it to the template. That is far more testable than say, jQuery. What JS framework would you find significantly more testable than angular and why? &gt; As apps grow, the amount of code needing to be tested for regressions quickly becomes too cumbersome for any human to manage No kidding, that's why my angular app has all those unit tests. that's why I'm glad to push as much as possible into the controllers and services behind them where I can test it, and rely on simple data binding to present it predictably. &gt; Anything can be automated with the right tool, even visual changes Agreed. Anything can be automated, but the effort required and the resulting robustness varies. Unit-testing the aethetics of css is for some reason still not widespread. Angular does not address visual changes because it's a javascript framework not a screen-shotting tool. There's no reason why you can't use such tools with an angular app though. Why would you think otherwise? Why would lack of this unrelated thing that is no better in any other javascript framework put you off angular? 
Sounds to me you haven't been doing a damn thing on UI development for a long time. You'd realize how slow the old way is and how quickly it gets messy. It's like no one here ever heard about MVVM. 
I was playing around with it today, and was just wondering if you had tested the search with tables? I am having a bit of trouble getting it to work for tables and was wondering if it was just me.
really? what browser were you using? When I click on buttons in chrome absolutely nothing happens. its been driving me insane. 
I think it's a mistake to compare Angular to jQuery. They do very different things. 
Basically yes. This property of angular apps cracks open much of the app to testing in a straightforward way which you just won't get with e.g. jQuery. The parent poster doesn't understand [MVVM](http://en.wikipedia.org/wiki/Model_View_ViewModel#Free_MVVM_frameworks) and [doesn't want to, and furthermore thinks that this is a good thing](http://www.reddit.com/r/javascript/comments/1ru9t3/do_people_really_love_angular_or_is_it_just_a/cdr9zje) and so ends up at a conclusion about testability that is contrary to what people who use angular actually experience. It's quite odd.
No, they go about things in very different ways. Coders use them to build similar apps. Only the angular apps are often far more testable.