As far as I understand it, the larger benefit is that it makes code reviews easier. With a trailing comma, only the line with the param that was added will be marked as changed. Without a trailing comma, both the line with the added param and the previous line where a comma had to be added would be highlighted as changed. 
So what you're saying is that I need to install both?
At our place, we use them so that git diffs are less "noisy": if you imagine going from `myFunc(a, b, c)` to `myFunc(a, b, c, d)` // without trailing comma: myFunc( a, b, + c, // added `,` + d // added `d` ) // with trailing comma: myFunc( a, b, c, + d, // added `d,` ) Slightly awkward to convey this without syntax highlighting, but hopefully you get the idea.
That's awesome! I just checked out the proposal and I really hope it makes it into the standard.
Sounds promising, will take a look during the weekend
Thanks! Let me know if you have any questions :)
Interesting
haha, I promise I use single quotes in my production code!
So you walk into a hardware store and complain that there are too many tools ?
Can I just say I love the references in this post
I mean, sometimes you don't know what specific hammer or mallet you need.
http://exploringjs.com/es2016-es2017/
Shooting doesn't work...
There are several tiny raytracers in many languages. Here one for [Python @ 467 bytes](https://codegolf.stackexchange.com/questions/38615/ray-trace-a-shiny-sphere)
Oh, darn it!
Ahhh, makes sense. Thanks!
How do you kill an array index? :-P
Didn't mean to be glib. I prefer video content too.
Fantastic, this could bring deep learning legitimately to JS (rather than proofs of concept).
This is why lunches are catered and the host picks the dinner location. This way we only argue about when to eat which is usually easier :)
I get what you are saying, I guess I am just so used to seeing the extra line if diffs at this point that it doesn't bother me :)
You need to aim at a valid target before it shoots
If I have 10,000 visitors a day. How much money are we talking here?
Some computers don't register mouse clicks while buttons are being pressed. Try using an external mouse.
&gt; Does it come with a CPU fallback for users without WebGL? I found a pretty great summary [here](http://gpu.rocks/) that answers this and some related questions. In all seriousness I think Turbo.js came out first. Both this and Turbo are about a year old. From the look of it I think this one has a nicer syntax and the CPU fallback is tremendous.
You use [IAM](https://aws.amazon.com/iam/) to generate tokens and then put those tokens in now's "[secrets](https://zeit.co/docs/features/env-and-secrets)" feature to store them for use when the server is deployed. You then use a [now.json](https://zeit.co/docs/features/configuration#now.json) file so that the server can access those secrets. 
So whats the performance comparison? Edit: I know there's one on the frontpage, but thats just one example and it doesn't really explain me how useful this will be for most projects. I don't need to do big math calculations, so I wonder how usefull its performance is in my situation. Also the benchmarks I run, is 1 second slower? (CPU: 0.362s ±4.3% | GPU: 1.440s ±2.0% )
I'll take leeching computing resources over obnoxious advertising. 
Depends on the time they spend and power of their rigs. And it will also make the browser lag... But my answer to your question would be about &gt;50$/day
why can't it be both?
Whoa. I might have to play around with this this weekend. 
it should work without needing an external mouse
Hey, my pad function is awesome. It's only one line! const bestPad = (a, b, c) =&gt; a.split('').reverse().reduce((a, b, c) =&gt; (a[c] = b) &amp;&amp; false || a, ((d, e, f) =&gt; (f = (g, h, i) =&gt; (i = (g - 1) &gt; 0 ? f(g - 1, h) : []) &amp;&amp; (i[g - 1] = h === undefined ? ' ' : h) &amp;&amp; false || i) &amp;&amp; false || f(d, e))(Math.max(a.length, b), c === undefined ? ' ' : c)).reverse().join(''); bestPad('abc', 5); // -&gt; " abc" bestPad('abc', 5, '-'); // -&gt; "--abc"
There's a benchmark on the front freaking page. In my case the GPU is 19.8 times faster than the CPU for matrix operations.
Not bitcoin, but [one of these](https://www.coinwarz.com/cryptocurrency) should work really well. A large enough website can make a killing doing WebGL mining. Though it's probably illegal in most western countries.
nothing's a debate until 2 devs have different preferences
Use the original sources, please. http://cowbirdsinlove.com/43
...aaand apparently they weren't really looking for general use cases in this thread after all: https://twitter.com/othermaciej/status/885999233463009280 :/
No rigs, we're talking about 10,000 Adrenos (or similar mobile devices) here :-( Wondering if I can squeeze out $0.005 worth of bitcoins from a visitor in 20 seconds without lagging their device. 
you know what the dude meant.
Make it start at 1 :-o
Maybe he meant ravenous and not rapacious...
people do it for diffing reasons. consider this code: const myFunc = function( a, b ) { return a + b; } the argument is that not having a trailing comma makes the following change (adding arg `c`): const myFunc = function( a, b, c ) { return a + b + c; } less correct in source control and that the lines with argument `b` will point to the new author rather than the original author because of the addition of `,` to that line. the idea is that this makes history correct and code review easier. it's a terrible reason to introduce conventions in your code. it tightly couples your code's correctness to the outside tooling and process you use. it makes assumptions about the correct process to use. a better diffing algorithm could come out tomorrow that addresses these issues and makes all the reasoning for having trailing commas moot. it's such a specific use case and it's based on preferences for current tools that could fall out of flavor tomorrow. a short sighted reason to introduce a language construct.
This is a very useful list. I'd personally make data structure a higher priority, since 'innocently' choosing an inappropriate data structure can have serious consequences on code quality ... and make development either easy or a nightmare. For sizeable structures, it's well worth experimenting with several choices, and with a broad selection of conceivable data, before settling on one choice. Even then, retaining as much flexibility as possible may turn out to be critical. Once a problem becomes clear, the willingness and time to bail and start over is essential. 
I'm one of those weirdos that limits myself to native javascript (entirely for *web development* and big databases). The use of external tools can be very helpful for some purposes, but a person can pour a *lot* of time into learning them. That time might be better spent learning alternative languages more suited to purpose. I realize that as a non-commercial JS programmer (with copious experience non-scripted languages), I have more 'time luxury'. But over the past 7-8 years (starting with ES5) I haven't found much that's 'too hard' for native. And most of the additions to ES6 were 'nice' but not all that essential.
You need to have "new Date()" not "new.Date()" Same thing with "now" . You have "newDate()" 
I upvoted this for the title alone. Great article. 
I think the first argument is self-contradicting. If you are writing an app with a high enough level of complexity, then your choice of stack is definitely not merely a preference among two roughly equal things. The choice matters because of external factors: library ecosystem, team familiarity, etc.
True, but not with some computers.
Also you have to wait for ammo to spawn, which happens when you are seen by a zombie.
That's a fair point, but the main point here seems to be that, at the end of the day, if you've made an app and are happy with your stack, the rest hardly matters, right?
Nothing still happens
When prettified this is 17 lines. 
And then there's React's patent clause... While not as bad as it seems at first glance, the idea that if you use React, you can't sue Facebook without losing your license to use React is a bit questionable, and could certainly be used maliciously by Team Zuckerburg.
for the uninitiated: why would anyone want this?
Oh, duh. It's an infinite loop. You never actually assign a new value to sum
[Raises hand] Ugh... stupid question... &gt; Which makes more sense than “Angular vs React” because Angular tries achieve a different goal compared to React or Vue. Is this because Angular is more "full stack"-ish (defines factories, services, etc.) while Vue/React are primarily focused on UI? That is Angular is a framework and Vue/React are more library-esque? Other than jQuery/YUI (shit, THAT dates me) I've only ever Angular'ed so this statement made me go "humm?".
I don't understand your argument. It's still better not to litter language and have minimal core than introduce chaos like in PHP you compare JS with. JavaScript is littered enough. For example strings have three methods for making substring: 1. String.prototype.substring 2. String.prototype.substr 3. String.prototype.slice They work basically the same, but the difference is in the meaning of their arguments. It's very PHPy solution and maybe it would be better if (old) JS had not substring functionality at all, and if it was ES 2018 that introduced this at first time. I would like JS to have one substring method than 3. (It was of course just an example of many ways to litter language like in PHP). I would rather go with minimalism than mess. 
So can you please correct it for me. I realised i forgot to bring some semicolons at certain places, but after correcting that nothing is still printed on the screen.
Potentially, I view its uses more into education. Then hard-core large scale machine learning. What it potentially can allow, is fast practise and learning of deep learning concepts, all in ones own browser. With the most "global" language there is. JavaScript. For serious big-data TB size data sets it still is back to good old servers. Though honestly, this was done more in a case of not who wants / if there are uses. More like its cool and for lolz.
I use ES6 imports only if I have to transpile anyway (e.g. React with JSX). Other than that - I use requires that work in Node out of the box. So I don't have to transpile to run tests. Besides I sometimes run my frontend in Electron (just for development purposes, even if app will be browser based in production), so with CommonJS I can completely skip transpilation/building step when developing. 
Hmm is it illegal, if its declared on the website in prominent form (not just T&amp;C)? Toss in some viral content, and users who do not care about ads can pretty much feed the miners haha. 
Correct. If you think of it in terms of mvc , vue and react are just the view. 
React and Vue are no mere libraries. They need a lot of support in your project, like JSX, Babel, etc.
Thanks! As my development over the last year has been about forcing Angular 1.x into the View-only end of things, makes sense why Vue and React have been attractive! Out of curiosity... what have the cool kids been using for the M_C portions of the apps with Vue/React? (Mental note, I really need to get onto building proof-of-concept apps to justify a move!)
&gt;nothing's a debate until 2 devs ~~have different preferences~~
Apparently Vue monkey patches Array, breaking things like lodash's `remove` function, which is a bad practice: https://github.com/lodash/lodash/issues/2965
Tbf, if Facebook sues you first, then you're free from the restriction and can counter-sue.
That's only if you plan on making it the foundation of your project. It's possible (and really nice!) to use a simple `new Vue({ ... })` instance just to manage the UI of, say, an electron application, or some single unit of a larger website. It's true that other bits and pieces exist to leverage that library to an actual stack, but it doesn't change what it is at its core: a view library.
Not sure if this is what you are going for, but it prints to the screen. (https://jsfiddle.net/ecx1ofbk/)
I know a lot of people don't really like this library for whatever reason, but I've always had an apreciation for processing and processing.js for graphic heavy applications. It uses the canvas these days AFAIK. http://processingjs.org/ GLHF.
Still not working for me 
Scope is a Facebook Messenger bot that identifies songs from lyrics/titles. Scope returns detailed information about songs it matches including title, artist, album, release date, recording location, BPM, key, samples, featured artists, producers and writers (where available). Scope also returns direct Spotify, Apple Music, Soundcloud, YouTube and Genius links to the song. Scope is powered by Genius and Spotify APIs so matches are slightly biased towards hiphop and rap music (Genius started off as Rap Genius). It's easy to scope a song - just send a message starting with 'scope' followed by the lyric/title you're after (e.g. scope waves). Scope will reply with details of the closest match. If Scope matches the wrong song, simply reply with the word 'wrong' to select from the next best matches. Hit up Scope at https://m.me/scopebot or https://facebook.com/scopebot Vimeo demo at https://vimeo.com/225540115 Technologies Used - Node.js - TypeScript - Terraform - Lex - Lambda - CodeBuild/CodePipeline - Facebook Messenger Platform - Spotify API - Genius API
Only if your counter-suit doesn't relate to any facebook-held patents 
It seems to suggest CSS alone cannot be Turing complete. But ( CSS + Human repeatedly providing user input ) could be counted as Turing complete. 
I'm sorry I really don't "get" your framework. Why not just add the text in the html directly xD
All I get is this error (It points to the ;): }); SyntaxError: Unexpected end of input
If it's really a concern you can alway use Preact, it's a drop in replacement under the MIT license.
Indeed, but there are caveats. Preact isn't a perfect replacement, as shown by the issues page, and it is a smaller, potentially ephemeral project. But the point is not "you can use a different library" it's "there are other concerns than just preference that can play a part in choosing React vs Vue"
That usually means you're missing a } or ) somewhere.
Same could be applied to React. 
 there are other concerns than just preference that can play a part in choosing React vs Vue That may be true but I really don't think the patent clause counts as one of those reasons. The patent clause is more of a CYA clause than anything else. If it were something to be concerned about Google, Airbnb, Microsoft, and Apple wouldn't be using it. You can read more about why it's just a defensive patent [here](https://github.com/facebook/react/issues/7293)
Could you look at the code and maybe look where? Nothing helps
This is where having good formatting comes into play. The code here looks to be all over the place, without any order to be spoken of. No way to tell when blocks begin or end. [This is Prettier, a JS formatter which does the job for you. Paste your code into the box on the left.](https://prettier.io/playground) Add `});` to the very end, and you'll see the error go away. "Unexpected end of input" is the error the JS parser throws when it's running through your code, but a section (like a block, and object, or an array) isn't closed off properly. It expects an end bracket, but, _unexpectedly_, receives _end of input_ instead!
Nah, that's computer work. Run it through a code formatter and it should be obvious to you based on how it indents things.
I didn't say it couldn't :D
The clause says, paraphrased: "if you sue Facebook regarding any patent they hold, you lose the right to use React"... That goes further than defending against litigation due to the use of React, and ties the user's hands regarding future corporate actions. While that may be acceptable to companies who are designing software in-house, it can cause significant issue for contracted developers, whose clients don't necessarily understand the future right they forfeit by using React.
This doesn't make sense to me. There's a mouse click event and there's a keyboard event.
No! You'll never learn otherwise. Pull up dev tools on the browser you're using and it'll show any Javascript errors. The infinite loop error isn't one it'll show though. 
Popular solutions for M part are Redux, Mobx and Vuex (Vuex unfortunately works only in Vue, so it's vendor-locking). Additionally this changes rapidly over time so if you ask the same question in 6-12 months from now the answer will be different (hype driven development, "cool kids" usually change their tools every few months when old ones go out of fashion).
I have pestered @webkit and for a long time on Twitter to support service workers. @jonathandavis response to my requests: give me a use case that absolutely requires service workers. Unfortunately the Webkit team lives in complete isolation from the web developer community. Unlike Google and Microsoft, Webkit does not interact with the developer community. They do not provide us any tools, frameworks, etc. So they have no idea what we want or even how we use their browser. So sad. Funny thing, I have pestered Jonathan Davis for years to support other things, like: promises, fetch, etc. His response was always the same. Why did I need them now when I got along fine for years without them. As I said, they are very clueless about what the web developer community is doing and needs. Webkit is hopeless. They just add baubles to Safari and then announce the new features, expecting us to fall all over ourselves in excitement. Instead, I'm sitting here fuming, wondering when they are going to support services workers and web app manifest to make PWAs discoverable on iOS. 
Change "sum+i" to "sum = sum+i" 
No it doesn't. I suggest you read it because the clause isn't in regards to any patent Facebook holds but rather **only** the patents covered by React, which at this time I believe is still 0 patents. Additionally you keep the right to use the patent if they sue you Notwithstanding the foregoing, if Facebook or any of its subsidiaries or corporate affiliates files a lawsuit alleging patent infringement against you in the first instance, and you respond by filing a patent infringement counterclaim in that lawsuit against that party that is unrelated to the Software, the license granted hereunder will not terminate under section (i) of this paragraph due to such counterclaim. And if you sue them your explicit license to their patents will terminate; however your license to their code would not terminate, and there's a decent argument that the license they use for their code contains an implicit patent license that is not terminated, but worst case, you'd lose the patent license. There are many reasons why not to use React but I don't think the Patent clause is one of them
That's better than this? const [db_stuff1, db_stuff2, db_stuff3] = await Promise.all([ asyncGetDatabaseStuff1(information1), asyncGetDatabaseStuff2(information2), asyncGetDatabaseStuff3(information3) ]); 
Edited, all corrections have been made but still nothing happens.Please help. PS: I just edited the post
It keeps saying there's a problem on line 205 (I removed line 206) and that the problem is a space...
&gt; lawsuit [...] that is unrelated to the Software That is not freedom to countersue, if your suit has anything to do with Facebook's software patents. You are also incorrect about the implicit patent license granted by the BSD license. That "implicit patent license" requires a very loose read of the BSD license that has never been supported by legal precedent, making it very unlikely to be considered defensible. And I'd like to see a citation on your statement that there are 0 software patents related to React. Facebook holds a massive and varied portfolio of patents, and just because they aren't explicitly listed as attached to React doesn't preclude them from the clause. Without the explicit clause, there would be a far better argument for an implicit license being issued by the BSD license. With an explicit license in place, with explicit caveats, that is not the case. Perhaps your business is fine with that uncertainty, but the web is littered with comments from legal department that aren't, and if you are building for a client, and this decision isn't made by their stakeholders, with full knowledge of the implications, you open yourself up to future liability as well. 
There isn't really a difference, just hipness. Ember was hip and then Angular was hip and now React is hip so no-one uses Ember or Angular anymore.
What do you think of vue
It's almost hip but not quite.
No, don't remove anything. Just add `});` to the end of the script.
As I said, your lawyer may be confident. There are plenty of lawyers online who disagree. That's the wonder of software ip law, it's so generally loose that there are plenty of competing and seemingly valid interpretations, even from lawyers. Until it is tested in court, the text gives a fair amount of room for interpretation.
Hahahah love the way you used hip!
The HTML element with id="output1" must exist in the document before the script is run because the script is not called. Put an element with id=output1 in the body of the document. Move the script to the end of the document, just before the &lt;/body&gt; 
I think the debate just started
You're wrong.
[removed]
in the for loop add console.log("test") then open the dev tools ctrl+shift+j and see how many times it's printed if it's more than you expected to change the callbacks in the loop.
Mentioned this in a similar thread a few days ago: Apple does not have good incentives to support mobile web beyond the basics. They want native apps that they can monetize. I'm not saying this as a tin-foil hat Apple hater, I'm an all Apple ecosystem user that just sees this being a struggle that may drag out for quite sometime because it's in their best interests to incentivize developer lock-in to native apps.
beauty is in the eye of the beholder
Vue is a library, not a framework. Angular and Aurelia are frameworks. Vue, React, Knockout, etc are libraries. Not sure what ember is, never used it. Distinctions are simple, frameworks do everything and are much bigger. Libraries do 1 thing and need many more 1 things to do the everything that a framework can, but it gives choices then. Aurelia and Angular handle MVVM/MVC, React, Vue, knockout only do V. We actually have very few frameworks and a metric ton of libraries.
Have you seen async / await (now an official part of the language with ES2017)? async function blah () { const stuff1 = await asyncGetDatabaseStuff1(information1) // use stuff1 const stuff2 = await asyncGetDatabaseStuff2(stuff1) // use stuff 2 const stuff3 = await asyncGetDatabaseStuff3(stuff2) // use stuff3 } Now you don't have to mess with any callbacks at all. This is all powered by `Promise` under the hood, but language makes it invisible. Even before `async` / `await`, there were libraries like `co` that did the same thing using generators. None of this is new. I suspect promises were never really intended as a user-facing feature, but as the plumbing needed to make these other features work.
Ohh thanks for explaining. I'm new to web development 
I use (ok, fail) instead of (resolve, reject) It's easier to type, to remember and to get aid from the autcompleter
It's a fantastic achievement for sure. But in what real life situation do you need JavaScript for a 512 x 512 matrix multiplication? Client side image rendering in a browser?
If there are "plenty" of lawyers online who disagree, then why is React being used by so many household names? Some of these companies are even social media competitors, such as Twitter and Reddit. Additional companies that seem to think it's safe: Airbnb, Netflix, Walmart, Mozilla, Atlassian, Tesla, Uber, SoundCloud, Vogue, Wix, etc.
If the website is large because it is good (e.g. Reddit) then the sacrifice on its overall engagement metrics/ad revenue by seizing the browser with mining surely outweighs any potential value at this point. Even if you hypertargeted the best computers, I bet you could find something better to do with that cputime for ROI on your megasite than mining.
From that thread, it seems that Vue is modifying the *instance* properties that enables it to observe calls to `Array.prototype` methods. Since lodash calls the `Array.prototype` methods directly, the library bypasses Vue's observers. This is not ideal, but short of using ES6 Proxy, which isn't supported by all browsers that Vue wants to support this seem to be the best way to do it. 
If you can't choose between the two, check out RE:DOM. It's faster, lighter and simpler than React and Vue: https://redom.js.org 😎
But now, instead of the Promise interface managing the state of concurrency for you, you're doing it yourself: /* We need these before next_step_function can run! */ if(database_stuff1 === null || database_stuff2 === null || database_stuff3 === null) return; /* Do stuff here */ With `Promise.all`, managing that state is abstracted away from you. So, your code is actually prone to more bugs...
Can I have separate files for HTML, JS, CSS? Also can I use SCSS?
Yeah! Moon can be used by including a script tag. If you want more functionality and organization, check out [moon-cli](https://github.com/KingPixil/moon-cli). It can generate a project using Moon single file components. Single file components allow you to define components with three tags, a template, a style tag, and a script tag. The template defines the HTML template. The style defines the styles, and can optionally be scoped to that component. The script can define the component options.
Well not quite. There are a few key differences when considering performance. Vue allocates large amounts of memory for setting up its watchers, which you need to be careful of to avoid jank. React has fiber coming out, which promises to significantly reduce jank. It's large community and commercial backing has allowed it to take the next step up in performance. You're arguments could apply to any number of recent JS frameworks, the community is at the stage where a number of these things are widely accepted, but there are key differences that will separate them in the months and years to come.
[Apple made over 8 **billion** dollars off the app store last year](http://www.zdnet.com/article/apples-app-store-2016-revenue-tops-28-billion-mark-developers-net-20-billion/) 
But can I have a Moon.Component() and pass the template property a relative path to a HTML that is a different file just like Angular? All I want is to have 3 files for a component.
No, as Moon would have to fetch and compile it, adding a significant amount of weight.
No, stop. I don't care about performance, community, or anything. I care if I can push an app out the door, and if I can maintain it for as long as I need to. Sure I might have a really fast app running on React Fiber, but if the team doesn't like working with react, or is just slow with it for whatever reason, causing slower iteration cycles, then it's a bad decision for that team. If the team works faster with Vue, it's a better decision for that team. If the app is still **fast enough** (and I don't think I could ever put enough emphasis on that) then it's still a good decision for that team. Switching to a solution less fitting for the job just for a few extra milliseconds of performance, or just because everyone else is using it, or just because a big commercial company is backing it - none of these are good enough reasons all things considered. Objectivity is thrown out the window when context is taken into account. You can switch React and Vue around in that above rant and it'll still be the same argument. It just doesn't matter. Use what works best for you.
I see, but DisplayJS is still faster in code actually. And there is tons of other useful functions that will make your workflow faster. You have to remember that DisplayJS is still in beta and a beta is to get feedback from other developers. I’ll try in the next week to optimize it as much as I can, even if it’s almost useless because a classic render for 1000 variables (I did the tests in Chrome 😊) takes about 8ms, which is pretty fast actually. Vue.js is faster because it’s using a diff algorithm that is simply better. I plan to implement a similar algorithm in DisplayJS soon. Thank you for your feedback 😊.
No problem! Good luck with optimizing, and keep up the good work on DisplayJS 👍
😂 Well, your comment makes me laugh (don’t be offended) because I don’t think 🤔 you understand the all point of JavaScript. The static content will be added directly to the HTML, but the dynamic content will be managed by the JavaScript. And to put the text in an element, you can do it easily with jQuery, but when you need to do it at a large scale, you’ll need DisplayJS to do that 😊
This put a smile on my face! How long did it take you?
&gt; I don't care about performance, community, or anything &gt; If the app is still fast enough That's all fine, and that's your prerogative to not care about those things. But they're important in many apps, so you shouldn't be telling people that they can't recommend a framework just because for you don't care about these things for the types of apps you push out.
Angular is a full framework it aims to provide every single piece of functionality you might require to build modern web applications. Complicated to learn and use but very powerful, was the most popular framework for a while but has fallen back a bit now. Ember is a similar full framework but not as popular, it's a bit stricter than Angular so code is more standardized. Aurelia is also a full framework, it's very well designed but never really took off. React is a view only framework, it's built for Facebook who don't need things like Routers so will never include such functionality - the current rewrite is to solve a particular problem Facebook has. It's much simpler than a full framework but you'll have to implement a lot of functionality yourself. Probably the most popular framework at the moment. Vue is a framework in between the Angular and React philosophies and provides a good compromise, it's nowhere near as popular but is gaining fast.
https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks Is pretty comprehensive. https://hackernoon.com/5-best-javascript-frameworks-in-2017-7a63b3870282 This article gives you a little more insight into the current popular frameworks/libraries. The only thing that I would add is that AngularJS and Angular4 are really not that similar and should be considered separate frameworks.
I was worried more about reddit ;)
Well, if you already made the app, then obviously you've committed to your tech stack, at which point there's really no point in debating.
The main difference between frameworks is their intended use case. Most of these use cases can be translated as an abstraction level to the HTML. When working natively, the lowest level of abstraction would be to manipulate pixels on the screen. In the browser this is a bit different as you have already a kind of wireframe API to work with, which is the pure HTML level where you can attach handlers to the wireframe elements. This is the level where jQuery lives: providing a way to search and apply changes to HTML. This means you can apply changes to a page which has been mainly written by hand or generated by a server side generator. From there you can increase the level of how much HTML is generated by the client and for what purpose (think some live elements as auto-updating 'trending now'). This leads to frameworks which are designed mainly to handle separate items on the page. With these frameworks you can often combine static HTML with generated interface elements, but you can also do fully generated pages, the so called Single Page Apps or SPA. This is the realm of Angular (Google), React (Facebook) and Ember. What these frameworks usually don't offer is an full application level of control, like native frameworks as Cocoa, Qt or Gtk. You need those kinds of frameworks if you want to build online native-like apps like Apple iWorks or business apps. This is possible with frameworks like SproutCore and Cappuccino, which provide a full native-like MVC API BUT happen to run in a browser or webview and which can usually also run fully offline. I hope this explains the JS framework landscape a bit.
Vue is definitely a framework, it has an official router and state management solution. Perhaps React and especially Knockout could be described as libraries but I'd say the lines are blurred - they give you enough functionality and structure in the View that Model and Controller becomes trivial in vanilla JavaScript.
Thanks for the clarification, I thought it was altering `Array.prototype` directly.
&gt; I never said this? From the article: &gt; And please, stop trying to push your preference onto others. &gt; But workflow and pushing to production should be top priority. That's fine, but workflow is well-documented and simple for most JS frameworks, so I would argue the opposite to you, that it's actually short-sighted to choose _because_ of this. &gt; But do they, really? Yes they do. I'm currently working on a performance-critical app, and Vue is struggling to keep up. In situations like this it might even be worth prototyping the critical parts of your app in a few different frameworks before you try, to see which works best for your particular use-case, all things considered. I'm afraid your assertion that it just doesn't matter which one you end up using is frankly ludicrous.
This reminds me of https://turbo.github.io.
That code reads pretty unpleasantly. People would get berated for checking stuff that looked like that in where I work.
We recently made this choice at work. Without reading the article, I disagree entirely with the title. There are lots of actual reasons to choose one over the other. Those are situational, sure, but not preference. After reading the article, I still disagree for the reasons above. There are many concrete things you can use to make a choice between front-end frameworks nowadays.
There is nothing to catch up to, while the syntax exists [the semantics of module loading remains in development](https://whatwg.github.io/loader/). 
Did they release WebGL 2.0 or something recently? (Or was it 3.0) I remember this wasn't possible because computational shaders weren't a thing as of a few months ago.
Huzzah! Many companies are not worried about sueing Facebook in the future! I don't see why you think "some companies are ok with these terms" means "all companies have no reason to care"... It's a pretty obvious distinction.
I think this whole attitude is part of a school of thought where all the differences between frameworks are down to whether you like HTML templates or JSX, or a slightly more functional style. It's a dumbing-down of the process of writing software. There are many differences and each candidate should be assessed and evaluated according to various factors that you define before you start looking. It's basic engineering practice. Don't just choose one because of the colour of its logo (according to you that's as good a reason as any, because they're all basically the same anyway), make an informed and reasoned choice.
This isn't an argument! You're just contradicting everything I'm saying! I paid for a good argument!
"If" being the operative word in that sentence.
Creating web applications is still an open-ended problem and the JavaScript community is diverse. Sometimes software has poor documentation too, so developers end up creating their own "perfect solution" instead of trying to understand someone else's configuration. 
Fair call. Solstice, -16761600 
[Every teenage Boy in 1979's thoughts on Promises](https://www.youtube.com/watch?v=eqM3P7LziIc)
I think you're missing }); on line 44 but this code formatting is awful
You are right. We have used `[hash:base64:6]`. It's in use here https://www.lyko.se
Why would you define "ambitious UIs" by the number of template variables? &gt; when you have like 20 or 30 variables to display If you have 20 or 30 variables in your template you're doing something wrong. &gt; but when you have 100 or 200 var, this is where Display JS is strong. Now I'm confused about what you're counting. Do list item variables count more than once?
As the title says. Having read that writing about or teaching what you have learned is a good thing I decided to try that out. I wrote about a very simple algorithm on freeCodeCamp so I'm sure I'm not telling you something you don't already know this is more to ease myself into it. I'm putting it here for any feedback really, whether that be my code or writing style sucks. It got published by Codeburst almost immediately, so I must be doing something right.
&gt; If a developer is really comfortable with functional programming and Javascript, chances are they will prefer React. On the other hand, if someone has been writing a lot of templates before and loves to write them, they will prefer Vue. I dislike this comparision because it implies that people who write React aren't comfortable with writing templates. They're the same developers that always existed before React, when there was no choice *but* to write templates. That they've chosen to embrace a more abstractly functional style doesn't mean anything. Personally, I see the style of *writing* React as pretty similar to writing Backbone Views---you have JSX which looks like a template, bound to an object that handles the life cylce, event handlers, and data. Pratically speaking, React goes a lot further than that with the virtual DOM and synthetic events, but as a matter of 'style' it's really very similar. Now about Vue.... To me, the main difference between Vue and React is the ecosystem. React's is larger and more free-wheeling because Facebook hasn't set out any prescriptive guides or defaults for data management, loading, routing, etc. Vue does--following a "batteries included" philosophy. I will note that since Vue templates are disjoint from actual javascript, you are pretty restricted in what you can do in the middle of a render which leads to them being more obvious to read, but more tedious to write since you can't do any data transformations inline.
Press F12 and use the debugger. You'll be surprised what you're about to learn!
How promises are "spaghetti code" ? How do you use them ? By the way, make up your mind : is it camel case, underscore case or unreadablelowercase ? asyncGetDatabaseStuff1(information1, callbackhandler); asyncGetDatabaseStuff2(information2, callbackhandler); asyncGetDatabaseStuff3(information3, callbackhandler); function callbackhandler(err, data){ /* process the data here into database_stuff(1,2,3) */ next_step_function(); }
OPM
https://github.com/transcranial/keras-js
&gt; since you can't do any data transformations inline What is preventing you from doing so? EDIT: Legit question that gets downvoted, why? 
What I’m saying is that when you have a lot of variables, it’s easier to use DisplayJS than jQuery or vanilla JS. 😊
That'd be fine too
Can't you extend Vue and React to be more than just view and be the whole MVC instead?
Online game AI!
I think redux has been the go to for react for a few years now though hasn't it been?
It's fairly simple. If you have legal concerns about a business license or contract, then ask your own companies lawyer to go over it---then take *their* advice. That is why you pay them, and every companies risk profile is different. 
I once saw this on [Mathematics Stack Exchange](https://math.stackexchange.com/questions/166869/is-10-a-magical-number-or-i-am-missing-something) and didn't know what the true source was. **Thank you!**
Vue's interpolations come from the data element on the Vue object. Now in Vue, if you write `{{ msg }}`, then somewhere in data you have to have something that says `message: "blah"`. Then, you *can* transform things but only so long as you're only accessing the white-listed globals, or Vue data. So `{{ msg.trim() }}` would work, but not `{{ show_errors_about(msg) }} ` In React, your JS expression can reference anything available to the scope of your render function. For example `&lt;div&gt;{ show_errors_about(this.props.message) }&lt;div&gt;`. Edits: Clarity, and goodness this formatting is awkward. 
Recently WebGL 2.0 landed with GLSL 3.0 ES. You are definitely able to do this in WebGL using rendering to a framebuffer. Many particle systems and more complex simulations in WebGL use multiple framebuffers to compute. The general technique is called GPGPU, check out this example: https://threejs.org/examples/webgl_gpgpu_birds.html
no more ads, now you just run our bitcoin miner
Exactly, which is precisely why the license differences can be relevant to the choice of react vs vue
For sure, Facebook is asking for "payment" in order to freely use React. Rather than trying to license it for $1000 per CPU core used like I'm sure Oracle would be chomping at the bit to do, Facebook says "you can't sue us or our friends on patent grounds". It's up to you to decide if its fair payment. It reminds me a bit of the GPL---free and open, but with an additional clause to force people to play nice and be 'good community members' and the like. 
That is true, although the GPL's limitations only extend to actions taken with that specific software, whereas React's limitations extend to actions of the business as a whole, which is significantly wider reaching. That is why this is potentially a heftier decision for clients of third-party developers, that they often aren't even made aware of.
This is a side-effect of the max-height animation trick. You're animating the maximum height the element can be, from 0px to 900px over a duration of 2 seconds, and then back again the other way. Your menu is ~150px. Changing the maximum height between 150px to 900px has no visible effect, but it's still happening.
i clicked the benchmark and suddenly my pc was running very slow so i had to close the page
The thing is, the class adds a new max-height value, which works fine in itself. Animating it however is another story. When you set a different max-height and animate it, the animation runs for the whole height you set in max-height. That's why when you open it, it's instantaneous, because it's at the start, but when you close it, the animation starts at the max-height value, which can be a lot higher that the rendered height and decreases it until it reaches the height set by the content (which in your case takes two seconds because of the high max-height) and then you can actually see it working. Bottom line, it works fine, the code has no delay, it's just a weird and stupid quirk of animating heights with css.
My favourite thing about his example is that if he wants a fourth thing he needs to add it 3 places compared to just one =)
That's usually where you plug in Redux or MobX into your app but for Redux I think it would be more closely related to the [SAM](http://sam.js.org/) pattern than MVC.
That's not very honest. Don't do shit like that.
There was [webcl](https://en.wikipedia.org/wiki/WebCL), but according to wikipedia it doesn't seem to have been widely implemented. 
Which did you choose? I went with vue at work because I'm only the webdev and it was easier for me to get started. 
Why not [Polymer](https://www.polymer-project.org)? (\/) (°,,,°) (\/)
Oh, I see. Is there anything like that for Vue that makes it more into MVC?
Thanks, I couldn't think about it this way.
So far as I am aware, a Proxy approach also cannot provide the same functionality as intercepting prototype methods. With a Proxy, you cannot access and manipulate the original object and observe it. You have to interact with the new Proxy object to observe it. With prototype interception, an original object, in this case an array, can be observed. In simple terms, this allows for a plain old JavaScript object, or an array, to be passed to a framework without the passer having to do anything special, and retaining the ability to interact with their object. Of course, users could be required to pass or request a Proxy object, but such an approach is obviously less 'smooth' than prototype interception. And, also, there are observations that Proxies can make that prototype interception, getters and setters, and other approaches are not able to. But still, prototype interception certainly seems to have some value.
Despite saying that you should use what ever framework you want and it doesn't matter, he did say that if you're more poised to functional programming you should use React (and Vue if more for template-related dev). It almost feels like that statement nullifies what he's trying to defend. I enjoy React a lot, primarily because of how I can write my functional programming. 
There is [Vuex](https://vuex.vuejs.org/en/intro.html) but I _personally_ don't believe that MVC is the keyword but rather state management these days (SAM for frontend, MVC for backend). That's what all these libraries are trying to provide a solution for: how you manage your app's state. I am sure to miss something so someone will correct me but from I gather [React + MobX ~= Vue](https://twitter.com/youyuxi/status/736939734900047874) and React + Redux ~= Vue + Vuex. If you go with Redux you will still need something like redux-thunk or redux-saga to do async stuff as Redux does not do async out of the box.
Good to know, thanks for all that information!
Thanks for the amazing answer. Indeed if you want to use inside the component functions that come from outside you must inject them, and that's annoying. Then again if you really need that you can still plop some JSX and write the render function yourself.
Your first paragraph sums up development. Why we have mediocre developers constantly calling one tech the "best" I'll never know. I guess I've always figured devs were somehow smarter than that. 
I made a quick &amp; dirty, dead simple [brainfuck interpreter](https://github.com/izeau/bifurk)
React has about half the market share of both Angulars combined. Both are growing at about the same rate. Together, they have taken about half of jQuery's market share in the last 2-3 years. This data is fairly easy to find by Googling. 
I would add that Angular 4 is superior in every way. It's rather elegant.
If it can be used as an alternative to ads, I'm all for it!
I work on an enterprise-level app where we make legal guarantees about accessibility (specifically around screen readers). If we don't get accessibility right, it's not just a PR hit, it means we're engaging in false advertising. Outside of Silicon Valley accessibility does matter, not just because we care about blind people but because if we do it wrong, we could get in a LOT of trouble. We put a lot of work into stressing that point to new developers, because otherwise they ignore Severity 1 bugs and skip checking whether tab indexes work when they build UI elements. Internationalization is something we set up once and put a process around. When a new string needs to go into the app, we run it through the doc team and stick it in a database. I don't rate it particularly highly on the list of features people should know because I think even for enterprise-level massive apps, you really only need one or two developers at most who can set that system up. But I have limited experience, so maybe that's not as common as I suspect.
You can just {{}} a Computed method that returns show_errors_about(this.msg), right? Data isn't the only element you can render inline. Or am I misunderstanding your requirement
That's a completely stupid rule. It makes no sense. It took me a while to understand why the fuck it would only shoot intermittently. It would make more sense if the blue dots were the ammo you had to collect, and it would be much better if the amount of ammo collected was retained into the next level.
&gt; Then, you can transform things but only so long as you're only accessing the white-listed globals, or Vue data. So {{ msg.trim() }} would work, but not {{ show_errors_about(msg) }} I'm confused what you're saying here. You can have show_errors_about if show_errors_about is a method in the Vue component. Are you saying something else or are you literally saying that you can't use functions in a Vue template? You [definitely can](https://jsfiddle.net/92cx1kbq/). However, probably preferable in this case would be a computed property dependent on message, [like so](https://jsfiddle.net/9ddv2y5o/). 
Well that way I don't have to show ads.
https://vuejs.org &gt; The Progressive JavaScript Framework
I was saying you can't use arbitrary functions that aren't connected to your Vue component, you have to define it in methods or data. Maybe that's untrue? It's the impression that I got from reading the documentation.
Yes, that is true, but I'd argue that's a feature, not a bug. Global functions are generally difficult to reason about. Now, of course, if you want to have a function which is available across many different components, you can use mixins to provide that functionality. 
That's cool. You'll probably like this one created in ClojureScript, https://github.com/imalooney/t3tr0s
I have some small reservations, in that modern frameworks do not only abstract HTML, HTML becomes an implementation detail. Most frameworks today have few things in common with HTML except minor semantics. These frameworks can also readily produce real applications, in the web and natively. They're probably more suitable for the task even than older MVC solutions given that MVC and MVVM are slowly making way for newer paradigms. 
Could one use this in Node? I've seen some WebGL packages for node (I think for electron apps) before. This could be nice for manipulating large sets of data in Node, especially now that SIMD.js is being postponed (at best).
Oh, that's quite true. I only mentioned it as it is a difference between the styles of React and Vue. Vue has everything in clearly defined locations, and you can't break out of that mold easily. React on the other hand mostly has you writing *just* JS. Whether being 'just JS' is good and unrestrictive, or bad and unstructured----is kind of up to you.
Yes, I thought the same thing when I read their patent grant and license. I was a bit more uncharitable thinking " oh no! RMS has a successor", but I personally don't find it too onerous. The GPL was onerous to me because it was seemingly championing the end of proprietary software, but being against patents is something that I can get behind. I can understand why others would be troubled though---there's a fair bit of arm twisting going on here.
Implementing whole class with one method `execute` for command pattern seems to be needless boilerplate in JS and it reminds me of old Java where lambdas were emulated by classes. But JavaScript has lambdas - so you could probably implement the same thing as lambda (maybe with closure). Maybe this is slight difference, matter of style (I just prefer simple style, without too much boilerplate).
I think you need Chrome 60 with a flag, or Safari to make it work.
Getting the basics set up took about two weeks. Designing the levels took about one week.
thanks for info. PS. ops, I edited my previous post instead of creating new one. (in previous post I said that it didn't work on my Chrome 59).
Welcome to 2012?
This is sweet. Probably runs much better too, the function I wrote is pretty slow 
Maybe you could point out a quality market share report? It's notoriously difficult to get accurate statistics - especially now applications get bundled. [npm installs](http://www.npmtrends.com/@angular/core-vs-react) would seem to be fairest to me but this shows React way out in front. I'd definitely say jQuery is a library not a framework.
You don't *need* thunks or sagas. You could call your API functions, or whatever else, from components and dispatch the success or error actions from there. That's just not a very clean way to do it, so instead those libraries let you can dispatch an action that does async stuff and then dispatches more actions.
If only there was a cutting edge technique that meant two classes with one character difference could share logic. [MoveLeftCommand.js](https://github.com/emilniklas/tetris/blob/master/lib/commands/MoveLeftCommand.js) [MoveRightCommand.js](https://github.com/emilniklas/tetris/blob/master/lib/commands/MoveRightCommand.js) 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [emilniklas/tetris/.../**MoveLeftCommand.js** (master → adee0a9)](https://github.com/emilniklas/tetris/blob/adee0a9531a3e53431089247f7d5c2a3879aa0ba/lib/commands/MoveLeftCommand.js) * [emilniklas/tetris/.../**MoveRightCommand.js** (master → adee0a9)](https://github.com/emilniklas/tetris/blob/adee0a9531a3e53431089247f7d5c2a3879aa0ba/lib/commands/MoveRightCommand.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk95x9a.)^.
Cutting edge would be ES7 + WebAssembly + WebGL 2
No, it's pretty good. I like that you covered multiple ways of doing the same thing! Good for beginners to understand the possibilities here. 
You better show the ads tbh
You dont need the `()` in that tenary operator, and maybe you can write something about the difference between the methods?
I don't think react fits the mvc pattern. I would say it uses a pattern of composable components. The difference kid that each component manages everything from lifecycle to network requests to styling. 
For something as simple as finding the longest word you're using too much JavaScript. This is much faster and arguably easier to understand. function findLongestWord(str) { var longest = 0; var cur = 0; var len = str.length; for(var i = 0; i&lt;len; i++) { if(str[i] != ' '){ if(++cur &gt; longest){ longest = cur; } } else { cur = 0; } } return longest; } 
https://m.youtube.com/watch?v=kQFKtI6gn9Y
beautifully done, thanks for sharing!
&gt;[**Argument Clinic - Monty Python's The Flying Circus [6:07]**](http://youtu.be/kQFKtI6gn9Y) &gt; [*^Monty ^Python*](https://www.youtube.com/channel/UCGm3CO6LPcN-Y7HIuyE0Rew) ^in ^Comedy &gt;*^8,379,442 ^views ^since ^Nov ^2008* [^bot ^info](/r/youtubefactsbot/wiki/index)
There are other whitespace characters that the space character i.e. \n, \t...
Whats the difference?
It is neither if you have a lawyer who tells you to not use react. More reading: http://react-etc.net/entry/apache-foundation-bans-use-of-facebook-bsd-patents-licensed-libraries-like-react-js
and the dreaded \r, if windows/mac users are uploading files. (was just space in the article too)
It was enough of a problem that the lawyers at Red Hat said the company was unable to use react because of said *defensive* clause
I'm with gschoppe, you must be made of a lot of money to take on that risk. My lawyer said don't, its not worth it in the long run.
You're not wrong. Some industries and some applications *must* have accessibility. Plenty does not, though.
Companies that also employ armies of lawyers and have lawyer fee's in their budgets. Small enterprise is the one that has the most to lose.
Exactly. If you use a sort in JS you are probably getting O(n log n) (I believe some implementations are using merge sort). You should be able to find the longest word in a single loop (O(n)) which will be much faster and really even more readable. That said, I do appreciate that the article mentions multiple ways of doing things and on occasion preferring readability over anything else. There are definitely times that performance does not matter all that much (for example, if you know you list is never going to be more than n items log (where n is a relatively small number) then it really doesn't matter what you use as long as the dev coming after you can actually decipher your code).
You hit the nail on the head there. At the government the first thing they ask is if the software is GPL and if it is to find an alternative. The entire choice was based on the license. I think for a lot of companies the license can be just as much of a deciding factor as the problem it is trying to solve.
Yeah, just read the article. There are also some unicode characters, that's why I think it's easier to use a RegExp in this case.
[removed]
I'm interested as to why you think import/export is more "eloquent" than require/module.exports. If you use object destructuring, and only call require at the top level, they behave basically identically from an aesthetic standpoint. But that being said, it's important to point out that import/export weren't introduced for "eloquence" or the like, but the benefits of static analysis, among other things. I agree with you on using babel though, for the most part it doesn't seem worth it when working in node, especially if you have to jump through a whole bunch of hoops to use it in your workflow.
I'm a big fan of ember (even though I don't work with it anymore) so let me plug it. As others have pointed out, it can be a full framework but it can also only be a rendering engine. Glimmer (its piece that does what react does) can be used separately. Ember and Ember Data were separate projects for years and you can still not include ember data if you don't want it. Now, ember also does server side rendering if you need a fast first page so I wouldn't recommend picking and choosing pieces. Just get the kitchen sink, render HTML on the server and load all that js without blocking the user. Notice how I glossed over server side rendering? All the react guys are getting ready to jump all over me because server side rendering is a really advanced react technique that you probably wouldn't invest in until you had a team to support it. With Ember it's much easier to implement because Ember believes in convention over configuration. So, all things Ember tend to work well together without too much pain. Even deployments. There's an ember happy path for keeping your index.html in redis so that you can deploy new front end assets without changing the backend. You can deploy a test version of your ember payload and test it in prod by adding a get param to the URL. Then, it's a simple command to promote it to production or roll back to a prior version. Which brings me to EmberCLI (which Angular was using last I checked). All of the dev tools are packaged into a node program which ships with ember. Again, tight integration and standards mean it all works together out of the box. Generating code, testing, deploys, etc... all happen through embercli and it all works together. The last thing that's different about ember - which seems trivial - is that it uses templates. Originally, Ember was designed with ie8 support as a first class citizen so they took the template (which looks like HTML but it's all js) and did a setInnerHTML with it. This was the most performant at the time because ie8. Then react came along, didn't support ie8 and used a virtual dom to kick the shit out of ember performance wise. Now, the ember core team are a bunch of thieves so they stole every good idea from react and built a new render engine named Glimmer. Glimmer dropped support for ie8, used modern apis to update the dom, and now has better performance than react if you choose the right benchmark (the reason is that templates let Ember know a priori which things can change so the update cycle has a much smaller surface area. React has to do virtual dom diffing to figure out what changed then update only those areas. Glimmer wins because it doesn't need to do the dom diffing piece. You can optimize react components to make them rerender much faster; you don't need to do that with Glimmer). I always advise beginners to build their first spa with ember. The reason is that you will get a ver complete picture of all of the concerns that go into spas. Then, when you pick up react, etc.... you'll know what questions to ask as you build out all of that plumbing for yourself. 
I think the bigger problem is that collision detection/response is done by throwing/catching exceptions.
I think it has to do with coming from Python before getting into node. So maybe "familiar" is a better description. I always configure my eslint rules to prefer no semi colons too, to further illustrate where my preferences are coming from. 
We chose react. We actually have a huge document we made with all our reasoning. It has a big matrix of all the categories and scoring for each popular framework. I wouldn't do the research justice trying to summarize too much. Vue was pretty close though in the end. 
&gt; A KeyboardEvent property representing the physical key that was pressed, ignoring the keyboard layout and ignoring whether any modifier keys were active.
Facebook isn't an SPA so why would they create an spa framework? I've found react to be very popular with shops that are updating rails apps because it's not about a single page and is very good at replacing components on the page. 
Fuck ESLint to enforce semicolons. The tool for the job is prettier, not eslint.
yea thats what i started with .im mostly using a mix of p5.js and processing its good but i dont really care to make moving arts things like it seems its used allot for. i prefer to draw with a pencil. GLHf haha i just learnt what it means 
Care to explain why? Or do you just have a really strong conviction for something that seems totally subjective? 
https://www.similartech.com/compare/angular-js-vs-react-js I saw another site recently that showed similar statistics, but I forgot to bookmark it. But Googling turns up a lot of stuff. As for the oft-discussed distinction between libraries and frameworks, I think the important point is that jQuery, React, and Angular are all competing for the same market space: primary tool for building client-side code. Whether you call any of the tools a library or a framework is indeed an important discussion, but ultimately that's not the point here. The point is market share, and Angular is clearly still way ahead of React in real-world deployments. In the corporate world, Angular is the tool of choice at this point, and I don't see any signs of that changing.
I like prettier because the formatting is deterministic. It always looks the same. 
Try it: https://jsfiddle.net/1r8dmjcu/ You can now, for example, tell if someone pressed AltGr + M to type µ and not Ctrl + Alt + M to trigger some shortcut. This was basically the reason why Atom was unusable if you used a keyboard with a non-US layout (or the US-International layout).
I appreciate the depth but you're reading way too much into this. This is a really basic algorithm challenge! People doing this challenge have no idea what \n, regexp and unicode are yet and the challenge doesn't require such cases to be considered. This article is aimed at total beginners, I'm just showing them a couple of basic JS methods.
I will bear it in mind, thanks.
[removed]
Copypasta
You can click the starfield to add more stars. You can click the logo to color / monochrome the stars. Setinterval works, I guess. What about window.requestAnimationFrame()?
Awesome, that's a great tip. Will give that a try this evening to make it smoother. 👏
Thanks, appreciate the compliment!
Just did a little reading about prettier. I'll taste a stab at it. 
Would you mind sharing that document? At least the big matrix part? I would like to see how the scoring and decision was made.
I'm not sure I would call this weird or quirky.. it makes perfect sense. Setting max-height larger than the height of an element will have no visible effect, without any animation involved. The open animation also has a period of time where it's active but nothing is happening visibly, at the end of the animation. The close animation animation then has that period at the beginning. If height were animated rather than max-height, there would be no perceived delay in either direction.
Works for me after changing &gt;document.getElementById('output1').innerHTML = "The ... back to &gt; document.write("The... And then remove the line break after "+elapsed+". 
I understand your point, but your methods are slower than it you should be. Complex abstractions, like arrays, sort and reduce are not the best tools for this kind of task. If you want to teach people how to use these methods, you should use an example where these methods are the best way to go.
Oh that makes sense. Thank you!
Something like `user-select: none;`on the Star Trek text makes spamming clicks much more enjoyable.
I wouldn't, unless you specifically need some functionality Node doesn't provide. The only reason I use it client-side is to ensure all the required functionality is present in an unknown client that may or may not support it natively. In the case of Node, *you* control the interpreter, so you can predict with 100% accuracy which features are available. The real question is, why doesn't Node support import/export syntax natively yet? Standards are a good thing.
This is why: https://github.com/nodejs/node-eps/issues/51
As I said usage statistics are really hard to do, checking www.similartech.com it has various google.com sites making up the angular.js top 10 and there's no facebook.com for React. I don't think I'd trust these figures. Angular really isn't the corporate choice any more judging by the job listings I see. Most of the jQuery stats will be due to Bootstrap or a plugin.
Thanks, will give it a try. That would avoid the select box around the star trek div from showing up right?
&gt;before React, when there was no choice but to write templates. Um what? Templates are much newer technology then hmtl manipulation with javascript. edit: lol, nobody here has programmed in JQuery? JSP?
I created a cordova plugin to start a webserver like ExpressJS on iOS and Android. [cordova-plugin-webserver](https://github.com/bykof/cordova-plugin-webserver)
There's no readme.md...
Use both. They work surprisingly well together. And `ESLint` can cover a lot of things that prettier cannot.
Just finished a largish React project for a client and can relate to your sentiment. I guess I needed a depency break. That's part of the reason it's all in the index.html - that and some laziness off course 😜
Yup!
The DOM runs asynchronously to the JavaScript code, which is almost irrelevant since the DOM executes so damn fast now. Here are some things to keep in mind: * The instruction to access the DOM is coming from JavaScript. This means that even if the DOM asynchronously you still need to execute some instruction to make this happen, so execute your DOM instructions before you fire your giant long running function. * The spinning icon, or whatever you choose, should come from CSS. That way it animates independent of whatever else is executing in the page. Here is how I would do this. 1. Create a modal like experience. This should be a tiny bit of HTML and a little bit more CSS. It should also be display:none by default. 2. In your event handler for that click action I would execute three instructions in exactly the following order: turn the modal one, execute the big function, and finally turn the modal off.
And not supported in IE, Edge, Opera, Gnome Web (Epiphany)
I call bullshit. The story, as long told, is Eich deliberately modeled the language after lisp. His bosses at Netscape told him to not do that and instead make the language work more like Java. So.... he did it anyways and added Scheme like prototypes to allow an inheritance model. With an inheritance model the language would work a bit more like Java, but it wouldn't have classes. Java-like classes would break the Lisp-like scope model.
Maybe overkill but you could try a WebGL implementation? If well done it would run a lot smoother with many more stars!
I'm pretty sure this article is satire
I believe `for` loops are always going to be faster than using functional methods, but I disagree that that's more readable.
Nice writeup! My nitpick would be with your function naming -- if I encounter a function called `findLongestWord` I expect it to return a word, but your function is returning an integer representing the length of the word. You should name the function something like `findLongestWordLength`.
Why write a bunch of code when reduce handles the problem well? It's way easier to maintain and the performance difference will hardly matter for most use cases and you can optimize if it's a problem str .split(' ') .reduce((item,longest) =&gt; item.length &gt; longest.length ? item : longest) .length 
I will politely disagree with every point you have made, and humbly leave it at that. No biggie.
I understand this sentiment, and I agree the simplicity of this project is wonderful. But in all fairness, it is a really simple web page. That's not necessarily maintainable when it's a large website, with lots of functionality, being maintained by a large team.
I'll give it try to see if that can be done without sacrificing any of it's simplicity. Would be cool to make it less resource intensive.
It wasn't obvious for me, I thought that max-height property is just for setting the max point, actual height had to be the height of the div (like with *height: 100%*).
Update: I fixed it!
Actually, your understanding is correct. By animating max-height you are animating the maximum possible height. The actual height is determined by the contents of the container, or the height property if it's set explicitly. To restate what I said with your terms, you are animating the max point. Not the height. While the max point is set larger than the height, you won't see any visible change.
I didn't say that Facebook is an SPA, I just said that React is in the real of frameworks which allows to do both parts of pages or full pages.
It looks like your comment schema depends on posts.js (Post schema) and your post schema depends on comment.js (Comment Schema). I'm not sure that's gonna work...
I have a french keyboard and use atom
By that logic shouldn't this updated example work: https://jsfiddle.net/ssu3fzmr/2/ or am I misunderstanding you?
you are right.
"*Was* unusable". They fixed the issue after 2.5+ years.
Oups my bad
We need to dispel the notion that JSX (i.e JavaScript in templates) is used exclusively with React. It's perfectly viable with Vue as well
Did you mean something like this; &lt;p id=output1&gt;&lt;/p&gt; 
I guess he came from Python. That's the way there to handle many things, as I learned myself (not a python pro, but saw in several different libraries, frameworks this approach and used - it came out quite nice really)
It's obviously not cutting edge technologies... https://memecreator.org/static/images/memes/4618121.jpg
I am hungry for apples all of a sudden.
I think it's this way of thinking that makes the web slower and slower. Of course here, in developed countries, we have access to powerful smartphones and computer and fast Internet but that's not the case for most of the world population. Websites are becoming too abstract IMO
Yup. I misinterpreted your comment the first time around. 
&gt; requestAnimationFrame Just added requestAnimationFrame implementation, definitely smoother, but still pretty resource intensive. I think because of the blurring. 
Just added that, thanks Ricky!
&gt; You need a browser that supports ES2015 modules. Chrome on Android 7 doesn't support.
This also has the benefit of approximating the way a human might do it in their head, so it's quite easy to understand. Most people aren't going to make a list of words and then sort them by length in order to find the longest one.
It's doubled the amount of stars I could put up before it slows. :D
If you are passing in long enough strings for it to be noticably slower you have other issues.
This javascript not /r/jihadiscript
And the Star Trek transition is smoother too. Great tip! Never using setInterval again for browser animations.
It sounds to me like that's a fundamentally flawed design decision on Vue's part. If they want observable arrays, they should have created an ObservableArray class that can have all the functionality they need and it probably would be good to give that class a toArray() method that yields an ordinary array. Taking a plain JS array and changing the semantics of what to expect of it is just asking for trouble such as this bug, even if it seems like a good idea at first sight to make the framework slightly easier to learn.
But how you gonna do it without html 
Very true. I shouldn't have added that sentence after the requirements, my apologies. 
I think it definitely will become superior in two years. Right now it's not ready for enterprise applications yet. Google still uses AngularJS for its cloud platform and firebase platform.
np was just wondering
What I mean with abstracting HTML away: in frameworks like SproutCore, for many kinds of applications you don't even need to see any kind of HTML, also not in the form of component definitions or templates.
Can't you use another templating language in react? You certainly can use something else in Vue. You can use jsx in Vue.
Why not use a web worker for that?
https://www.youtube.com/watch?v=-IPxxeb-4gk
&gt;[**808 Tutorial | CARNAGE | Razer Music | Re-Upload [7:20]**](http://youtu.be/-IPxxeb-4gk) &gt;&gt;808 tutorial by carnage it's funny &gt; [*^Lil ^Cancer ^King ^Beats ^[LC-KING]*](https://www.youtube.com/channel/UCkMr0WhL3T8LG_pMpUjVIHg) ^in ^Music &gt;*^218,831 ^views ^since ^Oct ^2015* [^bot ^info](/r/youtubefactsbot/wiki/index)
This is a great use case for [web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). Web workers are effectively an extra thread of JavaScript execution; so in your case, the DOM can continue to update without being hung up by the calculation being performed behind the scenes. When the calculation is done, you simply post it back to the outer JavaScript program which updates the DOM with the result.
Yes, did you try it?
Interesting! I'm a bit new to front end stuff, I had never heard of a web worker before this, I will try it, thanks :)
For sanity sake to people joining the thread late, if you solve a problem, please post the solution. Was it line 13 and/or 70 Also do you not have to encapsulate after an else (if after the else contains more than one expression?) Also I've noticed a lot of missing ; (I'm not talking about after if else's) either. This could be how new I am to JS syntax or maybe it's the formatting
This works for me: https://jsfiddle.net/my0mtkpy/1/
This is mostly done with CSS. Make a normal scrollable page, but make the title slideshow [fixed](https://www.w3schools.com/cssref/pr_class_position.asp) and give a higher [z-index](https://www.w3schools.com/cssref/pr_pos_z-index.asp) to everything else on the page.
 let lengths = s.split(' ').map(s =&gt; s.length); return Math.max(...lengths);
Also, 100% wronger if the array is empty.
we are on the same boat, i wish someone will jtell us what to do
Thank you. That's for the parallax effect, right? What I need is even if you go scroll further down there's an effect on how the page scrolls.
This works in my actual use case too, thanks :) The web worker thing suggested sounds nice and I'm glad to have learned it exists, but I think it gets a bit muddied by me bundling all my js files to one big file, so I chose to keep it simple and use this setTimeout solution.
hahaha good to know that i am not the only one :) i got some answers here that you may find helpful: https://www.reddit.com/r/webdev/comments/6nhsur/with_many_tools_being_around_how_do_you_keep/
Had a quick glance at the source, why are you calling `stars.map` to iterate over the array elements in the draw function? `Array.prototype.map` creates a new array so accumulating a ton of garbage there. (Use forEach).
Oops, that's awful! And that probably also explains why my Macbook was heating up so badly. Chrome collecting all that 💩. Thanks, fixed it right away!
Before using any library, I take a shot at implementing it myself. I needed to embed arbitrary media from URLs in a page I'm working on. I was considering using [embed.js](http://riteshkr.com/embed.js/), a 36KB plugin that pulls in yet other plugins to provide an all-encompassing solution. But I ended up [implementing it partially myself] (https://github.com/joshuaptfan/doublespeak/commit/6c3935c1884210fbc90c658293f1b5cb2e37e43e) in less than 50 lines of code. Sometimes some functionality of your web app is simply outside of your focus, though, and for those situations I prefer small, single-purpose plugins, like [clipboard.js](https://clipboardjs.com/).
I haven't experienced any added issues from using it. What about when you're writing a universal app? Are you going to not use import and export in the entire app?
Curious. Why was the logo for Vue.js used to make the "Pro's &amp; Con's" graphic? 
You could have webpack generate two versions, one transpiled with babel and one not transpiled. Then write a script that will run first and import one codebase or the other using feature detection. EDIT: You could do the same thing with rollup, grunt, or gulp. Also haven't used this personally, but [feature-detect-es6](https://www.npmjs.com/package/feature-detect-es6) seems like a popular way to do this. You can also use [jQuery.getScript](https://api.jquery.com/jquery.getscript/#jQuery-getScript-url-success) to load and execute the different codebases.
The common pattern is to always transpile a module into ES5 before being consumed. That way, you can decouple the tools you use to work with on your module with the tools you are using with your main app. If I'm building a React app with flow/Webpack and you are using Angular with Typescript/Rollup, we can both easily use the module because it's just compiled ES5. It also prevents your main app from becoming a monolith - imagine if you had to worry about building every single module - maybe your app will grow like crazy and you are developing more and more modules for more features. It will get complicated fast. I was just looking at the package.json for Redux on GitHub, and that will give you an idea of what a possible workflow might look like. In their case it's something like: bundle the code into lib/index.js (see the scripts field in package.json for their different build steps), bump the version, and npm publish. Then, it's ready to be used by other apps. The app that consumes the library knows to look in 'lib/index.js' for the exported object because Redux has the "main" field set to 'lib/index.js' in the package.json. Notice how if you 'npm i redux' in your project and look at node_modules/redux folder, you get a lib/ and dist/ folder. This is done using the "files" field in package.json. You can include anything, including stuff that is gitignored (like your built bundle).
I don't see any special effect when scrolling on desktop or mobile.
I've never used Babel server-side, but was considering it, so this is an interesting perspective. But why are building your application in a docker image? I understand using docker for deployment, but the build process can take part before you deploy and could even be done on your development machine, depending on how you like to set things up. Btw, have you thought about server-side hot module replacement? That's actually the thing that made me consider using Webpack with Node, and at that point Babel is only a tiny step away.
I think you're misunderstanding what is happening there. If you noticed, there is an 'await' keyword before the call to promise.all(). That means the code will effectively pause execution at that point and resume once all of the promises have resolved. You can then take the values retuned from the promises and do whatever processing you need. No callback necessary.
It's slower than usual sites. 
To keep good at vanilla JS I write parsers. I specialize on multi-language parsers, such as parsing handlebars tags directly in the HTML while parsing the HTML without running two separate isolated parsing steps. Another example is JSX which recursively switches between a JavaScript lexer and a markup lexer. Writing large parse structures and trying to solve as many parse considerations as possible in the shortest number of instructions possible can be challenging, but with practice it becomes fairly predictable. This kind of work makes for good vanilla JS practice because libraries and abstractions aren't helpful. They add more instructions and just get in the way when there is already plenty of code to manage. Furthermore, performance is a big deal to code parsing. For the sake of speed and maintenance less really is more. In addition to that I have been asked to pull the parsers out of my personal application so that they are more available for community contribution, available for use in many applications, and scale to allow support for additional languages, such as C++ with boost templates, with less effort. Pulling the parsers out for wider consumption means revising the code architecture and doing lost of clean up. If there were a bunch of extra code from libraries and abstractions in the way this would be a complete nightmare.
Just curious, why use server-side hot module replacement? I use nodemon and it seems to do the job just fine. My node app doesn't take long to restart though 
Ohhh, "Continue to here" debugging looks great!
A lot of newer currencies end up using GPUs until it becomes not worth it anymore.
Also check out the video: https://youtu.be/VWPVrJU2upw I am planning to do one on Express also
Yeah still nothing.See how I did it. &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Triangular Numbers&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var n = 100000; var start = new Date(); start = start.getTime(); function init(){ var sum = 0; for (i=1;i&lt;=n;i++){ sum+=i; } now = new Date(); now = now.getTime(); elapsed = (now - start); document.getElementById('output1').innerHTML = ("The "+n+ "th traingular number is "+sum+".&lt;br/&gt;"); document.getElementById('output1').innerHTML = ("Elapsed time was "+elapsed+" milliseconds."); } init(); &lt;/script&gt; &lt;p id=output1&gt;&lt;/p&gt; &lt;p id=output2&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 
Your version allocates an extra array for lengths, whereas the reduce version operates in place. That said, I'd still pick your version for simplicity.
I haven't bothered writing universal apps -- also seems like more hassle than it's worth, for the projects I'm doing. It certainly has its place, not debating that. But the stuff I've been working on doesn't really warrant the investment in development of server side rending.
I, too, am fine with nodemon. As I mentioned in an earlier comment, the stuff I'm doing doesn't warrant the investment in development time.
If you don't already have a build step, I don't really think it's worth adding babel just for `import/export` syntax. However, I recently started using flowtype, so I pretty much always use `babel` nowadays. Adding support for `import`/`export` is just another preset.
He's referring to the parallax on the hero
 node app.js the code works fine I just need to edit it in a way that it opens a set number of tabs at a time instead of opening just one, but for some reason when I do change the index statement it glitches and opens them all.
If you want a longer talk of the same things, but more in depth and with more interactivity, check out: https://www.youtube.com/watch?v=PjjlwAvV8Jg
I find it useful if you are already using it on the client for consistency across the codebase.
Typescript is a popular choice for node I feel. But that's for the type checking. I think node8 is so close to implementing everything from the es2016 spec though, so you may not need if you can update the node version. Check out http://node.green
It looks good. Is the project hooked up to a database like mongodb?
Last project I did I didn't even use babel on the client side until I needed to make the project generally available (chrome even has async await at this point). and even then I use a continuous deployment tool to build it so I don't have to have a build step for local development Unless you need decorators or flow type, not worth it at all anymore.
It sounds like you're overthinking it—just publish file(s) containing ES6 module code. If someone wants to use e.g., babel to consume it, there's [plugins to do that](https://babeljs.io/docs/plugins/transform-es2015-modules-commonjs/); or maybe rollup to generate a single module-less file to further transpile. They could even do it as an intermediate build step. If you only ship ES5, it's kind of opaque transpiled code and it makes it harder for folks building entirely with modules to use your code.
A lot of it was based on internal things. I'd have to prune a lot to make it public unfortunately. If you have any specific questions, I can try to answer. We're about 1.5 sprints into converting as well, and have already learned a few things. 
Additional reading to go along with /u/EngVagabond https://medium.com/webpack/the-state-of-javascript-modules-4636d1774358 https://github.com/tc39/proposal-dynamic-import may be the answer for `require()`, but I don't know.
I might not have phrased my OP very well -- I was on mobile at the time. Docker _is_ only used for deployment. I'm not developing in Docker containers or anything. And the building, releasing, and deployment of images is done on the CI server. But In order to get my CI server to build a Docker image that runs transpiled JS code (i.e. not executed with `babel-node`) I've either got to install devDependencies in the Docker image (not ideal) or build the image using another Docker image that does have babel etc. installed. So when I got that far down the rabbit hole of trying to configure my CI server to build the image in this way, I just said fuck it, I'll write require statements.
How is that much better than setting a breakpoint on the "continue to" line and continuing execution (F8)? Unless I'm missing something, this only saves one keystroke.
Yes there are certainly cases where I don't bother on the client side either. I'll use Browserify for being able to pull in npm dependencies but that's about it.
.textContent for text only tags and .appendChild for nodes (usually created with .createElement)
Run through the tutorials and examples for https://phaser.io and try and replicate them, it's basic JavaScript and in a few days you'll be able to cobble together your game if you really try. Reference https://developer.mozilla.org/en-US/docs/Web/JavaScript aka Mdn if you need.
&gt; Please take notice of the following policy: &gt; o No new project, sub-project or codebase, which has not used Facebook BSD+patents licensed jars (or similar), are allowed to use them. In other words, if you haven't been using them, you aren't allowed to start. It is Cat-X. &gt; o If you have been using it, and have done so in a *release*, you have a temporary exclusion from the Cat-X classification thru August 31, 2017. At that point in time, ANY and ALL usage of these Facebook BSD+patents licensed artifacts are DISALLOWED. You must either find a suitably licensed replacement, or do without. There will be NO exceptions.
No, you don't have to understand the source code to use it. You have to understand *how it works* and have a decent idea as to what it's doing under the hood, but that's it. I have being using React at scale for 3 years and my eyes glaze over whenever I try to dig too deep into its codebase. If you're good at vanilla JS and are creating real world projects with other people, you absolutely should start using a framework ASAP. The long term efficiency gains far outweigh the initial slowdown. If it makes you feel better, React's source code is notoriously hard to follow. One of the main goals of React 16 ("Fiber") is to fix that.
Trashy blogspam.
Webworker is overkill for this I think.
In the [Vue documentation](https://vuejs.org/v2/guide/syntax.html), they call their interpolation "mustache syntax", which refers to the mustache template systems that dates [back to 2009](https://en.wikipedia.org/wiki/Mustache_\(template_system\)).
They work very well together. Prettier for formatting and eslint for the things prettier can't handle like unused variables.
FB may change their license: https://github.com/facebook/react/issues/10191
Good point! [The challenge on freeCodeCamp](https://beta.freecodecamp.com/en/challenges/basic-algorithm-scripting/find-the-longest-word-in-a-string) uses it for its test so I just went with that. I'll recommend renaming it to make it clearer.
You know.... your team will eventually change and grow, and even if it does not its membership might changes its mind on what is the 'best practice'. It's one of those prickly annoying things about human beings: they're always striving to do better than they did before and if you the leadership is willing to throw objectivity out the window for them.... then be prepared to have many a Great Rewrite as your company evolves (or at least one from language A to language B... look at Reddit or Twitter or the Facebook Messenger team).
As a Python immigrant, do you ever wish the syntax was `from './foo' import X`so your IDE could actually auto-complete import statements just like it does in Python?
So javascript is executed in an environment... that environment is typically a browser (like chrome/mozilla/etc) or a native device (like a desktop/phone/etc). Since it sounds like you want to understand how to use javascript to run in a native environment, then there are a few solutions out there. NodeJS is a great way nonetheless to execute javascript on an unimpeded environment. That being said, there are a lot better languages (like java/c/c#/c++ to build local/native apps with than something like NodeJS).
How do I add a space?!
Because "good" writers like himself, do not borrow... they [steal](https://www.agriya.com/blog/2017/05/15/pros-and-cons-of-vue-js-framework/). /s
Thanks, I understand is meant to run in an environment but as of Yosemite, Apple has added Javascript so that it can be used to script automation in the OS. see: https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW1 but my programming skill isn't strong enough to fully understand all of that. so I wanted to start small and learn how to output and learn from there.
Yea, so various companies will take javascript (mainly some kind of engine like v8) and implement it in their products/etc =&gt; A big example is something like javascript in adobe products (they have their own custom/unique implementation of JS). While these are technically "javascript" =&gt; these implementations often have a ton of quirks to them and do not follow common standards in javascript. In other words, it may look like JavaScript, but under the hood that JavaScript is married to some API they expose in their applications and consequently it is commonly very undocumented processes and difficult to develop for without direct experience. I doubt you will find many people on here who have experience with implementing javascript this way in a macOS environment unfortunately :(. Reading over your source lead me to find this reference =&gt; https://github.com/JXA-Cookbook/JXA-Cookbook/wiki/Using-JavaScript-for-Automation. It seems to contain some good steps on how to instantiate the automation. I think what you're lacking here is mostly just "how do I get this up and running", which means you'll just need to read through the documentation accordingly. This is another good resource on using Apple's script editor =&gt; https://macosxautomation.com/applescript/firsttutorial/02.html. Another =&gt; https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/index.html (this basically explains that macOS's Script Editor now can consume both AppleScript and JavaScript).
Yeah, it was hard to find more info. I was hoping to learn JavaScript and learn how to use it for automation. 2 birds with 1 stone type thing. Thanks for that link, that might help me get started. Cheers
No problem. And yea, I'm sure you will definitely gain experience on programming in general, but this type of implementation/use is very different than how javascript in normal web development is used =&gt; and since this reddit is dedicated to web-dev/node-js/browser-js development, you will be hard pressed to find many on here that can help with this topic. I would recommend heading over to https://www.reddit.com/r/applescript/ =&gt; and asking "Hey, I see JavaScript can be used in place of AppleScript, I'm totally new to this stuff, can anyone give me pointers on how to use the Script Editor with JavaScript?". Good luck :D.
Good point. Thanks for that Have a great weekend!
Create elements programmatically using the DOM functions and insert them where desired. var div = document.createElement("div"); var textNode = document.createTextNode("my content"); div.appendChild(textNode) document.body.appendChild(div); The danger is if the innerHTML can be modified in some way by manipulating the page or URL. An attacker could insert any HTML they wanted. Using the DOM, you always get the HTML you meant.
As of right now, I'm not sure where you get that "FB may change their license" as no one from FB has said anything about doing so in that issue thread.
Not guy(s).
VS Code autocompletes, but you have to type something like `import {} from './foo'` then go back and put your cursor between the brackets to get suggestions - you're right, it's a pain.
This is the pattern I've seen: - Compile all library files into two folders. Both folders target the final environment (typically ES5 for browsers), but one folder uses CJS and the other folder uses ES6 modules - The package.json `main` field points to the CJS version - The package.json `module` and `jsnext:main` fields point to the ES6 modules version - Optionally, produce a third build as well that is a single UMD file; this is for devs who are going to include the script directly instead of via a module bundler What will happen is when the dev uses webpack or rollup, it will read the `module` or `jsnext:main` field and use the ES6 module version. **It still won't run babel on it**, but it will understand the module format and gain benefits such as tree shaking and scope hoisting. For non-webpack non-rollup cases (ex. NodeJS!), the `main` field will be read and the CJS version used. Mentioned by /u/mndewizzle, [redux](https://github.com/reactjs/redux) is a really good example of this approach. Its package.json includes the following (unrelated parts removed): { "main": "lib/index.js", "module": "es/index.js", "jsnext:main": "es/index.js", "scripts": { "build:commonjs": "cross-env BABEL_ENV=commonjs babel src --out-dir lib", "build:es": "cross-env BABEL_ENV=es babel src --out-dir es", "build:umd": "cross-env BABEL_ENV=es NODE_ENV=development rollup -c -i src/index.js -o dist/redux.js", "build:umd:min": "cross-env BABEL_ENV=es NODE_ENV=production rollup -c -i src/index.js -o dist/redux.min.js", "build": "npm run build:commonjs &amp;&amp; npm run build:es &amp;&amp; npm run build:umd &amp;&amp; npm run build:umd:min", }, } And its .babelrc includes these envs (omitting the "plugins" config for brevity, but it includes most of the ES6 -&gt; ES5 transforms and some others): "env": { "commonjs": { "plugins": [ ["transform-es2015-modules-commonjs", { "loose": true }] ] }, "es": { "plugins": [ "./build/use-lodash-es" ] } } With that, it produces two folders (`es` and `lib`) which both contain ES5 code, except the `es` folder uses ES6 modules (but still otherwise ES5 syntax). It also produces a `dist` directory which isn't used automatically by tools, but for the non-bundler devs they can reference that file directly.
I don't understand the docker bit. You could just install everything, build app &amp; `npm prune --production`.... but really pruning shouldn't even be necessary unless you are strapped for file size on the registry or in the host.... you'd probably get more benefit clearing npm cache as part of the install step. 
Thank you for sharing! Will check it out.
Bold move posting it here. I hope you like vulgarity and memes 24/7
I'm already regretting it :(
Really cool idea execution, congratulations!
&gt; That's not necessarily maintainable when it's a large website, with lots of functionality, being maintained by a large team. I'm not sure what the original comment was, but I agree that for experiments like this what matters is the thing working, not test coverage, maintainability, best practices, etc. Of course, as long as this stays as an experiment and don't scale.
What does the voice sound like?
You really should live stream this so we can listen
where should I stream it? 
YouTube or Facebook I guess. Not sure how anonymous it would be though but it would be fun to listen 
There's no real anonymity to speak of anyway since you can tweak the URL to go to OP's site with their name and resume.
Definitely stream it it sounds hilarious 
First off, when I used 'I', I was speaking for the good chunk of people who want to put technical details aside for the sake of pushing an app out the door, not just me specifically. I wouldn't dare push my preferences on others. Even then, yes, of fucking course technical details are important, but not everyone has the same problems. Not everyone needs Fiber. Not everyone needs the community. Not everyone needs the industry support. It's case-by-case. If Vue is fast enough, the performance gains from Fiber won't matter if you were to switch. If Vue becomes slow, find ways to make Vue faster. Or, if the team hates working with Vue for whatever reason, then they can switch to React. Whatever forwards productivity. _This_ is the point I'm trying to make. I'm rambling. But I feel like we already agree on most of these points anyway while just using different words, so the argument feels pointless. I don't get you people.
Angular 1 didn't even exist 6 years ago so don't make long term plans in the JavaScript framework world. The truth is it doesn't really matter, if you learn one framework well you can apply a lot of the same techniques and pick up another quickly. You haven't described the types of site you'd like to build which has a bearing on the framework, however based on your background I'd go for Angular as the comprehensive documentation plus wide range of tutorials makes it better for studying. Definitely give React a go after a while though, a day of playing around with it should be enough to see if you prefer it.
Speaking of which, "Portfolio" is misspelled on it.
You should take a look at React and Vue. 
Exactly, but for code formatting ESLint sucks.
thanks, will fix it tomorrow
I decided to stream this on Instagram. Follow @me.annoy to watch the live stream
I decided to stream this on Instagram. Follow @me.annoy to watch the live stream
Breakpoints are persistent on reload.
It's a common feature in other debuggers, and it's welcome for picking ad-hoc interesting spots in the code to go to. It's easy to implement, does no harm, helps you save clicks and not pollute the breakpoint list, so - a good thing.
At least play the sound neck to the user
This video doesn't cover it, but with "continue to here" also comes a similar ability to do the same thing while stepping into an async context, even where there isn't a line to actually put a breakpoint on. So while by itself it might not be a huge optimization, it ends up helping to enable things that were not even previously possible (without actually modifying the code) function foo() { // You can set a breakpoint here, and click to continue right before transform will be called return getAsyncResult() .then(data =&gt; transform(data)) } Paul Irish gave a pretty good demo: https://www.youtube.com/watch?time_continue=1065&amp;v=PjjlwAvV8Jg
Why not twitch or something else that doesn't require an account? I won't sign up for Instagram just for this, lol.
I don't know how. I will figure it out lol
On a side note, you can still use the harmony flag to get some newer stuff (node --harmony). ES6 modules aren't available, but some handy stuff like Object rest/spread are. 
Install OBS, look for a guide on how to configure it for twitch and follow it. There you go.
Now streaming on youtube https://www.youtube.com/channel/UCLuAsDy7eePvUbi3zpVjE8A/live
Takes about two hours to learn: https://www.udemy.com/code-your-first-game/
Doesn't matter that much, but it's an improvement.
Had a great time learning about chuck norris. 11/10 would listen to again.
[removed]
Twitch sounds better
And hyperapp as a minimalistic easy to get into solution.
It converged to one troll playing "tttttttttttttttttttttttttttttttt" repeatedly very quickly
Hahah awesome!!!!!! I love it, great job!
So I'm done streaming for the night. There are a couple of things that I will have to fix tomorrow before I start streaming again. Also, I will be moving to annoyme.us. Finally, I have to give credits to this dude (https://www.youtube.com/watch?v=WhtbyUMnalY) who had the original idea of this thing and I used it as a project to learn js :) Have a good night/day until tomorrow.
My advice would be to try both out. Both are fundamentally capable of the same things so you aren't losing utility. Angular is more out of the box feature complete where react by itself is just a component library and needs a stack of other libraries to bring in the same feature set. Also Angular is written in typescript, a superset of Javascript. You don't technically have to use typescript yourself using Angular but honestly you really should. It's a much better experience. Typescript provides static typing to Javascript which is really useful for both tooling support and general code usability. You can use typescript with react as well but since Angular is actually written in it the experience is probably a bit better. If you do try Angular make sure to use the cli. It simplifies project and code generation, provides a good development server, and takes care of the build process. If you have any questions /r/angular2 is the best place to ask them. The official [quick start guide](https://angular.io/guide/quickstart) shows how to create a new project and the basics of using the cli.
I can only relate to my personal experiences, but I came from Angular **1.x** to React and have written down my facts on [why I did so](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/). Maybe these help you to understand it from a personal perspective. Perhaps you should give yourself one week of learning each (ReactJs/Angular) and afterward make a decision based on your preferences (learning curve, learnings material, ...). Since I can only relate to React, I can recommend you to start with the [official documentation](https://facebook.github.io/react/docs/hello-world.html). Afterward, you might want to read the 170 pages open source book [The Road to learn React](https://www.robinwieruch.de/the-road-to-learn-react/). It comes with zero-configuration and tooling (because of [create-react-app](https://github.com/facebookincubator/create-react-app)) and teaches the fundamentals of React. Along the way you will build a Hacker News application and transition slowly from JavaScript ES5 to the new JavaScript ES6+ features. It's more of an practical hands on book where you learn React along the way. In the end it gives you more recommendations for different learning paths. 
hey /u/tunnckoCore.. i made this thing for boilerplates (not libraries or packages) - probably just serves noobs like myself who cant make things from scratch but just figured it might be nice to loop back to you. take care! https://packagejason.herokuapp.com
I tried "moist" repeatedly, but he's no longer live streaming. Troll fail.
That's a good suggestion, I should try that out first. Thanks!
I guess it only makes sense from their perspective as they're an open-source organization and they don't want any additional license terms to be applied to their software besides the ones that are in their own license. For similar reasons I wouldn't be surprised if they disallow GPL too. I don't think however that anyone should take this as an indication React is not safe to be used in his/her *application* because of this. Unless you have a very specific desire to sue Facebook in the future, this doesn't affect you at all.
What do you mean?
Well, yeah it did exist 6 years ago. The first version of Angular came out October 20, 2010.
Don't think you could consider it a framework until 1.0 in 2012. Actually I didn't count it as a framework until 1.5 came out last year.
React - no way around it IMO
It works because the types are exported as thunks.
Yeah, sorry about that, I'll write one up. This is more of a jump off point than a full fledged boilerplate.
Thanks everyone :D
No database, reads dummy data from a couple of arrays, but adding a db is easy, just change the data fetching in the resolver functions.
About 34 kg
Idiotic "satire". I'd personally slap the idiot who wrote if I ever came face to face with him
Shitpost. Ban the author
I missed the comment too but I was someone bitching about not using framework XYZ...
&gt;Using the DOM, you always get the HTML you meant. Unless you parse received HTML to do that - then it is as safe as innerHTML
[@youyuxi's latest tweet](http://i.imgur.com/OdB3gV5.jpg) [@youyuxi on Twitter](https://twitter.com/youyuxi) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Well that's unusual to say because I've built web apps for 1 of the largest retailers in the world using angular version 1.2 and 1.3 and they are extremely strict with that they use so I'm pretty sure most people would have classes it as a framework before 1.5
Since you've got Angular1 experience go ahead and dive into Angular 2. If the tutorials are hard to follow watch some video tutorials on YouTube and I'm sure you'll start loving it once you get a grip on how it all gels together :)
Thank you, this makes sense. Got a place to work from now.
Right, thanks, this is what seemed most logical to me. And yes, overthinking is an unfortunate tendency of mine
Because at the he time if posting they literally were asking if FB would consider changing their license or relicensing, and the reply was "I'll check on Monday"
Oh I am sure this wont be abused at all!
Keep it simple and straightforward. Express. Separate html, css, JavaScript + jquery for dom. 
I know..
No need to use babel for the backend. just stick with require with node.js If you use promises, I recommend checking out the module`bluebird`. Better performance, and you can promisfy any callback function. node has this built into the `util` module by calling `util.promisfy`
In the "parallel" function, both promises are kicked-off before you await either result. In the "series" function, the second promise is kicked-off after you got the first result back. Pro-tip: You can use Promise.all + destructuring if you need the results of a few promises before you can move on. let [a, b] = await Promise.all(promiseA, promiseB);
lol nice work!
So it will be released as soon as warning is fixed or there is more work to be done?
Yeah I generally use bluebird too. 
That means nothing...
Good to know. 
Apart from they may change the license.
in "parallel" function both promises were resolved in 500s? 
Let me know if that full text of the kama sutra comes through...
500 ms, yes. You can wait for several things in parallel. Imagine you're doing a network request and, say, want to get the location via the Geolocation API (which requires user interaction). If the former takes 500 ms and the latter takes 1000 ms, you can be done with both in 1000 ms. The file can be downloaded while that dialog is shown and waiting for the user's response. If you, however, wait for the network request to complete before doing the Geolocation lookup, the whole thing will take 500 + 1000 ms. If it's a pile of network requests, doing them in parallel won't give you the full theoretical performance boost, because there is a limit to the number of requests you can actually do in parallel. However, keeping 4/6/8 connections busy is still much faster than doing the requests one by one. So, if the next async thing doesn't need the result of the previous async thing, start it right away.
Is React a hell to use because of its license ?
What makes is not ready for enterprise, yet? I know of several large companies currently making the transition, so I assumed the runway was clear...
There's nothing to base this opinion on
If you're using it for personal projects, it doesn't really matter. I can understand why companies might have some concern with it though. Hopefully this gets sorted out, there's currently an issue open [here](https://github.com/facebook/react/issues/10191) suggesting a relicensing of React.
&gt; Yeah, you're the 10x super-pro that doesn't, right? I'm just a guy who works for a company with pretty high hardware and software quality standards (that we have to comply to by law) so seeking for help on StackOverflow is simply not the way we work. Not everybody builds webapps or mobile apps or whatever. A significant part of the IT world actually has nothing to do with that, and doesn't use JS at all, simply because it doesn't make much sense in some contexts. JS is indeed becoming huge. But relying on StackOverflow statistics is just like assuming an iceberg volume by measuring the part that's out of the water.
I mean if we’re being pedantic, sure there IS html. But with modern frameworks you don’t have to write a lick of it. 
I think so. React 16 is scheduled to include Fiber, and it's overdue. I don't know of any other part that they will wait on before release.
Twitch
So what's the alternative? Edit: they say preact and inferno
well you will always write some Kind of markup
Mixer is the best stream platform.
I submitted this Repo 2 weeks ago and asked for feedbacks. This is an updated version based on your comments. Feel free to criticise it and give more suggestions. Thanks.
The problem is that Facebook covers so much that damn near any site could be considered a competitor. Post pictures? Competitor. Post information? Competitor. I know React is all the hotness right now, but I'm staying away from it.
I'm not sure what other specific work still has to be done, but Dan and Andrew have both recently said that React 16 won't be out for at least another few months. 
&gt; My curiosity mainly focuses on why some people choose to use React and others choose Angular2 Because it solved problems that angular 1 had and that todays angular still suffers from. Angular is a template oriented oop/mvc framework and that paradigm is [coming to an end](http://blog.wolksoftware.com/the-rise-of-functional-programming-and-the-death-of-angularjs). React has paved the way for a new approach to deal with complex problems in the most obvious and natural manner, and today 9 out of 10 frameworks are react derivatives or base on very similar principles at least. To things to consider: * [React is the most used framework](http://npmcharts.com/compare/react,angular,@angular/core,ember-cli,vue,@cycle/run,@polymer/polymer) * It has the largest eco system * It is one of the easiest to learn and use * It literally reaches everywhere, the browser is just one of many targets Fiber, Reacts api compatible rewrite that is coming out now, should probably also get at least a footnote. It will cause similar ripples as React has caused in that it pushes the web into a new front that it couldn't reach before: native performance.
Vue could be.
Really? What a nightmare. React Native has made the decision to ship with the React 16 alpha and it's understandably causing problems like this: https://github.com/airbnb/enzyme/issues/928
Seems like the two major ones are Vue and Angular. I'm not too familiar with either library but I believe they both use templates and Vue has mutable state (what does Angular do for state?). I really enjoyed the functional style of React and would like something similar. If I were to switch from React, which library/framework would resemble a more functional style? 
A discord bot build on discord.js that forks a watcher process to watch an audio folder for changes, and automatically creates commands to be played. It's a soundboard bot that's easy to maintain (new files don't have to be hardcoded, and bot doesn't have to be reset) https://github.com/idietmoran/Discord-vasi
This makes sense. I've experienced having to change code to set breakpoints in this way. Thank you.
Preact 
The PATENTS file has nothing to do with "competition". It's an attempt to discourage patent suits against Facebook. I've got links to [further discussion and analysis of the PATENTS file](https://github.com/markerikson/react-redux-links/blob/master/pros-cons-discussion.md#reacts-patents-license) that may be helpful.
While I agree that the "Why" part of a recommendation is important, this formatting makes the list much less readable. Most will find the list useful without the motivations, and for the curious it's probably enough to be able to access it somewhere else.
Angular is better plus no license headaches Our team been using it for a few months, and it’s awesome, improved our team workflow by light years. Plus it’s fully integrated with TypeScript (language that makes js development great again) relies on rxjs for reactive programming, and we use ngrx/store which is redux like state management for angular entirely implemented using rxjs and TypeScript.
Apart from where they literally say it you mean? Do you even know what "may" means? Its not the same as "will"
I think Dan was saying he'd check on who to refer the issue to, but regardless that doesn't tell us anything about what Facebook may do. 
Not sure what exactly you mean by functional, but we use ngrx/store and ngrx/effects along with Angular for Redux style state management and immutablejs to handle mutations. 
Modules are supported in Chrome 60+, but they are behind a flag. I guess that Node will support it at the end of the year, too.
Angular for large projects. Vue maybe for small or personal projects
Why is Vue unsuitable for large projects?
Well if you look at the problem from a large company’s point of view (which are usually the ones developing large projects), you want to develop your software with a tool that is backed by someone reliable, that continues getting features/security updates and 3rd party libraries, which tool will you chose? A. Something developed by some chinese guy B. A tool developed by a fucking huge company like Google, which relies on this tool entirely to manage itself internally, was developed for a workflow in huge teams for big enterprise grade applications, full time dedicated teams and a huge community around it. I understand that there is a vocal circle jerk around vue and everyone loves it bla bla bla (and i probably will get down voted by vueboys for expressing my opnion on the frameworks), but come on, circle jerking aside, let’s be real here for a moment, even though I’ve used vue and liked it alot for being the best of two worlds (angular+react) vue is just a hobby project compared to mastodons like react and angular. That’s why a company will be more inclined to go with angular/react for a mission critical large project.
ofc React may be safer than Vue (because it's backed by Facebook) but I don't understand "Rivets part". If some lessons should be learned from "Rivets part", I think these would be more like: 1. automate your work. If you need write boilerplate in each class, just use inheritance/composition or other technique to reduce boilerplate (e.g. simple wrapper) 2. Don't use (in production) libraries you never used before just because they "sound easy". If you think about using library you don't know, try first to make at least some sandbox project and check how this particular library can handle typical scenarios you will need in your project. Using React in production if somebody never used React before would be comparably unsound decision. Sometimes it's better to use tool you know best, not the coolest tool. 3. Refactor your code before it's too late. If Rivets was indeed bad choice, you should get rid of it as soon as possible, even if that meant big refactor. Counting on "people behind Rivets" to fix your problems is not sound (BTW if you will have some issues with React, will you expect Facebook to change React API jut to solve your particular problem?? No way). 4. If you use some niche technology, be prepare to fork it and use your own fork instead of using official version (with fork you could "repair" Rivets). On the other hand I must agree with the article that Issues on Github can tell much about project status. So it would be wise to look into GH issues before using particular solution. And source code itself. Many problems with libraries have direct source with poorly written code in library (especially when architecture is poorly designed. So it could be good indicator if library is safe to use)
[Can you imagine a world without lawyers?](http://i.imgur.com/ywOpPB7.gif)
Yes. Have you tried it yet?
The thing is that Angular's tooling and IDE support is without competition. Also, the Angular architecture scales incredibly well. You can just use the CLI tool, write `ng new my-project-name` and you are good to go. When I used Vue for some projects at work about a year ago, it wasn't quite there yet. Also, Typescript ❤ Vue is really nice because the syntax is intuitive and easy to pick up, though. I think it is the perfect thing to use with a PHP app, for example. Just use it to add some sugar to your views. Using Angular as your front-end for PHP or Ruby (...) app, on the other hand, is a huge overkill. It was made for SPAs and should be used for those. So if you want to avoid Facebook, both frameworks are solid choices. They just have slightly different use cases, if you ask me.
Ugh, why would you use Vim, it's developed by that Bram guy. Neither Google or Facebook are involved so it must be trash. It doesn't even have daily patches! How can you take something seriously unless it's used by almost everyone you know in your echo chamber. /s It doesn't need to be popular to be good and useful in the right scenarios with care and attention. But I think JavaScript is a mess of a language and ecosystem, so, nobody here will listen to me anyway :D Sometimes simpler, smaller software is better. Size isn't everything.
Replace p elements with &lt;div id="output1"&gt;&lt;/div&gt;
Alibaba is using Vue
&gt; Ugh, why would you use Vim, it's developed by that Bram guy. Neither Google or Facebook are involved very bad comparison pal. nobody makes production grade software running on vim (wtf lol) It's not about the size, it's about making a decision strategically, which is how it works in real world, I realize that circlejerking and fanboyism might work on reddit and medium.com, but that's not how it works in companies, they don't base their decisions on emotions or badly written, biased medium.com hyping articles.
lawyers are a symptom, not the problem most of the time. &gt; Can you imagine a world without assholes that require us to have a legal system?
I never used it, but DekuJS is inspired by React and supposedly more functional.
There's also VirtualDOM
as someone who just started to get vuejs, that hurts :( But this might be the truth and I suspected it for a while, because all job postings I see for frontend engineers are either React or Angular, damn guess I'll go learn some angular... Got any links to point me to?
Yes, here is the official getting started: https://angular.io/guide/quickstart This is the official tutorial that goes over main Angular features (directives, components, services, http, routing, modules, etc. ): https://angular.io/tutorial if you really wanna go in depth, I recommend to follow Maximilan's Udemy course: https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/overview 60% of what I know I've learned from him, really good teacher. Good luck.
Thank you!
Entire Google is managed by Angular internally (+100 business/management oriented tools). The most profitable Google's product, Ad Sense is running on top of Angular Google Trends, Ad Words, LucidChart, Gode.gov, and not to mention that 90% of Angular apps are running behind the firewall (internal enterprise software). feel the difference yet? 
The pursuing conversation also includes discussion of the possibility of apache and Facebook collaborating to change the FB license to be compatible with future OSS licenses. Frankly it is woefully poor not to see that.
For the frontend, I agree with the sentiment "just pick one". Angular1, React, and Vue are all good choices and Google/Stack Overflow will be big helps for both fixing issues and finding packages that already have features that you want. On the backend, the most important thing in my opinion is to keep it de-coupled from the frontend by creating a lightweight API. If you are choosing nodejs/javascript for the backend, express would be my initial choice but there are others like hapi. If you keep the backend and frontend de-coupled, then you have more options down the road if you decide to switch languages or frameworks!
I just started a new project and the license was one of my major concerns. I looked into preact as it's supposed to be API compatible. Ultimately, I went with React anyways: 1. Nobody seems to be majorly concerned about the patent issue. It generally seems to be a defensive thing rather than an offensive thing. 2. Preact is API compatible, but it's internals are not. Many of the niche react tools (testing, dev tools, etc) simply did not work well with Preact. I decided that it was worth the risk to use React for the time being. Should we ever find ourselves in legal trouble with Facebook, we'll invest the time and energy into changing to preact. That would hopefully come at a time when we have more revenue, more team members, and more ability to handle the challenges that come with preact compatibility.
Yet the previous state of their patents and termination clauses shows a mentality that I won't develop software to be dependent on. The clauses are extremely unusual even today and violate the spirit of OSS. Who knows what games Facebook would play if it were to have a serious competitor using React?
If you needed to switch, all you have to do is add this to your webpack config: { // ... resolve: { alias: { 'react': 'preact-compat', 'react-dom': 'preact-compat' You wouldn't need the react dependency after this. I always do this in production, preact is about 2-3kb. Or even remodelling to preact/inferno/etc wouldn't be hard. These libraries all work similar and have the a similar foundation. 
IDE support is really good with Angular, gotta give them that, especially with Webstorm, literally prevents potential bugs on the fly before you even compile.
Yep that's what I'm saying. WebStorm plus Angular is simply amazing 
&gt; A. Something developed by some chinese guy &gt; B. A tool developed by a fucking huge company like Google, which relies on this tool entirely to manage itself internally, was developed for a workflow in huge teams for big enterprise grade applications, full time dedicated teams and a huge community around it. I see your point, but that "some chinese guy" did work for Google.
Compared to Google, he’s still some Chinese guy
I said I saw that point, but compared to most Chinese guys, he worked for google and made a huge framework used by and supported by many big companies. So just saying "some Chinese guy" doesn't really make the point you are making. The point you are making is one between a personal project and one by a big company. No need to make it about the guy himself.
Good for them! I hope others follow. So sick of mediocre developers who think react is the only thing out there. 
Let's start with imagining a world without React being recommended for everything. Then imagine no Facebook. 
I think you *may* admit you read the conversation wrong.
nice arguments for preact you got there...
Depends how important uptime is and how complex their webapp is. There are still a lot of unknowns with Angular4. There's also a few features that are still in their infancy like Angular4 Material.
muh react, muh functional programming, muh higher order functions that take in functions and return other functions that return even more functions, muh functional monads and mappable functors. Damn I'm tired of those people you can't even imagine.
I chuckled.
Angular being used widely by the company that originated it and Vue being a suitable alternative for apps of similar size are not mutually exclusive ideas.
It'll be shipped as an alpha first—if that helps!
I work for a company who doesn't shy away from litigation, especially when it's defending their own patents. If ever, Facebook did infringe on our patents, we would surely sue them and usage of React would give them leverage against us. Either it would require a rewrite of some products or there would be arbitration... neither of which I want to be involved in as a software engineer. **Edit** This also applies to ImmutableJs, which is IMO more disappointing as a developer because the concept of immutable data structures has been around since well before Facebook.
Now where did i put my copy of War and Peace?
Still nothing 
It's kinda funny that FB wrote Cassandra, but now Apache can't use React.
Of course. 
A world without facebook sounds glorious 
You can use Redux with any framework including Vue, so you can still have a functional approach to state. I find the scalability and predictability of Redux to be the advantage tho, which Vuex (Vue's state management lib) gives you in a very similar manner regardless of being mutable or not
Real question: I just started learning React 2 weeks ago. Is it still worth learning or should I focus on something else?
[Hey guys, we have moved to a new domain http://annoyme.us/](http://annoyme.us) 
Stay learning React. These things tend to work themselves out. 
I'm surprised no one has linked the issue in `react`: https://github.com/facebook/react/issues/10191 Asking to consider switching to dual license as RocksDB has.... Dan says he'd look into it on Monday. It may be that all these concerns evaporate in the near future.
Twitter uses React.
This is the dumbest possible argument for Angular, given Google's proven track record of killing products, even popular products. The only products I trust Google won't kill are search and AdSense. And Green Tea being built with Angular gives me zero trust that Google won't ditch Angular the minute Bread Green pisses of the wrong person or decides to leave the company.
&gt;nobody makes production grade software running on vim Ah, so you have no clue what you're talking about. Got it.
Could say the same for you tbh
I wouldn't pay attention to them. They make it quite clear they have no clue about anything outside their tiny bubble. If you like Vue, use Vue.
Google is an advertising company, not a developer tools company. 
&gt; I just started learning React 2 It's already on 15 bro better update 
Yeah google doesn’t have software engineers who use developers tools, and facebook is a social network that doesn’t develop developer tools so no reason to use react either. You argument makes so much sense, honestly sometimes I think I’m communicating with 15 year old children here...
Yes. You're starting both waits at near the same time, so by the time the first await finishes, the second has also finished (since they're both 500ms) so it immediately returns. Your series waits for the first to finish before the second starts, so it takes 1000ms.
This works for me. &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Triangular Numbers&lt;/title&gt; &lt;div id="output1"&gt;&lt;/div&gt; &lt;div id="output2"&gt;&lt;/div&gt; &lt;script&gt; var n = 100; var start = new Date(); start = start.getTime(); function init() { var sum = 0; for (i = 1; i &lt;= n; i++) { sum += i; } var now = new Date(); now = now.getTime(); var elapsed = (now - start); document.getElementById('output1').innerHTML = ("The " + n + "th traingular number is " + sum + ".\n"); document.getElementById('output2').innerHTML = ("Elapsed time was " + elapsed + " milliseconds."); } init(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;
Hate to break it to you, but yeah, I have a clue. There are plenty of people out there using vim to build "production grade software." Making statements like you did above show that you have no idea about the "real world." This has nothing to do with stuff I read on reddit or blogs, and everything to do with talking to actual developers at conferences. Not speakers, but attendees. There are tons of people out there using VS Code, Atom, Emacs, and yes, even Vim. And they're building quality software with it. To say that nobody uses Vim just shows your ignorance. Also, latching on to Angular because it's built by Google shows your ignorance. Google is an advertising company. Everything they do, in the end, is done to get more eyes on ads. Angular doesn't further that goal, and thus can be dropped just as quickly as anything else built by Google. And if you think that Angular is super popular within Google, then you should check the dearth of Angular content this year at Google I/O. There was more Angular content at Microsoft Build than at Google I/O. The Angular team is building an ecosystem distinct from the web at large. That ecosystem is a warm comfy blanket today, but the moment the political winds inside Google change and the Angular team gets disbanded, that comfy blanket is going to become a straitjacket. 
Try a Python framework, Ruby on Rails or Meteor. \*runs and hides\*
What's so difficult to understand? Let me spell it out for you. A) Everything Google does is done to help get more ads in front of more eyeballs. B) Everything that doesn't help directly further that goal is ancillary, and thus can be dropped at any time. This has been proven time and again by Google dropping quite popular products.
I ran the code in the debugger and I know what he was saying now. He means that when you try and place the contents into id="output1".. the browser has no reference to those elements yet, therefore the elements should be created before the script executes. So place the html elements above the script. In the future: Run your original code in chrome, press F12 and click on console. It will show you the exact error; from there search that error and see what you come across. 
You idiot, i didn’t mean nobody uses vim to write code, i said nobody develops software on using vim as a framework. He compared an editor to a framework, which makes zero sense
Meh just a stupid opnion nothing more nothing less, software engineers working at google personally don’t give a shit about ads, they just work on the project and try to make the web applications faster and better. Not everything at google is about ads. With the same logic you could say facebook (which is also an advertising company btw in case you didn’t know) is developing react to sell ads. I don’t know if you realize how stupid you and your ads argument look yet, if not, keep going I’ll be happy to help you realize it 
Yes. This could be used to build a client-side image editing tool. It would also be useful for more intense data visualization.
Ok, so I misread you *completely* misreading the original comment by /u/Wolfy87 The original comment talked about how silly your argument that people should only use frameworks "developed by a fucking huge company like Google." Should we not use Rust because Mozilla only has revenues of &lt;$2 million? Should nobody use Ruby on Rails because Basecamp is a small company? Heck, Stack Exchange is a pretty small company. I guess we shouldn't use that platform for exchanging answers. At the end of the day, any developer who builds their application with Angular is ceding a large portion of their control over the future of their codebase to a huge company who has proven repeatedly to not care one whit about the needs of those using their tools. Hell, just look at the Angular team itself and how they completely missed the need for a migration plan from NG 1 to NG 2. It was a complete mindfuck to them that people who had built applications with the previous version of the framework might want a way to easily migrate to the completely new, completely incompatible new version of the framework. I'm friends with members of the Angular team. That doesn't mean I trust them to still be maintaining Angular in four or five years.
Facebook *is* building react to help show ads. That is how Facebook makes money. The technical goals behind why React was initially created were to speed up the website and get rid of pernicious bugs. The end goal was to build a better performing, less sucky facebook website that would keep user eyes on the site and keep them from getting frustrated by perf issues and leaving. I've had conversations with core members of the React team. They'll flat out tell you that "Facebook isn't committed to React. Facebook is committed to the ideas behind React." Both Facebook and Google have the money and resources to drop their respective tools and switch to a new shiny idea or implementation of an idea without much of an issue. Does your team/company have the money to re-implement your application if the Angular team decides they need to rewrite again to deal with technical debt? I doubt it. Maybe they do, but I doubt it.
lol.
&gt; I've had conversations with core members of the React team. They'll flat out tell you that "Facebook isn't committed to React Ok, I smell so much bullshit from you right now, it's borderline annoying, don't bother replying any further.
I hope you enjoy The Adventures of Sherlock Holmes. I am wrote a python script to send some books to your script. It sounds good so far.
Fuck you man 😂😂😂😂
I've used JXA pretty extensively and would absolutely not recommend it for someone new to JavaScript. It's super finnicky, very poorly documented, there are almost no resources for it online, and it's nothing like any other js environment.
Hahaha, love it.
React is pretty quick and easy to learn IMO and it's another string to add to your bow. If you haven't already, you should look into how to achieve the same results as React, Angular etc. without using any frameworks, it's always good to know how these things work under the hood.
You can smell all the bullshit you want, that's your prerogative, but I had Lee Byron tell me that at Oredev 2015. You obviously have no idea who you're arguing with, or just who I know or don't know. So, sure buddy. I'm full of shit and the conversation I had never happened.
Someone is interrupting my fine reading of Holmes with "Hello World." How rude.
you make claims like that you better provide some good proof or otherwise just stfu and don't make a fool out of yourself.
Well, who can blame him? He doesn't have much time left over due to his [side gig](http://www.ntrglobal.com/cloud-helpdesk)... (/s)
I did try to add subtle changes in the story.... they have yet to be read out loud.
Well, there's this picture from Twitter with me having dinner with Lee Byron, Rob Wormald, Pete Hunt, Steve Klabnick, and Monica Dinculescu. https://twitter.com/robwormald/status/662025331339980800 So, that's core team members of Angular, React, Rust, Polymer, and Aurelia (myself). 
soon Ill stop it lmao
I don't care about any of this, I'm talking about claims that facebook isn't committed to React. 
&gt; I just started learning React, two weeks ago
And I'm telling you about the conversation I had with Lee while at Oredev. Facebook is committed to React until they find a better way to implement the ideas of React. Whether that replacement, when it comes, is a simple migration for developers outside Facebook is much less important than the internal concerns of Facebook. Facebook has the means to completely rewrite their entire codebase if need be. Most companies using React don't, either because they have to work on writing new software, or because they hired contractors/consultants to implement the software and now that team is gone.
you sound like total scrublords, tbh.
&gt;Facebook is committed to React until they find a better way to implement the ideas of React. Which will still remain React, I'm not a React expert but as far as I know they've already completely rewrote React's Reconcilier, I think Fiber Reconcilier they call it now, and as far as I know the migration to react fiber will be transparent for devs, or minimal migration changes will be required in worst case scenario. &gt; or because they hired contractors/consultants to implement the software and now that team is gone. shit like this isn't uncommon in the industry and happens everyday, in fact I did this myself once when I was a contractor, there's nothing out of the ordinary here, a lot of companies are running on legacy technology and even if it can be daunting sometimes, they are still running.
&gt; I just started learning React 2, weeks ago
Good to see your still spouting your opinions as facts. You keep being you and never let anyone talk about another js framework without mentioning how react is teh bestust and anyone not using it is just being foolish. We don't have room for rational discussion around here. 
There's plenty of software built on Classic ASP still running. It doesn't make it maintainable or easy for companies to find developers to maintain it. And that's what will happen when/if Facebook moves on from React, which is a lot more likely to happen than you might think. Facebook is a company that lives on the bleeding edge.. heck, they invent the bleeding edge oftentimes. They invented React, and at some point they'll reach the limits of the virtual dom and they'll move to something newer and better. The question isn't if, it is when. 1 year or 8-10 years? I don't know. But there's a lot of smart people that work at FB who aren't afraid to discard "legacy code." And they're not worried about the React community as much as the React community wishes they were.
 const cards = data.cards;
Hmm. I wonder if learning swift would be more “future proof”
This is nothing new, and you will 99.99% never need to worry about this. React has been out for over 3 years now, and the Patent clause has been there. There are multiple corporations that are using ReactJS in their workflow, even companies that lawyers could argue are competition (e.g. Twitter) and no one is loosing sleep over a patent clause in the license. 
I understand that and I agree, but again, this isn't new in the industry, technologies come and go, companies either adapt or keep maintaining the legacy techs, those who can't do either will disappear, and something new, something better will come and take its place, it's the natural flow of things. A Web Agency where I worked at as Angular 1 contractor worked on a huge project, when Angular 2 came out, they've realized that that can't afford to rewrite the whole thing, and I didn't want to keep working on Angular 1, so I transferred my knowledge to their devs, wrote some docs on my work and left. They are working with legacy tech just fine, and the client is happy. An R&amp;D lab was also developing their tools in AngularJS, but they've realized that they can move to Angular and hired me to lead all Angular projects migrations and training, in one moth I've trained the team, month 3 we've migrated the main tools they've had from AngularJS to Angular 4, month 4 we've created even more awesome tools with Angular 4 that will actually help a lot of people, and we keep moving forward. Yes the lab works in medical field, so they have the budget to pull shit like this, but it's totally possible. And this been going on for ages, technologies and companies come and go, especially in the tech industry where everything moves at the speed of light, and this is normal, we've been doing this shit for decades and the world hasn't ended yet, I honestly don't understand what are you so worried about. 
Finally working now.Thank you all. I failed to put the div tags at the right place.
Microsoft supports React, Netflix uses React.
It would, but it depends what your goal is. If you just want to develop native iOS/Mac apps, swift is where you want to be (and it's a great language). Javascript is quite a bit more flexible - you can do almost anything (including writing apps for iOS/Mac) with it.
http://idangero.us/swiper/get-started/#.WWvVVMapXMI ```Don't forget to change 3.x.x with actual Swiper version``` It seems that you can have more than one swiper on the same page: https://github.com/nolimits4web/Swiper/blob/master/demos/23-thumbs-gallery-loop.html 
Are you making the api call to localhost:xxx/api when you're in production? If you are, try making the api call to http://mydomain.com/api or whatever. I used MERN for a couple of days but hated it so I can't remember much about it, but give that a shot
And so we go back to my original argument: trusting Angular simply because it's developed by a team at Google is misplaced trust.
not just angular, everything, but If I have to chose between a hobby project, and project maintained by a team which been doing this for years even before React was a thing, I'll chose Angular. We can't just sit there and be afraid that the world will end without moving forward and taking calculated risks.
supercalifragilisticexpialidocious
Really? That's really bizarre... Not a good decision on RN's part, especially for a minor release. The fact that they aren't adhering to semver gives me pause when considering it for an upcoming project. Thanks for the info, I'm going to dig a bit further to figure out what the thoughts were behind that decision.
Unrelated, but I think you can use a for..in loop instead of iterating over selects.length.
While records seem very useful, we ened up purging them from our codebase. They are great if you know exactly what properties your records will contain, but in our case (very configurable records) it turned out to be a problem. The main challenges that we encountered: * They cannot be extended. If you suddenly realize the need to apply an additional property to an item, you have to modify the record declaration, which makes no sense if that need is contextual and not global. * Syntax inconsistency. Immutablejs may not be as pretty as destructuring everything, but if you have records and deeply immutable state, you end up wanting to use get/set anyway. Not much detail since I'm on mobile, but those points should be enough to get the idea. I'm not saying that records aren't awesome or that you shouldn't use them, just that you should carefully evaluate your own use case and long term requirements before deciding on your data architecture.
and here comes the video for Express: https://youtu.be/-XHN1T6r_R4
That's your prerogative. But, to me at least, the Angular team has already proven they have no problem completely dropping their entire userbase to go chase the new shiny. I personally will use anything *but* Angular for any projects. I'm on the Aurelia team, so obviously I prefer to use it, but I'd look at Vue and then React or a React clone to build an app before dropping to Angular. It's nothing personal against the team building Angular. And this is ignoring my misgivings with Angular from a technical standpoint, which are many, but have been aired previously in various conversations with various people, and that, in the end, won't sway the Angular team at all.
Wait what do you mean 99% will never have to worry? Almost all my personal websites are Apache + React. Doesn't this mean until something changes I can't use that stack anymore? 
For someone like myself who uses React together with Cordova to build commercial products, what does this mean? That i can no further use react and Cordova for my commercial products?
Unless you plan to file a patent related lawsuit against Facebook you can safely ignore it. The change is about Apache projects depending on React, not about projects depending on both React and Apache software.
Agreed. Vue is a great alternative. I've been using it at work lately and I love it. 
good rule of thumb, if you're code is nested more then 2-3 levels deep you're probably doing it wrong.
&gt; Use verbs for non-resources. There is no such thing as a "non-resource". Resources are not domain entities. A resource doesn't even have to exist in your domain. In fact, though it's uncommon, a resource can be purely virtual (as in, it only exists in your URIs). So, you don't "tell the server to translate text" by issuing a `POST /translate?text=Hallo`; rather, you "request the translation of the provided text" by issuing a `GET /translations?text=Hallo`. The same can be applied in any situation where you think "there is no resource" and need to use a command/action/verb in your URI.
I see the course at udemy is currently on sale. Thanks
“twitch plays loud noises”, a spiritual successor of “twitch plays pokemon”.
For personal projects, this whole situation is irrelevant and not something you need to worry about at all. The license worries are just for people using React in a corporate setting.
There's no need to use vim when you have ed. Ed is the standard editor.
At the end of the day you're saying the smartest JS developers in the world, who all effectively use async/await and promises are "tools and newbies". Sorry but I just can't take you or your challenge seriously. 
i'm... not sure you understand the purpose of a promise. a promise isn't a way to do away instain callbacks and usher in some new callbackless era of javascript. in your example, every time you want to add in a new async function, you have to modify your original code. if you want to support nine simultaneous calls, you need nine checks and nine variables. inevitably, someone will complain that they can't do ten async calls. wouldn't it be nice if we had a way to handle any number of async calls? promises are just a generic way of doing what you're doing. you're still using callbacks. you're still in absolute control and can do everything it is you want. now, however, there's structure. you can handle quirky use cases. in your example, how do we handle failure? what if i wanted to handle a specific failure case when `asyncGetDatabaseStuff3` fails, but it's recoverable and we want to keep going? what happens if based on `asyncGetDatabaseStuff`'s data, we need to make a determination if we want to call `asyncGetDatabaseStuff2` and `asyncGetDatabaseStuff3`? we can absolutely do this by having our framework handle more robust cases, but now we introduce complexity. it's now our job to test/maintain our framework, to handle these more and more complicated use cases. all this work is done via callbacks. the callbacks are still there. dive deep enough into the stack and you'll find an `function (err, data)` waiting for you. the tedium of _managing_ the callbacks is handled by promises. we're given a nice, neat api that we can leverage to handle our success and failure cases. don't like the `.then` or `.catch` syntax? leverage `async`/`await`. promises have _nothing_ to do with the "spaghetti" code you're seeing. promises are just a means to an end.
- CanJS - Vue - Angular In order of my preference.
Worth pointing out that Angular 1 and Angular 2+ are nothing like. The new Angular was a complete rewrite and many aspects did not directly port over. I know of many developers who struggled with the transition and just went for alternatives such as Aurelia and React (more so Vue these days).
There are so many ways to do the same thing and not just in javascript. If you don't want to use Promises.. don't. You don't have to. You can do whatever you want without them. However, for your challenge.. how about fetching something from an api, and printing it to the console. Something like.. fetch('http://apiv3.iucnredlist.org/api/v3/version').then( data =&gt; console.log(data) ); If you can write that without promises so its less than a single line of code and its more readable in some good old fashion coding.. lets see it. 
Which Python framework is a replacement for React, a client-side view library?
good job man, fix the shooting part asap ! :P
Here's a shortlist of things to choose from - https://promise-nuggets.github.io/ - all of which demonstrate using Promises vs Callbacks. Note that pretty much all the callback-based examples use the (third party) `async.js` - so you'd get to re-implement those examples without it. Which from experience, is not very much fun at all. 
what happened at your job that made you hulk out on a modern language feature that everyone loves? let it all out man, we're here for you.
Except for that whole licensing issue some companies have an problem with
Continue. There is literally no problem with the React license.
I guess it's time to finally make the switch to https://fortran.io/. I knew this day would come, I just didn't expect it so soon.
You can't compare with large companies. Microsoft was an early investor in Facebook and they probably already have IP and patent sharing agreements. How do you know what agreements Netflix, Microsoft, and other large corporate React users have negotiated with Facebook? Do you have a written IP sharing agreement with Facebook?
Make sure your names are good. The first name you think of for a function is probably wrong. Come back to it a few minutes later and make sure the name of any nontrivial (or even trivial) function is clear and considers both what the function does, and how/where it's likely to be used. Bad example: return api.update() .then(getReferenceData) .then(cacheData) .then(render) .then(success) .catch(error); Better: return api.getLatestChangeNum() .then(getReferenceDataIfChanged) .then(updateCacheFromReferenceData) .then(updateDOMFromCache) .then(clearErrorToast) .catch(showErrorToast); This was quickly adapted from an existing project but I hope my point comes across.
Have you had any difficulty or issues using preact? It's really appealing to me for the size, but I feel a little wary about going with the store brand version of react tbh.
I haven't touched JS in years. It doesn't really look like or feel JS anymore with all the new features.
This really depends upon your definition of readable. **Declarative.** Many people prefer lots of abstraction and isolation so that they can drill down on a single piece of code for their minor modification without worry about the world around them. You need to describe the purpose of your bit of code as you write it with descriptive names and shallow structures. **Imperative.** A minority of developers don't want all the extra luggage that goes with abstractions and a bunch of superficial ~~bullshit~~ help. These people want to know how the hell they got to the target place in the code and they want their answer honestly and directly (no bullshit). Less is more. Here is what I have learned from experience doing open source: * When I jump into new projects the most frustrating thing is finding where I should put my changes and how the code comes together. You will improve upon this most by concentrating on architecture, but you can help with documentation about how things are organized and where pieces go. * Most developers need a certain amount of hand-holding getting into a new project. Provide good documentation to ease them into it. Also provide very simple means of validation so that newbs can test and validate their modifications. * Reduce or eliminate build steps to run your application. Save the build steps for validation, unit tests, and automation. This allows new people to experiment with your code faster. * Don't let newbs dictate your architecture. What has made large code easier to maintain for me is deeply nested structures that make heavy use of closures. Such code is imperative in its architecture but allows declarative tactical units that are easier to understand and easy to reuse. Deep nesting scares the crap out of weak programmers, but they will get over it. Things like shallow structures, inheritance, and other fun stuff are really popular among newbs, but you really need to be managing the flow control structures of your app otherwise the newbs will turn it into a spaghetti mess. * Lock down the dependencies. This is not open for negotiation. You need to be an iron-handed dictator of evil death about this or else you will soon be shipping a 1000 NPM packages and wont know why or how they integrate with your application. * You should define team code standards and styles. This includes all the holy war crap that people get so emotional about and also relevant things like validation rules, taxonomies, and naming conventions. All the crying that people do about code style really is stupid, but its nice to have standards to unify things. I recommend finding software to auto-format the code to conform to the team style standard upon commit so that the contributing developers can work however they wish and an automated process applies the team standards.
&gt; I say Promises are for tools and misguided newbies that have no clue what they are talking about. http://i.imgur.com/kWJSvz7.gif
1. Functional programming is good for avoiding avoiding side effects and mutable state. But it doesn't necessarily make code more readable. 2. using / not using `this` keyword is an implementation detail, not something that makes code magically more/less readable. 3. Too much JSDocs can be overwhelming. Commenting every function is needless (unless you have spaghetti code in your project) and obscure the code. So too much JSDocs can make project **less** readable. 
And "Clean Code" by Robert C. Martin is word reading.
Yeah that's what I'm doing. I tried to make the calls that way but they still returned 404
&gt; You obviously don't get the abstract concept. You can't even articulate your point of view. You only say that A is ugly and B is cleaner, but you don't even provide a contrived example of that. &gt; The check is still in one place. You have to add something after line 3, after line 7, after line 10, and after line 18. Destructuring + await + Promise.all clearly wins.
Do you mean vanilla components with shadow root?
&gt; You still have to write the promise. You have to promisify older callback-based APIs, but that's not true for newer ones. Dart, for example, had Futures (=Promises) and Streams from the beginning. They are used extensively by the standard library and all third-party libraries.
mithril.js is both smaller, faster and easier. 
Of course, the `async` / `await` syntax is powered by callbacks under the hood. As soon as execution hits an `await` keyword, the language bundles our current scope into a callback and passes it into the promise's `then` method. When the promise resolves, it runs the callback and our code resumes. At the end of the day, the `async` / `await` syntax does the exact same thing as the convoluted code in your blog. The only difference is that the transpiler / interpreter handles the boilerplate for us, so we can express our *intention* as plainly as possible. This is how languages evolve in power - by doing the grunt work for us so we can focus on the things that matter to our customers.
I am back streaming again. https://www.youtube.com/watch?v=OzjUwXX-azU
I've never known I needed something so badly until now! Gonna live the dream of 1970s physics code on a node server.
Not that I support the idea, but there are several Python -&gt; Javascript tools out there, so conceivably you could build a React killer using Python as the base language and convert the code to JS, ala Angular/Typescript. 
But it appears /u/Headpuncher is recommending learning some existing Python framework. If not, "why don't you write your own view library comparable to React?" is a rather involved task for someone who is has just been learning React for a few weeks.
I got that user was suggesting to use something like Django or Flask in place of react (which if you don't need/want a js driven site, Jinja2 is a very capable template system). On the other hand, I wasn't suggesting someone actually write a Python -&gt; Javascript framework, just that it is possible if someone really wanted to. 
Those "guys" who posted before you are not guy(s). To many it's trivial, but to some it matters.
This alone makes me worried; Reddit_object.length === many_people_object.length - not even camelCased?
VirtualDOM (I think the correct spelling is "virtual-dom") is a library based on React's own virtual DOM concept, but it's way lighter (and badly documented as well :/ ). Never actually used the thing, but I frequently hear of it being implemented in place of React.
He forgot to add that /r/angular2 is a good place for questions.
[removed]
Are you planning on suing Facebook?
IANAL, but [Facebook's PATENTS grant](https://github.com/facebook/react/blob/master/PATENTS) seems equivalent to what [Google eventually did with WebM's additional IP Grant](https://arstechnica.com/information-technology/2010/06/google-resolves-webm-licensing-conflict-with-bsd-license/). The Facebook PATENTS grant seems to be written in a way that has zero impact on the BSD copyright licence. It explicitly states that any rights that can be revoked are only with respect that patents that are held by Facebook, which are wholly independent of the any rights granted under copyright law. So, basically, it says if you sue Facebook for any reason, or any 3rd party in relation to claims related to "The Software" (i.e. React), then you lose the rights to any Facebook owned patents that React (and their other software) is covered by. e.g. 1. Facebook owns some patent, P. 2. React code does something that is covered by P. 3. Facebook grants you a licence for P so that you can use React. 4. You sue Facebook, Facebook revokes said licence to P. 5. You can still do anything with the software that is granted under copyright law, with respect to the BSD licence, but you can be sued if you infring upon P. (theoretically, you could modify React to remove any code that would infringe upon P and continue using it unaffected). This interpretation is supported by [Facebook's FAQ on the issue](https://code.facebook.com/pages/850928938376556). &gt; **Does termination of the additional patent grant in the Facebook BSD+Patents license cause the copyright license to also terminate?** &gt; &gt; No.
What?
[HyperApp](https://github.com/hyperapp/hyperapp) for me.
Are you, as an individual, or legal entity, planning on suing Facebook over a patent claim? If yes - then you will have to stop using any React code in your application. If no - then you are free to continue using React code in your application. That's basically all the patent in question enforces.
When you create a promise, to get a value out of the promise, you must do .then() to unwrap the value. And you can do .then() as many times as you want against that original promise. (Not talking about .then().then().then() chaining). With RxJs observables, you must do .subscribe() to unwrap the value. But if you subscribe multiple times against the original observable, you are not sharing the original observable anymore. You are creating a new observable everytime you subscribe. The difference is that a promise tries to resolve as soon as you create it whether you do .then() on it or not. Observables do not evaluate anything until you subscribe. There is the concept of hot vs cold observables you can read about. Various blog sites explain it. You can change an observable to multicast and have its wrapped value shared across the subscribers/observers by applying .share() on it. This operator forces an observable to be evaluated immediately. Subscribers are free to peek into its wrapped value later.
Correction: Adsense is running on angular dart. Not angular Ts
I'm a little bit confused on the multiple subscriptions not sharing the same observable anymore. In our current project, we have one observable that has a lot of subscriptions. Every time the observable emits a new value, all of the subscribers get the same value
Yes yes YES to #10!!!
Except typing requires additional bloat to work, which is kinda ugly. And even that, it wont work properly.
`for..in` is rarely what you want. If you're iterating an array in modern JS you want `for..of` or just `.forEach`. `for..in` will do unnecessary work like traversing the prototype chain, which is 100% not what you're looking for when you want the items of an array. It may very well work, but it isn't what it is meant for.
If you're going to use Preact, I'd recommend developing with it as early as possible, and test it with all your dependencies first. Some React-based frameworks will not work with it (eg. draft.js and many of it's plugins)
Couldn't you use local storage to store the image URL to be transferred to the next page?
How do they determine what does compete with Facebook and what doesn't? They could easily make that claim for any successful commercial webapp ever made with React.
What did they kill off? They have more popular tools that's been around for years other than Angular such as Polymer and dart.js and they are still supported pretty much as if they were new.
CanJS? I haven't heard about this one in a while. Is it not abandoned yet?
frankly immutableJS sucks. Javascript wasn't meant for this. If you want to work with immutables best to use a language which supports them out of the box and compiles to JS.
It's stored locally in a folder. I'm using JS to fetch all images from that folder and display it.
I've made a plugin which autocompletes all exports wherever you type so you may never need to go up and down again. It also has an option to add imports when you're pasting code. Try it here: https://github.com/capaj/vscode-exports-autocomplete Don't forget to submit an issue if you find some!
I think i will stay on React for progress and build tools, and use Preact for smaller payload in production. Some projects still use createclass, they need another alias, other than that I haven't had many problems. There's also react-lite, perhaps it would work with draft?
amazing feedback! Indeed records cannot be extended, We use them for our react/redux store, and its doing great in that context. Syntax inconsistency might cause some pain, but our way of solving is that we only send records (or a Collection of records) to the components, while we deal with other immutable on the reducer/selector/saga level.
As I said, i use it for size only, and it may be a escape hatch should licensing become a problem but I doubt it will. I haven't had problems so far. You can set it up quickly and see if it works. There are others too like inferno-compat and react-lite.
Actually, there was never a real version 2. They used v 0.1 to 0.14 and then released v 15 ;)
I think the bigger problem is react-native, what alternative do we have? I know that there is Ionic and maybe some other Angular mobile frameworks, but they are by far not the same as react-native as they need a WebView and are not really native apps...And at least when you do animations you'll see the difference...
Alright, thank you. 
In case you want to go more in depth for the React part, perhaps this one adds up very well on the linked article: [A gentle Introduction to React's Higher Order Components](https://www.robinwieruch.de/gentle-introduction-higher-order-components/)
um, the very concept of promises is good old-fashioned coding. as in developers have been making promise-like libraries for as long as javascript has been used in production-facing apps. as in promises as a concept predate node.js as a concept. [as in functional programmers invented them in the back half of the 70s](https://en.wikipedia.org/wiki/Futures_and_promises). so yes, you are saying utter garbage &amp; i'm reasonably certain you have no clue what you're talking about. 
**Futures and promises** In computer science, future, promise, delay, and deferred refer to constructs used for synchronizing program execution in some concurrent programming languages. They describe an object that acts as a proxy for a result that is initially unknown, usually because the computation of its value is yet incomplete. The term promise was proposed in 1976 by Daniel P. Friedman and David Wise, and Peter Hibbard called it eventual. A somewhat similar concept future was introduced in 1977 in a paper by Henry Baker and Carl Hewitt. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Is it the same value or an equivalent value? Look into the multicast operator.
error handling? performance characteristics? i don't have time for that, i need to put more buckets under my waterfall.
Angularjs &lt; 1.5 is nothing like 2+. An angularjs component is pretty similar to angular2+ component etc.
Are you on the react marketing team?
https://en.m.wiktionary.org/wiki/guys You are Welcome 
Yes, but removing any React code that is based on P would be very difficult. Also consider any other patents have that may impact on React and you'd need 10 lawyers just to keep track of it all. Nobody _needs_ React. You can use vanilla JS or any one of the other frameworks and libraries. So better to not use it.
Can't even imagine trying to maintain that code, all the JS, CSS and HTML in a single JSX file. Blurgh. What a mess.
Why do you think this is not production ready? Does it need more unit tests or something? Or are there some known bugs or limitations?
Yeah just haven't tested enough
There is quite a discussion about this - additionally to Backbone.js either Vue.js or React.js might be adopted: https://www.sitepoint.com/which-javascript-framework-for-wordpress/
Use namespaces and don't put everything in the global scope.
NativeScript does the same thing but based on Angular. They're also working on integrating Vue with NativeScript.
Never had a look into NativeScript. Does it generate real native views?
I haven't tried it. But yes, it does. No WebView.
Fair enough, if it works for you then stick with it. Thanks for the heads up about React Lite, I'll give it a try!
That sounds promising! :)
Very basic differences between react and angular: Angular is a framework and gives you everything you need to build a front end application (view rendering, router, state management etc.) Whereas React is just a view library so if you need to partner it up with other libraries such as redux and react-router to get everything you would get from angular. In terms of which to choose : my first piece of advice would be to disregard any comments about which is "best". Neither are "best" - it's just different tools for different situations and preferences. That said, if you are just starting out you might be better off with react or vue due to their shallow APIs. Much easier on beginners although it is still very possible to create a complex React app. In fact it is much easier to get yourself in a muddle with React than it is with angular because it's relatively unopinionated whereas angular has very strong opinions. Tldr; React == easy API, complex ecosystem. Angular == complex API, easy ecosystem. In my opinion. 
&gt; Every argument, article, and comment I've ever seen about Promises or trying to handle the asynchronous nature of javascript has just be garbage. You wrote a short article with very few lines of code, and it wasn't even quality code, and it doesn't support your bold statements. Go write this article and make it substantial in respect with what you say. And stop boasting off like that, it's bad for you. Edit: grammar
What I was doing was answering the question in a pseudo humorous way. In every thread about "what should I do, ooh the angst!" there are suggestions that are ridiculously off-base. I thought the runs and hides addition made it obvious I was not being serious. However, learning Django or Meteor or something that let's you see what's going on in more than just the front end is a huge bonus as a developer. So I'm sticking by my comment and revelling in the downvotes. I like that the focus is on python, completely ignoring meteor which allows for both react or angular on the front end. Personally I'm not a fan of RoR so that was just trolling. 
OMG just use preact or inferno in compat mode and STFU
Except what you just wrote would just log the response, and not the data. You'd have to extend that a little bit: fetch('http://apiv3.iucnredlist.org/api/v3/version').then(response =&gt; response.json() ).then( data =&gt; console.log(data) );
I enjoyed reading this and like the Why-sections giving me context on the things where I wasn't agreeing. * I prefer not squashing when rebasing, and making small commits that tell a story. That way if a bug is discovered git bisect will find the line of code that introduced the bug more easily. * I think it is a good idea to open a Pull Request early with a "Work in Progress" prefix to encourage collaboration and early feedback * If the system has a good continuous deployment pipeline with frequent deploys (for example every feature) then I would skip the develop branch and find a strategy to test the code before merge (automated or manually)
I know what you mean, I already _know_ javascript, and 9/10 times I think I just can't be arsed with a lot of the new stuff. I never bothered with Coffeescript, and it looks I'll probably start using Typescript soon, as it's a superset of ES6 with a few bits about strong typing bolted on top. To that extent, it has an eye on the coming standards, but it isn't full of cute, clever nonsense, and isn't "javascript for people who don't like javascript" like Coffescript and a few others are. In terms of features that are actually needed to benefit the user, HTML5 APIs are far more commonly of benefit than any ES6+ features.
If you're making a request to localhost in production, that will fail and horribly. Why? Well think about it. You've told the client it should send this to localhost. But localhost for the client is itself, not your server. So whenever you're making requests, you want to make requests to a path relative to the domain you're on, e.g. the requests should be made to /myPostRequest. This ensures that when you change host to e.g. http://mydomain.com, your post request just routes to http://mydomain.com/myPostRequest, and on your local machine, it routes to localhost:1337/myPostRequest
100% agree with you there and i know exactly why some developers didn't move onto angular 2+. it's also worth pointing out the Angular 2 focuses on component based architecture and so do other frameworks (such as react) so if in the short term you decided to goto Angular 2 (because of previous knowledge on how angular1 works) then later on, if needs be, you will probably find it easier to learn and use a framework like react.
Apache stops using React for their projects. That doesn't mean you can't use both Apache &amp; React techs in yours.
Good catch :)
Well, patents is only a game the big guys can play anyway.. 
Do we need a "Libre React" or "Open React"? It should be feasible to make a fork of Preact that's not only API compatible with React, but also is compatible with it's internals. It would mean reverse engineering parts of React. A succesful "Libre React" project could also nudge Facebook to change it's license on React.
Yeah you're right. Didn't realize that when I read the article.
*Follow a style guide!* Or make up your own, but *stick to it*. 
For one-liners, wouldn't you have to use brackets, otherwise the statement returns undefined without logging anything ? data =&gt; {console.log(data)}
I'm aware, I'm just fucking around since the person wrote a 2 instead of the word two 
modules.
I think you misunderstand what a Promise is, a Promise isn't just some other way of writing an error/success case, it's more of a result value. In the same way that this function can either return a synchronous value or throw an synchronous error: function divide(x, y) { if (y === 0) { throw new Error(`Can't divide by zero`) } return x / y } This function can either return an asynchronous value or throw an asynchronous error: function fetchJSON(url) { return fetch(url).then(response =&gt; { if (!response.ok) { throw new Error(`Not a 2xx response`) } return response.json() }) } [You even said yourself](https://www.reddit.com/r/javascript/comments/6hjes4/any_way_to_assign_a_new_value_to_this_inside_a/diz6swp/) that you thought Promises weren't a good substitute for syntax. Personally I agree that's why they made `async` functions which turn the previous example into: async function fetchJSON(url) { const response = await fetch(url) if (!response.ok) { throw new Error(`Not a 2xx response`) } return response.json() } Which I think is a lot better, they have a direct correspondence to if the functions had been synchronous, and you can still use all your regular syntax with them, like `try-catch`, `if`, `while`, etc
Your wrapper code works pretty much fine. What errors are you getting?
If you have an observable from a promise, that is a hot observable due to the nature of a promise trying to resolve immediately. Also if you are using a subject, that one is already a hot observable.
Oh, I want to be able to replace the 'pageCheck(this,item)' with something I can put in the parameters. Basically a wrapper that looks like wrapperFunc(pageCheck(somereferencetoNEWajaxObj,element)) and have it work. Right now It's literally just a function to clean up my doSomething function; it's not really re-usable. Is that ok? Is the code without a wrapper fine and using one like I'm trying to not possible and my example wrapper is also useless? 
No, that's a common misconception. As long as what you're doing is just another function call and nothing else, you're good.
Hi, sorry for long time response! Check out a TodoMVC implemented with Dutier. https://codesandbox.io/s/mZnrX7GN0
Looks nice!
 function HTTP (url, method) { let then; let xhr = new XMLHttpRequest() xhr.open(method, url) xhr.responseType = 'document' xhr.send() xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { then &amp;&amp; then(xhr.responseText) } } return { then: function (callback) { then = callback } } } HTTP('///www.google.com', 'GET') .then(function (response) { console.log(response) }) This should be fine for your use case
For the HTML you should just write it out twice. If you're not yet at the stage of using templates or component-based frameworks then just writing the HTML twice, with different class names so your library doesn't target the same markup twice, should be just fine. I wouldn't recommend it but if re-using the HTML is something you really need to do you could write it out as a string inside a template literal. Return the template literal from a function, in that function you could accept strings for the class names. It would look something like this: const generateHTML = function (classnameA, classnameB) { return ' &lt;div class="outer-${classnameA}"&gt; &lt;div class="inner-${classnameB}"&gt; &lt;!-- content here --&gt; &lt;/div&gt; &lt;/div&gt; ' } I don't think backticks work on my phone, so make sure you're using backticks for the string block after you return, else it won't be a template literally. You could then insert this into to DOM before you call the slider constructor, you'd need something like innerHTML (not recommended) or appendChild, which is safer but you will have to build the markup differently.
thanks everyone and thanks /u/sinefine for telling me hot vs observables. that topic and [this article](https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339) clarified my question. 
Not at all. Still actively developed. They just released a [major new version at the start of the year \(v3\)](https://www.bitovi.com/blog/canjs-3-0-release). They now have a full framework called [DoneJS](https://donejs.com/) which CanJS is a part of. If you want a full isomorphic framework without cobbling together your own, it's a great choice. Downside of course is their are less popular so less community support. But the core team is responsive online so there is that. 
The [16.0.0 milestone](https://github.com/facebook/react/milestone/23) is probably a better indicator than this site. 
You absolutely should use try/catch around JSON.parse as it will just barf if anything is wrong. The real question here is if you should just return an empty result instead of doing something else? It'll depend on your situation. If it's something mission-critical and not having the information will be bad, you should stop the application from continuing and inform the user of the problem. If it's an optional bit of content (like recommendations or something) then it's okay to return nothing and act like everything is okay. You could also ask the user if they want to retry the operation, or even retry it yourself a few times before giving up.
Thanks, good points on the empty result handling. For the application's sake I need to return a valid value so that `maps()` elsewhere in the app don't go tits up. That being said I think you make a good case for implementing a little UI whenever the the state variable that calls this function gets updated with an empty array.
Have you tried https://lodash.com/docs/4.17.4#uniqBy ?
Google has a long history of killing products, even popular products. Here's a really annoying slideshow of some of the products killed just in 2016: http://www.networkworld.com/article/3130069/smartphones/google-graveyard-what-google-has-killed-in-2016.html#slide2 If Google is willing to drop Hangouts on Air, which was pretty widely used, killing Angular isn't too far fetched. It may or may not happen, but there's plenty of precedent. 
Why can't you use promises?
It's completely ok (even more – it's required) for `JSON.parse()` usage (as well as for `JSON.stringify()`), but IMO not ok for handling missing object properties. I mean this line: ```const content = props.cachedItem.content || props.item.content; ``` You can get 3 possible TypeErrors here: if `props` is undefined, if `props.cachedItem` is undefined and if `props.item` is undefined. The only case it's ok, I think, is when you should have such properties for 100% of cases, but just want to protect yourself from unexpected stuff. Otherwise, if you have such items it one cases and does not have in other valid cases, it's not good to use try-catch and better to explicitly check for those keys.
 b.filter(o =&gt; !a.find(o2 =&gt; o.id === o2.id)) I guess.
If I understand what you want, your problem is how to efficiently control the callback flow. You have bunch of async (xmlhttp) requests, and whould like to invoke them without callback mess (better formated code), with your own code. function cascade(funcs){ var funcs = Array.prototype.slice.call(funcs) // making a copy of funcs (array of functions we provided) function next(){ var args = Array.prototype.slice.call(arguments) // making array of arguments passed to it var func = funcs.shift(); // takes the function always from beggining of array (changes array) if(func){ // while there are fucntions args.push(next) // add reference to itself as last argument } else return; // so now we have function and all arguments (with next as last) func.apply(this, args) // calling function with whatever arguments passed and next() as last one } next.call(this); // enter the recursion } cascade([ function doSomething(processNext){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { processNext(this.element); // note that in first function argument like "element" must be variable from closure } } }, function pageCheck(page,item, processNext) { var xhr1 = new XMLHttpRequest(); xhr1.onreadystatechange = function() { if (...) { processNext(page,item); } xhr1.open(..) // ... } } ]) Althou you should understand how "this" referencing loses context in async functions. I left them in there because I just copied your code.
I think cookies should do the trick for you: https://stackoverflow.com/questions/4825683/how-do-i-create-and-read-a-value-from-cookie. To expand the answer a bit: 1) escape/urlencode the URL to the image -&gt; set a cookie with "path=/;" so it's shared between pages 2) in the editor page, unescape/urldecode the image path and there you go. This is just off the top of my head.
It is worth pointing out that any functions directly containing a try/catch block will **never** get optimized by V8 prior to version 5.3. You can get around this limitation by wrapping your dangerous code in another function and calling that from a minimal parent try/catch.
Use a `Map` and write an algorithm such that if an item is added once it points to data and if it is added when it exists it points to null or undefined. Use the `id` for a key.
Damn, I can hardly wait it's like christmas. omg omg omg!!!! :D i'm 12 btw haHAA
And if your arrays are big and you care about performance, create object (or Map) object with keys: const a_map = a.reduce((acc, value) =&gt; Object.assign({}, acc, {[value.id]: value}), {}); const uniques = b.filter(o =&gt; !!a_map[o.id]) EDIT: Object.assign is reeeeeeeeeealy slow, see below in this thread
By the time it gets to the if statement, the value of c has been updated to 5. So then it'll be 5. Variables work like a shelf. You can put the number 0 on the shelf, then later you can replace that with 5. Now if you check what number is on the shelf it'll be 5 since that's the most recent number you placed there.
You can use try and catch. Just make sure you catch intelligently. That is: try { JSON.parse(content).blocks.reduce({ //.... }) } catch (e) { if (e instanceof SyntaxError) { // parse error, proceed accordingly } else if (e instanceof OtherExpectedError) { // and so on... } else { // and then finally... throw e; } } The whole point of catching errors is to deal with *expected* errors, not unexpected ones. Make sure to only catch the errors you anticipate, and do so as specifically as possible.
Ah ok, so then the output is "Door number 1"?
This looks great, I'll give it a more in depth read and possibly link to it in the article!
It should be, but that last line will always write over the output so it'll always say "Door number 3" regardless. Just like with variables, whatever was last placed in a variable (and that text output is a variable) is what will stick.
Gotcha. So if I stated my var var a=10, b=5, c=0; c = a/2 c will equal a/2 even if stated 0 before? What if instead of a semi-colon it was just a comma? var a=10, b=5, c=0, c = a/2 would c still = the latest input? thanks for help btw!
I believe in that second example, c would be 5. But the best way to figure out something like this is to just try it and see what it does. JSFiddle is a great website to test JavaScript snippets. And from my testing, yes it is 5. You can see my test [here](https://jsfiddle.net/g72ezkqq/).
open up the console in the browser and find out! :D (no shade)
Another form of this is a promise which has catch method built in. Promises are nice even if it's just to remove try/catch boilerplate. Imo, it's better than some of the examples here because it guarantees resolution and provides a cleaner comprehension chain. &gt; Promise.resolve(JSON.parse(data)) .then(...) .catch(...)
I think you mean `e instanceof` not `e.instanceof`.
Comparing with `/usr/share/dict/words` one can find these somewhat word like words: $ comm -12 available.txt /usr/share/dict/words adz ail brr cud dud dug hag hep hes mys ohs pis sot woe wry 
Hi /u/Jean64, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your work/homework for you.
It's meaningful when discussing performance. For example a newbie might worry about passing around a huge object through a bunch of functions, but saying "don't worry GHC passes all but the smallest objects by reference" is a valid way to make them not worry.
I agree with the other comments that the try/catch is fine for the JSON.parse call, but I completely disagree that it is okay for anything else here. It is an antipattern in javascript to use try/catch for control flow logic, and you are clearly aware of, and can handle, the different exception cases that can occur here. The *only* part that you are unsure about is the attempted parsing of the content. It is incorrect that the point of try/catch is to catch expected errors - it is exactly the opposite. Exceptions are for unexpected or unrecoverable situations, not for normal flow control. If I was reviewing this code, I would end up with something like: function getItemMapFromProps(props) { let defaultValue = []; if (!props) { return defaultValue; } const item = props.cachedItem || props.item; if (!item) { return defaultValue; } let content; try { content = JSON.parse(item.content); } catch (e) { return defaultValue; } if (!content.blocks) { return defaultValue; } return content.blocks.reduce((a,b) =&gt; a+b); } getItemMapFromProps({item: {content:'{"blocks":[1,2,3]}'}})
I'm a big fan of lodash's `.get()` method for accessing nested properties that might throw errors. const obj = {} const prop = _.get(o, 'nested.property') // undefined
Thanks for the reply. So all this section is is a text input and a button that adds whatever is in the input to a list. I should wrap all of that in a form element and the hitting 'enter' thing will work by browser default behavior? 
Can you explain please? 
According to the Scrabble valid 3-letter words list [here](http://www.tnellen.com/ted/scrabble/scrabble_words_3.html), the following three-letter words are all still available: adz ahs ail ait arb auf awn ays bey bod bys cay cit cru cud cum cwm dah dey dso dud dug dzo eas eau ecu edh ehs eik eld elt ern ers euk ewk ewt fah faw feu foh fon foy fra fub fud fum gam gar geu gey gie gju goe gos gub gur hae hag haj hep hes hic hin hoa hoh hox hye ich ita jap jeu jew jiz jor jow kae kam kas kaw keb ked kef kep ket kon kye lav lek lep leu ley lez loy lud lur luz meu mho miz nas noy nur nus nye nys obo oik oon orf ors ouk oup pah pis poa poh poz pud puh qat rhy riz ruc rud sab sed seg sei sez sib sny sot sov suk swy sye tae taw tay tew tum twa uey ugs uli uns urd ure vae vau vly voe vug wae wem wey woe wos wry wud wus wyn xis yex ygo yob yug zea zek zex ziz zuz
Thanks!
What about objects that are unique to `a`? const getId = obj =&gt; obj.id const filterBySet = set =&gt; obj =&gt; !set.has(getId(obj)) const idSet = new Set([...a.map(getId), ...b.map(getId]) const unique = [...a.filter(filterBySet(idSet)), ...b.filter(filterBySet(idSet))]
Well, I understand how it works, but I don’t see why you want to use it. It kind of makes the code unreadable. 
wow, you are right. And then, i would probably use something like Immutable.js with nice helper methods https://facebook.github.io/immutable-js/docs/#/Set/subtract
Lodash to the rescue :)
Martin's *Clean Code* is on your side, he recommends that a function should either try/catch or do work, never both. Functions should do one thing, and the moment you write a try/catch block, that one thing is now exception handling.
I'll throw this, too, out there: Why are you processing data out of the props of a component? That looks like the wrong place to do that thing (low cohesion). Why don't you do the retrieving, parsing and processing data in your data store/layer and handle errors in a more graceful way? Say, having a flag in your state which tells the components the current status (loading/error/ready), and then rendering maybe an error message instead of that empty list, maybe in a separate component.
Yeah, just it's not always possible to use such libraries :)
&gt;not found &gt;cum will be yours. Oh yes, cum will be yours.
That would be great!
brb registering all
God, no. Don't use exceptions for flow control.
Well that is just not true. Redhat is using React for log analyzer and they have it listed under their job postings [One](http://redhat.jobs/waterford-irl/senior-software-engineer-developer-experience/CBA6B23CEB234CC5AA7E814F16D54F04/job/?utm_campaign=NACElink&amp;utm_medium=Education&amp;utm_source=NACElink-DE) [Two](http://redhat.jobs/raleigh-nc/ui-front-end-developer/98727865AD584946AE50BB65C0F68C69/job/?utm_campaign=NACElink&amp;utm_medium=Education&amp;utm_source=NACElink-DE)
What you're looking for is the symmetric difference of two sets, A and B, that is, the set of elements that are in A and B but not both. Here's a naive solution in pseudocode: set A set B for each element in set A: if element is in set B: delete element for each element in set B: if element is in set A: delete element merge set A with set B Basically you're computing the difference of A with respect to B and B with respect to A. This is O(n), so not great for large data sets. But it'll work fine for most smaller sets. Check out the docs for Set on the MDN for how to implement a difference method on a Set object.
Can you elaborate on this please? I haven't read Clean Code.
`pointer-events: none;` makes it so no click events trigger on that element, so you can have a "hidden" element by having .hidden { opacity: 0; pointer-events: none; } This makes it easier to animate things in and out without display none messing things up
You have to get used to it. It's unusual if you're coming from other non-functional languages. It's useful to build callbacks, for instance.
Agreed
Just because there are jobs does not mean the license is accepted by the organization: https://react-etc.net/entry/apache-foundation-bans-use-of-facebook-bsd-patents-licensed-libraries-like-react-js Existing projects are grandfathered in until a certain date. Edit: I'm sorry doc I could have sworn it was redhat's lawyers that said that but the fact I can no longer find that article makes me wonder if I had the company wrong. I tried to find something that backed up my claims on rh.
JS's objects and arrays use a hash map data structure internally. So you probably wouldn't need to implement that data structure. More likely, you might use JavaScript objects to represent graph data structures if your application needs that.
Three.js is probably the best bet. I've used that plenty and have had great success. Very easy to setup and use.
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
Thanks for the comment. Learning it now. 
&gt; and arrays use a dynamically resizing array data structure -ish. JavaScript's arrays are hash maps too. The only difference is the string keys we insert look like numbers.
Be sure to check out /r/threejs. 
Nice! 
For those who aren't using React yet, is React different than React Fiber?
This will find all items in "b" but not in "a". if you want both, you'll have to duplicate it and create an index of each. const aindex = a.reduce((acc, obj) =&gt; { acc[obj.id] = obj; return acc; }, {}); b.filter(obj =&gt; !aindex[obj.id]); edit: This was my original solution to my misunderstanding of your problem, it's the inverse, it finds the ones that are in BOTH arrays. const bindex = b.reduce((acc, obj) =&gt; { acc[obj.id] = obj; return acc; }, {}); const unique = a.filter(obj =&gt; bindex[obj.id]);
I hope they do change it. I work for a Fortune 150 company and our lawyers have said we can't use React due to the license. We don't even work in a space that competes with FB, but the current license still really freaks out lawyers out. 
If you care about performance, you shouldn't do an Object.assign on every step of the loop. `(acc, value) =&gt; { acc[value.id] = value; return acc; }` is more performant.
I don't really can say anything regarding the problem, I just really like the expression 'to go tits up'. Thanks for that.
if you go that way, even reduce is less performant than for loop, bacause function scope.... I only wanted to avoid needless passes through list, which is biggest performance hit
Maybe you needed to think about not reusing records. Maybe the moment you needed that extra field your object was in a different state and needed a different record. If you think like this then records become states in state machines
If you own both sites I’d suggest using a message event bus to talk between your sites.
That is my biggest beef with try blocks. Some things only throw exceptions which seems to encourage using try blocks for flow control.
Yes. Set the button type to submit: &lt;button type="submit"&gt;
I created a quick little test harness, generates 10,000 unique objects like the ones above, puts 33% in "a" only, 33% in "b" only, and 33% in both. Then I ran both our functions on it. They came back with the same results, but mine ran in 3.86ms and yours ran in 17,198ms. I didn't bother to test against a for loop, but your assumption of how that works isn't really right, either. The difference between having the Object.assign and not is HUGE, the difference between using a for loop and a map is not. I'm not trying to beat you up about this, I see this kind of thing all the time and there was a time when those assumptions were correct, they're just not anymore, which is why I brought it up :) Here's the test code if you want to try it, or add in a for loop implementation: const ind = {}; const a = []; const b = []; for(let i = 0; i &lt; 10000; i++) { const id = Math.floor(Math.random() * 100000); const obj = {id, randomvalue: "hello" + id, othervalue: "sup" + id}; const r = Math.floor(Math.random() * 3); if(r === 2 || r === 1) b.push(Object.assign({}, obj)); if(r === 2 || r === 0) a.push(Object.assign({}, obj)); } function me() { console.log(a.length, b.length); console.time("me"); const aindex = a.reduce((acc, obj) =&gt; { acc[obj.id] = obj; return acc; }, {}); const uniques = b.filter(obj =&gt; !aindex[obj.id]); console.timeEnd("me"); console.log(uniques.length); } function you() { console.log(a.length, b.length); console.time("you"); const a_map = a.reduce((acc, value) =&gt; Object.assign({}, acc, {[value.id]: value}), {}); const uniques = b.filter(o =&gt; !!a_map[o.id]) console.timeEnd("you"); console.log(uniques.length); } function loop() { console.time("for loop"); console.timeEnd("for loop"); } me(); you(); 
hmm. Very valid points. Yeah I tried do that with Nginx and reverse proxy (and either did it wrong or it just doesn't work that way). I'll check the code when I get home. Thanks I'll give that a shot!!!
A very short elaboration is that if every function/method you write only does one thing it makes it easier to: * decide when you need to start writing a new function/method (ie. when you start a second concern) * test that function/method (as you know exactly what to test) * maintain that function/method later on (it's much easier to read old code when every function has a single purpose) * etc.
I'm going to save this for later... And probably never read it again. Nice work OP!
Can you elaborate? What's the correct solution there?
Personally, I think it's cleaner, simpler, and more readable to just partially apply as needed. For example: // Ordinary function (not curried) const parse = (baseUrl, type, attachement, size) =&gt; self.attachementUrl(baseUrl, type, attachement, size); Of course, since all we're doing is forwarding the arguments, we could write it like this: // Ordinary function const parse = (...args) =&gt; self.attachementUrl(...args); Then we can partially apply for preview and static: const parsePreview = (...args) =&gt; parse(baseUrl, 'preview', ...args); const parseStatic = (...args) =&gt; parse(baseUrl, 'static', ...args); Sometime later: parsePreview(v, 1800);
Thanks for obliging. I was interested in the concept of segregating exception handling specifically.
It tried to be a language that didn't care about types, but it turns out types matter, and trying to pretend they don't only creates awkward situations like this.
...and they have a 'length' property, and some specialised methods
Yes. I should have said, "from a data structure perspective." The data structure that underlies JavaScript's arrays are hash maps.
You're proposing to use try/catch as a flow-control pattern - don't do this. If not for the reason of ideal code, at least recognize that there is some overhead and lost information when a catch is triggered. Do your normal checks before any try/catch rather than having expected and known error conditions throwing exceptions. Usually, don't use a try/catch if you can't handle the exception in some way. Here, you've decided that it is valid to return an empty array if the data is invalid. That may be fine for you're application; however, you're also skipping a chance to log the failure, which is invaluable for debugging. If you can't handle an exception but want to log it, do so, and then re-throw the exception. Finally, keep as much code as you can outside of the try/catch. E.g., if you were making a database query, you wouldn't put a variable assignment in the try/catch with the query itself. This will prevent you from having to deal with some scope things, but mostly it'll prevent you from catching an error that you shouldn't, and continuing like nothing happened. In many cases, it's more appropriate to let the exception bubble up the stack so the application can handle it (vs. handling it in a library). You might also consider structuring your code like this: myFoo() { let result = []; try { result = JSON.parse(...); } catch(e) { log the exception } return result; }
Again? Has JavaScript ever *not* been a story of the Good, the Bad and the downright Ugly though... I mean, granted its useful and necessary at this point I suppose - but its always been very easy to fuck up royally with poor practices. 
Thank you very much! It did come out a little bit longer than I'd hoped when I started, but I've learnt a ton writing this and hopefully others can, too!
Global isNaN should have been named coercesToNaN. Number.isNaN is what you want almost all the time.
looks like it tries to convert the arguments to number before checking whether it's NaN. `Number('someString')` is `NaN`, hence `isNaN('someString')` returns `true`. It's kind of okay-ish because people usually check for NaN after checking for typoeof number. But as has been mentioned in another comment, [`Number.isNaN`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN) was introduced specially to get rid of such implicitness.
The reason for testing knowledge of things like Binary Trees and Linked Lists is not for those concepts to be used exactly in their textbook format, but to verify that you are familiar with the trade-offs inherent in different manners of digesting and storing data. We rarely store a linked list as a basic data structure, but linear traversal isn't uncommon at all... so knowing what the tradeoffs are with maintaining a link for "next item" with each of your assets, as an ordering method. The same applies for leaf/branch data or complex graphs... the problems you run into might not exactly match a red-black tree, but knowing what the caveats of using different data structures helps your custom structures maintain efficiency with potentially massive datasets.
Yes I think it's lame that JS doesn't have any proper standard collections library. Having objects as a hash table is fine but there are no trees or linked lists etc as far as I know ... There isn't even a standardised "interface" or contract for what a collection should support. If I made a tree myself, what funCtions should I provide, like map, filter, forEach etc. I think this is the next step for JS. 
YouTube live would be easier to get started
because 'props.item' and a tonne of data stemming from it can be undefined, i'd rather have all the flow control logic in a single function rather than in the multiple places this function is called from. The codebase for this project is far from perfect and compromises had to be made 
I am already streaming on youtube. The link is in the website http://annoyme.us
The correct solution would be to explicitly handle the error cases you are interested in with `if(){}` etc., and handle the *unexpected* errors with try.
Oh cool, I'll check it out.
Anytime you have 2+ devs you will have 3+ opinions. 
Pluralsight's really dropping the ball lately. We used to use them for the great dotnet courses but they're even slow to get those out now. Our team is in the process of moving to Udemy. 
[removed]
&gt; There isn't even a standardised "interface" or contract for what a collection should support. If I made a tree myself, what funCtions should I provide, like map, filter, forEach etc. I think this is the next step for JS. I think C++ got this part right. Each data structure container supports an iterator interface, and then algorithms like map, filter, forEach are ordinary functions, not tied to any particular data structure container, and those algorithm functions take as input a pair of iterators. vector&lt;string&gt; a_array_container {"a", "b", "c"}; list&lt;string&gt; a_linked_list_container {"a", "b", "c"}; set&lt;string&gt; a_tree_container {"a", "b", "c"}; unordered_set&lt;string&gt; a_hash_table_container {"a", "b", "c"}; // for_each and other algorithms operate on iterators, not knowing and not caring what the underlying container is for_each(a_array_container.begin(), a_array_container.end(), [] (auto value) { cout &lt;&lt; value; }); for_each(a_linked_list_container.begin(), a_linked_list_container.end(), [] (auto value) { cout &lt;&lt; value; }); for_each(a_tree_container.begin(), a_tree_container.end(), [] (auto value) { cout &lt;&lt; value; }); for_each(a_hash_table_container.begin(), a_hash_table_container.end(), [] (auto value) { cout &lt;&lt; value; }); 
Well, if you buy all that stuff about a function/method only doing one thing, and if you buy that error handling is a conceptual "thing", then it naturally follows that a function which does error handling, ie. does one thing already, shouldn't do anything else.
It seems you fundamentally disagree with try catch being used exactly for what they are meant for.
Yes agreed the C++ approach is really nice :)
Not really. I completely support using try/catch when you know something may possibly throw and you have no way to counteract that. JSON.parse is a perfect example, if you can't trust the string to be valid json, there is no error callback or other way to stop it from throwing an exception. Similarly if a library Throws instead of using an error callback. However, I *very much* object to it being used to write syntactically bad code. Accessing a nested property on an undeclared object property is always invalid and will 100% consistently throw. For example: const obj = {}; console.log(obj.prop.childProp); //always throws It is bad practice to "avoid" this with try-catch because it is an avoidable and known exception. Instead, you should write defensively and handle the error-case without ever having an exception thrown. 
I've been playing around with service workers and so far it's really cool! there are a few gotchas though. For me it was aggressively caching everything to the point where it wouldn't ever fetch an updated copy from the network. only way to fix this was to go in and delete the service worker in dev tools. 
I don't understand, why do you need the language to tell you what functions you should or shouldn't provide for a data structure? You provide what you need. I agree that functions to cycle through objects were sorely needed, we are finally getting them (Object.entries). We have maps and sets with iterators, &gt; there are no trees or linked lists etc as far as I know ... that was the point of my question - why would you need them in JS? what problem can you not solve with standard JS data structures?
It depends what you mean by 'these 2 basic tools'. In Node, most people will use a framework like Express or KOA, Passport for authentication, and a package that smooths over talking to your DB. Plus any number of npm packages to make your life easier. A starter Angular app is going to have dozens of dependencies.
I don't know if your site (script.ninja) isn't displaying correctly on mobile, but you haven't made any points as to why promises are not good. I just don't really understand what your argument is. Give an example as to how you would handle a situation where you have to make three queries, but the third requires results from the first and second queries, and any of the queries could fail. In promises: ``` var getUser = UserRepo.getUserById(0); var getUserPosts = getUser.then(u =&gt; u.posts); var getTopTrendingHashtag = HashtagRepo.top(); var getUserPostsWithHashtag = Promise.all([getUserPosts, getTopTrendingHashtag]) .then(([posts, hashTag]) =&gt; posts.filter(p =&gt; p.tags.indexOf(hashTag) === -1)); getUserPostsWithHashtag.then(posts =&gt; console.log(posts)).catch(e =&gt; console.warn(e)); ``` I apologize for any simple mistakes I'm on mobile. What would an example be with your method? 
Why would you do that? It's already clear that `attachmentUrl` takes four arguments, and it gives you the names of those arguments. Now you've hidden both of those behind `...args` for what reason? This is not what varargs are for.
&gt; Why would you do that? Less repetition. At the cost of a level of indirection to discover the parameters, you're right.
Can't wait to build dud.js
The parent page I own but the iframe page I only have access to the Header and the CSS. I enabled the CORS on the Parent page. 
I own the parent page but the iframe page I only have access to the Header and CSS. I gather I should be able to add a message event bus in the header?
You have made an incorrect assumption about what `isNaN()` means. The concept of "not a number" is an IEEE 754 notion, and it means any bit pattern that is invalid according to the spec. JavaScript kind-of co-opted that, but the reason `isNaN(false)` is `false` stems from the mistake of having the function first coerce its argument to a numeric value. Do that with `false` and you get `0`, a perfectly good number. As somebody else noted, what you probably want is the more modern `Number.isNaN()`, which will *still* tell you that `false` is not a `NaN` because *it isn't* &amp;mdash; it's the boolean value `false`. 
I'll just leave this here: [https://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original](https://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original)
yes, it cares so little about types that it decided to include dynamic types and operators like`typeof` from the first version. it never tried to pretend types don't matter. it's a typed language, and JS's types were fine for about 15 years, but now that strongly typed languages are fashionable (again), people try to act like js isn't typed or js didn't have types until recently.
Yeah, you should be using `typeof whatever !== 'number'`, not `isNaN`. `isNaN` is only for numbers, to check if the number is a `NaN` (`NaN` being a special number value for results that don't make sense in the context of real numbers, like `Math.sqrt(-1)`). Next time read the documentation!
And how did you fix it? I had the same issue in react few months ago and never bothered with it since
The reasons why I love currying so much and lean on it heavily in my codebases are the ability to create closures and the natural tendency when using them to build really, really small pieces that you compose into larger ones. Closures are the foundation of currying and to me are really where they shine. For instance, let's suppose that we want to grab the `name` property from a list of friends: const prop = k =&gt; o =&gt; o[k]; const map = fn =&gt; arr =&gt; arr.map(fn); const getName = prop('name'); const getNames = map(getName); const list = [...]; const names = getNames(list); It's the standard `let me show you how to use map` example that every tutorial/example uses, I know. But I want to point out the values that are being passed around here and why them being curried is helpful to me. `map` and `prop` are `curried functions`: functions that take multiple args but take them one at a time. We assign the value of the first function to a new value and now those new values have some magic closure that they carry around. This ability to enclose information that is known at one point in time and then let another worker fill in the gaps when they need to was game changing for me. I could write a generic event handler that all of my inputs could use: I just pass in the key at one point ( when assigning it ) and then the value at another ( when I call it ), and my state handler assigns the value at that key: handleChange = k =&gt; v =&gt; this.setState({ [k]: v }) Now for saying that it makes the code `hard to read`, I definitely agree with you there. Going from not understanding what `reduce` or `zip` or `complement` to being able to think in these terms took me some time. But I would say the same for any new codebase. It took me a solid 2-4wks to become proficient on my current team's codebase ( *some might argue longer...* ). I believe that is just the cost of entering an already built system: You have to learn a new API. But I think that with `functional programming` and the terms that seem common ( the methods in `ramda` or `lodash/fp` ), once you understand how they work, you can go from codebase to codebase, project to project, and instantly understand *what* is going on without needing to know the *how*. Which brings this rant to its final point: reusability. All of the functions above are one-liners. Really, really small functions that I can test nearly all possible outcomes of input -&gt; output. Now I know 100%, without a doubt that this function works as expected. Once I know that, I can compose these things without worried that the lego pieces will break. For instance, let's suppose that instead of the `list` being a variable, it is a key on some object that we get and we want to use currying and all the cool kid stuff: /* map and prop from above */ const compose = (...fns) =&gt; start =&gt; fns.reduceRight((state, fn) =&gt; fn(state), start); const data = { list: [...] } const getNamesFromAPIDataType = compose( map(prop('name')), prop('list') ); fetch('/api') .then(getNamesFromAPIDataType) .then(handleChange('friends')); So while you did have to learn what `prop` and `map` mean, we can hide those names and instead build a very descriptive API for the consumers of our code.
I'm gonna save it and read it! Use pocket to save to phone and read on commute
&gt; But my answer to your question would be about &gt;50$/day Based on what? That seems extremely high.
Seriously woe.js will be the framework to end all frameworks
Over the years I was more than 'once burned twice shy' by a lot of specialized environments (particularly proprietary ones). I invested a lot of time in learning and developing stuff in them, and then they were abandoned. So now I tend to stick closely with widely-used, close-to-native-as-possible stuff, and keep my data as portable as possible ... all text. Look like native JS will be around as long as I'll need it !
Motts isn't talking about internally. He's talking about how Javascript presents itself to a programmer. Do you want to multiply a string that's numeric digits with a real number? No problem says Javascript let me just implicitly convert that for you. Because Javascript was supposed to allow nonprogrammers to write code and they shouldn't have to learn about "low level" stuff like types. But this approach to trying to abstract types away from a programmer just causes more headaches than its worth. Because edge cases exist like the + operator also being overloaded for string concatenation. Trying to make a type system that is automatic and invisible only works up to a point. Then it fails spectacularly.
bum and tit are gone. I'm out.
Thanks for posting. Love taking this every year.
Yes it’s just a script tag on both pages. 
.... Sooo how do I quickly and properly test for a number. It's what we are trying to do. No one ever wants to test if false is "technically" a number....
Well you can use `typeof`, or you can use the `Number()` constructor and an explicit call to `.toString()`. So, `Number(false.toString())` is definitely `NaN`, so you can pass the result of that to `isNaN()` safely. In my experience, if you really find yourself doing this a lot, there may be a couple steps back you need to take and figure out *why* you're having to do this. 
There are also js_of_ocaml and Reason, though I'm not sure how mature the latter is.
```const uniques = [...a, ...b].reduce((a, c, i, arr) =&gt; { if (arr.filter(x =&gt; x.id === c.id).length === 1){ a.push(c) } return a }, [])```
TypeScript's type checking isn't optional if `no-implicit-any` is enabled.
I wrote a thing about Scala.js [here](http://www.lihaoyi.com/post/FromfirstprinciplesWhyIbetonScalajs.html). I'm clearly biased, so I won't say too many words, but read through and see what you think.
Wow been another year already, thanks op it's always fun.
Definitely _not_ GWT. It's Java, it's painful, there's very little community that I can see, the ecosystem has stagnated, and the future is in limbo waiting for a hypothetical future GWT 3.0 compiler/release that will also throw out a bunch of existing infrastructure like GWT-RPC. Source: wrote a GWT app, and ready to rip it out and replace it with React+Redux.
If you're turned off by TypeScript's only-partial optional support via `no-implicit-any`, try taking a look at [monapt](https://github.com/jiaweihli/monapt).
Thanks op it's always long.
Just for fun: https://www.destroyallsoftware.com/talks/wat 
You could have jiz
Just took it, it's always nice to have that kind of overview of our industry. I'm a lot happier and optimistic than a couple years ago !
I've been doing a thing with scala.js and [scalajs-react](https://github.com/japgolly/scalajs-react), loving it. The scala language itself is great, its expressive enough for some great dsls to come out of it, like the react one, and scalacss. Its also been a good opportunity for me to learn to write more fp-heavy code (using cats) while still being able to opt out when I can't figure out how to do something cleanly in a pure way. ~~My only complaint is that compile times are a little on the long side, at least on my box - around 60s to output js in fast mode.~~ **Edit** turns out the long compiles are only when operating within the SBT shell of intellij... for some reason. When compiling from a normal terminal, it takes a much more reasonable 10s.
Well, wow, nothing beats experiment and verification of assumptions, so thanks :) 
Been doing this for a while, too. Probably the best lifestyle change I've made in the past year.
As far as I can tell, the browser caches up to 5MB or so, so eventually older resouces get removed. Aggresive caching is not the best way to deal with progressive web apps, nor is the simplistic `activate` handler that most tutorials (mine included) show you, but it's a starting point. In the real world, a progressive web app would cache *some* resouces and remove some older keys from the cache. Unfortunately, a dummy app like the one I built or even a small-scale app usually goes with aggressive caching and quick-n-dirty handlers, as it's the easy thing to do.
you could also try this: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite *you'll need a polyfill for IE / older browser support. the MDN page has an implementation available. 
Thanks for all for your responses! This seems to do the trick. b.filter(o =&gt; !a.find(o2 =&gt; o.id === o2.id)) Easier than I thought... Mixing the filter and find is clever, I tried to do two for loops or something stupid.
damn, thats a nice example =)
 var isNumeric = function(n) { return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n); } It's a bit old hat but it correctly detects integers, floats, hexadecimal and octal numeric values, and it can detect if strings are numeric
https://irc.now.sh
Yup, 5mb is the cache limit. https://stackoverflow.com/questions/35242869/what-is-the-storage-limit-for-a-service-worker
The API should be the same; it should be backwards compatible. What they're trying to do is change their diffing system, and try to chunk manipulations in multiple frames. It should make React's core faster.
Not this one, but other lodash functions didn't work...
Does anyone know if local assets such as the `.html`, `.css` and `.js` files take priority over external resources (such as embedded images etc.), so that they don't get deleted after the limit is reached? Is there any way to indicate a `dontdelete` sort-of-thing for a resource in a web app's cache? 
Sure thing. If you're curious why, it's because Object assign makes a new Object instance, doing searches in a loop without an index is bad, like you noted originally, but creating and destroying objects, even small ones is also pretty bad. Causes memory assigns, copies references, and has to garbage collect more often.
As a data structure a map is almost identical to an object so it doesn't add much. A set is similar too. I realise now I didn't really answer your question because it reminded me of this thing which annoys me in JS without saying properly why, sorry for that. Basically different data structures have different properties which suits them to different use cases. None of the structures I know of is intrinsically sorted, so I can't put 100 student objects into something and immediately know who comes first and who comes last in alphabetical order. I know there is array.sort but you have to resort every time you add something. A tree or similar would be good for that. Once I needed a structure similar to an array but I needed to be able to add and remove elements easily. In JS this is extremely slow with arrays as the whole thing needs to be re arranged to prevent gaps. This could be a good use case for a linked list or a C++ deque. I had to write a custom data structure. The language doesn't need to tell me what functions to provide on a structure, the language should provide features so that we as a community can implement an agreed and reusable set of functionality. Code reuse is the goal. If I implement a better data structure, other people can only use it if it plugs into their code. By agreeing on map, filter, reduce etc data structures can be swapped in and out as requirements change. If at first you just need to know, who is in a list of students, the a map is fine. But when you need sorting, and you plug in Joe Blogs tree implementation that you found in npm, it will work a lot better if your existing map reduce etc code carries on working. This is a core idea in other languages from C++ to C# to Java etc. 
Oh man, what an arrogant post. You're just wrong.
So there are a couple of small overheads that you will incur if you do this; * Some JS engines won't optimize your code * The error object and backtrace etc. will be created, which they wouldn't if you checked for stuff rather than just allowing your code to fall over. Despite this, I don't think there is anything wrong with what you are doing. Readable code always wins out over tiny performance gains and it sounds to me like you've taken a pragmatic approach. What you want to avoid is "swallowing" errors needlessly; https://en.m.wikipedia.org/wiki/Error_hiding?wprov=sfla1 So before tucking your code in I would maybe either log something to the console or put a comment in to indicate to future explorers why you've done what you've done. Also maybe create a backlog ticket for a rainy day to come back and handle it properly. I don't know what "properly" is, I just mean something to differentiate an error from just having parsed an empty array. Tldr; yeah you should handle it properly but don't worry about it. 
**Error hiding** Error hiding is an anti-pattern in computer programming. The programmer hides error messages by overriding them with exception handling. As a result of this the root error message is hidden from the user (hence 'error hiding') and so they will not be told what the actual error is. Error hiding is a bane of support engineers' jobs as it often delays the resolution of the problem by hiding information needed to identify what is going wrong. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Non-Mobile link: https://en.wikipedia.org/wiki/Error_hiding?wprov=sfla1 *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^92553
visit https://www.webspeckle.com
flow?
I'm sorry, /r/naturalscriptlang/ reads like you're having a mental breakdown. Do you have any stuff you can show? 
Instead of `location.href`, use `window.open('http://google.com')`; See more: https://developer.mozilla.org/en-US/docs/Web/API/Window/open
Never heard of this. Love the idea.
It's a bad idea from the start to use a human language for programming. Programming languages benefit from strict syntactical rules, absence of ambiguity, restricted grammar and vocabulary, monosemy, lack of redundancy, etc. Natural languages have everything but those qualities. It's an awesome challenge, but I feel it's a huge waste of time. It won't help people write better code.
Mongo is most used for **prototyping** because it doesn't force you into a set schema. A lot of ex-backbone.js users prefer Bookshelf.js over Sequelize because of the familiar API, but I think Sequelize is probably the most used ORM out of the two (I have not researched this, I'm speaking from experience of being involved in many Node.js code bases - so take this with a grain of salt). If going the SQL route, I think it's far better to not use an ORM, instead use a middle-ground between raw SQL and an ORM - like Knex.js. There's really no need for an ORM, as it complicates things. If your server offers middleware (express / hapi / koa all do) then you can instead use those for validation logic and transforming data before writing it to the DB. If you do that then there is very little benefit that an ORM would provide you. As for whether to go MongoDB or Relational Database - I urge you to not think about "what is most used" but rather "what are my needs". For instance, MongoDB has built-in sharding, which makes it easier to scale across servers. But it also lacks transactions, which means if you're doing financial data or any kind of work that involves transferring money, where all the queries involved should fail if at least one of them fails, then you should be using an ACID-compliant database, which MongoDB isn't. If storing heirarchical data, where let's say you have a "Module" model, and your "Module" model can have many child "Module" models, each of which can have their own child "Module" models, then you should be using a graph database. You can absolutely model this kind of data in MongoDB and SQL (especially postgres with it's recursive CTEs) but actually querying it is a pain in the ass, but it's a delight in a graph db.
Awesome !
Redux is extremely similar to Elm principles, Scala is over-engineered most of the times (a contractor once did a simple static server generator in Scala that took 40 min just to install dependencies, not to mention the development pain compared to JS with livereload and immediate response) If you want to keep a FP approach just use Rambda or Rx.js extensively, they are both great (see redux-observable) Just learn JS + Typescript or Flow, no excuses, both can be set as mandatory (though you will lose part of the reason why JS is great by forcing types on everything) 
Hopefully we find out people are not using semi colons ;)
I knew it was pointless before clicking, and then I clicked and saw the first item in the list: MooTools 
100% agree. 
There's currently a [stage 1 proposal](https://github.com/claudepache/es-optional-chaining) for an optional chaining/null propogation operator. The syntax looks something like: var street = user.address?.street Hopefully that makes it into the standard soon.
Most people do, I'm afraid, and rightly so.
Why do you not want people to use semicolons?
nah they aint
&gt; Thanks for posting. Love taking this every. I think you accidentally a word :p
https://standardjs.com/
well they aint needed really see https://standardjs.com/
Yeah I know but it still seems like the best practice to me.
but its not thats the point... https://www.youtube.com/watch?v=gsfbh17Ax9I
...and?
Roh and Dah are available. Shame about Fus.
FYI, the iterators for both sets and maps are guaranteed to return entries in insertion order
It isn't if you have a code formatter like prettier. There ARE some hard to catch issues with no semicolons, but prettier will automatically insert all necessary semicolons for you. ;)
Get the help you need mate. Y no me refiero a google ni a microsoft, sino a un psicólogo.
Great stuff!
You could consider Dart also. Though I have no clue if its supported anymore
thanks both of you.
heirarchical data will do well in Mongo if every node in the document stores the path to the top. You can then query based on the path that every point in the hierarchy has. This can scale better than recursion using a CTE as you will very quickly hit the limit of the number of levels you can go down. Mongoose as an ODM works well if your main unit of update is a well-defined aggregate
If you don't need a whole lot of interrop with existing JS, Elm is absolutely fantastic. Virtually never getting a runtime error is a beautiful thing, and you get to see what Redux is "meant to be", so to speak. If you do need interop, PureScript + Pux is essentially the same thing, but with better support for interacting with the javascript world, at the cost of not being quite as sound, and not as well known. ReasonML is probably going to be more "mainstream" at the pace its going through, and might be a better choice. 
I have a feeling they're unintentionally creating a selection bias by filtering out people who don't have the time or energy to fill out such a lengthy form. Maybe a compromise would be to accept partial responses?
http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding http://inimino.org/~inimino/blog/javascript_semicolons https://www.youtube.com/watch?v=gsfbh17Ax9I
I would use let content; let content_json; if (typeof props === 'object' &amp;&amp; props !== null){ if ( 'item' in props &amp;&amp; typeof props.item === 'object' &amp;&amp; props.item !== null){ if ('content' in props.item){ content = props.item.content // try catch content_json = json.parse(content) here. }else { //err }else{ //err }else{ // error props not object } Im on mobile so couldn't type perfectly. 
Ever since prettier took over formatting (in our projects) and allows the option to not have them, i don't feel the need to have them around, it's just more visual noise. Without prettier i would use them out of muscle memory and to avoid edge cases.
That kind of nesting is the exact thing I would do anything to avoid, including using a try catch block as a poor mans way of implementing flow control 
&gt; In the end, we want, in the future, to talk with machines. Natural language is ambiguous. Machines need precise instructions. What you want is a controlled language, a very small subset of english. In the end it will read like non-sensical, bizarre sentences. ~~If you want to convince me,~~ could you show me what these statements become in NaturalScript ? ^*Not ^sure ^I'll ^be ^convinced const randomArrayElement = (arr) =&gt; arr[Math.floor(Math.random()*arr.length)]; const x = randomArrayElement([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); const y = (x &gt; 0 &amp;&amp; x &lt; 11);
I. Don't. Care. Semicolons are here to stay.
Prettier didn't "take over" formatting... I'll stick to the airbnb eslint set, thank you very much
The time it took you to whinge about it here you could have filled in half the survey... If you want a comprehensive survey then you have to invest some time into it. There is no such thing as a free lunch. #freeloader
Hipster
&gt; if every node in the document stores the path to the top. see, a graph db doesn't force you to do this. I did say you can use mongo to model this sort of relationship, but its far better to use the right tool for the job. a tree structure is a graph. it has roots in graph theory. so use a graph db and save yourself the headache.
Thanks, I've edited my comment to sound like less of a dick
I think this is a great style guide to start from https://github.com/ryanmcdermott/clean-code-javascript 
...which means by now you could have just filled in the WHOLE survey instead of complaining :-)
Its always good to know why something didn't work rather than just knowing it didn't. 
why comment then ;)
Can't let a hipster have the last word
Scala.js is working well for me.
I thought dart was not strongly typed, is it?
Great tips, and a perfect rip-off of one of my old articles - https://ihatetomatoes.net/8-tips-become-better-front-end-developer/
Depends on use case really. 
You make a valid point about the graphs native structure. In my experience of dealing with real world data (having to visualize hierarchical data at speed) you always need to precompute values for faster retrieval. In this day and age, it is possible we could both have a valid point. Architectural approaches such as CQRS allow for the usage of separate data models for reading and writing. If using a graph based model one would still have to recurse up or down the model and this may not scale well for reads but is definitely desirable if altering the hierarchy.
Oh I didn't know that! Will surely try it. But how would this work with dependencies?
I every do too!
I read this before posting here, actually! Didn't know you'd comment on my post, haha :) Anyway your post is really good, scala.js seems to the best option for me as of now. Though if I get more time I might try out reason and purescript as well. By the way, what is your opinion on reason?
Both the frameworks are ideal for creating additional user elements. But neither ReactJS nor VueJS can be called the full-scale framework. I recommend to try Vue.js. It is one of the fastest-growing libraries currently and is not only a utilitarian but also a quick and easy tool for applications and interfaces development. In this blog, I found the most detailed information: https://erminesoft.com/reactjs-or-vuejs-which-is-best-for-your-project/
Lol, as with most things in tech. :)
It has a strong mode apparently
So on a scale of cats, less is better right? We are not old spinsters, we want less cats.
1) never use `isNaN`, always use `Number.isNaN`; 2) never use `typeof` etc, always use the Miller Device `Object.prototype.toString.call( x )` for reliable, sensible results; 3) `Object.prototype.toString.call( Math.sqrt( -1 ) )` will give you `'[object Number]'`, as will `Object.prototype.toString.call( 1 / 0 ); in that case, check for `x === Infinity`, `x === -Infinity` (actually, those checks should be cheap to execute, so do them before the call); 4) `NaN` is the only value with the surprising (and logically impossible) property that it doesn't equal itself (!!) and isn't even identical to itself (!!!), so you can always write `x !== x` to get `true` for `NaN` and `false` for everything else. Best to wrap up all that stuff in a separate type checking module to avoid spilling half-baked, wordy, subtly bug-ridden one-off solutions all over your code.
Once you use it that is, taking over format is its sole purpose. Prettier defines the outlook of my source code and i am perfectly fine with it, also took a major burden off my shoulders. And since it does that, commas are optional without further caretaking. If you don't use it, that's great, who said you should?
Would you like to share the repository of your project ?
External libraries that don't have a TypeScript definition are assumed to be `any` and `no-implicit-any` doesn't apply to them. Personally I feel like it's not really a problem though, most libraries have a definition already and if they don't it's pretty straight forward to just write one.
Both the frameworks are ideal for creating additional user elements. But neither ReactJS nor VueJS can be called the full-scale framework. I recommend to try Vue.js. It is one of the fastest-growing libraries currently and is not only a utilitarian but also a quick and easy tool for applications and interfaces development. In this blog, I found the most detailed information: https://erminesoft.com/reactjs-or-vuejs-which-is-best-for-your-project/
Be sure to describe your thought process as much as your solution. When I interview someone I'm less interested in whether the solution is correct and more interested in how they're thinking about the problem. If you get nervous, keep in mind that the interviewer wants you to succeed. Interviewing sucks because it takes time away from your work and you already are overbooked (otherwise there'd be no need to hire) and so they want you to get the job.
If you use a build tool it's pretty unnecessary 