Thanks for your answer, gotta try this one again. I encountered this the other day but didn't completely understand the dependencies object how should I specify the version. 
Have to look into that as well.
https://insomnia.rest/
Oy! try this one on for scale. const curry = ( fn, arity = fn.length, next = (...args) =&gt; (...more) =&gt; ((more.length + args.length) &gt;= arity ? fn : next)(...args.concat(more)) ) =&gt; next() 
its faster and being used by tons of people, so not having it appear in JS connections is bizzare.
Does your job require you reinstall a project over and over again? Because if not then it's not much of a difference (saving a minute or two during the day) especially given those benchmarks: https://github.com/pnpm/node-package-manager-benchmark
If it takes no time to install at all and its faster then why not, it's an advantage. 
...and yet, neither of those libraries are listed anywhere in the survey. I think my original comment stands. Aside from the size, moment in my eyes it is functionally perfect and not in need of updates. Even then, last commit is 3 days ago so I wouldn't exactly say it's not actively developed.
It has to be installed separately. On your machine, on CI, everywhere. It doesn't come for free.
What's the definition of a "built-in" for an enterprise application?
Apparently it's not. :)
oh yea thanks i got it now. 
The framework/salary association is really interesting. Like why ember?
That's good to hear
I'm a student and get WebStorm for free.... Still prefer VS Code..
A lot of it seems to follow the main JS buzzwords, so while people say one thing they're actually talking about another (ES6 vs ES7)
2 things: 1 - you don't NEED to attach to your express server, if you don't want to, look into socket.io docs, you can set up to listen on a different port, but if you decide to go along with this then 2 - you can add it to your req or res object in a middleware ``` const io = require('socket.io')(server); app.use((req, res, next)=&gt;{ res.locals['socketio'] = io; next(); }); // Later in a different route router.get('/potato', (req, res, next)=&gt;{ const io = res.locals['socketio'] }); ``` 
I think some of the author's choices are ... suspect. For instance, the State Management section ("State Management regroups all solutions used to manage data, both on client and server.") makes no sense. It compares GraphQL (a means of communicating data between the client and server) against Redux (a 100% client-side data store), when no one in the history of web development has ever said "should I use GraphQL or Redux?" Then on top of that they also compare GraphQL to Apollo ... a GraphQL client. At least say "GraphQL Reference Implementation" or something ...
Probably because most who are using it are core contributers, thus they get high consultants fees in addition to the needed status and clout to launch a framework that isn't a personal project. 
Probably things like service injection that make it simpler to set up tests with mocks for TDD.
I looked into reason, and seeing that it's a OCaml to JS makes sense. Seems interesting 
My guess is most Ember devs are actually Rails consultants. And given the fact Ember is mostly black box magic, it has an amazing ROI in terms of repeat consultation fees
As someone who is just getting familiar with application building and using MEAN stack, there are a lot of things going on in this that I just flat-out do not understand. Exciting, and terrifying.
moment is not unmutable, all the locales are included with no possibility to cherry pick and the 2 core members moved on to make a tc39 proposition. To me moment is the 'underscore' to the new lodash kids on the block, namely luxon (an actual branch of moment, that says a lot) and date-fns.
Happens every year...is normal
What kind of jobs using vue pay that?
Will look at it. Thank you.
please access property with bracket notation to avoid typescript errors.
Well, they basically burned down their own house with v2
Yes, that’s true. I was careful not to say that _all_ of the features could be. However, most of them can: - Destructuring - Classes - Arrow functions - Object literal shorthand - Modules The above list is probably not exhaustive but the point stands that ES6 (and CoffeeScript) are useful even if they’re largely syntactic sugar. 
Cool, it took a while to get how it works, but I've learned 4 new things, thanks!
I recently switched to ramda, which covers pretty much everything lodash does, except its all functional. It's also easy to set up with tree-shaking, via babel-plugin-ramda, which I found easier than installing specific lodash functions. Lodash functions also seemed to weigh in a bit heavier than their ramda counterparts (_.merge for example, imports quite a lot of code, i found R.mergeDeepRight to be a nice alternative).
OOC, is it a contract gig or full time? Working with a team, or by yourself? I've switched almost all front end project at work to Vue, but it was pretty easy because I'm the one to make the call. I'm eagerly watching and waiting for other, bigger teams to embrace Vue, both because I love it as a framework and I'd like to hear that there will be plenty opportunities for me to work with other teams using Vue :)
What about diagonal scalability?
My initial thought is to send an XMLHttpRequest GET request to the URL and then log the results. Unfortunately, doing this from another domain runs into CORS issues. Are you trying to do this from within a webpage or can you do this outside the browser? (Node with a headless browser, for example)
 fetch('https://www.reddit.com/r/javascript').then(r =&gt; r.text().then(r =&gt; console.log(r)))
I don't want to give info away but it's a full time gig, I'm being hired as an employee not a contractor. Junior front end engineer. I'm coming from React personally but vue doesn't seem bad. I was able to figure out a lot of it within a few hours of tinkering. During the interview one of the coding challenges was to build a certain type of component in any way possible, with a choice of vanilla js or any framework, or even a whiteboard; I was scatterbrained so I ended up making the thing half jsx half vue directives 
What exactly is it that you like about VSC that WS does not offer?
It autocompletes and creates all unimplemented functions when you `implement` an interface to a class.
I mean Ember is no more of a black box than Angular or any other complete application framework. It's pretty well documented. The only reason React has "transparency" is because you write everything yourself. 
I don't think so. It's too early to say anything. I just wish people would stop being whiney bitches and complain about everything just because they heard it's cool to complain about it. Angular has its issues, but so does React. A view library that can't decide for itself how to style component. Wow. Amazing. Very views, much library.
Following JS trends is all about being butthurt.
I use angular. My complaint is that they made the popular thing obsolete and started over. It's even worse than python 2 to 3. When will people learn from history that breaking backward compatibility makes adoption painfully slow.
Interesting, I haven't heard of it. I'll check it out. Thanks!
But with this second approach how I would be able to emit and send data from db to client?
Looks like vue.js is doing great marketing (even if just word-of-mouth). Almost half the participants say: "I've HEARD of it, and WOULD like to learn it". Meanwhile, react.js has over half the participants saying: "I've USED it before, and WOULD use it again".
Tried running that exact line of code and it didn't return anything :/ 
At the moment I'm doing this in a random console (using codepen.io)
&gt; Maybe moving this to /r/typescript would be more appropriate. There are many languages that can compile to javascript and many have their own subs.
But in angular's case supporting backwards compatibility would have hamstringed their abilities to actually use the features that make angular angular. If anything I think it was a marketing mistake to reuse the angular name. But it was the right technical decision to start over with an entirely new code base with fundamentally different architecture.
Isn’t that supposed to be ESnext or is that just another marketing term too?
that's awesome, good luck! i think you'll find that there is nothing you can do in React that can't be done with vue, even if you have to use a different approach. 
It uses his system memory more effectively.
[This SO question](https://stackoverflow.com/questions/37559610/socket-io-emit-on-express-route/37560779) may help you.
Different prototypes with different props and functions 
An empty === an empty array, I’m not sure where you were going with that 
I'm looking for feedback on a web app I build for designing notifications. It allows you to design and build emails, push and text notifications in your browser, using mustache templates and sass/scss. I'm hoping to make it more generic and usable for others, but it's already proven to be quite useful for internal use at my company. It runs locally to allow for access to the filesystem, so you do have to install it. Feedback would be much appreciated! https://github.com/nickforddesign/notifire
Compare to socketcluster, what's the difference?
This all the way. The only reason people view it that way is because they tried to recycle the name. The only fail I see in Angular is the naming confusion. The more they try to fix it, the worse it get. Then again, sometimes I feel like people are stupid. They legit keep naming it "Angular 2/4/5". In a year, they'll dub it "Angular 2/4/5/6/7"? When will they learn? What Angular community can do to help is to try to correct everyone who misuses the name and explain it. The more explanations online the more chances someone will see it somewhere. It's. Just. Angular. The other one is AngularJS. It's not perfect, but c'mon it's not _that_ confusing or difficult to get it.
At this point the biggest issue is that there is a very vocal contingent of the Javascript community that hates angular and basically trolls any post about it they come across. But I'm not sure this is really a problem for the angular community to fix. It's more a problem that Google themselves should be fixing. They should have blog posts and the like written by the angular team members that get submitted to places like /r/Javascript and /r/Webdev. Usually the only time I see pieces like that they are posted to /r/angular or /r/angular2; preaching to the choir.
WAI-ARIA is there to add extra semantics to the markup, and helps people using assistive tech (screenreader etc). But when it comes to semantic markup, well, it helps us all. ;) Some disabilities are temporary, e.g your arm is broken, eye-problems etc. In these cases it would kinda suck if you could surf the web. In Norway this is actually mandatory (§14 in the Anti-Discrimination and Accessibility Act). And as such we kinda have to care about this stuff. :) It is basically akin to WCAG AA, with some additional rules. https://uu.difi.no/om-oss/english 
Thanks for the link but that does not seem to work either. When I emit event on client then on the server I am not receiving that event and also no errors there.
I had absoloutly no idea about this. Sorry if my comment came off as insensitive.
You have it right with the charts example. Another might be that every Unit has takeDamage and dealDamage and moveNext, and you have dozens of types of units. In general when you have to do the same action across many slightly different things is the time for polymorphism. But practically, they need to be in the same list, and you iterate through the list to call that action you know is shared. It almost never pans out that the charts are in a single list, so you will probably not need polymorphism with them. It would pan out like that with a list of Units.
polymorphism is essentially the idea that the sibling descendants of a base class will all have the same interface but varying implementations. 
Yeah I get this feeling too. I work in Angular daily and it's great. I can understand the steepness of the learning curve for Angular, but frankly it's no longer in RC, there's a great CLI for it now. I think a lot of people that dismissed it need to take another look at the platform now that it has matured a bit. That said, Vue is great too. Between the two, I've never found an excuse to use React. 
Heey, no worries. Just "pay it forwards" and over time we'll make the web a better place for everyone. 
Surveys aren't the most trustworthy and can easily be skewed through social media impact and otherwise. If you look at real world statistics Angular isn't in such a bad place: http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core We're using the "big three" at work (React, Angular, Vue), but i wouldn't pick Angular personally any longer (or any template oriented framework). To me they seem to carelessly pander to the web with completely complacency without really knowing where they're going themselves. 
Doing this in the Chrome developer console gives a CORS error, which makes perfect sense. Browsers generally don't allow pages to request things from other domains. The code does work in node.js, though. I did an `npm install node-fetch` first, and then in node did `const fetch = require('node-fetch')`. With that setup in place, the line above works perfectly.
How is TS an "Object Oriented language" if JS is a "Hybrid language"? Valid JS is also valid TS. Functional programming in TS works exactly as it does in JS.
Wow I was going to comment "What about diagonal?". You bet me too it. Bastard! :)
where are you located?
Your understanding is good. `let` declarations are scoped to whatever block you define them in. If you replaced that `let` with `var`, you would be able to access it outside of the scope. From MDN: &gt;Because variable declarations (and declarations in general) are processed before any code is executed, declaring a variable anywhere in the code is equivalent to declaring it at the top. This also means that a variable can appear to be used before it's declared. This behavior is called "hoisting", as it appears that the variable declaration is moved to the top of the function or global code.
I want to say yes based on my understanding JS and outside of my knowledge of IFTTT API limitations. Post a code snipet and I'll work something up : ^)
yes - a block statement, but not a function block. So while `let` works this way here, `var` would not because `var` statements are scoped to the closest function block, not block statement like `let` and `const`. And each iteration of the loop is treated as a new block statement.
A minor nitpick is that you can have closure without functions. let outer = 3; let sum = 0; { let inner = 2; sum = inner + outer; }
Thank god.
Seems to a common problem actually since I went through the same trouble and took some time to document it. The key move: run tests with `Xvfb`. You can check the CI setup (e.g. GitLab CI YAML) at https://tekkie.flashbit.net/devops/angular-e2e-tests-on-gitlab-ci
Personally I think having a multi-paradigm (hybrid) language is a good thing. We shouldn't get married to any single paradigm. C++ is also a multi-paradigm language, and the code examples in this write-up use C++'s support of the [generic paradigm](https://en.wikipedia.org/wiki/Generic_programming) (data and algorithms parameterized by types).
"works fine in react" stops reading
That's just ordinary scope. That's not a closure. A closure *is* the JavaScript function. https://i.imgur.com/9PbxJbX.png https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone#closures
The library is too big for most uses, if I’m only using 2-3 functions from moment.js I can just write them myself at a fraction of the size 
I agree. I would argue that all practical languages are multi-paradigm anyway. A truly FP language would not be useful within itself and, in fact, the mere act of altering bits to do calculations is a side-effect. I've only worked with F# for FP, and the only way to make it useful is to interact with its OOP side to cause side effects like printing to the screen.
Coffeesctipt is dead, good riddance. 
It's hard to believe that it didn't return *anything*. Can you post a screenshot? That would help us debug any problems. For reference, this is what I get when running that code in the Chrome console: https://imgur.com/a/6ic14
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/tWZstfz.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dr7lj6z) 
It’s not really simpler if it makes vanilla JS harder to use. Short cuts and syntactic sugar obscure the real language underneath and then when you have to use plain JS or learn a new framework you are at a disadvantage 
AirBnB did just rewrite their entire front end in React this year so I don't think that's a fair assessment. I have a former coworker working at Google replacing legacy systems written in Python with Go. Walmart rewrote their entire front + backend. Just because it doesn't happen at all once at a large company doesn't mean it's not happening.
Hi /u/gnawlej, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Calluumm, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/owenrhys, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/myrrtle, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/drobke, For javascript help, please visit /r/LearnJavascript. Thank you!
I think this misses a lot of the point of what LINQ really is. While this is a pretty nice suite of lazy map/filter/reduce functions using the same words as LINQ and thus somewhat providing the feature of LINQ-to-objects, for me the cool part of LINQ is that it allows you to query many different sources (databases, rest-apis, etc.) with the same language and interface.
so uhh when are you going to stop posting this like clockwork once a week?
Seriously, this lib comes up almost every week on multiple subreddits... please stop posting about it unless there are some major changes that might be interesting to look at.
Using a block also means you're leaking into the surrounding scope if you transpile to es5 or lower. 
The + operator is not a function. You should just use the language as it has been designed, and maybe stop trying to redefine things to suit yourself:-)
Sorry I'm in a rush this minute, but I'm doing exactly what you want here https://github.com/phrase-technologies/phrase/blob/develop/api/src/app.js should be enough to get you going, if not I can write an explanation a little later on
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [phrase-technologies/phrase/.../**app.js** (develop → 249482a)](https://github.com/phrase-technologies/phrase/blob/249482ab71945d318f6f8f699f8ae6562e46bdf6/api/src/app.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dr7okuw.)^.
Documentation, testability, performance, amount of tooling available, security, number and quality of official libraries maintained by core team 
It really returned absolutely nothing. I'm working in codepen.io I tried running it in the chrome console and got CORS problems 
Not necessarily.
I think V8 has done something similar for a while now ... if you boot a simple Electron app it's just as quick as a native app ... The problem is most devs don't think about optimizations, so most electron apps suck.
I recall a google thread being linked to(sorry I didn't save it) when ff first started talking about this. I distinctly recall someone in it saying chrome has been doing a version of this for years now. Still doesn't take away from what FF is doing though. Good for them
For sure, we need a level playing field so I wholeheartedly endorse Mozilla's efforts. Besides, it's fascinating to see all the different approaches to JS perf.
When I experimented with yarn about a year ago, it was slow as hell. I don't remember exactly why. Something about building dependencies I think.
Fair enough. But if you want a free standing fmap function, then step 1 is emulating [function overloading](https://en.wikipedia.org/wiki/Function_overloading).
NaN evaluates to false. 9 evaluates to true. The `||` operator returns the (first?) true operand in cases where there is one.
`NaN` is falsy: &gt; Boolean(NaN) false &gt; !!NaN false But `9` is truthy: &gt; Boolean(9) true &gt; !!9 true So you're saying "falsy thing OR truthy thing" and Node decides "truthy thing!" The other falsy values in JS include: `null`, `undefined`, empty string `""`, number `0`, and obviously `false`. &gt; It works with 0 This is interesting. `console.log(NaN || 0)` prints `0`, despite the fact that `0` is falsy. What's going on here in actually short circuit evaluation. The JS interpreter checks the first thing in the OR expression, and if it is falsy, then it evaluates the expression to the second value, without even looking at it. So if both values are falsy, the second value will be the result of the expression. 
Not just taking a page, they're actually using ember... angular-cli uses ember-cli as a dependency.
That is an awesome explanation. You, dear Sir (or Madam/Miss), Rock!
I don't know why you're getting downvoted when you are completely correct.
This article is on point. Much better than I was afraid it would be from the title. The complicated stuff like spa frameworks aren't for your basic blog or a restaurants static content + cms driven menu. The complicated stuff exists for when the website is really a Web app. And the newest generation isn't *really* more complicated than app frameworks targeting other environments. Different, but not inherently more complex. The ecosystem is definitely getting there. Little by little.
Co-author here. Options within a category are not mutually exclusive, so it was perfectly fine to pick Redux, Apollo, and GraphQL. Categories are just used to group technologies together and facilitate navigation. 
Novice front end dev who started coding 6 month ago. Had some time the last week or so and thought I’d learn about database design, and went with firestore real-time database to make a one-to-many customer service chat application. This is obviously unfinished, but has the groundwork. I’d like to know how other people would approach the problem! https://github.com/maladr0it/firebase-app
&gt; ~~num //bitwise not Anybody care to explain how this manages to work? 
&gt; first? yes console.log(NaN || false || 9 || true) &gt; 9
That works too, as long as the point gets across.
&gt; What's going on here is called _short circuit_ evaluation. The JS interpreter checks the first thing in the OR expression, and if it is falsy, then it evaluates the expression to the second value, without even looking at it. Although this analysis is correct, in the interest of pedantry I want to point out that this is not what "short circuit" means. Normally when you call a function all arguments are evaluated before the function runs. If an argument expression produces a side-effect then that effect will run whether or not the function references that argument position. Operators like `||` or `&amp;&amp;` are similar to functions - but as mentioned these operators can short-circuit. `||` returns its first argument if that argument is truthy. In that case the value of the second argument has no effect on the value of the overall expression - so if the first argument is truthy then the second argument is not evaluated, and any side-effect the second argument produces never runs. The term "short circuit" refers to skipping evaluation of the second argument. For example, this line logs to the console only if `success` is falsy: success || console.log('no success') Likewise `&amp;&amp;` returns its first argument if that argument is falsy, and skips evaluation of its second argument in that case. authorizedToLaunch &amp;&amp; launchMissiles() You can see that short-circuiting makes it possible to use `||` and `&amp;&amp;` for flow control. There are languages where these operators do not short-circuit, and you could see a result in such a language where `NaN || 9` evaluates to `9`. The behavior of `||` blindly returning its second argument if the first argument is falsy is not directly related to short-circuiting.
It's also worth mentioning that the right side of the OR is not evaluated if the first part is true. You'll often see this pattern in code: a() || b(). Function a is guaranteed to be called, but function b will only be called if a returns a falsy value. You'll see this pattern in other languages besides JavaScript too.
Number is most readable, and does what you expect if you want decimal, with leading zeros. The article says it's slower than parseInt. boo fucking hoo. Is Number parsing perf really holding your app back?
&gt; What's going on here is called short circuit evaluation. No, it isn't. Both arguments to `or` are evaluated here.
There are changes, ssl and machine scaling was added only to this release and it is the first post which include machine scaling and ssl. I do not post if there is no changes to the library.
Size, comfortability to use, may be perfomrance ( unfortunatly have not tested it agains sc), there are still some difference in functionality.
When i will stop developing the library, i am doing posts only after interesting changes to the library, (may be from next time i need to include info about changes in the post)
Wait, he's down on Number() because if you pass it an octal it can't return the decimal that kinda looks like it? Isn't the article called "converting strings to number..."?
This blog posting has all the signs that the author is a developer in the larval stage.
I think the main reason he suggested not using `Number()` was because of: &gt; Number was also one of the slowest outcomes in JsPerf. &gt; Number, pretty much don't use it
I also like it because you can pass it in function chaining like: let nums = ['1', '2', '3'].map(Number) You generally don't want to do that with `parseInt` since you should be passing a radix.
In es5 and lower there are no block-scoped variables, so it's impossible for a block *not* to leak into the surrounding scope.
I noticed that, and is a sign of an inexperienced developer.
You should point these things out then in your title. Right now it is simply advertising and self-promotion.
I think it’s just Javascript automatically casting to a numeric before performing the bit flip, and a negation is just a convenient way to perform it without affecting the actual value. I assume it works the same performing a bitwise and with all bits as 1, although that’s a little more cumbersome to write and use.
This is more of a CSS question, but you're most likely looking for margin properties. If you want to do it via JS, you could do it by adding the position of the previous radio button, plus the width/height (depending if you're going X axis of y axis) and then adding the amount of pixels (aka margin).
Ok, will do it from next time :)
Ah the post did mention that ToInt32 gets called on the string in v8. So it seems like it’s just a roundabout way of “cast to int, negate all the bits then negate em all back to the original”. 
The closure is the call to a reference outside the local scope. The term actually means the child scope is closed over (encapsulated) from the outer scope. The only difference between the block example above and a function example is that a function must always have a reference when not an IIFE. Functions without references cause an error. Blocks on the other hand have no reference.
So they still use React just don't load all of the React code bundles immediately 
If the transpiler is good at its job the `let` keyword would be converted to a `var` and the containing block would be wrapped in an IIFE so that the declared reference would be hoisted in a scope contained in the current block.
I'm also confused
This. The basic API and cocnept is good but the plugin ecosystem is messed up since most of them aren't official. Also, at least with Ionic I've had some problems and conflicts from updates of the cli
no, just stop posting it... you can make a twitter or a blog for fans to follow changes, if even 10% of open source libraries posted every single change this subreddit would be garbage
Interesting point. What package are you using to query rest apis with linq? I've never seen that before but it sound like it would make my life much simpler.
Look up fast truth JavaScript. It's super useful. potentiallyFalse.value || defaultValue (Cond1 &amp;&amp; cond2 &amp;&amp; theConditionalValue) || defaultValue
I recommend [Vue.js](https://vuejs.org/) - Great for people new to MVC frameworks - Great for people familiar with Angular, even if only a little bit - Really fast and easy to pick up The core concepts (templates, methods, computed properties) are all you need to build most small SPAs, and everything else is just icing on the cake meant to cover other edge cases.
It doesn’t seem intuitive at all WELCOME TO JAVASXROPT! Lol
Perhaps something like this? const getPlayer = player =&gt; ({ ...player, flag: show_flag &amp;&amp; player.flag, bomb: show_bomb &amp;&amp; player.bomb, tagpro: show_tagpro &amp;&amp; player.tagpro, /* and so on */ }) I don't think it's better, but it certainly is shorter if that's what you were after.
Thanks for the links. Slightly confused with this approach because I am using all the routes etc in legacy way i.e. I create a router variable and assign it express.Router() `let routes = express.Router()`. And in there I use `get, post` etc and with callback. Above links seem to be very different approach as you are passing io as a parameter in app.js file.
Then how do i find funs if i will not post info about it atlist once in a while?
Falsey/truthy has been known to make strong men weep.
The whole point of a transpiler is to implement ES6 concepts using the features ES5 supports. There are no block-scoped variables in ES5. But that just means the transpiler needs to alter code that uses them. [Babel does so like this.](http://babeljs.io/repl/#?babili=false&amp;browsers=%3E30%25&amp;build=&amp;builtIns=false&amp;code_lz=GYewTgBAFANgpgFwgSwgXggBgNwogHggFZdkBqMgSggG8AoCCAZ0QBVkBbOEAVwSijU0APggBjEADsmIeADoYIAOZRklADQQAjJWx0AvnrrwkAD3Ta9NCCYjmMAJj0BIUxWz669iAGZsQA&amp;debug=true&amp;circleciRepo=&amp;evaluate=true&amp;lineWrap=false&amp;presets=latest%2Cenv&amp;prettier=false&amp;targets=&amp;version=6.26.0) For performance reasons, it usually creates a new variable name which is in the surrounding scope [though babel ensures it uses a name that isn't referenced in the JS]. But when needed, it turns the block into a new closure. 
How is anyone going to help you without any context whatsoever about your use case and your code?
[removed]
aka code splitting. 
Though it's not mvc but mvvm, I really liked the simplicity of [knockoutJs](http://knockoutjs.com). There is few tutorials that'll put you right on track. 
 Yep. Pretty shit article 
Thanks for saving me a click. I backed out after reading your comment. Any big company not doing code splitting and using webpack is clearly falling behind in the performance department.
Short version: `a || b` is short for `a ? a : b` `a &amp;&amp; b` is short for `a ? b : a`
Wait, what? he's inexperienced because he cares about performance? Specifically using js for a back-end with node - we're in a single threaded world here.... quite frankly, I'll take take any win I can get to eke out more concurrent users from a given cpu on a server. It may seem like nothing, but in a complicated application that needs to scale to many users on limited hardware, every little bit adds up &amp; in the end, it'll server more users with performant code. If you are certainly dealing with ints, using bitwise operators can speed that one operation up by quite a bit. In the end, it's probably a couple of drops in the ocean - but the ocean is made up of drops and if you can increase throughput, why wouldn't you?
Depending on the rest api, you'll probably have to do a custom QueryProvider yourself, because not all rest api are similar. But if you are using something like OData, there may be third parties available.
I'm going to do some digging at work tomorrow. Any resource suggestions for making a custom QueryProvider for the uninitiated? 
Everyone keeps saying "falsy" and "truthy," but no one has named what concept allows for this. That concept is called "type coercion."
&gt; (may be from next time i need to include info about changes in the post) Yes, please do that, and only if it's major updates. Thank you.
Oh shoot, but I got it now to this error: https://gyazo.com/2d9a7c274b8270301fd23cc2b26b31ba &lt;/li&gt; &lt;button onclick="getSearchTerm()" style="float: right; margin-top: 13px"/&gt;Search&lt;/button&gt; &lt;input type="search" id="mySearch" placeholder="Search for a product" style="float: right; margin-top: 13px"/&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div id="buttons"&gt; &lt;label&gt; &lt;input id="query" type="text"/&gt;&lt;button id="search-button" disabled onclick="search()"&gt;Search&lt;/button&gt;&lt;/label&gt; &lt;/div&gt; &lt;div id="search-container"&gt; &lt;/div&gt; &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="javascripts/auth.js"&gt;&lt;/script&gt; &lt;script src="javascripts/search.js"&gt;&lt;/script&gt; &lt;script src="https://apis.google.com/js/client.js?onload=googleApiClientReady" + "&amp;output=embed"&gt;&lt;/script&gt; This is the snippet that handles the search bar and the rest of it is copied from the YouTube API.
Hi, I'm a bot that links Gyazo images directly to save bandwidth. Direct link: https://i.gyazo.com/2d9a7c274b8270301fd23cc2b26b31ba.png Imgur mirror: https://i.imgur.com/FzVJcQy.png ^^[Sourcev2](https://github.com/Ptomerty/GyazoBot) ^^| ^^[Why?](https://github.com/Ptomerty/GyazoBot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/u/derpherp128) ^^| ^^[leavemealone](https://np.reddit.com/message/compose/?to=Gyazo_Bot&amp;subject=ignoreme&amp;message=ignoreme)
Never mind networks and computers are faster than they’ve ever been and will continue to be so. Somewhat ironically, the engineering overhead in using your stack to serve pretenders HTML is actually probably more significant than just serving an SPA at this point.
Clickbait title.
Well you can create a new function by partially applying the radix.
Not true. Scope is implemented by transpilers with try / catch blocks.
It's also super buggy. Because if MyObject.potentiallyNotDefined has the actual value of 0 or is intentionally false, it will use the defaultValue anyways. Might not be what you want.
I’m on phone, but if you do 0 OR ‘’ OR 1 OR undefined this will return undefined? i will expected 1?
It will return 1
Technically console.log((NaN || 9)) will log 9, rather than "returning" it. Console.log (as a function) has no return. so: let a = console.log("foo") // =&gt; logs "foo" console.log(a) // =&gt; logs "undefined" The second thing is to realize that *usually*, the || and &amp;&amp; are used to evaluate binary values of complex booleans. And when you use them in an "if" statement, or as part of a ternary, that's really all they are. But because of the *way* that the computer evaluates the statement, you can use || and &amp;&amp; as shortcuts when grabbing values. So, with ||, it really means "Keep evaluating until we hit a value that is true/truthy, and that's the value we're concerned with. console.log(false || 0 || false || "linoleum" || false || "wabbajack") // =&gt; logs "linoleum" In the code above, what the computer is really "thinking" is * Is false true? No. Okay, then let's make this value the next thing in the chain. * Okay, is 0 true? No. Okay, then let's make this value the next thing in the chain. * Is (the second) false true? No. Okay, then let's make this value the next thing in the chain. * Is "linoleum" true. Yes! Ahah. SO the statement must be true. And we don't need to evaluate this any further - "lineoleum" is the value we must want. If all the values are false, of course, the computer will return the last value it evaluated. console.log(false || 0 || "" || NaN) // =&gt; NaN * Is false true? No. Okay, then let's make this value the next thing in the chain. * Okay, is 0 true? No. Okay, then let's make this value the next thing in the chain. * Is Empty String true? No. Okay, then let's make this value the next thing in the chain. * Is NaN true? No. Hmm... there's nothing left, so I guess we'll have to use this last value as the last item I evaluated. NaN it is. Similarly, with &amp;&amp;, it only needs to keep evaluating until it hits a falsey value, because any "false" in an AND chain throws the whole thing off. console.log(1 &amp;&amp; 39 &amp;&amp; "sproing" &amp;&amp; function(){ return false } &amp;&amp; NaN &amp;&amp; true &amp;&amp; "eh steve!" &amp;&amp; 0) // =&gt; NaN And similarly, if they're all true, it'll resolve to the last item in the chain. console.log(1 &amp;&amp; 39 &amp;&amp; "sproing" &amp;&amp; function(){ return false }) // =&gt; f () {return false } In the case of (NaN || 9), it's evaluating NaN as "falsey", so it will evaluate the next item in the chain, which is 9, which is "truthy" so the computer assumes that you meant "9" all along. This can be a confusing aspect of Javascript, and I will admit probably shouldn't be used because it's not user-friendly... but it often saves a lot of time and effort in writing out some complex logic, so people tend to use it anyway. For example, let's say that you have a function where you want to have a default value if the value is undefined. var add = function(amount, initialValue) { if(initialValue === undefined){ initialValue === 0; } return initialValue + amount; } It can often be written in shorthand as: var add = function(amount, initialValue){ initialValue = initialValue || 0; return initialValue + amount; } Or, let's say that you have an object that MIGHT have a property... and you don't want to throw an exception. var logDeepKazoo = function(obj){ console.log(obj.instrument.kazoo) } logDeepKazoo({instrument: { kazoo: "Zibbbb!" }}) // =&gt; "Zibbbb!" logDeepKazoo({instrument: {}}) // =&gt; "undefined" logDeepKazoo({}) // =&gt; Uncaught TypeError: Cannot read property 'kazoo' of undefined You could check to see if obj has the property instrument first... var logDeepKazoo = function(obj){ console.log(obj.instrument.kazoo) }
Things like slack take a gig of ram for a chat client, its still a bit over the top. I had chat on 16mhz machines, I think electron needs some optimizations
They are using React server side but it is not in the code bundle taking the page to an interactive state: https://mobile.twitter.com/netflixuie/status/923374215041912833
Not potentially buggy if you've internalized what falsy values are. Anything &lt;= 0 or False or null or undefined or empty is a falsy. 
In general http://wiki.c2.com/?PrematureOptimization &gt;"Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%." In specific, who is converting strings to numbers in the orders of magnitude where performance would actually be affected, and then recommend optimizations to the general user?
Only weak men use ==
&gt; Anything &lt;= 0 or False or null or undefined or empty is a falsy. This is falsy. I mean, false. `-1984` is not falsy. And an empty object `{}`, an empty map `new Map()`, an empty buffer `new ArrayBuffer([])`... are all truthy. Only an empty list and empty string are falsy when empty. Or, you know, one can be more precise about this, and [look at the spec](https://www.ecma-international.org/ecma-262/7.0/#sec-toboolean).
"Most frameworks now offer some sort of server-rendering feature" uhm not very long ago the web was being rendered server side only
You're overly paranoid. This ay need a rigid treatment if you're writing e general module where you don't know what people will throw at it, but in your own programs, you generally have an idea of what kind of data to expect. for example, if you're parsing then you *know* what you get is a string. There's only one way a string can be "false": if it's `""`. If the only data your function can get as a parameter is is a string and nothing but a string, there' is absolutely no need to check for `false`, `null`, `undefined`, `0`or `NaN`.
I never had to import multiple helpers in the same file but my guess is that your syntax should work, I'd double check the output with something like webpack-bundle-analyzer but there is no reason it wouldn't work. I usually use it like this : `import pullAll from 'lodash-es/pullAll'`
Ah ok. I thought the point of lodash-es was you didn't need too include the path to the function. I tried my code, but the whole lodash lib was included. I'll try your suggestion later. 
&gt; Both arguments to or are evaluated here. Nope. In a() || b() b() will only be called if a() returns false. This is often called "short-circuiting". 
This is especially nice if b() would crash of it's called in a case where a() returns false. For example? a &amp;&amp; a.x if a is null, then `a.x` would throw an exception. But now, it doesn't. 
&gt;So you're saying "falsy thing OR truthy thing" and the JS interpreter decides "truthy thing!" Not completely true. It decides "not falsy thing", and just takes the other one. It doesn't matter is it truthy or not.
There is only one problem: &gt; NaN == false false &gt; NaN === false false
I'm not convinced, but I appreciate your effort to tell me about something I didn't know. The reason is because I've seen many attempts at write once, view anywhere. The React reconciler is intriguing for using the HTML concept of "the browser will render it as it needs to" and applying it to cross-platform code at the native level. It still won't be the same as native code per platform, and even PWA code is optimised for each screen size and level of computing and connective capability. I think this is unavoidable, so the reconciler is more along the lines of "make something, anything, happen" rather than the pixel perfect layouts needed. HTML was intended as a descriptive markup, but has been egregiously abused to make it drawn as intended. This will never go away, everything needs to be drawn as intended on all platforms. HyperHTML won't provide that either, but it is very specifically fixing up my problems with DOM. Reconcilers are abstracting while not fixing the "as drawn" problem, whereas my actual problem is that not all browsers behave the same before even considering and getting into text tricks with consoles.
Not very long ago the web wasn't rendered server side via Javascript which is what people mean when they say that. The reason for doing so is to share code between the server and frontend.
No the article is good, just the title is clickbaity. The article actually says exactly this. &gt;Netflix uses React on the client and server, but they identified that the client-side portion wasn't needed for the first interaction, so they leaned on what the browser can already do, and deferred client-side React. The story isn't that they're abandoning React, it's that they're able to defer it on the client until it's was needed. React folks should be championing this as a feature. 
that talk is about their home page when you aren't logged in
By your problem description, I thought the problem was with passing the variable around, and not the fact that you can't send messages to your client. Anyhow, I think it would be useful if you included a snippet, gist, codepen, anything with your intention marked clearly if you still expect help from the community.
I quite like truthy and falsy values though. `NaN` and `null` can get fucked though.
If you're coming in with a bunch of html/css already written, it's AngularJS. You can later create components and then build them out in Vue if you prefer that approach.
I know what you mean. I went through the exact same learning stage. This is how the variabled inside the IIFE are resolved: ``` var outter = " Outter Scope"; const x = ( function sum(){ var a = "About"; var b = " JS," return (a+b+outter) })() console.log(x) ``` 1. The compiler reaches the IFFE, sees it's an expression, needs to evaluate it 2. It reaches the `function sum()', and then invokes that function (it has not compiled the inner working of the sum() function at this point - that is a key thing to know) 3. Now for an invoked function there are two phases: compilation phase, and execution phase - Compilation phase -- variables a, b are hoisted -&gt; they are now part of the local scope of the sum() function -- that's the compilation phase over - Execution phase -- 'About' gets assigned to a -- 'JS' gets assigned to b -- The engine e.g the Chrome V8 Javascript Engine, reaches the return statement -- ```outter``` is not in the local scope, so Engine searches the next scope up, and so on until it finds a variable 'outter' --- the value gets returned It's better to refer to the JS Engine as an engine, so that we can use the term compilation without conflict - as the engine does the compilation and execution
Meh I'm not that paranoid, I use it myself quite often actually. However in cases where you are processing user input it can be quite tricky. In those cases I would really check for undefined before falling back to a default value. Just as that parseInt without en explicit radix could lead to unexpected behavior. Call it paranoid or call it defensive programming.
I wrote something myself, which was a pretty heavy amount of work, but also an interesting learning experience, doing all the Expession and AST walking requires. One place to start might be looking at existing providers such as: https://github.com/JoeMayo/LinqToTwitter Or tutorials such a as this one: https://msdn.microsoft.com/en-us/library/bb546158.aspx
Seems like someone needing help with their homework? Why would you have that example using the logical-OR operator without even knowing the basics of the what the operator should do? Seems equivalent to asking why does 4 + 3 give me 7? You could just go to the documentation for that operator and read what it does.
That's unrelated to what was explained above. `==` has a different set of rules, not completely dependent on boolean coercion. As for `===`, well, there's no coercion there at all.
it keeps taking the next until a truthy value is returned
why is this a problem
Can someone explain this one please: Chain asynchronous functions Loop through an array of functions containing asynchronous events, calling next when each asynchronous event has completed. const chainAsync = fns =&gt; { let curr = 0; const next = () =&gt; fns[curr++](next); next(); } /* chainAsync([ next =&gt; { console.log('0 seconds'); setTimeout(next, 1000); }, next =&gt; { console.log('1 second'); setTimeout(next, 1000); }, next =&gt; { console.log('2 seconds'); } ]) */
Learn about how logical operators works, that's the very basic of the prog..
*[jQuery]... was a huge success, and its ultimate success is that it made itself unnecessary.* Amazing quote!
Interesting. I said the same thing just a few months ago and was downvoted into oblivion and made fun of on reddit. Not that it matters. I also said IE and Edge would be third rate browsers and reddit did the same thing.
Good article! I guess jQuery gave us a lot to think on and many of its ideas we see in the native platform today. Will frameworks like React and Vue do the same? Will we see native ways of doing web components with lifecycle hooks some day? 
For all the talk of perf, the author fails to mention the (probably) fastest method, [code]variable | 0[/code]
I think there isn't a binary representation of Nan because it is not a number so cannot be stored as such.
You can start with [building an iqueryable provider](https://blogs.msdn.microsoft.com/mattwar/2008/11/18/linq-building-an-iqueryable-provider-series/). It will teach you how to build a custom linq to sql. From there, you'll be able to change it to whatever you want (like api request). 
Keep in mind, I have no idea what I'm typing but here is a code snippet i tried but doesnt work. var url = Trigger.EntryURL/.rss?sort=qa&amp;limit=1&amp;depth=1; var comment = document.getElementsByClassName("md"); Tumblr.createPhotoPost.setCaption(comment); Tumblr.createPhotoPost.setSourceUrl(Trigger.EntryURL)
Whatever value you want and that is not a number value.
It reminds me when I was a beginner,and have a project to learn js.In order to see the relation of each files, reference,I read every file to make sure I fully understand,until I read jquery.min.js
NaN is of number type, though. But it doesn't have a binary representation. It would still just be NaN. (typeof(NaN) == "number") //true
jQuery is ca. 2010 JavaScript in style, approach, and functionality and simply is not needed nowadays for 95% of all tasks where it's used for.
Which transpilers? It certainly isn't in Bable or Typescript.
When using p5 dom, you can use the style method to apply a margin, as [indicated here](https://github.com/processing/p5.js/wiki/Beyond-the-canvas#setting-style). Or you could access the underlying element using the elt property of the radio object, and modify it's [style property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style). Or even yet you can [set a class and set the margin on a stylesheet](https://github.com/processing/p5.js/wiki/Beyond-the-canvas#using-a-css-stylesheet).
Yes I'm aware of how transpilers handle blocks, and my point is that it has no choice but leak. No, it's not a problem 99% of the time, but if you leak into the global scope and your transpiler is not aware of some globals, it has a chance of clobbering them.
I really like most of Eric's writings but _strongly_ disagree with his feelings on type systems. In the article, he talks about how he's used TS in Angular 2, and how it got in the way more than it helped. I've been using TS in React for a while now and it's great. &gt; The added complexity of templates and type constructors makes it harder to design and understand generic functions in statically typed languages Quite the opposite, actually. Annotating your methods with types makes you _think_ about the API of your method beforehand. It also _signals_ to other developers how they should use the API. It's harder in the sense that you have to do more thinking up front, but it forces you to put your assumptions in code, and as developers, minimizing our assumptions is one of the best things we can spend our time on.
Do you have a snippet that Babel will turn into a closure? I've never seen it do a block to IIFE conversion, it just renames variables. Yes that's usually sufficient, but if it's not aware of all the variables in the surrounding scope (ex. `window`), it doesn't know it needs to rename them.
I'd love an example of a piece of code babel will turn into an IIFE. I've only ever seen it rename variables within a block.
Jake Archibald’s stuff is pretty good. The title for this article was just a bit clickbaity; the article itself is still good, it’s just not exactly what the title makes it seem like it’s going to be.
I don't believe there is a single binary representation of `NaN`. JavaScript uses the IEEE 754 standard for storing floating point numbers and `NaN` is simply a value that does not represent a real number. &gt; The value NaN (Not a Number) is used to represent a value that does not represent a real number. NaN's are represented by a bit pattern with an exponent of all 1s and a non-zero fraction. There are two categories of NaN: QNaN (Quiet NaN) and SNaN (Signalling NaN). &gt; A QNaN is a NaN with the most significant fraction bit set. QNaN's propagate freely through most arithmetic operations. These values are generated from an operation when the result is not mathematically defined. &gt; An SNaN is a NaN with the most significant fraction bit clear. It is used to signal an exception when used in operations. SNaN's can be handy to assign to uninitialized variables to trap premature usage. &gt; Semantically, QNaN's denote indeterminate operations, while SNaN's denote invalid operations. [Source](http://steve.hollasch.net/cgindex/coding/ieeefloat.html)
According to IEEE 754, NaN values are represented by the exponent fields containing all `1` and a non-zero significand. JS uses 64-bit floats for all numbers, so this would look like &gt;s111 1111 1111 xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx where s is 0 or 1 and `xxx....` is anything but all zeroes. I don't believe you can retrieve or examine this value in JS, but it's used in the underlying engine.
What is this, 2007? Also, jQuery is JavaScript.
Hi /u/samdbeckham, For javascript help, please visit /r/LearnJavascript. Thank you!
 2016, jQuery is a JavaScript library. Are you sure you've read the article??
Hi kenman, I'm a little confused. I'm not looking for javascript help, why was this post removed?
This subreddit isn't really for extreme beginners. Content that's aimed at those types of users would be more fitting in /r/LearnJavascript.
&gt;2016 Doesn't feel like it. &gt;Are you sure you've read the article?? Have you? &gt;"What’s the difference between JavaScript and jQuery?" &gt;"how jQuery and JavaScript do the same thing in different ways" &gt;"languages like jQuery and JavaScript"
Well, from my point of view, main culprit of this "overcomplication" is the increase of requirements for the UI. Few year ago, one static form with one send function was totally bleeding edge from business point of view. Today, shitload of interactive features are requested. When requirements are complicated, implementation is too.
Can't you retrieve it with DataView and ArrayBuffer? (write a Float64 and then read the raw Uint8's)
Wrap it in some div then.
I wouldn't say a video series on learning VueX is aimed at extreme beginners at all. The last episode is i the top 100 most upvoted posts of last month on /r/javascript so people clearly want to see this kind of thing. I understand moderating every post on a sub as active as this can be difficult. I moderate a much smaller one myself and you can't properly check every post. Is there anyway you can reverse this removal or allow me to post it again please?
You're totally right. Neat! const buf = new ArrayBuffer(8); const view = new DataView(buf); view.setFloat64(0, NaN); let binStr = ''; for (let i = 0; i &lt; 8; i++) { binStr += ('00000000' + view.getUint8(i).toString(2)).slice(-8) + ' '; }
&gt; I wouldn't say a video series on learning VueX is aimed at extreme beginners at all Please re-read your title, and see if you can understand the reason behind my initial assessment. "I Have No Idea What I'm Doing [...] Getting Started" conveys a completely different subject than "learning Vue and Vuex by creating a digital version of a popular card game". Feel free to repost, but please use a more descriptive title.
Yep, I totally see where you're coming from. It makes sense with the context of the video but without context it does seem very much for beginners. I'll re-upload with a better title. Thanks for talking through this with me and not just brushing me off.
&gt;Doesn't feel like it. I've read the date it was posted, didn't feel it. &gt;Have you? yes, and I found the third line weird too and it's a good thing that you pointed out because the purpose of any post in any sub-reddit is discussion, and bringing each other's knowledge. Now for the question about the difference between javascript and jquery: I don't know why it bothered you since there are always beginners developpers, and I personaly came across this question many many times, IRL &amp; in different social medias. The second line, I don't understand what's wrong with it either? the purpose of a library is to simplify code writing by providing functions that are frequently needed. So, what do you think?
Sounds like observables just aren't mature enough yet.
Codewars http://codewars.com 
&gt; To get stricter type checking, you can define your parameter types and then wrap your function with a type checking function. If you find that you (might) need this, or yet another dumbass test that checks your types, then I'm sorry to break it to you but you most definitely *do* need Typescript or some other form of *static* type checking.
Bollocks... you can always use Typescript even if you're just shoving ES6 JS through it.
Yay! Yet ANOTHER is framework! ...
... I mean, if you wanted to unhide a password, wouldn't it be easier to just go in the dev tools and change 'type="password"' to 'type="text"'?
Just today I showed a colleague some large refactorings that I would not have wanted to tackle without TypeScript. On the other hand in small projects I'm fine with using **vanilla JavaScript**, although even than I may use TypeScript Just to define the **public APIs.** But for larger projects with dozens of developers and hundred of thousands of lines of code I find it impossible to argue against using TypeScript (or a similar alternative such as flow).
console.log( !+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[] ); // returns 9 JavaScript can be weird, but the answer to your question is that if the thing before || is false, it gives the thing after ||. It does this because that is just how logical OR works.
&gt; I don't know why it bothered you since there are always beginners developpers, and I personaly came across this question many many times, IRL &amp; in different social medias. That's exactly *why* I have a problem with this article. If I were someone asking myself this question, I would come away from this article believing jQuery is some sort of alternative to JavaScript. "What’s the difference between JavaScript and jQuery?" is a reasonable question to hear from someone who doesn't understand what jQuery is. It's _not_ reasonable as a rhetorical question asked by an article like this, because it doubles as a statement that jQuery and JS are some sort of rival technologies. &gt;The second line, I don't understand what's wrong with it either? It's slightly less bad, but it still contributes to the theme of jQuery and JS somehow being different things.
[removed]
Try this try { throw("You don't know what you are talking about"); } catch (a) { a = "muppet"; console.log("See? You " + a); } console.log(a);
And I respect your point view :)
I had a fairly large project which I started working on months ago. It compiles a custom JS-like syntax to executable WebAssembly. I haven't had anyone do any sort of peer review on it, which helped the accumulation of tech debt. Now it's getting some attention and I'd like to raise the quality &amp; consistency of the codebase before it's too late. Link: https://github.com/ballercat/walt There is a lot of code and I bet a lot of areas that can be improved upon. Thanks.
Thank you.
I would just use zipA
&gt; Yes, I know that. My point is that implementing block-scoped variables in ES5 is not technically possible. The variables you put in your ES6 code are scoped according to the blocks in your ES6 code, when the resulting program is executed. Thus, babel implements the block-scoping. The generated code doesn't use block-scoped variables -- they're not part of ES5. The same goes for literally everything an ES6-&gt;ES5 compiler implements. It's why you have a transpiler. That said, transpilers rely on static analysis, and javascript is dynamic enough that you *can* break its assumptions if you want to. In this case: let x = 4; { let x = 5; } let code = "_x"; eval(code); But that's mostly because *es6 eval* isn't implemented via babel [with good reason, though it wouldn't be impossible], and not anything particular to block-scoping. &gt; Do you have a snippet that Babel will turn into a closure? [Had one in the post you're responding to.](http://babeljs.io/repl/#?babili=false&amp;browsers=%3E30%25&amp;build=&amp;builtIns=false&amp;code_lz=GYewTgBAFANgpgFwgSwgXggBgNwogHggFZdkBqMgSggG8AoCCAZ0QBVkBbOEAVwSijU0APggBjEADsmIeADoYIAOZRklADQQAjJWx0AvnqA&amp;debug=true&amp;circleciRepo=&amp;evaluate=true&amp;lineWrap=false&amp;presets=latest&amp;prettier=false&amp;targets=&amp;version=6.26.0)
You do know that everything stored on a computer is in binary right?
So then how could you store NaN if you can’t store it as binary? (Your words not mine)
Thank you, this gives me something to learn. DataView, never used. You mean to say NaN is evaluating to 0 ?
You just have to create a declaration file for all of it, which is a non-trivial thing in the same of some more complication/abstract libraries. Many of them already exist, but some don't and others lag behind the latest version of the libraries in question. I've personally been inconvenienced by them on multiple occasions.
I don't think people writing untyped code don't think about their types or interfaces. If their code is going to work, they have thought about those things, with or without annotations. So i disagree that it makes you do more thinking. It does guide other developers to canonical use if they are using development tools that can leverage the type information. In a plain editor you are rtfm either way.
Project Euler https://projecteuler.net
Gotcha ... thanks.
This thread made me realize that I'm so dumb 
I've written a few miscellaneous utility functions to help me when writing vanilla JS tools and applications. You can find them here: [https://github.com/dshepsis/Utilities/tree/master/JavaScript] They are all formatted and commented a little bit differently, but any particular or general advice on style and readability would be appreciated!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dshepsis/Utilities/.../**JavaScript** (master → bf0daaf)](https://github.com/dshepsis/Utilities/tree/bf0daaf13c9fc7ffc90ef5669452ba991df48e2d/JavaScript) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
This and general tooling functionality. Jump to definition (at least in VSCode and WebStorm) seems to work better in TS projects than JS. Code suggestions work better in TS projects. Automatic rename refactoring across multiple files works better in TS projects. Hovering over keywords for summary documentation works better in TS projects. Editors are better at finding typos in TS projects. When dependency APIs change, editors will let you know if your implementation is now wrong (for dependencies with well-maintained definitions). Overall, I find the development experience to be far more enjoyable in TypeScript. I spend less time jumping back and forth between dependency documentation and more time writing good code that I am confident will work well.
This article suggests that the TypeScript equivalent of: const identity = arg =&gt; arg; is: function identity&lt;T&gt;(arg: T): T { return arg; } Why wouldn't you just use: const identity = &lt;T&gt;(arg: T) =&gt; arg; This is only 8 characters longer than the original, as opposed to the author's TypeScript example which is 21 characters longer. TypeScript will infer the return type, and there is no reason you have to use the function declaration form in TypeScript instead of the arrow function expression. It seems the author has intentionally used the noisier form to make TypeScript seem more complicated.
Crap. Every link goes to the same Udemy course. And it's this persons only post. I was about to report it, but I realized that other users might benefit from seeing what sneaky spam looks like. (hell it might not even be that sneaky) The really STUPID part, and I say this if the poster is paying attention, is that if this person had just posted straight up &gt; Udemy course on the modern aspects of JS With a little explanation and then a link to the course, it would have been accepted outright.
I don’t have an answer for you but I don’t think this is the right place to ask about database migration Try [/r/mongodb](www.reddit.com/r/mongodb) 
Yeah, when I do studies I totally lump together unrelated things into arbritrary groups too.
Hello. I'm happy that you found it useful. Vuex post is on my todo list.
I'd say more often I'm starring an updated fork of a project that I've previously starred.
Because I'm willing to bet none of the people giving a (correct) answer knew the answer up front. They just know where to look and what to look for.
Ruby is better language than JS by far, if Ruby could be used in the browser, JS would be dead since several years ago.
Okej 
I worked at a company using Rails for about 3 years. Got fairly comfortable with it, and it felt a joy to use. Since then ive been primarily using JS for backend, as well as frontend. Really I think for the modern style apps, rails just felt behind in terms of supporting SPAs. So for some it fell by the way side. I've since gotten pretty comfortable with node, and tend to forgot little things here and there with ruby. I've used ruby a for a couple of the challenges on http://adventofcode.com for this year. I do like the spread assignment: `a, b, c = numbers.split(' ')` for example. I do like a lot of the code structure of it. But I've also gotten really into mixing OOP &amp; functional programming over using classes &amp; mixins for everything. That's not really something I miss.
Yeah, totally. Back in college I might have been able to rattle off the explanation if I had just studied it for a final. But now I just look it up as needed.
I liked your choice to use vue cli too. I've set up webpack so many times for React and/or ES6 &amp; imports, and it hasn't gotten easier. Totally agree with you it's a pain and should be skipped if it's not a production project
Seems like you've tried both and have a preference, but you want it confirmed. I'd pick React. Mixing JS and HTML isn't "dirty". There's nothing sacred about keeping the HTML in a different file. That just makes it harder to find when you need to make a change. Separation of concerns is what's important. Don't put logic in your HTML, and don't put design in your JS. JSX is a clear barrier between the 2, it's just not in a separate file.
Try this: https://stackoverflow.com/questions/6251548/converting-database-from-mysql-to-mongodb Might have the answer. Don't know what relational database you're using but figured MySQL would be a good bet
No, that's not how `||` works. It takes two operands. If the first operand is truthy, then it returns that first operand. If the first operand is falsy, then it returns the second operand - whatever that operand's value may be. So `NaN || whatever` always evaluates to `whatever`, regardless of whether that value is truthy or falsy.
Because the author doesn't know much about Typescript (read the comments on that page).
I don't have a good enough handle on tco to speak intelligently on the mater, but I understand it has to do with reducing the strain recursion can put on the execution stack. - anyway, here's what I got from Safari - which just implemented tail call optimizations. [Debug] zipA: 9.842ms [Debug] zipB: 611.840ms [Debug] zipC: 1370.077ms [Debug] zipD: 354.469ms
yeah, this is ridicolous. I think "rx observables forEach" is just a listener (observer). The "subject" is the one can emmit values "sync" or "async" const source = Rx.Observable.from([1, 2, 3, 4, 5]); Your subject is an array, witch is evaluate immediatle. So the listener recive all values immediatle. But your subject can be a Promise/Event/Ajax/Array/Number/etc...
You should ask the same question on the Ruby subreddit so you can get a more balanced view.
Nice
The typed/d3 binding is almost 3400 lines. And the way types are nested in that library, it's hard to cherry pick functionality for a definitions file. For small to medium sized projects, if the libraries you use are complex, and there are not bindings already, it is a non-negligible amount of work to use typescript. You may be happy with the end result, but that doesn't mitigate that fact. In this respect, i think facebook flow is undersold. 
&gt; And since they learned CoffeeScript in a w'end and can quote jQuery usage tips ...sounds quite snobbish to me... :-)
I agree. It's super nice and easy to navigate jsx-components and understand the *program flow* so to speak.
I'd choose react. For one, as you've mentioned, there seems to be more job opportunities in the market for react developers. I'd like to get to jump on Vue.js one of these days, but right now I don't see anything a big ecosystem and community as React. 
Can't exactly remember but the jist of it is that we set it up to create a rectangle with a random colour, but that wasn't enough so we put it inside of a for loop and set that to go for around 99999 times. EDIT: I'll get back to you if I can find the code.
I’m a front dev so mostly using JavaScript but our backend uses rails so I occasionally do some Ruby. What I don’t like about Ruby is that it is super implicit. Last line of a function is always returned even if there is no return instruction, a function can be called without parenthesis if it doesn’t have arguments, class properties can be call without « this », etc. Maybe this is just my lack of experience with Ruby talking but sometimes I find it hard to understand quickly someone else’s code just looking at it. Is this expression a variable or a function call ? Is it local or belonging to the class ? You can never be sure without carefully looking at the rest of the code. I don’t have those problems with JavaScript code which I found much clearer. I never did any Python but I like that one of their rules is « better explicit than implicit ». 
If it's a complicated app like page, i highly prefer if it loads all the parts before allowing a user to interact.
Thanks, it all makes sense now :P
Separation of concern is a very misunderstood thing. React was made to separate it, cleanly and elegantly. Though it gives you full control over view logic, looping, conditions and so on. Vue of course has to do that part as well, but it can't do it clean because its templates are cut off from your code, it has to circumvent the gap with actual hacks now: dependency injection and inflators. If you have worked with React and know what JSX boils down to, a simple function, it will click. React obviously has the [larger market and appeal](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core), a larger community, but technology-wise it is on the forefront as well. It is also simpler to learn, in that there isn't much to learn at all. You use javascript as you always would without having to make drastic changes. In Vue you relearn *everything*. Like beginning the language anew, from simple loops, to conditions, to filters, to referring to simple scope objects. The philosophy is also way different. Vue is a web-framework. React is a cross platform lib. It just so happens to offer a reconciler that can render to the dom, one of dozens. This allows you to transfer your knowledge and skill literally everywhere.
Do you mean that you have 2 tabs open when you say 'other page'?
Hi, Looking for get involved https://github.com/cercatore
I want the option 2 but with xmlhttprequest to send a GET to the second page and use PHP to echo the value. Also without the submit button, I want to use an addeventlistener keyup.
I actually started with Javascript about 20 years ago, then Java, then PHP for many years. In 2009 I decided it was time to put on my big boy pants and pick a project and dive into RoR. There was a lot of work around town for Ruby / Rails devs at that time, and I was looking for new direction ( and more money ) in a market full of kids whose PHP credentials lay predominantly in hacking Wordpress themes. I decided I'd try and customise Spreecommerce for my online store, as it seemed to be the leader at the time and had a bit of a community. Long story short... after bashing away at it for about nine months I found the ecosystem to be flakey and poorly documented, and Ruby dependency management absolutely nightmarish. Worse still was the Ruby / Rails community. I hope history will remember them as a bunch of mindless jerks who were the first against the wall when the revolution came. After that, it was an easy choice. :D 
Just curious, what typed languages do you have experience with?
It looks like you crashed the display driver. That's the usual symptom: all displays go black and then recover within a few seconds when the driver gets restarted. Have you tried it on a different machine with a different display card and driver? Also be sure to check for display driver updates.
If your wanting to compare against it, `isNaN(n)` or Number.isNan() should do it for you.
Fun fact, all of those "x" mean you can use Nan values to store lots of other kinds of data in the same place where you might other times store a number. This is called [Nan tagging](https://news.ycombinator.com/item?id=11327166). I [use it in my programming language for storing values](https://github.com/munificent/wren/blob/master/src/vm/wren_value.h#L474-L529).
You just got a little bit smarter.
Woa I'm surprised that is preserved. I swear I've read an article where Firefox / SpiderMonkey stores type information or something in those bits. Wonder what you can break with that. :P
They're not unrelated at all, they're all different links in how your data gets from your database to your client. In fact Apollo is a GraphQL client that uses Redux to store its data (or at least did until the recent 2.0 release). It's hard to get more related than that…
Did you just look for keywords you recognize in the question and ignore the rest?
This is so much nonsense. What does the size of the definition file have to do with anything? Your comment makes 0 sense.
Typescript is just some additional add-ons to JS that allow for strong typing (i.e., being explicit about what data-types variables are supposed to be and providing error messaging when these type rules are violated). Babel is software (i.e, a transpiler) that takes newer JS syntax features (e.g., fat arrow functions, const, let, async/await, etc.) as input and returns older/more reliable syntax as output.
Typescript can target various versions of es and when it does will transpile features like fat arrows to es5 or whatever version you target.
Neat, I never knew about this! Here's [the spec reference](https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-number-type): &gt;2^53 - 2 distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value. In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is implementation-dependent; to ECMAScript code, all NaN values are indistinguishable from each other
Nice.
&gt;Polymorphism involves subclasses overriding shared functions in order to do different things Only the specific definition of polymorphism used when talking about objects. Not the general definition or even the only one used in computer science. Your example is polymorphism but it's not required for dependency injection. class Foo { bar = () =&gt; console.log("bizz") } class Bar { bar = () =&gt; console.log("buzz") } Those two classes can be freely injected into an object expecting either one, but they do not share a base class of any type.
https://www.reddit.com/r/shittyprogramming/comments/7ju2jp/how_to_properly_represent_nan/
If the definition file DOESN'T EXIST ALREADY, you have to WRITE IT YOURSELF, and sometimes that file REQUIRES A LOT OF WORK TO CREATE. If you can't understand that, you need more help than type hints. 
Sorry is Babel a transpiler or a polyfill or does it have options for providing either of these capabilities. If I can simply include a script ref to Babel on an html page then I would consider that a polyfill. If Babel requires me to run a cmd on the cmd line in order to translate my job into something else then I would consider that a transpiler.
The number one issue i've got is that the browser doesn't natively support TypeScript. As you may all know, not eveyone has the benefit of building large-scale apps. Typescript on a one-pager subscription page? No tnxz. I've worked on TypeScript and my experience with is has been phenomenal. So as long as you're not polluting your type-checks with `any` statements, you'll reap a lot of benefits. I can only imagine how better node backend development is with static typing. It was discussed to add native static typing support in Chrome here: https://groups.google.com/forum/embed/?place=forum/strengthen-js#!topic/strengthen-js/ojj3TDxbHpQ. Though that was cancelled due to scoping complexities. It was cancelled... On a side note - thread is filed under `strengthen javascript`. I swear I'll go nuts if someday, people will argue `oh you're still using no static typing in your javascript? ohmyg so baD.`. There's been talk around here about potentially getting native typescript support in your browser: https://github.com/Microsoft/ChakraCore/issues/1435. If Chrome decides to fully embrace it as a natural language for the browser, others will follow and so will I. For now - I'm sticking to Typescript for one big app i'm working on and ES6 for all my other projects. Well, if I have to build a mission-critical app for a hospital, that'd probably a no-brainer: Typescript all the way.
It is a transpiler.
Literally in no way do you *have* to write a definition file. As mentioned elsewhere here you can just give the stuff a type any, or use implicit any, and be on your merry way no worse off than if you were using pure Javascript. And none of that has anything to do with the size of a definition file.
From a practical perspective the easiest way to think of it is: - Babel compiles modern JavaScript so that it runs in older browsers and older versions of Node. It does this by converting modern features into code that will run on older browsers and adding polyfills for missing functionality. - TypeScript does the same thing as Babel plus it adds optional static types (not part of standard JS) which allows the compiler to check for certain types errors at compile time. Used correctly the static types can improve the quality of your code and remove the need to write certain tests. Obviously this is a simplification of all the differences.
It has gotten easier. https://github.com/facebookincubator/create-react-app
I'm not saying that polymorphism is required for DI. I was simply trying to get validation that the example I provided would be an example of implementing polymorphism *through* DI. "Only the specific definition of polymorphism used when talking about objects. Not the general definition or even the only one used in computer science." Thanks for the education. What would be the other major definitions of polymorphism in computer science? It sounds like my definition may be oversimplistic coming from a C# background. Is there a better definition to use when discussing with js devs?
And where do you define it to any? In a definition file. If you're just easing the restrictions until anything passes, you're better off using vanilla js that everyone will be able to consume, or using opt in alternatives like flow. The size of the file is an indicator of how long it would take to make. That d3 def file would take quite a bit of effort to create if you had to do it yourself. To assume that there will be a def for every version of every library you use is a mistake -- or your projects are trivial. 
Thanks for testing.I see at least zipC and zipD doesn't get the stack overflow error.
Not dumb, only ignorant. That's much easier to fix.
Wow, I hadn't heard of wren before. Looks like a nice minimalist language for embedding in stuff. Always wanted to have something like that, I'll give it a go for a future side project!
&gt;And where do you define it to any? In a definition file. No. You don't. You declare it basically anywhere in your code base but usually it makes sense to either declare it near where it's used or make all the declarations in a single file. A file that is a code file and *not* a definition file. /* together */ declare var d3: any; // use d3 any way you want d3.drawAThing(); Or /* my declarations file, dec.ts */ declare var d3: any; Then import "dec.ts"; // now freely use it d3.drawAThing(); You literally don't know how to use typescript. Which is fine. But then you want to mouth off about it. If you don't know anything about it then stop acting like you do.
I saw the others answers and used mine to cover the possibility they were trying to compare values against NaN.
What would you want the binary representation for for this use case?
First, let me get this bit out of the way. Like others already said, using `slice` and `concat` in the way you do in B, C, and D is really slow. These functions are multiplying your time complexity by an extra O(n) factor, where this is entirely unnecessary. Also, none of these functions is lazily implemented, unlike what you'd find in a more functional-focused language. This is also why Stack Overflows are being produced - JS was never setup to do this type of stuff. FP is not about avoiding loop constructs and requiring recursion. I think this is one of those examples where you're pushing the FP style onto a piece of JS code where it just doesn't fit at all. That said, let's look at your sample code. - `zipA` is the straightforward `map` implementation, nothing fancy here, and performs well as expected. This is more or less how JS is intended to be written. - `zipB` is the basic recursive form of the zip function. Unlike in your test, it actually produces a Stack Overflow on my Chrome (and I don't see why it shouldn't). Can't recommend using this implementation ever, only useful for research or some stuff. - `zipC` I'm going to ignore, as it's just a worse version of the idea behind `zipD`. - `zipD` itself is not properly implemented though, as it returns the wrong result. `concat` accepts arrays of values, and will simply push all these values onto the array, so you end up with a 1d array of numbers. I don't know a whole lot about TCO, but as far as I know it relies on the last statement of your function (here `zipD`) being of a fairly strict format, here it'd be `return zipD()` (arguments allowed, ofcourse). This is not the case here, as the first and last statement in your `zipD` is a ternary instead. It's possible that the ES6 TCO specs support this type of syntax, though I personally doubt it. --- That all said, we can take a closer look at your `zipD`. Let's start by fixing the bug: this is simple, just add another array around the input for `concat`: `acc.concat([[a[0], b[0]]])`. But wait, we can do better! You may notice that we're only using `concat` to add one elements to `acc`, but in this notation we can't use `push` due to its return value. If we write down `zipD` differently, we'll both make the function way easier to read and understand, plus we get to use `push` instead of `concat`. zipE = function(a, b, acc = []) { if (!a.length) return acc; acc.push([a[0], b[0]]); return zipE(a.slice(1), b.slice(1), acc); } This actually helps our performance a decent bit, but due to using `slice` we're still technically at O(n*n) time complexity. My Chrome reports about a factor 2 - 2.5 speed improvement. Coincidentally, due to our rewriting the function into `zipE`, we now have a TCO-supported function for sure! If we're looking for performance, we can do way better though. We need to find a way to get rid of the `slice` calls. Well, what if instead of only passing the remainder of the array, we instead pass the entire array, but keep track of where in the array we were at? Below is an implementation: zipF = function(a, b, acc = [], i = 0) { if (i === a.length) return acc; acc.push([a[i], b[i]]); return zipF(a, b, acc, i + 1); } The changes: we've added another parameter to keep track of where in the arrays we are at. This requires us to modify our base case condition. We also have to `push` that index from both input arrays. In return, we can keep passing the original input arrays without `slice`. I've tried to do some simple speed tests comparing `zipA`, `zipD`, `zipE`, and `zipF`. Around a length of 6e3 is the highest my browser allows me to zip without throwing a Stack Overflow on either of these functions, so I'll be using that length. To get more accurate results, I added a loop around each call. For A and F it loops 1000 times, for D and E only 10 times. Here's a sample result: zipA: 209.469970703125ms zipD: 8744.4716796875ms zipE: 4325.997802734375ms zipF: 229.696044921875ms Taking the loop size difference into account, `zipD` was a whopping factor 4000 slower than `zipA`. `zipE` was where we repalced `concat`, resulting in approximately a factor 2 speed improvement. `zipF` is where we fixed the other remaining slowdowns, the `slice` calls. As you can see, it's now performing roughly similar to `zipA`. This would be my way of writing a recursive zip that supports TCO, in JavaScript.
Alright, at least you aren't one of those customer support bots that are so prevalent these days.
[removed]
No, the data structure is going to be different because they're different technologies. I'd question why you're doing this unless a relational DB is fundamentally unsuited for the application (which if it's working means it probably isn't) you probably shouldn't switch to a document DB system.
imho: jobs = react devexp = vue
That's really all the script does, but automatically. 
Yes,the zipD was wrong,have edited the post. So the key point is reference.If I do it in FP way,always create a new one to replace the old one which spending too much resource to do.zipF perform really close to zipA,in a recursive way,nice.
\o/
Looks great, responds pretty well on iOS.
Very well done
It’s a pretty common thing to know if you’ve studied CS, so maybe these people have also. I knew the answer, but not the exact representation by memory. It’s like any knowledge though, not everyone can know everything
Glad that there's an open source animation library with SVG morph (looking at you, Greensock). 
Babel isn't just for ES6. Through plugins, you can enable lots of more "out-there" syntax features that may not have even reached stage-0 yet, or write your own plugins to perform arbitrary transformations. Most people do use it for targeting downlevel support for ES6+ features, but that's certainly not its only use.
&gt; Does dependency injection qualify as polymorphism? DI can use polymorphism, but it isn't required to. For example: // Without DI class User { constructor() { this._storage = new SessionStorage('SESSION_ID'); } // ... } This is bad. The user class constructs its own dependencies, which means user is responsible for the dependencies of its dependency -- such as the session ID. // With DI class User { constructor(storage) { this._storage = storage; } // ... } storage = new SessionStorage('SESSION_ID'); user = new User(storage); Now user doesn't need to know how to construct its dependencies. It just gets a fully formed, ready to use dependency. This is DI, but no polymorphism was used.
Wow I'm sitting on the toilet thinking the same thing. Looks promising at a glance, but I have a lot of questions before I would feel comfortable switching from GSAP.
But DI has nothing to do with the actual polymorphism here... `makeSpeak(@Inject Animal animal) // run time reflection based DI` vs `makeSpeak(new Cat())` vs `makeSpeak(ServiceLocation.locate(Cat.class))` vs `makeSpeak(new Animal() { @Override speak() {} }) ` vs `makeSpeak((Animal) new Object()) // runtime error` are all just ways to provide arguments to a method that accepts polymorphic instances. Like, you wouldn't say that instantiating an anonymous class or casting to an interface is a form of polymorphism any more than DI. It's true that DI helps build applications that leverage polymorphism, but DI isn't polymorphic in itself.
Most people saying this haven't actually built an app in js lately, or haven't written any job for the last few years. JavaScript used to just be a way to add a little logic to HTML. So back in the day saying you were a JavaScript programmer was kind of like saying you were an HTML programmer. Understandably you'd be laughed at. Sit one of those people in front of a full blown angular app and, if they bother trying to understand it, they'll probably tell you they had no idea just could do that. It's the same as people who hate on any other language. 99% of the time it's sheer ignorance.
Pretty amazing, and I only tested it on my iPhone 6 :)
I'm sitting in my office chair with a shitload of typescript errors as soon as I import anything from it. Urg.
Yeah sorry I fucked up some of the exported defs, I’ll be releasing a fix today
Noice. Looking forward to hammering away at it!
As a fullstack Developer, working on a ridiculous amount of project, with a lot of developers ( colegues ) , spanning different programming languages, I noticed a discrepancy in front end developers and backend devs/ full stack devs. I worked on the web since jq was the most awesome thing ever, a time when you used to build what you needed, then I worked with backbone, knockout, angular js, ember and now work with all the new 3 popular js frameworks ( angular, react and vue), on the backend I worked with php, c# and node. The biggest problem with new mostly self thought front end developers is the mentality , they pick up some skills in a specific framework ( react / vue / angular ) build a basic crud and call it a day. I’m not saying it’s this is not good, but this is step 0, in a very very long way ... In order to become a true developer, you need curiosity, you learned react let’s say, look into redux, look into preact, after start looking into angular , see how they do it ... after start with some node, get a grasp on how backend really works ... But most importantly find a mentor, someone that can explain stuff to you why , and when you should do something. A few years ago I went to a conference , and met a lot of young eager devs preaching the awesomeness of angular js. I went to talk to them and ask them what makes angular so awesome , they’re response was, check the internet, everybody says that! Fast forward to last month I was at the same conference , the exact same thing happened , but with react. TLDR; find a mentor, crud apps and tutorials are step 0, understand the problems , understand what each fw actually resolves , get some courses on algorithms , never, and I mean never do something like a “new SingletonAbstractFactory” :) 
Also on Android.
I’ll make the square bigger thanks for the heads up
Only Chrome for now, it seems. From the use of `customElements`. :/
It would be really helpful for when forms are filled in, certain parts of the UI change. And when the modal changes, the UI updates.
Vuex is just like Redux just for Vue. Both libraries handle local state just fine.
Every time this question has been asked over the last ~7 years, the most upvoted answer is "they probably haven't built anything with modern JavaScript" or "they don't know JavaScript." It's a real ego-boosting answer that completely dismisses actual concerns behind the sentiment. Those reasons include, but are not limited to: * JavaScript has historically been a bit of a technological joke. The fact it was written is 10 days is not because of some technical prowess, but because of the real lack of foresight and technical requirements, and the reality that it _needed_ to get out that fast, or it would not succeed. *All* of us know what happens when software is rushed. It sucks! * JavaScript took off because it has been, and mostly remains, the only option for serious interactive content on a website. Again, this is not because of any technical or other advantage the language has historically had. * The lack of foresight from the early days, and the stagnated development between then and ES5, continued to introduce flawed concepts. * These technical mistakes haunt us to this very day. Because browsers are the VMs running JavaScript, and we cannot control what browser a user uses, _and_ because we cannot expect every piece of JavaScript on every website to be updated, browsers _must_ support the oldest versions of JavaScript all the way through to the newest. For developers working with other languages, this is madness; it's beyond reasonable. * To further confound developers who use other languages, it is hard to imagine why a developer would choose to use JavaScript on the server side. Why bother with all that bad crap that you don't need? * JavaScript has some seriously questionable parts that a lot of developers use in different ways, and it leaves the software prone to defects. Consider how `this` works, and what it means in different contexts. * JavaScript has a lot of evangelistic supporters. These developers are no better than those outright dismissing the language. JavaScript is far from perfect, and antagonizing other software developers with opinions never wins friends. * No language is perfect, but few languages have books published called "The Good Parts" and "The Bad Parts." JavaScript is a study both in how to use the language, and how not to use the language, more so than any other language I've used. Now, getting into more modern JavaScript, there has recently been a rise in dissidents who are proponents of JavaScript! Generally, a developer should remain open to the idea that one tool isn't the tool for everything. While we all knew it before, only recently have people been coming out against using JavaScript for desktop applications. It's slow, it uses a ton of resources, it doesn't make sense from other technical points. Take battery usage for example. Why distribute a JavaScript VM that interprets code packaged into it to execute what are essentially websites, when you can write it in a language that compiles once and uses OS-native UI and device controls. These are just some points to consider when someone rags on JavaScript. It often is not down to ignorance. /u/laur3d has some excellent points to consider as well.
It does all that, yes, but in a arguably inferior way. Babel is and always will be the better transpiler, due to its community support, close affiliation to the specs comittee and wide spread support. Either way, it is a solved issue now on both sides, Typescript does not cause conflicts any longer. Typescript can check types, Babel can transpile.
If you want an opinionated framework, I'd go with Hapi.js which is very well thought. But I'm one of those hands-on types ; so I usually never go with opinionated back-ends (at least in Nodejs because we don't get Rails). Instead of Express, I'd consider Koa.js, which feels more modern and takes away a lot of pains that you'd encounter with Express.
They need to be on the same host and same port. For example if you have http://localhost:8080 as the main page and http://localhost:9090/login as the login page they can’t access each other’s session storage 
TS can compile to anything from ES3 to ESNext (stage 3+)
&gt; no one would use TypeScript otherwise That has been a pain point since day one and has caused countless of issue in the past. It has been suggested over and over in their issue tracker. Microsoft itself has provided the babel plugin now so what are you even on about.
Java and VB
Oh ok, so Redux for React like Vuex for Vue. Vue itself seems pretty simple and straight forward, but adding Vuex seems to add another layer of complexity.
Can you explain why I wouldn't need it?
Hey man can you do me a favour? I've just made a test project and I'm not getting any errors. Can you send me a screenshot or a dump of your errors please?
Thank you for both those links. The market one is very helpful. I may stick with local state from what I've read up until now. I feel Vue would be a better fit.
I heard a quote once, "If Java was the only typed language I knew, I'd be a Ruby Dev too" I didn't really gain an appreciation for types until I started learning scala
No included SVG morph, but there is a tutorial to build animations with an open source library of your choice https://popmotion.io/learn/morph-svg/
JSON has no date format. .NET is doing some weirdness. Instead of doing that weirdness, convert the date to an ISO 8601 formatted string. Such a string is portable to many languages and does not require a regex for parsing.
So I'm very partial to Vue, but I'm opinionated that way. I find it does everything you need and is just far more user friendly. But that's just my opionion.
I'm not even really sure what this means. Care to elaborate?
Hi /u/IamPerk, you should check out /r/LearnJavascript too. People in here are typically doing JavaScript development professionally, and thus, don't engage much with these types of posts, but you might get a better response on /r/LearnJavascript
Yeah I tried posting this over at /r/maplestory and it got removed. I figure I'll post the imgur links in the RZ thread here: https://i.imgur.com/ypN6MLd.png https://i.imgur.com/GRm5s2N.png https://i.imgur.com/1R00aBV.png https://i.imgur.com/ByOzscY.png https://i.imgur.com/eQuGKri.png https://i.imgur.com/VZ3hNjR.png https://i.imgur.com/QcRSIBk.png https://i.imgur.com/1ljDrwK.png https://i.imgur.com/C9vyl8y.png https://i.imgur.com/IZli0Uk.png https://i.imgur.com/4SyYrSJ.png
There are plenty of free APIs you can use for learning - https://github.com/toddmotto/public-apis/
Asking someone to do programming work for you without compensation is kind of a dick move man. If it was the first half of the post you'd probably be fine but taking it further and asking them to change it to suit your needs isn't appreciated. 
Sign up for http://javascriptweekly.com/. They'll usually have a few interesting intros each week.
[removed]
I'd be interested in taking a look at the code. Where did you get the graphic assets and what's the story with their license?
&gt; the complexity of redux to render something fairly simple Well there's his problem - Redux doesn't render anything. It's a data store.
That's weird. Does the normal dragging work as you'd expect? The smoothing functions aren't doing anything complicated.
As someone with a lot of front end experience and more recently a focus on Node, I have somewhat similar feelings in terms of issues with SPAs. Of course, I do think that Rails is a step back. I guess in the end the working relationship is more important than the particular technology to some degree. One alternative I will throw out there might be something like Vue.js which could be a bit simpler. One aspect of this is, is there some part of the UI that really benefits from being on the client, or actually needs to be? Maybe that part can stay as a mini SPA or component. For stuff that needs to be interactive on the client, a few modules and custom classes in ES6 have worked fine for me without the complex lifecycle stuff. The reason you need the complexity of things like redux is to deal with a lot of moving parts on the page at the same time. If it's not really a requirement, then I believe in simplifying pages to do one thing at a time. Besides my big client-side interactive graph with modules and classes that just have a one-time render and handle a few mouse events, I am doing the other part of my latest front end as a server-side-rendered Node app and keeping it simple with one thing happening per link/page at a time. The cool thing is it's HTTP/2 so I can push the pages ahead of time which makes them appear instantly when the user clicks them. It is nice to be able to share tooling and code between the front and back end when it makes sense.
I know this is not a popular opinion given all the fanboyism here, but if your app is so simple that rails+turbolinks suffice, maybe react+redux is in fact overkill. But if you do have significant client side logic, he either needs to propose something better than slapping jquery on the page, or get on the react/redux train. At the end of the day, you as a team need to figure out what's the best tool for the job, not be arguing about what's more comfortable for one person at the expense of others ability to maintain the code they own. 
Have you made components using bootstrap? Post a link here; I'll add them.
I don’t believe the author has actually visited healthcare.gov even once or he’d realize that our government beat him to it at a cost of only $1.7 billion.
I had it working in IE 10, just the CSS3D, no WebGL, and no nested CSS3D, just flat.
I can sympathise with your co-worker - I'm an ex rails/ASP.net dev and for many years I resisted SPAs. I didn't see the point of them - it all just looked like over engineering. Then I landed a job where the front end is an SPA. And now I get it 😐 So my initial resistance was that I felt I already knew how to do fronted using server side rendering - the SPA revolution threatened to make my existing knowledge obselete. On a subconscious level I formed a bunch of negative opinions and these manifested themselves by me forming opinions similar to your coworker. That is when you start to resist change. They are more complicated, but the benefits far outweigh the problems; * faster * more scalable * more maintainable These are problems that you don't realise you have until it's too late.
Helpful, thank you; fixed!
Even before the net neutrality vote my answer would have been: Easy: don't use one, ever. Stop wasting your visitors' bandwidth; which, I all-but-guarantee, 9-10ths of the framework is unused by your website, and therefore is pure bloat. Bloat some internet customers have _always_ had to pay for. Bloat that kills mobile batteries. Toss that garbage into the garbage fire it causes.
I've got a beater android (xcover 3) and it's butter smooth until 3D. Still cool after that. Looking forward to protoing this during christmas break!
I love [Feross'](https://github.com/feross) work. This talk seems a little below him, so I admit I'm a little disappointed. That said, I'm sure it's nice as a speaker to have fun presentations like this from time to time.
Yeah, in fact every example on the site for dragging that I could fine feels good except the 2nd one here: https://popmotion.io/learn/input-smoothing/ It could be outside of the libraries control. I can't promise there's no external factors as the mouse I'm using is quite old.
Okay, I'm still slightly confused by this one. I know that the Unary operator ('+' plus sign) converts to string - like: '1'+1 //returns '11' But I didn't realize that it would convert ! or [] to a numerical value. Is it that ! is converted to false and [] is converted to true - and that the false is then converted 0 and the true to 1?? 
Not answer to your question but.. Care to describe a bit your usecase? This is a first to me, someone switching from RDBMS to NoSQL.
https://github.com/jdorfman/awesome-json-datasets https://github.com/burningtree/awesome-json https://github.com/abhishekbanthia/Public-APIs
But is it web scale?
If redux is too complicated for your use-case, then for christ sake don't use redux. It's that simple.
Very interesting. I used to play Maple Story alot aswell. Too bad I'm not that experienced in Javascript yet, but I'd love to see the progress of this project and follow the git repo!
Yeah because I've got nginx in front of that. Nginx is synonymous with web scale brah
You need at least two nginxs to achieve true scaling though. Obviously an amateur. Come back when you're services are micro.
That's a really hard question without being familiar with the project. We don't know which one is the right tool for it. We can't know. Assuming he's a reasonable person then you should consider that your position may not be correct, if he's not then you can't convince him anyways. What reasons does he give for not wanting to switch?
It's an easy drop in when people who are new to React see all of the different CSS modules and CSS-in-JS solutions and don't know what's best, so they just say "Fuck it, bootstrap is good enough and I don't have to learn anything new to use it".
Yeah. That's my first thought too. If you don't actually need it then don't use it. But given that they are using redux, there must be SOME state that has to be managed -- you still need a solution to that (maybe it's only component-local state and you'll be fine just slapping a bunch of jquery widgets). The benefit of React is not that it can be used to make a SPA (that seems like an implementation detail to me), but that it helps simplify state management (or at least push the concerns off to something whose sole purpose is to manage state). That said, if redux being too complicated is the issue, but you still want a state management system, then take a look at mobx. There is almost no boilerplate and it _just works_.
Haven't tested it elsewhere but as far as I know the code is able to crash the drivers either through a bug with the drivers or a bug with the IDE, we were working with. Considering the IDE is pretty shit (it's used for educating 10 - 12 year olds in coding) it's probably the IDE. 
Maybe he’d be happier with Vue.js. Simpler in some ways than React+Redux.
Your startup will fail if you see the front end as an afterthought to be bolted onto the real app. To your customers, the UI is the product.
yeah, it seams that [react-bootstrap](https://react-bootstrap.github.io) is not as popular as it probably should be for the same "I don't have to learn anything new to use it" reason. Although API is very similar, but not a 1:1 match. Have you used react-bootstrap?
I apologise to your battery
vue + vuex is a good deal simpler than redux. at least on frist approach. in combination with frameworks like next.js or nuxt.js, here is what their respective stores look like: redux: https://github.com/zeit/next.js/blob/canary/examples/with-redux/store.js case actionTypes.ADD: return Object.assign({}, state, { count: state.count + 1 }) vuex: https://github.com/nuxt/nuxt.js/blob/dev/examples/vuex-persistedstate/store/index.js `increment: (state) =&gt; state.counter++` 
/r/AskProgramming instead? This is not JS or FE related 
I'm not passing that as an argument to anything express related.. I'm just passing it to my own function so that the `io` object I create can be used anything in my application. doing something like `global.io = io` is essentially the same thing
Could do it using css. Say your video is 500px tall and everything is inside an element with class `container` : .container { transform: translate3d(0, -500px, 0); transition: transform 500ms linear; } .container.pushed { transform: translate3d(0, 0, 0); } Then use javascript to toggle the `pushed` class when you want to show the video. Tweak until it looks like you want.
Sounds like you guys are not actually a team. Instead you have a bunch of people trying to push what is familiar to themselves. You should work that out first
Thank you for that comment. It's always nice to see that frustration while learning programming is normal.
[removed]
[removed]
[removed]
Yup, great for bloating websites and shiting code that noobs don't understand. Nice advice for a starter.
/r/learnjavascript
https://swapi.co is an open star wars api
&gt; If you do not center your life around those aha moments, programming can, and will, burn you out. This is really well put. A lot better than the usual "if you don't like it you aren't cut out for it."
At the end of the day, I'd consider what makes the best experience for your users. SPAs can beat a server rendered page but take a lot of tooling and tuning to do correctly. If your application is primarily read only, it may actually be a better experienced to be server rendered.
The communities I program in offer free help all the time coding things they're experts in, it's called collaboration. Something people are especially willing to do when making examples to promote their framework, something i'm assuming you don't really know much about.
NES has too many dependencies what with needing `Outlet`, `Electricity` and `Controller`. This will really hurt long term maintainability. You'd better just scrap the entire thing or rewrite it in go/rust/trending.
Well, I'm pretty sure it's clear that I don't recommend it unless and until he knows what he's doing yet decides to keep doing it anyway. Javascript is a necessary evil to begin with; I look at jQuery as an anti-arthritic. 
Welcome to zombo.com
Not so necessary now. ES6 has helped and frameworks such as backbone help with dom manipulation.
Learning to program is a great experance. Did you get into JS for the web front end or just to learn to program? I would recomend you learn at least one other language and not get hyper focused on one stack. Pick up something like Python, C, C#, or anything else really. It will help you a ton when you return to JS.
 &lt;script&gt; document.getElementById("finishClass").onclick = function() { document.getElementById("message").innerHTML = "Congratulations!"; }; &lt;/script&gt;
This is an amazing idea. Maplestory was my first mmo and I have a lot of nostalgic feelings for it. Pus, I'm still in love with browser-based games. I'd love to look at your code.
&gt; "Why is it called a Ternary expression, what does the word “Ternary” indicate?" If you ask me that I'm walking out of your interview.
Hey /r/javascript folks! This is my first OSS project and I would absolutely love your feedback! HN discussion: https://news.ycombinator.com/item?id=15934289
 I prefer to avoid risking giving bad ideas to beginner by mentioning "trendy cool stuffs". I don't know, it didn't take me much time to bury DOM function in class even if it didn't bother me much. I often end up with stuff like XManager.getXObj(id).method(...); It's a necessary evil to keep the readability otherwise I would have to spend my time with docs, and that doesn't strike me as simpler than DOM stuff. Honestly JQuery syntax gives me a real cancer.
+[] is 0 !+[] is !0 is true true + true is 2 true + 2 is 3 I don’t know why JavaScript works this way, but it is considered standard behavior.
You didn't give the full code. Save the code below into a file called message.html by copying it into a text editor (Notepad on Windows TextEdit on Mac) Make sure to save the file as message.html (sometimes notepad will try to save it as message.html.txt we don't want the .txt so check the box that says save as all file types) &lt;button id="el"&gt;Click here&lt;/button&gt; &lt;p id="message"&gt;&lt;/p&gt; &lt;script&gt; document.getElementById("el").onclick = function(){ document.getElementById("message").innerHTML = "I'm so proud of you, congratulations!" } &lt;/script&gt;
You can do anything with zombocom.
[ReqRes](https://reqres.in) is great.
And a plan. When your startup is making major strategic decisions on the basis of "ask some dudes on Reddit", you have a problem.
&gt; offer free help Except you're *demanding* free help, which is totally different.
Redux shouldn't be used for every project. That is your problem. The purpose of Redux is for allowing a large application to be scalable and less prone to bug creation. [The creator of Redux even mentions this.](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) There are plenty of other SPA solutions that are much easier. Personally, I've found Vuex to be an easy to learn state management for a Vue application.
I think he's referring to all of the boilerplate generally need to connect an action to an actual view. action =&gt; reducer =&gt; container =&gt; components (and perhaps even more)
This is working code - if you put it in a card and your Boyf cuts and pastes it into something that can run code (like the console in his browser) and presses enter it will work. There are a few places here where you can personalise this with your own information - wherever you can do that I've let you know by putting a comment starting and ending with '///' after the line of code - be sure to take that comment out before you give him the card! Here's the code: ``` const course = ['module1', 'module2', 'module3']; ///name of course modules - you can leave this bit out if it's not straightforward, it will still be clear what's happening but it won't be working code anymore/// const girlfriend = { name: 'your_name', ///put your name here/// loveForBoyfriend: 712 ///a random high number/// } const boyfriend = { name: 'his_name', ///put his name here/// courseModulesDone: 3 ///number of course modules, needs to match number of different 'things' in const course above/// } const myBoyfriendIsAwesome = function (girlfriend, boyfriend) { if (boyfriend.courseModulesDone === course.length) { boyfriend.courseComplete = true; girlfriend.loveForBoyfriend += 100; girlfriend.feelings = ['pride', 'joy', 'congratulations'] ///or whatever you want/// } return { girlfriend, boyfriend }; }; console.log(myBoyfriendIsAwesome(girlfriend, boyfriend)); ``` When you run this code it will return this: ``` { girlfriend: { name: 'your_name', loveForBoyfriend: 812, ///note has increased by 100 :) /// feelings: ['pride', 'joy', 'congratulations'] }, boyfriend: { name: 'his_name', courseModulesDone: 3, courseComplete: true } } ``` [Here is a picture of it looking more 'codey'](https://imgur.com/gallery/Mrazp) and in fact it is easier to read this way I think - cos I'm rubbish at imgur the code snippets are in the wrong order (output is first, and the code you want for the card is second) Hope that helps! Feel free to PM me if you want any more help / info
I always recommend people learn Vue before React. It makes concepts easier to grasp after seeing it with a common Vuex architecture.
Sure, but Redux is not a requirement for building an SPA, even when using React. You can get away just fine using React component state, mobx, or any other state management system. Saying "front end development sucks because using Redux to render simple applications is too complicated" is like saying "agriculture sucks because using genetic engineering to pot some houseplants is too complicated".
Ugh. My current position came from someone with this mentality. Entire project is built on Java and JSF (Java's Stupid Frontend). JSF is literally the worst framework to ever be built. Seriously, the "templating" pages or XHTML. YOU CAN'T EVEN USE &amp;&amp; WITHOUT IT ERRORING. This is a site that millions of people use, and I got brought on to build an Angular frontend, because having a server render every single aspect of every page and do all pieces of logic is really, really, really draining on resources. I don't understand why people wouldn't want to make the client's computer do all that for them.
Another great way to do this is just to mock your own. Grab the newest local (not chrome app version) of Postman. It's free, very robust, and now comes with the ability to mock apis instead of only testing them. 
First, it's really hard to make any sort of arguments without know your situation. I've been leading development for a startup and made the decision not to use Turbolinks for our app. We went with something similar to what you seem to be using React, Redux, and Typescript. We then use rails as an API server. For our circumstances, I wouldn't change a thing. We've certainly had our pain points, but overall I think we're in a much better place. I still have two huge concerns with Turbolinks: 1. It encourages the use of a lot of Rails "magic" and take shortcuts that work well with a server-coupled web app. It can be incredibly difficult to work out of the "bog of magic" as we want to implement a true API to support web clients and true mobile clients. 2. If you have to do any non-trivial client side JS, it can become a huge mess to manage the relationship. For us, we had too many custom features to justify the use of Turbolinks. 3. Bonus. Web App Manifests are helping SPAs act like true mobile apps. I'm not aware of the extent that Turbolinks can leverage Web App manifests. ----- I just noticed that you're also using `react-native`. I wouldn't even second guess skipping Turbolinks. You might make things easy for your web app, but you're going to need to do the work with `react-native` anyways. Either |== SPA Rails == Consistent API ==| |== iOS App |== Android App 
My rule of thumb is: if your users rely heavily on the back button (like reddit for example) then you have a web site, and shouldn't go SPA, but if they don't, you may have a web app. I also think his BS detector is working perfectly if he thinks React/Redux is too complicated, it is. You should introduce him to Vue.js
Irrelevant to the current talk, but tangential to your point: I'm not from a western country but I hear that organizers are significantly pressured by hate mobs on the internet to ensure a very diverse set of racial and other identities for all speakers at tech conferences. I personally find it quite disgusting that one's ethnicity or gender is a criteria for anything, and it's shocking to see this happen in parts of the world that have led the way on human rights and equality for so long. Many of my friends in silicon valley are disturbed by this trend, particularly after Mr. Damore was fired. 
It was your self-deprecating attitude that I was referring to. Most programmers refer to documentation easily found online. And it's not even a CS only thing or after Google thing, many professions had/have reference books. You're most likely not dumb, just unaware where to look. But if you keep telling yourself that you're, well that might end up being a self-fulfilling prophecy. 
Hi! I'm the organizer of that conference. This was a lighthearted talk to close the morning session, I encourage you to have a look at the other talks to have a complete opinion! https://marmelab.com/blog/2017/12/11/minutes-of-dotjs-2017.html
SPA is really an investment. It will make your backend design more service driven (and have an open API). Some of gains are on PWA and reduce band costs (by caching frontend). But not everyone or every project needs to be that, and on business aspect, mainly for startups, faster you ship your Minimum viable product, earlier is the profit.
&gt; "trendy cool stuffs" jQuery is 11 years old. &gt; bury DOM function in class What's providing your class functionality, Prototype? Just curious because I am honestly out of date. &gt; jQuery syntax ... cancer Yeah, it's old and rusty. But it's everywhere, and I wasn't aware of /u/camelBasketCase 's information... maybe it's just not necessary now... except when you're working with something that already depends on it. Thing is, it's everywhere, and in the real world you're going to end up working with it. But I admit I'm probably outdated; I'm from a world where you have to use something like Prototype.js to unlock the language's undocumented OOP (still true?), which honestly turned me off taking JS seriously (hence "infuriating garbage heap" or whatever I called it).
Yeah, maybe I'm out of the loop. Call me a straggler, but I still remember Javascript as a bunch of warring zombie voodoo golems. It's hard to imagine anything as shite as that situation used to be, ever truly turning around. Like, I just assume it's as bad under the hood as PHP... how accurate would you say that is from 1-10? I'm fine being pleasantly surprised.
Vue is way more complicated than React, in my opinion. It feels like they tried to stuff a million features from Angular and React into one framework, and there are too many ways to do the same thing.
I agree that the whole redux rigamarole is a super pain in the ass and overkill for about 90% of web apps. Have a look into something more lightweight and less irritating like Vue and Vuex
Why?
Interesting! I think that argument order is fixed by destructuring, but this is still very useful
[Here's a quick CodePen.](https://codepen.io/ryanvazquez/full/xpwOaz/)
why, reddit of course! https://www.reddit.com/r/javascript.json
I dunno... I'm working at a company with a massive angular 1.x app that's a huge mess. It pretty much fell into every bad practice that angularjs encourages, and now it's insanely difficult to maintain. It's too big to rewrite it without spending way more money than the business wants, but every feature added is just increasing the tech debt. There are definitely downsides to SPAs.
It's a shortcut, you know, nobody blames Redux for frontend ecosystem being complicated.
2 way binding can interfere with other concerns like state management and form validation. Explicitly breaking up the flow into 1 way with events allows better integration with other systems. 2 way binding acts like a black box and makes it harder to integrate with other parts of an app.
&gt; My rule of thumb is: if your users rely heavily on the back button (like reddit for example) then you have a web site, and shouldn't go SPA, but if they don't, you may have a web app. Why is that?
To be fair, the web/JavaScript documentation provided by Google and Microsoft include information on both standards as well as vendor-specific proprietary details (which makes sense). Personally, I've always been a fan of [Mozilla's MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript) which seem to orbit closely around standards. You almost have to go out of your way to find Firefox-specific stuff there.
You could also statically render your app with something like gatsby, jekyll, or similar, and use small, loosely coupled FaaS/PaaS services for your backend. https://jamstack.org/
&gt; Example of finding element by id &gt; Uses .queryselector() Have you considered .getElementById() ?
What about "Could you maybe" is an implicit or explicit demand. 
Argument order is just an example, another example would be stopping [Mars Climate Orbiter](https://en.wikipedia.org/wiki/Mars_Climate_Orbiter) from crashing into Mars because of accidentally treating metric values as imperial. With opaque types this would have been impossible :)
You can do anything badly, doesn't necessarily have anything to do with the tools.
Everyone may have a different opinion about this, but heres my take. Sounds to me like this guy is frustrated for any number of reasons and just wants to take a step back to something he is familiar with. Can he really argue that Ruby on rails is less complicated or complex than redux? Have you actually looked at the redux source? My argument to continue with the SPA is that it is nothing more than a client for your API, just as a mobile app would be. As soon as you start coupling your server code to your client code, the tendency to take shortcuts will increase, and it will become harder and dirtier to integrate other API consumers, such as your ios app and android app. If redux is hard, take the time, put in the hours, and learn it. If neither of you want to do that, just use regular react state. It works fine. Its the default! There are times when redux can be overkill. Finally, I say directly to you, if YOU want to continue with redux or some other technology, work your ass off. don't wait for your company to give you eight hours in a day to work on it. Work hard, work often, experiment, ask questions on reddit, slack, elsewhere. If you think that rails is a step in the wrong direction, prove that guy wrong by creating your proof of concept. Do you want to work at a rails shop with rails developers? 
The main problem is not front-end per se, but running system rules in the browser instead of in the server and having end-points that return JSON as "models" so that you need to write JavaScript in order to build your domain objects in the browser. Don't return models, return a presentational state. Don't build the domain model in the browser, build it in your server.
That was exactly my plan! My end goal is to get into information security but I have very little skills in that area. I know basic HTML and barely any CSS but I figured I get my feet wet in JavaScript and start pursuing Python after that course. Basically see how deep this rabbit hole will take me. 
Doesn't even ask me to subscribe to their newsletter when I move the curser off the page (presumably to close the tab). 
If you're using uWebSocket (uws module), you're definitely going to be short on CPU then on Network then, far to the bottom, on RAM. I've seen 200.000 connections on a server and CPU goes 100% (because of socket.io) at some point before everything else.
Because if NaN turned out to be 9, i don't mind, i don't mind.
I said React/Redux, which has an excessive amount of plumbing just to wire everything up. With Vue you can use what you need and everything is already wired up.
Hey, sorry that my talk disappointed you. This was pretty different from my other talks in the past, that's true. I personally find that most conferences could use one or two more weird, fun talks as a break from the typical react / redux / latest framework / new ES syntax talks which all tend to be pretty similar from conference to conference. Still, I appreciate the feedback nonetheless.
I don’t know any react, otherwise I would have left some more helpful comments!
For a better apples to apples comparison, that first case could be expressed much more simply as: ``` case actionTypes.ADD: return { ...state, count: state.count + 1 } ``` 
In addition to the other good answers here, there's another very important, short answer that I think people are being too polite to point out. JavaScript is a scripting language. By definition, scripting is a single half-full jar of baby food chosen by someone else; programming is a full grocery store and a full kitchen.
Or employ something like Reselect and Redux-Thunk that abstract away a ton of boilerplate :)
They could argue that they prioritise user experience, but really a SPA is often more performant as well if you do it right.
I think your points are really good. But I want to piggyback and say that react/redux isn't that hard if you are good at javascript.
Nothing will ever be as bad as SOAP.
I always find the "simpler" argument strange when talking about React. It's like everyone forgets what life was like before React. When I first learned Angular (I'd used quite a few frameworks before that), it took around a month to learn all the proprietary stuff. Components, directives, dependency injection, digest cycle, services, template markup, etc. After that, I continued to run into gotchas for months because Angular insisted on bleeding its abstractions everywhere (I've never met a good Angular dev who hasn't read huge sections of the Angular source code). My experiences with other frameworks were not as bad, but needing weeks to learn was the norm. When I first learned React (not too long after it was released), it took one weekend (started using it to replace jQuery and Angular the following week). Coming from Angular, I kept waiting for the rest of the complexity, but it never came. I kept waiting for all the gotchas, but they simply didn't seem to exist (they do, but most bugs are very subtle). 4.5 years later, I've certainly gotten my miniscule amount of learning time back.
Yes a SPA is almost always more performant, and that’s because the client’s computer is handling the majority of the logic, which was my point. Having the server render everything doesn’t make sense on a web app that millions of users use - the majority of which are within the same time frame. Not sure why people are down voting me. It’s been proven time and again: utilizing the client’s resources is good for your server.
&gt; take a look at mobx. this would be my recommendation as well. Mobx reduces all boilerplate to 0
The etomology of a word has no context to the relevance of the task (being a JS developer). Knowning _why_ it's "ternary" and using that word instead of just "inline if" isn't important. Ask me how to use it - or where is isn't a good idea. I've been a JS developer for long enough and I didn't know this. Apparently it's about _'three'_ parts tests/then/else ... Sounds like an "if statement" to me... I guess it's kinda like asking a writer to explain how paper is made. 
I meant performant for the client.
I agree. REST is nicer, but it's still not good enough.
Angular 1.x made it easy to form bad habits. I’ve done Angular 1.6 through 5.1. Angular 2+ is great. Convince whoever that it’s worth upgrading. Angular puts out tooling to help with the migration, which will simultaneously help you resolve the technical debt
Why wouldn't you compare React/Redux to Vue/Vuex?
GP made the argument that Redux might not be needed, and instead of just ditching it, you decide to add yet more layers of framework on top of it?
As did I. It’s more performant on both sides. That was my initial point.
Agreed with both of you. I'd add that the simpler your app the less you have to win from using Redux, which may explain why the co-founder "bangs his head on the complexity of redux to render something fairly simple". The benefits become clear when the app grows in complexity. Also, for context, the gp /u/lhorie is the author of the Mithril frontend framework, and he currently works on a React-based one for Uber.
Very interesting read, thanks!
Maybe the problem isn't frontend, but that you're trying to stuff so many hip libraries into it? Try just writing vanilla JS, or vanilla react, and watch what happens
It started a bit slow. When the window started following the mouse, it started to become awesome. If you do this talk again, show less code in the beginning and more of the code in the advanced "annoyances". By the end, I liked the talks a lot. Great presentation, porn advertisers will love it. On a side note: I really liked the way you implemented the window following the mouse. Is the flicker when idling only visible in the video (frame rate stuff?, I wont visit that website to test it, sorry). If not you could maybe get rid of that by just resizing a div on the page with a move handler and only start resizing the window, when you loose the mouse. 
Right. But young frameworks leave you in a lot of poor places as well so it's not entirely on folks for following standards that change. But as the SPAs mature they have better practices these days to actual develop front-end more properly.
Oops! Meant `react-redux` not `reselect`. Also, `redux-thunk` is very literally [14 lines of code](https://github.com/gaearon/redux-thunk/blob/master/src/index.js). Both of these modules _greatly_ reduce the boilerplate that a lot of devs complain about in regards to integrating React with Redux.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [gaearon/redux-thunk/.../**index.js** (master → 4f96ec0)](https://github.com/gaearon/redux-thunk/blob/4f96ec0239453623adde857b7e7ad8c4f2897bf1/src/index.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
&gt; front-end performance Sorry, but the amount of code you need to send across the wire to make an SPA function properly clobbers performance compared to just having only the fully rendered DOM shipped across the wire, and maybe a sprinkling of rich UI interactivity. I've worked on two enterprise SPAs and initial page loads are between 3 and 5MB, and the amount of time we spend on state management is appalling. I view SPAs as massive performance dogs that you have to be willing to say "Ok, this is going to suck for people on mobile" and now I have to manage state and navigation history myself instead of keeping my app stateless and letting the browser do the navigation history for me, but at least I get...... fancy page transitions? I really dislike SPAs unless you're building an *actual* application like Spotify.
The RESTful Pokemon API is great for this. https://pokeapi.co/ It's a realistic enough example of what real APIs look like, it has a good set of features and it's properly documented.
You should check out Rich Hickies' talk on simple vs. easy. Turbolinks might be easy but Redux is simple. 
To expand on this a little bit, what Redux really brings to the table is a highly-organized state management system that is super easy to test. It's boilerplatey by design, which I think some people really struggle with. For a smaller app, MobX and RxJS both offer super flexible state management with minimal boilerplate.
I didn't mean to imply anything about REST with that statement! :D
No sense in being evangelical about it. (That's directed at your co-worker.) Why change everything now?
Yeah but ya know, React's just the view layer. You can make an almighty mess building up the rest of it :D
[Sometimes Google's ***products*** pretend other browsers don't exist.](https://i.imgur.com/cl8hp9z.png) 
I personally really dislike Redux and would probably feel the way your coworker feels if my first foray into SPAs forced me to use Redux. Redux, for me, has the effect of making minor tasks feel burdensome. Changing one minor thing on the page requires implementing the entire family of behaviors from defining probably at least a substore, an action, a reducer, a mapStateToProps conversion, etc. It feels very boilerplate-y and the "but you get time travel for free" argument is a bonus but not something we ever really needed. Also, if a particular application's requirements could be met comfortably, with clean and maintainable code, via Rails+Turbolinks, I would absolutely recommend that route over a heavily tooled SPA. Don't make things more complicated than they need to be. The benefits of the tooling you're arguing for are not really things that Rails+Turbolinks doesn't already do (it's performant, it's localizable, it's accessible, you can still create hybrid web/native apps reusing html views, it provides server-side rendering inherently, etc etc)
I think you should take the best parts from both worlds. Pure SPA has long initial load but page transition is instant, on the other hand, you have pure SSR where page transition is slow, but that is reduced by PJAX (Turbolinks in Rails case). I think the biggest advantage of these classic SSR applications is default cURL support, which improves SEO as well as other things. I also liked this "per page" separation which gets much harder to separate with pure React/Redux, most of the time, you need to clean/reset state by yourself. So I found ideal solution that takes the best out of both worlds; SSR/SPA implemenation Next.js, or in case of Vue, Nuxt.js. It basically loads only things needed for that "page", and for simple applications you don't even need to use Redux, you just keep state in "pages" containers. For these that are resistant to changes just like MetalMikey666 was, Next.js is very minimalistic implementation that simplifies everything, and gives you huge benefits in development.
&gt; I'm positive I could write AT LEAST a book on "The bad parts" of several other languages I think the point of this statement was that, even though other languages do have problems, they're not big enough that people had considered writing books about it.
The argument wasn't about boilerplate; it was about complexity. By adding another layer on top of Redux, all you're doing is increasing complexity - which I personally find hard to justify when considering the possibility that Redux wasn't necessary to begin with.
That's a great suggestion, will give it a shot.
&gt; Then wouldn't a more accurate comparison be React/Redux vs. Vue/Vuex? There's quite a bit of plumbing to set up for Vuex. Thats fair, but I don't agree with the plumbing to set up vuex, its very simple. https://vuex.vuejs.org/en/getting-started.html &gt; I would argue that React has a significantly simpler API than Vue, but Vuex only has a slightly simpler API than Redux. Thats fair too, but I find reacts lack of functionality that makes it much more difficult. Mixing js/html/css into some unreadable mess. In vue its just templates, js, and scoped css, makes it so easy to use. But combining the two is where it gets out of control in my opinion. Its probably the architecture of react and redux that causes this, with the data flow, the immutability and diffing. In vue/vuex its just 'reactive' data that's plugged directly into the vdom and everything just gets easier, in my opinion.
You can make it at least 15% more annoying by adding [Page Visibility and Speech Synthesis](http://blog.frankmtaylor.com/2014/03/07/page-visibility-and-speech-synthesis-how-to-make-web-pages-sound-needy/)
That's true although just because best practices aren't there doesn't absolve you of responsibility. Its down to the team to try and find a system that works as well as possible. It's also important to factor in technical debt especially when you're adopting a young technology without many standards/ best practices. This is also a problem that is more likely to affect something like Angular which is a true framework than react or vue which are just view libraries. Early adopters will always come unstuck if they don't at least allow for the possibility that things could get messy and have a plan to work through those problems when they arise (or revisit them at a less critical time in development). Leaving it to become even more of a mess and then saying that frameworks aren't all they made out to be because your codebase is a mess seems to prove my initial statement. No-one likes budgeting for tech debt, in time or money, but its lack indicates a management problem, not a technology problem imo.
No one wrote a book on the bad parts of JS either, it's a section in the appendix of "JavaScript, the good parts"
But `react-redux` and `redux-thunk` (or `-saga`) are pretty much a given for any non-trival React/Redux app anyway. When people complain about Redux boilerplate, the presence of these things is assumed - their grievances are not to do with manual React integration or coming up with their own way to dispatch async actions...
Huh surprised to see a Facebook thing being downvoted here. lol
There is a good reason why Google totally rewrote Angular for v2+
Also worth pointing out that if redux is too complex and the state is simple you can just not use redux? I know react/redux are often used together but they are separate libraries. You can easily build apps with only react if you want to. I'd also argue state management isn't even reacts purpose (although state is obviously an important piece of that puzzle), if you need a state management solution then you should look for one. That doesn't mean you have to use react.
damn that's awesome, I've actually looked in Mithril and liked the look of it. But would need to use it with JSX because I can't live without JSX now
I come from a C++ background so I'm familiar with other datatypes, I was confused as to what problems you've run into with JS. Internally JS uses a double to represent numbers, which is a fairly common data type in all languages. PHP doesn't use true ints either, internally they use longs to represent boolean and integer values. In all my years of writing javascript this has literally never once been an issue. It's true that other scripting languages (PHP, python etc.) will internally represent ints differently than floats, but as soon as you do an operation (like division) that changes an int to a float the internal type is changed automatically. Additionally, mysql, or any database I've used will automatically convert floats to ints if necessary. I'm just curious if these are problems you've run into in practice, or if your just talking about theory. Either way this seems like a rather uncommon, *super* edge case specific issue you're talking about.
You totally can use it with JSX :-) `/** @jsx m */` and you're good to go. Mithril also supports arrays as fragments, but I haven't looked at how to adapt the new `&lt;&gt; &lt;/&gt;` syntax to Mithril.
&gt; Can he really argue that Ruby on rails is less complicated or complex than redux? I think he means it makes it simpler to do what their use-case calls for, i.e. easier. Rails makes it incredibly quick and easy to render some pages via templates, with easy routing and database integration, and you get Turbolinks for (nearly) free to automatically minimize the delay between page loads. Initial productivity is commonly very high (important for a startup). Of course there are a ton of tradeoffs with this approach, as you and other people have already mentioned, I just wanted to say that I don't think the simplicity of Redux's source code is relevant here, except to say that it's one of the reasons that Redux isn't the most "ergonomic" library to use.
requestb.in?
Oh I agree. That's often on the CTO and the architects to plan out the best tech choice for the organization. In which case I'd expect to see them weight their choices and be responsible for choosing any immature frameworks that could lead them down a dark path. But even experienced CTOs can make wrong choices and they aren't immune to these problems. You can't foresee the future of a framework and the if that direction aligns with the long-term strategy of X business. The difference is most large teams have the resources to compensate for errors in judgement and pick up the slack if the framework will not or cannot but many small teams have to rely heavily on the open source communities to guide them in best practices. And it is these companies that get burnt due to limited resources and experience dealing with such problems. It's a small price to pay to working with open source in my opinion but I can understand why some organizations get frustrated with it all.
Cool - but the "bad" example is totally wrong. It works fine as is because destructuring on an object uses the names of the variables. If you destructured on an array then you'd have a working "bad" example.
Did you even open the article?
There is no destructuring on the (contrived) example, maybe you misread the type annotations as destructuring?
Maybe draw something cool on a canvas. A rosette does look like a flower . Maybe that. Not many lines of code. 
I'm assuming that SPA means single page application? If your users are complaining that it's too complicated then this is a UI problem. So forget about what kind of application it is. Concentrate on making the UI less complex. Single page applications are not the answer to EVERYTHING. It works well for Reddit, youtube, twitter, twitch. But you try and do something like tinkercad, banking software, tax applications, google docs with an SPA it might be very difficult to do. The main point is to make a UI that makes sense to your customers and its something they want to use. We live in a world where we can't expect our users to read the manual. They do not want to have to have training. They expect UI's to be intuitive and easy to use. They expect to be up and running in five seconds. 
And Angular 1.x really was a bit of a mess.
Holy crap, you replied! I hope I didn't come across as rude or unappreciative, I genuinely enjoyed the talk. I've spent a lot of time working with WebTorrent, so my "disappointment" was more based in the fact that you weren't talking about something that's completely over my head. I hope you don't take my feedback as indication to not do these fun talks anymore. Your work is awesome and you deserve to enjoy presenting on whatever you like!
Don't worry about being downvoted, it means you're right.
This is not correct. Initial serverside render with js handover and lots of decent code splitting and asynchronous imports mean very high performance with low page weight. The you have aggressive caching and service workers. The badly structured/optimized SPAs you had to work on don't mean they are all like that. SPAs are great for anything with a lot of dynamic/short lived content and can be much faster than a pure serverside render due to roundtrip times. Though people should not use them for everything. Blogs for example are a poor choice for a SPA.
Mobx is much simpler to reason about the code. Actions, creators, reducers... we found that to be unneeded complexity that slowed us down!
God damnit thank you
reddit, youtube are SPA's? 
 &gt; jQuery is 11 years old. And is still the trend and overused.
That'll be easy to google...
&gt; the SPA revolution threatened to make my existing knowledge obsolete I remember when I worked with a bunch of very talented Flash devs at an up and coming digital agency. They bemoaned the Jobs letter to no end. For years after they steadfastly refused to learn any skills outside of the Action Script world. They'd bristle at any mention of HTML 5. Then suddenly every client's CEO was hellbent on viewing our work on their shiny iPad &amp; we were fucked. About 2/3rds of them were laid off at once. The remainder spent a few years pretending Adobe Air was the cross platform dev environment of the future. I haven't worked there in years, but I heard they just let the last of the Adobe fanboys go. Out of the lot of them, only one bounced back quickly, and he did it by getting into physical computing and finding ways to pitch it to big clients for environmental installation work. He dropped Flash like a bad habit &amp; immediately realized high market value writing Java. Watching Rails devs cling to their framework feels like watching the demise of Flash in slow motion. I've tried to take the whole experience at the digital agency as a career lesson—don't be an X_Language_or_Framework dev—be a software engineer &amp; don't be afraid of unfamiliar tools. I've done a mediocre job of branching out to other languages, but I've tried to stay aware of emerging &amp; declining frameworks—jumping ship when demand swelled elsewhere—and so far it has paid off in spades. &gt; It is difficult to get a man to understand something when his salary depends upon his not understanding it.—Upton Sinclair
All you have to avoid is analysing the source code at runtime. So using `Function.prototype.toString()` is out. Pretty much anything else will survive mangling, uglification etc.
These questions are very antiquated. 
thats what te history push api is for
Woohoo vanilla JS. [Here's](https://robinsr.github.io/blog/post/vanilla-es6-spa-1) a fun tutorial building a SPA with ES6.
What's the new REST? 
Thanks for the link. Gonna read through this now. I'm lazy and like vanilla stuff so if I can create something with as little complexity as possible, I'm all for it
Some people don’t have time to reinvent wheels while they solve problems 
Doesn't sound to me like reinventing the wheel. Sounds to me like you want to light a candle but you're refusing to strike a match from the box that's in your hand; instead you're spend four months shopping ebay for an ornate lighter. Sometimes finding "a solution" for a step in a programming project can be 20x the work of just doing it.
The way I think of SPA is that all the pages are the same, just the content on each page changes. 
From the article, seems like RPC. Soon after to be deprecated by some protocol for exchanging structured data. 
Seems like you could have the best of both worlds. A rest url structure for simple crud stuff and a related event resource to handle rpc-like mutations via an event (ie a name and params) 
GraphQL is often cited. There are other solutions though
We still use SOAP on our product services. Only SOAP. It's so horrible. I hate it. And my existence.
Even though it is a bit crap ("There’s no simple explanation for this; it is one of the most confusing concepts in JavaScript") the questions themselves actually get asked a lot in interviews, so it's useful in that sense, as long as you go and find your own answers
You mean, you don't use document.write() anymore????
Sure that is the definition of a SPA where its all rendered on the client, but youtube/reddit aint SPA's. Look at reddit code on github, its all in python using server templates. Pretty sure youtube does the same sort of thing.
Why do you still use it?
I work for a startup with three other devs. Maybe back when I worked for a large company, we could afford to take time to make our own libraries and stuff. On a small team, for a company of 30 people, we all depend on new features and addressing customer feedback. I’d rather use a library someone else wrote and actively maintains to do things like manage state, parse xlsx files, integrate with amazon s3, crop/rotate images, etc. 
https://www.mockapi.io is pretty good
Im not hip enough for graphQL
Fair enough. I think a better solution will come along soon. It a good improvement but not the best.
Yes, me too. Here's some more I had Saved: **Exploring MVC with vanilla JS** * [MVC Design Pattern Javascript](https://www.sitepoint.com/mvc-design-pattern-javascript/) * [Classic Front End MVC with Vanilla JS](https://medium.com/@patrickackerman/classic-front-end-mvc-with-vanilla-javascript-7eee550bc702) **Vanilla 2 way data binding:** * [2 Way Data Binding in Plain Vanilla Javascript](https://namitamalik.github.io/2-way-data-binding-in-Plain-Vanilla-JavaScript/) **Vanilla Routing:** * [A Javascript Router in 20 Lines](http://joakim.beng.se/blog/posts/a-javascript-router-in-20-lines.html) * [Vanilla Single Page Router Architecture](https://www.ynonperek.com/2017/08/24/vanilla-single-page-router-architecture/) * [A Modern Javascript Router in 100 Lines](http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url) **Templates and Components:** * [Developing Small Javascript Components Without Frameworks](https://jack.ofspades.com/developing-small-javascript-components-without-frameworks/) [ * [Frameworkless Javascript Part 2 Templates and Rendering](https://jack.ofspades.com/frameworkless-javascript-part-2-templates-and-rendering/index.html) **Another good one:** * [Choosing Vanilla Javascript in 2016]( https://andrewrabon.com/choosing-vanilla-javascript-in-2016-6f38a8302ee5) **And if a SPA is even necessary:** * [Why You Should Not Build Your Start Up as a Single Page Application](https://www.amberbit.com/blog/2017/9/20/why-you-should-not-build-your-startup-as-spa/) * [The Disadvantages of Single Page Apps](https://adamsilver.io/articles/the-disadvantages-of-single-page-applications/) * [Why I Hate Your Single Page App](https://medium.freecodecamp.org/why-i-hate-your-single-page-app-f08bb4ff9134)
From what I've seen, graphQL seems pretty slick though. Im tired of committing to something whole hog and then a horse of hipsters run through "invalidating" every technology under the sun. 
You're right that there are certainly cases where it shouldn't be being used. As bart said, generally it is when you have a good idea about the data coming in. Usually it's best done with some strong typing.
Sure. I guess the distinction for me is that a framework is one thing, an alacarte collection of libs is something else. I think using a framework exists on one far side of a spectrum, and on the far opposite is making the best moment-by-moment decisions on a project. And once convenience becomes such a priority, performance is usually the biggest victim. Javascript needs bloat like cancer needs obesity.
 atob('SSdtIHNvIHByb3VkIG9mIHlvdSwgY29uZ3JhdHVsYXRpb25z') This returns, "I'm so proud of you, congratulations" If you want you can generate a different message...press F12 in any browser window, hit console and type in btoa("your message here") 
React+Redux is actually pretty simple and Vue runs into limitations when you try to build an app of any size, Vue just doesn't' scale
Are you serious? Look at the code to tell if it's a certain type off application? Really? I ain't doing that. If it looks like a duck and quacks like a duck. It's a duck!!! I don't care what the innards look like
Yep. Vue.js being simple than React is total nonsense. Vue doesn't scale to large apps, it's basically another Angular 
This argument is so bad. What is "the rest of it" that people are finding so difficult? The view _is_ the difficult part. What else does Angular provide? A REST client? A shitty dependency injection system?
Given the choice between writing business logic and DOM manipulation logic vs. just business logic, I know what I'm picking every time.
I like this for how simple it is. Redux-think is really simple and I don’t like how Redux-saga has a larger codebase that I can’t so easy understand all of how it works.
SPAs are more efficient for data usage when leveraged correctly, not less.
Something made up by people who have no clue what REST is.
There are many steps involved and many ways to do this. Try a few things and ask again when you have a more specific question.
After reading the article, it appears that he does know what rest is.
Also if your code depends on function.name that may cause problems, but if the mangler has the option to ignore function names then it’ll be fine
While this is true, putting time into a ui for a startup probably isn't a good idea. You need to find your market first and ensure you have a product people want. You don't want to build a terrible ui obviously, but the bare minimum effort should be involved until you have established a market. UI should be borderline embarrassing until then so you can fail quickly until you find that product. Hell, I apply this for new features as well. Make it ADA compliant and put the bare amount of effort into making it presentable until we are sure people need it, then go back and jazz it up.
Wow, this is so great. Pretty sure the speech would just be drowned out by all the music video noise, though!
I think the term you're looking for is an "event handler". If you look that up, you'll find what you need. Check out [MDN](https://developer.mozilla.org/en-US/) for more info.
I've done research. Could you tell me keywords to search for?
Assuming you are going to use vanilla (plain JavaScript. 1. Search “getElementById” and “querySelector” for the element binding 2. Search “addEventListener” to make the “thing” happen while clicked 3. Search “localstorage” if the “thing” needs to exist even if the page is re loaded That should at least get you started. Don’t give up ! 
^ This. If it's a real app, it needs some async middleware.
Given the choice between writing business logic and DOM manipulation logic vs. just business logic, it depends on the project.
Oh, a horde*. That was really confusing 🐎 Honestly the flexibility of GraphQL seems like it solves so many of the reusability issues I've had with REST, so I'm interested, but I don't *need* it, nor do I see any reason to start hating REST. SOAP deserved to die. REST works fine. GraphQL has been around long enough to try. The invalidation thing is so true. Every new Thing I adopt has me wondering how much more work I could have done sticking with what I knew just a little longer, because I just have a whole new set of problems everyone will bail on in another year. The hype-hate cycle is petty and distracting. I have become a lot happier just completely ignoring these sort of clickbait things and trying out what I feel like when I feel it's as ready as I am, sticking with what works for me and my team, and keeping clear of strong opinions.
'member when you used to copy SOAP syntax from a copy of MSDN magazine next to your CRT? I 'member.
Ohhh I member!! And member [/u/doubledickdude](https://np.reddit.com/r/IAmA/comments/1u75hh/i_am_the_guy_with_two_penises_ama)?? *** ^^I'm&amp;#32;a&amp;#32;bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[**Block**&amp;#32;**me**](https://np.reddit.com/message/compose?to=memberberrybot&amp;subject=stop&amp;message=If%20you%20would%20like%20to%20stop%20seeing%20this%20bot%27s%20comments%2C%20send%20this%20private%20message%20with%20the%20subject%20%27stop%27.%20)&amp;#32;|&amp;#32;[**Contact**&amp;#32;**my**&amp;#32;**master**](https://np.reddit.com/message/compose?to=/u/Synapsensalat)&amp;#32;or&amp;#32;go&amp;#32;[**here**](/r/memberberrybot)&amp;#32;for&amp;#32;suggestions&amp;#32;and/or&amp;#32;death&amp;#32;threats
Big mega corporation.
Nobody is going to pay to have it removed. Bad software is like getting cancer without health insurance. You know it's bad. You know it might be killing you. But you keep ignoring it and hoping it goes away on its own because you don't have or don't want to spare the resources to get it fixed.
I would give [hyperapp](https://github.com/hyperapp/hyperapp) a look. 
I personally prefer React, I’ve just heard from a few people that they found it easier to get started with Vue.
&gt; Using “HTTP 404 Not Found” to notify about an unexisting resource sounds RESTful as heck, doesn’t it? Too bad: your nginx was misconfigured for 1 hour, so your API consumers got only 404 errors and purged hundreds of accounts, thinking they were deleted What the hell is this person talking about? Why would you configure nginx to only send out 404s? If it was simply broken, it would send out 500 errors! Also, how would a 404 response from a server to a front end – or even to another server – cause the deletion of accounts? It just means something wasn't found! You don't delete accounts as the side effect of an error. 
https://github.com/typicode/json-server local API.
Clickbait title (but might read it still out of curiosity, it's weekend after all. Some time for leisure) Kidding aside. REST might have it's flaws but for read-heavy scenarios it leverages all the caching benefits of http: expire/vary headers and the use of CDNs. GraphQL is very nice but sometimes the arguments in favor feel like frontenders wanting to do whatever they like and move their problems to the other side of the network fence.
I went to this conf. First, it wasn't that expensive at all for this type of conf and for the number of talkers there was. And big names like Wes Bos, Brendan Eich, Sean Larkin and Feross. It was very much worth every penny. We even got lots of goodies. Second, most of the talks were very impressive and very interesting, I ended up loving most of them. It was my first time at a dotConf and for sure it got me hooked. Thank you for that. See you next year. 
dotJS isn't that expensive for what you get. 
Stop the argument. Address this question... What is going to be the fastest and best bet for the business? Screw SPA, jQuery, Turbolinks as the discussion, make the architectural decision that supports the business best.
REST is just a way of encouraging API designers to actually use as many HTTP features as reasonable when designing HTTP-based APIs. There's nothing in the REST principles that would prevent creating RPCs and it's actually really common in many APIs to do both things (for example, having endpoints such as `/services/verify_confirmation_code` or `/services/send_activation_email`, etc.). If anyone cares to point out where in the REST constraints it says that you can't have a procedure as a valid HTTP resource, please be my guest. &gt; Is sending the activation reminder email an update on a “must_send_activation_reminder_email” attribute? Or the creation of a “activation_reminder_email resource”? Is it sensible to use DELETE for cancelSubscription() if the subscription remains alive during a grace period, and may be resurrected during that time? How do you split the data tree of getAccountDetails() between endpoints, to respect the data model of REST? None of this shit is part of the REST constraints. &gt; Using “HTTP 401 Unauthorized” when a user doesn’t have access credentials to a third-party service sounds acceptable, doesn’t it? However, if an ajax call in your Safari browser gets this error code, it’ll startle your end customer with a very unexpected password prompt. lol wat? No it won't. &gt; Too bad: your nginx was misconfigured for 1 hour, so your API consumers got only 404 errors and purged hundreds of accounts, thinking they were deleted…. So, you're blaming REST for fucking up something else entirely? Really? &gt; Or you’ll shamelessly return “HTTP 400 Bad Request” for all functional errors, and then invent your own clunky error format, with booleans, integer codes, slugs, and translated messages stuffed into an arbitrary payload. That's exactly what the author is advocating is so great about RPC--that you can come up with your own set of known exceptions and return them to the user and then he's acting like that's a bad thing when REST does it. &gt; Or you’ll give up altogether on proper error handling; you’ll just return a plain message, in natural language, and hope that the caller will be a human able to analyze the problem, and take action. How would RPC handle this any differently? &gt; Or, well, yes, actually it remember its authentication session, its access permissions… but it’s stateless, nonetheless. It doesn't remember it's authentication session--your authentication session, either as a cookie or as a token, is explicitly passed as an HTTP header. ------ I'm sorry, but this is just whiny bullshit. The article tries to make a case that REST is so terrible because it's easier to build 4 RPC API endpoints and then drags out all of this nonsense that has either has nothing to do with the REST constraints or that is in no way solved by using RPC. And by the way, an API that only has 4 procedures is a BIG fucking exception to the norm. It's far more common in my experience to find an "RPC" API that has a fucking rat's nest of 50 different available procedures--which, good luck remembering what exactly that one procedure that does that one very specific thing was named without consulting the documentation. **There is a legitimate argument to be made about the glorification of designing all REST APIs to use attributes of a data model as a means of triggering procedures or that there's a dramatic lack of understanding that REST is a set of guidelines and not an architecture by itself,** but of course this article is more concerned with being as edgy and extreme as possible instead of actually focusing on making coherent arguments.
This is an incomprehensibly idiotic opinion. On many levels.
For a simple application (or set of marketing pages) you can do it without redux. Just have a simple React app with sever side rendering for SEO purposes. Add redux if the app starts to handle complex state. This simple setup can easily be modified to have more complex libraries and tooling when necessary.
&gt; and loathes what front-end has become. What has front-end become? I am doing frontend for more or less 20 years. It took me years to be fully proficient in w32 GUIs, at least 2 years to know and understand the whole of XAML deeply, a long while for GTK, Android, etc. At least a few months for Angular. I learned React *in an hour*, being able to do the same things i've been needing years, months, weeks in otherwise. [We build desktop applications](https://twitter.com/0xca0a/status/884851183051001856) with it that replace c# enterprise apps. We deploy these in the web and as native applications, sharing most of the code base in between. Front-end development has never been simpler or more powerful. As for redux, redux is a simple programming pattern you adhere to. It sucks the complexity out of the view, where it doesn't belong. Any redux app i have touched would have been at least 10x larger without. It turns the most complex, daring applications into pure views. They obviously do not know what they're on about, and if they have the power to drag the company into the dirt by their biases, leave it and work elsewhere. That's what i'd do.
Where Redux trips up is when it's used for every piece of state even when other components won't need to use it. I maintain that most state can simply live inside the component itself and be updated using setState. It keeps things as clean and simple as possible. Redux is good for when you want to share state between components. In the case where you want components A and B to k ow whether or not the product carousel has Y product selected instead of Z then Redux makes this simple. 
Any WordPress site basically -&gt; just add /wp-json after home url. 
&gt;EDIT: why is that the only place on reddit I ever get down voted is when I say something negative about react? I wonder. In this case I don't think it has anything to do with React as much as this silly statement: &gt;My rule of thumb is: if your users rely heavily on the back button (like reddit for example) then you have a web site, and shouldn't go SPA, but if they don't, you may have a web app. Why should websites not be SPAs?
Then you are speaking a different language from the rest of us. SPA is very much about the innards, not styling.
&gt; I've worked on two enterprise SPAs and initial page loads are between 3 and 5MB, and the amount of time we spend on state management is appalling. Half assed SPAs suck, yes.
&gt; Mixing js/html/css into some unreadable mess I think you have never tried React nor know what it is or does. This kind of silly hearsay doesn't do any good. Separation of concern is what React excels in and what makes it so simple to operate. Vue is an older technology stack, similar to Angulars roots. It doesn't do templates because it's so convenient to rob you of scope or force you to dependency inject, it does it because there just wasn't any other way back then.
You're missing reduxes point. It was made to be explicit, it doesn't mutate but keeps the store immutable, that is also its biggest asset because it prevents sideeffects. Otherwise you'd use mobx, which in turn would even be "simpler" than Vuex, though again, "simpler" is pretty relative - implicit magic doesn't pan out well for complex applications.
I'm not the creator, I found it on [Product Hunt](https://www.producthunt.com/posts/code-to-go)
Chill mate! Any Enterprise level app is going to be more than a view layer, routing, services, stores, sockets, you name it. I'm not knocking react at all, I have just worked on some projects where some inexperienced devs have made an unbelievable mess with react.
If your site is static, take a look at Gatsby. Redux is not always needed, you can just get away with state for most applications. When you find that hoisting and passing through state gets complicated then take a look at a store architecture.
&gt; there's a dramatic lack of understanding that REST is a set of guidelines and not an architecture by itself **BINGO!** That is pretty much the entire issue here.
I feel for your coworker as well. Having worked over a year on a React-Redux SPA; I hate absolute SPAs. Would prefer hybrids where each page is a standalone SPA, but not the whole goddamn app.
The most common case is simply a typo in a reverse-proxy mount point. The URLs which clients call do not exist anymore -&gt; mass HTTP 404. 
have you done puzzel 5 please i need help
Do you mean something like this? Although you may still be unfamiliar with arrow functions. const printCharacter = (character, time) =&gt; { setTimeout(() =&gt; console.log(character), time); } const printSentence = sentence =&gt; { let time = 0; let characters = sentence.split(''); characters.forEach(c =&gt; { printCharacter(c, time); time += 500; }); } printSentence('hello world');
There is nothing stopping you from using local state as well as the redux store. It’s encouraged.
Events are emitted on the next [microtask](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/), concurrently with `.emit()` or in serial with `.emitSerial()`. In most synchrnous event emitter, each event is emitted, event handler run, and then the next event is emitted. Here, by default, all events are emitted concurrently.
[removed]
A UI is more important in the early stages than a fully code-tested and highly performant backend; you are not going to establish yourself in the market if your app looks unpolished. It _can_ be MVP and yes it can be barebones, but what is there needs to look good and be functional.
[removed]
I came to a similar conclusion as the author a couple of years ago wen building systems for my company. I ended up standardising on the simplest possible approach I could think of - since that really seems to be the key to making clean APIs which are easy to understand and reason about. URLs are /v1/:method_name All requests must be POST Method params go as JSON in the request body Return value goes as JSON in the response body Passing input/output via any other means (e.g. query string params) is strictly prohibited. Errors are returned as: { "code": "some_string" } And the status codes don’t matter, other than being 2xx or non-2xx
After reading the article, it's obvious he is thoroughly clueless.
 function chartyper(message, container) { let msg = message.split(''); let i = 0; function nextChar(e) { e.preventDefault(); container.value ? container.value+= msg[i] : container.innerHTML += msg[i]; i++; if (i===msg.length) { document.body.removeEventListener('keypress', nextChar); } } document.body.addEventListener('keypress', nextChar); } // You would use it like... chartyper("Oh! I didn't mean to type this here. I probably should go to r/LearnJavascript to ask this type of question.", document.querySelector('textarea')); // As it is right now, when the message ends it just removes itself. You will most probably want to do something different like calling some other function or whatever. // Meanwhile just copy and paste this whole comment into the console, here in this page.
Op make sure everything is chill with your AWS account. A friend of mine had his hacked a few years ago and over 15k worth of charges were racked up.
No that will throw 503 errors, not 404
I should admit that backbone uses jQuery but you only need to know the basics!
Yup, I've ditched Redux for MobX more than once. Redux can accomplish a lot, but it is overkill in many cases 
mike penis-e
Thanks, I'm very glad you enjoyed it :)
Has it occurred to you that your co-worker could be correct? There are all sorts of reasons to prefer server-rendered apps: - it reduces the work the client has to do. This is important when targeting low-powered devices outside the developed world. Inside the first world, it means better performance. - there are more options to use other languages. If your team mostly knows Python, for instance, it might be wise to use JS sparingly and put lots of logic into Django code. - the web isn't _really_ supposed to be stateful. Content pages shouldn't really need something like Redux. As for your counterarguments - frankly, I think you are wrong: - mobile apps should be written in the best technology for each platform, and designed around native UI patterns, or else there is no benefit to them over a Cordova app. You should certainly _not_ be trying to make your iOS and Android apps look like your HTML. - server rendering would allow you to keep your microservices APIs private, accessed within the confines of the VPC/VPN. This is generally preferable for security. - there is no accessibility benefit to using SPAs. In fact you now have more work implementing ARIA everywhere. - as someone who's worked on both sides of the fence, honestly, the developer experience is better as a back end type. There's less technology churn and better established practices. Testing is often a fair bit easier too. Not everything has to be written in the most popular technology du jour. Why don't you give the Rails approach an honest go and see what you learn from the experience? Programmers benefit when they have many tools - right now I think you are carrying around a React hammer searching for Redux nails.
I prefer it as well if it's a smaller application or team. Redux introduces so much boilerplate which is good if you have a team of many devs, but highly annoying and incomprehensible if you're not that many people, or the application is small.
OP doesn't say they're _using_ React-Native. Just moots it as a benefit. And I wouldn't use a grand unified API for all three apps anyway. BFF seems a more successful pattern.
Let's hope REST and RESTful' go the wah of the dodo, soon. I got an introduction to them a few years ago, by a professional instructor. Basically *there is no spec*. Or: the "spec" is the http RFC. S with JSON, what we need is a simple, restrictive, and fairly complete *official* spec. A spec that can safely handle all use cases that now everyone has to reinvent for himself, as specified in the article. I use JSON as an example because even though it started out as the syntax of "the data structures as in Javascript", it got more restrictive over time. (Object keys *must* be quoted, you can't just use a backslash in front of just every character, and "\x40" is not a recognized escape sequence, you must use "\u0040" instead.) And that is a good thing.
Hence why I don't get how some companies put up an ad looking for a "react developer"(replace with relevant frameworks..) A good software engineer knowing ES6 JavaScript and how the browser works is framework independent. I know plenty of developers who mainly worked with Java, but were able to join C# projects in an instant and came up to speed fast. Likewise, older devs also with Java background having to take front-end tasks in typescript. If you know the basics of software engineering you'll pick it up fast. If you just learned a framework and not much outside of it, you're gonna have a hard time in a few years when that framework is gone. 
On what grounds do you assert that Vue is not scalable?
Sure, because it does so little. When people say React is awkward, what they mean is that React + Redux + Selectors + Webpack + Sagas + React Router is a shambling incoherent mess.
Because half your technology involves rebuilding browser features in a worse way, and this inevitably harms UX.
"Immutable data cannot be changed once created, leading to much simpler application development, no defensive copying, and enabling advanced memoization and change detection techniques with simple logic. Persistent data presents a mutative API which does not update the data in-place, but instead always yields new updated data."
Surprised to see no mentions of [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write) amongst the suggestions so far. A rather appropriate opportunity to use it.
&gt; The etomology of a word has no context to the relevance of the task (being a JS developer). [...] Ask me how to use it - or where is isn't a good idea. I agree. It doesn't mean I can't ask you why it's called that way. You don't have to ace every question; it is just some more information for me. Walking out of an interview for such a question is bonkers. &gt; [...] using that word instead of just "inline if" isn't important. Untrue. You need to be able to name the stuff you use, so you can reference it, search about it and communicate it. &gt; I've been a JS developer for long enough and I didn't know this. Apparently it's about 'three' parts tests/then/else ... As an interviewer I don't care if you don't know; I want to figure out how you think. Example: "Hmm... Ternary ends up like binary. Binary because of *bi* has to do with stuff that comes by 2 -- for example 0s and 1s. So I guess ternary is about stuff that comes by 3. That would make sense because there are three parts in *if... then... else...*". That right here can get you hired, because you demonstrate your ability to draw analogies and communicate your thought process intelligently.
Why not use Isomorphic JS? use [nextjs](https://github.com/zeit/next.js/) (or [nuxtjs](https://nuxtjs.org/) if you prefer vue) it's really sweet and simple and allows you to have the best of both worlds. 
why is this not just the normal way of doing APIs? seems so much simpler. single API end point. main disadvantage I can see would be caching is now not going to work.
I don't think he's wrong. Not just because it's overly complicated the frontend, but because you shouldn't be expecting the client's machine to run a bunch of JavaScript for no good reason, because there's a high probability that the client's machine is a mid-range android handset on a shitty 3G connection, because mobile overtook desktop as the largest web browsing platform in 2014 Having to download masses of JavaScript and do several round-trips to the server just to render what is effectively a html page Is not the optimal user experience, because it doesn't matter how many JS UI gimmicks you have on your page if the user bounces after staring at a white screen for 5 seconds. The average web page takes 19 seconds to load on mobile and then performs like dogshit when it arrives. You can have a decent front-end JavaScript-enhanced UX but do it with progressive enhancement, not an all-encompassing SPA. Plus server-side templating saves you having to write two applications: a data service with a rest api, and a presentation application to consume that api... you just write one application, which saves time and that's what you want if you're just starting up.
Bad bot
Broken gets fixed. Crappy is forever.
&gt; SPA into rails-rendered views using Turbolinks If that's a viable strategy, then sure, absolutely. React/redux/mobx/angular/vue/whatever are tools for doing *complex* stuff that you can't do in easy ways. If you can get a good UX going an easier path, why wouldn't you? &gt; He bangs his head on the complexity of redux to render something fairly simple Redux *is* a ton of work for rendering something simple. If your final product is (and will remain) centred around rendering simple things, why would you use Redux? &gt; design cohesion through sharing css and code between web and react-native If you're already doing a react-native app, then it obviously makes a ton of sense to do a react web app...assuming it makes sense to do a react-native app. In fact, it makes *so much sense*, that I'm kind of confused why you're having this conversation; you'll need all that fancy redux code for the mobile app, so why not just copy and paste it instead of rewriting the logic? &gt; leveraging the APIs we already have to build You could also potentially do that with much simpler solutions like Intercooler, or even some jquery code. &gt; Are there any talks I can show him that focus on developer ergonomics in a rich frontend tooling context? Probably not. Redux isn't popular because it makes easy stuff faster, it's popular because it makes hard stuff possible. The developer ergonomics are *not good*. I work on a large React app, and there's a lot of pain points; webpack rebuilds are getting pretty slow, the super elaborate yarn/webpack/babel/random babel plugin build process is fragile, trying to keep all the different libraries up to date without breaking the world is an ongoing headache, etc. It's worth it, for us, but it's not exactly *easy*. (Also, if you're thinking about major changes anyhow, maybe give mobx a try?)
I don't think this is comparable to sagas, it looks more like the way it describes itself - a saga-like replacement for thunk
I'm sorry, I'm not speaking about a typo in the url to the upstream (application) server, but on the URL pattern exposed by nginx to the world. The same way, if you make a typo in your django/flask/others url patterns, it will rightly return 404 errors, precisely because that's what they're for - reporting unexisting URLs.
Never the less, Deleting a local record when receiving a 404 is a broken client. 404 does not indicate that the resource will never return, that would be the meaning of 410 Gone
Seems to be a duplicate SO question based on the replies. "Original" one here: https://stackoverflow.com/questions/34385243/why-is-immutability-so-importantor-needed-in-javascript
I know most if what you said the mssing things from my knolage/understanding are "advance memorisation" and "detection techniques" 
To be fair, in reality, you generally do not want caching for these kinds of APIs. It'd typically be implemented within the service.
The typeof operator is your friend, friend. Example: console.log(typeof 'some string'); Will return "string" in your console. Happy coding :)
There are open-source programs that reverse engineered Nexon's file encryption and extracts the assets (graphics, audio, etc). For example, see Harepacker: https://github.com/haha01haha01/HaSuite/tree/master/HaRepacker. As far as getting the original assets, Google "maplestory v62 setup" and you should be able to find the original game installer. Licensing is always a slippery slope. As with many games, private servers have been around forever and Nexon doesn't legally pursue PS owners unless they are monetizing their servers, i.e. selling game items for real money. People who run private servers try to eschew this by allowing "donations" and incentivizing them.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [haha01haha01/HaSuite/.../**HaRepacker** (master → e38c800)](https://github.com/haha01haha01/HaSuite/tree/e38c800ae21081c6c96826d97fe8c878cd5021dd/HaRepacker) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Yeah I pretty much only use reddit on mobile which leads to typos like that. I may have to try out a simple project with graphQL so I can get a feel for what it offers over rest. I have noticed at times some similar frustrations as the author of the article when trying to map business rules to specific rest apis. There really is a balance between adopting new tech and being all curmudgeonly about everything. My office is fairly conservative and we've got a lot of office politics going on about that. There is a whole department that is fighting to put all of our business logic (and I mean all) in stored procedures. 
I can't think of one reason why you would say that.
Immutable patterns can make a lot of sense in order to structure application state and bring sanity to the data- and event flow. Redux stores and variations of it often use regular javascript shallow copies and reference equality, and if you need structures to be immutable you freeze them. I don't really see any benefit you'd get from immutable.js at all. I may not see all the use cases, but if it's redux or redux-like state management, i would not recommend it as it has effects on the entire codebase as well as performance pitfalls.
Hey - this looks interesting to play with - have you got this hosted somewhere? Even using github.io or something - a link would be great in your README file
Hey, I did host it on Github: https://novoselrok.github.io/color-palette-wasm/ The link is right under the header in README :)
Er, I know I said stay away from strong opinions, but the jury is in on over-reliance on stored procedures. You're going to regret that. What you guys are after is probably closer to event sourcing or message architecture. Some teams like my own aren't really ready to take on something like that, though.
&gt; Using “HTTP 401 Unauthorized” when a user doesn’t have access credentials to a third-party service sounds acceptable, doesn’t it? However, if an ajax call in your Safari browser gets this error code, it’ll startle your end customer with a very unexpected password prompt. It's been some time since I used Safari, but I'm 99% sure this isn't the case lol. You need a WWW-Authenticate header with "Basic" alongside the 401 status to trigger the browser's authentication prompt. REST is nowhere close to being perfect, but looks like author doesn't know what he is talking about. Some things he did point have nothing to do with REST itself.
Doh. Thanks :-)
But which RPC ;-)
Or you can mock your own api and build documentation using apiary.io or postman.
&gt; Vue just doesn't scale How does Vue not scale?
&gt; A coworker of mine is convinced that front-end has gotten too complicated for startups to invest in, From what I understand this is a UI problem. Fixing the innards is not going to solve a UI problem. 
REST is for CRUD.. and should be for CRUD only. The author wants a RPC solution, REST is not it. 
As execution and network environments have changed, we've adopted/created new remoting technologies that are adapted to their environment. I've seen and worked with DCOM, RMI, CORBA, SOAP, REST, and probably one or two others. They all have their flaws and weaknesses. And they are all adapted to their environment. Designing remote APIs transcends the specific technology solutions -- but depending on the needs of your application/system and which solution you choose, you are going to have an easier/better or harder/worse experience with a particular solution. As with most things, choose the solution that fits your needs and be aware of its flaws and weaknesses as well as its strengths and suitability for your purposes. 
I never understood why people are doing this comparison. SOAP is very powerful when you know how to use it. These are 2 technologies that can live together, one is not better than the other, they are different. They have to be used for different purposes.
React + Redux is a solves a specific problem: persistent, highly-stateful UIs. Can't comment much without knowing what your frontend looks like, Rails + Turbolinks can be a great option if it's mostly reads. You can also have a middle ground where you sprinkle React on pages that IS highly stateful, and let Rails + Turobolinks do the routing. React + Redux is a hammer, but not all UIs are nails. 
React official documentation is dope. Also, 'Thinking in React' article is where it clicks for many people. Btw, react is AWESOME :)
Currently, I'm going through this myself: https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/content I've taken this instructors PWA and Vue courses and loved them so picking this up was a no-brainer.
Thanks for the encouragement. I have avoided it for stubborn reasons and it’s time to give it a shake (says my customer). 
I only took issue with your claim that sites like Reddit and YouTube are SPAs
Yup, that sounds right on target. Usually my root with have: - `./src`, front end source files, to be built with webpack, eg. `./src/widget1/index.js`, `./src/widget1/index.css`, and so on - `./dist`, built front end files, eg. `./dist/bundle.js` - `./app`, server files, express or whatever - `./readme.md` for project info, `./package.json` with some npm scripts for build task, eg webpack, `./node_modules` etc
Haaa haaaaa young Padawan, you have not encountered the horrors of CORBA or interfaces defined in UML!
Same same over here. Sigh...
I posted a couple weeks ago, but I just released `1.0.0` of `image-focus` on [npm](https://npmjs.com/package/image-focus). It's a dependency free utility for cropping images based on a focus point. (~2.13kb gzipped) [Demo is here](https://image-focus.stackblitz.io)
It sounds like you are writing server-side code. Bundling with Webpack is useful for code that runs in the browser, but is not useful for server-side. You can use Node's `require` keyword to import things from other files.
Agreed and I would say more generally you need to use the Redux store for state that any in way persists after the component might unmount. So, for example, if you've got a form component inside a tab selector (not a browser tab, a javascripted tab within the page itself) and the user might tab away and tab back and you want the form to remember its values, you need to put those values in a store and thus incur the extra ceremony.
Luckily there seems to be enough push back that things are looking ok
 project/ ├─ api/ │ ├─ controllers/ │ ├─ models/ │ └─ routes/ ├─ client/ ├─ node_modules/ ├─ package.json └─ server.js The `client` folder is either the output of [`create-react-app`](https://github.com/facebookincubator/create-react-app) or is as described by the [Vanilla Bean](https://github.com/wiledal/vanilla-bean) standard. Either way, it'll be completely encapsulated, so that I could transplant it to an API built in Rails or Django or whatever. The `api` folder could potentially contain more folders (e.g. `helpers`) as necessary, but this is what I'd call the minimum for a well-structured app. Also, the root might contain other junk like DB seeds, deployment configurations, a README...
Oh! I didn't mean to type this here. I probably should go to r/LearnJavascript to ask this type of question.
Could you explain the API portion a little bit more? (Not op) but I've only really experienced MVC on the front end so I'm wondering what tech and peoject type you have in mind
Since I use a lot of React and Express my personal projects or things for fun usually consist of a top level server.js file, a top level routes file I can include, the standard node_modules, package.json, .gitignore, etc., a public folder for serving static assets with express (like CSS and images), build tool config files (usually just webpack), and then two folders, src and dist, where I organize React components inside of src and dist usually just has a bundle.js. I also often have a top level index.html which is served up and includes the bundle. In reality the structure of my projects varies widely based on the tools being used but right now that's a nice and simple way for fun projects you just want to host on a $5 droplet.
You could ignore them...if you like javascript and it works for you - that's really all that matters 
Nah man... i'm neither prosletyzing or getting butthurt. There's some specifics here that sound like "interesting points" and i'm interested in knowing for myself what could be said.
Say I was building an API to store a burger menu in a database. In express I'd tell my app to use routes that I defined in `./api/routes/BurgerRouter.js`: // server.js var express = require("express"); var app = express(); var router = express.Router(); router.use("/burgers", require("./api/routes/BurgerRouter")); app.use("/api", router); app.listen(3000); These routes are then available at `http://localhost:3000/api/burgers`. And inside my `BurgerRoutes.js` I define what routes are available, and delegate the RESTful actions to `BurgerController.js`: // BurgerRoutes.js var express = require("express"); var burgerRouter = express.Router(); var burger = require("../controllers/BurgerController"); burgerRouter.route("/") .get(burger.index); // see all burgers burgerRouter.route("/:burger_id") .get(burger.show); // see one burger module.exports = burgerRouter; Then inside `BurgerController.js` I perform those tasks, using methods defined in the Burger model, (e.g. CRUD actions): // BurgerController.js var Burger = require("../models/BurgerModel"); exports.index = function(req, res) { res.json(Burger.findAll()); }; exports.show = function(req, res) { var burgerId = req.params.burger_id; res.json(Burger.find(burgerId)); }; This depends on methods `findAll` and `find` being defined in `BurgerModel`. In reality, my `BurgerModel` would be built as a [Mongoose](http://mongoosejs.com/) schema, because life is too short for writing Mongo code. So now my folder structure looks like: project/ ├─ api/ │ ├─ controllers/ │ │ └─ BurgerController.js │ ├─ models/ │ │ └─ BurgerModel.js │ └─ routes/ │ │ └─ BurgerRoutes.js ├─ client/ ├─ node_modules/ ├─ package.json └─ server.js And in my client, I can fire an XMLHttpRequest or fetch to `/api/burgers` to get back all the burgers in the DB as JSON, or to `/api/burgers/42` to get the JSON data for the burger with the ID of `42`. I might turn this into a blog post. Please do ask questions or let me know if anything should be made clearer.
Here's my standard advice for learning React : The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. There's also a "Front-End Study Guide" based on that article that's very good, at https://github.com/grab/front-end-guide . On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://reactjs.org/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. For an even simpler setup, CodeSandbox ( https://codesandbox.io ) is an online editor that lets you build entire React projects right away. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, Redux, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
You say it handles your use cases pretty well, do you know of specific things it doesn’t handle? Eg does it try to process tag soup vs well structured markup? Does it handle script tags that in turn contain JavaScript that creates HTML tags? Ditto for CSS selectors with content properties containing HTML?
The snippet you posted is incomplete, so it doesn't really do much. Just initializes some variables to true/false, executes a function called `query`, and executes a function called `balHisInfo`. Judging from the variable names, probably has something to do with Bitcoin, perhaps showing account history data in the form of charts? Without the rest of the code (such as where the `query` and `balHisInfo` function are defined), we can't really tell what else it does.
Well actually, yes I have, but we're talking apples not oranges grandad, and I'm forty fucking two. Young padawan indeed. 
Honestly for me (surprisingly haha that was really clear! In fact just yesterday I came across the syntax you used for the `.route` followed by the different methods, so it's really neat to see such a nice use case for that. If you wanted to turn it into a blogpost I would have a few suggestions. You did a good job of mentioning that `.find` and .`findAll` could be a lot of things based on what tech you're using, so I would make sure that that is in the blog post, because a beginner can't always tell what is built-in, what is just a plain variable name but is also convention (I've had people ask me about naming counter variables 'i' and whether naming it something else would break the for-loop), and what is intended as a concept but would vary by tech stack. Maybe in the code a comment near that line of something like ".find would be ___ if I was using ___ and ___ if ___". That way beginners could more easily parse the different pieces so they can focus on the structure you are showing. On a similar note, a good point of clarification might be for something like: `.get(burger.index); // see all burgers` you could remind the reader that burger is whatever is exported by the burgerController.js file, and if they look there they see index being attached to the exported object. THen something about how it uses the `res.json` express method which inside it uses your generic `findAll` method, which is ostensibly a stand-in for an ORM or other database related method to fetch all entries of burgers. Maybe not all in code comments now that I look at what I typed, but I think that you started to hit on it and should definitely continue strong with that. Even though for me your example was excellent, I can remember a time not too far in the past where I would have been confused on those points, since when a beginner is struggling with structure and fitting the pieces together, examples by nature can get confusing, because they (of course) have all the pieces mixed in that you are trying to explain how to organize.
Here are the wiki pages for the subjects you’re confused about. https://en.m.wikipedia.org/wiki/Memoization https://en.m.wikipedia.org/wiki/Change_detection
I can't help but nitpick a bit... &gt;It wasn't designed to be used how it is today and that is clear from the lack of things like import statements. Lack of things like [import statements?](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import). It's supported in all major browsers. &gt;NaN does not equal NaN. To determine if a var is NaN you have to check if it is not equal to itself. You can also use [`Number.isNaN()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN). &gt; There are so many features missing that I need in everyday programming and instead have to do the complicated way. That isn't true nowadays. You can [work with bits directly](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) or run [multiple threads](https://developer.mozilla.org/en-US/docs/Web/API/Worker) etc.
I strongly dislike this structure, actually, at least what you have under `api/`. It's so much easier for other developers to see what's going on in a project to structure it by module or component, instead of type. project/ ├─ api/ │ ├─ login/ │ │ ├─ login.controller.js │ │ ├─ login.model.js │ │ └─ login.route.js │ ├─ schedule/ ..... ├─ client/ ├─ node_modules/ ├─ package.json └─ server.js Grouping by type makes it hard to browse the project and see at a high level what's going on. I really hate that it's the default for so many generators. 
I don't disagree. I probably follow this convention because I came up as a Rails dev, and Rails groups by function. In fact, the Rails models, controllers and routes aren't nearly as close to each other. This structure is a _gift_ to Rails devs. Next project I start I'll try it your way.
Thanks for the feedback. If I had a whole blog post, I would actually write the schema and database connection because you're right, the Model is just a black box here, and relies on the reader knowing typical CRUD functions.
You should definitely do it! I would read the CRUD out of it
My website, and a game that’s hosted therein. Play it here: http://www.huntermaverickwells.com/
So basically the same as type safety through constructor constraints and instanceof... Just a bit cleaner (maybe) If you could extend primitives in Typescript, you'd have "amount extends Number" and put the necessary constraints in the constructor and your operator overloads. Maybe some or all of it could be translated to runtime checks in javascript.
To add on to this response. I like to structure my src directory like so: * `/src/widgets`, components that are reusable and not specific to the site. This would be [atoms, molecules, and organisms](http://bradfrost.com/blog/post/atomic-web-design/) * `/src/widgets/button/button.js`, an example of how components would reside in the widgets directory * `/src/widgets/index.js`, [the root exporting directory](https://stackoverflow.com/questions/34072598/es6-exporting-importing-in-index-file) * `/src/views`, this would contain templates that are aware of the page that they are on. For instance, if you are making a facebook comment page, widgets wouldn't use the word comments, but views would be the composition of widgets and have a title that says Comments. * `/src/views/{domain}`, This would allow you to say like comments which would contain a comment list component, comment input...you get it. * `/src/actions`, any actions that fetch or download something. If you're using something like react this is where your [functional set states should reside](https://medium.freecodecamp.org/functional-setstate-is-the-future-of-react-374f30401b6b) The goal of this structure is that widgets can be extracted from the application eventually into a component library to be reused in any application in the future. This allows your team to be far more agile in designing future applications and makes your code more like legos instead of an entirely built application where things have to be extracted rather than simply pulled out and used somewhere else. The actions directory lets you change how the application works without changing the view of your application. These should be separate things in my opinion. If you decide to change the api that's getting data, your views shouldn't have to be modified to do so in my opinion.
PyCharm is mostly for Python. WebStorm is the Jetbrains product mostly for Javascript. However you can write both in either IDE. You just create a file with the .py or .js extension...
Lol I guess "Z JavaScript library" could work? 
Ok thanks :) I will definitely try this
I personally would never use a library without a single unit test no matter how small it was.
One trick when wanting to divide up similar functionality is to make good use of index files. Most people are aware of it but for those who aren't it shortens file paths and coupled with object destructuring (CommonJS) and ES6 imports, it makes importing grouped objects simpler and more logical: src/ |--components | |--AppHeader | | |--index.js | | |--AppHeader.js | | |--style.js Would be: import AppHeader from './src/components/AppHeader' And AppHeader/index.js may simply be an import/export: export { default } from './AppHeader' Or it may be a container for the stateless functional component stored inside AppHeader.js: import AppHeader from './AppHeader' export default AppHeaderContainer extends Component { // ...stuff goes here render () { return ( &lt;AppHeader {...props} /&gt; ) } } This encourages you to organise your components properly and think more about whether `React.Component` (or whatever the Vue/Angular equivalent is) is really required, which in a lot of cases it isn't. Also for things like large folders of assets, indexes become almost essential. Store all your files in a single folder, and export them all from the index: src/ |--assets | |--galleryImageA.png | |--profile.png | |--logo.png | |--index.js Then inside your index.js: export { default as logo } from './logo.png' export { default as profile } from './profile.png' export { default as galleryImageA } from './galleryImageA.png' Then wherever you wish to use them: import { logo, profile } from './assets'
Hi! Thanks for the questions. Currently, it does not handle [optional tags](https://html.spec.whatwg.org/#optional-tags), meaning tree constructur won't automatically add closing tags for those cases. Also, it does not handle self-closing tags inside SVG. This one relatively easy to add and it's on my todo list. For other cases you've asked: It does process tag soup, you'll get tokens and AST in any case. It treats script and style contents as plain text and does not try to parse html inside. I'm currently waiting for a Pull Request to be merged into [astexplorer](https://github.com/fkling/astexplorer), so users can play around on the live playground.
This little article has helped me organize most of my projects: https://medium.com/@msandin/strategies-for-organizing-code-2c9d690b6f33. It's not specific to JS, but can certainly be applied to JS projects.
Could be some sort of a script like coinhive that uses the client's cpu for a few seconds to mine bitcoin. They really have to let the client know about it before they do these things btw. Not sure though.
Lmao DB memes 
Organising your code by feature first makes far more sense, indeed. Lumping things together first by what they are (and not the purpose they serve) doesn't scale nearly as well.
Why not have a burgers directory and put all the burgers code in one place? You can then ask the burger feature to instantiate itself, and your app needs no knowledge of what the burger feature is doing. The less knowledge needed across your app the better, as it encourages decoupling features and the logic which binds them to your app.
Or use ES2015 modules, which is faaaar nicer to work with (in my opinion).
The same point was raised [here](https://www.reddit.com/r/javascript/comments/7k7o8i/how_to_structure_javascript/drcc7lq/). The answer is because I was a Rails dev in a past life, and it's now just a habit.
 A visualization library for genetics &amp; bioinformatics. You can also use them for other types of data. Most applets can be synchronized with each other. https://github.com/IbrahimTanyalcin/LEXICON
Good news - http://www.zdnet.com/article/developers-rejoice-microsoft-google-mozilla-are-putting-all-their-web-api-docs-in-one-place/ - Microsoft and Google are going to put all their effort into MDN.
JS has its warts. Python is far worse. Python is inconsistent, poorly documented, terrible to write functional code in, and offers no material advantages over JS that I’ve seen. Just my opinion, but if I didn’t have to use it for work, I would replace Python entirely with JS tomorrow. 
Here is a stack overflow post asking a similar question: https://stackoverflow.com/questions/614126/why-is-array-push-sometimes-faster-than-arrayn-value In the OP there is also a link to site which has comparisons of the different methods. Hope this helps!
Pretty much. Like I said, this problem doesn't lend itself well for FP in JS, because a proper FP language would have tons of optimisations to make things like the `slice(1)` be O(1) (or close to it), instead of O(n). JS simply doesn't have these tools, you are way more limited when trying to write 'proper' FP in JS, and thus a more traditional approach such as `zipF` actually does work. Also, `zipF` basically performs identically to `zipA`, in my tests they tended to flip a coin for who's faster.
Honestly, if your app serves a useful, scalable, timely need, people will find a way to use it, no matter how shonky the UI. Vice versa no design can save a badly thought application. I have worked for too many startups who couldn't figure out their product-market fit and spent their time on decoration and design instead. It never saved them. I also see a lot of teams invest in UI because that's a lot easier to work on and get quick results than marketing, user testing and product validation. When I see a startup hire lots of UI devs but few PMs, salespeople or analysts I see a big neon warning sign.
`a[a.length] = foo` was faster than `a.push(foo)` in the past, but that isn't the case anymore. Use a profiler to figure out where your application is actually spending its time.
benchmark.js is great for these types of investigations 
OP is asking about organizing server side code. They don’t need webpack or to build front end files. 
&gt; It's often the ones that are hung up or don't want to learn that complain, it's in their best interest if they want to remain where they are or if change frightens them. Can you blame them? I've been a front end developer for almost five years now. In that time I've had to learn Backbone, Knockout, Angular, React and Vue. Every time I invest something else comes along and I have to scrabble to stay employable. I'm just fucking sick of it. None of it goes anywhere, the apps everyone writes are just reskins of the same, nine of this proves to me anything more than learning for learning's sake.
&gt; I don't understand why people wouldn't want to make the client's computer do all that for them. For real? You want to make the client do all the work? When you're targeting low power devices in the developing world and subject to SEO render timings? When you can prebake the HTML and serve all your documents through CDN edge caches?
If you want two example repos to look at, I have [one in JS](https://github.com/atom-morgan/es6-api-starter) and [another in TS](https://github.com/thecodecompanion/lets-get-lunch-api). Like a few other comments here, I separate things out by routes, models, middleware, and controllers with a separate directory for testing as well.
I'm at a largish web company, and my team uses rails as our front end view renderer. We use both react and custom elements, but just not for everything. We use a front end view library when a certain UI calls for it. Recently, this article has spurred some good conversation https://evilmartians.com/chronicles/evil-front-part-1
&gt; I hate weak typing. I don't want a language to assume it knows what I'm trying to do. Isn't python weakly typed?
Rails is full of bad ideas. It's really not the greatest inspiration for best practices. 
That was the case. Newer frameworks aren't even frameworks any longer, they're patterns, patterns that you can apply everywhere. Knowing redux, you don't know a library, you're a better javascript developer in general - i use that knowledge now in all possible cases. React, just teaches you functions and flow. And you already see that these are the technologies that are leaving the web. I use the same exact knowledge that i have in the web now to drive mobile and desktop apps - why? Because we have learned from past mistakes. If people still insist to use arbitrary, web-bound black box frameworks that have you learn *their* ways, that's up to them - and up to you if you want to work in a such a environment. 
Thank you so much! I used this one and he loved it! 
I really liked eggheads course: https://egghead.io/courses/react-fundamentals Teaches you setting up an environment, making a first component and going from there. When it ends in about an hour you know React.
I released an updated version of a tool I made a few months ago to explore and compare packages in npm. The demo is [here](http://npm-introspect.z3d.tech/). Tell me what you think.
making a page for this should be pretty straightforward if you know minimal is and html. 
And I think this is the biggest issue when people talk about "REST". I've noticed at least three separate things people mean when they say "REST": * An API with full hypermedia controls, aka HATEOAS * An HTTP API where the URLs represent a "resource", and the HTTP method determines what is done to the resource * Any HTTP API which uses json Saying that a given API is RESTful unfortunately no longer means much.
Try storing the created element in a variable like: let checkbox = createElement(createElement(li, 'label', 'confirmed'), 'input', '').type = 'checkbox'; then try to update the name property of the element before it is added to the DOM: checkbox.name = 'my-new-checkbox'; 
In what world does the speed of any of these bits of code matter?
You can't _refute_ the first three, but only because they mostly show a lack of understanding that prevents discussion. &gt; I hate weak typing. I don't want a language to assume it knows what I'm trying to do. _"Weak"_ typing doesn't really mean much at all. Maybe they meant "dynamic typing"? If so, confusing the two shows a a severe lack of understanding that should prevent any meaningful discussion. &gt; It wasn't designed to be used how it is today and that is clear from the lack of things like import statements. The first part, not being originally designed to be used as it is today, is mostly correct. But that is because very few languages are, and it means very little. Languages evolve and usages of those languages evolves too. As for the second part of that, not only there are now _import statements_, but also this does not mean that there no solution at all before. It only means that the previous solution (i.e. letting HTML manage the loading of JS scripts) turned out to not be good enough. Not being good enough is a flaw, of course, but luckily, as I mentioned, things evolve and flaws get fixed. So, uh, big deal. &gt; NaN does not equal NaN. To determine if a var is NaN you have to check if it is not equal to itself. `NaN` should **not** equal `NaN` anywhere. This is not something JavaScript-specific. If someone still has problems about NaN, they could go read [Wikipedia](https://en.wikipedia.org/wiki/NaN) before continuing to argue. Also, there is `isNaN` and `Number.isNaN`, depending on what you need, as has already been mentioned. ---- Finally, "brigading", or just getting annoyed about someone not liking the language you like, is about as stupid as not liking a language for reasons like those.
No, it’s strongly and dynamically typed.
Weak typing does mean something. In Python, you can’t do: sum = 5 + 5.0. You need to convert one of the types to match the other type. Dynamic means you don’t need to explicitly declare the type. I.e. “x = 5” vs “int x = 5”. So Python is a strongly typed and dynamically typed language. It does seem silly to me to specifically hate a language over this. Different use cases, different jobs, etc. Each have their pluses and minuses.
https://adamsilver.io/articles/the-disadvantages-of-single-page-applications/ 
I'm guessing you haven't used vue more more than a few minutes and just glanced at the docs, nobody with experience with vue would say that. I've converted vue.js/vuex to react/redux and back again just to understand my options better, its like you are telling me the sky isn't blue.
I get that, but to suggest it as a solution seems a bit weird if you picked it up somewhere else for something unrelated :)
It's painful? I find it delightful compared to the C++ background I came from.
"Get a more interesting purpose in life," is what I would say to them.
&gt; Weak typing does mean something Something. But not much, and not everyone agrees on a unique specific meaning. So it almost never adds anything useful to any discussion.
Using both, every day, professionally. From the React docs: &gt; Instead of artificially separating *technologies* by putting markup and logic in separate files, React separates *concerns* with loosely coupled units called “components” that contain both. In React a view is 100% separate from logic which comes in as prop. The view logic on the other hand is driven by javascript *as it should be*. React components are thereby explicit, type-safe and statically analyzable. In Vue a "component" is in truth a directive. That directive needs declarations (dependency injection) to refer to other components. It also needs dependency injection to refer to its own local state. The template doesn't know javascript and it can't be injected, so while ternaries are run in sandboxed evals, view logic is driven by tacked on markup extensions (v-if, v-........). Vue "components" are neither type safe, nor statically analyzable nor can you glance over them - they fetch their references from at least 5 different sources: methods, data, props, component-declarations, global declarations - leading to an intangible mess. This was the same in Angular - you can now flip your table, but that's how it is.
It’s not like I overrode Node’s default file structure out of madness. I copied MVC architecture from one framework to another. 
It's not very clear by your wording so... - If what you want is to _learn how to do such a thing_, you should probably try r/LearnJavascript and/or maybe r/HTML - If what you want is for _someone to build this for you_, you should probably go to r/forhire/ r/Jobs4Bitcoins/ r/web_work/ r/freelance/ or some similar subreddit - If you're not sure which one of the two options you want, some subreddits, such as r/CodingHelp/ welcome both In any case, I don't think this is the appropriate place.
I really don't understand what you want. You can create an HTML form, some very simple JavaScript and then inspect everything in your browser's dev tools. But not sure that's what you need. Also, JS is not compiled, what do you mean with compiler?
It was amazing compared to what came before it. But things have evolved since then.
Agree! App structure must correspond to business logic hierarchy.
I don’t know about that. There is risk in using a dynamically typed language that isn’t strongly typed. Most software engineering firms I’ve worked with and for would consider JS dynamically and weakly typed. I think the statement by the poster is reasonable to bring up when considering what language to use for a project, but it’s not a fair criticism of JS.
&gt;&gt; Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both. This is not a react argument against vue, looks like its more of a promotion of frameworks that use components. Its surely not referring to vue when it says "separate files" since vue developers almost always use single file components. &gt; they fetch their references from at least 5 different sources: methods, data, props, component-declarations, global declarations - leading to a salad. And a "brochure" for Vue could say this creates flexibility and power and you have to be careful with it. Keep your local data in data, keep your global in vuex. Vue isn't for idiots, its easy to use and easy to abuse.
Does this help? https://codepen.io/anon/pen/opjaEB
document.body.addEventListener('keypress',() =&gt; { if (e.keyCode === 90) { console.log('it worked!') } })
&gt; document.onkeypress = toggleScript function toggleScript(ev) { if(ev.keyCode == 122 ) { // 90 for capital letter Z // your code goes here } })
It's probably (misguided) coursework
It's from 2009, will hardly apply today
1. You need to learn how to benchmark code (and no - don't ask us how, at least _try_ to google it first!) 1. You need to stop worrying about benchmarks for pointless micro-optimisations like this (show me a real case scenario where the nanoseconds you'd save would _really_ make the difference)
Mithril.js 
I manage multiple Shopify stores and will use both Turbolinks in conjunction with Mithril.js which renders some highly impressive results. Due to Shopify being virtually dependent on liquid this combination is a good fit.
Elm fanboy disses Javascript, talking total crap in the process
That’s a valid point. I think the way you made it was a little aggressive, but I’m glad you made it. You’re right. 99% of the people that use the app I’m rewriting are in urban areas with consistent mobile data, and/or computers with enough capabilities to run the app. So yes, I could see in your situation in which that would be better. 
Wouldn’t the benchmark site linked in the post be running the JavaScript that the browser supports?
Negative. Im a professional. It's important because I have a crucial task that handles ridiculously large queries, rebuilds and posts to a different tool. Just trying to speed things up.
Um. Why?
The author doesn't use semi-colons -- I'd pass
Explain yourself?
At the start of a mdm project and pulling in all my data from multiple different databases, rebuilding thousands of Jon objects almost doubling in size to meet the destination tools requirements. Now a query with 10k+ rows takes less than 25seconds but still I want to make it faster if possible.
Is the array insertion really the bottleneck?
There is no bottle neck or problems. Just looking for best options and I like making things fast. Was just looking for people's thoughts...
Fair enough. Fuck JSF though.
What did you try. What is it that you don't understand? This is a fairly good documented feature, so if we get to see your code, we could help you point out what you did wrong. Of course, I could just tell you how to do it, but then you would probably not learn from it. Anyways, I will try my best to explain it to you. First you will want to set up an event listener. You will have to figure out where you want to "capture" this event. If it is in a &lt;input&gt; element (or any other element), you will have to get a reference to that element. If you want to capture the keypress globally, you can use the global 'document' object. E.g &lt;input id='myInput' /&gt; &lt;script&gt; const myInput = document.querySelector('#myInput') &lt;/script&gt; You now have a reference to the element with the ID of 'myInput'. You are now going to have to decide what kind of event you will want to capture for. You have keydown, keyup, and keypress events for handling keyboard input. So we will set up an event listener on the reference. myInput.addEventListener('keypress', (event) =&gt; { /* Everyting inside this block will be executed on 'keypress' */ } And then you will have to figure out how to handle the checking of the keypress. const { code } = event if (code === 'KeyZ') { /* Do something here if key 'z' is pressed */ }
Don't waste your time with micro-benchmark. Compiler is not an unchanging object -- hundreds of people work on it for their job. They already tries to optimize stuff at the line-level for you. Unless you are writing a library where you can later-on change it in one place when the compiler behavior changes, optimizing between two lines of logically identical code is worthless. Here's an video for you that covers some basic compiler optimizations: https://youtu.be/65-RbBwZQdU?t=173
Qwest.js or Mithril.js 
https://jsperf.com/array-direct-assignment-vs-push/5 Thoughts on this?
The majority of the objections in the list are rubbish - either outdated (NaN, import), or vague statements that mean nothing (There are so many features missing... It likes to do things in a way nobody...) or just trolling (how many languages have callbacks for array sort? does Python?) I find that most developers of competing languages dislike JS mostly because of "weak typing" (but Python is only marginally "stronger" typed than JS - it's not an absolute quality) and because they can't get their head around events. I say "fuck them"
My opinion (and some others have written the same) is that it's a pointless micro-optimisation and you should profile to find out what parts of your code are the slowest
Weak / Strong types are relative terms, hardly two "strongly" typed languages handle type the same way. Python is only marginally stronger than JS. See https://stackoverflow.com/questions/9929585/seeking-clarification-on-apparent-contradictions-regarding-weakly-typed-language
Seriously?
Yes, that would still hold. But then couldn't OP write the same thing herself? But the discussion is probably outdated.
Yes. Web Assembly runs in the browser. Or in Node. Literally everywhere JavaScript runs. Why would you then in interpret it back into JS?
These are usually people that read too many JS hate online, and decided to hate js to be cool. Nothing you say can really change their mind. 
Not sure if you edited your comment, or if I totally missed it somehow on the first read: This is an _interpreter_, not a _transpiler_. As in, you write WASM and the JavaScript runs it. The documentation is scant here, but as far as I understand it, this will _not_ take your JS and turn it into WASM. Furthermore, from everything I've heard about WASM, compiling JS to it is almost certainly not possible. You need a low level language without a garbage collector. That's why WASM exists, to _replace_ JS with something low level and more performant. The only languages that can currently be compiled into it are C, C++, and Rust.
Thank you for your opinion.
Translation: "I don't understand ASI and it scares me"
Mithril doesn't do 2-way databinding. Though I suppose it provides helpers that let you wire up inputs without a lot of boilerplate. m('input', {value: stream(), oninput: m.withAttr('value', stream)})
True, I should of noted this for OP. By any means though, he’d get better results using Mithril (8kb) vs using Rivets (25kb)
What does this buy me over just using thunks and async/await?
Damn how did you manage to find this 16 days later?
I’ve quit smoking weed and cigarettes which is rendering me a temporary insomniac. Hope these help. 💥
Hope you get through it breh.
Why? To slow it down for js to catch up?
🙏 
This is huge. This allows older browsers to run WebAssembly :)
Bike shedding over semi-colons is proof of bad developer mindset. Just choose a style, be consistent, and enforce it with a linter. None of this shit matters, it's just an aesthetic preference. 
I suppose that’s true. Are we anticipating a lot of WASM code that doesn’t have a JS equivalent but is also worth running at the much slower speeds a JS interpreter would allow? I mean, you can already compile your code into ASM.js if you need an older browser fallback. That runs reasonably quickly. I can’t imagine this interpreter would work any better, and would probably work much much worse. 
Can you give detail answer here https://stackoverflow.com/questions/47837685/use-socket-io-in-expressjs-routes-instead-of-in-main-server-js-file maybe.
&gt; Dynamic means you don’t need to explicitly declare the type. Dynamic means that type-checking is always deferred to runtime. There are statically typed language where you don't need to explicitly declare the types of things (this is type inference and is fully supported by Hindley-Milner type systems like the ones of ML &amp; Haskell).
&gt; JS has its warts. Python is far worse. I'm a big JS fan but let's not go there. Don't pick fights you cannot win. From a language design perspective, JS a *far worse* than Python. I would still pick JS over Python more most projects though.
That's funny, I actually built a Whatsapp quiz quite some time ago by hooking into the Redux store and dispatching some action. It was a a lot of fun, at least my friends thought so — they demanded more quizzes! The unfortunate thing was that the connection between my phone and computer was quite spotty, so sometimes it would disconnect. Unless Whatsapp rolls out a proper API, allowing you to easily setup and maintain bots, I would never bet big on using private functions that could be modified or removed any time. 
It's all a pointless debate anyway, based 90% on personal preference, but can you tell me why you think Python is better from a "language design perspective"? I find its design choices inconsistent as hell, and that's _before_ you get into the 2/3 split which is a huge headache. More importantly though, I think some of the foundational design choices are just "wrong". Being white-space delimited is cute, but makes functional programming a huge pain in the butt. List comprehensions are fun until you need to do anything of consequence and realize a decent map or reduce would be a lot more comprehensible. It's a scripting language. JavaScript is too, but I'd say JS has scaled up much more elegantly than Python. I'll take `NaN !== NaN` over Python's design decisions any day.
Meh, as long as you are using naming conventions I don’t think it matters much. Hopefully you’re fuzzy finding the files and not using a mouse to click on it. Maybe it’s better for someone new to project idk
Maybe it could be used as a patch but why are people using such old browsers?
You can use mousetrap.js
To be fair full WASM support is only in the newest browsers. And someone will always be running something old. Supporting very old browsers is a hard requirement for some projects. It's just hard for me to imagine people going, "Hey! We've got this C++ code we want to run in the browser, let's compile it to WASM! Oh wait, what about IE 6? Pipe it through a JS interpreter!"
My concern is that old software like that is a security risk when it's network facing. The old stuff is generally found in businesses too so it has the potential to lose them money, not just their saved bookmarks or something.
Who cares what we think then, just run a benchmark for your use case and pick the fastest. 
I think there's an argument to be made for speed to making effective contributions after a hire. Especially for mid level hires. 
I always just get the epoch milliseconds with date.getTime() and use this number on my json object. Then on the receiving side, new Date(millis); https://www.w3schools.com/jsref/jsref_gettime.asp 
Just use prettier, choose among the very few config options and stop encouraging people to waste time arguing about this.
Young padawan, in what way is CORBA different from SOAP and REST?
In my work, I think about data representational issues, such as overflow, underflow, precision, conversion mismatches, etc. in order to ensure that code behaves correctly under all reasonable foreseeable circumstances. Perhaps it depends what kind of code you're writing as to whether these are practical or theoretical concerns.
One of the benefits of javascript is the ability to share code between client and server. I try to not separate the two inside my source code because of this benefit. My latest large scale application really showed the cracks of improperly structured organization. I wouldn't necessarily recommend this for smaller projects, but for one that needs to scale to a lot of code, I structured my application by feature. On top of that, each feature is actually an npm package: src/ plaforms/ web/ packages/ cli/ packages/ mobile/ packages/ packages/ auth/ packages.json bootup/ packages.json packages.json Each plaform has its own `packages` folder that can also contain features specific for itself. Then we leveraged `yarn workspaces` to do all the installation. The other extremely important thing that helped us was creating a strict API for each package. No package was allowed to reach into a sibling package's submodules, it must use the index.js file. For example: // bad import { fetchNewsArticle } from '@company/news/action-creators'; // good import { actionCreators } from '@company/news'; const { fetchNewsArticle } = actionCreators; This certainly increased the verbosity of our imports but it created a very clean API that was consistent across all internal packages. Since we had a consistent API for all of our packages, each plaform was able to load whatever dependencies it needed upfront. For example, we use redux and redux-saga for our application. Each package exported a `reducers` object and a `sagas` object. Each platform then simply had to use one of our helper scripts to automatically load our reducers and sagas. So inside each platform was a `packages.js` file which loaded all reducers and sagas that were required by the platform and the packages it wanted to use. import { use } from '@company/package-loader'; const packages = use([ require('@company/auth'), require('@company/news'), require('@company/payment'), ]); const rootReducer = combineReducers(packages.reducers); const rootSaga = packages.sagas; We didn't even care if the package exported a reducer or a saga all we cared about was the platform has the features that we want it to have. This setup has worked extremely well for us, we are supporting 7 different platforms and has infinite scalability. It's relatively easy to find what you are looking for. The real beauty of this setup is once you learn how to build one package, you know how to build any package. They are all setup the exact same way. 
A utility library I made to conditionally concatenate CSS class names. It's _almost_ a drop-in replacement to the alternative classNames, but 10x faster in 300 bytes. - https://github.com/JorgeBucaran/classcat
What makes you think blocking on JS + secondary load to fetch data (two round trips of async calls) to render even a single bit of HTML is faster than just sending down the HTML and late loading the JS later.
Vue.js supports two-way binding (though at times it bemoans its mutable nature...) https://vuejs.org/v2/guide/forms.html
He's an Elm consultant peddling his services. He spams /r/elm non-stop.
Here's a sneak peek of /r/elm using the [top posts](https://np.reddit.com/r/elm/top/?sort=top&amp;t=year) of the year! \#1: [Meet Ellie](https://www.humblespark.com/ellie-announcement/) | [13 comments](https://np.reddit.com/r/elm/comments/5ta0x0/meet_ellie/) \#2: [Tour of a 4,000 LoC Open-Source Elm SPA](https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa) | [23 comments](https://np.reddit.com/r/elm/comments/69wrfq/tour_of_a_4000_loc_opensource_elm_spa/) \#3: [Elm Roadmap FAQ](https://github.com/elm-lang/projects/blob/master/roadmap.md) | [6 comments](https://np.reddit.com/r/elm/comments/68pngi/elm_roadmap_faq/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [elm-lang/projects/.../**roadmap.md** (master → c56ab7f)](https://github.com/elm-lang/projects/blob/c56ab7f514c8a8e992b30d66b643a9fc4f866bad/roadmap.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drda06o.)^.
A single JSON object is not a valid JavaScript script. Do you need to load the data in this way? Can you use XMLHttpRequest?
Where are you actually doing that data retrieval?. Don't see it
I made another event emitter, probably the smallest one I've made so far. Here it is on npm [dataGun](https://www.npmjs.com/package/datagun).
By adding the `script` element to the page.
As u/Meefims mentioned, if you use `XMLHttpRequest` instead of the `script` element, then you can use the JSON output from PlexPy as is. But let's run with the [JSONP](https://en.wikipedia.org/wiki/JSONP) data format that you are attempting to use. You are on the right track, but you have the wrong parameter name where you specify the JSONP callback in the API query URL. Your URL includes `jsoncallback=processJSON`. I've never used PlexPy and had trouble finding any documentation on the URL query format it wants, but when in doubt, look at the source code. Here is the [source code for plexpy/api2.py](https://github.com/JonnyWong16/plexpy/blob/master/plexpy/api2.py). Open that page and do a Ctrl+F (or Command+F on Mac) and search for `jsonp`. You'll find it mentioned [here](https://github.com/JonnyWong16/plexpy/blob/cfd30996264b7e9fe4ef87f02d1cc52d1ae8bfca/plexpy/api2.py#L49) and [here](https://github.com/JonnyWong16/plexpy/blob/cfd30996264b7e9fe4ef87f02d1cc52d1ae8bfca/plexpy/api2.py#L460). Note that both those lines mention `self._api_callback`. So let's do Ctrl+F again and search the page for `_api_callback`. You'll find it [here](https://github.com/JonnyWong16/plexpy/blob/cfd30996264b7e9fe4ef87f02d1cc52d1ae8bfca/plexpy/api2.py#L100) on this line: self._api_callback = kwargs.pop('callback', None) (You could also do this searching on a local copy of `api2.py` if you have it, of course.) As you can see, the query parameter name the code is looking for is `callback`, not `jsoncallback`. If you make that change in your API URL, you should now get the JSONP formatted data you're looking for. Also note that you can test the URL directly in your browser to see what it produces. When you use the `callback` parameter, instead of getting JSON data like this: {...} you should now get JSONP data, which is simply the same JSON data enclosed within a call to your function: processJSON({...}); 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [JonnyWong16/plexpy/.../**api2.py** (master → cfd3099)](https://github.com/JonnyWong16/plexpy/blob/cfd30996264b7e9fe4ef87f02d1cc52d1ae8bfca/plexpy/api2.py) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drdbtje.)^.
Young padawan.
It should be possible to compile node.js to wasm, though. Not that it would make any sense.
Twat. 
Of course, but it’s not the software developers' job to care about this. They only need to get it working in any way possible. As a freelancing software developer, I usually take the liberty of warning my clients about security issues, but if they don’t care, neither do I.
Well sure, as a freelancer that's true. If you're part of a big company though it can be good to give users the nudge to improve their security.
This is not a benchmark problem unless you actually have a super-specific problem for which you are willing to sacrifice common code practices. You should _not_ fill an array using indices. Use push. The only reason to use indices is if you really want to have specific values at specific indices, or to replace already existing values. Yes of course "it works" - but there is LOTS of code that "works" that should never be written. The reason for using `push` to _push_ values onto an array instead of assigning to a specific index is a) readability (expectations of readers) and b) the possibility of errors. Yes, if you do it right it just works. That's not the point of many rules. They (rules) are made for a "statistical space", not for individual examples. Sure it's easy to pay attention to any one (one! single!) specific example when you are called out. The point of the rules is that you minimize the error potential while writing lots of code, maybe in a team _(you can be a team in space and or in time - you yourself working with yourself a year later are a "team" too, you will have forgotten all about your past code)_, without anything that triggers your brain to pay extra attention. The assignment to indices example clearly is easier to get wrong (even if you get it right 10,000 times, as I said, the rules are statistical, about doing it a million times) than the `push`.
It's OK, you'll be even older before you know it. So, you're wrong about CORBA being different than SOAP or REST. It's all the same as the concept of RPC; you ask for data, you get data. And it's all fucked for the same reason... you cannot abstract over an unreliable transport to the level where it's part of the language.
In a big company, if the rules say that you have to use IE6, that’s what is used. This policy has been in place for a decade, so why change it when it has worked so well in the past. /s
Thanks I have new nightmares now.
Imho not yet, it only handles js and not most of the assets / other files needed. 
&gt;Parcel has out of the box support for JS, CSS, HTML, file assets, and more - no plugins needed. Also the giant animation on the home page...
what else is needed that it doesn't support? It handles a lot more than just .js
There's no mention of TypeScript.
It must be Saturday
https://parceljs.org/recipes.html How this is "no plugins" and "zero configuration"?
One shortcoming I can see off the bat is the development server doesn't have the ability to proxy requests. Also don't see a webpack-html-plugin replacement.
It wouldn't have the performance of native WebAssembly of course but I have done a few benchmarks and it seems that it has acceptable performance for a polyfill. Actually polyfilling is one of my goals. It seems that I could be a good playground for the spec authors.
See https://www.reddit.com/r/javascript/comments/7k8194/a_webassembly_interpreter_written_in_javascript/drddmd4/
WASM requires more specific types than JS does. While JS to WASM is possible it would generate very inefficient code. Imagine that in WASM each operations would have a branch for signed/unsigned and 32/64 bits. I believe more in other languages like Golang or C++.
see https://www.reddit.com/r/javascript/comments/7k8194/a_webassembly_interpreter_written_in_javascript/drddmd4/
What's wrong with webpack?
That's a good point but I believe the interpreter could be more efficient for that case. You would have the benefits of the WASM binary format and could switch to native if supported/needed. Note that I would take advantage of asm.js optimizations within the interpreter.
It handles TypeScript. Should be mentioned on the website though.
Those configurations are for NPM and babel. The bundler needs to have modules it can pull from and know how to tell babel to transpile your code. These are not a configurations for parcel itself.
Can you elaborate on this?
&gt; Young padawan. Patronising people, especially by quoting children's movies, is definitely not indicative of any intelligence or maturity.
different port, /api, etc
This looks handy if you’re developing a SPA. Not so much for a more complex MPAs with a server backend.
Sure - maybe for example you've got your API hosted on a docker server. So you'd like any requests that go to /api/foobar to actually go to docker:8080/api/foobar instead. With this "no config", without proxy, approach, you'd need to have the service be on the same machine, with same port, and try and make relative paths match up.
Just tried an extremely simple project with an `alert('foo');` line in one file and a `console.log('test');` in another. I'll paste the JavaScript output below. The output is waaaay too verbose. I understand the appeal of "zero configuration," but it shouldn't come at the expense of performance. I also don't really understand why people think Webpack is so arduous - the minimal configuration is really quite simple and it's excitability allows you to do pretty much anything. It'll take time for any alternative to gain as rich an ecosystem as Webpack has. Here's the output from my simple example: ```JavaScript // modules are defined as an array // [ module function, map of requires ] // // map of requires is short require name -&gt; numeric require // // anything defined in a previous bundle is accessed via the // orig method which is the require for previous bundles require = (function (modules, cache, entry) { // Save the require from previous bundle to this closure if any var previousRequire = typeof require === "function" &amp;&amp; require; function newRequire(name, jumped) { if (!cache[name]) { if (!modules[name]) { // if we cannot find the module within our internal map or // cache jump to the current global require ie. the last bundle // that was added to the page. var currentRequire = typeof require === "function" &amp;&amp; require; if (!jumped &amp;&amp; currentRequire) { return currentRequire(name, true); } // If there are other bundles on this page the require from the // previous one is saved to 'previousRequire'. Repeat this as // many times as there are bundles until the module is found or // we exhaust the require chain. if (previousRequire) { return previousRequire(name, true); } var err = new Error('Cannot find module \'' + name + '\''); err.code = 'MODULE_NOT_FOUND'; throw err; } function localRequire(x) { return newRequire(localRequire.resolve(x)); } localRequire.resolve = function (x) { return modules[name][1][x] || x; }; var module = cache[name] = new newRequire.Module; modules[name][0].call(module.exports, localRequire, module, module.exports); } return cache[name].exports; } function Module() { this.bundle = newRequire; this.exports = {}; } newRequire.Module = Module; newRequire.modules = modules; newRequire.cache = cache; newRequire.parent = previousRequire; for (var i = 0; i &lt; entry.length; i++) { newRequire(entry[i]); } // Override the current require with this new one return newRequire; })({72:[function(require,module,exports) { console.log('test'); },{}],4:[function(require,module,exports) { "use strict"; require("./secondary"); alert('foo'); },{"./secondary":72}],0:[function(require,module,exports) { var global = (1, eval)('this'); var OldModule = module.bundle.Module; function Module() { OldModule.call(this); this.hot = { accept: function (fn) { this._acceptCallback = fn || function () {}; }, dispose: function (fn) { this._disposeCallback = fn; } }; } module.bundle.Module = Module; if (!module.bundle.parent) { var ws = new WebSocket('ws://localhost:56748/'); ws.onmessage = function(event) { var data = JSON.parse(event.data); if (data.type === 'update') { data.assets.forEach(function (asset) { hmrApply(global.require, asset); }); data.assets.forEach(function (asset) { if (!asset.isNew) { hmrAccept(global.require, asset.id); } }); } if (data.type === 'reload') { window.location.reload(); } if (data.type === 'error-resolved') { console.log('[parcel] ✨ Error resolved'); } if (data.type === 'error') { console.error(`[parcel] 🚨 ${data.error.message}\n${data.error.stack}`); } }; } function getParents(bundle, id) { var modules = bundle.modules; if (!modules) { return []; } var parents = []; var k, d, dep; for (k in modules) { for (d in modules[k][1]) { dep = modules[k][1][d]; if (dep === id || (Array.isArray(dep) &amp;&amp; dep[dep.length - 1] === id)) { parents.push(+k); } } } if (bundle.parent) { parents = parents.concat(getParents(bundle.parent, id)); } return parents; } function hmrApply(bundle, asset) { var modules = bundle.modules; if (!modules) { return; } if (modules[asset.id] || !bundle.parent) { var fn = new Function('require', 'module', 'exports', asset.generated.js); asset.isNew = !modules[asset.id]; modules[asset.id] = [fn, asset.deps]; } else if (bundle.parent) { hmrApply(bundle.parent, asset); } } function hmrAccept(bundle, id) { var modules = bundle.modules; if (!modules) { return; } if (!modules[id] &amp;&amp; bundle.parent) { return hmrAccept(bundle.parent, id); } var cached = bundle.cache[id]; if (cached &amp;&amp; cached.hot._disposeCallback) { cached.hot._disposeCallback(); } delete bundle.cache[id]; bundle(id); cached = bundle.cache[id]; if (cached &amp;&amp; cached.hot &amp;&amp; cached.hot._acceptCallback) { cached.hot._acceptCallback(); return true; } return getParents(global.require, id).some(function (id) { return hmrAccept(global.require, id) }); } },{}]},{},[0,4]) ```
It's not a replacemenet, it's an alternative for people who don't want to lose their mind with webpack at the beginning of their career. A part of webpack's appeal _is_ that you can configure the shit out of it if you need/want to.
With a proper IDE, import files do not matter. My folder structure is mostly flat and I don't give it much thought. What I care about are filenames: they must follow a good convention. Then I just use the fuzzy seach through the project with my IDE and don't even look at the filetree most of the time.
you can see my code example here https://github.com/dispeakble/twimc
Just so you don't waste a couple of minutes and 70 MB of disk space; Parcel requires Node 8.
How does this compare to [poi](https://poi.js.org/#/)?
Thank you, I try and stay young in mind and heart. ;)
Well no, bundling isn't as big a concern with MPAs. Why would you bundle if you're sending single pages at a time. Especially any more than your back-end framework is already doing for you. Also, SPA vs MPA says nothing about complexity. They're just different architectures. 
Exactly.
Poi is built on top of webpack, so it shares webpack's performance downside (compared to Parcel). However, you also gain the ability to use anything from the webpack ecosystem, and it also splits your code into separate client and vendor bundles by default, something parcel doesn't do quite yet. It's also much more mature, considering Parcel just came right out of the gate. All things considered, for a zero-config bundler, Poi seems like the better choice right now. It's something I only became reminded of recently when Parcel came to light, and I think it deserves a lot more love.
Waiting for when reddit comes full circle back to 'make'.
&gt; bundling isn't as big a concern with MPA Yes it is. &gt; Why would you bundle if you're sending single pages at a time Asset handling, url rewriting, bundling modules, cache busting using asset manifests, code splitting, js transforms, minification, etc... &gt; SPA vs MPA says nothing about complexity In relation to bundling it does. Configurations for bundling an MPA will always be more complex than for SPAs since things like common chunks, asset-manifests, and multi-entry will inherently be a concern with MPAs where they are typically not with SPAs. 
This looks really cool and I'm so pleased we're seeing practical examples of WebAssembly put to use for some of the more 'standard' web application problems! Well done!
Still using stealjs for the last 5 years. Still don't see a reason to move.
You can easily infer two points from the link: 1. It's slower 2. It needs plugins and boilerplate even for very simple use cases Note that I don't take sides here I just wanted to point out that the link actually already addresses that partly.
Yeah fair enough. I would have thought a back-end framework would manage that.
&gt; `import classes from './main.css';` Why does every trendy hipster packaging system now statically **import** CSS files instead of finding some other, safer way to link to them (say, a structured comment)? The second tit do this you're no longer writing vanilla JS, or even $framework JS - now you're writing modules that are "$framework-packaged-with-webpack" JS. It ties all your UI modules to one or more specific packaging system, which is the complete opposite of good, modular architecture.
&gt; `import classes from './main.css';` Why does every trendy hipster packaging system now statically **import** CSS files instead of finding some other, safer way to link to them (say, a structured comment)? The second tit do this you're no longer writing vanilla JS, or even $framework JS - now you're writing modules that are "$framework-packaged-with-webpack" JS. It ties all your UI modules to one or more specific packaging system, which is the complete opposite of good, modular architecture.
But that's like five centuries in Javascript time.
this is the dev bundle with hot module reloading. so yeah, it's gonna be a bit verbose. but still. 100 lines is not bad for hot reloading and a module bundler / require in the browser.
Heh, well v4 addresses both these points... it no longer requires extensive configuration, and it is considerably faster.
And the typical reaction, https://xkcd.com/927/ :)
There are tons of reasons why importing css is a good idea. Static analysis on your css for one, and importing the css that your file needs rather than loose implicit links between your app and your css file.
&gt; trendy hipster packaging system While you make a decent point, using defamatory terms like this is a good way to get people not care about what you say. Additionally, though it may lock _your_ code into using one or more specific bundlers (which isn't that big of a problem to begin with), the build tool usually extracts the CSS into a separate file, which can then be imported the usual way by users as they place. That, or the styles are added dynamically from JS. Flexibility isn't really lost here. If anything, this comment kind of shows a lack of context.
Make and bundlers don't occupy the same problem space. It's more comparable to using gulp or npm scripts than a bundler, which would be a smaller part of the build system, even if it _is_ the build system in some cases. If this is a joke, add the /s.
what's wrong with statically importing css files? usually the idea is that a certain component should only deal with how it's being rendered, and the css is concerened with that. maybe i am missing your point so please do explain :3
Having worked extensively with JavaScript for over a decade I've seen lots of attitudes to it. It usually boils down to fear from programmers who weren't familiar with it and weren't used to lack of IDE and compiler protections - the type of coder who usually works by writing something and waiting for a compiler to tell them it doesn't work before trying to figure out why. I ignore them - I ignored them when they said it would never take off, when they told me it would never be useful for anything other than adding eye-candy to a web site, when they told me its too simple to be useful - the list goes on. I looked at the bigger picture and the naysayers have so far all been proven wrong. 
&gt; It needs plugins and boilerplate even for very simple use cases I see that as a strong point. Don't forget many webpack plugins are actually maintained by the webpack team.
How does this output compare to Webpack's output for the same code?
Sure, but they've but stealjs has grown with the times.
Ah you're right that this is the HMR code, but it's not really accurate to say it contains "require in the browser." It contains an implementation of a function called "require," but it's not a true "require."
Seems like another good alternative to use in hobby projects and prototypes. I'd be hard-pressed to call this a "replacement" for webpack though.
No. Your reply is the only joke here.
Ah yeah you're right. Webpack and Parcel's output are similar in size without the HMR code. With a code split, the Webpack mininfied output is about half the size of the Parcel minified output (Webpack: 1.52 KB, Parcel: 3.86 KB), which I think is an issue of each "chunk" (or whatever they're called in Parceltongue :P) containing all of the boilerplate code. Interestingly, I noticed after running Webpack and Parcel on the same code in quick succession, Parcel is significantly slower. Webpack is 79ms, Parcel is 3.96s after deleting the cache and 656ms on subsequent runs. It'd be interesting to see how that changes as the size of the project grows.
The jsoncallback bit is apparently part of the jsonp request and not an actual API call. If I remove that and just put that address in it returns the expected data and if I check the debugger the page loaded that data but gives me the error I posted originally.
It's a jsonp request because plexpy and the web server are at different ips.
&gt; lol wat? No it won't. It did some years ago (fixed the article on that point), if it doesn't anymore, it's yet another broken "broken-expectation" for me :) I won't argue over the rest, eg. mixing up transport-layer and application-layer errors is a concept that should find no advocate (whatever merits REST could have on other sides). 
umm.. a weird reply but okay. all `require`s on the client side are just implementations. there is no "true "require"" yet. so yeah, i don't know what you are talking about :, )
&gt; Weak typing does mean something. In Python, you can’t do: sum = 5 + 5.0 Great point, bad example. Strong/weak typing isn't absolute, it's relative. In Python, you *can* add an integer and a float, and it will do the conversion for you implicitly and return `10.0`. That doesn't work for all types, though—you can't do things like `'5' + 5`. Languages that are more strongly typed make fewer assumptions about operating between types, and more weakly-typed languages will attempt to make a sane decision in the face of ambiguity. Python is generally considered more strongly typed than JavaScript. For `'5' + 5`, JavaScript prefers to convert numbers to a string, so it assumes you want `'5' + '5'` and gives you `'55'`. Python decides it's too ambiguous and throws an error. While this contrived example might make Python look more sane, you could argue that JavaScript is better for cases like this: `msg = 'Your number is: ' + 5`. Like you said, each have their pluses and minuses.
I felt his mention of it indicated a strong use case. A consolidated API is likely better for a startup. If keeps things simple when things are simple. As they grow, they'll want to split things up.
Set up different environments in your npm scripts and change which one you hit based on that.
Host your own simple express server with proxy support? web-dev-server is just using [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware) for proxy support. Stupid simple to set up.
I see, haven't used those before
No
I suspect the author's opinion is that config files are yucky.
That's a valid criticism, on all counts, and admittedly I was only really thinking about the case of `import 'mystyles.css'` (linking to a whole file) rather than `import cssClasses from 'mystyles.css'`, where you can then use `cssClasses.someclass` to get really nice tree-shaking of your CSS. That said it still seems cleaner for packaging systems to use structured comments to link to CSS files and then offer an API to get the parsed classes back, rather than forcing people to write *invalid* JS that chokes and throws errors in practically every other build system and execution context in the world. What's wrong with something like: /* cssImport myClasses from 'styles.css' /* import getCssClasses from 'my-packager/css-import'; let cssClasses = getCssClasses(); ... instead? It's a tiny bit of boilerplate, but it means you could potentially then compile that code in any context and using any build system (getCssClasses() could watch for the file it was called from if available and scan that file for embedded structured comments, or simply return an empty object if called outside the context of the packaging system that defines it). &gt; Flexibility isn't really lost here. It really is - have you ever tried to work on a project that needs to compile under webpack and grunt or gulp that imports non-JS files? Or had to run webpack-in-JS files through Babel (or any other source-parsing or compilation tool) in any context where you *aren't* running a webpack build? Or even taken a CSS-importing UI module out of a webpack-using codebase and tried to reuse it with any other build system? When you overload `import` to support non-standard filetypes it's little exaggeration to say you're *not really writing standard JS* any more - you're writing a new language that only works with one specific tool, like TypeScript or CoffeeScript. There's nothing wrong with that, but it's a really bad thing for naive devs to sleepwalk into without realising they're making that compromise and the inherent limitations it brings with it.
Why don't you just go on and use script tags instead. Seriously the snobbery in the javascript community is disconcerting. Bundlers bundle assets, get over it please, they've done so for years and *all of them bundle css*, which they treat as, you guessed it, an asset, which they obviously should. If the current spec doesn't support bundling css, that's committees fault.
I see the allure of parcel, but I feel like webpack has the community backing to always keep it innovating and in the forefront of the JS community. I think there is something to be said about how webpack should work out-of-box like this though.
It obviously depends on the speed of the person’s internet and computer, but in America, at least, it has been proven time and again. I don’t have proof in front of me and don’t care enough to find it, but either way that’s how I feel about it.
Does it handle .scss?
Every time I see this get reposted, I get even less interested.
When you mean vanilla js, do you mean “no dependency on any other library”?
&gt;for people who don't want to lose their mind with webpack at the beginning of their career. Not even just that. I'm not at the beginning of my career and I don't want to lose my mind with webpack. (Actually, I don't even know how that works. I just let Angular CLI set it up for me.)
That's a fair point, and it might be an advantage to some people for their code to be agnostic towards the build system they're in. But it doesn't really tend to matter much for app-specific code, since that code's likely not to be used anywhere else. If it's not app-specific or shared, it's up to the author to compile it down to allow others to use it in whatever context they like, and this is usually done for any shared code worth using.
Just put it all behind Nginx. Or Caddy if you want minimal configuration.
Wow, interesting. I haven't been following Webpack progress too closely lately, and am still getting used to the fact that it's already on v3 — and there you are saying that v4 is coming. Could you point to any discussions/examples demonstrating how it won't require extensive configuration? I am finding this hard to grok.
If you haven't thought about how people will use your app, then you already have a badly thought out application. The UI should determine the requirements for the backend.
You can do that with Parcel as well if you want, I think.
Does 'zero configuration' mean that every time a new asset type comes around Parcel will have to support it to use it?
I gave Edge about five-minutes of my time. Can't even see a reason to try it. Though, it is great for downloading Chrome on a new system.
It detects a string (require, import, src, href for example) it takes that file, runs it through a module and bangs it in. Super simple.
have you tried doing web development without Angular? there are cases where you don't want/need Angular, but still need bundler
I don't understand why more people don't just do this. Proxying requests is overkill.
Why not? Any real constructive criticism behind your reasoning here?
Is "hipster" defamatory now? I just thought it was someone who stays trendy, typically young.
Exactly, this is like the linux sucks guy talking about linux packaging software.
It's a word when used in a negative connotation, implies that intelligent and respectable authors are making new tools for the sake of it. People who use this word often lack context on the thing they're talking about.
Fair enough
No, that's the point. Chrome is fine. I have no reason to look elsewhere. I don't want to spend time switching to a new browser. I already have the usability and plugins I need. I use cVim, so I hardly ever need to touch the mouse while browsing. Things look the way I am used to. I've gotten used to AdBlock plus and the way it works on Chrome. I like the LastPass experience on Chrome. At this point, I don't even care which is the best browser. Browsers are a commodity to me. If one works, I can't find a reason to look elsewhere. I imagine many others feel the same way. There has to be something compelling to make me spend the time and effort to switch. 
Webpack 4 is still alpha software no?
A competent JS dev with no react experience will be able to make effective contributions infinitely quicker than the opposite. 
If you don't see webpack as hacks over hacks over hacks over a decent plugin you hope will continue to receive support over hacks over gotchas over gotchas over hacks, then... What's wrong with *you*?
I’m not sure I follow. If I’ve got a java server on localhost:8080, and the dev server starts up on localhost:1234, so /foo would lead to localhost:1234/foo, what are you proposing?
You have a constant that contains your API url for dev. Dev is: { root: 'localhost:1234', apiBaseUrl: 'foo' } Prod is: { root: '', apiBaseUrl: 'foo' } Url is constructed as `${root}/${apiBaseUrl}/&lt;call&gt;`
&gt;have you tried doing web development without Angular? Yes, but bundlers hadn't been invented yet.
I think the proxying solution is cleaner in the code, and removes any potential CORS issues - but fair play to you if you like that setup. 
I agree that it's a shortcoming, but I see this as an alternative, not a replacement. If I just want to setup a simple project to demo something or create a POC, this is great. If I need something complicated I will go through the work of setting up webpack. 
Would also recommend reading https://developer.mozilla.org/ms/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript. A lot of JavaScript code out there is using Prototypes which is also important to understand. 
Plus, with Microsoft's history with browsers, it's hard to recommend them to anyone else, either. Until both Google and Mozilla really screw up, very few people are going to recommend Edge. Even worse, the next Firefox is really snappy and actually has reasons to recommend it.
As I understand it you would have to build a JS runtime in WASM to handle things like garbage collection. Types would also be major hurdle. I believe there is a project like this for a Python WASM runtime. It seems pretty silly for Python, but _very_ silly for JS, since anywhere that runs WASM has a very good JS runtime already. So, possible? Sure. Anything's possible. But difficult, silly, and not currently being done by anyone I've heard of.
Alright then, lemme ask you a question: On a daily basis, an average day... What's the most deepest, most uncommon, JS feature you create in the average day? I mean I understand (key word: understand) prototyping, closures, the potential of first-class functions... you know, the kind of things that the average non-js user isn't necessarily going to know when coming over for the first time. But how truly often are people initiating these things? Kind of a weird question, on the level of "how often do you floss your teeth". I know it's hard to quantify... 
Until I looked it up as a result of this post, I didn't realize that ASM.js is actually a pretty lousy polyfill. It doesn't work on Safari or IE 11 and older. I'm still skeptical of the performance you'll get, and the utility of making (slow) WASM available on older browsers, but I could be wrong. I imagine at the very least, it's a very interesting project to work on.
It’s to avoid CORS issues.
Possible? If you built a JS runtime in WASM with garbage collection and the rest, yes. Possible. Silly and difficult though.
Yes.
Would I need webpack or this? Just wondering, I'm currently building an electron app and using gulp for the scss compile.
Unfortunately, it follows in webpack's steps in supporting things like this: import classes from './main.css'; I'd much prefer if bundler frameworks didn't hijack syntax to do compile-time magic. It makes it difficult to build static analysis tools when otherwise statically analyzable syntax incurs arbitrary side-effects, and it makes it difficult to migrate out of the system down the road :(
Has that stopped is before
You can modify this HTML element by using [the id](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById). Simple one liner: document.getElementById('df_1_2').value = "test"; Or, if you want to set it directly in the HTML element (&lt;input&gt;), set the "value" attribute: &lt;input id="df_1_2" value="test" pdmqa="assignee" tabindex="100" onfocus="return detailFocus(this);" onblur="detailBlur(this);detailSyncEditForms(this)" onchange="detailAutofill(this,'agt',true,'combo_name',false,'');" type="text" value="" size="20" name="assignee_combo_name" class="" autocomplete="off"&gt; 
Except your transport layer has meaningful errors that your clients already have built-in features for handling. Returning a 400 or 500 error is far easier to debug in a browser console, far easier to track in a server's access log, while conducting load testing with tools such as ab, etc. If you think that always returning 200 OK on every request, even when the request failed, makes *more* sense, I simply don't know what to tell you.
If you don't think you need something like this for your project, you won't need it. Especially for electron it's not necessary to bundle anything. (Although you can always use webpack for optimization, and hot-reload during development. But it's a bit of an effort to setup if you've never done it.)
Will do. Thanks
there is a video tutorial in the same channel with the script linked in the description.
&gt; Not sure why I get downvoted for a pretty simple solution... Apparently what you find simple, must people don't ;) And I have to agree, as I don't see Webpack + webpack dev server + http-proxy-middleware + days of headaches dealing with all the problems that will likely crop up being a better option than using a single simple library (Parcel). (Caveat: I've never used Parcel, so it may well be more complicated. I'm just saying that on the face of it your "simple" solution is a lot more complex than the original one.)
&gt; document.getElementById('df_1_2').value = "test"; Thank you! Thank you! My Google-foo brought me to this: document.getElementById("df_1_2").value := "test" So I was getting pretty close. Whats the difference between = and :=? And how to I make this function? 
The project is still very early so it's difficult to tell. Note that the polyfill is not only useful on older browsers but also in JavaScript compliant environment like Nashorn (where WebAssembly will probably never be implemented). I agree, that stuff is super interesting! WebAssembly was really designed and I really believe that I will become the biggest platform.
&gt; While this contrived example might make Python look more sane, you could argue that JavaScript is better for cases like this: msg = 'Your number is: ' + 5. Eh - if you want to do interpolation, do interpolation (not 'addition'). It looks much neater IMO.
Webpack was around the time of Angular (before version 2 and up)
The lack of decent documentation on their site makes that somewhat difficult and complicated. It looks promising, but it's still not mature enough. 
Seems like WASM is the sort of thing that gets projects to abandon older browsers and other non-compliant environments (haven't heard of Nashorn). It's such a leap forward, there will be "Web 3.0" (or whatever you want to all it) apps that do things impossible in any other environment. Time will tell though. Good luck with the project! Maybe I'll check it out again after I've had a chance to do a deeper Rust/WASM dive myself. I have very high interest, but very limited time at the moment.
Is it just like [FuseBox](http://fuse-box.org/)?
https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/ You should _probably_ take time to read that.
I'm honestly not sure if I've seen ":=" in JavaScript, so I can't answer that. What do you mean by "How do I make this function"? If you mean how to run it, then that depends on whatever tool your using. I'm unfamiliar with AutoHotKey personally.
Web frameworks hadn't been invented yet either.
Yeah. The main reason that I use redux-saga in my projects instead of think is that I can use actions to kick off sagas. They show up in devtools, and with intelligent filtering your application can support record/playback libraries like redux-vcr.
:= is common in AHK. I wasn't sure if carried over to JS or not. So that answers that question. How would you typically run this? 
He doesn't use semi-colons and is resistant to introducing them because it would lead to "coding inconsistencies". Not if he learned how to use lint it wouldn't
This is the best tl;dr I could make, [original](https://www.computerworld.com/article/3242165/microsoft-windows/microsofts-edge-browser-is-in-serious-trouble.html) reduced by 89%. (I'm a bot) ***** &gt; According to Net Applications of Aliso Viejo, Calif., Edge has been designated the primary browser by fewer than one in six Windows 10 users for more than a year and a half. &gt; Edge had never been a big performer in the Net Applications&amp;#039; user share sweepstakes, but in earlier data iterations, the web measurement company had painted the browser in somewhat brighter colors. &gt; Bottom line: The data from both Net Applications and StatCounter indicate Windows 10 users are shunning Edge, and former IE users are renouncing that browser at a pace alarming to Microsoft. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/7kfr2q/web_developers_may_finally_soon_start_to_ignore/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~267654 tl;drs so far.") | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **Edge**^#1 **Applications**^#2 **Net**^#3 **browser**^#4 **data**^#5
It's a completely different thing.
We'll see your FUD and raise you a DUH
[X] Prefer not to answer
No. 
&gt; - [x] Prefer not to answer FTFY (maybe, idk if Reddit supports check boxes with its markdown)
Hi /u/bornforcode, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
I wonder what would it take to get someone to switch to Edge or even a new browser? Sure, there are niche browsers for various scenarios, but something that gets a lot of people to switch. 
You can put any concept in 10 words and add "Super simple" in the end. Webpack is not rocker-science, but it's definitely not somethiing that falls under domain "simple", _especially_ since you're not talking about its usage, but its inner implementation.
Yes probably. You can connect on Twitter if you want to follow my work. 
Thanks for sharing.
I forgot the link. It's https://twitter.com/svensauleau. 
If Edge had improved JS and rendering speed like the new Firefox Quantum, it could be really compelling.
I guess I wasn't clear - I mean that if a library is going to drop a global "require" statement, it should be able to handle at least some kinds of arbitrary modules. It'd be like dropping a global "define" function and blowing up when an AMD module calls it. It really just indicates to me that Parcel isn't really designed to play well with others.
There are several charting libraries for JavaScript that would do most of the work for you. The grandaddy of them all is [D3](https://d3js.org/), which can do anything, but with a very steep learning curve. If you just want quick results, try a library like [C3](http://c3js.org/) or [Highcharts](https://www.highcharts.com/), which use D3 behind the scenes, but only give you a few options to work with.
I guess so? You already have to pass the `proxy` config to webpack to get that to work. It's a list of routes that are really just express globs and you can provide optional auth config for each route. proxy: { '/endpoint': { target: {host: 'google.com', port: '80'}, auth: `foo:bar` } } Really not much different than: import express from 'express'; import proxy from 'http-proxy-middleware'; const app = express(); app.use('/endpoint', proxy({ target: {host: 'google.com', port: '80'}, auth: `foo:bar` })); app.listen(80); 
This is such a common use case it's weird it isn't among the first things to include. [create-react-app does it well](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development), one `package.json` line to handle the common case (dev server `/api/*` to another port), as well as support for all `http-proxy` options for anything beyond that. Along with *support* for various `.env` files, it doesn't *complicate* the configuration in any way, because it's all optional for when you need it. Ideally the build and development tooling should have sensible defaults and get anyone started immediately with 0 configuration, but also *support* extensive configuration for whatever testing, development, staging and production environment setup the project requires. Last few years the proxy config that has been part of *every* JavaScript and TypeScript project I've worked on. That being said, competition and alternatives are always good in open source, as the projects can learn from each other.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [facebookincubator/create-react-app/.../**README.md#proxying-api-requests-in-development** (master → bd682de)](https://github.com/facebookincubator/create-react-app/blob/bd682de1f6b71ea4192b14f66c3bc22e658b5b87/packages/react-scripts/template/README.md#proxying-api-requests-in-development) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Well I hope that helps some people understand.
If you want that kind of interaction, you'll need Javascript, yeah.
Awesome! I’m really glad 👍
So far I have been able to place with the script and get it to execute in Chrome's Dev Tools Console. Have no idea how to get it to execute on its own. lol I'm getting closer though. 
Will this dethrown webpack?
In what position do I paste it into my code?
Hi /u/based2, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hi /u/digitalnico, For javascript help, please visit /r/LearnJavascript. Thank you!
Competition is good. I hope webpack adopts some ideas from Parcel
Mind showing me where to paste that code to make it work?
Where do I paste this into my code?
Without being a programmer and being willing to spend hours reading code, the only way is through trial-and-error. And that'll be quicker anyhow.
Link isn’t working for me but if I’m understanding you correctly, it sounds like what you want is a select component with months as the options. You could easily make that yourself