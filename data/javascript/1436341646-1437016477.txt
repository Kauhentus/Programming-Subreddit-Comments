It just happens to cover all 3 scenarios: &gt; [].concat() [] &gt; [].concat(5) [5] &gt; [].concat([5,3]) [5, 3] And it also does this (which isn't relevant for this use case): &gt; [].concat(5,3) [5, 3] So, whatever "g" returns, concat turns that into an array which we can then blindly apply to "f". Well, that line is pretty nasty, really. In general, I think it's kinda bad to write code which relies on the edge case handling or behavioral modes of the used functions. On a closer look, it always appears that there is some kind of mistake, but that edge case is then actually handled by that called function in a way which makes the code behave reasonably. Kinda like: function cap1(s) { return s[0].toUpperCase() + s.substring(1).toLowerCase(); } function cap2(s) { return s.charAt(0).toUpperCase() + s.substring(1).toLowerCase(); } One might think that the second one also breaks if it's called with an empty string, but that's actually not the case. "charAt" just returns an empty string if you're out of bounds and so does "substring". Maybe one should add a comment in cases like this.
Thanks, this is what I was looking for. 
If you look at what /u/I-fuck-horses said in context, they're really saying "async/await isn't completely new functionality on its own, it's just syntactic sugar over what ES2015 can do today". They went on to mention "classes" as another thing that is not new functionality and already existed in ES5. On the other hand, generators themselves are new in ES2015.
How is this being asked in 2015?
https://www.javascript.com/news
I don't find a link to the source code. Is there a repository somewhere ?
So you fucking dimwits find it worth your time discussing THIS??? **YOU** guys are what the people they talk about in the story about failing open source projects where everybody wants to talk about the color of the bike shed next to the power plant because you have nothing to contribute to a technical discussion about the power plant. You are so worthless. &gt; The principle that the amount of discussion is inversely proportional to the complexity of the topic has been around for a long time, and is known informally as the Bikeshed Effect. http://blog.codinghorror.com/procrastination-and-the-bikeshed-effect/ https://en.wikipedia.org/wiki/Parkinson's_law_of_triviality Of course, now you can turn to discussing *this* instead. Still avoiding anything technical. I'm out though.
TIL, OneTab. Installed it. OMG how did I miss this add-on? Love it! P.S. Come to think of it, Tabs are like Bookmarks.
For the same reason someone made zepto while there already was jQuery.
Nice! The every 5 minute hit is only when I am streaming so it will not be every single 5 minutes. I shouldn't hit the 100k at all. I will definitely look into this, appreciate it!
Because I wanted something even smaller. 9kB Zepto does not come with any animation support. My library in 6 kB already has animations.
I've made a site comprised of all my projects I work on over this past spring break. If this is what you are looking for just pm me and I can help you further. http://rgbballphysics.weebly.com
Ah. It's been a while but I made basically a canvas people could draw/color on and print/dl the canvas. It looks like printing the GIF will be similar. If you can't figure it out I may find some time to dig up old code and see if it works the same/similar to your need.
If "querySelectorAll" returned an array, that would be better, but since it is not the case, I think it is better to stick with the standard instead of replacing it. Worst case scenario, you found an inconvenient with every single function and now, to understand your code, I have to learn your "version" of the standard. That is an inconvenient for me greater than using array like objects. Now, if they add to the standard, that is a different story since everybody will know that and is not something that people are only going to find in your code. But it is not ideal either, "Object.getOwnPropertyNames(window).length" already is greater than 500. I think there is a point where patching only make things worse and you need to start from scratch to make the API concise.
You can use https://github.com/mzabriskie/axios. It is heavily inspired by the $http service provided in Angular.
&gt; Sure, you can grab Angular and two dozen extensions and MAYBE get SORTA close, but that's a maintenance nightmare. The CTO of a company I worked with traced a bug back to their code and filed a report only to be told it was serious, but they didn't know how to solve the problem without breaking other things in the framework (btw, their support you pay so much for is terrible). If you go to a Sencha conference and listen to conversation, you will see that working around Senchas problems is very common. Give me React and let me build out the components in a framework that doesn't have me constantly working around framework edge cases.
This seems like a really cool exercise, I'll actually do it for fun. It seems like a great way to remind yourself of the basics and the advanced features of JS.
I would have like more details on each task, for example in Simple Selector function should I use Sizzle or just take a look on how it works, etc.
I'll have to look in to it. I believe it's a thing you download form Google and put on to your browser. You can go ahead and download it and start playing around with it if you want. I'm at work on my work computer and I don't want to download anything on to it. I'll have to wait till I get back to my home comp to do the download... which I think is free... we should probably look in to that...
The simplest collision resolution is just reversing the signs on your vectors. But first make your vectors normal to the surface it is going to collide with. Just treat the puck like a particle.
Yep, I think that's our next direction here. It will be cool to learn how this thing works!
Article too opinionated... Frameworks are invented out of need. Where there are better options, we switch. Newer needs arise. Frameworks adapt to newer needs. Then we switch again. This is how technology evolves.
Since I present my opinion, I reserve the right to be opinionated :) &gt; ...we switch ...Then we switch again Why accept this overhead of re-learning and switching frameworks every couple of years? The idea I present in the article is based on my own personal experience in a few projects I have done in the past two years. I have had good success in developing apps with "do-one-thing" tools; while frameworks have actually slowed me down. Anyway, I'm presenting **an** idea. Obviously there are other valid approaches to web development. Thanks for the feedback.
I wouldn't expect my default compose to spread arguments after the first function. I know lodash and underscore don't, and I would be surprised if Ramda did. Generally speaking all the functions after the initial one are expected to take single arguments. On the bright side, that leaves you a nice clear compose defnition var compose = (f, g) =&gt; (...a) =&gt; g(f(...a))) It seems like it's too hard to say that every function you compose won't want an array as an argument. Presumably if you _did_ have a scenario where a function returned an array, and the next wanted it spread, you'd have a helper function for that scenario...and do some composition :-) var spread = f =&gt; a =&gt; f(...a) e.g. http://www.es6fiddle.net/ibuu66dh/
For everything.
&gt; Why accept this overhead of re-learning and switching frameworks every couple of years? When the advantages outweigh the disadvantages. Couple this with the fact that neatly-done frameworks with low learning curves, are attractive. Without this willingness to adapt, there is no JavaScript. We're stuck with COBOL or older languages. When you remember the days when people write code typing 1's and 0's (Machine Language), you'll realize why the innovations today (Object Oriented Programming, API's, Libraries, etc...) are most preferred compared to 1's and 0's programming.
I think you may be misunderstanding the point of my article (which is probably my fault, as the author). I'm not claiming it's not good to adapt and that innovation is not good. And the fact that I can see a few disadvantages in frameworks certainly does not indicate it. It follows from your words that not using frameworks = lack of innovation and progress. But I'm sure you can agree that innovation and progress can come in different forms. I'm merely presenting one of these forms.
Hi all, I was wondering if there was a way to change the behaviour of a scoped variable when it's exposed through the revealing module pattern. I'm trying to modify an existing library and I don't want to actually have to change its source code. Any help would be appreciated. Thanks!
You'd have to change z as well: x.z = function(){x.y();}; I'm guessing that doesn't help in the context of your challenge, though.
Extending is safe because you're not overriding the prototype, rather creating an instance member which is a bound version of the prototype. For a subclass, the method will initially still be a reference to the prototyped version until super at which case bind(this) creates a new, subclass instance-specific version of the method assigned to _that_ instance. This keeps all bound methods out of the inheritance chain.
Here was my answer: http://codepen.io/anon/pen/GJxbXR I was actually pretty close before I asked for help. I used some of /u/ForScale 's solution to help me. Thanks everyone!
Good stuff, man!! It looks a lot like where I'm at with mine now! And I think the method we're using has a lot of cool applications... I mean, point-and-click, on the spot element creation... That's pretty damn handy, right? I just learned 3d animation in html/css too, so... Think about walking through a virtual house and just creating virtual objects in the house, placing them at various locations. Pretty cool! Let me know if you want to collaborate on any of this kind of stuff, /u/cleatusvandamme!
I don't know of any videos on "advanced" topics and that can be a very broad topic anyways. What specifically would be your end goal and where are you now?
at this point our company will allow only Accepted ES standards in our nodejs apps. So ES7 is out of questions.
Thank you for your response!
Thank you!
&gt;MIT license Um.
Kyle Simpson has a great advanced javascript talk on frontend masters and pluralsight.
Interesting. In that case I would probably get myself comfortable with React and probably something else like Angular and really understand the MVC aspect of it. It's not really JS specific but you should be able to express it in terms of JS/Web Apps. I actually interviewed with them and they asked many questions about the dynamic nature of JavaScript although I will admit it was with their IT dept and not Engineering, so take that for what it is worth. Still never hurts to be able to explain the prototype chain and how to do "inheritance", why things like namespacing is important and closures. Just generally I have noticed recently people asking tons of questions about String manipulation and trees. So you might wanna practice that a bit and maybe throw in a regex or two to make them know you mean business. Even got fizzbuzzed on an interview recently, which was funny. Refresh yourself on O-notation, design patterns and concepts like that. Definitely get your answers to "What is your favorite algorithm?","What is the most complicated algorithm?", "What is a technical challenge you solved..." ready.
&gt; The constructor doesn't replace getInitialState. &gt; getInitialState is replaced by setting state in the constructor: Previously you defined the initial state of a component via getInitialState, now you do it via the constructor. The precise mechanism for doing so is not relevant, for all intents and purposes the constructor subsumes and replaces getInitialState in class-based components. Replacing doesn't mean doing it in the exact same way or there's no reason to do any replacement.
True. I had assumed that the React devs would have been using something like `call` or `bind` themselves if they were shuffling the original function around or calling it from an async context. I suppose if they were working off of the assumption that `React.createClass()` had already bound the function for them, they wouldn't do the same work twice.
Hmm you are right. Another instance of this pattern causing confusion.. heh. :) We have run into the "method can only be bound once" causing issues a couple of times, but I can't remember the exact situation that led to that.
Yep, some of them are very basic, but some dive in deep. Kyle Simpson has a good one, there is an advanced functional programming one in there. Just browse through their course list. It may not be what you're looking for. In which case, forgive me. However I felt it rather helpful in my career so I figured I'd share. 
MVC definitely. FB has their own library which is MVC and I am sure they must use this. More essentially though what is it? Why is it important. For things like prototype chain, it is important to understand both what it is and the distinction from classically inherited languages. Also I think contrasting it to a language like Java is a great way to explain it. Things like closures you need to really understand it and be able to express it in 1 sentence and give an example of where it would come into play. Regex is mildly important. Its not an everyday thing but its the type of skill you can use to make complicated tasks easier. I use it to search and replace in my text editor more often than i do in code. I was interviewed by someone who was less technical than me, he knew it and i knew it, and he apologized after asking it. BUt never the less I answered it. Patterns here: http://shichuan.github.io/javascript-patterns/?utm_source=javascriptweekly&amp;utm_medium=email And definitely be able to articulate why a pattern in general is useful. I joking brought up a sleep sort once and was quizzed to death on it. Take it seriously, if you have an algorithm other than a sort it may stave off some follow on questions. Knuth is your friend. If you dont have real world experience be prepared to talk about hobby projects. If you dont have any I would get a couple together and make sure they are on github. Dont try to fake a history or anything, it can just be for learning purposes. Oh you know git right? You will definitely need that.
Hi /u/FeleCro, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `infinum.co`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [infinum.co](/search?q=%28and+site%3A%27infinum.co%27+author%3A%27FeleCro%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|29|88%
I want to allow the user to edit these elements from the front-end using AJAX. The site is http://listling.com, and I want them to have a little edit pencil next to each element on the site that brings up an input with the value of that element pre-populated so they can edit it.
valid point about returning an array. however, as above your example doesn't enforce correct context.
You don't have to worry about React or other MVCs. I had my Facebook interview last week. They asked me about recursive tree traversal. Searching an array of integers and its time complexity. Also asked me to create a simple layout to test basic knowledge of positioning and such. Good luck. 
I learned a lot from the Crockford on Javascript series, you can find those on youtube. After that, do this: https://github.com/rmurphey/js-assessment 
As you can see many of them are fixes for OLD browsers, eg: * Safari&lt;4 (before June 2008): https://gist.github.com/rwaldron/8720084#file-jquery-js-L1064 * IE&lt;8 https://gist.github.com/rwaldron/8720084#file-jquery-js-L1044 and lot of these fixes are to features jCore doesn't implement.
fyi. Pluralsight pretty much has all the frontendmasters.com stuff in it for $25/month plus their other stuff.
Thanks, good point. Wrapping it in all in an IIFE gives me a warm feeling of encapsulation, but I guess it doesn't serve any real purpose. Any other thoughts on this approach/pattern?
That's certainly one way to do it - but you already got all the data in the client, so the only useful information is if saving the value was successful or not.
Have you tried using "%7C" in place of the pipes? Or [encodeURIComponent()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent)?
Cool. I'll check that out. Thanks 
Hmm, well I tried encodeURIComponent() but it seemed like it didn't help at the time. Currently though %7C when I am testing it seem to be the proper approach. Thanks alot!
very creative but awfully slow, I've been waiting 20mns for a 80x20 term window with 180 captured frames (still writing eof) and it seems to use only one CPU. Here's an [example of omggif used as a worker](https://github.com/meemoo/iframework/tree/master/libs/omggif) if it can help. [edit] found a 2.6MB output.frames.json file, maybe running ascii animation was not a good test case :-) 
Is it standard practice now to do bundling of scripts instead of using CDNs?
channels seem very similar to observables (kefir.js). What are the differences between them (advantages/disadvantages of one over the other)?
How does that work with libraries that use the require() syntax? I haven't done any major javascript work since jQuery went out of style. From what I've seen recently, it seems like everything is modularized and libraries no longer provide static distribution builds that you can simply reference.
How do you get an interview with FB with this level of knowledge? Im not being mean, I honestly am a little flabbergasted.
To be honest, I don't generally work on front-end projects without using browserify. A good module system is one of the things I really appreciate from the start of a project. I understand that you don't want to change lots at once about your codebase, so I think packaging up things into the module pattern is an *excellent* idea if you have variables or functions that could be either private to a particular module, or bundled into a module to be 'imported' (read, used) by other modules. After that, a refactor to use requirejs, systemjs or browserify wouldn't be so daunting. 
I've been working on one also, that will be isomorphic, on npm, also very small and unit tested. And open source and documented blah blah blah... If anyone wants to help. Not intended to have total parity with jquery, because that seems kinda pointless to me. https://github.com/rossPatton/quick.js
The constructor will replace both componentWillMount and getInitialState. ES5 { getInitialState: function () { return { prop: 'value' }; }, componentWillMount: function () { // some componentWillMount code } } ES6 { constructor(props) { super(props); this.state = {prop: 'value'}; // some componentWillMount code } } 
Google 'Monkey Patch' and see if any of the approaches can fit with what you need to do. 
I guess that depends on what your definition of correct is. Personally, I largely find that when I start doing functional js, `this` isn't normally a consideration. When it is, however, it's certainly not safe to assume that the `this` I want applied to the component functions is the same `this` that the composed function will apply. If the functions I'm composing are methods on an object, I'll often want to keep _that_ `this` e.g. let c = compose(x.methodA.bind(x), y.methodB.bind(y)) With your `compose`, if I don't bind my methods, then you end up applying whatever the global scope is, which would certainly be wrong, and if I _do_ bind my methods, then your apply does nothing. Much like the decision to spread the return into arguments, I feel that the decision of what, if any, `this` needs to applied to the component functions is best left out of the `compose` function.
For interviews, it doesn't matter. Pick one thing, and know it backwards. I mean top to bottom 100%, and the backstory. Showcase that. The want to know *how* you work, and that you are thorough and professional. The exact stuff they want you to know they'll teach you, or assume you can learn it.
Requirejs has support for bundles, if I recall correctly there's an option where you can specify the bundle route. I don't do heavy js stuff so haven't come around many micro libraries that can't be referenced with the script tag. I still use jquery but only where the vanilla js makes the code worst ( like being unreadable) . 
Watch every JSConf video on youtube. Then, go out and research all of the concepts and libraries/frameworks you learn about through those videos.
Memes are not allowed on /r/javascript *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
I still have to implement safety nets to only accept whole numbers, but I will get to that later :P Please let me know if you think this can be improved! I'm trying to learn JS at the moment. EDIT: Code updated with safety nets.
Advanced is best 'experienced' in pair programming. IMO, thats the absolute best way to learn the advanced stuff.
Nope, `this` would be whatever context the method is executed in. Meaning if you were to create a function and assign it: let foo = {}; foo.method = compose(f, g); If either f or g reference `this`, it will correctly refer to `foo` not the global scope. In the arrow function example, bind would fail since arrow functions cannot be bound, .applied, or .called. 
Yeah - that's more elegant than what I have right now and it makes sense. The issue becomes if I want to add more complexity to the user's &lt;input/&gt;, with sub-fields that need user input. For instance, let's say the initial &lt;input/&gt; is a link. once they've inputted the new value, I scrape that link for images and I let the user choose one of those images, ala pinterest. This is what becomes more complicated with jQuery alone (mainly because it doesn't include React's simple communication between modular elements and jsx templating in the view).
Definitely! Send me a DM and we can chat!
So if it only accepts whole numbers than it's integer to binary, not decimal to binary?
Hey Reddit, here's the second post in my Making Music in the Browser series. The Web Audio API has been around for a while and covered many places, but I hope you'll find it a valuable overview of using the API. Thanks for reading!
I think they meant decimal as in base ten.
http://browserify.org/ lets you bundle pretty much any node.js module to run in the browser, including node.js builtins such as `events`
It really isn't that strange. If there is no left operand of the addition operator, it assumes it's zero. +10 **=** 10 +[] **=** 0 [[]][+[]] = [[]][0] **=** [] [[]][+[]]+[+[]] **=** [] + [0] = "00" ++[[]][+[]]+[+[]] **=** "10" &amp;nbsp; Broken down in order: ++[[]][+[]] + [+[]] = ++[[]][0] + [0] = ++0 + [0] = * "1" + "0" = "10" &amp;nbsp; * I'm kind of cheating on the first part of this line because you can't syntactically increment an empty array object.
These videos are the answer to your question, especially the third: 1. [Crockford on JavaScript - Volume 1: The Early Years](https://www.youtube.com/watch?v=JxAXlJEmNMg) 2. [Crockford on JavaScript - Chapter 2: And Then There Was JavaScript](https://www.youtube.com/watch?v=RO1Wnu-xKoY) 3. [Crockford on JavaScript - Act III: Function the Ultimate](https://www.youtube.com/watch?v=ya4UHuXNygM) 4. [Crockford on JavaScript - Episode IV: The Metamorphosis of Ajax](https://www.youtube.com/watch?v=Fv9qT9joc0M) 5. [Crockford on JavaScript - Part 5: The End of All Things](https://www.youtube.com/watch?v=47Ceot8yqeI)
Alright will do, thanks!
Am I the only one who absolutely hates videos? Give me an article any day. 
I guess I just see the application of `this` as an orthogonal concern, and would attack your situation differently let foo = {}; foo.method = compose(f.bind(foo), g.bind(foo)) That way if I needed to borrow the method of another object, I would have that capacity. let foo = { method : function() { //code contains `this` } }; let bar = {}; bar.method = compose(foo.method.bind(foo), g.bind(bar))
Hah, forgot what my flair was for a second. 
Great start! Besides more compact ways to implement the function, I have some ideas for general improvements you can use elsewhere too. First off, you shouldn't use `alert` in that function. You should return a value (I see it commented, I assume it's for debugging). When the input is invalid, you should use `return null` or `throw new Error("message")` (look up exceptions). Also there's a compact way to modify numbers/strings in JavaScript. Instead of `a = a + 1` you can use `a += 1`. The same works other operators (-, *, /, etc). I like the syntax but some might disagree with me.
Why do you need a mechanic if you have the parts yourself ? I have a nice engine in my garage so it's basically a car. Setup is just as important as the code.
&gt; I think it is better to stick with the standard instead of replacing it. Replacing? It's just a utility function. Would you always repeat that event delegation code I showed earlier? Do you think the quality of your code would improve if you repeated that 5 times? &gt; Worst case scenario, you found an inconvenient with every single function and now, to understand your code, I have to learn your "version" of the standard. You mean... like jQuery? Anyhow, I'm really not sure what kind of scenario you envision. Wrapping some of the vanilla stuff yourself is something you'd do in small vanilla applications. Like, a calculator, a game which uses some DOM stuff for the UI, or a questionnaire which is supposed to be iframed, and things like that. If you use any of the frameworks (or game engines), there is usually a preferred way to handle DOM interactions. So, there would be maybe 100 - 1000 lines of code and this utility function would be one of a handful or so. You won't feel overwhelmed in the slightest. &gt; But it is not ideal either, "Object.getOwnPropertyNames(window).length" already is greater than 500. You don't have to make everything global, y'know? That's one of the main reasons to use modules, actually. That imported "qsa" function in my example wasn't global. By the way, this is also what made that tool-tip and "go to definition" work. That module was explicitly imported. It wasn't some global thing which just happens to be there. That's why the code analyzer knew that it existed, where it came from, and how its signature and documentation looks like. Creating structure declaratively is really awesome. If you haven't used modules before, read this article: http://www.2ality.com/2014/09/es6-modules-final.html In ES3/5 code, you don't have to make everything global either. E.g. if everything is in one file, you can just wrap the whole thing in an IIFE. Alternatively, you can use "namespacing". That is, stick everything in one global object which contains all of your stuff.
Point taken.
&gt; There is only a minified version available for download. Since the size of the library is its biggest advantage I don't want people to spread unminimized (=bigger) version. So this was intentional. Okay... You're doing yourself a big disservice.
You _could_ use jeditable, but sometimes that's overkill. 
Thanks hectavex, you expressed it the way I wanted to. I think the bug in the codepen.io example is there is a sign that is not getting reversed somewhere, otherwise it would probably work perfectly.
;)
You should check out: https://yahoo.github.io/gifshot/ - I used it to achieve something similar recently and it was super-simple and super-effective.
Just return the promise. Using generators to solve async problems is silly and over-complicating it.
I love ::.
Thanks, il read through the code
Hey I know you're looking for videos and I would totally agree that pluralsight is an awesome resource, think they give you a free week trial. I would check them out. But also if like you said you're an auditory learner, I have thoroughly enjoyed listening to the javascript jabber podcast on my way to and from work in the car. Just download a free podcast app like Player FM and you're good to go. I went back and looked for episodes that covered generic javascript topics rather than random one off libraries that people wrote and it's really helpful to hear 4 or 5 people each give their best explanation of advanced topics like closures the nuances of the 'this' keyword and promises etc. My older brother who does programming thought it was kind of odd that I liked programing podcasts. But honestly it's a great way to help you work out your own understanding of concepts while you drive which for me has been a huge boost in productivity 
This looks great, thanks for sharing. Got any more info on popper, my google-fu failed me?
Are you manipulating the `document.body`'s DOM or are you manipulating something `window`-wide? DOM generally is `document.body` (or just `document`), whereas `window` is more stateful with things like the History API and turbolinks/pjax, things that manipulate the window state. Fire events from things it affects, DOM typically affects `document.body`, but you should generally trigger the element's parent, as it more often than not can bubble upwards to `document.body` unless, ofcourse it is body-wide.
Don't forget the one that's literally called [Advanced JavaScript](https://www.youtube.com/watch?v=DwYPG6vreJg) ;)
Awesome! Did you download it?
Not yet - I'm very close (and excited) to open-sourcing this though! Will drop a link here/twitter once it's ready..
http://devchat.tv/js-jabber/
Alright, got it! So... have you tried it?
I was not sure how to use it haha. I messed around with it a bit but didn't now how to really use it.
Do you know how to use it?
Yeah... I'm getting the hang of it...
Great how do you use it?
If JavaScript didn't have to be backward compatible, it would be on by default, learn it.
Click the cjs up in the top right corner of your browser. Then check the "enable cjs for this host" checkbox. You might have to refresh at this point... Then type in your javascript. Then when you're ready, hit save. It will refresh the page and your script will be present!
There might be some confusion... &gt; so I think packaging up things into the module pattern is an excellent idea Based off of his response, I think he's speaking of the Node-style module pattern, i.e. using `exports` and such. From your question though, it seems that you were thinking of the [revealing module pattern](http://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript), which indeed would create additional copies of each method on the objects, just as you were concerned with.
&gt; You are transforming a node list to an array, that is all your function is doing No, it's not a function which converts a NodeList to an array of Elements. How often did I have to repeat this by now? 5 times? Could you please pay a bit more attention? &gt; If your function is not doing anything interesting, it is just renaming a variable, witch is silly. That sentence doesn't make any sense whatsoever. Renaming a variable is something you do in your text editor. It's not something a function could do. You can't even read the name of variables. var foo = 'bar'; You can't get ahold of that "foo". Anyhow, what about my other examples? All those functions are much simpler than "qsa". Do you think they shouldn't exist either? By the way, you won't find any support for your theory that a function which only does 2 things is too simple and therefore doesn't deserve to exist. There is no one who shares your point of view. Small functions are inlined nowadays. There is no downside. There are only upper limits. Like, a function shouldn't be longer than X lines, its cyclic complexity shouldn't exceed Y, or it should take at most Z arguments.
You pay more attention, that is all your function does. Renaming a variable is when you do things like var longIdentifierThatIsInconvenientToType = function ... ... var litiitt = longIdentifierThatIsInconvenientToType litiitt(...) You gave the variable another name, renamed. Now you are clamming to know everyone's opinion? That is just silly. Let me give you an example of a function that is too short to make any sense then function increment(x){ return x + 1; }
I be spreadin' arguments like I be spreadin' booty cheeks
It appears to be an anonymous function, but I don't know how helpful these examples are. 
try a different course, this one isn't very well put together and the code is plain wrong.
Replying for later
Why are they the future?
They're the future for people who don't want to use [the real future](http://facebook.github.io/react/). :)
I like the way you think. :)
I'm actually wondering what the differences between React and web components are. They seem very similar, except for the fact that React has state and once you update the state everything is re-rendered for you. From my limited understanding React seems like it would be better then web components.
Although web components and React seem similar, they are pretty different. The only real similarity is component-orientation. Cross-browser web components aren't trivial to create out-of-the-box, so you need a framework. If comparing with Polymer, then: * React's performance is vastly superior to Polymer last time I checked, and this will likely always remain so (barring Angular-style performance hacks that infect your codebase). Either way, it's ridiculously easy to make a performant React app. * Polymer requires sending heavy JavaScript to the client unless you make some really large trade-offs. But both React and Polymer will require a lot of JS to be sent. * React Native is pretty great. React is becoming more or less independent of the DOM. It's more of an idea. * Declarative components in React are a lot easier to reason about. (props, state) =&gt; html. Just better architecture overall. Component composition without global variables and destroying performance/encapsulation is a breeze. * Server-side rendering. * Better tooling, more power, less framework dependence, less to learn, and less cognitive load because React uses JavaScript instead of a template language. * Babel has JSX support built-in. You can easily write Babel plugins for React. You can lint your React code. You can type-check it. Babel will make your React code faster -- for free. * Polymer uses two-way binding. Eek. * React isn't tied to a slow-moving spec. Web Components aren't even set in stone yet. Still nothing concrete after all these years. * React has a lot more traction right now. And the React community has attracted a slew of smart, enlightened engineers, so you will probably learn a lot and become a better engineer. * Technically, one day React could render to web components. There is an advantage to web components, which is that they can, in theory, be easier to integrate into an already-established website. In practice, it depends.
&gt; _"It's perfectly fine to be a redditor with a website, it's not okay to be a website with a reddit account." - Confucius_ That is to say, that you should be submitting from a variety of sites, and that a majority of your submissions shouldn't be from the same site. Here, 88% of OP's posts are from the same website, which is way too high for any single site.
Clearly the better choice for now, but if one has to 'win', won't a native API win out eventually? It seems like every framework has a life cycle - jQuery and Angular both had me excited at one point but aren't useful to me now. I love using React but am trying to stay non-committal.
A good portion of what you described is solved by Vulcan, which let's you "compile" polymer projects so you don't have like 100 requests for a simple page. 
Do you know ["You don't know JS"](https://github.com/getify/You-Dont-Know-JS)?
What are your reasons? 1. I don't like the "mental overhead" the || operator imposes on me. 2. It will also eat up falsy values. So my answer must be: 1. Sorry to say so, but that's rather a reason to take pity for your mental capacities than not to use the || when it seems appropriate - and I know that's not what you meant, but that's what your post inspires; which brings me to: 2. Know when not to use it. For example, if you want to normalize an integer value, better use the binary brother "|" instead of "||". Also, don't overuse it. If you got more than 4 lines of defaults, better use an object and whatever function to normalize to defaults. Otherwise, use || when you need it.
The linear easing function have a good reason to exist. Since you have to pass some code to another function you may end up with really small functions if you have to pass a small amount of code. How is that the case for qsa, I don't know. And I think that you should avoid creating aliases for the standard. If you are unhappy with the type returned by a function, you should convert the returned value instead of creating another function that returns the type that you want.
A note to keep in mind that using true comparisons can be finnicky in some transpliers, since most of them do not truly distinguish between undefined and null. So calling `eatFruit(null)` wouldn't change null to strawberry. `null === undefined = false` `undefined === null = false` `undefined == null = true` `false == null = false` `0 == null = false` `null == null = true` `typeof null = "object"` `typeof undefined = "undefined"` It's one of the headaches of writing a library, really you want to type check your variables ``` function eatFruit(fruit) { if(typeof fruit != "string") { fruit = "strawberry" } } ``` Instances can be done in one of two ways `Object.prototype.toString.call(variable) == "[object Date]"` or `variable instanceof Date` Both have their own caveats `document.body instanceof HTMLElement = true` `document.body instanceof HTMLBodyElement = true` `Object.prototype.toString.call(document.body) == "[object HTMLElement]" = false` `Object.prototype.toString.call(document.body) == "[object HTMLBodyElement]" = true` `console.log instanceof Object = true` edit: formatting
Yes. 15+ years ago. We called it XML/XSL
components on the web
I agree that it's safe to use if you know when to use it and when not to. The problem arises when you don't know if the other developers who'll touch the code are also aware of when not to use OR for defaults. Can you explain how this would work with | and integers? Don't think I've ever seen it before. 
Patronizing developers alike, regardless if they are beginners or professionals, is a bad idea. The beginners will not get the information they need to become professionals and the professionals will just feel buggered. Now for the smaller sibling of ||, |: this.myNumber = conf.myNumber | 0 // will coerce to integer, falsy values will yield "0". 
Actually, I think the real future is [this](https://brendaneich.com/2015/06/from-asm-js-to-webassembly/). But components are the interim.
Yes. Polymer always felt more like a showcase to me, not a real framework. I don't see anyone trying to roll Polymer out into production apps. It was a demo of a specification that Google was pushing. Sure, it's been 2 years and the specs aren't final, but that's common. However the idea is the same idea that pretty much all major JS frameworks adhere to now with components and directives. Angular, React and others have all said they have a goal to natively work with Web Components when the spec is finalized.
Well, that link doesnt go anywhere meaningful?
If you work on a longer project, you shouldn't downgrade your tools, you should upgrade your documentation. The Technical Documentation of your project should lay out the guidelines for these kinds of cases.
Really? Have you got a source for that for React? I knew about Angular, but I thought React expressly dismissed it.
Don't worry, I'm building and maintaining business critical apps and I am completely lost.
Fuckin' weird... I just made something very similar yesterday: http://codepen.io/ForScale/pen/XbEYYN I wonder if this is like you buy a blue car and you notice all the blue cars on the road kind of thing...
There's a similar brethren for &amp;&amp;, binary AND "&amp;", but this is not near as useful for defaults.
[**@wesbos**](https://twitter.com/wesbos): &gt;[2015-05-12 15:17:23 UTC](https://twitter.com/wesbos/status/598144948559605760) &gt;Super excited for this new O’Reilly book [*pic.twitter.com*](http://pbs.twimg.com/media/CE0Jp9_WMAI6eZB.png) [^[Imgur]](http://i.imgur.com/FzAkZw0.png) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/3coewa%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Yes, it's called React.
Most important bit I think: &gt; Make sure to use the built-in lat() and lng() methods as these property names are very likely to change again in future! latLng.k/latLng.D just happened to work, they weren't in the official documentation.
That is a great point. So assuming we're sticking with only composing two functions, we're looking at something like this let compose = (f, g) =&gt; function(...a) { return g.call(this, f.apply(this, a)); }; Edit: And if we wanted to compose any number of functions it seems like this would work let compose = (f, ...fns) =&gt; function(...a) { return fns.reduce((result, fn) =&gt; fn.call(this, result), f.apply(this, a)) };
 function isNull (obj) { return obj === null; } function isUndefined (obj) { // Why people overwrite 'undefined' // pre-ES5 is beyond me... return obj === void 0; } function isNullOrUndefined (obj) { return isNull(obj) || isUndefined(obj); } 
&gt; Sorry to say so, but that's rather a reason to take pity for your mental capacities than not to use the || when it seems appropriate When I'm programming something the last thing I want to do is waste my mental capacities worrying about using || the right way. I just want to write something that is simple and correct. I've got much more important things to think about than some piss-ant default argument handling. People need to break the mentality that hard to read code is a badge of honor. It's not. Hard to read code is a failure on the behalf of the person who wrote it. 
or just redirect them to http://browsehappy.com/ both are as annoying for the user to be honest but I guess one might really need those fancy web-workers
yep looks good. Edit. Man the syntax is weird with the arrow functions. It's hard to tell in `...fn.call(this, result), f.apply...` the f.apply is the second argument to reduce, or a comma operator on the return value of the arrow function. I wonder how operator precedence works in this case. 
Hi! Just an update - I used this to get it working :) var intr = '&lt;?php echo $_GET["introducer"]; ?&gt;'; if (intr == "44243") { var tele = "+443301227336"; var teleshow =" +443301227336"; $( "#menu-newmainmenu li:last-child" ).html('&lt;a href="tel:'+tele+'" style="line-height: 90px;"&gt;&lt;i class="fa fa-phone"&gt;&lt;/i&gt;'+ teleshow+'*&lt;/a&gt;'); }
That's ok.
Why choose a small canidea delivered by a dinosaur when you can choose a whole web browser / OS thought to take control of your private life and, ultimately, your mind and soul?
You have much bigger problems if you have to change your code to protect against devs who don't understand how || works.
i've been using ===undefined in all of my code. I never have a problem with it. I agree with this article.
Come on, that is common practice and everybody knows what it does. And usual you want to catch the falsey values anyway. Take your example, why would you want to allow to eat the fruit ""? Better readability? Not really IMHO
Why on earth would you want fruit to be valid as "", false, or 0? None of those values are more valid of a fruit than a default. Under what scenario would fruit be "" and not null? In that scenario why is the default invalid, and in THAT case why is the default not set *before* the value went from null/undefined to ""? I would fail this on review. Without question, this should read: fruit = fruit || "strawberry"; When said developer argues that || is unreadable, we will be then reviewing every if statement that developer has written to ensure he understands operators. This isn't syntactic sugar.
Fellas, what is the best way to learn React for a guy who just finished reading Eloquent Javascript?
Alright, but we still need to make it so that it will find the password text box and the login box, and remove the password variable.
That's not really the point. We want web components so we can create new "components" we can use in HTML by simply writing `&lt;my-component&gt;`. The point is to avoid delivering gobs of pre-rendered markup, and just giving a semantically meaningful tag that defines a behavior, the same way you'd use `&lt;select&gt;`. We want the ability to create tooltips, dialogs, alerts, autocomplete, tabs, wizards, tag lists, and more by simply writing the tags in our HTML, without worrying about actual rendered elements necessary to create the visual style or the JavaScript necessary to enhance the markup. We want all of this, and we want full control of the API, behavior, visual styling, and accessibility. You can't change the way `&lt;select&gt;` works or looks now without gratuitous hacking, and web component make it possible for you to create your own `&lt;my-select&gt;` that supports icons, text styles, infinite scrolling, and more.
Web components aren't a new MVC framework, and they're not competing with React/Angular/Ember/whatever. They're meant to be used in combination with literally any library or framework you choose to create rich, custom experiences with semantic tags where you'd previously use gobs of markup and code that's tied to the flavor-of-the-week JavaScript framework that some intern decided to use to meet a deadline. See [my other comment](https://www.reddit.com/r/javascript/comments/3cmp98/the_state_of_web_components/csxk2al) for a description of why we need web components.
yea so chrome extensions have resources. so you can link stuff... ex: `&lt;img src=chrome://myextensionid12/img1.png /&gt;` I would create a `data.csv` or `data.js` then use ajax or xmlHttpRequest like: `$.get('chrome://myextension12/data.csv')` and parse the results... or maybe append `&lt;script src="chrome://myextension12/data.js"&gt;` to body when you need the data this way its not loaded every page view (i guess thats the simplest workaround i got) edit: you can also create a simple php or js script to query the data and host it either on the interwebs or inside your plugin (html/js only) `$.get('chrome://myexentension/somefile.php?query=123'); //parse results`
I agree, it gets a bit hairy in there. From testing on es6fiddle, the precedence works as you'd hope, so I believe if you wanted to apply the comma operator , much like if you wanted to return an object literal, you'd need to add parenthesis around the expression. 
Yeah :D
What if I wanted to create a neat little "widget" that lets you drag and drop files and shows a list of the files you're going to upload, and I wanted to make that available for anyone on any website to use? Would I build it with React and require that everyone who uses it have React as a dependency? Or would I create a web component that can be used on any website by including the widget (with a `&lt;link&gt;` or `&lt;script&gt;`) and adding `&lt;my-uploader&gt;` to their markup where they want it to appear, regardless of what MVC framework they use? That is the promise of web components: portable components for the web that use HTML's semantics. Yes, it's not possible right now in IE 8, but if you're still writing code for outdated browsers, I feel bad for you, son.
Because [raptors](https://upload.wikimedia.org/wikipedia/en/thumb/4/49/Mozilla_Mascot.svg/165px-Mozilla_Mascot.svg.png)! [edit] Chrome is just a webkit engine that got raped by Google and will rape you in return. And because ChromeOS might be the little thing that looks like a starting monopolistic situation, betting on Google Chrome may become as useful as it was when peole were betting on IE6, which makes a canidea delivered by a dinosaur the best survival species (although it needs a laser). 
start building something without react.js.
Yeah makes sense since the implicit return is a single expression.
&gt; The problem arises when you don't know if the other developers who'll touch the code are also aware of when not to use OR for defaults. I'd argue that the problem is those developers and not the code. If "those developers" don't know standard features of the language (and bitwise operators are ubiquitous and identical in many/most languages that you'll find), then perhaps your time would be better spent on developer education.
Hi /u/endpointben, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `endpoint.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.endpoint.com](/search?q=%28and+site%3A%27blog.endpoint.com%27+author%3A%27endpointben%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|5|83%
Hi /u/commandman, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
&gt; Would i use something like localStorage Yep. Everything starts over like it's the first time the Javascript was loaded. *You* need to provide the logic to check for a state. Cookies work as well. &gt; to store the generated HTML? You will more likely want to store a state than what was generated. 
The thing is, I believe that for a beginner with a relative lack of fundamental knowledge, trying to build something right away is not very productive. I mean, it will end up as me constantly googling how to do A, B, C... I don't argue that building real projects is important, but personally I prefer at first get a knowledge base, while practicing on book examples. And after that - try to build something on my own, using the gained knowledge.
Yes that's correct. And alright sounds good, i'l mess around with it and see if I get anywhere.
&gt; Yes, it's not possible right now in IE 8 Or IE9. Or IE10. Or IE11. Or MS Edge. Or Safari. Or Firefox. If only somebody would write an an article explaining how this came to pass ... Having just spent 2 days wrestling with a war between a WC polyfill and a non-negotiable third-party dependency, I'm very much in favour of keeping the 'here be dragons' sign up.
UPDATE: I found the link: https://www.reddit.com/domain/codecademy.com/ If I understand the Reddit! jargon it would be: /d/codecademy And not a subreddit at all, but it does look like one to a newb like me.
This is my favorite solution: http://leafo.net/sticky-kit/
I was talking about the [revealing module pattern](http://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript), which uses an IIFE to evaluate its contents once, then bind the `return` of that IIFE to a variable for later use. Effectively, this has the same semantics as a node-style commonjs module in that regard. I was recommending that starting with the revealing module pattern would be a great first step to clean things up - which you could do incrementally over the course of development, if you liked. After you've packaged all of your code into modules in this way, it becomes a fairly straight-forward (if slightly time consuming) refactoring step to start using something like node's module system instead. The contents of your files would be the contents of the IIFE. The `return &lt;value&gt;` would be replaced with `module.exports = &lt;value&gt;`. You'd have to look for what variables from the global scope your IIFE uses, and import those explicitly using `require`, which is a bit awkward, but definitely doable. 
I appreciate the response. I am trying to understand how their code works so I can learn from it though - why does it work on their page but I can't get it to work locally? How does the code get called when scrolling, but it does not for me? 
`$(document).scroll(checkScroll);` This binds checkScroll() to body.onscroll, not very optimistic as some browsers will fire the scroll event multiple times when the body is scrolled, results can be very laggy. 
More relevant code to post would be your own that you are trying to debug. :) The blanket-guess is that you don't have an element with the id of "cover-heading," but you covered that. Maybe it is spelled incorrectly?
What seems to be happening is the code runs a checkScroll every time a scroll event fires. The styling within the checkScroll functions conditional only executes if the current scroll position (scrollStart = $(this).scrollTop();) is greater than the header bars offset top. Else, it applies some default styling, which you can see if you are at the very top of the page. Where are you putting your alerts/console.log? If you place it after "checkScroll();" it only executes on page load, once. If you want to watch the alert trigger each time you scroll, you must place it within the checkScroll function itself.
Sure thing.
 &lt;!--[if lt IE 10]&gt; &lt;script src="https://cdn.rawgit.com/nicolas-van/install-chrome-dialog/0.1.0/install-chrome-dialog.min.js"&gt;&lt;/script&gt; &lt;script&gt;installChrome();&lt;/script&gt; &lt;![endif]--&gt; Oh hell the fuck no. Every time I see the conditional IE comments I immediately think incompetent newb creating additional (unwanted) work for other people later.
Well, their code works fine, as exemplified by their website. No one here can do much more debugging beyond that without seeing your code. Maybe post a sample codepen?
Sure thing. What I'm trying to say is that educational materials (especially, books) can give you a good structured foundation, which afterwards can make the googling process much more effective. I'm not saying that this is the only correct way, but it works for me. I also have a notebook near my laptop, where I take notes :) Someone could say that this is the relic of the past, but I believe that it helps to better grasp new information.
Yes, you are 100% correct - I actually found out that since I was missing the css selectores "navTop" and "topColor" that the script was stopping at that point. I fixed that and it runs more along what I expected now Next time, yes I will post the whole thing somewhere, cheers
Structured foundation type learning materials come out years after professionals have been using a technology. Web components are very new and there is currently no answer to the question "What's a good react.js book?" 
This is true, unfortunately. I know that for an experienced dev it's no problem to dive into new technology, but when your overall JS experience is little bit over 6 months, learning from official docs is a little bit complex. Although, seems that this is the way that I'll be doing it :)
You can pass a variable to a function without knowing the value of that variable. If you're passing the result of another function that might return null, you need to account for null. Just use || if you want. I do it all the time. I was just pointing out there are other ways to account for passing useful falsey values if it's an issue.
If "flt" would be exactly the same, it would have the same upsides, but it doesn't. It doesn't let me write more idiomatic code or anything like that. It isn't even a function. It's a typedef which serves no purpose. There is no use case for this. Your example isn't valid. Typedefs aren't functions. You know this. Your example should be a function, but, as we already established, even the simplest functions have their uses. So, there really is no way to make that argument work. &gt; I think you should embrace the way of the language and its API. *Its* API? That DOM stuff is just *some* API. It's not part of JavaScript. The APIs provided by Node or Komodo aren't part of JavaScript either. Those APIs are just something which is made available to the scripts running inside those applications. &gt; They were designed to be used in a way and work very well in that way. Haha... no. Many of the old DOM APIs are XML-inspired and rather Java-like, because that's what they mimicked. They do not work very well with JavaScript. This is one of the main reasons why jQuery got so popular. jQuery's API is the much better fit. DOM3: node.parentNode.removeChild(node) jQuery: $node.remove() Also, why do you think DOM4 will fix QSA/QS? They will fix it because the current API is shit. They fucked it up. Again. &gt; The path with least resistance is just using what was given to you. You mean, like, the ability to create your own functions? :P &gt; And what you are doing is not encapsulating code like the math example, you are wrapping the API to make it more to your liking, it is different. No, it's not any different. "randomRadAngle" calls some function, does something with the result, and returns it. "qsa" calls some function, does something with the result, and returns it. You don't believe that multiplying some number is a far more complex operation than converting an array-like object to an actual array, do you? Anyhow, if you really believe the built-in stuff is perfect the way it is, show me how you'd write this in an IE9-compatible manner: jQuery: $('.foo').forEach(function() { $(this).addClass('bar'); }); DOM4/ES6: queryAll('.foo').forEach(e =&gt; e.classList.add('bar')); Or show me event delegation. How does the code, you write each time, look like?
This wrapper by Uber seems awesome. https://github.com/uber/r-dom With that you can avoid gross JSX without writing React.createElement() a bunch of times
There absolutely are other ways. Here is a helper library that does exactly what you want I think. https://github.com/uber/r-dom
I have been writing a lot of React components recently and PropTypes finally became enough of a pain to justify writing this. Having written a lot of Mongoose schemas, I found myself liking the typing pattern and brought it to React. If you like these sorts of things, please check out my other repos and follow me on [Twitter](http://chrisandrejewski.com/twitter). I have just started using the account and need *scripters to follow.
For new code, use ES6's default function parameters. For legacy stuff, keep using ||. That's all there is to it, really. || is a tad cryptic for beginners, but it's the best (and most commonly used) option.
Works for me in node.. (v0.12.2) Edit: an apt-get upgrade later its still working 0.12.6
I gave the flt example because I have seen it before. Some people use that in C. Of course it does not do anything, it is an alias, and alias don't do anything, they just give you another name for something. Changes in the API does not imply that the API is "shit". It could be, for example, the API is already good and they are making it better. And I don't want to write code that runs on IE9, because I don't want to encourage people to use outdated browsers that put themselves in danger. Anyway, here is how I would write that code. var foos = document.querySelectorAll(".foo") for(var i = 0; i &lt; foos.length; ++i){ foos[i].classList.add("bar") } It is not as bad as you are saying. The standard is very good. It was very bad before and that is why jQuery got popular, but now is time to stop using jQuery and use the standard.
http://plugins.jquery.com/cookie/ I haven't used it before, but it seems straight forward.
 ... &gt; (new derived()).read(); reading undefined &gt; process.versions.node '0.10.26' Seems to work for me
Yeah, much easier understanding from that video. I thought of the exact one when I saw the post title. 
Select 2 https://select2.github.io/examples.html also hideseek is good http://vdw.github.io/HideSeek/
Since it sounds like you want to do this yourself I would say you're on the right track. Using `keyup` is the right event. I've made a very quick/dirty jsfiddle to get you started. Good luck. http://jsfiddle.net/z8zabe9o/
Thank you for your response! Also thank you for the fiddle. It's nice to be able to visualize things. 
You're not going to go from not understanding JS to writing perfectly succinct code without the going through a cluttered phase in between. The best way to learn is to write it yourself. Look up how to do individual things when you get stuck and continue on. After you are more comfortable with the language you will come across code like you mentioned above and either see it as a different way to do something, or a possible improvement to how you have been.
That video was so useful! I need a playlist of videos that tackle one topic at a time in such patient detail. So many things I see as a black box of magic that are probably rather simple. 
I've built an open source Sails dummy project to show you how I used TS on the server side with Sails. https://github.com/Vadorequest/sails-typescript Discussion is here: https://groups.google.com/forum/#!topic/sailsjs/XoxiE8CiFTE
The VanillaJS stuff on that page is, from what I can tell, to help illustrate why you'd want to use an existing framework (as opposed to writing it yourself in pure JS) to do MVC setups. The other frameworks are open source projects with many contributions over the course of years - as one man who's still learning of course you're not going to be able to understand years worth of refinement from many, many experienced people. If you've only ever used JS/jQuery to do front end interface work, you're going to need to learn about the MVC architecture for back-end and pick a framework and dive in, make some projects, develop your knowledge. Your best bet if you're newish to back-end JS is not to pick apart existing frameworks, but to *use* them and begin to demystify what they do, why they do it, and then from there you'll have a basis to pick apart how they do it. Or - as most people do - not worry about how/why they work, just use them to get things done. Bit of an extreme example but it's almost like you're saying you want to learn Linux so instead of ever using it and getting familiar with it you're just trying to read kernel code with a very limited knowledge of C to see what it does and how it all works. It's a bit of a backward approach, you have no context of understanding to jump in that deep and your technical language proficiency is not up to snuff to sight-read code and pick it apart. Start small. Pick a framework, make some simple projects/follow tutorials, study a bit about MVC in general and what the rationale is behind it, etc.
Custom elements are polyfilled and working work great in IE 9, 10, 11, Safari, and Firefox. I can't speak for HTML Imports, Shadow DOM, etc, because I'm not using them. I haven't tested Edge, but it's working nicely in IE 11, so I think we're good :) I know this because I write an maintain a library of dozens of web components at my job and all all 1,100 of the unit tests pass on the above platforms. What was the third-party dependency? I wonder how it was screwing the polyfill up such that it works on none of the platforms it targets... Sounds like a bug in the dep that you could fix!
Thanks !! Any feedback is welcome ! I put articles(markdown) to git repository. https://github.com/gi-no/blog_mean_stack Welcome feedback by Pull-Request or e-mail or comment here(or on blog), or anyway ! 
Doing code review at work makes me feel dumb at times, but I learn from it. There will always be someone better than you - I'm a sr level dev (coding since grade school, 7+ yrs professional/post University exp), and I still feel stupid looking at some other people's code. 
 [].forEach.call(document.querySelectorAll('.foo'), ...); [].forEach.call(document.querySelectorAll('.bar'), ...); [].forEach.call(document.querySelectorAll('.baz'), ...); You can't see the repetition? qsa('.foo').forEach(...); qsa('.bar').forEach(...); qsa('.baz').forEach(...); Looks like an improvement to me. &gt; Even if qsa is common, that does not make it a good name Common abbreviations are good names. extensibleMarkupLanguageHyperTextTransferProtocolRequest. I like XHR better. So, where is your event delegation example?
I am actually new to JavaScript and don't know how event delegation works exactly. I will end our discussion here, since I am moving to voat.co P.S: http://google.github.io/styleguide/javascriptguide.xml?showone=Standards_features#Standards_features
If I understand right, you need to put this inside a PHP file? You can just use [this](http://php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc) (hooray, lovely PHP syntax), if that's the case: $javascript = &lt;&lt;&lt;EOS {javascript goes here} EOS; Or you could find/replace all of either the double or single quotes and replace them with the opposite so you only have one type of quote in your javascript.
Some quick Googling of "botguard.bg" brings up "Google's BotGuard" which appears to be a RNG for preventing bots from doing automated sign-ups. Seems to commonly be used by Ingress. https://news.ycombinator.com/item?id=8277858
Glad the article is out there for people to find and read. Keep on being awesome and sharing what you learn!
Huh. I'd check again. No VS requirement that I'm aware of. I've used it in a few projects, and I'm absolutely certain I didn't use Visual Studio. At all. Promise.
I can never find any examples of people taking these kinds of ideas and pushing the DOM to its limits. Can anyone point me towards a DOM stress test of sorts? I want to get an idea of, with efficient code, just how much stuff can you get a real-time application to animate and change?
With the document.getElementById("textBoxId").value = guess; document.getElementById("submitButtonId").click(); how do you get the text box id and submit button id? Can you find it by inspecting the element?
Thank you so much - really appreciate it!
Uh, yeah; I do that every day using React.
ELI5 what can I do with this?
Funny that you aks, I was in fact initially trying to reverse engineer it, make my own Rekapi, with ES6 and without underscore dep, but then it suddenly hit me that animations can be expressed as functions of time, and I wrote the current version of keyframes overnight in one breath. So anyway: 1. I think it's much easier than Rekapi, there's no actors, keyframes, renderers and so on, just functions, compose and reuse them unlimetedly. 2. See https://www.reddit.com/r/javascript/comments/3cqjz5/keyframesjs_a_functional_reactive_animation/csy9mxd
Not exactly. I mean, it could be used for that I suppose. But it's a more memory-efficient virtual-dom, like what's used by React, and the virtual-dom library. A virtual dom being a mock version of the DOM that is updated by your code instead of the actual dom, and then the writes you make to it are written out to the real DOM in a much much more efficient way than doing them piecemeal like vanilla JS normally would.
I sometimes feel stupid looking at code I wrote. 
Why don't you use ES6 templates? var scale = 1; var translateX = 100; var transform = "scale(${scale}) translateX(${translateX})"
Looks quite nice. Thanks for sharing.
So it's like a DOM within a DOM? How deep can we go?
Come hang out in freenode/##javascript, plenty of people who don't like to Google get answers there
It's valid for Java array initialization also: http://stackoverflow.com/questions/2311864/history-of-trailing-comma-in-programming-language-grammars
It totally looks like a simplified version of React without the `jsx` and instead pure `js` which is nice. 
why be a dick? its a shit problem to solve. The dom is a piss poor visual renderer that is slow as hell and variable for every browser. The tools are all a hack. The language is full of hack. This thing is a DOM blitter - its weird form the perspective of a compiled program but its a cool thing in this context. 
A dick? I'm just saying I find it entertaining how trend/buzzword-driven things are. Obviously I'm glad to work in an ecosystem where the tech giants and independents are all buzzing to improve everyone's standard of living. 
Yup. This has been my standard new language learning workflow since about 1997.
Hi, the specific purpose is to be able to surf the dom elements and emphasize the selected ones in that moment if necessary. The library has been designed for a bigger project that will be released shortly. It can be useful for many cases and implementations, such as a debugging tool for example, or any idea you can think of 
So some people will use it once it's implemented. How many code bases of other developers do you have to read/fix each week? If the answer is less than 3, you're blowing this out of proportion.
Linters default to not allowing this but ooook
What I would have expected: (function(console) { var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"]; // i is used as a replacement for counter, as it is more usual to // have i for that purpose. // n is used to store name.length ibecause it makes the for loop // more efficient -- efficiency doesn't matter for this example, // but that's a good habit to have. for(var i = 0, n = names.length; i &lt; n; i++) { console.log(names[i]); } }(window.console)) // IIFE pattern - http://benalman.com/news/2010/11/immediately-invoked-function-expression/ If you want to learn functional programming, you could try one of the koans projects: http://www.davidlaing.com/2010/07/19/learning-functional-javascript-through-koans/. You will have to download and run on your computer.
Dude - its the imposter syndrome. Everybody that does anything creative feels they are an imposter when they look at a master and think they too must be a master in order to survive. As you get more experience you will realize only a very small proportion of masters are true magic -- the rest are just journeyman joes like you that fought through the crap to develop a deep understanding of the silliness of these stupid machines. be happy bro. Its all good. you are where you should be at this point in your career. In 15 years some dude on reddit will say the same thing to you and you will say what I am saying back. 
Of course they don't allow it. It's not currently valid syntax.
I've seen senior developers construct shitty solutions and even worse code … so it may not be you. Keep that in mind as you learn. 
I sometimes feel stupid when I write code
Ah, thanks for the info. I understand what React is and how it works. What I was trying to get across (I didn't do a very good job) is that it seems to take that extra step of creating a jsx file out. I probably should have worded that a little better xD
I've been stuck in a knockout hole for a while - so I am kind of agnostic. react and the notion of blitting the DOM seems much more right to me. unfortunately most people still use IE - so you cannot assume peopl are going to use a modern browser. Honestly -- we still have users on IE6 - like 80k users. The application on which I work has to play stupid UI games. 
No answer is an answer, too. I have to go through ~5 different code bases on a good week, some of them hastily written by ad agencies. You know nothing about badly written code. A trailing comma inside function arguments is negligible by comparison.
Maybe learning about JavaScript design patterns could be helpful to advance your programming skills, understanding of core concepts and teach you more lingo on the way? Here is a great book by Addy Osmani about it: http://addyosmani.com/resources/essentialjsdesignpatterns/book/
Most people don't use IE. World wide at least. In the US, more people do but, still, just barely half, if that. World wide it's maybe 40%.
Throw in type annotations, default parameters and destructuring and I'm sure you'll be seeing multi-line parameter lists more often.
As they should since trailing commas can mean different things in older browsers. For example I believe IE8- do something like: [1,2,3,] // -&gt; [1,2,3,undefined] And I believe trailing commas in object literals just weren't allowed at all. But so are trailing commas in function parameters now, and if it gets added to the language, linters should continue to call that out for the sake of compatibility. While we're at it, we should throw something like this into for loops too: for ( var i=0; i &lt; 10; i++; ) { // ... } Yeah!
That's an overly complicated approach. Why not simply use a simple iterative approach? function isChildOf(target, selected) { // iterate over selection - for .. in is slower here. for (var s = 0; s &lt; selected.length; s++) { // do not attempt to find nodes within different DOMs var parent = target.ownerDocument === selected[s].ownerDocument &amp;&amp; target; while (parent &amp;&amp; parent !== selected[s]) { parent = parent.parentNode; } if (parent === selected[s]) { return true; } } return false; } 
Ah, good idea. I'll do that this weekend.
We just didn't find any tool to programmatically navigate trough the DOM nodes and highlight them, you could for example highlight only &lt;img&gt; elements or elements with id=#someid, use cases are really various, it's all up to your imagination and needs, you know ;) 
On your receiving client, what happens when you console.log the data argument received?
If someone is so anal about source control history why don't they just use a preceeding comma for this specific case? 1: function clownsEverywhere( 2: param1, 3: param2 4: , param3 // Wow problem solved. No need to CHANGE THE LANGUAGE! 5: ) { /* ... */ }
I'm sorry, I don't really understand the question. Also, JavaScript uses 64-bit floats with 15 places of accuracy. Your number is too large to be accurately represented. Just typing in '76561197960265728' (not a string) into my REPL returns '76561197960265730'.
With all due respect, you need to research the reasons to use React yourself so when people ask you follow-up questions you can actually answer them. A company isn't going to be impressed that "React [is] the framework I'd like to learn". They are going to be impressed that you have made yourself a subject matter expert and that you are solving real business problems in a better, faster, more robust manner with this technology than with another. If you will be presenting your ideas to management or a senior team member, you need to be much more succinct and less verbose. Stay on message with the top 3 ways React outpaces other options. Keep in mind that decision makers will need a strong argument for using a technology that no one else in the company is familiar with. In general, they will want to stay with tried/true stable technologies so it's easier to find human resources to maintain it.
Check out [this video from React.js conf, "Complementarity of React and Web Components"](http://webcomponents.org/presentations/complementarity-of-react-and-web-components-at-reactjs-conf/) that explains exactly that.
&gt; kefir I'm looking at kefir now and it does seem like they're similar. One difference is that a message on a channel only goes to whoever is first in line to receive one, whereas observables message to whoever is listening. There's also a difference in how they're meant to be used, based on the promise vs. callback style.
Sweet. Thanks.
Check out Node Tools for Visual Studio 2013, although 2015 comes out in like a week I think.
there is the same for PHP: https://github.com/ziadoz/awesome-php
76561197960265728 is larger than 2^53 . Beyond 2^53 , things get weird. &gt; Math.pow(2,53) === Math.pow(2,53) - 1 false &gt; Math.pow(2,53) === Math.pow(2,53) + 1 true See also: &gt; Number.isSafeInteger(76561197960265728) false https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger
That seems fairly good. I like these because of how similar they are to Jade. I absolutely can't stand HTML, I don't understand why they worked so hard to include it. 
Ya I am i'm not sure why its not working.
As I said before- I wanted to clean the code a bit. Here's a github repository with full, unimified code: https://github.com/Tom64b/jcore
You can use concat to create a copy. &gt; var a = [1, 2, 3] undefined &gt; var b = [].concat(a) undefined &gt; b.reverse() [3, 2, 1] &gt; a [1, 2, 3] **Edit:** If you use ES6, you can also create a copy via `Array.from(a)` or `[...a]`.
For just 7.3 more Kb you could have most of jQuery by using [zepto.](http://zeptojs.com/)
Good god, why? This is some difficult-as-fuck to read code.
The problem is that #reverse is a destructive function meaning that it permanently changes whatever you are sending it. The easiest way to work around this is to precede your #reverse call with a #slice: var myApp = {}; myApp.myArr2 = ["hello", "world"]; myApp.myNewArr2 = myApp.myArr2.slice().reverse(); console.log(myApp.myArr2); // hello world console.log(myApp.myNewArr2); // world hello 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign &gt; Object.assign({a: 'a', b: 'b'}, {b: 'b override'}, {c: 'c'}) Object { a="a", b="b override", c="c"}
I don't have any experience with webpack, but I'll comment on Browserify/RequireJS: Browserify's syntax for modules is the same as NodeJS: var module = require('moduleName'); And it will work the same way as NodeJS. What's really nice about this is that the syntax is simple, clean, and familiar if you use Node at all. It also makes dynamic module loading (using a variable for a module name) painless. HOWEVER, it's much harder to shim a module with Browserify, and you must compile your JS before loading it into the browser, making debugging harder, and development speed tied to how long it takes to compile your code. RequireJS on the other hand, has a horrible syntax: define(['module1','module2'], function(Module1, Module2) { // your code goes here } This duplicitous declaring of dependencies has some benefits, but in general it gets real ugly real fast. As well, this makes dynamic module loading harder. Not MUCH harder, but definitely needs more manual boilerplate code. That said though, it's a lot easier to shim a module in RequireJS. And it does not require you to compile your Js code before using it in the browser. This greatly helps with debugging. As for concatenation and minification, both work just fine in that regard. I don't consider either one a clear winner. Since I don't know anything about Webpack, maybe Webpack is what I've been looking for all my life. But I have no idea ;)
For example when you make an entrainment website you don't need to care about corporate users, do you? :) Also- if you detect old machines you can serve them a simpler website or just the 90kB jQuery.
I've been using Browserify pretty heavily on a couple different projects, work and personal, for about a year now. I really, really like it. If you've used node and npm, you more or less already know how to use Browserify. It's the same CommonJS module system as node/npm. Plus using Browserify and writing node-style code for the front-end solves a number of pain points of "old school" javascript: * Dependency management &amp; resolution. No more mess of `&lt;script src&gt;` tags that need to be loaded in a specific order in your HTML * Modules &amp; namespacing. No more globals or IIFE-based modules. Makes testing SO much easier. * Bundles up your deployable artifacts to single, self-contained .js files * Basically forces you to implement a build process. IMO this is a good thing, as then you can easily hook in other really positive things like linting, style checking, running unit tests, less compilation, template pre-compilation, etc. into a defined, repeatable process. In the past I had gotten my feet wet with RequireJS, and I found it to be awful. The syntax is terrible and so few libs are AMD-compliant so you end up having to shim a hell of a lot of stuff. Conversely, for the most part Browserify just works, and for the handful of common needs there are several good Browserify shims/transforms available via npm (e.g., hbsfy, reactify). I don't have a lot of hands-on experience with Webpack but I've read through some docs and it looks solid as well. It looks like it has a couple of neat features that Browserify doesn't offer, or at least not easily, but the core functionality is pretty similar. I think you can't go wrong with either Browserify or Webpack. At this point in time I would not bother with RequireJS. I've been doing mostly Backbone-based stuff and it works awesome with Browserify. Some of my coworkers have said that Angular and Browserify/Webpack don't really play together super nicely, I know it can be done and that people do it, though.
What are the #s all about?
&gt; And it does not require you to compile your Js code before using it in the browser. This greatly helps with debugging. As long as you turn on source map symbols in your Browserify options it doesn't make debugging any harder. With source maps you'll get correct file names and line numbers in a browser console/debugger. For example, in a grunt-browserify task it'd look something like: browserify: { 'myApp': { src: 'src/web/main.js' dest: 'public/myApp.js', options: { // setting debug creates source map symbols browserifyOptions: { debug: true } } } }, &gt; and development speed tied to how long it takes to compile your code. Using a watcher makes this not really a problem, either. The first compilation from scratch can sometimes take a few seconds, but even in my largest projects, watchify can recompile in near real-time. To use a grunt-browserify example again, it has watchify built-in and can be turned on with a single flag: browserify: { ..., options: { watch: true } },
Thanks. See my edit regarding Browserify.
Agree with you 100% - The suggestion is terrible, has a lot of negative downstream effects, is a lazy way to fix an edge case that can be fixed by relocating a comma, creates confusion regarding the handling of arrays and is overall a poorly thought out idea. I have no idea why people are down voting you. They must like solving simple problems with complex and invasion techniques.
This can be done via a babel plugin: https://github.com/thejameskyle/babel-plugin-incremental-dom
I recently switched from Browserify to Webpack and I am very happy with my decision. It's an order of magnitude more customizable, and this will be useful as your app grows in complexity. The learning curve is a bit steeper, but totally worth it.
And this React-specific feature is super awesome because...? Isn't there some article or something you could link to?
I was just making broad speculations about a library based on its readme, so take whatever I said with a grain of salt :P
[Was taken from this tweet.](https://twitter.com/vslinko/status/619581969903550464)
This already exists as [npm package](https://www.npmjs.com/package/extend)
If I convert it to float32 I get: An unknown error occured while processing decodeAudioData. drakoumel The buffer passed to decodeAudioData contains an unknown content type. drakoumel EncodingError: The given encoding is not supported. If I send the data without conversion I get: Object [ -0.00011783346417360008, -0.0012129060924053192, -0.0018593413988128304, -0.0019558160565793514, -0.0020727275405079126, -0.00223039579577744, -0.0021641110070049763, -0.002132638357579708, -0.0022288309410214424, -0.002380483318120241, 2038 more… ] But it never starts playing, now I get TypeError: Argument 1 of AudioContext.decodeAudioData does not implement interface ArrayBuffer. var audioCtx; var started = false; if(!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } source = audioCtx.createBufferSource(); audioCtx.decodeAudioData(data, function(buffer) { source.buffer = buffer; source.connect(audioCtx.destination); source.loop = true; if(!started) {source.start(0); console.log('started playing'); started = true;} },function(e){"Error with decoding audio data" + e}); }
Interesting... Somehow I've never seen that before... Thanks!
I browse every now and again to see if anyone has put any interesting articles up 
Info, tech discussion/flamewars, language trivia, ES6&amp;7, notable libraries and frameworks, news, gossip and cool things people have built.
I personally look for someone being wrong in an area I know something about. This pleases me.
Nono, I meant once you encode it from your first browser, then send it to your server, and receive it on the client, can you log it without using your playAudio() function. Like: socket.on('audio-blod-receive',function(data) { console.log(data); });
Yeah of course it'll be possible. Probably slower than in Java, but absolutely doable.
Don't forget JSPM. It's growing fast (I don't use it yet, but I'm keeping an eye on it). It offers ES6 modules and babel support. With gulp as a normal task runner, I think it'll be worth using very soon.
jspm
If I send it converted to float32 I receive: ArrayBuffer {}, If I dont convert it I get the array that I just posted on top with the error.
You should probably ask these questions to the Iconic / Cordova / Angular community, but mostly the Iconic / Cordova community as your problem has very little to do with JavaScript from the looks of it.
You're making me realize I should unsubscribe.
Why not wrap it in backticks like `this`?
As a beginner I spend most of my time reading the answers to questions other beginners have asked. 
If you want to avoid creating a copy of an array and then reversing it, you can simply do this. var a=[1,2,3,4,5,6], b=[]; for(var i=a.length-1;i &gt;= 0;i--) { b.push(a[i]); }
Good bye. This guy has a majorly biased perspective. I do not enjoy node, but I use some tools that run on node. I have not been impacted in the slightest by the io.js drama. There's also something to say about not embracing bleeding edge technology. It hasn't even been a year since August 2014.
 Interesting. But one thing is distracting me. Why is the left frame of this page so darn huge?
Hey, just like in [Coffeescript](http://rzrsharp.net/2011/06/27/what-does-coffeescripts-do-do.html)! Doesn't seem to support "return", though. It'd be great to see an IIFE keyword in ES2017: const result = closure { if (something) { return 1; } return 2; }; Way more versatile than `switch`, especially now that `const` &amp; block scoping is a thing. Almost tempted to write a macro...
Can someone briefly explain how this is achieved for a person who is too lazy to go through the source code?
Awesome! I wonder what the ideal method will look like with ES6. Decorators?
:) Of course. I just meant with the existing set of ES6 features. I'm a proponent of keeping a language as feature simple as possible. But with single-page applications and Node et al., it's pretty clear that the range of concerns is FAR wider than ever initially imagined.
That definitely works. It is more confusing though, especially if you need complex logic that requires temporary variables and the like. (You can use `do` to create a new scope and define scoped variables.) Complex ternaries are best avoided. An alternative is to extract a function.
Aha! It's just sugar. Okay so there isn't some magic I'm not understanding. 
You have to get this data inside the page scope. A separate data file will keep that data from filling up other files, which is good for the so-called separation of concern. It will also allow the client to cache the data even if the other scripts change - or vice versa. Finally, since there's a lot of data as you said, loading it asynchronously will speed up your page.
&gt; Incremental DOM is primarily intended as a compilation target for templating languages. It could be used to implement a higher level API for human consumption. They don't expect engineers to write html this way.
That is a super readable way to do it, yes!
You are not incrementally updating the DOM, you are incrementally updating a virtual model of an element, and then the library is incrementally updating the DOM if appropriate. That being said - it's become clear that this distinction is a matter of semantics, I don't think we actually disagree about what is happening.
well obviously, point is what's interesting to you, I want to know what this community is interested in.
why's that?
Maybe not for a 5 year old, but here's a simple way you could go about it. Create a new file with the properties you'd like to apply to your HTML object. e.g. data.js var data = { key1: value1, key2: value2, key3: value3 }; Include it in your page the same way you include the rest of your javascript. e.g. &lt;script src="data.js"&gt;&lt;/script&gt; Apply the properties to your HTML object inside the javascript file that contains your logic. It will be available via the global variable, ***data*** that was defined in your included data.js file.
 You get your language feature! And you get your language feature! Oprah.gif
How come? They're used all over the typed languages, why are they an antipattern? Imo doing this if(arg1 &amp;&amp; arg2 &amp;&amp; "number" == typeof arg3){ }else if(aguments.length &gt; 4){ }else if(blablabla){} in languages like JS and Python is way more messier than a declarative polymorph declaration.
I believe primarily because polymorphic functions cannot be optimised by modern JS engines as they do not have consistent types.
I disagree on some points you made. Things like three.js allow for amazing graphics performance in browser. In order to accurately answer this question, the languages need to be put in the same context.
Excuse my ignorance, but why not use the event emitter in node with browserify?
Ok, my mistake, it seems 'decodeAudioData' is meant for audio files. Your raw audio already is playable on the other machine. What you should need to do is: * Send the Float32 Buffer via websockets to the client, and point it to your client's Audio Contenxt. * Or keep what you have and convert the Int16 Buffer back to a Float32 Buffer and connect it to the Audio Context. Basically you're not supposed to be using 'decodeAudioData'. I've copied your code and I'm going to try out my method, but you should give it a shot as well.
Also realized I misread what this lib does - I think it can replace reacts vdom entirely - and considering react just decoupled their vdom from the higher level api- they actually explicitly intend people to use a multitude of other vdom abstractions, or even native code (react native) - so these libs might play nice together 
Thanks! I'll take a look :)
A lot of people come here just for frontend JS and they may use PHP on the backend
I was curious so looked at how I usually do it. I use alpha var alpha = (function(){ console.log(+new Date); return true; })(); The reason is that is just how I think about IIFE and it made sense to do it this way.
Kangax has a really good and quite complete article on [named function expressions](https://kangax.github.io/nfe/) which is what you describe. 
First: using $(...).is(':checked') is way slower than $(...).prop('checked'). You are writing very structured (which is good) and very specific code (which is bad to reuse), doing similar things over and over again. You set specific events instead of using event bubbling (which would save you event handlers and would allow you to add code via ajax without having to care for the events). All in all, I've seen much worse. There's room for improvement, but where isn't?
It's just me or is Javascript going to be very complicated all of the sudden?
[That is true in IE 8](https://kangax.github.io/nfe/#jscript-bugs), but not for more recent browsers. The named function `g` isn't accessible. You can run a simple IIFE (to provide a scope) to test: (function(){ var foo = function bar(){ return 2; }; foo(); bar(); }()); You will get `ReferenceError: bar is not defined`
Updates fn.name, makes Internet Explorer cry..
The problem lies in dealing with other people's code that does use all the crap.
Especially when frameworks adopt all this new features and force you to use it, like it or not.
It doesn't suck, just a few improvements: I would suggest you to add your methods to `jQuery.fn` instead of creating functions globally, for example, your toggle method could be rewritten like this (also your addOption, etc): https://gist.github.com/mdibaiee/a02a432d78436f2963d5 Also, I would probably save the selected inputs instead of their IDs to avoid re-creating jQuery objects everytime I want to interact with them, this is as long as you are not removing them from the page. Other than that, I think it's good, I learned something new from you! The getDaysInMonth trick, thanks!
Come on man, this is pretty basic. What have you tried so far? You'll learn more if someone doesn't give it to you. 
Tell me if I am correct: I just attach the click event to an ancestor and let it propagate down the line to the checkbox or siblings?
Don't thank me, thank Stack Overflow. 
Correct. Classically, you would choose the document as ancestor.
Not sure what you are referring to as an "HTML object." An object in your JS code? An HTML tag? For the latter, see: [http://api.jquery.com/data/](http://api.jquery.com/data/)
To give some pseudocode from my phone: $(document).on('click', input.checkbox, function(e) { twerk.allNight(); e.preventDefault(); });
[Syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar)
Don't use preventDefault if it's not necessary. Otherwise, yes.
Your comments are a little try-hard. Massive blocks of comments like that to explain extremely obvious parameters is unnecessary. Additionally, those comments are HUGE! 4 lines of code to explain that you're 'setting up all the things' is annoying. Vertical real estate is valuable. On line 99, you call the function 'resetValue', but the comment says 'add option to select'. In actuality it does neither of these things. It SETS the value of an element. This is what I like to call a BAD NAME. i would think about what this function ACTUALLY does, and give it that name. something like: 'setElementValue' Additionally, the if statement in that function is pretty ugly. I would attempt to refactor it to make it's syntax prettier, and break it up into multiple lines. I assume this is an assignment, but if you can get away with it, I would bring in moment.js as a dependency. It's a great date library with excellent test coverage that would shorten your code immensely. 
Using the `new Function` constructor is generally considered bad practice, similar to using `eval`. That said I can't think of a cleaner way to take the templates in from somewhere else. Since you're using raw string interpolation like this do you run into problems with the fact that the back ticks in your template close the back ticks in the function you're creating? The back tick before the p tag in your template should close the opening back tick in your templating wrapper function. So your function body ends up being: ``` return `&lt;h1&gt;${data.name}&lt;/h1&gt; ${loop(data.moreData, (e) =&gt; `&lt;p class='${e.classes}'&gt;${e.text}&lt;/p&gt;` )}` ``` Which appears to have mismatched backticks...
Good question. I am running Firefox Developer Edition. I think the problem might be support for template strings. It is compiled with Babel, but babel can't get into `new Function` block to work its magic on that template. Or the ones in the html for that matter. **EDIT:** Actually it looks like it was a problem with the arrow function in the HTML. Should be working now!
Using `new Function` is dangerous, but it is the only way to make a template engine that renders in "pure" Javascript. You have to find a way to `eval` the code that you are embedding in html , since the only way the JS has to access it is as a string. That isn't a problem because the ${} evaluates as Javascript code. You can create nested template strings if you wanted to. Edit: Like this var string = `this is a string ${`with another string inside it`}`; The problem that /u/MahdiM was experiencing was because of the arrow function. They aren't supported well in Chrome yet, at Babel didn't compile them since they were being evaled and where only in the HTML.
I feel sorry for your time and effort wasted in this... And for those who read it all :(
Most Google Maps Object hold internal properties whose name is just a letter. Latlng object is a simple example, but if you inspect, for example, a google.maps.Polygon, it's full of them. As a rule of thumb, you should never access properties directly. Always use its getter. If there isn't a getter for a certain property you need to access, keep in mind that your code will eventually break. I made a repo that mirrors google maps API documentation so I can [track changes using diff](https://github.com/amenadiel/google-maps-documentation/commits/master), but of course undocumented attributes (such as properties name in compiled js) aren't mentioned.
I hope I'm not seeing the early days of Java again with JavaScript.
PM Lead for Google Apps Developer Platform (which includes Apps Script) here. UrlFetchApp is working fine. You need to get the cookie headers from the response object. Try this function getVoatCSRFToken() { var response = UrlFetchApp.fetch("https://voat.co"); var cookies = response.getAllHeaders()["Set-Cookie"]; for (iCookie in cookies) { Logger.log(cookies[iCookie]); } } 
Comment styles are irrelevant to this discussion; my preference in all languages and projects is for the PHPdoc style unless a client requests otherwise. It is a consistent format to make life easier for both myself and any other maintainer. Way, way too much code has either no commentary or just plain shitty commentary because someone was terrified of wasting some of the unlimited vertical space. **Edit:** I'll agree with you on function names because, as I said in another comment, it's all tentative. The code was at a point where it was just about functional when I came and asked. There's a good deal of cleaning up left. &lt;3 regardless. 
Yeah, I didn't pick up that you were not a novice, so I was trying to keep it about broad programing concepts, instead of giving you specific jqury / js tips that can be abused in the wrong hand I'll try and give it another look later, give you some more detailed stuff.
why wouldn't you just have separate functions? this is a huge amount of overhead to make a function that's orders of magnitude more difficult to reason about.
Forgiven, forgotten; I'm just as guilty when it comes to jumping down throats. 
A simple test for the target shouldn't take too long, but if it does or the focus of your event is really that narrow, another ancestor is viable, like you said. I assumed that his page was rather simple and didn't feature so many more events.
Hi /u/yolpo-, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `yolpo.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [yolpo.com](/search?q=%28and+site%3A%27yolpo.com%27+author%3A%27yolpo-%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|5|100%
It looks pretty good. There are some opportunities. jQuery has a [.toggle() function](http://api.jquery.com/toggle/#toggle-display) which accepts a boolean to perform show/hide. `'use strict'` is best inside a function, mostly for concatenation risks; it could cause a non-strict script to error if concatenated together. You could wrap the entire thing in an IIFE or `$(document).ready(function(){ ... });` if you don't need external access to the functions. This also keeps them out of the `window` (global) namespace. There are several options if you do want access to the functions, but don't want them to end up in the global namespace. **jQuery Objects** As YOBCZWHYNOT pointed out, you can save jQuery objects rather than generating them from the selector each time. You could replace your inputs selectors with jQuery objects, but would need to make sure your code doesn't run until docReady. This would also clear up the intent a bit... almost every place you have `jQuery(...)` would go away, making the code easier to read. Because jQuery uses $, it's a convenient shorthand to start the variable name with $ to indicate a jQuery object. **DOM performance** As a smaller consideration, adding the options one-at-a-time to the DOM is slower than accumulating them and doing a single add. You could rework the loop in `daysSelect` and the each in `monthsSelect` to accumulate the option strings in an array (cheaper than string concatenations) and then do all the DOM manipulations at once: $mySelectBox.empty().append(optionsAccumulator.join('')); The [$.map()](http://api.jquery.com/jquery.map/) function could replace $.each(), in that case. **jsDoc** Finally, you might consider the [jsDoc format](http://usejsdoc.org/), or even [Google's dialect](https://developers.google.com/closure/compiler/docs/js-for-compiler) for the [Closure compiler](http://closure-compiler.appspot.com/home). Plenty of dev and build tools make use of jsDoc formatted comments to identify errors and perform optimizations.
I wonder if the typescript will stay or eventually fade away for angular 2 as ES6 becomes the standard 
Just because you can doesn't mean you should. :)
I just did something like this with a personal app for browsing scp-wiki.net better on mobile. I wound up having to use JSON and whateverorigin.org to inject CORS headers into the HTTP request. You can take a look at how I did it [here](https://github.com/maximumdata/scp-wiki-mobile-ajax). It's extremely messy, as this was just a proof of concept that hasn't been cleaned up yet. The relevant code portion begins at [this line](https://github.com/maximumdata/scp-wiki-mobile-ajax/blob/master/index.html#L93) Good luck!
Hey buddy! Which one are you? You seem kinda...random.
&gt; Note that JavaScript has **NO** goto statement, you can only use labels with `break` or `continue`.
Where? 
Yes, and from doing nothing to DOM that hasn't changed, which would be pretty common in most apps.
Every flow control mechanism in every language is similar to - and implemented with - goto. If-statements, loops, switches, functions. They're all just more-readable goto statements, just as labelled statements are.
Function `resetValue` has a comment saying "Add Option to Select". Comment styles may be irrelevant to this discussion, but having erroneous comments makes style preferences rather relevant. You could alleviate the problem if you had better naming. Having a comment say "Dates" for variables called `date`, `dates`and `months` the first thing in your code may follow your style preferences, but it does not give high hopes about the code.
Your comment was caught by the spam filter, can you repost with just the final URL? It'll be more obvious that it's a PDF that way, too. edit: here's a fixed version of the comment: &gt; /u/Evanescent_contrail &gt; This is best avoided, and is almost always a sign of bad coding. Read 'Goto considered harmful'. &gt; https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF
What's the benefit of adding methods to jquery and not globally? Can't you access the jquery methods globally as well?
&gt; more-readable The word you are looking for is "structured". http://homepages.tig.com.au/~ijoyner/Ian_Joyner/Structured_Programming.html &gt; More subtly are the break, continue, and return statements used in popular languages. These are more convenient forms of goto that don’t need an explicit target label, but they do undermine the structured flow of control. I didn't even know labeled break/continue statements existed in JavaScript, but if we're comparing it to `goto`, it's just as disingenuous to flow control. I have no problem with `goto`, I'm just saying this is almost a `goto`.
Boom! Internet at the new place! Did you try the code exactly as I pasted it... the one where it checks for two characters? Cause that one was working for me... Or at least it was typing in passwords over and over.
I can't go on the webpage anymore it keeps crashing D: cause it keeps doing the script, I uninstalled cjs but it must save what you've done cause when I reinstall it it does the same thing again.
JavaScript Master race! Ok...maybe not anymore....but I love functional languages because everything is tracable/debuggable. 
Put all of the script in /* */ and hit save, then get back on the page. It will comment out all of the script, meaning it won't run.
Try this: http://crossorigin.me/
I open the cjs thing and it does not have code but its still running and I cant reset or save over it.
Hey guys. I actually found an answer on their forums and wanted to get back here and share. For android development (Also available for ios with safari), you can use chrome dev tool to inspect a webpage on the mobile, even if it is in a webview like cordova. Read more about Chrome's remote dubugging (chrome://inspect/#devices)
You have to go to the page you linked me, open the cjs thing, comment out all the code you have... or just hit reset... and then hit save. You have to be on the right site. Like if you're trying to do it for the site you linked me, while you are on reddit here, then it is not going to work.
I am.
Ok, after messing around with your code and getting the buffer and sending it, it just comes up as an empty object, not even a buffer, on the receiving page. At this point, I can recommend two things: * Try WebRTC (Web Real Time Communications) that was created especially for sending audio/video data over networks. * Use the 'ws' module for Node, as they have proper support and documentation for binary data, also native browser WebSockets can also handle binary data, so you'll find support for that as well.
You didn't actually try to run that, did you? `continue` can't be used outside of loops.
I found a little bit of info on using JSON to access data values, but I can't seem to figure it out for images.
First of all, you can't `continue` like that. `continue` can only be used on loops. There is nothing wrong with labelled continues and breaks. They are not that different from early returns. The problem with goto is that you can go to a position in code without understanding what state you bring with it.
Why not with declarations? Is that because it has an impact on how the code behaves? Oh wait, duh. Because you can't call a declaration that way, so you wrap it in parens. 
Okay got the script removed it seems like it doesn't like doing 8 digits which is a problem since most of the passwords for the site are 8 digits.
It's possible to get into a semantic argument about it, but for the most part no. Flow control changes the 'direction' of the program 'if this do that else that other thing'. Functions are black boxes that you are required to step into and out of, they aren't conditional and their evaluation doesn't change what step will be executed after they are returned from. Objects are a way of representing/packaging and don't really have anything to do with flow control at all.
Well, there is slower (1-10x) and *much* slower (100-1000x). If you want to port some algorithm which makes heavy use of 64-bit ints, you have a problem. If you have to break out some big int lib, things will get really ugly (a.add(b) instead of a + b) and really slow. ES7 will probably introduce 64-bit ints and some kind of operator overloading. Light-weight concurrency is also missing. So, if you want to port something which makes use of thousands of "workers", you'll have to come up with a different solution. Web Workers are way too heavy for this.
Can anyone think of a good reason to do this? 
Really, it's not about flexibility, it's about readability and optimization. I can already do this without a library: function doSomething(element, arg) { if (typeof arg === 'number') { doSomethingNumeric(element, arg); } else if (typeof arg === 'function') { doSomethingFunctional(element, arg) } else { doSomethingGeneric(element, arg) } } Or I can write it into the single function: function doSomething(element, arg) { if (typeof arg === 'number') { element.nextSibling.innerHTML = arg; } else if (typeof arg === 'function') { element.innerHTML = arg(); } else { element.innerHTML = arg; } } The former is much clearer, because each unique action is exposed as a separate function, and the "polymorphic" function is just a router/dispatcher. You can choose to expose the individual methods, if you want, or add the overhead for simplicity. Lots of libraries use argument checking to determine functionality. This method is kind of ugly, in that you pass a bunch of arguments that are not directly associated, and it uses `.toString()` to extract the input names and then match them up.
To immediately invoke an arrow function with the abbreviated syntax (one expression, implicit `return`), you must wrap the entire function expression in parentheses. For this reason, the most consistent way to write an IIFE wraps parentheses around the function expression and puts the invocation operator outside the parentheses (the `alpha` way). I'd like to think Douglas Crockford would think the same way, even though pre-ES6 he advocated the `beta` was because the other one looked like "a pair of dog balls"; it's the same logic that he used to defend the One True Brace Style (because you *must* put the opening brace, bracket, or parenthesis on the same line as `return` or `throw` if it starts the expression being returned or thrown, then it's more consistent to do this for *all* brace/bracket/parenthesis-wrapped constructions in the language).
The /// reference stuff is now covered by tsconfig: http://blogs.msdn.com/b/vscode/archive/2015/07/06/vs-code-es6.aspx
It won't. TypeScript is about providing type support.
That only applies to IDEs / editors which currently understand the tsconfig file :) 
Are you telling me that you've never broken out of a loop? Breaking out of a single loop and breaking out of a nested loop aren't all that different.
Surely there has to be a better example than breaking out of the loop to justify the usage of `label`. I could just use `return` and break out of the `function/loop` to achieve the same behaviour. 
My assembly language professor forbid the use of `goto`, she insisted we use `jal`. Anyways, I had to use `goto` in the fall semester last year in a C++ program in my programming languages class...I couldn't think of anyway to break out of the loop. for (list&lt;int&gt;::const_iterator i = first.begin(); i != first.end(); ++i) { for (list&lt;int&gt;::const_iterator j = second.begin(); j != second.end(); ++j) { if (*i == *j) { gcf = *i; goto Exit; } } } Exit: cout &lt;&lt; "GCF is: " &lt;&lt; gcf &lt;&lt; endl;
No. It's a rare trick that will make your code less readable and can be completely emulated by refactoring the inner loop to a function or using a boolean. It carries superficial convenience that doesn't justify it's terrible lack of readability if used in a less contrived example, e.g. If the body of the loop is longer. I would be surprised if IDEs even supported it. 
While not even in the same bracket of egregiousness as inconsiderate use of goto, this is a pattern that will make your code less readable because it is so rare (rare enough to be a TIL). What's worse, you can produce the exact same behavior by refactoring the inner loop to a function and returning from it, or just using a boolean. It carries superficial convenience at best. 
this is awesome thanks a lot man. can't believe no one's commented on this. one issue though. it will change the genre if i can find it but then sometimes goes back to how the genre was previously written. do you know of this issue?
This would haven been very handy a few weeks back when I was filtering stuff with about 4 levels of loops.
checkout `async`, `request` and `cheerio` -- you can do this with node pretty easily....although the callback soup may bog you down. Iterating over an array and collection results is not as clear cut in javascript as it is in other languages. Let me know if you need help. edit: i just realized you probably want to execute this in the client since you say "click a checbkbox" -- i'm assuming you need to do something in addition like hit submit? If not you can see what ajax call is made and just do that server side instead of interacting with the dom other than getting the value to send.
This is the place for a while loop. Use a for loop when you intend to iterate through the entirety of an object/structure.
If the url is the same for every single line item EXCEPT a unique number for each item, how could I teach this to append the url to the unique number eg - I paste each number into the input like 123 234 345 and it knows to append to http://dumbwebsite.com/123 http://dumbwebsite.com/234 http://dumbwebsite.com/345 etc
Maybe, but gotta show it. The first example on the site is as clear as water to me (although I think `loop2:` was unnecessary). When I try to write the same logic, I usually use a boolean variable and have an if statement in the outer loop that checks in each iteration. I prefer this one, but don't/won't use it because it's not common for other people.
You could always capture the request/responses for that workflow on a single url, and "replay" it on the other 999 as well
Mods, I'm aware this might not be on topic (or might invite discussion that's _really_ off topic) and won't be offended if it gets taken down. I just felt it was worth mentioning that /u/homoiconic (also known as raganwald) has made a public departure. Your regular comments, blog posts, and full books have been insightful, reasonable, and elegant. Thanks for the time you've spent writing for us. I understand the point you're making here, especially when you phrase it in terms of Reddit's making money off of hate speech. I've always been of the mind that the ideal for free speech is to allow racism in some small corner of the site so we can keep an eye on the craziness and show it to our kids when they ask about it. That's not really what's happening anymore. 
 var keys = [123, 234, 345] for (k of keys) { url = "http://dumbwebsite.com/"+key // code from above response goes here... // page.open(url, function (status) { ... }
Sometimes there's no other way. You've not been doing complicated stuff in that 20 years apparently.
Nope. I avoid complication. Its the key to good code.
not as a web developer. no.
Fair enough I suppose, there isn't that much need for it in web dev. Making JavaScript games for example though absolutely requires it.
Are you sure you're not just coding using antiquated patterns?
Unless I'm missing something, you need n nested for looks to work with every value of an n-dimensional matrix.
The second example could easily be rewritten as (in pseudocode, though totally possible in JS): var itemsPassed = 0; foreach (var item in items) { if (tests.All(test =&gt; test.pass(item)) { itemsPassed++; } } The first example is pretty much unreadable ("clever code") and pretty much unmaintainable. It would be better to forego the contrived gotos and simply use a break in the inner loop, cutting down 2 loc you have to reason about.
I don't know much about that....but have you looked a `map reduce`
Could you provide your best example of where this might be necessary?
It's extremely rare to have n-dimensional matrices where n &gt; 2.
You should save your data as JSON and load it with an XHR/Ajax call when you need it: var mydata; $.get('/my/data.json', function(data) { mydata = JSON.parse(data); } JSON means "JavaScript Object Notation" and is a good choice as a simple data format not only in javascript.
Modern JavaScript is practically always a compiled language. That's how it is now able to execute so fast. The compiler (JIT) is integrated into the runtime. Although right now, pre-compilation (from ES6 to ES5) is very popular, so ES6 is currently a combination of traditional compilation and JIT. The distinction is not between compiled and interpreted (meaningless these days) but between statically and dynamically typed.
He is surprised that "class"-es are not hoisted like functions. That's because he thinks "class"-es are "syntactic sugar for functions". No. It is 100% logical and in line with expectations, because "class" names *the prototype OBJECT* and not the constructor function as previously. That is the main difference between the "old" method of creating classes and the class keyword: The classname used to be on the constructor function, now it is on the prototype object (minus methods marked "static") and the constructor method has that standard name. You can clearly see the {} after "class" and that it designates an *object* and not a code block. So why would anyone expect an object to be hoisted? And I'm not sure why the Array behavior is surprising? That's known standard JS behavior for how Arrays are implemented in this language.
He sources an article from Gawker. opinion discarded.
Most code doesn't need to support n-dimensional matrices as well (e.g. in games, you're hopefully at worst working with a 3-dimensional array) so if you need to iterate through elements, you can replace: foreach (x in xs) foreach (y in ys) foreach (z in zs) f(arr[x,y,z], x, y, z); with arr.helper(f); where helper is defined as (in pseudocode) function helper(self_array, f) { for (x in xs) { for (y in ys) { for (z in zs) { f(self_array[x,y,z], x, y, z); } } } }
is this es6? in js that's not how you loop an array --- that's how you iterate over keys in an object.
It's pseudocode. foreach in other languages will let you iterate through the elements of collections. My point is just that you can usually hide away the nested loops to make your code way cleaner.
sorry. i went straight to code. just ignore me.
No, but I want to anyway.
Are you applying this to the `.innerHTML` or `.textContent` properties of an HTML element? This kind of *sounds* like a bit of a [code smell](https://en.wikipedia.org/wiki/Code_smell) 
I don't know if this is the right place, but does it have to be called emojify? I maintain a library called emojify.js, and they do completely different things.
items.filter(function (i) { return doesIPass(i); }).length
Is this a reference to something? Also, can this be my life motto?
Time to get it tattooed 
"when you have eliminated the impossible, whatever remains, however improbable, must be the truth" I know it from Spock, but I think it was actually originally Sherlock Holmes
What's wrong with labels? 
Or maybe he's dealing with some crazy nested data structure? The world isn't black and white. 
Yeah, I realized that, but writing a wrapper to handle that logic detracted from the core explanation. We'll just say that the function is defined for unsigned integers (as it also breaks with floating point numbers).
Making the inner loop a function and returning from it is no different than using `continue`. 
Not at all. Google will progressively enhance any page that allows the execution of Javascript. Less sardonically, Google probably concluded that it was costing too much to keep their basic pages integrated. Google wants to see the web move forward, so forcing that last fraction of a percent to upgrade isn't a terrible idea. Finally, I imagine that Google finds it much easier to track users when they are allowing Google's code to execute (and this is how Google stays profitable).
Oh! That's awesome! I'm going to have to try that out.
I don't see this in Firefox. I'm updating Chrome but I still don't see that (but the page doesn't work right; probably cause I'm in the middle of updating chromium). I don't see it on lynx either which doesn't run javascript. The image doesn't look like something Google would have so I'm suspicious of this post.
The big question to my mind is why I would use this over React? Angular2 does what React does, but with more complexity and makes composability harder.
thanks. so the genre will revert back to what it was previously? does that happen if you process the same tracks a second time?
JavaScript developer, used-to-be-Flash developer here. The Flash application has to actively expose the data that you want to retrieve through JavaScript. This is accomplished through the ExternalInterface class in ActionScript 3. http://help.adobe.com/en_US/as3/dev/WS5b3ccc516d4fbf351e63e3d118a9b90204-7cb1.html 
This answer pleases me. I think. I don't know enough about this area to know for sure.
It appeared for me on Chrome with Google Maps - that yellow figure is the Google Maps "mascot" for a couple of things, I think.
Some famous Vulcan philosopher most likely. Not some obscure Earth's 19 century writer.
It's really no different than using a boolean that breaks the outer loop. I think you're just ingrained with hate for labels because of `goto` and how it's cool to hate on `goto`. 
But this isn't true at all - plain HTML/CSS pages still work - wtf are they talking about...
No, it's more that if they were commonplace then it would be ok but as it's a feature that most people don't even know about you really shouldn't use labels when working on a team or contributing to open source code.
Are there someway to check if a Flash file exposes anything like this? EDIT: It's because I have a arcade website which I would like to make scores for :)
I think its intended as just light humour instead of a boring old "you have javascript disabled please enable it" page.
They could at least allow search with a static portion of the map (image) as a result.
[aurelia](http://aurelia.io/)
My rationale for ditching progressive enhancement and instead making a noscript redirect that simple says "Javascript is required for this site, please enable it in order to use it" is that the proportion of people who have javascript turned off is so small that losing them isn't worth the extra development time that goes into "progressive enhancement". Serious question: Who doesn't use javascript anymore? 
Ehh. I'm usually the one swinging the banner of progressive enhancement, but trying to build something like Maps like that is a waste of effort.
&gt; It appears on Google Maps Note that the Sherlock Holmes guy is actually the yellow Street View guy in costume.
You sound totally unqualified to be doing this
* People who are security conscious. * People who are privacy conscious. * People who want faster page loads. * People who want more performant websites. * People who don't give a shit about your 'sexy' double parallax scrolling effects. * Users of Tor. * Most likely users of screen readers. It's really sad that mountains of JS is loaded on pretty much every page when most of them would be perfectly fine as static.
I am a co-founder of [SEO4Ajax](http://www.seo4ajax.com/). If you don't use any cache to store your snapshots, the crawl rate of (Google) bots will be very low. So, I would recommend to never do a snapshot in real-time for search engine bots (vs social network bots). That is how our service behaves by default.
I'd rather my team spend time learning about contexts and closures -- language structures that are widely applicable and can't be swapped out for a simple design pattern -- before anything like this. I don't know, this seems like a silly argument, but I don't think you can deny most people would be disoriented and might even have to look this up if they saw it in a shared codebase.
[Everyone has JS, right?](http://kryogenix.org/code/browser/everyonehasjs.html)
I am probably the biggest progressive enhancement zealot ever, but I think this is legitimate to display on Google Maps. If it were on google.com I'd be raging hard though.
If you do not use "The /// references" then editors which are not aware of the tsconfig.json file will throw a lot of errors...
No, they're still using progressive enhancement where the technique is appropriate, like search. You should only see this message on web apps where a non-JS version is not really feasible, like maps. PE still makes sense as your default approach for *most* webdev efforts, but there are exceptions, and Google Maps is one of them.
React by itself is just the "V" from the MVC pattern, Angular is a full MV* framework. Thus it gives you a lot more organization when you are part of a big team / project; of course, that might be seen as an advantage or a disadvantage according to each case, but IMHO, in the end almost always it ends up being an advantage.
Screen readers are a whole different problem yes, but it's my understanding that they can read JavaScript pages fine, so long as you do a bit of extra marking up.
JavaScript is not necessarily the problem there. DOM elements created by JS can be made accessible, just as those loaded statically. The problem is most developers don't understand how to make pages accessible.
Wow. Nice benchmark results. Will test it soon. upd. First look: components really required.
Today I saw someone suggest that `three.js` could be used to make a cutting edge graphics game.
Had a play with it and I think it has a lot of potential actually. I love the concept and works reasonable but looks a bit hideous and needs some UI work and maybe some common templates like page examples for bootstrap and material. 
&gt; No one complained, presumably. I mean, really, the only people I've ever seen complain about needing JS enabled are curmudgeonly Slashdot grumps. And they represent an increasingly infinitesimal segment of the internet at this point. Designing pages without JS at this point is essentially dead. 
Everywhere! Blocks @Component, @View, etc in TS files. Why is this code needed? It should be optional, to override defaults. 20+ lines of bootstrap code in index.html. Why? What is the purpose of services.ts? Why the framework can't resolve components without me writting a shit ton of bootstrap code and configuration? Is this somekind of back to 90-s attitude? Pfff...
Why bother? Google has its own browser which is quickly become the most popular.... just remove the option to disable JavaScript. Force the user into their most desirable path.
I don't know of a library that has this behavior, but if you look through the site's code you can see how it's working and possibly remake it. First, they're setting the cursor using "cursor: url(...)" which you can see here: http://i.imgur.com/ViEsB9V.png?1 You should also notice in the above pic that all of the slider items have "display: none" except for the one being shown which has "display: block". It looks like the code for deciding which one should be shown based on the user's mouse movements can be found in main.js. Here's an image of the function: http://i.imgur.com/bMrUKk8.png Hope that helps!
My fiancé and I actually worked on this together. (Well, she submitted the code but we both decided on the Sherlock Holmes themed message.) Pretty neat to see it pop up on /r/javascript/ :)
It's just a humorous landing page. Google Maps (where this message *actually* appears) is quite non-functional without JavaScript enabled (for obvious reasons).
It's gotten to the point where "progressive enhancement" is going to mean "two versions of the same thing, one of which will only ever be used by a tiny minority of people" for a number of Web apps.
I'd say anything that's an actual Web *app*. I mean, look, if I'm building an Angular application there's no way I'm going to bother with a non-JavaScript version. For instance.
-runjs &lt;console.log('fart')&gt; -endjs 
&gt; However if you're creating many instances (say thousands or even millions, or with a lot of function code) you want to be sure that the browser will do smart things like optimize out the duplicate functions and not leak memory. Closures are absolutely foundational to the language, so therefore they are supported identically cross browser even including old IE*. I will get to the caveat in a bit (and its not limited to IE). Most simply put a closure is a declared reference accessed across scope boundaries. This means the limits to effectively optimizing use of closures in any given implementation is a factor of how efficient the interpreting software is at storing large numbers of references in memory. If a given application has so many variables that a modern computer with 2gb of ram crashes running the code due only to the number of references then you might want to rethink your programming approach. Now, you used the word **instances**, which makes me suspect you are talking about poly-instantiation. For the narrow constraints of this problem I would say poly-instantiation is irrelevant. It does allow sharing of properties and prototypes (which is more memory efficient), but as far as closure is specifically concerned we only care about the actual reference, which does occupy memory. As far as execution performance closures are always efficient and the ideal approach. A nearby closure means less resolution time to find the reference. If you are concerned if you should or should not use closures to obtain superior performance then absolutely use closures. This is only reference resolution though, and there are far more important low hanging fruit to improve upon in order to achieve better performance. Perhaps the most important things you can do is to write the most terse and least sloppy code possible and also never type recast (change data types) upon your references. About that caveat.... When we are talking about JavaScript only there are no memory leaks regarding closures in any browser. This is a common misunderstanding. Memory leaks aren't limited to IE and are more related to external interfaces than closures. Memory leaks can occur when a reference points to some external quality (such as a DOM node) and is used in closure. Some browsers may not know when to perform garbage collection upon the artifact and the safest course of action is never perform garbage collection prematurely. After all it takes longer for memory leaks to become an apparent problem than an immediately failing application. Old IE would use a separate memory allocation for DOM references apart from JavaScript so even if IE garbage collected everything from JavaScript properly it would still miss garbage collecting DOM artifacts. Crockford wrote something more detailed on this: http://javascript.crockford.com/memory/leak.html
&amp;#3232;_&amp;#3232;
&gt;this is a pattern that will make your code less readable because it is so rare so just because many js developers are noobs and may not know they can use labels to continue or break for loops, that means that it should be avoided? That sounds like the cart before the horse.
Now now, no need to be like that. :) My opinion is (not surprisingly) unpopular on /r/javascript, which is fine, but I do wish people would follow [reddiquette](https://www.reddit.com/wiki/reddiquette). Ninja edit: did people not read the article, thinking the title of it was what I was trying to convey? If so, that's rather unfortunate.
Hey guys I want to disable all software from running any code at all. Does anyone know how to do this?
oh no! they might have to learn something? you're full of shit, your argument makes no sense. what else do you want to hide from your team? they sound easily distracted and not very good, if you think you need to hide something about the language they are programming with.
One specific case I was thinking about is: function Thing() { this.a = 5; this.b = 'something'; // etc. } Thing.prototype.process = function() { // lots of complex code }; versus: function Thing() { var a = 5; var b = 'something; // etc function process() { // lots of complex code // will this get duplicated for each instance in old browsers? } return { process: process }; } 
React was marketed as such, but react is the VC and sometimes the M depending on how you implement your app. Angular has VC as well, but doesn't really have a model. ngResource isn't really a model and one usually needs to swap in something like restangular just as one would swap in flux. Angular's other system for models is services and factories, but once you strip the dependency injection, they are POJO. The framework that actually has everything under one roof is ember. 
This is all a hypothetical. Look, this is a silly argument, even before you resorted to the ad hominem attack this was and will continue to be an undesirable development pattern, whether or not you get incensed about it being so is another matter entirely.
Agreed :) Those two issues were only the tip of the iceberg for those developers.
you dont understand the internet, its ok ur a redditor.
sooo... no errors appear or anything but now I just get no sound feedback. When I console the buffer (input) I get: ArrayBuffer { byteLength: 4096 } function playAudio(buffer) { var audioCtx; var started = false; if(!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } source = audioCtx.createBufferSource(); audioBuffer = audioCtx.createBuffer( 1, 2048, audioCtx.sampleRate ); audioBuffer.getChannelData( 0 ).set( buffer ); source.buffer = audioBuffer; source.connect( audioCtx.destination ); source.start(0); } function recorderProcess(e) { var left = e.inputBuffer.getChannelData(0); socket.emit('audio-blod-send', left); } 
Alright, whatever, you go ahead and single handedly make it a viable development pattern. I don't care :P
As you note on the readme, this doesn't product valid JavaScript. You can use emoji as keys on an object, so you could make valid JavaScript peppered with emoji: var methods = { '💩': function(x){ return x+1; }, '🚀': function(a) { return methods['💩'](a * 4); } } Efficiency not guaranteed.
Thanks. I'm wondering if it will actually get duplicated though, as I've read various comments here and on Stackoverflow saying this is an optimization that has been made in current browsers. I'm not sure what browser versions this applies to though.
&gt; Serious question: Who doesn't use javascript anymore? Anyone visiting newspaper websites with 300+ 3rd party scripts.
&gt; this was and will continue to be an undesirable development pattern Again, full of shit.
Heres an interesting blog post on how many users have JavaScript disabled and the methods of finding it out. https://gds.blog.gov.uk/2013/10/21/how-many-people-are-missing-out-on-javascript-enhancement/
I agree. This is an issue of screen readers not keeping up with modern technology. When AJAX become popular, Google had to update GoogleBot to handle it. Then frontend routing came around, and GoogleBot had to come up with a prescribed way to handle that as well. I have heard of no screen reader project or company putting out any RFCs or even contacting the overall developer community to try and find a standard way to accomplish anything. Don't blame the evolving world of web development for the stagnation of a tangential industry.
[The extra cost argument has been debunked repeatedly.](http://blog.easy-designs.net/archives/the-true-cost-of-progressive-enhancement/) Unless you're developing something as rich as Google Maps, where it's completely impossible to use PE outside of literally writing two separate apps, then the extra cost argument doesn't really apply. In our fancy 21st century world of isomorphic/universal JavaScript there are very few web app classes that aren't suited for a PE-driven approach. The ones that aren't can be [strictly enumerated](http://www.sitepoint.com/javascript-dependency-backlash-myth-busting-progressive-enhancement/?utm_source=javascriptweekly&amp;utm_medium=email): - **Prototypes.** Quick mockups and throw-away code obviously don't need PE since they'll never make it to production. - **Client-side-only applications.** No server interaction = no PE. - **Internal corporate applications.** From the link above: *"Enforcing JavaScript isn't a problem when you know your audience and the devices they use. Angular was initially designed for enterprise applications."* - **Sophisticated interfaces.** Games, Google Maps, etc. If your web app isn't one of those things, you probably should be using PE.
Which is fine, because Angular is not supposed to be used for the sorts of web projects where progressive enhancement makes sense. The trouble with this though is *far* too many people default to Angular and similar frameworks which make PE nearly impossible when their use case actually is a very good case for using a PE-compatible approach instead. As such, people shouldn't default to Angular. People should default to PE. The use cases for PE-busting frameworks like Angular are [strictly enumerated](http://www.sitepoint.com/javascript-dependency-backlash-myth-busting-progressive-enhancement/?utm_source=javascriptweekly&amp;utm_medium=email): - **Prototypes.** Quick mockups and throw-away code obviously don't need PE since they'll never make it to production. - **Client-side-only applications.** No server interaction = no PE. - **Internal corporate applications.** From the link above: *"Enforcing JavaScript isn't a problem when you know your audience and the devices they use. Angular was initially designed for enterprise applications."* - **Sophisticated interfaces.** Games, Google Maps, etc. If your web app isn't one of those things, you probably should be using PE.
FWIW, that article was written by Brad Frost, one of the most respected web developers in the world. It may be blunt and crass, but it makes good points. You might want to give it another look.
You can't intentionally disable a website's functionality and then be mad when it doesn't work. 
The real answer is 1 out of 93, and I read all of that and still don't care. 
Hmm... yeah, I don't know, man. The site freezes for me now too. It was working when I would try it with just two characters... but I don't know. Maybe the site knows we're trying to brute force it and it's doing something weird when we go to it now... I honestly don't know. You could try clearing out your cookies/history and then going to the site... Might reset everything.
Do you say that about Java applets or Flash? Person (in 2006): "Java applets are insecure, so I'm disabling them. I wish more sites worked without Java applets." You: "You can't intentionally disable a website's functionality and then be mad when it doesn't work." That person is **not** intentionally disabling a website's functionality, they are intentionally disabling a security vulnerability. They're also not mad that the websites don't work, but they *wish* more websites worked without it.
No javascript for the sake of accessibility is an outdated concept at this point. The accessibility problem lies with poor accessibility education among developers. People who use screen readers use javascript. 
Anyone who cares about security or privacy, for one. (Including all sensible Tor users)
You will be assimilated.
I don’t know what you think is limiting? There are some truly amazing games and interactive experiences made with three.js. It almost seems like you’re limiting yourself on purpose.
You do recognize that the phrase "cutting edge" means pushing the limits of what's possible given the hardware, right? Do you actually believe that `three.js` in a browser competes in performance or ability with native graphics?
But why must so much functionality be tied to JavaScript? When I can't even navigate a site without it (or hell, when the site simply doesn't load), I see it as no more than a hindrance and lazy design to be quite frank. A website is nothing more than a document with formatted text. Presentation is (and should be) completely separate. JavaScript definitely does have a place on the modern web, but it's supposed to be in the category of interactivity/presentation - nothing more. In the majority of cases, JavaScript isn't (or rather, shouldn't be) vital for your average website. So I do "get mad" when a news website, blog, forum etc. simply breaks because they require me to load their 14 different sources for JavaScript - half of which are probably trackers who do nothing but worsen my experience. This is all in the context of _websites_. For web _applications_ JavaScript is obviously a necessity. Why make things more complicated than they have to be? Don't require JavaScript unless your site absolutely can't do without it. Edit: and why can't people follow [reddiquette](https://www.reddit.com/wiki/reddiquette)?
Ah, I see. She's on the Maps team so she actually submitted the feature. We both came up with the Holmes idea together though, after considering a few others. (We had an alternate Where's Waldo one too.)
Very true, at least he's a good sport about it. :)
That is definitely true, Google Maps has legitimately dropped PE. But the number of people who build websites that are little more than text, links, and forms and think they're just as justified in dropping PE is pretty damn alarming.
No, [it's not that simple](http://www.sitepoint.com/javascript-dependency-backlash-myth-busting-progressive-enhancement/?utm_source=javascriptweekly&amp;utm_medium=email). Making two completely different versions of Google Maps, one with JS, and one without JS, is obviously a waste of time. But *most* web apps can work without JS without such an extreme duplication of efforts by making smart architecture decisions like taking advantage of isomorphic/universal JS stacks that are compatible with PE. &gt; And they represent an increasingly infinitesimal segment of the internet at this point. [Not quite](http://kryogenix.org/code/browser/everyonehasjs.html).
&gt; ghostery You mispelled [uBlock origin](https://github.com/gorhill/uBlock)
You guys might wanna do a blog post about why Google Maps is one of the rare web apps on the web that isn't really a good case for progressive enhancement. A lot of people in this subreddit seem to think that rejecting PE should be a new default, whereas as many have pointed out [very few webapps should drop PE](http://www.sitepoint.com/javascript-dependency-backlash-myth-busting-progressive-enhancement/?utm_source=javascriptweekly&amp;utm_medium=email) and it just so happens Google Maps is one of those exceptions to the rule.
Well, frankly I disagree. The user experience is so much better that I think it's worth losing non-JS users. 
That's an interesting suggestion. I think some of the people (at least on this discussion) that seem to be faulting Google for not adhering to PE aren't taking into consideration the levels of complexity (cost, development time, testing, etc.) that such an approach adds *on top of* what is already one of the largest and most complicate web apps. Maps is totally free to use (even without a Google account or any authentication beforehand) and really expensive to maintain, develop, etc... I think the fact that it exists at all and works so well is pretty awesome in and of itself. :)
Try turning it off and not back on again.
I think an important thing to consider is that Google Maps is a totally free service. It doesn't even require you to have a Google account or to sign into anything. (And it costs a *ton* to maintain and develop.) If this were a paid service, then...yes, maybe people would have a reasonable expectation of a degraded experience without JavaScript enabled. (That's debatable I guess. It depends on their sign-up experience.) But I think it's completely reasonable for web applications like Google Maps to not support PE because (a) it would add a lot of complexity (and cost) to the development and (b) it would result in an experience that just isn't anywhere near as compelling. So the choice becomes... do you want to enable scripts while you're using Google Maps or do you just want to use another, more traditional mapping tool? That doesn't seem like such an unreasonable choice.
This article is so stupid. Oh no, they can't load the JavaScript if they're in a train and lose Internet service. That's too bad because otherwise they'd totally be able to use your site in that scenario. If anything SPAs are better for unreliable connections because the amount of stuff per page view is so much lower 
Yup! That's totally right.
&gt; * People who are security conscious. It has been a really long time since security breaches, now that the whole page loads in a sandbox. Plugins on the other hand aren't. Disable those. &gt; * People who are privacy conscious. Privacy is usually breached by cookies (HTTP) and iframes (HTML). JavaScript is limited to communicate with its original host, by design, and the extra information it can gather about you is limited to your user input inside that page, which you are already giving up anyway. &gt; * People who want faster page loads. Are you from the 00'? If anything, JavaScript saves you from loading pages by exchanging minimal information up and down to let your browser do the parsing instead. Faster than your connection. &gt; * People who want more performant websites. As in "I press upvote and I want the whole page to load again to perform that action"? &gt;* People who don't give a shit about your 'sexy' double parallax scrolling effects. Why are you even visiting if you despise it? Do you hate yourself so much? &gt;* Users of Tor. What makes JavaScript and tor incompatible? Read points 1, 2 and 3. &gt;* Most likely users of screen readers. Screen readers from the 90's, maybe. ---- Disabling external images and frames is infinitely more useful in these matters than disabling JS. And that's not even an option in most browsers.
My rebuttal to that 2nd link: 1. Irrelevant. Any JS that is critical enough to run before JS files are loaded can be easily inlined in the page itself. 2. Irrelevant. The page itself, images, or any other assets can be interrupted as well. Such a small edge case it's literally not worth redesigning everything for. 3. This is the same exact scenario as #2. Not sure why they needed to repeat themselves. 4. Not my problem. 5. This is not a valid concern. It was a one-time incident that was rectified quickly, and only affected people who used JQuery as a CDN without coding a backup. In short, it only affects short-sighted developers, and only did so for a short time. 6. These people are irrelevant to modern web design. The web uses Javascript. Period. People who turn it off have no right to complain when sites stop working. That's like complaining that the web stops working if someone makes a browser with an option to turn off CSS or HTML. 7. Not my problem. Will never be my problem. 8. Same as #5. Never use a CDN without specifying a backup as well. 9. That's why you design your site with a minimal browser in mind first. This idea that all sites need no JS modes on them is antiquated. You bring that up in a modern web design shop and you'll be laughed out of the room. HTML/CSS/JS are an inseparable trio. 
No kidding, I mean without JS there is no AJAX, and the ability to post stuff without refreshing and reloading the page is absolutely awesome. (See: Reddit.)
&gt; emojify.js I think the "-ify" suffix has been pretty much monopolized by Browserify transforms these days: https://github.com/substack/node-browserify/wiki/list-of-transforms
&gt; This article is so stupid. Oh no, they can't load the JavaScript if they're in a train and lose Internet service. That's too bad because otherwise they'd totally be able to use your site in that scenario. Yes. Exactly. That's not hyperbole, that is *exactly what PE is all about.* The user would still be able to see content if the JS failed. Then the second link they click would hopefully allow the rest JS to load and then they'd be in happy SPA land. &gt; If anything SPAs are better for unreliable connections because the amount of stuff per page view is so much lower Only if you succeed at loading everything in the first page load, which is not necessarily guaranteed. And only if your entire application is free of JS errors. Jake Archibald once told a great story about how the Google Chrome download page required JS for some reason and then one day when the CDN where the JS was hosted went down or there was some JS error on the page (I forget which) nobody could download the browser. There's no reason that should have ever happened. PE could have prevented it. It's just one of many examples about how PE is a better, more fault tolerant design. It may not be the right tool for every job, and I do agree it's not the right tool for Google Maps, but all you people writing it off as not the right tool for *any* job need to stop knee jerking and start giving the question more careful consideration.
There's no reason you'd have a worse experience for those who are JS enabled. PE is about fault tolerance, not kneecapping the happy path.
Not really as far as Google Maps go...
Reddit is a perfect example of a site which could benefit from more progressive enhancement. It's not hard to offer that feature to JS users while still allow comments to be posted with a page reload for non-JS users, and yet reddit does not due to poor programming.
Reloading after any comment submission would honestly just suck. &gt;and yet reddit does not due to poor programming. Don't be a fool, that is not at all the reason, the reason is they have different opinions / priorities than you.
&gt; is pretty damn alarming. And they keep feeling superior about it. lol
If the news site, blog, forum, etc. doesn't want your viewership that's their business.
Press Alt + F4, shutdown your computer, unplug your computer, pack it up on a box, and throw it out a window. Problem. Solved.
wtf does that even mean.
So what you're saying is that reddit should fail more gracefully, not that reddit should adopt PE. Reloading the entire page after every upvote would just be ridiculous. 
[Like this?](https://m.youtube.com/watch?v=ZP7ebyqBn_M)
It's not extra work if you choose a stack that prevents it from being extra work. Look into isomorphic/universal JS stacks.
Given that it seems your not the creator of the game, and presumably are not in contact with the creator, if where you're getting the game isn't already set up to do this now, my guess is chances are the game is not set up to do it.
Sorry, didn't mean to be a dick. Hope you make more videos before FRP on client side is super cool.
Works for me http://imgur.com/a8KQXKR
That makes more sense when the feature in question is prohibitively difficult to progressively enhance, like say embedding Google Maps on your site. Best to just not show the map at all to non-JS users. But a vote button is so much simpler. Just make it a link that reloads the page if JS isn't enabled. I think non-JS users would rather have the ability to vote by reloading the page than to be denied the feature.
"Someone important said something, there's no way they could be wrong! All smart people know everything!"
Using Angular doesn't suddenly make your interfaces better. Just build the same UX with something other than Angular that's more compatible with PE. It can be done, and yes, without bloating the effort. Angular is a good tool for some jobs, not all jobs.
.textContent, Change the text that the same variable stores on the click of a button.
To show errors, you have to analyze the code. No one wrote their own analyzer. Every plugin uses the same analysis service/server. Dart went the same route. The Eclipse, WebStorm, and Atom plugins just spin up a little web server which does all the work. Anyhow, here is Atom without a /// ref (and with tsconfig): http://i.imgur.com/C51P5TH.png As you can see, it knows about jQuery, because it has loaded that \*.d.ts file which was mentioned in the config.
Keep Austin callous and mean spirited!
I do accessibility rectification for SPAs. My life is a never ending hell.
That's a pretty terrible way to do an image slider, I tried to move my cursor to see a detail that was underneath it and it changed the image on me. Use a normal slider instead, something like slick.js should work better.
That's the API. We're not talking about the API. We're talking about the web app. Besides that, the free limit is 25k requests / day. That's pretty a generous free limit...
Keep looking! ;)
why not use static maps as a fallback? you already have graceful degradation built in....
a limit is a limit is a limit
Switched to Disconnect, will switch again when another alternative comes up
static maps
That was the IE6-7 behavior. People could harm your computer at this time but now it's perfectly fine (except if you still don't update your browser, which is bad and you should receive malware in that case). Come on, browsers now have powerful and really secure Javascript execution inside browsers and update themselves so they don't really suffer from exploits. Blocking Javascript is more historical than useful.
you really like that word. "Maps is totally free to use" != "Google Maps web application is totally free to use" i point that out because alot of people don't know that at all, let alone the difference between the two. much like the army of open sourcerers that worship chrome, they need to be reminded that chrome isn't open source, chromium is ;) 
Ah, sorry. I understand what you're saying. That's not really built-in... it could be made to work, but it would require some surrounding chrome to be a compelling experience. I don't have the answer for why it's not supported. I assume it's been considered and was decided to not be worth the effort? :)
Common man. Within the context of this discussion thread, "Maps" *clearly* refers to the [Google web] maps [application]. :)
I meant web developers, not screen reader developers. A standard already exists for making pages accessible: http://www.w3.org/WAI/intro/aria.php.
This is correct. PE was a great idea when most of the world had feature phones that choked on JS. While it's certainly true that many people still fall in that category, the number is shrinking and I'd bet they don't represent the majority any longer. And if someone turns it off explicitly? Too bad, you get what you get. JS is like HTML these days: you just can't do without it. No need for PE anymore. It's time has passed. 
I'm not one to wear tin foil hats, but we need to get away from this notion of free. Very few websites are truly free these days. In this situation, you are offering Google to track your data and serve you ads. Even if it's not within their maps apps, it's part of your agreement to be in their ecosystem. They make $45/user a year according to their recent earnings. If you are selling them your data and/or desktop space to show ads, it is not a free product. Wikipedia is a free product (although we should all try to donate if we have the means). But google maps is not free. To get back to the subject though: traditional software had minimum requirements to run the software. If you bought a video game that had minimum requirements higher than the specifications of your computer, then you can't blame the company Instead, if you charge a user, you should notify them that JavaScript is required to run your product. Like with Google, they can't show you ads or track you without JavaScript so they do the responsible thing and also don't serve you a product.
Oh wow, there is a standard. I'm surprised because googling "screen reader web standards" links to some close pages, only some of which mention ARIA (and even then very little). Now look at the ARIA page that you linked me. I don't see a code sample anywhere in sight. No documentation other than links to the official spec documents (which are a nightmare to read). Last updated 13 months ago. The rest of the web has moved on from shitty documentation and convoluted specs. It needs to be boiled down like everything else to be easily accessible and easy to understand. This is not good enough, and it's not the rest of the webs fault.
I need to clarify a bit I think. The idea is that progressive enhancement is still a best practice that should be your default methodology for *most* webdev efforts, [but some exceptions exist](http://www.sitepoint.com/javascript-dependency-backlash-myth-busting-progressive-enhancement/) and Google Maps is one such exception where PE isn't really the right tool for the job. The trouble seems to be that a large number of web developers have decided instead that PE-busting stacks should be your default and that PE should never be used, ever. It kinda reminds me of the bad old days of people coding entire websites in Flash even if they were just text and links and forms. People are making that same mistake over again through overuse of PE-busting thick client frameworks like Angular.
https://www.reddit.com/r/chrome/comments/32ory7/ublock_is_back_under_a_new_name/ tl;dr origin is by the original author of the 'back end' code, after some internal dispute. 
I'm working on a SPA that I will need to make screen reader compatible.... What kind of hell am I going to have to endure? It's an Angular app BTW.
Damn feminware-ists can't you just accept equal treatment for all wares?
Hmm, really? And is ublock not? Does ublock do everything disconnect does?
People who don't use it, disable it by default and turn it on when they actually see the need. This helps you get around anonymous data collection and all that, and also helps you generally maintain a higher level of software freedom. I'm not that much of a nut myself, but I respect people who are.
I agree. 99% of the time when people use labels they could probably restructure their code in a more sound way. I've yet to be presented a high-level case (as in, not writing a jitter) where that is not the case and higher-level language concepts (e.g. object disposal patterns) would not yield a better solution.
Nah you have to remove the CMOS battery first 
Is it cross platform?
I have literally less than a week of javascript experience and react is very easy to use. Don't overestimate the learning difficulty.
I am insinuating that no one cares about you. I did so by saying that the marketers would be the "at least one person" who cares about you. (but you push them out of your life... :'( )
I tried the latter. I think. Let me try this tomorrow, thank you#
You said it perfectly. 97.6% of the respondents for the [2014 WebAIM Screen Reader User Survey](http://webaim.org/projects/screenreadersurvey5/#javascript) said that they browse with JavaScript enabled. Many developers just do a poor job of building things so they're accessible.
JavaScript makes pages faster, not slower -- when used correctly. Don't count the screw-ups as the baseline.
I love how everybody arguing for disabling JS in this thread is throwing out "but Google Maps is a legit exception!" That's just please-don't-downvote-me BS, because Google Maps and Mapquest first existed without JS, and up until recently supported non-JS users, so it's 100% possible for them to be giving you your "degraded but functional experience". They just chose not to, because it's 2015 and nobody in their right mind thinks it's a good idea to spend time and money creating and maintaining embarrassingly shitty software just because there are a few laptop-wielding hermits who accept nothing else. You want your perfect security through abstinence? Throw out your laptop.
Anyone have any experience with it?
Wait, are you suggesting page reloads on upvotes? That would make me so damn angry. I would rather it just pretend that the upvote worked and have nothing happen.
Asking the important questions
I usually test these combinations: - IE 10/11 with JAWS 15+ - Firefox with NVDA Chrome works well with ChromeVOX, but hardly anyone is using ChromeVox at this point. Apple Talkback with Safari (both IOS and OSX) is worth testing too, but you'll find that most corporations don't seem to care. Mostly they care about getting AA compliance, and making sure JAWS &amp; IE work. As for the nuts and bolts of it.... - make sure your fields are linked to labels. So, either have the "for" attribute in your labels, or use labelled-by on your input elements. Don't use both on the same label/input at the same time, or things may get read twice. - use aria-described by on input (or other) elements to link related text (for instance, in a dialog you can focus on either the text or the first input, and link the focused element to the dialog title) - focus is important. You should be able to navigate the whole spa with the screen off. You will probably need to implement a way to focus on a page element when your SPA loads a new view (personally I use data-focus attributes and use a binding handler - most of my work is with Durandal/Knockout apps). - don't add a tab-index to everything. Screen readers have two methods of navigating a page. "Forms mode" which is what you get when you tab between elements, or "JAWS/NVDA cursor". The screen reader cursor has no visible focus, but allows you to navigate with the arrow keys. Your screen reader will find all sorts of reasons to keep shoving you in forms mode. Hit "Esc" to get out of it. - Angular has an accessibility module, look into it: https://docs.angularjs.org/guide/accessibility - I was going to write more, but this site has a TON of information around accessibility and angular... more than I could ever hope to give: http://simplyaccessible.com/article/spangular-accessibility/ Good luck :)
how does it compare to the NativeScript framework?
Being isomorphic is only a relatively recent fad and it's non-trivial to go back and add it in to something that wasn't designed for it to begin with.
Respect is relative. I never heard his name before last night, and nothing I read then gave me any reason to heap lauds upon him. Plus our opinions are just that-our personal outlook of a situation. I am quite sure that we different workflows, toolchains and methodologies, but neither of us is right or wrong in what we do. His post is a call to wake up and pay attention, sure, but as a sole developer, I can't afford the effort to target devices that only see infrequent use for web browsing. That said, I will make sure to target the colourblind and blind in future because *that* is worthy.
No need to get all snarky. I made a lighthearted joke because I liked your response. If you're referring to my edit, it was more a spur of the moment annoyance with people down voting based on a moral disagreement, rather than a technical one. It should have been in my original reply, that's my bad.
Very true. I still stand by my point however, that this is going against what the internet is all about, both on a technical and philosophical level. But I suppose readers here don't share those sentiments, so I might as well quit.
that looks really good! especially stuff like `&lt;template&gt; ... &lt;while someJsVar=true&gt;&lt;stroke size=1px color=pink&gt;&lt;/while&gt; &lt;/template&gt;` 
Runs on OS X and Windows, produces cross platform apps.
&gt; there is no reason not to code Isomorphic Really? it looks like however that the rendering on server side AngularJS or React suffer from serious perf issues...
I would probably throw your last block of 'setup stuff' into an init() function, and call that explicitly as needed. Maybe have a teardown function to unbind everything, depending on requirements. I think I'd use an [IIFE](http://benalman.com/news/2010/11/immediately-invoked-function-expression/) to wrap the whole thing, and pass in the global jQuery as **$**. You seem to be mixing your [function styles](http://www.permadi.com/tutorial/jsFunc/index.html) for no reason that I can tell, but maybe I'm just missing something.
[context: document, selector: "#edit1994861"] context: document selector: "#edit1994861"__proto__: m[0] this is the console.log(); the problem is that ajax requests are done when **nota** is not defined. you have to assume **id_avaliacaoqualitativa** is true and so $.each() is executed. That's why I am assuming I need to force $.each to be finished and only then do the ajax request.
there ya go: [1994861, 1, 67000000009492, 11269, null, null, -3, "Comportamento"]
Thanks for a feedback! Our team is working hard to improve React-UI-Builder and making some tutorials and documentation. I can't say nothing about UI at the moment, but common templates like a page examples will be finished soon and will be accessible through the projects gallery.
I made this for fun over the weekend http://testbed.stugoo.co.uk/london-timelapse It might be a starting point, but it primarily uses CSS
Just to shorten this (since I need to go), what you probably want is: $(document).ready(function() { // your code that calls inserirEdit }); You can also check the validity of the element you are looking for by adding the log to this block: $(document).ready(function() { console.log($('#nota_'+id_registo).length); });
Okay, I'll check it out. Thanks for trying!
You definitely could go this route! My reasons personally are that sometimes, depending on the project, I do not have the ability to use a browserify / webpack build step so having a pre-compiled standalone Event Emitter is pretty useful.
Nice. I went in on chrome and deleted the cookies... The website seems to function normally for me again.
Hi! Would you mind giving me an eli5 on promises?
It is not recent. people have been doing server side rendering with the same templates on both client and server for years and years.
Solved! thank you :)
Thank you! Your comment should be a sticky post at the top of /r/JavaScript. 
That gave me some confidence. Thanks! The thing is, I haven't tried it yet. Want to finish Eloquent Javascript first, I have a couple of chapters left :)
That. I mostly use callbacks but when I read his post the only thing I was thinking was "Gosh, use promises if you don't like callbacks".
What exactly are you having trouble with? Programming isn't copying tutorials, it's using the knowledge you already have a building on it. Where are you at now in the project?
Are you sure? Works for me just fine on 0.10.26 as well..
I loved the article, but I don't think you're conveying the right message. I believe the developer should take the best of both worlds. - While supporting legacy browsers potentially let's more users use your site, newer technologies might also potentially make them stay. Also, developers waste less time writing different implementations for older browsers. - Preprocessors. CSS preprocessors take little to no time to learn and are extremely time-saving. I believe it's only beneficial to pick one that suits your needs and just go with it. JS preprocessors on the other hand are entirely different story. - Accessibility. I agree in its entirety, although I don't think that's being boring; that's just making it work. - UI Design. I agree that there's a fine line between doing it and overdoing it in UI design and it all depends on the websites niche. It doesn't mean that we should build websites that look like they're from 2005 though. - Third party libraries. True. All-in on this. - UI architecture. There, you just went back to 2005. This paragraph is just full of fear of change. Of course using SPA everywhere is sub optimal, but like everything it has its use cases and takes a seasoned developer to do well. All in all it depends on what your clients are, if you're selling a B2B or B2C solution and lots of other factors. Every project might have different needs; in some you have to be boring, some allows you to enjoy yourself and rapid change.
Basically, I've started planning my game, no programming yet. The thing is, I'm struggling with how to *code* the game. For example, I'm going to need an inventory. Do I list the Item()s in an Inventory() array? Are Weapons a child function of items? Things like this I'm still a bit unclear about.
It's not just the OOP part, it's applying game logic to programming, which was why I was looking up tutorials and stuff, just so I can see how somebody did it. As for the inventory thing, what you said mostly makes sense.
Pointers are in C++, not JavaScript.
Thanks so much! Neat to know! I'm still learning about proper etiquette on Reddit. If I have more KA questions in the future, would it be appropriate to contact you or jeresig directly?
Thanks so much! That was a simple fix and was the kind of thing I was hoping for. I spent some time trying to learn more about what you did and why it worked. Does [this page](http://processingjs.org/articles/jsQuickStart.html#processingcodeinwebpage) explain the best?
probably not but i think its an easy workaround, in your hover fn check if you are dragging and if necessary reset the stuff your hover fn does $('.draggable').hover(function(e) { if ($(e.target).hasClass('ui-draggable-dragging')){ //reset once if you need to: $(e.target).css('border',0) // return to stop event return } $(e.target).css('border','1px solid green') }) edit: actually you might be able to... if you bind the hover to the parent obj: $('body').on('hover', '.myclass:not(.ui-draggable-dragging)', function() { //dostuff }) but im not sure if the :not() selector is gonna work here or not!
You're missing a key component in this: Business. In the 'good old days' of Flash, developers were forgoing all reason and logic and building entire websites in Flash. There was no reason for it other than 'neat!'. Today, JS is the biggest tracking language available. Yes, a lot of JS is 'neat', but a lot of it is also *business*. If you are running a *free service* which generates profits by collecting data and in turn, selling that data to advertisers, then why would you build that service in such a way that the profit-making portion of the service could be easily disabled by any user? You wouldn't, simply put. You wouldn't build the website in a way that those profit-making functions can be easily disabled while the service still works fine. And sure, a few diehards might get pissed off at you. But let's not kid ourselves: Those of you out there clamoring over the need for completely functional, non-JS websites are either doing so out of principle, and you don't actually use noscript *everywhere, everywhen*... or you're a member of an extreme minority, and your business as such is not that attractive. I mean, you don't see Elon Musk trying to bend over backwards to market a product to the Amish, do you? No. He realizes his target audience is 'people who use automobiles and electricity'. He doesn't target the Amish *at all*. They don't factor into his consideration. The noscript users out there? *They're the internet's Amish.* And at least in my development, I legitimately don't care about them. Neither do my clients.
&gt; ..because it's 2015 and nobody in their right mind thinks it's a good idea to spend time and money creating and maintaining embarrassingly shitty software just because there are a few laptop-wielding hermits who accept nothing else. You want your perfect security through abstinence? Throw out your laptop. Couldn't have said it better, though rather than 'hermit' [I compare these noscript users to the Amish.](https://www.reddit.com/r/javascript/comments/3d09y7/googles_new_page_if_you_have_javascript_disabled/ct1s7o8) 
also that if you use their framework Angular, you won't be crawled or indexed either.
I did appreciate that it was simple to use and was one less account I had sitting online someplace. I could get lost for hours seeing other people's tests and playing with them as well. Looking forward to having it back either way. Was incredibly useful.
tl;dr: either the config files are messy or the tools are young. Pick one.
"Things that don't help in any way: Posting +1 comments" "What about read only mode?" +1 +1 +1 +1fffffffffff
Your colors are showing. &gt; 1. a rise in frameworks which are hostile to PE Since when have frameworks dictated anything? I know a lot of professionals who shun them all together. It's also not fair to really use this in comparison to Google when they're *developing their own frameworks*. &gt; 2. developers fetishizing new frameworks because new = modern = better which is not always the case, and This has never not been true. It's never going to change either. But again: I know plenty of professionals who shun frameworks altogether. &gt; 3. because some very loud and vocal people are incorrectly dismissing PE as a "never use" technique rather than promoting nuance on the subject as I am. You're not getting it: PE is important *to a point*, but no, in a business sense, it's not worth spending *time and money on* very often. Progressive enhancement hits a wall, invariably. You have to draw the line *somewhere*. It's a business decision now; it used to be a technological one: "How many users are using this browser?". But now it's a cost-benefit analysis: "Do we care about the users using this browser? Is it worth increasing development time by another week just to handle the potential dozen or so users who this might affect?" 9 times out of 10 the answer is "Hell. No". You could spend 90% of your development time addressing less than 1% of the users. Please explain how that is at all a 'smart move'. A 'good use of time'. Look at IE7. Do you still support it? Why not? What about IE8? It's still used by nearly a fourth of China; aren't all those users important? China is a huge economy; you're ignoring them by not supporting IE8. And this sub will harp on IE8 support too: "Microsoft doesn't even support IE8, why should we?". But Noscript users are smaller than that minority even. What about Netscape? Are you building your websites to be compatible with Netscape? Because you may as well be, when you look at the numbers. Reaching the 'maximum number of users' is a brute force application of business and *advertising* (lest we forget that the primary function of most website development is to advertise a thing). No intelligently run business does this any more. None. Hasn't been the case that 'more eyes == more money' since the days of the newspaper-boy on the street screaming 'Extra extra, read all about it!'. And I'll evidence this: If I'm advertising say... the new Schwarzenegger movie. Does it behoove me to advertise on Lifetime TV network ("Television for Women")? Or The Oprah Network? Or Spike TV? If I'm advertising feminine hygiene.. do I advertise during that new hyped MMA match on Spike TV? Or do I stick it between Cake Wars and Toddlers in Tiaras? It's not about getting as many eyes on the screen as possible, it's about getting *the right eyes* to see it. If I can increase my sales by 40% by deciding that 20% of my userbase needs to be booted from my thoughts... that's a staggering win. I increase sales, decrease overhead costs. And reddit just did this: Look at FPH. They decided that in order to monetize, they're going to have to piss off some of the more toxic of the userbase. Drive them away. And if reddit can increase profits while dropping the number of users... well that's a win every way you look at it, users be damned. The backlash against progressive enhancement has come along right alongside the business takeover of development. Development used to be about programming first, business second. That's the hippie, long hair, free spirited internet we all fondly remember from the 90s. Now Development is a business endeavor. You have to say 'Look, this group of people *is more important* than that group, for our purposes today'. You certainly wouldn't be trying to support IE7 for that new browser-based photoshop-killer app you're making. Because IE7 users aren't your target audience. The fact is that noscript users are stuck in the past. Just like people still using Netscape. The internet doesn't get better by trying to consistently handle every browser and every combination of potentialities (see ask the ms- css tags and hacks). It gets better by *moving on*. 
Came here to make pointer jokes, should have known I wouldn't be the first. 
Interesting... I now have a better understanding of callbacks and promises than I have in the past. Thanks!!
That's like step one in making it happen. Even within those stacks, architecting things such that you can deliver a usable experience without javascript takes extra care and will cost you time you could have used on features for the other 95% of people.
&gt; No, you bring it up in a modern web shop and it seems to split the room down the middle. Yes, because probably 3/4 of the people who want to disable javascript *are web developers*. If that's your target audience, PE is definitely a concern. For most projects it's nowhere near worth the effort involved.
That is the [first myth debunked](http://www.sitepoint.com/javascript-dependency-backlash-myth-busting-progressive-enhancement/) on the article I keep trying to get people here to read.
And those frameworks are okay to use when you don't *need to* progressively enhance. Are you paying attention? **There is a cost-benefit analysis at play. It isn't enough benefit for the cost to progressively enhance to the point of noscript, in nearly every scenario you can picture**. If the business only stands to increase sales by 1% in exchange for increasing development costs by 50% (and this is a pretty standard fee for backwards compatibility to IE8, for instance), then the business would be stupid to order that progressive enhancement. You keep pointing to that site like it speaks for all developers, everywhere. It doesn't. It speaks for one, in a very generalized and idealistic sense without a lot of *actual business scenarios* discussed. I read it, all of it, and Buckler's portfolio. In fact, go to some of the websites he's listed on his portfolio and turn off Javascript. It's a fun little irony, considering how you keep pushing his article as if it were somehow scriptured truth. His whole article doesn't even consider the *cost* of development; he isn't even looking at the business side of things. He brings it up as a 'myth' point.. but just asserts it as true, without much evidence. Like a lot of the article. In fact this whole article barely even touches the concept of noscript, yet that's what you're using the article to argue on. It's vague, barely gives any clear indication of what the author thinks is a good time vs a bad time, and basically reads like an old man saying 'I remember when...', which he himself even admits proudly in the end. Damningly, he's asserting that AngularJS is inherently flawed from the ground up simply because it's a Javascript framework. That is laughable in the face of the *onslaught of Angular websites and apps today*. It's laughable in the face of the fact that it was developed by Google, arguably, the biggest 'web' company in history. You can pretend 'oh it might not be so forever' but no, statistically, it will be around forever, in some form or another. Here's a bit of discontinuity on his part: &gt; Sorry, but this is an illusion. AngularJS-like frameworks implement magical features but, dig below the surface, and you’re still using HTML, CSS, JavaScript and DOM manipulation. At best, it’s an abstraction. At worst, it’s a distraction. Note how in that quote he's admitting that JavaScript *is a part of the bare system*. He himself doesn't even believe the noscript bullshit. He readily admits that JavaScript should be expected to be 'below the surface' of every browser. JS Frameworks like Angular aren't going anywhere, and despite his best efforts to say he isn't, when he's saying they're fundamentally flawed and asserting they shouldn't be used (and he is), he *is* holding back the progression of the web - just like he says he isn't. JS Frameworks *are* the progression of the web. Even the modern browsers accept this implicitly by making it difficult or near-impossible to disable JS without a third-party application to do it. In fact, this is the biggest and most relevant point to make: Users using Noscript are using *Third-Party apps* to disable functionality of a browser. When, *ever* have you as a developer thought it was acceptable to be asked to debug a website because a third-party extension was interferring? *That's not your problem*. That's like Honda being asked to figure out how to make their cars continue to work after some users removed a wheel. Developers should not spend their time debugging third-party apps because that's a truly impossible task. I could argue point for point all day but the fact is this: **The money has spoken**. In the modern day, businesses rarely do and probably shouldn't ever support noscript globally (there are of course use-cases, like screen-readers, where noscript could be used, but this is accessibility, not progressive enhancement), because the cost is too much for the little, piddling benefit of being able to properly advertise to a bunch of paranoid hermits.
Of course a loop that does something is not the same think as the empty loops I often use in my testing. It is also true that when making changes like this in an actual application the real life performance gain is often negligible. However I still see the use of array.length in a loop poor practice unless doing so is truly needed, whenever I see it, it just bothers me. I was just throwing that out there as an example though. The use of context.rotate and context.drawImage vs just using context.drawImage on a sprite sheet was a better example that would likely result in a significant performance gain.
I'd suggest properly handling this situation so no error occurs. Does it hurt things now? Not really. Things work when they should and don't when the shouldn't. However these errors could potentially be surfaced to the user which doesn't look good, and if you ever have any legitimate errors, they could be hidden by these errors you're letting slip by.
&gt; If the business only stands to increase sales by 1% in exchange for increasing development costs by 50% If it costs you 50% more dev effort to do PE you're doing it wrong. &gt; There is a cost-benefit analysis at play. That's what the article I linked to is about. When to use PE and when not to. It does the cost benefit analysis very clearly and ironically with far fewer words and rambly tangents than you've been dumping on here. I'm not going to refute everything you said point by point. Try to stay focused and concise.
Okay.
I'm gonna guess that it takes a lot of resources to run that many for loops... It might be too much for the browser to handle. You could post again and ask...
&gt; Don't be a suckup. Buckler is not some authority figure who dictates how the web works, he's just one developer with one opinion. I think you missed the part where I said that tens of thousands of developers consider him to be credible, and that there are plenty of other people with similar followings *all saying the same thing.* &gt; I evidenced that your argument and Buckler's are different and even opposed when I showed Buckler assumes all browsers use Javascript. You never addressed this. Hard to address when 1. I have no idea what the hell you're even talking about and 2. I see no claims in the article that even remotely resemble that rather incoherent assertion. &gt; You also never addressed the issue of debugging for third-party apps. Okay. I assume you're referring to this: &gt; In fact, this is the biggest and most relevant point to make: Users using Noscript are using Third-Party apps to disable functionality of a browser. When, ever have you as a developer thought it was acceptable to be asked to debug a website because a third-party extension was interferring? JavaScript can fail or be otherwise disabled in any browser. PE is about much more than people who install noscript. In fact, it's the first myth debunked in Craig's article, along with pretty much every article explaining what PE is.
I'm at work, so I might not see it till later. Feel free to message me anything that you find out!
Alright.
They are immensely useful, but unfortunately, some devs have a hard time grasping their full power. I don't use them to directly throw errors, but rather, to consolidate error-handling code. A short example might help here... function validateUser(user) { if (!user) { modal('Please login before attempting this action.'); logError('Please login before attempting this action.'); resetData(); return false; } if (!user.id) { modal('Please save your settings before attempting this action.'); logError('Please save your settings before attempting this action.'); resetData(); return false; } if (!user.hasEditPermission()) { modal('You do not have permission to complete this action.'); logError('You do not have permission to complete this action.'); resetData(); return false; } // rest of code... } With this approach, you're repeating your error-handling code all over the place, which might be OK if this is the only place that you handle errors, but what about when you're doing lots of `user` checks (in different places)? Given enough devs and enough code, it becomes unruly very fast. Pretty soon, people are copy/pasting large swaths of error-handling code all over the place, and making a simple change -- say, changing `logError()` to `log.error()` -- requires making quite a few changes in many different areas of code. On the other hand, an exception-based approach might be setup with: // there's several ways to do this, I just chose one function UserError(message) { this.message = message; } UserError.prototype = new Error(); try { validateUser(user); } catch (error) { if (error instanceof UserError) { modal(error.message); logError(error.message); resetData(); } } And then that same `validateUser()` from earlier becomes a lot more concise, with the added benefit of DRY for the error-handling: function validateUser(user) { if (!user) { throw new UserError('Please login before attempting this action.'); } if (!user.id) { throw new UserError('Please save your settings before attempting this action.'); } if (!user.hasPermissionToEdit()) { throw new UserError('You do not have permission to complete this action.'); } // rest of code... }
How did you add it? 
There's also the new kid https://github.com/flyjs/fly
I agree with that the article is trying to say. It kind of falls into the general guidance: *Be liberal in what you say. Be conservative in how you say it.* In this case though it is about the technologies you apply.
Nothing to worry about, this is just a lame attempt at an ad by a website. Click cancel and forget it.
Thanks a lot for the quick response, I appreciate it! :)
yeah, I followed the last sample to make the fiddle ;)
Most of this is common sense to "even" the "cool" fed, and if not it should be: Yes people with disabilities will visit your website - cater for them. Yes, people with out of date browsers will visit your website - cater for them. Yes, you will be working in a team - try to not make life hard for them, you are not an arsehole and finally yes weird/mad fucking UI that no one else is using is just that. Try to remember people that UI can be beautiful, but mostly it MUST be useful and basically invisible, no one comes to a website to see the UI they come to see the product. Always think about the knife and how often you think about its design perfection as you cut into your steak.
Did someone port Node to OpenCL?
[Non-mobile version](http://v8project.blogspot.de/2015/07/digging-into-turbofan-jit.html).
Actually, this page is not using Canvas, it's using a very messy structure and code, If you want to write it using Canvas, you should first learn how to draw things [0]. Canvas has a new API called Hit Regions which should help you make your drawings interactive. [0] https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial
I throw an exception (regardless of language or platform) whenever the code cannot reasonably continue on or recover, or if a dangerous or impossible operation would execute. [Crash early](http://www.artima.com/intv/defenseP.html) &gt; **Bill Venners**: In your book you suggest we try to detect problems as early as possible, so we can make the program crash before it does damage. I have often felt the need for a ShouldNeverHappenException in Java. I'm programming along, and I get to a case that I'm confident will really never happen. But just in case it ever happens, I want to throw an exception there, but what exception? I usually end up throwing a RuntimeException and putting in a comment that "This should never happen." But it takes time to add that throw statement, as does any way of crashing early. Checking every pointer in a C program for null before it's used, for instance, would take a lot of time. Where do you draw the line? How do you decide the investment is worth it? &gt; **Dave Thomas**: That's interesting, because quite often you don't have to do anything special to crash early. For example, as long as you're sure a nullpointer is going to cause an error immediately, then I don't see much difference in throwing a random RuntimeException or throwing a NullPointerException. The bad thing is to propagate an error. &gt; &gt; The reason you crash early is to stop errors from propagating far away from the cause. Because once you have an error that's a million instructions away from the cause, finding the cause is a pain in the butt. Quite often, the check is done for you by the compiler. What we're trying to say is when the checks are not put in by the compiler, that's when you start needing to put the checks in yourself.
lols. hilarious
it's so Minimalistic!!!!!! :/
I'm personally a big fan of [gobble](https://github.com/gobblejs/gobble)
LOL
Incorrect: http://lljs.org/ /s
I don't think you understood my point. But here I go again. &gt; there's a proposal for Typed Objects, but that's all *runtime* stuff aimed at allowing the JIT to boost performance. Obviously, because compile-time stuff would practically have no meaning in JavaScript. 
I don't think you understood my point. But here I go again. &gt; there's a proposal for Typed Objects, but that's all *runtime* stuff aimed at allowing the JIT to boost performance. Obviously, because "compile-time" stuff would practically have no meaning in JavaScript, because nobody distributes their libraries and scripts as compiled bytecode, and not much tooling other than linters and style checkers are common in the JavaScript ecosystem.
Any reason you like it so much?
Simple, debuggable. Plugins auto install, and it fits my work flow nicely. And it's incredibly easy to write plugin. There wasn't a less plugin for it when I first started using it, and it took me about 5 minutes to write one.
u trippin
GitHub: making browsers crash with memes since '08 because 'what's lazy loading?'™
Actually, [it doesn't](http://begthequestion.info). Sorry for being such a pedant, but I feel like most people would benefit from knowing the true meaning of that phrase, especially when the proper meaning makes much more sense. I mostly have a background in Python. I've always used JS client side but only more recently on the server. Never used a package management system for client side JS though.
Made some simple benchmark of creating 1000 list item with styles and 3 sub-element: - Dot x 1000 = 37ms (String template) - Cito x 1000 = 62ms - Domlayer x 1000 = 84ms - Sprint x 1000 = 114ms - Sprint findCached x 1000 = 71ms - Maquette x 1000 = 156ms - jQuery x 1000 = 277ms - jQuery findCached x 1000 = 155ms - Mithril x 1000 = 387ms - Mithril MVC x 1000 = 332ms - Mithril MVC Compiled x 1000 = 235ms - Mithril MVC + doT x 1000 = 38ms Conclusion: It's the fastest vdom lib I have tested: 4x faster than Mithril compiled (I know its not a fair comparison) I was also impressed by [Sprint](https://github.com/bendc/sprint) lib 2x speed which is a drop-in replacement for jQuery in most cases. (also 17k vs 84k) Please note: This is not a real-world or fair test. Test results from latest Firefox
Based on the title I assumed this was going to be yet another component library, but it was actually a great read. 
How else do you show that you "contributed" to a library without actually writing code?!
I clicked on this thinking it was /r/programmerhumor, to be honest.
[He's fantastic. Hands down, one of my favorite blogs and he's only written three essays](http://rauchg.com/essays/) 
+1
[**@sebmck**](https://twitter.com/sebmck): &gt;[2015-07-13 23:28:41 UTC](https://twitter.com/sebmck/status/620736636830285824) &gt;Super excited to announce that I'll be starting at Facebook in a couple of weeks! 🎉 ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/3d7jli%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
And it is frustrating to no end not having it. I'm trying to optimize an image processing app written in js and I planed on using jsperf pretty significantly (as well as reading premade comparisons) With it being down it has significantly slowed my progress. If anyone knows how to throw some money their way I would love to. They have more than earned a donation from me just for time used, and I'm sad that it took it going away for me to realize it.
I am starting a Backbone-based web application for work and am wondering about how to mix React with Backbone. Seems like a good combination considering Backbone views don't really do much for you out of the box. From what I understand, React somehow sheds the two-way data-binding methodology and goes for something closer to "Functional Reactive" programming, not really sure the difference between those two, maybe this is even akin to "computed properties" in Ember, IDK. My only question at the moment - should I use React for all my child views and stick to Backbone views as all the parent views in my Backbone/React app?
Sounds like someone has trouble adapting to change.
A similar approach could be made without using error objects at all... validateUser(user, function(error) { modal(error); logError(error); resetData(); }); function validateUser(user, errorHandler) { var error = function (message) { errorHandler(message); return false; }; if (!user) { return error("Please login before attempting this action."); } if (!user.id) { return error("Please save your settings before attempting this action."); } if (!user.hasPermissionToEdit()) { return error("You do not have permission to complete this action."); } // rest of code.. return true; } To me, exceptions should be for "exceptional" cases in your program when things go wrong. Throwing exceptions just to catch them later *is* using exceptions for control flow, which is usually a sledgehammer approach to resolving errors. JavaScript allows you to provide callback functions. As you can see, unless one of the invalidation conditions are met, the callback never runs and none of that code is executed. This is effectively the same thing as surrounding something in a try/catch, except the added benefit here is that you aren't risking a bad programmer misusing the code by failing to catch UserError when attempting to run validateUser().
thanks for the suggestion - will definitely keep that in mind!
An expression like `1 &lt;object &lt;= 3` is syntactically valid but it doesn't do what you think it does. It's interpreted as `(1 &lt;object) &lt;= 3`. `1 &lt;object` evaluates to either `true` or `false`, which is then compared against 3. So for example if `object` was 10, then `1 &lt;object` is `true`, and `true &lt;= 3` is also `true` since `true` acts like the integer 1 for the sake of comparisons. In other words, this is complete nonsense, it's not testing if object is between 1 and 3. In fact it's always `true`, because no matter what `1 &lt;object` evaluates to, both `true` and `false` are less than 3. 
Best Geocities plugin ever.
Who wouldn't want to be friends with /u/_HlTLER_?
Be careful of scrolling when using an interactive map like that, I see that it's very fiddly to scroll to the bottom of the page because as soon as your cursor is over the map you start zooming in/out of the map. You could enable the zoom level controls but remove scroll to zoom?
just another way of doing it: *shrug* var object = Math.random()*10 var borders = [30,0,120,0] var colors = ['gold','blue','green','red'] var sizes = [30,80,120,150] var idx = 3; if ( object &lt; 2 ) idx = 0; else if ( object &lt; 4 ) idx = 1; else if ( object &lt; 7 ) idx = 2; document.getElementById("shape").style.background = colors[idx]; document.getElementById("shape").style.width = sizes[idx] +"px"; document.getElementById("shape").style.height = sizes[idx] +"px"; document.getElementById("shape").style.borderRadius = borders[idx] +"px"; 
I guess he could invert a binary tree on a whiteboard.
There is a donate link in the site footer: goes to https://jsperf.com/faq#donate. It says you can donate via [Pledgie](https://pledgie.com/campaigns/14709) or via [PayPal](https://mobile.paypal.com/be/cgi-bin/webscr?cmd=_express-checkout-mobile&amp;useraction=commit&amp;token=EC-11G54510VS4707010#m)
Ugh, the change to show/hide is going to be painful.
`npm install jquery@3.0.0-alpha1` realemail&amp;#64;gmail.com reddit is just so bad at algorithms... edit: wasn't criticizing you, but reddit's email detection algorithm, for blocking "jquery&amp;#64;3.0.0-alpha1" in your comment while also being so easy to bypass.
I don't like the way they are intending to do it with 3.0. I mean if I wanted to show a popup after someone inputs something I would usually style the popup as display: none; then .show() it when I need to. With 3.0 I now need to let the popup load into the DOM, then .hide() it, then .show() it when I need to. This seems really backwards to me. I guess I'll just be doing all my hiding and showing by .addClass(); from now on.
Ah, do you mean having a default path for the view of a component? Well in that case, I guess the reason is there are important differences between a backend framework (like Ruby on Rails) and a client-side framework (like Angular); a client-side framework can't access the file-system (at least not without a lot of limitations) and it needs to be agnostic from the backend-side. AFAIK that is an "issue" of all the client-side frameworks... 
maybe facebook will help it be more stable and not crash all the time. oh wait its facebook.
sigh, thinking same thing. this basically forces us to not use jq3 for a very long time. people just dont prioritize frontend refactorings like that.
It's good in the long term though, it's pretty bad code the old way as they pointed out. We've known for a long time not to style with JS unless absolutely necessary.
Well, regular frameworks do not access file system directly too. I don't see any problems here.
Thank you! I'm pretty overwhelmed at the response, especially seeing it on r/javascript...
Yea, `apply` exists and `push` accepts multiple arguments. Somewhat more interesting: &gt; let a = [...'abc'] undefined &gt; let b = [...'def'] undefined &gt; a.push(...b) 6 &gt; a ["a", "b", "c", "d", "e", "f"]
Just wait until "tutorial" sites start telling everyone to wrap their entire code with try/catch to stop those pesky errors from printing to the console!
Oh god, I can see it now. And then we'll have 60,000 essay-length blog posts about "why try/catch is an antipattern".
I think it's only google that asks academic questions like that. 
Awesome! Thanks!!
Trying to bruteforce until it founds the password ? Well, it will take a lot of resources to loop over this...
So does this work with jQuery UI?
Got to meet Seb at Edge Conf in London a few weeks ago. Such a humble guy. And only 18! He's got a bright career ahead of him. Though, Cloudflare is going to be pretty upset. They were pretty happy to have the creator of Babel working for them. Can't blame him, though. I wanna work among those talented engineers too... :(
Two things fail JSLint the the above example, the minor one is spacing. var hi = function(name){ Should be var hi = function (name) { If you understand function declarations, not using a space for anonymous functions makes no sense. The space before the opening bracket is style only, but the author is inconsistent (sometimes he puts and space there and sometimes he doesn't.) The major one you won't see when you lint this function by itself. Since you should declare all variables at the top of the parent function, you will either end up with a bunch of var statements (and fail JSLint) or one huge, hard-to-manage var statement at the top of your module. Both options are bad.
Thank you! that logo hurted my head
thanks for sharing
I didn't mean to imply that declaring functions in that manner was always the wrong choice, only that it should not be the only choice. It is more verbose and the hoisted declarations can make a huge mess of your code.
Were still at 0.13, so not much has changed. 0.14 is coming out soon, it is expected to have pure render functions, and probably some changes around context switching from being owner based to parent based. The guy who made babel/6to5 is now on the facebook team. Checkout the react europe videos on youtube, that conference was a week or two ago so its pretty relevant.
Never realized you were the author, I've seen your comments around here a bit, and they've always been helpful (at least to me). Love Babel. It's definitely a must-have in my toolkit now. Thanks for keeping it independent. Lastly, congrats on the job! Now go kill it!
Make deep copies of them if you need to manipulate them to calculate the result. Unless the function's stated purpose is to mutate the parameter (which is rare and almost always a bad idea), then mutating the parameter is unexpected behavior. Imagine calling a function to get the maximum of an array and getting back the maximum as a return value--but the function also emptied the array. Also, are you from Miami? I went to high school with a girl named Gigi Paris. 
Extending natives is bad, just never do it. Given a decent modern environment there is _zero_ advantage over: function mergeArrays(ary1, ary2){ ... } And potential downsides that can be quite the headache.
&gt; 0.14 is coming out soon The beta is out now if you're comfortable using pre-release software (API should be stable)
[This is theoretically possible.](https://github.com/CollectionFS/Meteor-CollectionFS/wiki/How-to:-Convert-a-file-already-stored) But... how?
I use: combinedArray = firstArray.concat(secondArray)
Just read through all but the last two. I have some experience with the stack but the articles were still very interesting and a good refresher. Thanks for The link!
Of course after hours of frustration and finally caving to ask for help I've worked out the solution myself. Thanks for anyone who might have taken a look for me. Images.find({"copies.Thumbs.size": {$lte: 1}}).forEach(function (fileObj) { var readStream = fileObj.createReadStream('Images'); var writeStream = fileObj.createWriteStream('Thumbs'); gm(readStream, fileObj.name()).resize(150).stream().pipe(writeStream); });
Good stuff! I gave a presentation on FP in javascript a while ago that might also be of interest to some people - https://github.com/ajnsit/functional-js/raw/master/functional-js.pdf 
Here's the long and short of it, guys. TEST FUCKING TESSTTTT JUST DO IT All us newbies forget how important this is.
&gt; I feel like every tutorial I read, I have to spend the same amount of time seeing what is updated from the version the tutorial was on That's your problem. Stick to the official docs and asking questions here or in their IRC. React is definitely worth learning but until 1.0 comes out, third-party sources aren't good enough to invest much time on.
Thank you! I run into this attitude so often.
Glad to see the compatibility with Promises/A+ and ES2015 Promises! Now, we just need to swap in velocity.js as the official animation library for jQuery!! :P
Yeah I ended up using canvas. I found a really helpful library called [oCanvas](http://ocanvas.org/), sped up the process. It's still a work-in-progress I guess.
He made the right choice supporting React's JSX right in Babel. React deprecated their own JSX tooling and are moving everyone to Babel. This is a good move for Facebook to keep the projects close.
Like rickyvetter mentioned it's not a task runner but more of a bundler. The distinction to make is that a lot of tasks that you use task runners to run are actually just bundling/transforming files. Which webpack is suited for. Also interesting to note is that webpacks competitor browserify can do almost all of the same things. These tools can be used along with npm scripts for a very lightweight build system.
*sigh* read what I wrote
Talk about coming in on the tail end of an issue. It seems to have been resolved - ish.
I was just looking for something like this. Amazing timing! Thanks
In my code I always use function expressions instead of function declarations. The only exception is for immediately invoked functions. var mathOp = function myApplication__majorSection__mathOp() { Writing functions like this allows me to bind the function to a `var` declared reference and still have an actual function name. Bind the function to a `var` reference prevents hoisting if the var declaration is at the top of its function or if the function is declared to a list of vars at the top of its function. The actual function name allows the function to show up in stack traces and profiler tools.
Personally, I'd rather these methods (and toggle) get deprecated. You should be using addClass/removeClass with your own .hidden css class. Then if you want them, write your own extension. (or, include a "deprecated extensions" library.
 Array.prototype.extMerge = function(array) { return this.push.apply(this, array); }; for(var i in [1, 2]) { console.log(i); } Output: 0 1 extMerge Yes, using for-in with arrays is wrong, but the point is that there is now one additional enumerable property on every array. This will probably break *someone*'s code. My perfectly cromulent code has been broken multiple times by 3rd party code which modified built-ins. Just don't do it. http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/
You might like virtual methods (a proposed ES7+ feature): http://babeljs.io/blog/2015/05/14/function-bind/ function randomItem() { return this[this.length * Math.random() | 0]; } function last() { return this[this.length - 1]; } let someArray = [...'abc']; console.log(someArray::randomItem()); // a, b, or c console.log(someArray::last()); // c It's like extending built-ins without the mess. Well, in this case, a virtual method wouldn't make any sense since ES6 got the spread operator. You can just write `a.push(...b)`.
I would think the JQuery source might be a good starting point. The challenge in direct DOM manipulation are weird edge cases in individual browsers.
Tomorrow is a follow up post where the Edge team will detail their plans for implementing the web component specs in the Edge browser. 
Having seen his code, I'm pretty sure he can.
That looks neat.
just grepped, over 1500 looks like (fuzzing under true number just to keep confidentiality).
It's the blog of Guillermo Rauch, author of Socket.io and other stuff. Not sure where we'd be without him.
Totally worth it. The core API hasn't had too many completely breaking changes for a while. For all the supporting cast you just have to pick stuff and stick to it. Yea, if you try out all 20 versions of Flux, you will probably go insane, so just pick one that seems reasonably good and focus on actually building things with it. 
Then you've misunderstood the approach. It isn't about breaking everything down into one-line functions, it's about (primarily) making code more maintainable by logically inserting a what-layer above the how-layer. Most code written by others that I see is a maintenance nightmare because it's only how-layer stuff: line after line of low-level statement which give no understanding of what is trying to be achieved. Bundling these lines into single-purpose, descriptively-named functions leads the coder along wonderfully. I've adopted this approach and my code has improved by orders of magnitude.
I don't know if I would call it a *problem*. These popular linters usually don't care if you use function expressions or declarations; both are valid uses of the language, the only difference being when they are loaded and the scope of access. I was simply pointing out that, even if he takes exception with the style of code, not **every** author conforms to JSLint rules, which IMO are extremely strict and it's not very popular... Name | Downloads Last Month ----|--------- JSHint | 1,665,082 JSCS | 394,085 JSLint | 41,352 Sorry Crockford, can't win them all.
Yikes
Oh, awesome. I'll check it out. 
True. Didn't think about jumping into the jquery source.
https://github.com/reactjs/react-future/blob/master/01%20-%20Core/03%20-%20Stateless%20Functions.js
&gt; it's not very popular... I understand what you are trying to point out. All I am saying is that it is either a strawman or irrelevant to the person's point.
Thank goodness. I love Babel, and I'm really glad to hear it will stay independent, and I hope it truly does. 
&gt; The only tricky part about autotesting your web browser is deciding what to use. I don't think you have actually tried autotesting a web browser.
This creates a new array though. The original is unaffected. let a = [1, 2]; let b = [3, 4]; let c = a; a = a.concat(b); console.log(a, b, c); Output: [1, 2, 3, 4] [3, 4] [1, 2]
What's with the Yandex thing?
Even if you don't use React on a production release, its worth experimenting with. I've gained a lot of new perspectives on application design from working on just pet projects with it. 
The spaces should be fine: "https://www.google.com/maps/search/22-40 W 77th St, New York, NY 10024" You could always use encodeURIComponent() to encode the URL.
I used similar things (Node + WebFlight) to interface my AR-Drone with my pc. The catch: I streamed it and chat could control the drone. Here's a VOD of the stream: [https://www.youtube.com/watch?v=gQ3dQk52SBo](https://www.youtube.com/watch?v=gQ3dQk52SBo)
And code like this annoys me and probably everyone else. var myFuncSUPERAwesSOME =function ( ) { } Opinions are opinions. That doesn't mean there's anything to "work on."
That's an HTML 5 property, which means abysmal IE support. IE11, according to your link.
That'd be nice.
That's nice.
Sorry, it's not clear what isn't working. Is it the second example?
Correct! Good catch. Wrapping the object in parens works: arrayOfObjs.map(o =&gt; ({[o.a]: o.b})); --- http://babeljs.io/repl/#?experimental=true&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=let%20arrayOfObjs%20%3D%20%5B%7B%22a%22%3A%201%2C%22b%22%3A%202%7D%2C%20%7B%22a%22%3A%203%2C%22b%22%3A%204%7D%5D%3B%0D%0A%0D%0AarrayOfObjs.map(o%20%3D%3E%20(%7B%5Bo.a%5D%3A%20o.b%7D))%3B
Sorry about that. This is the line that doesn't work: arrayOfObjs.map(o =&gt; {[o.a]: o.b});
I use these for reference [youmightnotneedjquery.com/](http://youmightnotneedjquery.com/) or [plainjs.com](https://plainjs.com/javascript/)
That is indeed the fix for this. Thanks
Since they are supporting Babel so emphatically I would argue the opposite: Just use Babel + ES6 + Decorators/[Composition](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750) 
&gt; It's also to have a fat chapter called *How to Stop Worrying, and Start Producing* in which I will shove down everyone's throats the idea that *sometimes* a for loop is just fucking fine. Considering that a well written `for` loop out-performs optimised V8 `forEach` by about a factor of ten it's more than just fucking fine...
maybe checkout http://ponyfoo.com/articles/testing-javascript-modules-with-tape
+1 for MDN
&gt; vars are hoisted, just like function declarations. Before ES6 the easiest way to defeat hoisting was to use no more than a single `var` keyword per function and place it at the top of the function. Therefore anything declared by that `var` keyword is not hoisted. More than one thing can be declared by a single `var` keyword if strung together in a comma separated list, to which all have defeated hoisting. Therefore you can determine exactly the order in which functions are declared amongst all the other references if they are assigned to a reference included in that single `var` list. Function declarations do get hoisted just like variable declarations. While hoisting can be tamed against references declared with `var` it is far more challenge to do with function declarations. Function declarations are hoisted in the order in which they occur during initial interpretation and they are hoisted above variables declared with `var`. This is problematic if a reference in a function requires access to a closure that is not declared declared or assigned a value yet. &gt; The difference with function expressions is that the function isn't declared until it is used This is a grave inaccuracy. A function is declared the moment it is interpreted whether or not it is ever executed. This is because a function is either anonymous or known by a reference and references must be declared to be available. This is why broken syntax in a function will throw an error and halt the application even before that function ever runs.
You missed out Webdriver.io when talking about controlling browser actions in selenium. Its similar to nightwatch, I've been using it in work and found it pretty good! 
Isn't that basically "clean code"?
&gt; when the animations are running I see a noticeable performance difference in the animations. &gt; [...] &gt; my question is can logging effect performance? Haven't you already answered your own question? Of course it can. Drawing text on the screen (and having to scroll the window when it overflows) is not free.
The title's pretty misleading - came here expecting to be convinced of Tape's relative worth over Mocha...are you telling or asking? EDIT: or did you mean to link to [this](https://gist.github.com/ericelliott/d576f72441fc1b27dace#comment-1391854)? ANOTHER EDIT: ah you probably meant to link to [this](https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4) (cleaned-up blog-formatted version of the above gist comment)
&gt; He doesn't explicitly say that SPAs are bad Well, he does that that: &gt; the BFED realises that Single Page Applications cause severe problems and that by avoiding them and leaning on the server appropriately provides a better experience and reach. So they cause problems and avoiding them provides a better experience. I'm not seeing a lot of nuanced "use them when appropriate" here. Further, that section links to an article by the same author which concludes with: &gt; ...SPAs require significantly more development effort, with a result that is detrimental to the user. Javascript is never going to do it better than the browser! He is, in fact, *explicitly* saying that SPAs are bad. (And also making sweeping yet trivially falsified claims about JS versus browser performance, but that's a separate quibble.) &gt; The point is that many front-end developers treat SPAs as a kind of panacea, which they aren't. That would be an excellent point for someone to make. The author did not.
http://goatse.cx
Hear hear! Functional programming "purists" would also avoid `forEach` as it exists purely to cause side effects and/or mutate state.
That title is way too clean for the expletives I'm planning.
Hey, thanks for the suggestion. I went ahead and added that on to the app, as well as added a Button for getting a link for that specific configuration.
It's usable in IE 7+, just add this to your stylesheet to polyfill it: *[hidden] { display: none; } And the idea of jQuery is actually "Write less, do more." If we follow your suggestion of removing `show()` and `hide()`, people will be writing more and doing less ;)
Some frameworks such as Angular recommend against using jQuery for DOM manipulation.
Ah. Why?
Maybe I should re-title it *Snaps in C-formation*.
I'd read such a book, damn it, but only if you had a chapter about immutable-vs-mutable-fucking-data. **Edit** I may even be interested in co-authoring such a book ;)
This is great news!
There is usually an Angular way of what you are trying to do. Most likely you want to update the model and let angular deal with the DOM. 
The only push-back I would give you, is don't modify the `Array.prototype`. &gt;"Don't modify objects you don't own." - someone like 10 years ago It may not be a problem for you on your own website, but as an example, [Date.js](https://github.com/datejs/Datejs) modifies the `Number.prototype` [which causes issues for d3.js](https://github.com/datejs/Datejs/issues/12). It's little shenanigans like this that make Javascript developers pissed off. Feel free to do it, if you understand the ramifications. That being said, cool script. I'd hire you.
Lol especially when they're 3 years behind on subject material, username is relevant only because they shitpost
After you learn the native DOM APIs, I'd check out my small [lib](https://github.com/eorroe/NodeList.js) which will allow you to use those same APIs. Check it out. Only thing is its written in ES6 (which you can transpile with [babel](http://babeljs.io/repl/)) but then again it's still using ES6 methods. TBH I don't think I'm going to rewrite it into ES5
I'm saying that avoiding JQuery seems impractical. I'm curious why you would want to do so, to better understand times where I should consider it. But as /r/dhdfdh said, apparently there's things that are significantly slower in JQuery, so that's one pretty evident reason.
In React, mixins are mostly used to make common behaviors. Sure I could write a shouldComponentUpdate function every time I make a stateless component, but adding the mixin is much easier and less error prone. Another great example is the Reflux mixin. It adds several reflux functions to the component and typing out them would be ridiculous (it's a couple hundred lines of code). Some people don't like mixins because they are multiple inheritance. If you aren't careful, mixins can get out of control (especially if your mixins have mixins). This simply isn't a significant issue when you use them the way React encourages. I would argue that composition is a better solution, but React uses constructors, so mixins are necessary.
I recently did this exact thing. My approach was to basically build everything in vanilla and spent lots of time in mdn looking things up. You would be surprised how much you can learn when you force yourself to build everything from scratch and not just plug and play with jQuery.
Fuck IE. bastardos
Why not?
This is cool. Does anyone know of a javascript sorting library that implements the various sorting algorithms?
Look at some of the MV* frameworks that are available now.
&gt; I believe DOM manipulation, especially without the help of a framework like Angular or jQuery, can be a good way to inadvertently introduce cross-browser issues Like what?
That is a pretty cryptic answer for asking somebody to ignore a foundational skill. I recently got second place at a work hack day because I was able to throw together an [additional tool](https://github.com/prettydiff/semanticText) in roughly 90 minutes. I couldn't have done this if I were shackled to some bloated MVC insanity.
The goal isn't to ignore jquery nor is it to imagine myself building something better. The goal is to understand the interaction between javascript and the DOM better than I already do. I'm a fundamentals person. I need to know how things work. It's how I'm wired. Some people are content to just use a framework. That's fine. I need a deeper understanding than that. 
This is a bad example, but let's say you change the DOM to set a particular element to invisible using DOM manipulation. Maybe the code hides the element in IE but it doesn't in Firefox because instead of setting it to invisible you need to actually set the width and height to zero. I totally made this example up, but that's the basic idea. One would hope that using a framework gives you the ability to just say element.hideyourself() and it works on both IE and Firefox with no special conditions. I know this isn't always the case, but it's intended.
Did you white board this in the interview then added it to codepen to show us or did they ask you to do it and send them your solution?
But that's like saying developers shouldn't understand assembly language. Of course they should. Nearly all just shouldn't use it. Knowing fundamentals like how plain javascript interacts with the DOM is a good thing to know. It doesn't mean you have to ignore all the frameworks. 
For sure. I was just trying to heed warning that JavaScript DOM manipulation can get you into trouble when you're on your own. I'm sure it's a great thing to understand but it has the potential to make life hell without the safety net of some proven technology.
Really, MDN + caniuse.com pretty much covers everything. As someone who learned web development pre-MDN, I can't emphasize enough how absofuckinglutely amazing it is to have it around.
TIL OP doesn't understand sarcasm OR straight humor
This is what I subscribe to. Yeah, they might have their share of issues but if you intend to get up and running quickly without much bs, why not take advantage of something that is proven to do what you want? You might not win a contest for performance or whatever but at least you're not putting yourself out by having to learn the basics. Everyone has their own opinions and end goals...having to write my own DOM manipulation code isn't one of mine.
Yep. If you think this isn't true, try a parallel example using both methods and see which one comes out cleaner and easier for the rest of the team to refactor.
I laughed, upvoted =] Its not so bad, knockback is the worst of it though..
They gave me couple of hours to do it at home
You could answer this yourself by visiting the github account.
You mean the one with all the spaghetti shit everywhere? You must work alone.
&gt;&gt;We say slice is pure because it returns the same output per input every time. &gt;We say it's pure because it doesn't have side effects and because it's idempotent. &gt;We say it's idempotent when we get the same output for a given input. That's not what idempotent means. In an imperative sense, it usually means that executing an action more than one time has the same effect as doing it once, as in HTTP PUTs. In a functional sense and in math, it means a function such that f(f(x)) = f(x). For example, the 'increment' function `f: x ↦ x + 1` is pure, since it has no side effects and it always has the same value for the same argument, but it is not idempotent, since f(f(x)) ≠ f(x). Instead of idempotence, you'll often see pure functions described in terms of referential transparency, which means that a function call can always be replaced by its value without changing behaviour, implying that the function doesn't have side effects and has a value solely determined by its arguments. This is one example of the difficulty of applying non-functional and functional programming concepts to each other. You're dealing with fundamentally different building blocks and concepts. You can make `for`-like constructs (see Clojure's `for`, for example), but they're generally seen as convenience wrappers over more fundamental approaches like recursion and folds. They also usually still have properties like referential transparency that for loops in non-functional languages generally lack. The 'hybrid' approach taken in languages like JavaScript, C#, and, more recently, Java and C++, is nice to have, but leads to misconceptions that functional programming is about replacing constructs like for loops with cute little shortcuts. These languages are almost always used for fundamentally non-functional approaches, not any kind of balanced compromise.
"Every JavaScript framework, library, and abstraction that accesses the DOM ultimately does so through the standard DOM methods." More people should be aware of this :)
which is why jqLite is bundled with Angular, and directives provide a jqLite wrapped `element` in link functions, I presume? /sarcasm
1) I'm not ignorant. 2) You're not more bad ass for doing shit no one else can read. 3) I didn't tell the guy to not learn the skill.
Seems like quite a bit of overhead - it reads like an attempt to bring Rails + Heroku to Node. No personal experience with it, but it does seem worrisome that their [list of users](http://loopback.io/users/) contains only one recognizable name from the web tech world - and that's GoDaddy :/ Nice to have plug-and-playable integrations though. Would love to hear a good counterpoint on this.
I'm so sorry! I forgot about the fact that bulk-require doesn't work with Web pack. Give me 24 hours and I'll submit a bug fix. In fact, it may be best to use the standalone build at require('e2d/dist/e2d') as a workaround for now. 
Hah, I almost felt bad for watching the demo, seeing something clearly well thought through, but putting that niggling discomfort in my head to see someone modifying the prototype of Array. imho there's only one acceptable time to modify a builtin global object: when you're shimming it. e.g. it's perfectly acceptable to set `Object.assign` to a function that implements what it would do, were the code running in es6. This is 100% acceptable if the proposal has been finalized, and okay too if it's not, but you're able to go back and update your shim and its callers in the event it does change.
Thank you very much, good sir! :)
That is wrong, though. Function calls give a **huge** performance penalty if you use it inside a inner loop. Try it yourself, replace "+" by `function add(a,b){return a+b}` in an inner loop and measure what happens.
Cycle.js only really clicked for me after I typed out all of the examples and then made a small example of my own. If you're interested in coming to grips with this style of coding, that's definitely what I would suggest as a starting point. It might also be worth checking out the framework author's (Andre Staltz) [introduction to reactive programming](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) with observables. 
&gt; so have a better look on what he actually writes: "Problematic", "causing more development effort", Those words and phrases do not appear in his writing any more than the word "bad" does, so I'm unsure where you're going with this; at least I was only paraphrasing rather that using quotes around phrases that were never written. In any case, this is someone who says SPAs always cause "severe" problems, that avoiding them always provides a better experience, that they always require "significantly" more development effort, and that they are always detrimental to the user. I would put it to you that this is: 1. Absolutely equivalent to saying they are bad; nobody says "this is bad for users, developers, takes longer, and works worse", and then follows up with "...and is totally awesome!". This is an article written by someone who thinks SPAs are bad, full stop. 2. Objectively false when stated as sweeping conclusions. It's simply false that a SPA is *always* slower to develop, or that a SPA *always* provides a worse user experience. I feel like you are defending what you wish the article said, and not what the author actually wrote.
So, the solution to hoisting is to place the code that would get hoisted where it would get hoisted to. Duh springs to mind. Broken syntax in a function throws an error because the parser found it and has little to do with execution. If you var a function at the end of a code block the variable reference is available from the top of the code block because of hoisting. The function definition isn't, but you can call it before you define it due to the variable hoisting.
I realize you could be partially correct. Maybe we're both pushing the meaning of what he actually wrote to its opposite boundaries. Still, there's a lot of middle ground to be covered.
Excuse my ignorance with the command line, but what on earth is using as his text editor? I want it! 
why use `let` to declare functions? declare them directly let myFunc = function (...) { ... }; is better written as function myFunc(...) { ... } You get named functions instead of anonymous ones, to boot.
A perfect mid point between troll and informative... Yes, you can use destructuring to achieve element swapping without creating a temporary variable.
Microsoft has changed. I think they are now doing more good for the open web than Apple.
It has more to do with pure functional programming which is is rarely if ever used in the back-end. Other FRP libraries include [Bacon.js](https://baconjs.github.io/) and [rx.js](https://github.com/Reactive-Extensions/RxJS).
With regards to this, we have an alternate solution that is Google SEO friendly (curl tested) - http://tinybutton.com Let me know if I can help answer any questions regarding this.
If you specify the `debug` option, then yes, the file is huge. I'm building a fairly sizable project with React + Babelify: in development, the file is pushing 4MB, but the production build is down around 650KB (170KB with gzip)
In that case, this page might be of some help: [How to forget about jQuery and start using native JavaScript APIs](http://blog.romanliutikov.com/post/63383858003/how-to-forget-about-jquery-and-start-using-native) ([reddit thread](https://www.reddit.com/r/javascript/comments/3agkg7/how_to_start_to_forget_about_jquery_and_start/))
Yeah, that sounds awesome! I tried the Leap Motion and the Xbox Kinect to do the same: https://www.youtube.com/watch?v=0uUrL3wHoAo
I've got 12MB in development, 2.3M in production. More than I'd iike, but then all those npm modules are soooo tasty.
Yep, that's just fairly stock standard vim.
great talk. observables are really interesting, and its really true that when you start thinking about everything as a stream everything gets really simple to reason about. remember: [everything is a stream](https://camo.githubusercontent.com/e581baffb3db3e4f749350326af32de8d5ba4363/687474703a2f2f692e696d6775722e636f6d2f4149696d5138432e6a7067)
What about: Object.defineProperty(Array.prototype, "newMethod", {enumerable: false, value: function(){...} }) 
I completely agree. Did just that yesterday - rewrote basic examples wo/ ES6, took some notes too: [My Cycle.js GIST](https://gist.github.com/JosePedroDias/fefd737aeefd54f492d0)
Because ES6
&gt; without creating a temporary variable ...yourself. It's important to remember that it's not actually free. Swapping two variables like this looks pretty nice: let a = 1, b = 2; [a, b] = [b, a]; console.log(a, b); // 2 1 But, for items inside some array, it's just too messy. It's not an improvement. With a virtual methods (ES7 maybe), you could write it like this: import {swap} from 'my-funky-array-extensions'; ... array::swap(j, j+1);
O____o time to investigate webpack chunking to load on demand?
(Note: `{b}` is a ES6 shorthand for `{b: b}`.) A: let a = (b) =&gt; {b}; console.log(a(3)); // undefined B: let a = (b) =&gt; ({b}); console.log(a(3)); // Object {b: 3} C: let a = (b) =&gt; { return {b}; }; console.log(a(3)); // Object {b: 3} Version A doesn't work, because the body only contains the statement "b;" which doesn't really do anything. B works fine because it's now just a single expression. C shows how an arrow function with a body looks like. If you want to return something, you need a `return`.
I wasn't aware that people still messed about with sorting algorithms. I remember it being a 'thing' back in the 80s/90s because most languages and libraries didn't handle sorting for you and you pretty much had to roll your own. Today though it feels more like it's just a way to flex the brain?
seems to do nothing
How is this better or different to alternatives? What would those alternatives be to compare and contrast to? It's unclear whether UIZE is competing with underscore, backbone, jquery, or requirejs. Who is actually using this?
It's worth learning them all. But also keeping in mind that they're generally terrible, and there's not much impetus to improve them atm. That's part of the reason frameworks came to exist in the first place, and continue to be popular.
Looks pretty good! I think the best thing to improve the code would be to break it down a bit. Right now everything is in this one object, which makes it a little confusing. For example, a filterNode could be it's own component. There's a lot of code for setting up the DOM object and events for each item - if you split it off you'd have a ~70 line component that's easier to take in in one piece. Also consider using JS prototypal inheritance to create your FilterObject methods. Right now you do `this.getSelectedItemObj = function () {}` for each function inside your FilterObject constructor. Instead you could assign the functions to the prototype object like this: `FilterObject.prototype.getSelectedItemObj = function () {}`.
Not ELI5 but close enough, I hope: Synchronous functions have two types of return values: they can return successfully (with an explicit return value or `undefined`) or they can throw an exception. Promises represent the return values of asynchronous functions: they can either be resolved (equivalent to returning normally) or rejected (equivalent to throwing an exception). In Python, try/catch structures can also have an "else" block, which is only executed if the try block completes without throwing an exception. JavaScript promises can be explained by comparison: the code that resolves or rejects the promise (i.e. the function that returned the promise) is the "try" block; the two callback arguments of the promise's "then" method represent the "else" and "catch" blocks respectively. Every "then" method *also* returns a promise. The promise represents the return value of whichever of the two callbacks gets executed. This means chaining "then" calls is a lot like nesting try/catch structures. In a pseudo-JavaScript with Python's try/catch/else, the following synchronous code: var v1, v2, v3; try { try { v1 = func1(); } catch (e1) { // func1 raised exception e1 v2 = func2(e1); } else { // func1 returned value v1 v2 = func3(v1); } } catch (e2) { // func3 raised exception e2 v3 = func4(e2); } else { // func3 returned value v2 v3 = func5(v2); } ... is equivalent to this async code using promises: func1() // -&gt; v1 or e1 .then(func3, func2) // -&gt; v2 or e2 .then(func5, func4); // -&gt; v3 or another exception It's easy to see how promises make the control flow less verbose (but also a lot more dense). Also note that the order of the functions in the "then" calls is inverted (catch/else vs onResolve/onReject). Each consecutive "then" is equivalent to wrapping the existing structure in the try block of another try/catch/else structure. Compared to regular callbacks promises also have the advantage that their behaviour is rigidly defined and thus makes a few guarantees: * a promise will only be resolved OR rejected exactly once (it can't be resolved and then rejected or resolved and rejected multiple times) * each callback passed to a "then" method will only be invoked exactly once * each callback will be invoked asynchronously, even if the promise has already been resolved or rejected at the time It's also possible to call "then" multiple times on the same promise (remember: chaining always results in a new promise, so you need to keep a reference to the original promise) and you can omit either of the callbacks, which is the logical equivalent of omitting either of the catch/else blocks -- this should make it obvious why an error "falls through" if a then call does not provide a callback in the second argument (onReject), e.g. `func1().then(func3).then(func5, func4)` means `func4` will receive both the errors caused by `func1` as well as those caused by `func3` (but `func3` will not be invoked if `func1` already failed). Or, if you want the spectral opposite of an ELI5 answer: promises are a bit like asynchronous Maybe monads.
Chaining means calling methods on the return value of other methods. For example, `String#split` returns an array, `Array#map` returns another array, `Array#join` returns a string. So `str.split(..).map(..).join(..)` first invokes the `split` method of the string, then invokes the `map` method of the array returned by `split` and then invokes the `join` method of the array returned by `map`. You could assign variables to each partial result, but chaining makes it a lot less verbose.
How will those decorators add functionality to a constructor? Creating a closure that completely wraps the constructor seems to have performance implications (and be hard to get completely right). If the decorator adds properties to the function, then it is literally performing a mixin on the instance.
Op what kind of a job is this? I will be searching for an entry level junior developer position in the next few months and would like to get some perspective on what you are applying to. 
and that says a lot!
How did this get so many upvotes and no answers? Anyway, personal opinion, jsFiddle sucks! Use CodePen instead. Here: http://codepen.io/anon/pen/rVKQwW
I'm excited to hear that MS will be support web components. My work is focused on the evergreen desktop browsers mostly and this will mean that we'll be able to use web components as our base level of "componentisation" in the UI in the not too distant future. I strongly suspect that the Edge team have just been very busy this year getting Edge into shape especially with the Windows 10 deadline. That hasn't left them with much time to do announcements or future planning. We might see more blogs from them as I think the deadline for "release to manufacturing" for Windows 10 has arrived and some of the pressure may be gone now leaving room to catch up on other things. :-) Also, don't forget that the Web Components specs are still being worked on and are not final quite yet. 
Pretty new at this. Made some edits, hopefully its more readable now.
That is cool that they allowed you to do that, makes way more sense then trying to whiteboard a solution like this.
So your server is sending back a JSON parse error, since this is the response from your sever. Chances are you're not sending correctly-formatted JSON data. Take a look at that.
I can't read anything in your screenshot. Use pngs for text, not jpg. Maybe my eyes are just bad, but I feel like you didn't even need to blur the rest of the text because the compression artifacts are so intense. I could not reproduce the message, but... edit: The messages comes from this script: https://www.redditstatic.com/reddit.en.bub3H_Pd-kk.js Still trying to figure out what it's supposed to do... it's kinda hard since it is minified, and this code, as far as I can tell is not on their GitHub. Maybe /u/largenocream would be interested/have an answer. edit 2: are you using any plugins/malware that would mess with your request headers and could be tripping their mechanism for detecting that? 
This also not happening to me. Try to debug the javascript file on Source tab, maybe you find something usefull.
Was there any advantage (other than the "cleverness" of the code) to use generators? For example, does it make the code easier to write/read/maintain?
/u/GlowInTheDarkDonkey is right (why was he downvoted?). Here is a version of the script with the things he commented on: http://pastebin.com/vn20UQYq **edit** fixed a typo
This isn't really a JavaScript question. I don't want to click any of the (various, sketchy) download links on the link you posted, so I can't see the script itself. One way or another, though, your computer certainly has malware installed, so you need to take the appropriate steps for that. If you're able to post the actual source code you ran, I can take a look at it, but what would any answer change for you? 
&gt; 2) You're not more bad ass for doing shit no one else can read. This is a common newb complaint. The readability of code is less important that the problem the code solves. Bad code can always be refactored later, but clean code that doesn't direct address the problem is absolutely worthless. Furthermore, code readability is completely subjective (particularly from someone who cannot understand the DOM).
&gt; So, the solution to hoisting is to place the code that would get hoisted where it would get hoisted to. Duh springs to mind. No, that is not what I said. Function declarations get hoisted above the `var` keyword. Its about getting ahead of that setting a clearly understood declaration order.
Appgyver is horrible, stay away from it. 
Makes sense, what a bummer. We're only using custom elements, and it's a very simply polyfill that employs mutation observers to check for elements to upgrade. It's working great for us, even in old browsers.
The script contains binary data that it writes to an exe and executes it - then deletes it. I modified the script to create the file for me, (but not run it) and let AVG look at it. AVG flags it as a [Generic Trojan](http://www.avgthreatlabs.com/ww-en/virus-and-malware-information/info/trojan-horse-generic/?name=Trojan%20horse%20Generic.C05&amp;utm_source=TDPU&amp;utm_medium=RS&amp;PRTYPE=AVF) which is dangerous because that implies it could be sending information from your computer. I would recommend you do a virus scan as soon as you can and even consider changing your passwords (especially for POE).
I went through and disable all the extensions one by one, testing after each. It was still there. So I cleared everything from the cache. The message is now gone. I enabled all the extensions, and the message is still gone. Something about the cache was triggering it. After going over the script in question and finding nothing nefarious (darnit), Im going to chalk this up to 'dont watch intrracial midget tossing porn at work anymore'. //unless its Friday
My personal take is that the arguments against Mocha were incredibly weak, and after looking at the syntax for Tape, I'll pass. **Too Much Configuration**: He complains about the configuration required for Mocha, which he dramatically exaggerates. You literally have to run `npm install mocha expect.js` (or replace `expect.js` with whatever you prefer) and you're good to go. I don't see having a choice as a bad thing, and you only have to make that choice once. **Globals**: It's true that Mocha pollutes the global namespace, and this is a somewhat valid complaint - but if you are relying on global variables, you probably have bigger issues than your testing framework. **Shared State**: I generally avoid `beforeEach` and `afterEach`, but I'm not sure I agree that they promote sharing of state between tests. Let's say you are testing a dropdown UI component, and it appends its menu to the body (a pretty common practice). You probably want to include a step after each test to empty the body and make sure you are starting fresh (or this can happen in `beforeEach`). Likewise, if your component does something like adding events to the body, you'll want to make sure those are cleaned up as well. These help solve the problem of the DOM being inherently shared between tests. That being said, you can also simply opt to not use them if you so desire.
Coming from someone who hacks shit together and calls it a solution, your opinion isn't very highly regarded. Anyone can spend a few hours and hack a problem, but it takes finesse to make it production strength.
Google's crawler handles full JS SPAs just fine. Even going as far as navigating to places that are only accessible through several js modals and onclick handlers on div's. My company wanted me to do a full check last year and I found that unless I'm doing something REALLY off the wall (like 15+ second setTimeouts or adding a click handler to the body and using mouse cursor to pick what button was clicked) it always worked fine.
Thanks a lot! Exactly what I wanted to know
Are source maps an issue here?
Basically, there is a Cookie called "pc" (Poisoning Canary) that is added into the dynamic JS configuration object (see r.setup() and r.config). Your cache is "poisoned" when these two values differ. Try this in the console: r.cachePoisoning.checkPoisoned(); r.config.poisoning_canary = 'different'; r.cachePoisoning.checkPoisoned(); If your cache wasn't "poisoned," you should see false, then true. Also, the next time you load the page, you may see the notice about sending the report. &amp;nbsp; So that's what it does. Why does it do that? If I had to guess, my first thought is some weird subreddit that has a use for it (note that the code for the /r/thebutton is in that same js file). It could also be looking for user manipulation of their object, but it seems too specific to be generalized outside of some other purpose. Maybe there is a browser that keeps messing with their object - throwing errors - and this is just a debugging attempt. &amp;nbsp; EDIT: I should note that changing the cookie has no affect because that cookie is then sent to the server, which generates the code to initialize the config object to that cookie's value. The only way I can think of to cause "poisoning" is how I described in the code snippet.
So the script checks for cache poisoning. I was able to reproduce this by logging in after deleting cookies. Presumably this is a first-login thing, where the data stored in the cookies doesn’t match the expectation, and therefor logs the cache poisoning. Not sure how they expect this to prevent cache poisoning, but the rest of the scripts show no oddities, so it’s fine :)
&gt; midget tossing Is that like propelling a small person through the air, or subjecting them to whatever it is that "tossers" in British places do?
This code will look through column A (skipping the header) and perform this evaluation: if the cell value is equal to the next cell value below it count it (a cell counts as 1 the value inside the cell is not relevant for this) if the cell value is not equal to the next cell value than perform this operation: ( 30 (this is a static number that won't change) - (whatever the cell count is at that point) = X insert X number of rows below the last cell that was equal. (so there is now X number of empty rows between the cells that are not equal. ***I think is next rule might be better to use at the very end which would be this operation: look for any blank cell in column A and fill in with the text "empty" ok this is basically what i'm trying to do but the code isn't functional var sheet = SpreadsheetApp.getActiveSheet(); var startRow = 2; // First row of data to process, assuming headers var startColumn = 1; // Last row of data to process var lastRow = sheet.getLastRow(); // Number of rows to process var lastColumn = sheet.getLastColumn(); // Fetch the range of cells where data exist var dataRange = sheet.getRange(startRow, startColumn, lastRow, lastColumn) // Fetch values for each row in the Range. var data = dataRange.getValues(); var j = 0; for (i in data) { var row = data[i]; var nextRow = data[i+1]; var prevRow = data[i-1]; var bin = row[1]; var nextBin = nextRow[1]; var prevBin = prevRow[1]; if (oldBin == prevBin) { j++ } if (nextBin != bin &amp;&amp; nextBin != "empty" &amp;&amp; j&gt;=29) { var j = 0; } else if (nextBin != bin &amp;&amp; nextBin != "empty") { sheet.insertRowAfter(i); sheet.getRange(i + 1, 1).setValue(”empty") //marking the row as “empty" } } //End “for”
I made this when I was having performance issues with Bootstrap popovers (they aren't lazy, and really hit my cpu on datavis). I wanted something fast that was easy to integrate with d3 and the rest of a site as well. Currently working on more demos -- if there any you'd like to see in particular, or any features, please issue away on github! 
ha. my laptop almost exploded when this site loaded. fans rotating at 7000 rpm (I didn't know it was even possible to go that fast).
&gt; but it takes finesse to make it production strength I have had 120,000 NPM downloads in the last month and not from dependents. There are less than 0.1% (probably less than that) of NPM modules that can make that claim. Somebody must think the code is production strength. https://www.npmjs.com/package/prettydiff Once you have solved a challenging problem then perhaps we can resume this conversation. In the meantime I presume you are speaking from fantasies instead of experience. 
That is the way I like to assign long strings. You can read more about it here :) http://php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc Edit: Also, using EOHTML makes my [vim] editor automatically show correct syntax highlighting (works for everything, like JAVASCRIPT, CSS, etc)
Ah, I personally use TextWrangler and set up the language color settings in the preferences. It's fantastic when you can simply ssh into the server where you are working on changes. Also, can you look at my reply to /u/GlowInTheDarkDonkey?
I would ask "Why did you decide to write this using the ES6 spec?" and curiously await your response.
Tossing a midget is completely different from tossing *off* a midget...
It wasn't the tone, it was the terminology. JS does not have destructors.
tl;dr: MS is working on making the `&lt;template&gt;` tag inert. After that, they'll look into Shadow DOM. You'll still need polyfills for a long time. 
`for (i in data)` is very suspicious. You're using `i` as an index, so I think you should try writing it as `for (var i = 0; i &lt; data.length; i++)`.
ok i'm starting to come around, you *can* be funny sometimes. just...not when self promoting i guess
To experience, I write code because I enjoy it
Alternatively, try emacs-evil!
Thanks for sharing! I'll take that story with me
Standards &gt; Facebook who cares what the Babel team thinks, it's open source. Fork away and if people find it useful then people will use it. If they don't, then they don't. I don't see why you need to keep it private or even ask if there is any interest before releasing it. Just release, announce, and see what happens ;)
Just a clever way to "stop" your code, you can see how easy I've implemented the bubble sort in Array.prototype.bubbleSort, also using it in a loop is easy with for.. of syntax
Thank god. I was thinking if I need to be at that level to get a junior level position I was going to have to spend a few more hours polishing my skillset. I still am going to have to, but I feel a bit more at ease about it now haha. Good luck with the job! 
The docs say [it's a two-dimensional array](https://developers.google.com/apps-script/reference/spreadsheet/range#getValues()). Arrays begin at 0 in JavaScript, not 1. The very first time through your loop, won't prevRow be undefined? And won't that make the code crash on `var prevBin = prevRow[1]`. This is actually a fair amount of code to simply say "it isn't functional". What's the smallest amount of code that exhibits behavior you can't understand? 
One post per topic per day is plenty; I'm removing your other one since you actually provided some info in this one.
Blacklisting FB features is as easy as `"nonStandard": false`, but I think that it doesn't go far enough. There will still be conditional checks for this every time you compile, and still the option to turn it on and get non-standard features out of the box. For example, if I see that a project uses this fork of Babel, I can be 100% sure that there are no non-standard extensions in the codebase, since the code paths will be removed.
Easy. Current trend: Use colorful non-rounded squares, box-shadow: 0px, 0px, 30px rgba(0, 0, 0, 0.3); and transition: 0.5s on every element (a'la Material Design). Looks decent even if browser doesn't support it. Also flat-colored-svg icons. And font-width: 100 on h1. Wide HD background images, but content width @~600px. Flashiness guaranteed. Expanding menus and other crap can be done with pure :hover. Unless you're drawing graphs/loading stuff while page is running, you don't need JS. Besides, XMLHttpRequest is so 2008 \s.
While I agree with some of the points, I don't agree with some of the arguments. &gt; a) Function Declarations feel like they were intended to mimic Java style method declarations but Java methods are very different animals. In JavaScript functions are living objects with values. Java methods are just metadata storage. Both the following snippets define functions but only the Function Expression suggests that we are creating an object. So, avoid them because they \*might\* be confusing to someone with Java experience (and of course, little JS experience)? No thanks. &gt; b) [...] If you want to create an anonymous function [...] you need a Function Expression. Incorrect: &gt; new Function() &lt; function anonymous() &gt; b) [...] If you want to [...] assign a function to a prototype or as a property of some other object you need a Function Expression. Also incorrect: function Constructor() {} function method() {} Constructor.prototype.method = method; Constructor.prototype.slice = Array.prototype.slice;
whats wrong with a conditional, and a notice saying that a project uses only stardard features of ES6? This seems like a lot lot lot of extra work for almost literally no gain.
This looks terrible! Basic complaints: * Unnecessary complexity. KISS! * Lack of backwards compatibility: addEventListener, querySelector, etc. * You have one gigantic classless "God" object. * You don't really use classes. * You use cryptic/misleading object/method/variable names: reflectToDOM, FilterObject, SelectFilter, etc... * You want to put JS into HTML for "config" purposes. * You are setting default properties improperly (hasOwnProperty/getKeys/map/for...in are much better) * You should conceal all your stuff within (function(){/\*stuff\*/})() if you want it to be "reusable". You won't need this/self variable repeated everywhere. Automatic resizing is not a part of filtering. Clicking on item can be handled using document's click event. It's also not a part of the filtering. IHMO this is pointless library. * You're duplicating the functionality of &lt;option&gt; element. * And in the real world results are pulled from the server, and server does the filtering. Here's shorter, dirtier version https://jsfiddle.net/omxow2qq/
&gt; Every single thing he wrote was a monument to his ego. Whenever a sorting algorithm was needed, he'd write his own, claiming that the built-in Java sorts were too slow. He wrote his own JSON parsing code. I'll echo your warning, it's a very real thing that I've witnessed as well. Hired a guy that had a PhD in EE, IEEE software development cert, and was obviously very talented. Left in a silo, perhaps in R&amp;D, is where guys like him shine, because in a team environment he was probably worse than hiring a fresh grad. I'm not sure I'd chalk it up to ego (he was very quiet and reserved), I just think he lacked the soft skills to realize the totality of the situation. His code was so clever that even _he_ had trouble debugging it after being away from it just a few days, much less anyone else. Without hesitation, he'd rewrite (or write his own) version of practically everything he touched, whether there were in-house or long-standing FOSS versions or not. When tasked with refactoring a component, he invented his own MVVM micro-framework (and "framework" is stretching it, since it only catered to his very specific needs). The code was bullet-proof, met all the requirements, and had tests for everything. He also made all sorts of documentation (UML, wiki, etc.). Bugs weren't that bad to fix, once you found that one magical line that it was hiding in -- which could take the better part of a day. However, new features, which weren't supported by his framework, were a nightmare. We removed/refactored as much of his code that we could soon after he left, due to maintenance reasons. Frankly, it was beautiful to see what he would come up with, but only until you realized that someone (other than him) would eventually be maintaining it.
You might be better off proposing a plugin system for babel so that the facebook extensions can live outside the project and so that babel can focus on es6 compliance without a bunch of extra JSX cruft.
I guess they liked the question :P Thanks :)
So since nonStandard is an option, this idea is primarily about sticking it to FB and not actually solving a specific problem, right?
What, no plasma and flames?
I'd recommend something like Browserify or RequireJS to organize and load code. Other than that, though, I'd just look things up as you need them. 
Thanks for the reply. I've never heard of those. Can you explain a little about what they do?
JSX and Flow are implemented as "plugins" internally but there's only experimental support for them and also they're still coupled with the internal implementation. 
take the time to learn swift and/or java. appgyver offers the bare minimum of app development yet is clouded by bugs that are beyond your control to fix, has poor debug tools. the "cross platform write once deploy to all" dream is a false hope you'll regret in the long run. invest in high quality tools. additionally performance is low.
Babel contrib here. You're missing some context, and that context is the parser. It's extremely difficult to implement "plugins" for a parser in any sort of efficient way (although Acorn and Babel have been trying to for awhile). Also, having support for JSX and Flow has been HUGE to growing adoption and uniting the community around a single tool instead of having 8 different options that few people truly understand. Facebook has been extremely supportive of Babel and is helping out in no small way. Feel free to fork Babel, you can do whatever you want this is the nature of open source. There's just no way you'll ever keep up with Babel's speed of development.
Babel has a plugin system, just not for the parser which would be the blocker.
The size of code affects 0 people, that's whats wrong
Forking rarely works out: http://tirania.org/blog/archive/2010/Dec-31.html Much more efficient way to spend time: contribute to Babel and figure out how to help move JSX and Flow outside the core.
Let me put it another way. The developers spend more time fixing non-standard defects, so that means they spend less time on standards. It is still 20,000 lines for the maintainers of the project. *EDIT* - Not saying I would use the fork, but I can see where it is coming from.
&gt;The developers spend more time fixing non-standard defects, so that means they spend less time on standards. Do you actually think that most Babel bugs are related to JSX/Flow, and that most of the maintenance time is spent on them? A glance at the Babel issue list tells it's remote from truth. Also 49 open to 1590 closed issues ratio says the project doesn't have maintenance focus problems as you imply.
You're getting a lot of flak here, some of it probably from FBers, but I think you're on to something. It'd be a great idea if non-standard features in Babel were optional plugins.
That would be totally different issue though. Babel is neither slow nor buggy. If removal of 20k lines speeds up the product then I am on board but OP never made any such claims. He just want to fork because babel is giving him too much :P
&gt; this idea is primarily about sticking it to FB I like to think of it as being about sticking it to patent trolls... ... wait, I might be in the wrong thread. :P (I kid, I kid)
Oh yeah? npm install babel ... on a plane. Maybe this fork could be called "babel-for-people-on-planes"?
Here you go export default function({ Plugin }) { return new Plugin('fuck-jsx', { JSXElement() { throw new Error('fuck jsx bruh'); } }); } 
&gt; If Babel just did ES6+ to ES5 transpilation and implemented JSX and Flow as external plugins, I'd be happy with that As I said that's currently impossible because of the parser. It sounds like you want to create a developer nightmare just to not need to use a flag.
Open source code does not exist because somebody is smart enough to have written (or forked) it. It exists because there is a community of people using it, and there is also a small group of people (often a single person) putting their sweat and mornings and evenings and days and often partly nights into it. Which is neither healthy nor right, but I'm just trying to not sugarcoat it. Open source is not code, it's people. Some forks have worked out because they offer significantly better value. IO.js over Node.js, Lodash over Underscore. They offered something new (testability, adoption of new features, different forms of decision making) that was valuable enough to split the community. Throwing away a bunch of code that lots of people use every day, and that contributed significantly to project's adoption by said community, with no real alternative for those people, is counter productive. You can try it, but unless you offer a greater value than “we don't have this flag and thus related code”, it's just spreading FUD and hurting the effort Babel has been doing so far in uniting the JS community with a single tool. Do you think you're going to do a better job of maintaining JSX-less Babel and porting bugfixes? Do you intend to do this with the same speed and reliability as the few Babel contributors? Or do you want to dump the code for code's sake? Because, in open source, the code is little, community is everything. Even Apple has learned this by now. My humble thinking is that your effort can be better placed in helping Babel split out non-core stuff and learning why this is hard to do, and how you can help. (Opinions are my own lol.)
I think you're just trying to trick me into installing Facebook spyware.
Love the fire and smoke effects. I don't like not being able to push two keys at once ( Up and Left, Down and Right . . . )
No comment
I think SSE is essentially dead. It is kind of sad when SSE actually does a better job in most use cases and from what I saw scaled better.
Sounds like you're artificially inflating the number to make it sound better
Those have both been superseded by sockets.
okedoke sorry about that.
Is that an official superseded, thus deprecation, or just what you think? Back in the day, http://matthiasnehlsen.com/blog/2013/05/01/server-sent-events-vs-websockets/, tested them and had significantly better results with SSE.
It's not really even a conditional, if you don't have any jsx nodes in your AST then it will never hit the jsx code. It's not like it's mixed in throughout the codebase.
What is ES6+? Does async/await or “bind” syntax count? What if some ES7 proposal is on an early stage, but *requires* a parser change (which currently requires it to be inside the core)? Does this mean Babel parser shouldn't support it because it's not official?
believe what you want. whether it's 20,000 or 2,000 loc, it's not a trivial number.
It's pretty trivial relatively. Why don't you just go open an issue or ask /u/sebmck a question on his [ama](https://github.com/sebmck/ama)
[Here you go.](https://github.com/clessg/fuck-jsx)
maybe i am underestimating but there wouldnt be much of a maintenance burden, it could even be automated by a shell script that rebases from upstream and only requires intervention on conflicts. i certainly didn't expect removing code in a fork to be so controversial, and you know what, it is easier than fixing the parser implementation in babel. i have reiterated to the point of sounding like a broken record, if babel separated non-standard from its core, i wouldn't rip out facebook code because there'd be nothing to rip out. 
&gt; I think SSE is essentially dead. Based on... what? The spec was finalized earlier this year and it's supported by all browsers except for IE. http://www.w3.org/TR/eventsource/ http://caniuse.com/#feat=eventsource
&gt;it could even be automated by a shell script that rebases from upstream and only requires intervention on conflicts You should give it a try. ;-) &gt;it is easier than fixing the parser implementation in babel Removing something that isn't perfect but is used by people is always easier than working with the community to fix it. &gt;if babel separated non-standard from its core, i wouldn't rip out facebook code because there'd be nothing to rip out. Then help make this happen.
I see you noticed my mistake
There's something about the parallax that really screws with my driving.
why...?
"Oh hey PHP, i dont use arrays, so i'm gonna fork PHP remove all the array code, and use that."
Very funny. it saddens me that you think sticking it to facebook is a joke. it's not, nobody but their cronies has anything to gain from trusting them, and they have everything to gain from the blind trust of their useds.
It is a maintenance burden, luckily facebook hired /u/sebmck to work on it full time. Also... again with the bullshit numbers bro.
&gt; he invented his own MVVM micro-framework (and "framework" is stretching it, since it only catered to his very specific needs). Oh God. Was his name Alex by any chance?? :D
I'm not sure what you're trying to say, but I think the counter point would be A) Edge is now evergreen, so no Big Bang anymore and B) they have said, and shown that they'll be more responsible implementing things. 
pretty bad analogy. arrays are standard php.
Hi /u/sthies, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `sematext.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.sematext.com](/search?q=%28and+site%3A%27blog.sematext.com%27+author%3A%27sthies%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|12|100%
Who is EmberSherpa, and why should I ask them questions?
I did not say that the people who work on open source at facebook are evil, but rather that they are voluntarily working for a shady company that exploits the trust of their useds.
IMO it already is, if only because of its release cycle. Unless the next version is literally a year ahead of everyone else, its going to be the one browser dragging everything else down.
That wasnt the point of the analogy.
I think it's dead because of how little effort people seem to put behind it from writing about it to actually using it. I rarely see people talk about "realtime" apps and demonstrate using SSE. Rather, they all seem to use websockets, because on paper it can do anything SSE can do, and with IE not officially supporting it it makes people often just jump right onto websockets.
It looks like it's about time to revive [ECMAScript for XML (E4X) Specification](http://www.ecma-international.org/publications/files/ECMA-ST-WITHDRAWN/Ecma-357.pdf) which handles JSX in a generic way
I'd rather [revive this](https://en.wikipedia.org/wiki/Blink_element).
JSX is pretty awesome, but any static analysis must be intelligent enough to recursively pass between a JavaScript parser and an XML parser as deep as a given set of code requires. This is not hard to achieve, but not many tools account for this.
I guess we'll see what they mean by "evergreen".
I'm a huge fan of React, but if JSX is going to be widely supported, I'd far rather have a standard implementation than a proprietary one which is based on the standard one.
Reminds me of XML hype in the early 00's
[Someone](https://github.com/leonderijke/Modern-Blink) already has a custom element implementation of that.
No React, just Babel + Backbone: find js/src -name "*.js" -type f -exec node_modules/.bin/babel {} \; | node_modules/.bin/uglifyjs -c -m | wc -c // 1735350 That's about 150KLOCs. We also pull in some deps from node_modules, and that doesn't include handlebars templates. So ~2MB, though we split it into a few separate files to load in parallel. We don't worry about it much though because we're an app that people leave open for long periods of time. For local development, we get sourcemaps, and do an overall build with unittests (another 250KLOCs) that ends up being about 20MB while doing local dev work because sourcemaps are huge.