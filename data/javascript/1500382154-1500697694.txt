What should i do if i cant describe s.thing? Just say i dont know it or..? 
If they're not needed (in 99.99% of the lines you'll right) then how are they best practice? The reality I've seen of semi-colon ridden codebases is that they get randomly forgotten here and there and it doesn't even matter because the language doesn't enforce it. So why not just drop them entirely?
Do you have any more info about the environment in which they are working angular4/react/vue or vanila? Also, they can ask you about whats different in html5 in comparison to html4 or what do you know about cookies, local storage, session storage. And there can be some questions about css media query. Or some question about design patterns. And maybe if you seek out more info about they and what you have learned.
lol. "tits up"
Yes i am doing it for a few weeks, looking questions on the internet or i just create a question and seek for answer. Thanks for your consideration.
I recommend to try Vue.js. It is one of the fastest-growing libraries currently and is not only a utilitarian but also a quick and easy tool for applications and interfaces development. In this blog, I found the most detailed information: https://erminesoft.com/reactjs-or-vuejs-which-is-best-for-your-project/
That is why we are on the way to call them by year name : * ES2015 (ES6) * ES2016 (ES7) * ES2017 (ES8)
I feel that neither Facebook nor the community around Flow are very serious about it. Typescript seems like much better option between the two in that perspective.
Hi /u/Jharkendar, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Yes, that's right, good point.
Pretty much :)
look at his post history
I recommend Node/Koa + ReactJS on the front end (create-react-app). You have a lot to learn. Have fun with it and good luck! 
same as /u/HipHopHuman I'd advise against sequelize. It's API goes away from SQL and tries to make it more like mongoose. This is not very good because those two DB approaches are not alike and so you should use a different API. Knex is really awesome, but if you like OOP and MVC, you will want to have models. You can either write your own on top of knex queries, but I prefer to have a little bit more power-so I use [Objection.js](https://github.com/Vincit/objection.js). I've used many ORM in my life, even tried to write come of my own, but Objection is hands down the most awesome piece of ORM I've come in contact with. Try it and you'll never go back!
Having Prettier + format on save in VSCode has been amazing. 
Seek help friend.
Done. And another year goes by.
I'm not asking anybody to do my work for me. My JS works well but it's not behaving as expected. 
Okay, I've read through the whole thing. First of all, great tutorial for beginners. However there was one thing I didn't like and that is the last part about production. You are using renaming and other methods to fix the "errors" your build process inherited. In my opinion you should fix the build process so that it outputs the app the way you want. Other than that, great tutorial.
So is this replacing React or will both React and React fiber be developed as wholly separate projects for the foreseeable future?
Don't be overly boastful, but don't be humble. Most of the world is not humble, so you'll disadvantage yourself against your competition. 
It's ok to say you don't know. It's far better, in fact, to say you don't know than to sit in silence for a long time. When someone says they don't know I usually ask them a question leading in the direction of an answer to help move them forward. If you don't know, it's also ok to talk about somethings that you think won't work. That still helps me understand where you're coming from and may give me a hook to help you along.
Right? I feel like we collectively hit a low point around the uncertainty early in Angular2's development. New libraries and frameworks left and right, no clear "best" build tool for a given job, and the biggest framework of the time was about to have a massive API overhaul while pushing TypeScript. There was a lot to take in during this transition from the bloated WordPress-style approach to a leaner API-friendly, MVC-focused mindset.
I've been using Scala.js in production for a couple of years now, and haven't regretted it for a minute. It's overkill for one-liners, but for a complex client it's delightful to have a really well-thought-out type system available. And the strong interoperability with JS makes life much easier: not only do I get to use the existing ecosystem, I've found that using JS libraries is almost always much *easier* from Scala.js than from JavaScript -- we deal with writing enough facade as a one-off cost, but I can then code against it with a lot more confidence...
&gt; ...but I feel that for a team project it is not very ideal. I was exploring for other options and found that Elm and Scala.js... If youre making a decision based upon what is ideal for a team project, then I would have to wonder if you really think it would be best for your entire team to learn scala/scala.js -- lets be honest... no one knows scala :D
&gt; I came here to talk about programming That is quite hard if you cant share any relevant code...
If you're talking about SQL vs NoSQL I agree. If you're talking about MySQL vs Postgres I disagree. Postgres is always better than Mysql. Only thing which mysql has going for it is slightly wider cloud provider support. 
So you need funding? Or programming help? I am quite confused of what problems are you trying to solve in this thread
Hi /u/Hacklone, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
To our defence, we are not a very big team, just a handful of devs. As you said none of us really know Scala currently, but we are not really time-bound and wouldn't mind picking up and experimenting with a new language. 
It's not really replacing, it's just a rewrite of an internal part of react. It's probably going to be the default renderer of react 16, which is just the next version. Because it's a big thing (lots of hours, very promising), they gave it a specific name. For developers, nothing should change, react should just be faster/smarter. 
You seem to only worry about the functionality of your code. Would you argue that your code is equally as readable or better than an example using promises? Working on large codebases with many developers, it becomes very important to balance modularity, readability, and functionality on a **grand** scale. If you were to use callbacks everywhere, you would have to trust a team of developers to all use them the same way. Let us say there exists a team of developers that doesn't follow the same standards for callbacks. That means that every time a developer comes across an async method, they need to trace back and figure out how the callback chain works. Promises inherently encapsulate this functionality and provide a standard API on top of this. This allows for a couple of things: 0. Cognitive load taken off developers reading code. They see a method returns a promise, they know it's async. They know they can wait for it or handle an error that gets generated. 0. Composition. You can easily compose methods that return promises together. If you research Reactive programming (Rx.js) you will see how powerful this is. Composition allows you to break down solutions into smaller problems and combine then together at a higher level. 0. Standards. Your codebase is much more uniform, and developers don't have to work as hard to keep it that way. I would honestly love for you to respond, I am curious about your viewpoints on codebase maintenance. My previous job had a codebase in the multi-million lines of poorly written code dating back to the early 90's. There were a significant amount of lessons learned regarding keeping shit together.
Second vote for knex.js as a query-builder and DB layer over a full ORM like Sequelize or Bookshelf. Keep it simple. And with knex you can always pull in Bookshelf later if you need, it's built on top.
Good discussion! Both the frameworks (React and Vue) are ideal for creating additional user elements. But neither ReactJS nor VueJS can be called the full-scale framework. Vue.js is one of the fastest-growing libraries currently and is not only a utilitarian but also a quick and easy tool for applications and interfaces development. In this blog, I found the most detailed information: https://erminesoft.com/reactjs-or-vuejs-which-is-best-for-your-project/
&gt; It's kind of okay-ish because people usually check for NaN after checking for typeof number. But is the glass half-full or is it half-empty? I think it's definitely not okay-ish b/c you never know what people do. Just look at the random assortment of solutions posted here that don't work *quite* as advertised. Your suggested ordering of actions is also somewhat counter-intuitive b/c you normally want to do all the trivial, fast checks up front (`x === null`, `x === void 0`, ...).
That's why Ruby On Rails kind of annoyed me. Like most of the "best practices" were just what some hipsters thought looked the coolest 
You should clarify AngularJS vs Angular2 (1b should be "AngularJS"; 1c should be "Angular (2 or 4)")
I have yet to hear anyone explain to me why Yarn matters. "Because it's deterministic." What does that mean? "Um, er, uh." ----- Edit: yes, I get that you're downvoting me because you're angry at me for disagreeing. All the same, nobody who's replied to me so far has shown `yarn` doing anything `shrinkwrap` didn't, and you're all downvoting all of us pointing that out, ***instead of showing us why yarn is better***. There's a reason for that. Come to your own conclusions about what it is. 
do you mean why yarn matters or why determinism matters? npm 5 is now deterministic (by default) by the way determinism matters because people have experienced bugs when different devs on the same team ran npm install and packages were installed in different orders.
Everything about this post is amazing
..and funnily enough, it's the _same_ Ruby hipsters who started this fashion for no semi-colons in JS
It means that packages are pulled down and work in the exact same way with the exact same versions on the build server or your coworkers machine as they would on yours. It's pretty important for reproducible and reliable builds and QA.
Natural language programming isn't particularly new. [Inform](http://inform7.com/), for example, has pushed quite far in that realm. Syntax in and of itself is fairly inconsequential in the grand scheme of things. Most of the largest codebases in the world are written in "ugly" languages and have a ton of silly boilerplate that likely wouldn't exist in some other languages/paradigms, but for the most part, these languages are simply tools that have been selected for matching some criteria at which they excel at. Natural language programming isn't generally considered practical, since most implementations are exolangs, and generally people tend to stick to mainstream languages etc due to job availability and resources (docs, stackoverflow, tutorials, etc).
if you're using specific versions without any wildcards, then in what circumstances would npm install result in different environments?
Have you read the post? Or about Yarn or Lock files and semver ranges. These are the components of deterministic or predictable installs. Predictable is kinda important in software engineering.
Have you read the post? Or about Yarn or Lock files and semver ranges. These are the components of deterministic or predictable installs. Predictable is kinda important in software engineering.
You may be doing that, but the dependencies of your dependencies can shift around as much as they want.
The promise of Yarn was great, but I've had problems with them since day 1 because the offline feature didn't work with Github dependencies (as opposed to published npm packages). I opened 2 issues with them about this and even eventually had a member of my team submit a pull request to fix this. Curiously, the very naive pull request that we sent (it didn't have any unit tests) was ignored for almost a month before being merged without guidance on unit testing. A look through their git history around that time shows that [it doesn't seem like they really believe in unit testing?](https://github.com/yarnpkg/yarn/commits/master?after=78243bc49de94e423031e37c21dd16bb235f00dc+69). After that I switched to [pnpm](https://pnpm.js.org/) and never looked back. For my use case, it's better than Yarn in every way. Though I have to say, NPMv5 looks like it merits further a further look.
It means you can *determine* which packages will be installed before you install packages. This is a Good Thing™.
Yarn had some issues publishing packages under certain flags. It was a good start but a lot was missing. Nice to see I can get my lockfiles and use npm! 
fair enough, but isn't that what shrinkwrap is for? and does that mean yarn ignores wildcard versions?
If you don't know which to pick, you probably should use a SQL engine. Mongo is generally considered bad due to its weak data resiliency guarantees (look up auto increments to see an example) and is one of the main reasons people tend to avoid Meteor these days. I usually reach for sequelize and use its lowest level API (.query) to write parameterized SQL queries. I also usually reach for Postgre because I like its feature set. MySQL is not bad. If you have PHP background, it's a great choice since you'll be familiar with it from LAMP. Personally though, I prefer raw Postgre. I feel like it's very good for incrementally mastering SQL.
Just from my experience, I would also ask about the work environment. I picked up an internship recently where there are very heated conversations between some major type A personalities daily. There's also crazy deadlines. While I've learned a lot, my productivity and retention have tanked here. Maybe I'm just a panzy, but I'm looking at getting out of this internship as soon as is responsibly possible. 
Don't rush to answer, think before you talk. Read up on closures, prototype inheritance, call apply and bind, and variable scoping. There is a guy on you tube called techsith he has interview preparation course on JavaScript. 
we already had that with `package.json` (or `shrinkwrap` if you wanted the whole tree.)
&gt; Have you read the post? Yes. . &gt; Or about Yarn or Lock files and semver ranges Sure. Don't know anything specific they do that shrinkwrap didn't already do. Can you tell me what specific facility you gained, that we didn't already have? I'm aware that predictable is important.
Not sure why you wrote this twice. I'll give the same reply here too. . &gt; Have you read the post? Yes. . &gt; Or about Yarn or Lock files and semver ranges Sure. Don't know anything specific they do that shrinkwrap didn't already do. Can you tell me what specific facility you gained, that we didn't already have? I'm aware that predictable is important.
&gt; It means that packages are pulled down and work in the exact same way with the exact same versions on the build server or your coworkers machine as they would on yours. It's pretty important for reproducible and reliable builds and QA. We've had that for years with `npm-shrinkwrap`, though. Including the entire tree, down to the version. What's the new part we didn't already have?
It’s a really good book: * Whatever it says about JavaScript is still relevant, but only covers the language up to ECMAScript 5. * Anything related to browsers has aged less gracefully. You may want to look for material elsewhere. Regarding JavaScript features after ES5, you can check out my books, which are free to read online (alas, there are no paper versions): * “[Exploring ES6](http://exploringjs.com/es6/)” covers what’s new *after* ES5. * [The other books](http://exploringjs.com/) cover ECMAScript versions after ES6. * As an alternative to The Definitive Guide, you can read “[Speaking JavaScript](http://speakingjs.com/)”, which only covers the language (no browser stuff such as DOM, UI frameworks, etc.).
It means that running `yarn` won't upgrade a bunch of packages I wasn't intending to. It means that if I do upgrade my packages and something breaks, I have the ability to compare what changed (i.e. identify which package broke), and ultimately roll back if necessary. It means that when someone pulls down a particular commit of my repository and builds it, they won't get different results.
i don't mean either of those i mean "what specific technical improvement to determinism does yarn give us that we didn't already have" everyone's trying to define determinism, instead of to tell me what specific increase in determinism yarn offered over shrinkwrap at this time i am unaware of any specific technical improvement yarn offers over npm which is not present in shrinkwrap people keep trying to tell me how important determinism is. that's great. i'm more interested in what and where yarn's determinism benefit actually is, instead of being told why it matters. i confess i don't think there actually is one.
we already had that with shrinkwrap can you tell me something yarn does that npm didn't already do?
Here's a [StackOverflow answer on the topic](https://stackoverflow.com/questions/40057469/what-is-the-difference-between-yarn-lock-and-npm-shrinkwrap) &gt; As for comparison with `npm shrinkwrap`, [the documentation](https://yarnpkg.com/en/docs/yarn-lock) explains it very clearly: &gt; &gt; It’s similar to npm’s npm-shrinkwrap.json, however it’s not lossy and it creates reproducible results. &gt; ... &gt; The lossy behaviour of `npm shrinkwrap` is due to the non-deterministic algorithms used by `npm` itself; as stated in the comments of another answer, `npm shrinkwrap` &gt; `npm install` &gt; `npm shrinkwrap` is not guaranteed to produce the same output as just shrinkwrapping once, whereas Yarn explicitly uses ["an install algorithm that is deterministic and reliable"](https://code.facebook.com/posts/1840075619545360). `npm` is certainly closing the gap here, as this post states, but there's still some advantage to `yarn`. --- Plus, the fact that `yarn` is just faster than `npm` (due to its local caching) doesn't hurt either. 
You might be having better luck having a discussion on the tradeoffs between `yarn` and `npm` if you didn't open with a straw man argument, i.e. arguing that people who advocate yarn can't define "deterministic".
How is `shrinkwrap` "lossy?" In what way is the shrinkwrap not reproducible? What "algorithms" do `npm` use that are non-deterministic? What about shrinkwrap is not guaranteed? Can you give me an answer with falsifiable specifics please? This is just more assertions that I can't check. I think people need to start noticing how little specific technical merit is involved in ***any*** of these answers. 
I didn't say that. What I actually said was that yarn people can't show why yarn is more deterministic than shrinkwrap. And you've tried, and haven't succeeded. Also, that's not what a straw man is. Besides, [Stephen Bond was right](https://laurencetennant.com/bonds/bdksucks.html). If you're just going to yell at me, that's fine. In the meantime, nobody so far has shown any specific way in which `yarn` is more reproducible or more deterministic than `npm shrinkwrap`. They've just repeatedly asserted that it is, and pointed to stackoverflow posts of the same. I feel like this is actually proving me right. I'm sorry if you're unhappy about my pointing this out to you. However, at this time, I am not seeing a technical, specific answer regarding what the difference is. It's not just this thread. 
Your original comment is ambiguous. "What does that mean" can either be read as "What does 'deterministic' mean" (implying that yarn advocates can't define determinism: a straw man), or read as "What does 'yarn is deterministic' mean?". I realize, now, that you probably meant the latter, but I (and I think most of the other replies you've gotten) read it as the former. That's why people are downvoting you: not because they just can't stand criticism of `yarn`, but your comment really seems to be dickish at first read. Simply saying "Can anyone explain what makes `yarn` more deterministic than `npm shrinkwrap`" would probably have led to a lot less hostile discussion. Even with the more flattering read of your comment, it's a lot more tactful to open with a neutral question, rather than asserting that nobody who you disagree with knows what they're talking about.
JSX is influenced by JSP tech which goes back to 1999?
Personally, I don't use semicolons , but I don't get why people care whether or not others follow their own stylistic preferences. 
Shrinkwrap is an unholy mess and caused way more problems than it fixed in my experiences. Very few people I worked with could properly update dependencies when using it.
Automatic determinism rather than the clumsy half-hearted attempt of shrinkwrap.
How are these problems solved or even reduced? I work on a team in a large company and progress moves slowly. We can't just switch build tools or frameworks, so I haven't been keeping my ear to the ground as far as what's the latest. Is there a clear winner yet on how we should build JS apps and what framework to use?
A HTML document is a tree, so knowing tree algorithms can come in handy. Also, it's important to know when to use one or the other, even if you don't have to implement them from scratch.
I don't think he'll accept that answer. Or any.
https://yarnpkg.com/blog/2017/05/31/determinism/ For the Yarn vs NPM debate, I point to this. Seems like NPM wins. &gt; npm 5 has stronger guarantees across versions and has a stronger deterministic lockfile, but Yarn only has those guarantees when you’re on the same version in favor of a lighter lockfile that is better for review. It’s possible that there’s a lockfile solution that has the best of both worlds, but for now this is current state of the ecosystem and possible convergence could happen in the future.
It's fine, even members of the npm team laugh about the old shrinkwrap. It was bad, really bad. Since I switched to yarn back in October I have saved myself a lot of time by not having to explain how to add or update dependencies to people, that's part of the reason why yarn matters. While lockfiles are nice, the main motivating factor was speed increase. Yarn brought a ridiculously large reduction in install time, and continues to be significantly faster for me.
Dependencies of dependencies may not be pinned, even if yours are. Yarn's behavior is most similar to using npm shrinkwrap, but it handles creating the shrinkwrap file for you automatically. This was a major benefit of Yarn over NPM, but it's worth noting that the version of NPM discussed in this post adds it's own lock file.
Are there any benchmarks yet? We've been looking at adopting React, Angular, or Vue and one thing we've noticed is that Vue usually comes out on top in the various benchmarks. I'm curious is React Fiber has caught up to Vue. 
Thank you for the feedback! I agree that the production part is not optimal, but it's easy to follow and explains what the problem is and how to fix it. Going into build changes is something I am not very comfortable with and besides, most beginners would straight up quit if I had to get that technical. If I do a follow-up, however, I will most likely include an upgrade to the production section with more details and best practices.
(you can do that with `eslint --fix`, just so you know)
That's how I feel about almost all style standards in any language. The whole idea of "Pick one and be consistent" is mostly hipsterish as well. There are a few counter examples (like "should you line break before the opening brace?" and "should you line break before the closing brace?") which are mostly unanimously agreed upon, but it straight up does not matter if your codebase uses single-quotes, double quotes, template quotes, or a mixture. No one is going to make a bug because they didn't realize a string used double quotes. It's not going to affect reading comprehension. Personally, I just turn that rule off. There are a bunch of these like that.
React+Redux would be the safest bet since it's so widely used and actually used in Facebook'core products. The core API rarely changes and any change is minimal, most newer versions just tweek the internals 
this just makes the determinism assertion again, without explaining what the actual difference is, is the thing i am unaware of anything yarn does which is "more deterministic" than a shrinkwrap file
How is shrinkwrap clumsy or half-hearted? You know shrinkwrap can be turned on by default in the user config, right?
Kay. My actual question is neither of those. I'll repeat it, again, because this isn't the first time I've clarified for you. "What makes `yarn` more deterministic than `shrinkwrap` in a specific technical sense?"
Came here to say this. A JS survey that gets the nomanclature of one of one of the largest libraries wrong, kinda makes you lose confidence.
Is that new in npm 5? If not then that just proves my point that it was clumsy. I poured over the documents and had no idea. Nor did any of the other accomplished developers that I work with. Either way, I still would have switched. Yarn brought a huge speed increase, which was the main motivating factor.
Yes, yes, I get what you're asking. And I don't know the answer, honestly. But your original comment didn't ask that. You asserted that nobody could answer your question **without actually asking your question**, and then you insist that people downvoted you for disagreeing. I'm suggesting that, if you don't want the downvotes and pointless sidetracks like this, you might be more careful how you start discussions next time. That's it. You can take that advice or leave it. Have a good day.
Addressing #3: Node.js allows you to run javascript on your computer or a server. One of those uses is HTTP, but general tools and scripts can be done also. NativeScript most likely is using JS tools for task automation &amp; building your files, so Node is required to run them.
No real opinion on it; it looks cool but I don't know enough about it to form a proper judgement
I'd recommend checking out some basic node tutorials then start making some basic express.js apps to get your barrings. As to point #1, There's something to be said about your entire stack being in JS. Some might not like this, but I love it. You can share code, libraries, and patterns across your entire app if you design it right. As to point #2, Node is sooooo much easier to set up and run than apache. It comes down to preference, but PHP would be my last choice for a server-side language nowadays. Especially considering you have: Nodejs, .Net C#/F#, Golang, and Scala as alternatives. Just my $0.02. 
Thanks very much for the insights, and I'll make sure to check out your guides as well!
Just read this and scala.js looks pretty awesome to be honest. One gripe I have on JS is a lack of decent collections implementations, and scala has good ones. Is there some way to bring scala collections into JS natively, i.e. usable in JS directly, via the magic of scala.js? Obviously jumping straight into scala would be awesome but it isn't necessarily practical for existing / mature projects? Can we get scala-collections in npm or have I misunderstood what this is about?
Before NPM v5 came out, yarn had several advantages over npm with regards to the lockfile or shrinkwrap - Given a package.json and yarn.lock yarn will install the same output into node_modules. Older versions of npm wouldn't do this, even with a shrinkwrap. - The lock files are generated by default, whereas the shrinkwrap isn't. - npm shrinkwrap did not work with dev-dependencies, unless the --dev flag is used. Yarn works with dev-dependencies by default - npm install --save updates the shrinkwrap, but npm install --save-dev doesn't. This is inconsistent behaviour. Resolving the resultant shrinkwrap issues is not always straightforward, but yarn handles it by default.
A good actual use case for a linked list would be to implement a hash table, as a type of collision resolution. Hash tables are used everywhere for fast insertion and deletion. B-trees are used for super fast retrieval as well and it's actually how SQL databases are implemented. If interested, I've just written an article showing how to write a LL in JS. https://codeburst.io/js-data-structures-linked-list-3ed4d63e6571
What about support for pasting embeds to Medium via embedly?
Tomorrow? Barebones questions: * What is the *this* keyword * Variable scope, hoisting * If you had a large application how would you organize your JavaScript? Ask to see if you could take a look at the work area, you'll probably walk past it anyways.
I don't know about 5.3, but npm 5.2 is buggy. That version is a package manager that doesn't manage my packages. Yarn isn't perfect either, it also has bugs like with node-gyp. For me I will be using the most reliable one, whether that's npm or yarn. 
This should work! If you paste a runkit link in medium, it should be transformed into an embed: https://medium.com/@tolmasky/embed-ly-support-d6cc45e5155e 
I've never heard of Stellar and the readme doesn't do a great job of explaining exactly what it does - can anyone give a brief summary?
welcome to modern programming. cargo cult is in, rationality is out. it's why software reliability and quality has nosedived in the past 5-10 years. I've been programming for 25 years and can readily defend this. But that doesn't matter because rationality is out, cargo cult is in.
Issues with yarn - 1. it never became popular. You had to know about it to use it. Most projects/articles/tutorials never updated to say yarn, it was rare to find a github project or article that actually recommended using yarn. Hell, even FB themselves use npm - https://facebook.github.io/react/docs/installation.html 2. yarn global add was broken for a while, I stopped using it. Also had other issues I forgot, had to use npm and in the end its wasn't worth it to save a few s. 3. its not installed by default with node
Not that I know of, you could [check it out yourself though](https://gist.github.com/duivvv/2ba00d413b8ff7bc1fa5a2e51c61ba43). No idea if it's going to beat Vue, Inferno or whatever, but the stuff I've seen/read makes me excited :).
I have found docs and tutorials that use yarn install. Granted, nowhere near as many as npm, but still. 
Hi /u/farm-fresh-js, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `codeburst.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [codeburst.io](/search?q=%28and+site%3A%27codeburst.io%27+author%3A%27farm-fresh-js%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|11|79%
If you want Scala collections in pure-JS, the collections from Immutable.JS are basically that as far as I understand.
[their tests directory](https://github.com/yarnpkg/yarn/tree/master/__tests__) is pretty big for not caring about unit testing. anyway, [looks like unit tests are passing again](https://github.com/yarnpkg/yarn/commits/master?before=a7e6efeaaa68a8c4cafa40f04a2143508c1140e1).
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [yarnpkg/yarn/.../**__tests__** (master → 78243bc)](https://github.com/yarnpkg/yarn/tree/78243bc49de94e423031e37c21dd16bb235f00dc/__tests__) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dke3q9r.)^.
I'm pretty new to JS, but is hoisting a thing people actually *use*? It just feels like such a weird thing to regularly do, coming from languages like Java and C#.
Got it, thanks!
Everyone worries about this and the truth is most apps/sites will never hit the kind of scale where things like sharding/access speed make a difference. Use whatever tech makes sense and is the easiest. If you like storing schemaless json and its more productive, use NoSql like mongo. If you have a lot of use cases for SQL like queries and already know how, use that. 
Strongly recommend it. Made tremendous difference for me. After wasting away in beginner, intermediate tutorials for months; I just, irrationally, decided to read this book from cover to cover. Took few months but it was quite a level up for me. Nothing was magic anymore.
A personal favorite: isNaN('') -&gt; false Number.isNaN('') -&gt; false parseInt('') -&gt; NaN Edit: formatting 
Yarn and npm 5 lock files include cryptographic hashes, which are used to provide comparable determinism guarantees to directly committing all of node_modules. Shrinkwrap files include only version numbers, leaving open the possibility for network errors or malicious attacks to affect the result saved to node_modules. The former method guarantees that if an install command works at all the result will be consistent, while the latter is a more incremental improvement over a standard package.json.
Short of creating your own function called isValidJson (which uses a `try…catch` block under the hood anyway), there's no way to `if…then…else` invalid JSON. You have to use a `try…catch` block. Also, what would you do, exactly, with an actual unexpected error? I feel like if you are handling an error you should have *some* idea of what is going wrong and address it. If you have no idea and catch the error, then who know what side effects that could have. And finally, I mean I get that you're saying you shouldn't do it, but why exactly? How is: if (file_exists(file)) { if (file_is_valid(file)) { if (file_is_long_enough(file)) { do_something_with_file(file); } else { alert("File too short"); } } else { alert("Invalid file"); } } else { alert("File does not exist"); } Inherently better than: try { do_something_with_file(file); } catch (e) { alert(e.toString()); }
I did indeed. Fixed.
React [sees the most use](http://npmcharts.com/compare/react,angular,@angular/core,ember-cli,vue,@cycle/run,@polymer/polymer), but also hasn't had deep core changes for years because it's foundation doesn't need it, it simply grows with the language. Most frameworks today are react-like, so even switching doesn't mean much when you can freely exchange code &amp; components. As for build tools, [webpack has established itself](http://npmcharts.com/compare/webpack,browserify,gulp,grunt,brunch) in a similar manner.
Just go to a library and start reading it. Bring along a pad of paper and a pencil. Write down the questions you want to ask as they occur. When you are tired of reading, leave the library and look the questions up on your computer. Do *not* bring your computer to the library.
Immutable.JS doesn't AFAIK have any sorted collections like a tree. Being able create a sorted collection with custom comparator and just start adding should be pretty basic but doesn't seem to exist in JS. I am pretty sure it does in scala though ... so getting from there would be cool! PS to be explicit I don't actually care about immutability, just some half decent collections!
Is this a help request?
Hey, thanks for the comment ;) Stellar is an action based web framework! What does that mean? That means that every feature is represented as an action, those actions receives a set of inputs, perform some work and give an output. You can look to it as a small piece of logic. With this concept, you can create small, independent and easy to test actions that when combined create a more complex action. In other words, you can better reuse your code and make it readable. But the most interesting thing is that Stellar can generate documentation without any human interaction. You can read more on our website, [stellar-framework.com](https://stellar-framework.com). I'm trying to create videos and posts to explain how to use and show use cases, but I'm a little out of time.
I'm not arguing for the decision made, I'm trying to understand the logic behind it.
no, it's a link for the solution on my github.
Hi, I saw your article, but I am afraid it doesn't answer my question. "implementing a hash table" is not a real life situation - we already native objects which are hash tables, why would we need to roll out our own? I am aware B-Trees are used to implement databases but that's not what we do in JS. Don't take me wrong, it's all interesting and learning new things can only be good, but I don't think they actually have any practical purposes in JS. I was hoping someone would prove me wrong, but nobody has.
I don't see what a DOM tree and a b-tree have in common, other than the word 'tree' in their name
I downvoted you because both your argument and defense of your argument utilize straw man fallacies.
Pretty useful, thanks!
Problem is that you never learn about the actual work environment by asking about it during an interview. Nine times out of ten they'll tell you that the work environment is pretty relaxed and people get along well, we do this or that as a group sometimes, people eat lunch together, etc, etc. They will never tell you that we have a number of obnoxious type A personalities in the office that like to have heated debates about mostly inane topics relatively often in the middle of the office floor. You will never learn that stuff until you actually start working in the office. At that point you either need to adapt or move on. Ask to look around the office. This won't solve any major problems because most people will be on their best behavior most likely, but you may be able to see clues.
I don't much use variable hoisting purposefully (ideally avoid it and the consequences it can cause) especially with the let/const keyword nowadays I find no reason to use var. Function hoisting on the other hand I use pretty often, sometimes its considered bad to do but I often declare useful functions at the bottom of a file, and since function declarations are hoisted I can use them. I keep my business logic at the top and helper functions that are only used once for instance I keep at the bottom with sane names in case someone wants to look at its implementation.
Honestly, you're right, in JS there's practically no use to linked lists. In a normal web app you won't ever be dealing with so much data that implementing one yourself would help. If you were, you'd use a database anyways. It's still asked in interviews because it shows that you can think about how to deal with data and algorithmic efficiency but there isn't much of a practical use. For a tree, I just remembered a practical use. Last year me and 3 others built a website that displays a Git repository in visual form. A tree made the most sense to store the commits, checkouts, etc. We got the data from GitHub's API and transformed it into a tree, then rendered it. You can see it at http://www.gitcentral.com/ (doesn't work perfectly...)
I wonder how many people that switch to yarn, jspm, ect. have actually been limited by npm in some way.
I tried to translate your pseudo-code into a Codepen. Seems to work? https://codepen.io/anon/pen/EXzqpw (this isn't a 2D array, but same principle)
Hi /u/incarnatethegreat, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
+1 for 'avada-kedabra' 
Not to mention coders who know C# who use Async/Await
Both free online Eloquent is probably my favorite introduction type book, and YDKJS is great for digging a little deeper. [Eloquent Javascript](http://eloquentjavascript.net/) [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)
I've never had a problem with npm. Am I a casual?
Ironically, I think natural language is actually a poor medium for facilitating understanding. A great example of that is in Starcraft 2 lore. On one side of the spectrum, you have protoss dialogue that is very elaborate and fitting for its faction-divisive culture, and on the other side you have zerg dialogue that is basically broken english purely for the sake of efficiency. Similar to how zerg dialogue deliberately mangles natural language grammatical flow, code maximizes for unambiguity. There's no room for contextual constructs like `it` in code. One could argue that something like `from 0 to 100 {}.` is a readable loop, but it's not necessarily so. To a non-programmer, the curlies are confusing noise, and to a programmer, it lacks information about the step size and break conditions, and it increases the language surface (which is a bad thing - see C++ dialects). The only "natural" thing that this example has going for it is the abundance of spaces instead of parentheses or other symbols, but this is arguably already the case in languages like Python or Ocaml.
Dude, look at his comment history. This sort of inane bullshit is his forte.
The single biggest issue I have with NPM is it's inability to vendor dependencies, similar to python's pip. Our CI and builds are network isolated, and the assumption that you can always reach the registry is really naive. 
&gt; [press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself Oh god, I've been doing this manually for so long. Thank you Mister Bot!
It would be interesting if weren't for the terrible video, the impossibility of checking the code and the lack of links to dig deeper about it.
I am sticking with npm 4x until package-lock is stable. The speed of 5 just isn't worth it for me with the number of times package-lock is corrupted and breaks npm i. I wish they had done incremental releases with speed improvements and the package-lock stuff, rather than coupling them together.
It doesn't do anything more deterministic than a shrink wrap. In fact, it is less deterministic since it doesn't save hierarchy of dependencies. All it did was make it default behavior. The biggest issue with shrinkwrap was the manual process behind it.
Hoisting is something to be aware of. Forgetting the var for var foo = 1; means that foo is a global variable. [Examples here](https://stackoverflow.com/questions/6888570/declaring-variables-without-var-keyword). A typical question: what will the console log when I declare variables this way, inside and outside of functions, and why?
He's not talking about himself though. It's a valid complaint from a statistical perspective. Maybe there is a correlation between some of the answers and the ability or willingness to fill the whole form. That's something we will never capture.
I've used `yarn` since day 1 since I found `npm` to be broken. Specifically the shrinkwrap files which really didn't work, and `yarn` had that one covered. However, `yarn` didn't (doesn't?) work with private github repos which is a very big problem for anyone making some serious development with node. So we've actually ended up with a mix of the two, but prefer `yarn`.
There's a lot of answers, but I haven't seen this mentioned:even when using shrink-wrap, the order you install things in mattered with npm (before 5). Furthermore, this was only the case if you installed by manually adding dependencies to your 'package.json'. Thus, Yarn was somewhat more deterministic, although in practice it didn't matter that often. The main difference is that you could be sure it was: someone didn't have to remember to shrink-wrap, and it didn't matter if they added it manually. That said, given that apparently the version of Yarn used matters, and that npm comes with Node, pretty much makes it irrelevant, I guess. 
You can do this with less loops if you're looking to improve upon your answer. 
Nice! I missed this last year but occasionally go back to look at the results. I like the way they break down and group the tech.
Wow I did it that way and it hadn't worked, weird, I will have to comb through my code and see what the issue is...
Yarn matters less (for the moment) now that NPM5 is released. I saw it as essentially a way to call out the issues with NPM and prove that they could be resolved without starting a huge public argument, instead just opting to *show* that things could be better. From the NPM blog: &gt; Shrinkwrap has been a part of npm for a long time, but npm@5 makes lockfiles the default, so all npm installs are now reproducible. The files you get when you install a given version of a package will be the same, every time you install it. &gt; &gt; We’ve found countless common and time consuming problems can be tied to the “drift” that occurs when different developer environments utilize different package versions. With default lockfiles, this is no longer a problem. You won’t lose time trying to figure out a bug only to learn that it came from people running different versions of a library. Yarn did this first, and so spurred NPM to do it as well. Yarn also focused on performance during installs, and now over in NPM land... &gt; We’ve reworked package metadata, package download, and package caching, and this has sped things up significantly. In general, expect performance improvements of 20–100%; we’ve also seen some installations and version bumps that run 5x faster. It's basically a working example of how more competition in a space benefits users. That doesn't necessarily make Yarn better or worse, but it does make it an important project.
new documents I've seen had yarn. I think you're struggling with the shear magnitude of old documents which arn't going to suddenly be updated to use Yarn.
I assume so. I've had a few yarn issues and npm issues, and both get solved by some full scale purging.
I've settled on create-react-app, Redux, and Styled-Components. 
No, you're being down voted because you were too lazy to lookup what determinism meant and because you then proceeded to mock people who care about determinism. In reference to your edit, it's not just about a lock file. It used to be the case that NPM would result in different node_module trees if modules were installed out of order.
NativeScript will not allow you to make hybrid applications (webview based), it will allow you to write **native** mobile applications in JavaScript by providing you with a runtime (JavaScriptCore) that has bindings to the Android and iOS API's.
How to confuse a crocheting programmer
It does look much improved since that time when I was struggling with them. However, I can't just keep switching package managers all the time for no reason. I have to actually write business logic. [pnpm](https://pnpm.js.org/) is great and I see no reason to go back and re-try Yarn. PNPM is faster for me and I have gotten much more rapid replies when I open issues on their GitHub than I do on Yarn, despite Yarn's larger community.
I think that's overthinking it
I've encountered huge issues with it and Windows. Not obvious and very annoying to track down issues. Went back to npm, angry at myself for even thinking about using a new js build tool within its first three years.
how is this related to /r/javascript?
I ended up using different html comamnds
That was fun!!
"Our codebase uses yarn with [needles](https://www.npmjs.com/package/needles) to [knit](https://www.npmjs.com/package/knit) and [purl](https://www.npmjs.com/package/purl)."
&gt; No, you're being down voted because you were too lazy to lookup what determinism meant Thanks, I actually know perfectly well what determinism means. I haven't mocked anyone at any time. Please quote me doing so if you believe otherwise. I'm simply pointing out, correctly, that you guys keep saying "it's more deterministic" then not actually saying how.
If interested in a workaround, you can disable the use &amp; creation of *package-lock.json* via the `package-lock` CLI flag / config setting: https://docs.npmjs.com/misc/config#package-lock
&gt; &gt; Shrinkwrap has been a part of npm for a long time, but npm@5 makes lockfiles the default &gt; Yarn did this first If you mean shrinkwrap, nuh-uh. If you mean making lockfiles the default, I mean, okay? Were we going to throw away the entire NPM infrastructure so that we didn't have to write a `~/.npmrc` ? . &gt; Yarn also focused on performance during installs, and now over in NPM land... NPM's been making performance improvements every month for like seven years. It seems spurious to suggest that this is because of Yarn. . &gt; It's basically a working example of how more competition in a space benefits users. This is an interesting position. I actually agree with you here. I have yet to hear any explanation of how it's more deterministic, though. ---- Edit: going down later in the thread replies, I got three good answers to this. * Order of install was undefined and that's potentially dangerous * Crypto thumbprints of modules to prevent nefarious replacements (meh) * Correct rules for maintaining non-default `shrinkwrap` are genuinely non-obvious I am actually very sympathetic to the first one, as that could cause legit problems . Thank you for one of the very few good faith replies in this thread.
&gt; There's a lot of answers, but I haven't seen this mentioned:even when using shrink-wrap, the order you install things in mattered with npm (before 5). Furthermore, this was only the case if you installed by manually adding dependencies to your 'package.json'. This is the first technical answer I've seen. Thank you. I was unaware of this. Why is this the case? I mean, maybe I just got lucky, but I've never hit this, and I don't know anyone who has. I suppose I can see some argument for side effects of things in native installs, like `node-gyp` stuff. Is that where that triggers, or ... ? . Thank you for one of the very few good faith answers so far. `:)`
&gt; The biggest issue with shrinkwrap was the manual process behind it. This is a viable position. I automated mine away in scripts, but, having to do that, knowing it's an option, having other people do it slightly differently; etc. Interesting. Thank you for a good faith response
https://watchandcode.com/p/practical-javascript For new programmers, that site is better than any book. 
The straw man is when you misrepresent someone else's position to ignore their real position. As far as I know I haven't taken any stance on other peoples' positions. Indeed, I'm complaining that I can't receive them. Also, since I'm openly requesting people to tell me what this is based on, I'm pretty obviously not trying to ignore you guys' beliefs. In other news, [please consider Stephen Bond's position](https://laurencetennant.com/bonds/bdksucks.html).
Egghead.io is fun too... Targeted, short, easy to find. My $0.02
&gt; Yarn and npm 5 lock files include cryptographic hashes ... possibility for network errors or malicious attacks Oh. That's interesting. Okay, I didn't know that. Thank you. This is a significant, legitimate improvement. 
yeah, same. i switched to yarn intending to switch back once npm reached performance parity, then decided to stay because yarn has features i like (`yarn &lt;script&gt;`, `yarn upgrade-interactive`) and i just know if i do i'll be switching to something else sooner or later. bower, yarn, and pnpm aren't gonna be the last package manager upstarts by any means. also the npm client is built by only three people (extremely talented people nonetheless!) &amp; feels more like a vanity project to support the registry than a first-class product offering. i fear the day when npm the company decides it doesn't need to invest in its development anymore &amp; decides to afterthought the product entirely. it already feels like it gets dev love only when someone else embarrasses them with an innovation (like sane lockfiles).
i would like to see you readily defend that quality has nose-dove in the last 5-10 years. i've also been in software for multiple complete decades. i agree with you with regards to cargo culting. however, we did the same shit in the 1990s, y'know? `:)` however, i did get two interesting answers out of this 1) apparently there's a crypto thumbprint for modules now 2) there is a claim of order of install dependency. it is not yet validated, but considering garbage like `node-gyp`, i believe them
i switched to yarn from npm because i had to. a project with ~200mb of dependencies took an order of magnitude less time with yarn. for someone who tinkers with node_modules fairly regularly, reset times like i had with npm were a no-go. but that's not even the killer feature yarn advertised when it came out; people were extremely limited by npm's non-determinism, even with shrinkwrap files (`npm-shrinkwrap.json` has always been an afterthought, and with `package-lock.json` now officially is), and yarn offered first-class lockfiles + offline-only installs as a solution. tl;dr: npm has a lot of limitations.
&gt; Given a package.json and yarn.lock yarn will install the same output into node_modules. Older versions of npm wouldn't do this, even with a shrinkwrap. I would be interested to learn why, in the case of a shrinkwrap. My possibly false understanding was that that was the entire purpose of a shrinkwrap. . &gt; The lock files are generated by default, whereas the shrinkwrap isn't. I guess I don't really think this is worth a package system fork, but, noted. . &gt; npm shrinkwrap did not work with dev-dependencies, unless the --dev flag is used. Yarn works with dev-dependencies by default This is just knowing how to use the tool correctly. On grounds like these, ... `git` as a whole. . &gt; npm install --save updates the shrinkwrap, but npm install --save-dev doesn't. This is inconsistent behaviour. Resolving the resultant shrinkwrap issues is not always straightforward, but yarn handles it by default. I did not know this. This is gross. Point #1 seems like a good enough reason to support the determinism claim. If you could help me understand why that was the case, I would genuinely appreciate it.
you can stop explaining to me this is the fourth one. i wasn't asking &gt; I'm suggesting that, if you don't want the downvotes and pointless sidetracks like this i don't care about the downvotes and there doesn't seem to be anything i can do to dissuade you from repeating your explanation why you're telling me things i'm not interested in or asking about
it is written in JavaScript. 
&gt; Either way, I still would have switched. Yarn brought a huge speed increase, which was the main motivating factor. You're the first person to tell me this. Everyone else says it's about determinism. In this thread, I've seen now three legitimate claims supporting the determinism issue: * apparently order of install is undefined, which was dangerous; * there are package hashes to ensure no nefarious package replacements (meh;) and * there are consistency and ease of use problems around non-default shrinkwrap, particularly in that the rules around maintaining dev dependencies are seriously inobvious the order of install issue seems serious to me, as i do not believe it is voluntarily manageable
* It's perfectly ok to say "I don't know". Don't try to bs an answer on the spot. * Think before speaking. * Aside from technical questions, be prepared to answer questions about yourself. Such as "What are you strongest strengths? Weaknesses? Where do you see yourself in 10 years?" etc. * Dress professionally, groom your hair, shave or groom the bread, brush your teeth. Overall good hygiene. * Relax. * Turn the interview around and interview the interviewer. Catches them off guard and puts them on the spot.
Not sure how this helps me get one girl, let alone two.
You can loop through the keys using [forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach): &gt;arr.forEach(function callback(currentValue, currentKey) { }); Hope that helps.
Thank you for the reply! Would forEach be used to print out "name","address","phone" or "john","earth","123"?
Your question isn't really clear. You seem to be asking how to enumerate the properties of an object, but that has nothing to do with the fact that the object is in an array. Being in an array or not doesn't affect how you do that. To iterate over the properties of an object you can use a for-in loop, or you can use `Object.keys()` (ES5) to get an array of the properties. For example: let foo = {name: "john", address: "earth", phone: "123"}; for(let prop in foo) { console.log(prop); } If the object is in an array, nothing changes except that you index into the array to refer to the object: let bar = [{name: "john", address: "earth", phone: "123"}]; for(let prop in bar[0]) { console.log(prop); } Note that properties are unordered, so you aren't guaranteed to get them in any particular order. If that does not address your question then please clarify exactly what you're trying to do. 
I switched to yarn because NPM &lt; 5 shrinkwrap was not deterministic and for large projects that's absolutely necessary.
forEach only gets you through the array. The array has one value which is an object. To get through that object without hard coding you can use a for..in loop (`for (var key in object) { ... }`). In that loop, the `key` is the object key, such as `name` and `address` and `object` is the object itself, being what you pull from the array. Getting the value you'd use `object[key]`. You can also use `Object.keys(object)` to get all the keys of an object as an array and use forEach on those (you'd still use `object[key]` to get the value). How you iterate through an object can produce different results sometimes, depending on any inherited members that may exist. MDN has a table of these differences: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties Note that this table does not include the newest Object methods, `Object.values` and `Object.entries`, though they iterate similar to `Object.keys`, only providing different values (values, or keys and values, instead of just the keys).
The shrinkwrap is/was just responsible for locking versions of dependencies, but not for how the dependencies are installed into the node_modules folder. I think this explains it: https://docs.npmjs.com/how-npm-works/npm3-nondet Yarn's lockfile is also only responsible for locking of versions, but yarn's resolution of dependencies will produce the same install even if packages are already installed. npm 5 is different, the new lockfile format guarantees dependencies are installed the same way every time. Most of the time, I don't think the above is really an issue, it's probably quite rare to have a bug caused by it. I think the latter points I mentioned were the biggest issues we had with npm - we wanted something that handled dev dependencies in a stronger fashion.
And for most packages that don't include type definitions, you can just `npm i @types/&lt;package&gt;`
The solution is you're getting two guys
NodeJS is basically an environment with a set of libraries that allows you to better cooperate with OS, and to be free from browser restrictions (like CORS). It's basically a platform for writing desktop applications, that's why it's often being used for making servers. But you can also create normal desktop apps (i.e. Atom and Visual Studio Code are made in NodeJS). 1 It's totally situation specific. The biggest adventage is the fact that the same programmer is able to code front-end and back-end without learning totally new language. 2 NodeJS allows you for more than just being web server, it's also faster than php. NodeJS also comes with biggest open source repository in the world, called NPM (Node Packet Manager), which lets you to easily install packages and takes care of their versioning and dependencies Node also allows for pushing data from the server, which php is not able to do as far as I remember (but my knowledge may be outdated in terms of php). 3 Unfortunately I was never making any mobile apps in JS, so I'm not able to tell you what is NodeJS for in this category of apps. As far as I remember, Android can't run NodeJS, so it's probably more likely to be just a helper for compiling code to Android apps packages.
Yep. Nothing is new. Just better implemented and more widely received. 
Thank you for a clear, specific, and technical explanation. I really appreciate it.
- Very important, but often overlooked part is... Showing yourself as someone who is fun to work with. https://medium.com/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466 - JS stuff: "this" keyword, how variables are being passed as arguments (objects, primitives), closures, promises, prototypical inheritance, functional programming elements in JS (like .map .filter .reduce instead of loops), what is "use strict" for, JS design patterns, how to manipulate DOM, excercise for some interview whiteboard tasks. - CSS: SASS/LESS, atomic design - HTML: HTML5, semantics, SEO - Helpers: Continous Integration, Git, Task runners, NodeJS basics, colors theory, babel 
In your argument you create an imaginary person who can't define why deterministic behavior is beneficial. That's the straw man. In your defense of your argument you say "downvoting me because you're angry at me for disagreeing", which is at best an assumption that you don't have enough information to make and at worst another straw man fallacy. Deterministic versioning is always preferable since it makes applications more fault tolerant. I'd much rather know that my application is going to get a particular version of a dependency that I know works, than to assume that the developer of that dependency is using semver correctly and that they haven't accidentally pushed a patch version with a BC break. Pretty basic stuff. I don't know a single developer who wouldn't tell you the same thing.
The lock file in yarn was the killer feature for us. Better performance didn't hurt either, of course. I would definitely say that most switchers did so because of npm limitations. It will be interesting to see if they switch back as npm becomes feature comparable again.
The old scope / pass by reference / value answer is always a good one to have in your back pocket, also be ready to *simply* explain closures. If you don't have a good project you've built you can enthuse over, have one ready that you'd *like* to build- and then explain your vision of how you'd do it ( what stack it would use, what approach you'd take, UX, testing, etc, etc. ). And *relax*! Be the guy they'd like to have on the team. Fit is everything.
ohh... too late
NativeScript is not hybrid. NativeScript compiles your html / javascript code into native Android/iOS code. If you want true hybrid development you should go for Ionic or Phonegap, they use a browser instance to interpret your app. That said, for NativeScript, Node is just an internal dependency. You're free to use whatever you want for your backend (after all, a mobile app is almost always just the front end). I prefer Node over PHP &amp; Apache but that has nothing to do with NativeScript.
https://github.com/prettydiff/wisdom/blob/master/Web_Interview.md
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [prettydiff/wisdom/.../**Web_Interview.md** (master → e5ee280)](https://github.com/prettydiff/wisdom/blob/e5ee280f84020b02dcba0dcb0d37661c16b4d0ce/Web_Interview.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkek0zx.)^.
Thanks! This is perfect, one last question. I know data[0] returns me the object itself. Is there any way to print out the object's values? Example: alert(data[0].name) //this prints out "john" Is there any way I can print "john" without mentioning the parameter "name"? I'm trying to make this program flexible so that I may not know the variable names, but still be able to print out the variable name and value.
I'm in a pretty bit typescript codebase and honestly love it. we've generated types from our backend and we have implicit any turned off and with the angular language service we even get typing in templates. I think the fact that it's just JavaScript with types pretty much is a huge benefit personally, but that's up to each team's skillset. It's a really clean way to do types imo and with our type generator we're always guaranteed to be strongly typed the whole way so that's nice too :) I feel very confident coding in that codebase! 
The data declaration must be a function that returns your data object. Don't know if this will fix your problem, but you should be building your component the right way first. 
You can always research it yourself. Here's a starting point [https://docs.npmjs.com/how-npm-works/npm3-nondet](https://docs.npmjs.com/how-npm-works/npm3-nondet)
Once you have the properties, just access the value for each property. for(let prop in foo) { console.log(`the property is ${prop} and the value is ${foo[prop]}`); } ES8 adds `Object.values()` which is analogous to `Object.keys()`. 
I'm not new, just want to explore every field of the language can do, need books for depth study.
It takes like 10 mins. If you don't have the time, then do it another day :)
Prettier can match about 98% of Airbnb's style guide. Just a few more JSX settings and it'll be good.
For what it's worth, the latest versions of npm also ships with [npx][npx] which has the `yarn &lt;script&gt;` thing, and will also let you do things like `npx create-react-app` which would *temporarily* install create-react-app and run it if it's not in `node_modules/.bin` [npx]: https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
&gt; In your argument you create an imaginary person who can't define why deterministic behavior is beneficial. No, I don't. . &gt; Pretty basic stuff. Has nothing to do with the actual question I asked. Please have a nice day.
Don't forget about Crockford's 'JavaScript: The Good Parts' - an oldie but goodie. Skip the diagrams in the front and the rest is a good read. Even if you disagree with some of Crockford's opinions, the book explains ES5 and older fundamentals well.
I think you may have just explained my recent npm woes, cheers.
I know it sounds trivial, but on top of the lock file, I liked yarns commands more - cleaner and less typing
Switched to yarn because my builds were failing for reasons that were apparently super new and a pull request was a massive time investment I couldn't afford at the time. Stayed for the auto-shrinkwrapping and less command typing.
Not a book, but I really enjoyed learncode.academy on YouTube. Guy knows what he is talking about.
A good Javascript exercise is to make a small, simple, single page app with toggling sections. I.e. a menu of 6 pages and when you click on one the 'active' page will change. Beyond this, the JS world is a little too broad that you can learn everything you will possibly need. Keep in mind that the questions are intentionally hard, so don't get discouraged. Another good thing to learn is node-style `module.export` and Webpack, which can allow you to organize your code better.
&gt; No, I don't. Then who says "Um, er, uh." in your original comment? If that was a direct quote, then you didn't properly attribute it. &amp;nbsp; &gt; Has nothing to do with the actual question I asked. Question you asked: &gt; "Because it's deterministic." &gt; &gt; What does that mean? I responded: &gt; ... application is going to get a particular version of a dependency ... 
The thing in line 5 is an `if`, not a loop. I guess you've used setInterval, which calls your "decrementTimer" function repeatedly. That's your "loop".
You're right! I should have posted the whole code. So when my function reaches the end (line 33) it exits, even without a return statement?
Here's the whole code: https://pastebin.com/ybiA1tpS JS begins on line 94.
Yes. A `return` statement is only needed when you want to return some value or when you want to return somewhere in the middle of your function. Without a `return` statement, your function will return `undefined`. function foo(v) { if(v) { return 5; } } let a = foo(true); let b = foo(false); console.log(a, b); // 5 undefined That kind of function is crappy because the type of the return value is inconsistent (`number | undefined`), but it does illustrate what I just mentioned.
Bummer. I was expecting the show intro made with Three.js.
Accessing Reddit at less than 13 years of age appears to be a violation of the terms of service. Please log out until you have reached the required age. https://www.reddit.com/help/useragreement/#p_35
This breaks TypeScript's smarts and you can no longer rename `nested` or `property` and have it propagate through.
&gt; Simple &gt; Enterprise Scale Yup, that's yer paradox, right there.
You'd be doing this in the same way you generated those divs for each card data. You prepare an object in your script, and then you instantiate that object along with its properties everytime you click on a card. On your object, you can do like &gt;var generateCardInfo = function(c){ &gt;this.infobox = document.createElement('div'); &gt;c.appendChild(this.infobox); &gt;} Then you can call it like &gt;var myCardData = new generateCardInfo(container); &gt;myCardData.infobox.innerHTML = cards[targetcard].info; Where targetcard is a variable referring to the card that is clicked. If I understood you correctly, and this is a native js solution
&gt; ReasonML is probably going to be more "mainstream" at the pace its going through, and might be a better choice. Really? I really don't see that many people adopting ReasonML as of today. What makes you say it will go mainstream?
try [VanillaJS](http://vanilla-js.com/), it's the fastest framework on the market (beats React, even beats Svelte!), and it's industry proven (22 year veteran)!
OMG! That's exactly what I told corporate legal, brah! 
Angular, taking a page from ember, has an official cli that takes care of most, if not all, of your development and build pipeline. Yeah there is a lot of stuff going on under the hood. I know because I've set it up manually before the cli was a thing. But it's just not necessary now. Just fire off a command and it does the stuff I need to for me.
Yeah I totally hit my answer for angular thinking it meant angular and not angularjs.
Yeah we shouldnt use semicolons because they are like punctuation in natural languages they arent strictly necessary for parsing so it would be dumb to use them we should write like the Romans did without punctuation the point of our code is to human readable not machine readable and therefore if it was good enough for Italy a couple thousand years ago its good enough for Javascript 
because the closure, try to read at the method only.
&gt; yarn &gt; shear magnitude
how is this even valid syntax? msg here is a function.... why does the function have object members like object1? This isn't even valid unless I'm mistaken. I think you need: msg: function () { return { object1: ... } };
My larger claim is there's a number of contingencies in programming, each approach software development in a different way. They've all always been around, the attitudes towards them have changed. Some of them lead to scatterbrained, bug-ridden, backward-incompatible, convoluted messes. These milieus have become increasingly acceptable. Being late and overbudget has gone from a place of "doing it wrong" to a standard outcome. Thus the members don't characterize it as problems to be addressed but realities to be accepted. The cultural shift has happened where it's ok to not talk to your customers, worry about multi-year operational integrity, have frozen apis, compatibility, prefer stupid over fancy and flexible over proscribed interfaces. Struggling for integrity, stability, and coherent systems as the primary goal is increasingly a losing fight. Claiming "the product is fine as is" or "further changes will only degrade it" or "90% of the time should now be documenting and fixing real-world edge cases and issues" is bomb throwing Instead it's redesigned with new unproven code while legacy (read, in production and business-critical) implementations get abandoned because it's now socially ok to not value things like that. We move fast and break things instead. The fix is to stop trying to be a hero or genius and exercise the power to say "no". There's no shame in leaving alone stuff that works, they aren't "abandoned", they're "finished". Fix the bugs but the design phase is done. Join the revolution comrade. Let's make tools, not toys.
its valid, but it doesn't do anything, as heres nothing passed into the function. this would work if you had observers ona function, but even then, i believe each function substantiates a new set of objects
it's just an example. this isn't the actual javascript I'm working with, I just made a simple example so that the focus is on the syntax.
Sorry but it just turned 21 years!
What do you mean by that? How could yarn not work with private github repos? You don't actually run yarn nor npm on github. The only thing I could see, is that some CI services might not support yarn, but I have no idea how it could be related to private gh repos in anyway. Just curious (i use npm &gt;= 5 myself)
could you be a little more specific? 
It's not really clear from your code, but I suspect you want the msg function to return an object, and then you will be able to access the members of that object. var myObj = { msg: function() { return { object1: "one", object2: "two" } } } }; console.log(myObj.msg().object1); Edit: `default` is a reserved word. You can't use that as a variable name. I renamed it to `myObj` for the example. This would execute the msg function, and you access the properties of its return value.
no, I'm not trying to access whatever the msg is returning. I'm trying to access(and change) the properties of other objects in the function. 
Then that doesn't make any sense. Objects don't exist within a function until it's been executed, and even then they are scoped so that nothing outside the function can access them, unless you expose them via a variable in the parent scope or in its return value. Perhaps you should explain what you're trying to achieve and we can suggest a better approach.
But your example isn't even a valid example.
No, the body of that function is... object key value pairs? That makes no sense... it's not valid function body syntax. He/she needs a return statement that return the object or something, but looking at their comment below sounds like they are way off.
JavaScript the good parts: I learned enough in a few days to be able to start messing around with the language, and enough terminology that I new **what to look up** when I encountered a problem / needed to find something. It's short but it's a great starting point if you find or think you have trouble knowing what you need to look for. EDIT: The author (Douglas Crockford) also has a 3 part video series on Youtube that's like a verbal/video discussion in less detail and missing a few things from the book. Personally I watched all three and read the book when I got back into web because last time I did Node/Angular1 I knew how to do things but I didn't know what I was doing
Why don't you turn some Linux commands into Harry Potter spells. Oh wait.
Lmao. Seriously though I nEEd IdeAs
Oops swapped that.
Purl looks like a handy library, thanks. Wasn't sure if you mispelled perl or curl ;) it takes a url string and gives you everything you _would_ get from the window.location object if that url were loaded. Very nifty!
use getter / setter functions to assign and retrieve the private values. You'll want a different code-pattern. You can also cast the object property as a variable, but then it would be outside of the scope that you want to maneuver in (I think).
You would probably be better off if those values were not in the function, but passed to it as arguments.
Ha!
What are you trying to achieve? This definitely isn't the right way to achieve it.
Hadn't heard of it. Thanks! I like that it is segmented so I only have to use the bits I want.
If you define object1 and object2 as part of the "default" object, like email is, then the msg function can access them via `this` (e.g. `this.object1 = "one"`) and other code can access them through default (e.g. `default.object1` and `default.object2`). If object1 and object2 are declared inside the function, they get created for and are unique to each function call. Every time the function is called, new versions of those variables would get created. If you're trying to access those values outside of the function, then you'd have to wait until the function was called and then somehow get them out of the function, such as in a return. But at that point the function is already over and does it matter anymore? It ultimately depends on what you're after.
Is Yarn optimized for Windows? I had some serious delays on my machine and went back to NPM.
I use Yarn at work, and can confirm it works against private Github repos. Hosted CI service support is doubtful. Thankfully, Netlify had that covered.
Nice, but why
As stated by others here, your syntax is invalid. I think maybe you are talking about prototyping? var msg = function(){ this.object1 = "one"; this.object2 = "two"; //more code }; var msgInstance = new msg(); console.log(msgInstance.object1); This will correctly output "one". However, you can't have a constructor as a property of another object as far as I know.
I'm not entirely sure what the problem was. It might also have been fixed. https://www.google.dk/search?q=yarn+private+github+repo&amp;oq=yarn+private+github+&amp;aqs=chrome.1.69i57j0j69i64.10598j0j1&amp;sourceid=chrome&amp;ie=UTF-8 shows a few of the github issues others created
I've have WebStorm at work, but I don't use it. I've just never been sold on why I need a full blown IDE. VS Code does what I need it to do. I'd love to hear the benefits of moving over to an IDE, but it just always seems a tad bit slow to me.
Totally depends on your skill/experience level. Make a card game, using canvas and opengl or something. Make it multiplayer. Try making a maze where each node exists in its own docker container, and you have to use HTTP queries to get from one to the next. Make a service on each of the big free hosting sites and generate some metrics having them communicate with each other. Think of some awesome native application you used in your childhood and recreate it in the browser. Make an interactive map but have it pull tiles from different providers round-robin style. 
You haven't given that much context over what's going on. If this is what you have: var default = { email: "blah", msg: function () { var object1 = "one"; var object2 = "two"; } } And you want to access `object1`, you can't "look in and take" it. You have to have it willingly "pass it out". Eg: var default = { email: "blah", msg: function (fn) { var object1 = "one"; var object2 = "two"; fn(object1); } } default.msg(object1 =&gt; { // object1 === "one" }); Or try a closure: var x = function () { var _object1 = "one"; var default = { email: "blah", msg: function (fn) { var object1 = _object1; var object2 = "two"; fn(object1); } } return _object1; } x(); // "one" But if you're talking about accessing child properties of objects that exist inside functions you don't control (eg: if you wanted to pull an object from inside a jQuery method), you're S.O.L I'm afraid. And it'll be different if you want reference or value.
I think most people realized that we don't need a 'clear winner', we have 3 major options at the moment (A4, react and vue) and they are solving problems in their own way. They are all pushing our industry forward and to get great innovation, diversity is key. Plus we now all have more experience with all 3 options so it's easier to find out what you should go with depending on your needs when a year / 2 years ago most people where picking sides just because they felt they needed to. Now you get feedback from people who have been working with those stacks for a long time and dust has settled. In terms of builds, I feel like webpack's code splitting and tree shaking are awesome and babel made our life better. As for me, I build my personal projects with react and my company uses Angular 4, and because I work in a startup incubator I also am talking to people using vue in production. We actually are organizing a meet next week to talk about our front end stacks and compare our experiences.
Why did someone spend time on this?? I don't understand...
Alias detection is a big relief for me. I've been working on a relatively large project and relative paths didn't really make sense, so I implemented aliases and the lack of autocomplete or the missing ability to consistently cmd click on something to take me to its source is a pain. Really happy about this! 
Debugging unit tests (individually, even!) was probably the biggest thing for me. 
The bigger the project the more some of the convenience features of a full blown IDE make sense IMHO. Still - try the tools that are out there and decide what best fits your needs. VS Code is also my editor of choice for frontend stuff at work.
Intellij has best javascript intellisense and autocomplete to this day. Tried VScode, didnt even compare to it. But was somewhat nice.
If you're a student and you want to try out WebStorm you can [get it for free](https://www.jetbrains.com/student/).
This. It's the main point I'm using PHPStorm at work, although I don't work on large projects or use version control.
Yeah this is going to favor react developers hugely because Angular devs are too busy updating their DT definitions.
I normally only use WebStorm when I am using a computer from a client, and it starting growing on me. Although you need a mighty fast computer for things to be smooth, it's great to have code completion and debugging. The click to go to function is also a great functionality. But in the end, I rather use Atom/Sublime at home because when things start lagging with WebSstorm it gets pretty annoying.
Actually this was not the name I thought about but your suggestion let me think again since this one is obvious too...
**O**ne Piece!! But Gid30n's guess is so relevant that this one become not so obvious... Let's wait some years and see..
I think you're missing the point here. Maybe you want your object to be returned by the function? Or if you're trying to achieve some sort of data hiding perhaps you should check the Revealing Module Pattern and closures. Can you give more context on the problem you're trying to solve? The example code you've given does not make that much sense to me and we can't help you think of an alternative approach unless you provide more info.
It's not clear whether you want to get data from a website or a database. If you want to get data from a database, and it isn't yours, it needs an API sitting on top. If it has an API go and look at the docs. If it's a website you want data from you need to make a request to the page with the data you want. If it's a search page they might have a query parameter you could put text into, if not you will need to make multiple requests where you get to the initial search page, do a search, then scrape the results.
You don't know JS series by Kyle Simpson. They are 5 or 6 short books that go in depth about how the language works - closures, prototypes, coercion, hoisting, this keyword and what not. All things that we're using on day to day basis but have no idea of what's actually happening under the hood. They've given me a better understanding of the language, prepared me for interview questions and helped me avoid common mistakes and traps. However, I think those are not for beginners. Even though they start from variable declaration and the basics, the books go into much detail and can be overwhelming for a newcommer. If you've got some experience and want to go deeper into the language I highly recommend them.
Do you guys have a power user kind of tip for using WebStorm? 
because i wanted to make it! :D
Reasons why I use PHPStorm/WebStorm: Note: I'm a PHP, Node, JS and Electron Developer and also do some Go stuff. I have two programming jobs so I spend about 12 hours a day in an IDE. I have a baseline 2016 MacBook Pro w/Tb. * Performance is good enough - definitely compared to VSCode. I use Sublime if I need something fast or if I am opening a 15Mb JSON file and need to look at it. * JS debugging is [FANTASTIC](https://www.jetbrains.com/help/webstorm/debugging-javascript-in-chrome.html). * It will tell you what primitive type your variable is so you don't do stupid shit like `"5" + 5` and expect 10. * It will tell you if the var you are using is out of scope, overwritten. * I can run Gulp, Grunt, NPM, Unit Tests etc. from the IDE. I actually rather just have some dedicated Terminal windows for this but it is nice being able to hit a function key and have my app build itself and refresh in the browser. * The conflict resolution in JetBrains products is the [best I have ever seen](https://www.jetbrains.com/help/idea/resolving-conflicts.html) * LOCAL HISTORY of files. Yes I can go back and look at each change I have made to a file for the past week or so, and then do a diff. Really good for those "well this was working two days ago" scenarios when you did some voodoo magic shit and your logic is now broken. * GoTo: class, declaration, file, method, etc. all just works. I click on a symbol and hit CMD-B and I am there. Super fast. I know these things can be achieved in ST3 with plugins, I even paid for Sublime because it is a fantastic piece of software. But then you have dependancies and rely on people maintaining the plugins etc. and I don't want to deal with it. I get where you are coming from, OP. I used MacVim for about a year. But the time that is being saved by my IDE is totally worth the slowdown I get from the extra load on my CPU it imposes.
Well, you can go for one of the following: [grab something from this list](https://medium.freecodecamp.org/every-time-you-build-a-to-do-list-app-a-puppy-dies-505b54637a5d) [grab an API and build something around it](https://github.com/toddmotto/public-apis)
I'll check that tonight after work and make some comments.
It's a website. I was not clear with the explanation, basically, if I type in company's name and press search it opens window with VAT number and official address. I have to check about 1000 names, some might have errors.
Been using PHPStorm for two years now, never looking back. Git integration is great.
Haha, I like that
Can someone give a quick summary of what Webstorm does better for JS devs vs Vscode with the usual extensions? I know Webstorm does a lot more stuff with build tools, knowing about webpack etc. But I'm talking about basic code editing, debugging node/react etc all of which VSCode seems to handle fine. I used Resharper with C# before and loved it. How is the refactoring support in WS (given that JS is not really suited for it) ?
Some things are just done for the joy of it. To many technical matter are simply a means to end, for the job for the salary for the keeping of mortgage payments, but to some it is actually a fun hobby to play with.
I'd say that there are 8 parts on YouTube actually, here's the playlist: https://www.youtube.com/watch?v=JxAXlJEmNMg&amp;list=PLgEN6Yip8UBKt4j7_KJhhAMnggkA-5svC I loved the series, Crock is a very cool and humble guy. Some of the stuff he's talking about is outdated but mainly because he was right. I also disagree with some of the things he says but mostly because he taught me to have an opinion based on my own experience.
Why not collaborating on OSS ? A lot of projects are waiting for dev mind or dev time :)
It'd be cool to roll again and again without the need of reset.
Good catch. Something I didn't think enough of to change. I'll fix that in the morning. Thanks for the input!
Are you using Bash? If you're using open source tools, you're going to have a much nicer time than trying to use cmd. Windows has become a much more attractive developer environment since they added the Linux subsystem.
Use Bash for Windows if you need to use open source tools.
If you use Jira, the task/context integration is amazing. You can quickly switch ticket and get the open files/etc you were using for that ticket open, automatically creates/switches to the branch, etc.
Great read. It is worth noting that CoffeeScript 2.0 is in beta3 with ES6 support. http://coffeescript.org/v2/ We have converted a large CS codebase at work to 2.0 without any big issues. You now have ES6 classes, spread/rest, async/await, JSX, fat arrows, import/export, tagged template literals, splats... We just compile the CS2 code to ES6 code and then continue with Babel/webpack etc.
&gt; it takes a much more reasonable 10s for incremental builds it should be much faster than that, give sbt some more memory (2GB+)
ok, tell me
Thanks, those sound good.
What's alias detection? It sounds like it might be useful for what I'm working on but I've never heard of it.
Learn a bunch of shortcuts. It will improve your speed by so much.
We noticed the same, at least for a while, it seems better now. Then again, nothing is ever optimized for Windows and we had similar problems with npm in the past. 
You can specify aliases in your Webpack config that allows you use consistent import paths. So instead of saying ../../../components/MyButton you could just say components/MyButton. Normally the real pain is just doing it once, and webstorm would keep track of the path, but I really didn't like the look of the relative paths. The downside of the alias is that while it is cleaner looking, you can't always cmd click on a component to go straight to its source. This update should fix that. 
I didnt say mainstream. I said more "mainstream" than Elm or PureScript, which isn't a very high bar. ML itself is a much more commonly used language than those 2, and the interop with the existing ecosystem is pretty top notch (anything is better than Elm there, by design, and tooling is better than PureScript's right now). 
New to VSCode, can you pleade mention what are the "usual" extensions peoole use? It seems to have a lot built in already.
I'm doing my first game and having a problem with the buying function. As you can see on top there are 5 different resources. The game is an incremental game, each time you buy the cost increase. Problem is resources 1 and 2 are working fine. But resources 3,4,5 don't increase on cost using the same code line as the other ones.
A spellchecker.
I don't use VS Code (only VS and Webstorm), but this link was on /r/webdev yesterday: https://medium.com/@0x1AD2/visual-studio-code-treasures-1accae07c60a
Not using VS Code, but see this comment further down: https://www.reddit.com/r/javascript/comments/6o66pv/webstorm_20172_is_released/dkf4301/
+10 for JS debugging, especially node.js This was literally a game changer for me.
Can you elaborate on what you mean by "the usual plugins"? 
Ditch the switch statements and use arrays. You can [get a random element](https://stackoverflow.com/a/5915122/380189) from them just about as easily but they are far easier to maintain. --- Instead of grabbing items individually to show them you can either group them in a div or something or you can give them all a class name and use [Document.getElementsByClassName()](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName). --- This: &gt; &lt;script&gt; document.write(faction)&lt;/script&gt; Is weird. At a minimum you could use [document.getElementById()](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) and [Element.innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) from your main script and just put the (only) script tag after your html elements for now. --- Also just a thought for future projects: Github pages would host this sort of thing and make it blazing fast regardless of how many people access it to avoid getting hugged to death.
No difference I'm afraid :| A large portion of the time is spent in the fastOpt phase.
Take a look at the URL and see if it has a query parameter for search text, if it does then this will be fairly simple! You want something like 'www.website.com/path/to/search?search="my search text"'. Replace the text at the end with your script, I would recommend having a constant like 'www.website.com/search?searchText={query}' then do .replace('{query}', yourSearchText). Once you have your URL you want to send off the request normally, then inside the response you should have a big lump of HTML containing the data you're after. Get a package like Cheerio, put the HTML into it. That gives you a jQuery-like API for getting the data from the HTML while inside a node environment. If you're doing this from a web page, then don't bother with jQuery and stick with native APIs and get the data out of the response as you would normally. At this point you should have the data you need and you can write it to a DB or do whatever you want :) HTH Edit: Forgot to say, if they don't use a query parameter for their searches it will be a bit more tricky, but it should still be possible. You will have to make multiple requests to get the response with the search results in it, but the principle is the same: get a response with the search results page containing your search results, then scrape the data.
Alt + enter is glorious for suggestions. 
Go To definition/symbol/Class/etc is by far the biggest reason I am hooked on WebStorm. I have not been able to match their speed or accuracy with any other editor. I assume it's possible but my experiments have never led to the same results. The tight plugin integration for stuff like Flow and ESlint is also extremely helpful. They are also just on it, something new and interesting comes out and within a few quarters they usually have it integrated. Depending on what type of machine you're running it's overhead might be a non-factor. I run WebStorm and RubyMine at the same time along with a bunch of other stuff and almost never feel it. 
IdeaVIM is the best VIM plugin I have used.
Probably just me, but I actually upgraded to 2017.2 yesterday and could not hit any of my break points with the same config as I had before upgrading. Obviously this made it unusable for me. I immediately had to roll back to 2016.3 (my company's perpetual fallback). 
What version of Scala.js are you on? In latest 0.6.x there's a patch in place that addressed a regression in `fastOpt` performance. I do see a slowdown when a GC event occurs, which happens more frequently the longer sbt session is left open (for me, up to weeks at a time). As an experiment try closing sbt session, re-opening, doing a couple of compiles to get the vm warmed up, and then record `fastOpt` times when making a simple change like add/remove `println("hello world")`. Should be around 2 seconds.
I'm sticking with Yarn as I've also had issues with the lockfile. It really isn't obvious what's going wrong and it's causing a load of hassle that could have been avoided if we just stuck with Yarn originally.
[shift+shift](https://www.jetbrains.com/help/webstorm/searching-everywhere.html), search everywhere, end with '/' to denote directory and it will navigate there in your tree view. - install [code glance](https://plugins.jetbrains.com/plugin/7275-codeglance) - install [.ignore](https://plugins.jetbrains.com/plugin/7495--ignore) - enable viewable whitespace - display your tabs on the left or right
Not sure about books, but John Resig's free uh... tutorial(?) is great for learning some advanced quirks of JS: https://johnresig.com/apps/learn/
http://superherojs.com/ Edit. HTTP
No. Perhaps npm is sufficient for your projects. I'd love to try Yarn, given its various improvements (caching and parallelisation, amirite?); it's just that npm hasn't proven that problematic for me.
Holy shit, I never realised this. That's bad!
Can you share the website, and an example use case?
Most likely. He deleted it already.
$(window).on('resize', checkWidth); is probably what you want.
The site is currently handing out an invalid certificate for the name, so browsers are very likely to complain. The name on the cert is *.github.com so it looks like github pages setup incorrectly rather than something more malicious, but if you want to be more wary the source for the site is available at https://github.com/superherojs/superherojs (as is the opportunity to contribute if you know resources that have been missed thus far).
Thank you. I will try uglifyjs. Anyway, I think webpack should have an option to disable the bootstrap code for some entry points, or remove it automatically for files with no dependencies.
Hi /u/Nareleth, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Try this http://superherojs.com. Without https. Stupid work computer added it.
`pnpm` is superior to both `yarn` and `npm`. Try using them with a large 1000+ package monolith. pnpm blows them away in speed and disk space usage and probably always will. With pnpm every `package@version` uses the same files on disk via hard-linking. Peer deps are resolved correctly too. A lot of thought has gone into it and there are regular releases. It seems like there is less of a place for `yarn` as `npm` gets better, but `pnpm` will always have a place.
I would seriously recommend waiting to update for a little while. Personally I had an awful experience this morning with it. * My git branch widget on the status bar disappeared, still can't get it back... * Indexing slows your computer to a crawl, so forget about using it for half an hour until it's done. * Some plugins broke. (Material UI in particular) * The Toolbar at the top with quick actions disappeared and I couldn't re-enable it. * Many settings, such as color changes, do not apply until your restart the editor. * Even when settings do apply, the aren't always correct and you have to restart the editor again... * Breadcrumbs are at the bottom now? Can't put them at the top, even when I choose the top option and restart. Anyways, if you have issues, just restart the IDE 20 times or so and it'll eventually go away. EDIT: Git Widget is finally showing up now...
In webpack config, you set up an alias for a particular directory. In some projects there is '@' by default for the src folder. So instead of writing import myModule from '../../../components/myFolder/MyModule' You can just write import myModule from '@/components/myFolder/MyModule' Or set an alias of '@myFolder' to src/components/myfolder' which becomes import myModule from '@myFolder/MyModule'
Have you tried blowing out the IDEs cache? It's good to know it's not overly stable, that's a shame. 
For functions that throw exceptions, you would obviously need to catch them if you are going to handle it. But then you should try/catch that specific call right there, not the whole block of code you are writing and try to sort through the types of exceptions later in a single giant catch clasue. The second example doesn't try to use the exceptions for flow control. It merely catches them all without distinction. That would be the correct way to use exceptions. Now, do_something_with_file as it is used in the second example (which is great), would have to do something like the first example internally, but instead of if/else/alert, it would use if/throw. That way it would be much cleaner and completely flat(no nested ifs). 
Why is stolen content and shitposting on Medium such a problem in the JS community? So people can tell employers they have a blog? Look up any framework/library and you'll find 10+ articles that are just the docs slightly reworded. 
You've defined the `checkmark`, `minutes`, and `seconds` as local variables in the `initElement()` function. Those variables won't be visible in other functions. And when you assign a value to the `minutes` and `seconds` variables in the other functions, you're actually creating and assigning variables in the global context. i.e. `window.minutes`, `window.seconds`, etc. Your code fails when `zeroTimer()` tries to increment the `checkmark` variable, because it doesn't exist in the global context. To be precise, it fails when the JavaScript engine tries to retrieve the current value of the `checkmark` variable - in order to increment it. The increment of variable `minutes` and `seconds` in the `decrementTimer()` function doesn't fail because both of the variables are already exist in the global context which was previously created in the `startTimer()` function.
I see what you did there,... &gt;_&gt;;;;
Assuming that the code with the proper syntax is like below... var default = { email: "blah", msg: function() { return { object1: "one", object2: "two" //more code } } }; The object in the `default.msg()` function will only be available after that function is executed. In order to change that object, let the function executes and return, then you'll be able to change the object. One method is to hook the `default.msg()` function like so. //save original function for later use var defaultMsg = default.msg; //override the `default` object's `msg` function with our function default.msg = function() { //call original function and get the object var obj = defaultMsg.apply(this, arguments); //do what you like on the object. e.g. obj.object2 = "three"; //change existing property obj.object3 = "new"; //add new property //etc. //then return the object just like the original function does return obj; }; 
Just to add to that. Not sure if other IDEs have it but creating live templates is the shit. I also like how it comes with prebuilt ones. for example just type itar and hit tab and you got your for loop.
Needs a "used it hated it" option.
A little complex since it is more than pure frontend and requires a little backend. But you could have a db pointing to the url of your pages. Create a call to the backend to get the count of all your images, and images by state or whatever you need, and then display that value at your page. It seems to me to be one of the better and more automatic way of do things.
&gt; As you can see where?
One thing I love (and miss) about webstorm is it's automatic refactoring. If you move a required dependency it will update the path to the dependency automatically in every module in which you require it. 
Sry, posted the img but didn't add the text.
I see your problem. Resources 1 and 2 ate 3,4, and 5. Then ate each other. _Edit: This comment was created prior the the OP including an image of the code (when there was no 1,2,3,4, or 5 to see)_
what version of node are you using? Node renamed the breakpoint control flag. Wondering if Webstorm was setting it incorrectly.
Please explain. The cost is actually working fine, you buy-lose the resources-get stuff, the thing that doesn't work is the cost increase.
Merge conflict resolution is almost enjoyable.
`npx` is a wonderful idea, and if i ever switch back i'm sure i'll use the heck out of it. to me though it's a lateral move for a new set of tradeoffs. i'll stick with the devil i know for now.
If you're into math, [Project Euler](https://projecteuler.net/) is a great site with a ton of byte-sized problems that are fun.
Can you post the code in a pastebin or codepen or something?
Sounds great. Parsing times, especially on mobile devices is just way too high.
We're on LTS, 6.11.1. I suspect it had something to do with our webpack config since they made some webpack changes. Didn't have the time/desire to investigate so I just rolled it back which was surprisingly easy.
You can use a systemJS config for your webpack aliasses. Good it works out of the box now though
Interesting Do you think learning back-end stuff is worthwhile at this point? I've been teaching myself programming for about 6 months and javascript for probably 2 months. If so, do you have any resources for beginners? thanks for the response 
If you keep getting stuck, and can not resolve/command click, set up a systemJS config that mirrors your webpack alias/resolve config.
It's true, jetbrains has the best vim support. It can also use some .vimrc settings and has emulation for [Vim Surround](https://github.com/JetBrains/ideavim/blob/master/README.md#emulated-vim-plugins)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [JetBrains/ideavim/.../**README.md#emulated-vim-plugins** (master → 49ecfd6)](https://github.com/JetBrains/ideavim/blob/49ecfd687967529e2ec10dcc96aee563956d014f/README.md#emulated-vim-plugins) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkfi38o.)^.
Of course it is worthwhile, even for basic things. Everything is a plus at the moment of get hired. I used to check at https://www.codecademy.com/ long time ago and also egghead.io For backend there are a wide variety of options. I would focus on php, ruby or nodejs. You can also check at https://www.slant.co/topics/5809/~alternatives-to-firebase toc reate a db using non relational models (like mongo) without too much coding and access the data directly from your frontend.
I have the all-you-can-eat JetBrains license and experiment with every WebStorm release but always go back to VS Code for JS and TypeScript. It's just so much faster, there's no contest. Looking forward to giving this a shot. If they ever manage to provide a TypeScript experience that's comparable to VS Code, I'd probably go back. When it comes to Ruby, Python, or Java, I'm still a JetBrains fanboy. The IdeaVim plugin is fantastic, the refactoring tools are better, I prefer the way they handle search, I'm a bit more comfortable with the interface, I love the way git is integrated. But holy shit, is it slow sometimes.
I thought `.resize(...)` would also work. Maybe I'm only and haven't used jQuery since 1.5.
FYI, at the bottom you don't need `$(window)` since you already have `$window`. It'll save you some cycles. 
Was very happy to find out about this but it seems the plugin is abandonded and it doesn't work (doesn't log me in even :() 
&gt; words put in some order that has sense when read. Regular code already has this property, otherwise nobody would ever be able to read any code. As I understand, your argument is that organizing tokens in a way that resembles english grammatical structure makes a language powerful. My argument is that this is a superficial view. Let's take the loop example further. In JS, it's now common to use `.map`, `.filter` and `.reduce` instead of `for` loops. Now, one can argue "why in the universe would you write `Object.keys(foo).map(doSomething)` over `for (k in foo) doSomething(k)`? The latter reads far more like plain english!" but there are very good reasons to break down the loop abstraction into categorical higher order functions (namely to self-document intent, restrict ad-hoc mutations, decouple logic, etc). `from 0 to 100` is readable on its own, but falls flat as soon as you start brainstorming even the simplest corner cases. If we wanted to change step size, in Python, that's a concern of `range()` and that's where you go for docs. With `from x to y`, it's really not obvious where the step argument should go, even from a language design perspective. Should it be `from 0 to 100 in steps of 0.1`? `from 0 to 100 stepping by 0.1 as i?` Do I really need to re-type that whole thing twice if I'm looping the same range twice? What even are the performance characteristics of doing that? Do I need to add the step argument in `from 10 to 0`? What happens with `from 0 to 0.1`? Does `from 0 to 'a'` understand what I mean? Also, in terms of language design, this is a *known* concern. There may also be *unknown* concerns. For example, C strings can't really be looped with just for loops because when it was first designed, it didn't account for the fact that with unicode, bytes don't always map to characters, as is the case w/ ASCII. One can wave their hands and say `from 'a' to 'z'` works as you might expect, but then what does `from 'a' to '日'` do? Do we now need a `from 'a' to '日' using charset 'utf-8'` construct? What if I want surrogate pairs? Is all of this syntax going to be part of the documentation for a single looping construct? The pattern I see here is that API is tighly coupled to syntax, which means that every stdlib API addition becomes a language breaking change. That's usually unacceptable. &gt; Trust me. It's far more potent than Python AS GRAMMAR. But...FAR. That's why I get mad. It's offensive, because Python has one of the simplest parsers. Python has a parser. And a interpreter. Today. People use it to do anything from profitable software services to AI research. Sorry to be super blunt but nobody cares about vaporware that thinks it's a snowflake. I noticed you mention somewhere that you live on the streets. In terms of thing to do with your time, I'd recommend staying away from language design. It's **extremely** time consuming (trust me, I speak from experience) and frankly it has little chance to make a positive monetary difference in your life. If you know how to code, I'd recommend getting a job (any job) to at least get a roof over your head. Maslow and all that. 
Can asians be weebs? considering that the etymology stems from "wapanese (white japanese)"
Mithril.js is really simple to understand, it's almost baremetal vanilla JS.
Here you have. There are some comments in spanish arround. https://pastebin.com/G6TxfkBM
use the `debugger` instead of asking reddit.
If you want to get some sort of a solution that would allow you to just update the photos and get correct photo counts "for free", then you will need to have a database of some form and a little bit of dynamic content generation. If you are not yet at the stage when your website is based on a full-blown CMS then the cheapest way would be to create a "poor man's database" in a form of a JSON file that contains an array of your photos for a particular state. This file should be accessed on both single state page and catalogue page, via AJAX for example. The single state page will read this array, iterate over the photos and generate whatever HTML you need to display them. The catalogue page will read the same array and output the length of that same array. Then next time you add a new photo, you will have to edit the JSON file and add the new photo to the array, and you'll get both state and catalogue pages updated in one go. Of course, you don't have to have one file per state, you might want to have a file with a list of all states, containing nested arrays of photos taken in those states for example.
This is great but I now realize I'm reaching way above my head. I'm going to bookmark this comment and come back to it when I get there. Thanks!
Oh awesome thanks for this! I didn't know there were more
/u/Slightlygrilled feels good
Maybe this could work for you. Modify the msg function to allow for an object as an argument. Then return a new object that is a blend of your original object and what was passed in. Var def = function (){ Return { Msg:function (_msg){ Return Object.assign ({object1:1},_msg) } }; (I am on mobile, sorry for formatting)
[removed]
those lists are awesome B)
I'm not sure why but it works. [Here is a codepen](https://codepen.io/christoferpeterson/pen/EXBpbY?editors=0010). When I replace it with the equivalent according to the [jquery api](https://api.jquery.com/resize/), it does not work. 
&gt; For functions that throw exceptions, you would obviously need to catch them if you are going to handle it. But then you should try/catch that specific call right there, not the whole block of code you are writing and try to sort through the types of exceptions later in a single giant catch clasue. Okay, I'll absolutely agree with you on that. I personally like to use exceptions to wrap as little code as possible and then generally I won't use them to wrap large sections of code at all unless the whole thing isn't important to begin with (e.g. an animation or maybe sending back diagnostic info). Otherwise I'd rather something break hard than silently disappear.
Code completion and assistance is much better. That's the reason I switched back (Webstorm -&gt; VS Code -&gt; Webstorm) on my current Angular project. Also integration with VCS is much better. A lot of small things, like local history, the debugger much is better, Chrome integration worked at once (in VS Code it didn't for me). Lots of plugins, templates ... but all those are not so important. As I said, the completion is much better and that's the main reason I switched back. With VS Code I often got way to much suggestions and sometimes it just didn't work (didn't suggest a method or a property which was clearly there - code was compiling and running fine (Typescript)). The only downside is that from time to time the tying is not snappy enough. I didn't figure out why and when (no, not when it's still indexing :-)). Most of the time a restart helps. The perfect IDE would be VS Code with Jetbrains code intelligence. As I've moved to Java with my current backend (ASP.NET -&gt; Node -&gt; Spring Boot), I use IntelliJ Idea anyway. And Datagrip. So for me it's all Jetbrains now, which makes the whole tooling streamlined. They are all quite complex, but powerful.
In my experience, the one heavy part is the initial indexing of the project. After those 20 seconds it's a total breeze even on my shitty laptop.
I'd like to see him talk about whether the patent rider could affect valuation in a private company exit, eg IPO or acquisition, especially in the case of shipped software that is not remotely updateable with a replacement.
TL;DR React's patent clause means nothing because Facebook hasn't filed any actual patents related to React. It's just a tool to preempt the patent-trolls. EDIT: [Here's Dan Abramov's opinion on the matter](https://twitter.com/dan_abramov/status/766210972776337408?lang=en) &gt;(1) Facebook gets sued by patent trolls every month for ridiculous sums of money. &gt;(2) Facebook, to the date, has never yet used software patents offensively. Only in defence against patent lawsuits. &gt;(3) If you don’t intend to use software patents offensively, you have nothing to worry about at all. &gt;Oh, and if you didn’t realize, that clause is limited to patent lawsuits. It has nothing to do with whether you “compete” with Facebook. &gt;And don’t forget the last year’s update. You keep the protection given by grant if FB sues you first. 
Have to agree on the search part, VS code really lacks in comparison. You can set different scopes (to exclude/include certain folders etc..) and can even edit the code in the search popup, it's brilliant. Also, I love the Shift+Shift hotkey for quickly looking up files, didn't manage to make that work in VS code, I use the default CTRL+E there. Still use VS code though, can't beat the price.
Here's a codepen with a running example https://codepen.io/cheapsteak/pen/JJQavr To reiterate the problem for anyone wanting to help, it seems that clicking on "Comprar Horno" does not cause the cost of "Piedra" and "Carbon" to increase edit: solved [here](https://www.reddit.com/r/javascript/comments/6o8qdx/new_guy_here_need_help/dkfsq0x/) 
Didnt know you could do that! "Invalidate caches and reset" within the all settings menu? It all seems to be okay more or less now. 
Javascript already has native string interpolation: const { username, platform } = { username: 'SandalsMan', platform: 'Reddit' } console.log(`My username is ${username} on ${platform}`)
OSS?
The problem is with your javascript errors Open your dev tools, you should see `VM1249 pen.js:65 Uncaught TypeError: Cannot set property 'innerHTML' of null at Comprar` Any code after an execution error is not run. Here is a working codepen (with some debug code I left in that may be helpful for you) https://codepen.io/cheapsteak/pen/NgZLeW?editors=1010 The main thing I added was, instead of: document.getElementById(buy).innerHTML = cost4[n]; I added a guard before setting innerHTML if (document.getElementById(buy)) { document.getElementById(buy).innerHTML = cost4[n]; } This is necessary because when `n` is `3`, buy at some point becomes `buy='cost2['+n+']';`, and there is no element with the ID `cost2[3]` on the page, which causes `document.getElementById(buy)` to be undefined, and trying to set `innerHTML` on `undefined` results in an execution error I should add that this isn't really the way you're supposed to do things, but you remind me a lot of how I first started learning to code, caring not about the code but just in getting something done :) That you managed to get this much done without even knowing to check your console log is immensely impressive, but if you spend a bit more time (but not too much!) learning more efficient ways, you'd get farther much faster 
Not read your code yet, but learning JS I think one of the best things I did was run my code through a linter. Have you been doing that? You might learn a lot about "best practices" etc on JS. 
&gt; (2) Facebook, to the date, has never yet used software patents offensively. Only in defence against patent lawsuits. lol Facebook answers to one authority only, the share holders. So believe me, they will use patents offensively. It's in their share holders best interests to do so.
Yes, I use ESlint. I also just installed jshint and am about to set up the config now.
Same as others - JavaScript: The Good Parts. It's good for all levels and just provides a great introduction to the language. Even if it's getting old now, it's still great because it teaches you the core concepts. I had no experience writing JS at uni but had to do a lot in my graduate job, so I bought the book and I felt confident within a week.
You think a business would do that? Do something shitty in the interests of profit? You godless red
Just super curious why you choose to declare your variables that way, is there an advantage I'm missing?
Just to match the example in the OPs readme.
It's certainly a weak argument, IMO. But FB still can't use this patent clause without any actual patent claims registered with the government. And if they *did* somehow register a (retroactive) patent claim for React, it's unlikely a Judge would award damages on software that's being given away for free under a mostly BSD-3 license.
well, has any open source license been tested in an East Texas court room yet?
[Hopefully we won't be spending as much time in East Texas anymore going forward.](https://arstechnica.com/tech-policy/2017/05/supreme-court-makes-it-much-harder-for-patent-trolls-to-sue-in-east-texas/)
Are you front-end or back-end? As someone who's a front-end developer, yarn has been really great at ensuring a fast and reliable build chain. The need for nesting multiple versions of the same library just isn't as critical here.
I haven't battle-tested the new npm yet, but prior to the newest version, yarn literally worked much faster than the old npm did. Plus, you still don't have to deal with the "nesting hell" that other redditors like to complain about.
stringInject also caters for scenarios where you may get placeholder values back as part of an API response, and you need to inject variables into that response. This is just one example. For constructing strings in the sense that you have above yes ES6 does cater for that natively.
Seriously, use the `debugger`.
would anyone be "shocked" if they heard facebook was suing someone for creating a site too similar to facebook? fuck no. I mean [iirc](http://www.npr.org/sections/money/2016/12/09/504999255/episode-741-amy-and-steve-vs-facebook) they're actually suing someone right now just for violating the facebook ToS and making a site too similar to facebook. 
&gt; I said AS GRAMMAR Yeah, and I wrote like 3 paragraphs elaborating on why I think that's not the case. As someone who's interested in language design, I've actually been in a similar stage as you seem to be now (namely, thinking a lot about grammar without much paradigm/primitive experimentation), and over the years I've seen a lot of people in a similar stage of learning. People at this stage usually think mainstream syntax is annoying/dumb/limited in some way and that things would be better if only we could write code in a slightly different syntax. It's a bit embarrassing looking back, but honestly this was a fairly early stage of learning and a bit of a delusional stage for me. There's no need to be passive aggressive towards "the system" (whatever that may be). You can still be passionate about language design, but keep in mind that Dunning-Kruger is a thing, and that it's possible to have a unrelated (and possibly unchallenging) day job AND on your free time, spend time on language design or whatever project drives you.
&gt; The old scope / pass by reference / value answer I'm not familiar with this, care to explain?
@EasonG: Yep, JXA's a DOA POS and not worth the time, but if you're into JavaScript and Mac Automation then this may be of interest: https://bitbucket.org/hhas/nodeautomation The (recycled) documentation's a bit crap and it's not thoroughly tested so probably still a bug or too, but it's API-complete and its pedigree (appscript/the other JavaScriptOSA/SwiftAutomation) is absolutely rock-solid. I'm loathe to put too much more time into it (I have bigger priorities now), but if someone else wanted to have a crack at getting it out there as a viable alternative they'd have my support.
Shift+Shift is excellent but CMD+P is pretty brilliant when you know the name of the file you're looking for. It's very very fast, I miss it a lot with JetBrains.
I'm also a bit too busy to clean up Apple's messes these days (one of my abandoned projects is full typescript definitions for JXA), but I'd love to take a look! Unfortunately the repo looks like it's set to private. Edit: It's loading now, thanks!
Could someone explain to me why this can't happen: I work for lets say Microsoft (I don't). I develop an awesome site using React. Everyone loves it. Microsoft sues Facebook over a patent that Oculus is infringing. Facebook, obviously, tries to find what Facebook patents Microsoft might be infringing. What about React? I get email from my (Microsoft) lawyers telling me to immediately cease React usage. 
Perhaps I didn't glean the reason from the article, but why is East Texas a favorite district to sue in?
As the article points out, Facebook hasn't filed a patent claim on React. Essentially, it's a patent rider without a patent.
We were closer to a clear winner last year. But as soon as things get simple, people end up having some free time to spend on bikeshedding :) Joke aside, 12-16 months ago, React/Redux looked like the "one and only", but now Angular2 made some headway and VueJS is now pretty popular. The biggest progress though is that we're now at a point where we've more or less standardized on a package manager, a build tool, and most of the big name frameworks will do the trick no matter which one you pick. So go ahead and pick React with Redux or MobX, or VueJS, or whatever. Use npm and webpack. Use Babel and/or TypeScript. You'll be fine for a few years. The one place where things aren't stable at all is CSS land. None of the mature solutions are slam dunks, and the ones that seem really good are very new. That makes things a lot harder.
regardless of which side of the semi-colon battle you're in, standardjs isn't really an argument. It's more or less just a reasonably popular all in one preset for eslint with a very SEO friendly name. Its not like its the "official" javascript standard. It doesn't even have a majority market share compared to alternatives (at least based on npm stats). Not saying its bad or anything, but linking to it isn't a very good rebuttal (the stuff you linked below is better)
Like with everything in software engineering, the problem is you end up having to deal with other's code sooner or later. Unless you only work at startups you created yourself, only work with your friends, and never use Github. So yeah, people will care what others do, because it affects them.
The thing that jumps out at me is initial readability. Looking at it I'm feeling a bit overwhelmed. Learn to break your code out a bit more, follow a style guide (e.g. https://github.com/airbnb/javascript). Set yourself a limit of characters to not go over on a line also. Look at things you're doing repetitively (e.g. sending messages) and split them into helper functions. Prefer to have clear defined export locations, if you have multiple exports in a file then do at the bottom ``` module.exports = { foo, bar } ``` If you're only exporting one file then `module.exports = function ` suffices, there's no need to add a method to the export for a singular function. Attempt to standardise your coding style. Read through other projects (I've got a basic twitter app here if you're interested https://github.com/echoes221/twit-ten) and re-visit your basics. I feel from looking at the code you're playing around with async/await, promises and some higher order functions without having a solid underpinning of the code base itself. Honestly, just keep plugging away, optimising, seeing how things can be done better. It takes time, keep at it!
Don't hate, it's the only one I knew of.
This is what I get from this. The patent clause in React blocks patent trolls from filing a patent for React, right? So, in reality, the patent can only cause problems if and only if FB files patent for React. Am I understanding it properly?
Thank you for posting this. Mozilla is presenting their proposal at the next TC-39 committee meeting next week. I'm looking forward to hearing committee reactions
There's also an FAQ at the end of the [document](https://github.com/syg/ecmascript-binary-ast/blob/master/README.md) and some lively discussion happening on Twitter and in GitHub issues too
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [syg/ecmascript-binary-ast/.../**README.md** (master → cb032b2)](https://github.com/syg/ecmascript-binary-ast/blob/cb032b20ecf7d92bde21d18ed4656d62ed1dca9c/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkg41a9.)^.
I trust him not to use them offensively not because he's a good person(lol), but because he's starting to care about his PR a lot. I imagine the reputation is worth more to him than a few million he'd get from lawsuits.
how do you know if that is true? How do you know if Facebook hasnt filed any patents for all of its open source projects with same patents like react native, graphql, relay, jest, ... Im am 100% sure they have, because they should and otherwise they are dumb. ive worked for a big tech company and they want us to file a patent for little stupid things. so zero patents for projects like react native??? haha no way. u must be really naive or are on facebook's side for some reason.
im sorry but you must be a student or have zero experience in tech companies. i have an they want us to file patents for every stupid little things and you dont think Facebook filed any patents for big, popular and innovative projects like react, react native or graphql?? there is no way that is true. absolutely zero.
I didn't downvote you =/. Using Notepad++, I actually don't know how to use a debugger, will try to learn.
Patent claims are public. You can't claim a patent in secret.
does it matter if offensively or defensively? of course its worse if offensive but defensive means that you cannot ever sue Facebook. If you are the next SnapChat and Facebook is trying to copy you over and over and you cannot sue Facebook if you use their opensource software . how is that ok?
so u believe they actually have zero patents for them somehow? what is your source that facebook has zero patents?
The U.S. Government.
Worked fine on this way =). Thanks But I still don't get why I got that problem. var cost2 =[0,0,10,25,0,0]; cost2[3] is supposed to be 25. Problem may be cost2[1]=0. But I still think that 0 is not undefined.
have you searched them? and do you think they will put React in their patent titles?? lol 
As far as I can tell East Texas has minor procedural differences that make cases harder on defendants (e.g. harder to force quick dismissals) and so increases the pressure to settle out of court. https://www.eff.org/deeplinks/2014/07/why-do-patent-trolls-go-texas-its-not-bbq
People have every right to worry about the license. Take a look at [this comment](https://github.com/facebook/react/issues/10191#issuecomment-316380810) on GitHub. It explains one of many possible scenarios that can happen with this broad patents clause by React. . I don't know why /r/Existential_Owl is trying to dismiss this issue, but surely ASF banned using React because of its license+patents. So actual lawyers don't like React's license. It is a fact. /r/Existential_Owl, are you a lawyer? You must not be since you are in this sub, so stop acting like one.
Because we've already looked on the [US Gov't website](http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=0&amp;f=S&amp;l=50&amp;TERM1=facebook&amp;FIELD1=AANM&amp;co1=AND&amp;TERM2=&amp;FIELD2=&amp;d=PTXT)? Look for yourself if you really think there's some big conspiracy
Are you saying u read all 800 patents and tried to find which ones apply to which open source library from Facebook and concluded there are no patents for all of Facebook's OSLs? wow. are you in a lawsuit with Facebook? Otherwise you must not have a time for it. 
Does the license actually say anything about *Facebook's* patents? I was pretty sure it was about *any* patents that Facebook is sued over. 
Sure, but in a situation like that there should be a project/company style guide (which is pretty easy to do now with `eslint-configs`), in which case personal preferences don't really matter as you should just follow the style guide set for the project/company.
&gt; (2) Facebook, to the date, has never yet used software patents offensively. Only in defence against patent lawsuits. North Korea, to the date, has never yet used nuclear weapons offensively. They have it only for defensive reasons. It must be all okay then.
for those who don't know. you can exclude project folders from being indexed and avoid having the contents appear in searches. nice to do this with build folders and npm_modules folder. will save a lot on indexing time. 
You have said effectively nothing. If Facebook has never yet used software patents offensively, there is no logical reason that they would start now. Every business since the advent of stocks and shareholders has had to answer to its shareholders. That doesn't automatically mean that that same company will use software patents offensively- in fact, I would posit that those two things are completely unrelated. And given that Facebook has made more money than I can possibly envision without yet using software patents offensively, I would think the shareholders, being logical people who have a share in a company with inordinately large amounts of money, will support the continuation of that trend. This patent clause is only coming up in the news because of the whole issue with Apache. Nothing has changed and everybody on Reddit and HN and the Internet in general jump^ to completely illogical conclusions because it's sensational to do so. From a logical perspective, the only reasonable prediction that I can see is that nothing will change legally. Other JS frontend view libraries might get more users and new ones might come out to try and fill the void for people who don't want to use React because of the patent clause. Apache and other important devs and corporations might have some migration struggles. It'll definitely be a major topic of discussion on Reddit and HN for a while until people stop caring about a non-issue. But the article author is quite correct in calling the patent clause a "paper tiger".
X-Post referenced from [/r/learnjavascript](http://np.reddit.com/r/learnjavascript) by /u/jeanlaf [Web scraping made easy by NickJS](http://np.reddit.com/r/learnjavascript/comments/6oc0p6/web_scraping_made_easy_by_nickjs/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Open Source Software!
? We're talking about the license for React. Other technologies would be under their own licenses. Facebook published React under the BSD-3 (adding in the patent rider amendment). They can't just pull permission out from under you unless you're in violation of either the BSD-3 or the patent rider.
First of all, because it only applies to patent suits. Just because Facebook Messenger is a Snapchat clone these days doesn't mean the patent clause will ever be invoked. Second of all, because, as has been said plenty of times, no judge in the world is going to award a patent infringement case on a freely-available BSD library.
[This looks like it might be a GraphQL patent](https://www.google.com/patents/US20150161199)
That's not a patent. The patent clause doesn't apply. Your argument is irrelevant and you should have read the article. This kind of sensational, disjointed thinking is exactly why the article needed to be written in the first place.
No, I'm not saying that. The community has, hundreds of people and dozens of law firms and they'll all tell you the same thing. 
Dude, what part of "a licensed lawyer who makes more money than you're worth to know this shit like the back of their hand" don't you understand?
North Korea has never, not to my knowledge, open sourced their nuclear missiles under a freely-available BSD license.
Have you read all of them? No? Then shut up.
so you believe this redditor over lawyer team on ASF? haha. I pity your life.
Idiot spotted
Yeah cuz lawyer team of ASF are dumb and paranoid right? And you also think no patents now means no patents forever right?
If only there were some sort of technology that allowed you to search pages on the internet quickly and efficiently. Hey, /r/javascript, do you have any ideas?
Oh wow, I feel so horrible. My entire life is so pitiable because I have a goddamn opinion. No scratch that, I have an educated judgement of facts that cannot be disputed, unless you'd like to dispute the basic integrity of the US judicial system. God, I hate trolls.
Yeah cuz they will put react on their react related patents. you must have not written any patents in your life
Pro tip: you need to use /u/Existential_Owl to summon a user, not /r/Existential_Owl. /r/ refers to subreddits.
You misunderstand how patents work. They don't apply retroactively before the filing date
Are you five? Because this is an adult subject. You don't just try to debate US patent law and then pull "idiot spotted" because you don't have any actual counterargument.
It's not exclusively about profits but what the shareholders (the owners of the company) want.
I called u idiot cuz u r one. Is that so hard to understand for idiots like you?
yea, no you're right. don't judge a company by their words and actions, just trust them implicitly and denounce anyone that questions them. i was going to cite instances like Oracle vs Android as textbook examples of **exactly** why this is a problem, but your stance is so moronic i don't see the point. go ahead and build your platform in Facebook's back yard. idc. 
but.. but.. they said they searched and there were none!! how mind blowing Facebook files patents on open source projects?!!
https://github.com/syg/ecmascript-binary-ast#motivation those stats are crazy. i wonder how much of it is just swallowing of huge dependencies rather than actual app code.
/u/Existential_Owl, /u/IamCarbonMan can you explain this?
Yeah, that for sure looks like a GraphQL patent as far as I can see.
and they want profits :p
which has the same license+patents format that community is concerned about. or do I have to explain how these things are related?
You can't apply a patent grant to a non-patent case. I don't get what's so moronic about that. I'm not judging by Facebook's words, I'm judging by how patent law works.
I'm sure that pokes a small hole in the one argument about Facebook having few patents that matter in this case. I'm still fairly certain that have no patent on React, which is the primary worry.
Yep, they have 2 billion monthly active users but they're just desperate for the money they'd get from suing our React powered brochure sites.
No, that's not the primary worry. Community is not worried about whether React has a patent or not. They are worried about what Facebook can do in all scenarios with their open source projects and their patents which are not standard open source licenses. This is bigger than React. It sets a precedent whether Facebook will continue using the same license+patent for their open source projects. Currently they are all over the place not only React.
No one forces you to use React, which is exactly what started this whole thing. Apache will no longer be using React or other projects with BSD+patents licensing. If there's no patent on React then FB can't do anything to you in relation to React and patent cases. That are held to the terms of their patent grant and patent law in general. If they release other libraries in the future that have questionable licensing and usage terms, then people will have to evaluate those in the same way. The question that is currently causing all this ruckus is "Should I be worried about using React because of the implications in a possible patent suits?" The answer to that question is no.
A better analogy would be Israel's Iron Dome... But the problem with analogies is you're basically always comparing apples and oranges.
ScalaJS 0.6.18 first build: &gt; fastOptJS [info] Compiling 1 Scala source to /Users/trogdor111/project/web/target/scala-2.12/classes... [warn] there were 8 feature warnings; re-run with -feature for details [warn] one warning found [info] Fast optimizing /Users/trogdor111/project/web/target/scala-2.12/racebase-web-fastopt.js [success] Total time: 28 s, completed 19/07/2017 11:35:24 PM Later builds: &gt; [success] Total time: 10 s, completed 19/07/2017 11:39:40 PM This is on a mid-2015 i7 mbp. I'll have to give it another try on my old sandy bridge linux desktop at home, I do recall it being somewhat faster at this. 
That is the worst argument and the worst mindset to have. You can apply that argument to anything in this world and have zero constructive outcome. You don't like the president? No one forces you to live in this country. You don't like your work environment? No one forces you to work for the company. You don't like how Facebook is changing its privacy policy? No one forces you to use Facebook. People want to use React in their projects. ASF wants to use React in their projects, so they are asking Facebook to change it. Are you seriously going to tell them that no one forces ASF to use React? People want changes and they are voicing their opinions, and that's good thing to do. That's how democracy works.
Have you heard of a company called Sun? It got bought by Oracle who started suing everybody and anybody who used Java. Believe me - things go to shit very quickly in the commercial world. 
You talk about opinions. But this isn't a matter of opinions, it's a matter of law and facts.
Wow that language looks way too verbose. I had a lot of trouble visually parsing what was going on because of a lack of punctuation. I really don't understand the push towards verbose languages. It's just so much quicker to see blocks when you're not reading everything.
[Facebook has hundreds of patents](http://stks.freshpatents.com/Facebook-Inc-nm1.php) and the lawyer who wrote the article only did a cursory search to see what might apply to react. An exhaustive search would be very time consuming, so there is no guarantee that Facebook has zero claims covering react. The patent licence is applied to all of Facebook's open source software, not just react. So even if they really don't have anything covering react, there's a good chance that a company using react might also be using some of Facebook's other software that may be covered by some claims. The patent licence serves 2 purposes. 1. It gives companies using Facebook's software an assurance that Facebook isn't going to sue them offensively for patent infringement. If the patent licence wasn't there, then companies would have no guarantees at all. Facebook could theoretically sure them at any time for infringement. 2. It leaves Facebook with the option to sue defensively for any patents they do have. Without the explicit patent termination clause, it it might weaken Facebook's case when suing defensively as their opponent might claim some kind of implied licence to use the patents from the BSD licenced software. (I am not a lawyer.)
just put `debugger;` in your code where you want your breakpoint. When the `js` engine hits that line it will do all the magic for you and you can step over your code and see what is happening.
The Angular CLI is a fantastic tool for getting a project up and running in a few minutes. But more important, we now have a standard comprehensive setup for building web applications. 
No mention of RxJS? Seems surprising.
Careful. I got downvoted to hell for saying this.
&gt; They can't just pull permission out from under you unless you're in violation of either the BSD-3 or the patent rider. Or if you sue them. Look at the Microsoft/Oculus example mentioned.
Another thing you can do is this: var prop = 'name'; console.log(data[0][prop]); // also prints "john" So if you want to access a property of an object dynamically, you can use the square brackets.
I made rilti.js, rilti means rhythm in Lojban. it's a small vue.js-like super minimalist library for making elements efficiently, dom manipulation, webcomponents and more [rilti.js](https://github.com/SaulDoesCode/rilti.js) [rilti-todomvc](https://github.com/SaulDoesCode/rilti.js-todomvc) Worked real hard on this project/former-project that morphed into this, 3 years of learning and face palming. It's my first "real" project.
Your BSD license is not revoked, solely the patent license which is protecting no patents 
My understanding is that the license to use the software is revoked if you sue Facebook for any patent they hold. It's right there in the PATENTS file. So if Microsoft you sue Oculus for misusing their patent, Microsoft's license to React is revoked.
The article says the license only applies to the patent license. 
That is pretty slow, how large are your `fastOptJS` and `fullOptJS` binaries?
Somehow I suspect when giving actual legal advice and not 140 characters of "this is not legal advice", real attorneys will advise you of your legal obligations under the license as it is written and the consequences to your business under different scenarios, not "oh, they've never done that before so it's all good". Edit: Developer, not lawyer, but have had multiple legal teams at various customers flat out tell us that React isn't on the table over the last several years. Some haven't, and we've built some nice things with React. But to pretend that this is all hysteria from ignorant devs is dishonest. 
7.5 MB fastOpt, 2.3 MB fullOpt. Project itself is still quite young, and therefore quite small still. Dependencies are scalajs-react, scalacss, cats, circe, and scala-java-time.
IMO, simply "yeah but they COULD do it" is the weakest argument. Simply asserting that something could happen and then acting like everyone should be actively avoiding the thing that *could* happen is just a weak superiority complex. Is it likely to happen? No, it's not. We all know that. Should anybody be discouraged from making a lot of money developing React applications because it *technically could* happen? Fuck no.
And there you have it: what others thought (the people who picked the style guide) ended up affecting them. Thats why people care about what others do. Because then they have to do it too.
Don't tell me what to do /r//u/Existential_Goat!
 disabledEvents: ['CHANNEL_PINS_UPDATE', 'USER_SETTINGS_UPDATE', 'USER_NOTE_UPDATE', ..... (very long line) this could be rewritten as: disabledEvents: [ 'CHANNEL_PINS_UPDATE', 'USER_SETTINGS_UPDATE', 'USER_NOTE_UPDATE', ..... (every event in separate line) There are other places with long lines that could be rewritten like this. And FYI template strings (closed in backticks) allow for new lines also, so I don't know why you wrote: client.shard.broadcastEval(`const { RichEmbed } = require('discord.js')\nthis.channels...... (very long line) if you could write: const code =`const { RichEmbed } = require('discord.js') this.channels...... (string divided into lines) &gt; This code feels repetitive and ugly, if after every `if` block there is some amount of the same code you could just pullout this code out of the `if`. If after each condition there is `const haha = setInterval(intervalFunc, 30000)` you just pull out this line and put it after all `if`-s like this: if (something) { } else if (something_else) { } else if (something_else_else) { } const haha = setInterval(intervalFunc, 30000); you don't want to run this in a condition. BTW it's classic rookie mistake (putting duplicated code to blocks in ifs). I'm not sure why so many people can't see that there is a very simple solution for this. Second thing. If you have same code logic but different data/params, you could instead of repeating logic (as you do now) just parametrize data via variable and share logic. So instead of writting this in every conditional block: msg.author.send(`some text, different in every block`) .catch(e =&gt; { return clearInterval(haha) }) you could pull `msg.author.send` out of conditional blocks, and put them in some sort of variable assigning instead, like this: sendingText = `some text, different in every block`; and then call msg.author.send(sendingText), after all ifs. 
Absolutely not. 
I haven't had the opportunity to check out GraphQL yet.
It's an important thing to look into, definitely, If all the big name users of React start jumping ship, I'll be hopping into the lifeboat along with them, that's for sure. 
Yeah, pretty much. If some of the biggest household names around (like Netflix, Walmart, and Twitter) don't seem to think there's a problem with the patent rider, then I'm not too worried, either.
Sourceforge, Slashdot, Atom minimap...
The software is as far as I understand it covered by **one** license, not one for the copyright and one for the patents. The PATENTS file is read as an extended requirement to the combined BSD+PATENTS license. (Which is always referred to as the BSD+PATENTS license) As the PATENTS file says: &gt; Facebook, Inc. ("Facebook") hereby grants to each recipient of the Software ("you") a perpetual, worldwide, royalty-free, non-exclusive, irrevocable (subject to the termination provision below) license under any Necessary Claims, to make, have made, use, sell, offer to sell, import, and otherwise transfer the Software. ... &gt; The license granted hereunder will terminate, automatically and without notice, if you... I think this file quite clearly says that the license to **use** etc the software is 100% dependent on you not making any patent claims against Facebook, and if you do, that license to **use** the software is revoked. The author apparently reads it as two separate and independent licenses, I don't.
And you make this brazen claim why?
BTW, you have to have your Dev tools open for 'debugger' to break.
Because: 1. It's obviously true 2. The plain language of the relevant license document spells it out clearly 3. The official React license FAQ answers it (fourth question [here](https://code.facebook.com/pages/850928938376556)) 4. It's been explained many, many, many times (eg, [here](https://www.reddit.com/r/javascript/comments/6nljvd/apache_foundation_bans_use_of_facebook_bsdpatents/?ref=search_posts), [here](https://news.ycombinator.com/item?id=12108158), [here](https://www.reddit.com/r/webdev/comments/4t6vjo/your_license_to_use_reactjs_can_be_revoked_if_you/), [here](https://github.com/facebook/react/issues/7293), and basically every other time this topic gets discussed. 5. Plus, it's *spelled out explicitly in the article we're discussing*. &gt; That is, triggering the strong patent retaliation clause is limited to the patent grant itself. Thus, the BSD-3 license remains in effect. How brazen!
&gt; The software is as far as I understand it covered by one license, not one for the copyright and one for the patents. Why on earth would you think that? That's not how licenses work.
legally, most are required to
Perhaps! I was just relaying what the article had said. I would email the author if I were you to discuss your thoughts though! 
The problem is that it's also being used to getElementById, and you don't have an element with that ID.
 for (let a = 0; a &lt; Boxes.length - 1; a++) { for (let b = a + 1; b &lt; Boxes.length; b++) { compare(Boxes[a], Boxes[b]); } }
While nobody seems to have found any indication that there are actually patented IP included in React, why should anyone trust that this will always be the case? It also doesn't clear up libraries like Immutable, dependencies of other projects that devs might be using and not even be aware of, dragging them into this mess. Second, the claim that "Facebook only uses its patents defensively" does not draw a distinction between defense against trolls and defense against people who genuinely want to protect their IP. Facebook is a gigantic company. They buy other companies, they experiment in different areas. It's inconceivable to me that Facebook has never been sued by someone because they, deliberately or not, infringed on someone's patent. Those people would _still_ get caught up in this. So much of this defense of the patents clause rests on the idea that it doesn't have teeth NOW, that Facebook isn't trying to be the bad guy NOW, that this is to cover their asses for some future event. "We're fine, trust us! We don't aim this weapon at you, we only aim it at bad people!" That is just not a compelling argument when you're talking about an outrageously huge company having potential leverage over your or my business. The patents grant would not be in there if Facebook thought it didn't have teeth or didn't intend to use it. If it was worthless or harmless, its scope would be restricted. While I do not doubt the sincerity of the brilliant React developers who probably wish this wasn't an issue so we could instead be stoked about 16.0.0 and beyond, I think it is naive to not be extremely uncomfortable with this whole thing. I'd LOVE to be wrong about this and I apologize if I am misunderstanding any of the details.
history of javascript can clear some questions....https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript 
Hi
I need to read more on loops. I would have never, in a million years figured this out on my own. I'm console logging (a,b) just to see how it works. For some reason the thought of doing a loop in a loop makes my mind go blank, don't know how to explain it. Appreciate this a lot!
It has been minified to increase loading speed. Minifying is common practice in web development. It's basically a script that goes through your code an removes spaces and line breaks, it also renames variables to letters
That's not the original source that the programmer would look at or edit, that's been generated automatically by a minifier that throws away everything nonessential. In the actual source there would be comments, sensible variable names, whitespace, etc. 
jQuery is just a library for javascript written in javascript. It is probably the most mature and widely used one out there. document.queryselector is a relatively new thing in javascript and basically does the same thing $ does. jQuery is just how people queried the DOM before this newer javascript implimented it. You could write var $ = document.queryselector; and behold.... "jQuery". Note: did this on my phone so I'm not sure if that would work but it's not too far off I'm sure.
Zuck owns about 30% of Class A shares. The Board could be rid of him tomorrow if they honestly believed it would be better for shareholders.
the 3 core benefits of jQuery in the past were: 1. handling a vast array of cross-browser bugs 2. doing so in a nice short syntax 3. a vast ecosystem of ready-to-use plugins was created on top of this base. today... 1. is no longer relevant. 2. can be handled by much smaller and faster libraries [1],[2],[3] and many others. 3. is an open question, but there are plenty of libs that replicate jquery plugins that don't require a jquery dependency. [1] https://github.com/philpl/sprint [2] https://github.com/finom/balalaika [3] https://github.com/finom/bala
Following emojis are now fully supported: * Twitter emoji * Messenger emoji * Google emoji * Facebook emoji * Emojione emoji 
I'm not sure of the actual share breakdown but he has majority of the voting power, so he controls the board and cannot be voted out. &gt; Because Mr. Zuckerberg controls a majority of our outstanding voting power [...] &gt; &gt; - [April 2017 proxy statement, page 13](http://d18rn0p25nwr6d.cloudfront.net/CIK-0001326801/9455e35f-a8eb-4ea9-9264-44889de58b05.pdf)
If this list grows you might want to consider baking 'finding objects' in. You could have a look at Maps and Sets or making a wrapper collection object. This way, you can already make an index during write-time, so you have a performance increase when reading.
FWIW Facebook's lawyers say the same on the first point: https://code.facebook.com/license-faq - the patent grant (license) is in addition to the copyright license granted by BSD.
You do realize that his comment was sarcasm right?
I like it :)
It's probably a bit harder to understand the way I did it, but it's the most efficient way. It's common to do this: for (let a = 0; a &lt; Boxes.length; a++) { for (let b = 0; b &lt; Boxes.length; b++) { // if it's not the same box if (a !== b) { compare(Boxes[a], Boxes[b]); } } } But in that case you end up comparing the same boxes twice (1 vs 6, then later 6 vs 1 etc.)
You would switch to preact, that's 2 lines of modified code and let the lawyers battle it out while you keep developing your awesome website.
Change the line console.log(this.todos) to console.log(JSON.stringify(this.todos)). push alters an array in place and console.log preserves the object reference, so you can explore its structure interactively in the development tools. But once you do that the object has been changed already.
I ran your code and it works fine
What about future patents that have not yet been filed?
Don't write loops. They're bug-prone and hard to maintain. Boxes.forEach(box =&gt; Boxes.forEach(otherBox =&gt; compare(box, otherBox)); );
You think someone would do that? Just go on to an internet message board and tell sarcastic jokes?
You can search for authors (sourced from GitHub contribs). 
Future patents can't retroactively apply to existing versions of React since React itself would serve as prior art and likely get thrown out in court, if they didn't get rejected by the patent office first. Future patents could theoretically apply to new features in a future version of React.
why the hell would you do that..when you have standard partial application and all the FP libraries which deals with curry ..just have a look at ramdas curry 
It feels like something that can be achieved so easily in user land is unnecessary as a language feature. The Ramda example is incorrect in that all functions are curried and it provides a placeholder arg as well. 
After working with Ruby in the last couple of weeks, I sure hope JS doesn't take the path of only adding syntactic sugar going forward. I swear I now have syntactic diabetes from all Ruby sugar. Things like partial application are rarely used in codebases enough to justify adding them. I love having functional ideas promoted but I'd much rather focus on commonly used methods.
You can use the native `new URL(str)` instead.
That’s inefficient, it checks the boxes against each other twice -which could possibly lead to bugs/unexpected behaviour- as well as against itself. I’d favour forEach when possible, but it’s not really the tool for the job. I don’t think they’re significantly more bug prone or hard to maintain, they’re just a bit verbose when you don’t need control over the index.
Ah okay, that makes sense. Thanks. &gt; Future patents could theoretically apply to new features in a future version of React. This could still be a major burden if you can't update your application to the newest version of react. On the other hand there would most likely be a fork in this case...
I am really impressed with the team's diligent work to stay on top of things and not end up as a framework of yesterday, like Backbone or Knockout. Haven't used Ember for anything myself, but I have played around with Glimmer a bit and quickly read through the FastBoot docs. I like the direction where they are going.
Even so, the React patent grant explicitly *protects* you from Facebook's patents, unless you use your own patents offensively.
Why would there be a fork? If they're Facebook's patents, then they'd be covered by the same patent licence. If they're a 3rd party patent, then Facebook would likely remove the infringing code if there was a successful claim against it.
The problem is if Facebook has a claim over React then they could even more easily go after Preact. In fact you may have less safety with Preact simply because of this.
I meant that if - in the worst case - Facebook puts out a new version of React that has a new feature that is covered by a one of their new patents, the community would most likely fork react excluding the patent encumbered feature. Not really important, more a theoretical reflection on what would happen.
Forgive the potentially dumb question, but why don't we serve an LLVM-style intermediate representation? Then you don't need a heavy parser or JIT.
While I do understand the appeal of it, this exact behaviour could be accomplished by doing this: function add(x) { return function (y) { return x + y } } console.log(add(3)(4)) // 7 const addOne = add(1) console.log(addOne(5)) // 6 const addTen = add(10) console.log(addTen(2)) // 12 You can even wrap existing functions: function add(x,y) { return x+y } function add_partial (x) { return function (y) { return add(x,y) } } console.log(add_partial(2)(3)) // 5 const addOne = add(1) console.log(addOne(5)) // 6 const addTen = add(10) console.log(addTen(2)) // 12 Which, if you look at it, is fundamentally the same, just replacing the algebraic expression with a function call. Sadly you cannot reuse the function name add though, so any transpiler would have to keep track of the partial names. The proposal provides nice convenience, especially reuse of the function name.
💩
If that's the case the patent clause shouldn't be there at all.
&gt;While I do understand the appeal of it I don't think you do. You don't even seem to understand exactly **what** it does. Firstly, you're only applying partials at n=1st argument. Sure you could create a different abstraction if you wanna apply partials at n=2nd or 3rd argument. But secondly, it's not about *just* accomplishing the behavior, which by the way, could be done much more simply using the traditional bind syntax `addOne = add.bind(null, 2)`, instead of creating functions like you have (you might also need to consider "`this`"). It's more about accomplishing it in a clear, concise, and flexible way. With this proposal you can apply partials in just 1 word while having the flexibility of applying partials at any argument position. 
People are getting antsy about the React license though.
With the introduction of arrow functions that change the fundamental nature of "binding" (`this`), it's only natural to introduce a new "bind" syntax that takes this into account... This syntax is perfectly inline with how arrow functions work, eliminating the awkward `.bind(&gt;null/this&lt;, ...)` syntax. Afterall, you're not really "binding" anything. 
&gt; You godless red Russian, or Republican? I get confused about the difference these days.
But the BSD license is useless if the patent grant is revoked because it means you still can't use it. 
The good thing about `React` is that you start from a small set of modules and include other modules as you need. Ember is also moving in that redirection combined with its convention over configuration principle. Virtual machine of [Glimmer](https://glimmerjs.com/) outshines the Virtual Dom of `React` in terms of speed and size. In the near future, one can start from `Glimmer` and move all the way up to Ember as the application grows in complexity. Ember has a great plugin ecosystem powered by its cli. If you need server side rendering, just install the `fastboot` plugin with a single command and you are good to go. These create a compelling story for the developers who value simplicity combined with developer happiness.
What? Partial application &amp; function currying is bread and butter of functional programming. What are the other methods you're thinking about?
I encountered a situation where I had to use invalid custom attrs, so I see how it might come in handy now. This seems to do the trick: https://stackoverflow.com/questions/21648347/true-custom-attributes-e-g-microdata-in-react/33860892#33860892
And the vast majority of the time what they want is profit, because that means the worth of their investment is more likely to grow and/or dividends. Other times it is generally profit *and* something else (maybe they'll accept less profit in trade for the something else) where something else is more likely to be a negative control (don't support X or I'll pull my investment) than a positive one (do Y because it is a GoodThing™).
What's the greater goal? There may be a better way to do what you are trying to do then to compare the boxes
Forced label positioning. Basically for item loot boxes (Path of Exile does it good for example)
Ah I see, you're trying to prevent collision?
I would not waste time learning JQ in 2017 if i was you, as well as making applications with dom-api. JQ was once needed, but that was many years ago (2010...ish?). As for the dom, it's good to know the basics no doubt, but you would not come far making complex applications with it. I'd probably start by learning Javascript, especially the modern variant (es6 and up). Then move on to a framework like Angular, React or Vue. They're all smaller than JQ and a lot more powerful. The dom plays about no role in most of them.
Yeah, I think. They just cannot be overlapping each other, but I figure it's still going to be an expensive loop if there is a lot of items right? I was thinking only to run it once an item is dropped in the world. Shouldn't be that bad, but now i'm speaking as someone who didn't even know how to loop through them in the first place :P
Game design optimization is my weakness, but it should be possible to do this in one loop if you use the x and y coordinates to put each box in a 2D array. If you try to insert a box at an occupied index, you could just greedily offset the x,y until you hit an empty slot
What happens if you switch which one is run first? Also try running it 100 times and average the last 10 times to get a good time. If the function executes quickly run it 10000 times for each function and look at last 50.
never
The licenses are really separate licenses in separate files. A patent license and a copyright license. The IP attorney in OP is making some odd points, but this is right, the termination is limited to the patent license.
Really nice write-up!
As an IP attorney: this is not legal advice, but you're right. "They've never done it before" might factor into my legal advice, but it's a really, really small factor. My company does approve react these days, but that's more because we have a cross license, and not because it's a good license.
Yeah, but Facebook has a ton of patents and nobody, anywhere has read through them all. So saying "they don't have a patent that applies to x" is stupid. An attorney shouldn't say things that are that stupid.
You're probably looking for a [Force-Directed Graph Algorithm](http://getspringy.com/).
Thanks
Your "asm.js" version doesn't really look like asm.js. There aren't any `|0` "type annotations". Also, the difference is just 50 ms and you're calling each function only once.
You're using the wrong examples to support your argument (see [semigroups](https://en.wikipedia.org/wiki/Semigroup)). Say I have a standard `divide` function: const divide = a =&gt; b =&gt; a / b; I can now half my number easily by: divide(10)(2) === 5 However after writing out that each time, I decide to write a `half` function from the `divide` function, but as the `divide` function reads as: `a` divided by `b` we're unable to apply the `b`as 2 without specifying `a`. Unless we re-order the function parameters, which would then read incorrectly. With the partial application proposal we can easily do: const half = divide(?, 2); half(10) === 5
**Semigroup** In mathematics, a semigroup is an algebraic structure consisting of a set together with an associative binary operation. The binary operation of a semigroup is most often denoted multiplicatively: x·y, or simply xy, denotes the result of applying the semigroup operation to the ordered pair (x, y). Associativity is formally expressed as that (x·y)·z = x·(y·z) for all x, y and z in the semigroup. The name "semigroup" originates in the fact that a semigroup generalizes a group by preserving only associativity and closure under the binary operation from the axioms defining a group. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Jquery will have a very long tail in terms of being used and maintained within projects (ie your future career), but you're right, its just a facade to manage DOM objects in a more intuitive way. You'll probably still need some number of libraries, if only to minimise your test area (the code that you write will need supporting tests, 3rd party libs already have them).
I think a problem is also the missing syntax highlighting. I actually kinda like the idea behind it. For example how you define event listeners with `on click itemDeletionButton`. This way it's really easy to find what you're looking for. But I wonder what drawbacks this approach in general has. Also it's again a completely new way how to code - at least for me.
Totally, agree - syntax highlighting would add much clarity by setting different colors for different type of words (plugins, evaluators, handlers). Another thing is that we are not used to look at this kind of syntax, so our brain rejects it automatically as less readable. In terms of LOC the language is not verbose at all. This implementation of TodoMVC is very lean.
Not really. Prettier makes it so that only one representation is valid. eslint will gladly accept different code styles and different line lengths.
That's true. I know that this problem exists also the other way around. Programmers who usually code in Basic, VB etc. also prefer their style over C-like languages. That's why I'm trying to be open to new things.
Because of the words "additional", and how they never say it's "the BSD+PATENTS license", and because you can license works exactly how you want. Licenses don't "work" as specific way, it's the intent and meaning shared that grants rights.
I really feel obliged to point out that these days, true end-to-end testing is considered... suboptimal. The big figures in continuous development and delivery-at-scale advocate testing 'pyramids', where most testing is implemented at unit level, and order-of-magnitude less as integration tests, and then only a bare handful of functional UI scripts.
We've just had a meeting about Javascript testing where I work, so this is going to be very handy. Thanks for sharing!
I agree, this is definitely the way to go.
Then you might also want to check out the review of Javascript unit testing tools that I wrote in June: https://mo.github.io/2017/06/05/javascript-unit-testing.html
They're separate documents, that apply to different things, and don't reference each other. Why would you assume that when one license says something about *itself*, it's actually referring to a completely separate document? (In any case, even if your guess was reasonable, [it was wrong](https://code.facebook.com/pages/850928938376556).)
There is no guarantee ASM.js will be faster than vanilla JS. In this case the code operations are identical, but the ASM code requires the ASM abstraction call, which is an extra step the vanilla code doesn't have. In order for the ASM.js to really outperform vanilla JS you have to give it some kind of binary operation that vanilla JS isn't good at.
Of course you can still use it. :)
I've shared them both with the team :) Thanks again.
thats where you are wrong boi
Did you open your browser console after this was executed? The code looks completely fine and it seems like a browser display bug.
But are semicolons really something that "affects" you? When getting into a codebase that uses semicolons you type them, in a codebase without semicolons you don't. It's not something that kills your productivity either way.
Right, the code works fine. Bizkitgto, when asking for JavaScript help it is always useful to provide a JSFiddle, like this: [To Do Example](https://jsfiddle.net/jones1618/gouohj46/) 
This survey misses one of the most interesting questions about Javascript development: What are people using on the back end? Are more people using Node, or are PHP and ASP.net still dominant? Is .net core getting any traction? Is Ruby surviving? These are key issues for any JS developer even if they are not purely Javascript issues. Instead, we get a lot of speculative questions about obscure libraries like GraphQL and Relay which almost nobody uses. 
https://opensourcefriday.com/
Yes I am running the code in Sublime Text and running it in Chrome, and the console is showing the results.
I am running the code from Sublime Text, and executing it through Chrome. When I run it in fiddle and open the console, I get the same result as in the OP. 
You must open the browser console before executing it.
Here is my [fiddle](https://jsfiddle.net/bizkitgto/saqh5nrb/), and when I check the console (chrome developer tools) I get the same issue as before when using sublime. 
Waouw ! ZombieJS looks promising !
It seems like the console.log of an array is the issue. Even if the console is open before you run your code, each of the three console.log statements is showing a reference to the CURRENT state of the array (after the change). If this was just an array of values (not objects), you could use console.log( this.todos.slice(0) ) to log a copy of the array. But, copying your array doesn't help because the copy still holds references to the original objects and will show the same problem. This explains all this better: [JavaScript Array: Copy Value vs. Reference](http://www.dyn-web.com/javascript/arrays/value-vs-reference.php). Your best bet is to write a function that loops through the array and console.logs its contents as text. Then, call that instead of calling console.log directly.
More than just sugar has been added in recent versions, such as Proxies, Symbols, proper tail calls and so on.
I threw in the towel trying to test my Preact interface, all I ended up with was verbose and confusing code, and just used my Java integration stack [Spock](http://spockframework.org/) and [Geb](http://gebish.org/) I'm sure other languages may have even better tools.
I'm kind of on the fence about this...Lambdas + closures can achieve the same thing: // with sugar const add1 = add(1, ?) // without sugar const add1 = (n) =&gt; add(1, n) 
it does the job, and is pretty straightforward now, you should focus on implementation not organizing few hundred lines of code... i guess your fears are invalid ;)
I agree, though a lot of people feel otherwise Also, it's not about a single small thing. its about all of the decisions people make together.
&gt; IMO, simply "yeah but they COULD do it" is the weakest argument. It's not a weak argument. It's a consideration you have to take when making your choices. You introduce yourself to risk. How high that risk is, is another thing. But considering that in the technology world, patent lawsuits are very common, the risk isn't negligible. So if you want to build a social network thing that might compete against Facebook, maybe choose Vue instead... 
THANKS! See my EDIT above, it gives the expected result. I am not sure I fully understand why this happens, but it caused me a ton of insanity. Thanks again. 
when I run it (chrome/ubuntu) I get: ASM: 1149.0449999999998 No ASM: 1482.64 calling it twice in a row yields similiar numbers, so no major compilation lag in there. calling it in onload made no difference. getting rid of "use asm" and the timings are virtually identical (asm vs no asm), 1500ish fyi I've been curious about emscripten (asmjs, not webassembly yet) so I did a test with that as well, and it looks like it did have to do some extra stuff on the first call (which might be lost between calls in your case? or it is already asm-ified somehow?) called them 3 times in a row: ASM: 1188.4900000000007 No ASM: 1489.9699999999993 emscripten: 1501.165 ASM: 1181.58 No ASM: 1479.5649999999987 emscripten: 1203.9500000000007 ASM: 1182.050000000001 No ASM: 1484.17 emscripten: 1201.3049999999985 I'm not wild about magical optimizations, especially if you are trying to be performant though and need to know what exactly is going on, so explicit "use asm" is good, emscripten is better. "use asm" can quietly downgrade, and you won't know any better, for something as simple as a typo (or not using it can quietly upgrade leading to more questions). edit: found a ycombinator discussion that looks similiar to this point: https://news.ycombinator.com/item?id=6553794 edit2: just realized that compiling c to javascript to run on the server is kinda stupid, just leave it in c... edit3: just tried it with gcc, using -O1 it takes 300 milliseconds, 4x faster than asmjs. anything above -O1 takes 0ms (and returns 1498500, the right answer). edit4: had to try webassembly too, 900ms. still 3x slower than native for this trivial example ( but it wasn't faster the second time either, though you have to coordinate with the runtime loading before you do anything interesting). both webassembly and asmjs also return in less than 1ms with emscripten using optimizations (I think it basically returns a constant).
we're only talking about React
Demo doesn't work. There is a text "What is your name?" and I can't input anything. Many code duplication: message.appendChild(content); this.__messageContainerDiv.appendChild(message); this.__scrollToBottom(this.__messageContainerDiv); this repeats itself many times... Protip. If you use often `document.createElement` you could make some sort of shortcut to it, e.g. const createElement = tag =&gt; document.createElement(tag) Instead of hardcoding CSS classes (same CSS classes in many elements): okButton.className = "__convoFormInput __convoButtonFormInput"; you could make some constants, like this: const CLS_FORM_INPUT = '__convoFormInput'; this way if you will want to change name of your CSS class (and you will soon or later), you will do it in one point (DRY). Maybe you should extract whole "assign classes" logic to separate function, like this: assignClasses(el, classes) { el.className = classes.join(' '); } this would be more future proof (even if you will decide not to use classes at all, but for example data atttributes).
On the flip side, you'll have thousands of devs and evangelists all on your side, and, because it would be a high profile case, it shouldn't be too hard to get a pro bono lawyer (unless you're a dick).
First of all: we're talking about "the React patent grant," which facebook uses in a very large number of its projects. Second of all: saying "they don't have a patent that applies to react" is stupid. No attorney anywhere has read through all of Facebook's patents to see if they read on *anything* React does. No person can tell you there is no such patent.
Full disclosure: I'm a core dev working on ArangoDB Foxx. Feel free to AMA.
dude, you really don't know how this works, do you?
As an attorney: this guy is an idiot. (this is not legal advice) 1. Facebook *probably* has patents that have something to do with React. Facebook is a big company with a lot of patents. Nobody's read through them all, nobody can say that none of them read on react. 2. This doesn't do much against patent trolls because patent trolls don't use React, because they basically never do anything at all. 3. Saying they haven't sued yet is not very comforting to any sane client, and shouldn't be. 4. The termination also applies to counterclaims. So yeah, if facebook sues you, you have something to worry about. 5. If you compete with facebook, and practically *can't* sue them because you know they're going to come back with a suit over react, they have an effective license to use all of your patents. Facebook uses React in cross-licensing agreements with big companies. It's absolutely an issue of competition. Edit: Reading through his argument, he states it better than the TL;DR did, but I still argue he's wrong.
It also has the benefit of high consultant fees when something breaks since the developers won't understand what's going on under the hood. Makes me want to become a Angular consultant $$
'sup with `const half = (a) =&gt; divide(a, 2);` ? e: corrected syntax
Do what you want, fam. If you want to come to /r/javascript to convince devs to completely avoid the most popular JS framework in use right now, then you do you.
Thank you for taking the time to take a look, many good points! &gt; Demo doesn't work. Weird, [it works here](http://i.imgur.com/tptdhQZ.gif). I've only tested Chrome so far, will look into other browsers. &gt; Many code duplication You're right, I should turn that into a function. &gt; Instead of hardcoding CSS classes you could make some constants Hmm, never thought of this, but yeah, those would be easier to change than with search-and-replace. Thanks for the tip!
Thanks for the encouragement! Will continue adding/finishing stuff!
&gt;ArangoDB
`splice` is evil. I would initially assume JS array performance is good enough and use `.filter` instead of splice bltAr = bltAr.filter(bullet =&gt; bullet.y &gt; 0) bltAr.forEach(bullet =&gt; bullet.update())
I don't advise completely avoiding it. But I'd sure be happier if you used another framework instead.
I really do, I'm an attorney who's covered react approval for a gigantic corporation. Who the fuck do you think you are?
Probably ES2018 too. 
A dev who's sat down with lawyers who cleared React for a mid-size company. And I'm someone who believes that newer developers should learn the technologies that are in high demand (if they're worried about job prospects).
A blockchain command-line interface https://github.com/seanseany/blockchain.js
Looks [completely fine for me on macOS Safari](https://i.imgur.com/Jd6XHKV.png). Are you absolutely sure you opened your browser console **before** opening/reloading the page?
I agree with this. I've seen people try to setup a whole complicated environment so they can run integration and functional tests when they don't even have any unit tests. Sadly, there are still quite a few people out there that think unit tests are unnecessary, and only functional/integration tests are worthwhile.
That is pretty much the definition of syntactic sugar... 
I've never liked splice, because it's broken things in the past, but I never knew how to replace it. Your fix did fix the problem! Is there any way to replace "bltAr.splice(bu, 1); emyAr.splice(ed, 1);"?
I was wrong. Demo worked but I didn't realize that the white rectangle on bottom was &lt;input&gt; (maybe add some placeholder, e.g. &lt;input placeholder="write here"&gt; ?). 
The library itself is ~130kb, which is already larger than most sites I write in total. It also has up-front processing time to load the page: even if you have server-side rendering so the page displays something, it takes time to rehydrate the context and until then the page will be unresponsive. For example, Walmart, one of the most highly-optimized React sites out there, takes 1.96 seconds to DomLoaded and 3.81 seconds to finish loading on my machine over a regular internet connection. Compare that to Amazon's homepage, which looks very similar and serves a similar purpose but doesn't use React: 0.65 second to DomLoaded and 1.65 seconds to fully loaded. If we assume that Amazon's findings still hold (they found 100ms of latency cost them 1% of sales: https://blog.gigaspaces.com/amazon-found-every-100ms-of-latency-cost-them-1-in-sales/ which is in line with what I've personally observed measuring performance projects), that means Walmart is sacrificing 13% of their sales so they can use React. And that's on a desktop with a large pipe. Depending on who your audience is, even if they are all in America they may be using DSL, 3G or even dial-up still. If you are using client-side analytics frameworks like Google Analytics or Optimizely you may not even realize that people aren't successfully loading your page. By comparing server requests to recorded page views I once discovered 50% of our mobile users never even got to the point of recording a page view. After moving away from React, that number dropped to 4%. I also recommend using low-powered phones to test your site when you are developing so you can see how it feels to you end users (I have an old MotoX for this purpose.) If it is snappy for the slowest of devices, it will be lightning fast for the latest and greatest.
No doubt. However, in most cases - currying is rarely used (1-arity is not really practical) and partial application, while useful, is not that commonly used. While these are surely good ideas, I find composition to be a much more common pattern - hence the pipe operator. 
you can do it with Flickity and nth-child + scale I believe, a bit playing with css to handle resizing but I've made something similar successfully
And that's my argument. Let's try to focus on these things and cut down on the sugar. It seems like most proposals are focused on sugar only. 
As a non-attoerney, I second this.
You shouldn't have to do that. This appears to be a known glitch in chrome.
99% of problems with `splice` is modifying the array you are *currently iterating* over. The same problem can happen with `filter` if you do it inside the iteration. There are several things you can do here if you want to avoid this. 1) first create an empty array, then instead of splicing out what you don't want, push to the new array what you want to keep 2) if you're going to call `.filter` later anyways you can mark the items you want to toss then filter on that property // during iteration bitAr[index].gtfo = true // later bitAr = bitAr.filter(x =&gt; !x.gtfo) 3) create a new array literal, slicing up your previous array around the index you want to get rid of. note: `slice` not `splice` bitAr = [...bitAr.slice(0, index), ...bitAr.slice(index + 1)] 
It's not a glitch, it's a performance optimisation.
I mostly agree, but it's case by case. This in particular, along with the function bind syntax, I'd _love_ to have personally, but I don't really care that much for the pipe operator. To each their own I suppose.
Well it only happens in chrome (and after digging into this it's a known issue that they are working to fix), and you tried to do this in safari. I'm no expert. What you suggested didn't work for me. Try again but in chrome. There is a big write up about this in stack overflow if you want to read more. Take a look my edit in the post.
RSS and JSON were both described first in 1999.
RSS's death had nothing to do with its data format. XML is simple enough. http://andrewchen.co/the-death-of-rss-in-a-single-graph/
How is indexing managed in Arango? One of the much needed features of Neo4J is utilizing indexing in ORDER clauses - is this something that Arango supports? Can you efficiently order large numbers of records by utilizing indexes on properties?
- A lot of people have moved away from JSLint in favor of ESLint, since its plugin system allows parsing newer JS features, JSX, and a lot of other fun stuff that's not easily done with JSHint, as far as I know. JSHint has the benefit of being simpler, but I guess it ended up not being enough to stick with it. - The "Frameworks" section should probably be called "Libraries" instead Looks good otherwise. 
Yes, ArangoDB supports [a number of different indexes](https://docs.arangodb.com/3.2/Manual/Indexing/IndexBasics.html) and they're used in queries as you would expect. You can also investigate whether indexes are used by [explaining queries](https://docs.arangodb.com/3.2/AQL/ExecutionAndPerformance/ExplainingQueries.html).
If you want to read more about function factories https://medium.com/@pyrolistical/factory-functions-pattern-in-depth-356d14801c91
https://jsonfeed.org
You can do this with slick and some custom CSS. http://kenwheeler.github.io/slick/
Of course there are many ways to achieve that. However the `divide(?, 2)` proposal is [point-free](https://wiki.haskell.org/Pointfree).
I have just looked over Skiplist indexes - it seems this is equivalent to utilizing [indexes with ORDER in Postgres](https://www.postgresql.org/docs/8.3/static/indexes-ordering.html) - am I understanding that correctly?
Partial application and pattern matching are the last 2 things I feel are missing in the JS toolkit
cool :)
Good call. Looks handy, thanks.
I tried it in Safari because I didn't care enough to open chrome for this rather obvious non-issue. Both browsers are based on WebKit and behave the same in this regard. You're definitely not opening the console before loading the page, I don't know why you insist on doing it like that but you should stop it because it's a stupid thing to do. As far as I'm aware, all major browsers collect far less debug information if the developer tools aren't open. That's because most users aren't developers and expect the browser to be fast and battery preserving. In fact, I saw the behavior you described where all three arrays are the same in my initial page load and I wasn't surprised to see the real results upon a reload.
react-lite for production is 25kb, preact-compat ist about 2kb, at that point the payload is irrelevant, added SSR makes response immediate. I know nothing about Walmart as the "most optimized React site." Time to visual in general depends on a thousand factors front- and backend, [hnpwa](https://hnpwa.com/) makes it clear you can get similar times with any framework and that it's the stack that defines how fast a page is up in the end. 
I doubt it would leak. If the element is removed from the `DOM` then it is no longer in the `Render-Tree` so then the css engine shouldn't be doing any work on it. https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction
&gt; You're definitely not opening the console before loading the page I opened the console before loading the page...I have already stated that I do this. This did not fix or solve any of my issues. 
Are you using `dev tools` and the `debugger` to help find the bug?
Missing the :thinking: emoji.
&gt; Am I right in thinking V8's JIT and other optimisations... Slightly off-topic, but I don't think the JIT can optimise a first run -- like in your experiment. At least for `monomorphic` optimisations. 
Make a codepen or provide a working (broken) example.
Please provide a working (or broken) codepen.
If you insist: https://gfycat.com/EnragedConsiderateIcefish
OK! Nice work on the gif lol. Yes, but open the arrays and see the contents inside, that was what I was doing. But my console did look the same as yours.
Actually if you got legacy code with no tests, it's better to start with functional tests. Especially since the code can be spaghetti like and hard to unit test. Then as you refactor the legacy code you add unit tests to your new code whilst the functional tests make sure it's all still working. 
Okay, that's definitely odd. You didn't make it clear that they appear correctly until clicked.
LOL. Now you see. Weird, huh?
It is, yes. It's probably still for performance (logging a lot would be very slow), but there should be a toggle to disable this. Actually, I think I also have a fix in one of my code-bases for that. I usually just `console.log(JSON.parse(JSON.stringify((data)))` to dereference it completely. Doesn't matter if it sucks performance, my machine is good enough and it's only enabled in the development build.
That works...but ugh...annoying lol.
I only have one place where logs are created in that project.
Thanks
Thanks for reminding me of the giant chasm in my life that is the former home of Google Reader. Tried several replacements, none were very close to what I wanted, though it's been awhile so maybe I should check some out again. I used to follow 20+ blogs, now I follow precisely zero (I just check the articles that bubble-up here and HN).
tbh, I don't think the population at large realizes businesses can be held liable if they don't maximize profilts.
So, I see _what_ this is, and I have somewhat of an understanding of blockchains, but can someone please explain _when or why_ I would use this?
Do you need document ready? As in is there a specific reason you are doing everything in dom ready. Try it without. Try putting console.log statements. Are you updating the page or anything? 
Exactly. Can someone explain to me how the fuck people are supposed to read the news efficiently???? Also, check out Inoreader.
RSS feeds are a brilliant idea from a different time when interoperability was still a prized property of system design. Nowadays, the web is so dominated by big players like Facebook and Google that they can effectively dictate the use of their proprietary interfaces at the expense of standardized interfaces like RSS. Merely changing the serialization format likely won't change this dynamic.
Skiplist indexes are useful for sorting, yes.
This is a tough question. I think you need to look into `algorithmic complexity` and `Big O notation`. Basically nested loops increase complexity by a factor of n. A more perfomant algorithm will increase complexity by less than a factor of n -- `log n` for example. How do you do this? Using different data structures or a "divide and conquer" strategy. There's likely plenty of others. I wouldn't say in general that "for loops are expensive".
SO to the rescue! https://stackoverflow.com/questions/5349425/whats-the-fastest-way-to-loop-through-an-array-in-javascript a `for` loop with the `length` saved off to a variable for (var i = 0, len = myArray.length; i &lt; len; i++) {} Saving off the length saves some computation to check the length each iteration, which I think was more of a problem in older JS implementations, but probably doesn't hurt even in modern. ----- Also, Array.prototype.forEach is a better `for` loop equivelant than `.map`, map is expected to return a new value to replace the old value.
Saving length to a variable is an obsolete optimization. Modern js engines will automatically cache the length.
ran into the same exact thing as you :P
Nested loops are not expensive. Just about every virtual dom implementation does nested loops precisely because they are fast But this is just when we talk about the generic case. For specific cases, there are algorithms that can help. Sorting is a well explored case with many algorithms to choose from. Virtual dom algorithms have heuristics to reverse the direction of the loop, break early and perform cheap conditionals instead of expensive ones under various conditions. Obviously the type of algorithm to use depends on the case.
What is actual euler problem, and why are you adding 7 twice?
Hi, thank you for your feedback. :) I made the CLI to learn about how blockchains work. I hope this CLI can help people understand blockchain as well. 
I wouldn't rule out the tools that don't use a real browser personally. They tend to run a lot faster and the issues with not being a real browser are way overblown in my experience. 
Any live demo? 
Length could change if your length comes from an array and you are doing something tricky with the items in the array inside the for loop.
&gt; i wonder how much of it is just swallowing of huge dependencies rather than actual app code. LinkedIn has the worst devs I've ever seen from a major service, but the other apps are probably pretty legit heavy. Gmail is incredibly sophisticated, so weighing in at only 3.9MB is impressive to me.
Your mistake is that you're not telling us what the Project Euler problem is. 
Hi Vladan, thanks for working to push the platform forward. Would you mind answering this question (taken from my other comment in this thread)? Why don't we serve an LLVM-style intermediate representation? Then you don't need a heavy parser or JIT.
open('article').read().wtf().back().comment('this is fooking amazing man!').end();
Glad to see gatsby has hit a usable state. I tried using it when it first came out and there were just too many issues. Will definitely be giving it a try again. 
I too would like to know. What is the block chain actually _for_? I've heard of course about cryptocurrency, or people signing documents with it, but I'm missing an important piece of that puzzle.
Seems pretty fantastic. And even more awesome if you are using something like `semantic-release` for automation, because this dependency updater [support auto-merge](https://renovateapp.com/docs/configuration-reference/package#automerge) of the PRs that he sends you. Also it has very much options and configurations. Not to mention that it is really smart and applies best config for your repository. For example, if you are not using conventional commit messages such as Angular's or etc (introduced bny using `commitizen`, `semantic-release` or `standard-version`), the commit messages of the tool, won't follow it. And the opposite, if it detects that your previous commits follow some convention it will use it. There is also an option that instead of `chore(deps): update denendency x to x.y.z` it may starts with `fix(deps):` ([option is called "semanticPrefix"](https://renovateapp.com/docs/configuration-reference/package#semanticprefix)), which in turn will automagically trigger the semantic-release (if you are using it), so even your package will be auto-published when some of your deps is updated. I feel that is pretty awesome thing. You even don't need to know what happens, it is enough to stay up to date and your package to be published automatically.
Thank you!
thank you
Do you have a React site that you would consider a good example of performant React? All of this depends a great deal: I have built a number of serverless sites, in which case your "stack" is the CDN. Even hitting the back end, that is not always the bottleneck if it is decently optimized or appropriate to cache. I didn't say to never use React: I suggested that there are specific cases where it is inappropriate. For all those cases I wouldn't be using a framework at all; if performance matters that much I'm writing vanilla JS, just like if I were on the server I'd be dropping down to C.
 const someObj = new Form(); Form.prototype.someMethod.call(someObj); someObj.someMethod(); // same
Nice post. Thanks :)
If you want it where your comment is, that's not going to happen. Unlike function declarations, classes aren't hoisted. You'll need to put it below your class definition so it can be defined prior to you attempting to access it. If you're especially concerned about the space, you could wrap your class in a function and call that function to define it before your usage: const Form = createForm(); //I want access here the method someMethod(). &lt;-- now accessible function createForm () { return class Form extends Component { someMethod(); } } export default Form 
vue.js is listed as a library-probably should move that into framework section
Nice article. I had to use protractor for an angular app and then just continued using it even for non-angular apps, I think it's still a great option regardless of framework. One thing about all the js frameworks is they are fast to get setup and running. Edit: Protractor is also super easy have run parallel execution too
hay bb, i miss u
If you remove the element from the dom, and you don't intend to append it back to the dom, it is better you set the variable that holds the dom element to undefined so that it should be garbage collected
Agreed but they are still nice to have. There is a big benefit to not have to manually verify that the ui is rendering properly assuming the tests are reliable. My ui-integration tests are very simple, basically render the page with mocked external calls and assert no errors are thrown. 
This works: function isItAPrimeNumber(number){ if(number === 1|| number === 0|| number === NaN){ console.log('something happened') return false } for(let i = 2; i&lt;number;i++){ if(number%i === 0){ return false } } return true } let sum = 0 console.log("it's worknig") for(let i = 7; i&lt;2000000;i+=2){ if(isItAPrimeNumber(i)){ sum=i console.log(i) } } //sum+=7 console.log(sum) Perhaps you want to put that last bit in a function that accepts a number and returns sum which will be the largest number below the number fed to the function that is prime. Who knows.
I'm not 100% on the use-case for this specific tool but I had the same question as you. Specifically *why the hell should I care about the blockchain?* The way that I understand the technology being useful outside of cryptocurrency is an immutable record of *things*. Let's say you have 10 people sharing a single object and they want to be able to agree on the state of that object. The blockchain lets those 10 people do whatever it is that they want in life and interact with that object however they want with the rule that whatever the group decides is the state of the object is the state of the object. Using the blockchain *idea* and maybe even the blockchain technology itself ( still trying to figure out miner fees and how that fits in here so I could be totally off base ), we can create a distributed system that uses the blockchain to decide what the actual state of the system is. Or for a more immediate application, immutable accounting records for businesses. Never having to keep balances/accounts in sync with each other since the blockchain is an immutable record of what happened and when.
[removed]
Yes it could and it might've become an infinite loop even before we start talking about performance. Caching the length in a case where length is deliberately mutated in order for code to be correct would actually introduce a bug. I'm saying that in the case where length stays the same throughout the entire loop (which is arguably almost always the case in real life), a browser will optimize away the member lookup.
FYI "anything === NaN" is always false
Well - based on what you've written in your description - what you want to do is have a hidden CSS class that 'fades out' and then you want a 'show class' that fades in? The link you click on should toggle the element between those two classes shouldn't it?
yeah, that sounds like it would work better than the current code I've got (which I think is just changing the display type of the element). I'll give that a shot and see if I can do it. Thanks for the pointer
I'm just guessing here - but I do know that your function doesn't change the class - which is really what you're trying to do (and yes this would be totally easier with jQuery :) 
Kudos. I like this. ☺️👍
Sorry about the late reply, I haven't been checking the thread. I did look at LLVM's IR and from what I remember it is designed to be serialized to disk in binary form and size might have even been one of the considerations. We're focusing on the Babel AST and Shift AST since they're vendor-neutral and well known. We're not dogmatic about any particular AST or binary encoding format. I'm not sure if LLVM's IR is ideally suited for efficiently representing JS ASTs though. I'm not sure what you mean by "you don't need a heavy parser or JIT". The LLVM IR would still need to be parsed. And I think JIT-ing is orthogonal. I don't think representing JS with LLVM's IR would be a big win, since existing JS engines don't use its IR. Did you mean JS engines could execute the LLVM IR directly?
I think it only seems like a lot of if you think of websites like GMail as documents instead of applications. For comparison, Facebook's installed Android app footprint is 150+ MBs. I don't think &lt; 5MB is a lot for a desktop mail reader application (GMail) in 2017. The premise of this proposal is to allow web apps to be as performant as native apps, and I think that's long overdue. Lack of APIs and uncompetitive performance of the web platform have been holding back the sophistication of web apps.
replied below :)
You're not completely wrong, but your response was written to an absolute that "JavaScript is overtaking the world", which was a hyperbole. I don't think the author literally meant that it was taking over the world. When it comes to JavaScript, it is the bread and butter, but it would not be possible with the underlying compiled languages that make running V8 on the server possible. Currently, it still can't compete with C++ or Python, but there have been massive strides in the past 5 years and when you start seeing things like Brain/Synaptic.js, Electron.js, and ASM.js, JavaScript starts entering other fields. To your credit, in its current state, scripting languages have a hard time solving some of the problems that compiled languages have. This is especially true of floating point math, but that doesn't mean JS won't be capable.
No, it wouldn't. Javascript supports class lists now. Stop promoting jQuery, it's not 2005 anymore.
I made a suggestion because to me it would be easier to use jQuery cause remember beginners don't know as much as you super experts. Jesus, I thought this was reddit not stack overflow
This^ Remindme! 2 days
Sorry, but a live demo would give anyone arbitrary code execution on cpu intensive tasks. It'd require a dedicated session for each user similar to the jupyter live demo https://try.jupyter.org/. Currently don't have the resources to do that. :(
&gt; I'm not sure what you mean by "you don't need a heavy parser or JIT". [...] Did you mean JS engines could execute the LLVM IR directly? That is what I was insinuating. Is that a bad idea from an engine perspective? &gt; Sorry about the late reply Not at all, thank you very much for chiming in with this information!
Let's hope he doesn't need to explain the code edit: fixed bug where 60 seconds was appareing instead of 0 Seconds https://jsfiddle.net/r0uayyc6/
Because RSS is from a time when XML was king. APIs were called *web services* back then and JSON was a killer from a film.
If you are on Mac: http://netnewswireapp.com/ On Web check: http://digg.com/reader
Really just putting a Promise around `navigator.geolocation`. Not really sure it's worth adding the dependency.
I got it from here: https://medium.com/@lhartikk/a-blockchain-in-200-lines-of-code-963cc1cc0e54 You can find all the references in the *Acknowledgement* part of the repo.
Lots of issues with the code but I think you're looking for something like this: function addvariables (n,x) { var y = 0; for (i = n; i &lt; x; i++) { y += i; } return y } console.log(addvariables(1,11))
Your understanding is exactly right. I built this tool to educate myself about this emerging technology. 
I switched to Feedly after the death of Google Reader (RIP) and it's serving me well enough.
When someone wants to see how a blockchain works :)
Feel like I've seen this before :)
90% of the comments in this thread are asking about what the blockchain is or what it's for. I'd like to take a stab at explaining this my perspective having developed blockchain applications for the past 5 years. Blockchain, in Bitcoin, contains two core concepts: mining and digital signatures. Mining is the way the network is secured by proving work was done over a period of time (and incentivizing the work done by rewarding to those who participate). This requires finding a nonce that results in a hash digest meeting certain requirements. Mining is decentralized and miners contribute their work to the network and broadcast transactions on a best-effort basis. This means anyone who wants to be a miner can join in at any time. Digital signatures are used to determine whose coins are whose. If a friend sends me 10 BTC they write a message to the p2p network telling everyone that they are paying the coins to my public key. That transaction is signed by my friend's private key and everyone on the network can verify it. When I want to spend my coins and send them to someone else, I can now sign a transaction with my private key authorizing the coins to be sent somewhere else, and so on. Miners put that message into a block when they find a nonce that satisfies the aforementioned difficulty requirements. Blocks are chained one after another in the blockchain. The main reasoning behind why this system is needed, and a technical overview of it, can be found in Satoshi Nakamoto's paper [bitcoin.pdf](https://bitcoin.org/bitcoin.pdf). If you haven't read it please do so now. It's quite short (about 9 pages) and easy to understand. /u/Is_At_Work asks: &gt; when or why I would use this? You should use this if you want to build a bitcoin wallet, payment processor, or bitcoin merchant portal in javascript. You might also be interested in why decentralized networks or p2p applications are useful, or what advantages they have; this project seems like a good way to learn about that. /u/koresho asks: &gt; What is the block chain actually for? The blockchain is for authorizing payments of a cryptocurrency between two peers without the need for a centralized 3rd party approving of the transaction. There are other uses of the blockchain which are more in line with the second point, digital signatures, but they are secondary to the main purpose of peer to peer transfer of value. Bitcoin is blockchain's killer app. /u/cirsca asks: &gt; why the hell should I care about the blockchain? Blockchain facilitates trade over a network. Imagine a metal as scarce as gold with a magical property of "can be transported over a communications channel". This has implications with respect to individual rights, the world economy, and the way we monetize and transfer value at a level higher than bartering directly for goods. Lately people are distancing themselves from the proof-of-work concept and are using blockchain to describe only the mechanism of signing a transaction as verification of sending an amount. Change "sending an amount" to almost anything else - authorizing a change in a ruleset, casting a vote for a politician, verifying a point of IoT data is authentic. Now add in the concept of a peer-to-peer network to this and you've eliminated a middleman that once existed, thereby improving the efficiency and reducing cost. In these cases, "blockchain" refers to the structuring of a program or database in such a way that it has no central point of failure while still providing all of the features expected. For example, augur and gnosis are decentralized prediction markets. Ethereum has implemented smart contracts which enable decentralized release of funds based on a gambling outcome. One of my own [projects](http://alexandria.io) is using an alt-coin blockchain to store IPFS hashes for a decentralized YouTube competitor. There are tons of use-cases for blockchain technology, but in my opinion, the first and most important blockchain concept is decentralized p2p cash.
It doesn't become an infinite look when removing items from an array, and it doesn't mean it's automatically a bug either, nor is it automatically a 'code smell'. Your perspective may not be the same as everyone's. While I do agree the majority of for loops use a static number for iteration count, that doesn't mean it's always that way. That's what I love about for loops over other 'modern' methods like filter, map, etc - they can be made to do things that are outside the capabilities of the newer methods. 
There are existing systems that execute ASTs directly (Oracle Truffle), but I'm told it would be difficult to implement &amp; maintain for a language like JS. It would also require changing the existing JS engines much more substantially. The binary encoding we're proposing only replaces the front-end.
That is smart, makes it easier to grow consensus. Thanks!
Thanks for the write up! That does help explain it. 
thank you, that makes a lot more sense now! 
Myself and a colleague created a blockchain conference last year and we had to speak to many companies that are involved in their area. I think a lot of people only think of blockhain as a way to transfer money but it can also be used in other areas which are just as exciting if not more. One I remember talking to was a company called Filament, they use it for wireless networks. Amazing stuff if you can read about it. It's also used for sharing documents, real estate deeds, share certificates etc. The immutable nature of it means there can be no discrepancies. Arcade city was a cool one. Like Uber but payment was done through a blockchain. Go on google and look at what the companies in Europe are using it for. Estonia has a lot going on. 
This kind of programming in JavaScript terrifies me. It is quite conceptually beautiful, but I can't imagine maintaining this without higher kinded types and some variety of static adhoc polymorphism. Static types keep the meaning intact as this code grows and matures. Without it I'd be afraid of this evolving into a hot mess as misunderstood refactorings pile up. This code is natural in something like Haskell with its strong type gaurantees. JavaScript's weak dynamic types desire shallow abstraction if any.
Thanks you legend, appreciate it. PM'd you.
It means Cordova isn't allowed to use React in any of their tools/projects/plugins/sites because they are an Apache Software Foundation project (and this does in fact affect their plugins.cordova.io site, which will need to be rewritten). It means nothing to you as a Cordova and React user (unless you have your own concerns about the licence/patents issue)
Most libraries are "just wrappers" over seemingly simple APIs. Native APIs like the geolocation API are usually filled with these terrible nuances you discover once you start working with them. By itself a library like this might provide relatively little benefit but combined with dozens of other wrappers required to build modern apps you get a much more comfortable and less-buggy development experience. 
Damn, you don't even need Promise for that. You can retain same syntax without using Promise thus wider support without polyfill.
I think your statements are true for any kind of programming in JavaScript
Because the for loop checks if 7 seven is a prime number. What it doesn't do is checks if 2 and 5 are primes.
What if type isPrimeNumber(). Then would number be = to NaN nope then it would be undefined. Thanks!
Wouldn't the sum be missing and 2 and 5 since they are also prime numbers. And is there a way to solve this faster. Since it took me at least 15 minutes to execute.
https://projecteuler.net/problem=10
To sum all the prime numbers to 2*10^6.
:)
This is awesome! Switching to GraphQL made a difference in how my team documents and uses our internal APIs. This is the easiest way to get started. 
even if you called isPrimeNumber(NaN) is still wouldn't matter NaN !== NaN
So I'm the one to blame for pushing Vladan heavily in the direction of binary encoding for the AST instead of other approaches. Any "bytecode" style encoding would have had a really hard time getting through any of the browser vendors. It would have been a very early "no" from both committee and the implementors. All of the browsers already use their own internal bytecode design, which is heavily instrumented and tied into the hidden runtime type modeling system, as well integrated with the different JITs. For a new over-the-wire binary-bytecode format to fix the load-time and parse-time issue, the engines would need to implement an interpreter that directly executed that bytecode. That means wiring up that new interpreter to their hidden type systems, their jits, their exception handling, everything. It's an enormous surface area. So you suggest the bytecode-over-the-wire idea to one of the JS engine devs, and their gears start turning, and they start thinking about all the intricate places in their code where the rest of the system depends on their interpreter.. and the idea doesn't seem so rosy to them anymore.
**Sieve of Eratosthenes** In mathematics, the sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime, with constant difference between them that is equal to that prime. This is the sieve's key distinction from using trial division to sequentially test each candidate number for divisibility by each prime. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
What about 3?
Yeah, the more projects that achieve maturity with this the better it will be for adoption.
If a framework, any framework, is handled with care it will cope with the most demanding projects. [The benchmarks](http://www.stefankrause.net/js-frameworks-benchmark5/webdriver-ts/table.html) where vanilla is pitted against frameworks only have it carry out simple dom operations which makes sense because frameworks do have overhead that needs to be small. That doesn't mean vanilla is faster, in pretty much all real world cases it isn't. [There's so much stuff you'd need to implement](https://www.reddit.com/r/javascript/comments/6lsjmx/why_we_didnt_use_a_framework_case_study/djwntzq/) to come near any framework that schedules read/writes, touches only subtrees that need to change, utilizes code-splitting and async-component loading, etc. The only criteria where vanilla would have a tiny advantage on paper is time-to-content, though SSR and proper compression make it irrelevant. If React for instance is compressed to 2kb and uses SSR, you wouldn't detect a difference to a static HTML page even under the slowest bandwidth.
&gt; |&gt; _ =&gt; ༼ つ ◕_◕ ༽つ
I think if the geolocation API was added today, it probably would be promise based. I am surely going to use this library in my future projects.
I think I found my mistake. I could have just made it start from 3 and then just add 2. Thank you very much.
inb4 the async/await version
From the source: const current = (options = {} as PositionOptions): Promise&lt;Geolocation&gt; =&gt; { return new Promise((resolve, reject) =&gt; { return geolocation.getCurrentPosition(resolve, reject, options); }); }; Why would anyone add a dependency for this 4 lines of code? 
If Java is really abusing scripts, someone should file a report.
It's defining an arrow function called *current* which takes an *options* object of type *PositionOptions* and returns a Promise which resolves something of type *PositionPromise*. You might find it useful to paste it into the TypeScript repl: http://www.typescriptlang.org/play/ I don't really know TypeScript so if anyone can correct me, please do.
Surely, in term of simplicity vs elegance, class should be in the middle of the scale, not at the end: Object literal -&gt; factory -&gt; class -&gt; functional mixin -&gt; stamp Once basic inherence or plain composition with class doesn't help, you should use mixins or some userland object constructor like stampit. IMHO, you should stick to idiomatic javascript; `Object literal -&gt; factory -&gt; class` is enough. Anything else and you're trading elegance of your API for a maintainer stepper learning curve.
This is completely dependent on the API itself. You'll have to find out what its rate limits are. 
So how is const divide = a =&gt; b =&gt; a / b const half = a =&gt; divide(a)(2) So much more complicated? I get that it's much more convenient in a pipeline situation to have const foo = bar |&gt; add(7,?) Than const foo = bar |&gt; _ =&gt; add(7, _) But as soon as you're going to reuse your function, doing this const addSeven = _ =&gt; add(7, _) const foo = bar |&gt; addSeven Is just synonymous to this const addSeven = add(7, ?) const foo = bar |&gt; addSeven It sure is convenient and easier to read, but I don't see much of a point right there. if you care about this, you could do: const addSeven = function (_) { return add(7,_) } You say I'm using the wrong examples to support my argument, but I have yet to read an argument why this absolutely needs to be a thing and needs to be supported. At this point it just seems like a minor convenience thingy to me.
Semicolon after the second to last promise. Though I'm surprised that the parser wouldn't bitch at you for it. 
Sorry it was a typo when copying the code to reddit. The OP is now edited. The problem remains.
Instead of: var ul = document.getElementById('list1'); And... Math.random() * i | 0 Use: var ul = document.querySelector('#list1 &gt; ul'); And... Math.floor(Math.random() * ul.children.length)
Async/await is sugar syntax for Promise
Cus wrappers and bloatware makes better code lol xD
Refer to the site's policy/documentation regarding the usage limit of its API.
You're correct. However, the function does not return anything so the compiler will not accept this code. The return type must be respected, a simple "return" in the body will make the compiler accept the code.
Awesome!!!
Can you put a catch block at the end and see if it catches any error?
Note this is TypeScript, the same function would read in plain JavaScript like this const current = (options = {}) =&gt; {} `const` is a keyword for declaring variables much like `var`, but it's block scoped and can't be reassigned. `=&gt;` is an arrow function, arguments go in the left and return value or function body goes to the right, it also automatically binds `this` You can use them together to assign functions like this: const increment = x =&gt; x + 1 const add = (a, b) =&gt; a + b const foo = () =&gt; { return 'foo' } Assignment in function parameters is used to set *default* values const addOneOrMore = (a, b = 1) =&gt; a + b So now you can tell what the plain JavaScript version does 1. Assign a function into `current` permanently 2. The function takes one parameter `options`, use an empty object in place of options if the parameter isn't provided 3. Empty function body, returns `undefined` by default The rest of the syntax is TypeScript, it's simply information about the types involved in that function and doesn't change what the function *does*. `options = {} as PositionOptions` means the options parameter is of type `PositionOptions`, probably an interface defined somewhere else. Meaning there's explicit properties that object can contain and anything else is a compilation error. `: Promise&lt;PositionPromise&gt;` means the function returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) and that promise resolves into type `PositionPromise`, this type is also defined somewhere else. If it tries to return anything else, it's a compilation error. And since the function doesn't actually return anything, you can tell that piece of TypeScript wouldn't compile. It needs a return statement and the type being returned has to match whatever `PositionPromise` is.
"Creating a blog with CodeIgniter"
&gt; I have yet to read an argument why this absolutely needs to be a thing and needs to be supported. It absolutely doesn't *need* to be a thing, because as you've demonstrated, we can already achieve something similar with existing code. However, you've also demonstrated that by using `?` our code can be more succinct, point-free, and also prevents an assignment to a variable that is later garbage collected. Take the [exponentiation operator](https://github.com/rwaldron/exponentiation-operator) which introduces `**`. We can already achieve that by using `Math.pow`. However it's still a *thing*. As others have mentioned in this thread, `?` is syntactic sugar. The `|&gt;` operator, which is essentially `compose` (more specifically, `pipe`), has been used for years from libraries such as Lodash, Underscore, Ramda. Ramda has also supported the [`__`](http://ramdajs.com/0.22.1/docs/#__) for many years. Both `|&gt;` and `__` are now being *hopefully* baked into the language, as inspiration is one of the ways that languages evolve over time.
Done. No error raised. :(
I changed the code to this new one: phantom.create().then(function(ph) { ph.createPage().then(function(page) { page.open('https://example.com/').then(function(status) { if ( status === "success" ) { page.evaluate(function() { document.querySelector("input[name='j_username']").value = 'example'; document.querySelector("input[name='j_password']").value = 'example'; console.log('Submitting logging...'); document.querySelector("input[name='submit']").click(); }).then(function(){ page.property('onResourceRequested', function(requestData) { if (requestData.url.indexOf('geomaps.json') !== -1) { console.log(JSON.stringify(datos)); request.get({ uri: requestData.url, headers: requestData.headers }, function(err, res, body){ if (!err) { console.log(res.headers); } else { console.log("Error getting data from website: "+ err); } }); } }); }); } }); }); }); Same result. The console.log(JSON.stringify(datos)); is being fired but the request.get is never being fired. I thing may have something to do with firing async funcions inside promises?
Just a minor correction: `options = {} as PositionOptions` is actually providing a default value which is *cast to* `PositionOptions`. The type of `options` will still be inferred as `PositionOptions`, but the default value itself is no longer type safe. To illustrate why this is a bad practice: // inferred as: (options?: Options) =&gt; void; const current = (options = {} as Options) =&gt; { // here "options" is inferred to be of type "Options", but is actually "Options | {}" }; current({}); // Error: Type '{}' is not assignable to type Options // (But isn't that our default value?) current(); // No error, even though functionally identical to the above 
Lol, so why isn't there a competing RSS-like standard which uses JSON?
The compiler will still complain if you're not returning the proper type. function returnsNumber(): number { return; // Error: Type 'undefined' is not assignable to type 'number' }
The people who would use this are the same people who used leftpad.
More tests. If I simplify the page.property('onResourceRequested' code block I see that the then() is called only once and before the requestData is received for each call... [Imgur](http://i.imgur.com/WD56kPE.png) I am a little bit confused and I don't know right now how to approach this...
If someone is really interested in building JavaScript blockchain apps, please visit /r/lisk
I don’t know the API, but if `.click()` returns a Promise then you need to return it if you really want to chain: return document.querySelector("input[name='submit']").click();
I can't tell if it's intentional, or just incredibly ironic that having JavaScript turned off turns that entire page into a spinner graphic...
In case you're interested, here are a few tips related to chaining promises: http://exploringjs.com/es6/ch_promises.html#sec_common-promise-chaining-mistakes
[Made it pop out a little.](https://jsfiddle.net/xvx4a04p/3/) Better indeed! I also added CSS constants fixed code duplication somewhat, so thanks again!
I would actually argue that ** and Math.pow are not synonymous. As ** calculates at compile time, while Math.pow() calculates at run time as illustrated [here](https://stackoverflow.com/questions/41679191/why-is-math-pow-sometimes-not-equal-to-in-javascript) Ok, I should have phrased that part about supporting better. I didn't mean to say that it shouldn't be supported, however I think there are things that should be considered for future support more strongly than this one, e.g. (dynamic imports)[https://github.com/tc39/proposal-dynamic-import], (promise finally)[https://github.com/tc39/proposal-promise-finally] or syntactic sugar like the pipeline proposal, which I deem a tad bit more important than this proposal.
Here's a little [trip through the looking glass](https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language). Enjoy. :D 
Their optics product also has 1mil requests free. Fun company to watch and compelling tech. 
`| 0` is faster
Great article! 
Sure, and obviously there's a level complexity or a need to standardise an interface you may reach where a lib can come in handy. Promise-wrapping is such a standard pattern now, and this library _literally_ does nothing but wrap 3 of the `navigator.geolocation` functions. It's a matter of opinion whether something is a useful abstraction or a pointless obfuscation, and in my opinion this obfuscates.
Succinct article with a clearly useful concept. Great!
You should read about operator precedence and associativity to understand why that happens. https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
[removed]
I figured it out, but just by looking at it, it didn't occur to me for first. But thanks for advising :) 
I'd never considered how to lazy load Vuex store modules, very cool
I had the exact same issue on react-native when i was playing around, super annoying. Newbie user shouldn't have to search for hours in order to remove a feature intended for power users.
thanks for the help, got me on the right track and I did it this morning, wasn't that difficult after realizing all I needed was the add/remove the classes. css .hide { opacity: 0; transition: opacity 2s ease-in-out; -moz-transition: opacity 2s ease-in-out; -webkit-transition: opacity 2s ease-in-out; } .unhide { opacity: 1; transition: opacity 2s ease-in-out; -moz-transition: opacity 2s ease-in-out; -webkit-transition: opacity 2s ease-in-out; } html &lt;div&gt;&lt;a onclick="toggleHidden()"&gt;Legal&lt;/a&gt;&lt;span id="hide" class="hide"&gt; - There is no spoon&lt;/span&gt;&lt;/div&gt; javascript function toggleHidden() { if (document.getElementById("hide").classList.contains("hide")) { document.getElementById("hide").classList.remove("hide"); document.getElementById("hide").classList.add("unhide"); } else { document.getElementById("hide").classList.remove("unhide"); document.getElementById("hide").classList.add("hide"); } }
Interesting regarding `**` and `Math.pow`. I didn't know there was a subtle difference. As `Promise.prototype.finally` is stage 2 (soon to be stage 3) and dynamic `import` is already stage 3, I'm sure they will definitely arrive sooner. I actually don't even see `?` in the [TC39 repository](https://github.com/tc39/proposals/blob/master/stage-0-proposals.md) yet, but I presume it's sat at stage 0. Personally I'd also like to see [cancellation](https://github.com/tc39/proposal-cancellation) prioritised, so it's good to see them having another shot at presenting that to the committee.
Why gulp over npm scripts?
I don't know, but IMO because most people aren't using it. Most people get their news from Facebook.
Nice! Thanks
Since this is a phantom script I will assume you are running this under NodeJS. I think the best way to debug this would be to use the node inspector. First, make sure you are using the latest version of node, or else you may have to adjust the following instructions. If your file is named `index.js`, run the following command: $ node --inspect-brk index.js Now open `chrome://inspect` in Google Chrome, and find your app in the list and click "Inspect". I would then place a breakpoint at the head of **each** `.then` block and just follow the execution through.
&gt; [17:55:11] Version: webpack 2.5.1 Feels like you're using webpack v2 for this example, lel.
Hey guys, I'm the creator of that. So, thank you for the discussion, some good comments, and others not so good, but thank you for your comments even so! So, I really like to contribute to open-source and learn everything about programming or JavaScript, I've created 12 libraries and they are published on npm. Why do I do that? Learn. Get knowledge. Probably some are not useful or the next jQuery of the libraries, but I think are helping other people around the world. My 12 libraries have helped more than 9.5k people, and that's so gratifying for me. I've created pozition.js for learn TypeScript and I just published to help other people. I described my motivations on README's project. "My motivations to create that lib are: learn TypeScript and develop a simple Geolocation "adapter" using promises instead of callbacks." Thank you for your comments guys! And if you liked it, please, use and enjoy! ;)
This is what is wrong with the world.
You can count Linus out hahaha
One more thing, I know the Geolocation API is simple, really simple, but when you work on a project that uses a lot of promises, APIs like that may break the "flow", you know? Unfortunately, the native geolocation API doesn't support promises natively, if you try run this code, you're gonna get an error in your console: navigator.geolocation.getCurrentPosition().then(pos =&gt; console.log(pos)) So, if you prefer, you can use pozition.js to help you haha
they don't have. Would you reccomened. Experementing sending a certain number of requests in a certain time frame and figure when I am denied access.
Async/Await is a good feature and you can use it if you use pozition.js There's an example on README: https://github.com/cezarlz/pozition.js#async--await
Thank you!
This is TypeScript, I've created that to learn it. Some people add jQuery just to use the addClass method or $.ajax hehe
The readme starts with: Yes. The Geolocation API is so simple, and you need to answer yourself: Do I really need that? :D
You heard of leftpad, right?
I don't really get the question, it sounds like you are getting confused. ALL nested loops are expensive, because their algorithmic complexity is O(n^(2)) - that's true whether they are for loops, .forEach, .maps, you name it. It's always good to try and refactor the code and avoid nested loops if possible. On the other hand, if your "n" is very low, it hardly makes a difference. Then there is the fact that some loops are faster than other - no loops are faster than for / while loops in JS. .forEach and .map need to create function scope at every iteration, so they are a bit slower. Whether that is significant enough for you to worry about only you can tell - one thing is doing a particle visualisation or a video game, another is processing 20 items from a pulldown menu. 
what is this autism
1. Lodash is just a bunch of helper functions. graphql has no impact on whether you'll benefit from these helpers or not &gt; Graphql and Apollo-Client, or Functional Programming these things are completely separate. You can do both or just one or the other. &gt; redux Apollo uses redux under the hood, though you don't need to know too much about it. but sure learn it, it's a very small library that helps with state management.
Nah, I work with him :)
Hmm, I was going to say function isCssSelector(sel){ try { document.querySelector(sel); return true; } catch(e){} return false; } except at least on Chome this actually works? document.querySelector('[target')
Seems worthwhile to read. If I can get past no-semicolon syntax. 
Seems worthwhile to read. If I can get past no-semicolon syntax. 
&gt;We recently used RxJS on a large, complex asynchronous project integrated with a bit third-party distributed system. Where is it? I am designing a new project. It would be great if you can share it with us!
Tl;dr the docs and errors are bad 
Hi /u/wprzecho, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just your pragmatists sites. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [pragmatists.pl](/search?q=%28and+site%3A%27pragmatists.pl%27+author%3A%27wprzecho%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|9|50% [blog.pragmatists.com](/search?q=%28and+site%3A%27blog.pragmatists.com%27+author%3A%27wprzecho%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|7|39%
&gt; Code examples rarely use real-world use-cases... This has been my biggest complaint about the state of documentation across the entire industry. *Nobody* knows how to produce actual, useful documentation.
I am sure I have seen one, but RSS is dying, so no incentives
Good on you for deducing the behavior through testing, instead of just writing a rant and linking to the `wat` talk for the 1000th time.
Inoreader is great
I used to, but they seem to be constantly changing it and stripping off functionality while adding useless crap in order to monetize it. Plus, reddit was throttling them. Now I am happily using inoreader, much better IMHO
Thanks! :) 
we built a twitch chatbot that controls an RC car using Node.js and a Raspberry Pi. The idea is that we wanted to have a car that can move around following commands sent from a chatbot over the internet (twitch chatbot in our case, but can be any chatbot).
heh I happened to have this [book marked](https://raw.githubusercontent.com/coodict/javascript-in-one-pic/master/js%20in%20one%20pic.png) follow up github link: https://github.com/coodict/javascript-in-one-pic
RxJS came about at the same time as Rx for .NET. I didn't look at RxJS, but kinda assumed it would follow similar conventions. Could that be why it doesn't follow the Javascript functional api guidelines?
 var limit = your_limit var sum = 0; var flg ; // default prime indicator for (let i = 2; i &lt;= limit; i++){ flg = true; for(let j = 1; j &lt;= Math.sqrt(i); j++ ){ if(j!=1 &amp;&amp; (i%j) === 0){ // ignore when j = 1 in order to include 2 as prime flg = false; break; } } if(flg) sum+=i; } console.log(sum); To get why we use `sqrt(i)` watch [sieve](https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif). Notice then he starts to discard numbers that are divisible by 2, then by 3 and so forth. Important detail is that when it comes to number 7 and discards number devisible by 7 (49,77) "all numbers that are left are primes". So the pattern is as following. What ever the number `x` that you try to figure is it prime, if that number is not divisible buy some number `y` for which stand that `y &lt; sqrt(x)` that number must be prime. Lets say we wanted to see if 49 is prime, if you look at that gif, you see that 49 wasn't divisible by any number up to its root. See, pattern. Cheers. Edit: mind that this is highly suboptimal for any large `limit`.
It's really hard and expensive to create and maintain documentation, but I hear you. Open source has helped a huge deal in that you can look in the code. On the other hand, if I don't want to read the source to find out why getGoats is returning bears and have the temerity to ask online, I'll get a bunch of fuctards telling me to "go read the source". Seriously, just answer the fucking question and save a bunch of people doing the same hunt through the source.
Huh, that last one actually works in Firefox as well, but not in Safari. I quickly looked over the Selectors spec and don't see anything applicable. Interesting.
&gt; RxJS makes the same mistake lodash did a number of years ago, regularly opting for variadic arguments to its methods rather than taking arrays Can someone explain what this means?
 function t (a, b, c, d, ...etc) {} vs function t (arr) {}
Ah, right, that was annoying in lodash. Though the spread/rest operator makes that a tiny bit easier to deal with
Eric Elliot Warning (I don't mind him, but for some reason Reddit hates him)
Do you just delete your screenshot if you make an intentional update?
The best way example imo is the vuejs documentation but yeah..... this is a chronic problem 
Yeah definitely isn't allowed in the spec. Interesting that both FF and Chrome allow it.
nice and very helpful for reference! wouldnt it be nice if you had some examples using the methods you list out. it might just be my opinion, but often when I go through documentation as a beginner its tough to understand some methods purpose and how to use it, where example scenario helps understand it better and makes it easier for me to take it and implement it in my code 
i think the gains over WASM will be much smaller. we'll have to wait and see :)
Stack traces for errors are super important. I was excited to see the "capture async stack traces" option show up in Chrome's devtools, but it's unclear to me when I can expect that to work. Is it just on native Promises, or will it work with third-party libraries too? If I'm using a library that's not yet supported, is there some sort of annotation I can add so it is useful in that context? (without recompiling Chrome.)
Do you? I'm not being sarcastic, I'm legitimately looking for someone or something that can show me how to write good docs.
Saved to read later!
&gt; for some reason Reddit hates him He's a better salesman than programmer, and he's become JavaScript's most popular source for misinformation. Anytime he mentions "composition" or "inheritance" or any remotely related topic, it's a good bet that everything he's saying is wrong. For example, C++ is as classical as it gets, and if I had a C++ class inherit from another C++ class, is that class inheritance? // C++ class A { public: auto a() {} }; class B : public A { public: auto b() {} }; Even the most ardent Eric Elliott fans have always answered yes, that's obviously class inheritance. But when [Eric Elliott was asked that question](https://medium.com/@xwt23v/i-m-genuinely-trying-to-figure-out-where-you-draw-the-line-between-inheritance-and-what-you-call-ab11d70f7aaa), he said the C++ example above is composition. It turns out Eric Elliott has been using his own personally invented definitions for "composition" and "class inheritance". What he calls composition isn't what the rest of the world -- nor the GoF -- call composition. The pattern that Elliott calls composition is actually multiple inheritance. People who learn from Elliott are led to believe they're favoring composition, but in reality they're abusing inheritance more than ever. And unfortunately, through good salesmanship and big personalities, Elliott's misinformation tends to spread. Here in this thread, for example, /u/Pyrolistical posted a link that also got composition wrong. That article sourced to MPJ, and MPJ learned it from Elliott.
The original shot always stays until and update comes down that you want to update to (I.E. a planned change). Should just be a key press of "u" in watch mode
I've purchased this course and it is excellent. I haven't purchased a lot of courses from wherever, but this is by far the best course I've ever seen, yet alone paid for. It's really fantastic to get up-to-speed with Vue 2 with routing, state management and some webpack/vue-cli. If you're looking to learn Vue 2, I cannot recommend this course enough. Don't pay $190 for it, though, wait for it to go on sale for ~$15 bucks. Just keep the course page open in a tab and check it each day - Udemy courses, from my experience, go on sale all the time. [Max is also on youtube](https://www.youtube.com/channel/UCSJbGtTlrDami-tDGPUV9-w/videos), which is where I first found parts of his Vue course, which led me to Udemy. Here's a direct link to the course as well (link at bottom of article looks to be some type of referrer link, so if you want to avoid that): https://www.udemy.com/vuejs-2-the-complete-guide/
&gt; Console.log(default.msg.object1) can you show me a example with getter and setter? I did that works welll but it doesn't replace email: var defaultx = { email: "blah", setMsg : function(n) { return email=n; } }; console.log(defaultx.setMsg(66666)); console.log(defaultx.email); 
I understand. Now. there was a guy who posted that ancient algorithm. And saw a youtube video how it works. And attempted to use it. Now my program executes in 30 seconds. Before it did in 15 minutes. Here is my code I am so proude. let arr = [] let arr2 = [] let sqrt = Math.floor(Math.sqrt(2000000)) console.log(sqrt) for(let i = 2; i&lt;2000000;i++){ arr.push(i) } function isPrimeNumber(x){ if(x&gt;10){ if(x%10!=3&amp;&amp;x%10!=1&amp;&amp;x%10!=7&amp;&amp;x%10!=9){ return false } } for(let i = 2;i&lt;x;i++){ if(x%i==0){ return false } } return true } for(let i = 2; i&lt;sqrt; i+=1){ if(isPrimeNumber(i)){ arr2.push(i) } } for(let i = 0; i&lt;arr2.length; i++){ arr = arr.filter(event=&gt; event%arr2[i]!=0) } arr2 = arr2.concat(arr) console.log(arr2.reduce((a,b)=&gt;a+b,0)) 
Its $10 course with coupon code -&gt; [View here](http://gainfromhere.com/online-courses/)
I agree Elliott's definition of composition is wrong, but what is your definition of composition then?
I have never been able to find one good answer in RxJS docs. It's extremely vague and unhelpful IMHO.
That is a challenge with web proposals: how can you make it easy to swallow for vendors (who are often the same people as the working groups)? Still, if this proposal is successful and WASM proves popular, maybe the ball will get rolling on efficiencies of increasingly larger scope. Thanks for taking the time to share that info.
Holding one object as a member/attribute/property of another. Composition: const a = { aMethod() {} }; const b = { a: a }; // b HAS-A a b.a.aMethod(); Inheritance: const a = { aMethod() {} }; const b = Object.create(a); // b IS-A a // That is, b fulfills a's interface and borrows a's implementation b.aMethod(); Also inheritance: const a = { aMethod() {} }; const b = Object.assign({}, a); // b IS-A a // That is, b fulfills a's interface and borrows a's implementation b.aMethod();
[most.js](https://github.com/cujojs/most) is so much better. It focuses on speed and embraces functional programming by conforming to the fantasy land specification.
Nulll
Still, watch out, that will eat up at least: integer in javascript: *32bit* integer count: *2000000* 32*2000000/1024/1024 ~ 61Mbits of your ram for every call.
&gt; Though the spread/rest operator makes that a tiny bit easier to deal with But slower in performance, unfortunately. 
&gt; and is written in typescript, so users will need to learn some typescript before they can understand the codebase. Yeah, it's pretty hard to understand typescript if you only know javascript /s &gt; Which version should new adopters use? I have absolutely no idea. Oh, please. 99.9% of all people will default to the latest version unless they specifically need an older version. hell just type `npm install rxjs`. While the docs could be better and it would be nice if there were more tutorials etc. it's still a newer library, so it's a little early to be complaining about this.
Thank you for the write up! I have referenced this post in the FAQ part of the README :)
You might look into https://github.com/photonstorm/phaser I made a few small demos with it and it's really powerful with great performance. There is also an IDE specifically for this.
&gt; You're not completely wrong Haha thank you so much :) &gt; but your response was written to an absolute that "JavaScript is overtaking the world", which was a hyperbole. You and I do know that, but the random guy spending his days on StackOverflow doesn't, and simply has no idea about the iceberg thing. Once again, I have nothing against JS or scripted languages. I use them when/where they fit. But many people work on stuff where it simply doesn't make any sense to use JS. Sometimes you need to manage every single byte of memory you are allowed to. Sometimes you need to talk directly to the hardware. Sometimes you need speed. Sometimes you need reliability. Sometimes you need small binaries. Sometimes you need to embed assembly. The list goes on. And even more important, sometimes you need to rely on someone who has 30 years of experience with C...and that guy would slap you if you mentioned that JS might be an option. Not because they don't want to change, but because they just know it doesn't make sense. This all is written by someone finishing a 300k LoC Node.js app...and the choice of Node.js is all mine ! :)
It works just like a normal jest snapshot in that you can update it by running jest with the -u flag once you know you are ready to update the baseline snapshot.
Irrelevant 90% of time.
I usually do both. Answer the question then "btw you can always look in the source. In this case you'd want to look at file src/File.js line:123"
\+ waaa, 2 versions, wtf, what do I use, I don't have time to do research
I get your point. But don't understand how you got to there can you please make it more simple.
You might be asking to see proprietary code
That is pretty cool! I still don't get how that regex gives you a coherent sentence...
I think your last example can be thought of both as IS-A and HAS-A. Consider this. * Given I have a.aMethod() and b.bMethod() * I desire object c that has c.aMethod() and c.bMethod() I would disagree if you said c IS-A a and c IS-A b, I would rather say c is composed of a and b. Or c is the union of a and b. I don't think this is multiple inheritance because A) I never used extend and B) I never considered a and b to be types. I considered a and b to be objects that happen to have methods on them.
if I have an app that really needs performance, on a desktop or high end laptop (where you might find a decent gpu), I aint about to choose javascript. That would be stupid, just making extra heat and wasting electricity and not even close to the performance the machine can deliver.
he gets paid millions because he's probably well known and is good at marketing himself (maybe he does conference talks); he's not simply good at writing code. if you make yourself a good website, you could easily make 75k (assuming you're also good at code). to make a 100k+, you have to be good at taking business requirements and translating it into broad, production-quality software architecture/platforms. of course, it all depends on the market rates you're in. someone doing JavasScript in SF is gonna make more (on average) than say, Moscow, Iowa. spoiler alert: you're extremely unlikely to make &gt; $250k, let alone "millions" in web dev. in fact, very few technical engineers [of any sort] make millions.
I would also recommend in situations like this that you look at a resource like the w3schools page on JavaScript functions as it is often easier to read than the js docs and would show you a few things you were doing wrong originally (it mentions that the parameters to the function, the things in parentheses, are listed like, separated by commas) even if you can't figure out why what you're doing doesn't work, you should be able to see what looks obviously different than the spec.
&gt; I would rather say ... c is the union of a and b. You just described multiple inheritance. :-) Let's look at another C++ example. I presume we at least agree that C++ classes and inheritance are as classical as it gets? Here's C++ multiple inheritance -- that is, still ordinary inheritance, but without being restricted to just one parent. class A { public: auto aMethod() {} }; class B { public: auto bMethod() {} }; class C : public A, public B {}; // ... C c; c.aMethod(); c.bMethod(); Here we have a C++ class that C++-inherits from two C++ classes. This isn't composition just because we inherit from two classes instead of one. It's still inheritance. &gt; I don't think this is multiple inheritance because A) I never used extend Try to see past the labels. `Object.create` isn't spelled "extends", but that's inheritance. The C++ examples also never say "extends", but that's still inheritance. Forget about the superficial labels and focus on the behavior of the end result. EDIT: &gt; I would disagree if you said c IS-A a and c IS-A b There's a concrete test to know when there's an IS-A relationship. [IS-A is when A’s speciﬁcation implies B’s speciﬁcation](https://en.wikipedia.org/wiki/Is-a). And that's exactly the case we have here, regardless of whether it's spelled "extends" or "Object.create" or "Object.assign". C satisfies B's specification, so C IS-A B, *and* C also satisfies A's specification, so C IS-A A.
Kefir and bacon are also worth looking at. For some reason I keep going back to RxJS though.
once the shaders are compiled, you're getting the same native performance as you would by utilizing GPUs from any other language (assuming you're not using super-specialized GPU features). if you need low latency, then you'll definitely want something closer to the metal, though.
Works perfectly! Thanks everyone! 
So downvote me for warning people about the 10% of the time that they will *definitely* care? Cool. What a community. 
The only documentation I find myself raging about is what fucking parameters does it take and what should they be. 
But that's the problem. You claim "C satisfies B's specification", I disagree. I only assert "C contains a method bMethod()" So what if it came from B.bMethod(), that doesn't matter to me.
&gt; You claim "C satisfies B's specification", I disagree. That's uh... that's not really an agree or disagree kinda thing. It's an observable, testable fact. Here's an even more concrete test. Imagine you have unit tests to verify that your "b" object works correctly. But rather than passing in a "b" object, you pass in a "c" object instead... and the tests still pass! Then "c" IS-A "b".
Wasn't this just posted a week ago? Also it's kind of funny that the article calls a 2015 Macbook Pro a "powerful" machine with its AMD Radeon R9 M370X that's weaker than some integrated Intel GPUs.
&gt; Constant variables are not necessarily immutable (their value can change), but they can't be rebound to another object or primitive. This isn't true. A value assigned to a constant can not be changed. I think what you're referring to is altering arrays and objects by reference. const myObj = {}; myObj.prop = 7; You're not actually changing the value of `myObj` here. `myObj` is a pointer to an object in memory. You've declared that pointer using `const` and, as such, it can never be altered. The line: myObj.prop = 7; is using the pointer stored in `myObj` to locate the object in memory, but is making a change to the object itself. The same works for an Array. const myArr = []; `myArr` is a pointer to an array in memory. So, it may ***seem*** like you're altering the value stored in your `const` variable, but you're actually not.
Battery die die die .... 
 &gt; It's used to do things that used to be covered perfectly well by CGI - or even by HTML itself. I deeply resent being asked to use my processor to do whatever calculation to determine the name of the file to display. You're the one providing the service, you figure out the filename on your CPU. Worse yet, the JavaScript in these cases often takes its data from forms, which look identical to forms that issue a CGI request. SPA are becoming increasingly more common due to scalability and maintenance benefits. If developers can share the workload with the users computer and thus save time, headaches, and money - why wouldn't they? &gt; JavaScript is the wrong way to do form validation. You have to check again on the server (you can't trust the client), so you have to make the same tests in two places (client and server) and (usually) in two different languages, which is a nightmare to maintain. Both client and server validation are expected for modern websites with economic applications. Why should users have to wait for a page reload to find out that the username they chose is taken, or that the phone number they supplied is missing a digit? You mention the validity of this viewpoint, but I think its of enough merit in the UX department to really hammer it in. Almost everything you talk about increases product quality, decreases time spent by the developer, or has a clear and tangible economic benefit to the owner of the site. There are a few exceptions such as spammy popups, but for the most part this article sounds like an ideologues manifesto. At the end of the day, most software and websites are business applications. They exist to make money or to support someone in making money. We code things to meet the demands of the market, whether that be clients or users. 95% of people using the Internet demand modern features. If they didn't want it we wouldn't write code that way. Bitching that Mosiac users can't use the modern web isn't solving anything. Unless I'm writing a site for a bank, hospital, or government entity, I don't even bother checking it works in IE. Technology moves fast, and developers cost insane amounts of money. Let's not waste time on making things nice for 1% of the market unless its a real threat to the bottom line. 
When is this a concern?
So you are doing duck typing, fine. I understand why we disagree now. You are thinking about the problem using a traditional OO type system, where as I think about the problem as just a bucket of objects and functions. I don't care about IS-A. It gives me no value. I only care about getting an object with all the methods I care about. I have no concept of inheritance hierarchy in my system. So A union B is just a means to an end to get all the methods into a new object, and NOT trying to express IS-A. 
&gt; you're getting the same native performance as you would by utilizing GPUs from any other language I don't think invoking pixel shaders via WebGL 2 an particularly efficient way to implement GPGPU... native languages would at least use compute shaders if not OpenCL/CUDA.
I upvoted you both. Because you're both right. Happy?
To be fair, they're only flat-out wrong like 10% of the time.
My first job out of code bootcamp was at a small SaaS company where my predecessor had chosen RxJS over Redux because the latter "wasn't mature enough." I got really good with it. The learning curve was steep and the infrastructure my predecessor built around it was fiendishly complex, but I eventually fell in love with it. Still, I wish I'd had the seniority (while greenfielding features on different endpoints with different code bundles) to say "this is the wrong tool for the job, we're using redux." My big takeaways, in no particular order: - Rx isn't terrible for state management using the `scan` operator. - Observables that `combineLatest` a whole lot of state together are hard to test without mocking All The Things. - For all the warnings in the React docs about not using `context`, it works fine for Redux and MobX. Subscribing your observable state tree like `stateObservable.subscribe((state) =&gt; this.setState(...state))` and then passing `...this.state` as props is fucking hideous.
I think I vaguely understand this, but what I'm still confused about is how that message got there in the first place. I understand how it is encoded, replaced, parsed, but that all required that message to be there in order to begin with.
lol I got caught completely off guard by this
I tend to be too wordy. Which is a different problem.
This is prob a xss here....
Some MSDN and MDN content comes close. But for every good example, even there, there's at least one bad one.
Wow this looks amazing! Is this web browser only or can it do native desktop and mobile apps? Or can it be combined with something like React Native? Just found this.. Looks like Cordova can build Phaser projects for iOS, Android, Windows 8/10, Windows 8 phone, Chrome, and "Web Application" (whatever that is): https://www.youtube.com/watch?v=7qe2XOkubL0 edit: Or maybe React Native for Web or ReactXP? https://microsoft.github.io/reactxp/ 
&gt; Days and days of development were lost to bisecting a long pile of dot-chained functions in order to isolate the one that raised the (usually stupidly trivial) error. Brutal.
It's easy you just learn to not use semicolons anymore I find punctuation to be redundant anyway can't you all just understand what I mean anyway it's not that hard just read it
From the bacon documentation: &gt; In addition to EventStreams, bacon.js has a thing called Property, that is almost like an EventStream, but has a "current value". So things that change and have a current state are Properties, while things that consist of discrete events are EventStreams. It could be so simple. I've watched many videos about RxJS but I still can't tell you what's the RxJS equivalent of bacon Properties. This already sounds so much easier. Thank you for naming these examples.
....what xss has to do with anything in this case?
The message was in the tweet. You only get it if you copy and paste directly from the author. The magic 'A' was the key in the object literal. If you were just to type a single 'A' yourself then no, there would not be a message. 
A saint amongst men
When you've gotten to the point where you've profiled your code and seen that the rest/spread operator is the cause of poor performance in your codebase. Anything other than that is just premature optimization. If rest/spread makes your code more concise, more readable, and/or easier to write, then use it.
Considering what this needs on the backend, and since it looks like MotoCMS hosts your site(?), I would ask them for a module. 
Nicely done mate
Please correct me if I'm wrong. The 'A' alone is what is rendered as the first letter of 'Always'. Each subsequent lowercase letter in the output is added individually by converting 2 back-to-back invisible characters' unicode codes into an ASCII code. So if I wanted to write a 'b' (ASCII code = 98 decimal or 62 in hex) I would find a pair of obscure invisible things whose unicode codes together are something like %uXXXX%uXX62. The regex then effectively chops off the first u + 8 more characters, leaving me with %62. That hex value unescapes back to 'b' and I can thus alert 'Ab'.
Correct. At least that's how I understand it. 
Both of you made valuable points, and his comment didn't negate yours. Chill. 
I'm thinking hide a script in the invisible characters that decode into a valid js which then gets eval. When ppl come back to find the bad code, they see nothing
TypeScript would change your life. 
I was at -13. Excuse me for being angry that people are annoyed that I pointed out reality. 
But what's the advantage of the latter?
&gt; You can create a Property from an EventStream by using either toProperty or scan method. Sounds like the `scan` operator from `rxjs` would be analogous. 
My team is pondering refactoring our mobile apps (built using React Native) to using either Redux, or a similar architecture built using some observable library. I was initially thinking RxJS (since I know it quite well), however I do remember the learning curve being quite brutal. Is there another observable library that ya'll suggest? I've also used Kefir, but I'm afraid it not might be mainstream enough to find help on stackoverflow/etc..
&gt; Thoughts? Is this something that someone with limited skills can pull off? I don't think you should expect to be able to pull this off with a time crunch. Sounds like you'd probably need a couple months of study.
I'm the RxJS project lead, and I actually agree with this complaint. Many of the APIs that exist in current RxJS exist because they existed in previous RxJS. The original APIs for RxJS actually come from Rx.Net. This is because RxJS was originally written as part of Microsoft's project Volta as a compilation target for Rx.Net code. The process is ongoing, and I would love to see issues and PR's around making our APIs better than they are.
React Bob.
Hi, I'm the lead on this project. I completely agree with this statement. The documentation is a sore spot. And I would love to get more examples in there. It's been on the agenda for a long time. However, I have bigger fish to fry trying to reduce the size of the library and improve RxJS's tree shaking story, and I really only have about 8 hours a week maximum to work on it. Honestly I would love to get the author's help with our documentation rather than see the hard volunteer work of some truly decent people berated. Even though I do understand the author's frustration. Sadly, RxJS is maintained by very, very few people and only in their voluntary free time. A lot of people think I get paid to work on RxJS full-time by Google, while that might be the case someday, right now that's simply just not the case.
What are the JavaScript functional API guidelines you're referring to? 
[flyd](https://github.com/paldepind/flyd)
The sentence is encoded in the name of the property. Each letter is hidden by unicode witchcraft. The regex removes all the witchcraft and just leaves the sentence in plain text.
Balls - I copied and pasted it.... that code is so bollocks. Thanks... I need to look elsewhere.