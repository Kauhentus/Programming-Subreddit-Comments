I'd say start by experimenting with it! Just come up with a simple idea and try to create it, use google as you go along. Like, try to set up a button that pops an alert when you click it. Then try to add an input box and make the alert say what was in the box. Keep evolving your pointless ideas until you feel like you are getting the hang of it - at that point, look for an online javascript course.
Should be often faster than CSS cuz it replaces width and top etc animations with transforms. Outside of that there’s obviously the JS overhead that you don’t get with CSS. But, I haven’t optimised that homepage by only running animations when they’re on screen yet and it’s running well even on slower machines. 
+1 Definitely build yours from scratch. Especially Webpack4 now does things a bit differently.
Reminds me of PHP (in a good way). My only observation is that code strings in the interpolations won't get picked up by babel, so you're going to be limited to what ES6 features you can use if you need to support older browsers.
It'd be pretty trivial for this to be a standalone script without requiring Reddit Enhancement Suite.
Yes. Don't block HTML parsing while the page is loading by putting the script in a separate file, put it in the header because it's information on how to interact with the content without actually being content itself, and use `defer` as a shortcut if you don't want to wrap everything in a DOMContentLoaded listener.
I see. But what if we put scripts just before body tag? It only loads slower?
If I’m ever building a site for abominable snowmen I’ll use this
It probably loads at (very nearly) the same speed (the same, if the script has already been downloaded), but I think it semantically belongs in the header instead.
I didn't think Reddit had a feature to filter out subreddits without RES?
I'd mix a bit of both. Just setting yourself a goal of a thing to make, and getting on with it, is great - but it can leave you with some bad practices, and fundamental gaps in knowledge. I'd balance doing that with going through a guide from a respected source like https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide
I always use defer. Since both methods do the same job I find it more natural to put scripts in the header where I have all my external assets in one place instead keeping them spread across whole html file.
You're sharing built code, so it's a little hard to say - we can only speculate But from the looks of things, the popover is coming from a JS binding - so you'd just need to look for the `onmouseover` event that's happening and bind it to another (smaller) element, which shouldn't be too hard (but could potentially be, depending on how the JS is done) The opacity changing is definitely easy, though - it's a simple `opacity: x;` css property
Ifølge YouTube put a script that actively change elements on the page, at the bottom, you will get a 'content flash'. This is ugly.
Really great article, thanks for sharing!
Is it ok to use this and any codepen for commercial website?
Can you change it to the opposite pls? Everything i want to see are cats
Oh wow, that's cute. Nicely done!
I firmly believe that `new Function` does not belong in a templating enginge...
WTF. Did you even read the title? 'values are strings'? Like it says on the tin: "Typed **Object** Model". "Instead of strings, **values are exposed as JavaScript objects**" 
WTF, read the fucking article itself not just the title. el.attributeStyleMap.set('padding', CSS.px(42)); 'padding' is now a string even if what's in it is typed.
"padding" is not a value, it's the property name. 42 is the value here.
cannot use when supporting IE sadly
Got me, OK. Please re-read my comment with "value".
He isn't but I am - thanks for pointing this out man I'll have a look
Will make sure I do :)
From my experience it is usefull if you refresh your knowledge about `closure`, `scope`, `event loop` - how synchronous engine handles asynchronous operations
*cough* forgot to commit
When Pose detects a user trying to animate size or positional properties like `width` or `top`, it will automatically perform a FLIP animation. Fully explained here: https://popmotion.io/pose/learn/flip/
Not yours right? Dont show off other peoples work claiming its yours!
https://caniuse.com/#search=defer supports ie 10 perfect, ie9 partially?
You can still use it even if IE doesn't support it. It will just be ignored and people who haven't upgraded to a real browser will just have to wait.
Everyone already knows that vanilla JS is going to be faster than using a framework that runs it's own code on top. That's a no-brainer. But people don't use frameworks/libraries because they run faster (although they're a deciding factor when choosing _which_ one to use). It's because they are easier to use in the correct situation. I'f I'm building an SPA/widget, I'm going to use Vue/React/Angular. That's what they're built for. They provide the framework to perform the jobs they describe. I'm not entirely sure I understand the point that this article is trying to make.
Does this work with flow or TypeScript?
Lots of cringe here
&gt; it will often need to process tainted data Can you elaborate on this? new Function/eval are only dangerous if you are allowing arbitrary user input and saving it somewhere, or downloading logic from somewhere else and executing it in your environment. Using eval and new function are perfectly valid ways to approach certain classes of problems and the security concerns are completely unfounded from what I can see. 
Don’t think op claimed it was his
Use TypeScript :)
Yeah you can add a type layer like Typescript of flow, and if that’s not an option or you want to use vanilla js, you can validate your params. For example, you can throw a TypeError if a param was expected to be a string, but was a number. You can totally do this for each property of object params. It sounds like some of the problem is shitty architecture too. There are design patterns for creating JavaScript functions that are intuitive, and using something like jsdoc to document your code is a must if anyone else is going to work on the codebase.
If you really want to keep strong typing, use TypeScript or Flow. If not, well welcome in the world of weak typing :D I mainly work on React projects and we are very strict on PropTypes precision which suits us. But in most cases, I just don't have to worry about the type of my variables, because I can check very easily which type it has by looking at the code (Array =&gt; .map / .filter high order functions for instance / Object =&gt; access key / int =&gt; addition) And we try to keep good naming conventions (isXXXX / hasXXX are 100% of the time booleans), functions and method always start by a verb or "on" for some events etc... Not that we don't allow string concatenation, only string template so if I have "a + b", a and b must be int. 
From https://codepen.io/dsenneff/details/QajVxO, pasting below &lt;!-- Copyright (c) 2018 by Darin (https://codepen.io/dsenneff/pen/QajVxO) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. --&gt;
yeah, I dont know that I want strong typing - obviously weak typing makes a lot of things trivial tha would otherwise take quite a lot of mucking about to achieve in a strongly typed language. But strongly typed function signatures are transparent, whereas weakly typed ones seem like detective mysteries to solve. 
I never used neighter Flow or Typescript but I think that at least Flow allows you to just type whatever you want (if you want to type the type of return but not the type of the variables for instance). I must admit that typing is kind of a mystery for me. When I do Java, I spend hours thinking about "what is the type I must put in front of this Map of Map of String". And when I come back on JavaScript, I almost never find myself infront of a situation where I struggle due to the lack of strong typing. 
Use self discipline. * Use sensible names for parameters. * Document what values parameters should hold in the function header comments. * Have functions test parameters for invalid values at the top of the function.
TypeScript &amp; Flow come to mind (one or the other, not both): https://www.reddit.com/r/javascript/comments/7bfwpl/flow_vs_typescript/
Also, I'm pretty sure we can just keep things in the header anyway as HTTP/2 is more adopted. 
And the question ? :D class GmMessage extends React.Component { render() { return ( &lt;div&gt; Hello {this.props.message} &lt;/div&gt;); } } ReactDOM.render( &lt;GmMessage message="Good Morning, have a great day!" /&gt;, mountNode );
Thank you codebyte and hacker rank are really useful. That's a great suggestion. 
Hi /u/haganenorenkin, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Amen. lol
See https://developers.google.com/web/fundamentals/security/csp/ TL;DR: if you use a content security policy (and you should), things like `new Function` only work if you specify `unsafe-eval` in the source list (and that's something you generally don't want). Some environments have CSP on by default (e.g. browser plugins)
It’s dying?? I never used it... should I feel justified?!
THEN HURRY UP AND USE IT BEFORE IT VANISHES!!!! :) Nah, seriously, if you've never had an actual need for it, no problem!
Assembly is crazy faster than C++, yo.
&gt; Even when an attacker can't inject script directly, they might be able to trick your application into converting otherwise inert text into executable JavaScript and executing it on their behalf. eval(), new Function(), setTimeout([string], ...), and setInterval([string], ...) are all vectors through which injected text might end up executing something unexpectedly malicious. CSP's default response to this risk is to completely block all of these vectors. I appreciate the link, but I think it only helps illustrate my point even futher. It seems many people mistake eval and new function use as the same thing as cross origin scripting, cross origin scripting is something you shouldn't be doing if you have *any* other choice. However, using eval or using new function within your application is the same as using setTimeout and no one bats an eye about using a setTimeout in javascript. TL;DR: Cross origin scripting is a bad idea, as is allowing arbitrary user input that executes on your backend. However you shouldn't concern yourself about using eval/new function in your app logic in the cases where **you** control the input and **you** only parse a standardized result. 
Redux goes a lot beyond just storing data that you've fetched from remote sources. Redux gives you a middleware-based unidirectional architecture that allows for better structuring of your app. I've seen a lot of new state management system tools arrive recently, but none beat the middleware architecture that Redux gives you.
A conservative CSP will disallow all classes of eval-like behavior, including setTimeout(string) and friends. The problem with the "you control the input" line of thinking is that you don't necessarily know whether you're the only one who has control over the things you think you do. There was a great example a while back where someone noticed you could attack Vue by exploiting the fact that it indiscriminately runs various HTML constructs as trusted code, regardless of whether that DOM was created from a 3rd party script or not. As it turns out, it's common in the real world for code from many different stakeholders to be running side-by-side in a single page. Code from the app developer, library authors, analytics services, a/b testing, etc. A security policy is exactly what it says: a policy. It is crafted as a blanket response to the fact that things like eval-like constructs do and have caused serious vulns over the years. One can argue that XSS can be mitigated manually and you can still retain the ability to `new Function` if you are zealous, but that generally falls apart as soon as you have a bug bounty program and a miss costs you a few thousand dollars (or worse, you actually get attacked). 
Really buggy and jumpy on iPhone 6s
Cool. Only thing I have a problem with is yuml. It sucks. Plantuml is a lot better and would give you the option to extract other diagrams like sequence diagrams. Plus plant isn't a web service only.
Redux will probably outlive React. Apps built with Redux are just far easier to maintain than apps that use any other state management strategy.
Awesome, I'm going to try to give a go to https://www.npmjs.com/package/node-plantuml Thanks for the feedback! This is why I thought it was good to do an alpha release :) 
100% agreed.
Keep individual portions of the program simple enough that you don't lose track of what variable holds what value?
Yeah Pose itself isn't bound to a framework. `react-pose` is a seperate package
we should all code in Machine Language cause its the fastest yo!
I'd be willing to have a look, if there are particular parts you need checking? Also, I'd request you do something for me in return.
The churn in this field is insane 
When I say "attack", I mean any technique that can be used to elevate permissions, theoretical or practical. The problem in the Vue case in particular is that you typically don't think of static HTML as a eval-like, whereas with Vue you must, and that is a counter-intuitive default. Just because it doesn't have an impact in your thing doesn't mean it doesn't have an impact for all things generically. If you leave a known weakness alone, and there happens to be a compatible weakness somewhere else, the combination of techniques can become a viable practical attack. If you can prevent an entire class of vulnerabilities by "outlawing" a questionable practice, then why wouldn't you? You seem to be arguing that if you have a security hole, it's going to be somewhere else and not with `new Function`, and sure, this may be the case a lot of times. But there are times when it isn't. There was a post here last year where someone had written a perfectly innocent looking templating engine, but as it turns out, I found a way to exploit it based exclusively on the mechanics of `new Function`. Had that snippet gone into production at Google or Facebook and they specifically disabled CSP to "make things work", you can bet it would've caused some damage. Also, if something goes awry, it shouldn't matter who's at fault. That line of reasoning is poisonous, but that's for another time.
Well, what exactly are your concerns regarding structuring and reusability? Do you want to write a function that can take in a couple of arguments and return different timers? I guess what I mean is; what else do you want this function to do?
This is hilarious 
There are a lot of example problems for job application coding challenges online that you can tackle and websites like codewars have thousands of coding problems at every possible difficulty level. I would also suggest reading https://github.com/getify/You-Dont-Know-JS. Particularly the sections about "scope &amp; closure" and "this &amp; object prototypes". I also made flashcards for string and array methods (taken from MDN) and then wrote small functions using each one. These can really help you so long as you're confident in their usage. I am also a HUGE fan of Stephen Grider's online courses on Udemy. They're always on sale for $10-$13 and I've learned a ton from them. I think having a portfolio can not be understated when looking for work without a certificate of formal education. Make a GitHub if you don't have one already and try to push code to it everyday. Pin your app repositories and include a link on your resume. Finally, don't get discouraged, each interview/coding challenge is a learning experience and each "failure" will only serve to prepare you for the next opportunity. Good Luck!
Sure, knowing I have limits! 
Cool. So what do you need me to look at?
Neither framework is "better." Both can be used to build powerful and maintainable web applications, and if anyone claims otherwise they're a fanboy whose opinion you shouldn't trust. To truly compare the two you'd need to read some of the (many) articles posted which compare the two in greater detail, but I like to sum it up this way: Angular is about putting logic in your mark-up, while React is about putting mark-up in your logic. Personally I use/love React, but again both are perfectly good.
Personally I'd move `tick` out of the function it's in and make `counter` a module-level var. I feel like discrete functions are easier to maintain than nested ones (it's much clearer what their inputs/outputs are, and you only have to wrap your brain around half as much code at a time).
I use Redux without React.
He just said it's not dying.
well I can't tell for sure. Something that would be like.. in own scope but have a worker function outside to be used with some arguments from within, I attempted but I am not sure if it's good, this all seems messy and I am pretty sure this comment is messy :/
Well, idk how that would look :/ if you have a bit of time, reorder it? if not it's ok, thx either way
Are you some kind of artist?
I don't understand the down votes. 
Who is not creating while coding? :) - I use Redux server-side with Nodejs to store transient shared session. Each peer dispatches actions from client to server via a socket, and the server propagates the actions to all the other peers. - I also use Redux with PhaserJS. - My colleagues use Redux with D3 and A-frame
You are correct in that the article states the opposite, namely that redux is here to stay and that there is no reason to jump on to the next flavor of the month. My comment was aimed at the fact that some people are now under the impression that they have to move their app to context or unstated asap because it's new. I should have been more explicit and should have provided more context to my post. I apologize for angering reddit. 
&gt; That line of reasoning is poisonous, but that's for another time I find your entire line of reasoning as poisonous because it dissuades people from using legitimate language features due to your ignorance on the fundamental security issues at hand. You are interchanging two entirely different classes of exploits and labeling them as the same, in effect you are limiting javascript as a language from expanding to certain use cases that might require the use of `new function`. &gt; sure, this may be the case a lot of times I am arguing that this is the case **all** of the time, by time new function becomes a concern you have already lost the game. You are proliferating advice from a place of legitimate concern but also a place of ignorance. 1. Can people misuse new function? Absolutely 2. Is every use of new function a "misuse"? Absolutely not 
I've been spearheading adding redux to an AngularJS application and it seems to be going pretty well. It was a pain getting the team on board with the ideals but the integration itself was pretty simple.
You should definitely write a blog post about how to do it. I failed because I cudn't find anything on how to use redux with angularjs. 
How it would look? Instead of: function a() { function b() { it would look like: function a() {} function b() {} Also I'm not sure what you want me to "reorder"?
I think it would be best to either just output plantuml syntax to console or to a file and let a user invoke plantuml themselves, because there are a lot of output options like latex or pdf.
Hi /u/accordionjavascript, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/samnelson15, For javascript help, please visit /r/LearnJavascript. Thank you!
Ok I'll take a look. Where is the best place to read the entire thing?
I'm really into looking for subscribe, but hummm...I don't know Anyone here is a webstorm poweruser? I'm a visual code user and it works great, but webstorm feels more solid
What do you mean by "failed"? What happened? There's [Redux binding libraries for Angular1 and Angular2+](https://github.com/markerikson/redux-ecosystem-links/blob/master/library-integration.md#angular), as well as other frameworks. There's also the [@ngrx/store](https://github.com/ngrx/platform) library, which is a reimplementation of Redux built around RxJS. So yes, there's plenty of people using Redux with Angular already.
send me email and I'll email you any format you wish. I suggest starting with the Amazon sample to see if you enjoy the style. If so, ask and I will ship it over!
However they all beat the design of Redux and I don't think it's close. I think if Redux had as clean an out of the box implementation as some of the other Fluxy libraries out there we'd probably consider it an essential part of almost any React project!
Nope. It's worst in many cases. I don't understand why people use it in many projects. Application flow is hard to understand. There is no inheritance, abstraction layers, and mass of boilerplate code.
&gt; There was a post here last year where someone had written a perfectly innocent looking templating engine, but as it turns out, I found a way to exploit it all the way up to arbitrary code execution based exclusively on the mechanics of new Function Sorry, but you're saying with this `template engine` that you can get a user to run arbitrary code that the "original web dev" hadn't intended for the user to run? 
Mobx, or vanilla react. 
`state = {}` Transform Class Properties my dude 
Maybe you're just used to something different. Redux is much easier to understand than inheritance chains, and it's less bug prone too. The application flow cold hardly be simpler. It's just pub/sub. Components dispatch events, reducers apply them to state, and components subscribe to state changes. You get a single source of truth and predictable data flow.
I feel like there's a language barrier here. My point is simple: if you nest a function it makes it harder to work with. You have no idea whether the variables within it are global/module-level, whether they were passed in to the function, or whether they're shared scope variables form the parent function. But if you separate the two they can be read and understood independently, they can be unit-tested separately, etc. All code is subjective, but I think there's some fairly objective agreement among programmers that you should only nest relatively simple functions inside other functions (if you even do that).
You don't need an entire extension in order to run your own script on a page - just write a few lines of code and inject it.
Agreed. We are still maintaining a Meteor app that’s essentially nothing more than a DDP server. I’ve looked at the code a few times and it’s pretty componentized already. I’ve contemplated extracting the modules needed and maintaining a repo within our team, but the idea of maintaining someone else’s code that way just troubles me. Instead, we’ve been slowly shifting away from Meteor. 
The underscore is a variable, but since it's not used it's a common practice to assign unused parameters to the `_`, so those looking at the code know that it's unused. What it's actually doing there is allowing the `x` variable to represent the index of the current element. ***** It also sometimes refers to the [Underscore.js](http://underscorejs.org/) library, but that is not what it's doing here.
`_` is often used as a throwaway variable. In other words, just ignore it. It's the same thing as this: [...Array(5)].map((unused, x) =&gt; x++);
Ah, thank you. I should have looked at the doc for .map() as well. Much appreciated. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
They need the index, which is the 2nd variable passed to map. If you take it out, you would lose the index.
I like how it peeks when you click the "Show" box
Ah i see
I know but Reddit doesn't have a feature to even save a filtered list. Only RES does
Thank you.
Thankyou for your help!
Glad I could help.
The framework doesn’t matter. As long as you can make an API call, you can use whatever framework you want. 
I am sorry I forgot to take this down or edit it! I actually found the answer about 3 hours after posting this. Ty though
The problem here isn't the use of new function in your examples. The problem is lazy programmers, it's quite obvious that you probably don't need to do most of the logic in your examples but i digress. Coming up with a list of "safe parameters", and validating against that list would ensure that `v` never contains anything that isn't explicitly defined before hand, pretty straight forward. Again the problem isn't the use of new function, it's the lack of validation before using it. "Arbitrary input"
It’s used to indicate an unused param. Also,if you use ’Array.from()’ instead of the Array constructor, you could do the same with this: ’Array.from({ length: 5 }, (_, x) =&gt; x);’ as it takes an optional map function as the second argument.
Windows only wins because it is forced on developers. I'd much rather use osx or Linux but can only use Windows at work. Don't really understand why it is forced though.
Ah, My bad. It was unclear. I mean multiple react or Vue apps. I want to make a lot of small apps. One app could for example fetch a user's invoices an display them. Another app would fetch the users contact information and also let the user edit the contacts. And then I would be able to just put these apps in to whatever webpages I want. The apps would be like black Boxes that could be used wherever, and live on the same page. Like components but more independent. Like microservices on the front end
For some reasons I never thought of using Redux with Phaser. It seems obvious now but you just blew my mind lmao
The article is insightful. Redux is powerful when it is used in the right place but cumbersome when used everywhere. My current interpretation towards React + Redux is to try my best to use state and props for better code encapsulation, and treat Redux store as a database providing global data and controls.
It is cute and user friendly. Thanks for sharing.
I find this much more readable, although I might use an actual word in place of the "_", such as "unusedVar" or something
What would this output? for(var i = 0; i &lt; 10; i++){ setTimeout(function(){ console.log(i); }, 100 * i); } 
What data layer are you using then ? What's a good self hosted realtime data library if Horizon is dead and Meteor has its own issues ?
I have just learned Redux and there are already people burying it. It's so annoying ☹️
Reminds me of this. What would the following log? for (var i = 0; i &lt; 5; i++) { setTimeout(() =&gt; { console.log(i); }, 0); }
@100ms -&gt; 0 @200ms -&gt; 2 @300ms -&gt; 3 ....... Till @900ms-&gt;9 Sorry I'm on my phone right now
But it doesn't unpeak when you check the show box after unchecking it....
&gt; The problem is lazy programmers This is exactly what I mean by poisonous. Shit happens because tiredness, deadlines, mistakes, etc. Blaming people is counter productive. Do you protect again DNS poisoning in your app? Clickjacking? CSRF? I mean, from your posts so far, it seems you don't do CSP. If shit hits the fan for any of these reasons, does that then mean you are lazy/incompetent/fireable? You're saying yes, I'm saying that no it's a policy failure. &gt; validating against that list Come on, you and I both know people rarely ever do this, especially in frontend. Besides, it adds a ton of friction for developing new features and there's no way to evaluate whether it's being done properly at scale.
Oh damn nice it will output 10 ten times. Lol you got me
I am a big redux fan and have never found a reason to switch to something else. After years of coding complex “widget based” gui’s I fell in love with redux shortly after learning react. It is just such an elegant solution to a complex problem. It basically forces you to write your app in pure easily testable functions and conceptually makes you separate the view layer from the state layer. Cheers Redux maintainers on making such a great library. 
yes, I mean it as in the textbook example of "eval is evil"
Yeah it’s a pretty common interview question. One that people starting from es6 with let/const will probably trip up on lol 👨🏼‍💻
[Document your code](http://usejsdoc.org/about-getting-started.html)
That's the gotcha, but then the real question is how would you make it work so it does output each number?
You want to build an API that handles all the data. Then you create as many apps as you want and connect each one to the relevant part of the API. Although honestly, from what you wrote it just sounds like it's one app that has different components.
For widgets like this, I'd go with [hyperapp](https://hyperapp.js.org/). It has some of the best parts of React, with builtin state management, and it weight one freaking kilobyte. 
but can I remove the timeout that would solve it but my guess I may not or else it would be that hard right?
That is a really strange architecture. Usually people have a single app per page, with multiple components. You can share components across apps. Creating multiple apps seems like an unnecessary burden with minimal benefit and maximal overhead.
That's already a hell of a lot of boilerplate. At the minimum you're dealing with importing constants files deal with all your string literals reducer mappings (which is an annoying avoidable bad design choice imo). More likely you're also dealing with Actions, and a half dozen other libraries that stand as testament to the shortcomings of react.
It looks like the span element is somehow getting an inline style of "display:none" after you let go
Out of curiosity, why not just use react at this point?
 [...Array(5)].map((unused,x) =&gt; x++);
Seriously, what's the difference? You really have to ask that question. Linux is open source, and OSX is owned by the devil that makes Microsoft look like a cute little poodle.
Wouldn't that state sharing only work on one server thread because it is in memory?
Alright. So maybe I have to choose an frame work that my "apps" supports, and then build the apps as components, like the one you install via npm. A follow question then. Can a component have its own state management. For example in react, can a component have its own redux, and still be used inside an app that has another redux? 
https://github.com/sindresorhus/p-progress
Context API!
I don’t really understand how Redux is considered easier to maintain than MobX. With MobX you can still structure your app in a typical modular redux fashion, and if you are updating state only via actions then you have a workflow that is basically the same as Redux, minus the boilerplate. There are some bells and whistles that you forgo such as time travelling, but I consider that a decent trade off given that it’s much easier to comprehend, especially for junior developers. Is there something I am missing?
I think static types really help when you’re working on a complicated app or with a large team.
Something like &lt; arrow key elements &gt; &lt;article&gt; &lt;section id="s0"&gt;&lt;/section&gt; &lt;section id="s1"&gt;&lt;/section&gt; &lt;section id="s2"&gt;&lt;/section&gt; &lt;section id="s3"&gt;&lt;/section&gt; &lt;article&gt; let selectedLinkIndex = 0; arrowRight.addEventListener('click', () =&gt; { selectedLinkIndex++; window.location.hash = `s${selectedLinkIndex}`; }); or just do it manually, pretty much as you typed
Sure, but you could just inject JS on your own rather than relying on a big extension. Just because it's not a feature of the site doesn't mean you can't write it in a couple minutes yourself - as a web consumer, that's one of the greatest benefits of knowing JS IMO.
Though the site will break if the script depends on the HTML being populated first.
Just the kind of thing a drunk person would say
I’m sure after 3 years they still didn’t fix the problem with Azerty keyboard users .. 
Maintainability isn't determined by how much code you have to write, or how easy it is to learn the chosen design pattern. Maintainability is how easy it is to reason about a program's behaviour. Redux apps are easy to reason about because state changes are predicable. That's because they have a single immutable source of truth. Another benefit of redux over mobx is that there's no hidden magic. The redux library is really just a few helpers to make implementing the pattern easier.
I've been a WebStorm power user for years and really love some of their features, but really, VS Code is way ahead in many fields already and is developing at a tremendous pace, unlike WebStorm. Recently I switched to VS Code completely and now I'm thinking of cancelling my subscription which is due in April. At the beginning I missed some of the features like really well working Smart Selection and some code actions - wasn't able to find an extension to replace them properly but wrote my own 😅 Now the only reason to open WebStorm is their amazing Find-in-Files feature, which is perfectly polished compared with VS Code's search. But I can live without it given all other languages features working much better.
&gt; The redux library is really just a few helpers to make implementing the pattern easier. I love this [Redux in a Nut Shell](https://gist.github.com/MarcoWorms/30758235f05faec844b8c06ce2e5bac9) gist because it shows just how simple redux is. 
Don't worry. Almost every React app uses Redux. The people predicting its demise mostly just don't understand what it does.
So far I'm liking everything I'm reading... thumbs up, guys.
Thank you Wouldn't the laat part be in a &lt;script&gt;?
Mobx
100%
With MobX, if you structure your app like a Redux app, you also have a single source of truth, with state injected through the provider or through a higher order component. Immutability is nice but I don’t think it intrinsically makes an app easier to reason about if it requires a large amount of ceremony. Especially working in a team of varying skill levels, I’ve seen people make a tangled mess with Redux and breaking immutability. Yet MobX generally just clicks instantly with everybody, despite all the magic. Don’t get me wrong, I really like Redux and it has exposed me to a wide range of awesome design patterns, but after toying around with MobX recently it just seems like a much more practical library, despite lacking the functionally pure concepts that Redux offers.
thanks
Mobx is great for smaller projects. But it has it's flaws. Let's consider the problem that state management libraries are trying to solve. We have the tree structure that React follows, and in that structure, two leaves on different branches that wish to react to the same state change, the piece of state needs to be shared in the first shared parent of these leaves. This proves problematic as now the developer must pass the state as a prop down the branches towards the leaves. This in turn results in messy code, especialy in the upper parts of the tree that hold a lot of state they don't really need. What MobX does is gives the dev the ability to decouple the state from the view tree. Now we can have inject the piece of state directly in the component that uses it. This works great and solves a lot of problems. Additionaly MobX lets us define our base state and derived state that gets computed automagically when the base state changes. Really great concept. Now we can define our state in mobx stores anyway we want, and connect them in a state tree. However, the problem araises when you have a piece of derived state that depend on base state from another store, or actions that modify state from multiple stores. The solution is to lift the common state and actions that modify multiple state up the state tree to the nearest common parent. But then we're right back where we started. The problem with state that is similar and "belongs together" being all over the place throughout the state tree. In smaller projects you can get away with putting all your state in a single store (which I started doing recently and seems to work for now) but this just doesn't scale well. Also you could just lift the common state and actions and live with scattered state which is also not that bad. Despite all that I love MobX! The based and derived state feels so natural I often wonder how I haven't thought of it before. And there's really not much boilerplate so that's great too. But still you have to admit Redux scales better. It propagates actions down the state tree so everyone hears about all actions and can subscribe to any action and modify state as needed.
https://github.com/mweststrate/immer makes immutability easy. The proposed redux-starter-kit has it baked in - https://github.com/markerikson/redux-starter-kit
WP3
It'd be in your separate JS file.
Same, ngrx for that angular feel.
If your state is mutable components can alter each others' props bypassing the react lifecycle. That's pretty hard to reason about when it causes bugs.
Ditto, I use redux in a lot of my server apps.
I use it with Angular. I'm a core contributor for ng-redux. Angular + AngularJS I should say. 
I never have used a constants file. The examples that I have seen with constants files are fine but I have personally seen large ones become a big pain. In my action file I just export a variable (an object or enum) called ```TYPES``` and import it in my reducer.
Can you describe it please?
I have used thunks for data fetching and they have worked fine for me. The implementation of thunk middleware is a few lines of code fwiw. I normally do something like ``` const load = (dispatch) =&gt; { return async () =&gt; { const data await fetchData(); dispatch(loadResults(data)); } } ```
Awesome! I'm getting tired with the legacy ref API
Redux's core is tiny, and deliberately leaves it up to you to decide how you want to handle side effects like AJAX requests and data fetching. The most common approaches are `redux-thunk`, `redux-saga`, and `redux-observable`, which let you handle side effects with basic functions/promises, generator functions, or RxJS observables, respectively.
Hmm, soo I can use Context API for keeping auth but redux is still better choice to keep API responses? 
It's the best article about modules I've ever seen.
Non-React user here. Why use Context and not Redux for that type of global state? The examples I see them give for Context are a “theme” or a “locale” setting. Why shouldn’t those be part of Redux state? Or is Context provided as a way to ease using those types of things when you aren’t using Redux?
You can have multiple stores for sure. 
Cleaner refs thank fuck.
Surprised \[thread\-loader\]\([https://github.com/webpack\-contrib/thread\-loader](https://github.com/webpack-contrib/thread-loader)\) is not mentioned in the article...
Right 
I wrote an article a while ago about cases in which you might or might not want to use Redux: https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367 Hope it helps. Disclaimer: I co-wrote Redux and work on React team
This is how I wrote my first multiplayer js game! Redux process all actions, and on an interval the server sends out state updates as well as continually sending "one time events" until all clients have received them. 
This is my first big webd project based on angularjs (only to some extent). It’s my school’s IT club’s website. (Don’t) go easy... https://github.com/plibither8/projectbeta.tech_main
Wouldn’t you just use let instead of var?
I think I know what my problem is. I don't really understand how node works or what it means. I know it is server side... Anyways, I made the stripe form work with node. It is all set up. The problem is, I don't really understand how to set up node with my website? I open the website by VS code server and I open the stripe form or stripe button (that takes the buyer to stripe and it all works) in terminal with node. Basically I want to get stripe on my website... but I don't know how.
😥i'll probably never upgrade to react 17 if they drop legacy context :( That react-router v3 &lt;-&gt; v4 upgrade is such an endeavor on large apps.
Redux Ducks bro. Put it all in one file. 
relayjs?
Clipboard history none of VS code plugins is able to reproduce it properly IntelliSense VSCode tries hard, but Webstorm's is mindblowing HomeFeeling (??) I open Webstorm when I start coding and I close it when I finish, no need to change window, switch context and whatnot Search everywhere thinghy Shift-Shift and it found literally whatever you want in your project (Classes, methods, attributes, filenames...) Git Support It's my favorite git tool and I use it in non-web projects too, as their support is simply amazing. The only thing that I have to complain about is their markdown support, because that really sucks. 
What makes me chose everyday Webstorm while most of my colleagues use VSCode - **Clipboard history** none of VS code plugins is able to reproduce it properly - **IntelliSense** VSCode tries hard, but Webstorm's is mindblowing - **HomeFeeling** (??) I open Webstorm when I start coding and I close it when I finish, no need to change window, switch context and whatnot - **Search everywhere thinghy** Shift-Shift and it found literally whatever you want in your project (Classes, methods, attributes, filenames...) - **Git Support** It's my favorite git tool and I use it in non-web projects too, as their support is simply amazing. You can do super complicated things in a couple of clicks. The only thing that I have to complain about is Webstorm's Markdown support, because that _really_ sucks. That said, VSCode is still my free editor of choice, because some of these things (although not as well as WebStorm does) are achievable via plugins. The drawback is that VSCode - equipped with all the plugins you need to install to make it a proper IDE - is way slower than WebStorm, but again... it's free. If you are into buying a license, WebStorm is **the** choice to me.
That makes sense!
This is not a Java subreddit
Java didn't approve my post. I thought people of this subreddit would like this post.
Java and javascript are totally different. I am hoping you know that
What's the solution in redux for that?
Alright. I'm deleting this post in a little while.
I suppose And probably more on certain types of applications. Ours scale pretty good with a good use of PropTypes.
Yeah, I'm also a spring-hibernate learner. Once I built a CRUD app using Spring-Hibernate. Anyway, I'm deleting this post in a little while.
Wohoooo! Finally. 
Superfast, tiny, js framework. https://github.com/shikaan/titef Next release will be a "marketing" release in which I am supposed to make this stand a bit out
It's mostly about their language support compared with one in WebStorm. Just to illustrate: - `Add missing import` code action in WS imports with some ridiculous file paths, like `../../../../utils/api` rather than 'utils'. I always have to do it manually. VS Code gives me two or three options to import: 'utils', the relative path, or 'Add to existing imports'. All predictable and reasonable. - Tooltips with types. I work with TypeScript mostly and when type inference puzzles me I have to check the type of a variable. Have to open VSCode and look what the type is. - Code Snippets: VS Code allows you to regexp-replace placeholder variables. Makes a huge difference when you have frequently-used snippets with values inferred from file-path (like namespaces for Redux actions and BEM). In fact, there are bits and bobs everywhere. I still love how WS is polished in many areas, but these basic features make the difference when you code a lot and want to eliminate as much boilerplate as possible.
Thanks for a both suggetions(power and Sqrt). 
Thanks for your answers and suggeted link but I really apriciated if I got a answer in short time without reading tons of article, and I can not ask a question there. Overall Thank You for Reply.
These changes are scary for apps wanting to upgrade, but the React team recognizes scary changes are needed to stay relevant and avoid legacy cruft (looking at you Java). I think they have been doing an amazing job at keeping it as painless as possible.
"LUL"
I think it’s likely that RR3 will be ported to new context API (in a an official API-compatible fork, for example). 
Thank you, I'll definitely look into the udemy course I already have some in my backlog. And I do have somewhat of a portfolio since I'm not a complete noob. Maybe I should have said that I have been a web designer for some time but the pages I made with my current company aren't really complicated and I'm looking for my next challenge. 
i never insulted you, if calling you "naive" is insulting, you said to me "i'm butthurt" , that is way more rude than being called "naive". go to uncensored and read all my comment if i insulted you in the first place. https://www.ceddit.com/r/OnePiece/comments/887jm2/one_piece_ch_900_color_spread_via/
commented on the wrong thread much?
i purposely came here because you are reporting my comment left and right like a fucking retard.
Lmao I reported a comment where you insulted me so you got salty enough to go through my posts, find the most unrelated post you could've found and then cross-commented on it. Wow. Owen Wilson level of wow
Don’t use react-router unless you want to pull out all your hair. It’s way easier to use something like page.js and push events from that into your state manager (or wrap it in an event stream if you have ascended to FRP).
So stack overflow?
The issue is pretty simple. Have you tried debugging it? What could be wrong I'd you get only those values?
So Reddit?
You aren't using your Math.min / Math.max in the right spot / order. this.currentX = Math.max(Math.min(this.currentX, 0), -2000) should do what you want.
That's what I like about ngrx. Everything has already there.
_ is very common in a more functional style for meaning unused, but I agree with your wish to meaningfully name variables.
Thanks. Follow up question, a bit OT but ... I'm doing this building a draggable slider. However, at the bounds (min, max) values, it feels unresponsive when trying to go the other direction, I have to drag a few time before it responds. PEN: https://codepen.io/ReGGae/pen/e044cf7a9be59af631bd3339106e7d21?editors=0010
&gt; The separation of actions and state changes is what makes Redux so maintainable. IMO, Redux doesn't go far enough in separation of concerns. In a basic MVC, the view should be dumb and just render model state/data. It should not be aware of any actions at all, or care how you interact with it.
Yeah, `thread-loader` is awesome! :) I didn't mention it specifically in the article, but did link to Rowan Oulton's great article, where he mentions it
$1 refer to the first variable extracted for the RegExp you give to replace, $2 the second one etc... 
you can't get the 2nd parameter if you don't assigned the first
&gt; Add missing import code action in WS imports with some ridiculous file paths, like ../../../../utils/api I just tried that (WebStorm) and got a "util" based path for node.js's "util" package, no strange directories. &gt; Tooltips with types. CTRL-Q (info popup). There are more options &gt; Code Snippets https://blog.jetbrains.com/webstorm/2018/01/using-and-creating-code-snippets/ https://www.jetbrains.com/help/webstorm/creating-and-editing-live-templates.html
Seems like I'm going to spend some time in order to use `getDerivedStateFromProps` everywhere... :D
That seems to be because `this.offX / onX` continue to increment when you're already at the edge/boundary. 
Try stackoverflow anyway, if its interesting question someone might put a bounty on it. Besides someone on #javascript channel irc.freenode.net might be interested. What is the issue anyway?
A truly immutable language would be useless, as in this case you wouldn’t be able to increment i. 😳
Hey it's so fast and smooth! I really like it. I did find a small but with the podcast layout: [layout bug](https://i.imgur.com/G4sk3DK.png)
&gt; First, it’s important to note that only variables declared using the var keyword are hoisted. Variables declared using the newer let and const keywords are not hoisted. That's not exactly true. While you can't use let and const variables before their declarations, they still get hoisted to define the TDZ. This hoisting is what prevents you from accessing a similarly named variable defined in a parent scope. { let a; { a; // error thanks to hoisting let a; } }
Meteor is amazing stack and like many of you said give very good flexibility. When we started to cooperate with corporations, and outsource projects for them using Meteor, is was something fresh. Not only for us, but mostly for them. Some people drop this technology few years ago and they have no idea what's happened since that moment. Meteor 1.6.1 right now is the best version ever. When we were building one of our start-up - our main objective was to quickly transfer data between devices and a lot of powerful features to help in conducting a presentations / conferences. You need to choose technology to problem, that you need to solve. Without Meteor it would not happened. When we started, we needed to app very fast. We needed to validate our tool and problem that we want to solve. Meteor give us many features, just out of the box so development vas extremely fast. We could test our solution and after few pivots we had a fully functional application. I would never change this technology, in this project (and many more), for anything else.
Next, aiming for mobile screen?
This is very cool. I've been wanting to mess with ML for a while but never really found the time to do it. I work with JS but haven't touched python in years so this will make it a lot easier to get my feet wet. Also I spent way too long playing pacman with my head. That's just awesome.
Big if true
Big if true
WebGL accelerated = huge win.
You don't like Python?
if(true) big();
Or just _links to S.O._, [it seems](https://github.com/parro-it/amaj/issues/1)
Node.js is going to be #1. Python is doomed.
As said in another comment in this thread: give MobX a try. It's very similiar to redux, but with almost zero boilerplate and no restrictions on how to build your models. You just add two annotations and a function to your plain JS models: `@observable` and `@action`, and pass your reactive handler to `autorun()` for plain JS code, or `observer()` for a React component and similiar - that's it. I'm not trying to deny Redux its well deserved respect for bringing its design patterns into the JS world, but there are much better alternatives out there by now; and I consider MobX one of them, as it turned the awful overhead that comes with Redux into just four functions (those mentioned above) for 90-100% of your model, depending on your type of application.
I like Python but I love TypeScript
I guess if your mainly a js developer then having to jump to python for tensorflow could be alittle annoying. I mainly use python and js secondary so I may be biased but I think if you wanna use tensorflow python is the way to go, at least for now. Regardless I am looking forward to using tensorflow in js.
Thanks, worked like a charm=)
 ReferenceError: big is not defined
what can you do with type you can't with vanilla? (serious question)
now add gpu acceleration!
I agree with you on all the mentioned points. The few juniors that I've trained all had a much easier time to understand and work with MobX, at least on small-scale apps. I'm personally using it in a small and big personal project, and it's turned data modelling into a fun activity for me again. Before I found MobX, I had considered using it and tested Redux and vuex, an implementation of Redux-like state management for the Vue ecosystem, before coming to the conclusion that I consider both way too heavy on boilerplate by themselves, so I began writing helper functions for my exact needs. Back at work again, we've worked again with both Redux and vuex, and vuex seems a bit easier to work with in my opinion, similiar to how vue can be easier to work with than React for most web/app projects. We'll hopefully try MobX there in future projects. Other posts are talking about how you should use immutabile data structures so that you can reason about your state and have it be predictable. For me, that's very similiar to the people shouting badly at PHP because it's easy to write bad code in it. While the argument is arguably true to a certain extend, I can't see how MobX fails to provide exactly this, a predictable state, if used properly and encapsulating your state changes into actions (MobX provides `@action` for exactly that). You cannot misuse a tool and then blame the tool for it. Use MobX correctly and with the ideas that make Redux, vuex and MobX great, and you'll have a much nicer experience both programatically and at runtime, compared to Redux and vuex. Another thing that came up is that MobX contains "hidden magic", but I'll take that bit of hidden reactivity over the heavy boilerplate of Redux-like implementations every day. That "magic stuff" is easy to understand, explain and apply correctly, while taking away practically any negative points I have about Redux.
it's really sad :(
I’m gonna have to disagree with you on that. I’m primarily a JS developer, however JS doesn’t even come close when it comes to scientific computation or ML. Check out NumPy, SciPy, and Keras. I don’t see that changing anytime soon, but I’m glad to see that TensorFlow is coming for node. 
Oh, so it's google?
Nothing really, as far as I know TypeScript just compiles to regular JavaScript. It just has some helpful features to make your life easier.
I get it. I mainly use JS/TypeScript, but I also really like Python, even if it's been a while since last time I used it, switching back and forth between languages can be annoying.
 ReferenceError: big is not defined
That's a nice library I hadn't heard of, thanks for sharing. Looking through it, it looks exactly like what MobX does internally if you wrap your state-mutating code into MobX's `@action`s, but with more boilerplate to make it into its own library. So if you like Redux+immer, you'll most probably love MobX.
refactor large code bases with impunity 
Why do you want an easy life? 
I didn't even specified a time frame.
This is pretty cool, but can it make toast? 
Oh man good catch! Thanks for letting me know, I think I hard coded the height of the media player, I’ll get that fixed. 
Apparently best not say that in /r/javascript... no matter how true it is. When javascript has its own numpy, maybe. Until then, no.
what can you do with vanilla that you can't do with TS?
It should be pretty responsive. A few mobile layout bugs have popped up for me to work on. Need to work on my media breakpoints!
Hi /u/BenjiStokman, For javascript help, please visit /r/LearnJavascript. Thank you!
Me too! But I used sockets to transfer to clients!
Life is hard enough as it is. I like some challenge, but I value time more.
 - if(true) big(); + big();
You could technically do that with flow. But seeing as you have transpile whether you use flow or TS, I guess it’s down to preference. 
Hi /u/ReGGaeBAWS, For javascript help, please visit /r/LearnJavascript. Thank you!
I'l try with another thing.. not really related to the whole draggable thingy but I'm playing around with some effects, currently a bouncy/scale one. But is it possible to NOT reverse the effect depending on direction? Currently if draging one way it is scaling down, and when dragin the other way it is scaling up. I want it to scale down both directions. Is there any straight forward way of doing this? I think I have done it before but forgot how... Math isn't my strongest skill.... You can see the "effect code" in the run() method. https://codepen.io/ReGGae/pen/e044cf7a9be59af631bd3339106e7d21?editors=0010
1 + "2" == 12;
/u/deathmood, Thanks for posting the name of a JS file as a title, it's really helpful to all of us!
to make it intriguing ;\)
True ? Big() :
AWESOME! JS is my primary language for programming most of the things. And tensorflow coming to JS is great news for JS devs!
What value does time give you?
Stack overflow is useful, but a question like this https://github.com/parro-it/amaj/issues/2 would have been closed as subjective in 10 second.
Just like clickbait! yay for you!
let size = big; if (true) { return size; }
wait really? i saw it's opengl i want sure if that meant it actually rendered on a card or not 😲
I'd say everything. Everything I can do takes some time, it is a limited, valuable, and probably non-renewable resource.
`setTimeout` causes the function to execute later. However, since all instances of that function reference the same variable they all have the same view of its value. Since they execute after the loop ends it has attained its final value.
Thanks for the help! I get it now. :)
That's what I get for writing JavaScript on mobile :P
Even tho we need to calm down, I am very happy with this news. Tensorflow native bindings are a great step. With the new eager execution improvements, it will cover a lot of what is needed for fast matrix manipulation in JS.
Would you mind elaborating more? :( I'm very dumb, and sorry for that!
Why does everyone complain about react router 4? It's the only version I've ever used and it's been pretty easy to work with.
Not at all, learn JavaScript and master it before going to any frameworks or libraries. Frameworks and libraries are all just hype. You really dont even need them unless your building a full scale application for production use. 
setTimeout is being executed long after that for loop finishes. Specifically it is running the function you passed to setTimeout `i * 1 second` so it will always run atleast one second after it was first called. So what this means is that by the time any of the functions get allied that for loop has finished and that means `i = 6` since that is what the for loop was set to finish at. ^Sorry ^for ^possible ^bad ^formatting, ^on ^mobile.
I don't think that it is a bad idea to start with JavaScript. But I let people who teach answer, they will have more knowledge on that matter. As for "what should I watch for ?", JavaScript belongs to the family of languages that were created by one man in a few days. So as you can imagine, the first versions were not perfect, far from it. For my advice would be to check the versions of the tutorial / examples you are looking at. Try to learn ES5+ (5th version of JavaScript, the 5th and 6th versions really changed a lot of things). And otherwise, enjoy !
It makes great toast.
Doesn’t typescript have the ability to read jsdoc style comments as well? Thought I remembered hearing that on a podcast a while back
And a more general advice when you start learning how to code : Don't focus on libraries. I would'nt go as far as /u/grat2013, but clearly there is tons of things to learn before and too many libraries to soon is the perfect way to get lost and to stop coding.
Okay I understood that. But why does't it logs after 6 seconds later, considering `i = 6` and `i * 1000` equals 6 seconds. 
isn't flow pretty much dead as they started to use reasonml to write typesafe javascript?
I was responding to ts vs vanilla not ts vs flow. Flow is good (that's what I use at work) but its tooling sucks. TS also supports type hints via jsdocs. But then if you're using comments/jsdocs to add types, why not just use TS/Flow
It is not OK to NOT learn JavaScript. 
OP is using an affiliate link, highly suggest you report him to Humble https://support.humblebundle.com/hc/en-us/requests/new and Reddit for spamming his affiliate link. He's an affiliate link spammer https://www.reddit.com/user/g4m1ng/posts/ A few of the other accounts he uses: * u/younglegend * u/youngflash (BANNED LOL) * u/Indie_Kings (BANNED LOL) * u/IndieKings * u/13378 (BANNED LOL) * u/PZMQ (BANNED LOL) * u/808hunna * u/repsup100 * u/blazek_amdrt 
Some may say that all this "liberty" you have with JavaScript can give you bad habits :p
...'splain please?
For a newbie, learning JavaScript first is a very good idea. On one hand it is simple is forgiving, and on the other it will expose you to quite a few concepts that are important in today's programming world, such as C-based syntax (so you could later easily read many other languages), functional programming (very much in demand right now), and all the general programming ideas that any new person needs to learn (variables, functions, types, logical operands, etc.) Once you get a taste of what programming is like, you could then move on to another language if you so desire, though you should have no problem getting a job in JS. Earlier I mentioned that it's forgiving. That can be (and is) seen as a disadvantage by some developers. The truth is, you can write absolutely horrendous code in JS because the barrier to entry is lower than normal. It will be up to you to study up on best practices. The fact that your friends code in it is great, because you'll be able to get guidance from more experienced developers. And the truth is, one can write horrendous code in pretty much every language, so don't listen to those who'll tell you to start learning C++ first — it has it's own mind-boggling silliness. =)
(function (isTrue) {if (isTrue) console.log("Big");}(true));
That confused me for a bit, went and ran it my self and figured it out. The for loop is basically instantaneous. So all the setTimeout functions are made at the exact same time. So when you run it this is how it outputs: 6 *1 second later, a total of 2 seconds after setTimeout was called* 6 *1 second later, a total of 2 seconds after setTimeout was called* 6 *1 second later, a total of 3 seconds after setTimeout was called* 6 *1 second later, a total of 4 seconds after setTimeout was called* 6 *1 second later, a total of 5 seconds after setTimeout was called* You’ll notice how the last one is only 5, that’s because the for loop only executes it’s content when `i &lt;= 5` but at the end `i` still gets 1 added to it. Resulting in it equaling 6 at the end. So they actually are being called 1, 2, 3, 4, and 5 seconds later like they should, it just looks misleading.
Done of the example code works. I'm getting a 404 from github https://github.com/tensorflow/tfjs-examples 
MDG is working on it. That is the idea since version 1.3. Probably in next major version we will see it splitted. 
Functions contain blocks of code that can be run at any time. Variables used in functions can be defined either within that function (this includes function parameters) or outside of the function. Variables defined inside the functions, known as local variables, are unique to function calls. Every time a function is called, new versions of those variables are created specifically for that call. Variables defined outside of a function but used within that function are not unique to calls of that function. Whenever the function runs, no matter how many times, it will reference that same variable each time. In your loop, you have a function defined (or, more accurately, many functions, one for each loop) that references a variable, `i`, defined outside that function. Whenever the function runs, it pulls the value of that variable as it exists during that time. The loop uses the `i` variable to track its iterations. At the end of the loop, `i` will be 6 because it's the first number that fails the `i &lt;= 5` condition. While looping, functions are created, but never called. `setTimeout` will eventually call the functions, but after the loop has completed and at a point in time when `i` is 6. Additionally, within the loop, `i` is used to determine the delay for each `setInterval` call (`i * 1000`). This use of `i`, however, is not within the function, so it is evaluated right away. This gives each `setTimeout` call 1000, 2000, ... 5000 delay values respectively. The order goes something like this: * loop i = 1 * create function with log(i) * evaluate 1 * 1000 = 1000 * pass both into setTimeout * loop i = 2 * create function with log(i) * evaluate 2 * 1000 = 2000 * pass both into setTimeout * loop i = 3 * create function with log(i) * evaluate 3 * 1000 = 3000 * pass both into setTimeout * loop i = 4 * create function with log(i) * evaluate 4 * 1000 = 4000 * pass both into setTimeout * loop i = 5 * create function with log(i) * evaluate 5 * 1000 = 5000 * pass both into setTimeout * loop i = 6 * condition fails, break loop * (1 second later) call log function, log(6) * (2 seconds later) call log function, log(6) * (3 seconds later) call log function, log(6) * (4 seconds later) call log function, log(6) * (5 seconds later) call log function, log(6)
Thank you very much!
Great answer! Thanks for sharing your point of view. We can see it on extremely fast growing popularity of VueJS (almost 90 000 stars on the GitHub!). It is great tool for building small things within your website. I know it is scaling well, but I don't think it is used by (or will be) big companies. They do not want to change theirs internal apps every time, when some new frontend framework rises. They usually invested a lot of money into React or Angular few years ago - and that is enough for them for now. 
I will say yes, with reservations. Javascript is an excellent choice for learning the basics of programming, to wit: conditionals, loops, functions, input/output, arrays, records (objects), recursion and classes. After getting those down, I'd advise you to pick up another, non-scripted language like Java or C. With these you will learn things you wouldn't learn about with JS, such as static type checking and direct memory management (C only). Do not "master" Javascript as some here are advising. Not only would that take years, but it would be mostly a waste of time. Javascript is a relatively large language with a lot of obscure features that are a) not necessary or even desirable to use and b) have few or no analogues in other programming languages. Using this time instead to learn another language would be more valuable for understanding programming in general.
Yeah Javascript is fine just focus on the good parts (es7) 
console.log((arg =&gt; (a =&gt; b =&gt; c =&gt; a(b)(c))(arg)('Big')('Small'))(a =&gt; b =&gt; a))
&gt; You really dont even need them unless your building a full scale application for production use. You do understand that this sentence is equivalent to 'you need them for anything that pays', don't you?
Fixed!
After a couple thousand attempts 
You the man, xtan.
JS uses C-like syntax. That's very convenient when you later want to pick up another language with C-like syntax (C/C++, Java, C#, Dart, etc). There is also an easy upgrade path to TypeScript since it's a superset of JS. It's popular and there are a bunch of great resources available (e.g. Codecademy and similar interactive learning websites). It does have quirks and warts, but it's not like this would ruin your mind forever. As long as you learn other languages in the future, the first language doesn't really matter. I'd say JS is one of the better choices. A perfect option we can all agree on doesn't exist.
I've been working on this repo with Codewars katas solutions with tips &amp; resources to learn ES6, RegEx, and more! https://github.com/lndgalante/codewars-katas
Thanks, not sure why that never crossed my mind...
&gt; we are actively working on creating node.js bindings to the TensorFlow C API Where does this leave [PropelML](https://github.com/propelml/propel), I wonder. PropelML already has that, though, not sure how of the API is already covered. Sounds like they are both trying to do the same thing, which is weird considering that PropelML uses deeplearn.js for in-browser stuff.
Affiliate advertising for udemy course.
Affiliate advertising for udemy course.
Thank you very much sir. Neat explanation for dumb people like me. I've understood how it works under-the-hood. Thank you again.
That is demonstrably untrue, and [73.6% of all statistics are made up](https://www.explainxkcd.com/wiki/images/c/cf/numbers.png) anyway. [NumJS](https://github.com/nicolaspanel/numjs) doesn't have feature parity with NumPy, same as [SciJS](https://github.com/scijs) and SciPy. But they're not that far away from each other, either. SciJS has optimization, linear algebra, integration, interpolation, fast Fourier transforms, signa processing, image processing, ODE solvers, and more. With Node Tensorflow bindings, it's probably not long before we see robust neural network libraries built over it in JS like Keras.
&gt; ~~When j~~Javascript has its own [numpy](https://github.com/nicolaspanel/numjs). Fixed that for you. 
Looks like another Russian bit got exposed, boys.
https://i.imgur.com/OxSBxDX.png lulz
+1 for your mention of page.js. I adopted it because I migrated my project from Backbone and page.js was minimalist enough to allow to write a Router class around it that was nearly compatible with my previous router. That said, nowadays I still like page.js and would plug the router state straight into Redux if I could. And it has allowed me to completely sidestep the horrors I keep hearing about React Router (though I do admit the API of the latest version does look quite nice).
&gt; Also could you clarify why does it console logs per second instead of increasing order of seconds as stated by you? It's the same thing. The "per second" is the increasing order of seconds. The first setTimeout is called with a 1000 delay so it waits 1 second before calling its function. The next one is called with a delay of 2000 so it waits 2 seconds. 5 functions, each with increasing delays, so they get called in order, one second apart. Keep in mind that each setTimeout starts right away as part of their being called in the loop. They don't depend on one another; it's not like the second timeout has to wait for the first to finish. Once the loop finishes, all 5 timeouts are ticking away waiting for their delay to complete at the same time.
co-wrote? Didn't you come up with Redux on your own? I believe it was introduced in that EU talk on time travel debugging?
Excellent. Even I was thinking the same would be going on. Thank you again, sir!
Yes, that was where you got the "assignment in conditional expression" error from. Typing "relay1 = 0" inside the if statement caused the error. The code itself is pretty awkward so I will be surprised if it works, I was just helping you resolve the error.
Got it, Thank you for the help!
Sure thing!
I don't know exactly what they meant, but I'm guessing they are talking about ubiquity. JS is everywhere. Replacing AppleScript. Replacing visual basic for things like Excel scripting. React native, QtQuick, winJS, etc for native app development (not too mention electron). Duktape and JerryScript for embedded and internet of things work. there's node for server work. The list is very long. Finally there's the hugeness that is the web itself where JS is the only option. Most programming careers all but guarantee you'll be writing JS, so you might as well learn it. 
It's certainly ruined me. I have to go back and forth between JavaScript and Java a lot and man ... being forced to create pseudo\-classes in Java for what would be anonymous objects in JS *sucks* \(maybe I just suck tho\).
Yeaah, strict mode on board
Pick up some react skills. Employers want it. It makes you more marketable if you're a freelancer. 
&gt; Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can. -- Zawinski's Law I've worked on fixing several apps that were "to small to need redux" (including my current project which is now 100k lines with double or triple the features planned for the future). In every case, untwisting the convoluted threads of state snaking everywhere took far more time than adding state management from the start. I would put forward that if your app is small enough to not need redux, it's probably small enough that a lightweight framework like mithril is a better match.
Andrew Clark contributed several key insights to Redux's development, including the concept/implementation of middleware and some of the concepts around reducers. There was a lot of discussion going on in the repo during that time as well.
Not sure about a github repository but npm has something like that npm.runkit.com
I'm not worried about the length of code. I *am* worried that you've missed a few things, or misunderstood some things, and that you repeat most of the code to deal with a small issue. As long as your code works, is clean, and is easily readable, length isn't a problem. Also, I suspect your code has a problem with numbers like 900 or 1500.
Hmmm, the reason I use Python for machine learning and data science is because of the massive community of scientists making blog posts in Python, not because of the lack of libraries in any other language.
 if(",,"==new Array(3)){var z=[66];z.push(z[0]+39),z.push(z[1]-2),z.forEach(r=&gt;{console.log(String.fromCharCode(r))})}
That's a cache you're creating and it seems sensible that creating just once would be more performant. I would use const though, not var. Also beware of premature optimisation. Having a cache also means organising it. Another way of handling this is through instantly instantiated modules, which would probably organise the code more semantically. 
true
Would you like to have a playground like that just to have an easy way to run your code, or the idea is to have a place where many libs are already available?
This is a course by Brad Traversy.
To have a place where the libraries are already available and can be a good starting point for new projects.
I understand your sentiment, but I'm not sure how else you would implement it without causing other problems. First of all, I'm pretty much never assembling actions manually. With action creators you just call a function, not unlike what you posted, and then the action creator generates the action. So you aren't manually touching any of the strings after you set all your redux code up. Second there are very good reasons for having your actions have the type be a string. It means that every action is easily serializable. We were able to build a cool "mirroring" system when we were debugging our app that could dump the whole redux state to the server, plug it into a different client machine, and then send every redux action from the first client to the server, then to the second. This let us pull up the exact state of the client and then mirror every change in that client. It was great for when remote workers had issues, or testing identical states/state changes on different browsers etc. Since everything is simple JS objects, we can just JSONify the whole thing and just ship it. It took no time at all to write that system. Similarly redux actions make great logs. You can write middleware to log or report all actions in like 5 lines of code since all you need to do is JSONify every action and save it. I'm not sure exactly how we would build these systems if redux didn't have easily serializable actions, but it would be a hell of a lot messier for sure.
tribalism looks like a meme, know your memes and you won't care that much :-)
Programming is full of insecure idiots. Literally the only answer is to ignore them. 
Hi /u/JessicaLang1992, For javascript help, please visit /r/LearnJavascript. Thank you!
You can minify your scripts using a plugin like [W3 Total Cache](https://wordpress.org/plugins/w3-total-cache/) or just serve minified versions of them via CDN [WP Super Cache](https://wordpress.org/plugins/wp-super-cache/). Or better yet get a free [Cloudflare](https://www.cloudflare.com/) account and use the "Speed &gt; Auto Minify" setting and they'll handle it for you. I've spend a fair amount of time making WordPress not dog slow for clients so if you need any tips feel free to hit me up.
There are parts of JavaScript that are bad. If you know them, and are comfortable with that knowledge, then who cares? If you like it, then you like it. There's something positive to be said for the freedom JavaScript allows. But that same freedom can also be a con. Also, I have yet to use a language that I thought was a complete slam dunk. Every language has its edges and warts.
the solution is to give no fucks But one line dependencies in 7 million projects is kind of an issue that shouldn't exist
Yes, JS has quirks. Newsflash: all languages have. It's not like `typeof null === 'object'` is any worse than mutable defaults in argument lists. Poeple who hate on JS are ones who couldn't avoid learning it, because it's just so important.
People hate on Java too. PHP has it at least 3x as worse. C++ has been universally hated since inception, I think. Don't get me started on Perl or Lisp lol. Anyway, people hating on a programming language or tools in general are the type of purists you should generally avoid. They can go on and on about how their stack is better and has static typing and whatever while you do 5x the work in half the time.
&gt; the thousands of one-line npm packages, that fellow developers write for free. It's a quite serious issue, so as a node dev you should take note of it.
Depends on what it actually is imo 
I used to use ngreact to swap out stuff to react over time.
No, I don't. Code without types is unreadable because it requires me to remember the flow of information. I would *really* love to use TensorFlow from Scala, Java, C# or TypeScript. Ideally, there would be a language that does compile-time dimension checks (you can probably do something like that with templates in C++, but package management isn't a thing in the world of C++). Just try reading some of the code in the research TensorFlow models. It sucks. Not because the concepts behind it are hard, but because a ton of information is hidden. Also, Python's lack of a strict project structure is very annoying. I can take any modern JVM project and it will follow a strict hierarchy, with a proper, unified place for dependencies (Maven POM, Gradle build file or SBT build definition).
Make sure you export your reducers so you can import them combine them all together in a single index file. My files usually go like this: constants action creators reducer redux-logic middleware Before I rearchitected our platform all of these would be separate files and it sucked greatly. 
I acknowledge the issue, but there are plenty reliable devs in the community (sindresorhus comes to mind) that produce crap tons of useful stuff. 
They're obviously publicly statically envious of anyone that's productive with some tool they consider inferior. Of course I'm generalizing, you know, abstracting singleton proxy factory manager controller providers. Knowing their main private motivation is virtually void, you can safely ignore them and enjoy what you do. The problem is the language including script in its name... But I have anecdotes of boosting several teams productivity with a few lines of ksh. On a serious note, though, no real seasoned professional will question a correct usage of a reliable tool (frameworks, languages, operating systems, etc) as long as it works and you're productive. Use what's best for the job at hand. 
I don't! :D
Don’t be Putin that shit in here!
So it’s a lot like C.
https://repl.it supports node projects as of quite recently, just noticed it the other day that it auto installs required deps. runkit is the one bundled/associated with npm.
Honestly... I view it like I view sports teams. People get so bloody attached to shit they had no part in creating. And then they feel personally aggrieved when someone else shitposts about it. I’m too busy building Angular5 apps with a big fucking smile on my face to give a shit about what people are saying about JS. 
What else would they have posted? It tells exactly what it is.
I think a big issue that people have with JS is that you don't get a choice. If you want to write interactive clientside code you are going to have to use JS at some point and if there is one thing developers hate it's being forced to use a technology they don't like. WASM will change that for sure, it will be interesting to see what languages come out on top once that gets widespread adoption.
You can't make a web browser read another site directly unless that site gives you permission. Instead, you need to write some server-side code and call that from your web page. That server could be written in Javascript with NodeJS. But since it's 2 separate things, it's a lot more complicated than a simple tutorial will generally handle. That's why you can't find a tutorial for it.
I’m so productive with Ember. Can’t say I was with angular 1...
There are better languages and worse languages but the processes and culture tend to drive success than the choice of language. No matter what language you pick people are going to have negative things to say about it and most will be unjustified. If you like the language, code and be happy. Programming is about solving problems not about being in the cool programmers' club. With that being said, I've been writing Javascript seriously since 2001 and I've spent most of my career being paid to write it. I generally like the language but I hate the npm module culture. Abstractions only add value when they don't leak. Dependencies can gain you time and expertise but add potential future instability to your project. I only add dependencies to my project if I trust the author, I've read the code, and I can keep up with what changes are being made to the code. My experience with node projects involving high numbers of dependencies is that the authors of those projects don't go through their transitive dependencies with the same care that I do and so I see dependency count as negatively correlated with quality. I know the arguments from the other side. I thought they were misguided when izs and mikael initially made them and my experiences in the intervening years haven't changed my mind.
That entirely depends on how the existing site is implemented. Without a lot more information, possibly more information than your company wants public, it's impossible to give you a meaningful answer.
I'd rather have cancer than work with Java/C++
&gt; being forced to create pseudo-classes in Java for what would be anonymous objects in JS sucks (maybe I just suck tho). In Java, if you wanted, you could instead instantiate a hash table object. Ultimately that's what JavaScript's objects are.
You don't know my package.json!
weird, I've never had an issue with js' loose types, but i hear a lot of criticism for js on the type system..
They do it because they can't handle the language's quirks and are angry we get paid as much as them or more. When it bothers me I whip out my alt-account and flame like there is no tomorrow. But mostly, I don't give a shit, it's _their_ problem. It brings a tear to my eye when it's Java people doing it, LOL, I mean only VB is lower in the food chain IMHO
Seems so obvious now ... 
glitch.com ?
What exactly is your goal?
No. We hate java. Go away.
When I last looked into it a couple of years back or so, hosting solutions were limited and costed an arm and a leg, so I filed it under "forget it". If things have changed since, they people behind the probject need to do some marketing do change that perception.
5? Already? I thought it was 4 just yesterday!
There's a [port of it for Flutter](https://pub.dartlang.org/packages/flutter_redux) and most likely other things as well
Did you just assume my dependencies?
Somehow I have only found out about WASM just now. I am pretty sure this thing and everything on top of it is the future.
Take a look at the function expression mouseMoved = function() { paintBrush._____ = _____; paintBrush._____ = _____; _____; }; You be on the right track, but it looks like paintCanvas is not being invocated. https://developer.mozilla.org/en-US/docs/Web/Events/mouseover https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors
&gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses - Bjarne Stroustrup
It's so simple yet it allows complex templates. It's allow pure DOM, meaning the template is not treated as a string, but is traversed as a DOM. It's tested, extensible with the concept of filters (with which most interesting features are implemented). It's also very simple code, without weird hacks.
The only good thing about strong type IMHO is refactoring, especially someone else's code or old code. 
The link seems to be down?
Check again friend. 😊
A development website whose demo's don't support Mac/Linux...
I didn't think they were serious. All languages have people hating on them and making jokes. In the end I like what I like and will continue to want to learn more, of many languages including JavaScript (especially JavaScript)
Anyone using Vue CLI 3 with Tailwind CSS? I can't seem to make the parts fit together the way I used to before. Granted I'm pretty new, I just can't figure out what is a webpack config problem, what is a Vue config problem, what is a CSS import problem, what is a writing css problem, or what might be a post-css loading problem. Help?
I know about the type annotations. The problem is that pretty much nothing uses them, and they don't seem to be very expressive.
his language just happens to be butt ugly though.
When your only hammer is C++, every problem looks like a thumb
Be careful what you wish for
Could you elaborate on the expressiveness part. I've used C#, C, and Rust before. If any of those help explain what you mean, that would be great.
Too many language features, and too small of a standard library.
What's wrong with Lisp?
The cache would be more performant, yes. Pooling is a similar but different concept where a large collection of instances is created and reused. This avoids garbage collector hiccups because nothing is being allocated nor reclaimed by GC. But if you're asking this kind of question, I would bet money you're not working on the kind of project where this optimization is worthwhile.
I must confess, that was 100% made up. JS is still very far from Python, but it's cool that it's making good progress.
Let’s start with it’s name ‘lisp’. You’re beginning with a speech impediment. From thenceforth it’s you’re job to be expressive despite this... sounds like an uphill struggle to me. Aside from that it’s a confusing mess of brackets all over the place. But to be fair I’ve never even come close to coding in Lisp so who am I to judge?
You're seriously going to bash a language because of it's name without ever having written it? And cleanly formatted Lisp code are incredibly legible, you essentially ignore the parenthesis (not brackets), and look at the indentation for scope. Here's a database configuration, two model definitions with an entity relation, and then query in a Clojure ORM tool: (defdb prod (postgres {:db "korma" :user "db" :password "dbpass"})) (defentity address) (defentity user (has-one address)) (select user (with address) (fields :firstName :lastName :address.state) (where {:email "korma@sqlkorma.com"})) You're telling me that this is a "confusing mess" you can't read? **Maybe there's a reason other developers and polyglot developers shit on JS devs.**
I am not sure if project organization belongs in the language, specially since projects can be so different... a web project directory structure has very little in common with an ML project, or a desktop GUI project (yes, I make desktop GUI programs using wxPython). If you are talking at a very high level ... directories like src, test, documentation, build, etc at the top level, maybe that makes some sense. But I wonder how much does it actually help. 
He didn't bash it, he said it is bashed and tried to guess why. Fuck off genius
&gt; The problem is that pretty much nobody else uses them I thought every typed language uses them... I know this might come across as snarky, but seriously, can you explain what's the basic difference between type annotations/information in Python and, say, Java? &gt; they don't seem to be very expressive Why are they not expressive? 
\&gt;Being told to fuck off by a Vegan Swede who's post history is full of nothing but "alternative" recipes and arguing with people about meat. I love Reddit.
It might be the best language to learn first. The only other option is maybe python
In the end it’s just the same thing rewritten over and over again, and the thing all those reimplementations have in common is that all of them suck.
big =&gt; big ? Boolean(big) : !Boolean(big);
Going through the post history of everyone who doesn't jerk off to [any non-js language], not weird at all
Hm yes I better know everything about this stranger who challenged my reading comprehension and use that as a retort
This announcement is just great! If you are interested in using JS in ML, checkout [this one](https://www.robinwieruch.de/machine-learning-javascript-web-developers/). Still have to put Tensorflow.js in there now :)
True ? Big() :
Hey I appreciate the example. I wasn’t being serious... was genuinely useful in understanding lisp. 👍
Oh god my autism kicked into overdrive. Whoops, going to delete this then.
What on Earth are you talking about? We've had immutable-only languages for a long time.
Million line packages with thousands of files could sneak things in just as easy if not more so 
Delete this nephew
He’s not complaining about RR4 by itself, but the upgrade from 3 to 4. It wasn’t just some breaking API change but an entire paradigm shift. I really like the RR4 paradigm, but it was a pain upgrading from 3 to 4. 
For declaration you always use a keyword prefix. For re-assignment, you don't use it. Non-strict mode: - `var x =` and `x =` are the same when not in a function (creates a property of the global object, `window` in a browser) - `x =` will create a global variable no matter which scope it's in, which is bad - `var x =` creates a local variable in a function Strict mode: - `x =` will throw a ReferenceError if `x` had not been declared with either `var` or `let` (re-assignment), preventing #2
But sometimes you *do* need global variables, don't you? Or would you just have to make sure that you always declare them outside functions? That does make sense, as you generally don't want function-specific variables to be accessed outside their respective functions unless you're returning them. Also, am I right in saying that 'let variableName' behaves roughly the same way as variable declaration in Java? And that 'var variableName' behaves roughly the same as variable declaration in Python? That seems to be the case so far.
Same here and I would think so too. Any good resources for getting hands dirty with WASM? I read it has 75% browser compatibility already.
You do, but they're generally constants so it's not a big deal that they're global. A common tip is to use a single global object `MyApp` and assign all your global variables to that object. This way you don't pollute the global namespace. A more modern approach is using es6 modules. You don't even need global variables anymore, just import/export the variables you need. 
That's because the function hasn't run yet, so the global variable hasn't been created yet. function test() { myContinent = 'Oceania'; } test(); console.log(myContinent); vs. function test() { var myContinent = 'Oceania'; } test(); console.log(myContinent);
The reason that code isn't working is because the function hasn't run, so the variable wasn't created. Try this: function test() { myContinent = "Oceania"; } test(); console.log(myContinent);
Your console log doesn't work because it isn't run within the function and as such does not have access to the var. Your original attempt at assignment with myContinent = 'Oceania' does not work because you aren't using var, let or const ahead of it. Two separate issues. const myContinent = "Oceana" function logContinent() { console.log(myContinent) }
Ah yep, that makes sense; I tried calling the function and got exactly what you predicted. So in summary, I should *always* use a prefix. Am I right in saying that 'let' is generally better than 'var' though, as it has more restricted scope?
I see. Is that quite similar to the process of importing modules in Python, Java, etc?
I've been writing javascript since the 90s, but I'm not loyal to any language, I just like making things for the web. If some other language came along and I could write full-stack web applications with it, maybe I'd use that instead. The fact is that nothing else can, so what's the point of arguing about it? 
hi. I guess I dont quite get this "Mostly in JS we don't create 700 different data structures like you people ("everything is an object"), in practice what we pass around is in most cases either an Object, a function, a primitive (string / boolean / number) or an Array" What are you saying? What Im saying is that a function signature doesnt tell me what the parameter is, so if the code is unfamiliar to me, I have to track it down. Defaults work for primitives for sure. But knowing something is an Object, for example that defaults to {} is hardly much better. Whats in that Object? Thats the question. I dont suppose there is a perfect solution
What?
# CONSOLE.LOG((ARG = (A = B = C = A(B)(C))(ARG)('BIG')('SMALL'))(A = B = A))
This should be higher in all honesty.
Syntax error
Yep! Not all browsers support es6 modules yet, so you'll need to use a module bundler like webpack or browserify. Even when all browsers eventually do support modules, webpack will be here to stay, so it's good to learn it.
Generally you want to avoid repeating code as much as possible, called `DRY` (don't repeat yourself). In yours, you're calling `Number` with the same argument in two different cases (and also calling it four times total), and doing the reversing twice when it's not needed. Also, prefer ternaries over `if / else` when possible. It can be simplified to: function reverse(n) { const r = n.toString().split('').reverse().join('') return Number(n &gt;= 0 ? r : '-' + r.slice(0, r.length - 1)) } - First, store the reversed string version of the number. - Then, you can return the number version by using a ternary expression that evaluates to `r` as-is if it's not negative, otherwise it appends a `-` to it and takes the last `-` off.
I clean my tears with my paycheck.
So if you want to stick to the JavaScript language but you want to learn the back end and databases the you should learn some nodeJs. It is server side JavaScript. Once up and running on a server, you can choose any database to work with but I would recommend either mySql if you want a relational database or MongoDB for a noSQL database. I personally like MongoDB. Also React is definitely the hot library to learn right now. To strengthen you critical thinking you can practice algorithms on hackerranker.com Good luck.
Personally, the choice of TypeScript over Flow is mostly due to a more developed community, better tooling, more consistently defined types across many open source libraries, etc. Flow is amazing, but tooling and community are incredibly important. 
I'll preface this with I mostly do python--but seriously you seem to be taking some dumbasses comments too seriously. There wouldn't be the "modern" web without JS--it has its wrinkles and warts but so does C, Java, Python, Lisp ... Node on the other hand is utter shit--I'm joking. There are 1,000s if not millions of people using JS and Node and you're focusing on the dumbasses. 
Yeah--but everyone loves python so can we all agree to write everything in python from now on? [I've got flame retardent underwear on--not sure if that will be enough] ;-) 
If you can cache it, it begs the question - why even instantiate something? class Foo { static action() {} } function onClick() { Foo.action() } If refactoring to something like this messes up your state, then you can't cache it.
There's a lot of redundancy in your code which is not considered good. For example, look at this snippet: if (x[0] == '0') { x.shift(); x = Number(x.join('')); } else { x = Number(x.join('')); } That last statement in both branches are identical so that can be rewritten as: if (x[0] == '0') { x.shift(); } x = Number(x.join('')); You don't necessarily have to see those while you're first writing the code but once you have the first draft done, you should be able to spot the ways you can merge similar branches. 
JavaScript is not programming. It's scripting.
&gt; console.log((arg =&gt; (a =&gt; b =&gt; c =&gt; a(b)(c))(arg)('Big')('Small'))(a =&gt; b =&gt; a)) No joke, doing beta reduction on this comment has given me the best intuition to date as to why (a =&gt; b =&gt; a) represents "True" in lambda calculus.
It's already at 6
Honestly, reddit is trash. Most people here don't know what they're talking about. It's fun, but it's a massive circlejerk.
Most of them were forced to use JS for web development and instead of actually learning the language they just tried to use it like &lt;insert their fav language here&gt;. When it didn't work out they blamed the tool rather than the fact that they didn't bother to learn how to use the tool.
And if we get the smart pipe stuff it has even more potential: 1 |&gt; f(_, 'hi') The `_` isn't in the proposal, I've just used it here since I don't think a character has been selected yet for the use case.
Yes, it does. 
I wouldn't start with JS. There are so many weird things in the language that are confusing and hard to understand. I would start with a more straight forward language like Java or Python If you just want to mess around and get familiar with coding then JS will be fine
We ignore them because they are jealous, javascript is one of the most powerful, capable and flexible languages out there, while that is all within reason and you can practically do anything with javascript, that in no way means you should. However it is to the best of my knowledge the only language that can run an entire stack, and I have seen some companies do that, but in what other language can you write the front end, back end and database,heck it even handles mobile apps to a degree. I was playing with React native which to a degree is javascript development on a near native device app, with a node backend connected to a mongoose dB. One language to rule them all, now this was pure data aggregation and display, I would not do that for anything computational. As they say, with great power comes great responsibility, so while js is uber powerful, like every other language out there it has its strengths and weaknesses and it is up to us a developers to know the strengths and weaknesses of ever language we use and ideally of a few we don't so that when a project comes around we can make the best decision for the project, not for our skill set. That is one place where I think js gets at least part of its bad rep from, many developer do not underage concept of a toolbox, they only ever learn to master one tool and then use that tool for every job, regardless of weather or not it is the right/best tool. Case in point: #truestory Developer gets project, project is a single page with a form, about 8 fields on it, it is basically a contact form, nothing fancy at all, user puts in data and clicks submit button and bobs your uncle. Said developer has a tiny toolbox, he knows nothing else, so for thus remarkably simply project he pulls out thus tool, and thus to is Angular 2 and Biotstrap. Minified an gzipped I think was about 800kb. Now this is not a problem for only js, many developers only ever learn one tool and given the complexity of backends that may not always be such a bad thing, realistically we all specialise in what we enjoy most, it's the bad ones that believe the tool they know best is the only tool for every job, as that is almost never the case, but because javascript has soo many avenues and options, it's even more important for us front end guys to ensure that we have a well stocked toolbox, so that we don't pull out the sledgehammer to hand a painting on a wall...
People find reasons to complain about everything. I don't think programming languages are any different. 
I unsubscribe and move on. /r/WebDev in particular I just removed myself from as it seems increasingly toxic, including their moderators. *shrug* it happens. Check out the app DevRant. Usually a pretty good community there.
Yep! But prefer "const" to "let" unless you need to modify the var.
Honestly, people lay on the negativity when a language they don't use becomes popular. The most important thing to remember, regardless of the language you choose, programming is a human act: it's people all the way down. It's for people who work together and share the codebase you're in, the people who have the vision and the people who will eventually use or interact with the software you make. Don't let negative people taint your feelings about what you do now or will do in the future. Focus on being a humane programmer and the industry will be your oyster. 
Can I introduce you to ObjectiveC sometime?
I love js but one line packages is something that I can't defend. There is a guy making 800 trivial packages and he's making sure they end up in huge projects like webpack. It's dumb. No matter how small your project, you somehow end up with 1000 dependencies. I'd rather put trust in a few well trusted maintainers than in thousands of package mills. 
I like javascript and PHP. I want to learn java. Hey I even like the bit of clojure I have played with! 
Fewer people to trust, though. I'd rather put trust in a few well trusted maintainers of large projects, than thousands of one-line mills or [someone who creates seperate packages for individual colors](https://github.com/doowb/ansi-colors). This is beyond ridiculous.
How is the package size a factor? Cpan, pip, rubygems, nuget, etc would all have the same issue. You can always snapshot/save/mirror all your dependencies if you are concerned. JavaScript is not unique in this issue.
Seriously please propagate that JS is awful, when it's probably the most necessary language at this point, I'd rather be in more demand and make more money.
Ehm. It's a language? I don't give a shit what people say. If I know that this language can solve my problem better than another language then that's the only I'm going for. Some people think that Russian sounds weird, but I'm not going to try and speak English to my grandmother. Same principle here. Javascript for webapps. PHP and Python for servers. C for desktop. Rust if I want to feel bad. Don't worry about it too much.
no thanks, ill take swift though :) 
Bananas aren't a fruit. They're yellow... 
I just see it as a joke. I my self "hate" on Java almost daily, but I still use it every now and then. Languages are just a means to an end, you use the most suitable one for the job and that's that. No need to make such a fuss about it :) 
Yeah, but I need to upgrade to get the miner, right? If I work with fixed versions that shouldn’t be an issue.
Please explain how ngrx is any more complex than redux.
Right. So did ES5 basically not support module importing at all? If not, then did code writers have to fit everything into a single JavaScript file and break things down into different classes (using OOP)? It seems weird that the JavaScript paradigm would be moving away from that, given how OOP has become increasingly popular with other languages in the last 10-20 years (as oppose to module importing).
You're not allowed to like things that we don't like.
A someone else here quoted: &gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses - Bjarne Stroustrup 62.5% of all developers who answered the StackOverflow 2017 survey code in Javascript. Cool kid python was on 32%
Surely npm has million one liner packages, but they make package independent. Someday try to install numpy in Python.
 console.log(a); var a = 1; logs undefined console.log(a); a = 1; will throw ReferenceError
That website seems to indicate they're the same: "deeplearn.js has become TensorFlow.js"
Wut?
#/FACEPALM
Python 2 or 3? I rest my case.
PHP deserves it 🙄
not exactly -- deeplearnjs has become part of tensorflowjs as tfjs-core (https://github.com/tensorflow/tfjs-core), but there is also another, more high-level keras-like part -- tfjs-layers (https://github.com/tensorflow/tfjs-layers)
Yup. Java is trash
&gt;It brings a tear to my eye when it's Java people doing it, LOL Lmfao preach my brother
Wut???
“Seriously though, I hate angular” See original comment. 😂 Yes you can use NGrx for state if you wish... there are a number of libraries in the angular ecosystem for state. 
lol
Isn’t it fine to use “const” even if you need to modify the var, as long you don’t need to re-assign it?
You complain about circlejerk on hating JS but you came here to circlejerk about JS...
Nothing is wrong with Lisp, but people still love to hate it. Frankly, they have the best [hate jokes](https://www.toggl.com/programming-princess/).
Cool. This is good news :D
Haven't opened the website in a while. It's good news too. It will get more exposure now :D
`const erection = !twasAFarce(article) ? 'big' : 'pretty big';`
A better typo yet would have been &gt; I always hear use Putin for training and Gulag for execution.
There are no programming languages that are really liked by everyone, unfortunately. JavaScript is incredibly popular, so there just so happens to be a lot of people who hate it, and many others join in to circlejerk. Copypasta inbound
I am sorry, I was very tired yesterday and didn't clarify that it's not the typing package's fault. The problem is that due to the "Pythonic way" most developers don't write code with types in mind, which means that it's impossible to require that something is something (i.e. it implements an interface). For instance, try requiring something to be the equivalent of ICloseable in C# using typing. You'd have to create an ABC (bleh) for that, and good luck forcing every Python user to describe the capabilities this way. `typing` itself seems pretty OK.
Figures it would be jonschlinkert - that dipshit's pretty much the poster child for bullshit single-line dependency modules.
&gt;I thought every typed language uses them... I know this might come across as snarky, but seriously, can you explain what's the basic difference between type annotations/information in Python and, say, Java? It's not that there is a difference. It's just that Python developers don't write code with typings in mind. In Java and C# everyone makes a best effort to describe the contract using interfaces. In Python, everyone just writes classes with the same methods, and you can't really say "I want something that is Closeable" because nobody specifies that their class is Closeable. That's why I don't think type annotations are expressive - they can be, it's just that in practice, they are not. In the end, you'll be writing things like `Union[Dog, Cat, Rabbit]` instead of `is Pettable`because Python programmers would just say that all these things extend an Animal and be done with it.
It's a good language that is easy for new developers to learn and now has strength enough with transpilers for the static type gurus to get into it. It has spread from browsers to servers and now IoT devices. In fact I tried using Python to control a servo with a RaspberryPi and found that it had trouble keeping the servo in one place. I found a Node package that wrapped the same library but fixed the jitteriness. The point is someone else figured out the problem and fixed it so I didn't have to. I could use their package and focus on the problem at hand, not the bugs that show up along the way.
You know how people tend to hate CEOS, politicians and bosses? And not janitors or other low end folks?
That's pretty much a list of most hated programming languages in the world, good job :D
Which python is that? python 2 or python 3? ;)
Brad travesrsy - go check tons of his free content on Youtube, if you like it check his udemy modern JS and after go for mongoDB / express / node.js backend course.
What does DSL stand for in this context? 
To be fair, Angular is TypeScript, which is quite a bit nicer. 
Well, compared to redux + thunks (with async functions), there is a *LOT* more work to doing async handling (effects) in ngrx vs @angular-redux/store. You have to write a *LOT* more code, for not much gain. With ngredux, since the store is available to my service, I write async service handlers that dispatch directly instead of using redux-thunks, but the point stands.
Also, easy enough to re-dispatch actions to other instances.
That's pretty much my goto as well... I haven't found many cases I need something more complex than thunks... though with @angular-redux/store, I can just use a service for event handlers, and dispatch from there directly. All the same, the action -&gt; dispatch -&gt; reduce -&gt; publish pattern is really nice.
I used it in the late angular2 betas, and that was painful... recently revisited with @angular-redux/store, and it's been a *very* nice experience at work. Far simpler to use in practice than ngrx imho.
Which language is still around and runs on everything? Oh right.
I haven't touched Java in a while, I usually find that it can take days just to get any given Java project to build. I haven't had many good experiences with it, and haven't become familiar enough to get past that. I always liked C# more, and found it easier to get up and running with. JS is similar, it's just a lot less friction to get started... these days better than ever before. Modular code + a few command line utilities and you can do a lot without being hung up in a ton of boilerplate. Note: a lot of devs from other languages try to bring their boilerplate with them... WTF do I need a dependency injection framework for? I have CJS (require) and now ESM (import/export). WTF do I need an ORM? I have template strings that can convert to parameterized queries. In the end, it's a lot of snobbery... the same people will generally lean towards TypeScript over JS as well.
Blatant affiliate linking. Fuck off.
People just slag off things that are different to what they're doing themselves. Just ignore it.
What's the beaker browser? What's the dat protocol? How much of these are standards? Your readme should explain these things.
In practice, I find most of the "magic" that can be surprising in certain context to be very logical defaults... JS is better than most for ETL or dealing with garbage data without completely blowing up. I like it for a lot of things, and is usually the first tool I reach for... even if only to orchestrate other programs. NPM is also a *HUGE* part of that, making it very easy to do almost anything quickly as a proof of concept, and if necessary, refine later. Atwood's Law makes JS the penultimate prototyping language.
I believe you are wrong on #4, using a variableName without a declaration will always be global.
I think what you're missing is that the original array is indeed unchanged. There reducer creates a new array with the the old data plus the new data and returns that, and then that's the new state. By the time you get to BY_ID, it's not the same array.
Exactly. What does it matter if it’s a “one line dependency” if it solves my problem and I never upgrade it. Does anyone just blindly update all their dependencies? And we have lockfiles. 
Here is my suggestion: - learn React and how to create small apps, https://glitch.com is an awesome tool to create small (or not so small) demos and projects - dive into learning even more JS, more advanced thing, all while creating demo projects (it's more fun than just learning the theory all day) - learn some Node.js so you can write server-side code as well, always with JavaScript, so you won't need to learn a new programming language. You can start simple with frameworks like Next.js that use Node.js to create server-side apps with React, and interact with databases from there Just a very broad roadmap, but this is what I would do in your shoes 
I like your solution. Could you post a snippet code of your Russian doll solution.
4) is wrong. Always use let &amp; const. Much better practice. 
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: /r/Serendipity/comments/88hpm6/webdb_the_web_is_your_database_a_db_for_the/
Cobol keeps getting better and better
I’d rather write Ruby than Python 🤭
https://en.wikipedia.org/wiki/Domain-specific_language - w/ the domains here being data transformation, dataflow and dynamic JS function construction. The syntax is also quite interesting for graphics and/or live coding purposes and is easily extensible. Other Forths aimed at JS are implemented as toy virtual machines and kind of standalone universes. This one here only embraces Forth's minimalist syntactical and stackbased approach, combines it with Lisp's "code is data / data is code" philosophy and is really just a powerful, dynamic function composition generator on crack...
Exactly the same as VB6, back in the day. Purists who don't actually do serious development dislike it. 
It's basically a decentralized way to host web resources in a peer to peer manner. The beaker browser is a modified chromium that supports this.
No, there is no way. I assume the ui you're trying to build has a button that allows a user to filter by id. To model this, you'd need to store the user's filter choice in the state (rather than changing the list of all the items in the store). Your state would look something like: { users: [... all users], currentFilter: 1234, } And then you'd apply the filter in your render method
I can't believe there are still smart people working in that shit of a language. Most people I met who are PHP programmers are not very clever, but I personally know at least two who are very bright, smart guys and yet they still work with it. Unfathomable.
Welcome to earth, the citizens here shit on each other.
&gt; I am NOT a fan of class-based OOP. I mostly write react these days and I like to use classes to keep code for a single domain together. Long inheritance chains are quite bad. IMHO if you don't go overboard with OOP it's still a nice was to break down complexity. Just avoid long inheritance chains.
You need to interpret it backwards, then once in French and twice in Deutschland
Amazing intellisense. Autocompletions for everything. No need to keep checking documentation or stackoverflow to find out what methods are available to you or what arguments to pass to an API. No easily avoidable runtime errors. Much easier to read and understand other people's code. I would never go back to plain JavaScript.
Think of Redux like a queryable RDBMS for UI. We can store all the records in Redux, irrespective of what to render. The information to render is the responsibility of the respective component. One of the practices which I follow is to separate your redux tree into two categories: Entities and UI state. Entities deal with all information fetched from server. This is mostly kept normalised ( which you have done above ) to do easy lookup. UI state should contain all client information like filters, pagination indices, etc. The component that renders needs to read both these information to decide what to show. This can be achieved by writing selectors that can return the derived information from Redux. Example Reducer : import { combineReducers } from 'redux'; const normalizeData = (records) =&gt; { return records.reduce((allRecords, currentRecord) =&gt; ({ ...allRecords, [currentRecord.id]: currentRecord }), {}); } const byId = (state = {}, action) =&gt; { switch (action.type) { case types.FETCH_RECORDS_SUCCESS: return normalizeData(action.payload); default: return state; } }; const ids = (state = [], action) =&gt; { switch (action.type) { case types.FETCH_RECORDS_REQUEST: return []; case types.FETCH_RECORDS_SUCCESS: return action.payload.map((record) =&gt; record.id) default: return state; } }; const filter = (state = false, action) =&gt; { switch (action.type) { case types.SET_FILTER: return action.payload.id; case types.RESET_FILTER: return null; default: return state; } }; const sort = (state = false, action) =&gt; { / * Login similar as filter * / }; const entity = combineReducers({ byId, ids }); const ui = combineReducers({ filter, sort }); export default combineReducers({ entity, ui }); 
Tampermonkey is a Chrome extension and should work anywhere Chrome runs. What do you mean by "on pc"? You mean Windows? Or Intel CPUs?
&gt; Why do you think it's relevant what a language does if you put in code like '5' + - + + - - - + - '-2'? The whole panel is showing how inconsistent basic JavaScript can be, even fully understanding coercion etc. sometimes isn’t enough to save you from bugs. Of course that example is taking it to extremes for comic effect, but that it is valid syntax is still mad imo. Sure Python’s late binding in closures may be a gotcha, but it’s consistent and relatively rare to see. This is the real basics of JS. Again though, good JS can be written so these warts are not relevant. 
This package is in the Beaker browser org on GitHub and and the readme even has a "How it works" section that links to the DatArchive API documentation. What more do you need? Would you expect the `babel-plugin-module-resolver` readme to have a full section on what Babel is?
I lick their salty tears. 
Thanks for the comment
"1" + 2 == "12"
I’ve recently started using TinyState (do a github search)... It works extremely well for small apps. 
Thanks for doing this!
Lol the point I'm trying to make is maybe that's why JavaScript gets shit on all the time. It's more of a scripting language than a programming language and there are times that a JavaScript solution won't work on a different browser.
Great write up. Thanks!
It’s a great language, but not ideal as a first one IMO (I’m a computer science lecturer for 20+ years, and I love JavaScript). I think it’s too open and messy, especially when combined with HTML. Too much rope for a novice to hang themself on. A more constrained language like C is better to start. You can follow this with JavaScript.
I'm surprised I didn't see anyone mention that arguing is just fun. I write js for a living, but I sure use every opportunity I get to shit on it.
If it's open source, why not just share it with us?
Ugh, I recently inherited some projects from as late as 2016 with no VCS. 
JQuery is no longer needed if you’re targeting IE11+. QuerySelector does the same thing as $() and fetch is a decent replacement for ajax(). It’s super common and there’s no rush to get rid of it, but for new projects it’s a waste of time. 
If you really care about this use case, sleep sound: this is perfectly valid TS.
I've been working on this repo with Codewars katas solutions with tips &amp; resources to learn ES6, RegEx, and more! https://github.com/lndgalante/codewars-katas
You should at least try to use constructors / funtions / objects to try and break down your complex logic there. I’d also try to apply some templates like underscore / handlebars 
Yeah dude this is what you're looking for: https://runkit.com/ 
Thanks!
You can try to design your own structure, or you could read the documentation of Vue.js, for example :)
People used to use Backbone. Before that, mostly PHP/JSP/.NET + jQuery, yes.
I keep misreading it as WebMD.
&gt; ReactStrap This one looks good.
I work on a quite large django project and I only use jQuery. Honestly I try to use JS only when it make sense and keep it simple and so far it's manageable. I've thrown in a little of Vue.js for the realtime dashboard, but that's it. These days I'm trying to build full JS SPA with Python backend, while there are obvious advantage, I find the JS stack quite bloated and confusing.
First off there we’re frameworks before vue,angular and react. Backbone, ember ... come to mind. These are still valid. Many newer ones have a focused virtual dom, which is definitely not necessary to creating for larger applications , though have its benefits . Jquery is more of a selector and utility tool than something that is going to help you provide an extensible structure. I have old projects pre modern frameworks that still run seemlessly today. Imagine no worries of code base changing!! The key for me was to build in a component based system. The was a generic way to put content on and take it off the page. 
A lot of stuff was done server side, with very light client side interactivity. CGI-Bin, PHP, Java, Python, C/C++. Ultimately, the big companies that made client side apps wrote their own frameworks. React (Facebook), Angular (Google). A lot of further frameworks were inspired by these. There were plenty of helper libraries. MooTools, JQuery, PrototypeJS. And some frameworks like DHTMLX, ExtJS and so on. These also inspired further frameworks. Some places just went with vanilla JS. It's very powerful, and quite easy to build up enough interactivity for specific purposes. Not nearly as easy as whipping up some vue or react or whatever, tho. A lot of it was about re-inventing the wheel. The tools has been around since 2006, if not earlier. Obviously its been massively improved upon. Also, they way it is used has changed significantly, too
put src files in src/ keep config files in the root
I'll take the billionth crypto wallet generator for a 1000 Alex.
Well, I've used Backbone, Can.js and jQuery in the past. It can become very messy if you start to code without planning every detail. The backend language doesn't matter that much.
The languages and libraries you use are largely irrelevant. Whether use jQuery or vanilla js in this instance is doesn't change much. This is an architecture/ design question. There are a number of approaches you can use and they all have their advantages and disadvantages. Facebook push the Flux Architecture which has at it's centre this idea of uni directional data flow. You could also emulate the component model organising your ui into self contained components with all of the markup, behaviour and styling together. If you're using js modules this is very simple. Vue subscribes to the MVVM pattern (model-view-viewmodel) with vue being the VM part. This is something you could look into if you wanted to further organise your project. It is a very popular pattern at the minute. The reason frameworks/ libraries make this simpler is that they push a particular pattern (in their docs or based on certain additional modules) or in some cases prescribe one. There is nothing stopping you from implementing something similar on your own. On a complex project it is an absolutely essential step. 
I think you have the wrong link for day 2
&gt; app.use(function errorHandler (err, req, res, next) { &gt; if (error instanceof ValidationError) { `error` should be `err`. 
Large web apps before complex web frameworks were made with pure js, case and html and server side languages. At that time server side is more heavy than client side. With web frameworks becoming popular, frontends are becoming heavy.
Pretty much the same. Breaking down logic using mvc, templating, module patterns (Revealing Module Pattern, AMD, UMD). Original Angular used AMD to manage module dependencies.
&gt; This is an architecture/ design question. &gt; The reason frameworks/ libraries make this simpler is that they push a particular pattern Spot on. If a developer can design a good architecture, it doesn't matter what framework or even what language he's using. It seems that developers nowadays can only surf on frameworks, instead of come with architectural concepts which can scale. This is horrendously true in web development world.
It's just a massive meme really at this point. I wouldn't get annoyed at any of it. It's a very popular language due to the whole HTML5 thing and it's in massive demand and used everywhere. If you think there's no issues with the language, then surely that's all that matters?
Its the wild west out there, all you need to survive in wild west is the right kind of hat. Although on a more serious note, the replies to this post are not encouraging. Lots of people missing what is at the heart of good software design.
It would be nice if the headlines were about what it is they learned not 'Day 1', 'Day 2' etc.... The goal is to make the article easy to consume while also being conscious of the readers time. I've just recently read 'How to read a book' and it has changed me. I now try to evaluate the effort involved in reading a piece and try to judge if it's worth it. I think medium is getting cluttered with these articles with good intentions but fail to execute on the delivery... Maybe one day I will start blogging (I'm just not good with words) and share my experience about this. I do appreciate the authors effort to help others and I thank you for that, I'm just sort of ranting. 
**"Thank you, haters, because you help me to be stronger and working harder".** I can't remember the author of this beautiful quote.
Before React/Vue there were still frameworks like Knockout, Ember, Backbone, etc. But if we exclude those and consider the time when framework churn on the client side wasn't a thing, most companies with client side apps built there own frameworks to make things easy. If you were making a client side app, rather than a simple website with interactivity there were things that you wouldn't want to do over and over again for every route/page. So you start with making those easy, and then just keep iterating. As an anecdotal example, at my last job their legacy app which was the companies bread and butter was not using a documented framework. It was built 100% with jQuery with a C# backend. There were patterns and abstractions built that made it equivalent to a framework, with methods modules to spin up pages, widgets, events, notifications. Now granted it was not a pleasant framework since there was no documentation, was very buggy, and was plagued with global variables everywhere (Good luck not accidentally reassigning/overriding a variable in another file). Every module was essentially a global singleton that could be accessed from anywhere else and none of the original writers of the app seemed to know a thing about encapsulation. Though it had these problems, it solved a problem they had at the time. To give a clue of how big of an application this was, it had almost 200-300 different routes/pages/widgets that could be accessed. Doing this without some basic abstractions would have been an even bigger hell that it was.
Well, jQuery isn't really an application architecture so much as a DOM normalization and convenience library. There were a bunch of these and jQuery won because the selector driven API was a good idea. As for how web apps have been built, there have been a couple eras of how things work. First came CGI. When a web request came in to a particular url, the http server would shell out to a script and send the script's `stdout` back to the client. I believe (this was before my time) Perl was the dominant language but you could write the scripts in anything. The output is static html pages and the input is form data. Javascript doesn't (really) exist. After that came what I call the *SP era of web development, which started in 98-99. The script processor moves into the web server in some form and you get a sort of mixed database/template language ball of mud. Coldfusion, PHP, ASP, and JSP all come to prominence here and this is where the first dot com boom happened. Javascript is used to show/hide stuff and for AwEsOmE mouse trailers but Flash is the more refined client side tech. Then comes the era of Ajax and Web 2.0, otherwise known as "javascript works". To me the kickoff for this era is the launch of Google Maps in late 2004. I learned JS in 2001 contributing to the pre-Firefox Mozilla web browser UI but pretty much nobody cared about Javscript until Maps and then everybody cared. Oddpost, OWA, and Gmail all came first but they didn't have the same impact. The big challenge client side was to get stuff working consistently across browsers. Dev tools didn't really exist, there was the Gecko DOM Inspector (for the few of us who knew about it) and developer bookmarklets but they were all pretty basic and a lot of effort went in to figuring out what was happening in the browser without any way to see it. In the beginning everybody had their own normalization library and over time, thanks to the newly awakened power of Open Source (and hosting on Sourceforge) things consolidated into a set of normalization libraries: prototype, mootools, mochikit, dojo, yui, and jquery. Of the set, jQuery won. During this phase the bulk of the web development community finally realized that the *SP model of mixing business logic and presentation was bad. There's a shift here to a more defined server side model with a seperate templating layer and an "MVC" (really model2) architecture. The rise of Django, Rails, CakePHP, etc happens here. The bulk of the "real work" in the web app happens server side and the client side code is used for "ajax sprinkles" to make the interactions a bit smoother. A relatively common strategy was, in response to a button click, to XHR to get a rendered chunk of HTML from the backend and `innerHTML` it into a section of the page. I classify the Ajax era of web development as ending in 2009 with the launch of Backbone into the Client MVC era. The big shift here is that the business logic and templating moves client side and the server starts primarily serving JSON. As before, there were plenty of people working on these patterns before Backbone showed up, notably qooxdoo, sproutcore, knockout, and yui3. I'd switched over to this style in 2007 because I was working on a Python web framework called TurboGears that turned returned dictionaries into JSON and I was using my own library that worked a lot like Backbone but Jeremy's version was quite a bit better. One of the reasons this development didn't happen sooner was that Javascript got roughly 50x faster in 2008-2009 due to the speed competition between v8, spidermonkey, and jsc. The work in the js engines is really what enabled the modern era of client side development and (with the help of the iPhone) finally knocked off Flash. This is the first time I started seeing 10k+ LoC apps client side regularly. I'd run into a few before but it was pretty rare for a jQuery app to go over 5k LoC without turning into a hairball. Using plugins as components could buy you a bit of leeway but without having a more defined architecture in mind things got out of hand quickly. The currently active era of web development (Component Era) starts in late 2011 with the launch of Angular but it didn't really catch on until 2014 with the rise of React. Aside from components and generally fixing the flaws in the earlier client MVC models (which I won't get into), this era is marked by a shift to a dedicated build step for pretty much all client side code. Server side, there's been an embrace of SOA (Cloud Computing) in the form of backends as a service (e.g. Firebase) and serverless, though neither has become the dominant pattern. The upcoming era is the PWA era. I expect it to be marked by a shift to more code client side for single page applications (but better cached due to Service Workers), likely in the form of WASM. With Safari about to ship SW, I think we're 18-24 months away from someone making the breakthrough pattern here. Well, this wound up being longer than I expected. To answer your question more directly: earlier web apps were much simpler. We put a lot of effort into just getting stuff working.
I've seen people diss python for it's whitespace stuff. I'm not proficient enough at python to know why this triggers some people, but I've seen it.
I don't read WebDev as often as I read here. How have they become toxic? It seems like they would be big JS fans. 
VM16680:1 Uncaught ReferenceError: CONSOLE is not defined at &lt;anonymous&gt;:1:1
&gt; come with architectural concepts which can scale and then proceed to moving to production without writing a single test. Classical I apologize for being salty, but developers surf on frameworks for a good reason. You don't reinvent the wheel when client pays you by the hour to get the job done, especially considering a high turnover rate in the industry. It will be shitty and go into dumpster the second you personnel decides to move on to another project because there will be no one left to maintain it.
Personally prefer watchandcode by Gordon Zhu. Super easy to understand but you end up truly understanding javascript.
Quoting Fowler: &gt; I considered using multiple languages, which would emphasize the language-neutral intent of the book. But I felt that would be more confusing for the reader, better to use a single language so they can get used to a consistent form of expression. So which one would be the most approachable to readers? Such a language needed to be widely popular, among the top half a dozen in language popularity surveys. It really helps to have a C-based syntax, since most programmers would recognize the basic code structure. Given that, two stood out. One was Java, still widely used and easy to understand. But I went for the alternative: JavaScript. &gt; Choosing JavaScript was deeply ironic for me, as many readers may know, I'm not a fan of it. It has too many awkward edge cases and clunky idioms. ECMAScript 2015 (ES6) introduced a rather good class model, which makes many object-oriented refactorings much easier to express, but still has annoying holes that are built into the fabric of the language from its earliest days. But the compelling reason for choosing it over Java is that isn't wholly centered on classes. There are top-level functions, and use of first-class functions is common. This makes it much easier to show refactoring out of the context of classes.
Aye, I hear ya. That might not have been a good example considering the post was about JS haters. I just brought hem up as an example because it was my most recent experience. In what way are they toxic? Just acting like a bunch of turds. I don’t even remember the details at this point. You know how the Internet is.
Keep perspective. I don't visit other programming subreddits all that often, but I do get a lot of ribbing from other programmer friends and colleagues. Almost always, it stems from misinformation. They mostly remember JavaScript from 1998, when its reputation was forged as a toy language that you had to program at least twice to make it work. Even as recently as 2016, I interviewed people for the position of "JavaScript developer", and out of the 16 people I interviewed, 13 had never heard of Object.create. Yet here they were interviewing to be a professional developer in that language. So that's the perspective, that people regard JS as a crappy little toy language that you don't have to bother learning until after you get the job. In real life, I can change that in the course of a single conversation, but on Reddit people will cling to the memes for dear life, so just sit back and realize that you know better than they do and don't be bothered with it.
Any large enough web app uses a framework, either 3rd-party one or implicit, undocumented one that emerged during building this app.
I maybe wrong, but the for loop runs in the context of the stack, thus its last value for i is 6( when the loop terminates) . The settimeout methods are added to a ‘queue’&lt;- these will be only executed once the the stack has finished executing which is your for loop in your case (which will lead to the value of i being 6) . I recommend reading about the javascript event loop to understand this better https://youtu.be/8aGhZQkoFbQ here is an awesome talk about it. Go through it , much worth the time spent!
Another person converted, muahahah
It fits with Fowler idioms well, I'm looking forward to it and not primarily as a JS consumer :)
ES6 has to be one of the most successful revisions to a language ever. So many people say they wouldn’t even consider using JS before it. 
Off topic but great post.
&gt; I don’t blame people for using it I don't blame them. I just can't comprehend why they don't switch to some other language. It's not only more enjoyable-it also pays better.
I understand but without the extension your preferences won't persist. You'd have to run the script everyday
See the store as a database and your reducers are responsible for adding, removing and updating records. You can then use selectors to retrieve (some of) the data. This is where your fillet logic should take place
Before frameworks, we all ran into the same issues. And do we learned namespacing and modular programming. And everyone started building framework s to make the job easier. And on it went until it evolved to what we have today. A word of advice, stop building, plan and architect your solution and refactor now, or bite the bullet and move to a framework, it’s only going to get worse from here. If you like I can take a look at your code and give some direction.
Well, ADD_ALL adds the data to the state, that’s where the data comes from. The state is not mutated, a new state is returned. You follow? 
With [effects](https://github.com/ngrx/platform/blob/master/docs/effects/README.md) all you do is define an observable chain to respond to a type of dispatched action. Rxjs observables *can* be complicated. But they don't *have* to be. And they aren't that wordy.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ngrx/platform/.../**README.md** (master → cb473c0)](https://github.com/ngrx/platform/blob/cb473c00475289509f0924321bb293d0ad1137ca/docs/effects/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dwledel.)
Nothing
You're bringing back java nightmares. Hibernate, spring boot and maven. But the legacy was even worse somehow (thanks ant)
[[[[]]]]]][[[[]]]
Go with the framework that has the best UI library and support for what you need. My guess is you would not want to develop all components and drag and drop functionalities from scratch. I’m partial to react, but look into vue and angular and see which ones have libraries that support what you need, if you find multiple options, find out which one is most performant and you have your answer.
That guy seems like a douchebag
&gt; ECMAScript 2015 (ES6) introduced a rather good class model Ermm, not it didn't. It's just syntactic sugar over prototypal inheritance, and has no member privacy.
Js is such a train wreck anything is better than the status quo. 
Thousands of winforms and wpf devs are in the same boat too. They definitely aren't complaining.
You seem to have a deep conflict. What you just wrote and the fact that you spend time in this subreddit don't match. Not unless you are into BDSM. *Of course* your brain will come up with all kinds of justifications, but it makes no sense to spend (even more) time with something you dislike and that's that.
Disagreed. Practicing functional programming, leveraging prototypal inheritance as needed (but making an effort to minimize inheritance), and closure for privacy is a better way to write JS than with ES6 classes IMO. ES6 classes start making more sense when you dive into TypeScript.
I built https://tomsplanner.com/?temple=example with bit of jQuery and the rest is vanilla js. Took me 2 years while periodically doing freelance work for bread and butter. It's very heavy on the front end and pretty light on the backend. The code base is now 10 years old and still feels like totally workable and I am still adding to it. I would say, keep things simple, don't over think and 'over abstract' stuff. Readability has always been my second goal when writing code (do what it is supposed to do without errors is of course number 1). I found MVC to not work because of performance issues. I found having single event handlers very useful. So I have one event handler for all xhr requests, one for all mousedowns, one for all mouseups etc... I use loads of singletons for different parts of the tool (one that manages scrolling, one that manages notifications, one that manages drag&amp;drop, context menu's etc..)I have one function that checks a lot of layout related stuff when big changes to the data occur. I found that linking data objects to dom node works really well. So for instance a row object in my datastore is directly tied to a property of the dom node that represents the row in the interface. You can use objects but I find that a collection of stand alone functions that work together work just a fine as an object with methods. I don't think global variables are evil. When used right they are pretty powerfull. Oh and make the names of your variable and functions so they are easy searchable. Don't overstrech yourself to avoid code duplication just make sure your comments point you to the other spots where the code is duplicated. This keeps things simple and readable.
Now I’m getting lisp flashbacks.
((((())))(((+5 5)))
Thank you, i think UI framework is a good option for my case, i should go with react + electron. 
JS is undeniably important because it's in every browser. There is no more conflict in spending time here than on this very post, by Fowler who declares not to like JS but still bases his book on it. Life is full of contradictions.
With lots of code and a great deal of hard-to-maintain fudges. Reporting in with a SPA used for analysis of terabytes of image data and pretty large network analysis stuff, sitting at about 65kloc of js, with no frameworks. It uses libraries, obviously, but nothing like react/Vue/angular. It has some custom windowing stuff, 3d viewing tools and so on, and nobody really knows how any of them work any more.
ES6 is pretty great. You can be as sloppy or succinct as you like.
nuh uh
APRIL FOOLS !
You know what he means...
Remember the data that a reducer returns is immutable in the sense that we don't mutate it; they're instead copied and altered, like in Array.map. You dont need to freeze the state because you've decided in using Redux to never, NEVER directly alter the state anyway, but instead to dispatch your actions to your reducer, which does the copy-and-edit process for you. It's very tempting to make a reducer return an array, but especially given the intent behind your two actions, consider instead normalizing your data into a database-like dictionary object of id keys paired to corresponding object values. { "001": {id: 001, name: "foo"}, "007": {id: 007, name: "bar"}, ... } That way, you have one thunk to fetch your data, one action to receive the data, and any component that needs one datum, you can grab it simply with bracket notation without even sending an action to this reducer: this.props.puppiesObj[this.props.selectedPuppyId] But how will you map over the data, you ask? Use Object.keys to (essentially) convert on they fly your dictionary object into an iterable array: Object.keys(this.props.puppiesObj).map(puppyId =&gt; &lt;Puppy key={puppyId} ...this.props.puppiesObj[puppyId] /&gt;) Is slightly more verbose than this.props.puppiesArray.map(puppy =&gt; &lt;Puppy ...puppy /&gt;) But it saves you a whole action call and allows the reducer's data to be queried in multiple ways, very quickly. To do a findById on an array, you'd have to check every idx, which is why you needed to write a BY_ID action.
And so, it begins
I, for one, am not a fan of my member being made public 
Don’t try to execute the JavaScript file alone: that is running it with the Windows Script Host. The WSH is an old component in Windows that doesn’t support modern JavaScript. Instead run it with Node (which I assume you have installed): `node server.js`.
Thank you for taking the time to reply, I did as you said ,but I got was this [error](https://imgur.com/JvHT6yQ) so I figured out that I should install express, so I went ahead and did that and tried to run the server again but I got this [error](https://imgur.com/P394jNn). 
I miss the stability of interfaces and types too much to enjoy working on any JS project of scale. So my preferred way of refactoring would be a type- and test-assisted restructuring of code by gradually adding TypeScript (and layering, extracting methods/variables, using interfaces for separating abstraction from implementation etcetera). IMHO, types and interfaces help enforce structure and convey meaning. I like JS, but I like types too. I am very curious to see what Fowler's way of dealing with large JS codebases looks like.
This guy web develops.
It's the jobs that matter, not the subscriptions. =)
If you've just installed express then you likely have the latest version which no longer needs body parser. You should be using express.json and express.urlencoded This has been part of express since 4.16
How is it 2 layers? You define a class to hold the effects and then each effect is just a decorated observable stream. That's the only layer beyond the standard redux stuff.
Same error, same solution, install body-parser. Looking at the code you posted, you're going to have to install body-parser, and pusher. You should learn about npm and node packages.
We will crush them in our fists. They are nothing.
It's been a while since I've done anything in HTA. Here are a few guesses: You have some typos in the file:// syntax. Can you build a full, absolute path programmatically? Query for the .hta's absolute path via an API and generate paths to other files relative to that? Can you pass a path that omits file:// to RunFile? `RunFile('./Data/myscript.js')`?
I'm pretty sure we've had those for a while now... Thank God. I know this a controversial opinion, but screw python. What a useless language. 
you hosted 2 applications or you were using a third party api?
Exactly! In fact we have more than they do! =) So all is well.
Back up to the CGI Era, I was around and developing front-end back then (before I made it a career) and indeed it was almost 100% Perl. PHP came in a bit before ASP/JSP, as Pretty Home Pages, IIRC 1997. I remember it well because it was still coding HTML in Lynx browser while the admins of the telnet chat site I frequented were raving about it. That gap in time saw so much adoption from amateurs that it's still largely responsible for its success and proliferation even today. A lot of those folks went pro, and cemented PHP at a lot of organizations. Then ASP/JSP became a major thing and PHP still held its own. So there's a little more context. I've been meaning to do a blog post from the perspective of someone who's been doing front-end since the early years. OP's post is spectacular and almost how I would have described the general timeline myself. 
Drump DESTROYED
Exactly. setTimeout is a Web Browser API. Thanks for the link, will definitely check that out.
Saved my ass. Thanks!
Ok, I updated the tutorial with your great suggestions - thanks again! One more question - why did you add "|0" after random() and a couple of divisions?
And I just joined yesterday. Maybe I was the one to push it over, haha.
Both JS (with all its related projects like typescript etc) and Python (with all its related projects like ML etc) are doing really well! I like the way the communitites innovate, and has not stagnated, like other communities (php for example) and push new stuff and fix old stuff to work better. its a good time to be working in each tech. personally i think TS is a game changer, i have close to zero runtime errors after switching to TS, and in the python world python 3.x is such a better language than 2.x series ever was. 
One could even argue if it even needs to be a class, rather than a pure function? Or, why not create the instance at startup instead of running time.
I'll still take it
lol ok bud
Absolutely. Many would disagree, but really it's a great starting point as it'll teach you concepts that will transfer nicely over to other languages. I started with Python but really its syntax is so unique it took me a while to get used to other languages.
Decided to publicly release an old project of mine. It was originally made as a target interpreter for a visual programming language I was developing, but has some interesting applications beyond that such as safe remote execution of arbitrary code. The language itself is super super thin and needs to be expanded upon before it's useful out of the box, but the foundation is there and it's easy to add new functions. Let me know what you think
who cares
that's not the main reason you obfuscate. you do it to conserve bytes.
Hi, what is your goal? Do you want to get a job as a front end developer? If that’s the case you definitely need to have strong js + web api + css + HTML skills. Regarding framework or vanilla I would say that this has more to do with marketable skills than anything else. Don’t get caught trying to learn too many things at the same time. Focus on what will be there for the long term and learn specific stuff on the job. I recommend to read Eloquent JS. It’s a wonderful book and it teaches you at the end how to build a UI with vanilla js (it teaches you all you need to know about js and even a bit of node). Once you are there you realize that react is the tool that helps you with this very specific task. Once you understand what is the problem it solves, I recommend learning react because it’s not a framework and principles can apply somewhere else.
Is there something in your code (a proprietary algorithm, for example) that someone would want to steal and (here's the important bit) monetise? If not, you're likely worrying too much about it. If your client is talking to a server, it shouldn't be trusted to do any validation, so if you're worried people will tamper with form inputs (for example), then this should be validated on your server regardless. Minification should be part of your build process, but for the purpose of reducing your code size, rather than securing the code.
Just one detail. ES6 **is** "vanilla JS". "VanillaJS" means using plain JavaScript without any additional libraries. You're putting ES6 on the wrong side. Separating ES6 from "vanilla JS" is like asking if your should "learn Java before learning Java8".
3) there are many fanboys among framework users. It's all a matter of pick one of your liking or that suits your project. 4) checkout node clusters. It will scale vertically. Horizontal scaling is nothing I've looked into. 5) I think Vs code is good. Webstorm is also great, however, again, this is all just personal preferences. 
What about var? Is it ever worth having the extra scope, or is that considered bad practice as well? I know Java variables effectively have the same scope as those declared with 'let' in JavaScript, but I also know that Python variables have the same effective scope as 'var' in JavaScript.
It only presents JS as immature langauge
What I love about TypeScript is that you get something between JS and Java, because interfaces don’t have to be implemented, they are checked structurally (not nominally). Therefore, you can introduce new interfaces after the fact. In that regard, TS is more like functional programming languages than like Java.
Good catch! On the other hand, it can’t be all downwards if “there are top-level functions, and use of first-class functions is common”. That and being able to create objects directly are big plusses of JavaScript, IMO.
Yes, he means that JavaScript is so bad that any improvement seems significant. In psychology, I believe this is known as anchoring.
fuck, i was thinking this would actually be great lol
I will never forgive him for what he did to Jamie but I hope he is happy with Sonia
Dumb fanboyism from edgelords
Me
Kinda looks like readable assembly :)
Most definitely.
That's minification.
`| 0` is a way to do truncation for numbers which don't exceed the range of signed 32-bit ints. It's essentially like doing a double to int32 cast in languages like C or Java. For positive numbers, it's like floor(). For negative numbers, it's like ceil(). If you need a larger range (or something more readable), Math.trunc can be used instead. However, Math.trunc isn't supported by IE9/10/11 (which do support canvas). https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
Even if someone does steal your code, unless you are doing something revolutionary, and assuming you are shipping a non-trivial amount of code, the time taken to understand what's going on in order to use your code correctly will be as high if not higher than having to re-implement it from scratch. Even more so if someone wants to fix a bug or modify your code without introducing new bugs. You have the mental map of the whole thing, you know why you've done things the way you did, and it is more valuable than the raw bytes (especially after minification, which blurs the intent by mangling names and stripping comments).
*pulls out py27 pitchfork*
Published on March 28th, so I guess he is serious 
&gt; php for example a prime example. PHP is slowly dying.
I'm learning Vue and after doing tutorials I decided to make game: [prime-factor](https://prime-factor.herokuapp.com/).
PHP has zero innovation going on. The core devs seem to have a hardon for BC, thus keeping the language as messy as it is. Theres also no real progress in any of the ”fields” it is used in, mainly the CMS world. Well i guess theres still jobs maintaining old PHP codebases.
Read too many code bases and you'll realise it *is* "an ancient cryptic text of lost knowledge", at least as far as too many of us seem to be concerned...
Sadly, no; legit and confirmed through several other channels. An April Fool's version would have had the book use C++/Qt. */ducks*
If EastEnders was a show about engineering practices in software… Well played!
Yes, you would declare them where you need them. If you need them outside any other functions that's where you would declare them. But still using `const` if they are immutable and using `let` if they are mutable. But they won't be truly global if your code is wrapped in a module. In Node.js (and any browser JS that you bundle with Webpack or similar tools), the file that you `import` or `require()` will be wrapped in a closure (a function scope). So the variable won't be available to other modules even though you declared it outside of your functions. But that's good. Most likely that's what you want. If you want to share variables across modules you can either use the global object, or even better, create a separate module for holding those variables that you then import where you need it. You you always want your variables to be as scoped as possible to prevent leaking variables and causing accidental conflicts. If you include unbundled JavaScript directly in your HTML you can emulate the scope that a module would provide by using an immediately invoked function expression (IIFE): // First module (function (global) { const multiplier = 5; // immutable let counter = 0 // mutable function increment() { counter += 1; } function print() { console.log(counter * multiplier); } global.incrementCounter = increment; global.printCounter = print; })(window); // Second module (function (global) { console.log(multiplier); // undefined setInterval(function () { global.incrementCounter(); global.printCounter(); }, 1000); })(window); 
# Yes
I think he was being facetious ^^^I ^^^hope
Same thing,minification removes white space and changes variable names to as short as possible. Minification obfuscates. 
Javascript hoists variables to the top of the enclosing function when you declare them with var, even if you declare them inside a block. The, nature, of modern JS code is such that var is basically a bad move. When it's time to use var, you'll know it in your bones.... And when it's time to declare a global, you'll feel super dirty about yourself for doing it.
I like codewars :)
Ah didn't realize codewars had JavaScript. I'll take a look thanks.
Almost all algorithm problems platforms have JavaScript as a language option nowadays :)
Even obfuscated code can be reverse engineered, which means if your code is doing something sufficiently revolutionary then obfuscation will not suffice. If you want to protect some code you should just keep it on the server behind an API that you query from the client side as you're doing.
minification obfuscates, but obfuscation is not necessarily minification. Just like a mac is a pc, but a pc is not necessarily a mac.
thanks. fixed!
Preach!!! Cut the bullshit and create cool stuff!
Well I think it's interesting. :-) I've run a [small reddit programming language index](https://mikekreuzer.github.io/Ripley/) for the last two years. I suspect the change in number one may possibly have something to do with the growth of reddit - reddit was written in Python &amp; Python types were always overrepresented here as a result. But it may be more. Some Python types sure seem defensive about it, for whatever reason.
Thanks I tried that but it didn't work. No idea why it's not liking it
What do you mean "back in the day" :D Perl is still alive and is being widely used, even for greenfield products. Also, Perl 6 (which should have never carried the same name), is awesome. Totally different syntax. And is truly amazing. But sadly, due to the name being tainted, will never become big.
I tried using this but no luck: RunFile('./Data/myscript.js') Yeah I know I have a typo somewhere but no idea where. I've tried the following: RunFile('./Data/myscript.js') RunFile('/.Data/myscript.js') RunFile('file:.Data/myscript.js') RunFile('file:/.Data/myscript.js') RunFile('file://.Data/myscript.js') RunFile('file:///.Data/myscript.js') RunFile('file:////.Data/myscript.js') RunFile('file://///.Data/myscript.js') RunFile('file://///Data/myscript.js') RunFile('file:////Data/myscript.js') RunFile('file:///Data/myscript.js') RunFile('file://Data/myscript.js') RunFile('file:/Data/myscript.js') RunFile('file:Data/myscript.js') I'm not sure how to build a full path programmatically but I'll look into it. Thanks
I'm just being a dumb edgelord.
I'm not quite sure what you're asking, but you can simply return whatever data you want at the end of the function: var bar=foo(data); //bar is now equal to the manipulated data. function foo(data){ //Manipulate data return data; } Sorry for formatting, on mobile
Ooh nice, thanks for the link!
Ok wasnt sure how to do that i know in plugins they create callbacks for events and every time you edit that callback they always make some data available to it like in a calendar plugin which is what im working on if i create a click event for everytime you click on a date i want the user to be able to create a function and i always want data from calendar to be available within that callback that the user created
A click handler in JavaScript usually gets an MouseEvent object of type click as argument. The usual pattern is: the target gets an ID within a data-attribute, for example `&lt;button data-id="2464"&gt;` and then in the click handler, you'll use var clickHandler = function(ev) { var id = ev.target.getAttribute('data-id'); if (!id) { return; } // do something with the ID }; document.addEventListener('click', clickHandler); Which leaves the question what the button should do?
I don't know what a "plug-in" is, but that sounds like a JavaScript Object. You can access javacript objects like this. var data=4; var test=new calendar(data); alert(test.data);//alerts 9 function calendar(data){ this.data=data+5;//modify the data } If you could share some code that'd be helpful
I will share some later dont have my laptop with me right now but thaks for the replies
The definitive guide is a pretty great book. For a beginner, I’d recommend doing this order. 1. JavaScript.info 2. You Don’t Know JavaScript 3. EloquentJS + Definitive guide
Put that away, it's almost dead. 
Hi /u/TECHAnonymousYoutube, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/pabloFossfato, For javascript help, please visit /r/LearnJavascript. Thank you!
And obfuscation might even lead to larger files.
Hi /u/Bucz150, For javascript help, please visit /r/LearnJavascript. Thank you!
Ok thanks I built the absolute path programmatically using var rootdir = shell.currentDirectory; and it now works!
/r/UnexpectedBillyMadison
In psychology, what you're doing is known as projecting.
No module use? Yeah, that’s a no from me. 
I think JS is presented that way by non-JS devs, and this is the (childish) response of "See! I told you!"
Seriously, didn’t that finalize years ago?
I thought so. But, perhaps not technically? They’re obviously taking a conservative stance; which makes sense for a large company. 
Sounds like you need some kind of an autocomplete component? If you're using React, I've had good experiences with https://www.npmjs.com/package/react-autosuggest
what is this about ?
&gt; Semicolons ARE required 👍
Named imports are still under a bit of scrutiny and/or debate. Import { foo } from ‘bar’
I heard there is already a new major version of blahblahblah.js. BlahblahblahJS is so 2017, these days it's just Blahblahblah.
Thinks like flexible typing, quirks surrounding equality statements and hackish oop (which is really more of a benefit once you understand it)
They're not the same. Minification obfuscates _somewhat_, but obfuscation might well make your byte count bigger.
Afaik, the syntax is done by ECMA (https://github.com/tc39/ecma262), but the loader, i. e. the way the modules are actually handled, is done by WHATWG (https://github.com/whatwg/loader). The former is stable, but the latter is not.
There's also an optional deoendacy to use most of it called blahblahblah.io
Actual Link: https://google.github.io/styleguide/jsguide.html
Nitpicking, but technically it is more than syntactic sugar - once a function is a constructor, you cannot `.apply` it or `.call` it (or any other way to invoke without `new`) any more, which you can do with plain "slap a prototype on this Function" inheritance.
Simplest answer is that twenty years ago it was a messy proprietary box of ballache. Who remembers document.all vs layer... I guess for some people the stank never left their nostrils.
Key Lessons: Use modern JS features. 
So you want us to mix our http calls and commiting the data to the store? Now instead of having store commits in one location the can happen in two? Also now the http is coupled to the commit code? Im sorry but I don't see the benefits
Tabs or gtfo 😏 spaces are for newbs and pubg players
Also, Google encourages tabs. Just in other places. I means, snickering aside, I don't have a horse in this race, but gah, "aside from newline space is the only whitespace that appears anywhere" is probably the worst rationale I've seen in my entire life, and I've seen mainstream political debates. Look, pay attention: *adds a tab* see, now spaces are no longer the only whitespace *replaces all spaces with newlines* MWAHAHAHAHAHAHAHA THE POWER.
Why is single quote (') preferred over double quote (") ? For me it makes sense to use double to remain same when dealing with c++ for instance. 
&gt; Use const by default I will get downvoted for this, but (like everything) JavaScript developers take a good idea, and destroy it. Function level variables should *not be a const*. Const variables should be those that never change during the *run-time* of the application.
No, not at all. Babel has an implementation, but it's different form (I'd argue superior to) the implementation being pushed by the W3C/browsers.
"Being same as C++" should be quite low in priority for a JavaScript style guide. One reason why single quotes is no shift. It's faster to type, and who cares what it is, anyway, as long as it's consistent.
Boooooooooo
What do you mean by a "Java script data base"
This is a *JS* style guide, not a C++ style guide :) In Javascript the single quote is by far the most common one used by the community.
https://stackoverflow.com/questions/9959928/double-quotes-vs-single-quotes-in-javascript?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa
Well I'd upvote you because you're correct. The JS community has the most bizarre interpretation of "constant" than any language. Everything is constant, including very mutable (and mutated in the specific code) objects and arrays. It's a misguided attempt to make code more "functional", which is a fad I can't wait to blow over and go away. Functional languages contain useful idioms and features, imitating them blindly in an imperative OOP language is just pure non-sense.
Why not? I can accidentally assign to a variable inside a function can't I? Const vars prevent that from happening, and cost you *nothing*.
I was a longtime tab user, but spaces are BY FAR more widely used in JS. If your editor is even halfway-decent you should be able to switch from tabs to spaces without even noticing a difference.
[codefights](https://codefights.com) has Javascript and arcade mode starts all the way at the beginner level with "return arg a + arg b."
Google wrote Maps in Java, and used a converter to turn it into Javascript. I'm not listening to them.
&gt; I can accidentally assign to a variable inside a function can't I? Yes, this was such a common mistake to make before `const`. /s
It's a phase. At one point in Java a sub-group of FP aficionados were obsessed declaring every local variable final, regardless of practical utility. Now people are taking a few steps back and applying more common sense. Java 8+ even permits capture of variables that are effectively final, without them being explicitly declared final. 
On most international keyboards you have to press spacebar after typing a quote for it to be inserted, so both are really a PITA in the end
Yeah the faster could be a reason but very short amount :) but yes, agree. I use what ever the project in writing suggests. I find it a bit interesting that both are available to begin with though :)
About your question and exact answer 
*Cough*... LISP. :)
&gt; flexible typing Dynamic is fine. Weak isn't. If you write complete nonsense, you should get an error instead of some random garbage result. E.g. if a NaN shows up in the UI, you have to figure out where it originated, because doing math with NaN yields another NaN. Getting a type error for 4 + null or 5 / "banana" makes things much easier. Nowadays, Brendan Eich wouldn't repeat that mistake.
Published on March 27th, and [obligatory XKCD](https://xkcd.com/927/)
So, basically just use air bnb eslint config which is much more fleshed out.
"Whoever does not understand LISP, is doomed to reinvent it." :) It's a useful format, and flexible. It's basically LISP, and also matches the typical format of a syntax tree, i.e. the intermediate transformation of a language to a machine-readable form, before it's ground down to machine code, or whatever the final target is required to be.
[No](https://youtu.be/gsfbh17Ax9I).
They must be punished for their insolence, punished severely. 
Yes! Spoken like someone who took the time to learn the language. Var is not the devil, learn it and use it. Let’s should only be used when you need a variable that is block scope vs function scoped. The only case I find for that is in a for loop. If we always use let or always use const or always use var we miss out on the additional meta data those keywords give us. Const for constants Var function scoped Let block scoped Downvote away, but I don’t give a fuck. Learn the language and don’t just follow the fads.
Freecodecamp.org
I think it's bad because it's an abuse of what a const is. A const is something that should never change in the life-cycle of an application, not the life-cycle of a function. I can count on one hand the number of times I accidentally re-assigned a variable to something I didn't mean for it to go to. (And none of those times did it ever make it out of my local development testing). If you are getting so sloppy that you have to use const to prevent yourself from doing that then you should remove some distractions from your coding life-style. Additionally, using const to refer to arrays and objects is just maddening when you change the contents/structure of those things 7 lines later. Yes the reference to the array/object hasn't changed, but you changed every single thing inside of it. It's *not* a const anymore. That's abuse.
Premature optimization is the root of all evil. Prettier + eslint makes this rule irrelevant.
Yeah anybody arguing that it's faster is full of it.
Single ' marks are in fairly awkward positions on lots of keyboards, whereas double includes the extra finger to push shift, but are in a more convenient location. Not sure if that's the case of US keyboards though. 
oh god, here we go.
Is there an easy-to-follow resource (or maybe one that I can sign up for updates too) so I can keep up to date on the features? I'm finding it hard to remember the difference between what's finalized and what's just implemented in Babel.
They're literally the same button on US layout keyboards.
Probably, but I don't know it :) I just read /r/javascript.
TC39 Recently recommended this as well. Their reason being they couldn't guarantee they wouldn't break ASI with future language features if memory serves
Not needing to escape double quotes might be a benefit 
Not common, no; in fact the way I code functions are rarely even big enough for something like that to happen. But at the same time, all it takes is one long function and `var` to potentially introduce a time-consuming bug, so why not use `const`? Other than the two extra characters there is absolutely no downside whatsoever to using it.
I think you're maybe misunderstanding the purpose of a const. Something that doesn't change within the lifecycle of a function is perfectly valid. Global constants are valid for config too but why limit a useful tool just because it doesn't fit with your view of what a const should be? I don't need to count the times I've accidently reassigned a const. It's never happened. Also knowing that a variable always points to the same object is valuable, even if the contents of that object has totally changed. If I'm reading someone else's code and it doesn't use const I just sigh because it means I now need to look through the function and see if it's changed anywhere (and it it hasn't I change it to a const so the next person reading the code doesn't need to do that). Going back to the immutable example, if you had an immutable object scoped only to a function would you declare it as a let?
ok, that is pretty nice. 
The Firefox version of Tampermonkey also runs at Firefox for Android: https://addons.mozilla.org/en-US/firefox/addon/tampermonkey/
Surely using a transpiler like Babel eliminates the need to worry about this? 
Much of it is actually similar to my personal style. But a few of those things (2 spaces over TAB, ever using ` over ' for strings) are not things I'm gonna do.
&gt; But at the same time, all it takes is one long function (your's or your co-worker's) and one var to potentially introduce a time-consuming bug, so why not use const? Because you yourself admit that using const excessively solves a *theoretical problem* that you rarely if ever have in the first place. I'd say if you have a long function to the point you lose track of which variable is which, locking them down with `const` won't help you at all - you should refactor that function. On the other hand `const` is very valuable when reading code to denote true constants. That is, value literals which don't depend on runtime state, and which you don't intent to change in any way. Those include numbers, strings, look-up maps/arrays, things which would be "constants" in any other language. Some people declare a variable as a `const` because they *don't reassign it*, but then they *mutate it*. Like this: const list = [1, 2, 3]; .... list.push(4); JavaScript won't complain about this. It's not reassignment. But declaring such objects as constants is just confusing as hell.
Const is not immutability, true. And shorter functions are better, also true. But if you have two equally valid options, and one has benefits the other doesn't, why use the inferior option? Using `const` in no way stops you from defining more traditional `SOME_VALUE = 5` constants.
' is pretty common in some languages though - probably more common than ".
&gt; eliminates the need to worry about this It's a style guide.
How is this good for anything? 
On all "German" qwertz keyboards they are in a terrible position :(
So a JS developer has two options right? 1) Only use `const` for `FOO_BAR = 5` type constants, gaining the "meta information" that said variables are "real constants" whenever you see `const` 2) Use `const` by default for all variables that aren't re-assigned, and use the `FOO_BAR` variable naming convention for "real constants", giving you the exact same "meta information" about the exact same variables, but also protecting your other variables from accidental re-assignment.
This is pretty cool, can you release it on github?
So, if Google says it it’s a “lesson”, the rest of us just have opinions. Got it. I agree with most of Google’s opinions, but that doesn’t make them The Official Way of Doing Things™ 
Isn't like the Ford vs Chevy debate? Or Cike vs Pepsi?
But it's getting phassed day by day. It is in EOL in two years iirc. And almost all good stuff is ported to py3. Lets be honest py2 is dead and is only used in projects to be maintained.
I think it all comes down to who your code is for. Is it only for you? Then you only have to care about your code's readability in a "will I still understand this six months from now" sense. Neither using tabs or using `'` instead of template strings will impact that, so if your code is only for you (and future you) then keep doing what's comfortable. But if you work with a team, whether that means co-workers or OSS library maintainers, there is value to doing things the way everyone else is used to seeing them. For instance, if you submit a PR full of tabs, you should expect it to be rejected (quite possibly by an automated ESLint-type tool) because the vast majority of JS libraries use spaces.
So then what are they using instead? Not using modules is not an option.
Bad: string concatination Proceeds to use it in long string example
except modules. 
probably just until node has full support. Or maybe an internal build tool of theirs.
&gt; I think it's bad because it's an abuse of what a const is. A const is something that should never change in the life-cycle of an application, not the life-cycle of a function. Well, it doesn't. That other invocation? It's actually another const. Because it's in a new scope. Const isn't just a "safety feature," it's an IDE hint _and_ documentation. Just like type systems, for example.
I thought it was a mildly interesting milestone, perhaps mostly interesting that javascript hadn't overtaken python years ago. Otherwise I think people are inferring a lot of gloating in this post that just isn't there.
&gt; It's faster to type Not really, though I hear this argument all the time. Your pinky rests on the shift key. A isn't slower to type than a (or shouldn't be). The reason to prefer double quotes is to keep consistency with JSON, HTML, and other languages. Personally I prefer backtick to both because it's simply cleaner in a lot of cases. Historically the argument for single quotes was so that you didn't have to escape double quotes in your html strings when writing jQuery apps, but that doesn't really apply in modern JS dev.
You make a point of the advantage of inter-team consistent coding style. So I'll clarify. Of course, if the whole team codes in a specific style, I'll adhere to it. If they never use ?: but only IF statements, I'll do it. If they want to use single long strings and never separate them into smaller ones with '+', so be it. But if I am the one setting the style, or am coding for myself, I'll definitly not do any of that crap. Which was my point to begin with. There is nothing in my comment about using style guides in general, just a few "advises" in this specific one.
Look, const sounds new, and therefore hype, and a thing being hyped then it's wrong. Frankly, anything liked by more than two people is bad and wrong, and if one of them posted something about it to Reddit in 2009 then they're bad, wrong and can't shut up about it.
&gt; Your pinky rests on the shift key. No, that's not where my pinky rests. https://en.wikipedia.org/wiki/Touch_typing#/media/File:QWERTY-home-keys-position.svg
var is lexical scope, not global scope.
I don't get the 2 spaces thing. It makes code harder to read. 4 is best. Don't even @ me.
Not that existing code would break, but that the existing rules might have to be more complicated around newly added syntactic features.
What do you guys think about the spaces over tabs? For me, I tend to make more mental mistakes and spacing errors with 2 spaces. Tabs make everything clearer to me.
Depends on your linting style. Standardjs doesn't use semicolons, and it doesn't create any bugs as long as you don't have any warnings. 
Well, it's one way of doing things and if no other company or organization propose something similar it will become the standard.
using single for code and double for html is the norm, which allows putting html in js strings and js in html attributes without making stuff weird.
I use the home keys when typing a document, but when coding, there's a lot more {}()&lt;&gt;_-\ use, so my fingers are in a different place.
I'll never understand not using tabs for indentation... And even less so using 2 spaces instead of 4
I could have stated it more clearly (I sort of conflated W3C and browsers, when what I was just talking about the version both support), but what I said wasn't incorrect. The version of ES Modules decided upon by the W3C does define that the modules work in in such a way that the only possible way (according to the Node engineers at least) for Node to implement that spec is to use the .mjs nonsense.
ASI is not future proof for new proposals and features. That's why it should be avoided. 
10/10
But if you adhere to style guides, in both personal and professional coding, you're far, far more likely not to have conflicts with your team. Style guides don't (usually) come out of one person's opinion. The good ones at least are a reflection of what's most popular in the community. So you *can* do things however you want at home, and then do them however your work tells you to ... or you can adopt community standards, be far more likely to have your personal style match your company's, and then if you ever go to a new company again you'll be far more likely to just be able to code "your way" on the company dime. (And if your company doesn't use standard X, it's a lot easier to convince them to when it's a community recognized pattern and not just "how you like to code".)
I agree, except tabs are king bc the everyone can set their own indentation level.
So you know why I shared this article. I'm confused
Google's standards are two things combined: style and technical wisdom. Google is the closest to "THE Internet Company" in the entire world. Their engineers manage the biggest consumer of web pages (Google search). Their browser (also a major consumer of JS) has the greatest market adoption. And they pay for big salaries and insane perks just to get the best possible engineers possible. To ignore the technical wisdom presented would be foolish IMHO. But when it comes to the purely style components Google (like Facebook or any other company) should be taken with a grain of salt, because what makes sense for one company doesn't *necessarily* make sense for another. But even then, their advice is still worth considering because it's not *just* Google's opinion; it's also a reflection of the opinions of thought leaders in the JS community (or at least the ones Google reflects), and again your ignore their wisdom at your own peril.
Not everyone uses QWERTY keyboards (even though it would probably make a lot of things easier). On AZERTY they're very similar to type (both need shift), and on QWERTZ `'` is even a bit more awkward to reach (in addition to needing shift) while `"` is in a pretty natural position. Although, why should we use `"` and `'` for strings anyway anymore? Just use template strings unconditionally.
What bugs would that be, apart from the one obvious one when your next line starts with a `[`?
&gt; Every statement must be terminated with a semicolon I wish every JavaScript developer understood why this is important.
return statements are the biggest offender.
I've never encountered a bug due to semicolon inference.
Using a proper editor it shouldn't matter. 
Yeah, been using Standard JS since my last job and I love it. Not had a single bug from omitting semicolons and now I have a far better understanding of ASI in JavaScript
But return statements behave the same either way, if your codebase uses semicolons or not. 
Source? Seems odd that they’d be scared of breaking MooTools but would change the semicolon rule
https://github.com/tc39/ecma262/pull/1062 It's best just to use semi colons. 
Thanks
whoops, looks like I misunderstood that feature.
Not sure what constitutes 'fine' here. At the end of the day const and let are the same.. it's about letting the reader of your code know your intent, with a bit of compiler help. I would recommend only using `const` for things that are not meant to change.
There is no debate, just use Python on the backend and Javascript on the frontend, it's fine :-)
How much experience with javascript have you got? If you're a complete noob, that link to a react library from /u/arronkim234 might be a bit much to digest, but if you've got some experience, it might be worth investing in a bit more time to learn how to use React. If you have no experience at all, take a Code School course or something similar and get the basics of the language. Everyone has to start somewhere, and that's the place to start these days.
Why do you get worked up about something so pointless?
That's a feature, not a disadvantage. Some people have an easier time with an indentation of 4 or 8 spaces, some prefer to work with a 2-space indentation. With tabs, everyone can configure it for themselves without having to change a line of code.
Can you configure your editor to display 2 spaces as being 8 columns wide?
And they only occupy a single character worth of storage and memory. This doesn't mean much on small projects, but if the project is large it could shave the loading time down.
&gt; did code writers have to fit everything into a single JavaScript file no, authors would typically write separate files that would either be concatenated by a task runner, or simply added one by one using multiple script tags &gt; OOP JavaScript was modeled after [scheme](https://en.wikipedia.org/wiki/Scheme_(programming_language)), a functional programming language. Classes might make sense in Java, but in JavaScript, the trend has largely been to leverage functions and closures to write programs. As a long time JS developer, I don't think it makes any sense to do traditional OOP in JavaScript. Functional style is much cleaner / easier to reason about.
And that's why I use prettier. I'm the worst at this, prettier just fixes it. 
By "made an input" do you mean in HTML? 
I use tabs in an editor that does automatic conversion of tabs into spaces. 
That's the point I don't care if you want them to look like 2 spaces while I (a sane person) use 4 spaces. The indentation level is still the same.
No, that's why you shouldn't use double quotes. Using single quotes shows a clear separation from HTML.
Well it can be configured to convert a tab to 4 spaces.
It's a style guide not a spec for a JS interpreter. It's something you should do, **always**, but it may not necessarily break if you don't.
[a similie is a comparison of two things often using "like" or "as"](https://en.wikipedia.org/wiki/Simile)
?
Who is the douchebag who came up with 2 space indents over 4? Its horrible.....
I think it's just the idea that if your aren't going to change it use const, otherwise use let. 
Ahhhhh damn. I like keeping my double quotes from C++ (new JS guy here). Looks like I'll join the single quote crowd if that's preferred in the community.... damn!
Closure modules, require AMD, etc. There were ways to split your code before ESM, I’m just surprised google is stuck in the past like that. 
This shouldn't matter if you're minifying/uglifying.
Keep in mind ESM and Node modules are not entirely compatible. Node is still unsure AFAIK how they are going to interop (which is why it’s not yet available in 9.10, despite v8 supporting them).
just use prettier and forget about everything else. hit save and keep coding
That's what I mean, if you use tabs you can set the display width, if you you use spaces you (usually) can't, so it *does* matter.
If you're the one writing the code sure, but if you get to work in a codebase that uses 2-space indentation, you'll have to live with everything being indented only 2 columns. With tabs, you could configure it to your liking.
Do you not actually have a reason for feeling so strongly about tabs v spaces or are you being intentionally obtuse?
Somebody who wants to squeeze every ounce of performance? 
As someone formally learning JS for the first time, what's wrong with var? 
If they can break the way we work around ASI, they can give us a way to switch off the ASI. I wish someone could explain why they don't give us a `'use noasi'` pragma along the same lines as `'use strict'`. It shouldn't be that hard to detect pragmas before applying the ASI.
For people promoting immutable code it’s a no brainer to use const. For people writing dynamic code and reusing variables it removes the possibility. Why not reuse / reassign a variable?
My comment has nothing to do with globals. Learn the language please.
Nobody actually thought you were pulling your hair out. What makes using tabs so important to you?
I'm not sure, but I'd guess that it is more expressive to use let or const. If you are reading the code, you will know whether or not the variable is mutable
It’s understood just fine. We just don’t like it. Your reasons for liking tabs are not convincing to us. 
You should have them take it down. When I publish content, I require it to be unmodified or to remove the attribution.
&gt; Just use template strings unconditionally. Why force your browser to interpolate strings all the time? It's a waste of processor time. I don't care whether a project uses ' or " or a mixture of both in one file. It doesn't matter to the code, it's only a developer preference. My current project for work uses ' while another project I work on uses ". Remembering to switch sometimes causes issues, but prettier fixes that. What I find funny is the JSON standard uses " and the SASS guide prefers ' due to laziness. If JavaScript were to prefer one then a " makes more sense since JavaScript and JSON are closely related.
It's not. We have linters and formatters. In settings without a linter, the project is probably small enough for this to not matter. If there's no linter in a bigger project, then you're shooting yourself in the foot in plenty of other ways anyway, where extra semis aren't going to help all that much. But that's just me. ¯\\\_(ツ)\_/¯
Blogspam summary without enough justification. https://google.github.io/styleguide/jsguide.html
I prefer spaces because it tends to copy nicer if I need to copy + paste a code snippet onto stack overflow or something.
What exactly are you trying to do? There's an [input event](https://developer.mozilla.org/en-US/docs/Web/Events/input) that would probably be helpful. Generally, you would want to have the input and a ```&lt;div&gt;``` element to display the output. For your JS, you would do something like this: ``` input.addEventListener("input", function() { //get the value of the input using "input.value" //display the result using something like "divElement.textContent = ..." }) ```
Var is function scoped, let is block scoped. So even if you declare a `var` in a block within the larger function, it's still accessible to the entire function. This is unintuitive and can cause strange bugs.
I get your point, but it's important to remember that Google's excellence is in infrastructure, implementation and external quality. For internal quality, software design and architecture, I would rather look at other companies and movements.
You still can, you just have to change the `const` to `let`. The idea is that you can accidentally assign to a variable that shouldn't be assigned to, but you will never accidentally change a `const` to `let`, so by starting with `const` (except for variables you know you want to re-assign) you ensure everything is only re-assignable on purpose. And the only cost of doing things that way is that every once in awhile you have to change some `const` variables to `let` (only the ones you started out thinking wouldn't be re-assigned, but then you changed your mind).
True, but don't forget about the Chrome team. The people that implement *any* web browser are going to be some of the most knowledgeable people on the planet about "best practices" that have a meaningful impact on the browser ... and the Chrome team isn't just any browser team, they're the most popular browser's team AND they are a part of the larger (very Internet-knowledgeable) Google company.
&gt; Single quotes is also the JS standard. Source? JS has no standard. That's why these ridiculous arguments keep happening. 
They don't need to. The rule is `JS will NOT insert a semicolon if two consecutive lines are valid without it`. As they add new syntax, previously invalid constructs can and will become valid. They will, obviously, try to avoid that, but they can't avoid it forever. New constructs need to be added for the language to develop.
If you want that level of memory management and performance JavaScript is not the right language for the job
Using template literals says to someone reading your code that there is a variable about to be interpolated and it tells the JIT compiler to prepare to do something other than just create a string. It's not huge, but there are reasons not to use them blindly that are more than personal preference.
ASI is not a fundamental feature at all. It's literally a fallback mechanism, designed to allow browsers to not fail immediately on badly written code. It's a quirk akin to old JS engines not throwing ReferenceErrors on undeclared variables - only it's much higher to get rid of, because some developers decided to abuse it, because their favourite language doesn't use semicolons at all.
I honestly forgot this was a JS thread.
&gt; Do not use ES6 modules yet (i.e. the export and import keywords), as their semantics are not yet finalized. Note that this policy will be revisited once the semantics are fully-standard. [...Eh?](https://www.ecma-international.org/ecma-262/8.0/#sec-modules)
Yeah, I get editing mistakes but changing content is pretty bad
Quite a few threads on this sub are about JS unfortunately
I'm surprised that no one complains about the requirement to use semicolons.
[3.3 goog.module statement](https://google.github.io/styleguide/jsguide.html#file-goog-module) [3.4 `goog.require` statements](https://google.github.io/styleguide/jsguide.html#file-goog-require)
 let a = 5 let b = 10 [a, b] = [b, a] Error: 10 is not a function
I get that people have strong opinions, but I don't get it either. I really, really don't give a shit. My priority is consistency. Which means whatever my IDE does when I tell it to auto-format, that's fine. I have more productive things to focus on.
So Google is now declaring that using tabs to indent code represents "incorrect" JavaScript. Lol. This is not going to go over well, Google. Let the fighting begin!
Yep. The downvoting’s intense today. Feelings are obviously hurt on the Python side. There there, I guess.
Could have fooled me, y'all can't even figure out the obvious benfits of tabs 
Check out [exercism.io](http://exercism.io)
For me it goes back to when you had to actually put code in html on-click events. Standard in html is to use " for attributes. So you always used ' for js. Others might come up with excuses... but that's the truth 
Not that this issue hasn't been hashed to death on the interwebs, but: I use vim in the console often for editing code files. Line width is limited; default is 80. Using four spaces force many lines to wrap, which makes code *very* difficult to read.
Why do you publish there then?
 that's why all my variables are single letters. My code is much faster that way /s
9999999999999999 === 10000000000000000
LOL. APRIL FOOLS!
Okay. `var a = 5 var b = 10 ;[a, b] = [b, a] console.log(a, b)` I have literally never had this situation come up while coding JS, and I’ve been doing it full time for a few years now. Regardless, Prettier handles automatically removing or adding semicolons to my code. So it’s literally just a linter setting at this point.
Heroku &amp; Mlab are probably your best best bets for free hosting . The thing about using a raspberry pi as a server that doesn't get mentioned enough is that it's very likely that hosting is against the TOS of your ISP .
Ah okay, thanks :). 
This was only the second article that I published through them. When it happened the first time I just figured that they found a bunch of issues in that article in particular and maybe heavy editing wasn't the norm. But this time I feel like it's a pattern.
c9
I think NPM is the real game changer, I've turned more than a few Javascript skeptics by sitting them down and having large projects *just build*. Haskell is probably my favorite language of all time, but I mostly don't even bother doing hobbyist stuff with it anymore because my tolerance for cabal has gone way down.
&gt; It's not. We have linters and formatters. how do you have your linter/formatter set up to work with ASI?
The IDE should handle indentation. 
No longer broken? Does this make Safari act like a decent browser? :O
I agree. I don't care about too much about style. I just prefer not to be too weird, easy to change/diff the code, like dangling commas, and automated through the editors on save or with a hotkey.
Thanks! Forgot about cloud9!
There are linter rules for warning when lines start with `(`, `[`, or `\`, and formatters will format the code in a way that makes the mistake apparent: // this hello() [world].forEach(log) // gets formatted as this hello()[world].forEach(log) So then you think "oops lol" and fix it. This rarely happens in practice anyway. I can't even remember the last time it did.
A template literal with no replacements is parsed identically to a string using `'` or `"`, so there should be no performance hit. Since it's a much less used character than the other two, that also means less escaping.
Well, when I said "there are linter rules", I didn't mean just the one I described. There are rules for every ASI pitfall. As for _why_ I don't insert semicolons, simply because I don't like them. I came to JS from languages that didn't use them. I've rarely, if ever, encountered the issues that come with not using them. All things considered, they _are_ a style preference.
Sure and everyone is entitled to their style preference. however when in doubt it's always safer to be explicit. Google has a massive codebase with many different engineers rotating in and out of working on it. for them requiring semicolons probably saves a decent amount of dev time. It leads to more consistent code. It's the same reason why static typing tends to be preferred. 
Why is people mad at tab vs spaces when you can set your editor to treat the tab key as many spaces as you want... it's like everybody is typing four spaces everytime, what the fuck
Sure, I totally agree. Google is a big company, and they probably have other reasons for holding the viewpoint that they do. However, &gt; however when in doubt it's always safer to be explicit. Programming is all about tradeoffs, and the meager level of "safety" I gain from using semicolons doesn't outweigh how much I gag at the sight of them, heheh. &gt; It leads to more consistent code. You can totally have consistent non-semi code! I'd argue that it's even _more_ consistent in some cases: items .add(first) .add(second) .add(third) // look, no semi! i can rearrange the lines as i please :D But, all that aside, it's up to you. Not you specifically, just to anyone reading this. I have my own reasons for my preferences, as do you. Do what you prefer, whatever makes most sense for you. c:
Let's be real, if you use tabs over spaces for performance gains on server-side code then you're doing something wrong.
I just want to second this. I’ve been writing client-side and server-side JS professionally for going on 11 years. I’ve written a complete JavaScript parser in JavaScript, and contributed to language specs (not JavaScript). I care about avoiding ambiguity and having well-specified syntax. I just went semicolon-less a month ago, now that I have my own codebase again, and I don’t see myself going back. It’s visually cleaner, and after examining the edge cases of ASI in detail, I’m confident the linter has it covered. Semicolon style doesn’t even help with “return \n foo;” where foo is some multiline monstrosity— only a linter does — and all the other cases that are disambiguated by semicolons are far less subtle. I never would have said this before, but I now see the “you must use semicolons!” argument as dogma more than anything.
Your team picks a style guide to follow, everyone follows it, your devs don't spend an ungodly amount of time arguing over pointless things like space vs tabs (see: [Bikeshedding](http://bikeshed.com/)). If you're working on your own stuff then you can do whatever makes you happy.
Tabs don’t render well in VIM tools that have terminal driven error messages that point at code. I personally prefer tabs because they’re semantically correct. 
/r/LearnJavascript
Why is it dumb?
&gt; A const is something that should never change in the life-cycle of an application, not the life-cycle of a function. That's.... not true. Where did you even learn this definition of const? A const is something that will never change in the scope that it is defined in. That's it. If it is a global variable, the scope is the whole application. If it is a function variable, the scope is the local function. It makes perfect sense and it prevents errors, and it communicates your intent clearly. What is your issue with it? &gt;I can count on one hand the number of times I accidentally re-assigned a variable to something I didn't mean for it to go to. Part of good code is communicating intent. For future you and future maintainers. Const is a valuable tool to communicate intent. It isn't just for preventing errors as you are typing the particular method at that moment. &gt;Additionally, using const to refer to arrays and objects is just maddening when you change the contents/structure of those things 7 lines later. &gt;That's abuse. You have a warped view of identity in code. You can very well mutate the object stored in a const variable. You can't reassign to it. That is the point. If we follow your logic, then even application-wide consts have very little value. How many global and non-object (since objects are a no-no) variables do you need in an application to begin with? Sorry but you are completely missing the point of const.
Google would suggest you use let instead of var.
Tabs to spaces is easy, the problem is for a block of code how does the editor know when 2 spaces was supposed to represent indentation vs alignment: function() { SSwhile(value) { SSSSif(reallyReallyReallyReallyLongConditionA &amp;&amp; SSSSSSSreallyReallyReallyReallyLongConditionB &amp;&amp; SSSSSSSreallyReallyReallyReallyLongConditionC) { SSSSSSSSreturn; SSSS} SS} } function() { Twhile(value) { TTif(reallyReallyReallyReallyLongConditionA &amp;&amp; TTSSSreallyReallyReallyReallyLongConditionB &amp;&amp; TTSSSreallyReallyReallyReallyLongConditionC) { TTTSSSSreturn; TT} T} } 
I'm not doing it for performance gains, but every little helps.
Can't complain with that. Since it doesn't mention why using arrow functions is preferred, here's something for those who are unsure about them: * They use surrounding context of a callback function and automatically binds "this". * If you don't need access to surrounding context, it's at least shorter/cleaner looking. * Skips generating the old default "arguments" object. * Nameless. For those who are complaining about semicolons and indentation amount, just get used to adapting to different styles of code. It's an extremely petty thing to defend. Worry about your human rights or something.
The only thing I don't like about this response is if the IDE converts tabs to spaces it looses the ability to change the indentation without breaking multiline alignment.
That's what I was thinking. They call it "home row" for a reason.
I still prefer tabs.
This is pretty cool. If I can offer some feedback, I'd do two things: 1) Include the ability to go backwards/forwards through the steps as a feature 2) Break the genre and preview lists into columns to avoid so much scrolling. Keep up the good work! 
This is probably the only good argument for spaces I've ever read. That being said, tabs give me the freedom to take advantage of that inconsistency by displaying it most appropriate for the format
that's the same thing.
It's because " is used as html attributes. When you're using js for what it was designed for, before we had fleshed out browser API, you'd be making a lot of HTML with string contacts. Go ahead and play the string escape game with large swaths of nested HTML xD
The original action, the effect itself, and the secondary action against the change... you're now looking in potentially three places for one chain instead of one.
two applications.
Ugh! That must be so annoying. Clearly a click-bait move. The original title makes more sense. 
Mixing them is inconsistent and bad, so a style guide must choose one or the other. No one should actually care which it is.
Ehhh, Google you can fuck off on this
You know this? John Mueller has already spoken ex cathedra on js styling and SEO? If it hasn't been expressly denied, anything and everything is a ranking factor. It's a legit concern 
I love everything about this style guide except the part about vertical alignment. Vertical alignment is good.
As Airbnb, Google recommends trailing commas: const values = [ 'first value', 'second value', ]; I always disable that rule.
How could it possibly be used as a ranking factor? The vast majority of JS code on the web is minified and optimized, Google wouldn't expect anything else. They promote minification as a tool to increase page load times and created one of the leading minification/optimization tools.
&gt; if you use tabs over spaces for performance gains ...and aren't minifying...
I read that and thought this was an April fools post. 
Ive worked (hacked) with leaflet for 3+ years and then i switched to mapboxgl and my life became so much easier. There is a bit of a learning curve to any mapping system, but if you have the ability, mapboxgl is definitely the way to go.
While I don't like trailing commas either it keeps the commit cleaner and easier to read since you don't have to modify another line to add a new line.
You can build your app and host it using s3. Very simple solution. 
I understand you point. Maybe it's the force of habit, but it seems like a line is missing to me.
I disagree. Take from open source whatever fits your particular use case. If it doesn't write it yourself. It's entirely senseless to rewrite something for any of the advantages you mentioned.
I sadly dont know any Javascript. Is there an R package to interface with it?
I said I wasn't doing it for performance gains. It's my preferred coding style, but there's no arguing about a smaller memory footprint being better when you're working with a large codebase.
V8 compiles JS to machine code. It doesn't store source in memory.
As a noob writing noob code.....why not 'var'?
tldr: in production none. If you're learning how react works under the hood and want to set it up from scratch or want to hack on something more transparent, that's what I'm going for. I wouldn't use it for large scale production. This serves more as an extremely simple reference for what one needs to make react work on a basic level. create-react-app is definitely more prepared for a production facing situation, but this is more for people who want to mess with react and don't need or want many of the bells and whistles cra provides. 
If I understand it correctly, ProseMirror isn't even really text editor as a product, more like a platform for building one, while being provided with an example editor. Recently I've been choosing text editor component for my (non-React) project. I picked CKEditor 5 and I'm happy with my choice - I think it's implementing similar ideas as ProseMirror while actually delivering a real product (not just platform).
And then you need to backspace to remove an indent and you press 4 times instead of 1
[Microptimization. Just. Doesn't. Matter](https://blog.codinghorror.com/the-sad-tragedy-of-micro-optimization-theater/).
Two space indetation and not four. Mmmm, no.
To be fair, they're not exactly the same, since commonjs imports are dynamic and es imports (aside from import()) are static. That opens up a lot of opportunities for tooling (like tree shaking, iirc) that aren't really an option when dynamic importing is the default.
There is a free course recently published for Vue.js "Intro to Vue" course at www.vuemastery.com This platform helps produce the official Vue Newsletter with the latest in vue.js and libraries to help you with your career as a developer. Also get a free vue.js syntax cheat sheet in a 2-page pdf and rapidly code up your next project. 
The W3C isn’t part of this. The new extension is really fallout from various complex scenarios in which CJS modules and ES modules include each other in Node. Browsers have a similar problem but they solved that with `type=“module”` in the script tag.
Google's JS styleguide has been around for ages. Why is it only getting attention now?
Agreed. Some suggestions are ok. Others are crap. Like what's wrong with using var? I know it's not block scoped. I know of lots of situations where I can take advantage of that (not being block scoped). Why not use it, huh Google, why? And what's with the single quotes bullshit? As far as I know there's no difference between the two. As for tabs vs spaces - who gives a shit. I'm not crazy to format my code by hand, I have a prettifier plugin in Sublime Text.
What exactly made you change your mind on semicolons?
It's literally called Standard JS. https://standardjs.com/ &gt; Single quotes for strings – except to avoid escaping
Quincy with the freeCodeCamp Medium publication here. The reason we changed it from "13 noteworthy points" is because many people will dismiss any article with a number at the beginning of it as a "listacle" and don't read it. Lists are seen as low-effort posts - the kind of article you see on Buzzfeed. We do our best to improve the readability and flow of articles submitted. If you disagree with any of our edits (you can see them in the version history) feel free to revert them. I've updated your article to use your original headline. It's a good headline (though again, some people might pass on it thinking it's just another listacle). Thanks again for writing this excellent analysis of what was a relatively unknown style guide, and submitting it to the community's Medium publication.
I have been using Draft in production for about two years now. Several of those PRs are mine because I maintain a fork with a number of fixes. You’re right that Draft has been very slow to take changes and I believe that that is largely because it’s not a full time project for many of the maintainers and Facebook’s own usage is fairly minimal. Twitter and Facebook have come to an agreement that Twitter will be contributing more actively, though mostly on building out mobile support I believe. There has been some brief talk on the Draft Slack of maintaining a community fork of the project. Despite this, I have found Draft to be very easy to work with. I don’t regret using it at all and I’m happy to continue to use it. The primary issue I have is that it makes it difficult to implement collaborative editing because it doesn’t give good feedback about what changes have occurred. Feel free to ask me if you have other questions about Draft. I can’t compare it to ProseMirror because I’ve never used ProseMirror.
Google has been getting on my nerves lately
You forgot a semicolon at the very end. Remember, after every statement. What a silly rule.
I think you mean [line 3465](https://github.com/v8/v8/blob/5cf2ae5a4d7224198a0474eb27cc618b6843bc32/src/parsing/parser.cc#L3465) is where it does the processing. It first has to check if there are any variables within the string literal, then it counts them and uses that count in your line. Line 3495 above yours checks if there are variables, line 3488 above that calls the cooked() function. The cooked() function generates the list of strings. I could be wrong on the exact details of the function starting at 3465, but to me it looks like it's processing the string literals using a recursive algorithm.
Another reason is that var is hoisted
Well. Lately I've been running into bugs with semicolon optional code, where ``` let pizza = foo [someVariableInScope, someOtherVariableInScope] = functionReturningArray() ``` throws an obscure error.
Not sure what OP meant, but for the sake of accuracy, `var a = 1;` outside of function scope will assign to `window.a`, i.e., the global object, so `var` is either function or globally scoped, while `const` or `let` are never global.
Good to know, thanks a bunch!
A linter with the appropriate rules would warn about that 😉
I guess you run your linter every single time you compile/test/run code huh.
My editor does it for me, and gives me red squiggly underlines when I do a stupid :D
Improved tooling, really. Now that things like `prettier` will yell at me when I do something stupid, it's just an extra character I don't need to type. And when I work on projects / teams that _do_ use semicolons, `prettier` just throws them in for me. I will say that hopping back on a language with mandatory semicolons throws me off a bit, now.
Yeah the author of the medium post doesn’t understand what arrow functions do or why for...of loops are preferable so I can’t imagine how his summary of the style guide would be useful
It's safe to say that Google's or airbnb's style guides were made by language experts, so bringing up learning in this context is presumptuous. A basic reason to avoid mixing `let` and `var` is consistency; the same code shouldn't use different kinds of variable declarations, unless there's a good reason for it, which there isn't for `var`; it's just not useful to treat function scoped variables differently. The differences also go beyond just block vs. function scoping; `var` declarations are also hoisted and they assign properties to the global object outside of functions.
I am not saying to not use open source code. I think open source code can be very useful and very powerful. All I am saying is to be careful when using it because it can potentially lead to some security vulnerabilities. And I am mainly advocating that people should know how to code because it concerns me when I meet developers who copy and paste the vast majority of their code but don't know how to swap values of two variables (I have met a couple people like this).
Be careful relying on prettier. I have examples of real work mistakes which prettier doesn't catch or fix. It usually involves a function call directly followed by an expression wrapped in parentheses or followed by an array structure. These usually end up being abuses of the language as well, but I've seen this kind behavior often enough and done enough tests that I'm not confident with saying "prettier will catch it" because it doesn't always. Nevertheless, this is just a warning and depending on your tools YMMV. 
Do you know if this is for vanilla only, don't see how using React would be possible without import and export statements? (Unless I'm missing something)
I may be spoiled because I learned JavaScript after strict mode was added, but I can't imagine how any language behavior can be more annoying than lookahead-based ASI. (Compare with [Go's non-lookahead ASI](https://golang.org/ref/spec#Semicolons), which doesn't seem to cause any controversy.) No matter how we choose to deal with JavaScript's ASI, it's always more difficult than if the ASI wasn't there at all.
that's just a style guide that's cheekily named "standard." if someone is referring to that when they say "the JS standard," then they are somewhat confused about the relationship between that style guide and JS.
what do you mean by "eject"?
Create react app has a script called eject.Which kind of eject the app from its defaults and let us configure it for more custom needs. 
If you have a code snippet as an example, I’d love to see it. Knowing the corner cases for prettier behavior is always good.
Internal backwards compatibility most likely.
Code isn't always read in an editor that can analyze it, and making it explicit that reassignment is not intended also helps avoid doing it by mistake.
YES FRIEND
Ok, that makes sense. Does each function effectively have the same scope as one module? So you can either have one master file that imports multiple modules, or you can write multiple functions in one file and just ensure that no variables are declared outside the functions - is that right?
Right. Is it possible to create a web page structure that includes multiple versions of your JavaScript code, and switches between them depending on the client's browser type/version? So that, for example, you have one version that uses let/const (for newer browsers), and another than only uses var (for older browsers)?
I thought Node already announced they're going to interop by requiring that crappy MJS extension or whatever
&gt; everybody still uses tabs I suggest you go over to /r/python sometime. They worship at the alter of "PEP8" in which the creator of Python just wrote "use spaces, not tabs" and everyone was like "genius has spoken!" but it turns out the guy's justification was "meh i just like it better"
Alternatively to using `.bind`, you can use an arrow function. I believe it's considered more modern style to use arrow functions, because it solves a lot of problems with `this` and this gray area you're outlining. So in your example, it would be setInterval(() =&gt; { thiswontwork("Yo! Why wont you work?"); }, 1000); curly braces around `thiswontwork` are optional for one line statements.
&gt;The reason for this is that different editors/OSes/people have their tab character defined as either two or four spaces, leading to inconsistency when a tab character is used. This is a very compelling argument for why you should use tabs and not spaces. It's not a compelling argument for spaces instead of tabs. In fact, it's a damning argument against spaces. If it just *remained a tab* and then you had your IDE make your tabstop whatever you wanted, it's a non-destructive UI change. Converting tabs to spaces is like working with a single layer in Photoshop. NO.
I use this, which allows me to stay under create-react-app: https://github.com/timarney/react-app-rewired Also, if I am creating a library, it depends: is the library huge and does it need tree shaking, then I would use babel / typescript and not use webpack, which can be done w/o ejecting. 
Some of these rules are introduced not because they the ultimate “correct way”, but just to keep Google’s own code base consistent.
If your IDE converts tabs into spaces, it can create ambiguities where it's unclear whether a certain number of spaces is for indenting a different block, or if it's for vertically alignment multiple lines of code (think a function with too many params for a single line, you have to do multiple lines in the function header) So then those six spaces, is it three tabs, or is it two tabs and then two spaces for alignment? If you kept it as tabs, it's obvious: a tab is for indentation, a space is for alignment.
Luckly I havent had this problems, but in most of my workspaces there were a config to import (regarding these kind of settings). Also I dont see the problem with spaces for identation. You set your tab key to put 4 spaces, then if you need to align you do whatever you need (if you arent replacing your tab character then you re pressing space six times)
Is this a joke? I’ve not been using semi colons for over a year on personal projects. Number of bugs caused by this decision: 0.