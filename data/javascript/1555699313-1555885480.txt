I'd say for the sake of understanding these data structures (be it for interviews, other langues, whatev) it's important to understand how these structures work and their time/space complexities. Even though JS has similar built-ins, try implementing one yourself and you'll quickly understand how they are supposed to operate, as well as the advantages/disadvantages of different structures depending on use cases. Even though you'd rarely have to build one yourself, it's paramount to understand the concepts because they can be applied to a lot of different problems.
I designed and coded my entire site. I can call myself intermediate with static web development. No reason to waste more time finding someone, figuring out payment methods, spending money, and then having to ask them to make changes.
Actually very worth it to do that. What exactly are you struggling to build?
No it isn’t. Thanks for your opinion.
Also you’re essentially asking someone to do work for you for free. Go on github and look for examples of the stuff you want to do, copy/paste to your hearts content. Good luck making that work if you can’t even make a guided tutorials project work.
It more worth your time to actually learn stuff yourself so you don’t have to copy other people’s work.
Told you I figured it out. Thanks for your opinion.
The gate keeping is strong in this community. Afraid of becoming irrelevant?
You actually didn’t say you figured it out. You said it wasn’t worth it to you to either learn or hire someone who knows what they’re doing. Glad you’re satisfied.
Only helpful answer. Thank you.
No this isn’t about gatekeeping.
Check my edit on the original post.
Sounds like you want a framework.
Yes, I did.
Yes! That’s what I was looking for. Any specific ones good for just having content of a textbox emailed to a specific address?
Then what is your end goal here? It obviously isn’t helping others.
Well, then I guess I have to throw this superfast deque implementation out of the window: https://github.com/AlexAegis/advent-of-code/blob/master/src/2018/day09/deque.class.ts
It was originally to convince you to learn how to do things yourself but you were ultra resistant to that. You want someone to hand you answers.
The problem is hosting those databases, I know that there are better solutions, but save $5 every month is a good thing to do in my case. (the performance gap is not an issue in this case)
because I'm working a startup, every money that I can save is a good thing. Also, we already have another cloud provider, I like to maintain everything in the same place
I have learned plenty myself. I just want the equivalent of code monkey from back when I was 9.
&gt;Are there any ressources (books/websites/online courses) you can recommend, to learn more about the basics of computer science. Preferably demonstrated using javascript, or in general. I took this [Udemy course](https://www.udemy.com/share/100pDeAkcfcVtQRXg=/), and I absolutely love the instructor and it was a great refresher course on data structure &amp; algorithms. He even gives you coding challenges to test yourself, I learned quite a bit from it and would take any course he teaches. Good luck!
hahahahahhahah... so funny how Redis has so many toxic people...
It doesn’t sound like you’ve learned enough to do what you’re trying to do. The solution is learn more or find someone who knows more than you. Or try and copy from other people’s githubs but it’ll still take knowledge to integrate. Even if you got a framework you would need to learn how to make everything work. No one is gonna hand you your perfect solution.
Treeees
Eloquent JavaScript is a great first book
People with emotional intelligence and control over their egos have given me many solutions. Thanks for your opinion ✌💜
I just looked at what I think is your site. Are you advertising yourself as a web developer?
&gt; Pointers or not is simply an implementation detail Not according to the textbooks, but okay What do you imagine to be the difference between a tree and a hash, then? They also have the same interface
I am a hosting platform that does small basic static sites for small business's to fund charities that help combat climate change, gun violence, and human rights violations.
&gt; They don't exist natively because they're trivial to implement yourself. They're not possible to implement in javascript . &gt; That's exactly what a linked list is. It's really weird how you're just saying "yeah huh" instead of giving valid evidence It's also very weird how you're trying to explain what I already said back to me, as if you thought maybe giving unimportant details would change my opinion.
Good luck with that. Hope you’re successfully providing hosting support to help those causes.
&gt; How are queues not possible in javascript? If you're able to explain the difference in C++ between a deque and a class with deque's interface built on top of a different datastructure, apply that explanation here If you're not, then my answer won't land with you anyway What you're discussing are containers, not datastructures
Oh, well, as long as you use that title, surely it must be correct Similarly, es5 people were really angry when we said "no, that's not a class, that's not a private method," etc. They wanted us to know that their metaphors were real. Later, when the language got the real thing, they all came around, but ... haven't learned, it seems Look, you can slap this same interface on any datastructure. That won't make it a deque. The difference between containers is how they're used The difference between datastructures is how they're implemented
Are you really attempting to give an interview prep website as if it's a definition of computer science?
Thank you! You should check out the news section of my site. I put up two informative videos today.
&gt; &gt; Javascript people use arrays as queues &gt; &gt; so you havent read any js queue implementations Many of them. . &gt; &gt; because of a lack of pointers and direct allocation. &gt; &gt; If that is your litmus test I'm sorry you disagree with my college textbooks No, it's not "my" litmus test. It's just what that word means. Datastructures generally require extremely specific allocation behavior in order to maintain their algorithmic guarantees . &gt; then you cant have datastructures outside of c/c++. Sure you can. Most languages have pointers.
Was just the first link that popped up. And certainly I'm more prepared to use that definition as opposed to yours.
Thanks a lot!
You mean a music video and a speech by Leonardo DiCaprio? Also linking to articles other people wrote from your site?
&gt;Stacks and Queues are basically already in the JS standard library so you don't really need to implement them yourself. In what sense do you mean? In the sense of \`Array.prototype.shift()\` and \`Array.prototype.pop()\` ?
That small bit of functionality is probably less than a framework. You’ll want some sort of plugin or something. It really depends on how you’re making your site.
I see that you are willing to accept an interview webpage that makes several other obvious mistakes as if it was a form of reference, when it is not, while ignoring the normal use of a term in a field, and pretending that that normal use comes from the person you're saying is wrong That's an enjoyable story and I suggest that you publish it. Many people will be very interested and you might become wealthy Have a nice day
JavaScript. I'm assuming when you say that you're not talking about the [Web Platform](https://en.wikipedia.org/wiki/Web_platform), how JS fits in, what APIs it has, etc. You're just talking about the programming language itself? When you're saying that you probably mean ECMAScript, which is the non-trademarked name, after ECMA, the standards organisation that publishes the specification for the language. You can read the latest version here: [ECMA-262 2018](https://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) Assuming you're not going to read that (you should tho, eventually, it's very interesting), you should probably start by reading [Eloquent JavaScript](https://eloquentjavascript.net), that'll introduce you to the basics. Then you should maybe read Axel Rauschmayer's book [Exploring ES6](http://exploringjs.com/es6/) (ES6 is short for ECMAScript 6, which came after 5.1, but is older than 2018 edition, because they changed to [yearly release cycles](http://2ality.com/2015/11/tc39-process.html) so ES6 is ES2015 really, it's a whole confusing thing). You should also read his [blog](http://2ality.com/2017/02/ecmascript-2018.html), it's great. That's all just the language, to actually do anything useful you'll need some APIs. If you're writing JavaScript on the browser, you'll need to know [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML), how to interact with the HTML from JavaScript (HTML is parsed into a tree structure called the Document Object Model, DOM) with the [DOM API](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model). The DOM is not strictly for HTML though, it can also contain SVG or MathML, but that's another topic. The DOM API is just one of [hundreds](https://developer.mozilla.org/en-US/docs/Web/API) of Web APIs that make up the Web Platform, there are APIs for almost anything (with varying levels of browser support, from making [http requests](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), to getting the [ambient lighting conditions](https://developer.mozilla.org/en-US/docs/Web/API/Ambient_Light_Events) the user has. If you're using JavaScript on the server-side then you have a totally different API: the [Node.js API](https://nodejs.org/en/docs/). There isn't a lot of Web Platform and Node.js API overlap, except through the [Node Package Manager](https://www.npmjs.com) (NPM) repository of libraries (if you wanted the fetch api server-side, for example). I'm sure by now someone else has written a more detailed and useful answer in every way, but hopefully this will get you started on your journey. Good luck!
You Dont Know Javascript series are amazing and very informative.
A queue refers to a specific type of list - a FIFO (first in, first out), which is easily achieved in javascript using \`Array.prototype.push()\` (add to end of array) and \`Array.prototype.shift()\` (retrieve + remove element from beginning of array). I guess the context you use those functions in is what would define it as "using a queue".
Please stooooop. You are making too much sense. Next they will say class in javascript is the same as the one in C#. But yes, we use datastructures to make our code performant. I wonder how people use stack in javascript and why not use a simple array?
&gt; I wonder how people use stack in javascript and why not use a simple array? There are no stacks in Javascript. You have to use an array instead, which means either coping with allocation thrash or preallocating, both of which are generally the things you're trying to avoid when invoking a stack in the first place
Well, what IS a linked list then?
Something I should stop talking about in Javascript communities entirely
Hi /u/Uneedajob, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Javascript the good parts by Douglas Crockford
I can only assume that you're trying to troll us and I'll go for "don't feed the troll".
I doubt that [].shift() is slow. I think the underlying array in JS is implemented in a way so that insertions at the beginning and the end happen at 0(1) time. I know I Perl that the array is later and the pointers to the beginning and the end of the array know where the current item is. It will only be necessary to expand the array if you do a lot of shifts and insertions at the end of the array. Anyway what I wanted to say is that the underlying implementation is not as naive as you think since the designers did consider certain edge cases.
Yup! Great content. Did you listen to his speech? Powerful.
I’ve heard his speech. So you don’t make a profit on this at all? You’re charging more than many hosts, even other services that do similar things to you for profit.
&gt; I'm sorry you disagree with my college textbooks You either don't understand what your college textbook is teaching you, or you need to throw it away because it teaches crap. Linked lists as a data structure have nothing to do with pointers and allocation. These are implementation details of your specific implementation of linked lists.
Really? I'm $6 more than wix and people never have to do anything at all with me. They send me their content and I deal with everything else. They don't even need customer support because I am my own customer support. May I ask why you have so much animosity towards me?
Because I think you have no right to call yourself a web developer if you aren’t willing to learn and grow. I’ve seen other posts by you where you’ve been straight up rude in your approach. Wix has a support team and a WYSIWYG editor so their clients can update their own content and site, which is a struggle I know you understand. Do you own the physical servers your hosting on or do you buy space from someone else? You can’t figure out how to send an email from a form so I have little faith that you actually understand the complexities around the stuff you’re selling.
This seems to frustrate you more than it should. Look, there are individuals that pretend to know more than they actually do in every community. Why exactly are you so bitter about javascript developers in particular?
The most common are: stacks, queues (both single-level and prioritized), linked lists (and circular objects), Maps/Sets, and multi-dimensional array constructions (remember to avoid fill causing unintended links). &amp;#x200B; These are the structures (other than the built-in ones such as arrays and objects) that NodeJS uses internally (they are optimized for speed): * [Priority Queue](https://github.com/nodejs/node/blob/master/lib/internal/priority_queue.js) * [Linked List](https://github.com/nodejs/node/blob/master/lib/internal/linkedlist.js) * [Free List](https://github.com/nodejs/node/blob/master/lib/internal/freelist.js) * [Fixed Queue](https://github.com/nodejs/node/blob/master/lib/internal/fixed_queue.js)
Like I said, my main business is awareness and charity. Need money for that. I'm glad you are so interested in me. You have spent hours now thinking about me. I have been on the phone with my 90-year-old grandma this entire time though and now I have to get off reddit and get work done. Have a great life!
Hi /u/e3n3d3, this post was removed. Since we are a programming subreddit, there are very few instances where visual media is valid content for /r/javascript, including screenshots, demos, etc. Memes and other low-effort content are already prohibited. Please use the `submit a new link` option with a valid source URL, whether it's the project homepage, a blog post, etc. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Our first release of code, components, and CAD files will be in 3 months. Feel free to join our discord for the time being :) [https://discordapp.com/invite/7CqPxd5](https://discordapp.com/invite/7CqPxd5)
normally in any scripting language , you shouldn't focus on data structures , that's the beauty of scripts..these things are already well made and managed by the language internal logic. But to answer the question , your main and only data structures are arrays
He is colt steele. Suggest a good teacher he is.
Sounds to me like your main business is providing hosting to others who do charity work. I sincerely don’t believe you don’t make a profit on your work.
Of course I make a profit! How would I live lol? I never said I am not for profit.
&gt; This seems to frustrate you more than it should. You may be overestimating my interest in your guesswork regarding my emotions . &gt; Why exactly are you so bitter about javascript developers in particular? I'm not. I just said "all these languages have the same problem." I apologize that you think observing what this group of people is doing *right* *now* is something other than simple honesty
You did in some of the other demanding posts you have. You even mentioned spreading awareness (of nothing in particular) and charity. Charities are not for-profit. You’re full of it, man.
&gt; You either don't understand what your college textbook is teaching you, or you need to throw it away because it teaches crap. There are many other possibilities too, it turns out. It is not coincidence that all of my college textbooks say the same thing on this topic, or that several of them dedicate multiple pages explicitly to solely this topic. . &gt; Linked lists as a data structure have nothing to do with pointers and allocation. These are implementation details of your specific implementation of linked lists. I will trust my college textbooks, plural, considered classics in the field, over a random stranger on reddit who does not give the impression of actually having been to college about this
That was before. I changed my mind. As people do when they live and learn. Also, I am bored of explaining this to you. I am deleting this post now.
Please do. Also stop trying to act like the world owes you something.
&gt; I can only assume We know. Please take your insults somewhere else now. Thanks.
Time is money. I'd consider how much time you spend rolling you own solution (especially when you factor in bug fixing and maintenance vs $5 per month) as well as how much time you're spending on non essential bits vs necessary features.
i dont think you understand what you are saying. Please explain it? What "datastructure" are you referring too that has a class built on top of it? A queue in javascript can be as simple as object (struct) that contains a value and a reference to the next object in the queue. No arrays necessary. /r/gatekeeping
Here's a sneak peek of /r/gatekeeping using the [top posts](https://np.reddit.com/r/gatekeeping/top/?sort=top&amp;t=all) of all time! \#1: [On a post about their dog dying](https://i.redd.it/yoxbfwh3nm921.png) | [1200 comments](https://np.reddit.com/r/gatekeeping/comments/aeky3m/on_a_post_about_their_dog_dying/) \#2: [Unsure if this belongs here](https://i.redd.it/aqmqzr1bxvd21.jpg) | [674 comments](https://np.reddit.com/r/gatekeeping/comments/alyba8/unsure_if_this_belongs_here/) \#3: [Anything &lt;$5 isn’t a tip](https://i.redd.it/s8ulclj18cq11.jpg) | [5554 comments](https://np.reddit.com/r/gatekeeping/comments/9lktoe/anything_5_isnt_a_tip/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
&gt; i dont think you understand what you are saying. Please explain it? It's really weird how people lead with an insult then ask someone to put effort into them . &gt; What "datastructure" are you referring too that has a class built on top of it? I'm not. At all, in any way. . &gt; A queue in javascript can be as simple as object (struct) that contains a value and a reference to the next object in the queue. No arrays necessary. Objects are not structs. Objects are hashes or maps. What you are trying to describe would be called a single entry singly linked list if it was in a language with direct allocation and pointers Queues are not linked lists With respect, you haven't got the background to understand these things Have you ever read a datastructures book? If so, which one(s) please?
A queue can be implemented using a linked list. https://en.wikipedia.org/wiki/Queue_(abstract_data_type) &gt; Queues are common in computer programs, where they are implemented as data structures coupled with access routines, as an abstract data structure or in object-oriented languages as classes. Common implementations are circular buffers and linked lists. Please go on though.
&gt; i dont think you understand what you are saying. Please explain it? It's really weird how people lead with an insult then ask someone to put effort into them . &gt; What "datastructure" are you referring too that has a class built on top of it? I'm not. At all, in any way. . &gt; A queue in javascript can be as simple as object (struct) that contains a value and a reference to the next object in the queue. No arrays necessary. Objects are not structs. Objects are hashes or maps. What you are trying to describe would be called a single entry singly linked list if it was in a language with direct allocation and pointers Queues are not linked lists With respect, you haven't got the background to understand these things Have you ever read a datastructures book? If so, which one(s) please? Are you able to answer the question I keep asking the other people who make this mistake, about what the difference is between a tree, a hash, and a set? Do you understand why I'm asking that? . &gt; /r/gatekeeping This is the weirdest attempt to pretend that actually knowing things about a science is somehow a personal attack that I've ever seen Gatekeeping is when you try to keep someone out by pretending their opinions don't matter. You asked me a question and I answered it, and now you're acting like that answer is inherently an attack This strongly disinclines me to interact with you further. If you'd like another response from me, include an apology.
I was imagining something more along the lines of a certain South Park song. You know, the one Chef cooked up.
since you deleted your previous reply A queue can be implemented using a linked list. https://en.wikipedia.org/wiki/Queue_(abstract_data_type) &gt;Queues are common in computer programs, where they are implemented as data structures coupled with access routines, as an abstract data structure or in object-oriented languages as classes. Common implementations are circular buffers and linked lists. Please go on though.
&gt; since you deleted your previous reply Uh, ... no? . &gt; This strongly disinclines me to interact with you further. If you'd like another response from me, include an apology.
Trees are just such a logical way to learn about recursion that not understanding them is a waste. It's basically killing two birds with one stone
I'd rather just point out how downvoted you are. Clearly youre knowledge isn't valued around here. Perhaps is for a reason.
[No it's as naive as I think](https://jsperf.com/pop-vs-shift-on-a-array/15)
Yeah
Project Page (?): https://github.com/thehappykoala/Harmony-of-the-Spheres *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
&gt; I'd rather just point out how downvoted you are. Clearly youre knowledge isn't valued around here. Perhaps it's for a reason. It's just a bunch of JS people being angry that someone said something from blogs wasn't true. I'm not really that worried about your constant attempts to cause shame. Please have a nice day. . &gt; Also, wikipedia is the free encyclopdia that anyone can edit! Feel free to update the article on queues if you think you have something valuable to add. I've never met a valuable programmer who attempts to use Wikipedia as a reference, so to me it seems like wasted work
TIL. Wow. I had no idea shift was so much slower than pop. I just assumed it would cut off the head of a linked list and be more or less done.
&gt; Do not try to over-engineer your data structures because that's the job of the compiler to optimize and you can't beat it ;) Sounds like something a person with experience only in JS would say. Be judicious with your micro-optimization, of course, but it's not too difficult to beat standard libraries and the compiler itself, especially if you can restrict the domain of inputs and outputs from the fully general case.
OK I'll bite, can you post a passage out of one or more of your textbooks, with the textbook name(s), saying that a linked list implementation in JS is impossible?
You haven't disputed it though. You've only claimed that explaining it "wouldn't land with" me, which is where the personal insults started. Very succinctly, a queue IS an interface built on top of a data structure that implements _enqueuing_ and _dequeueing_ methods. The data structure can be an array, a linked list, or something else. What makes it a queue is the order in which elements are added to and removed from the underlying data structure. In this case, it is First-In, First-Out. Is there something wrong with that definition? If so, could you please explain what it is?
&gt; You haven't disputed it though. I'm not trying to. Please respect that the person you're trying to talk to doesn't want to talk to you, because of your tone. Thanks.
thanks and sorry
Buddy, I'm at work, and I've gotten 25 angry, swearing, insulting inboxes from people on Reddit insisting, with no evidence, that I'm wrong. Now you want me to give you evidence that the thing you said to me isn't correct? Pass. I also don't dig through medical textbooks when I say "vitamins don't cure cancer" and the homeopaths and Dr Sebi fans come downvoting and "you don't understand yourself"ing.
Right so you have no evidence backing up a clearly wrong statement. Thanks for coming out I guess.
Yes you are. That's all you've done in this thread. What you HAVEN'T done is backed up your assertions. You just rudely claimed it would go over my head, and that I don't have the background to discuss this with you.
It's really weird how you made the statement, you had no evidence, and you thought that was okay But now you want to demand evidence from me that my ignoring your statement was wrong, *after* I told you I wasn't interested in talking to you anymore, and somehow I'm held to a different standard `:)` That's nice, friend. Enjoy holding up your own wealth of high quality evidence while sayng this. Please have a good day
Can you cite a reference for your specialized definition/implementation of a linked list? Because that's not the general case. https://en.wikipedia.org/wiki/Linked_list, for example, doesn't include fixed format or management by allocation as a requirement.
I posted a reference that you dismissed. You've posted nothing.
I enjoy how you're pretending that a website trying to teach people job interviews is a form of reference. &gt; You've posted nothing. Not for you. That's about your habit of being insulting. I can see that you're trying to win. Nothing will change from here. Please have a nice day.
I haven't insulted you a single time lol? I'm trying to have a discussion and you've been condescending the whole time.
Please stop trying to use wikipedia as computer science reference Please stop injecting yourself into conversations to demand evidence from not-the-first-person-to-make-claims Please don't ask for evidence from someone who is answering questions they were asked, assert incorrectly that they're making claims, and expect positive interactions from them Yes, I can. I simply choose not to, because it's going to lead to more abuse from others. If you actually wanted an answer you'd have asked in private. You're trying to win by shaming, and citing inappropriate reference. Have a nice day.
I feel like this 'problem' was solved a long time ago.
&gt; I haven't insulted you &gt; you've been condescending the whole time. I'm not interested in "that's not an insult, that's a fact." Look, it's simple. You asked me for something, I said no, and you kept asking, constantly saying "oh you must be wrong if you won't answer me. You're condescending." That's nice. If someone tells you "the way you're treating me is insulting to me and that is why I won't give you what you want," you can either call them condescending then not understand why you're thought of that way Or you can apologize, amend your behavior, and get the thing you want Anyway, have a nice day.
You don't technically need them in any language and could use an array or list instead. JS is no different. However using them potentially reduces bugs and makes the code more understandable. Whether you need them is down to the problem you are trying to solve. Processing a tree is useful with them if you don't want to use recursion and use a loop instead. Or if you were dispatching events or working on items from a queue that is populated by something else.
One possible path you could take would be for you to search HSL and manipulating that with JavaScript.
Generate in what sense? In CSS? On a Canvas element?
For a canvas
&gt; Please don't ask for evidence from someone who is answering questions they were asked WTF? Don’t ask for evidence? Why they hell would anyone ever believe something without evidence. &gt; Please stop trying to use wikipedia as computer science reference Your definition of a linked list is completely arbitrary. A linked list is nothing more that a list where items order is managed by each node having a reference to the next. See the NIST definition of a linked list if you’re unhappy with the Wikipedia definition: https://xlinux.nist.gov/dads/HTML/linkedList.html &gt; Please stop injecting yourself into conversations to demand evidence from not-the-first-person-to-make-claims Well it’s a good thing his conversation is happening on a social sharing platform that encourages its community members to interact with each other. &gt; You're trying to win by shaming, and citing inappropriate reference. You’re being an asshole who can’t admit they are wrong when confronted by conflicting evidence.
You can select colors (fillStyle and strokeStyle) using any standard CSS declaration for a Canvas – hex (3 digit and 6 digit), rgb(), rgba(), hsla(), etc. Was part of this assignment about learning color spaces?
&gt; WTF? Don’t ask for evidence? If you cut away half of what I said to make it look like I said something different, you're being dishonest. What I actually said was "please don't butt in and expect a positive response." You cut before the "and." . &gt; You’re being an asshole Please have a good day.
&gt;Please take the time to understand what someone is saying before challenging it. I thought I had, and it didn't make sense, so I asked the person making the statement to help clarify. I've DM'd you and await your response there.
&gt; Sounds like something a person with experience only in JS would say. Considering we are talking about JS, I take it as a positive point. I am mainly experienced with JS that's why I am confident in talking about it. I think in JS it is really useless to try to beat the optimizations brought by the engine. That's my experience talking. But I am open to critics if you have some use cases where you implemented some optimizations in JS that were significant.
This is a shallow take. What other languages have you used?
&gt; I thought I had, and it didn't make sense It's weird how you're telling me that what I said didn't make sense ***after i told you that what you're claiming isn't there at all*** I gave no definition of a linked list. I gave no implementation of a linked list. No, a datastructure's definition does not look like "It's when a node cell is defined in a fixed format, linked directly, and managed by allocation" I'm not sure what you're reading, but I didn't say anything that can be considered these ways . &gt; so I asked the person making the statement to help clarify. Have you considered that I might not want to? We're up to 40 abusive replies from a pile of people now, and other people keep asking me to repeat things I've already said, then saying "well sure every time you say something someone swears at you, but it's not me, so you shouldn't not want to say other things" . &gt; I've DM'd you and await your response there. I gave a detailed response there because it won't be available to the people who think insults are a good way to discuss computer science
For the folks asking for sources from StoneCypher, here's my question and their response, unedited so I'm not accused of taking it out of context &gt;&gt;Can you either share what you're using as a source for what a linked list is, or share what kind of source you consider legitimate. &gt;I mean I don't have a source for what linked list is any more than I have a source for what plus means. It's just something a programmer from an allocatable language understands. &gt;But yes, like I can find you reference that touches the topic, I can find you reference that touches this topic. You can find this position concretely defended and explained at length in D&amp;EC++, in CLRS, in Knuth (I think in 2? It's been a long time,) in NIST DADS (which, amusingly, someone posted underneath your comment, and which clearly says I'm correct, but which they do not appear to understand,) in Wirth ADSP, &gt;What do I consider a legitimate source? It really varies on what one is talking about. Much higher standards for a physics claim than a recipe, by example. The reason I say that is because the standard requirement for a topic like this is pretty strict, and if you try to apply this standard to other things it quickly becomes unreasonable. &gt;For something about datastructures, it should be a well edited book written by a college trained computer scientist, from a large publication company with a history of publishing high quality computer science books. That means Addison Wesley and MIT Press are in; O'Reilly and Pragmatic are walking the line; Packt and anything ending in .com are out. &gt;But, like, if we're talking about how to make a pleasant user interface, it can be pretty much any asshole who can spell, you know? Because that's about opinion. (Which is not to say that there isn't value in the formalism around higher end HCI/UX material, but rather, just that it isn't a hard requirement here.) &gt;You can use anyone's pizza recipe, but you better go to a doctor for your prescription recipe. &gt;It's like when someone tries to define a skip list, so they tell you "a skip list is a list that has links to midpoints in the list so that traversal is faster," but because they've never done the CS or read the guarantees or implemented one, they don't know that that's hard-wrong because the structure only works if it's stochastic &gt;And sure, if you look it up on reddit, on wikipedia, on stack underthink, they all get this wrong, because they're also written by people who learned that way &gt;And that's fine. There's nothing wrong with that &gt;But that isn't reference and you shouldn't pretend to yourself that it is. The error rate on the web's CS is like 60% in my opinion. &gt;In certain specific languages - notably C++, Java, Fortran, Coq, ML, and probably a bunch I don't know about - the difference between a container and a datastructure is a big deal. &gt;Ask a high end C++ programmer what it means that the C++ multiset container doesn't define what datastructure it's implemented by, and why that matters. They're going to lecture you for ages on how the performance guarantees of the container require it to be either a red-black tree or some near case variant, and how there are actually better datastructures that you could use which violate the performance guarantees, and they might start talking about Boost or SGI STL. &gt;Then ask them "wait, so what's the difference between a container and a datastructure?" &gt;The answer you should get will be roughly "a container is about how the programmer uses it; a datastructure is about how it's implemented under the hood." &gt;A set can be a lot of things. (Not in C++ because of some requirements the C++ language standard makes, but those are choices, not facts.) Under the hood, it might be a hash table, it might be a tree, in Javascript it's a fucking array, et cetera. &gt;Why? Because a set is a container. A set doesn't define how it works. &gt;A red-black tree, on the other hand, is a datastructure. It cannot be made in many languages, because the things that define what it is aren't available in lots of common languages. &gt;And it's really weird how when I say "this can't be done," JS redditors seem to take it as an attack on the language, or on them. &gt;I said "you can't open sockets in Javascript" once two years ago. More than 400 replies about things that seem similar to sockets to them, about proxy services like socket.io, about websockets (which are not sockets,) about special flags you can turn on in firefox to make sockets available to XUL, about flash, about all sorts of shit. &gt;Voted into the ground. (Not that I care. If I did I wouldn't post in /r/javascript at all.) &gt;Still correct, though. And every novice who read that thread would come away with the wrong idea, because Reddit has culturalized attack mode, and reddit programmers as a result often choose to lose opportunities to learn as a result. &gt;You cannot make a red-black tree in Javascript. Or, for that matter, in erlang, my favorite language. I point that out because I'm also not attacking my favorite language. It's just a fact. &gt;You can't implement them in CSS either. Or SQL. Or, in fact, in 18 of the top 20 of what Github thinks I use the most. The only ones you can are C/C++ and C#. &gt;The problem is that reddit programmers try too hard to win. They want what they believe to be correct so badly that they cite obviously wrong sources, and ignore the good sources they cite to the point that they don't even notice those sources undermining them. &gt;I'm being sworn at, mocked, abused, I'm having demands made on my time repeatedly after I've said no during the work day, people are telling me they know better than my textbooks, that I can't read, etc. &gt;None of these people appear to have a scrap of code on github &gt;It's very frequent that the less a person actually participates in a trade, the more likely they are to claim deep knowledge, argue with proper sources, and behave abusively &gt;I'm not making the homeopath comparison lightly &gt;These are a bunch of not-programmers with no evidence arguing with the principal platform engineer at a nine figure security company. &gt;They're getting core concepts wrong, like that there exists such a thing as an "implementation detail" for a datastructure. &gt;That's all a datastructure is, is a name for implementation details. &gt;This whole community is ridiculously toxic and self unaware.
what the fuck, dude, i told you i didn't want them to be able to see any of this
Do you have any good resources? Preferably in js.
aaaaand you spited me and took the thing i gave you when i said "i don't want to be in this thread anymore because every time i say something i get hassled" and put it back in thread `:(` and next you'll say "i don't understand why you won't answer questions i ask you anymore"
it's not clear why you think it's okay, when someone said "i don't want to do this in that thread because i'll get abused," to go to them in private and say "okay we can do it here, please answer" then just go put them on blast this is a violation of trust you won't receive another answer from me
Welp, that’s what I get for talking out of my ass haha. I guess they would have that optimized but alas
I used C, C++, C# and Ruby, but what is your point anyway? Each language has its specificities and not every concept can be translated from one language to another.
&gt;it's not clear why you think it's okay, when someone said "i don't want to do this in that thread because i'll get abused," You didn't indicate that to me, neither in your response nor in the post I responded to. Maybe you indicated it to someone else in another thread, but it wasn't to me.
This post, which is currently on the /r/javascript front page has a few sections on the various types of tree structures. https://www.reddit.com/r/javascript/comments/beoyqb/github_dsajs_data_structures_and_algorithms/ https://github.com/amejiarosario/dsa.js Like another poster said, trees are also a great way to learn about recursion, and they are just a lot of fun in general!
&gt; Do not try to over-engineer your data structures because that's the job of the compiler to optimize and you can't beat it No, the compiler will not fix your data structures and algorithms. It's up to you to know the best way to represent and solve your problem. The compiler just implements *your* solution efficiently. The compiler (outside of toy examples) will *not* replace your wrong algorithm with the right one. If you want to be a software developer, it's important to have enough of a foundation in algorithms and computer science to understand the [time complexity](https://en.wikipedia.org/wiki/Time_complexity) of your code because that directly impacts its performance. Your users want the program to run fast, and it's up to you to do that. This is *especially* when you're a Javascript dev. Your code runs on hardware you don't control and interactivity is important.
&gt; I thought queues are pretty much redundand beacause of the way arrays work in Javascript. A queue is a *conceptual* data structure. You can implement a queue using an array in JS (though it's [a little tricky](https://en.wikipedia.org/wiki/Circular_buffer)). If the algorithm you want relies on a queue (and there are a *bunch* that do) then knowing how to implement one is useful.
Yes, I did. Repeatedly and clearly. &gt; &gt; I've DM'd you and await your response there. &gt; I gave a detailed response there because it won't be available to the people who think insults are a good way to discuss computer science
dID yEW no YoU CAN forCE yoUR PeFREncEs On OtHurz iF Yoo MAKe ELynT ROOLZ b4 oThErss?
This is awesome! Any chance you could add settings to account for preferred coding style - especially single quotes instead of double quotes?
&gt; I do not get the impression that you have any interest in the answer to the question you asked Oh I do, you just aren't the person I would like to learn it from. I asked a simple question and you typed out an essay full of complaints out of which just 1/8th was devoted to the actual answer.
Thanks, I signed up. As someone who is self taught, this looks perfect to fill in some gaps
|| you can do: `new Array(patterns.length).fill().map(cell =&gt; -1);`
I did 3 variations of stopwatch and countdown timer using React (classes and fn components), React using Hooks and pure vanilla js. Would love to hear feedback and suggestions for improvement. &amp;#x200B; Vanilla JS - [https://codesandbox.io/s/6252pyn1o3](https://codesandbox.io/s/6252pyn1o3) React with Classes and functional components - [https://codesandbox.io/s/qq1p9zynl4](https://codesandbox.io/s/qq1p9zynl4) React with Hooks - [https://codesandbox.io/s/z683l500ol](https://codesandbox.io/s/z683l500ol)
People are downvoting, but I wholeheartedly agree with you. Even if I was forced to use an RDBS for K/V storage, it's trivial to write those queries and abstract them to a simple get/set function.
"the reason I asked you a question then ignored your answer is"
If the array used a linked list you'd lose O(1) random access.
sure can. we're discussing doing this without `.fill()` though
Getting wildly different results in my test with node let total = BigInt(0) for (let i = 0; i &lt; 1000; i++) { const arr = new Array(2000) const start = process.hrtime.bigint() for (let j = 1999; j &gt;= 0; j--) { arr.shift() } total += process.hrtime.bigint() - start } console.log(Number(total / BigInt(1e6)) / 1000) Clocking in at about 0.2 ms per iteration
How do you know I ignored your answer? I'm not qualified enough to go into discussion on data structures, however I have spent the last 2 hours thoroughly analysing all you've said so far (although it's quite a struggle to filter the important bits), and reading up. You clearly have knowledge, it's just that it's wrapped in this horrible condescending personality, which is a shame really because you very clearly know how to convey it - but choose to actively stir the pot instead. Honestly, your top-level comment literally only needed two more sentences of explanation and you'd have the highest-voted comment in this thread, probably with a great, enlightening and very informational discussion ensuing below it.
That's Redis Cloud, not Redis. Redis itself is free, just install it on your server and run it.
You can install any of these key-value tools on your existing server or some other server of your cloud provider if you don't care about latency.
Just install them on your existing server. What's the problem?
Except Array.prototype.shift() is O(n) and dequeue when using a queue is generally expected to be O(1)
It depends on the problem at hand, but for the most part: objects, maps, stacks, queues, linked lists, trees, and graphs. I talk a [little more about this here](https://algodaily.com/lessons/how-to-prepare-for-a-technical-interview).
It could be that it will reduce parsing time, with features (or a pre-compiled library) targeted toward replacing commonly included patterns. The big ones are React, Redux, Angular, and other application frameworks. If the browser API was much, much better, these libraries wouldn't need to exist.
We have two servers. So needs to be centralized the data.
Does this not say shift performs 5 more operations per second?
What country are you from?
The compiler won't optimize your linked list to an array if it notices you always access it sequentially. The point is you actually _do_ need to know data structures and where they fit into algorithms.
&gt; you can't really solve problems like "check if the parentheses in a string match" without a stack. You absolutely can though? Keep a counter, loop through each character, increment when you find a `(`, decrement when you see a `)`. Or am I misinterpreting you? I'm absolutely not disputing the "stacks are a pretty fundamental concept in CS" thing, it just seemed like a weird example.
&gt; How do you know I ignored your answer? By reading your response, wherein it goes entirely unaddressed. . &gt; however I have spent the last 2 hours thoroughly analysing all you've said so far (although it's quite a struggle to filter the important bits) I think you're being more than a little melodramatic. The thing you said was "an essay full of complaints" was eight sentences, by example. You also said 1/8 of it was devoted to an answer, and was all complaining, but there's only one complaint in there. The rest of it is the answer, and because you filtered it out, you didn't notice. If you find yourself struggling to filter eight sentences, well Okay . &gt; You have knowledge, it's just that it's wrapped in this horrible condescending personality It's really weird how you think insulting me will get you things. You keep doing this. . &gt; which is a shame really because you very clearly know how to convey it - but choose to actively stir the pot instead No, I actively withdrew. I'm just responding to people like you flaming me, to say "okay, that's nice" . &gt; Honestly, your top-level comment literally only needed two more sentences of explanation and you'd have the highest-voted comment in this thread, probably with a great, enlightening and very informational discussion ensuing below it. I see you're new to `/r/javascript`
It cannot be "optimized." The array must work this way for the other parts of array to work correctly.
That's because your test primarily measures allocation
The thing is that it's not about optimizations brought by the engine; the engine can optimize an O(n) algorithm down to a couple of instructions per element, but it can't optimize away the fundamental O(n) nature of the algorithm. That's why it's sometimes necessary to build dedicated data structures (such as queues) where the relevant operations (such as enqueuing and dequeuing) take O(1) time instead of relying on the engine's well-optimized but O(n) algorithms. Of course, if it's just about a small thing used in the frontend with usually just a few elements, O(1) vs O(n) absolutely doesn't matter. However, if it's, say, a back-end which should accept thousands of requests per second, or a game where your time budget per frame is 16ms (if you're lucky and the GC hasn't eaten most of it), it suddenly starts to matter a lot.
It's a very common interview question that gets posted once in a while on here, hence why I chose it. Typically you have to match (, {, and [ so the counter idea doesn't quite work
Ah, yeah, that would make more sense, thanks.
Queues are a very basic structure and can be implemented using an array as a base. I would expect anyone I hire to know how a queue works. Most importantly it shows that you can think about a normal situation (like waiting in line at the grocery store) and conceptualize that in code. If you look up interview questions you will find all kinds of these answers everywhere. I also took algorithm and data structures in python on udemy (you can write them in whatever language the concepts are the same). It goes over the basic structures and their time complexity which is also important for interviews and performant code. Good luck!
Thank you for this. I'm surprised people clicked a facebook link at all to watch a video.
it says pop 5,000 a second and shift is 10 a second
yeah but what do you get for pop, it's the relative performance that matters
[puppeteer](https://github.com/GoogleChrome/puppeteer), maybe.
Take a look at Cheerio https://cheerio.js.org
But can you make Cheerio wait for the JS to finish loading
puppeteer
the DOM is a tree. one should be familiar with trees, even though they aren't typically used directly by JavaScript engineers.
Data structures are one of things the compiler cannot fix. That's why understanding them is important.
Only saw the tree view but I didn't experiment for long
That's completely wrong.
&gt;we must check whether the x and y coordinates of the the two divs meet and if true remove the coin div element using the Js DOM ? Yeah, that sounds right. This won't work though: var guy = document.getElementById("guy"); var coin = document.getElementById("coin"); if(guy.x &lt; coin.x + coin.width &amp;&amp; guy.x + guy.width &gt; coin.x &amp;&amp; guy.y &lt; coin.y + coin.height &amp;&amp; guy.y + guy.height &gt; coin.y) { alert("Collision!!!"); } `guy` and `coin` are both `HTMLElement`s, so they don't have `x` or `y` properties. You should maintain some kind of state object, and use that as your source of truth for the positions. e.g.: const state = { positions: { guy: [0, 0], coin: [0, 0], }, } Then update `state.positions.guy` when you move him, and compare `state.positions.guy` to `state.positions.coin` to detect collisions.
I second this. Just used puppeteer for something similar. It's promise based and seems to have a tool for just about every use case.
e=mc^2 seems easier to understand than the code above.
And then killing them again. And again.and again ...
like my /u/Magnusson points out there is not a one to one relationship between style properties and things you might be doing in JavaScript so you need to setup something like he describes or like this where I have three JS objects representing your three main game objects and each has an htmlElement property like so: [https://codepen.io/anon/pen/XQqwgB?editors=0010](https://codepen.io/anon/pen/XQqwgB?editors=0010)
Or for that matter an end user application where you still have to get back in say 30ms
I built my portfolio site with nothing but webcomponents this week. They are almost there. Just need to be able to Pierce the shadow dom a bit better with css, get a bit better tooling, and have a light framework over them.
That doesn’t sound right. Why not work the way described above that Perl does it? It would cause every array to take more memory and if I had to guess that’s the reason Chrome doesn’t do it (it’s already too much of a memory hog), but that’s hardly “The array must work this way for the other parts of the array to work correctly.” I think all the other parts can work just fine. It’ll s just waste a lot of memory.
in vanilla JS: const targets = document.querySelectorAll('.ml2'); targets.forEach(el=&gt;{ el.innerHTML = el.innerText.split('').map(char=&gt;`&lt;span&gt;${char}&lt;/span&gt;`).join('') }); [https://codepen.io/anon/pen/NmMZKy](https://codepen.io/anon/pen/NmMZKy)
Looks cool. I'll pick it up and play with it.
cheerio (gives you pretty much an exact jQuery api to use) &amp; phantom/puppeteer/another headless browser
Specifically, it does not produce a visual rendering, apply CSS, load external resources, or execute JavaScript. If your use case requires any of this functionality, you should consider projects like PhantomJS or JSDom.
Nah, you give cheerio the HTML response from the actual request.
Any of the chrome debug wrapper projects will work (puppeteer, chromeless, Selenium). They're all just API's on top of the chrome debug protocol which essentially means they're just a chrome browser you can control, all of them come with an evaluate function that let's you essentially run code on the page as if you were doing It in the debugger.
Just wanted to share two Chrome DevTools console behaviors I found surprising.
If you're down that far in performance needs, JS wasn't the right choice to begin with though.
Cool but this has been posted 100 times
This statement feels like an aimless cop out. Sometimes you end up with a lot of data in a js application and you can just pick a proper data structure that's not O(n). Hand waving a person toward C or something feels illogical.
"Where the FUCK is the anchor bird?!" [throws more stones]
Is it supposed to be posted once and every person who subscribed to reddit and this sub is supposed to just miss this news from this NEWS aggregation platform about current *NEWS* on the internet?
seriously, what an asshole that guy is
You're missing the class, but apart from that, it's the right solution
node and puppeteer
Because in the end there's 99% chance that we are going to deploy our app on a Linux server.
It seems to me that you missed something ;)
By the way, in this case I would use `el.innerText.replace(/./g, '&lt;span&gt;$&amp;&lt;/span&gt;');`
His span have a class, yours doesn't
Oh! Shame on me. I thought you mean the `.ml2` class.
Maybe they meant an actual queue like rabbitmq? So you basically solve the problem using a microservices architecture. Service 1 talks to the APIs or whatever. Cleans and transforms the data and sends to the queue. Service 2 receives the data from the queue and then does something.
&gt; While discussing my solution, I was told, that I was expected to solve one part of the given task by building a queue (i solved it completely differently). Well how did you solve it? If you solved it in a reasonable way, and the interviewer took points off because you didn't solve it _their_ specific way, it was a shit interview. &gt; which kinds of data structures do you come across from time to time in Javascript Objects. Arrays. Maps. Sets. The most important thing to me isn't necessarily knowing tons of data structures. Knowing about data structures is fine. Knowing _when_ to use them is the important part. Got a bunch of objects where you know you'll have to iterate and touch each one anyways? Put it in an array. Are you going to need to scan an array repeatedly to find a specific object by an id? Iterate over it once, and put it in an object or a map so you can look it up by that id in O(1) next time. Do you need to check for the existence of something that can be compared by equality? Put it in a set. And maybe, _maybe_ you'll end up writing your own data structure (trees, linked lists, queues, circular buffers, etc), but it tends to be rare in my experience. The number of years I've been writing javascript is larger than the number of not-built-in data structures I've had to write myself to improve performance. --- Of course with that being said, it's always worthwhile to learn data structures anyways. When you _do_ need them, it's good to know what's available. This is one of the better repos I've found for algorithm examples in javascript. https://github.com/trekhleb/javascript-algorithms
What has that got to do with building UIs and web apps? Because that's what JavaScript is for.
I've used Selenium. Far slower than scraping the usual way, but sometimes necessary, especially for sad old government web sites still using [ASP.NET](https://ASP.NET) or Java "viewstate" features.
Your claims make no sense. You just went on berating the most popular cms in the world by just saying it lacks proper performance? Do you even understand how many hours and how many people and how much effort it took so WordPress be WordPress? If you want to make a new cms from scratch, alright, do it. Why do you speak ill of WordPress?
**you are doing a great job**
No, multi puprose solutions like Wordpress will always be resource hungry and slow. If you want fast, the code something non generic.
Jkery
I've experience with other languages and what you've said makes sense. Imitating a data structure is not having it as a fundamental one such as is available elsewhere. Even something like using pointers to direct to the next / previous in a linked list is very different from using a object names in javascript.
Regex replace everything that's not those while length &gt;0 and () or [] or {} exist replace them with empty strings return length ===0
If Wordpress abandoned Wordpress. Anyone could build something similar that is much faster but they couldn't harness the community of developers talking one paradigm. Going to NodeJS means abandoning the communities work. A fresh start would certainly be faster but it's like comparing the speed of a continent to that of say a mosquito. The mosquito is faster but it does a hell of a lot less.
Why u delete, OP?
TIL continents are bloat
Nope, it's already foobar.
They support trillions of mosquitos
Phantomjs is abondonware right?
How much the times have changed... The humans finally evolved to accept JS as their saviour.
Pretty interesting! Have not seen this before, thanks for sharing
All hail the Lord
Sure Got it!
Amen.
Why can't you use other scrapers for viewstate stuff? I've often seen "viewstate" as a scrapeable parameter on the page, or is that something else?
Let me rant a bit: Missing types, interfaces, return types, parameter type hints, no real classes, no traits, no private protected public, no extends. Sorry but I cant see how JavaScript is good. I use it everyday but when it comes to backend logic I like to have a language with more features. And no type script is a hack. JavaScript should be type script and not a pre processor to fix the language.
Nice Codepen :p. Why the hate against jquery though?
I suggest you You Don't Know Js, it's a really good book. An yeah, there are classes, there are private fields - take a look at ESNext.
Because in this case: - It"s not needed - it's less performant Also, your replace regex is absurd lol.
&gt; Missing types, interfaces, return types, parameter type hints, no real classes, no traits, no private protected public, no extends. Half of those are about your personal favorite flavor of OOP, so it has less to do with quality and more with your narrow-mindedness as a programmer. The rest are fixed by TypeScript and I don't understand why you're dismissing it. Oh, except traits. Yeah they would be cool.
Having a C/C++ background, types are a waste of time because of all the casting pain it involves (don’t know about modern C++). They also make the code a lot more verbose, see C# for instance. I believe types should be indicated in the descriptive comment so your Intellisense tool could parse them and that should be quite enough given that you use a decent editor. JavaScript supports most of OOP concepts and work well with other paradigm. Interfaces are supported by TypeScript (that I don't like) and are far more appropriate for compiled language (to bypass the rough nature of all compiled language). If I remember well, interfaces comes from Windows COM technology, which was pretty amazing at the time but now, many other paradigms are used and work quite well. Private and protected don't work that well in TDD/BDD env. Basically, testing is a HUGE part of the JavaScript ecosystem and the requirements of delivering software with no bug being extremely important, there is no advantages of having private or protected methods as you end up exposing them to be able to test them. People think, typing is going to make my code fantastic with no bug they are wrong. Agile does that. In any case, Js supports many of these concepts (private, extends, etc) but it’s just not focusing on them as OOP is not the only development system out there (FP for instance). JavaScript is what I was dreaming of when I was coding in C (C being the one when I was doing assembly). It's a fantastic language that took a bad name 15 years ago due to its use and complexity but it's very advanced today.
I think strict types are good for large/complex systems: they document your code and add constraints to help guide change, which is enforced by a compiler. IMHO, they help guard architecture. Dynamic languages require more restraint, discipline and commitment in order to maintain a well-architectured project. You can create a coupled chaos in both weakly or strictly typed languages, it's a bit easier in weakly typed ones. With regards to verbosity, a lot of languages support type inference to tackle the verbosity.
JSDoc + tsc (running as a linter with --no-emit) solves your type issues. I've taken Crockfords advice and now create all my objects with closures. No classes, no prototypes, no 'this' keyword - just functions and objects literals. It's not something I'd do in C#, but Javascript isn't C#.Honestly it feels like I'm going with the grain of the language now, I highly recommend it.
The best response to an opinion is “you’re narrow-minded.” As if you’re not narrow-minded because you are pro-JS.
Oops, that'll teach me for not reading the context!
No.
It’s really not misunderstood. There is a huge cohort of people that only use javascript, and have only ever used javascript, and they get upset when people criticize it because it’s all they know. And they use it successfully so they don’t see what the problem is. JavaScript is not terrible. It’s just that when you have actually used other languages you see that it is pretty quirky, it does lack some things that are common in other languages, and it really was much much worse even 5 years ago. Again, people who have only used JS see ES6 as a godsend and as progressive, but really all it did was make JS an adult language. I just seriously question people’s opinion who don’t have any breadth of experience, and that also includes people who hate on JS because all they know is C# or something.
They effectively said languages outside of the class-based OOP paradigm are bad. You don't think that's a narrow-minded view?
For me, there is no correlation between complexity and used languages. Architecture and complexity is down to experience and maybe talent. Strict typed languages (I called them compiled as I still think in assembly/code machine) are great for low level system, things that requires speed, etc. They use the correct amount of memory and they are the fastest. They do really make sense for low level operations/close to the OS processes, systems that require heavy processing like image/video transcoding/editing etc., embedded systems with low amount of memory, etc, but they make far less sense with systems that requires database access, AI development, Advanced web application, things that requires lots of async operations as multi threading is still one of the most complex part. To be honest, What I call complex projects is likely different from what you would call them, so it might be difficult to discuss this. However, creating a mess, would be down only to the people. A lead that forces you to use their way, may be an example. An architect that does not understand some requirements, a senior dev. that wants to apply the same pattern everywhere, it's all down to the team/people.
Not really when JS does try to add OO features, but is missing 90% of them. So if it were actually a functional language that would make sense, but it has way more OO features than functional ones. Honest question. Is JS the only language you use?
I don't know man, working with Java or c is pretty shit compared to a modern JavaScript workflow. Sure IDE's help solve some of the things you have to do but switching to Java just felt like going back to the dark ages for some reason for instance.
&gt; Not really when JS does try to add OO features Not really, all it has done is introducing syntax sugar for prototypical OO features which it has had from the beginning. The upcoming private methods is the first truly new feature I can think of. &gt; So if it were actually a functional language that would make sense, but it has way more OO features than functional ones. I didn't say it was functional. It's multi-paradigm, always has been. &gt; Honest question. Is JS the only language you use? No.
/u/mort96 talked about 16ms timeframes for real time gaming. JS is not a suitable language for this. Of course there are situations where you’ll end up with larger data sets or bottlenecks and using proper data structures will be a required optimization, but what he described is not something you figure out halfway through a project lol
You're so right! I worked with many progamming languages and believe me JavaScript is in the bottom of my list. I really hate couple of aspects of JS. E.g. typecasting, error handling, code styling. You get in a such big mess when you try to build something bigger. It is definitely not language of my choice. P.s. #1 goes to Go
I mean. That makes no sense. I’m by no means a Java fan, but it is way more powerful than Javascript. You just like the JS ecosystem. That doesn’t make Java “the dark ages.”
So? Install it on one or on both. Some of these stores are designed to work across multiple servers.
If you read what I said, I did not say anything bad about JS.
It's completely normal to criticize bad/stupid solutions.
Up to this point I never insulted you, pointing out the fact you're being condescending towards me and everyone else is not an insult in any sane culture. It's your choice to expect praise, and consider everything else as insult, flame or judgement, but I guess it's a sign of the times we live in. You say a controversial thing without a single word to back it up, then call everybody that responded an uneducated idiot, then go full siege mode implying everybody is flaming you. Nobody would call you an asshole if you didn't try to be one. Nobody calls a person an asshole for respectfully stating facts. It's the WAY you state the facts. Hell, you literally started the dispute with an insult ("people will downvote and argue with me because some blog told them otherwise"), then just dismissed every response with little reasoning, spouting unrelated bullshit and basically just being frustrated. That's being an asshole, saying queues aren't possible in javascript is not. I don't know if that's what you are on daily basis or you just had a bad day, but I sincerely hope the latter. You see, these stereotypical asshole engineer savants you're trying so hard to mimic usually have the advantage of authority - an anomynous guy on the Internet does not, which puts a burden of requiring just a little bit more explanation on you, and is what people are calling you out for. I am sure it is a sensible assumption that /r/javascript might not all consist of CS graduates, let alone good CS graduates that fully understand the intricacies of this topic, and the fact there are over half a million people here means you inevitably will get dumb responses quoting some silly blog posts. However, as you surely must have noticed, there are people here that actually wanted to have a discussion, despite it's unfortunate beginnings... but you just kept calling them idiots and pointing out how little they know compared to you. Obviously it's your right to not want to be an educator, but then at least don't be a fucking instigator. It genuinely makes me sad that you care about heated argument more than a civilised discussion that this subreddit desperately needs. Just a sentence or two more and this post would've been a valuable resource to so many people, probably linked to for years to come. But you don't care, you'd rather go into an insult spree, call people not-programmers and "actively withdraw" from any sensible conversation, why you're even here then is beyond me. Please do not respond to me anymore, contrary to your beliefs I don't actually want anything from you. I'm sure I can expand my knowledge without being looked down on.
Whatever works with you and your team. Every file structure is more of a guideline anyways.
Thanks for the reply. With complex projects, I tend to think about projects with a lot of domain concepts that have a potential to overlap. Types and objects can help align mental models between domain expert and developer. Another source of complexity is infrastructure (storage, IO, messaging, logging, "services") and the separation between the abstraction (*some* storage) vs the implementation (a *database* storage). This is where the ports and adapters architecture, more generally polymorphism and interfaces, help structure a project in a decoupled manner by explicitising the difference between an abstract type or interface and the concrete implementation. I like Golang's dynamic interfaces in this regard as it fully decouples the abstraction and the implementation. Of course, you can use a dynamic and/or weakly typed language for this. But to me, it is less explicit and slightly more error prone.
 The -Script suffix suggests that it is not a real programming language, that a scripting language is less than a programming language. But it is really a matter of specialization. Compared to C, JavaScript trades performance for expressive power and dynamism. But the side bar says All about the JavaScript programming language! Hmmm........
Sounds like it works for you. Probably more important to have a rule and stick to it. If you're consistent it's less important in this case what the rule is
If somebody implemented a data structure in Javascript, that acts exactly like a red-black tree, but uses object references instead of pointers, what would you call that structure? Should we come up with a different name because it does not use pointers?
Any book or link to Crockford’s advice?
https://youtu.be/bo36MrBfTk4?t=2143
Powerful? how many times do you hear about teams not making deadlines in these languages... Examples are legio. And I guarantee you, all your fancy oop principles are thrown overboard in these situations. I have seen enough examples to say that. In an industry where delivery is important, I would say that JavaScript is the most powerful. You can ship products in no time. It's only a matter of time for JavaScript to gain what it doesn't already have and at the speed that it is evolving it's sooner than later.
There is still a resistance at r/programmerhumor that needs to be crushed.
&gt; interfaces comes from Windows COM technology Lol, wat?
To me, complexity really depend on requirements. The more unrealistic the requirements (in time and resources), the more difficult the project. I would not be able to tell whether to scratch Js or any other languages if I don't have the complete picture. I do have my bias, especially with Node and JavaScript as I know the potential. Everything image/video/data processing can be challenging, video games development can be very challenging, many things that touches the OS (you said, IO, storage, etc.), networking related development, security, 3D, etc, all those things can become excessively complex but at the end, it's all down to the people. The language is just a tool. Interfaces a pattern. The success of a project? The people, the choices.
You’re bias is coming out in full swing now (no Java pun intended). Projects are not late because of the language choice. That’s a laughable point. I agree with you 100% that the promise of OO has never been fulfilled. But JS isn’t even a good functional programming language (impossible to opt out of shared mutable state), so by that logic you’d still be looking for a language other than JS. But I’m sure logic escapes you.
I'd be interested to hear what you think makes other languages more powerful? (and I really mean that, it's nice to see a thread with reasonably balanced discussion instead of condescending and dismissive rhetoric). I realise that C (and others) have memory management, but aside from that what more "powerful" features is JS missing?
Typescript is only as powerful as the JS allows it to. Although I do agree it is about as strong as it gets with a dynamic language underneath.
Oh come on, just do the test yourself. Building an app in JavaScript takes way less time than in c#. I know because just recently I had to create a webapp based on a xamarin project. I can objectively compare times, but "I am sure that logic escapes you" arrogant prick...
I might be wrong (everything I wrote was from memory) but I always thought interfaces were bound to Component Object Model technologies (COM). We were using abstract classes at the time but I don't seem to remember as that was one of my development work a long time ago. I believe this was the first time interfaces were used like we do today. It’s definitely not Java as it was only created around 1995. Correct me if I wrong. Always happy to learn.
I think you misread the paragraph. He's saying it is a programming language, but it's prefix incorrectly suggests otherwise.
I am using \[mechanize\]([https://github.com/sparklemotion/mechanize](https://github.com/sparklemotion/mechanize)) with my latest Ruby on Rails project. I do the scraping in my backend server and persist the results directly in my database. \`Mechanize\` is pretty cool, it loads the entire page, I can query the \`DOM elements\` with the \`html tags\`, \`classes\` and \`ids\`. I can even use attributes with something like \`page.search("div.myclass p#myId a\[attribute='something'\]")\` Mechanize is a \`ruby\` project, but the dependencies are written in \`C++\` ... still does not run fast.. I literally can watch the log file of the server create one entry per second :)
To be fair if you're [writing code like this](https://www.reddit.com/r/learnprogramming/comments/839qcw/shared_mutable_state_in_javascript_how_could_it/) the language isn't what's holding you back conceptually. Its closure and pass by reference defacto is hardly a hurdle to anyone who writes code professionally.
&gt;Powerful? how many times do you hear about teams not making deadlines in these languages... You do realize that most of these have ...ahem.....js frontends? Why do I see and hear so many people raving about productivity in flutter?
\&gt;Oh come on, just do the test yourself. Building an app in JavaScript takes way less time than in c# Maybe because you just don't know C#. Plus its entirely project based \&gt;I can objectively compare times No you really can't because your belief you are as proficient in both is subjective and terribly unlikely.
why the down votes?
Err the app was the same... I happen to know it took them over a year to finish and JavaScript project only took six months... But what do I know right?
Which parts are you talking about. Here is a link to a discussion about a similar topic in Perl - [link](https://www.perlmonks.org/?node_id=17890) I was a bit naive to think that the implementation in JS would be similar and it actually makes sense it is different when you think about it. The JS can run in the browser and the memory footprint is more important there.
We might need to define "interface" better to continue this discussion usefully.. VB6 can interact with COM, but does VB6 have interfaces? Pure virtual clasers without fields in C++ were considered interfaces. COBRA was very similar to COM and predates it by nearly two decades. The essential concepts of an interfaces goes back 50 years.
Well, we have do have our knights [post](https://www.reddit.com/r/ProgrammerHumor/comments/bf2jew/thank_you_very_much_sir/?utm_source=share&amp;utm_medium=ios_app) But if that's not the case, we should prepare for another crusade! ⚔️
I have just come across this twitter thread after seeing Rauschmayer's talk on future JS [(FB video link)](https://www.facebook.com/plugins/video.php?href=https%3A%2F%2Fwww.facebook.com%2Fqirolab%2Fvideos%2F814527372236414%2F) and then following the original post on his blog http://2ality.com/2019/01/future-js.html I must say I am normally a big fan of both of their work, but I strongly disagree with their stance here. Nuking a really useful feature that works well in other language just because of a vague, unproven "it will lead to more problems later" seems more like gatekeeping than a strong technical argument. What do you people think?
Clearly not C\#
Every language has limitations, and learning those limitations is part of learning the language. JavaScript lacks type safety, static typing, and there are resulting problems with things like equality checking between stored values. Current JS runtime environments are also not quite as well developed as your average Java runtime. Byte for byte, a Java application will probably outperform one targeting Node. All that said, I would rather write client/server code in JS. Or pretty much anything. I hate Java.
No official epub/mobi/pdf versions this year?
No they're quite right, or at least have a very good point. Littering your code with null checks sucks, for several reasons. Making it a one character operator doesn't make it any better and encourages ignoring the larger problem, as they suggest. Null is called the billion dollar mistake for a reason.
Ah! You’re right, it’s been awhile. It has to be captured and passed with each request, which is annoying but doesn’t require JavaScript execution because it’s only modified by the server. There are still sites that do require Selenium or a similar approach, but not because of viewstate alone. I looked at the last code I did for that sort of site and it just captures and passes the parameter. At least with the ASP.NET’s version. I recently ran across the Java version and haven’t had a chance to try it (I scrape public domain information from government sites that don’t have fancy Open Data APIs).
Many people that complain about js are often not aware that the language is designed for flexibility, not for rigidity. In a Java or C# program, I am locked into OOP which is great enough to make your undergrad professor happy, but I might have need of something that needs to behave like an OOP language sometimes and then like a scripting language at other times. Yes, it comes at a performance hit. Who cares? Performance just needs to be good enough.
Ahh, I'm in a very similar line of work. We originally did all our scraping using manual requests (mimicking network requests and parsing the html response.) this was super fast but you had to do fiddly stuff like scrape viewstate tokens and whatnot every request (depending on the site, I'm assuming Java because I managed to get a Java stack trace once :) ). we ended up eventually switching to one of the browser solutions because it was just too hard to maintain the manual way, turns out browsers handling everything for you is really great.
&gt; Typescript is only as powerful as the JS allows it to. In what respect? Can you please elaborate?
You know, hot reloading, the thing flutter advertises so hard is inspired by... You guessed it
JavaScript is awesome what a time to be alive!
 [https://homehost-demo.herokuapp.com/](https://homehost-demo.herokuapp.com/) react app that organizes your media collection. powered by tmdb and spotify
TypeScript compiles under the hood to javascript. The compiled result can just as good as javascript is because it is javascript. For example private or public properties. You can't set a variable to private in javascript. You can just scope that variable so that it feels like that it is private. This is what type script does. But if you get that object in your hand you can still access that private property because it is javascript and type script can't change javascript.
You would need to have some pretty demanding technical aspirations and/or content before you'd have a problem hitting 60FPS in a JS game.
People are pretty bad at seeing both sides of an argument. I don’t listen to people who can’t explain and understand both sides. Memory management certainly gives you power, but it’s unnecessary for 90% of the code that I personally write. I work on information products, SaaS right now. So I’m looking for languages that help me express business rules, and that introduces as little possible accidental complexity. That’s important to say, because my opinions would be totally different if I worked in video games or embedded software. So from that angle, things that I think are powerful: 1) Immutability / Value semantics This is number one for me. I think the best trend in the industry right now is that we talk about pure functions. Out of everything that promises to make everything better, I think pure functions are the only thing that actually deliver on that promise. And a pure function is way less useful in a language that only has shared mutable state and no way of enforcing that a function is pure. True value types (that can’t change and / or be referenced more than once) allow you to keep functions pure even after someone accidentally tries to add side effects down the line. (Note that I really don’t think const in JS or C++ get you this all the way. See structs in Swift for an example of what I’m talking about). 2) Concurrency It’s just essential in today’s landscape. We need good ways of thinking about multiple things happening at once. I’m partial to the actor model or CSP, because these actually dovetail quite nicely with value types. Both require passing messages, and values make the best messages because they can’t be modified. They simply represent an occurrence. 3) Enums / sum types Enums in a lot of languages are implementations of sum types. They allow you to express “either / or” relationships. For example, an app can either have an authenticated user or not, and an authenticated user has certain data associated with it. Powerful enums like those found in Rust and Swift allow you to express these relationships in a way that’s more explicit that having a bunch of bools that you need to know are tied to certain pieces of data. 4) Non-nullability Null is ridiculous. There are languages that don’t have null, and there are languages that allow you to deal with them explicitly via Optional types. Either way it’s better than having null. 5) Closures / First-class functions It sounds obvious right now, but there are generations of people who had a function pointer as the closest thing to a first class function. Closures solve so many problems that I simply can’t live without them. 6) Standard Library The lib that ships with the language is essential, and not all standard libraries are created equally. As you can see, by my definition right now a statically typed functional language like ML or Haskell seems like they tick all the boxes. But I think Swift and Rust also have a lot going for them. I’m also totally fine with dynamic typing, so Clojure looks great. I work in Ruby, Swift, and Javascript mainly right now, and Ruby and JS are pretty comparable to me. They default to shared mutable state. And it’s very difficult to have true value types in them, so that causes a lot of frustration. Swift’s Objective-C interop requirements also create annoyance, so I have no “perfect” language at this point. I’m just looking for specific features.
Typescript's philosophy is to not add features JS doesn't have. One of the issues I frequently find is dealing with data classes - so it's basically an object with several fields. It doesn't make sense to ever add another field to it. And fair enough, typescript prevents me from doing so in general, but there are several situations where it does allow me to do so, for instance when spreading one object over the other. Sometimes I might also want to check if all properties of an object fulfil certain criteria (for instance all string fields of a form are required and I want to check if they are truthy). I can't do that easily with typescript, since the compiler doesn't know if the object doesn't have an own property set somewhere else in the JS code, so it can't make any assertions when it comes to types of the object's fields values.
You can do this with destructuring already
snake\_case is actually the most readable format. Around 20% more readable than CamelCase in terms of how quick a human can infer accurate meaning from set of characters. There is a few studies done on this one, I'm sure you can find it via search engines so I won't get into it. I also learn to appreciate this fact and got used to after doing a bit of Rust, where variables, function definitions and filenames, struct properties are all defined in snake\_case other wise the program simply won't compile. CamelCase is however reserved for Types. That being said, even if it is objectively more efficient and therefor better put preferecnes and tastes aside, it's still more optimal to go whatever the community accepted standard is. However, I'm not sure if ESlint requires filenames to be written in certain way.
We were talking about interfaces as paradigm rather than language keyword. COM extensively uses the concept the author of the post was describing. Basically passing a ”contract” to the system/implementation. I don't know VB6 very well but, it seems to allow interface inheritance. After that everything is just .dll and name mangling. CORBA did not seem to address the same issues (but I don’t know CORBA at all). It did not seem to give something as mature as COM either. Visual Basic and Visual C++ would allow you the use of interfaces (the concept) as we know it, but they are Microsoft Technologies (to some extent). Maybe the concept came from before, but I haven't found conclusive evidence of that. In my mind, it's still link to COM.
Can you explain how? var a = {}; var { i: { dont: { see: how } } } = a; Throws an error.
Type safety and checking are "features" I actually prefer to code without (in frontend at least) but there is also Typescript to help with that. And as far as equality checking, maybe it's my lack of experience, but I find that's not a JS specific issue.
&gt; Littering your code with null checks sucks, for several reasons This is also a vague, unproven statement :-) Care to explain? `var a = something || a_default;` has been a standard JS mannerism since way back then, and it's even worse.
const a = {}; const { i: { dont: { see: how = "foo" } = {} } = {} } = a;
You obviously only write JavaScript though. So of course you’re going to give up after one project in a different language to go back to the language you know already.
oh yes, of course. But that's much less legible and error prone than the alternative. Also, except for Proxies, you could do pretty much everything you do in ESNext in ES5 (as shown by transpilers), the point is whether we can make it less error prone and easier to type with new operators / language constructs.
Perl isn't optimizing anything. They're just preallocating an array, a strategy I mentioned in another thread. This has been measured to death and is a terrible idea. The problem with saying things like "why don't they optimize it" is that that's not a very specific statement. Then you get into moving the goalpost constantly to "make a point," and lose the opportunity to learn. The whole issue about stacks is how to allocate single nodes efficiently in a push/pop environment. Dodging it by allocating a mass of ram is a good idea in a language where you can't do the real thing, but in a language where you can, that's just an awful idea. This isn't an "optimization," but perl people will describe it that way. This is coping with severe language limitations in a least-bad-available way
But you can also define here what the default value is
Why?
JavaScript did not invent hot reloading. Erlang had it in 1986.
&gt; pointing out the fact you're being condescending towards me and everyone else is not an insult False. Also, I'm not. Also, that's not what the word condescending means. You seem to be trying to insist that it's correct for you to behave this way, but at the end, you're still not getting what you're asking for . &gt; You see, these stereotypical asshole engineer savants Uh. I'm not a savant. This is 101 freshman highschool stuff. But keep trying to insult people if it makes you feel better. . &gt; let alone good CS graduates that fully understand the intricacies of this topic You literally can't get into most highschool AP programs without knowing these things. Why are you acting like this is high touch material? These are the literal wheel-rut basics. . &gt; However, as you surely must have noticed, there are people here that actually wanted to have a discussion Yep, and a lot of us succeeded. Let me know when you're done complaining. . &gt; contrary to your beliefs I don't actually want anything from you. Well, unless you were asking questions for some weird social reason, there's some evidence above that disagrees. . &gt; Please do not respond to me anymore Then stop saying things to me.
Yep. But tell a blub programmer that blub is missing something and they'll spend 65 reddit posts explaining to you how bad your personality is, calling you an asshole, and telling you your textbooks are wrong.
I am sure flutter was inspired by Erlang... But nice googling there buddy.
Yea no, I write Java backend and JavaScript in the front end
Mutability is a bitch. JS allows the objects to be changes in a pretty arbitrary way, leaving TS compiler with an impossible task of making unsafe type assertions. Take for instance the following code: type A = { a: string, b: string, }; const a: A = { a: "sth", b: "sth else", }; delete a.a; console.log(a.a.length); This compiles without a trace of error (with strict null checks), but fails at runtime. Another one is allowing arbitrary fields while spreading, which can cause errors when you misspell shit: let a: A = { a: "asdfa", b: "asdfasdf", }; const b = { ą: "asdfasdf", b: "asdfasdfasdfasdf" }; a = { ...a, ...b }; Typescript allows that because it's valid javascript. This also leads to the typing issues: a.getOwnPropertyNames() doesn't return you the type of keys of `A`, but a plain `string[]`. Why? Because JS might have set some new properties on the object.
I don’t need to google. I’m aware of history.
Work continues on improvement UI Email Signature Generator - [https://github.com/antonreshetov/mysigmail](https://github.com/antonreshetov/mysigmail)
But I bet you wish you wrote Node on the backend :(
I'm experimenting with a JavaScript visualizer as a documentation tool [https://poet.codes/e/mq2PoRVJ4CG/frame/1300px/930px](https://poet.codes/e/mq2PoRVJ4CG/frame/1300px/930px)
Also the choice to go with structural typing can lead to issues, for instance if you spread an object you might accidentally end up with a property you didn't want (maybe because you misspelled it somewhere). I've also noticed that even with strict nullity checks you don't get errors when deleting a property, I'm pretty sure it has to do with the property resolution and the fact that delete can fail at runtime, but it's still a bitch to find.
No it really doesn't need a standard library. And namely for two reasons. One is more generic, other is language specific. I would go as far to say that it would make the language worse on the long run. 1) standard libraries make language as a whole more inertic by coupling certain type of code implementations to the language itself. It increases maintenance cost of the language to a high degree and makes very hard for the language to maintain BC promise while keeping itself relevant. For languages which are not driven by a rich companies which have vested interest in keeping the language updated like Microsoft C#, Google Go, this is a death sentence, because maintenance becomes virtually impossible. And no, before someone suggests, there is nothing about std libraries which makes them better in terms of quality than distributed libraries can be. And std libraries are subject to bugs, security issues and poor implementation as any other piece of code. It just has this aura of "official" which makes it feel safer and more accessible. Std libraries get outdated and unmaintanable as well, and once they reach that point, there is no way but to reboot the language like Python 2 -&gt; 3 did. Or how Go 2 will become a thing. Only actual benefit std libraries provide is that it's more convenient to use. And that's pretty much it. And on my book is not worth sacrificing both, power of the language and it's flexibility, which it must retain given that JavaScript runs on platforms which change very rapidly, and has to retain that ability to keep up. It's not the language which is "wild". It's the domain itself, JavaScript simply keeps adapting fast. 2) for js specifc reason, JavaScript isn't really a language which can do some heavy computations on it's own. That's why most of the heavy lifting done in the web is by the browser or in case of Node by C++. What JavaScript is amazing at, is how it can delegate tasks to those API's efficiently by utilizing the event loop and when get back to collect the results. Javascript is the layer which wraps the underlying functionality in an efficient way, rather than doing things on it's own. That's why JavaScript finds so many places it can be used, because it doesn't really care all that much what it wraps. Is it browser? - np. Is it node c++ ? - np. Is it deno Rust ? - np. Those platforms it runs on serves as your de facto std library, there is no point bringing your own.
Okay, I think we got off on a bit of a tangent. I am still not sure what you are implying in your comment. That arrays in Js can’t be optimized or that you cannot implement say a priority queue in Perl? You can implement any data structure you want in Js or in Perl or in most of the current popular languages. I agree that certain problems require solutions which are not available in the standard library. That’s why people study CompSci and algorithms so they can see that and have an idea for more optimal solution. And also how is implementing an O(1) unshift operation on an array not an optimization. Of course there is a drawback that you have a bigger space complexity but it is always a trade off in most data structures. For the record I am not a Perl person I just happened to use it for a project and was looking for performance of the different array operations and stumbled upon that discussion.
Yeah.. but some points are good :)
I think Constraints Handling Rules will do the job, and there is a js implementation for them https://fnogatz.github.io/paper-now-chrjs/
Maybe they'll provide that later in the year. pdfs or epub don't provide traffic to their site, nor do they get a chance to show their courses offerings.
&gt;When it can mistakenly be read as "here are some algorithms you must know for an entry level frontend job" it just wastes people's time. I don't think OP should be expected to waste his time catering to people who make absurd assumptions like that.
For what it's worth it was interesting to read your comments. There are always things we forget we knew as well as new things to learn. My computer science background proper is limited, but experience with lower level languages does teach you important things about how higher level languages abstract. The point about memory thrashing if an array is used as a stack really struck a chord. I've had similar experiences with other communities, I tried helping out on the excel subreddit, but found them to be unbearable when a non standard approach was mentioned. Here we should all be willing to learn what the limitations of our tool are, and when that will matter and reaching for a different tool is the answer.
[removed]
I agree. Thank you for trying to help establish a culture like that. I feel that it would be an improvement
&gt; That arrays in Js can’t be optimized or that you cannot implement say a priority queue in Perl? Neither. Also, a queue is very different than a priority queue. You just made an enormous switch without even noticing it. 1. I didn't say arrays in JS couldn't be optimized. I said that what you're describing is not an optimization, but rather perl people coping with perl problems. 1. I did say that the thing you're requesting from arrays is, in general, not possible, because arrays like all datastructures are a set of chosen trade-offs, and you're explicitly naming one of the things arrays do poorly as "the thing you don't want." That's not how datastructures work. You can't just magically optimize their behaviors away. You use a different datastructure, instead. If these things could be optimized away, it would have been done ages ago. 1. `You can implement any data structure you want in Js or in Perl` Respectfully, if you're accidentally switching between major datastructures in discussion, *maybe* this isn't something you're ready to argue? No, you absolutely cannot implement most datastructures in Javascript. You can implement containers, instead. They're extremely different. &gt; I agree that certain problems require solutions which are not available in the standard library. That’s why people study CompSci and algorithms so they can see that and have an idea for more optimal solution. That's like saying "I agree that you can't go faster than light speed in certain vehicles. That's why people study computer science, is to go faster." That's the exact opposite of correct. Once you study the relevant science, you will understand that what you're discussing is a hard law that cannot be gotten around. . &gt; And also how is implementing an O(1) unshift operation on an array not an optimization. Because that's not even slightly what preallocation does here. . &gt; For the record I am not a Perl person I just happened to use it for a project and was looking for performance of the different array operations and stumbled upon that discussion. Please understand that homeopaths stumble on discussions in the effort to understand medicine, also. And they also get angry when you say "that's not how this works," and respond by making vague allusions to *the smart people* who are studying to change things. You will never get around allocation thrash costs on an array. The second you do, ***it is not an array anymore, but something different.*** You can't get around a car's limitation to drive on the ground by putting wings on it. By the time you're done, it's not a car anymore.
The Java and C# developers are just jealous.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [Learn C and its lower level interactively, in your browser - Part 4: Variables](https://www.reddit.com/r/coding/comments/bfcxsg/learn_c_and_its_lower_level_interactively_in_your/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I don’t think there is a strong casing convention for JS files out there, so I think you are free to do whatever you want so long as it’s consistent. I prefer the look of kebab-cases filenames myself, with snake_case a close second.
Thanks, I think I will consider snake\_case in the future. I mainly went for kebab because it seems to be the convention for NPM package names as well. So imports of application files and external modules look consistent.
Whenever there's no clear answer in programming, the correct answer is to follow the herd. Not because the herd is right, but because if there's no clear answer that's because there's no clear *correct* answer, and in such cases you're better off writing code the majority of programmers out there would prefer to read. *and the same applies to file names
I’m not completely against optional chaining, I’m mainly saying: be aware of the downsides. I’m appending a quote of my blog post (where I just now added a few sentences). ---- However, this feature also has downsides: * Deeply nested structures are more difficult to manage. For example, refactoring is harder if there are many sequences of property names: Each one enforces the structure of multiple objects. * Being so forgiving when accessing data hides problems that will surface much later and are then harder to debug. For example, a typo early in a sequence of optional property names has more negative effects than a normal typo. An alternative to optional chaining is to extract the information once, in a single location: * You can either write a helper function that extracts the data. * Or you can write a function whose input is deeply nested data and whose output is simpler, normalized data. With either approach, it is possible to perform checks and to fail early if there are problems. ----
Community convention trumps vague "some study (under totally different conditions) said" in my book.
must less legible? I straight up CAN NOT understand it.
But bugs are easier to catch when there's predictability
The study: [http://www.cs.loyola.edu/\~binkley/papers/icpc09-clouds.pdf](http://www.cs.loyola.edu/~binkley/papers/icpc09-clouds.pdf) It found that underscores are a wee bit faster to read (13%), but CamelCase led to far better accuracy (50%), and the differences in reading speed could be mitigated by experience reading CamelCase. The merits of accuracy can be debated. Personally, I find underscores to be awkward to type (US keyboard layout), so I don't use them often. They also remind me too much of my PHP days. And I prefer visually compact identifiers. Fortunately, like the OP, I have the luxury of defining my own "house style." So, I used kebab-case for most front-end filenames (JS, Vue, HTML, etc.) and for CSS classes, and CamelCase for back-end .NET filenames (matching the class name). For both JS and C#, I tend to use UPPER\_SNAKES for non-local constants, and pascalCase for most variables in all languages. But hey, I also use tabs and will die on that hill, so I may not be the right person to listen to... :)
Long C# developer here. Type safety makes development slower (much), but rather scale-able. I'm surprised how fast I can code in ES6 after switched from C#, especially doing immutable via spread syntax. Now TS makes things better by introducing type safety, which can be made optional.
Side note: I started using pascalCase for database tables and fields awhile back. I love it. Combined with UPPERCASE keywords and tabs for visual alignment, it makes my SQL very easy to read (at least to my eyes).
Accuracy claim seems to be dubious at best, as studies which were conducted to confirm the findings failed to replicate that: [https://ieeexplore.ieee.org/document/5521745?arnumber=5521745&amp;reload=true&amp;tp=](https://ieeexplore.ieee.org/document/5521745?arnumber=5521745&amp;reload=true&amp;tp=) Most good studies are behind a paywall though, so though luck.
Yeah, that's what I pointed to my last paragraph too. However, that doesn't change the fact that community as whole is wrong on this issue.
Hi /u/brainhack3r, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/shiftclicky, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle), "Curated lists", and similar content. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Jason_F2, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
&gt; then like a scripting language at other times What exactly does this mean? JavaScript has C-like syntax and capabilities similar to other “non-scripting” languages. The “script” in its name comes from the fact that it was originally used to write small snippets of code to enhance a static web page. I see something more like shell languages or perhaps as Perl as bonafide scripting languages.
Hi /u/mementomoriok, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Repo: https://github.com/cujarrett/glimpse
Hi /u/tastycakeman, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Qwerty1571, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/pverma8172, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle), "Curated lists", and similar content. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/e3n3d3, this post was removed. Posts must directly relate to JavaScript. Content regarding CSS, HTML, general programming, etc. should be posted to their respective subreddits instead of here. Here's some related subs that might be useful: * /r/css * /r/php * /r/html and /r/html5 * /r/webdev * /r/frontend * /r/programming Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/j_orshman, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/AlexAegis, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle), "Curated lists", and similar content. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
I always use lower case. You avoid issues issues between mac and linux when using all lower case. Mac is case insensitive, so importing myComponent, mycomponent, MyComponent and Mycomponent all work. When you move the same code to linux it stops working because those are 2 different files and there is now an error.
Because array is not a queue if used that way.
There's a whole universe of people out there that "actually used other languages" and came to a completely different conclusion: "JavaScript is good at some things that are difficult in those other languages, terrible at some things that are easy in those languages, and I probably need to think about whether JS is appropriate or not before I blindly choose a language." In the end, the same people who write shitty JS write shitty C# and vice versa. That JS is permissive of bad ideas doesn't mean good JS devs implement those ideas. You will still set your own pants on fire if you don't follow SOLID in JS, but you might also find it's a hell of a lot easier to implement SOLID if you don't have to define a permanent, unchangeable interface type every time you write a unit of code. Really it feels like comparing C# to C: JS: "You need an oven to make cookies. An oven is a thing that has a thermostat and a timer. Take the cookies out when the timer calls its callback." C#" "You need an IOven to make cookies. An IOven is a type that has access to an IThermostat and an ITimer. An IThermostat is a type that has a Maximum, a Minimum, and a Temperature property that must be set to an int32 between Maximum and Minimum. An ITimer is a type that has a DueTime property that must be set to a date in the future and will raise an Elapsed event when that time arrives. Be sure to use the dispatcher if you need to interact with the UI, and make sure to unregister your event handler before disposing of the IOven." One of these is appropriate for "I want to write a 500-line script that I'll use once and never change", and the other is appropriate for, "I'm writing an enterprise framework that needs to be maintained for 10+ years by a team that may not include me. Too many developers focus on the context they live in and assume all languages must fit that domain.
The first gotcha "await" is not specific to the chrome dev tools. That happens in all JS files. "await" always needs to be in a function. There is a proposal to change that behavior. [https://github.com/tc39/proposal-top-level-await](https://github.com/tc39/proposal-top-level-await)
This comment has been made about a billion times on reddit. Downvote and move the fuck on if you don’t like reposts. No one gives a shit if you’ve seen it before.
I'm having trouble to understand what it's aimed at. For small applications and web pages microservices serves only to overcomplicate the issue. There is no reason to force complex solutions to simple problems. Now if you're aiming to businesses and non trivial programs, where it typescript? &amp;#x200B; I like the concept, that there might be microservice oriented framework, but I can't grasp what Hyron is trying to accomplish in particular. The "values" part in introduction sounded like political slogans at best too. Perhaps some concise examples with pointing at specific problems might be a better approach.
O wow, shitty phone haha. Sorry that comma looked like a period haha. Thanks for the clarification!
&gt; It’s really not misunderstood. This is from 2001. The world was a very different place back then. I used JS to teach myself programming in middle school in the late 90s, and back then *nobody* took it seriously. If you ever dared mention it online, you'd get yelled at that it wasn't a programming language it was a scripting language and therefore you were a loser and a poser.
Why is this called virtualization and not just an emulator?
I have used camel casing for filenames for a LONG time and it is, IMO, so superior to other methods that I have no intention of ever going back.
&gt; especially doing immutable via spread syntax ...that genuinely never occurred to me. I still wish the language had some form of immutability built-in, but that's actually not a bad solution. Thanks!
Fair enough. That's not explained all that well. What I should've said is that it can use whatever paradigm you want at any point during the execution of your program. OOP, FP, or PP take your pick. That kind of flexibility is unparalleled, and is one good reason why js has stuck around for so long.
This isn't very big problem though and the same pretty much applies to C# and java too, as you can still access private properties using reflection.
I thought you had a valid argument but it seems you are only arguing for the sake of arguing. Pointing things out of context and they blabering about generalizations does you no good. Obviously there is no point in arguing with you anymore as this wil lge me nowhere haha but I am still confused as what do you mean by: &gt; No, you absolutely cannot implement most datastructures in Javascript. You can implement containers, instead. What the fuck is a data structure if not a container hahah
First of all, thanks for your feedback The fact is still in the early and incomplete phase. I will soon build articles to show its advantages compared to other frameworks I also orient it to support for typescript (just that I haven't worked with it before) Hyron orientation beyond a framework is only for nodejs like other frameworks, but I orient it to become a common framework that you can build applications in other languages ​​such as pluggable services in (I call it central management for microservice). It can bring a much simpler approach to the present, and high flexibility, allowing you to build powerful addons to automate the process. I expect in the near future we can build applications by drag and drop, maximize automation and more efficient reuse from the community :))
&gt; "You need an IOven to make cookies. An IOven is a type that has access to an IThermostat and an ITimer. An IThermostat is a type that has a Maximum, a Minimum, and a Temperature property that must be set to an int32 between Maximum and Minimum. An ITimer is a type that has a DueTime property that must be set to a date in the future and will raise an Elapsed event when that time arrives. Be sure to use the dispatcher if you need to interact with the UI, and make sure to unregister your event handler before disposing of the IOven." Not a C# dev here, but Java is part of my toolkit (I don't believe in restricting my skillset to one language). I see this _so often_ in the Java world because plenty of devs simply inherited the "put everything behind an interface" mindset without actually thinking 1. what it's for, and 2. whether it's needed. These same devs then design a huge clusterfuck of class hierarchies for no good reason other than "that other class needs a different config" and team productivity and joy take a hit. At the end of the day, managing complexity and designing fit-for-purpose software requires some thinking, and a shitty dev will write shitty code, whether in Java, JS, C#, or whatever (although a shitty C dev is far more dangerous than a shitty JS dev). Modern Java (like, past Java 9) has actually been gaining some features from JS, just like JS has been gaining some features from Java. Languages evolve, even C and C++, and devs who say "x language sucks" because their last experience with it was 10 years ago... well, it says more about the quality of that dev than the language really.
thank bro :))
Thank you, @helloworldjs for the headsup. The proposal (https://github.com/tc39/proposal-top-level-await#solution-top-level-await) really interesting as it'd let the module resolution system to handle promises. It does have some issues of itself (https://github.com/tc39/proposal-top-level-await#faq) but let's see how it goes 🤞
It's more about the buzz and brand knowledge than generating traffic imo. Moreover, last three years in a row there was an option for file download, which was provided by a platform ([gitbook](https://legacy.gitbook.com/@frontendmasters)). Something's changed now, probably.
&gt; 4) Non-nullability &gt; Null is ridiculous. There are languages that don’t have null, and there are languages that allow you to deal with them explicitly via Optional types. Either way it’s better than having null. I don't know. Optional-spam is a thing in Java and causes more problems than dealing with null. Been part of teams that got burnt on both sides before, so I'm a bit wary of statements about null values being ridiculous - in my experience, handling the "no result" situation requires special attention no matter what, and I haven't really seen a universally acceptable way of doing so (without dubious trade-offs).
I use JavaScript only with Typescript, everything makes sense to me and I think it’s a great language! With typescript you can have a little more safety and be more productive. I even like it more than C++.
We're not quite agreeing. You assume that some random study that almost certainly wasn't done on JS code or file names proves that everyone should use snake case everywhere. I think that's far from enough proof to even come close to indicating that one choice is better than the other, and therefore that this *is* a case where there's no clear "better" solution.
Would you care to explain why you find it superior? Otherwise I have no idea what you mean by that.
I open-sourced my email alias app Ptorx: https://github.com/Xyfir/ptorx
So, while you're not wrong, and I doubt many who have only JS experience will take kindly to it, I wonder what the purpose of your answer is? Put it this way - if someone's only language is JS, then why stop him from at least learning the theory and (theoretically) implementing one in JS? With time, he might figure out that that's not how JS works under the hood and get curious about the inner workings of memory and instructions in different languages. If not, eh nothing lost. It's more productive than just going "no that's not possible in JS, you should do this in C" because a JS dev is just not going to pick up C just to implement a linked list properly. If your response has a better motivation than just being right (because that surely is worth a lot on the internet....), then there are probably better ways of achieving that. Either way, I don't know why I even wrote this, but I hope I never catch myself responding like this in real life when a fellow dev wants to learn something.
Well, it handles so many edge cases better than other alternatives. Usually, I have my bash set up to do case insensitive auto-complete on tab... but when I'm temporarily somewhere without my bash settings I know I can always just start lower case and get most of the way there. I, generally, don't like spaces, dashes, or underscores as they are harder to type. However, if you were simply to use all lower case letters (without spacers like those) it would be hard to distinguish the "words" and that's where the camel casing comes into play. thisIsAFile.txt Plus, I'm a developer so reading camel-cased things is quite "normal" for me. So, my "method" is not all that different than OPs except I don't use the dashes.
Transpiler can emulate private properties in various ways that make them functionally equivalent, e.g. using closures or symbols. Babel has shown that the dynamic nature of JS makes it possible for transpiler to accurately emulate almost all features.
This was written to address my (surprisingly) recurring need to create dynamic regular expressions. If you like it and have need, please use it!
EVERYONE USE TYPESCRIPT NOW! (My company is switching to Typescript and too many intelligent engineers in my org are for it, for me to stop it. Many of them even sympathize with me... but Javascript isn't a language for most people, so we must err on the side of stability.)
I mostly agree, but in this case I feel that the pros of using lower case filenames do make it a better choice if there are no clear cons. Sometimes the herd still needs to get educated too. For example if you look at starter kits and code examples they almost always group files by type. I think this was popularized by Ruby on Rails. That doesn't mean it's the right way to structure your app. For simple examples it makes sense and you often can't group by feature, but because most developers learn from these examples most web projects I think do not structure files properly. When React was introduced its paradigms also clearly broke away from the herd. But it needs to be a conscious decision of course.
This phrase is meaningless on it's own.
&gt;is pretty quirky EVERY language is quirky, usually much more so than meets the eye and absolutely much more than it's likers would have you believe. With all languages, once you get past the basics (for loops, arrays, basic functions and objects, etc), there's usually ***plenty*** of weeds to get stuck in "why the hell do you. . ." To contend that JS is "more quirky" than anything else bypasses this reality. Aside from that, people arguing about the better programming language . . . you may as well be arguing about your favorite color.
Yes exactly. That was the first point I was trying to make.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
I came from loving C++, begrudgingly doing PHP (IMO the best scripting language companies were willing to use), to liking Javascript, but preferring C++, to LOVING javascript as it becomes increasingly more power and with incredible tools like Redux. I only got deeper into JS 5 or 6 years ago and although I think Rust may end up being a better language, it serves a wildly different purpose from Javascript, and meanwhile Javascript is (IMO) the best language for almost every situation. Not arguing, just saying, someone who's been working in the industry for over 10 years and has worked in many languages, thinks Javascript is one of the best things to ever happen to software development.
People are downvoting because you were wrong. If you use wrong data structures, you your 1ms task to 2000ms one. No one talked about "high performance realtime timing sensitive backends" except you. Just because some O(n^2) algorithm would be too slow for your task, doesn't necessarily mean that js was a bad choice.
Heck ya!
What did you Talk.Factory.Template.Generic.Say.Instance?!
You like Typescript more than C++? Anyways Typescript is an awesome compromise for the people who aren't a fan of the wild west of Javascript =P
Personally I don't mind typing the dashes. My terminal auto completes them, it's relatively rare that I create a new file, and import statements in vscode also auto-complete. Also because of the barrel files I mentioned in the end, I mostly don't have to write the filenames in the import statements since I import from the parent folder and group names tend to be just one word.
Sorry but it doesn't. He was cited multiple sources claiming otherwise and he couldn't find a single source agreeing with him. By his definition even Java and C# don't LinkedLists.
I think it’s a cop out to say that if the code gets shipped, everything is fine. By that logic we’d just throw code at the wall and if the UI looks fine, end of story. Code can always be shipped. That’s not the point. The point is there are things that languages allow you to do that make our lives way harder than necessary. Software is barely out of its infancy. We got a lot of things right but we most definitely got things wrong too. Or things have just changed - we have CPUs that are millions of times more powerful than a couple decades ago. So I think re-thinking standard language features is totally on the table.
Can you explain why there's not a single source agreeing with you then? Maybe you should publish your paper since you've made a new definition for linked list.
Earth is shaped like a banana. Don't ask for evidence, if you don't agree you're an idiot. /s
Yep agreed 100%. It’s very subjective. But the article said JS is “misunderstood.” I don’t think that’s true at all.
There’s no shot that Optionals cause more problems than null.
&gt; My terminal auto completes them, it's relatively rare that I create a new file, and import statements in vscode also auto-complete. Only if you have the settings that make them do that. Bash, by default, won't... for instance. Now, normally that's no big deal as usually you are in your own terminal with your own dotfiles. But all it takes is a quick sudo command or sshing into another box without your dotfiles to realize that all that wonderful tab completion you were counting on is GONE.
&gt; Can you explain why there's not a single source agreeing with you then? For the same reason that there isn't a single source disagreeing with me. Nobody's gotten any. . &gt; Maybe you should publish your paper since you've made a new definition for linked list. Thanks for the sarcasm. This definition does not come from me, though. And, since some guy published the private mail where I sent him the sources that he asked for and never actually checked, you can read that to find it. All my publishing is years in the past. I'm long out of college now. Thanks though
We shall call it FINDarkside's tree from now on. Linked list is also FINDarkside's list, because you don't have real pointers in js. Quicksort shall be named FINDarkside's sort, because it can't be implemented in js, as arrays in js differ greatly from arrays in c++.
Yea I like it more, imo typescript is flexible and easy to use. C++ is getting bigger and bigger and more complex each year. Currently I would definitely choose Rust over C++. I used C++ for a long time it was even my first language I have ever used and I still like some of the stuff and I really appreciate classes and the way how they are implemented, because I think it is better than C# or Java (but those are languages for itself). Anyways today I’m much more into web development and I love to use JavaScript with Typescript, I use Typescript anywhere I can. So for me it is Js+Ts=Web, Python for Algorithmen and Prototyping and Rust/C++ for hardware or graphics. And yes you can use Rust for Web as well, but I am not a huge fan to bring so much complicated stuff to the web, because the web is already complex.
Sorry but this isn't true at all. Slow algorithm is slow even if you write it in javascript.
But he's also claiming that you can't implement linkedlists in js as there are no real pointers.
&gt; Typescript is only as powerful as the JS allows it to. Yes, though somehow it allowed Typescript to have the most powerful static type system of any mainstream language in use today. Ironically, probably due to Javascript's dynamic nature.
&gt; So, while you're not wrong, and I doubt many who have only JS experience will take kindly to it, I wonder what the purpose of your answer is? Because the original asker did. . &gt; Put it this way - if someone's only language is JS, then why stop him from at least learning the theory and (theoretically) implementing one in JS? Because the theory cannot be taught in JS, because JS doesn't have the tools to express it. It's a little like why, if someone's only language is SQL, you try to stop them from trying to learn user interface theory. Or why, if someone's only language is Java, you try to stop them from learning cache coherency strategy. Or why, if someone's only language is assembly, you try to stop them from learning about ABIs. Or why, if someone's only languages are HTML and CSS, you try to stop them from learning big O notation. Programming is in some sense a direct expression of the whorf sapir hypothesis - a language that you speak gives you a set of tools in which to think. If your language is Pascal, you have absolutely no basis for understanding a query planner. Don't try. If you try, you'll put together a whole bunch of metaphor, and you'll have to un-learn that (which is rarely actually possible) before you can learn the real thing. Everyone's acting like this is an attack on Javascript, but this is a truism of all languages. Languages are a collection of trade-offs. Either you do this, or you do that. You can't do both. . &gt; With time, he might figure out that that's not how JS works under the hood and get curious about the inner workings of memory and instructions in different languages. Do you realize that what you're saying is "don't tell him what correct is, on the chance that he might discover his error on his own, get curious, and try to teach himself from scratch?" . &gt; It's more productive than just going "no that's not possible in JS, you should do this in C" because a JS dev is just not going to pick up C just to implement a linked list properly. That's your opinion. I disagree. My opinion is that the practical, productive thing to do is to inform someone that they have an error. If they are interested, they can ask, and then you get into a discussion. The problem is that in certain communities, that will attract ne'er do wells who think they know more than they actually know, and try to establish their might with mockery, abuse, and downvoting. This doesn't happen in most programming language subreddits, and did not used to happen here. This is specific to `/r/javascript`, and is recent. . &gt; If your response has a better motivation than just being right (because that surely is worth a lot on the internet....), then there are probably better ways of achieving that. I am not actually interested in your counsel on this matter. I've gotten into more than a dozen extensive positive private conversations on this topic following the programmers who actually wanted to learn seeing me say "I don't want to say it in thread because of the abuse," reaching out in private, and getting high quality discussions as a result. You are working from incomplete information and guesswork. Your guesswork about my motivation is incorrect, and your attempt to impose your opinion of what is "better" or "worse" in my motivation system is inappropriate. . &gt; Either way, I don't know why I even wrote this That makes two of us.
If I ever return to C# I am very tempted to try writing it that way and see how it goes.
What's wrong with `getOwnPropertyNames()` returning `string[]`? Objects only have string keys
I'd love for these to be `keyof A` or something like that.
Re-read /u/mort96's comment carefully. The end. What is he talking about? That's what I was answering to.
He was talking about back-end.
Per the package.json, the license is [ISC](https://opensource.org/licenses/ISC).
It took me a while to realize i had to click that circle in the bottom right corner to see anything... but this is way more than i was expecting, great work!
&gt; For the same reason that there isn't a single source disagreeing with me. We have already posted multiple ones. You don't have sources at all. "I've read it somewhere, don't remember where" is not a source. Should Java and probably majority of programming languages rename their data structures? It must be rough when the whole world got it so wrong and you're the only smart one. Take care.
&gt; put everything behind an interface Correct me if I'm wrong, but I believe the core of this came from Unit Testing before reflection became a thing and even then...You throw everything behind an interface so you can stub out everything later.
Then I still think you'd have some very high traffic expectations for JS/node to be impractical.
Just after reading your readme, that sounds amazing. Seriously well done.
I did. He talked about backends where O(n) solution is too slow and O(1) solution is available. Doesn't necessarily mean that js was the wrong choice. Your argument is basically that if your car isn't fast enough on the first gear, you should switch to faster car.
File naming is a team decision, so have fun with that. An aside, though: barrel files can (but won't always) ruin tree-shaking. Pay close attention if you care about bundle size.
Meaning?
&gt; You avoid issues issues between mac and linux when using all lower case. Issues that are almost always caused by failure to pay attention to file case in your code. Which is a lintable _bug_, whatever your filesystem's rules are.
&gt; I thought you had a valid argument I didn't have an argument at all. I offered a piece of information to the original posters. Now I'm just sitting here responding to a dozen people telling me what a bad person I am. . &gt; Can you give an example of a data structure and a "container" of a data structure? There is no "container of a datastructure." There is only a container. Datastructure examples include red black trees, b trees, singly linked and doubly linked lists, tries, hash tables, octrees, splay trees, and so forth. Container examples include abstract array, list, associative array, set, map, multiset, multimap, graph, and so on. A few words, frustratingly, are validly both, with distinct meanings in each, such as heap, stack, and vector. I consider this to be a problem. (Stack and heap, in particular, have valid distinct meanings as datastructures, as containers, as hardware systems, as memory allocation regions, as allocator strategies, and as allocator algorithms; they are confusing as piss when discussing things in detail.) The Java standard library gets these terms vividly, frequently wrong. It's agonizing to try to explain this to a Java programmer, because their own language fights their understanding this so hard. . &gt; What the fuck is a data structure if not a container hahah A container is about how it's used. A datastructure is about how it's implemented. By example, the C++ standard library has no datastructures (though several of the vendor specific libraries do.) All C++ has are containers. However, the performance guarantees on several of those containers are so specific that only a handful of datastructures could possibly implement it, so, we're in Might As Well Be &amp;trade; territory C++ says "it has to store data with this general structure, these are the methods you call to get it in and out, and this is how long it will take." That's a container. Most languages have only containers. A datastructure, on the other hand, is "this is how we're actually going to do it." And that's when you're doing the CS thing and saying "it's four pointers to there, and then we keep a list of these and successor links over there, and we tie this hash table in a knot like so, and bang, it's o(1)." A container can be lots of different shit under the hood. A datastructure cannot. If it's a set, fine. That means it keeps either zero or one instance of each of its type items, and can tell you whether it has it, can add and remove, and does a lovely souffle. But I don't know how it's made. It might be a tree, it might be a hash table, it might be a fucking array and `.find` for all I know. (Wait'll you find out how JS implemented set.) If on the other hand you say "this is a van emde boas tree," suddenly I know a ***whole lot*** about how it works. I know how fast it'll add and remove stuff. I know what things it's going to be good at and what things it's going to be bad at. I know how its memory behavior is going to work. I know how much overhead it'll need. Et cetera. The truth is, unless you're making a database, usually you don't even give a shit about this stuff. Javascript has mostly containers. Array, object, set, weakset, map, and weakmap are containers. They tell you how they'll interact with you, they tell you what kind of shit they contain, but you don't know how they're implemented. They could, and in fact do, vary significantly in performance between engines. If you know your shit, you can set up some performance tests to tell what's underneath each one in each browser, though, honestly why would you bother That said, JS does have a few datastructures: the `TypedArray` family (`Int8Array`, `UInt8ClampedArray`, `Float64Array`, et cetera.) Those are datastructures because you know ***exactly*** how the memory is laid out, where values are stored, what positions are, et cetera. That's the whole point. JS has the ability to make custom objects, and there's a long argument to be had around whether they're types. To some extent, you can implement custom containers, despite a lack of things like operator overloading. The API will be a little gross, but it'll work, and then you can do all the Okasaki stuff. But look, *most languages* can't do datastructures. Javascript is one of those.
It's not that JavaScript === bad and Typescript === good, it's that JavaScript lacks the grammar needed allow large teams to work on large applications while avoiding the cognitive overhead of integrating objects from diverse groups. You can sort of get by with JSdocs but unless your teams are all on board and maintaining strict discipline in keeping them updated and correct, rot tends to set in and a quick hot fix here and a promise to fix that doc later over there and now your jsdocs are invalid. For me, the amount of times I'm using a method and the docs say a parameter or return value is some type but it's actually another and causes me to have to analyse the whole code path is far too great.
I’m curious what you’re doing that needs all of these dynamic regexps?
&gt; I am not actually interested in your counsel on this matter. I've gotten into more than a dozen extensive positive private conversations on this topic following the programmers who actually wanted to learn seeing me say "I don't want to say it in thread because of the abuse," reaching out in private, and getting high quality discussions as a result. &gt; You are working from incomplete information and guesswork. &gt; Your guesswork about my motivation is incorrect, and your attempt to impose your opinion of what is "better" or "worse" in my motivation system is inappropriate. &gt; Neither is your information about any of my knowledge correct. I've seen people with your toxic kind of attitude before, thinking they're doing any good to others around them when all it did was drive people away who later flourished elsewhere.
I think leadership in technology can happen in two ways - technical excellence/authority and leadership/management of people. Some leaders are good at one or the other. Truly great leaders are highly proficient in both. My top 5 tips: 1. Know your onions. You don’t need to know every framework, buzzword or hot tech. But knowing how things work and a great grasp on the fundamentals will stand you in good stead. 2. Be a problem solver. This speaks for itself, I think. 3. Love your craft. Whatever you’re involved in - give it your heart and soul. People will always follow passion. 4. Take responsibility for everything. There’s a great book called “Extreme Ownership” by Jocko Willink. It covers everything. 5. Have a heart. At the end of it all, you’re dealing with people. Be kind, humble, empathetic and self-aware. There are so many more tips I would love to offer but those are the 5 that come to mind. P.S - I lead a number of teams: from DevOps engineers to full stack JS engineers, working on multi million pound projects. Feel free to DM me for a chat 👌🏼
I'm the lead developer at a marketing agency on a team of 7. We do a lot of react apps (sometimes Angular) and occasionally do server side JS and of course, as a marketing agency we do CMS work, often with a variety of custom built aspects. Day to day there's task management, ensuring we're hitting our deadlines as best as possible, and trying to keep up with where everyone is at. If someone is spinning their wheels on a problem often I'll switch up tasks and get someone else looking at it. I also do all of the first round QA and review the code for obvious performance or other issues. We're a 7 person team and we don't have a dedicated QA team so it's manageable for now. Bigger picture I am in involved in projects after a certain point (but before it goes into development phase) so I have input on some of the technical challenges and have an idea of priorities and timelines. I'll also assist with building task lists at this point. I also try to keep up with the changing JS landscape and introduce the team to concepts or new features via presentations. I also often lead "pre-dev" meetings where we try to talk through solutions to the more unique or difficult problems. I've been a JS developer for 20 years so usually the biggest thing the team leans on me for are some of the really difficult or tricky problems. So I still do some programming but often my limited dev time is spent on talking through things when someone is struggling or on high level workflow or process type stuff.
http://remotejobs.today
It's not about the language itself, but how one works with it. Working with JS is pretty sweet as the tooling for it is insanely varied and the support for the big players is fantastic.
His example was a back-end that needs to process thousands of requests a second, *or a game that has a 16ms frame to answer*. Your comparison is flawed. My argument was that when you need a car that needs to hit 100mph, don't pick a car that tops out at 110mph with some tweaking.
Thanks :) Check out [sandbox mode](https://vasyop.github.io/miniC-hosting/) if you haven't
Looks really nice, well done! The only thing I don't like (judging from the video) is the table cell width that changes when writing text.
My whole point was that his 16ms timeframe example for a game where GC eats half of it was one of these.
&gt; 5. Have a heart. At the end of it all, you’re dealing with people. Be kind, humble, empathetic and self-aware. This is probably the most important bit. It's no secret that plenty of programmers are a bit on the low side when it comes to people skills, but part of great leadership is about building people up (y'know, your team) and empowering them to succeed.
Hi /u/TheDeveloperDude, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
There are a lot of "non random" studies past Binkley which proves this point. I'm not really interesting debating an argument out of ignorance. Yes, optimally it would be better if people switched to snake\_case for most cases. However, changing it goes beyond what is pragmatic in a sensible way, therefor one is still better following conventions. Also I don't appreciate this attitude you give trying to misconstrue what I've said in order to pick a fight.
No it's not. The reason JS has stuck around so long is because it's the only language native to browsers and therefore the web. If JS had been created as a standalone native OS language and had to competed with Java, C, Python or any of a number of others it would've been dead long time ago. People learned it because they had no choice, and the web has driven everything as of late. If browsers natively supported python at the same performance as JS, Python would've won over the browser market hands down.
I also love this style. Much less shift key.
ElasticSearch.
Do I need another database as well or just es
Every nerd thinks they're right about almost everything. I *guarantee* that if I tried I could find a nerd who could argue just as forcefully for why camel case is "objectively" superior. But, especially *in aggregate*, nerds also prefer to be right for good reason. So if there is compelling evidence for either side of a programming "holy war", whether it's casing, tabs vs. spaces, or emacs vs. vi, over time the "correct" choice wins. That's why we (mostly) do Angular 2 and React and Vue and not Backbone and Ember and Angular 1 now: there were objectively better reasons to use the former, so the herd shifted to them. The fact that you won't/can't provide your "oh so conclusive" evidence of underscores being superior suggests you're just another fanatic who picked a side on a holy war, and upset because the herd hasn't gone your way. But I see it as there not being compelling evidence for either side, and that's exactly why the holy war continues.
&gt; Care to explain? nah, I'm not invested in convincing you or anyone else here of anything. Tomes have been written about it, and I find it hard to imagine any developer with a modicum of experience isn't personally familiar with the issues. Chaining on it's own, aside from conditional null dereferencing, is widely considered an anti-pattern (aside from situations where you derive a specific benefit from chaining, like a fluent interface). Chaining when you might be getting nulls back? Woof. No, I really think it should be obvious why that's bad and encouraging it with an operator isn't clearly a good idea. &gt; `var a = something || a_default;` has been a standard JS mannerism Doesn't mean it's a good idea.
Hi /u/N8Programs, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
This is the best advice that I have seen so far.
&gt; snake_case That's gonna be a hard pass from me, dawg. Underscore is one of my least favorite character to have to type. Slow af.
Thank you for the feedback! I think it would be a good idea if the user was allowed to choose the behavior of the table cell. I plan on adding a ‘Settings’ section where I would add this feature.
I assume people here come on good faith, therefor I do not usually write comments in a way that I should defend myself. I given hints and expected people who are curious to follow through them. Some did. And left a link to original study done by Binkley. I left a response to that a link to another study which tried to replicate the conclusions of Binkley. You can find them by reading a bit through the thread. With time only time changes. It takes people, well, lets say like me who point that there is better case to be made for certain thing. For example, tabs vs spaces, spaces won, the tabs in most editors now leaves spaces instead. That fight is over. Yes some it just preference. However, some people's preference is informed not only by habit but also by factual / pragmatic reasons. In case of spaces, that was formatting of code review tools was inconsistent when reading tabs. Now I'm sure there was a lot of people who tried to downplay it as just "preference". Programmers like any other people subscribe to all sorts of weird habits and rituals. And very commonly the lack of arguments or introspection for that preference is deflected by trying to reduce argument to subjectivity. Or some weird mix of subjectivity and "there aren't bad tool, there is just correct tool for the job". Which doesn't stand to scrutiny when you think of it. Tool makes aren't unfalilble gods who cannot make a mistake or produce crap. Same way it's not correct to blame users who find your app difficult to use due to poorly though out UX for example. But that's another discussion. I also don't appreciate to be called names though.
[https://www.makerspartlist.com](https://www.makerspartlist.com) \- A SSR react app that uses sits heroku and leverages graphql and apollo. I then have a DigitalOcean droplet that downloads the video, creates images and runs my tool classification model on it. Returning a list of all the items it found. It been tough to get visitors though
You can have both or just es. But I think that's an overkill for your task. Lots of modern rdbms has full text search capability. For example, i have used postgres to build a data catalog whth fairly complex filters.
Frontend Lead here. For me it‘s two things. First of all the technical side. As a technical lead you should know your stuff. This comes from being passionate about it (i looooove programming/software engineering) and the experience you have gained over the years. You should be able to handle tasks that may be too hard for others. Secondly, dont‘t be a dick. You‘re dealing with people. They get sick, have heartbreaks, have family drama‘s and are on their own unique journey. They shouldn‘t be afraid to ask and tell you stuff, be it technical or personal. Also most programmers are self-learners and work best with a healthy dose of freedom, so give them their space.
I agree that it's slow. And that's certainly an argument not to use it. I do however, believe that reading is more important than writing for the most part in our profession.
Anyway JS sucks
Yes but in recent times I don't have a team or I would lead the team on these decisions. I just want to make a well informed decision. Can you share a resource explaining the problem with barrel files and tree shaking? A quick search didn't surface anything. I am using named exports only, and re-export with `export * from "./file"` in the barrel. I would expect this to work fine as there are no intermediate variables.
The other comments had great insight. Being a leader can mean a lot of things depending on the company. What I will say is the most important thing to leading a team is radical candor: caring personally and challenging directly.
I’m a team lead and another thing I choose to live by is that leadership !== authority. I try be an “authority” on topics, or in other words when people are looking for a decision to be made, I’m happy to make it. But this does not mean that I hand down orders that must be followed without question. If an intern or a junior makes a solid point opposing the opinion of a leader, and the leader ignores it and gets defensive, all that says is that the leader has a very fragile ego. It doesn’t contribute anything positive to the team. Listen to your team, don’t attach emotions to your opinions. Even though you are the lead, your opinions should be just as defensible as any others.
It will be interesting to see how WASM plays out.
Hi /u/N8Programs, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
First off, I identify as a "nerd" so I wasn't calling anyone names, I was just casually identifying us programmers as a group of people who tend to be smart and hold strong opinions. And second, my *entire* point is that your preference is personal ... not objective truth. So I'm not making a personal attack against you, I'm just saying millions of programmers prefer underscores and millions prefer camel case. I have yet to see strong evidence that either one is correct, and the very fact that there continues to be millions on either side suggests that no individual on either side, no matter how strongly they feel the "evidence" is, is correct.
4. I love that book, I've been trying to live and breath it within our team as well as trying to get others to do so
I love kebab-case too. It's default for Angular
I am going through a similar thing. There are too great books I can recommend: Radical Candor by Kim Scott and Measure what matters by John Doerr. Also listen to all the other people in this thread. Good luck on your journey! There is so much to learn.
Yeah, the most exciting technology right now is Blazor that allows .Net to run on the briwser. It is now an official product. https://dotnet.microsoft.com/apps/aspnet/web-apps/client This makes me so happy as a back-end developer who occasionally has to dabble on the front-end.
He's not saying that you can't implement something with many of the features, more that you'll suffer issues which wouldn't be there in a fully implemented native solution. The issues discussed elsewhere with a queue and the slow behaviour of shift illustrate this neatly. It's an interesting case of where you draw the line, but rather than getting caught up on that look at the differences, when they might matter for you, then what you could do if that need arises. Everyone here is likely skilled at javascript, probably other languages too, knowing when to switch to another language or approach is an excellent skill to hone.
Open sourced this JavaScript project this week, and today was trending in top 5 JavasScript projects on Github. &amp;#x200B; [https://github.com/boyney123/mockit](https://github.com/boyney123/mockit) &amp;#x200B; MockIt gives you an interface to configure and create REAL mocked end points for your applications. Whilst you wait for APIS to be built use MockIt to talk to a real service.
I'm an engineering team lead. While I think there are many qualities to being a great leader, I also think that a lot of them can be done by anyone. Having said that, I took a shot a compiling some of the things that came to mind. **Technical Foundation** The tech lead needs to have solid technical skills. You have to stay on top of your game. Whatever technologies your team works in, try to become an expert. Someone else will always know more about a topic than you (and that's okay), but you should be competent in all key aspects of your team's code. I like to challenge myself my giving tech talks to the team on topics to force myself to learn them well, or write blog posts. All of the usual suspects like technical books and articles should be a consistent part of your weekly workload. **Follow Technical North Stars** Ensure the team is following best practices. Have a team discussion about what you want your "north stars" to be, and then keep the team steered in that direction. It might be robust tests, following SOLID principles, favoring readability of complexity, etc.. But figure out how you can best ensure that you keep your team aligned with what you all decide is important to you. Code reviews are a huge piece of this, and by setting a high bar for your team, you can raise the overall quality of your code. **Help Drive Vision** As a tech lead, you should ensure that your team has a clear vision for what they deliver and how they will deliver it. Then, you need to ensure that everything you do aligns with those visions. It's easy for teams to get side tracked, or go down rabbit holes. Always make sure your team is working on the most important thing that will help you achieve your team's goals. Recognize when others are thrashing or stuck, and help them. **Lead By Example** In everything you do, try to set an example for others to follow. It can be anything from showing up to meetings on time, to putting the effort and time into code reviews that you want others to give, your attitude when interacting with other teams, etc.. This is one of the hardest things to do, IMO. If others look to you for leadership, then sometimes that means you have to put your personal issues of that day aside. Keep the team positive and focused. **Make Others Better** Give others the chance to grow by not trying to solve everything yourself. Don’t just give answers, but work on having discussions that explore multiple approaches. The resulting solutions tend to be more robust and give others a chance to be involved in the planning and problem solving. **Allow Others To Be Right** Leads can sometimes fall into that habit of making all of the decisions, or overruling others because of their title. Allowing other people to be “right” can be valuable in the right circumstances. It can help foster good team dynamics and encourage healthy team discussions. Don’t let your experience lead to arrogance. You can learn something each day from anybody. Be open-minded and humble.
Doesn't work with `null`, either. Those all have to be `undefined`.
The "what it's good for" in the C# world is "if you want any shot of testable design". I don't mean to point it out as a flaw of the C# language. I mean to point it out as C# requiring more ritual than JS. If what you are doing is, at the end of the day, not going to rise to the complexity that requires full application of SOLID principles, then in C# you'd skip a lot of that ritual too. But at the end of the day, the JS would be "a bunch of composed functions" and the C# would be "type definition boilerplate to describe composed functions and the code to compose the functions". That teeny bit of C# overhead is a bother if you're writing something small. But it pays for itself if you're writing something big. Interfaces are for isolating yourself from change, and big projects always involve unexpected changes. Basically it's a lot of words to say they're all good languages if applied to their intended context with their intended disciplines. I'd rather write my sprawling servers in C# and my random throwaway projects in JS. This is the same as it's always been, but used to people said Ruby/Python much more commonly than JS.
No it doesn't. Shift is slow because it's not queue. You can implement queue in js which has constant time first item removal.
Writing only one language is not a good thing. You should know many. Micro frontends are gaining on popularity, so does serverless which allows us to write every function of our backends in language best suited for it.
Nice little parallax effect minimal css and js: [https://codepen.io/sbernheim4/pen/VNrxVK](https://codepen.io/sbernheim4/pen/VNrxVK)
If you think the only thing people love about Flutter is hot reloading you are as clueless in Flutter/dart as you are in C#
Everything a developer says, especially absolutes, has the same kind of clause attached that Magic rules do. In Magic the clause is, "...unless some other card's text changes this rule." In programming the clause is, "...unless we're in a contrived, 'Well, actually...' scenario. I don't mean shipping buggy, unmaintainable code is *good*. But I do think "not shipping code" is *bad* if the sole reason is you're trying to decide which of 10 languages is the best fit. Pick one you can write maintainable code in. Write the code. Ship it. Maintain it. Dirty hands make you right. And in the end, a lot of businesses are running on buggy, unmaintainable VB6 apps written a decade ago. They're still happy and think they got what they paid for. Some customers can only afford a used Toyota Corolla, so it's not worth extolling the virtues of the 2019 Chevy Tahoe to them. I don't like bickering over which thing is technically better. Usually, when a team's doing that, I go write prototype code making both approaches. Lo and behold, the argument fizzles when someone proves which side has a point. Sometimes, there's not a smoking gun. Sometimes both proof of concepts show neither approach is great. At the end of the day, you can pick one or commit to shipping nothing. I can go on and on about the dozens of other considerations, but it's another distraction. Fighting over the minutia of "your customer values shipped code over perfect code" is the same argument as "why would anyone use JS instead of a more rigid language". We may as well add tabs/spaces and which typeface is the superior one to the mix. Oh, and bracing styles, we have to settle THAT before we write a line of code, right?
So to lead the team you absolutely need to be able to un-stick anyone who might get stuck. The problem with JS is that (and I'm speaking as a JS professional who loves it) we are dealing with one of the most hostile ecosystems that planet earth has ever had to offer in terms of technical churn and breadth. Pair that with the fact that many JS developers will make the mistake of underestimating the challenge involved (or will come armed with some preconceptions about JS that are not necessarily true) and you have potentially quite a lot of scope for people making mistakes and quite a lot of work to do as a leader in terms of training people out of those mistakes. &amp;#x200B; Good luck but as i said: know your stuff is number 1 on the list of things.
You're not offending me, I don't have a horse in this race, I find the discussion interesting and it tackles areas I don't need to day to day. I do, however, feel that a lot of the posters here are going with the hive mind and learning nothing. Do you have a link to the queue in O(1)? I'd be interested in reading it.
Some great comments in here 👌 Keep them coming please!
I agree, right tool for the right job. Most of my effort is back-end related, C#/Java, for enterprise software, so JS has never really been necessary for my work. If I can now write C# with a SPA component model that behaves almost identical to React (which is great) then it would make my job much easier as I can do fullstack on my own terms, well, as long as I work on a .NET team.
Curious why one person is merging and deploying code? Seems like a huge bottleneck..
 [https://github.com/swimlane/airdrop-cli](https://github.com/swimlane/airdrop-cli) &amp;#x200B; Easy deployment of ES modules without external connection needed at runtime. I think of it like a deployable faux-cdn (like [unpkg.com](https://unpkg.com)) for ES modules.
If you are looking to be a good leader I would recommend you read The Feiner Points of Leadership. It is not related to technology but I got a lot out of it.
I’m thinking I might just use mariadb but I don’t know how efficient searching g will be with a million records or more.
Personal preference can be informed by non personal factors. At the end of the day everything is preference. However stating that it's preference doesn't exhaust the issue. We can inspect the reasons and factors leading to that preference. As it turns out some factors can be objective. And they don't stop being objective over someone using them to inform their preference or not. So there can be millions of programmers who continue to write camelCase because they are simply used to it. Especially when snake_case has enforcement cost attached to it due to _ being farther away in they keyboard. People will opt for path of least resistance even when it's bad on the long run. A lot of programmers my not like to write clean code and refactor things properly over doing a hack here and there because it's "faster". But we can agree that it's objectively correct to write clean code, which actually makes you faster in the most cases. And I think there is enough evidence. I do trust scientific method in this regard. And given that not a single study replicated results which point to same conclusion is good enough for me. As for name calling I was refering to "fanatic" which was a tactic to label me as unreasonable nutbar in attempt to demean anything I have to say.
This is how I also try to be. But how do you all handle people with strong personality who keep doing what they want? And how do you explain things that are based on experience or personal opinion? For example naming? Or my personal favorite is complexity or performance? I always have a discussion on how to minimize iterations and such. Or try to tell them to not overuse closures etc. And nobody argues that this is wrong. But they simply do it anyway. They think that it is just a matter of milliseconds and don‘t see the big picture. I‘m kind of annoyed of this. I find that they like to work quick and dirty instead of learning how to write good code. And I have another question: how do you motivate your people? I think that the best way to learn is to do projects in your free time. I do not force it, but I honestly and in a friendly way gives them the advice to do so. Because non of them does something in this regard. Instead they are spending time on 9gag. I also showed them that I do other things beside my work. I thought this will motivate them. But this was not the case. So, am I wrong to expect it (kind of)?
O(1) queue works just the same way as in any other language which has queue. You could make it as linked list or by using arrays. With linkedList it's trivial, you simply keep reference to the first element and when you want to delete the first item, you'll simply change the head of the queue. You could also use [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) but again, it works just the same way as in any other language. For reference, here's the [source code of ArrayDeque (Double-ended queue) in java](http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/00cd9dc3c2b5/src/share/classes/java/util/ArrayDeque.java). ArrayDeque supports constant time insertions and deletions from both ends. Java doesn't have real pointers either, so by his logic Java can't have real data structures either. And here's [queue in javascript](https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/Queue.js). Removing from the start is constant time because it uses linked list. But then again, he's claiming that you can't implement linked list in most of the programming languages, so we're just going more deep into the rabbit hole. If it was implemented with circular buffer, he could argue that js doesn't have real arrays.
No one suggested that and JSDocs isn't the only alternative and the Typescript "grammar" doesn't decrease "cognitive overhead" regardless of how "diverse" the "integrating" "groups" are. I'm guessing you're a Typescript ninja superstar?
Just to chime in here; I have absolutely written games in JS, I know lots of other people who have written games in JS, and web sites which used to be full of games written in Flash are now full of sites written in JS. JavaScript definitely isn't the most appropriate language when writing a game, but if you want something which runs on the web, it's the _only_ option (even if only as a compile target for other languages). With hardware accelerated Canvas and/or WebGL, the web isn't even such a bad platform for games, as long as you make sure not to accidentally produce too much garbage.
Jocko Willink is a great person to check out when talking about leadership!
&gt;You can't set a variable to private in javascript. I know it's not the point of your comment, but you actually can now! Private class fields is now a feature of javascript.
I would add that teaching (compassionately, not condescendingly) is the most important part of my job. If one of my junior devs asks me if I have time for a question, or to look at something, the answer is yes, then I approach it from the perspective of me being helpful to them. I try my best to keep it in my head that I need to be of service to my team, not the other way around.
`function colorCode(jq, obj){` `const keys = Object.keys(obj);` `const html = jq.html().replace(new RegExp(\`([${keys.join('')}])\`, "g"), (match, p1) =&gt; {` `return \`&lt;span class=${obj[p1]}&gt;${p1}&lt;/span&gt;\`` `})` `jq.html(html);` `}` This colorCode function will solve your needs. To start, define the color classes in your css file: `.red {` `color: red;` `}` `.green {` `color: green` `}` `.blue {` `color: blue` `}` `/*And so on....*/` Then, you can color-code your text by passing the following parameters to the colorCode function: colorCode($("#phrase"), { e: "red" //"e"s should have the color red a: "blue" //"a"s should be blue l: "green" //"l"s should be green... }); You can input any one character, and a corresponding CSS class to color-code your text.
I have a friend who is going to be leading a team for the first time in about a week and he asked me the same question. The above advice is fantastic but I would like to add a story I told him. I was once reading a D&amp;D book about how to be a good Dungeon Master (I know, I’m so cool you can barely breathe at this point. Stay calm.) The advice that they gave was to understand what motivates each player and tailor your game to whatever combination you have. That turns out to be fantastic advice for engineering teams. Play to your people’s strengths, shore up their weaknesses, and keep conflict to a minimum. A couple of examples: Had a guy on my team who was smarter than me. He could go on for an hour if you asked him to about the language design decisions that separate Clojure from Scheme. He had a strong ability to hold a lot of things in his head. He could also be abrasive unintentionally because he never quite understood that everyone else wasn’t as smart as him. I put him in charge of architecting the middle tier and the data schema. I also had him review pull requests and make notes but he didn’t lead code reviews. Another guy, same team, super social, eager to please people. Hilarious. I had him knock out a lot of tasks that others didn’t want because it made him feel like he made everyone else grateful, and he did. I also had him present stuff and made sure he touched everyone on the team as often as possible, breaking down requirements with others and stuff. He made everyone’s day more fun. My current team I have a good kid who is great at banging out code but also doesn’t want to speak up and will hesitate to reach out if he needs help. I make sure to touch him a lot and go out of my way to ask his opinions in meetings (note that he doesn’t have social anxiety he’s just the quiet type). Learn your people. Be agile (in the original sense of the term) in your people management and let people win with their strengths.
Quickly looking at the code you provided, Looks like you’re passing text variable to .html() but your new variable is called a
&gt; I thought the value pair had to be a string, integer etc. Nope. The keys in your object will be stringified (turned into strings), but the values can be anything you want. ```js const objWithLotsOfStuff = { user: { name: 'Tyler', age: 28, friends: ['Jake', 'Mikenzi'], birth: { city: 'Las Vegas', state: 'Nevada', ssn: 1234 }, sayName: function () { alert(this.name) } } } ```
I tend to use PascalCase for classes, models, and components and kebab-case for libs, utilities, configs, and misc code. If I'm working with partials, it's kebab case with an underscore prefix. PascalCase and kebab-case are different enough that I immediately get a sense for the kind of file I'm working with, and this keeps my imports consistent as npm modules typically use kebab-case as well.
 **In JSON, values must be one of the following data types:** * a string. * a number. * an object (JSON object) * an array. * a boolean. * null. &amp;#x200B; you can continue nesting objects/arrays even further.
France
I’ve see a lot of people giving great input here. If you have specific questions I don’t mind fielding those. Background: Was hired by research professor out of college. Within 3 months was a tech lead in charge of 3 separate teams. The company was building a competitor to Spark so my teams were spread out in diverse areas. * classical ML team working on implementing classical algos * team trying to implement highly efficient distributed deep learning on intel cpus * a team building a “compiler” that worked similarly to Volcano or Cascade and could optimize DAGs from user space into the underlying engine ops I encountered a lot of unique situations during my time at that company because of my age, mix of math/engineering focused team members and our unique tech. I then helped found a company which was subsequently funded for ~10 million dollars. I started as lead architect but now have migrated to be in charge of all solutions architecture and user facing development. Since we are building a compute as a service offering competing with AWS, solutions architecture is pretty critical. Anyway feel free to ask me anything.
Yep, that works. Huge nested objects are extremely common, and JSON wouldn’t really be what it is without them. Any valid object, including arrays, can be a value. Now, my question is how is it working for you without quoting the strings? Did you remove them for the post?
Full stack lead here. Primarily node services with some react for demo purpose more than anything else. Just starting on some React Native proof of concept stuff. My day to day is mostly administrative. I consider my job to be more about keeping my team unblocked and clearing a path for them. Writing code is a much smaller part of my job. I try to take stories that my team doesn’t want. I also try to get people working more in areas they want to, while pushing them out of their comfort zone. My favorite quality of my team leads in the past was admitting mistakes and lack of knowledge and not pretending that just because they are “the lead” that they know everything. So I hope I embody that quality as well.
Thanks for clearing that up !! Couldn't find an answer for this, was searching for a while.
It's weird how you're doing all the insulting and yet I'm the one with the toxic attitude. Please have a nice day
Hi. I should have posted in correct format. I have the strings quoted in the JSON file.
&gt; We have already posted multiple ones. So far, two things have been posted. One is a job interview site that's replete with errors. The other is NIST DADS, which doesn't take a position on the matter at all, but strongly implies the converse. . &gt; You don't have sources at all. Actually, I do, and I told you where to find them. . &gt; "I've read it somewhere, don't remember where" is not a source. Cool. Tell that to whoever said this. . &gt; Should Java and probably majority of programming languages rename their data structures? No. It would do harm to Java to rename their data structures a fifth time, and the majority of programming languages don't have this problem in the first place. . &gt; It must be rough when the whole world got it so wrong and you're the only smart one. I didn't say this either. I said something quite different. Have a nice day.
&gt; how do you motivate your people? I'm working on this one as well. What I'm trying out right now is explaining WHY to do something instead of how. If I can make it a learning experience, and make them feel they understand the lesson, then hopefully that will make them more engaged. I rarely experiment with code outside of work, but I do experiment A LOT with code in my job. I encourage my team to do the same, but to be willing to go back and clean it up if their experiment doesn't work out. I want them to try things out, but I don't want a bunch of tech debt. If doing their thing then having to go back and undo it causes the project to take longer, I'm fine with that. The value is added when they learn new things and gain more experience. It adds better quality in that developer's code over time. What I'm struggling with right now I'd that one of my guys... He's so damn nice, and quiet, and nonconfrontational. I'll show him new things or make suggestions and explain the why in detail, always making sure to ask if he's following along, or if anything is unclear (sometimes I have a habit of being too technical and not conversational enough). He *always* says yes. It isn't until days or weeks later that I see his changes and realize he really didn't understand. Maybe he knew he didn't and didn't want the confrontation, or maybe he thought he did get it. It's frustrating, but my main desire is to get honest feedback from him if something isn't making sense.
As shown by your responses so far, I am sure you are an expert in your field. And how am I clueless again?
Offline calculation of continuously compounded interest rates for accounts featuring both deposits and withdrawals is computed over a time period specified by the user via an interactive gui. Complete support is provided by plain vanilla javascript and css.
Were you born in France?
Yes why?
&gt; The other is NIST DADS, which doesn't take a position on the matter at all, but strongly implies the converse. But it does. You claimed that linked list requires native pointers. But here's the definition in NIST DADS: &gt; Definition: A list implemented by each item having a link to the next item. It also explicitly links to C# and Java implementations which simply use objects that reference to previous/next node. So yes, it explicitly is against what you claim.
I never used the words "native pointer." That actually means something, and is not required here. Yes, as long as you use just that one sentence, and remove everything else, it looks like there isn't a problem. Have a nice day
Wow you took that a little too personally. Do you want to try again with something a little more constructive than attacking the way I talk?
My favorite line: "JavaScript was not developed at Sun Microsystems, the home of Java. JavaScript was developed at Netscape. It was originally called LiveScript, but that name wasn't confusing enough"
It's always good to have a dedicated DevOps person who focuses solely on repo maintenance + code deployment, to avoid lazy devs skipping procedures and end of day tiredness.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
I take this as you've finally accepted being wrong. The definition is just that one sentence. And I also read the rest of it, which again, link to C# and java implementations which work in a way that according to you isn't a real linked list.
clueless in English too?
&gt; I take this as you've finally accepted being wrong I'm sure you do. Have a nice day.
Do you not do code reviews? If most of your team is on the same page about best practices, it should prevent people from ignoring the rules. We also use strict linting configs and code quality checks in CICD. Strong opinions need to be backed up by real reasons if they are going to be a part of the team’s strategy. We definitely try to discuss this stuff during the hiring process as well, if you are a steamroller who can’t play well with a team, you ain’t getting hired.
I will try it like you but only if they clean up after the. This was a good advice. Thanks. Haha this is truly funny because I also have that guy. What helped me was to do a review day in private, only with my developers. Without the Manger and such. But I announced it one day before this meeting and wrote down the questions and told everybody to think over night what he wants to say next day. So I kind of made up a good situation where everybody was honest and could speak up. And after I told him that he says to often yes and amen to everything, other team members joined me too. But everybody was friendly and respectful. And he was not afraid to explain why. I don‘t want to sound racist but he is an asian guy and this was a cultural thing after all. I think it helped us a lot.
As a corollary to this, one thing I do as a lead is every now and again, even if I know the option one of my team proposes isn't the best answer, and as long as it's not a hugely consequential thing, I'll give it to them anyway, let them try it. Sometimes, they manage to make it work, which gives them a deserved feeling of accomplishment (and, usually, they come away saying "okay, it worked, but probably X would have been better", which is where I nod my head knowingly). Sometimes, they fail as I expected, and it becomes a learning experience (and when this happens, I'm very careful to give them encouragement while educating about why it happened and what would have been a better option and why). And, you know what? Every now and again someone surprises me and it works out better than the "right" answer because, hey, nobody's perfect, certainly not me, and I don't get things right 100% of the time (that scenario is, frankly, exceedingly rare, as you'd expect from an experienced lead, but I always leave room for it because it's not impossible). This also helps humanize me in their eyes so that they aren't shy about making suggestions and asking for help because while they recognize my knowledge and skill, they rightly don't view me as some sort of ivory tower god that they need to fear. It's a minor strategy that has worked out quite well for me over the years. Honestly, one of the things that gives me the most pleasure in my work is seeing someone I mentored, years later, being a solid lead and demonstrating a lot of the things I tried to instill in them. Some people worry about their own job security in those situations, but those are exactly the type of people who shouldn't be leads. It makes the days I struggle to get any "real" work done feel very worth it because you come to realize that at a certain level, a person's ability to enable others is probably more important than what they themselves can do on a daily basis.
100% I do this as well, sometimes it’s tempting to just tell them the way to do it, but it’s better to show restraint so they learn more.
An interesting repo, very easy to follow, even after a couple of beers. I am, as previously noted, comfortable with the idea that it'll deliver the functionality for use cases I'm likely to encounter. It's also interesting to me to think about what the limitations are. One piece of code I improved recently required some understanding of how v8 manages objects, that edit gave small improvements for our use case, but in others it would be major. If I'm always looking for things like that I can help my team and write better code.
Agreed on having a dedicated devops person. They should own setting up infrastructure and setting up an automated deploy process. They should not be “maintaining the repo” or the one deploying the code. Everyone on the team should know how to merge code and should be able to deploy code (after a PR and tests pass of course).
 You are kind of pathetic now, but okay... Have it your way
I'm a js backend hobbyist, so my opinion may be a little bit biased, but here we go: So, I've coded on the backend with PHP and node.js, and javascript definitely beats php hands on. PHP has a poor codebase and standard library, and while powerful, is clunky and inconsistent. However, if you want to simply host a webpage from a server, php could be the way to go, because it can be embedded inside html. &amp;#x200B; However, for more advanced functionality, go with node.js. If you want anything beyond basic webpages and REST APIs, PHP will begin to fail you. Node.js comes with an amazing package manager called npm, and a decent core library. It has a steep learning curve, but once you get rolling, it's really fun. For example, here is a multiplayer game I built with less than 1000 lines of node.js: [http://multi-galaga.herokuapp.com/](http://multi-galaga.herokuapp.com/) People talk trash about node, but it is a great framework for medium sized projects. Not to mention it has nearly 1 million different packages available for use. There are also a great many libraries to help you. If you are thinking about doing server-client communication, then node.js will be great your entire app will be in javascript. However, node.js isn't the best backend language for huge projects. No matter how well you write code, javascript will begin to stumble around one hundred thousand lines of code (no typing, lousy function parameter enforcement, etc.). So, if you want a project that big, you either should go with python on the back end, or, if you like javascript, try typescript, a typed version of js that can support huge projects.
I've done plenty of back-end development. Mostly C#, Java, and Node.js, with a bit of F# as well. I think using JavaScript on the back-end via Node.js is a perfectly fine choice. JavaScript isn't perfect, but nothing is. Fashion trends in our industry swing back and forth like a pendulum. Sometimes dynamically typed languages are in vogue, and sometimes statically typed languages are. I remember in the 90'ss when Java was the hot new technology that everyone wanted to use. But then developers started to end up with PTSD due to being forced to work on J2EE monstrosities. And for a while, Ruby on Rails and Django (along with Python) were the hot new thing. Node.js then came along. Lots of developers moved firmly into the dynamic typing camp, and many blog posts were written on why it was superior to Java's rigidity. But familiarity breeds contempt. And after some Rails and Django systems grew huge, developers started to feel the pain. The same happened to a similar extent on Node.js apps, although Node developers in general seem to have focused more on creating smaller services instead of monolithic apps. And so the pendulum has swung back in favor of statically-typed languages, and we now have awesome options like TypeScript we can use. My hopefully unbiased advice: if you're comfortable with JavaScript, use JavaScript. If your application gets big enough that JS starts to become painful, start migrating to TypeScript. Keep in mind that the majority of people who complain about languages on the internet never actually ship anything complete, because they're spending their free time complaining instead of creating things. No solution or language is perfect. Pick what works for you and go create something great with it.
I co lead a team of 5 full stack developers. I've found the most crucial thing is to listen, much like others have said. As a small company we specialise in a number of frameworks and technologies - but crucially if one of our team has something they can bring, we take it on board. It's not us dictating what to use, or how to use it, it's very much a team effort.
well, you should probably get your SSL issue fixed. You are using the wrong cert. anyways JS get trashed because 1) The barrier to entry is low, so there are a ton of bad JS code out there, along with terrible JS devs. 2) A good proportion of the JS spec is terrible, weird, and illogical, so the "good practice" is only to write in a subset of the language. 3) A decently sized JS codebase is not very maintainable. That said, it is possible to learn the good practices, and given that JS is an amazingly dynamic language, you can write some very produtive code with it. This will take time however, and a systematic approach to studying JS is recommended, you will have to learn every part of JS, and especially the bad parts. If JS is your first language tho, I would recommand that you learn something else simpler first, like Go. Nobody disputes that Go is a good backend language, and it's got a compiler that will scream at you if you make mistakes (JS will sliently fail at alot of beginner mistakes, so you won't even know that you are wrong). Plus, Go is alot simpler than JS, and infact, decent Go code does resemble the "good subset" of JS.
Exactly. Also, I think it’s important to talk about what a compiler *can* optimize. The compiler will only optimize an algorithm written in a way that provides strict guarantees about its behavior. E.g., the logical flow of the program might logically guarantee that a specific function will only ever take a single constant integer as it’s argument. So you can potentially optimize the function’s internal operation, if it can guarantee a perfectly consistent output. The problem is, the compiler often has to account for an open-ended set of possibilities and edge cases in your algorithm. So it can’t perform an optimization that would eliminate some of those possibilities, because it’s much more important to make sure everything is executed accurately and deterministically with respect to the original code. Most of the time, these prerequisites for optimization are not obvious to the programmer. And many times you could change one subtle aspect of the algorithm, and completely wipe out any chance for optimization. ... which is why premature optimization is a bad idea. You can never be totally certain your code will get optimized by a compiler, especially if you’re still actively making changes to the code later on.
I lead a team of javascript developers and have done it in the past also. I am not a great leader by any means, but here are some things that are very important in my experience. Have goals. This has to be aligned with company goals of course, but have every developer drifting without a clear goal can be very challenging. Each person will come up with it's own expectations or will feel frustrated that they don't know where they are going. Feedback opportunities. Have 1-on-1 meetings or other formats where you can give them feedback on what they need to improve, praise on good things that they have done. And most importantly, where they can give you feedback, tell you what is burning them out, on what they find unfair on what you/the company is doing. Nothing can break their thrust in you more than the feeling of unfairness. I do 1-on-1 with every team member every 2 weeks, almost a full day dedicated to that. Aa good tip here is to ask open ended questions and let them open their chests to you. Questions like: How was your week? What do you think the team should improve on? That meeting yesterday was not productive, what do you think I did wrong? Actively ask feedback on yourself. If you want to be a good leader learn from your team and make sure they are comfortable on calling you out on your bullshit. Nothing worst than people pretending stuff in front of you and making your own bias stronger. Don't be afraid to show vulnerability, it will make people sympathise with you and not hold your failures so harshly against you. Value people by their differences. Some people like to propose technical improvements, some like to show how focused and productive they are, some like helping to have a tight process organising the sprint, code reviews, etc. Know what each of your developers like, give them the opportunity to do so, ask their opinions about subjects they like and praise them publicly when they achieve something. If possible make them drive some initiative on the subject they like, delegating is a fine art but when done properly is rewarding for you as a leader and for your team members as they take ownership for the code/process and will care much more for it. Teamwork is awesome, ego is evil. Value people that do what is best for the project and everyone else. Stop people that are toxic to others, don't let people talk over each other. "Wait man, John was not finished explaining his point" is not an uncommon phrase for me to say, and be extra careful for people that you see that have social anxiety or in an unfair position like women on a male-dominated field. Don't let someone hog all the "nice tasks" while other people have to do all the boring ones. Again, fairness is extremely important. Transparency. Tell them what you are working on, you are not above the team. You are part of the team and still report to them. If you have management work besides your coding work they should have some idea on how much time you dedicate to it. It is as important to be on your daily stand-ups as your coding work. If you have bad news, tell it like it is, no sugar coating. Treat them like adults and they will respect you. Treat them like children and again the unfairness feeling comes to bite you in the ass. Agree, don't impose. Technical improvements, process changes, any kind of change to their work whenever possible should be agreed on by the team and not imposed on a top-down decision. The leader is not the guy that has all the answers and will lay the plan so everyone just work like ants. But someone that can extract the best of his team, use their expertises and value them for something more than someone that types code on a keyboard. They keys there I guess are good communication and no bullshit. If something is not right people should be able to come to you, people should feel valued and they should know that you have their backs, but will also hold them on their responsibilities. Don't be afraid to show vulnerability, say when you don't know something. Where you nervous because of a big presentation or something? Tell them and then ask how did you do on the presentation. That will be better for you and will make them comfortable to tell you how they really feel when they are the ones feeling nervous. I can try to enlighten any of my points with examples if you want. And thanks for this question, made me re-evaluate my own actions :)
It’s a standard technique in React and Redux. I think the popularity of those frameworks is making this functionality more well known.
Allow others to be right - this is very underestimated by new leaders. People need to have a voice.
Optimizing around the GC is a total waste of time IMO. I pity those who find a need for that kind of performance optimization.
Yes we do, but there are two problems. First: we have a chaotic culture. We try to introduce more scrum based workflow but it is a huge fight. We have to many projects on the side and people in charge like it how it is. Because they can always come in and give you another task. So our code review happens mostly not with the whole team and sporadically. But i‘m working on it. Second: I have 4 front-end developer in my team. There was no good hiring process before me. So two of them are career jumper. One studied biology, the second studied politics. The third guy is a very nice guy, but he is just doing what you told him to do and no more. And the last guy is a rookie who just started to learn front-end development. I teach him. Ok there is also a girl but she is only a student and I teach her too. And the problem is that when we discuss something then they can outvote me just by the number and not by the facts. So I Must Play out my authority from time to time. This is sad, I actually don’t want to handle it that way. I also let them do what they want, just to teach them, but mostly I am the one who is cleaning up after them. And this is also why I think that private projects would be good for all of them. But could are right this is a big problem in our industry. I have done it for so long that I now have a problem not to know what else to do with my life :-/
What do you mean by "waste of time"? JS (or garbage collected languages in general) aren't the nicest languages to write games in, but if you do find yourself writing games in JS, and you're not careful about your garbage, you'll quickly find your game full of microstutters where the JS engine decides it's using too much memory and stops the world for a while for GC. Optimizing around not producing too much garbage is not just "not a waste of time"; it's absolutely necessary. My brother is working on a javascript game at the moment, and he found his game to stutter; we did some profiling, and it turns out it's mostly just garbage collection. To get rid of them, he had to rewrite one part to just use plain old for loops instead of creating a short-lived array with `Array#map` each frame, and rewrite another part to use plain old trigonometry instead of creating a ton of short-lived 2d vectors.
I would love to see haskell-like pattern matching in javascript. That would be great. Ex: `function fibonacci(1) = 1;` `function fibonacci(2) = 1;` `function fibonacci(n) = fibonacci(n - 2) + fibonacci(n - 1);`
Oh, I totally agree with you. Those kinds of steps can be taken to mitigate GC issues. Depending on the program’s time/space complexity, memory footprint, etc., those kinds of optimizations might still be insufficient. My point was that it’s just a pain to deal with, and it’s pretty difficult to solve the problem deterministically, since you can’t directly control the GC algorithm. You basically just have to control your program’s memory demands, which is not always straightforward. But ultimately it can be done, as you said.
Yes, everyone should, but it doesn't always happen like that. In my last job the DevOps was the only one with rights to merge to master because he was a trustless, bitter man. We were sending PRs, CI ran, reviewer would approve, only DevOps would merge. Ideal? No. But in a few cases we were actually happy to let him do it all by himself, we could go home early while he stayed later Friday (yes, Friday deployment) evening.
thank you so much for taking the time to respond, means a lot to me (especially since its hard to teach myself) So I have this so far: &amp;#x200B; &gt;&lt;script&gt; &gt; &gt;function colorCode(jq, obj){ &gt; &gt; &gt; &gt;const keys = Object.keys(obj); &gt; &gt; &gt; &gt;const html = jq.html().replace(new RegExp(\\(\[${keys.join('')}\])\`, "g"), (match, p1) =&gt; {\` &gt; &gt; &gt; &gt; \`return \\\`&lt;span class=${obj\[p1\]}&gt;${p1}&lt;/span&gt;\\\`\` &gt; &gt; &gt; &gt;\`})\` &gt; &gt; &gt; &gt;\`jq.html(html);\` &gt; &gt;} &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;//Then, you can color-code your text by passing the following parameters to the colorCode function: &gt; &gt; &gt; &gt;colorCode($("#phrase"), { &gt; &gt; &gt; &gt;e: "red" &gt; &gt; &gt; &gt;a: "blue" &gt; &gt; &gt; &gt;l: "green" &gt; &gt; &gt; &gt;}); &gt; &gt; &gt; &gt;&lt;/script&gt; &gt; &gt;&lt;p id="phrase"&gt;This is an example&lt;/p&gt; I added the last line\^ (not sure if I needed to) &amp;#x200B; This is what I have between &lt;head&gt; and &lt;/head&gt; &amp;#x200B; &gt;&lt;style&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; .red { &gt; &gt;color: red; &gt; &gt; &gt; &gt; } &gt; &gt; &gt; &gt; .green { &gt; &gt; color: green &gt; &gt; &gt; &gt; } &gt; &gt; &gt; &gt; .blue { &gt; &gt; color: blue &gt; &gt; &gt; &gt; } &gt; &gt; } &gt; &gt;&lt;/style&gt; &amp;#x200B; Everything else is normal- the javacript is in the &lt;body&gt; and css in &lt;head&gt; tags It prints "This is an example" but not in color and the rest of my normal html &lt;p&gt; are also unaffected Any ideas?
&gt; I always have a discussion on how to minimize iterations and such. Or try to tell them to not overuse closures etc Do you measure the performance impact of these iterations and closures? Do you give your team a performance budget?
https://fast-dawn-16835.herokuapp.com - Ethereum block explorer tool still in progress. It's very lightweight, using no third party APIs like Web3 to connect to an Ethereum node. Only built in modules are used for the Node server, and Micromustache for templating webpages.
In my experience javascript back-end is hit or miss. node was at the top of the hype-cycle about 7 years ago and many people moved on and now it feels like a debris field. You'll find hundreds of abandoned backend modules, every google search you do on a particular node backend topic will probably turn up a blog posting from around 2012. I started a backend node project a few years ago, and I'd I find bugs in 'production quality' libraries almost immediately. I'm not shitting you. I remember things like Jest bugged out when using express.js, but only if there were two parameters in the URL. I'm trying to learn node backend development and I'm stepping line by line through how Jest was calling an express route incorrectly, turns out it was monkey-patching Array and two or more parameters were getting squished together somehow, it was a while ago, I forget the details. My first day on my node beginner project and knex.js, the most famous database library in javascript, was show stoppingly broken the very first time I had every downloaded it. I had to create a github issue but it was fixed almost immediately. I found two express.js templating libraries with the same name! I was using one and reading the docs for the other! Everybody created their own 'minimalist' framework because they thought they could do it slightly better, and not enough just wanted to contribute to an existing one. Same with templating libraries, there are probably hundreds. Javascript rockstars all say that prefer minimalist backend frameworks, and because they are minimalist they are easier to crank out, and then because they are minimalist users are condemned to be forced to unknowingly make their own snowflake maximalist framework. It was also a little weird to try to find a library for something, knowing that javascript was the most popular language in the world, and find nothing for the task I needed, and think I was losing my mind. For example, coming from rails I got addicted to database test fixtures, like factory-girl (whoops, factory-bot, hope I didn't trigger anybody). There was nothing at the time. Somehow the entire backend javascript world was either not testing their db integration, doing it by hand, or was mocking everything, I don't know which is worse. How about database migrations, oh, just use the one in knex.js, maybe it still works. Every single module I thought I wanted to use I'd have to carefully check if it was actively in development or abandoned, and if abandoned, I'd have to decide if had been abandoned in a stable state or not. I just recently came back to backend node and I'm liking what I'm seeing. Things are maturing and not just fracturing. I think all the "i can do it slightly better" rockstars went over to Go, where there are now ten thousand request routers (somebody made a web page with "XX days since somebody created a new Go router"). More and more modules/frameworks are going the async way and thats making it so much nicer. JS as a whole is getting nicer to use year after year, like async/await, object spread operator, etc [adonis.js](https://adonisjs.com/) has just the right level of "do the tedious stuff and then get out of my way" and I'm really looking forward to using it, service providers look great. nest.js looks good too but I'm not going the typescript way right now. Hapi.js released a new version a year or two ago and it looks like a comfortable ride now that its gone async. But if you want the first class treatment from a backend framework use rails or phoenix, or whatever those python people use. Communities coalesced around those frameworks and tons of work was focused on them. Keep in mind, backends for frontends like single page apps are often waaay smaller than entire CRUD web apps, so you might not have to do much, and JS might be the sweet-spot for an API. But if I had to make a huge CRUD app with tons of HTML templates and complicated database models, there's no way I'd use JS right now, I'd use rails or phoenix, there's so much more to start with, you are probably half way done just by installing it. This is waaay to long and probably way too much info. But I was searching for answers to your question not that long ago, I've been there.
This is cool
I did! It's even better, i have to try this against gcc to see if and how it'll be different. It's an amazing learning tool.
I hope to have a development job soon and I hope to be on a team like this!
Specifically JavaScript programmers? They expect a certain kind of communication style, asynchronous to be precise. Instead of telling your direct reports to get some coffee and wait for your instructions, you'll need to tell them to get a coffee and .then() go to their desk and work. It's the little stuff like this that will improve your effectiveness with your team.
The function works, but when I copied and pasted it into reddit, something went wrong. Below is a working fiddle (copy + paste the code from there): [https://jsfiddle.net/n8html/s0Lx5wtu/15/](https://jsfiddle.net/n8html/s0Lx5wtu/15/)
&gt;Do you measure the performance impact of these iterations and closures? I do measure performance sometimes to show the difference, but most of the time I just try to explain things, so they understand what to look for in the future. Just for example: if you define your closure inside of a loop, you don't need any performance measurement to understand that it's a bad idea. But actually this is a good point, I will try to do it more in the future. &gt;Do you give your team a performance budget? No. In our company everything is based on trust, there is no such think as budget. This is actually pretty great. So if they want to spend some time on performance optimization, they can ask and do it.
Yeah, it was seen more as a toy for making novel effects, or for client side form validation, or specialized math calcuators from geometry to finance (it was also a time of heavy use of Java applets for math-y stuff). I think its limited applications and heavy residence on the client side gave it the perception that it was impractical and very unsafe for the end user.
Stated reading the book, nlt the most thorough comp Sci dive in but man it feels nice to think about the problems in the language I work with most regularly. Can be so hard to read some of these books and understand the concepts when also trying to wrap your head around a language you don't know.
&gt; believe that reading is more important than writing for the most part I agree, but I'm drawing my line in the sand on that balance here ;)
I’ve been a lead software engineer for about four and a half years now. When I started, the team predominantly used Java with a little bit of JavaScript. Now the majority of our new stuff is JavaScript, whilst supporting some of our old stack too. The day to day and week to week look fairly similar to a mid level dev on the surface. I attend standups, retros and planning sessions like any other member of the team. I’ve got work to deliver and meetings to go to, the usual stuff. Where I’d say it starts to differ is around stakeholder management, mentoring &amp; coaching, architecture and standards. I typically spend a few hours a week doing internal and external stakeholder management. It’s important that you keep your team members up to date with what’s going on outside the team, and the same goes with external stakeholders. Being able to get people on side is a key skill, there’s no point being a lead of anything if you’ve got no one to lead. Mentoring and coaching can vary between teams and roles, but typically you will spend more time guiding others than the other way around. This could include a bit of hand holding with junior devs (although not too much) or talking through issues with the team, facilitating good technical discussions and making key decisions when required. This leads nicely onto architecture and standards. Some companies have lots of architects, but in my experience lead developers tend to make most of the decisions “on the ground”. There may be a broad pattern you have to stick to, but generally it’s up to you to define and implement a good software architecture. This could range from what languages and frameworks you use to what methodologies your team adopts. Defining standard goes hand in hand with architecture, in that it sets a common framework in your team to aid communication. With good architecture, developers waste less time discussing what a “controller” is, and with good standards, developers waste less time on whether to unit test or not (the answer is it depends), or whether to chain multiple arrow functions on one line (the answer is definitely no). I wouldn’t suggest going overboard with standards because people find long documents boring, but establishing a well understood baseline of what quality code looks like is important. Three extra bits of advice I’d include are; 1. Always bring people along with you. Don’t tell them what to do too directly, influence them and get them fully onboard. 2. Always look ahead at new tech. Knowing when to adopt something at the right point in the adoption curve is important. Knowing when to avoid something is also equally important. 3. You don’t know everything. It’s likely that the team around you have a multitude of different experiences and skills, it’s okay to learn from them. Leadership is about getting the best out of other people, not just yourself.
I work at a large corporation leading a team of developers. Let me start with some things that I have noticed from bad leadership. &amp;#x200B; Bad leaders only manage technically or people wise, not both They generally let things get out of hand before trying to fix them. They don't set expectations at the beginning with people. They have no vision. They do not love their product, team, and job. They do it for money only. They are themselves falling behind technically. They don't back their employees when needed or let their employees get away with everything. They manage either only up or only down. (to their bosses or to their employees). &amp;#x200B; I see these people all the time. If you want to be a good boss, try to not do these things while at the same time helping your team members get better. If you want to be a great boss, do none of those things while pushing your members to be the absolute best they can be. A successful manager will see many of their employees stay at the company they are going up in position. Thus helping the company and the employees both as much as possible
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_om369] [I am interested in hearing from JavaScript professionals who lead a team or teams of developers. What does your day to day and week look like? what are some qualities of good leaders in this specific role as it applies to JavaScript programmers?](https://www.reddit.com/r/u_Om369/comments/bfhuw5/i_am_interested_in_hearing_from_javascript/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
no one really cares for your opinions. A fact, if you were rational, you would have figured out by all the downvotes you have gotten in this thread. &gt;Have it your way Thanks (not that I needed your permission) - I will.
Thanks for your comment and for the typos example, it's a good one. Helpers functions are a good work around, but they are not trivial as it may appear at first sight, as invariably they will be applied to more complex cases and pretty soon they blow into fully fledged parsing libraries, or eventually someone in the team gives up and start using lodash. At least that's my experience. I'd rather have that feature standardised and baked into the language, I guess we'll have to wait and see what the Committee decides.
I hear ya. The existing practices sound like a struggle. One thing you can do is set up branch protection on your repos to REQUIRE code review for all pull requests, and protect master and dev branch from direct commits (PRs only). I can relate to loving personal projects, I do a lot of that. I don’t think it’s healthy to require people to do that but you can encourage it if people are really green.
See https://old.reddit.com/r/javascript/comments/bf1hry/2_questions_on_datastructures_in_javascript/elah9o0/ &gt; [Linked Lists] are not possible to implement in javascript
Thanks a bunch, Same thing is happening, css colors aren't applying I'm wondering if I need to put the css in the &lt;p id="thing"&gt; by doing &lt;p id="thing" style=".red { color: red; }" I tried that and it didn't read the .red part, only wants to do style="color:red" etc My guess is the issue has something to do with how the css is getting executed but I don't know Thx again, if it helps here is the page I am trying to add the code to, and with "view page source" you can see what I have written [http://rusticvoyager.com/tutorials/Synesthesia/](http://rusticvoyager.com/tutorials/Synesthesia/) One thing I noticed is I only have written "&lt;script&gt;" but on the page source it reads "&lt;script data-cfasync="false" src="[/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js](http://rusticvoyager.com/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js)"&gt;&lt;/script&gt;&lt;script&gt;"
Having all references be able to have a null value is unequivocally bad. It's just that the alternatives in Java aren't as convenient as they could be. Java isn't well-suited to using Optionals in its current form. Look at the functional languages for that.
Excellent summary. I'm curious about this: &gt;there are languages that don’t have null, and there are languages that allow you to deal with them explicitly via Optional types. The implication is that there are languages without null that also don't have an equivalent of Optional. Is that what you meant, and if so what (Turing-complete) languages?
You used assumptions and buzz words to make an argument, and i get a little annoyed when people are ambiguous with their language and verbose with their arguments. An alternative to Typescript isn't JSDocs, that was my point. Your whole comment is a mess. Anyways. I wasn't trying to attack you, just criticize the way you talk. I have no interest in debating the coherentness of your comment.
I made an [unofficial client](https://github.com/agaricide/mugshots-client) for [mugshots.com](https://mugshots.com). The API is a Node Readable Stream which streams Mugshot JSON (state, county, the arrest charges, etc.) The API also exposes composable async iterator API. There are [usage examples](https://github.com/agaricide/mugshots-client/blob/master/example/stream.ts) and plenty of tests.
I updated the code: `$(document).ready(() =&gt; {` `function colorCode(jq, obj) {` &amp;#x200B; `const keys = Object.keys(obj);` `const html = jq.html().replace(new RegExp(\`([${keys.join('')}])\`, "g"), (match, p1) =&gt; {` `return \`&lt;span class=${obj[p1]}&gt;${p1}&lt;/span&gt;\`` `});` `console.log(html);` `jq.html(html);` `}` &amp;#x200B; `colorCode($("#thing"), {` `e: "red",` `a: "blue",` `l: "green"` `});` `});` Check out the fiddle: [https://jsfiddle.net/n8html/s0Lx5wtu/19/](https://jsfiddle.net/n8html/s0Lx5wtu/19/) The problem was that the code was executing before the document was loading. The updated code executes after the document loads. This should fix your problem.
Use sessionStorage: `function alertWindow(){` `if(!sessionStorage.done) {` `alert("blah blah blah");` `sessionStorage.done = "true";` `}` `}` Whenever someone opens a tab, they will be greeted by your alert. However, until they close the tab, whenever they visit your website (within the tab), the alert will not show.
thank you so much it worked i just started learning javascript so i didn't know about !session storage
can you explain to me the sessionstorage operator mean
sessionStorage is a form of lasting data storage that exists in each browser tab. You can set data in sessionStorage, and it will last until the tab is closed. In my ```alertWindow``` function, I check if the ```done``` property exists on sessionStorage. If it doesn't, I show the alert, and then set the ```done``` property to true. Then, if the function is called again, the alert won't trigger because the ```done``` property is set to true. But once the tab is closed, sessionStorage is erased, and the process starts again.
&gt; immutable via spread syntax Can you elaborate on this? I'm not sure I understand
http://www.humanedevelopment.org
**[http://ai.neocities.org/Abracadabra.html](http://ai.neocities.org/Abracadabra.html) Mens Latina** -- thinks in Latin.
Largely because there's a quality control measure. There's no point in approving PRs and then not merging. The projects we do regular maintenance work on have scheduled deployments and they are fairly quick to do, so they're not a significant part of my work time. We are a little more loosey goosey on deployments during initial development, mostly because these are largely automated and its not difficult for anyone to handle. There have been moments where its been a bottleneck. But we aren't a very large team so generally it's not a problem. I can't say it would work for everyone. It does work for us though. Also the moments where its been a bottleneck have made us realize I shouldn't be carrying a lot of the actual programming tasks, so over time I've moved more towards management which has freed up more of my time for the PR reviews.
This is pretty much how it works for us. I've set up internal infrastructure and advise clients with direction here as well. We have automatic deployment processes during development and anyone is able to make these type of deployments. Once we go live and are in a regular maintenance contract we are stricter and have a quality control process so it makes more sense to have one person own that. Everyone knows how to merge but it makes little sense to approve a PR and then not merge it. I find it also helps to have someone with a high level understanding of the codebase as a whole, with the ability to resolve merge conflicts in a sensible way. Our methods work for us. They won't work for everyone. I do think we're in a somewhat unique situation. Not many marketing agencies do the type of work we do.
&gt; I'm on the edge of breaking down and crying because I've spent so much time and energy trying to figure it out but to absolutely no avail Professional programmer here - This is EXACTLY what programming is. Real programming means not knowing what you're doing. Learning how to persevere and figuring out your problems is one of the most important parts. Keep it up! You'll figure it out, you'll get better, you'll continue to rip your hair out, you'll jump for joy when you succeed.
[removed]
In Java, the ability to stub everything out later is extremely valuable due to the context in which the language is used. It wasn't even for unit testing originally IIRC, and proper dependency injection tends to have a far more noticeable impact on testability than putting implementations behind interfaces these days. Simply, programming to interfaces allows multiple devs to work on different parts of the project quicker and with more confidence and allowing one to swap in different implementations of a contract depending on the environment is invaluable in ops. It's pretty good business value when used right. But then you get devs who insist on interfaces and abstract classes covering every single class in every project without any justification other than "that's how it's done", and small and simple services quickly become monstrous legacy clusterfucks even before shipping and nobody wants to work on it anymore.
side note; session storage isn't an operator it is essentially a global class/ function prototype built in from HTML5's web api.
interesting, but still far from useful in production.
why make true a string? I mean it works because non empty strings in JS get converted to truthy values but just use a bool
This is not what programming is. You are not a professional programmer.
I will openly admit just how much of a combative asshole I was as a junior engineer. Being excited about tools and trying to convince my seniors and architects to adopt the new new. A year into the job I was given the chance to do it, after basically never shutting up about it, and I failed horribly and alone. So much of society portrays programmers as these awkward basement dwellers but the profession is anything but rejecting that social perception. It was easy to learn how to code, it is much harder to learn to be a programmer. Ask a lot of questions. Computers don't lie, so back up your claims with facts and unbiased computer science. It's so easy to get swept up in the latest craze but the fundamentals never change.
If you were taking a JavaScript course, and it was teaching you how to draw shapes, I think maybe it was a bad course?
You sound like an idiot.
With code it pays to start at the beginning. You seem to have skipped a few essentials. To "play" with js you only need notepad and a browser, I don't see how it could possibly take six hours to find that out, it's how every article on getting started with js begins. I'm not trying to be a dick, I've just seen people get lost because they were somehow confident they'd pick up the basics implicitly. Before you get into working with the canvas I'd suggest following some (free) tutorial on how to build a page with HTML and Js. Learn how to build a div, a button and a js function that updates the div when that button is clicked, things will pick up quickly from there.
&gt;the discussion of javascript news, projects, and especially, &gt; &gt;code &gt; &gt;! However, the community has requested that we no Hi kenman! Sorry, I didn't know. Thanks for telling me!
You need to find a different hobby. This isn't for you.
At least he knows what he's talking about.
Anyone that has ever been stuck on a problem should just do something else instead.
Can you get hello world to work?
This is great, thanks for sharing. I’m currently in an environment that embodies pretty much the opposite of every point in this link. It is starting to really take its toll.
You sound like an arrogant dickhead. Have a wonderful day.
It’s still a good market out there; never stop looking, and never settle. I would expect the same from anyone that reports to me. Hell, I’ve congratulated people who moved on from working for me in the past because their next opportunity fit their career progression perfectly.
Do you have any helpful links?
I love the !==, because you mighty have “authority” but don’t have authority.
We all struggle getting setup on something completely new to us. &gt; and the 25 hours i invested into khan academy was like 75% about shapes. I'm sure most of what you learned wasn't about shapes, you just don't realize it yet.
codecademy, academind, YouTube, w3schools, Chrome dev tools on any website. You should never need to pay for anything to code, and if you encounter a pay wall take a step back and think, "is this the only solution I can find via Google"
I wonder if you are confusing Java and JavaScript? Drawing shapes is kind of advanced in JS. It requires an HTML Canvas, which is not exactly intuitive to work with. Usually a starting JavaScript tutorial would focus on logging stuff to the console first. Which you can do from any web browser by opening Dev Tools (ctrl + alt + i).
Start with a CodeAcademy or easier type course then follow up with reading/going through Eloquent Javascript online (it’s free!) You can do it!
Lmao that's absolutely awful advice. I've been in this exact position, he's looking for a genuine starting point and you've offered him this rubbish. I hate this feel good bs. Obviously professional programmers go through strife in their work but you could have at least offered him a good tutorial or book to start off with.
I just figured out that javascript and processing.js are two different things... now i feel a bit lost on where i am and where i need to begin
Thanks
Ah. Processing.js is new information. I would guess that’s a complex thing to start programming with, and setting that up in your IDE is something that may be difficult for a beginner. Have you done a more basic programming tutorial? Just learning the basics? Variables, control structures, functions etc?
I'm going to need to restart and retrace all my steps.... because i thought that animation and interactive programs was one of the defining features of JS... I've done some of that, but it was all with shapes and stuff
The defining feature of JS is in web browsers. It’s the script that websites use to program some of the more complex behaviour.
Sure is! Assuming that's his code, of course!
e.g.: [https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns](https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns)
Some people see the lack of static typing as a big plus for javascript.
Makes sense when. I would also consider changing json format for configs to something more human readable. There is a reason why things like Gatsby or Docker don't use json for configuration, where config is one of central points of application. I assume you picked json because it was the easiest to implement and you can deliver working tool, but down the road perhaps it could change.
Storybook with knobs!
Actually, regarding the configuration, you can use the appcfg.yaml file that specializes in installing https://docs.hyron.org/config-file As for json build file, I think json is the most appropriate format, it doesn't have many properties, and allows external instance to be easier, in the form of limited array, in addition it is quite familiar to new people. , rather than yaml, or other format
Also, double check whether you were learning java or javascript. Making shapes in Java is like intro to objects / classes 101. You shouldn't really need to make shapes with javascript as that's basically what the DOM will already have available for javascript to manipulate.
Nice!
&gt; Sometimes, they fail as I expected, and it becomes a learning experience But wouldn’t that strategy be very expensive? If you’re at a startup, teams might not have the luxury of time to operate this way.
I don't think you know JS because 1,2,3,4,5 can all be accomplished easily, and there's well maintained libs for it. If your employer doesn't use the workflow you like, that's a problem with your employer, not the language. What you call "powerful" is simply a preference about the default way language behaves. JS can do all of that, and many people choose to work that way. 99.99% of the people who complain about JS simply know another language better and are mad that they have to learn another language that is different. Saying that it is less powerful is objectively wrong. It can do all of that without almost no effort (if you know JS well) thanks to the thousands of contributors of npm.
I could do it in one line.
sure. i usually get this kind of comment. i'm trying to only use one instruction per line in which case the information about the number of lines of code gives you a rough idea of the complexity of the code.
I think it could be if you're not careful, and as you allude to, depending on environment. In a startup, yeah, might not be the best idea. In a large, established corporation though, there's probably a bit more fault-tolerance, so to speak. But, I think the key point regardless of environment is that as lead, you have to read the situation and make a judgment call. And there are lots of factors... has the developer shown themselves to generally be capable of this sort of thing? Is the solution they're suggesting way out in left field or does it sound at least reasonable? Is the task in the critical path? Is the project in a state where a minor setback doesn't derail it? Can you actually see value in either them proving YOU wrong and/or it being a learning experience? Ultimately, it's a gut call, but hopefully one based on a lot of experience on the lead's part. But yeah, I don't think you're wrong that there's probably some environments and situations where you'd be best off to refrain from this strategy.
Yea you and and six other idiots downvoted me, so what... I don't care about Reddit votes, are you 12 yo or something... It means nothing.
No, don't get me wrong. It's pretty impressive... in fact, you may enjoy [this site](https://www.dwitter.net/).
This is also helpful if you are new to this world :) https://frontendmasters.com/books/front-end-handbook/2019/
i'm a huge fan of dwitter. i want to write code like that when i grow up :)
If you have been watching tutorials that are based on using the processing software can I suggest you download that first. [https://processing.org/download/](https://processing.org/download/) . Also I am not sure if you are aware but there is processing and then its sister processing.js. I have only used processing and know that it is essentially Java, and processingJS is javascript but from what I read they are both run with the processing software I linked you to. Get comfortable reading documentation, it is your friend. Processing getting started: [https://processing.org/tutorials/gettingstarted/](https://processing.org/tutorials/gettingstarted/) ProcessingJS getting started: [http://processingjs.org/articles/p5QuickStart.html#writingsketches](http://processingjs.org/articles/p5QuickStart.html#writingsketches) I hope that helps.
Not all that useful really, and could raise more questions than it answers ( if any ). There are separate keydown, keypress and keyup events in javascript so the title ( and parts of the article ) are quite confusing. The english is pretty horrible making it hard to read - it might be worth improving if you plan on doing more articles like this and finally - https://keycode.info does exactly what your code does but provides extra info, its not the only resource to achieve this either. I'm not sure your premise of "not having to look keycodes up online" quite holds much water given that the majority of Js programming with html and css is done on the web. Just my two cents but thanks for posting.
I would drop jQuery and teach modern browser API instead.
Cool extension! Personally, I've solved this by "pinning" tabs like email or spotify, but this is still a nice alternative :)
Hey do you have any recommendations on creating chrome extensions?
This is really awesome! Can’t wait to build something like this! I’m still at a beginner level I’m JS but this is inspiring to do!
I'm just going off of memory, but I believe SessionStorage is like LocalStorage where values must be strings. So even if he used a bool, it would have been converted to `"true"` anyway.
Kinda repeating a bit of what was said earlier but this is similar to the advice I was offered when I wanted to learn but just tried to jump straight into javascript and was totally wtf-ing for a week. 1.) Download notepad + + or sublime . they're text editors to help you code. Watch some videos on html and css and play with it. You gotta have that foundation. Create a webpage in html, make it pretty by creating a stylesheet in css and linking it to your webpage. 2.) Understand how javascript is interacting with a webpage. See what types of things it can make and look at examples. Coding is about creating something , and if you don't understand what it is that you are trying to create you will never be successful. 3.) Look up variables, functions, loops, boolean logic, arrays, conditional statements. Coding is logic and you have to understand certain aspects to get things to work. Copy paste will only get you so far. Once you reach this point you should have a better grasp on what it is you really want to do, and will be able to properly utilize YouTube and Google. Its like playing guitar. You don't just wake up one day buy one and start shredding. It takes time, patience, practice- and consistently reminding yourself to not get overwhelmed and that one day you'll be mfkin boss.
Nice!
Handy, I'm trying to move away from jquery
I thoroughly enjoyed that.
Jeez... they’re not even being subtle about it. Lesson: careful what you use from github.
Fantastic job. Cheers for this. I'll defo be testing this out :)
If you want to build tools for yourself or community to improve web browsing experience without expecting to monetize it, you're very encouraged to learn, it's very easy. Took me 1 day to learn how extension work and how to write one. &amp;#x200B; If you want to make money from it, I think you will have to seriously invest to it. It's hard to make money from browser extensions.
Nicely done! Have you tried submitting it to the chrome store? It would reach a lot more people. Also, I'd kill for this extension in VS Code :D
It's a class 3 proposal to be added to JS. I guess Chrome already implemented it. [https://github.com/tc39/proposal-class-fields](https://github.com/tc39/proposal-class-fields)
I think you’re referring to JQuery when you’re referencing “vanilla JavaScript” I don’t see the development community moving away from a component model back to MVC any time in the near future because of how reusable and maintainable components are throughout web development. If development changes need to be made throughout a website it’s much easier to change the JavaScript and layout of a single wrapped component than go through a bunch of html, css, and JavaScript files. IMO it’s not going anywhere anytime in the near future unless there’s another paradigm shift to a new unforeseen technology. Further I think that the applicability of component based development in other areas i.e. mobile development via ReactNative further cements its status.
won't web components make all these frameworks obsolute?
There are still projects out there with homebrewed frameworks custom built for the company's specific needs, with pure vanilla js. I recently worked on one, 12 year old js codebase for a major telecom company. Its important to understand that a "framework" is just a collection of design patterns that help keeping the code base sane in a large scale application. You'll see most of the same patterns regardless if you look at Vue, Angular, or a React stack. Since you mentioned "full blown javascript app", I would say the answer is no. Vanilla js is appropriate for smaller scale things, but I'd warmly recommend any business to pick an established framework over developing one from scratch, if the idea is to build a larger scale app that will be supported for years. When starting a new project, it just saves huge amounts of time not to have to develop your own framework, as the popular ones today are designed to solve 90%+ of common use cases. They also usually dictate how things should be done within the app, which helps with recruiting/onboarding new developers. That alone is hugely valuable for companies. Many smaller projects most certainly don't need fully fledged frameworks behind them when they start out, but the benefits of eventual scalability usually outweigh the cost of having something custom built from scratch, where scalability maybe wasn't considered from the start.
Thank you! Submitting to chrome store requires google developer account and I don't have one :(. Btw, we already have an excellent extension for vscode [https://marketplace.visualstudio.com/items?itemName=shyykoserhiy.vscode-spotify](https://marketplace.visualstudio.com/items?itemName=shyykoserhiy.vscode-spotify)
Do you mean that the community will get to a point where components will become packages instead of writing jsx? I’m not confident that it will get to that point because of the uniqueness of different developers design and workflows. You can already buy cookie cutter websites that you can write the JS for, or use packages like react-bootstrap or material-ui to format your site. Could be that it will get to a point where you pass web layout via JSON though, but I don’t think that would fulfill my supposition of your question of future web dev moving back to MVC, and I also don’t think it would give developers the granular detail over the layout of their projects that they would want.
Sweet! I made a script some time ago which blocks audio ads, it's a little bit tricky and I use it in tapermonkey - but I think you can easily add it to your extension to get an even better experience: https://gist.github.com/Simonwep/24f8cdcd6d32d86e929004013bd660ae Sry I'm on mobile
Wow interesting that chrome already supports this. This also works with react class components...but i guess Babel does the work there
I'm interested in this as well. If I'm just starting to learn javascript what else would I need to know to make a simple browser extension as a project?
Interesting !!. I had an idea about ads mute also. What I did is observe the player like you did, every time the player change, I will check for song info, ads will have some different info from actual songs. But I didn't have time to finish this feature. In your code, I see you check for the audio, can you explain a bit more about your mechanism to detect ads?
[removed]
I work in react mostly, which means I write a lot of JSX, but the logic is all vanilla JS (modern JS, not ES5). As far as I know, that's a pretty standard way to work with React, the most popular "framework" right now.
Thank you for the feedback! I will look into it.
It costs like $5 one off? Would get much better visibility - otherwise you’d need to be careful as your code is public somebody else might release it
Disgusting that people do this, is another example why the theme industry is so toxic for the development community
Works for me.. Can yo give a test case that fails? [https://repl.it/repls/DarkgreyApprehensiveCleantech](https://repl.it/repls/DarkgreyApprehensiveCleantech)
Hope this helps! &amp;#x200B; `function matchBetweenTwo(s,f) {` `testStrings = [` `'first test string',` `'second test string',` `'third test string'` `];` `const re = new RegExp(s + "(.*?)" + f);` `testStrings.forEach(item =&gt; {` `console.log(item);` `if (item.match(re)) {` `console.log(\`match on ${item}\`);` `return item;` `}` `});` `}`
If you think about it - the question itself isn’t the real question. Everything we do apart from maybe JSX/Flow/Typescript/Coffee is “vanilla” JavaScript. React and Vue etc is all vanilla - they don’t make up their own languages etc. I believe the question really is “will we ever abandon using prebuilt tools” Plugins/libraries/frameworks etc are all there to help us save time and rebuilding the same thing over and over again. Unless you wanna go back to the old days of making everything from scratch each time - then the answer is the same for both questions. Probably not.
Creative name!
The best coders I have seen in my life output error free amd well engineered and thought code slowly and steadily. They do have a fast typing speed though. Also there are some that write it on paper first in pseudocode format, that is an excellent way to remove errors before typing.
The inattention to details turned me off. There are three different type of string quotes on the first example alone. Feels a bit sloppy for a big shop like Autodesk.
If an ad is played, the url of the cover which can be clicked at the very bottom left changes to a non-spotify url. After capturing the audio element, which get's created by createElement, I found out that changing the src of it to something invalid triggers spotify to skip the track (or the ad). So the only thing you need to do is to check if a the cover url changes (With MutationObserver) and invalidating the audio-element src after that :) I'm currently using this for ~4 months since I'm using spotify every day. I'll update the script asap if spotify changes his behavior again.
The whole concept of “leadership” is flawed imo. It’s not about you, or me or anyone - it’s about the cohesion of a function team - my experience tells me that (perhaps counter-initiatively) that self-organising, self “leading” teams are the most effective. So the best “leadership” is being part of that process and facilitating other people incision in the same - and that’s something that everyone should be doing. Put the ego away kid - there are no “great leaders” - just good workers and dickheads - choose your path carefully
You don't need much more, Google has extensive documentation and even tutorials, just go search for it. Mozilla also has great docs for the general web extensions APIs that are not Chrome exclusive
You don't have to use regexp for the split function, you can just use strings. The below will split the string into an array with 3 values: string.split('|')
Was it ever popular to begin with? Because the way I remember popular ways to make interactive web pages, it was java/flash ==&gt; jQuery ==&gt; frameworks, vanilla was always barely used.
Literally nothing in the list can be done in JS. I know JS very well.
I think my Question is not clear &amp;#x200B; I don't want to get an array like this \[ Hello Everybody,How Is It going,Good Bye\] &amp;#x200B; All I want is the "How Is It going" part &amp;#x200B; and It should work if the string was like this var string = "Hello Everybody|How Is It going&amp;Good Bye"; &amp;#x200B; I want to get array of strings that are between the specified symbols in the function
\|(.*?)\| something like this can be used to match the word in-between the | .
I'd be cautious redistributing the circular font in \`popup/public/fonts\`. It's a paid font and by uploading it to GitHub you could be violating some kind of license policies.
Can you get me a resource? I can't find something like that. This would be great if js offers this...
A javascript library that makes unit conversion and templating easier: [https://www.npmjs.com/package/modol](https://www.npmjs.com/package/modol)
Well yeah, but it's still way more than 9 ops/sec. I'm getting a similarly low number at jsperf and I really don't know why, but it just doesn't seem accurate. I know from experience that some native array methods are rather slow, but I never saw anything *that* slow.
Wow - great project!
Thanks for the tip
var helloEverybody = String.split('|')[0];
Seems like you're looking for this: &amp;#x200B; string.split(/\[|&amp;\]/)\[1\]
His problem is he can't do this type of work. Time to move on. Not everyone can. It's why "everyone should learn to code" is such a dumb idea.
So cool :-)
I'm not sure what you mean by vanilla javascript here. Things like React or Vue use a lot of vanilla javascript. A lot of state behaviors / logic are written with vanilla javascript. What I feel you may be referring is, will dom manipulation will ever be a thing again. And the answer to that is no. Direct dom manipulation is awful way to do anything. You know all that jazz that you select an element with a secotor, add / remove class things like these.
This means that application shouldn't be coupled to a database. Database should be a plugin to your application. Meaning, database depends on the application, but application itself doesn't care about the database. Data oriented designs are good only for non-persistent data.
looks nice ill check it out
I believe Vanilla JS will rule supreme for a few reasons: 1) Speed... Pure JS annihilates any framework or library out there. Your game uses React? Cool, enjoy those 10 frames per second. 2) Framework churn. Nothing lasts forever. jQuery was cool for a while, now it's not cool (for SPAs at least). Now React is the new cool, but who knows for long. Angular was hot for a but, now dying off. They're all just fads. Know what is still working under the hood of all these things? Vanilla JS. 3) Vanilla JS is getting upgraded every year to be better, faster and have more features. If you only support the Tier 1 browsers (ditch IE11 support) you can do lots of cool stuff without needing any library or framework. caniuse.com is your friend. 4) Simplicity and long term maintenance. Who is going to maintain your app in the future when the framework fad you were using drops off the map because it was no longer cool anymore? The business either does a complete rewrite (at huge cost) or goes under. Whereas a custom built micro framework in vanilla JS (made up of well written code and reusable patterns/components/classes/functions etc) can serve the app for its lifetime. Anything is on the table to be modified, extended or improved as the framework _is_ the app. Good luck finding a developer who can dig into the internals of React 10 years in the future to keep maintaining it when Facebook has stopped maintaining it. 5) Security. No 100 MB of unverified node modules to pull in which needs to be updated every other day. No dangerous abstraction over the DOM APIs allowing for XSS. Software / Front End Architects will be a lot more useful in the future who know how to make a good extensible shell/micro framework for an application using best practices. I guarantee that it will be a better app and last decades. Rather than some clowns straight out of uni that bundled in React, webpack, gulp, brocolli, babel, redux, react router, bla bla with 100 MBs of node modules to create the app because they didn't know any better and it was the new cool for its time. "But Facebook uses it, it must be good". Facebook are full of shitty legacy PHP developers that came to the front end and couldn't figure out how to make a notifications popup so they invented React to do it for them. Their framework serves Facebook. You're just along for the ride. So enjoy rewriting things every couple of years when they figure out how to architect their framework properly. First React. Then you needed Redux. Now Hooks. Next Dooks, Mooks and Chooxs.
You sound like a great team leader.
At least I have a job. And I'm technically correct. I'd rather be a dickhead than stupid.
Dude, PLEASE add it to the chrome store. This is amazing
Yeah you can read about it [here](https://developers.google.com/web/updates/2018/12/class-fields) and if you Google around for the proposal docs they also include an FAQ about why they were added, tradeoffs they made, and alternatives they considered.
Of course! I would agree that it saves me some time and mental effort. Every tool has its place. My comment was just to point out that JS is not the tool for every job. I have worked on projects where I realized too late that I could have had an easier time with a bit of static analysis and type checking to catch my errors. I write mostly JS these days, but I'll switch to C# if the situation demands it.
Can you give some examples of inputs and outputs so I can better understand your requirements?
I think the answer is if you are making an application and not a website (like a restaurant site) then you should probably be using something like React or Vue. If you are making a brochure site, use JQuery. Vanilla JS is used all over the place. I use it daily in my React project.
ok Here you go var string = "Hello|Good Bye&amp;1234|How are you&amp;"; var extracted = string_between(string,"|","&amp;"); console.log(extracted): //should print ["Good Bye","How are you"] console.log(typeof extracted); //should print "Array"
Dom manipulation by hand will never make a comeback again. We are already using "vanilla JS" otherwise, just without touching the dom api, which was the sole reason the web was ugly, inflexible and slow, and none of the newer specs have changed that. Writing and reading directly to the dom is the slowest possible path, it makes state handling hell and leads to maintenance troubles. Layout inflating is dead for maybe 20 years, the web was one of the very last platforms to cling to it, you won’t find many people that wish to go back.
Yeah, it has no impact if it isn't saved anywhere. However, to be extra careful, I would always put {} around the body of an arrow function. Or you could use the ```void``` operator to make the function evaluate to undefined: Option 1 (okay): ``` () =&gt; doSomething() //Value could be stored somewhere - be careful ``` Option 2 (the best): ``` () =&gt; {doSomething()} //Value is discarded ``` Option 3 (cool thing that you shouldn't do in real life): ``` () =&gt; void doSomething() //void makes doSomething undefined, and therefore the function returns undefined ```
EDIT: I PUBLISHED THE EXTENSION ON CHROME STORE, YOU CAN INSTALL IN YOURSELF: [https://chrome.google.com/webstore/detail/spotless/allccgoelledmdfenijoodhcfjndddjh](https://chrome.google.com/webstore/detail/spotless/allccgoelledmdfenijoodhcfjndddjh) EDIT2: ADS MUTE FEATURE IS COMING SOON! THANKS!
 ()=&gt;doSomething(arg) is perfectly acceptable and has no side effects. However, you do have to watch out for developer intent; when you write: ()=&gt;{doSomething(arg)} you signal to your fellow developers (or yourself in six months when you've forgotten your own code) that the function is not supposed to return a value. Doing: ()=&gt;doSomething(arg) could (depending on context) mislead them (or you) into thinking the return value matters.
`match()` returns an array, so in your `string_between()` function you'll need to select the element which contains the captured match. FYI, the first element is the whole match, the remaining elements are the captured match. Assuming that there is a match. Otherwise, `match()` returns `null`.
Take a look at Svelte. The future of front-end might look something like it. It's a framework but doesn't have a runtime - all the fancy stuff happens at build time. I don't have a great grasp on how this works but it's fascinating. Take a look at the React, Vue, etc. source code. They *are* Javascript, Vue might be TypeScript. As mentioned already the abstractions away from the DOM are not going away and are pretty much necessary for complex web applications. Web components and frameworks will ideally end up working together i.e. web components will offer primitives to build off of. We'll see.
Ads LUL Spotify Premium all day
The `()=&gt;doSomething(arg)` form does the `return` statement for you. The `()=&gt;{ doSomething(arg) }` form does not do the `return` statement for you. The latter form has the same behaviour as normal function in terms of function's return value. If `doSomething(arg)` doesn't return any value, the first form would do a `return` statement for nothing.
I don't understand sorry &amp;#x200B; can you please explain more ?
Again... I understand it fine. I also know that ng1 (AngularJS) is a very different beast than ng2+ (Angular). I just plain don't like it. I think the DI system is overrated, the bindings to RxJS are painful, and most of the state management is overengineered. Yes, with react it's not in the box... there are *options*, and I get to pick which one suits me best. With angular, it's like the only option is the most complicated, overengineered option.
In this case you have a couple of options: &amp;#x200B; This is the pattern you'll need: /\\|(.\*?)&amp;/g &amp;#x200B; Then you can either call string.match(pattern) and get this back: \["|Good Bye&amp;", "|How are you&amp;"\] You'll have to strip the delimiters off yourself. &amp;#x200B; You can also call string.matchAll(pattern) - in which case you'll get an iterator back. You'll call [iter.next](https://iter.next)() , and for each invocation, you'll get an object back like this: &amp;#x200B; { done: false value: (2) \["|Good Bye&amp;", "Good Bye", index: 5, input: "Hello|Good Bye&amp;1234|How are you&amp;", groups: undefined\] } &amp;#x200B; Where you can see that object.value\[1\] is the actual match you're looking for. &amp;#x200B; In either case, you can build the appropriate values into your result array.
Looks great! Wish there was a Firefox version as well :)
Your `string_between()` function is currently returning an array. You'll need to return one of the array contents instead.
What's the advantage of using this as opposed to using the native RegExp function? You could replace the first example in your docs to be: `const dynamicRe = (tagName) =&gt; new RegExp(`&lt;(${tagName})([^&gt;]+)/&gt;`, 'ig')` It would give you the same result with 0 overhead. As for the case with array arguments, it might be a bit too much magic happening under the hood, in my opinion.
I tried that see here's my example [https://pastebin.com/YnVSisTT](https://pastebin.com/YnVSisTT) but It returns an Array with empty strings
I would goto Youtube and search for **Net Ninja** and see his videos on Javascript. I love his way of teaching. Give it a try. [https://www.youtube.com/watch?v=qoSksQ4s\_hg&amp;list=PL4cUxeGkcC9i9Ae2D9Ee1RvylH38dKuET](https://www.youtube.com/watch?v=qoSksQ4s_hg&amp;list=PL4cUxeGkcC9i9Ae2D9Ee1RvylH38dKuET)
Hi /u/theunpluggedweb, this post was removed. Job and job-related posts are prohibited * Job postings: Please post to /r/remotejs, /r/forhire, etc. instead of here. * Job/Career advice: Please post to /r/cscareerquestions instead of here. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Cangasevere, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/FalltheBanks3301, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/theo258, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/GloomyMusician24, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/fintip, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/cubef0x, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Cangasevere, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/chovy, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle), "Curated lists", and similar content. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Waste_Dark, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/pmz, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/jsdavis777, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/bapugraphicsins, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/chovy, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle), "Curated lists", and similar content. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
[String.prototype.split()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split)
Hi /u/Cangasevere, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Every function without an explicit return still returns undefined so saying 'doing a return for nothing' doesn't make any sense. I prefer ghostfacedcoder's answer in that the second one more clearly communicates intent.
This is really cool man!
Thank you. I'm working on it. Will have some constraints to determine if it's an ads like checking url, song name, artists... I will update the status for you!
The problem with your example is that | is a reserved character in Regex, so you have to escape it: \|
You could also think of it this way: Every function returns a value. If you don't specify a return value, a function will return a value (and type) of `undefined`. Functions can be invoked as a unary or binary operation. &gt;function test(){ &gt; &gt; return true; &gt; &gt;} &gt; &gt;test(); // unary operation; we don't care about the return value. &gt; &gt;const x = test(); // binary operation, x == true. You should start thinking about and adopting coding standards. When and what to return from a function. For example, in bash scripting, the standard is that a non-zero return value means there was an error. With this schema, functions either return 0 when they are successful, or return an error code otherwise. This allows us to "and" commands together in the terminal: \`mkdir ./test &amp;&amp; cd ./test\` (I think bash converts the zero return value as true and a non-zero as false for the terminal I/O).
Well, in your example, `tagName` is not escaped. But you can get around that. const dynamicRe = tagName =&gt; new RegExp(`&lt;${escapeForRegExp(tagName)}([^&gt;]+)/&gt;`, 'ig') // vs. const dynamicRe = tagName =&gt; rx`/&lt;${tagName}([^&gt;]+)/&gt;/ig`; To answer your question, this - like all tagged template functions - is for syntactic sugar. It strips out all the boilerplate around a simple statement so you can unambiguously see exactly what's going on.
Modulating your style with different people is great advice. People are different. Other types of style to recognize: - some devs love public team recognition but some devs absolutely *hate* attention focused on them. I buy my team birthday cake during the first week of every month to celebrate that month’s birthdays with zero singing and zero singling out. Everybody loves cake. - don’t make devs talk to people / customers if they don’t want to. Let them do it organically and if they aren’t ‘good at it’ team then up with someone who is. - some devs like to get a bunch of direction up front and then be left alone to crank out stuff without much interruption. Some devs love regular input. - some devs have really interesting ideas that don’t translate to an audience that isn’t technical. Having them work with ui/ux person can be huge because clamping them down creatively WILL equal lost innovations that no one else thought of. - following that, I’m amazed, still, at how much better — and appreciative — even the most prolific, successful UI/front-end devs thrive when they are freed from trying to figure out ui/ux problems. - allow people to be expressive, even to the point of snark and jibing with other teammates — since the less vocal may feel more included when even they are subject to *good natured* taunting. But, and this is critically important: be ruthless as a leader in demanding psychological, emotional, and physical safety, respect, and inclusion. There is no doubt from anyone on my team that I will immediately come down hard and oust anyone with a hint of a shred of malice. - there are ‘paced’ devs that take a while to plan and prod their work with lots of documentation and organization, there are worker bees that dutifully crank out fixes and features at a good pace that don’t mind picking up the mundane but necessary tickets that must be done, there are devs that do their best work when teaming up that ensure more people are aware of all of the disparate moving parts and how they interact, and there are the 10x-ers who just need time and space and they’ll somehow figure out how to bend it to their will when no one else can. They are all important and you need each of them. - encourage everyone to suggest novel tech solutions or frameworks, especially if it has to do with a tech that they are curious or excited about. We might not be able to fold it into the main work but it keeps people inspired and sharp and less frustrated to do the lame-o tech debt and process stuff that everyone hates. Plus, it may introduce an elegant solution that solves a problem that you had to hack together. We just did this exact thing recently by suggesting the purchase of an enterprise license of a web library. We’re getting much more polished and performing features with the license over the ‘added on’ foss version of the same library for way less money that a couple of months of dedicated developer time.
Mostly? Making configurable matchers for DSLs.
Hands down the most important thing. I have ~couple dozen dedicated devs that always strive to do the right thing and will consistently sacrifice for the work but I constantly reassure and remind them of underline concepts like family first, taking care of themselves both mentally and emotion but also physically, and I am ruthless in ensuring that everyone feels safe, included, and respected. I don’t even let customers be mean to my devs in the phone or email. The first time a customer yells at a dev is the last time. No one deserves to be treated poorly.
You don't need to use js for form validation. Just make your submit button with ```type="submit"```: ``` &lt;button type="submit"&gt;Submit This Very Awesome Form&lt;/button&gt; ``` Then, in your input field, mark it as ```required```: ``` &lt;input type="text" required&gt; ``` The browser will do the rest of the work for you!
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
Man, I got the react app alone up and running with the src branch that you specified, just as a way of trying to learn react. From what I gather the app doesn't work as a standalone react app? Because I didn't see the login page. And I tried to run the full app as well, npm run dev, even that's failing with some issue. How can get it running in dev mode to debug and possibly learn.
hey, thanks for your interests. Yes, the standalone reactjs will not work properly, because it needs chrome extension APIs in order to access cookies from Spotify to authenticate user. To make the standalone react work, you need to copy your Spotify access token to [this line](https://github.com/phandd/spotless/blob/6a77e14d8ec17532341f36f01a3abd7dd5a06064/src/utils/api.js#L5) and run `npm run dev`.
I published the extension to chrome store. Hope you guys like it!
I published the extension to chrome store. Hope you guys like it!
I recently stepped into a FE team lead role and I've noticed this has become a huge part of my day-to-day work. I love being able to try and figure out why someone is stuck and how to get them unstuck as it helps them learn how to problem solve their own way out next time and keeps my own chops sharp. However, it seems knowing when to step in and offer help is a challenge. I usually try to keep an ear open throughout the day as usually anyone on the team that gets stuck will offer a grumble/vocal proclamation (e.g. "Argh, this test isn't passing for some reason" or "Hmm, I really don't get how this function is working"). Other times, I will actively try to check-in on progress for a feature/task right before lunch or towards the end of the day but I know checking-in like this can also become overbearing if done too often or in an annoying fashion. I do wonder if anyone other team leads in this thread can speak to their experience of checking-in with team members on progress/tasks without being a nuisance or being too boss-y.
in the future, if you put four spaces before your code, it'll turn into a formatted block that is easier to read you can also get rid of the jquery dependency by using querySelectorAll instead i'm not 100% sure on what you want, but it looks like you want: 1. to hide one thing and show the other when a submit occurs 1. to check that all the fields are filled out when the user submits the form It seems like there's another piece of code somewhere, because usually when you submit a form it sends you to a different webpage, and you have to put in effort to stop that. That piece of code may be relevant to this situation It's not really clear what $("form-submit") does. I ... don't think that's a real thing? But it's `jquery`, so who knows. I'm assuming that what you wanted was for that to fire when a submit event occurs. Please remember, `jquery` is quickly diminishing in use, and a lot of people can't read it. But, generally, if I understood you correctly, I think you want something like this const sailingForm = document.querySelector('#sailingForm'), successPanel = document.querySelector('#sailingSubmitted'), firstName = document.querySelector('[name="firstname"]'); sailingForm.onSubmit = () =&gt; { if (firstName.value === '') { alert('Name must be filled out.'); event.preventDefault(); return false; } else { // it's probably better to do this in css instead, but successPanel.style.display = 'block'; sailingForm.style.display = 'none'; } };
I’m sure there’s lots of other great advice in here: but one thing I’d like to add: forget about the notion of being a leader of great “JavaScript programmers” as if they is some sort of difference in leading someone writing JavaScript vs leading someone writing Ruby. You’re leading *people*, no matter what.
That worked, will play around with it and let you know if I need anything further. Thanks man!
Oh gotcha.
It's ok now. Somebody submitted a PR fixing that [https://github.com/amejiarosario/dsa.js/pull/4](https://github.com/amejiarosario/dsa.js/pull/4)
You should give elixir a shot, you'll fall in love.
&gt; What's the best way to fetch data from an api on the client side, to reduce the loading time. It depends on the shape of the data. &gt; Website is similar to kickstarter. Currently it takes about 8 seconds to fetch project data, user data etc. Where is the actual bottle neck? You need to figure out if it is the query time in the database, the processing time of the server side application, or the download and parsing of the data in the client application. &gt; What is the common method for these type of use cases? Assuming you aren't doing anything crazy (supporting 1 billion users, working with extremely large data, and etc) the standard fetch call from the client to a HTTP endpoint the responds with JSON is just fine. It is likely that the bottle neck is something else, not the mechanism you are using to get the data.
First, thanks for your reply. &gt;It depends on the shape of the data. Data consists of users (name, username, related project ids) and project information (description, blog ids, title, asked amount of money etc) and blogs (related project id, content as text and url of images and videos used) &gt;Where is the actual bottle neck? You need to figure out if it is the query time in the database, the processing time of the server side application, or the download and parsing of the data in the client application. Current it is a react app and not server renderer. When it is mounted, it checks if there is a token on the local storage and checks if the token is valid, if the token is valid then it fetches the user info. After that it fetches the project data of user and public project data (projects of other users) &gt;Assuming you aren't doing anything crazy (supporting 1 billion users, working with extremely large data, and etc) the standard fetch call from the client to a HTTP endpoint the responds with JSON is just fine. It is likely that the bottle neck is something else, not the mechanism you are using to get the data. Currently I don't want to overengineer with a system that supports millions of users. But still want it to open fast on the first entry.
&gt; Current it is a react app and not server renderer. When it is mounted, it checks if there is a token on the local storage and checks if the token is valid, if the token is valid then it fetches the user info. After that it fetches the project data of user and public project data (projects of other users) I think you are missing the point of my question. How is the data fetched? What does the back end piece look like? What kind of database are you using to store the data? Basically. Look in the networking tab of the browser for the data fetch calls. If the response time to those calls is really high then it is not the client application it is the back end.
Sorry. It takes 1.78s for the public data to be fetched. It's the longest api call from client. I use mongodb on ec2. Database and the server is on the same ec2 instance.
Lol there is already a spotofy extension for vscode. Since more than a year actually.
For the record, I want **this** exact extension, not anything else, as I stated.
Sorry, I missed it then.
Yea I definitely was into elixir for a while. I feel like it doesn’t add enough to Erlang though. It’s basically just a prettier syntax to it. Language-wise, obviously it introduces great build tools as well.
I mean, is it necessary to add much to Erlang? Genuine question btw, I'm still pretty new to Elixir but it seems to be good at pretty much everything.
I don't use TypeScript because if I wanted that kind of system, I'd use a real language (say, rust with wasm) rather than a compiler ontop of a language.
Why would you migrate if it doesn't support a feature that you need?
Basically, for me, it is to allow dynamically changing variables, methods / functions, and especially due to the use of `eval()` and `Function()` (the latter is often used to grab the global scope from within a `"use strict";` environment. The more annoying reason is I cannot figure out how to use it very well.
WebStorm gives better code inspection and deeper refactoring tool. My next project will be colossal and these tools are necessary. And just for fun, ofc.
It takes a lot of time for bigger companies to make decisions on such things as language. However, there are some particular things I don't like about typescript. One of them is feature bloat. For example decorators. Just use higher order functions. Why the hell to invent separate syntax just to make things look more complicated than they are. So as for UI's I think Reason &gt; TypeScript as I see it.
Decorators are a really useful design pattern this is a weird complaint.
Interesting, I have a coworker who claims the same thing, but also prefers strict typing in TypeScript. Come to find out, he prefers strict typing because WebStorm isn't too good at showing inferred types. I run multiple "colossal" projects using VSCode and it works great. WebStorm isn't free, so if you have a colossal team running this project, consider the cost that adds up.
1. I find JSDoc-ing my function parameters enough when it comes to types. 2. I'd rather avoid compilation where I can.
1. Documentation is good :) Especially for libraries, documentation generated from JSDoc can be a good way to keep documentation sites up to date. 2. Do you avoid babel, too?
The benefits do not outweigh the costs for me. In a well tested project I think the errors that a type system will catch are very few.
wasm doesn't have access to the DOM, though.
Sure, so I write a bit of glue javascript. No big deal to me.
I don't use TypeScript because I want to focus on my JavaScript skills using vanilla JS and I think the extra step/task of transpiling is a pain during debugging. I generally dislike using any language/tool that makes me focus on its syntax versus the underlying syntax of the 'target' language.
Honestly, I haven't run into enough problems with "normal" javascript to justify the investment into learning the ins and outs of a system that runs on top of js. In principle, type safety sounds great, but why reach for it if good ole dynamically typed js does the trick for you and your team? FWIW, I'm working at a place with tens of millions of visitors / month, and a combination of good documentation and prop-types for our react stuff seems to work just fine for us. &amp;#x200B; I guess I don't have a clear enough idea of the problems typescript solves.
do you have any projects on github or elsewhere demonstrating this? I've been wanting to get into Rust, and haven't yet had a project to learn it with -- examples might be useful
I don't. I generally just write javascript because I genuinely like javascript.
JSDoc isn't going to force you to think carefully about your input/output and tell you when you're fucking up. I don't see static types as a complication at all, except when you're first learning them and getting used to it.
This is a good reason! Once you're well-versed in JavaScript do you think you'd be interested in TypeScript?
I would otherwise agree if the current options didn't have a lot of drawbacks. TypeScript is a good compromise until wasm options are more mature imo
You can still do everything you just said with TypeScript. It’s just a layer on top of JS, so you still write JS.
Honestly I'm anti-typescript, but ... I'm even more anti-eval. There are good use cases for eval, but they are few and far between.
I use both. It is nice to be able to type coerce a variable in Javascript sometimes, where typescript makes such things more burdensome. This most often comes up for me in comparisons where you have an API that returns numbers that are typed as strings. The linting I have to deal with currently won't let me do a comparison with ==, so I have to use === which forces strict equality, which forces me to recast my data before comparing. Is that really Typescript's problem? Ehh.... Sorta? It is just a downside of strong typing.
What if you're just developing or trying to integrate with other parts of the app that maybe don't \_yet\_ have tests?
do you think that the use of eval and Function reduces clarity or "ctrl+click"-ability / go-to-definition?
Sums it up eloquently. Type problems are just not a real cost to me (after a decade of coding JS), but Typescript absolutely is (to be fair, I only tried it for like six months, but still). In short, you pay more for it than you get.
I don't quite understand this argument, decorators are experimental and have to be enabled explicitly (and in my experience isn't used by that many, other than those using mobx). So if you don't use it how does it effect anything? It's a pretty isolated feature, so it doesn't change any other parts of the language.
What's wrong with pure javascript? As far as I can tell, the only thing typescript _actually_ gives you is the ability to say "this should be &lt;type&gt;", which you can trivially bypass in a multitude of ways. It's like typecasting in C/C++/every other weakly-typed language, except the compiler _can't_ even inform you that you're doing bad things. From my perspective, either you understand the interface you're calling (in which case you don't need strict typechecking) or you don't (in which case strict typechecking probably wouldn't save you anyway).
Because I don't see any reason why I would need it if I can just write Javascript.
As time goes on languages became more abstract to allow for faster development, that is partially why Lua, Python, Ruby exists. If C was easy to program, MATLAB wouldn't be a script language, they would just use C. Javascript came from a series of processes to allow its developer to think less about implementation details and more about behavior logic. When you re-introduces typing, sure your code is safer and less error-prone, but that is also an illusion: typescript still needs unit testing, integration tests, etc. Typing is just a technique for the compiler (transpiler) to let you know you messed something up which, while it works and makes your code better (and faster, for low level languages), it adds a lot of overhead: you need to know what each function returns (use an IDE to help you), need to predict your variable contents, etc. When someone reads bad Javascript code, you can think that typescript would solve the fact that variables are reused or mysteriously named, but that would not happen, code consistency, pattern usage solve problems. TLDR; Typescript solves very few problems for the overhead it adds, problems that I choose to solve them myself.
I don't think so, for me I don't see the gain (YMMV). I use [Visual Studio Code](https://code.visualstudio.com/docs/languages/javascript) and it does a great job with intellisense, identifying unused/misspelled variables, etc.
I don’t like typescript because it’s type system is too weak. Plus it’s obsessiveness to not generate any code based on the types makes it not that much better than plain javascript (eg fixing this, proper adts, pattern matching)
From experience I find that Typescript benefits the parts of the codebase that are badly written the most. Usually if the code is written well there's no need for Typescript.
Decorator is a function which takes another function as an argument and adds / extends to it's behavior. That's higher order function. Perhaps you could use your own advice?
This is going to be a stupid answer but mostly because no one sets it up, lol. When I was a part of some teams and had a non-leading role, I adapted to whatever. It was mostly TypeScript on back-end and JS on front-end. Now I do have a sorta leading role, but I don't feel like we need it for now (a small React app).
I work with TS &amp; JS - and I prefer ES5... to Next. JS on it's own is just crazy productive, and I find has a really nice-to-look-at syntax if you're into functional languages. The only thing I find is missing are interfaces - sometimes you wanna pass data structures around that you know looks a certain way.
My IDE (WebStorm) understands JSDoc and provides type checking based on it, it's not as powerfull as TypeScript but I find it sufficient so far. &gt; Do you avoid babel, too? For quite some time now. ES6 is universal (barred IE), so I don't see much use for Babel. I do use webpack, but I try to limit it to production builds.
This response actually made me laugh out loud
Personally, I do not like how it is trying to make javascript into java. If there were a way to write normal JS and have the benefits of typescript, then I would use it. Until then, I much rather continue with plain JS and normal tooling for catching errors: eslint, tests, etc..
TS really helped me when I joined a giant project and had to start working right away. Because everything was typed (the responses we were getting, the properties the data had), I knew what to expect and where and I was quick to edit the needed endpoints and logic. It would be much harder if I had to debug everything, not knowing what data I'm getting and what I'm supposed to transform it into. It made new people integration smooth - given they didn't refuse TS for no reason but were open minded enough to try to work with it. The sad part of this is that people (regular devs) who were on the project since the beginning didn't see (or refused to) the benefits of TS and said they could have been just as proficient with JS, which I do not agree with.
\&gt; For example decorators. This is a feature of javascript, not typescript (still stage 2, though) \&gt; Just use higher order functions. higher-order function's can't achieve the same things as decorators when considering classes. The current recommendation of decorators give the decorated function access to the class. [For example this decorator that syncs a value to local storage](https://github.com/NullVoxPopuli/emberclear/blob/master/packages/frontend/src/utils/decorators.ts#L22) used like this: @inLocalStorage myValue = false /* default value */; In order to pull this off with a higher-order function, we'd need a separate reference to the class inside of the class definition, which would mean the we can't define an instance property within the class, but would have to mess with the prototype, which then gets hairy when teaching people about what even is an instance method (in js: the answer is: "it depends" haha). &gt; So as for UI's I think Reason &gt; TypeScript I haven't ever looked at Reason, what's it like? How does it integrate with anything on npm (if at all? I know nothing)? &gt; All that object orientation jank in UI's doesn't provide much benefits if any at all &gt; But for state control, prop flow, UI's rendering is simply sucks. This totally depends on how it's implemented. Imo, a dependency injection system solves all of the suck that class-based state control can introduce. If you're familiar with React's Context, it's like a similar thing, except without having to wrap all the context providers.
I prefer the jet brains products in general but I cant get used to the look and feel.
I don't use Typescript because I hate writing type definitions
Because the company I doesn't want to invest in education or hiring better experienced JS developers
If it works for you, and your team great.
Because part of the reason I love javascript is that it's not a strictly-typed language; once you know its ins-and-outs then its coercion becomes a very neat and useful feature, and I wouldn't trade it away for the world! &lt;3 Whenever I work in Unity C# I'm always so glad when I come back to a JS project just because it's so much more flexible and pleasant to use.
Maybe I have an aversion to it because I've only used it on legacy projects, but it just feels like another hoop to jump through.
if they documented the data types and how the software is working, do you think ts would be unnecessary?
I think that TS reached its' goals when type definition became Turing complete. What means that JS model is overcomplicated and we need to find a way to simplify JS itself instead of making more complicated and intelligent systems over JS.
Because at time you really feel is it actually based on javascript, which sucks.
Yes you can. You can replace redux recompose with decorators on class components and it will work the same. So I cannot agree that it doesn't work on classes. They are not experimental in TypeScript as far as I know. And I was referring to TypeScript. They are quite extensibly used in Angular and things like Stencil. &amp;#x200B; Reason is OCaml inspired language which compiles to javascript. Ocaml, unlike langauges like C# comes from ML family of languages, not C. It's more of a functional language with very smart type inference, namely due to how the language is structured. However I do think it only really benefits React of all major view libraries / frameworks.
Serious question: are you not using ES2015, ES2017, etc. features and transpiling them via something like babel?
u/blukkie and u/ghostfacedcoder For the `eval()` I can understand yet only to a point (you cannot just assume `(function*(){})`, `(class{})`, etc. is available by User-Agent sniffing (especially if there is no User-Agent equivalent to check). The worst is the extra time (and files) needed just for a simple project: this is what gets in the way of actually using the result. Made a logic error? Gotta find it, edit the source, and recompile the whole thing.
I'm curious if you've ever worked in a strongly typed language before? I'd encourage you to try one out if you haven't. There's generally a pretty big difference between type safety and JavaScript intellisense. For me, I prefer not even having those errors be possible.
You don’t have to write them :/
I can’t recall the last time I or my team had a bug because of loose typing.
You do but you’re skilled enough to not notice the pain point. Typescript enables faster dev cycles and enables ether overall quality of the code base. New members get up to speed with typescript way faster than standard JavaScript.
thanks after lying awake thinking about it i understood what it did so did does and if statement execute the statements in order
Likely hasn’t. Once you really learn Typescript you don’t go back.
In that case, is the problem more likely to be that you don't have tests, or is the problem that you aren't using ts?
Ctrl+click only fails if it is triggered by a `&lt;a href="javascript:/*code*/"&gt;&lt;/a&gt;` (that runs on the current page), or an event such as a click. `eval()` and `Function()` do help when one is making a development environment within the container (which is what I do use them for on my own for-me projects)
I tend to install @types for certain libs for better code completion, but I avoid TS mainly due to verbosity and the extra step of compilation. I gave it a try, I did like it, but didn't find it super useful. Maybe because I love writing tests for my code, so I kinda find most of the possible type errors anyway.
You don't have to write typedefs to use js libraries at all. You can just use the library in your ts code.
If part of it doesn't have tests, I'd add the tests before I added TS.
I'm curious. What in your opinion is a good and bad case for eval?
the big advantage is that intellisense tells you all that "for free" as you need it. No need to look anything up. Greatly reduces develop time.
I've noticed this, too
Easy enough to miss a mistake. The compiler prevents that.
That’s a silly question. People won’t unless it’s enforced/required as part of ongoing workflow. And even if people did write external documentation, if it wasn’t in intellicode/the IDE, it wouldn’t get used. These are the exact problems TS solves so it’s like saying “would you define types if you didn’t have to define types”
Almost everyone uses typescript these days, indirectly. Many text editors are using the typescript language server, even for JS. I see people surprised when they get random "perfect" autocomplete suggestions here and there. I find it hilarious because that's the experience I have all the time with TS. Javascript has types anyway, all the functions and classes you create for other devs to consume have contracts. That's why DefinitelyTyped is a thing, all those libs already had contracts, they were just not documented. The alternative to TS is using JSDoc comments or just having a non-optimal developer experience.
Mainly because of the transpilation step. If typescript was natively supported in browsers, including their debugging tools, then I'd switch to it yesterday.
That is no valid reason in my opinion. That's like saying "I don't wear a seatbelt, because if the car explodes, it doesn't save me". Of course your code needs good unit-testing but TS makes it way easier to understand existing code without having to dig too deep into it. Also: PHP became popular in a time were there were no real alternatives beside things like JSP.
I skip them for the most party. I don't use "strict" mode, because of this. My TS usage is mostly for me in my own apps.
Nice work, this is really nicely made. As an aside, it seems that the Spotify Web Player can also be used as a progressive web app (PWA). It may not be as smoothly accessible as the extension, but it does add a shortcut to your desktop, taskbar, or start menu, and opens in a bespoke window. It should also work in other modern browsers like Firefox.
I’m hoping webassembly will save me from both.
I used to do a lot of C# and having to declare my variable types was one of the most annoying things about it as much as I love the language itself. I do mostly JavaScript now but when I occasionally go back to C# you bet your ass I'm abusing \`var\` every chance I get. This is the main reason I don't use TypeScript, even though I can see the advantages.
Imagine a big codebase. You want to refactor a function. Its signature changes slightly (e.g. you now return 2 things instead of 1 and you group them in an object), because you realize that by returning this other thing you get more useful context for the callees. The function uses a pretty generic name which is used in other places of the application too (having such a large codebase, this can happen often, because you usually enclose methods in modules and the function name can be simple because its functionality can be derived from the module name, e.g. a module named `requestConstructor` could have a `get` and a `post` exported members and everyone more or less understand what they do, but imagine having to refactor `get`). So, you solve this by searching the whole codebase and going in one-by-one the places to see if it is the referenced function and change it. This will complete the refactoring, eventually. This is the javascript version. Enter typescript. You change your function signature and you get 7 errors. That's exactly where you need to look at and it also validates that your change stands type-wise, after your refactor is done. You feel safe about not having runtime errors! Of course, there's a small overhead of needing to input types, but if you use jsdoc and stuff to document types, it's actually faster to use typescript, IMO (having used both). As an anecdote, before typescript, the same codebase was using javascript! And I felt pretty safe, but once we started adding types we saw so many things that we had done wrong or forgotten fields inside objects and stuff that we were amazed that the system was operational! We also solved dozens of bugs that were yet to be discovered because they were out of the happy path. Overall, I feel it makes the system much more stable in the long run, development faster (if we are talking about a large codebase) and a lot of times during development it saves a lot of time by skipping you having to see the error during runtime to realize that you've goofed something by mistake.
&gt; If there were a way to write normal JS and have the benefits of typescript, I’ve heard that this is what you get with Flow. Anybody have a comment on that?
I recently had to extend a Typescript Interface on a popular 3rd party ORM library due to missing properties. The Interface it shipped with was for another 3rd party library it used for validations. It was easy to write the extension, but it introduced a time consuming problem that I've never encountered with vanilla JS.
my reason is I use react and it feels complicated to set it up for react. I might use it on server but then the problem is not every library has typings
If you think TypeScripts type system is weak then I’m pretty sure you are using it wrong.
&gt; typescript still needs unit testing, integration tests, etc. The fact that people think they get stop testing because they use typescript is baffeling to me. &gt; it adds a lot of overhead: you need to know what each function returns I'd argue the opposite, and say that using Javascript without types adds a lot of overhead, because you need to lookup what each function returns, or just try it, and see what it returns, which is much slower than the compiler / tooling telling you what it is before you use it. &gt; TLDR; Typescript solves very few problems for the overhead it adds, problems that I choose to solve them myself. Without types, how do you know if a function returns an object or an array (without looking at it)? &gt; Edit: Also think about how popular PHP, powering more than half of the web while it is like untyped C with memory management, classes, and interfaces. This is a ridiculous comparison. C has the least features of any language that isn't assembly (and is also ancient).
You still need to do same declarations with flow. For instance type annotations, etc.. [https://flow.org/en/docs/types/](https://flow.org/en/docs/types/)
But why wouldn't TS help you write tests? imo, Typescript makes testing easier, cause you get intellisense
Pretty much the only "good cases" IMHO are special cases. For example if for some reason your app *needs* to be able to store arbitrary JS code snippets in the database and then combine them in random configurations, maybe `eval` makes sense for you. But most of the time I'd think you'd be better off using an alternative solution, like say expr-eval which let's you store basic computations as strings which you can evaluate later.
Yeah, I wish the type system was stronger. I think it _might_ get there... eventually? In the mean time, I've been wanting to try out this: https://github.com/true-myth/true-myth#why-do-i-need-this -- lots of inspiration from F# and other better-typed languages
I survived coffeescript.
Right. So please explain me how to define the types of functions that need higher kinded types, for example. Let alone anything more interesting. Since typescript cannot do these things it helps me more to write plain javascript and write more tests. This allows me to write very simple code, rather than complicated and redundant code to please the way too simplistic type system.
If you're casting to an any then casting to a different type, it's gonna be pretty clear you're probably doing the wrong thing. And no matter how well you think you understand the interface of a function, in any sufficiently large project you're gonna mess it up, a lot, sometimes in ways that won't immediately be obvious. Having your compiler let you know and force you to fix it saves a lot of time and headaches in the long run.
The worst thing that can happen in a productive environment is the emergent of completely risk-averse behavior, especially if it comes at the cost of employee autonomy and trust. People who are afraid to ever break a rule even if it’s the right thing to do aren’t people who ever feel like going above and beyond. Turned around: people who aren’t afraid of their management and feel empowered and supported by their leadership collaborate better and are more productive and loyal .... and why shouldn’t they be? When asked “Why would you go above and beyond like that for xxx?” The kind of people who go the extra mile and do the best work inevitably respond with something along the lines of “Because they would do it for me.” Isn’t that the kind of person you’d want to work with? Hell, yeah! There’s a leadership motivational speaker named Simon Sinek that talks about this. Here’s a version of one of his talks about this, specifically. https://youtu.be/lmyZMtPVodo He has another example that’s not in this linked video that he discusses a guy that works at a coffee shop in two different casino hotels. In the hotel where his management makes sure he is taken care of and that give him the autonomy to do his job, the guy is a super star employee that everyone loves and who provides incredible service. Same guy in another hotel with a ‘follow the rules or else’ style of risk averse management, he just does the bare minimum work to get buy and not get fired.
I do hope you’re right. But I’m afraid we won’t get there. If people wanted strong type systems, purescript would have been much more popular. From my perspective, most people prefer writing repetitive and redundant code in a style they are familiar with, rather than learn something new and write much simpler code.
Not OP, I haven't used typescript yet but from what I've read Typescripts type system isn't sound, which kind of means it's way too easy to circumvent the typing guarantees and do stuff like this: https://www.typescriptlang.org/play/index.html#src=function%20messUpTheArray(arr%3A%20Array%3Cstring%20%7C%20number%3E)%3A%20void%20%7B%0D%0A%20%20%20%20arr.push(3)%3B%0D%0A%7D%0D%0A%0D%0Aconst%20strings%3A%20Array%3Cstring%3E%20%3D%20%5B'foo'%2C%20'bar'%5D%3B%0D%0AmessUpTheArray(strings)%3B%0D%0A%0D%0Aconst%20s%3A%20string%20%3D%20strings%5B2%5D%3B%0D%0Aconsole.log(s.toLowerCase())%0D%0A Here, you have a string array and typescript allows you to add a number to that string array, which is kinda dumb.
TS hurts test writing. It hurts writing *everything*; writing TS, by it's very nature, takes longer than JS. Now you can make an argument that that cost is outweighed by benefits, but you seem to be missing something basic by asking "why wouldn't it help write tests", when it clearly does the opposite.
That went in-depth really quickly. I could imagine too quickly for some, especially given the example project requires some mathematical background to really follow. That said, ReasonML is a really awesome language and I wish it were embraced more by the JS community. Its focus on functional programming is a really good match with React projects and the new bindings they released recently have great support for React hooks. Interoperability with JS can be quirky, but its ecosystem is getting quite well supported really quickly. And its type system is so simple yet so powerful that I feel it offers an easier path to learn than TypeScript (provided you appreciate functional programming) and gives a greater reward by being more strict at the same time. If you haven't tried it yet, give it a go :)
Glad I could help.
Not that guy, but, no i'm not transpiling. just straight ES6. It mostly all works, and anything that doesn't work is the strictly bleeding edge new shit, and even most of that works on every browser these days in terms of javascript. I've run into very few things that needed a workaround, like the differences in implementation of event paths.
I wanna say first, fuck jetbrains and their shitty sales tactics. I have stopped using webstorm at around version 10 and have not renewed my license. &gt;Come to find out, he prefers strict typing because WebStorm isn't too good at showing inferred types. BUT, I find it hard to believe it became worse than VSCode at such things, I consider myself a power user of both and WS was always better at language features than VSCode. It's been a few years since I've touched it, but I just can't believe anything drastic has changed, it's a paid product. The extension ecosystem is probably better for vscode, but I'm not talking about colorful brackets here.
Perhaps that's the problem I have with decorators. For me it looks like needless feature which tends to help to deal with patterns which are unnecessary in javascript to begin with. And I would argue bring more harm than good and just accumulates jank. And I know my away around object oriented code. Or well, what people usually refer as object oriented code. Many people do claim they do OO, but they actually do procedural code which they modularize via classes and compose with the help of DI IoC frameworks. We actually learned to move away from OO code with ideas like stateless services for example and dumb state objects. Why? Because OO failed to deliver on it's promises. [https://www.youtube.com/watch?v=QM1iUe6IofM](https://www.youtube.com/watch?v=QM1iUe6IofM) a good video which touches on most points about it. New generation languages realized this. Go doesn't have classes. Rust doesn't need classes, and idea of behavior and state being separate is core to it's design, which leads to zero cost abstractions. Kotlin is moving away from encouraging OO patterns, still has classes though. But given all this experience and context, someone still decided that it's okey to bring them in ES6. Why? And now we are building even more fluff around this. Private fields proposal which was not without contraversy. Decorators which supposed to help to deal with them. Dependency injection, when for the most part ES6 module system is sufficient. I'm afraid that language I do most of my work... is turning slowly into a frankeinstein by people who probably came to front-end from languages like Java, C#, Ruby or modern PHP. and wanted to push into it what they are familiar with rather than what's beneficial for the actual tool. I'd be fine if all of that stuff was kept to TypeScript, but it isn't :/
Documentation easily falls out of date. Especially, if you aren't using JavaDoc style or something where it is right inline with the code, but even still. A function gets refactored, arguments are changed, and docs are missed. Or, some other part of the code that calls that function is missed in the update - missed in test coverage, code not well exercised, etc. Instead, your compiler tells you things are broken and your build fails.
Our apps are small and are constantly changing, doesn't seem to be worth it.
I've never said otherwise...
Have not gotten around to it, not running into problems where I felt I needed it. I plan to try it but other things come first until it is a necessity.
I understand. Thanks for kind explanation
Documentation would be good, but TS lints it live, docs get outdated fast. Writing in TS (especially if you're not used to it) might slow you down but so does writing docs. If I had to choose between writing documentation and using TypeScript, it would be TS without a question. It's also much more accessible if it's in the code and I don't have to search and scroll some documents when I'm supposed to be focusing on coding.
Has anyone used this? How helpful is it? Is it as easy as the site claims to be?
I've been converting some code from JS to TS in a project. The original devs were very good but there were plenty of misses. There was a ton of defensive coding - checking for null and undefined, checking for arguments being a number or a string, has own property on objects. They thankfully wrote a lot of tests to test all the defensive coding practices. Converting to TS, I eliminated a LOT of code from some otherwise simple utility modules and a lot of test cases. Less code. Less complexity. Less to maintain.
Not much of an investment, could pretty easily come to terms with it after one project. If you’re using Babel, you’re already going through a transpilation stage which is the only deployment hurdle with typescript. Hurdles harsh as well since all you have to do is run `tsc` and everything in your config does the rest.
If you take the time to document data types why not define them machine-readable in the first place?
This has been my experience as well!
Yes you do otherwise you're not using Typescript... parts of your code will use Typescript, others parts won't be... this additional complexity makes it a nightmare to deal with.
You did say that you shouldn't focus on data structures because "these things are already well made and managed by the language internal logic" which doesn't really make any sense.
Exactly same here.
I don't think that's abusing `var` in C#. It's implicitly typed if you do `var foo = 15`. I see no need to declare the type first there. Just the same as I would in TS with `const foo = 15`. Implicit typing is fine and it's a feature. I think pretty old C# version didn't allow implicit typing but I could be wrong. Might be habit of devs who were working in C++ or something prior.
&gt; If there were a way to write normal JS and have the benefits of typescript, Not related to javascript, but have you looked at F#? It is fully typed and has _amazing_ type inference.
Yes I work primarily in C#. I agree with you, I just didn't communicate well that with VSC + JSLint I don't see the benefits of TypeScript (again YMMV) - as those tools help me write better JavaScript (less duck'ish and more OOP).
An even shorter example, which bites me in the ass every now and then: const strings: string[] = []; console.log(strings[0].toLowerCase()); https://www.typescriptlang.org/play/index.html#src=const%20strings%3A%20string%5B%5D%20%3D%20%5B%5D%3B%0D%0Aconsole.log(strings%5B0%5D.toLowerCase())%3B
trust &lt; verify
&gt; You can replace redux recompose with decorators on class components and it will work the same. So I cannot agree that it doesn't work on classes. I was talking about on fields, not wrapping the class itself. &gt; They are not experimental in TypeScript as far as I know They are. In order to use them, you need to set "experimentalDecorators" to true in the tsconfig. &gt; with very smart type inference I love me some type inference. I've done F# in the past and loved it. &gt; However I do think it only really benefits React of all major view libraries / frameworks. I actually think Typescript was the *most* awkward in React until React changed their main recommended paradigm to hooks. React + classes + typescript + higher-order-component felt very cumbersome, imo.
I agree with the other comments here. I can see the benefits of Typescript **IF** JavaScript was typed out of the box but it's not. It's a wrapper around JavaScript that introduces a ton of unexpected bugs and headaches. TSLint will complain at the most idiotic things like a missing space on particular line or your imports being out of alphabetical order. Fine, you can adjust the config for that, but now I have to manage all these highly sensitive settings when I could have just used Prettier for style and ESLint for warnings. I've inherited many Typescript projects... I always prefer vanilla JavaScript with good documentation. Also, I didn't start with dynamically typed languages... I started with Java and the typing for it was fine... this isn't an issue with me preferring dynamic typing -- it's a problem with Typescript.
this
Webstorm + JSDoc + EsLint has been pretty solid at warning against type bugs for several years and we’ve already built up our codebase around it. We rarely have type bugs with how our team programs though most likely due to the tool chain mentioned.
It's all about ease. A little investment in typing shit in your project early, ensuring interfaces are well-defined, make sense, and _work_ saves a whole lot of time over the course of the project. Doubly so if you're not the only one working on the project. Sure, there could be documentation, or comments, or other self-enforced stuff that can communicate the same information, but why not go with the tool that communicates that information _and_ does it while you're working?
I mean, if you use JSDoc heavily - in VS Code at least - it'll give you many features TypeScript code base would. Not all but many.
You've never seen an error thrown because some variable or property is undefined?
I think this is the most legit reason to not use typescript. If your project isn't big enough, why bother?
Old versions did not. I didn’t realize you were allowed to use implicit typing in TS. This might make me more eager to try.
We use jsdoc + Typescript (or Webstorm) to do comment based type warnings without having to write Typescript.
I use Typescript on a big app which is served data via graphql (Apollo) which, due to services potentially being down, has a lot of nullable fields. Optional chaining would have sooo much upside for this app. I really want it. The downsides mentioned (like broken chains due to typos) don’t feel as relevant for typescript, where the transpiler would yell at you. Also the idea of normalizing all these fields doesn’t really solve any problems I run into personally (and would add a ton of boilerplate). Please give me optional chaining. Please.
I think the moral of the story is that no program should be only one paradigm. Sticking to only OO will cause problems. Sticking to only FP has other tradeoffs. Sticking to only one paradigm has tons of tradeoffs. Using all the paradigms in harmony gets you the best of every world. Also, that FizzBuzzEnterpriseEdition is a huge joke. haha. 'They' had to go so far out of their way to pull that off. &gt; is turning slowly into a frankeinstein by people who probably came to front-end from languages like Java, C#, Ruby or modern PHP. and wanted to push into it what they are familiar with rather than what's beneficial for the actual tool. Why do you think it's Frankenstein? The TC39 group spends an excruciating amount of time trying to get things right. &gt; I'd be fine if all of that stuff was kept to TypeScript, but it isn't. I actually disagree, because, the more in Javascript it reduces the learning curve of typescript.
With hooks reason + react looks so good! The only thing that is holding (at least me) back is data fetching and async story. Current solution with callbacks doesn't "spark joy" for me. My guess is they are waiting for the concurrent rendering in react with react-cache and other stuff and then maybe we won't need to write async code.
what's wrong with transpilation? do you use babel?
You prefer es5? As in “var” over “let” and “const”?
If they use jsdoc, they could get lot of ts benefits without changing anything, as ts can parse jsdoc.
Learning curve for the team. Leading a team in a startup.. there's just no time
Until you are a developer coming on to the project and you come to some function and it takes X and Y variables, but what are they? What properties do they have? What methods are available? Are the doc strings up to date (unlikely in my experience)? Coming back to code later or joining a project just makes visibility of what's going on so much clearer.
No, for the same reason. But I also use WebGL and if a browser doesn't properly support ES6, it's not going to properly support WebGL either so babel doesn't make any sense for me.
It's not all or nothing. You can still use libraries that dont have types just fine. And for libraries that don't come with types, the DefinityTyped project certainly covers a ton of projects that are on NPM. Sometimes, if it's not on DefinitelyTyped, I take an extra second to think of the dependency is worthwhile. Do I want to ensure that this license works for my project? Does it have a lot of open issues? Does it seem well maintained? How much effort is this new dependency really adding for me? We should be asking those questions anyway taking on a new dependency (remember when left-pad went a way and everything broke?) but availability on DefinitelyTyped makes me take another sanity check.
&gt; by it's very nature, requires writing type definitions But it doesn't. If there's something where you don't want to use types, simply don't define types. The time it saves by making it possible to provide proper intellisense is worth the effort alone for me.
That's primarily a Flow problem, not a TS one.
&gt; it adds a lot of overhead: you need to know what each function returns &gt; &gt; I'd argue the opposite, and say that using Javascript without types adds a lot of overhead, because you need to lookup what each function returns, or just try it, and see what it returns, which is much slower than the compiler / tooling telling you what it is before you use it. I think this is the core point. You read code much more often than you write it, and reading is harder because you don't have the context the original author had. That alone makes it a time saver.
Even more important than the return types is the members each object has. With typescript intellisense will tell exactly what you can do, while without ts, vscode will simply suggest random words you've used in the project.
oh cool. that's fair. what are you doing with WebGL?
This. Everybody is telling why they don't like TS. For me it's more why I like JS, untyped. I came from C# and learning JS was weird at start but became such a relief after a short time. I don't have to worry anymore about fracking types and definitions. Everything can become anything. I discovered a new fun and powerful way of coding. Coming back to types seems like a regression. Unit tests unsure safety of critical parts. This main advantage of types seems to be intellisense for most of people. Again after switching to js I dropped visual studio for vim. I ve learnt again a powerfull tool. I discovered I relied to much on intellisense. The same way I relied to much on my GPS. In the end I just follow the road but I never bother learning it. Now I learn and plan ahead my road map with vim and js. I own my tools, not the opposite.
If you have a really well tested system, it can give you the same level of safety as static typing does. Writing tests typically just takes a lot more time.
I've been a big fan of Svelte for a while, since seeing it first at JSConf EU 2018. I do have mixed feelings about Svelte 3, however. While it looks great, it is a complete rewrite of the previous library and it is completely backwards incompatible. This might be the "Angular 2" moment of Svelte, sadly.
Because the tech leads for UI are vehemently against anything that they don’t already know for my project. Anything that challenges their knowledge causes a shitstorm. Our app would benefit greatly from TypeScript, but I doubt it’ll move there anytime soon. As for personal projects - it depends. I am using it for my main side project, but for little ideas I just want to get out there, I don’t bother. It slows me down compared to regular JS.
But I like the nice intellisense and error checking that comes with type defs :( I feel like if I'm going to write dynamic code I'll just use JavaScript. Then I also won't have to build the project which sometimes can take some time depending on how big the project is.
You clearly don't need to support IE11.
&gt; Personally, I do not like how it is trying to make javascript into java. I don't think you'ver ever written any Java code. Typescript is by design just a system of types on top of Javascript, it doesn't add new features or removes existing ones. You can take your existing JS codebase and add typings where you like, and that's all it takes. It doesn't force any particular style of writing.
It's just extra steps that I never bother with. I have little control over what we use at work. For my own projects, they generally start off with me just coding something up on the fly in JS. Most of the time it gets abandoned, but for the ones that continue I just keep building off that foundation.
As long as you're declaring AND initializing the variable at the same time, implicit is fine. ``` let foo; // error let bar: string; // ok bar = 12 // type error. bar must be a string. bar = 'some text'; // ok. A string is being assigned to bar const myVar = 'text'; // ok - myVar is of type string. ```
It wasn't mature enough when we started our codebase, and we're not motivated to migrate to it.
You might be missing the point of typescript though. TS doesn't take anything away from you, it's all just extra on top of js. You have `any` type in typescript when you need it. It's also very different from C# and other strongly typed languages, as you often don't have to explicitly define types.
Absolutely. If you help people too early they never learn how to help themselves! I was unlucky (or, lucky?) enough to never really have any help while I was learning the ropes, and whilst that was all really stressful it \*does\* make you quite good provided you are able to actually keep your head above water!
No I don't. Why would you keep working for a company that does?
vscode will do this for jsdoc annotations in regular JS too.
If you use a webpack watch with live reload, the recompile time is typically less than a second. And what's more, it reloads the page for you as well. If you don't support IE11 then transpiling isn't an issue. But not everyone has that choice
Polyfils?
Because GHCJS babyyy
It forces you to add types just like java does. That was not javascript's intention when designed. JS was intentionally designed not to be like java and other type languages. Hence my statement. Please dont make assumptions about whether I've written java.
Agree 100%, an example where I ran into issues with this. Is when you use a 3rd party library that doesn't have type defs, you don't write them so you have to write dynamic code. Then several months later you refactor parts of the code and when you build the project, the build fails to catch some code that normally would have bee caught using typed code. Leading to some logical errors that are harder to catch. The bigger the app you have the bigger of a problem this can be.
The benefits it brings aren't worth the additional friction I get during development (or, at least they haven't been yet). There are a few instances where typescript makes your life slightly more difficult IMO. Truth is though I'd love an opportunity to take typescript for a proper spin but i just haven't yet.
Maybe not.
I would be only curious about people who have actually used typescript and decided to forgo. It's one of those things, like promises and async/await, that I found easy to nock until you try it! I have been writing JS for years and pride myself in a deep familiarity with it. However, Typescript makes js more accessible to people who don't know all the WATs. Also one of the biggest benefits that typescript offered to me is the IDE interaction, but a lot of our junior js devs just wait to compile as if it was another build step. For me and my coworkers that mostly write Scala, it's a tool to help you write code faster. We don't even use strict: true and I personally wouldnt recommend it, as it does bring too much overhead for the benefit when absolutely everything needs a type.
Such decisions are made based on what browsers most of our users are using. For new projects though, we have stopped IE11 support.
I don't disagree with the idea that multi-paradigm is usually the way to go. However I think it's important to reflect why we seen such emergence of FP in UI's. See, in my opinion, what allowed for web sites pages to become fully fledged applications was not components per say, but that we managed to separate state by abstracting the dom away. Components made it easier to do accomplish, but it's not the crux of the matter. Say back in the jQuery days when we manipulated the dom directly, state was always present, but was coupled to dom itself. So to infer anything about current state required additional work which made everything messy and hard to maintain. ``` if ($(#element).hasClass('.class')) { $(#element).removeClass('.class'); } else { $(#element).addClass('.class'); } See state is there. It's just ... ambient. Lost in the dom. Now with architectures like flux, we have state in separate entity. Have components which compute through that state and output the result (view). With additional tools like Virtual DOM we can do those computations efficiently and flush / commit once we have the full picture saving expensive rerenders. What I feel that with classes and artificial DataTypes (classes) we are moving back to mudding the waters again for no good reason other than misleading sense of familiarity. TC39 is consisted of programmers, it's community driven. And while I do believe it has higher level of competence than an average programmer, they are still suspect to same flaws as all of us humans are.
I actually use rollup to merge all js files into a single one (~300ms) instead of webpack, because the latter has a ridiculous dependency graph that even includes (or used to include) completely trivial stuff like the is-odd "package".
As I understand you basically say „I like ts features in third party libraries but I will not use these features in my code when I‘m writing my own code to make it easier for other people to use my code“
Even if you haven't, at least for me, having proper intellisense alone is worth the effort.
Yea.. but those docs are not always updated. And if you modify something you need to manually check everything again... which takes time.
Because Visual Studio Code already has built in type checking for JavaScript if you add the inline documentation. There's little to no added benefit to using TypeScript outside of their custom classes. And if you use them, it becomes bloat. Also in terms of maintenance, it means adding a barrier of entry for other developers that know JavaScript, but not TypeScript. I just code in ES6 and make good use of TypeScript's Salsa module. You get the intellisense and type-checking as a developer, but 0 runtime change for end users: https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript
&gt; it's gonna be pretty clear you're probably doing the wrong thing. Maybe, maybe not. Sometimes I _really do_ know better than the type system, and that cast is perfectly valid if a bit funky-looking. Other times I'm definitely doing the wrong thing. Here's the secret: it's nearly impossible to tell at a glance whether or not it's the wrong thing. &gt; in any sufficiently large project you're gonna mess it up, a lot, sometimes in ways that won't immediately be obvious. This is true with or without strict typechecking, so I don't really see it as a benefit as such. Consider an interface that takes in two strings and returns a int. What values are acceptable for those strings? What should I do with the return code? What happens if I mess any of that up? None of those things are communicated by the interface. _Those_ are the kind of language features I want. Currently no language supports that in a sufficient way with any amount of popularity.
If you are using promises then yes a polyfill will help you there. Not for es6 features like classes or even object.assign. You have to transpile it down to es5 code for it to work on IE11
It's not that I don't want to use features, I do. It just time consuming and at my work sometimes we are limited on time. For my smaller projects I don't have any issues using TypeScript.
All my typed JS stuff uses flow because I preferred it. I felt at the time TS was more aimed at Java devs and flow was more FP. In future types projects I’d most likely use typescript, because it looks like it’s now the defacto type checker. A lot of originally FB projects have switched to it. It also looks like they handle FP much better now than they used to.
I do TDD which means I literally don't need type error checking because I use strict equals in my tests. I also destructure my objects in public apis so that's my documentation. I work alone or in small team so that's the only documentation I need, though interfaces would be nice, not worth using typescript as it doesn't solve any problem I have. &amp;#x200B; Also "For me, I use typescript because I like to be told what I'm doing wrong -- before I tab over to my browser and wait for an update." That should never be the case in vanilla JS, you should be using a linter and have automated tests that tell you where your errors are before you touch the browser.
Why exactly are you complaining about TSLint when we're talking about typescript? It seems like you've used some kind of boilerplate template and didn't like the settings it gave you, that's not a problem with typescript.
Hey thanks for this, I already had this in my HTML file, but it made me realize that what I was actually looking for was "action" under &lt;form&gt;. This allowed me to link a completion page, which I guess is what I was trying to do 😅. Unfortunately this doesn't seem to be working so well for me on weebly as I end up being led to a maintenance page, where refreshing the page brings me to the page I was looking for. Sorry I'm not the best at describing my situation, but thanks for the help!
So you're saying Typescript isn't extra work if I just don't write Typescript, and write ordinary Javascript instead. Hard to argue with that :)
Thanks for the reply, that code worked, but it was my own mistake that I hadn't used "action" within the form tag
if we're being completely fair, i've never been bitten by using function-scoped var before. let vs var vs const seems like a style choice at most. not using any es6+ features just blows my mind though. i absolutely love template literals. arrow functions for quick one-line callbacks are great, too. &gt;const fullNames = people.map(p =&gt; \`${p.firstName} ${p.middleName} ${p.lastName}\`); versus &gt;var fullNames = people.map(function(p) { return p.firstName + ' ' + p.middleName + ' ' + p.lastName; });
It also wasn't Javascript's intention for it to be used for anything else but simplistic animations and minor interactivity in 90's web browsers, but here we are. Tools evolve with time, TS wasn't created for no reason. Also comparing type system of TS with JS is pretty ignorant.
Well, I'm glad I could be of help. (You described your situation fine). Also if you want help with the redirect, I could look into that too. :).
Ive used both javascript and typescript and i find typescript to be slightly more annoying. Firstly, setting up a project takes longer (setting up source maps, configuring compiler options, etc..). Developing takes an extra step and sometimes you run into obscure type errors which can take a long time to resolve. Also finding type definitions for lesser known libraries can be difficult. I’d take plain javascript with good documentation, combined with an IDE + a good linter over typescript any day
It works in vscode too, but it's actually typescript understanding JSDoc, and vscode using typescript to provide the intellisense. I think it's the same with WebStorm, but I'm not completely sure.
I tried it again this weekend actually. Three hours in and god knows how many Github issue rabbit holes and different versions of various packages and I can’t even get a basic React functional component to render in a CRA app with typing. I gave up on it again.
Take a look at vscodium, it's vscode without Microsoft's telemetry.
I found react with typescript to be a bit difficult initially, but in the long run found it extremely useful in our complex search app which changes filters based on a dropdown context. With interfaces for each filter and context, it's extremely easy to debug issues. Another thing with typescript is that we don't use frameworks if they aren't a must have, like for a spa. We have 20-25 page based modules and a global file which initializes the modules. The intellisense makes it very easy to navigate without getting lost in looking for the code half the time. I get errors right away and focus just on coding instead.
Could you clarify what exactly do you mean by ts making writing tests slower?
I've worked many js-only apps in the past and recently I decided to use ts on a new react app I'm building. So far I can tell around 30% of development time has been more about typescript-ing things than coding the actual application. On the other hand, the code really feels "safer" and overall more reliable than if I had used js alone, so I'm thinking it really depends on what you value the most, development efficiency vs out of the box more robust code, and how much do you trust you and your team coding skills. To be fair, even though I had worked with ts before, never really needed to use more complex stuff (generics, inferred types on so on) so I should also account for some learning curve.
Not at compile time.
Its like learning to ride a bike. TypeScript is good for when you need those training wheels on to stop from falling off and scraping your knee on the road. JavaScript is when those training wheels come off.
1- I've been using JS before TS was cool. I had to learn how to write clean readable maintainable code without any tools. Now TS has almost no added value. 2- Most of my work is in the process of shaping. If I started using TS, I'll probably spend a lot of time just rewriting types. I'm really considering gradually migrating to TS once there's less moving parts, but not now 3- Using TS means that the people who will apply for jobs in the company I work with, will need to know one more tool just to understand what's going on.
In my experience, static types are a negative. I went out of my way to choose node.js specifically because it was dynamically typed. So typescript would have negative value to me - I might as well stay with C++ or C# if im going to use typecrap.
Or a downside of poorly written apis. Depends on your perspective.
Some companies have a part of their audience that use IE 11, it's not the majority of their audience, but it's large enough that IE 11 is still something many large companies (esp financial ones) need to pay attention to at least for the next few years.
Because properly porting the things that would benefit from TypeScript in our codebase would be a massive undertaking, and I have higher priorities right now.
While I take your point, *most* ES6+ features are polyfil'able https://polyfill.io/v3/url-builder/
This is a great answer and really gives me a clearer idea of TS's benefits. Thank you.
Of course, those could be inaccurate, incomplete, or outdated. I've been bitten by that before.
Actually I think it throws the styling errors at compile time... so it doesn't compile if you have your imports not in alphabetical order. You could argue that the styling enforcement and typing enforcement are different tools but I just fundamentally disagree with that. The config I used was the default config so now I have to go through all the config parameters and let it know, "hey, please don't yell at me if I don't sort my imports in alphabetical order!" just to be able to get my code to run. But it's so much more than just the style config... it's everything... importing third-party libraries is an absolute nightmare and the go-to solution people seem to recommend is: "well you can just use the \`any\` type for that!" Well then you're using Typescript in part of your code and not others adding complexity! "No but you can interface your third-party imports!" Yeah, so now I have to Typescript my own project AND somebody else's! Ugh, no thanks...
&gt; I guess I don't have a clear enough idea of the problems typescript solves. Typescript solves the problem of you being ignorant in Javascript. If you are a newbie to Javascript, Typescript is most likely useful to you. If you are a veteran of Javascript that envies strongly typed languages then Typescript is most likely useful to you. If you are an expert in Javascript, understand its pros and cons, then Typescript is just another transpiler (like CoffeeScript) the kids are playing with for the next year or two until another one comes out.
My brain just works really well with dynamically typed languages. It's not that I can't do static typing, it's just that I feel like I'm writing a whole load of extra code just to make the compiler's job easier. Now I totally understand why, in a high-performance situation, you'd want to make the compiler's job easier. But the web is not a high-performance environment, and performance improvements are not a design goal of TypeScript anyway. I've tried TypeScript on pet projects and really didn't gain anything that I don't normally get with React PropTypes and unit testing. Without it my apps work just fine. My developer experience is just fine. So I feel like TypeScript just adds complexity and forces developers to jump through hoops for absolutely zero gain.
What do you mean by weak? Do you mean it doesn't have a runtime type system because not even Java has that. Typescripts typing system is the most powerful I've ever seen. It lets you define inline enums that are actually just strings. You can define objects where for instance either data or err is undefined but never both. Then you can do a null check on one and not have to do it on the other.
I just haven't got around to it yet. It's definitely on the agenda though.
Yes, linter prevents compilation if it's configured that way, same applied to ESLint. But your argument makes as much sense as not liking javascript because of ESLint. TSLint is not part of typescript, it's completely separate project originating from completely different company than typescript.
I usually just have each project as a, well, separate project. You can have multiple projects open at the same time (in different windows), which is perfect for me for quick switching.
TypeScript is a set of extra symbols and syntax that get stripped from your code when it's compiled to JS. It's a superset of JS, so your code remains untouched when it's removed. I'd recommend using the Babel TypeScript plugin (and only that plugin), which does nothing other than stripping out TS-specific code. As long as you're also outputting a sourcemap file, you'll be seeing the exact same code in your browser's debugger and your editor.
&gt; you need to know what each function returns I feel like this should be a given whatever language you are writing in. It's just explicit in TS. &gt; need to predict your variable contents Is this really that difficult? If your variable might contain several different types, that sounds like a code smell. &gt; transpiling (to me that is terrible) The vast majority of big projects already have a build step, so this doesn't feel terrible to me.
The create-react-app makes it super simple
I should be grand now, I think the issue with the redirect is on weebly's side, as I know the linking is correct, it even redirects me to the page, just doesn't seem to load quick enough or something as I get a "Site is down for maintenance" error, yet refreshing the page works fine.
Problem: I have to write a doc and keep it updated. But since its not part of the code, it's easy to not update or even write documentation at all. Also, docs don't analyze your code like TS and help you catch errors or harden your code. Also, with typescript generate docs is even easier.
If they're constantly changing, that would seem to be an argument for adding TS. It makes changes *significantly* easier. It's also not counter to small projects. You may even be able to use it with just plain inference alone; no types explicitly added to your code. It's inference engine is *really* good. In my last TS project, only about 1% of my LoC had TS annotations. It's a lot more minimal than you might think.
In most cases, unless your project is already in TypeSript, the return on investment is quite low if even breaking even. https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b
That is kind of the point. TypeScript will tell you at compile time that something can be undefined (or, ideally, while you're writing it, with the proper tooling).
Because Flow is more simple as mainly sugar rather than a whole superset on top of js 😇
Right. And what I'm saying is I never run into issues at compile time. Issues are during runtime when APIs return unexpected things, users input unexpected things, etc.
I come from typed languages so I already write typed code without having to typescript it. I also do not try to write "clever" code so type mismatch bugs are rare. I will, however, consider it should I take lead in a project with multiple junior devs that need discipline to produce good code.
Because [Flow](https://flow.org/) does the same thing but better while also being less intrusive.
The thing is Microsoft makes TypeScript and VSCode and they've tightened the integration between the two a lot in the last couple years. I wouldn't be surprised if VSCode &gt; WS for TS
Because Javascript is about 5% of my codebase, but has the most complex supporting toolchain already. Needs its own separate build step, defined in its own weird meta language, installs thousands of dependencies... and constantly fails for no reason. I would love to use TS but can't really justify adding one more dependency.
Making changes in a small app is already easy. Seems like a waste of time having to add types to a feature and then remove them when that feature is killed/changed.
If the programs are small I tend to just use js because I know what types are needed for the functions as parameters etc. But for complex programs Typenscript is a good idea
Ah OK, I get you now. The usefulness of static typing depends heavily on the project. I have some that use it 100%, and some that don't use it. And some that started without, which I've started to convert after repeatedly running into issues a round of type checking would have avoided.
Have you checked if the page you are redirecting to is with http? If your redirect url is [http://blahblahblah](http://blahblahblah), and your site is on https, then the redirect could fail. That's all that I could find on this question (I looked on the web).
The first Typescript project I participated in was a disaster mix of events, observables, and actions. The second one was worst, also having inconsistently named variables, objects, and classes, using classes for no reason, and writing all code is the most verbose ways. It took me a month before I understood their app and many more months before I understood 3/4 of the code. After the month I was pretty certain I could have rewritten what a team did in 3 years, in about 3 months, alone, with babel env. My second biggest complaint with Typescript how much work it is to write concise code. I would say, for the time and expertise it takes to be an exceptional javascript programmer, you need to double that to do the same in Typescript and even the code I've seen is never as consistently concise as Javascript. There's a reason we didn't write everything in C++ which has all of the tools to be the most powerful language, most programmers aren't good enough to write as good of code in it, as they would be in PHP, C#, Python, etc. My biggest complaint, is that programmers become significantly more lazy while writing Typescript. They lean on it as a crutch. They stop worrying about variable names, they stop worrying about algorithms. All of their focus is put on maintaining typing and winning against the errors the compilers gives them when they've given too ambiguous of a type. I like Typescript for very special situations, where you need exceptional programmers to maintain an important shared piece of software that must rarely change and must constantly improve and be exceptionally well documented. Like a critical SDK that is on the lowest level of a system. Everything else should just use javascript, a better typed language like Rust, or a niche language, because it's a super niche domain (like GLSL for video processing).
This seems poorly considered and argued. Imagine if I said Javascript is for you need training wheels and machine code is where the wheels come off. Obviously nonsense right?
"Drag and drop components" Developer: *chuckles* "I'm in danger!"
Object.assign can totally be polyfilled. It's part of @babel/polyfill, or there's standalone packages like https://www.npmjs.com/package/es6-object-assign
"Constantly changing" is exactly why we relied on TypeScript to speed up when developing new features. No use memorizing or inferring arguments and return types when we're still working out exactly what data needs to be passed around. No more "wait, did I put this thing in that thing or the other thing? Or did I just forget?"
I use ESLint... no problems... If ESLint was a problem then yeah, I'd complain about JavaScript not having a good linter but I don't need to because it has a good linter where I don't need to change every default config setting to get a basic minimal product compiling. If I'm simply running some tests, I don't want to worry about a million rules and style quality... I want to worry about minimal viable example and then worry about styling and quality later. I get that they're different tools. I do. But they are entwined systems. Again, you can disagree here... but I think you'd be wrong to. Every TS project I've inherited has had TSLint. &gt;Today, *TSLint* is de facto the standard linter for *TypeScript* repositories and for the *TypeScript* implementation itself &gt; &gt;[https://medium.com/palantir/tslint-in-2019-1a144c2317a9](https://medium.com/palantir/tslint-in-2019-1a144c2317a9) Again, it's so much more than just the linter. It's a whole plethora of headaches that I have to deal with every single time I start developing.
This assumes TypeScript is actually telling you what's wrong.
Syntactically valid code can easily be wrong
This is a nice piece of work. Unfortunately it violates section 9 of the English-language terms of service: &gt; reverse-engineering, decompiling, disassembling, modifying, or creating derivative works of the Spotify Service, Content or any part thereof except to the extent permitted by applicable law [... is not permitted for any reason whatsoever] So I would avoid adding it to any high profile extension stores, and keep it on the Q.T.
Yep, thanks to @csilk's link. I saw that object.assign can be polyfilled. Learning more every day. But practically speaking instead of keeping a track of which es6 feature can be polyfilled vs which cannot be, I would much rather transpile it all down to es5 using babel transpiler
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
To me it's not a question of using or not using it, but rather when do you use it? There's no way I'd introduce TypeScript to my personal projects since it would be of little added value, but at work it's very nice to have type checking, although I wish any did not exist as a type. It pisses me off to no end how often I see people setting the type of a variable to any; defeats the whole purpose of TypeScript. Having said that, that is not TypeScript's fault, but rather how people use it. &amp;#x200B; But yea, I'm never going to use TypeScript when I'm writing a simple canvas game for lols in my spare time.
I use typescript because at work we use Angular but honestly, it’s just an illusion on top of JavaScript. It isn’t real type safety and this bugs me.
Thanks a bunch I tried the new code, it still isnt working Is it possible it has to do with the fact that I'm putting the code on a static webpage? At least I've learned a bit through the code on Fiddle
Kotlin
Have zero need
Sounds like an unoptimized backend (did you forget indices on all fields you search for?) or you ask for more data than you need at the moment. 8 seconds is an incredibly long time.
I’ve been programming with JS for the best part of 13 years and quite honestly the number of runtime errors I’ve had to deal with that were caused by incorrect typing are negligible compared to others that a type system would not solve. For me, a linter is a far more useful tool to catch oopsies before compile time.
And to be fair, I've wanted to try it, but I've run into huge roadbloacks getting it working in a React project.
For personal use, I hate build steps, and try to avoid whenever possible. For my corporate use, we require being able to run the direct code, so that we don't have to deal with any potential bugs in the build step. So, basically, it comes down to "build steps suck"
Yeah, integrating TS into an existing project is way too hard. I've never successfully done it. I mostly blame the complexity of the node.js ecosystem as a whole, though. TS by itself is a pleasure to set up.
I will look further ın the indices. And seeing that the actual data fetch takes 1.7s, I started to think moving the first data fetch to server side on page request might help. What do you think?
I think JavaScript is a good dynamic language, and typescript is a poor man's static language. JavaScript definitely has the strengths and weaknesses that goes with dynamic types. If that is not for you then I would reach for choices like rust, or go, or c#. At work as a backend developer I use typescript and I spend a lot of my time fighting the tooling. Typescript requires a lot of configuration, managing dependencies, and at the end of the day, I still get runtime type errors. It does save guard against errors when coding absent mindedly. But tests are more important. If you are using typescript on the front end, then ok. Sure. The browser is a special environment to develop against. But other than I don't want to develop in typescript. I would rather develop in js or in go.
Ya I tried before to link it directly by copying the URL, but I ended up with the same result. I've got linking working on other pages, it's just the form action that it seems to have a problem with annoyingly, but it's not the end of the world as it still works, it's just the inconvenience of having to refresh the page after submitting the form
Sorry I couldn't help. Maybe you should ask a weebly admin.
Whatever, doesn't really matter if you see them as the same or not. It's still dumb to say that you don't like typescript because TSLint default config is not exactly what you want. It's like saying that I don't like javascript because vscode default theme is dark. If every project you've inherited uses tslint and they haven't changed the config, they clearly want imports to be ordered. Maybe you don't like it, but the linter is doing it's job, which is to keep the coding style consistent and reduce bad code. &gt; JavaScript not having a good linter It's a bad linter because you don't like the default rules? Lol. &gt; I want to worry about minimal viable example and then worry about styling and quality later. Again, this is on whoever made the project. As I said, tslint is not part of typescript, and linting errors won't prevent compilation unless you configured your build pipeline that way. Same applies to plain js as well, you can make linting errors to cancel the build.
Thank you for the link. I am working towards making this project open source but there might be an issue with copyrights of some lines I found on stackoverflow.
It's still weakly typed so there really isn't a huge benefit in using it with applications that interact with external services
Sorry. I'll try to think of what went wrong. I'll get back to you if you figure it out.
Not a bother! Thanks for trying though 😊 I've got to have this submitted within the hour anyway so I doubt I'd have time to ask an admin. At this point, any extra on top of the form validation is just for show so it's really not an issue, it's just one of those things that I'd try and fix just because it's not perfect 😅
Hah, I was trying with a fresh project using `create-react-app --typescript`. It _basically_ worked, but trying to actually add any types to things caused it to blow up. That sent me down a rabbit hole of github issues with the culprit probably being `react-types`. I tried rolling back to a bunch of previous releases but never managed to get it to work.
[removed]
I did quite a bit of research as well as worked extensively on a product that did code analysis. Typing was not either a highly determinate reason for defects in our code or about the 30,000 or so other repositories we minded continually. It also didn't make much of a difference in any metric we tracked. There just are simply better things to spend time on.
You do have to change things though, you need to add large docblock comments on top of your functions and keep them up to date as the code changes. Writing good docblocks is almost as difficult as writing good code.