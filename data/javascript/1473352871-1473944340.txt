&gt;so they've shut up and closed all dialog because they have literally nothing to gain Yeah exactly, the 2 dozen or so people *who were actually involved in the first place*. Further than that you're moving into the realm of presumption and leaping at shadows.
It's laughably sad that you don't see the connection. You believe animals ability for the bodies to evolve but not their minds? That's all evolutionary psychology is saying at its base. That our minds evolved to match our ancestral environment.
welcome to 2016.
As somebody who has been a sublime/atom user for years, what are some examples of things that an ide can do to help with JS development? Genuinely curious.
I think most people's opinion of him is formed from his terseness interpreted as rudeness online. If you ever looked at the comments he left behind on rejected PRs in the JSLint repo it could easily come across as someone that is an asshole. When someone submitted a PR to fix a niche itch of theirs to his repo it was usually a simple "No thanks" and closed PR but a fair amount of people seemed to take that as an insult and would get into heated arguments about it on the PR and in the news groups. 
Looking in the repo for the article, the code is being run through Babel. I'm sure someone out there has made a Babel plugin (or whatever they're called) to transform the 'includes' method into the 'indexOf(x) !== -1', but it doesn't seem worth the hassle for now if you have to support IE or obscure old versions of browsers. At my company, we're still forced to use IE11 as the default browser. Of course, we probably aren't playing around with Pokemon apps at work...
I'm just wondering how the function stubbing works with R.compose, it's less a syntax question and more a general question. 
TIL "rainbow-haired" is not a cheap shot.
Just test the functions you're piping the data through. 
So I've been trying to make a button (1-10). Whenever I click button1 it should add the number 1 to a text. I just doesn't seem to make it work.
What code did you write to try to do that?
It's alright, I think I've got a solid answer, but thanks anyway. 
&gt; I don't think it's a conference's job to decide if the reason for the discomfort is “reasonable” (whatever that means). I disagree. When an organization invites someone and then publicly disinvite them for a specific reason that specific reason needs to be justified or else it shouldn't be mentioned at all. Accusing someone of making others "uncomfortable" and using that as a reason, without any explanation, creates a situation where people assume the offense must have been significant and that can harm a person's reputation. At this point the reputation of the organizers is probably in some jeopardy due to how they've treated one of their guests and disseminated information.
99% of the front-end devs I have worked with.
I am by no means an expert on my IDE and there are many others who use its features much more than I do. Things I often take advantage of: - [Intellisense/code completion](https://blog.jetbrains.com/webstorm/2014/07/how-webstorm-works-completion-for-javascript-libraries/) it will suggest/complete methods from anywhere in your project. - makes errors or bad practices very apparent by default, even more so if you integrate something like eshint. - Jsdoc integrations. If I use jsdoc the ide will tell me when my types don't match up. It integrates jsdoc very well with typescript so I can use definitions from definitely typed to improve code completion as well as make sure I am using the libraries properly. - refactoring I can rename nearly anything in one spot and have it proliferate very intelligently throughout my project. This includes filenames/locations (changing imports/requires), methods, variables, exported names, and basically anything. It can be done from anywhere: If I don't like the way a method invocation looks I can rename it and it's definition right away without even opening the file that it is defined in. This really helps me write code that reads well and is self-documenting. - VCS integration a "shelf" that lets you put changesets on hold. Think git's stash except much easier to use with support for as many independently shelved changes as you want. Superior merging and diffing tools. Better, even, than any standalone tool I have tried. - run profiles with optional debugger attaching. This goes much further than running node some file.js, you can set profiles for individual gulp tasks, mpm tasks, grunt tasks and I am sure many more. - integrated testing/code coverage tools.
And I just realised that there should also be a button where when you have finished adding the numbers into the text it make it to a list below but that I know how to do. The problem here is making the button to work so it adds numbers in the text.
Thank you very much!!!
&gt; Accusing someone of making others "uncomfortable" and using that as a reason, without any explanation, creates a situation where people assume the offense must have been significant and that can harm a person's reputation. Except I don't think I've talked to a single person who has thought this way. The "well, he must have done _something_" mindset doesn't seem to have been adopted by anyone in this thread, nor in the HN thread, nor anywhere else I've seen this discussed. Right now, everyone I know who wouldn't invite Crockford to speak at a conference had _already_ made up their minds on that.
In that case I would use let/const and a transpiler, e.g. Babel.
&gt; Yes, but why then are so many devs using Sublime or Atom? Um. Some people think more advanced technology is "cheating", or "training wheels" in any given context. Who knows why, sublime vs webstorm is no contest. The only upside to sublime is faster startup to edit a line or two, but I can't imagine not using an IDE as a professional developer.
I'm creating shapes with the canvas element. so my styling is really attributes I use when building the shapes not really css or anything in that case. "_" is what I've been putting before any properties passed into the constructor just for clearity. So I know the variable is not set in the class but rather passed into the constructor. _g is context 2d of the canvas so i can draw to the canvas. what makes _g squirrely. and what would you suggest I do for a better variable naming convention? thanks for your help and input
If I publicly ask you, and only you, to leave a party at my home because some people are uncomfortable it is reasonable for the others guests who are uninvolved to think that you've done something to make people uncomfortable. &gt;Right now, everyone I know who wouldn't invite Crockford to speak at a conference had already made up their minds on that. Right but the point was likely to make the people who were willing to invite him to a conference to reconsider that position. You're looking at the wrong target audience.
Do you have any links about the false evidence stuff handy?
Gotcha. Re: variables, usually the convention is that `_` prefix refers to a private method or variable. I think `_g` is squirrely because it's not immediately apparent what the variable actually refers to; it's way too generic. Something like `canvasContext` or something would be better, imho. I like to have my code be as self-documenting as possible, and a great way of achieving that is by making your variable and method names super obvious (without resorting to Objective C levels of specificity)
And it is super intellectually lazy. The fact that your genetic composition can hold water in a debate that has nothing to do with genetics.
I've never really used setInterval in the real world, but not because I'm deliberately avoiding it - I just find a setTimeout seems to be the right tool for the job in practice. Often you have some logic in the callback that decides whether or not it needs to be re-called. I've never heard anyone say it should be avoided. If precise timing is crucial, it's better to use requestAnimationFrame anyway.
&gt; How would I get this on my webpage? You need to create a service on your web server to receive connections, probably just a HTTP POST, at a specific address.
That this is exactly the reasoning used to punish homosexuals one generation ago.
I think the biggest piece of advice I can give when talking about code performance is **don't prematurely optimize**. Write readable and maintainable code first and foremost. Unless you running many of thousands of iterations it doesn't matter if you're using `forEach` or `for` or whether the runtime environment has optimized caching of loop variable. The `setInterval` thing is less of a performance tip but more of a concurrency best practice. `setInterval` has the *potential* to execute code prematurely to when you're expecting. E.g., function doSomething () { // I take 500 ms to run } doSomething(); setInterval(doSomething, 150); This bit of code will run then next iteration `doSomething` immediately after it's finished executing the current iteration. The interval timer never stops! This has the potential to freeze your runtime environment by continuously running its code and not allowing the system to do other things. function doSomething () { // I take 500 ms to run setTimeout(doSomething, 150); } doSomething(); Even though this looks essentially the same the difference is that `doSomething` will *always* wait 150 ms after running before requeuing the next iteration for execution. This allows the system to run other operations and prevents your runtime from being locked up.
How did you put that API on your server? Basically all you'll want to do is write some JS that calls that API and then puts the data onto your page. For example, using the axios library: &lt;script&gt; axios.get('http://localhost:port/sabnzbd/api=myapikey?mode=history&amp;start=START&amp;limit=5').then(function(response) { console.log(response.data) //Write it to the page here, however you want. } &lt;/script&gt; Two more things, you'll have to include axios on your page which is easy with a script tag, and also this example is REALLY bad security wise because you shouldn't put your API key on the site like that. Ideally what you'd do instead is store the API key on your server, and have your server hit the sabnzbd API when you call the endpoint on your server, and just return the data to you. Better/more scaleable ways depending on what architecture you're using, but that would be the most straightforward way to make a REST request from the browser to an API. 
Hey Nick, thankyou for your comment. You're right, I'm pretty new to the modern stack. I'd be really happy if you would like to point out what are the more suited tools you are referring to and what are the issues in my code, to possibly correct my article and my habits ;-) 
Can you do this with express apps?
It's not worth the hassle to do this? import 'babel/polyfill' Oh god my fingers... you were right!
The library I've been using most is this one https://github.com/MrSwitch/hello.js. It also has a 'prompt: none' option which although it doesn't throw a visible popup it relies on an iframe which will also get caught by a popup blocker when it attempts to load from an async action. The google library I tried and had some success with was this https://github.com/google/google-api-javascript-client . But it seems to be really deprecated/unsupported at this point. I'll try using the newer GoogleAuth.signIn with 'prompt: none' to reauthorize and see what happens. Thanks.
If you are using lodash you can use the _.get method
true. 'php used mostly to assemble html and js for making queries business logic etc' - whaaaaaa
Oh yeah now that I think of it clearInterval seems kind of sloppy and error prone
Likewise, https://www.npmjs.com/package/deep-get-set if you don't want to import all of lodash.
Thank you for your candid review and opinion... in the README file, the configure method takes in a callback function that you can use manipulate the data that is returned from the AJAX call. Also, if it's disgustingly horrible and you know it could be better, why not customize and send a pull request? After all, that's what open source is all about. :)
And I thought it was easy already.
TIL hypocrites really hate being called out on their hypocrisy
sounds like you want a null coalescing operator, which JS does not have but people have made libraries to supplement it. for example: https://www.npmjs.com/package/koalaesce
Or just use the single-function lodash packages ([lodash.get is here](https://www.npmjs.com/package/lodash.get))
Yea I ran into the IE bugs as well and saw how old the unresolved issues were in github and elsewhere. I'm not sure if I can get away with not supporting IE at all. And just to check since you didn't explicitly mention it. Have you had success refreshing access based on asynchronous events? For example I don't have issues if it's setup so a button click directly triggers the refresh, but I have popup blocker issues with things like a background process that regularly makes an xhr request tries to re authorize before the access token expires.
Isn't what http://handlebarsjs.com/ is for?
localhost is only available on that one machine, the one running sabnzbd, I assume this is inside your house. If you need to make it accessible from another computer, there are 2 options. 1) Inside of your network: Find the Network IP address of that one box, on ubuntu its `ifconfig`. There you'll see how other machines within your network identify your machine. It will likely be something like `192.168.1.xxx`. Then to access the service from within your house, another machine will `192.168.1.xxx:port/sabnzbd/....` 2) Outside of your network. You need to find the IP address above and open your home router &amp; modem to outside traffic and route incoming traffic to that box. This is more tricky and will vary greatly depending on your setup.
_Amazing_ on mobile!
What was wrong with [js-cookie](https://github.com/js-cookie/js-cookie)?
Traditionally people would use `setTimeout` of 1000/60 to get approximately 60 frames per second (the typical monitor's refresh rate) but due to the overhead of running the function or the fact that a heavier operation may have set it further back in the queue and some browsers also throttle `setTimeout/Interval` when the tab isn't in focus, it wouldn't always line up perfectly with the next frame to be pained. `requestAnimationFrame` not only ensures the operation is updated at the next available frame but also it automatically adjusts with the monitor's refresh rate so if you have a 120hz monitor it will try to render at that rate instead of a hardcoded 16.7ms. Additionally it will group your animations that are ready to be painted in a batch update to the frame.
With requestAnimationFrame, your callback is called on the next frame (or repaint), rather than specifying a delay in milliseconds. What makes it more precise is that for animation, you only need to update once per frame. The user only sees one frame at a time. If you update more than once a frame, you're making the browser do unnecessary work and it can slow everything down (see "layout thrashing" if you don't know why that's bad). If you move an element three times in a frame, the user only sees it in the third position - the browser has to calculate the first two movements for no reason. A bit like writing "x += 1" three times, instead of just "x += 3" once. If you use setTimeout, it's not accurate enough to be run precisely once per frame. So it'll either be called multiple times per frame, and you have the previously mentioned scenario. Or, if it takes too long, you'll have frames where whatever your animating won't move, as the setTimeout callback isn't called in time. So the animation will be jerky and stop-start. If you're not getting smooth animations with requestAnimationFrame: - Ensure you're interpolating by using the timestamp provided to the callback, rather than animating a fixed amount per frame. If something should be opacity 1 at 1000ms, and opacity 0 at 2000ms, and you're at 1500ms, the opacity is 0.5. Then at 1516ms, the opacity is 0.516. Rather than calling "opacity -= 0.1" or whatever each frame - some frames take slightly longer than others, so the transition will speed up and slow down slightly. - Ensure previous frames aren't taking too long and causing a low frame rate. You can use the dev tools timeline to check this. - Make sure you use accelerated styles to move things. "transform: translate3d(0, 100px, 0)" is much faster than "left: 100px", as the browser doesn't have to remeasure things. This is a cause of slowdowns, which gives you a low and variable framerate, and hence jerky animation. Hope that helps.
Exceptions are not meant for flow control.
it does tho ['b', 4, 'c', 'b', 6, 'f']
It's funny, I looked over some of your vids (I have a really rough/in-progress 2d game I've been working on for fun at http://rpg-test.surge.sh) and immediately thought to myself that this is what a programmer coming from C++ into JS would write like, haha. Not that it's bad or anything, just what it reminded me of. Nice tutorials for sure, I'll have to give a good look over them and see if I can pick anything up. It's always interesting to me to see how programmers choose to handle a game loop, what they classify each component as (e.g. actors, entities, etc), how they render them and respond to events.
Why not this: if (a &amp;&amp; a['b']['c']['d']['e']) return true;
That would be the correct way in Python, but inefficient in JS (and most other languages).
As someone who uses a trackpad, I have no clue what the hell you guys are frustrated over. It works exactly how I'd expect it to.
Thank you! I've been using lodash and I had no idea this was a thing.
He's using `composeP` from the ramda.js library. `composeP` allows you you chain promise returning functions together like so: const result = await composeP(asyncOp3, asyncOp2, asyncOp1)(URLorWhatever); `asyncOp1`, `asyncOp2` etc. return promises. This would be the equivalent of something like: await asyncOp1(URLorWhatever) .then(asyncOp2) .then(asyncOp3); Not too much different than `composeP` but you can do interesting things with it. For instance I'm working on an asynchronous validation library that uses this feature with promises. It's admittedly not that different than Joi but supports async validation which Joi annoyingly does not support (though they claim they are working on it). Anyway, a validator will look something like this: V.string().maxLen(2); `string` and `maxLen` each push a promise (validation test) to an array. Then later when the validation is being executed, all the tests are applied to composeP like so: const pipeline = pipeP(...validators); `pipeP` is the same as `composeP` it just executes each promise/function in the opposite order, which works well with a stack. The pipeline can be dynamically constructed one operation at a time and then executed at a later time. All of this completely sidesteps the traditional node.js style of using callbacks for everything.
If you screw up your eyes and start to cross them over a bit, it looks like an ASCII art vagina.
TypeScript has this as well.
&gt;Additionally another tip I learned way back when (in early 2015), to never use setInterval but instead just recursively call setTimeout. &gt;Is this still true? As far as I know. My impression about setInterval() is that the browser sends new timing events to the queue on schedule regardless of whether any Javascript code is already running or not. But Javascript is generally singlethreaded and so the events will only come *off* the queue once all currently executing Javascript code has finished. In theory, what this means is that if your code takes longer to run than the interval you set, the event queue keeps piling up forever as your code's activity lags behind the actual system time. (Note that this might not show up in testing if you're testing on a fast machine, yet could cause problems if somebody tries to run it on a slower machine.) Whereas if you instead call setTimeout() at the end of your code, you only ever have at most one timing event in the queue at once and that sort of terrible situation never arises. That said, these days for many purposes it's considered better practice to use requestAnimationFrame() rather than setTimeout().
I'm using a trackpad and couldn't scroll at all.
Cool well if you've already done step 2 and opened all the firewalls/ports. You can go: http://homePublicIPAddress:port/sabnzbd/.... directly. Or if you've mapped a domain name with a dynamic DNS service, its even easier.
If you're iterating over tens or hundreds of thousands of objects, you should probably use a `for` loop. But in my experience, needing to iterate over a data set that large doesn't come up often. I'm not saying you should *always* use iteration methods; I'm saying you should use them first, and if performance becomes an issue, optimize away.
You're only making my point. In your scenario, the host and guest #1 come off even worse, and guests 2-15 have no reason to suspect that Frank has done anything wrong. Also, why did you omit the host's apology from your version? Don't you think [the actual apology](http://nodevember.org/statement.html) adds important context?
Do you have a link for this?
I prefer: ``` const get = require("lodash/get"); ``` But basically the same thing.
I am actually creating this tutorial to kinda show exactly how possible OOP is possible with javascript. I enjoy this approach to game dev.. :) thanks for the response. I'll take a look at your project. 
It wouldn't be JavaScript if there weren't 50 libraries with slightly different names that do the exact same thing...
I would say your answer is the right one. Your answer only imports `get` while the above answer imports all of lodash.
IIRC, this can allow for smaller build sizes in some situations (although minifiers with some amount of dead code elimination like the Closure Compiler can help in the former case). Essentially, you're only pulling in the module that you need, rather than all the modules that you don't.
Woops. You're right. Should have been `map`/`filter`/`reduce` that don't have side effects. 
setInterval gives no guarantee that the interval will be respected anyway. requestAnimationFrame is "graceful" by default and will not be called if the browser tab is out of focus, which can save resources on low end computers. requestAnimationFrame is better if you care about user experience. For instance a game doesn't need to render a canvas element if a tab is out of focus.
well played sir.
ah, now I think I know what you are talking about. I got it running (I think). &lt;script src="https://npmcdn.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; Then: &lt;script&gt; axios.get('http://11.0.0.30:8085/sabnzbd/api=myapikey?mode=history&amp;start=START&amp;limit=5').then(function(response) { console.log(response.data) //Write it to the page here, however you want. }) &lt;/script&gt; When I press f12 in my browser I get this error: "No 'Access-Control-Allow-Origin' header is present on the requested resource" So, if I understand correctly, this is because the webpage (server) is on my home-computer and the sabnzb program is running on my NAS (With a different IP). Is that correct? So it won't work this way?
Ah it's nothing nearly as complete as your project, probably won't pick up much from mine. It still manipulates absolute positioned divs for all graphics as opposed to painting on a canvas (which is technically the performance optimized way as I'm sure you know - although I haven't run in to any performance issues yet). Oh and I should add the source has gone through a compiler although it's not minified. You can check out the git for it here if you want: https://github.com/nickgcattaneo/RPG.
Knew this issue would come up eventually from reading the post haha. This is because the API does not have a Cross origin request header (and somewhat rightfully so), its a security measure put in place to make it so a random website cannot connect to another website without explicit permission even if its on the same IP (not host!). Unfortunately unless you can find something on Sabnzb which gives you the option to add this header you'll have to proxy the request (from another program) which does not have this restriction in place. Alternatively just use a server side language like PHP or nodeJS as Javascript is *not* required to do this project if your website is running from a server (including local server like WAMP/LAMP etc)
Is this better or worse: ['b', 'c', 'd', 'e'].reduce((o, v) =&gt; o &amp;&amp; o[v], a) I like that the array itself now has only property names, but not that the initial value is way at the end.
I didn't want to go deep in boxing/unboxing, but then "does primitive contain property" becomes a philosophical debate - can primitive contain property if any code to check it either have special path for primitives or boxes primitive as object? 
I don't think there's a version of JS that includes fat arrow functions but allows undefined to be changed, so I think you're probably OK here.
Smart, noice 
Wat
you should pm me or add me on skype it would be cool to talk a bit more about the projects. jamie337nichols@gmail.com is my email
Much better to get just the util you need. Also helps if you want to swap something out in the future.
Hmm ... can't find an obsolete enough ES5 environment to try it in. https://kangax.github.io/compat-table/es5/#test-Immutable_globals_undefined
&gt;...it's pretty easy to install obsolete versions of node I thought of that too, but couldn't find a definitive answer about which version of V8 included which ES5 features. Node stable (4.5.0) doesn't allow it. Even node 0.10 doesn't allow it. I'm not dedicated enough to go back any further than that...
Well, v0.10.46
Some people pursue the development of convenience, some people pursue development OPTIMIZATION, We are the the latter one, but nobody is wrong, let the post go sink. thanks for your justice. ^_^
I definitely agree with that, but let's consider that js-cookie has 9 years and is from the same maintainers as jquery-cookie, making it de-facto standard. It would be very good if the community could dedicate more effort in solving problems instead of reinventing the wheel. For example, instead of just reinventing jquery-cookie at the time I wasn't yet the main maintainer, [I helped improve it](https://github.com/carhartl/jquery-cookie/issues/68).
No objects were modified in the evaluation of this expression.
Booooo hisssssss on stage.fuck boycotting.
Doesn't short-circuit, though that may not actually matter for performance.
Devil's advocate: So? The only reason I wouldn't do this is in case another exception gets thrown, I don't want to accidentally ignore it. But I can easily see it being safe in this regard if I'm careful.
You have to bear in mind that the timers are asynchronous. This means when you use setInterval the instructions wrapped in the timer will execute regardless of whatever else is happening in the page unless the primary thread is locked (long running execution that freezes the browser). That is potentially good and bad. Since it is asynchronous its execution is reliable and predictable even if the code it wraps isn't. If the code wrapped by a setInterval takes longer to execute than the provided interval you have something called *fallover*. Fallover could cause collisions or race conditions. The longer the intervals the lesser chance of fallover. Fallover is hard to identify or predict until things break or behave unpredictably. A recursive setTimeout is the opposite of setInterval. It is not predictable or reliable as to when it executes, but there is no opportunity for fallover. When you are interacting with the DOM you are generally better off using a recursive setTimeout. If you need to make a general state change or minor UI component modification and the delay is 1 second or greater you are probably fine using setInterval. In the case of animations where you typically want the shortest interval possible you really want to use recursive setTimeout. In the case of beaconing data back out to the server you probably just want to use a setInterval. Putting DOM interactions inside a timer can be really challenging to monitor since both the timer and the DOM interaction are each asynchronous and it is the result of the DOM interaction that you would observe. EDIT When working with the DOM the maximum practical delay is 1ms, but only for changes to a node (and its children) where those changes do not move the node, change its shape, or its size. This basically limits changes to things like colors and opacity. The theoretical practical delay for other changes is about 5ms and goes up depending on a variety of other factors, such as the number of child nodes and length of text children.
I'll check that library out. I am just learning about functors now myself. Strangely enough the ramda-fantasy library has Futures, which are exactly as you describe Tasks. ramda-fantasy is a functor lib that works with ramda (same maintainers). Regarding my validation lib, yeah, that's the idea. Funny you should mention `Either` because that's exactly how I am handling errors in the chain of validators. So if `string()` in `V.string().maxLen(2)` fails, I pass the error message to `Either.Left(error)`, otherwise I pass the value being tested to `Either.Right(value)` and send `Either` further along the chain. The thing I am struggling with is making `Either` play nice with promises though. I have something working but I'm not happy with it currently. Originally I had everything working synchronously where the `Either`s would be piped through pipeK which chains functors. Since I am now chaining promises with pipeP, I lose the ability to chain functors cleanly. Just earlier today I was thinking of opting for Futures instead of promises because they are chainable functors. I should mention that `V.string().maxLen(2)` is just the user interface. All the functor stuff is going on in the background. It's a mixture of functional and OOP which I am sure others would balk at but it's too practical to ignore. As for async/await, I don't shy away from using it all. It's just too irresistible. If I ever publish what I am working on, it'll be transpiled code.
My personal favorite : https://github.com/letsgetrandy/brototype
Bro-hug for your solution.
Consider using higher-order functions instead of for loops
[Ramda](http://ramdajs.com/docs/)'s [path](http://ramdajs.com/docs/#path) function: getE = R.path(['a', 'b', 'c', 'd', 'e']); getE({ foo: 'bar' }) // undefined getE({ a: { b: { c: { d: { e: 'foo' } } } } }) // 'foo' Edit: I wrote this first, misunderstanding your question. But I'll leave it as an example of Ramda's composability. var test = R.compose(R.not, R.any(R.isNil), R.props(['a', 'b', 'c', 'd', 'e' ])); var a = 1, b = 2, c = 3, d = 4, e = 5; test({ a }); // false test({ a, b, c, d, e }); // true 
[Lodash is doing it wrong.](https://www.youtube.com/watch?v=m3svKOdZijA) Use [Ramda](http://ramdajs.com/docs/) instead ;)
This was my first thought too.
If you want to assign a variable to a nested object property that may or may not exist, `_.get` is the answer. But if what you want is a bool telling you whether or not a nested object property exists, you can use [_.has](https://lodash.com/docs/4.15.0#has).
Also: https://www.youtube.com/watch?v=I25UeVXrEHQ
God I'm so tired of the name Ada. Every programmer names their daughter Ada, every tranny programmer names themselves Ada. Maybe I should name my dog Ada.
Thank you for the constructive criticism, I have made changes to the library. I have fixed the naming inconsistency and also included the actually AJAX method that handles the request in the README file. This way, one can use it without user interaction. As for the data that is being returned, I want to allow the user to customize the data. So, in cases of getting back a json object or an xml object, they can utilize it by creating a custom callback function. I will work on the error handling as soon as I get the chance. Thank you so much for pointing out the parts of the code that I needed to fix.
I'm not in a position where I can watch a video. What is the summarized version of why lodash is doing it wrong? Also, people are posting lodash solutions, what would the equivalent in Ramda look like?
Honestly it's just an ongoing holy war. I use vim in the terminal with plugins. I get internally frustrated when I have to pair program with someone on IntelliJ because they are so slow. Much like that of someone typing out www in the url bar. On top of that switching to the command line is much slower. For me it's 1 keystroke. This was actually the reason I switched. I quit using my mouse and noticed I was much more productive. I have a fuzzy file finder. I'm immediately aware of lint issues. I have code completion with function signatures. I have snippets. I have search capabilities. Tabs. Windows. Splits. 
[Proxies FTW](https://h3manth.com/new/blog/2016/path-resolver-with-javascript-proxies/)
What if *e* is falsy though? Using: if (... &amp;&amp; a.b.c.d.e) returns false if e exists and is falsy. You'd want: if (... &amp;&amp; e in a.b.c.d) Perhaps you'd suggest: if (a &amp;&amp; a.b &amp;&amp; a.b.c &amp;&amp; a.b.c.d &amp;&amp; e in a.b.c.d) ?
I've been using IntelliJ combined with the IdeaVIM plugin and I seldom have to use the mouse, the keybindings are quite good and configurable. Although I would prefer working with a fast, lightweight and extremely customizable editor like Sublime, I'm not sure if I'm willing to give up advanced refactorings (e.g. renaming a function automatically propagates to all places where it's used) and the integrated diff viewer (e.g. you can compare to another branch or an older version of the file in your local editing history and cherry pick changes lines).
Why is this wrong? (vs. just a different paradigm)
its 2016!!! you have to use a library just to console.log these days, all the cool kids are doing it!
C# now has .? - so a.?b.?c.?d.?e Pretty succinct tbh
Confirmed. We're in Bat country now.
It will set `foo` to `undefined` when `a.b.c.d` are valid properties, but `e` is not.
I think the initial value has to be the object itself.
It clearly became a success *before* it turned out into an upos.
Whilst it's annoying to need a dependency for such an everyday/commonplace operation, this is the best answer. Those who do not use Lodash are doomed to reinvent it. 
Alternatively you can write the function yourself in about three lines of vanilla JS. (**Edit:** I was wrong - it's actually [**one** line](https://www.reddit.com/r/javascript/comments/51t6wu/most_efficient_way_of_checking_if_abcde_exists/d7et9hv).) Why do so many people in the JS community seriously think it's worth the risk and complication of adding external dependencies for every single pissant 2-3 line bit of code?
Good point. Thanks. I updated the code.
There's nothing wrong with "reinventing" 1/1000th of Lodash if that's all you need and it saves you a brittle external dependency and extra unnecessary failure-modes in your build. Bringing in an external dependency to save you three lines of JS in a trivial function is not the "best" answer - it's lazy and dangerous, as left-pad showed everyone.
&gt; don't use classes in javascript , use functional programming and not object oriented. What does this even mean? Everything in JS is an object anyway except for primitives. &gt; As a C++/Java developer i found OOP far better than any other approach Good for you, the thing is that JS OOP cannot be compared to other more traditional implementations of inheritance in other languages supporting the OOP paradigm. &gt; can someone post a simple code example of pitfall or buggy code resulted from using classes? https://github.com/joshburgess/not-awesome-es6-classes
Can't you just make a graph without force? http://stackoverflow.com/questions/28102089/simple-graph-of-nodes-and-links-without-using-force-layout
i mean use functional programming and not OO
I *think* it has to be chrome
Yes... Any kind of app. I have seen a colleague even debug a cucumber step function with it. 
JS is all about Oriented Object and nothing about classes -well since ecmascript 6 a little about classes-
There's no do or don't. Use what you want to use and is most comfortable wth using.
satisfied with mocha, expect.js, and supertest.
I'm late to the party but I figured I would ask here anyway. This feels very redux-ish with the normalized stores. One of the benefits with mobx is that you don't need to do that and can use real references instead. Did you find any benefit in normalizing other than being used to it from Redux?
a while back I hacked https://github.com/capaj/object-resolve-path which is faster than lodash especially when you access same path multiple times
 if (a &amp;&amp; a.length &lt;= 15) console.log("input is valid"); This definitely hits the edge-case, and would be flagged at code-review if I'm the reviewer. if (a != null &amp;&amp; a.length &lt;= 15) console.log("input is valid"); `!= null` is better in this case. Catches null, undefined, but not `""`. 
In JavaScript there are no classes. Yes you can use object oriented programming, but in JavaScript OOP is not based on classes, it's based on prototypes. Even if there is the new 'class' keyword, under the hood still prototypes are used. So first if all you should learn about prototypical inheritance. If you want to know about the pitfalls, read the articles by Eric Elliot: “The Two Pillars of JavaScript” @_ericelliott https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3 
I use [ava](https://github.com/avajs/ava) and it has been the best testing experience so far. I love that I don't have to import another assertion library. Even the great tj(author of mocha) acknowledges it: https://twitter.com/tjholowaychuk/status/709612159458611200
I use Mocha, Chai, and Sinon. That's pretty much all I've needed for the last 4 years, although I'm sure some of the newer technologies like AVA are great.
This book : "JavaScript: The Definitive Guide" by David Flanagan really help me to understand the beauty - a lot of people will tell you otherwise- and simplicity of this language.
thank you so much &lt;3 &lt;3
&gt; 11.0.0.30 is certainly not the public ip address of your house, its way too perfect. `11.0.0.30` is probably the address of your modem from within your LAN. Search 'Whats My IP' in google and you'll see how the rest of the web would talk to your home network.
I stand corrected. I misunderstood the usage. I thought `a.b.c = false` is a possibility. 
`_.get` seems like the winner here. too bad we're still using lodash-core, where it's not included.
Doesn't work with `e` being falsy.
In the video you mean? 
Java and JavaScript are two separate languages OP, there's a java subreddit and a learn to code subreddit. 
Because there is no standard lib and importing Lodash will give you tested, verified methods. Creating your own solution for every small problem will just be another potential for bugs.
But this is a video about underscore not lodash.
The class keyword in JavaScript is essentially a wrapper for constructor functions. The syntax is easier if you prefer using constructors instead of Object literals with factory functions. I understand why some people dislike using the constructor pattern, but honestly, classes are a bit easier to compose and extend in my experience (purely from a syntax standpoint).
I use Mocha and should.js, and supertest for integration tests. Along with that i use istanbul to generate code coverage reports for my test suites.
Please try to use OOP and functional syntax together.
We should be looking at `class` in JS as syntactic sugar on top of `prototype` based programming. They should be considered optional or given as a programmer's choice. From what I understood, `class` helps to simplify (clean) complex constructor function usage. It's always good to have the best of both worlds!
Nothing teaches a hard concept like running into what it was meant to solve in your own program. You can read about classes all day long, but until you have an overly complicated series of functions that are all ruining your namespace and making your project impossible to maintain, you're not going to really 'get' it. I've found it to be the same for everything I ever thought "I wish I could understand that." So now I try to balance learning things generally with learning as I go. I've only been at this a year, so I have a long way to go. But I feel like being so close to those first steps gives me a better perspective. I also started from basically nil. No HTML and CSS when I was in high school. I never touched visual basic for any reason. I was basically a younger version of a lot of people's grandma. All that changed when the fir....imean, when I started to want to know what things I could do better. No joke, I got into programming because of Excel. Nothing feels better than writing a macro that does what takes nearly an hour in mere seconds. It's like crack. Same now with consuming APIs in a way that makes sense to my use case. Company app doesn't provide the interface you want, but has well documented endpoints? Oooo buddy! I'm about to get my fix!
Completely agreed on Mocha. It just works, and it works great. Leaves you wanting-for-nothing.
[removed]
There's virtually no reason to use Karma for backend tests. Nobody should follow this advice.
Ramba is doing their website wrong for mobile. Also, that video is about underscore, not lodash. 2 out of 2 fail on selling ramba. :(
&gt;importing Lodash will give you tested, verified methods I've *personally* experienced a Lodash bug that broke our production builds, which is why we're moving to our own cached npm repo based on artifactory. Short of that, there was nothing we could do other than fork the package and fix it ourselves (with all the overhead, admin and build-system complications that entails) or just wait for jdalton (or whoever) to fix it... and release the next version of Lodash... and remember to update the `npm-packages` branch. That was a fun couple of days, and it's a really good thing we didn't have to do a release in the mean-time. More generally though, yours is *exactly* the same mindset that leads people to include the whole of jQuery just to select a couple of DOM elements, and allows left-pad to break half the JS ecosystem. Did we learn nothing? **Dependencies aren't cost-free** - they're convenient and they're (usually) proven solutions to problems, but they also inevitably and unavoidably introduce additional sources of bugs and additional failure-modes that you have *even less control over* than if you wrote the code yourself and statically included it into your codebase. Stop being so scared to write code that you'd rather get someone else to do it for you. Sometimes it's a sensible time-saver (when the problem is complex, the developer is brilliant and/or the amount of code is significant), but when the problem is simple, the amount of code is trivial and/or the developer has a history of pushing out broken/buggy code (*all of which* apply here) it's just amateurish and counterproductive. This problem (recursively walking an object through a named path) is little more complex than using a loop to iterate over an array. If you think requiring an external dependency for every `for(...)` loop is stupid (and dear god, I hope you do) then exactly the same logic applies here. I hate to sound like some elitist, dick-waving brogrammer, but if you don't even trust yourself to write a line of code as trivial as that without fleeing into someone else's library to do it for you, how the hell do you even call yourself a developer?
Thanks for pointing this out. I really only knew of mocha. Is there any push for JS to add a framework to the standard lib or are people happy with the third party route? 
oh boy, i'm going to have some fun tonight with this
Yes, this is the answer. AVA is the best.
For example, true &lt;&lt; 5 is 32 :)
It looks like in the first example you are only creating one observable and assigning it to the numbers variable. In the flat map you are just returning that same observable every time. In the second example you are creating a new observable for every value emitted from the interval(2000) observable.
How about - a project is marked as "production ready", "beta", or "experimental" - users can leave comments I get many addition requests that are small hobby projects that are clearly not production ready and that will likely get abandoned. I should reject them. But I don't want to. Because it's very difficult for them to get users but they should get a chance to become a meaningful project. Marking them as "experimental" and putting them at the end of their category could do be a good trade off. If a project is clearly BS, users would comment on this. The project then get's kicked out of the catalog.
yes -- i've done it before (though it is ugly). i think i used lzstring to compress and base64 to encode with minor mod to encode a value in the url.
Looks like i need to do some reading on bitwise operators!!
&gt; composition over inheritance Note that that JavaScript Scene guy tends to use "composition" incorrectly. Favoring object composition over inheritance is an OOP thing. It's about having objects own instances of other objects instead of sticking everything into the inheritance chain. &gt; They aren't even real classes. Of course they are. They are just as "real" as classes in other languages. Just check the definition of classes. It doesn't go as much into detail as you think. Another fun thing to note is that V8 is pretending for years that JS got real classes. Creating instances from blueprints is faster.
Yeah, for a generic utility it's absolutely fine. But if you're trying to squeeze out efficiency, you want to do this inline with dot accesses. I've actually been toying with how to make a nice syntax to do this exact thing with a babel plugin. Basically we're talking about CoffeeScript's `?` operator here. The catch is that a babel plugin doesn't let you introduce new production rules, so you're stuck with abusing JS syntax, and further constrained by not pissing off your linter. I wrote a similar function, with some additional features, and it pervaded our codebase enough that I had to optimize it. One additional way they could speed it up is to cache the parsed path. That was easy in my case because I could assume a finite number of paths; lodash can't assume that, so they'd have to worry about cache eviction. Probably not worth it for the modest speed up. I did some other crazier optimizations too, but they wouldn't help in lodash's simpler version. Interestingly, one optimization I thought would help, but didn't, was compiling the path to a function. That is, generate the chain of ternary expressions, and pass it to the function constructor. While it is faster for massively reused paths, the performance penalty for one-off paths is enormous, so in practice it made things worse.
Follow-up to say: I looked at AVA, and it looks like it may sport some of the very things I value about tape: * No implicit globals * TAP output I would definitely consider trying AVA for my next project.
String.prototype.padStart should have been in the standard lib. startsWith/endsWith also should have been there much sooner. I'd also like to see `Array.generate(5, i =&gt; i * i)` because `Array.from({length: 5}, (v, k) =&gt; k * k)` is hideous and cryptic. Can't be arsed to write a spec for that, though.
You can try create your own Event object from scratch, instead of using createEvent.
async await looks amazing, but I feel iffy about using it just because it's so far off
Yes, anyway to avoid that? This example has the "easy fix" of returning the same observable every time, but what if I was forced to wrap the observable inside a function, like Observable.interval(1500) .scan( (numArr:any[],curr:any,i:number) =&gt; { numArr.push(i); return numArr; }, []) .flatMap(numArr =&gt; { return Observable.interval(500) .map(i =&gt; { numArr.forEach((el, i, arr) =&gt; { arr[i] += 1; }) return numArr; }) }).subscribe(res =&gt; console.log('final value', res));
I use production. It's alright.
Haha, Cool video Pomie. But that youtube name seems awfully familiar :o.
I typically use Mocha and Chai. If the project is React then I use Enzyme too.
There's lodash/fp for a more FP friendly style with immutable auto-curried iteratee-first data-last methods. It also has several R aliases. https://github.com/lodash/lodash/wiki/FP-Guide
I've been using [ospec](https://www.npmjs.com/package/ospec)
Yep, MSIE is limited to ~2k URLs (other browsers are more or less unlimited, even Edge's limit is around 80k), Apache has a default URL length of ~8k[0], though many servers are configured with a 4k limit, IIS used to have a 16k limit (may or may not still be the case) [0] technically LimitRequestLine limits the URL + the HTTP verb
^ The answer to these questions is almost always "use reduce". 
The more readable solution is going to depend a lot on how everything is actually named. 
That's 2kb min+gzipped. You could use lodash-webpack-plugin to strip out extra functionality and it would be 600 to 300 bytes. https://github.com/lodash/lodash-webpack-plugin
You might be interested in JSON Web Tokens: https://jwt.io/
Oh, thats awesome. I appreciate the videos that you and mpj put out. Really helps beginners like me move to more intermediate / advanced topics.
Cucumber!!!
Is this the same girl from the nodebotanist video? "Let me tell you about how community works while completely ignoring the community"
SJWs
[removed]
[removed]
100 percent, I often forget about fetch as widespread support is relatively new. OP, much better solution for you as you can use this built in fetch function without adding any additional scripts: https://davidwalsh.name/fetch Here look at the "Handling JSON part" which is probably what you want. 
There is nothing interesting about a guy videoing himself in his kitchen for 9 minutes recapping anything 
i use mocha, chai and sinon and supertest and nock for integration tests. Istanbul for code coverage too. Found it to be a pretty fast setup but haven't compared it to ava or tape. I originally tried Jest too but it was really slow (a year ago). I believe that's improved a lot with the latest version.
I don't believe it makes sense to have a framework for testing in the standard lib, but then again Elixir does so with ExUnit and quite a few third party libs build on top it. I think there is only maybe one or two third party ones that don't leverage ExUnit. The only reason it could make sense is if the framework had hooks that allowed for things that currently are not possible and/or could speed up testing in large test suites.
learn C
Do you prefer writing tests for your API endpoints or single functions? Or both? Pros/cons?
I've really enjoyed all of your videos so far. The content is very well presented, and your personality makes it fun!
&gt; Meanwhile if a library is ever broken you can just roll back to a previous version. That's the theory, sure. When it's a grand-dependency (dependency of a dependency), or a direct dependency requires that specific broken version of Lodash (or a submodule) and you can't directly monkey around with the automatically checked-out npm modules in your closed and automated build server, not so much. &gt; But that is not super likely to happen with any decently known library since they'll have tests. Again, in theory, sure. In practice this has happened *twice* in recent months with point releases of Lodash *alone*. Protip: it's really hard to unit-test for *browser* support (arguably the biggest source of JS bugs going) and really easy to push out code into production that breaks when run in certain browsers (IE and Firefox, I'm looking at you). &gt; It's also likely that that OP already using lodash That's fine if so, but we're specifically responding to u/mbcrute's advice to use Lodash "if you don't mind taking a dependency on lodash". I have no argument with someone using Lodash *if they're already using Lodash* - to do otherwise is just stupid. We're specifically responding to the case where they *aren't* already using it, and someone just advised them to add a dependency on it for that trivial reason alone. &gt; It's one of the most relied-upon dependencies out there. Yep. And *even so* it frequently pushes out releases that break in browsers, and has to do several hurried point-releases over the course of several days to fix the broken code in production. So to put that another way, *even the most widely-depended-on libraries in the entire JS ecosystem* are likely to frequently exhibit bugs in production code that you can do nothing to fix or ameliorate.
Now, this could be useful. Thanks
Sounds overly complicated for a simple button and click listener/handler. What's your high-level/overall goal? Like "I want to click a button and add classes to an html element.."
Doesn't that produce UTF-16 though, technically creating an [invalid URL](https://url.spec.whatwg.org/#urls). Does it convert it to [Punycode](https://en.wikipedia.org/wiki/Punycode)?
I outsource testing to the cheapest east european house I can find and demand that they QA everything for a year before I'm confident in releasing. A lot less config files this way.
&gt; Lodash is modular so folks can use as little or as much as they want in a variety of module formats Yep, but try pulling in something trivial like lodash.merge. That "should" be a handful of lines at most to do a single, trivial, well-defined task. Because Lodash is a huge library with a lot of similar-but-slightly-different requirements, however, everything is abstracted away into multiple "base" and derived implementations. Lodash is mostly written *in Lodash*, so what should be five or ten lives of trivial code instead [turns into a 2208-line, 57 KB monster](https://github.com/lodash/lodash/blob/4.6.0-npm-packages/lodash.merge/index.js) *and you didn't even know that* because you heard "pick and choose what your need" and just stopped thinking. Fun fact - the *whole of Lodash* is only 69 KB minified, so exactly how much do you think that picking and choosing individual functions is actually saving you? If you use more than one or two Lodash functions, the answer is probably a negative number. Plus, if anything does go wrong you're stuck debugging 2000 lines of someone else's highly abstracted, cryptic code, instead of 5 lines of your own. And when you find the problem you may *still* not easily be able to do anything about without horribly hacking other third-party modules which have a dependency on that specific version of Lodash. &gt; External dependencies are great! That is the un-nuanced, clueless generalisation of a junior developer or a myopic fanboy. Like practically everything else in software development, external dependencies have benefits and drawbacks - they're great in some situations, and absolutely boneheadedly retarded to use in others. If you **ever** find yourself writing something as clueless and un-nuanced as "X is (always) great!" then you've failed to appreciate this very simple, fundamental fact, should stop opining about things you know little about and go ask a more experienced developer to explain to you why what you just said was so incredibly stupid. &gt; Lodash didn't become the most depended upon package in npm by left-padding it. Jesus fuck, you know that projects as respected as **Babel** had a dependency-chain that included left-pad, right? There's nothing magical about popular JS or npm modules that make them immune to bugs or invulnerable to uncontrolled dependency chains. &gt; Npm has also revised their unpublish policy to avoid left-pad issues in the future. Oh fuck me dead. "Left-pad" was supposed to be a shorthand for *anything bad that can happen to your external dependencies*, not just one salty developer unpublishing their module. Exactly the same problem exists if a dependency project: * Is temporarily unavailable (downtime, maintenance, network outages, legal action, etc) * Is unilaterally "repurposed" by the repo vendor to refer to a different library altogether (you know, the way [npm already did](http://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm) with the `kik` module that triggered the whole left-pad debacle in the first place) * Has a bug in the depended-upon version (bonus points if it's a grand-dependency, when you can't even roll back to the previous version of the problem library, which has already happened to my team twice *with Lodash* in the last few months alone) * Has malicious code injected into it by the original dev, a clever contributor, someone who's taken over the project voluntarily or by fraud/impersonation/hacking. * Has bugs or broken code injected into it (errors not caught by unit tests, browser-incompatibilities, bugs in new browser versions triggered by the library, etc) * Etc * Etc * Etc NPM's "policy" changes do nothing to protect against any of those dangers, and in fact have explicitly *caused* at least one of them to already happen.
It is easier to just use post and stick the command/data in the payload. Also re: compression, use more 2+d arrays where it makes sense, so that you have 1 row listing all the columns if you like, then the rest of the rows without labels repeated on every single value. A csv/tsv blob might be a good choice too. 
Hm yeah I guess it's probably not that common to ship with unit testing in the standard lib. I like that Python does it. It's cool that elixir does it. But if many people end up using third party stuff anyways shopping with it doesn't really centralize the community. 
&gt; compressToEncodedURIComponent I believe you're referring to earlier versions (versions &lt; 1.3.5) or different methods within this library. The method compressTo**EncodedURIComponent**() does not produce UTF-16; it is base64-based.
good catch but unfortunately that didn't fix anything. Shit, I was really hoping that was it lol DOM element? Sorry, I'm not sure what you are referring to. 
I use Jasmine for my front-end and back-end testing and I've never had any problems. If you ever find yourself looking to integration test your APIs, check out SuperTest. 
possibly. need to see if this is a lightweight include. want to avoid auth. and treat it as a straight up compressor/decompressor. I like the fact that the output string looks safe for url query arg
need something that will compress
actually I just noticed it is gaining in size, thats not good. need to compress
It's been awhile since I worked with Leaflet, but from a look at the Leaflet and Easybutton docs and my understanding of your requirement, I'm thinking you'd want something like this: L.easyButton('fa-pencil', (button, map) =&gt; { toggleLayer({ layer, map }) }) Where you define a `toggleLayer` function that uses [hasLayer](http://leafletjs.com/reference.html#map-haslayer) to determine whether to invoke `addLayer` or `removeLayer` on your map.
OP is working with the [Leaflet](http://leafletjs.com) API here folks, solutions should probably be aware of that.
Thank you! Really glad to hear this. :)
&gt; use post I hadn't thought of that
Yeah... I just don't know anything about those external scripts you're using... Sorry. 
Honestly I think that's the best approach. I know we are off subject from the original conversation you posted but I have dabbled in Atom, Sublime, Code, vim, IntellijIdea, Webstorm. Landed on vim as my editor of choice. Your preference will surely be different. But I think I did my best to describe why you see these editors being used.
&gt; reduces peak memory consumption of on-heap memory up to 40% &gt; reducing off-heap peak memoryusage by up to 20% Very cool
I guess I don't know what you mean then by using file watchers. I start a gulp task that watches my *.scss files and on change it transpiles them into *.css files. I don't hit the command line for every change -- just to start it. Searching... I can too :) (and without indexing) https://github.com/ggreer/the_silver_searcher https://github.com/junegunn/fzf https://github.com/junegunn/fzf.vim I search with `:Ag foobar` and I can even search through *that* list of results. It shows lines so when I hit Enter it brings me right there. The holy war continues! 
It's sad, because I saw other talks of hers which were technical and educational and she was in good spirits giving those talks. This talk is just mean and has nothing to do with development. It's such a stark contrast from her other work. 
Been waiting on this for so long
What advantage does this have over [cleave.js](http://nosir.github.io/cleave.js/)?
how do you mean bad? Like just in the case that a user has data to input that wouldnt be valid for the particular mask? or is there some other reason that you believe input masks are bad for usability? The reason I ask is because, for a lot of non computer savy people, it seems to be best to force their input into the correct format by taking the options away from them, like if you give a user the option to enter any characters into the phone number input, they might struggle to know if they should just put the numbers, or numbers separated by dashes or numbers separated by dashes with the area code wrapped in parenthesis, or numbers separated by spaces, etc... where as if you automatically give them a mask of: ( _ _ _ ) _ _ _ - _ _ _ _ where as they type numbers they automatically go into the right place... they generally dont have to think as much, and thus your app doesnt [make them fat](http://seriouspony.com/blog/2013/7/24/your-app-makes-me-fat) Is there another reason beyond a mask maybe not being correct for all possible formats the data may be in (for instance with the phone number example, a user with a non US phone number wouldnt work with the mask I showed above), or is that the only reason masks are bad for usability in your opinion?
Most masked inputs I see are there without any instructions. Leaving me to figure out what they want exactly. The moment this happens I am allready irritated and hate the developer that made this app. This is compounded that there are no standards and 10 sites might use 10 different input masks for the same data forcing even more cognitive overhead on me. Then don't get me started on copy pasting and deleting characters which is very often poorly implemented. I much rather prefer a validation at the end of my input telling me it's correct or incorrect and why. Masked inputs generally don't give you feedback WHY something doesn't work. It seems I am not the only one: http://ux.stackexchange.com/questions/58309/why-do-so-many-forms-use-input-masks-in-for-input-fields
What's the most advanced thing you feel you can do?
broad question.
Well, it's an attempt to engage the people outraged by the so-called 'HSJW' faction and point out to them that (a) they are engaging in essentially identical behaviour ('HW'), (b) that they're basic right that the social networks and organizations that form around Javascript should be *about* Javascript and not have extraneous value systems imposed, but (c) by the same token they need to take it seriously when people feel that they *are* encountering extraneous value systems that is pushing them away from feeling socially connected and participating in javascript development communities. This may be may well be every bit as futile as attempting to engage and argue with 'HSJW' types. There are exercises of bad faith on all sides, and those inclined to troll are drawn to the drama like flies. Additionally, my rant might well be cranky and incoherent. A cranky and incoherent wouldn't notice or believe this, so I can't rely on my own opinion in that regard. It's safe to say, though, that 'just reading about javascript' is an objective we share in the long term. Regarding which, I do not believe for a second that you clicked on a day-old zero-scoring self post titled "*Hypersensitive Warriors to be Considered Harmful*" thinking you were going to read about javascript, so [enjoy](http://i.imgur.com/R9tROCm.gif).
I am not against masked as an idea. but developers have proven to me they can't use masked input responsibly and as a result it's ruined for me from a ux point of view. 
http://pixel.nymag.com/imgs/daily/vulture/2016/02/17/recaps/17-broad-city.w529.h352.jpg
Sorry it took so long
Good things are worth waiting for. Just know that your work is valued by people like myself!
In your stackexchange link, I see the question agrees with you but the only answer gives a pretty good defense of them.
&gt; Input masks are often done poorly as you describe
Input masks is as annoying as pop-ups, stop it. 
Ps I found this tutorial by the author of folktale very helpful. http://robotlolita.me/2013/12/08/a-monad-in-practicality-first-class-failures.html
How is this a bad thing in your testing environment? The rules for programming tests are different than for production code. Having describe injected in all of your tests is just easy. It can even make your tests survive swapping out the stunners. If you switch from jasmine to mocha your test files might stay the same. The whole seeing where all variables come from is definitely a good practice for production code but for testing it doesn't really matter. It's the same for all tests. There is no guessing. 
I looked at the docs for folktale and it's really sparse and outdated. I'll have to search around and see if there are any tutorials. The docs just didn't do it for me. I guess I need to learn more about functional concepts before I can really grok it.
TAP reporter also exists for mocha. There's no benefit to doing node my-test.js unless every file might have a completely different test suite and way of running tests. I'd rather have a system where all tests are guaranteed to run the same. You can also do plain JS in mocha. You can generate a whole bunch of describe and it blocks based off of an array or do any other JS logic you want. Tape is cool that it pushes people to think about using plain JS. But be aware that this is also possible in other tools. It's true that you should use what works for you. Opening a discussion hopefully helps people get a better view of what might work for them. 
First, off let's define "true js engineer". Your post seems to imply that "working frontend" and being a "true js engineer" are incompatible, but they are not (source: I'm 100% front-end and would qualify as a "true js engineer" by most anyone's standards: I've led teams, written a book, etc.). So, it's important to decide: do you want to be a full-stack engineer or a front-end one? Once you decide that, your next question should be: do you need more breadth or depth? Learning another programming language (as suggested by halfzebra) is awesome for breadth, because it will expose you to different ways of thinking about problems that you can apply all over the place. But it won't help you if the job you're interviewing for expects you to know how to use (say) Webpack; for that you need more depth. Once you figure those two out I think people can be a lot more helpful.
Look at the docs for `hasLayer` -- it takes an [Ilayer](http://leafletjs.com/reference.html#ilayer) as a param. Is the `classes` variable that you're passing in an `Ilayer` object? Also please provide the console error, if any, when you have an issue like your map failing to load. 
Find a mentor.
I've read most of the guide but have yet to finish it. That's where I was introduced to functional concepts but it takes a while to absorb, especially since I've been doing the OOP thing for a looong time.
learn a statically typed language that will push your education to paradigms you haven't experienced yet
This is a controversial opinion and I've never once made it without getting angry feedback - but I have been on-call devops for production nodejs (and many other) applications for ~8 years. What I will tell you is that unit tests don't matter _at all_. No one cares, no one trusts them, and no one looks at them. Unless you have an organisational imperative to upkeep, testing, integration, control (which no organizations that have ever made money have), they will become tech debt. On the other hand - integration tests. Integration tests are monitoring, they're production-ready, they're testing the real world - they don't require mocks, they don't require frame works, and they don't require diligence from your developers. They can be run before, after, during deploys - and they can be run on a loop connected to a monitoring system. And do you know the framework required to run them? `Bash + cURL + grep`. You get exit codes, status reports, plug-and-play with any command line tool. Want to integrate docker into your integration test pipeline? Don't sign a corporate contract - `./test.sh &amp;&amp; docker build...` I know, I know, I'm wrong. But when half the code in a codebase is mocks and stubs and `IF ENV == DEVELOPMENT`, I promise your Ops team hates you. When a codebase does one thing, is tested continuously from the outside, then everyone forgets it exists (aside from just the authors who threw it over the fence)... It's a different story. It's not a story at all actually, because everyone forgot about it because it just works.
This is everything I hoped it would be.
Found an annoying bug. If you click to the right of the last available character after typing 1+ characters, if you enter invalid characters, the cursor remains in place and nothing happens, with no feedback as to what's going on.
Write your own blog website - you don't have to post any content, just create it - try to mimic a blog you like. When you have that to a state where you could at least roughly do what is needed, rewrite the whole thing - this time changing things in your code because of problems that you found with the approach you took the first time. After that's done, rewrite it again. If you are applying for a junior software role you don't need experience - I would be looking for someone who understands the basics, is eager to learn, and hopefully has the ability to pick things up quickly. I'd probably also be wanting someone who understands css so its easy to put them on css related tasks to add value to whatever is being built when theres not enough resources and too risky for the junior dev to be working on some js.
Excellent answer, thank you :)
Mostly just bants, yo. I was hoping I'd get some interesting reasoning at first. It just seems really strange that you'd let your technical opinions intertwine with your emotions like that but to each their own.
oh you are one of those... It isn't intertwined, in the end it's not the tech that matters it is the emotions, people don't use your app/website whatever because it has the newest or best library or tool or whatever. They use it because emotionally it fits well with them. And masked input just isn't the most neutral option right now. 
If you want some fast victories learn map filter and reduce. It will change how you code and think about problems. Today I started using lodashes _.get and _.set, they solve a lot of problems.
Yes, this is correct. I will try this method out. **Update** Would I put this inside of the For in loop or comment it out completely?
Now we're getting somewhere! Given that premise, I understand what you're getting at now. As a lifelong techy/tinkerer, it's easy to forget about the "regular user", I guess. I look towards functionality above all, I never even consider how a design makes me "feel" unless it's frustration, and I think I've got a higher tolerance than tour "standard user" for that too.
Hrm. Well, maybe without so much condescension, could you explain how one would go about sharing private methods between two public static methods?
I think masks are cool but the issue is people seem to think now they don't need a label. We have to stop trying to drop labels. From my experience the reason labels aren't used is a design decision rather than a usability one. 
I don't think he's trying to be condescending, JavaScript just does things differently. I'm learning it at the moment too (coming from Java and C#) and I've found it doesn't really a concept of classes or private members in the same way that other languages do. However, like OP suggested, these features can still be mimicked. There's a good intro to object-oriented JavaScript [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript) if you want something similar to classes in other languages. You can also create objects using [the module pattern](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript). There's a list of other good resources at [JS: The Right Way](http://jstherightway.org/). **Edit:** There's also [Learn X in Y Minutes](https://learnxinyminutes.com/docs/javascript/), which has quick-reference pages on common languages.
What exactly is needed to make them "real" classes? Programming languages are just abstractions to make it easier to make computers do what you want. ES6 classes have been incredibly valuable this way, even if some have declared them not to be "real" classes.
You're getting downvotes, but I agree with you. I've been learning C this year and it's taught me a ton.
I guess the more important question for you is, what area do you feel like you're lacking in? What do you find confusing? What don't you understand as fully as you'd like? Once you answer those questions, it will become much easier to find resources to help you fill in the gaps. 
All great stuff! I only wish I could finish a project before my library/framework gets a new, great update.
I believe the answer you are looking for is convert json to bson, deflate binary, encode binary to base64, replace unsafe base64 characters with url safe ones
&gt; Yep, but try pulling in something trivial like lodash.merge. That "should" be a handful of lines at most to do a single, trivial, well-defined task. A deep recursive merge is a bit far from trivial but even that is only 1.9kB min+gzipped with something like lodash-webpack-plugin ;) npm is great \o/ 
All you people railing against lodash. You do know that you don't need webpack tree shaking or anything fancy. They are all published separately under 'lodash.&lt;function&gt;'
It's a gray area. We don't hesitate to say that Python or Ruby has classes, yet it turns out classes in those languages work the same as classes in JavaScript.
Learn some alternatives to object oriented programming. You'll have a better time in JS (IMHO)
Okay fine we can talk about javascript then.
.map is an Array method, in the code in the OP locationData appears to be an object. so you would need to do var x = Object.keys(locationData) x.map etc.. 
Don't get me wrong - I'm seriously impressed with Lodash and genuinely appreciate all the hard work you put into it, but I think it's genuinely dangerous the way a lot of JS developers seem to think external dependencies are effectively harmless or cost-free. In reality everything's a trade-off, but when people are blind to the downsides of their choices they - almost by definition - don't make good ones.
My advice, as some have noted, is to not get stuck on a solution that you've already identified. Think about the problem you're really trying to solve, and ask the community for help with that *problem*.
Yeah sure thing. I use gulp atm to run my tests but you can also run istanbul and mocha without. With gulp: import mocha from 'gulp-mocha'; import mochaBabel from 'babel-register'; import istanbul from 'gulp-babel-istanbul'; import del from 'del'; A task to delete the coverage folder before generating the report gulp.task('clean:coverage', () =&gt; del(['coverage/'])); A task to initiate istanbul gulp.task('mocha:coverage', ['clean:coverage'], () =&gt; { return gulp.src(['server/**/*.js', '!server/modules/forceSSL.js']) .pipe(istanbul()) .pipe(istanbul.hookRequire()) .pipe(gulp.dest('coverage/')); }); A task to start mocha gulp.task('test:mocha', ['mocha:env', 'mocha:coverage'], () =&gt; { return gulp.src('test/backend/**/*.spec.js', { read: false }) .pipe(mocha({ reporter: 'spec', ui: 'bdd', timeout: 8000, compilers: { js: mochaBabel } })) .pipe(istanbul.writeReports()) .once('error', () =&gt; process.exit(1)) .once('end', () =&gt; process.exit()); }); And then i setup the npm test script to invoke the gulp test:mocha task. In CLI: istanbul cover _mocha -- --reporter spec
Aaaaand I think that’s literally the only thing I’ve said that you *did* understand. Ah, well. None so blind (etc). Have fun.
Thanks! We brainstormed many options and document store with key posted as URL query arg was one of them. The purpose of this thread though was to explore just the option mentioned in the title.
https://m.reddit.com/r/javascript/comments/51x74w/is_it_possible_to_compress_json_to_a_string_of/d7guax2
"Regular expressions will always outperform you, " False. They are often fast, but not always.
I'm not sure specifically what issues you're running into regarding extra lines of code (if you could explain it for me and others, I think that'd be helpful), but what I do know is that if you're looking to emit to a single file, TypeScript allows you to combine the `--outFile` option with `--module amd`. You can then potentially run that through a minifier.
These SJW are insane
Yes! I didn't know this existed! Works perfectly. Thank you!
The only issue I have with this is that I have to import the entry point after importing the bundle. Would be nice to let system or AMD provide an entry point when importing the bundle. Or am I missing something? I'm using system js and build with --out 
Well, this is getting a bit hard for me to do - the sabnzb runs on my synology NAS, not sure how I would do this!
&gt; In practice this has happened twice in recent months with point releases of Lodash alone. Lodash is generally low risk. Most cases of things breaking come down to folks doing things outside the documented usage or supported environments. &gt; Protip: it's really hard to unit-test for browser support (arguably the biggest source of JS bugs going) and really easy to push out code into production that breaks when run in certain browsers Things like Sauce Labs make it easy: https://saucelabs.com/u/lodash Code coverage is a rad thing too: https://coveralls.io/github/lodash https://codecov.io/gh/lodash &gt; Yep. And even so it frequently pushes out releases that break in browsers, and has to do several hurried point-releases over the course of several days to fix the broken code in production. I donno, browser related issues are pretty rare for Lodash. If you have a project that is hitting issues you should pass it along.
You should have totally led with this response :)
Upvoted. I agree, every time someone creates a shiny new thing solving a problem that was already solved almost a decade ago we should go with it: You know event sourcing? That's old, use Redux instead. You know Functional Programming? That's old, use pure functions with immutable data structures instead. You know REST? That's old, use JSON over HTTP instead (and call it a "new REST" or just "REST"). You know the agilemanifesto? That's old, use the asyncmanifesto instead... and it goes on and on and on... Shiny new thing FTW.
Hey, Text Mask author here. Cleave.js looks pretty well done (I hadn't heard of it before today). One difference I can see between the two libraries is that Cleave.js gives you easy API for common use-cases. Text Mask, on the other hand, makes no assumptions about how you want to use it. This makes it more flexible, but maybe it would require more work to get it setup? Another (probably negligible) difference between the two is the file sizes. For a phone number mask, you don't need an add-on in Text Mask, the size is around 8KB. With Cleave.js (if I'm reading correctly), the total size with a phone number mask would be around 24KB. Oh, and I just noticed that Cleave.js doesn't support editing a value in the middle. The cursor always jumps to the end. I think they can easily fix this problem by using Text Mask's [`adjustCaretPosition`](https://github.com/text-mask/text-mask/blob/master/core/src/adjustCaretPosition.js) algorithm since it's a pure function that can guess where the caret should be placed correctly (and everything in Text Mask is public domain, so they don't need to add attribution or something like that).
Underscore and lodash have similar APIs, and the same problem. That's what ramda and lodash/fp address.
Yeah, I think they're annoying too. But I made Text Mask because I saw an opportunity to make input masks that don't interfere with the natural interactions with text. For example, you can select portions of text and delete it, paste, edit in the middle, etc. Aside from some edge-cases, it all works as expected.
Why not just attach the listeners when you create the element?
help on some open source projects, a lot have 'begginer-friendly' tasks, this should give you experience working on loosely defined tasks, understanding an unknown codebase, code reviews, etc, etc Plus you get to meet some very friendly people (most :))
try the querystring package
I have a massive web app equivalent to Google docs and I need to split the code just like you'd do in C# or C++. And after I'm done I'd like to pack it into one file(like jquery, look how they have split code on github but then they pack it for distribution).
Have you looked at the JQuery load function? https://api.jquery.com/load-event/ Doing something along the lines of: $(window).load(function(){ // start doing javascript here. });
If your interested in isomorphic/universal JavaScript you should check out https://github.com/rill-js/rill. It is a replacement for react router that brings Express style routing and middleware to the browser. / Shameless plug for my own framework
Awesome explanation, any idea why people are hating on the ES6 class features. I get syntax sugar for people coming from other OOPL's but if you know whats its actually doing, it seems a lot cleaner to me. Just realized its u shortsynapse, you fuckin legend 
[removed]
He meant you don't need to use AMD unless you're loading scripts asynchronously at runtime. You can use ES2015 modules (TypeScript can output these instead with just a simple config change) and then use a bundler such as Webpack or Rollup to bundle your code into one file. They have much less overhead than require.js and almond.js (https://webpack.github.io/docs/comparison.html)
I liked how the article just went on and on about the purity of a pure function... who cares! All I want as a developer is performance optimized code that is as readable and scalable as possible. How or why "functional programming" does this is beyond me.
The object that getElemenyById returns has a bunch of properties and methods. You can learn about them [here](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement). In this case, you're looking for `value`: var num2Value = document.getElementById('num2').value; console.log(num2Value); But this is probably covered pretty early on in any javascript tutorial, so you should probably just go through one of those. Otherwise you'll have a very incomplete understanding of what you're doing. 
If your code is just before the ending body tag, this means that the DOM has fully loaded - that means that you can successfully interact with any element with JavaScript, and all of the answers other people have given here will not do anything useful. This is typically the right time to start executing your code, you won't have to worry about any errors with missing DOM nodes. If you want to specifically start executing some code once you're sure that the images have fully loaded, you're going to have to write some custom code - but again, most of the time this is not necessary. You could [append the images from JavaScript and listen for the onload event](http://idiallo.com/javascript/img-detect-loaded), but this means that the images won't start loading until your JS starts executing. 
https://www.npmjs.com/package/lodash.get import get from 'lodash.get'; const get = require('lodash.get');
maybe "offtopic", but you check this out: [freecodecamp](https://www.freecodecamp.com/)
[bel](https://github.com/shama/bel), [yo-yo](https://github.com/maxogden/yo-yo), and [morphdom](https://github.com/patrick-steele-idem/morphdom) are older than 3 months but have grown in popularity. They use template strings and actual dom, as opposed to transpiled jsx and virtual dom. These modules gave rise to [choo](https://github.com/yoshuawuyts/choo/), a modular functional framework. Also [inu](https://github.com/ahdinosaur/inu) which is a composable unidirectional UI framework that uses the same modules listed above along with [pull-streams](https://github.com/pull-stream/pull-stream). 
Hi, I'm the author :D The fire is rendered as a particle system of about 300 particles. It turns out that only 300 particles can result in a significant amount of overdraw, and this will cause poor performance on lower-end graphics cards. But I solved this problem by rendering the particle system to an FBO that is about one-fifth the size of the screen, and then upscaling and rendering it to the actual screen. Since then less fragments are processed, the overhead from all the overdraw for the fragments is significantly reduced. This technique is called off-screen particles, and you can read more about it [in this article](http://http.developer.nvidia.com/GPUGems3/gpugems3_ch23.html) 
&gt; JS class instances are completely mutable anything but concrete. You can Object.freeze them. Strong mode did that, for example. &gt; you might as well say JS has things like structs. I wouldn't say that, but I've seen proposals for that kind of thing.
There's 2 ways of solving this I think: 1. In `cardTarget.hover`, you do a check, ` if (props.listId === sourceListId)` and only update the monitor if the monitor is the monitor that you started dragging from. You _could_ try and find the monitor that you're actually dragging over, and if it exists, pop the card out of the original list, and push it into the new list. This is how I ended up doing it, and it requires that you: - Tie the original parent to the card when you start dragging. - If you detect you're on a new parent now (the above `if` is false), pop off the old parent, add to the new parent, and update the tie so the new parent is now the "old parent" (in case they drag back to the original parent). 2. On drop (in `containerCardTarget.drop`, compute where you got dropped, this would require you to quickly use `monitor.getClientOffset` and the offsets of each of the items to then choose _where_ in the list to drop the card, instead of just pushing it onto the end like you do: if (id !== sourceObj.listId) component.pushCard(sourceObj.card); (btw, style hint, you should _always_ use brackets on your `if`s, it's easier to avoid bugs if you choose to expand that statement, and it helps keep your version control blame clean) I went with option 1 since it makes the code a bit cleaner, and it makes it so that your user can actually see where they're going to drop before they drop (just like how they can see where they're going to drop in the original list in your example). But my code is sometimes buggy, and I haven't quite worked out some of the intricacies with it, so I'm not willing to share it yet. Option 2 would be nice and clean, since you're doing more of the work only on drop, so it makes things "faster" (if you're only doing the "is this on a new container" on drop, rather than on _every_ hover call, things are a bit faster). But with this you lose the fancy "live update" of the drag on the new container, and you might end up with some bugginess trying to compute offsets in the drop container. Also, there's the totally nuclear option of just not using dnd and going for straight [HTML Drag and Drop](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API), since that gives you a nice API for `drageEnter` and `dragLeave` to make option 1 way easier.
You can try adding the attributes defer or async to the script tag. Async will make the javascript execute asynchronously, and the defer will run the js before DOMContentLoaded event is fired. [async](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) 
~~A `do-while` loop always does one iteration before testing the condition, as opposed to a `while` loop which always does the test before an iteration.~~
 &lt;/script&gt; Just in case someone comes in here and copies and pastes this, it's missing the closing &gt; 
I continued last weeks showoff layout engine by creating a JSX -like syntax using only Template literals to transform and compose the views. The view objects are created using $`&lt;View&gt;&lt;/View&gt;` and inside the literal you can insert new views or text created by JavaScript or map lists to new views. The views are able to maintain the function context where they were created which in theory allows functions to be used as components. There's also experimental Hover and event system support. http://codepen.io/teroktolonen/pen/VKvQaJ?editors=1010
Starting a new react project is now bearable with [create-react-app](https://github.com/facebookincubator/create-react-app).
I didn't find the article condescending at all, and I thought it did a great job of as a "intro to fp".
We're in a relatively stable period. Major upcoming shift is [serviceworker](https://jakearchibald.github.io/isserviceworkerready/), minor upcoming shift is async/await. The churn as I remember it: * Google devrel and Polymer have been pushing a new acronym [PRPL](https://www.polymer-project.org/1.0/toolbox/server), which you may/may not need to know going forward. * Rollup has been making inroads on webpack. There was a nice [article about modules](https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/) that pushed a couple people I follow over. * Facebook's Jest team put out a new release with sane defaults for non-FB projects. It seems to be well received with people reporting faster test runs compared to alternative runners. In hipster hacker frontend tech: * Elm put out a new release (0.17) that got rid of Signals as their core abstraction and embraced The Elm Architecture as the one true way to build apps. * [Bucklescript](http://bloomberg.github.io/bucklescript/Manual.html) hit 1.0 and produces impressively high quality javascript. * Clojurescript's re-frame had a new release which introduced [async flow effect handlers](https://github.com/Day8/re-frame-async-flow-fx). It's a slightly different take on sagas and the like.
Honestly, I'm not sure why people don't like the addition of classes. I think they make OOP dead simple in JavaScript now. I guess some people hate change? And what do you mean I'm a legend?
No?
Integrated selenium testing into the createNode [view function](https://github.com/SeanJM/create-node) -- It's results are automatically embedded in the README.
The technique I have used in the past is something like the following $(data).hide().appendTo(target).fadeIn()
Sounds rough... Hang in there pal.
Oh shit man! Good to see you around again!
oddly enough it worked when I tested it. Apparently html just don't give a shit ¯\\_(ツ)_/¯
It means the HTML parser thought it was missing a &lt;/body&gt; tag, and that your /script tag looked funky.
thanks. That sounds like a good idea!
Looks good. A general pattern for private method is simply naming them with an underscore prefix. So far example class MyClass publicMethod(x) { this._privateMethod(x, this._privateVariable) } _privateMethod(x, y) { ... } } would have intended _privateMethod and _privateVariable to be private. Of course they are technically still callable, but the convention is to not call anything with an underscore prefix from outside. And if it's double underscore prefixed like `__proto__`, you're either trying some metaprogramming or really going into a wrong direction.
this should help you see how to parse the query string, basically you would use window.location.search, and then further parse that by splitting on characters that it makes sense to split on http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript once you have parsed those values, they want you to place an &lt;img&gt; tag for each one that will display a 1x1 image that is returned from the following URLs (replace the placeholders with the parsed values though) http://i.w55c.net/a.gif?p1={p1_parsed_value}&amp;p2={p2_parsed_value} http://i.w55c.net/b.gif?price=500&amp;p2={p2_parsed_value}&amp;sku=d90&amp;p1={p1_parsed_value}&amp;t=conversion to do this you will want to look at document.createElement, document.getElementBy*.append, or jquery equivalents, or you could use a frontend framework with databinding features, or whatever to prevent the images from being placed multiple times, you might want to look for a way to check if they already exist on the page, and only append the elements if they do not already exist That should be enough information to get you started without doing your homework for you.
Haha, whoa! I didn't expect to see inu mentioned here 👍
I like ES5
The basics of it though is that you need to hide it before you append it. Basically display none so it doesn't appear until you want it too
This. I'd add that you will also need to at least know the benefits of using framework againstt vanilla js, and the main differences between already existing frameworks 
I recently landed a new job, and I have never used the framework that they use. I went through the same scenario with my first job as well. So from personal experience, I don't think the frameworks matter that much as long as you have a solid foundation in JS and can convince the employer that you're an effective learner. 
Is this copy-pasted exactly? Because the 'p.then()' part of your function is actually inside the parentheses for your Promise constructor, which causes the whole thing to be invalid and error. Close the paren after the arrow function, *then* you can access p.then().
It feels like the social justice in tech movement has jumped the shark. Next year, using the word "baby" to refer to infants will be offensive. It'll become a trigger word for transgender people or some shit. This Crockford thing was our version of "Harambe memes are racist." 
I typically do put "experience with one or more SPA JavaScript frameworks" as required. I also have "strong understanding of pure JavaScript and OO JS techniques" That said, if someone was straight with me in the interview, it wouldn't disqualify them, if they truly are strong with js.
I'd say, go do a different project first, and then as you work on it keep an eye out for opportunities to share the code you write. My best open source ideas have always been something I did at work or at home on an unrelated project, and then thought "I bet other people could use this".
When Promises add complexity to the program they should be avoided, when they remove complexity they should be used. Always have a `catch` to debug.
If they test for a specific framework that is dumb. We test language knowledge first and if that goes well we may test framework knowledge if you claim to have experience with it (just to see where you land). The more important thing to understand is the language, patterns and some basic CS concepts. 
Out of interest, why do you still need to transpile? 
When you can't keep them. 
I made this simple site to remind the NES mini launch: https://ldom22.github.io/NES-classic-reminder/
I JS techniques?
Thank you! Great resource.
A) You are an idiot B) Don't look at un-minified code to point out "how absurdly large" a library is when it's 2/3rd comments.
Doesn't destructing already work in Chrome? 
I think that's always been the case with AMD/System modules (please correct me if I'm wrong). I don't think it's a huge burden, but I understand why it's undesirable.
Your question is akin to asking the following in OOP languages * How do you malloc? * How do you create a struct? * How do you do promising chaining? * How do you do functional composition? * How do you execute code on next tick/event loop? * How do you curry a function? While it is possible to do/simulate all those patterns in your standard OOP language (Java/C#), they are not the conventional way of doing things in those languages. Going back to your questions, ES6 allow you to do classes and static methods just like OOP. However it doesn't support private/public declaration. People generally use closure to hide methods in JavaScript. 
Why do either of those matter?
*always have a logically scoped catch that addresses each sequential grouping. If an individual promise needs a catch that's fine too. But the sequential grouping is, in my humble opinion, more important for debugging and less cumbersome/boilerplate.
I would say that the answer to the last question is probably true, at this point -- Javascript is used in a lot of things other than prettying up web pages and doing form validation these days. It's also used in game engines, in Qt (QML), and it's used to create entire applications .. and so if you don't have a grasp on the frameworks that people are using for these tasks.. well.. you'd better be able to get it pretty quickly :-D Despite some insistance here that picking up frameworks is easy, I'd have to say that many of them are quite complex, and basically introduce a completely new syntax to the language, which can be a bit difficult to grasp. Add on to that that we're also all picking up the new Javascript ES6 and ES7 and if you want to stay current, you've probably got a lot to grasp. I'm picking up ES6 and React right now, and I'm finding it quite enjoyable to convert a thing that I was working on that had been using no frameworks whatsoever. 
Is there any reverse compatibility to this process? Let's say i converted a draft js tree into an HTML blob and stored it in db. Then I allowed users somewhere else to edit the html blob itself in other standard wysiwyg editor like TinyMCE then a stored this new modified html blob in the db. Is there any way to convert this new html blob to a draft js json node tree to allow someone to modify this html blob in the draft js editor?
Actually one of the first java programs I wrote was a mini multi-threaded web server using a server socket, so interfacing server java with any client without any stack at all is trivial enough IMHO, maybe a json library. And tomcat is basically unzip it and run it. You can do a lot on the server with vanilla java though. But it is hard to compete cost wise for php hosting. Though maybe you can run node via cgi on those, yes? http://www.cgi-node.org/
Especially true for react.js and it's family of VDOM libraries.
[removed]
/u/chrisjlee84 has it right, but I just wanted to add that your specific case is a good fit for a framework I'm very fond of: Meteor. Meteor is a full-stack framework, built with familiar components like nodejs, jquery, mongodb and all the stuff you're likely to encounter on the modern web. It also does some tricky things really well, like keeping relevant data on the client in a miniature mongodb database (called minimongo, suitably) so that you can always write Users.find() regardless of whether you're on the server or the client. It's a great showcase for modern web development, and I use it for all my hobby projects, as well as run it in [a commercial product](www.favro.com). It fundamentally changed the way I view writing applications for the web, simply because it feels *right.* 
You're funny. PHP is not slow by any means. Especially php7. https://www.quora.com/Is-Node-js-killing-PHP I don't think so for the near future. If anything node is showing that atleast in my opinion that they are a much more difficult project to maintain due to the module pattern of node and also how dependencies seem to break continuously with node/npm projects. I haven't seen this happen nearly as much with php. But php doesn't have nearly as many "micro" dependencies as node does like leftpad or what ever it was called.
there's times when you need php and there are times when you need node... you shouldn't switch, you should be good in both.
Prepare your meds for the onset of javascript fatigue
Hm, that's a very interesting observation. It could also still be the combination of the two of course. It might indeed be worth a shot to try out the same logic for skipping uninteresting blocks, but without the regular expression and see how that changes things. Thanks!
Except please _really_ put thought into using mongodb vs postgresql or something else less trendy than mongodb. [Here's](https://www.reddit.com/r/programming/comments/3dvzsl/why_you_should_never_ever_ever_use_mongodb/) [a few](https://news.ycombinator.com/item?id=9912842) [reasons](http://svs.io/post/31724990463/why-i-migrated-away-from-mongodb) why.
If you want to switch from PHP to nodejs just for performance you gonna get disappointed. Especially compared with PHP7.0 there is not much to gain. At first it seems much faster as the node server directly answers the requests. But as soon as you add all the pieces you need for a complete application (like database abstraction, template engine or a bundle system for pluggability like symfony) you will see similar performance as in PHP. If you really want to learn how to build a high performance piece of software maybe look at https://www.erlang.org/ or http://www.scala-lang.org/ instead.
I'd personally use css animation for that. And when removing an element, "onAnimationComplete" js event which would as callback remove it.
Did you just say that modules make projects more difficult to maintain?
Use [this code](http://codepad.org/XOfEYfsx) as an example.
You might want to profile your PHP before jumping ship. PHP and Node are both very useful and not mutually exclusive.
Node is different from JS in the browser, so it can be a bit like learning a different language even though the syntax and core concepts are the same. The power of node is not the JS language, which is rather [quirky](https://www.destroyallsoftware.com/talks/wat). The power is the event driven design and the golden rule is *don't block*. You have to get used to following context through callbacks.
Great list, thank you!
This is great, thank you!
Thanks, from a quick glance, MobX does actually look pretty nice!
Yes, if you are learning always start with the language itself. You will have a better understanding overall
&gt; With the latest version of php, Does this not also hold true for the latest Javascript, or more specifically latest ECMAScript? If your starting from ground zero and you want to choose between php or js. I would highly recommend Javascript, above php. Because you can do both backend and frontend dev. I also feel JS has better tooling, you can start to play with [Javascript in your browser](http://jsforcats.com/) right now. But as you mentioned rather focus on design principles and understanding basic programming concepts like if, for, etc. If he is going the js route I would also recommend him looking into functional JavaScript; Read through the [underscore annotated source code](http://underscorejs.org/docs/underscore.html), etc. As for recommending a js web stack I would go with [expressjs](https://expressjs.com/). disclaimer: I work daily in php 5.3. While php is a de facto hacking language, it is ugly. They are trying fix it with PHP 7. But every-time I type `array(` I die a little bit inside, and it is something they only fixed in 2012(with 5.4)... took a while to realize array/list is a big programming principle. Also if your starting out to program I would recommend python above js and php. Good luck!
If you read the ticket you'll understand that it's because some gung-ho firewall software strips out anything it doesn't have explicitly allowed, meaning the verification token which is being passed back in a custom HTTP header is being removed from the firewall. That's a firewall issue, honestly. You'd have the same issue in any system which uses custom HTTP headers.
Nope, he said the module *pattern* used within node has a history of issues. I think he may be correct here, but I'm sort of agnostic. In any case the module pattern is a defacto hack to work around loose language scoping in JS, which is the only language which I've ever worked with that didn't have scoping mechanics to avoid the issues that the module pattern is used to deal with. This is the module pattern: (function () { // All of your code goes in here to prevent inadvertently stomping on globals }()); Essentially you declare all of your code inside the constructor of an anonymous function so that it gets its own sandbox to work in. This isn't a flaw in node, it's a characteristic of Javascript's design, which doesn't become apparent until you start writing larger, more complicated applications with dependencies.
We are talking about enterprise. Try convincing someone there (if you can reach someone who is responsible) to change the firewall settings. 
I have updated the article with my latest findings. So yes, the regular expression still provides the best result, but based on your feedback I was able to squeeze even more out :)
I don't disagree with you, but your complaint is placing the blame in the wrong basket.
This PolymerJS subreddit works pretty well actually.
There were no commits since March 8 in any branch. Is the project alive?
PHP 5.5+ is not ugly imo. It's actually really really nice. I used to drink the anti php koolaid until I got a job using it full time and learnt about modern php and proper OOP. Javascript feels more all over the place to me, with no real standards on how to write it. I also hate 'array()', but I always use '[]'.
It's a new thing to learn, people aren't born understanding functional programming as much as people are not born understanding deep fundamentals of math. That's an interpretation of somebody with a [fixed mindset](https://blogthenewcenturyschool.files.wordpress.com/2014/03/nigel-holmes-graphic.jpg).
Is there any reason you haven't you dabbled with any frameworks?
I've just gotten fed up with asyncness and callback hell. Started going back to php. Laravel seems really cool
Yeah, I think acknowledging the benefits of a framework is important. Not even having a basic working knowledge of one particular framework (doesn't have to be the latest thing that's cool this month) could be a red flag. Sometimes people who talk about "just using vanilla JS" are people who rewrite their own ad-hoc, buggy, undocumented framework for each project. Or they've never written anything of sufficient complexity. Or they don't care about their code being easy to understand, maintain, or extend by other developers. Of course, this is not always the case. I'm not saying not using a framework is bad - there are plenty of cases where they're not worth the trouble. Or a custom one is the right choice. But it's something to be mindful of.
Use callbacks when you want to execute something after an asynchronous operation has finished. Example: openModal('My modal', function afterModalHasOpened () { // This executed after the modal has opened // Not using promise because it is a callback }); Use Promises when you have an operation that needs to be executed sequentially, but you have to wait for the event loop: return requestWebSiteData() .then(saveToDatabase) .then(handleData); Callbacks are callbacks, promises are sequential operations in an asynchronous land (that can also be wrapped in a way that they mimic monadic binds, but that's out of the scope of this comment). **When should I not use Promises?** When you don't want to run a sequential operation or leverage the implementation of Promises for a more functional code, in that case use a callback as a function in the last argument or something else depending on the use case.
I learned you make invalid assertions, is that part of the learning process? It is about ego, i.e. you wish to claim you made the fastest of something, and thus blogs are more noise than signal.
or http://www.elixir-lang.org
And then you webpack or browserify your node modules and they turn it into a huge map of { 1: function(require, module, exports) { ... }, ... } 
This is a contrived example it looks like, so I think the real use isn't shown here. But either way, that's not true, if a promise makes your code cleaner then there's a million reasons to use it only within a specific function. We have no context to whether the outside function needs to know the result, you just changed the structure yourself. Anyway my point was that neither of your answers help OP with his question, regardless of how you or I would personally structure our code. You're correcting something that doesn't need to be corrected. 
The real problem is not speed per say, its the ability to utilize all cores. PHP have no/bad concurrency what so ever. Same goes for python, ruby etc. The language itself makes it almost impossible to have any kind of reliable concurrency going on. State is the main offender here. With node its kind of the same, however everything-async is imho still better than pause and wait for some program to return. I found i have to push everything to a MQ with languages like PHP. 
Since there seems to be a lot of "I learned PHP and now I'll feel bad if yet another person abandons the sinking ship I'm stuck on so I'll try to dissuade anyone who wants to do so" posts here, let me just say you're doing the right thing. PHP is the web's past, Javascript is it's future. PHP 2013 =&gt; 2016: 34.8% =&gt; 25.9% Node 2013 =&gt; 2016: 7.5% =&gt; 17.2% Source: http://stackoverflow.com/research/developer-survey-2016 "Worldwide, Java is the most popular language, Python grew the most in the last 5 years (6.8%) and *PHP lost the most (-5.0%)*" (emphasis added) Source: http://pypl.github.io/PYPL.html 
Python has threading and multiprocessing. You can definitely fully utilize all cores with python. EDIT: And for that matter, Javascript is single-threaded. You have to do some hackery to make NodeJS use multiple cores.
So might be, but writing custom code you can name the entrypoint module "entry" or "index". My use case might be a bit corner case but it's a cshtml file loading js files dynamically, therefore I don't always know the module name of the entrypoint. However if the tsc would have an option to name the entry point I would be able to do it more easily, provided the files array is only a single file. Now I have to do a gulp script with replace and do it build time, but id rather have it in pure tsc compiler. 
A lot of these replies are comments on the performance argument, which I feel doesn't really address your question. If you already have vanillaJS knowledge, picking up Node is simpler. There are some concepts in Node that are going to feel a lot closer to PHP, but just remember everything is asynchronous and that will help. I will caution you on the point of "full stack js" because there are a number of "full stack js" databases (really, persistence engines) which have no business being the basis of a serious application. The databases are promoted heavily by the js community, which is unfortunate, because the idea is the same (js everywhere), but the eventual execution is not good long term. And finally, I'd like to add that for all the blog posts of "leaving X for Y", nobody ever really abandons a programming language. You simply learn something new for a while, and typically end up applying your previous languages concepts where you can, to make something entirely your own. This is double true for js because the language itself is mostly flexible, and indifferent to your coding style. A sincere glhf on your efforts.
Was gonna comment with your EDIT, but you got it. So many people don't realize Javascript is single-threaded.
I got a 10-day class on PHP and thought I was a fucking master. Then I started writing actual PHP, and I was like, "DEAR GOD!" I didn't know shit. A year later, and I'm using Laravel 5.3, and let me tell you: had I not started with regular PHP, I would have NO FUCKING CLUE what is going on in this framework.
**any** sort of normal website. dashboards, login, any sort of interface.
Also, separation of concerns. If I have a job that may be considered "heavy lifting", I don't want my API server handling it. My API server is supposed to respond with a result quickly. 
Well of course you can. But my point is you are still screwed! When your language has global state and mutability there is no way to have a safe program using multiple cores. What about two processes both changing global state? Now take 1000 processes... There is no shortcut here. You will have to use a functional language for anything more advanced. Message passing is the best way imho! :)
Actually, I would say that PHP scales horizontally much better than node. Whether it's FPM or even mod_php with apache/prefork: you always can have multiple processes running - one per CPU. Because these processes share no user data, there's no locking to take care of. Node by default only runs on a single core. In order to make use of multiple CPUs, you have to go extra lengths and some of the most straight-forward seeming methods (forking) come with some caveats. Now node is probably faster than PHP once the JIT has warmed up, but it's going to be much easier to run more of PHP at once. So measure before quickly running with the more hip solution. 
You can write thread-safe python. Anything you can do in Node, concurrency-wise, you can do in pretty much every other language. You can even write multiprocess code in PHP, although it's really not made for that, so I don't recommend it.
At least it's *in* the standard library so it's a learnable behaviour, because it's consistent. Without tuple unpacking or some way to return multiple values, what would the alternative be? An object with index, input, and results array? ...Actually that doesn't sound too awful.
No, you do not have to browserify, minify, or transpile node modules for the backend which is what this thread is about; that's mostly for front-end code (which may include modules that also work in Node).
Thing with PHP is it can be used in many many ways which can make it incredibly ugly if you're not doing it right. To use your same example `require` in JS can be also used anywhere. You can `require` at the bottom of your file if you really want to. The isssue arises from the scope. This is why you'll rarely see includes in PHP in newer projects. You'll likely see completely OOP based implementation with auto loading etc. The function naming conventions are absolutely awful, thankfully frameworks like Laravel and the advent of alias' packages on composer (PHP's package manager like npm) makes it a lot easier to remember without outright changing it in the language itself - which would be difficult to do since it'd break a lot of scripts.
&gt; This is why you'll rarely see includes in PHP in newer projects. You'll likely see completely OOP based implementation with auto loading etc. Well that's good, was hoping this had been solved by convention at some point. Again, probably a lot of my issues were more with the messy codebase I have experience with.
I work a day job as a Full Stack Javascript developer. Recently took a PHP class. Functional Javascript feels much cleaner than the OOP in php. Personally, I think PHP's strong opinion on OOP is a weakness. Especially, when compared to ES6 where you can use a class keyword if you so choose but honestly i've never used it. The failed proposal of arrow functions killed me too.
I work as a Full Stack Javascript developer. Typically for our prescreen we will give a developer a list of like 4-5 technologies that they are unlikely to have used before and ask them to integrate a starterkit for it. For example: If they are a react developer who typically uses babel, and redux. We will ask them to integrate an Angular 2 starterkit with typescript and ng-rxstore. If they can do that then they have the versatility we need. We will then call them in for an in-person interview which would gauge how well the know the technologies they actually claim to know. The type of person we want to hire is someone who I can point to a random library on github and be like evaluate this library. And they should be able to pick it up and build something with it and give me feedback on it by the end of the day.
Re: some of the back and forth about multi core concurrency. Do you really need it? All the languages mentioned give you non blocking I/O, which solves 95% of your performance issues. The inability to use true concurrency in PHP or Node (versus Python or JVM) really only matters in two use cases: you're doing cpu intensive calculations and/or you have an API where you actually care that it runs in 15ms instead of 45ms. Another key thing to note is that this is completely unrelated to scaling and only deals with speed of each single request. If you don't care about squeezing out that last 5% of performance (and you rarely do) then any of the aforementioned languages are effectively on an equal footing. 
On the plus side, the documentation is about the best I've ever seen for any programming language. 
Comparing PHP and Node is like comparing apples and.. an orange taken out from a whole bag of fruits and vegetables that is Node. Nodejs/javascript is not just about building websites anymore. Ever used Gulp/Grunt? Babel? Anyways I wish I learned that the current trend to make good web sites is to separate server and client entirely. We're not building sites in NodeJS that does the job of both serving HTML and handling server tasks and realtime websocket requests. No. Client-side stuff should be entirely separate. If you do it right you should have a completely static website, with React or any other frontend framework, that should be able to run without nodejs, possibly served by a big cloud. And on the server side you'd have clustered Nodejs API server app (possibly behind nginx). This is what I wish I knew I should be doing to begin with when starting out with nodejs, instead of making "old fashioned" "websites" (an artifact of PHP era that I was still trying to re-create in node).
Personally, I am all-in on React and Redux. I like the capabilities Redux enables, and actually _like_ some of the "boilerplate" that people seem to complain about. But, I can see why some people prefer MobX. There was a good discussion thread a couple months back comparing the two, at https://www.reddit.com/r/reactjs/comments/4npzq5/confused_redux_or_mobx/ .
In your post you are talking about his Stampit alternative. But I refer to his critique in the post which I linked. I didn't say that his alternative is better, but he is explaining some pitfalls in the post which are real such as the gorilla banana problem.
There are plenty of modules that do things that shouldn't be done in point and minor releases... although it's less impacting when you have a build process in place as part of CI/CD, and there are ways to lock dependencies down completely.
If you want just simple static hosting check out: https://surge.sh If you want some simple node.js server side stuff check out https://webtask.io
what is MQ?
Not exactly. Read about Global interpreter lock. Even though python supports multi threading, the GIL creates a bottleneck.
The "coding" part of the workflow is virtually identical to what you would do in node: you put your bootstrapping logic in a `main.js`—or whatever you want to call it—and you organize your code in CommonJS modules with `require()` and `module.exports`, just like in a node project. The "bundling" part is obviously not necessary in node so that's where the difference is: you give that `main.js` file to [browserify]() which will follow all your `require()` and build a single `script.js`—or whatever you want to call it—that you call in your HTML page like any other script.
Here's one case when you shouldn't use promises: when what you're modeling can happen more than once. For example, I work with an in-house non-Web library that has an Image class, and that class holds a promise to represent loading the referenced asset. If the referenced URL changes then the promise has to be swapped out. This can happen before the old promise resolves, or after, with very different behavior in either case. Anytime you find yourself swapping out an old promise for a new one, that's a giant warning sign that promises are not the right abstraction. In my case it could have been anything from an "addEventListener" style system to an RxJS observable.
Everybody please stop writing libraries AAAAHHHHHHH
MQ = Message Queue. It's a way to store your non critical tasks for later and do them at your own pace, most often by completely different servers. Placing to the queue (requesting work to be done) is done by "producers", while work requested is done by "consumers" (sometimes "workers"). If the job takes 10s each, you might have 2 producers and 50 consumers which insures your front-facing app is snappy to respond, while you can respond to usage spikes by just increasing the number of consumers, which is really easy to do. Look up, for example, RabbitMQ.
I don't know why you have the impression we ditched PHP for Node when I said we never use PHP. We have never used PHP and the only reason we use Node is cause some of our smaller clients have an API they must use for ecommerce stuff. Otherwise, we wouldn't use that either.
Not actually a thing imo
&gt; EVER lmao i can't wait until you write something other than a CRUD webapp
Then you'd be wrong. There are just better ways to do things.
I have used Redis PS, but only via Kue which gives you a queue-like abstraction over it. It's OK if it works for you, but if you hit a wall (say, with monitoring your workers, figuring out throughput, failure rates, etc) I'd go with a dedicated MQ solution like the before mentioned RabbitMQ. You'll need to figure out how to deploy it, but later you use it like any other system service. I've worked with Gearman too, it's a job queue instead of being a general MQ, but the project seems dead now. Have great experience with it in several big projects.
 Yea.
&gt; So in terms of a web server using multithreading for python or ruby would make it actually slower. Then you should be utilizing Apache or Nginx for that. 
Thank you friend ;)
Uhh. This is more of a subreddit for people who develop in JavaScript. The fact you're encountering this and confused by it means you likely won't find help here. Your text editor is likely designed to explicitly strip out JavaScript code. It won't work. Find some plugin for WordPress or a developer who can help you. Good luck. 
Someone should tell the many sites out there that run day in and out on Python that their language is too slow. They probably won't realise otherwise.
I think you're either missing my point and/or forgot some of the things you said. "The few times we run into someone else's code that does, our first task is to get it off that" "PHP is fine for smaller sites where performance is not a requirement"
Recently started using https://modulus.io/ and enjoy it so far. It's a lot like Heroku and the deploy process is just running a cli command. Sounds like one of those two may be what you're looking for since the config for each of them is minimal if you're just deploying a simple node application.
Slightly more detail: What you are talking about is the fundamental principle of functional programming, that functions should be in almost all, if not all respects, the same as data. In javascript this means that you can simply assign a funciton "object" to a variable, pass it to another function, etc. When you pass one function to another, the one that accepts it is called a [higher order function](https://en.wikipedia.org/wiki/Higher-order_function)
i'm aware of the context, but "It's NOT a language problem. EVER" is a statement that explicitly disregards the context
Well yes i understand that part. The thing is there are javascript functions in the CGI script that i wanna execute. However when i used Chrome Inspector and try to run that function, it doesn't work, meaning it's not viewed in the DOM. Any way to access those functions?
"but i'm using a no-sql design and would need to update the avatarID in multiple places on any update, if I went this route". It sounds like you should address the real problem here. Hopefully it's not too late.
&gt; With the latest version of php, you can get a sense of OOP that you wouldn't from javascript. Please try to be more specific here. PHP supports `class`-ical OOP while JavaScript highly support `prototype` based OOP. So, to get into OOP concepts -- JavaScript is still good but may not be true from the perspective of a novice developer, or a "class"-ical OOP programmer. That said, from my (personal) experience: JavaScript is the best language to actually make use of Design Patterns in code we write daily.
Node is irrelevant to my statement that blindly replacing PHP with something else is foolish.
I have no choice in the database
&gt; When your language has global state and mutability there is no way to have a safe program using multiple cores. OSes are programs. They're also typically written in C.
After looking more at etags it looks like they perform a checksum to see if a file changed. So would this automatically work if a different picture gets posted to replace the current one? Seems like it.
Hi /u/peterecruiter, this post was removed because /r/javascript is not a job board.
Hi /u/Drugs_and_Mirrors, please post your directly (no images). Thanks!
Do you need to wait for the window to load everything? Like [this](https://css-tricks.com/snippets/jquery/run-javascript-only-after-entire-page-has-loaded/)?
Yeah, the OP has it dead on. I find some beginners struggle with callbacks, when they don't struggle defining a function and calling it themselves, as they think they're somehow special or magic or exceptional. You're just providing a normal function for another function to call if and when it needs to. Seems so obvious once you get it.
That is not how I understood their comment. I understood it as saying that there is always a tweak you can make to your application's architecture to make it perform well enough in the language you originally picked. I don't think that is true except for problems that have trivial computational content, such as communicating with a database.
Node.js is easy once you have your JavaScript basics right. Focus on learning JavaScript (not Node.js first) and then try some stuff on Node.js. I recommend you to start with a framework like Express because it has so much flexibility that it forces you think and design your application yourself. That was invaluable for me coming from frameworks in PHP where everything I needed was baked in and had little room to innovate. Also learn to use promises early on because it makes so much easier to work with async code and also because a lot of libs already use them. And lastly, have fun, coming from a language like PHP, Node.js feels much more advanced and it's much more fun. Specially npm. I love it as a package manager, also the module system in Node.js is a lot of fun.
Well no, everything got loaded already. I just need to find a way to read the HTML that has been loaded after. Chrome Inspector can find it in the DOM somehow but when I try to find the element in the console, it says undefined, meaning it's NOT really there...
Not in Node.js though. In the front end sometimes the struggle can be real.
Promises was a game changer for me. I'm sure async/await are too but haven't taken the time to learn it though.
Thanks for the suggestions. I thought Heroku was just another VPS with some sugar on top for ruby/rails, but I guess I was wrong. I'll have a look at the links posted. Thanks again.
I'm confused, do you know any code? If you know a bit of JS, you could get a jQuery slideshow library and hack something up quickly. Is there any part of it you're stuck on especially? If you don't, and you want some images in a slideshow in a pinch, there's probably a free photo hosting site somewhere that might allow you to upload some photos and create some kind of slideshow that can be linked to. But it won't be exactly what you want. If you want a custom slideshow built for you, I don't think anyone's going to jump at the chance to do this for you for free. You could try one of those cheap freelancing sites? If this is for an interview or school assignment or something, and you don't even know where to begin, you might as well just face the music. You're screwed.
Yeah it might sound confusing. It's just a simple exercise but I'm going to be honest I dont understand much o JS. I guess I'm screwed indeed. It's just an old assignement that I didnt atend because I was in the hospital. If you know of any basic scripted code around for a slideshow feel free to tell me and I'll edit it. It's the onmouseover events and all that jazz that I dont know 
That's because the problem area is complex. I don't know why you think a functional implementation wouldn't also have many bugs and a massive amount of people working on them. Language choice really does not matter as much as people on message boards think it does.
OK. What doesn't make sense to me is that you can't get a reference to the element while you can see it in the inspector at the same time. If it's visible in the inspector, it's in the page's DOM. If it's in the page's DOM, it is findable by JS. So I'm having trouble figuring out why it's not working for you. Here are the steps as I understand them: 1. The page is loaded, with no content. getElementById will fail here, as the content isn't loaded 2. The page makes a request to the CGI script via JS 3. The CGI script request is completed. The page's JS updates the page's DOM 4. Now you can see the content. This is the part where getElementById should definitely work. $0 is a part of Chrome - it is a reference to the currently selected element in the inspector. So it's a troubleshooting step really - it removes any chance you're using the wrong ID or there's a typo, something like that. You definitely are using a console attached to the page, is that right? Does "window.location.href" in the console give you the address of the page?
RabbitMQ is free, and after you'll figure out how AMQP works, it's easy to go.
Is it feels cleaner because it's better or because you know js? For me well written OO code is really clean (no matter what language you use), and the same thing applies to functional programming. I totally prefer to write domain-centered microservice in PHP than in JS (ES2015), because OO approach feels more natural, and type hinting could save my ass. Btw, arrow function is just a syntactic sugar, why do you care so much about that?
Wow that's quite the gouge.
If you want to host single page applications (no backend database, etc), then I would absolutely recommend surge.sh. You can buy a domain and tie it to your site through them easily as well. It will expect an index.html and then from there host a slew of files for you as needed that you can reference to in your app. accordingly.
No worries. If you use setInterval or setTimeout to show the images, and mouseenter to stop the timer, you should have something useable pretty quickly. Hope it turns out OK.
I don't know why you have the impression we blindly replaced PHP with something else. I said we don't use PHP and it doesn't meet our performance goals, so we replace it with what we do use if we're handed it by someone else. PHP can't meet our performance goals and doesn't fit into our flow. Typically, we write all our own code. It's only the occasion when someone comes to us with a site or other code that already has PHP in it. They don't come to us cause they want another Wordpress site. They're looking for more. 
The day something like symfony comes out for Node, is the day I go full JS!
My ego? K.
A lot of things get easy if you pretend IE and the old stock Android browser don't exist :trollface: The big majority of JS stdlib and even browser APIs can be polyfilled so you can at least work from a superset of browsers, instead of having to write your code for a subset of what browsers supported 13 years ago. There is still Safari's broken `flex-basis` (fixed in Safari 10) to troll you, though...
I thoroughly agree with everything you've posted so far. This other guy is a typical armchair redditor.
You could just make the effect you want in Blender, use the BabylonJS exporter, and then overlay a canvas running your BabylonJS animation on to your web page. ...or you could just create your own effects by hand the old fashioned way =)
This is the only mostly complete answer of the bunch. The rest are vapor and people typing like they know what they're talking about.
I was putting money on this being a link to a new Eric Elliot blog post.
Hi /u/randomGuy4386, please don't repost content you've already posted before, and especially don't try to hide that you're reposting content by hosting it on a different platform.
I know that it seems that way and yes it would be nice for people to do my homework for me but I am looking more for simple guidance than for you guys to do everything for me. Which is why I will most likely be doing the last part of the assignment by myself when I have a better idea of how the code works, syntax, functions, etc. But thank you for the heads up about jsfiddle I do realize it must be hard to figure out whats going on and I apologize about that. I know I must look like a lazy student, I'm more just confused than anything and I'm willing to put all my effort in. Will post the files in a second. Thank you for the heads up man. 
Sorry to have not already known about JSFiddle, I see how it makes this a lot easier for people to help me out. Edit: to all the people who fucked with it, you are mean*. 
Thank you! will be trying this out. 
actually we should encourage the publishing of more libraries and appreciate that there is a space for all of them to freely exist, lest we start discouraging development like Apple has started: &gt; If your app looks like it was cobbled together in a few days, or you're trying to get your first practice app into the store to impress your friends, please brace yourself for rejection. We have lots of serious developers who don't want their quality apps to be surrounded by amateur hour. this is right out of their [new guidelines](https://developer.apple.com/app-store/review/guidelines/) and I'd rather the web *not* look like that
... using javascript
As an IBMer who recently quit, don't use Bluemix. Uptime is horrendous, you'll get almost no support, any static files on your site will have a significantly large TTFB (time to first byte, when being sent to a client). It's not a mature or stable platform yet. Maybe someday it'll be better. Go Heroku.
just a quick question that I assume I know the answer to, but havent heard it officially via any means, when async really lands, will you just wrap await calls within a try/catch in order to be able to catch promises that reject? (im assuming yes, but would like clarification, if you can answer)
I'd wrap with a try/catch in all the same places that I otherwise use a `.catch` on a regular promise. If you `await` a promise that rejects without wrapping it, the returned promise of the async function just rejects with the same value. Depending on the function, I'd consider that acceptable behavior in some cases. As long as it gets handled at some point to tell the user that their request failed, I'm happy. Edit to add an example for those who aren't familiar with async/await: function() { asyncFunction().catch(function(e) { ... }); } is equivalent to async function() { try { await asyncFunction(); } catch (e) { ... } } Second edit: I just realized, you weren't asking about best practices, were you. Sorry, I got ahead of myself. Yes, that is how you deal with rejected promises. Also, I believe it's already landed in Node 6, and you don't have to wait at all if you don't mind transpiling with Babel!
For me it's not about how 'clean' it looks, maybe that was a poor choice of words. It's much more about easy it is to test. Functional code focuses on isolating side effects and writing pure functions. The result is code which is easier to test, since all functions are pure there is no mocking or stubbing. I was never fully able to understand TDD until I started focusing on writing pure functions. Now I don't understand how I wrote code before. You could argue that I think it's cleaner because I know JS but I would argue that I would take a well tested mess of code vs unspeced (or poorly tested) OOP code. I just think functional code with it's test suite is easier to understand then OOP code with it's test suite. Arrow functions are indeed just syntactic sugar, It's one of those things though; once you have them, you can't go back.
You're complaining about versions of PHP that are completely dead and irrelevant. You've been able to define an array with [] for a long time now; though that's a silly reason to form an opinion on a language.
this is only the client side, and you should be minifying/uglifying that code any way you don't need to do any of this for server side javascript, and with the tools you're making fun of, you can write server side js and client side js in the exact same seamless way. there is definitely some work involved, but the payoff is worth it it's actually pretty nice to not have 2 languages for server/client, competing module systems, etc
&gt; I have to look up documentation basically every time I need to use a function. You need a better editor then. PHPstorm does that for you. Remembering function names or parameter order hasn't been an actual problem in at least half a decade.
In a Javascript thread this is especially true, so many people just jump straight into a library (usually jQuery) and then struggle since it's hard to understand what's a library issue and what's a language issue. Learning the language first is the best and imo only way to go in any stack.
At a glance, the "then" method can't return the same promise. It must return a new one. For starters, that's something you can investigate.
You really misunderstand. Im def not saying "write every OS in Haskell" the issue was about PHP and other "traditional" languages like Ruby, Python etc. You dont write a OS in any of those too right? The benefit of something more functional and immutable is that such a language will always provide better concurrency and parallelism. You also have 100% guarantees that there will be no state shared. This alone is huge. Im also not saying its a silver bullet. Mutable global state is often "easier" because you can just change it how you like. It can be faster too, specially in high speed stuff, like games. But that "easiness" comes with a cost. 
Wow! All those downvotes. It really shows the quality of this reddit. Seems every time someone mentions this they get downvoted fast.
What is difference then from multiprocessing module python, or python behind load balancer? GIL and similar issues does not effect it on these cases.
While all of that is indeed interesting content, the title of the thread is really misleading. "Building ReactJS from scratch" - makes me think that the video is about to re-implementing the React framework. Is that the bigger goal of the series?
1/ Have you ever met someone who has used both React and Angular who prefers Angular? There's a lot of immigration from Angular -&gt; React , but very little the other direction, that adds up over time. 2/ React decouples the DOM implementation from the framework now allowing for things like React Native to exist. React Native will be absolutely huge for mobile development, introducing more people into the React toolchain. 3/ All the coding bootcamps teach React to students now, so that's more straight React developers coming into the ecosystem. Some combination of these 3 things + others that I'll write later when i get back to my comp. 
think I've got it working, that kind of helped me! Thanks!
Find a way to post to telegram directly from Google scripts
zachrip is right... The element doesn't have to be added to the Dom to add event listeners to it. This code makes no sense.
Perhaps you misunderstood me - I'm not disagreeing with you. What I'm trying to say is that if everything is done right, there shouldn't even be a situation where the language performance becomes an issue. If you failed to pick the right tool for the job, it's almost always your fault unless the business requirements have changed drastically since the start of the development - there's nothing you can really do in that scenario. If you think you picked the right language and STILL are having performance issues that can't be solved by upgrading the hardware, the architecture is probably at fault. Either way, the developer should take the responsibility instead of blaming the tool.
Good stuff! One question though. Why do you want to leave the semicolons out? Even telling Will to remove them. I'm curious since this video is the first time I've heard someone advocate for the removal of semicolons. 
Looking at job adverts here, Angular seems favoured exclusively by large enterprise corporations. Your results may vary so maybe have a look at job listings.
Hmm, doesn't spreading also make copies instead of pointing references to the original properties? I'd love for this new implementation to be smart enough to point references too :D Maybe one day....
Check out https://scalingo.com/ first small container is free for a month. It scale in a second and you pay only for what you scaled (just unscale or set to 0). Pricing is affordable and performances awesome (migred from Heroku to this for one big data project).
When I actually read the article, it doesn't give a whole lot of legal benefits beyond taxation---which is what I already mentioned. They do give a lot of 'benefits' that are present even if you're an unmarried couple, or really good buddies with someone like: Housing: You can live with someone who will cover the rent &amp; get a house rather than an apartment. Health &amp; General: You somehow spend less on frivilous things and someone is around to remind you to eat healthy so you do, and don't need as much health care. Oh my! The real benefits as given by the government are: 1. Taxes: You pay less taxes per year filing jointly because you are in a lower bracket (if in fact you just so happen to be straddling the edge of a bracket for this to matter). I am married. I'd pay $0 less without my wife. We'd both take the standard deduction and be in the same tax bracket. 2. Social Security: You get benefits from your dead spouse. Unfortunately you have to wait for them to be dead for you to get this. 3. IRA. Your spouse can put money in an IRA to support you while you aren't working because legally speaking you supporting them by doing housework, etc. So... I guess in conclusion what you get for being married that you can replicate while "single" is tax benefits + retirement benefits. That's it.
;MASTERRACE
when do we expect full compatibility? Perhaps this will never happen as old versions of browsers are going to be around for a long time, but when do we expect ES6 to be written by 'everyone'?
Watch this https://www.youtube.com/watch?v=Qlr-FGbhKaI
&gt;[**Semicolons cannot save you! - FunFunFunction #9 [9:24]**](http://youtu.be/Qlr-FGbhKaI) &gt;&gt;By all means, use semicolons for consistency, or just because your team likes it that way because it’s more C-like, or frankly just because you like how it looks. But don’t buy into the religion that it absolves you from thinking about automatic semicolon insertion. The ASI is always there, and and you need to be always vigilant about it, no matter if you add semicolons or not. &gt; [*^funfunfunction*](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q) ^in ^Science ^&amp; ^Technology &gt;*^13,207 ^views ^since ^Dec ^2015* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
Maybe, because it's off topic.
Neither userID nor avatarID should ever change or be re-used regardless of what database system you use.
Thanks! Both for that specific video and the YouTube-channel ;)
meh, implementing stuff like that all the time can be a pain, use something like cloudpipes to setup workflows to whatever. not tried telegram yet but it's fine. https://docs.cloudpipes.com/channels/telegram.html
I've used both and prefer angular2
Awesome channel
Imho I understand the reasoning but I think it's stupid for browsers to make arbitrary changes to the spec. What's next ? If you don't have your assets on a cdn and you want to load a known library (eg jQuery) on a gprs connection the browser will stop loading that?) (extreme example I know...)
"NodeJS is great when it comes to dealing with Front-End stuff" -&gt; How does NodeJS relate to Front-End stuff?
You're joking...? 1. Zachrip didn't say that. 2. Yes the element does have to exist in the dom in order to add a listener to it. You get an error if you simply try to add a listener to an element that doesn't exist. ...What are you even talking about? 3. Yes it does make sense.
Spec? It seems this is mentioned in the DOM Level 1 spec and then dropped. It is time for this to be killed and for the web to move on. Support for absolutely everything else from the earliest standards that didn't make into the next version is considered deprecated. Its time this dies and all associated incompetence.
This is awesome! I've been coding in vanilla JS for 5 years and thanks to this now I finally understand what React is doing! Thank yooouuu!
What a misleading title though! Building React from scratch, part 1. I thought, it was going to be something similar to Paul O'Shannessy’s talk at React Rally, who was actually demonstrating how to build something sorta like React.
But it's not being removed in ALL cases. They're only not executing JS inserted via `document.write()` if 5 very specific circumstances are met.
If your code sets the etags correctly, the browser will ask your server for the profile pic, and send the etag in its cache. Then if they match the current version, the server will return a 304, saying it's the same. If it's not the same, it returns the new pic, with the updated etag. Etag doesn't have to be a checksum. It just has to be consistent for the same version, and different if there's a change. It could just be the revision of the pic. Or the last changed time. Checksum is easy though, so that's the usual method. 
Mate, even though I love your enthusiasm for React.js, I do need to add a bit of perspective. I work as a full-time Senior Front End developer and have over 18 years experience. I have accumulated over 500 connections on Linkedin, with a large number of them being recruiters specializing in the "front-end space" -- which means that I get the privilege of being bombarded by "job opportunities". As a bit of an exercise, I skimmed through my Linkedin inbox (so that's not including phone calls or direct email) and out of all the job specs since June of this year. I counted 12 Angular jobs vs 2 React, with one being marketed as an opportunity for someone to learn React on the job. Now I'm not saying that there aren't other React jobs out there or implying that React sucks. (On the contrary I love React. Love it so much that I'm now using Vue.js . haha) What I'm saying is that from what I'm seeing/hearing, Angular is still the top pick for large scale projects and if someone asked me whether they should learn with Angular or React. I'd advise them to start with Angular 1.x, then to learn how to migrate to Angular 2.0 and to try to get as much experience as quickly as possible so that they can start in the industry. Both React and Angular have their places. Neither is going anywhere anytime soon. I just wish they'd finally release Angular 2 so that it can get wider adoption. **A little piece of my front-end self died a little when I saw that you weren't using semi-colons.** [Google Trends - angular vs react](https://www.google.com.au/trends/explore?q=angular,react)
That's what I'm saying, remove it in ALL or in NONE. What's this IE6 all over again ? If the moon aligns well, then the magic of document.write works. We're programmers, I don't want 5 specific circumstances in chrome, 4 in safari, 10 in firefox, 3.14 in Edge. I'd love to start seeing bug reports from customers and in order to debug that on mobile I have to check for those 5 specific settings 
Employee.
People like to load polyfills using that too. Not that I agree with the approach, it's just convenient.
I would be gravely concerned if I still saw php 5.3 in the wild. Are they also running that on Ubuntu 10? There's no reason a company can't factor in language updates to their 10+ year plan. So what, they're going to be using 5.3 until 2019?
Doesn't work in Firefox 45.2.
Ah okay. Thank you for sharing this inside knowledge then
I did not even see the missing ). I fixed that and retested it, but it still doesn't actually redirect the page. https://jsfiddle.net/rbeason/vcq0pe4p/5/ I just ran it again and now JSFiddle gives me the error: Forbidden (403) CSRF verification failed. Request aborted. Does that mean it actually is working? Nope it does not, just tested on my local server as well, nothing. Just clears the form when I click on the submit button.
You can't wrap condition checks like you have in your second statement. The correct way would be if (computerChoice &gt; .33 &amp;&amp; computerChoice &lt;= .66). Also, your last else statement has a condition to it but no "if".
Change that trend comparison to just the US though and it tells a different story.
Hi... I'm just a lonely dev, keeping fossils alive. Ubuntu... lol... I would love to use Ubuntu. But we on CentOS... 6(who wants to learn systemd to go to 7?!?!). Also, I am concerned, and I raised it multiple times. But the admins feel it is easier to keep old systems firewalled and running. Then trying to get old software running on new systems. I believe these systems will use 5.3, until cobol dies.
Thank you! That was the part I thought was causing my problems, but I had no idea how to fix it.
* `(new window.DOMParser()).parseFromString(myString, "application/xml"); //standard solution` * `new window.ActiveXObject("Microsoft.XMLDOM") //IE8`
You must be in one of those places that still uses a Java applet on IE6 for intranet applications.
If we're playing that game. Why not look at India? [Google Trends](https://www.google.com.au/trends/explore?geo=IN&amp;q=angular,react)
Do you have the code up somewhere?
What do you mean by never reused? It makes sense to have a createdBy pointer for docs that points to the userid
I just watched this guy's 2 part series on Ethereum and it was one of the most informative videos that's out there currently. Good stuff!
It also includes an gallery-creation functionality powered by [Photoswipe](http://photoswipe.com/).
Thanks! did not remember about `DOMParser`. I guess I had some issues with this API in the past.
Should've released this on 9/09 and upstaged Roland's ho-hum offerings.
Only if it was free
He's procreating now, we must put a stop this.
Really depends on the design pattern. JS's single-threaded, single-user nature means you'll never encounter a real need for a lot of patterns out there, and if perchance you do it's likely you shouldn't be writing that solution in JS. 
&gt; Fix your app. Not your language. I get where you're going with your comments, but this line alone betrays your point. As if once you had the app already built you could just tweak it to perform correctly.
So why would you *need* PHP? There's C#, Java, RoR... 
They are somewhat special though. For most people a callback is the first real exposure to passing around a function as a reference. That that functionality exists is strange to new developers, or to developers that don't work on applications where you would need them. At that I think it's kind of a disservice that we call this - and everything else - a callback; there are distinctly different types of callbacks. For example, we have filter predicates ("callback" that returns boolean for comparisons), processors ("callback" you pass to map() that returns a processed value - not sure if there's a colloquial name for that callback other than 'callback'), action delegates ("callback" executed under specific conditions), and arguably there's a difference in an action you pass into something like each(), versus an action used as an async callback - which itself has a number of special considerations.
Why would you *need* C#, Java, RoR... ? What do they bring to the table that PHP doesn't?
No, it was born to do exactly the same as any other back-end languages: connect database, serve HTTP requests, building API and logic and calculation. I don't really see a reason why it's poor for server side development. Doing stuffs related to front-end assets is another bonus, not its main purpose. People do that because the community is huge. So, you are comparing one aspect of Node JS to PHP
&gt; a callback is basically a function passed to another function. Is this correct? Yes, but not all functions you pass around are something you'd call a "callback". E.g. an easing function is called multiple times while the animation runs. It's not something which is called (back) when some computation is done. As a (somewhat backwards) rule of thumb: If you'd better do that kind of thing with a promise, it's a callback.
I would not use this. It's so unreadable, especially when there are multiple calls to .end(). Just use another variable; it won't kill you.
Not so sure about RoR, but for the others - OOP? Native multithreading? Enterprise features? 
But you can, we do, it's a normal part of development, metrics and iteration
PHP has OOP. Javascript is technically a single thread language, and PHP can be utilized as multithread in roughly the same way. Also, while Java is considered a multi-threaded language, it's not 100% multithread, because there are instances where it fails to utilize it. Also I don't really see any enterprise features that are better suited in any language. Look, I'm not saying PHP is the end-all be-all; I just don't ever see why it's oh-so-imperative to remove it. I mean, if there's bad code (which there are some bad PHP coders), then by all means, but if the code is sound, then what's the point?
Mostly by developers who assume js is a shit language and the front end doesn't deserve as much thought or planning the back end.... Front end code can be very nice and we'll structured. JS itself is a very powerful expressive language that can follow functional or classical paradigms.
true. but if you do this type of stuff often and need to research and support different APIs and code/maintain them, the development costs can vastly outweigh subscription costs. 
https://youtu.be/nI0cQ-2YR1I?t=1h6m19s So you don't have to go searching for it, here is that talk.
I sometimes print stuff on a page with document write for better readability over the console. Not in any code though, just when testing shit on the console
I was thinking that I would learn Node and then I could do JS on the front end and JS on the back end. Then I was thinking for that to be a 50/50 split I had to move to SPA's heavily. I thought this would be a brilliant idea because I could have the client and the server be in the same code base and all of my tests for both the front and back could run all of the time. However, I found that Angular on the front end and Node on the back end works, but it works better when they are separate projects. Node uses NPM and CommonJS and Angular is happiest with Bower and AMD(?). The issue really only rears its' head when unit testing, as far as I can tell. But, I refuse to write non-trivial code that I cannot unit test. As an aside, my experience seems to suggest many SPA projects are not using unit tests or E2E tests. I guess they are manually click-testing. Anyways, so then I was thinking that I could separate out the client and the server into different projects and work on them separately. Testing works fine that way and the world is a happy place. Then I started thinking, if I eschew the whole SPA mentally and use good-ol progressive enhancement, then I could keep everything on the back-end and in one code base. Besides, SPA's suck on my iPhone-5. There just have to be boatloads of even crappier androids out in the wild where the experience is even worse. But then I was thinking, if I do that then I am not really using JS a ton on the front-end at that point, just basic jQuery progressive enhancement, so why use Node at all when it has a harder mental model and is not faster than PHP7-FPM once you add a database and all of the boilerplate that is part of any non-trivial project. Plus, PHP has a super simple mental model which lets me focus on the business problem. I have to admit, even though it seems like I am anti-JS or anti-node, I feel a very strong pull to JS. The async nature of it just feels really "right" to me. 
Why I've never seen "Build Angular 2 from scratch" kind of video?.. /sarcasm
hm. how about **factory, module, singleton, prototype, mixin, decorator patterns**? I use them almost every week in JS. What patterns are more necessary when we go multi-threaded model?
Enjoy the fish.
The latest spec is DOM Level 4 https://www.w3.org/TR/dom/ and document.write is not in there. As I mentioned somewhere in this thread document.write is defined in DOM Level 1 and then forgotten because its a really bad approach. &gt; It's there to support dynamic HTML document creation. That is what the DOM is for, not specifically document.write. There is not a good reason to use document.write above other recommended approaches.
Sorry, I worded my reply poorly. I meant - there's a lot of patterns you wouldn't need in JS. Not that you wouldn't need patterns in JS. Multithreading introduces need for synchronization/locking/concurrency patterns, for example. It's interesting that you point out Singleton; a singleton is a whole different beast of a pattern in a multithreaded environment, as multiple threads compete for access to it. Even aside from that, though, I still wouldn't say JS is the best language for design patterns; plenty just don't really apply to it. Browse through Fowler's Enterprise patterns and you can find a number that you wouldn't use at all in javascript due to it's prototypal inheritance rather than classical inheritance. There's certainly plenty there that JS could use, yes, but some that it just doesn't need or it has better ways of accomplishing it. On the same token, some languages don't need JS patterns because they are natively offered by the language, like how module isn't really a necessary pattern in, say, C#, because of the native features in the language.
I enjoyed a lot of the video, but just some nitpicking: angular isn't "dead man walking". Even though the release cycle and deprecations have been super weird, there's a huge community. (And it's definitely my personal favourite over react). Just have a look at the google trends thing: https://g.co/trends/BMP9Z
Dude on the right is very much a dude bro. 
You do not need to use an OOP constructor, it's better just use a static factory method. _.query('construct').chained('chain a').chained('chain b'); // query is the factory method The above is generally favor because a few reasons * It is named * Easier to refactor/rename in the future for backwards compatibility * Better compromise between OOP and FP syntax, so readily usable in both style of codebases Even in Java, there has been a favor towards factory method over constructor, because the first two reasons.
[It's][1] [fine.][2] [Really!][3] [1]: http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding [2]: http://inimino.org/~inimino/blog/javascript_semicolons [3]: https://www.youtube.com/watch?v=gsfbh17Ax9I
in addition to what others have suggested, you should look into using a text editor if you're not already. most themes in sublime would've probably caught the missing `)` (by highly differently, showing that you missed something). The bracket highlighter plugin is also a lifesaver. A linter would have caught the issue of `getElementById` not being defined You should learn this stuff, but it's nice to let your tools help you catch the little things when you can
I've read the articles and that video you linked and those few little instances are the exact reason to enforce the semicolons. I don't want to have to remember where I do need to use them, and don't want to live in fear that our juniors make a mistake remembering these rules, so no thinking necessary, always use semis. Also, it gets confusing when mixing different languages. Don't get me wrong I think a PSR like codestyle for JS would be great, but not with these rules unfortunately. 
well you *can* write `React.createElement('div')` if you want, but that gets tedious fast. You're not the only one with that hangup, but everyone gets passed it very quickly once you realize how fluent and powerful it is. As an example, getting a snippet of markup via function is a beautiful thing. let FancyTitle = message =&gt; &lt;h1 className="fancy"&gt;{message}&lt;/h1&gt;
until I fix it. Thanks!
I fail to see how I cannot achieve that* using only CSS. By "that" I mean examples in article.
Not really. I'd say it's one of the most confusing replies. Array.map - so that must be async right? It's better to just understand a callback is a function. Array.map requires a function - because it knows it should transform each element in an array somehow, but it doesn't know how. So you supply a function it executes for each element which returns the transformed result. An async function does something, but it takes time, so you can't depend on "return". So you supply a function it should execute when and if it's complete. Etc. 
I like it! 
&gt; Space after function name function name (arg) { // ... } When and how did that become a thing?
The world is going to end because of that, isn't it?
Did I say that? Actually I just genuinely want to know how that became a thing.
Adding a space after the name feels yucky to me. Will not do.
Yeah, agreed. I almost pointed out those implications in the thread, as well... I think those assumptions are kind of the problem I see with naming everything a callback. Different kinds of "callbacks" imply all sorts of semantic concerns for them, and I think developers assume all callbacks are, say, async, when that's not at all the case.
Thanks, I appreciate the response. 
thanks bro. 🍻
There are a lot of functions out there. What makes this function different from other functions? His explanation was the only one I saw, at the time, that explained it and he explained exactly as you did.
What's so bad about it?
[removed]
Yeah. I guess there's sort of two layers of abstraction here - there's the base abstract concept of a function being able to accept other functions as arguments, without any concept of how they'll be used. I'd call these supplied functions "callbacks" - but not everyone does. I didn't really realise that until now. Then you have the actual concrete patterns where this ability is used in practice - addEventListener, Array.map, setTimeout all take functions as arguments, but how the function is utilised in each is different. But in the end, they'll all taking advantage of the one basic language feature. Was interesting to find out not everything thinks the same thing when they hear "callback".
Spaces for indentation? Fuck that, didn't even read the rest. 
okay, agreed! never touched other `prototype` based lang like `self`. So, I can't really make a comparison of JS Design Patterns within `prototype` based lang world.
It would be useful if you show us what you already have implemented to see if we are interested
God I hate this jerk off. If my name is Bob and I make a style guide it's "Bob's Style Guide". If an international consortium of web developers agrees on a style guide, then *that* is a "Standard Style Guide". But you don't just get to declare yourself the standard.
Personally I would go further than the other proposed changes in this thread. Lots of magic numbers at the moment, and also you're not quite allocating an equal distribution of the three options. How about something like this: var possibleChoices = [ 'rock', 'paper', 'scissors' ]; var computerChoiceIndex = Math.floor(Math.random() * possibleChoices.length); var computerChoice = possibleChoices[computerChoiceIndex]; It's important when writing code to minimise repetition. This applies not just to repeating the same few lines of code, but also to *concepts*. You can ask the question "how many places in my code depend on the possible values for computerChoice?". For the original code, it's a lot - this makes the code hard to change. The code above only has one place that needs to change if the options change, so you could extend it to rock / paper / scissors / lizard / spock by changing just one line.
Well, think about the word "callback" and you can see why just passing a function somewhere can't be the definition.
For a real challenge, try writing js in C++
I'm using the javascriptissexy path and I recommend Beginning Javascript by Paul Wilton, Jeremy McPeak.
That sounds like a nightmare.
What do you mean?
Why not just make an image sprite. It should be faster, both in perception and actual loading, than using inline data via Webpack.
Exactly what i was thinking, where's the Ember/Glimmer love.
Great to see Inferno doing so well in this benchmark! :) On a side-note, there should be more benchmarks that test scenarios where keyed algorithms should be more performant vs non-keyed.
It's just arrays in arrays to any dimension.
Some people still do that, but the standard for awhile has been to use modules with `import` or `require`. Its always been like that for Node.
I wonder how an Elm transpilation would perform? I just started learning Elm, after going from jQuery/Backbone to angular to react to angular 2 and back to react. Not sure how the performance is but would be interested to see.
I was going through your code again and I have one question I cant figure out: In the code: jQuery.getJSON(flickrURL, info, photosSuccess); info is: var info = { tags: response, format: "json" }; Considering the info variable is the data we send to the server along with the request, how does jQuery send a response (as the data it sends along with the request) before it gets the server's response?
Yeah, there's some more barely not viewable. View image in new tab or something.
VanillaJS like a goddamn boss up in here. I think I'll buy a t-shirt.
If I switched my import from React to Inferno , what would happen? Could I make the switch easily?
It probably won't work. The Inferno application model is close but not an exact match to the React model. Most notably, Inferno components are always stateless and the lifecycle handlers are registered differently and have different arguments. The inferno-component companion library might help paper over these differences. My experience is on the 0.7 line exclusively using stateless components. The other main difference is that Inferno does not come with its own event framework and does not perform browser event normalization. How easy/hard the switch is depends on exactly how you're using React. I migrated a ~3k LoC app to check things out and had an easy time (change imports, adjust lifecycle components, change a few keyboard handlers) but Inferno happens to exactly match how I use React.
These are the process steps: The page is loading: * 1. An html page loads. It is not blank, it contains some html (it has some elements avaialble, but not the ones i need), and a long list of javascript functions, that executes different things, in the header. I believe this is where they call the cgi script. * 2. In the body where the html is, at the very end, there is a form element where cgi script will place the rest of the web page into that section of the element. * 3. DOM isn't update...Inspector sees it, but not the console and saving the page reveals nothing. you're absolutely right. I don't know why it's like that but it is. The element can be seen in the inspector but when trying to select the element, it doesn't work. EDIT: I cannot figure out why it does list items all as one even though i numbered them
I know it may not be "cool" anymore, but would Knockout qualify for this list?
Why is React-lite slower than React? 
Why can't you use NPM at work?
This table must present the geometric slowdown differently. There are two things that react-lite does faster... significantly faster, that just averaging them makes react-lite appear faster. But if you weight the averages to account for these two anomolies, react is much faster overall. Notice the 'clear rows' columns. https://cdn.rawgit.com/krausest/js-framework-benchmark/956b068f03ef96a9c08d209ffadb0947cd56edc6/webdriver-java/table.html
Vanilla, domvm, vue2, Inferno1.0 and everyone who has “swap rows”/”remove row”/etc below 40 ms just doesn’t use “track-by” algorithms. Almost all other libraries will see a huge improvements in test cases “replace rows”/”swap rows”/”remove row” just by disabling “track-by” algorithms. There is no point to compare implementation that doesn’t use “track-by” algo with implementations that properly rearrange nodes. And it doesn’t mean that “track-by” algo makes everything slower, it just means that test cases used in this benchmark are all biased toward implementations with disabled “track-by” algo. Vanilla even has this weird implementation for remove row test case https://github.com/krausest/js-framework-benchmark/blob/26367bcbe364ef6a6cde7cf0400009e617805efb/vanillajs/src/Main.js#L235
Not sure why the author commented it out of the overview earlier, the code is still in the repo.
That depends on if you are planning to run the code in a browser or on the server with node.js. There is no chance at all of being able to do that if you're running on the client side. 
That is because test cases that are used in this benchmark is easy to implement in Vanilla. Try to create efficient Vanilla implementation for this benchmark[1] with way much more test cases :) It will be extremely hard to create efficient vanilla implementation and that is why there is only naive "innerHTML" implementation. 1. https://cdn.rawgit.com/localvoid/6715c4b23eadc460112e671b4add3710/raw/907901966dd0473f1026d1ff25e244a022eb5ab1/uibench_results.html
We use it only for multi-line strings (e.g. creating small HTML snippets for tests) or when using variables (${abc}). Otherwise we stick to double quotes.
Uh, that's an arguable "standard". 
I was tying to make a Web interface to controlled a robot so I would need it to be client side.
Why doesn't HTTP fit the bill?
[Cross-posting from r/programming](https://www.reddit.com/r/programming/comments/52dnb4/chrome_is_intervening_against_documentwrite/d7kbtb3?context=3) - iframe manipulation in code playgrounds is a **legitimate** use of document.write - the alternative ways to do so are usually much longer. So, no - the 3 things you mentioned are NOT the only uses of document.write Used properly, document.write is most certainly NOT garbage.
If you're using a transpiler it shouldn't hurt but it's overkill. We lint for them only to avoid string concatenation.
[Some items from a SO question](http://stackoverflow.com/questions/802854/why-is-document-write-considered-a-bad-practice): * [1] document.write (henceforth DW) does not work in XHTML * [2] DW executed after the page has finished loading will overwrite the page, or write a new page, or not work * [3] DW executes where encountered: it cannot inject at a given node point * [4] DW is effectively writing serialised text which is not the way the DOM works conceptually, and is an easy way to create bugs (.innerHTML has the same problem) So manipulating the dom (we're talking about the **parent/main** dom here, not some other dom), document.write is almost always bad for reasons [2], [3], and supposedly [4]. Let's talk about another dom - say, an **iframe**. Certain html, css, js code playgrounds use document.write to write to an iframe dom, and it's because of [2] and [3] that they're good - you get synchronicity from [2] and [3] (you want that in a code playground execution context), effectively mimicking how you'd normally develop without a code playground. So document.write is almost always bad to use for dom manipulation (main/parent), except when it's not (iframe for code playgrounds). There are other cases - but this shows that document.write ISN'T ALWAYS bad. Just horribly abused. 
Only valid answer.
executes netcat via node.js. What you're asking about doesn't exist if you're trying to do it in the browser. I don't think you want to do what you think you want to do. Why not use node.js on the server side that communicates with your robot at a low level--which it can--and then access the functionality the server has in interacting with the robot via the web browser. I guarantee this is what you'll have to do unless you don't use a web browser. Of course you could run the browser and node.js on the same box. http://electron.atom.io/ 
Obviously we use with transpilers , without that none of the features can be used. &gt; don't advocate using it for all strings, that's crazy Why is it crazy, other than its not natural to use it while coding , what other disadvantages it has ?
Thats a good point, we are very used to quote or double quote so its difficult to get the habit of going in opposite direction :) 
Perhaps I wont be chaining at all, as the pipe/flow pattern does make sense: https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba#.5284btkrx i think I find your example somehow more confusing because my methods will be available in the chain as well as static. Then it becomes a questing game which method to take. The constructor is also going to be a catch all and turn its query into an array by default. But then again, perhaps pipe/flow is the way to go, less testing, less objects to write, easier to extend. Thanks for your insights.
The latest beta version of ember is rolling out an entirely new rendering system, glimmer 2. The early benchmarks suggest it is faster than react. Glimmer might be ready by 2.9, but it will likely not be tuned up as much as it could be until 2.10, 2.11. That's my guess.
Abdolutely interesting. But I looked at some elm code and decided that I'm not the person to port the code to elm. I wouldn't come up with a good enough version. If someone has the heart and knowledge for that - just send me a PR.
I made a post awhile back on various coding styles of JavaScript. https://www.reddit.com/r/javascript/comments/4jmp2r/code_styles_of_js/ While that could be used a reference, unfortunately I didn't go into detail on the benefits and drawbacks of each of the styles. Not only that there are actually other styles of coding I didn't listed. For example, data-binding and reactive, but since those require external utilities, I didn't go into them. Generally when choosing a coding style for an application or for a library API, you should consider a lot of things. For example, * What are the benefits and drawbacks of imperative vs functional styles? * Whether to choose inheritance/composition or factory or mixin if you are using OOP? * How to structure inheritance tree? * Whether functions in functional programming should be lazy or eager? * Which arguments to bind first in FP currying? * Whether to return a function or take a function in FP? 
I'll explain. Trivia questions that can be easily answered with the first Stack Overflow or MDN search result are not useful questions to ask when measuring skill/experience. It's not reasonable to expect everyone, even experts, to memorize every API. I think it's more valuable to test for understanding, but I'm not sure how to do that.
I stick with `'` for strings.
You dudes are like the dual representation of both sides of my own personality. 
Are these even frameworks? Take react for example - that's not a framework, just a rendering library.
My problem with backtick is that it's not really convenient to type (Alt gr + 7), ugh.
Are those tests for self-learning or a part of a job application process?
you don't have a dedicated button for ` on your keyboard?
Thanks for the response. I've try to go with option 1 but with no success :/ it's hard to debug because the hover event happen just too fest. Do you mind to share your code, i guess i can help find why its buggy. Thanks for the style hint :) 
You can always make a "build" folder on your machine and build assets in npm there and move the output to your project. But why no npm though? I get the risks, but that's on the dev. Also, the cdn links on JS projects are all fed by npm, one way or the other.
Who is "we"?
Thank you for the response! I'll do a search and see what other people have done to move past this point
Automatic semicolon insertion may lead to subtle bugs. Always use semi-colons ffs. http://stackoverflow.com/questions/12745743/automatic-semicolon-insertion-return-statements
You need to be absolutely sure you don't hit any storage limitations. Browsers differ in what they offer, but 5 mb is common. Obviously, since it's a string store, you'll need to serialize/deserialize everything you put in there, which you'll need to be careful about if you're moving lots of data (could lead to degraded UI perf).
Well a few things. First, localstorage is synchronous. So if you try to store big chunks of data, it will stall the page. Also, Localstorage has a 5mb limit on most devices (it's more on some, but i just remember that 5mb is about the limit you want to use it for). I'd recommend using [localForage](https://mozilla.github.io/localForage/) instead. It's a wrapper around LocalStorage as well as IndexedDB and WebSQL and will automatically choose the best storage backend based on what is available on that device. It's maintained by Mozilla, and has an amazing reputation. In most cases it will use IndexedDB as storage which is async/non-blocking and will prevent the page locking up when storing/loading large chunks of data, and it can scale to store GB of data and more (I used it to store around 9gb of data at one point for a thing, and realistically it can go until the hard drive fills up) 
&gt; iframe manipulation in code playgrounds is a legitimate use of document.write This is effectively covered in my first bullet point.
That definitely is how it went for me, and I don't see Angular 2 luring me back (but then, I don't always make those decisions :). In fact, now that I know I can do FP to some extent in the real world, I'm moving there more and more. RxJS is really gaining ground, and other frameworks are winking at me as well (e.g. Cycle.js, Elm - although they have some other disadvantages compared to React). And that's the point, I think. Many CS graduates encountered FP in college and were enthusiastic about it, but then moved into industry and thus back to OOP, as FP was an academic endavour - the common trope about Haskell. Now that its ideas are gaining ground in industry as well (not just for front-end development - see Scala, Rust, etc.), we will embrace it rather than flock back to the next OOP framework.
Your documentElement would be `&lt;html&gt;`. What were you hoping for? 
&gt; Angular 2 probably only uses classes because its a great way for example to model a component: the component has a state and a serious of private functions that operate on that state, a class is a great way to model that. Well, yes... That's what makes it so OOP-focused. In React and Cycle.js, components don't have state; the application has state, and the component is just rendered in a certain way based on that. &gt; Also dependency injection kind of needs classes, the constructor is an ideal place to inject dependencies, not sure how we could do dependency injection with pure FP. They are the arguments of your functions. And you usually have fewer dependencies, because functions have fewer responsibilities. &gt; its deep integration with RxJs It's not _that_ deep. It sometimes returns a stream that you can either use as input for your template, or convert it to a stateful variable inside your component (as often done in the documentation). I'd recommend you to give Cycle.js a try, and then compare the amount of integration with that of Angular.
Cousin comment, in case you were actually wondering: https://www.reddit.com/r/javascript/comments/52gfym/js_web_frameworks_benchmark_round_4_inferno/d7kostg &gt;I decided not to publish the Ember results anymore. I'm afraid the bad performance isn't just ember alone but also due to some bad decisions I made. Since the code is very different from the other approaches this isn't easy to tell. Especially for the fastest frameworks I had some very high quality contributions where my ember knowledge can't keep with. If you want just send me a PR and it'll be included again. And yes I'd love to see the glimmer 2 alpha/beta results too.
Nobody tell him that manual transmissions are called "standard" in some parts of the world. Or that the "US Units" are often called "standard". Or that the word standard can mean other things, like how this guide lets you follow some basic "standards" to prevent bugs in your code and to make it more readable.
&gt; Vanilla JS performs like crazy FTFY.
I'd recommend trying it at least once. It felt wrong at first (and i'm actually the one in my team that fought it until the end!), but now I can't go back. That being said, if you really, truely, absolutely can't stand to not type `;` all the time when it's not necessary, then you can use [SemiStandard](https://github.com/Flet/semistandard) which is the same as Standard, but with semicolons. Edit: I will say that using something like Standard, SermiStandard, Happiness, or another "no changes allowed" style system was a big plus for us. We had a lot of internal arguing over things like Spaces vs Tabs, where the open brace should go, should we use `"` or `'` for strings, etc... Standard solved it in a way that I didn't think was possible. It pretty much made everyone angry at some part of it, but it turns out that code style really doesn't matter to your productivity, as long as it stays the same. After a week of bickering if standard was worth it, we all just moved on.
&gt; There is no point to compare implementation that doesn’t use “track-by” algo with implementations that properly rearrange nodes Wait, this bench is not apples to apples? What's the point of it then?
&gt; The problem goes away in 6.4. I think you answered your own question? Sounds like a bug in 6.3.1. I'm curious though, do you get different results if you omit the `console.log()` in the first example? I don't believe it's required.
I heartily second localForage. I started using it as a cross-browser alternative to WebSQL, and after getting used to Mobile Safari's SQLite implementation I was blown away by its ridiculous simplicity. I've been using it for at least two years for every project that requires a local store. Completely painless. Promise-based. It won't store custom types, but otherwise it stores almost anything you can throw at it. If you need something more than just key-value, it won't help, but otherwise it is near perfect for persisting local state across sessions. For mobile applications, I usually delay writes for a second or two, basically to debounce write requests. I've never had a case of db corruption, but I'd prefer not to thrash the db if I don't have to. It is a pity that moving a synchronous app to use promises is such a pain. If it were me, I'd probably do a refactor.
I got help, but it was not very helpful because I don't know how jQuery works and how to configure it on my system.
Your example use cases sound like exactly what LocalStorage is designed to solve for. 
Basically it removes the refresh of your web application, once the loading happens in the background. Youtube, Instagram, Facebook... they use a similar solution to not refresh the application. Did you get it? :)
Looks like the second rule doesn't agree with you http://standardjs.com/rules.html &gt; Use single quotes for strings except to avoid escaping. 
Assuming you're writing in azerty, {[]} are all Alt gr + something (infuriating).
That seems to be a bit out of date. looking at issue [#421](https://github.com/feross/standard/issues/421) they allowed backticks all the time currently. Not sure if that will stay permanent, but i'd assume so as feross tends to be more lenient toward newer features.
Another option for IndexDB would be https://github.com/jakearchibald/indexeddb-promised
because 25 is so hard to type
&gt;What's the point of it then? Before this benchmark I had no idea that in some situations it will be faster to remove row the way it will be done in non-keyed mode by updating all nodes and removing the last one, so it doesn't trigger long-running recalculate style. At least I've learned something from this benchmark :)
Thanks but I still don't know how to execute case 0 from the second switch because I can't seem to get the text "kaas" in my browser..
&gt; “track-by” algorithms What are "track-by" algorithms?
I'm assuming it's a more modern implementation of Balupton's history.js. In that case, it would be really nice to see a lot of before/after examples showcasing the benefits. 
these are the memes we deserve 
https://www.youtube.com/watch?v=cmGr0RszHc8
That is what the debugger keyword is for. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger
Oh, come on. The guy who came up with this name knew exactly what he was doing. "One JavaScript Style Guide to Rule Them All", it says right at the top of the readme. And conveniently, he's the guy in charge. It seems to have gained some traction, so I guess it worked out for him.
Hi /u/Gialfen, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `onsen.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [onsen.io](/search?q=%28and+site%3A%27onsen.io%27+author%3A%27Gialfen%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|9|75%
Well, the idea was to make a "standard" that wasn't up for modification by the person using it. To perhaps eventually get some consistent code across more than one project. To stop the bikeshedding about if you should use X vs Y, or how to style this or that. And I personally think it's doing a pretty good job. Now you can get your panties in a bunch and complain about how it's wrong that he's "misleading people" or something, but I just can't believe that anyone out there thinks that this is an "ECMA standard" (especially because the only mention of ECMA is in the FAQ header called "But this isn't a real web standard!"). It's not like the author gets anything by getting people to use his style guide. It's not like you need to pay him $20 every time you use it, it's a FOSS style guide and associated tools, linters, formatters, and plugins. You can write it off because of a cheeky name if you want, but it's improved consistency in our code, stopped bikeshedding, and enough of some pretty big projects have started using it that i'm pretty sure aren't being "swindled" that i'm happy to use it (some of those projects include `karma`, `fs-extra`, `yargs`, `npm`, `nyc`, and - in a bit of an ironic twist - `semistandard`)
if (i != l) { n.push(l); i= l; if (n.length === t) break; }
The onclick method is a type of **event handler**. Here are examples of event handlers in JavaScript and how to use them. http://www.w3schools.com/js/js_htmldom_events.asp
This is wrong. The `if(n.length === t)` check is performed regardless of the outcome of the `if(i != l)` check. &gt; if(2 !== 3 &amp;&amp; false, 4 === 4) console.log('runs') runs &lt; undefined Remember your operator precedence. 
I made an RPG that made very extensive use of localStorage. I saved up to 16 characters worth of data including their entire inventory, character stats, bank and their equipment. I was storing giant JSON objects with 90+ attributes on each item, so it was a lot of memory. Even so I didn't hit the 5 meg limit. Unless you're storing crazy stuff like images as strings, you probably won't hit the limit. It worked very well and it was lightning fast. I never noticed any client-side lag due to loading data from localStorage. Even if you hit the 5 meg limit, the browser will prompt the user to expand the amount of disk space.
This is a great interview, thank you for sharing. Really helped me understand explicitly the difference between angular' approach and react.
Thank you!
TIL. Makes more sense to use localforage then.
Yeah, I have nothing against the project itself. I use a similar one. But he does get something out of this - he now has a lot of users of his open source project. That's not easy to do. And he got there by presenting it as something it wasn't. On top of that, he plays innocent. So some people are going to find that behaviour irritating, and maybe post saying so whenever they see the project mentioned. And that might make them write off his project and pick an alternative. Anyway, it worked, so good for him. He gained a lot more than he lost. Haters gonna hate and all that.
Looking at the code between inferno and vanilla, I'd take the 7% slow down to have to deal with that.
This was a massive help. Thank you 
After posting the above comment, I took a close look at JS-monads-stable. It was an embarrassing mess. All of my attention had been going towards testing new ideas and finding cleaner ways to make things work. I cleaned it up quite a bit and added MonadMaybe. If anyone looked at the online demo or Github repository, I hope they will look again. By the end of today, I will have cleaned up the ramling portion that comes after Monad Maybe. Online: http://schalk.net:3055 Repo: https://github.com/dschalk/JS-monads-stable 
Sure. I'll add it if you send me a PR :-)
Yes, using (reading or writing) localStorage while a user scrolls will cause jank. If you have all the objects in memory, why would you bother dumping to localStorage? What is it you think your getting by sticking with localStorage?
Do beware: [IndexedDB still janks](https://www.youtube.com/watch?v=loahuEoWPy4#t=12m34s) even though it's async! If you really want to be paranoid, preserve all performance at all costs, IndexedDB from inside a WebWorker communicating with the page seems to be the available option. Thanks Nolan for the video demo!
I just find people who want stuff done; like family and knock up solutions to suit that. I whack it all on a cheap Azure tier so I can manage it in one place. If i need a solution to a problem I need solving, like a grid or a service library I just put it in GitHub and on NPM to open source it. Anything i can open source I do :) Keeps the learning hunger alive! 
Way I'm going to try to salvage this is by mixing the two. Page loads, LocalStorage values are read into an object array. Each object has a flag of "updateFlag" which is set to false. The functions for updating a value, update the value and changes that flag to true. On unload, the object array is read and any objects with the updateFlag are updated. But goddamn, my code is so full of hacks now. 
You would have to send the commands to a server (via HTTP) which would then forward the commands to the robot
I'm just saying the .lang property isn't there. It doesn't appear to be the same object. 
The name was made a joke and the author didn't expect it to be popular to the point people will get angry.
No idea what you're talking about. If it were the same thing, it should be there. Perhaps you're not looking at the full conversation here? const doc = document.implementation.createHTMLDocument(); doc.write("&lt;html&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt;"); doc.close(); Here doc.documentElement.lang exists. The same html was provided in both cases. Your example simply doesn't have the .lang property so it isn't producing the same results.
Note that you cannot use them with import statements for obvious reasons.
Oh this must be a desktop thing, not a mobile phone thing. We've had heaps of trouble with quotas on mobile phones, and not being able to get them past 10% (or 12% or something) of free space. To the point where we are considering forking Chromium and removing the quota hooks and shipping that (or app is not of interest to random internet people so we can get away with stuff like shipping our own version of Chromium).
It's rare, but some corporate IT departments disable localStorage/sessionStorage for their users. Not sure if you're concerned with those users, but using one of the wrapper libs mentioned by other posters should handle falling back to cookies though, so no worries there. I did also run into a case once in IE11 where *any* reference to `localStorage` would throw an error "More data is available". Never did figure that one out. Even try/catch didn't catch the error. The error text seemed to point to a Windows kernel subsystem. Pretty freaky that it would surface in a JavaScript API. It eventually resolved itself for that user, probably from an update.
Ahhhh, yeah that is sloppy pre DOM level 2 HTML silliness you are relying upon. So, yes, you were hoping the parser would just guess at what you wanted. Back in the day... like the 90s, during the browser wars, browsers needed to make things as simple as possible for people who had never written code before. So, the browser attempt to read your mind and guess at what you want for legacy HTML. The browsers stopped support this nonsense years ago and keep most of the sloppiness in there purely for backwards compatibility. Technically there is a published DOM level 0 document written, but it is little more than technical notes and certainly not a standards spec. Both it and DOM level 1 are largely considered ancient and dead. The actual DOM specs that modern technology use are DOM levels 2, 3, and 4. By modern I mean everything after 2001 (15 years ago). The big change with DOM level 2 is that it specifies an API and a model where DOM level 1 only specified an interface. That is a big fucking difference. With DOM level 2 you can walk between nodes in a relational way and arbitrarily extend the document from within. You couldn't do anything like that with DOM level 1. Another ground-shaking difference is that there is only 1 DOM level 2 specification. There are two DOM level 1 specs, a core spec and a separate extension to supply HTML specific assumptions and stupidity. With DOM level 2 there is absolutely no difference between HTML and XML. You access both in an identical way and they interface to the documents in identical ways and output identical things. You certainly don't get that with DOM level 1, as your example shows.
Is this satire?
&gt; This is effectively covered in my first bullet point. If I'm not mistaken, your first bullet point is "advertising/analytics/spyware". How is an HTML, CSS, JS code playground under that? Not all code playgrounds do advertising, or analytics, and/or spyware. ?
"cheap" "Azure" ... k
at the end of the day *everything* is about rendering content, so it's good to know what the relative trade-offs are in that arena.
It will, just hold out for the inevitable heat death of the universe.
He's also a superstar developer who happens to be a really nice guy. There's nothing wrong with making something you know is gonna raise some eyebrows, it's just a package after all. We all need to be more light hearted like Feross!
On top of the fact that this isn't really encryption; if someone has access to this data and recognizes that it's just base64 (like, how it says in the "encrypted" string that it's base64) then they just need to use some tool, like SphinxJS, to transform it. I don't really see the point in this at all. It's a fun experiment, but that's about it.
JAVA SCRIPT
Good point. Using these tools has made me realise coding style is just a collection of comfortable habits (well, more often than not), and whether I use tabs or spaces, or semicolons or not, just doesn't really matter. So the next step to enlightenment is to stop finding the name of this mildly irritating every time I see it. Hopefully one day I find it in my heart to forgive him.
&gt;Well, the idea was to make a "standard" that wasn't up for modification by the person using it. Words in English (well, in any language) have meanings. Standard doesn't mean "something that's not up for modification made up by one person." It means (according to Miriam-Webster at least) "something established by authority, custom, or general consent as a model or example". The author was not an authority, and there was no established custom or general consent to use his personal style. So it's simple: he deliberately mis-used English get popularity for his project.
&gt; It is going to be command line based &gt; it will just run command-line commands &gt; allows a way to define task dependencies/orders &gt; allow modification of tasks at "runtime" &gt; be simple to use on a simple level, but powerful enough to handle a very complicated project So...[GNU Make](https://en.wikipedia.org/wiki/Make_\(software\))? Like Im all for doing this as a learning experiment, in which case hack away, but Make has existed a very long time (coming up on 40 years) and does pretty much everything here. It also has the benefit of being mostly declarative in nature and doesn't rely on the NodeJS runtime as it's compiled into a binary executable.
It doesn't swallow them without reason - this allows you to chain an error handler to the promise with `.catch()`
Hello Kenman, Is it Saturday yet?
Why do people make these kind of blogspam sites? Clunky generic Wordpress or Drupal site, poorly written articles on basic language features, nonsensical framework comparisons written by someone who clearly doesn't have even a basic grasp of what they're talking about. Do they make money from them somehow? Some SEO trick? That's my interview question.
[Kind of funny that you took the time to look up the definition of the word 'standard' on merriam-webster and just so happened to look over the first 2 definitions.](http://www.merriam-webster.com/dictionary/standard) I'll put them here: * a level of quality, achievement, etc., that is considered acceptable or desirable * something that is very good and that is used to make judgments about the quality of other things By those definitions, "Standard JS" is definitely a standard. It brings a level of quality to the code that makes it desirable. But even if we decide to use your definition (which was weirdly 4th in the list...), I'd argue that "Standard" fits because the person installing it is acting as the authority. The "user" is standardizing on standard. Just because it's not your standard doesn't mean it's not a standard. Either way, i'd prefer to go with the 3rd definition: * a conspicuous object (as a banner) formerly carried at the top of a pole and used to mark a rallying point especially in battle or to serve as an emblem It's a flag!
You could use Node JS on a server to access the Yelp API to get the review. But here's the clever part, have the email reference an image. That image has the count and the stars, so when you update the image no matter when people open the email, they get the latest numbers.
s/allows/forces/
Or just a breakpoint in the debug tools.. 
you can check this module https://www.npmjs.com/package/url-parse
Those errors should be reported like every other error is, rather than having special treatment for promises. I discovered this because I was writing code running via node, and sometimes execution would just "randomly" halt in the middle.. it wouldn't throw an error, so I had no clue where to look.
nice
Makes sense, didn't end up using that code anyway. Someone was nice enough to help me through it and while they did write some of the parts they explained the code, deleted it, had me rewrite something similar. So yeah, thank you to the people that have been "teaching me how to fish".
Another way to do it is to use .done() var color = 'grey'; function ckCounty(st,cunty) { // return the jqXHR object return $.ajax({ url: 'whateverScript.file?state='+st+'&amp;county='+cunty, }); } var ckCountyXHR = ckCounty('ga','TAYLOR'); ckCountXHR.done(function (response) { if (response &gt; 0) { color = 'green'; } console.log(color); }); ckCountyXHR.fail(function (response) { // do something if AJAX call failed }); OR var color = 'grey'; function setColor(st,cunty) { var xhr = $.ajax({ url: 'whateverScript.file?state='+st+'&amp;county='+cunty, }); xhr.done(function (response) { if (response &gt; 0) { color = 'green'; } console.log(color); }); xhr.fail(function (response) { // do something if AJAX call failed }); } setColor('ga','TAYLOR'); 
The memory limit was a huge surprise gotcha when I accidently stored full images from the users camera lol... Whoops.
On an emotional level, I agree with you. I want async error propagation to Just Work with the same ease as exceptions. But the harder question is *how* exactly do we make that happen? The issue is that most of the time we don't know if we're at the end of the chain. Consider: let p = Promise.resolve(42) p = p.then((n) =&gt; { // Maybe there's a problem, maybe not if (Math.random() &lt; 0.5) { throw new RangeError() } }) // Maybe we have more async work to do, maybe not if (Math.random() &lt; 0.5) { p = p.then((n) =&gt; { // ... }) } // Maybe we have a way to handle and recover from a particular kind of error, but maybe not if (Math.random() &lt; 0.5) { p = p.catch((e) =&gt; { if (e instanceof RangeError) { // Make it all better } else { // Don't know how to handle other kinds of errors, so re-throw throw e } }) } What should happen at the first "then"? Should the error kill the process? But we might be able to recover if only we let the error propagate through the chain. On the other hand, what if we let the error propagate and it turns out we have no way to handle it? Then it gets silently swallowed. The first "then" simply doesn't have the information it needs to make the correct decision. I really like the `done()` method from the [Q library](https://github.com/kriskowal/q#the-end). This is how you the programmer tell the system this is the end of the chain. There's nowhere else to propagate to, so if there are any errors we haven't handled and recovered from by now, that's bad, and we should die. In the mean time, the closest we have to `done()` in ES6 is this little snippet: .catch((reason) =&gt; { setTimeout(() =&gt; { throw reason }, 0); }); Of course, even this still relies on programmer discipline (or linters) to make sure we either call `done()` or to return the promise and make it the caller's responsibility.
My [cube clock](http://coup.cu.cc/cubeclock/)
Of course it's not so "useful" as an encryption tool, it just provides a way to do it. Besides, if you want to encrypt a string more safely, you could encrypt a string by hash or someting else at first, than translate the hash code to base64.
Yes, if someone access to the base64 image, he could probably decrypt it by SphinxJS. However, you could use some other encrypt methods between encrypt and decrypt by SphinxJS. Anyway, SphinxJS is not a tool for totally "safe", it just a light tool to encrypt / decrypt a string to / from an image, that's all.
What happened? Did the image corrupt or did the code just go "Nope, not gonna do *that*"?
React is a framework, just like Entity Framework is (obviously) a framework; just because it's not a kitchen-sink framework like Angular or Ember doesn't make it a library. It's just a rendering framework rather than a web application framework. Even if it wasn't a framework, why does someone always have to nitpick about this? You know what they mean, they're comparing rendering speeds which is what all of these frameworks/"libraries" are doing. Just because some of them also include other stuff isn't important.
You can handle all of your errors in one place, instead of handling them as they occur.
Looks like you have an infinite loop here: mouseClicked = function() { if (page === 0) { page1(); page = 1; } else if (page === 1 &amp;&amp; mouseX &gt; 125 &amp;&amp; mouseX &lt; 275 &amp;&amp; mouseY &gt; 270 &amp;&amp; mouseY &lt; 320) { while (looper === true) { &lt;---- where does `looper` become false? page21st(); } page = 2; } }; A quick 'find' reveals that `looper` is only set to `true` and never anywhere else set to `false`. As such, your `while` loop will run forever. 
That's what I need, I'm pretty sure. I'm going to sleep now, so I can respond to anything tomorrow. Thanks!
Wouldn't innerHTML work just as well for an iframe? You can essentially implement document.write with innerHTML.
What you're doing does sound tricky. That proxy configuration to add the CORS header, can be setup on any apache/nginx instance. I was mainly pointing out you can make the ajax work in the browser as expected, without coding anything.
So don't forget a `catch`? Handle your errors? What is the problem here?
Sounds like a pretty good idea, I play a lot of video games but I never thought to consume any API from a game. I'll keep an eye out! Also, cool little RPG game :)
Just subscribed to the podcast! Hadn't heard of it till now. 
Fair warning, [knockout is pretty slow](https://www.codementor.io/reactjs/tutorial/reactjs-vs-angular-js-performance-comparison-knockout)
I guess you could say both. Since my app relied on localstorage to track state between page loads it essentially froze in time and page refreshes would actually rewind the users progress back to when it originally was filled. here's a better answer tho: http://stackoverflow.com/a/14191200/1443717
Even with a transpiler, the possible disadvantages are: * Harder to type on English keyboards than ' * Can't use ${ construction * Unintentional multi-line can occur when using backlash line continuations * Confuses some into thinking the string will use variable and expression replacement somewhere inside * Must escape backticks * JSON requires " to be valid on strings and keys As for performance, you'd have to test and see. Since it is new to native browser implementations, it is probably slower now. Even when finished, it will likely remain slower than a static string because static strings they never have a dynamic part. They can be added to an internal string index that lasts the lifetime of the program.
&gt; could probably decrypt it by SphinxJS uhhh, he could "decrypt" it by using a 4 letter javascript method: btoa()
It depends on how you consider. As to me, it's encryption.Whatever:)
WaifuBot is an open source bot I'm developing to talk about anime. It would be really cool if you guys could talk to her, helping me training it. :)
Hi /u/yeaBuddyneedsHelp, this post has been removed for 2 reasons: 1. Please use a descriptive title. "Need Some help" doesn't help _us_ at all (help us help you). I would suggest something along the lines of: "Need help sorting an array of objects". 2. We're not going to just do it for you, you need to demonstrate what you've tried already. If you have a lot of code (20+ lines), then please post it on a site like jsfiddle.net or codepen.io. If you don't have much code, then you can include it in your post. Just indent it with 4 spaces so it'll be properly formatted: // example code let arrayOfObjects = [{foo: 1}, {bar: 2}]; Feel free to submit a new post if you can address these problems. Thanks!
[Yes, it's possible.](https://www.reddit.com/r/javascript/search?q=synth&amp;restrict_sr=on&amp;sort=relevance&amp;t=all)
Hi /u/BlackScar47, if you need to post again, please use a descriptive title. Thanks!
Well the frameworks are written in VanillaJS
 votes = [ { user: "57d3008f89b90a0011deee9c", _id: "57d300c289b90a0011deee9e", team: { voteNum: 10, name: "Cloud" } } ]; Step 1: Create an empty object to hold counts (countObj) Step 2: Loop through the votes. Step 3: For each vote, increment the countObj[vote.voteNum] by one. Remember to initialize the countObj[vote.voteNum] to 1 on the first iteration if it's undefined. Step 4: Loop through countObj to find the key with the highest number of voteNums and log the key (hint: use Object.keys(countObj).forEach()). The last part is kind of hand-wavy because I don't know if you just want the voteNum key or if you want the actual objects. You're going to have to give more information about what the output should look like. I have a codepen to show this example, but hopefully you can figure it out on your own.
I think _.countBy(obj, 'voteNum') might do the job
Thank you!
you know it probably is a good idea to use WeakMap instead of Map to store subscriptions...
I didn't really start this as a point of argument. I just wanted to know what was legally mandated. You gave me a pretty good article about that; so I summarized it to confirm the information about what's legally mandated versus everything else. That's pretty much it. If I missed something about lower insurance costs or status being legally mandated, I'd appreciate it if you pointed out to me where it was in the article. I thought I read it pretty well.
First things first: do you want to **sort** (i.e. re-order) or **count** objects? If you want the first, look at [Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort), for the second, look at [Array.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach). For bonus points, if you want to count on voteNum, sort the array on voteNum first, so you only have to iterate over it once to do the counting.
The art style is great! I also entered this year. Best of luck to you!
TIL the comma separator can be used in conditional statements. Been doing JS for 4 years and I'm still learning!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [What are some of your favourite websites to use? \[X-post for science\]](https://np.reddit.com/r/coding/comments/52pn4o/what_are_some_of_your_favourite_websites_to_use/) - [/r/jquery] [What are some of your favourite websites to use? \[X-post for science\]](https://np.reddit.com/r/jquery/comments/52pysq/what_are_some_of_your_favourite_websites_to_use/) - [/r/php] [What are some of your favourite websites to use? \[X-post for science\]](https://np.reddit.com/r/PHP/comments/52q1i1/what_are_some_of_your_favourite_websites_to_use/) - [/r/programmerhumor] [What are some of your favourite websites to use? \[X-post for science\]](https://np.reddit.com/r/ProgrammerHumor/comments/52px24/what_are_some_of_your_favourite_websites_to_use/) - [/r/programming] [What are some of your favourite websites to use? \[X-post for science\]](https://np.reddit.com/r/programming/comments/52ppq8/what_are_some_of_your_favourite_websites_to_use/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
What if you try using `wss` instead of `ws` protocol when you create a new Websocket instance?
They're not killed: unless catch throws again, it returns a resolved promise so that the second catch would be skipped.
This is cool ! Apart from socket.io, what is is technical stack behind the game ?
Wow, another frontend podcast! Thank you!
google.com
Xposted to /r/all
It's not like that though. It's like complaining that errors are not reported in an empty catch, then execution silently stops.
It *is* like that. I suggest you should learn what promises are. the video I link is a good start. Everything works as intended. The analogy with try/catch only goes half the way. Promises - monads in disguise - are a completely different paradigm. Granted, this mix of very different concepts now in Javascript doesn't make the whole system any easier to understand. Promises are really quite the alien in this system. Reminds me of the Windows 8 and 10 GUIs: Some dialogues still are the old Windows 7 and earlier thing, others have been updated to a completely new concept, just look at the two different (old and new) settings windows. Mixing monadic code like promises with "normal" code leads to such results. That's what happens when you pick and choose parts from a different programming world and put it into the Javascript environment. It's a compromise. Feel free not to use it if it confuses you.
This IS for my job, hence the "for science" tag. I'm building a digital product which is gonna target programmers, so I want some insight in my target group in terms of web usage so I can determine patterns in UI.
Ideally, good things should be easy and bad things should be hard. Synchronous exceptions make it easy to do the right thing. All you have to do is exactly nothing and the correct thing will happen. Errors will propagate, and if unhandled, will be reported and kill your program. Asynchronous rejections, on the other hand, make it easy to do the *wrong* thing. They require the programmer to do something with perfect consistency. If we forget a catch, even just once, that's bad and errors can be silently swallowed.
[Adlibris](https://www.adlibris.com/no) a Scandinavian book store that has extremely nice UX, the shopping/checkout process is one of the best I have ever experienced, largely due to the integration with Klarna Checkout, just wonderful..
A fine piece of earthenwarelike article by Terry Coatta et. al. 
&gt; To be clear, the status quo is that they are swallowed and reported via unhandled rejection racking mechanisms (and thus reported in dev tools in browsers and the like). Is that required in the spec? Or is that just how v8 behaves? I didn't see unhandled rejections get reported in the latest Firefox, for example.
Probably breaking because you're losing everything that's tied to script, such as event handlers, references to DOM objects, etc. What you'll probably need to do is run some query on the page to filter for text nodes, and then iterate each text node and do the replace directly on them. Here's [some examples](http://stackoverflow.com/questions/298750/how-do-i-select-text-nodes-with-jquery) of ways you might be able to query for text nodes. This way, all DOM elements remain, you're just changing the contents of them. However, I'm not sure what the best way will be to trigger your functionality, seeing as React will be re-rendering nodes with the source-of-truth data. You might also look into the "Cloud-to-Butt" extension and see how it's implemented.
ty! which one is your entry?
Unfortunately firewalls and proxy servers that don't allow anything except plain HTTP(S) through are a fact of life and you either have to implement a fallback or simply accept that your application won't work in those environments. While websockets can operate over ports 80 and 443 (as per normal HTTP and HTTPS) so can avoid being affected by arrangements that simply block traffic on other ports, some proxies accidentally break the mechanism (see https://en.wikipedia.org/wiki/WebSocket#Proxy_traversal amongst other references) and some may deliberately do so. As you are explicitly using a port other then 80 or 443 you may be hitting a simple port-based block rather than something interfering with the protocol. Most good websocket libraries support fallback options such as long-polling &amp; short-polling via plan HTTP(S)+AJAX, though you usually need to do at least a little configuration work to use this rather than it being entirely automatic.
I meant there are some problems which only a language &amp;/or technology change can solve. Some problems you can't just fix by throwing more script language at a wall. For example... what if I need to get at a file on a user's filesystem? Javascript doesn't currently have a solution.
Yes, but how is this different than forgetting to handle an error in a callback? You're in for a hell of a bad time if you throw in an asynchronous callback chain and expect it to be handled for you. I understand the frustration with the user expeciernce of using an asynchronous language, but this difficulty is not specific to promises or even Javascript -- google `asyncio python exception` and you'll see tons of threads complaining about basically the same thing.
I didn't mean to be dismissive or negative in any way. I find it hard to believe that you feel that way about my comment. I was sincerely surprised that I didn't think of Google and was thankful for that reply.
Aren't there already ways to comment code for type checking? Would this not fragment the code-commenting between codebases? I ask because I actually **like** to do type comments in my code, and would like my IDE to respect those (Webstorm apparently already has facilities to deal with @flow so that's nice), and I'd like to have a single definitive answer to the question, "What system should I use for type comments and documentation?"
Edit: Added type inference to blog post. You're right that that's misleading since I didn't really touch upon type inference. The general idea though is that you can't rely on type inference for everything. I get where you're coming from since even in my haskell example I didn't write out types in the `do-block` after saying statically typed languages need to have types written out.
I'll edit it into where the Haskell example currently is, and tweak it a bit. Thanks for the feedback.
TypeScript 2 has control flow analysis which works similar to flow.
&gt; Aren't there already ways to comment code for type checking? [Closure compiler](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler) does this. Personally I prefer my types to be part of my code, which TypeScript does (but so does Flow, so ¿).
Great, I have even less of a reason to use Facebook's technology. &gt;:)
I would say no, for one very specific reason: It appears one cannot know the return type of your function in advance. If there's one hit it returns an element, but if there are more it returns an array. That's very inconvenient, because you'll always need to test the return type manually to make sure before you do something with the result. Then I'd say this is already more useful (and is pretty much what the Chrome console offers by default): const $ = selector =&gt; document.querySelector(selector); // one result const $$ = selector =&gt; document.querySelectorAll(selector); // multiple results
Personal preference. I like that it isn't a superset of JavaScript, in my experience, gently integrating flow is much easier than gently integrating TS into a project that has neither, and I don't like using TS with React. TS has a bigger ecosystem, but I think eventually the ecosystem of flow will get there as well. 
What do you mean by more widely supported?
I assumed he's talking about the ecosystem, and the fact that flow only very recently got windows support: https://flowtype.org/blog/2016/08/01/Windows-Support.html
[`Map` and `WeakMap`](https://i.ytimg.com/vi/vqgSO8_cRio/hqdefault.jpg).
It only makes sense if you are not using strings as keys, and everyone *but me* is using strings as keys right now, because this is the first emitter that allows to use objects as keys. Said that, the reason why I wrote this event emitter is an app that doesn't need strings as keys, so I'm forking it :) Edited: ~~everyone~~ "everyone but me" [reason](https://www.reddit.com/r/javascript/comments/52n4aw/high_performance_event_emitter_for_modern/d7mier0)
const qsa = document.querySelectorAll.bind(document); You need a closurized tear-off.
Very nice! The UX is clean, well laid out and intuitive, for the most part. The pages and layers interface is very nice. The ability to add multiple filters (I'd call them properties) to an object (like multiple fills and borders) is truly novel. The most obvious features I'd like to see added: Border styles and line endings (dotted/dashed lines, arrows, block/circle endings, etc.). Also, since you support pages, a hyperlink property on objects would be amazing: Click on this circle, go to this page. Also, there are a few quirks/bugs I could report. Other than a chat window, I didn't see a place for feedback. Where would I submit that?
&gt; everyone is using strings as keys right now [Then you don't need to support objects](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it). There's little sense in going half way if you're allowing people to pass objects for a hypothetical use-case. Personally I think it's a nice use-case as it allows the passing of `Symbol`s as keys.
Hey! The chat box is the best place for feedback. We collect and organize everything from there. Re: border styles and line endings - don't worry they're on their way! Perhaps sometime within the next 1-1.5 months they'll ship ;)
Flow I can use as much or as little as I want, and still use babel. I definitely prefer what I get out of babel as opposed to using typescript.
So their big thing is they want to avoid unexpected scripts that are loaded synchronously. How do you even load a script asynchronously. They don't even tell you how to do that. 
I could, but my main problem stems from being stuck with whatever typescript supports. With babel, if there's a plugin that enhances the language in a way I want, I can just add it and use it. With typescript, I have to wait for it to be added to the language.
I'm not talking about javascript plugins, I'm talking about babel plugins that actually add or modify new syntax to the language. I'm pretty sure if I do something that typescript disagrees with syntactically, it'll barf.
Ah I see. That's fair. 
https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script async flag on a script tag?
Yes you can, it's pretty clear too! (err: any, ok: someType) =&gt; void That's a typical callback's type signature.
"An unknown Error has occured. We have been notified and fixing the problem." Doesn't look very stable yet... What I did was create a circle, then drew some paths and subtract those from the circle.
That's nice, but not exactly what I mean. Can you do something like this?.. function takesCB(a: int, b: int, cb: function(x:int)) {cb(a+b)} Ah, I found this: function do_something_async(cb : (x: number) =&gt; void) { cb(37); } Looks like you can. Very cool! Not very well voiced in the docs.
Hi /u/nickbudden, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
&gt; const $; $ = document.querySelectorAll; You can't declare a `const` like that, you must assign it a value or you get a: &gt; Uncaught SyntaxError: Missing initializer in const declaration
No idea how that works. They don't even give examples at mozilla.org for it. It's like one little blurb and that's it. You'd think someone writing this article would give examples of what they want you to do instead of having to hunt it down. Personally, I'm going to keep using document.write because I like it and I'm going to throw up a stink every time I see someone say it's archaic. Fuck that. Provide all the functionality it has or at least document actual workable alternatives. 
Flow is just a type checker. It does what it should and no more: checking types. It already resolves cases TS struggles with or can't resolve. As for ES6, i fail to understand why a typechecker should provide it or even mess with it in the first place. "Basically ES6" isn't good enough when real ES6 and Babel already do things TS can't. 
You're getting downvoted because your comments (to yourself) are getting increasingly pathetic.
You don't need comments :D You just use babel https://www.npmjs.com/package/babel-plugin-transform-flow-strip-types
Yep, translate3d pushes element's bitmap rectangle to the GPU hardware to be processed, the resulting performance is excelent even on mobile hardware.
Are you suggesting that if you don't call .catch on a promise chain that errors inside of the promise should be thrown out of the promise, eg that the following works try { var p = Promise.resolve().then(function () { throw 1; }); } catch ( e ) { /* 1 */ }
Notice that you are all alone with your opinion? There is a reason for that, little self-absorbed narcissist. Here, for you, little child: **Promise-based functions should not throw exceptions** http://www.2ality.com/2016/03/promise-rejections-vs-exceptions.html 
You forgot to tell what exactly in Flow's typechecking is more advanced. Using comments instead of "var a: string" is a disadvantage in my opinion, not an advantage.
That is... not recommended. Don't mix two completely different systems. "Promise-based functions should not throw exceptions": http://www.2ality.com/2016/03/promise-rejections-vs-exceptions.html "You're Missing the Point of Promises": https://gist.github.com/domenic/3889970
Spec doesn't require it but does specify the mechanism. I guess Chrome might be the only browser with good rejection tracking tooling.
https://www.reddit.com/r/javascript/comments/52msni/til_errors_thrown_side_of_then_from_promises_are/d7mcr0j https://gist.github.com/domenic/3889970 ("You're Missing the Point of Promises") https://www.reddit.com/r/javascript/comments/52msni/til_errors_thrown_side_of_then_from_promises_are/d7mpnzk https://www.reddit.com/r/javascript/comments/52msni/til_errors_thrown_side_of_then_from_promises_are/d7mn1kh 
I'm not recommending anything, I'm asking /u/eof what he means by the opposite approach. The code also doesn't work at all, which might lead to an examination followed by an understanding about why promise error handling is fundamentally a different beast than sync exceptions.
You can also use https://github.com/leebyron/flow-remove-types if you want the minimal build system or Flow comments https://flowtype.org/blog/2015/02/20/Flow-Comments.html if you don't want any build system at all. Flow is built to integrate with your existing workflow as much as possible instead of trying to force a totally new build chain that you need to rewrite everything to work with. Why fork the ecosystem
It's a great post I'm glad you went into detail about the need for static typing. I think most posts just assume everyone is on the same page when they might not be
Hold on, React's up to v15 already? Last I looked, it was still in the 0.something's...
"Winning" and not losing face somehow is more important than learning to you. Not being able to learn and in addition not being able to admit a mistake, you are made of great stuff. Even Trump manages to apologize occasionally. https://www.reddit.com/r/javascript/comments/52msni/til_errors_thrown_side_of_then_from_promises_are/d7mcr0j https://gist.github.com/domenic/3889970 ("You're Missing the Point of Promises") https://www.reddit.com/r/javascript/comments/52msni/til_errors_thrown_side_of_then_from_promises_are/d7mpnzk https://www.reddit.com/r/javascript/comments/52msni/til_errors_thrown_side_of_then_from_promises_are/d7mn1kh 
To the environment itself. For example, if you do function foo(){ console.log(unknownthing.property) } foo(); what happens? an error is thrown, it isn't caught, the process is aborted and **the user is informed** that there is an Uncaught ReferenceError
http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive &gt; The semicolon may appear explicitly or may be inserted by automatic semicolon insertion. So entirely depending on your preferences of ASI. 
Yeah I actually fall into that category. I've heard the hype for static types expressed on the internet for so long, but I never understood it until doing Haskell for a few months, and then using flow in my own projects.
&gt; Either you don't want promises to allow registering error handlers asynchronously, or you want the current behavior. The two are mututally incompatible. What I want is a third option, which is for promises to explicitly declare which errors they can register async; and to bubble all others immediately. 
No thanks. Personally, I find all these tools (incl. TypeScript) either getting in the way (you want me to annotate (read clutter) my code, making it look as cumbersome as Java?) or a crutch for people who cannot handle the flexibility that Javascript provides. I sigh with grief whenever I have to go and touch any Java. Nothing but superfluous typing and casting, when most of it is quite obvious and could be implied. I use TypeScript only to make declaration files, to plug into my IDE. Other than that, not useful. It may be useful to consider how human languages work and evolve. For example, there is a reason why English is easier to use than a more rigid language (like French or Finnish) - it's because it's so adaptive and versatile, and has lost a lot of the archaic baggage that still encumbers other languages. Sure, it's impossible to write water-tight grammar for it, but it works just so much better than more archaic languages that have yet to shed their redundant idiosyncrasies (e.g. nouns having gender, a plethora of verb cases - Finnish has 16, Russian even more!, rigid word order, etc.). It may also be worth thinking about how much time you spend on errors related to types. For me, it's, let's see...none.
I personally think ASI is a bad idea but anyway, according to that the semi after 'use strict' is optional, which makes it *not* extra. Digging into my ESLint config now to see what's up. Thanks
&gt; is certainly not alone Yes, of course not, you have steadfastly refused to listen to anything you were told in your thread. I recommend to you to read the many wonderful tips and links that you got. You might learn something.
Thanks for reposting with the source :)
I have listened to it; I am not sure why you think I haven't. I even stated that the reasoning for this behavior became clear to me. For some reason you seem to think The Ways Things Are === The Way Things Ought To Be; without actually acknowledging any of the *tradeoffs* that this decision creates.
Sorry, now I'm worried that *my* comment came across harsher than intended. Was just trying to point out how extensive Google's design documentation is.
&gt; I am not sure why you think I haven't. Because you keep talking in loops? And to the wrong people? ECMAScript is open to public discussions. A reddit forum is not the place to keep repeating how much you dislike this or that. Your approach is not productive. You have heard all there is to hear about your issue in the context of this forum. If you want Javascript to change - and there is a lot that a lot of people want to change (many would like to replace the whole language...), go to http://www.ecma-international.org/memento/TC39.htm https://tc39.github.io/process-document/ &gt; Input into the process &gt; Ideas for evolving the ECMAScript language are accepted in any form. Any discussion, idea or proposal for a change or addition which has not been submitted as a formal proposal is considered to be a “strawman” (stage 0) and has no acceptance requirements. Such submissions must either come from members of TC39 or from non-members who have registered via Ecma International. You write &gt; you seem to think The Ways Things Are === The Way Things Ought To Be My answer: No, I'm just not directing my wishes to the wrong forum and the wrong people. &gt; without actually acknowledging any of the tradeoffs that this decision creates That is not true and it shows that you did *not* in fact read my comments at all.
Jumped from 0.14 to 15. API is pretty stable. They wanted to ship non-breaking changes faster and have some breathing room with version numbers.
Unfortunately I'm not really sure, but maybe /u/thejameskyle could help you out.
I finally got what you were saying. I'm sorry for not reading the rules through carefully the first time.
Thanks, I've read the api, but I still have questions: + If I start with my latest tweet, using the timeline api, can I cursor back and find all of my tweets? + If I use search and find a tweet, and find its author, and want to find the prior tweet, can I do that by starting at the author's latest tweet and cursoring backwards? And is there a more efficient way to do so?
It's no problem, just wanted to straighten that out. What I want to accomplish is that the website I'm about to design will have a UX and UI that fits the 'coder' perfectly. 
&gt; You caught the downvotes What do you mean? To me, it seems no one has voted on my comment.
Reading over the API it indicates exactly how this functions, I guess I'm just not quite sure where you're confused at? If you look at the status/user_timeline GET method, it indicates that ID's are sorted chronologically, so all you would have to do to find older tweets is simply ID's less than your current ID. Regarding searching other user's tweets, in general you can do this unless it is protected, which is indicated in the doc's: User timelines belonging to protected users may only be requested when the authenticated user either “owns” the timeline or is an approved follower of the owner - so you would need to account for this in your design accordingly. As far as searching all of your tweets, it indicates in the doc's for the timeline: This method can only return up to 3,200 of a user’s most recent Tweets. As far as 'what is the most effective way to do this', it really depends on what user experience you're attempting to offer. If your goal is searching all your tweets, then you may want to cache older tweets/etc as opposed to constantly re-requesting tweets as you cycle.
Thank you, will make some changes.
Sure no worries. Was a small test project I was doing, thought I'd try flowtype out for it. Noticed that, and was a bit surprised.
I don't know if I'd necessarily start here, but you may find it useful: http://todomvc.com Its the same basic JS app written in dozens of various frameworks. Exploring this repo has exposed me to tons of Javascript principals and design patterns...
&gt; Let's not arbitrarily break the web just to suddenly follow a possibly-incorrect spec. Ugh, chrome did the same thing to me with their DeviceOrientation changes (shifting to the chrome-only DeviceOrientationAbsolute event) in v50. It's infuriating that they'd release breaking changes that are intended to fix other discrepancies with other browsers... by detecting chrome and adding yet another workaround for chrome. 
One of the powerful aspects of Flow is that you very often need zero types to have excellent coverage on your code, Flow uses really powerful in-depth inference/flow-analysis in order to type your code for you. function square(n) { return n * n; } square("nope"); This code will cause an error in Flow even though you haven't told it anything. In fact if you write a massive script in one file with no unknown external dependencies then you will need no types whatsoever. This works for very complex programs. Look at this screenshot: https://cdn-images-1.medium.com/max/2000/1*1y23zIfBrVUqnCpHYc5_Xw.png, that's the code from [Lerna](https://lernajs.io/) building up a graph of packages with a dozen or so class methods, 99% of which has absolutely no types and Flow is still able to catch a real mistake that I kept making. Type Systems have evolved a lot from the days of Java. Computer science didn't stop evolving in the early 90s. Type systems today are designed more for the programmer and less for the compiler. They can provide excellent experiences if you're willing to give them a shot. Maybe you've been burned so hard before you're not willing to ever try it again and that's fair too. 
Thanks for the link. Looks similar to how i'm doing it. I wonder if it's because i'm doing it across imports. Or maybe the .flowconfig needs some extra details?
It should work just fine across imports, if you want to create a small test case repo of what you are doing I can look at it
Here ya go: **command line** * low level parser * archive utility * application distribution tool * Node now supports multi-core execution via clusters. A process manager that observes multi-core usage, child processes, and async execution times would be awesome. * dependency analysis utility * easy git submodules. Git submodules are a really powerful distribution tool, but a huge pain the ass to code for considering you maintain them differently than you install them cold. * network security tools, like a utility that warns when a node app beacon information to the web * email and IM message database and distribution tool * easy file/directory/application hashing * UDP packet analysis tool **browser or desktop** * Graphic User Interface * data analysis tool... example: http://mailmarkup.org/xyz * a tiny media distribution tool * media codec transpiler to the codecs browsers support
Babel is great, I'm already using it with my build system, it has a lot of other useful community supported addons, and so on. Compiling with typescript and then processing the output with babel is silly when adding flow support to an existing babel setup is a single line of config. Also, I prefer flow's type system.
Flow: * is only concerned with type checking * can be enabled by a simple comment at the top of a file `/* @flow */` * if using babel preset `react`, the syntax already gets converted to js * can use eslint * `language-babel` atom package already contains the extra syntax highlighting To me typescript seemed too loud and too heavy. All I want is type checking on top of javascript, let me worry about bringing in other es6 features. I had to use tslint which is not nearly as popular or useful as eslint, especially with airbnb's config. The syntax highlighting doesn't look as good as atom's default highlighter. There are a ton of reasons to prefer flow, however, the ecosystem is not as large and as such type definitions are more scarce, which is the most crippling part of using Flow.
Ahh, yeah I think the issue is more with Redux. Higher Order Components are actually quite difficult to type so when you wrap it with `connect()` it's being destructive to typing. (I'm assuming that's the primary source of your problems). There's some longer discussions here about them: - https://github.com/facebook/flow/pull/1821 - https://github.com/flowtype/flow-typed/pull/116 
Can you tell me how Monaca and Onsen are related? Monaca's the backend services and Onsen is the front-end UI tools? 
I have commented on this, but it must have not gone through. A git repo will allow developers to collaborate on the project easier, and allow you to monitor what is added to the code by getting notifications for pull requests. 
My favorite parts of React are 1. I specify a JavaScript object and my UI changes to reflect that object. If I update that object, again my UI reflects those changes. Coming from jQuery where it could be difficult to figure out where your UI is in complex applications (is this panel animating? Are the select options filled in at this point? The user clicked this box and this box, but that other thing is hidden, how should I update this table?), this is very refreshing. I think the buzzword for this is "declarative". 2. Composition. Everything is a component - and your UI is a simply an organized collection of these components. I guess this is sort of what you mean in your OOP comparison. This makes it easier to organize an application and, as the OOP analogy goes, encapsulate functionality in those components. These are the two things that help me build more reliable stuff more quickly, and make them easier to maintain. This is what I care about the most. I know the React's virtual DOM helps implement these, but I am here for them - not the virtual DOM.
&gt; a crutch for people who cannot handle the flexibility that Javascript provides Anyone who can handle a proper type system can handle Javascript's type system. You just need to treat all objects as type "any". While nice and easy to understand, you will spend a **lot** of time hunting down type errors at runtime. How you "handle" that depends on how much time you have to waste doing that. I don't handle it well, personally.
No.
What do you get when you console.log($('#access input#booktitlesearch')); - ? Is it returning a node/object correctly? There's some interesting comments/notes on this stack overflow, but either way there's no reason it shouldn't be working assuming the element can be focused and you're selecting it correctly: http://stackoverflow.com/questions/1096436/document-getelementbyidid-focus-is-not-working-for-firefox-or-chrome
Onsen UI is similar to Ionic since both are UI frameworks and targeting for mobile hybrid and web apps. However, Onsen UI 2 and Ionic are different in the way providing UI components. We try to be JS framework agnostic, so Onsen UI is implemented using Web Components (Custom Elements). That makes us room to support many popular JS frameworks, including Angular 1, 2, React, Vue.js, jQuery and many others. Ionic supports Angular 2, which is one of the most popular frameworks for Cordova and the web. We've seen many people using Onsen UI and actively contributing to the community these days. That's awesome, but we are not as famous as Ionic. I hope you give Onsen UI a try and see if it does good job for you.
Sublime, Atom, VS Code... They are awesome editors and no wonder you love those. Our tools will just fit in your development environment. Monaca CLI (command-line tool) or Monaca Localkit (native desktop app) will connect to the cloud to provide project synchronization and remote build. Monaca also provides [Monaca Cloud IDE](https://monaca.io/cloud.html) which is a great tool for those who want to access from their browser. All the setup are well prepared, so you don't need to install any dependencies. For people who love Visual Studio, we have [VS extension](https://taco.visualstudio.com/en-us/docs/tutorial-onsen/) for that too.
Ah that makes sense, cheers!
Inferno is very cool and very fast. I recommend giving it a look-see. 
I've just started with cordova + Framework7 and I love it. What is your opinion on the future of hybrid app development?
Can you tell me the top 5 Onsen 2.0 templates in your opinion? (Please don't say "it depends.") 
Yes, since I founded the corporation when I was an undergraduate at college. I know the power (or recklessness) of youngsters. It's very important of having a "try and see" motivation. For the future growth, there are many thing I am thinking, including new forms of web and native apps! I'll write in a different blog post regarding the roadmap! 
&gt; infuriating That describes the feeling. 3D game suddenly borked, all flat. Lame.
Yea, good point, the syntax is valid, but else statements unwrapped is just a nightmare - I made the assumption this was merely a portion of his code.
I have a fairly newbie question, but I have been trying to get some examples from Inferno's github page working on codepen/jsfiddle, but cannot seem to get it working, even after adding the required external links. 
Are you trying to use JSX? React JSX differs massively from Inferno JSX and requires its own plugin which (I don't believe) jsfiddle supports.
Your first point (1) is what I meant by components as pure functions (i.e. declarative views that the vdom makes efficient). I suppose I see this declarative nature as inextricable from the vdom since it's the only way to make it work well. And maybe by that I conflated them to mean the same thing while others didn't, which might be why I was confused at why React isn't primarily its vdom. Thanks for your thoughts
One more thing to add: The Intern programs is sponsored by the government, and we'll have another guys next year. They truly help us communicate in the global market.
there is no event system built in to normalize differences in events in browsers. If you don't target evergreen browsers, better stick to react.
Both of these worked for me using JScript Tricks to inject/run the javascript. The input control receives focus on page load: * $('#access input#booktitlesearch').focus(); * document.getElementById('booktitlesearch').focus(); In this function, you are adding the .focus() to a click event for #searchButton. Where is this element? I'm not sure where to click to get the desired results. Maybe a screenshot? Is it only at a certain width (you mention phone users)?
Answering my own question, it is for mobile widths. Shrink the page horizontally until you get the search button. The button does focus on an input currently. I'm thinking a solution was taken/figured out.
i will like to develop a PWA using onsen ui and pure vanilla javascript, can you recommend some libraries or framework that help me to keep my app as pure vanilla js (es6) as posible, but with modern patterns?
Very nice to see a cordova UI library for react, I've been using angular1 because of ionic, I'll give onsen a try when I have some time. Good luck!
But does Inferno still have things like onClick={} to set a listener? Or do I have to write it out myself? I'm guess ing own event system you mean some type of Polyfills that React may or may not use.
That cat image is 10/10 well meme'd.
Can Wanda Maximoff come out and state "No more frameworks!"
How is that different than React being one way bound? I'm probably too naive to see the difference in their description
Thank you! Please check out our [GitHub Repo](https://github.com/onsenui/onsenui) or [Website](https://onsen.io/) for more details. If you need any help, I and my team are ready for answering to your further questions :)
What is the expected output of if ($('body.artist_view, body.dutchcomics')) ?
Evergreen refers to browsers that update themselves.
This looks very interesting, but its main feature, an awareness of static VS dynamic content, seems like something React could conceivably offer in the future. Is this at all possible?
And go back to document.createElement and innerHTML? No thank you
Well that took forever. Wasn't beta announced almost a year ago? In "front end framework time" that's like 5 years.
You mean you don't write your own AJAX requests? \*strokes hipster beard disapprovingly\*
&gt; Evergreen [[wiktionary](https://en.wiktionary.org/wiki/evergreen)] &gt; 1. ... &gt; 2. Continually fresh or self-renewing; often used metaphorically. &gt; 3. ... It is often said of older things, but always to evoke feelings of surprising "new-ness".
Try `InfernoComponent` and `InfernoCreateElement`.
Took way too long for V2.
I stand corrected - learn something new every etc:)
I hate to say it as any early adopter of Angular, but I don't think it matters anymore. Most of the cutting edge devs that I know moved on to React. 
TS includes draft stage specs as well so the argument is moot. Just that only a handful of devs can only do so much, so you're waiting for things like async/await while the rest of the world has had it through Babel, which is the defacto standard for ESnext, now. Babel has many options to serve your needs like loose-mode and transforms that go below ES5. 
Too late, already moved on. 
Why do you say that? Everything I've read about vue.js compares it to react instead of angular. I thought react was an upgrade from angular and vue and inferno are both an upgrade from react. Or something like that. 
That's too bad. I was hoping enough people would ask for a refund that the conference would be cancelled. 
Vue is to React as Aurelia is to Angular. I think Inferno is to React as Vue is to React :P
Second version release of an incredibly popular Javascript framework? Currently sitting at 46 upvotes. Douglas Crockford kicked out of a conference? Multiple artcles about it with 300+ upvotes. Makes sense.
I did fix it by making the selector .length if ($(..........).length){} now, the foxus() works, but still it looses fous shorty after that, maybe because of its jqueryUI autocomplete iniatlisation.? this I still have to figur out. 
Coming from angular, vue just seem kind of like a simpler angular with a bit of react flavor. But you may be right
Now that version 1.x has got so much traction I think new projects will still consider 1.x over 2.0.
Surprise! I thought they'd wait two weeks more to announce it at AngularConnect. **Edit:** Funny, [according to the quickstart](https://angular.io/docs/ts/latest/quickstart.html#!#add-config-files), they're still depending on a beta of RxJS.
Thank you, this is exactly what I was after. Yes an email with a url to the product makes more sense anyway
I am currently working on setting up payment possibilities to the products of my company so in the recent week I spent quite an amount of time to check online payment possibilities so if you have any upcoming question feel free to ask me and hope I can answer :) Anyways, avangate (avangate.com) offers selling digital goodies. Let me phrase them: "Avangate can automatically deliver your digital products to your partners/customers immediately after successfully placing an order. Files are stored on Avangate secure, high bandwidth server and are limited in time and number of tries, to avoid the risk of stolen or resold codes." So the other way of selling the product is also possible. But to be honest I would go with the send url in email way.
Onsen UI itself is a open-source framework. Therefore, we're hoping to get contribution from the users, but absolutely free to use. Monaca, which is the tooling to build Onsen UI easier, is a cloud service and requires subscription. Monaca can be also started free for basic services, but we are asking for paid subscription if your project go big. See [the details here](https://monaca.io/pricing.html). So, in a nutshell, Onsen UI is completely free and you can use it with any tools you already love and use. But if you want to create mobile apps easier, Monaca is a great option, and it requires subscription.
I've been using Aurelia for the past 3 months. Quite happy with it tbh. 
Fair enough! Thanks for reply.
I love it! I can't wait to get off work (where we use Evil R) and start experimenting with NG2 :)))
the div is still displayed, would I need to add document.getElementById('submit').style.display = 'none'; when the page is loaded 
In those cases, one can chose aurelia. 
"router crisis" refers to the complete re-(re-)\*write of router *after* RC1 was released *maybe there was one more rewrite. But i had stopped counting at that point.
The way you thought of... document.getElementById('submit').style.display = 'none';
The place where it made the most sense is inside function setBoard() Can you show the HTML?
* https://learncodethehardway.org/javascript/ * http://programming-motherfucker.com/become.html#JavaScript * http://javascriptissexy.com/how-to-learn-javascript-properly/ * https://bento.io/javascript * http://teachyourselftocode.com/javascript
For someone suffering from the fatigue, currently doing frontend in react and flux; Should I care or let it slide until it is alive or dead a year from now? 
Now that it's finalized it is a good time to make a comparison between Aurelia and Angular 2 and show people how backwards Angular 2 does things. Unless of course they did a complete 180 between RC and 1.0 so it's not a completely overengineered pos framework any more. Haven't checked it out since the RC but I doubt they came to their senses.
I care. I liked Angular 1, the time invested in learning it benefited me greatly professionally-wise. React can be fun but each time I want to setup a new project any tutorial from last week is obsolete. If Angular 2 helps me getting up quickly without having to know which hot module reloader or router is the flavor of the month I may try it. Also, I know companies that already use it in production with alpha versions.
You don't close your submit div. You're missing &lt;/div&gt; 
.... whoops looking / editing code for to long, I have closed it now and added the document.getElementById('submit').style.display = 'none'; to function board however not it doesnt load the puzzle :/
Inferno 1.0 comes in around 8kb gzip.
https://www.youtube.com/watch?v=65-RbBwZQdU
document.createElement and document.cloneNode
Especially since 1.x is so much simpler than 2.0 and you can still build enterprise-grade apps with it fairly easily. As far as framework design goes, this is sort of a joke: https://angular.io/docs/ts/latest/quickstart.html Quickstart my ass...
Put your &lt;script&gt; tags at the bottom. The scripts are trying to modify the element which does not exist yet. This is why the block is showing even though you have js to hide it. 
Still trying it out but I totally agree. What a mess of a quickstart. 
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Sliding Puzzle - Easy&lt;/title&gt; &lt;style&gt; .picture { border: 1px solid black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;a href="index.html" style="float:left;"&gt;&lt;img src="images/arrow.png"&gt;&lt;/a&gt; &lt;div id="slider" style="visibility:hidden;"&gt; &lt;form&gt; &lt;label&gt;Easy&lt;/label&gt; &lt;input type="range" id="scale" value="3" min="3" max="5" step="1"&gt; &lt;label&gt;Hard&lt;/label&gt; &lt;/form&gt; &lt;br&gt; &lt;/div&gt; &lt;div id="main" class="main" onClick="onClick()"&gt; &lt;canvas id="puzzle" width="480px" height="480px"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;p &gt;Clicks: &lt;a id="clicks" name="clicks"&gt;0&lt;/a&gt;&lt;/p&gt; &lt;div id="submit"&gt;&lt;p&gt;Submit your Score!&lt;/p&gt; &lt;input type="text" name="name" placeholder="Name"&gt; &lt;input type="text" name="email" placeholder="Email"&gt;&lt;input type="submit" value="Submit"&gt;&lt;/p&gt; &lt;/div&gt; &lt;/center&gt; &lt;script src="sliding.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var clicks = 0; function onClick() { clicks += 1; document.getElementById("clicks").innerHTML = clicks; }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
To anyone happy with React, Angular 2 offers nothing.
Oh wait got it! Thank you for all your help
React is beautiful.. in principle, but to actually do useful things with it you need so many *additional* libraries that the slickness is lost. You want ajax? You need an additional library. You want promises? You need an additional library. You want routing? You need an additional library. And god forbid something goes wrong and you have to trace through the documentation of each of these libraries and how they work with react proper. In theory, sure I could pull out react and replace it with some other view engine, but in reality I'd be pulling out react and *all* the other react-based libraries and replacing/adjusting all of those. Angular 1.x sure isn't perfect, but at least all the most basic tools you need for a web application are right there and I never have to worry about how $http works with $scope or whether $q is a compatible version. 
&gt; in principle, but to actually do useful things with it you need so many *additional* This is actually a benefit. You are looking for an opinionated Swiss army knife. With React, you do things what makes sense to you, not what the framework *forces* you to do.
Well I mean, lots of people care. My entire organisation has been developing all our new clients in Angular 2 for a while now so this is a big deal for us. Many of my friends are developing their own projects in NG2 and a place I interviewed at a few weeks ago is going full Angular 2. This is backed by Google, which a lot of organisations (especially larger ones) care greatly about. I'm thinking the adoption rate will be quite high considering how organisations I know that are running the RC in production ¯\_(ツ)_/¯
Debugging Node looks a lot easier than doing node inspector or other ways from the demo
Thank you for your reply sir.
2.0 was much more intuitive to me when I tried it 6 months ago. Now I don't see why someone would choose angular 2 over react, but I also don't see why someone would start a new application in Angular 1 either. 
Or maybe it's just you who has nothing interesting to say about it? Angular 1.X was one of, if not the most popular JS front end framework. So the final release of it's second version is big news.
React has an incredibly stable api because Facebook uses react for everything. The tutorial isn't different every week; people just write a lot of tutorials with their own ideas of hoe to do things. Just pick supporting libraries (redux or mobx or even just vanilla react) and stick with it. It's not going to be the end of the world because someone made a new supporting framework. 
Yeah, it's just a different mindset. There's nothing wrong with either approach - you can make websites that do what they should just fine with either. It is divisive though - if you take a job that does things on "the other side", you're probably not going to be happy there.
The announcement post, https://github.com/blog/2256-a-whole-new-github-universe-announcing-new-tools-forums-and-features
No, I think it's just a little sad that those were incredibly popular, whilst something actually to do with JS and not drama just has tonnes of comments about how they don't care.
But RxJS v.5 *is* in beta. And they specifically wanted v.5
&gt; But Angular? Nowhere to be seen in any Google product of note. So out of curiosity, does anybody know what Google is using?
Apart from routing, web workers, animation, dependency injection, http, and form validation.
Google has a ton of products but for many of the larger and more famous ones they use GWT which is Java that compiles to JS
&gt; completely overengineered pos Gotta love the know-it-all devs that just want to shit on everything 
Angular didn't invent those. You've been able to use those alongside with React however you pleased in a way that suits you. That's kind of the point.
I think it's probably because Angular &lt;= 1 came out and it was mostly good, then it was announced that Angular 2's API would have some big changes meanwhile React came along with a fresh take on things. I felt like there wasn't much point spending time on Angular 1 if it was going to change and v2 seemed a way off. React seemed like the better choice, long term. This is probably why the 'meh' response.
Well, he's right in a way because technically you *can* certainly mix Angular with vanilla Javascript/jQuery, but you have to set up a whole host of watchers and scope updates manually to notify Angular of any changes that happen from outside of Angular. I've had to do that when I integrate SignalR into an Angular app, and it's kinda a nuisance every time. It works, but it's not really very elegant. 
Nice to see them trying to compete with gitlab and atlassian. Better for us, the devs. Edit: by compete I mean with features. Gitlab and bitbucket are not nearly the size of github... but both have similar features already
&gt; Is that similar to kanban Playing around with it, a project is just a board. Which can have notes, and issues assigned as cards.
Everyone forgets about react in 3, 2, 1...
But it is easier if they all come in one big package, with one 'recommended' way to handle it all. There are two ends of the spectrum that each library/framework aims at - hyper customisability for React and ease of development for Angular 2. I can see people who don't want to shop around for a form validator, etc. etc. happily moving to Angular 2 (and even those who would shop around, if it turns out to be the best design - yet to be seen). 
Don't forget universal apps.
Yeah, but the TS docs are complete: https://angular.io/docs/ts/latest/guide/style-guide.html
Mostly GWT. Some vanilla JS, too.
You're exactly right that React to Angular is an unfair comparison. But I disagree when you talk about a "real world use case". That is the whole point - you can use React with whatever you want. For some people, that is a benefit. They want that. You might not want that, and that's fine. In fact I think a lot of people jump on React + webpack + redux etc because it's cool or whatever, when it doesn't suit their needs, and then blame React itself. I don't hate Angular - it's just not for me.
&gt; Or they could just pick up the industry defaults for React projects - Redux for state management and react-router for, uh, routing. As an outsider who hasn't used React at all yet, it seems hard to keep up with that. It's hard enough to keep on top of everything else we have to deal with already—build tools (Gulp, Grunt, Webpack etc.), test frameworks, CSS preprocessors (SASS, LESS, Stylus, PostCSS) and so on without the added complexity of keeping up to date on the latest React router/state manager etc.
&gt; It's why they wrote GWT for compiling Java into JavaScript and why TypeScript appeals to their sensibilities. To be fair, GWT was written a decade ago. It was pretty unique at the time. They also wrote the Closure Compiler. And TypeScript appeals to a much broader audience than Java developers. :) &gt; TypeScript will make client code friendly to developers suspicious of dynamically typed, interpreted languages. This is a horrible mischaracterization of why TypeScript (or Flow, or Closure, etc.) is useful. Static analysis tools increase productivity and save engineers time (by catching bugs before runtime, enabling easier refactors, etc). The way you put it is like saying that unit tests "are for developers who aren't confident enough in their ability to write code". :) &gt; But it is important to be mindful that Google's priorities may not be the same as yours. Google's priorities are maximizing profit for Google. Facebook's priorities are the same. Both companies have smart engineers working on their frameworks and both communities (largely overlapping) have talented and motivated individuals contributing to the ecosystems as well. I don't want to get into an Angular vs React vs whatever debate though. I just wanted to point out that Google _does_ dogfood its own framework because a lot of people don't realize that. :)
I think he was being cheeky because you said "kaban" in your post title.
sorry to break it down to you but Angular is not everything, there are other frameworks out there with less ingrained design flaws. I just tell it how it is.
They all have their goods and bads. Just don't use it if you don't like it, and let the community decide. All I would say is if Google starts widely adopting it (which they already have in e.g. some parts of App Engine even though it was still in beta) people will flock to it. 