Depending on what you need/want, the [W3Schools Site](http://www.w3schools.com/js/default.asp) is generally pretty useful.
Is this book good for learning JS? DOM Scripting: Web Design with JavaScript and the Document Object Model
I haven't read that one, but Jeremy Keith is pretty good. I'd recommend this one: [Beginning JavaScript with DOM Scripting and Ajax](http://www.amazon.com/gp/product/1590596803/ref=pd_lpo_k2_dp_sr_2?pf_rd_p=486539851&amp;pf_rd_s=lpo-top-stripe-1&amp;pf_rd_t=201&amp;pf_rd_i=1590595335&amp;pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_r=1AXFC64HR9SRSBVXN1SQ)
whats this python tutorial you speak of?
Not really. The fact that javascript documentation is such utter crap is amazing to me, given that it's the most popular programming language on the planet.
W3C is weak n00000000000000000000000000b. Try [MDC](https://developer.mozilla.org/en/javascript)
W3Schools is awful. 
Most popular? [Maybe you're thinking of Java](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html).
Most widely distributed, then.
Somehow, there isn't one decent tutorial/guide on the entire web. Learning Javascript was tough for me.
Thanks for the warning. I swear this will run above the home page ONLY ! (It'll be Xmas soon and I intend to behave).
In defense, the title indicated *tutorial* ... and W3Schools tends to have the very basic "cheat sheet" of tutorials/references. [DevGuru](http://www.devguru.com/technologies/JavaScript/home.asp) might be a slight notch up. But yes, Mozilla has better, more-comprehensive references ... which are beyond what most would consider "tutorial," in my estimation/opinion.
Eh, they're okay for really basic/stupid ground-level references - if you're asking for a tutorial, chances are you're not looking for AJAX or JSON type references yet, or anything. I'd look for a more comprehensive reference once the ground work is done, however.
&gt;`var CalcTotal = function(x, y)` JavaScript is not C#. Capitalized function names are used to indicate c'tors. &gt;`(function(x) {return x * 1.2;})(100)` The wrapping parens should wrap the whole thing, because that's what you actually mean. (AS3 wouldn't compile something like the thing above, because it's nonsense.) &gt;`var person = new Object();` Beh. Use an object literal instead. &gt;`person.BirthDate = new Date(1979,10,17)` Semicolon missing. &gt;`else` if [...] ಠ_ಠ &gt;`var Person = function(name, lastname, birthdate)` { Stick to 1TBS. &gt;`thisMonth == this.BirthDate.getMonth()` `===` &gt;`var p = new Person("Dino", "Esposito", new Date( ... );` ')' missing. JSLint helps. Seriously.
Comes with the documentation. http://docs.python.org/tutorial/
For references, I prefer *JavaScript Kit*: http://www.javascriptkit.com/jsref/ *and* http://www.javascriptkit.com/domref/
There there: https://github.com/batiste/sprite.js/commit/676e3ed51239b1dbc043bd4da29f763eb011cc9b
Maybe Quirksmode is of some use: http://www.quirksmode.org/resources.html
Can you explain what you mean about the function-wrapping parenthesis? I've heard that the whole thing should be wrapped before, but I never understood why there's a difference. The wrapping parens don't actually do anything, right?
**A:** `(function () {[...]}()); // (function + invocation)` Instead of: **B:** `(function () {[...]})(); // (function) + invocation` or: **C:** `function () {[...]}(); // no parens - doesn't always work` Using B instead of A works fine in JavaScript, but it doesn't necessarily work in other JS-inspired languages, because it doesn't really make much sense. Thing is, `foo()`, `(foo())`, and `((foo()))` are the same thing, right? You don't really wrap anything there. So, you should go with A. You declare an anonymous function and invoke it. To make it work in every case and to make your intentions clear, you should wrap the whole thing with parens. The wrapping parens aren't required in all cases, but you should always put them there. This way the code will be read under the right assumptions. I.e. if you read the first line it will be crystal clear that you assign the return value of this function (which is *apparently* invoked right away) and you clearly do not assign this function to that variable.
Those are also good - I stopped short of including them, as well.
It would help a lot if he would just say first *what* language he's trying to parse. And lexing in Javascript character by character, instead by using regular expressions?? Ugh. Javascript is not C. 
brain =&gt; explode _Edit:_ fun fact - the Y combinator was discovered by [Haskell B. Curry](http://en.wikipedia.org/wiki/Haskell_Curry)
Not much content in this blog post, I was expecting much more. I'd suggest reading zakas' chunk method for processing array elements without locking the browser: http://www.nczonline.net/blog/2009/08/11/timed-array-processing-in-javascript/
Wow, I don't know how I missed that setTimeout/Interval can take extra arguments to pass to the function! I've been making pointless closures for years...
I agree, there's not much content in the blog, period.
~blearily looks at post~ ~sigh~ Do you want fries with that?
Look at the tutorials for reading and writing line-by-line. You can rip the code out of there with very little change to do what you want to do (just some checking model number and incrementing/decrementing quantity). You might consider using a form to record the orders and have the spreadsheet that records the info from the form execute your script every time it receives a new entry. 
Use the [*.apply*](http://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply) method to pass on the functions *arguments array*: http://jsfiddle.net/craga89/Wpvxf/3/ The arguments.callee properties aren't standard iirc and have been removed in ECMAScript5.
craga89's [answer](http://www.reddit.com/r/javascript/comments/egu5b/accessing_arguments_of_caller/c17zvw9) is one way. Alternatively, you could just pass arguments to B as.... an argument. Like so: function B(args) { var result = '', output = document.getElementById('output'); if (!args.length) { output.innerHTML = 'Failed.'; return; } for (var i = 0, l = args.length; i &lt; l; i++) { result += '"' +args[i] + '" '; } output.innerHTML = result; } function A() { // slice arguments as needed (if you don't need them all) // and "arrayify" the arguments object B(Array.prototype.slice.call(arguments)); } Really depends on what you are doing/preference; .call() and .apply() are mostly useful for changing the context of a function (what "this" is) or destructuring the arguments (object) somehow. You're not really doing either in the example, just looping through them. In your example, it seems more intuitive and flexible to me to have B just accept an array as an argument rather than treating it's arguments as an array. 
There is something unclean about passing the arguments object around. I would copy it like this before passing it to B: function A() { B(Array.prototype.slice.call(arguments)); } This is mentioned on MDC in the Description section of this link: https://developer.mozilla.org/en/JavaScript/Reference/functions_and_function_scope/arguments
Yea I actually meant to throw that in there for the reasons you mention and also in case OP didn't want to pass all the arguments, but forgot, thanks.
I hate the idea of wasting time on a no paren JS as well as # as a synonym for function but some of the prior one minute talks are interesting and provide things to look forward to. This one is still informative even if its depressing.
in the strings.js test, they check for trim. It assumes I guess that substr exists. Then let's say that they test for the existence of substr. It still does not mean that the function will behave the same accross browsers(http://rapd.wordpress.com/2007/07/12/javascript-substr-vs-substring/) or perhaps the Array split method(http://blog.stevenlevithan.com/archives/cross-browser-split). That's why they have bugs.js. The existence of a function must be correlated with an expected/proper behavior. so you have to look for the bugs.js file where you can find:"bug-string-split-regexp" for example. so the library we'll look for if(has("bug-string-split-regexp")){ } else{ ... // if the else use a method that break in browser z? } Now how can I test against the fact that in IE a pulldown always end up above anything else, whatever the z-index you set? All this, make me wonder: - what these tests take as granted (they assume certain things are implemented while some not. true today, certainly true tomorrow but not more relevant than a split method perhaps the day after tomorrow?). - what these tests base their bugs data base on, which browser version they support (you do not have the same bugs in Safari 3 and Safari 5,for example.I could not see the margin bug of Safari where it sends back the distance of the element from the window instead of returning the margin value. well, this is one in many many other bugs but i guess the "bugs" file is going to be pretty heavy in the long terms) - can you/how do you hande UI level bug with this?(if the answer is you can not then how do you do?) - is the existence of a feature mean that it behaves like it should be (again, in older version of Safari, they loved to pre declare dom css related methods but in fact, they were not implemented at all...so doing if(...) will return true but the function was just an empty stub...) - how heavy this is going to be (let's say i want to use this within a library and my code, how many kbs we're talking about) i like the bugs "data base", something where we could say: you want to know what bugs are around? well, look for has.js. We could certainly from there create a tool that will analyze the code and warn (or why not,replace the code with something else) when you write a code that might get you into trouble a la jslint. if(str.split(/(_)/) { #there's a potential bug here, warning... } 
jsmake 1.6 supports configuration file to make life easier. jsmake offers naming of anonymous functions or removal of them but it also offers a systematic file layout, compressions and directives. It can be integrated within a continuous integration environment very easily too. Most of the work to be done by the programmer will be to add some directives as he/she fits (the minimum being the !#require: directive). 
This raises a *WARNING: dark magic usually indicates an [antipattern](http://en.wikipedia.org/wiki/Anti-pattern#Programming_anti-patterns)* alarm in my head... what are you trying to do? There's a very good chance that there's a much better way to handle the problem you're trying to solve than just reaching into some unknown caller's argument list.
Brown, I think you could have figured out your problem by researching instead of looking for someone to do this for you.
You are incorrect sir, and perhaps would like to [review the ECMAScript5 specifications before making silly judgements.](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf) (warning, PDF link. You're looking for section 10.6.13 and 10.6.14.c, depending on whether you've set strict mode or not.) 
http://jsfiddle.net/hDCLX/ Works cross browser. May I suggest using [stackoverflow.com](http://www.stackoverflow.com) for questions?
I think if (arguments) will always resolve to true even if arguments is empty. At least in FF. Also why not just define an argument in b rather than use the arguments object inside it ?
Also, I wonder about the blanket statement that head.js is always faster than a combined file. Our scenario is pages must perform well in poorly connected countries that may have latency as bad as 1 sec. Even if you are loading 3 resources at a time in parallel, and are caching things, you still take a hit when the browser checks to see if each resource has been updated.
Everybody is trying to give you reasonable alternatives, warn you against dark magic, and generally trying to steer you toward normalcy. :( So that's boring. And after all, maybe you really really need to generate stack traces that contain function arguments, and you're quite sure you'll never end up having the same function showing up twice in your stack. Or some other really good reason like that. ;) So Firefox is failing, yes, but only a little bit. The feature is actually implemented, and it was implemented long before anyone else. However it has been [deprecated](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/arguments) for a few years now, which might be why they don't invest a lot of cycles QA-ing it. Anyway, the part that seems to be broken on FF is that inner functions that are called before their outer function returns will not have their `F.arguments` object defined during that call, unless `F.arguments` is explicitely referenced in the body of the outer function. That's `F.arguments`, not `G.caller.arguments`. Yes, that's a wee bit specific, and yes, jsfiddle is hitting exactly that condition. I know, that sounds crazy, so here's some code to reproduce (don't use jsfiddle, cut and paste in a .html file to keep things pure): &lt;script&gt; (function () { function b() { alert(b.caller.arguments?"Success":"Broken"); } //d.arguments; function d() { b(); } d("hi"); })(); &lt;/script&gt; Run this in FF, watch the "Broken" alert pop up. Now *uncomment* that `d.arguments` line, reload, and watch the difference. Fun stuff.
it's an half-empty / half-full kind of thing. in strict mode, the arguments.caller and arguments.callee properties must exist, but only to throw exceptions, so they're defined, but not in a terribly meaningful way. es5 in non-strict mode still has useful version of those properties, though. Interestingly, I don't see a reference to what OP is actually using, which is F.caller, which is presumably an alias to F.arguments.caller, but doesn't seem to show up in the spec.
Don't let go of those closures just yet. That extra args syntax is not supported in IE.. in fact, at one point, IE used to take a 3d arg for those method to specify which scripting language to use to run the string in the 1st argument. `setTimeout('MsgBox("Seriously")', 100, "VBScript");`... 
If you are looking for intro text when coming from another language, use the MDC JavaScript Guide its great for a rapid upstart with base knowledge of programming: https://developer.mozilla.org/en/JavaScript/Guide If you are (or helping someone to) start learning JavaScript from scratch - use Eloquent JavaScript which is an amazing text that teaches programming and JavaScript: http://eloquentjavascript.net
All of the information on W3Schools is old and mostly wrong. Please stop recommending them, see http://promotejs.com for how the JS community is trying to encourage and promote better JS documentation.
Thank you thank you thank you. Looks like just what I need (eloquent book).
In which other JS-inspired languages does B not work? And how does it not make much sense? Also, I don't understand what `foo()`, `(foo())`, and `((foo()))` being "the same thing" has to do with this. The purpose of wrapping parenthesis (weather it's A or B) is: 1) to enforce expression context (in A, it's MemberExpression; in B — CallExpression; both allow function to be interpreted as a function expression). 2) to make intention of calling a function clear (in which case, either A or B are non-ambiguous, as it is _opening parenthesis_ that usually serves as an indicator of invocation). I don't see why one should go with A over B. I personally always use B (as a habit).
There are a lot of drawbacks to the pattern Crockford espouses: http://bolinfest.com/javascript/inheritance.php
&gt;In which other JS-inspired languages does B not work? AS3. Probably others as well. Might also affect some more obscure (i.e. outdated, not well tested) JS engines. &gt;And how does it not make much sense? Function + invocation is one thing. The function itself isn't any good nor is the invocation itself. Therefore the whole thing should be wrapped. Sorta like (a+b) vs (a)+b. The former means something, the latter is a pure parser exploit. Well, unlike JSLint, I don't really care if you use B. ;)
Thanks for the linkage - I'll give it a read!
Where is that chart from? Doesn't seem accurate... [Here is another chart](http://blog.nielsen.com/nielsenwire/online_mobile/us-smartphone-battle-heats-up/) (From nielson.com) Anyway, it is a good question... It is expensive to develop across mobile platforms, so my financial vote goes for web, but my UX vote goes to the app. Though call...
&gt;"I find this odd because Crockford could have created his own annotation with an identical check in JSLint." There is that newcap switch (~require Initial Caps for constructors). And I don't think that the memory overhead matters in most cases. Good article though.
Please don't create real apps with classes that have 100 methods.
...though I'll also point out: there seems to be plenty of opposition to these guys from those, here, who claim to be more knowledgeable about the subject than I... but, perhaps it'd be *more helpful* (at least to me) if you could help point out some examples of *what* is wrong, there, rather than simply indicating "they suck" (yes, I know there's *better* out there - but not always *simpler* for those trying to learn the basics) (I'm really *not* trying to be a snot, here ... just want some good, glaring examples of why they (W3Schools) may not be a reasonable *beginner's* reference)
Why not? Everyone's doing it. geber's point stands though, in any case.
With respect to the memory overhead, take a look at Arv's results http://erik.eae.net/archives/2009/11/09/21.12.16/: &gt; I think it is important to realize that it uses a LOT more memory and is &gt; significantly slower. Given a class with 1 methods It is about 100 times &gt; slower in Chrome, 20 times slower in Safari and about 10 times slower &gt; in Firefox.
Since you invoke the imaginary "everyone", I will invoke the imaginary "no one" :b No, no one does that. Sensible API designers heed Josh Bloch's advice about ["When in doubt, leave it out"](http://www.infoq.com/presentations/effective-api-design). Senseless API designers don't, but still, can you think of any class off the top of your head where you could name a 100 different operations? (As an aside, the biggest class in google maps js api v3 seems to be 25 public methods. In java you have a Collections and a Scanner class with 37 and 54 public methods respectively. Those were the biggest I found with a quick search) The exception, which is perhaps the one you mean, is single entry point JS libs, like jquery. jquery exposes around 160 public methods. Calling these typical, and what everyone makes, seems a bit disingenuous though. There is only one jquery. There is a handful of libs doing the same thing in the same way. These libs put all their methods in a single place as a trade off. The alternative would be multiple entry points, and it's preferable to not pollute the global name space more than necessary. Also, I still disagree with gebers point, but I've replied again to the parent with that.
My previous reply was a bit snarky, sorry about that. Here's a proper one. Arguing about saving function pointers smells of premature optimization, especially since you don't link to any performance data. First of all, we don't know how many objects, and how many methods we would need to have, for this possible optimization to make any difference. JS engines are very good at dealing with functions. Secondly, is it realistic to write apps where you will maintain pointers to hundres or thousands of complex objects? 100 methods, or even half of that, sounds like we're dealing with something way more complex than a Polygon or Tweet. Furthermore, in the cases where you have thousands of these objects it's not reasonable to assume that you want to optimize for space. A game that creates thousands of Sprites probably wants speed. If I too get to speculate about JS engines I could easily argue that closures are faster than protoype based classes, since there's no need to crawl up the prototype chain. But I haven't done the tests either, so who knows? Finally, doing these kinds of optimizations, you can't really know if the optimization will be valid for all JS engines. So what is an optimization one place might be an antipattern somewhere else. Indeed this could be the case even with the same engine if it was compiled with different options for mobile and desktop. So tl;dr: use whatever class idiom you prefer for it's readability and features. (And if I get to be God-emperor of JS, don't use the one in the article. It looks fugly)
I created a library that handles that : [Code](http://github.com/dsimard/jskata/blob/master/src/jskata.nofreeze.js) and [example](http://dsimard.github.com/jskata/nofreeze.html). 
Yes, if you create 5 million objects you get a measurable difference. People in the comments mention a factor of 4-5 for object creation with Chrome. Well, it's a bit like those empty loop micro benchmarks. Yes, you can save a little bit of time, but the looping itself usually isn't the actual workload of the loop. So, switching to a loop construct which is a few times faster typically doesn't measurably improve the performance of your application. I.e. you don't even gain a few msec. (I still like the `for (i = a.length; i--;)` loop though.) In our online shops we create maaaaybe 20-50 objects¹. A single DOM interaction takes a lot longer than the creation of those few puny objects. There is absolutely nothing to gain there. [¹ I ignored option/data objects.] And if you have gazillions of objects you probably shouldn't invoke a function on each of them. E.g. for games it's sorta nice to use arrays of objects which only contain the relevant data. And there is only one function which is invoked which loops over all of them and updates them.
Here's my article where I agree with OP and talk about some of the advantages over the prototype form. http://hivedev.blogspot.com/2010/11/case-for-functional-inheritance.html
Also, February is *decades* ago in this field. 
Hey dude, thanks to your little chart link to neilson.com, you've helped me a bunch, and saved me *a lot of time* because I need that information for a thing I'm doing, and I didn't know I needed that information. Kudos.
You're taking only examples of famous well-known APIs (we were talking about "real apps")? I was simply making a throw-away comment about the quality of code overall in the industry, like when you start a new job and see on that first day the quality of the code you've been hired to work on. 100's of methods in a class? I wish that was the extent of the horror I've routinely run across at various employers.
I think "Mobile Application AND Mobile web" is a more accurate title. These 2 are going to exist side by side foe a long time. 
chart from http://metrics.admob.com/2010/03/february-2010-mobile-metrics-report/
In your style tag you are missing a semi-colon at "font-weight: bold margin-left:auto;". Turn that into "font-weight: bold; margin-left:auto;" If you need more info let me know.
It's always something simple, isn't it? Thanks so much for your help, BigAB! I appreciate it tremendously!
lol, I've literally never seen this function before, and I even read through jQuery's source a couple months ago. nice find.
Source: noop:function(){} I'm not sure if it's good practice, but I use it as a placeholder sometimes instead of &lt;a href="#"&gt;foo&lt;/a&gt; so that a click doesn't make the browser scroll to the top.
You definitely shouldn't be doing that - you should be preventing the default action on the element. For example: $("#mything").click(function(){ // Do stuff return false; // Stops bubbling and default action }); Easy!
We have been using *function(){}* just fine, for over a decade. Why -- does jQuery want to recreate the stdlib, keeping their users from using real JS? This dilemma is creating a real problem when looking to hire competent JS developers. 
That's not what it's for. It's for this: function(optionalCallback) { optionalCallback = optionalCallback || jQuery.noop; // ... optionalCallback(); } 
noop = no op = no operation. Most CPUs have a 'NOP' instruction which does nothing, that's probably where it originates. Put it in your pooper!
Why not just use the global variable, undefined? Unless you're advocating the use of the pseudo-protocol, *javascript:*, in href tags in conjunction with void(0) but then that wouldn't make sense with the competent JS developers part.
Ah, I didn't realize you could return false in click() and have that effect. Other than the fact that there is a better way, is there anything that could be bad about this though: &lt;a href="javascript:$.noop();"&gt;foo&lt;/a&gt;
void(0) returns false, which is not always what you want. It's safer to have a noop function that you can pass around as a default callback instead of having to check its value as a function every time you try to execute a callback. iamnoah has a great example.
First, instead of looping through everything, try using .contains().... Second, you probably want to use html() instead of text().... 
&gt; First, instead of looping through everything, try using .contains().... is there a performance benefit &gt; Second, you probably want to use html() instead of text().... that was the problem. Thanks a ton. 
See also Prototype's `Prototype.emptyFunction` (which does nothing) and `Prototype.K` (which returns the first argument that was passed into it).
`void(whatever)` returns `undefined`.
Mootools has a similar function: Function.from() but you can specify what you want returned as a parameter. var blah = Function.from('Hello World'); var halb = blah(); // halb = 'Hello World' It's very useful for default callbacks in classes.
Wow. That kind of speed bump is just crazy. Poor Mozilla team... they were finally catching up. **Edit:** This sounds sorta like the stuff Sun did with the JVM (hotspot).
Neither solution would work if HTML is available before javascript (jQuery in this case) has set up their handlers. I always do: &lt;a id="mything" href="javascript:;"&gt;foo&lt;/a&gt; So early clicks don't do anything. The jQuery way to prevent default is thru the preventDefault method: $("#mything").bind('click', function(e) { e.preventDefault(); // do stuff }); 
Very well, because void requires an argument(s): optionalCallback = optionalCallback || function(){}; The more optimal pattern: optionalCallback &amp;&amp; optionalCallback();
I wouldn't advocate *javascript:*. The use case is passing an anonymous function as a callback argument. It just seems silly to provide non-standard functionality that already exists, diluting the chance of developers -- jQuery users -- from learning JS.
i think you meant to use === instead of ==
Why define an *href* at all, if not referencing anything?
That's not the same thing. In your case calling optionalCallback with a string argument actually compiles a function (doing code evaluation - assuming that you've fallen back to Function). I mean you maybe meant to do new Function or just function(){}. However the reason why we didn't do either one of those is that we didn't want to re-create a unique, empty, function multiple times in the program - we could create it once and use it everywhere (reducing code complexity and making the code faster).
Or you can just use event delegation/jQuery live to achieve the same result without the nasty javascript:; - like so: $("#mything").live('click', function(e) { e.preventDefault(); // do stuff });
that's good, but it's the wrong use case. if you have a set of callbacks and one of the options is a function to execute, you can do: var callback = opts.callback || jQuery.noop; callback(); this is for the internals of javascript, not at the point you hook it up to the dom :)
[This is a very standard pattern](http://en.wikipedia.org/wiki/Null_Object_pattern). They are actually doing things correctly. There is nothing to see here. 
Node performance is going to be more awesome then ever!
Right - the original poster (hc5duke) was recommending using it to hook to the DOM via a javascript:jQuery.noop - which is definitely not the right thing to do. I showed him the better alternative. jQuery.noop definitely doesn't relate to DOM operations.
In Javascript herp coerces to derp with ==, which in this case is desirable. 
I wonder when [are we fast yet](http://arewefastyet.com/) will update and use crankshaft.
Hey John, you are correct in that I meant to use function(){} in place of Function. Nonetheless, I'm not seeing the speedup, in practice. I have probably come off a lot more flippant than I mean; the availability is not that big of an issue. js&gt; function run_test(fun){ var iterations = 1000000; var init_time = new Date().getTime(); while(iterations--){ fun(); } return new Date().getTime() - init_time; } js&gt; function time_run(fun){ return Math.max(run_test(fun), run_test(fun), run_test(fun)); } js&gt; var jQuery = {'noop': function(){}}; js&gt; time_run(function(){}); 700 js&gt; time_run(jQuery.noop); 711 js&gt; time_run(function(){}); 728 js&gt; time_run(jQuery.noop); 701 js&gt; time_run(function(){}); 697 js&gt; time_run(jQuery.noop); 697
And as to reducing the complexity of our code, as an outsider, I can't be certain of *noop*'s side-effects without digging into the source. Where as, reading function(){} will never leave me questioning the author's intentions.
Also, if this only executes once as it seems to do from your example, you can make it a self executing function: (function() { $("*").each(function() { if($(this).children().length==0) { $(this).text($(this).text().replace('NAME', '&lt;font color="red"&gt;NA&lt;/font&gt;&lt;font color="green"&gt;ME&lt;/font&gt;')); } }); })();
Excellent write-up. I haven't seen a better one.
even when they do, by that blog authors' own admission, the sunspider results won't change much, so mozilla is likely to keep the top spot on that one.. it will however give them more work to catch up on v8bench.
 $(this).text(... should be $(this).html(...
Oops, didn't see the other comments.
If you hover the individual sample points, you can see the revision number. Looks like they update it for every bench cycle. They probably don't use the bleeding edge branch though. And they really shouldn't, since that one will be broken frequently. I'm not really sure how long it takes till changes from bleeding edge trickle over to the stable branch. But I'd guess we should see it over at arewefastyet in about 4 weeks (it's updated every 2 weeks).
http://groups.google.com/group/nodejs/browse_thread/thread/b33731c46347d4b9/ Looks like it didn't help much. Well, at least if it's about braindead throughput.
&lt;3 competition
`href` refers to a URI, and is meant to point towards a web resource. While `javascript:XXX` is a URI, arguably it isn't a web resource (rather a piece of web functionality) so it is kinda against the intent of HTML. Also, a browser that doesn't understand the `javascript:` tag will fail, and perhaps even a browser with Javascript disabled will fail. There might also be some problems when interacting with the element through DOM. Also, if you try and open that link in a new window, a new window will open but will be to a rubbish URI (`javascript:XXX`). If it was an `&lt;a onclick=""&gt;`, then you couldn't open up a new window accidentally.
Yes, I'm aware of the difference and how I structured the test, as this is the actual use case(s) in the comments prior. But why would anyone inline an operation like that in your test loop? We can go on all day about how to use this properly, but I have yet to come up with a real need for "noop." "noop" does not conceptually portray I am getting a **Function** nor that it will return **undefined**. Hindsight is 20/20. It's jQuery magic. I can hardly imagine this is a case of wanting to stroke 5 less keys through the entirety of a library; it strikes me more as trying to be cute or make javascript something it is not.
did Function.from replace $empty? 
An a without a href looks and behaves like regular text - it'll pick up your custom css but won't get any default stuff, including the hover behavior. Absence of hover clues, even on a link that doesn't yet go anywhere, steers the user the wrong way in my view.
Nice, thanks.
What browser are you checking this in? I've been using &lt;a&gt;'s without href's, especially in place of submit &lt;input&gt;'s and it works like a charm.
I am still not confused in what I'm testing. Look at the examples above and as you have reiterated, they all create an unnecessary complexity -- non-problem -- to champion the "noop" function. I have already provided the optimal solution to your dilemma in creating the new function. The solution is not only faster; it is clearer. I can write test too that exemplify as noop as bad. I am well aware you have read the docs, code, examples, and internal uses. However, that intuition was not the case when first seeing this here. The function sets a terrible precedence, where there are likely better solutions -- in the case of your tests, that would be not creating the function on every iteration. Luckily, many JS engines will soon roll up your solution into optimal call stack.
The href attribute defines a link between the current element (the source anchor) and the destination anchor defined by this attribute. Anchors without href attributes can function unexpectedly behavior-wise, depending on what you are trying to do. In most common cases, if you are going to handle the click event for an anchor tag, it's best to do something like &lt;a id="uniqueId" alt="description" href="#"&gt;text&lt;/a&gt; 
...and of course if you wish to prevent the default action but continue with bubbling: $("#mything").click(function(event){ // Do stuff event.preventDefault(); // Stops default action });
 &lt;a href="#null"&gt;foo&lt;/a&gt; 
Interesting though, that Mozilla, Opera and Internet Exploder use a more sophisticated Dom-Mutation event system, while Webkit developers ditch that in favor of performance.
Just checked in Chrome 8.whatever - it's as I said, Reddit's custom CSS is applied but otherwise it's regular old inline text. No cursor:pointer when hovered. Writing href=# works, but it affects back button behavior. The most innocuous thing is to use javascript:void(0), or javascript:$.noop() if you don't mind breaking portability for no obvious benefit.
I'm semi-agreeing. I hate appending a hash to the current URL. (with href="#"), but I also avoid using javascript: in the href just since I find it's messy. You can use CSS to set the cursor:pointer behaviour. And the idea that an anchor tag has to resolve at a destination seems archaic to me. I'm not a big fan of holding onto the past. (ie. Let IE5 die already)
How 'bout you do you own work, m'kay?
Can you tell me who said that? Why do we have so much enthusiasm for criticism and so much criticism for enthusiasm?
If things have already come to this, you probably shouldn't be pursuing this field. Web development is all about late nights and tight timelines. Not to mention you can't buy your way out of a client's project.
Right. I took the class for funsies and the last two weeks went way over my head in difficulty. I plan on walking out of the CS building head hung in shame, never to return.
var thingsYouKnow = ['jack', 'shit']; var whatYouShouldDo = ['get', '"javascript', 'the', 'good', 'parts,"', 'sack', 'up', 'and', 'read.']; alert("You know " + thingsYouKnow.join(' ') + ', and you should ' + whatYouShouldDo.join(' ')); Learn some shit n000000000000000000000000000b.
I use it with ternary operators, here's a very simple example: var x = Math.floor(Math.random()*2); (x===1) ? alert(x) : jQuery.noop();
Again, I understand my test and that it is testing exactly what you describe. That is the point. There is no reason to inline the creation of the anonymous, function creation. Just like it would be bad practice to check your iterator's length, every iteration, when looping over the members. Or not using memoization when computing Fibonacci numbers. My point is, I find your test to be testing something that should not have to be written. Please find how I would fix your test in [my comment](http://www.reddit.com/r/javascript/comments/ehunz/noop_derp/c187ook) much earlier in this thread. I find using function(){} to be more explicit; I don't know how providing a function that does nothing is not explicit. Having to provide the argument, at all, is more of an issue, to me. Finally, as I have stated, I don't mean to pick a bone with jQuery. It has done a lot for the community, and I have a lot of respect for John and his team, despite how Usenets feel. Nonetheless, I didn't find this function to be particularly elegant or worth publicizing, and it bothered me that many libraries will sometimes, at all costs, hide standard JS from developers -- usually those still learning. You and I can go back and forth, but this conversation has gone way beyond my intentions of championing raw JS, in this case, as opposed to using magical functions.
Well, you're asking about cleartimeout but not using it. Your problem is, every click sets a new timer but doesn't clear out the old one. Not seeing a working demo, and just making a best guess, I think you need something more like: var curSlide = 1; function slideshow(what){ if (typeof(slideTimer) != 'undefined') clearTimeout(slideTimer); if(what == null) what = curSlide; curSlide++; var nextSlide = what + 1; if(nextSlide &gt; 3){ nextSlide = 1; curSlide = 1; } var slide1 = document.getElementById("slide1"); var slide2 = document.getElementById("slide2"); var slide3 = document.getElementById("slide3"); switch(what){ case 1: slide2.style.display = "none"; slide3.style.display = "none"; slide1.style.display = "block"; break; case 2: slide1.style.display = "none"; slide3.style.display = "none"; slide2.style.display = "block"; break; case 3: slide1.style.display = "none"; slide2.style.display = "none"; slide3.style.display = "block"; break; } slideTimer = setTimeout("slideshow()",3000); } var slideTimer = setTimeout("slideshow()",2000); Also, the way you've written your code makes this rather inflexible. You have IDs for slide1, slide2, slide3... then accommodate those with a switch statement. What if you need it to work for 4 or 5 slides later? You have to change code in a few places. Yuck. If instead you gave them all a class of "slide", you could do something like: var slides = document.querySelectorAll('.slide'); for (var i=0, len=slides.length; i&lt;len; i++) { (i == what) ? slides[i].style.display = 'block' : slides[i].style.display = 'none'; } Now, if you just pass in the slide number instead of the ID name, you've reduced the size of your code and made it more flexibile. Just a thought.
don't forget to clearTimeout() too. Here's an example from [w3schools](http://www.w3schools.com/js/js_timing.asp). You didn't include your click logic so I can't diagnose that.
First, you should consider using a framework for this kinda stuff. Second, when you click the link it never clears the timeout, so you make the clicked tab visible and set another timeout. Sometime shortly after clicking the original timeout is run, and before the new one gets run, the first one sets another timeout. Basically setTimeout will return a variable that you should be passing into clearTimeout() when the user clicks a button.
You code doesn't even address the issue of 3rd bullet. Please don't expect people to write your code. After you have written something, maybe then we could help out. Please come back after you have tried to implement it yourself.
EDIT: the if (typeof(slideTimer) != 'undefined') clearTimeout(slideTimer); solution does work. THANKS thanks. js is not my native tongue. i tried your if (typeof(slideTimer) != 'undefined') clearTimeout(slideTimer); suggestion but im still having the same issue. i know the switch statement is cumbersome (i know i will only have 3 slides) but i will use your statements because its nicer. so thanks. 
Did you make sure, in addition to that if (typeof) line, that you added slideTimer = before your setTimeout statements?
i thought it was pretty self explanatory. here is the click code if it makes you feel better &lt;li class="button" id="1" onclick="slideshow(1);"&gt;&lt;/li&gt;
a framework would be overkill for what im doing. this is a lightweight solution.
http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-0 That `TextMetrics` thing over there and also `fillText` with `maxWidth` parameter. You can also do that with the DOM. Change, query size, change, query size, etc, etc... it's amazingly slow. Well, it's pointless and looks like crap anyways.
I believe it's simpler than that: the first line is left-aligned and the second line is right-aligned. If there are three lines, the middle line is centered. The hardest thing would be dividing the line into two or three roughly-equal parts.
Again, my test tests what you have and everyone will understand it to be testing. There is no mistake on what it tests. To state "it's not testing anything," flies in the face of your previous statement of what it DOES test. In the same way, I can state your test will not test anything, unless as an example of what not to do -- create a function when called more than once (iterated, in this case). But you continue to ignore my final ("optimal") solution and only want to support your test of a non-issue, but please see your test (modified) that actually tests what I would expect to see in a case where such an optimization would benefit from "noop" -- btw, thanks for the tool. http://jsperf.com/function-literal-vs-jquery-noop/2 The tests are only relevant within the context of the argument you and I are not having. The jQuery team is welcome to run their show as they please. I'm not here to tell jQuery they have to wear pants around their own home, and I will wear pants when I'm in their home. The problem is when our not wearing pants at home starts to leak into the public domain. By definition, *function(){}* expresses directly and independently its function -- explicitly. Why should my descendants or my co-workers to have to understand a 3rd party, library call or make the weak connection with an ASM instruction, when I can explicitly express the value? Lastly, this is all a non-issue when we consider that our libraries shouldn't require a callback. Thankfully, we have to worry a lot less about these cases with better heuristics and JITs in developing compilers (V8, etc), but that 
did someone say my name?
Someone must have. What do birdies see when they faint?
If you're going to tell someone to use a framework, it would make sense to give a reason why in their case that would be beneficial. 
[this might help](http://www.bramstein.com/projects/typeset/flatland/). check out the links in the top right to see how they did it.
 &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Headline Alignment&lt;/title&gt; &lt;style type="text/css"&gt; .container { width: 250px; min-height: 200px; border: 2px solid black; padding: 10px; font-size: 12px; font-family: sans-serif; } .container h1 { position: relative; height: 1.2em; overflow: hidden; line-height: 1.2em; font-size: 2em; margin: 0; padding: 0; background: white; } .container h1.line1 { text-align: right; height: 2.4em; } .container h1.line2 { top: -2.4em; margin-bottom: -1.2em; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;h1 class="line1"&gt;This headline is aligned as you like&lt;/h1&gt; &lt;h1 class="line2"&gt;This headline is aligned as you like&lt;/h1&gt; &lt;p&gt;Hacky css-only way of laying out your headline.&lt;/p&gt; &lt;p&gt;Note that you have to enter it twice, and we assume that it's two-lines high.&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
on page load, you could measure the height of your headline with javascript and create the appropriate number of copies to generate something like the above. (e.g., maybe give your original headline a class "fancy-headline", then find all elements with that classname, creating copies and applying styles via javascript as necessary. That way it fails gracefully) But it's still hacky and most likely a bad idea :)
What is this: &lt;&lt;initialization&gt;&gt; Are these templates or something? I really think this is an over engineered framework, anyone else favor simpler organization of your javascript code instead of trying to bring in strict practices that work much better in server side languages?
FWIW, [JavaScript is the most popular language on github](https://github.com/languages/JavaScript)
"B" works just fine in AS3, from what I can see. As far as obscure/unknown environments, I can understand why function expressions wouldn't work (they were introduced only in ES3, not ES1/2), but I see no reason to assume that "A" is somehow safer than "B". Both constitute function expression; it's just a matter of where grouping operator — "(" and ")" — is applied. So again, having "B" as a personal preference is perfectly fine of course, but there's no reason to recommend it in favor of "A", as a superior choice ;)
Clearly this protocol just needs more XML. 
What I'd prefer is a simple method of performing the equivalent of telnet in a web browser.
95% of the time I see something like this and go "well, that certainly seems worse than the problem it's trying to solve" then I immediately remove the memory and continue onward.
Sad to see such an awesome new feature be shelved. Then again, it is for a good reason. The link he posts to the security vulnerability also details how to avoid it. I wonder how long until it's fixed, and if it will be in time to be implemented in FF4.
As someone briefly mentioned in the article's comments, if your code falls back to flash-sockets if window.Websocket doesn't exist, and long-polling ajax if flash is disabled, you shouldn't ever notice the change (other than slightly slower responses in the case of flash, and moderately slow responses in the case of long-polling). It still makes me a sad panda to see this removed for now, but there are plenty of workarounds.
I believe it's been stated that this exploit exists in Flash's socket implementation as well. So long polling only?
No, they're Literate Programming marks, tools for instructing people in how to read source code. They're neither language-specific or relevant to Backbone.
The exploit exists, sure, but I doubt that Adobe is going to drop websockets because of it - what the browsers do doesn't have any bearing on the Flash runtime. If Adobe has stated a contrary position, I'm not aware of it.
It's not being shelved, it's being temporarily disabled.
This is the kind of thing I like to imagine when working in non-lisp languages: code in a pre-language that you can then transform with macros.
Fuck it, just give us some damn sockets already plz.
why the downvotes...people don't recognise sarcasm? And who actually _likes_ XML!
That's what shelved means
&gt; And who actually likes XML! ‎"Java is a DSL for taking large XML files and converting them to stack traces"
Goddamnit! I read the headline as "We've decided to disable support for Wikileaks in Firefox 4" Damn reddit.. 
To me, shelved implies more permanence, but that just might be me.
Don't use return false. If you have two events bound to that element, the second item wont fire. Instead use $('element').click(function(e){ e.preventDefault(); ...code here }); Edit: I'm retarded.
So the exploit exists...so don't use Flash's websockets. That's what I'm saying. If we're all so uncomfortable using HTML5 WebSockets, we need to fall back to long polling.
Backbone.js is really quite a minimal framework. It more or less does the bare minimum to construct a usable MVC framework and lets you override everything fairly painlessly. I only needed to overwrite Backbone.sync for a project I'm working on, then the rest lets me do whatever I want while still providing me the structural support of MVC.
That's not true - multiple events bound to that element will fire. Only other events - bound further up the tree - won't fire. If you wish to stop other events on the same element from firing you have to do: `e.stopImmediatePropagation()` (which `return false` does not do).
I love me some lambda expressions, very cool. But for all practical purposes, if "code is read more often than it is written", it's by coders who would will likely have know idea about the custom syntax and will spend any time gained, many times over, just trying to read and learn it. In the real world I prefer an IDE take care of the keystrokes problem with snippets and leave the standard syntax in place. But still, great work, the things people are finding that can be done in JS is downright amazing. Is there anything it can't do?
&gt; It does this by running a regex-based parser over the source and feeding it to eval(). AH HAHAHAHAHAHA "eww" is right
Oh, fail on my part! Sorry here is the link: https://github.com/matthewd/capuchin
Note: Don't get impatient and click more than once. It'll break the whole layout.
Where can I download your framework, `herpderp.js`?
Ah yes, I stand corrected. Thanks for the clarification.
you can get performance boost by using the following version (function ($) { var replaceText = function() { var self = $(this); if (self.children().length == 0) { self.html(self.text().replace('NAME', '&lt;font color="red"&gt;NA&lt;/font&gt;&lt;font color="green"&gt;ME&lt;/font&gt;')); } }; $("*").each(replaceText); }(jQuery)); Working example here http://jsbin.com/iruta4/2 The performance boost will be negligible for fewer DOM elements, but it saves a lot of time on a large page. 
I declare this Totally Sweet. I don't care about the actual content, but the fact that you essentially used javascript and php to doctor the local presentation of someone else's page is pretty awesome. I salute you.
That's pretty ew, but this is one of the few cases where using `eval` makes sense. You're parsing code that is meant to be executed. The only alternative would be to implement JavaScript _in_ JavaScript, which would be silly. If you want to extend the underlying language, you have to run the modified code through an interpreter at some point.
It's explained it in the third paragraph &gt; A note: this article was written with the Literate Programming toolkit Noweb. Where you see something that looks like &lt;this&gt;, it’s a placeholder for code defined elsewhere in the document. 
I believe you are looking for [Onunload method](http://msdn.microsoft.com/en-us/library/ms536973\(v=vs.85\).aspx)
there's also [onbeforeunload](https://developer.mozilla.org/en/DOM/window.onbeforeunload) but it's non-standard.
To save you some time, since most of the reasons for wanting to know if your page is about to get unloaded revolve around 2 major themes: 1. You want to warn the user that leaving the page now would have dire consequences. You want an onbeforeunload event handler. Too bad some browsers will entirely ignore it. 2. You want to fire some network request to your server so you keep your server state as consistent as possible. You want an onunload event handler coupled with a synchronous XHR request. Please use a short timeout in the request for those browsers that support it, as you will effectively freeze the browser until your request is done. 
While you're adding syntactic sugar to JavaScript, you might as well go all the way with [CoffeeScript](http://jashkenas.github.com/coffee-script/) which compiles into JS. It's easier to deal with an established, well-documented syntax than to invent your own obscure thing. In CoffeeScript: square = (x) -&gt; x * x "Compiled" into JavaScript: square = function(x) { return x * x; }; 
2^16 is not too much for any computer, so you can just brute force trough. i dont really understand what you want to do, care to explain further? E: ad hoc, id take an array of 16 booleans, and then cycle through all combinations. 
I guess to be more clear, let me provide the context-- I'm trying to learn javascript by doing fun stuff with it. This script is for me and 4 friends who place a small bet each week on all 16 NFL games. We have to assign each game a point value from 1-16 (no numbers can be repeated), and pick a winning team. If we pick right, we get the number of points we bid; nothing happens if we pick wrong (no penalty.) For example, if STL plays SEA and CHI plays NE, I might pick STL for 1, CHI for 2. If CHI wins, I get 2 points; if SEA wins, I get 0. We total the points, and whoever wins gets the whole pot. (The points dont' equal money, we bet a fixed amount, and then the most points wins it.) The formula is meant to figure out when someone is eliminated from having any possibility of winning. I have tried two different formulas without using a script, just doing functions in excel. The first looks at all unplayed games and calculates what will happen if any player gets all the rest of his picks right. But that isn't a true best-case scenario, because winning all of your picks may actually be *worse* for you if someone else bid more than you on the same team. (For example, if you're losing 50-45 against one other person and you picked Chicago for 6 but the other person picked them for 15, then you actually want to lose this pick.) As long as this formula predicts that you're alive, it is reliable, but when it says "eliminated," it may be premature. So the second formula I came up with looks at a true best-case scenario between you and any given single opponent. It looks at all unplayed games and adds the results of that game ONLY if player A bet more than player B. This formula works between any two players, but it doesn't take into account the fact that it may be impossible to have a "best case scenario" against two opponents at the same time. So this one is accurate as long as it says you're eliminated, but when it says "alive," you may not be. I still think there might be a more elegant method besides brute force, but I can't think of what it would be. So my next idea is to simply check, for all remaining unplayed games, is there a single combination of wins and losses for which you will win? So that's what I'm trying to do here. When I say I'm looking for methods, I mean, is there some kind of "math.permutation" or something? I've tried googling, but I don't understand a lot of what I find-- there are scripts, but they don't have much context with them, and I don't understand a lot of what I'm seeing.
This sounds like a job for MapReduce! *Cue superhero music.*
&gt; is there some kind of "math.permutation" no, you'll need to `for` loop over your set to construct the possible perms. Try it with a simpler case first, eg producing all possible variations of 'abc', and then maybe you'll be able to apply that to your problem.
thanks :) (though I didn't use any php, only javascript)
Nice library. It makes me want to start experimenting with canvas manipulation.
Go for it, it's a lot of fun! Editing the canvas isn't too difficult, but making all of this work with web workers was a challenge (my friend [@rwaldron](http://twitter.com/rwaldron) helped me and did most of the web worker implementation).
My numbers were: Brightness: 1426ms Colorize: 1796ms Contrast: 2373ms Hue: 3524ms invert: 1445ms saturation: 1583ms sepia: 1879ms I have a 3ghz core2 duo, and 4gb of ram using chrome stable. Regardless very cool test, web workers seem awesome
take an array of 16 booleans set at 0, then increment in the way binary numbers do. the increment function is easy, just run through the array and switch all 1s to 0s, until you hit the first 0, at which point you make that a 1 and return that array. e: static boolean next(int[] A){ for(int i = A.length-1; i &gt;=0; i--){ if(A[i] == 1 ) A[i] = 0; else{ A[i] = 1; return true; } } return false; } this gives you all the combinations of 1's and 0's and also returns false when they are starting over. while( next(A){ do stuff } 
It could have something to do with Mozilla's optimizations against its own [kraken benchmark](http://krakenbenchmark.mozilla.org/) - which also does image manipulation. Also FF4 is really [no slouch](http://arewefastyet.com/) on its own on the 2 traditional benchmarks.
Very cool, thanks for the link! I hadn't heard of the Kraken benchmark.
&gt; No, your test does not test what I did...it does nothing...it's not testing anything. Again, it also has nothing to do with the topic at hand. Our test are not the same; I don't state that they are the same. My test does test something, otherwise you wouldn't have stated what it does test -- mapped pointers. It has everything to do with the topic and you trying to shoehorn "noop" as a necessity. &gt; Obviously they shouldn't when possible. Unfortunately that's not always possible, or at least not the cleanest solution. Yes, some libraries may require you provide a callback -- none that I use. Maybe you know of some? jQuery? I think it's a mistake and the prescribed solutions are simply creating a problem atop a non-problem. Why should we breed this into the JS community? Why is jQuery -- the most widely used introductory library -- teaching an anti-pattern and championing it here? No offense, but you can save me the explanation and condescension. I am not confused. I read your edit, and it does not address that the falsy test is ALWAYS an option and ALWAYS faster for the developer of the inner-loop. If you must use this library, surely it is open source and you can get it changed or not use the function. I can't recommend future development to propagate the usage of "noop" -- unnecessary "elegance" and an anti-pattern. If we are calling empty callbacks so often in a tight loop, then my proposed pattern is, at least, faster than the rest. If you are writing this pattern yourself, then start by writing the callback call using a falsy test, as I have proposed. You continue to ignore that my proposed solution is not to your test but rather the author to which I initially replied. In other words, I am proposing tests to real examples and problems. Your tests, while I am not suggesting they test nothing or are testing the same thing I am, are testing problems that should not exist in the first place.
2.66ghz core i5 4gb ram Chromium 10.0.602.0 (68277): Brightness: 972ms Colorize: 1233ms Contrast: 1724ms Hue: 2741ms invert: 971ms saturation: 1082ms sepia: 1254ms ie9 beta: DNF 
Yeah, IE9 doesn't support web workers yet :(
[Data above as diagram](http://chart.apis.google.com/chart?cht=bvg&amp;chs=650x250&amp;chds=0,4500&amp;chd=t:2197,2589,3369,4419,2021,2381,2558|460,515,1403,3139,499,792,614&amp;chbh=20,5,20&amp;chco=00AA00,AA0000&amp;chdl=Chrome%209.0.597.16%20dev|Firefox%204.0b7&amp;chxt=x,y&amp;chxl=0:|Brightness|Colorize|Contrast|Hue|Invert|Saturation|Sepia|1:|0ms|1000ms|2000ms|3000ms|4000ms|5000ms)
Try [jQuery Fundamentals, starting at Chapter 3](http://jqfundamentals.com/book/book.html#N206E1)
Sweet, everyone loves diagrams :D Your chart inspired me to add a graph to the benchmarking page itself that's generated using the awesome jQuery flot plugin once all the tests are finished.
Feel free to put it into your initial post. Would be a bit more convenient for others. :)
I'd definitely recommend this too. Rebecca Murphey does a good job of laying out all the important points of jQuery along with good examples along the way too.
If speed/rendering is an issue, there is an implied eval call at setTimeout("slideshow()",2000); due to the function parameter being a string. It's a very old practice that's practically rageworthy that it still continues. Try removing the quotes, if that breaks the app, try removing slideshow's parentheses. setTimeout(slideshow(), 2000); OR setTimeout(slideshow, 2000); will work.
Another vote for Rebecca Murphey. She's awesome.
Yes, onbeforeunload, but you can't get the URL of the new page, sadly. Fucking same-origin policy retardedness.
I work with one of the guys who wrote this book, if you like it i am sure he would appreciate if you bought a copy :) 
This is the only book you need. Seriously. But if your insatiable thirst for jQuery info is still looming, check out [Advanced jQuery](http://james.padolsey.com/stuff/jQueryBookThing/) as well.
http://sale.sitepoint.com/ It is on sale now as well! Since the original comment has been deleted he was advocating jquery: from novice to ninja. However, included a link to a "free" version hosted on rapidshare :)
As far as I remember, the code is written that way because it is meant to be compiled by the Closure compiler, which would make the appropriate optimizations, and thus readability is what matters most.
I love my [jQuery Cookbook](http://www.amazon.com/jQuery-Cookbook-Solutions-Examples-Developers/dp/0596159773)
Reading the comments is more valuable than the article itself. Most of the article arguments relate to micro optimizations (forget that the library ships with a custom made "compiler" and that they certainly don't care too much about optimizations that would be meaningful mostly for IE), how to circumvent stupid hacks (undefined=true). If you look at the byId implementation of the library, you will see that they do not try to fix the bug where IE returns an element that contains a name with the same value as the id searched if the id does not exist. This is not an oblivion, but a deliberate choice and a wise one imo. The library source code in itself is very easy to read,which, is definitely a plus. The library doc needs work though... 
FWIW I agree that it's an excellent book, although it's probably not what the OP needs, as it is starting in the basics, and the book is definitely worth buying.
In defense of this practice, this is pretty much exactly how [processing.js](http://processingjs.org/) works, or how pure javascript implementations of JSON.parse() are usually written. 
i'm actually very glad that you can't get the URL i'm going to. hooray for same-origin policy!
I'd be ok with that, as long as there is a small comment in the code stating something like, "compiler will optimize the following block". And it may for all I know, I admit that I am too lazy to look ;)
i'm not sure it has something to do with webworkers. but i'm pretty sure it has something to with tracing :) let me guess: there are a lot of ... for (var y=0; y&lt;480; y++) for (var x=0; x&lt;640; x++) doSomething(im, x, y); ... style loops in your code? tracemonkey *excels* at optimizing them. chrome is often faster than tracemonkey because they just compile everything into native code - even code that's called only once. the compiler - v8 - is pretty fast, so it's not a big problem. tracemonkey on the other hand just interprets code and collects data about the code paths that are taken (and the types used in it and other things). as soon tm is certain that optimizing the loop will pay off, it compiles it with *a lot of optimizations*. lots of aggressive inlining and stuff. also, at this point it knows a lot about the data types used in there, so if they don't change a lot several of the performance drawbacks of dynamic typing can be optimized away. otoh not-hot code won't get compiled because compilation has an overhead and doesn't yield much. that leads to tracemonkey being slower in the general case and faster in special cases. so, chrome does lot's of expensive function calls in tight inner loops. tracemonkey does not. voila - ff speed demon. ---- **the near future:** firefox also provides a baseline jit compiler, jaegermonkey, that roughly does what v8 does now. compile everything (more or less - works on a function level, not sure about the details). jm+tm are working together though, so it should bring best of both worlds. not sure if tm+jm already work together in current betas. **the other near future:** chrome gets crankshaft, some kind of multi-phase compiler. first, when the web page is loaded, it does a very unoptimized compile that doesn't take much time and comes with a runtime profiler. as soon the profiler identifies hot code it will be recompiled by a different, probably slow (but that doesn't matter anymore at this point) optimistic optimizing compiler, that churns out blazingly fast code. see [blog.chromium.org/2010/12/new-crankshaft-for-v8.html](http://blog.chromium.org/2010/12/new-crankshaft-for-v8.html). **nice bonus:** crankshaft is especially interesting for node.js! with node, you can more or less disregard startup/initial compilation times *(java/jre startup overhead victims may not agree, but we're talking about a different order of magnitude of startup slowness here)*, but heavily benefit from the optimizations. yaaaay!
Just so you know in Opera 11 the test fails at the second saturation iteration. The results are: brightness: 212ms colorize: 248ms contrast: 720ms hue: 5669ms invert: 209ms saturation: - sepia: - 
Good to know, thanks. I'll download Opera 11 and take a look myself.
Year old articles, perfect for the fast paced web world.
&gt;Google’s developers seem to have figured this trick out later on in the same file. From array.js, line 153: &gt; &gt; var l = arr.length; // must be fixed during loop... see docs &gt; ⋮ &gt; for (var i = l - 1; i &gt;= 0; --i) { &gt;**This loop is better in that it avoids a property lookup each time through the loop** ... Uh, what?? Even the plain and simple for (var i = arr.length - 1; i &gt;= 0; --i) { will look up arr.length *only once*. Whatever reason the Google team used to use this trick, avoiding to look up that property more than once is not it. 
Have you benchmarked this? I doubt it. It actually tends to be slower. But this is still a terrible article since Closure comes with a minifier/compiler thing that will fix some "unoptimized" code including this example.
Really? I create private Java methods that are only called from one location in order to improve readability and I don't write "compiler will dynamically inline this method so it is okay". Developers should err on the side readability and then document functions that are optimized to explain why they are non-standard.
My ghetto benchmark: &gt; z = [1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9] =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt; x = new Date; for (j=0;j&lt;100000;++j) { for (i=z.length;i&gt;=0;i--){}; }; new Date() - x =&gt; 1379 &gt; x = new Date; for (j=0;j&lt;100000;++j) { for (i=0;i&lt;z.length;i++){}; }; new Date() - x =&gt; 1822 &gt; x = new Date; y = z.length; for (j=0;j&lt;100000;++j) { for (i=0;i&lt;y;i++){}; }; new Date() - x =&gt; 1737 Ran these a few times and the results didn't vary by more than 50ms.
A few times? Not to mention with a trivially small array?
The init part of a for loop is only executed once. That's the whole point of that part. Imagine for(i=0;i&lt;3;i++) would randomly restart at 0. Would be silly, right? By the way, I prefer this one: `for (i = a.length; i--;)`
I commend you on the fact that you posted your comment on StackOverflow rather than reddit directly. Though you should have made it a self post and put the link in the post text. This way you wouldn't be getting karma for the help others may potentially give you; self posts don't earn any post karma. 
I didn't even think of that. I guess karma doesn't really mean anything to me. Thanks for the advice though. I will follow that in the future.
If I write something that looks very suspicious/dubious, but it was done for a very non-obvious and important reason, then it deserves a comment explaining why it was written that way and why the reader should not cleverly "optimize" it away. IE "This code looks funny because of XYZ, so don't change it." That's all I was trying to convey. Your example is very common and obvious as to why you would be doing that in your code, so it doesn't really apply.
Please don't do that. There really is no reason to. And you'll be working against the domain categorization feature http://www.reddit.com/domain/stackoverflow.com/
Ideally, you would have had this post link to an SO question to the tune of "Can someone comment on my post at reddit?" Then we would have completed the bonus stage. 
Chrome 8.0.552.224 beta brightness: 3225ms, clip: 1461ms, colorize: 1875ms, contrast: 2490ms, gamma: 1896ms, greyscale: 1792ms, hue: 2000ms, invert: 1523ms, noise: 1751ms, saturation: 1633ms, sepia: 2097ms Chrome 10.0.607.0 canary build brightness: 1307ms, clip: 1282ms, colorize: 1696ms, contrast: 2316ms, gamma: 1777ms, greyscale: 1643ms, hue: 1879ms, invert: 1303ms, noise: 1596ms, saturation: 1677ms, sepia: 1735ms 
Note that your preference is slightly more fragile as it will break if the array size changes during the loop.
Removing the current item works fine with that loop (or reverse loops in general). The same thing is of course also true if you do the length assignment before the loop.
A relatively simple solution: your system checks if the value == 'stock'. JavaScript is not case sensitive so you could simply change this to 'Stock' or modify it in some other way such as 'in-stock' or 'stock-accepted to note that you have already accounted for it. Then whenever you run your function again these would be rejected. For example: for (i=1;i&lt;=lastRow;i++) { if (data.getCell(i, 5).getValue() == "stock"){ for (n=1;n&lt;=iLastRow;n++){ if (data.getCell(i,3).getValue() == i_data.getCell(n,3).getValue()) { i_data.getCell(n, 1).setValue(i_data.getCell(n,1).getValue() + data.getCell(i,2).getValue()); data.getCell(i, 5).setValue("in-stock"); } } } } I would reccommend using the 'in-stock' method, so you can add .toLowerCase() functionality and make your function ignore case all together. Also note I've not coded for Google docs before so my line setting the value may need tweaking but in theory is sound.
I think the node way of doing things is (will be) that blatantly expensive tasks should never block the main event loop, just like how IO should never block. Heavy-lifting should be offloaded to a worker thread via a callback. That said, node definitely needs a native worker implementation.
Very weird idea to test your code in a simulated environment ... [jsTestDriver](http://code.google.com/p/js-test-driver/) is way much easier to incorporate with both jasmine and a continous integration flow. It is also more accurate (real browsers) and very fast. If you use Aptana with the jsTestDriver plugin, you can run all the tests in all the servers each time you edit a file. it's such a breeze!
You can't say "The best framework" in any title, anywhere. Expect downvotes.
isn't there a current worker implementation? Or at least a node-worker library? What's wrong with it?
Recursion! Recursion! Recuuuuuuuursion!
If it wasn't the fanboy incendiary title that did him in it was the site with a total lack of apparent content.
If node is shipping with a native worker module it's news to me. But yeah probably there's a library for it.
And... unresponseive script error in Firefox. 
https://github.com/pgriess/node-webworker it is great, but might not play nice with coffeescript
that is a common javascript pattern, indeed.
The code isn't wonderful, but I thought you might enjoy seeing an unusual application of JS.
... I remember when I wrote that comment there being a very good reason why I thought you had used php. I could have sworn. Oh well. I choose to believe that someone hacked your site long enough to put a random php file on it right when I looked and then deleted it again to make me look bad. The bastards. Anyway, my relative sanity aside, great job.
"I just don't see myself needing inheritance yet in my development."
The article was super interesting and very informative to someone like me who has had little contact with machine learning. Really appreciated it!
Good read; thanks :-) I wrote a [similar article](http://www.tomnomnom.com/posts/methinks_it_is_like_an_incestuous_weasel) some time ago, but with a different phrase and with PHP
I wish I'd thought of using the phrase "little string people" to describe the population. Awesome.
Neat. The only part I don't really get is this bit: &gt;So in strict mode, implied global variables are no longer created. You should explicitly declare all of your variables. Why do we need to explicitly declare variables if they're no longer assumed to be global?
Cool! back in 2001 I had learned about [JAPHs](http://en.wikipedia.org/wiki/Just_another_Perl_hacker) and started playing around in Flash Actionscript (mostly identical to Javascript) to create JAFHs. At one point I decided to try to write a genetic algorithm, though I had seriously lacking mathematical skill (still don't know much). I had heard somewhere randomly that any curve could be plotted as a sum of cosine functions, so I decided to use `a × cos(b) + c` as my element, create an array to hold them, and made mutation functions that would - based on a random unit value - fire off adding or subtracting a gene (trying to keep it to a handful by weighting a low or high number of elements as poor results, and keeping the percentage of time that adding/subtracting happened to a minimum), or tweaking a random constant in a random cosine function (a, b, or c). Then it would run a for loop from 0 to len('Just another Flash hacker') and kick out y values based on my cosine function. I had the curve I wanted - the ASCII values for the phrase - plotted in the background, the current ASCII phrase spelled beneath it, and the current sum expression below that, and it would update the curve in the foreground any time the expression changed. Pretty quickly it would hone in on the target, but as it got close, it would always sacrifice a value or two to get many of the rest a lot closer. One value would shoot away from the target curve, and the rest would slightly close in. I'd end up with things like "Jas- anogetr alash hockhr" before it finally gave up, never finding a closer match. I mentioned it to a programming friend years later, and he suggested I step by 2, so it sacrificed the values between what I cared about. It would take some work to get that going, and I haven't had the free time or inclination to really try it out, but it sounds like a good working theory.
Incidentally, I recently put together a couple of JAMHs (Just another Mel hacker) using Mel (Maya Embedded Language) in Maya, the 3D app I use at work. Here they are: proc _(int$_){print(substring(`whatIs _`+"Jshk\n",$_,$_));};int$_;for( $_ in{37,11,38,17,4,28,16,7,17,39,2,6,4,1,2,3,4,39,28,8,40,2,6,41})_$_ int$i,$j,$p,$m[]={1049358222,289141117,948693009,238622686,0,143262225,423924033,81397777,289743889,0,143385119, 356818809,953927711,524404638,0,680010257,323260737,145360913,289743890,0,956031505,288919933,76279697,288954321 ,0};for($i in$m)if(!$i)print"\n";else for($j=30;$j--;){$p=pow(2,$j);print($i&gt;=$p?"%":" ");$i-=$i&gt;=$p?$p:0;}//G:) The first steals letters from the result of a whatIs call of itself, which prints out that it's a user created function, and gives me most of the letters necessary, to which I add the rest. The second actually prints out the phrase in % symbols, like ASCII art. I got the 'pixel' positions with a call to [figlet](http://www.figlet.org/) (I forget the font now). Then I treated runs of 30 (31?) pixels as 0s and 1s and turned them into ints. The rest of the code just shifts those back out and prints the % or a space.
My understanding was that it would just break if you didn't use `var`.
JavaScript getting more like Perl all the time - Yay! If only PHP could do this too (I know why it can't - so please no flaming).
Because you can't have a statement mean one thing in ES5 and something completely different in ES3. Remember that "use strict"; does absolutely nothing on older browsers.
Finally. I really want JS to be faster, much faster. Strict mode is the only way to do that.
This is amazing!
John Resig you are my hero!
NOTE: does not support most browsers. Tried with -Chromium for ubuntu -FF for ubuntu
While no doubt it's awesome, would really be over the top if it was interactive, so you could grab it and spin it.
It just froze my browser. :-(
Ow, my CPU!
All I'm seeing is "Merry Christmas." Maybe Chrome doesn't like it.
i'm not having any problems, try updating
9.0.597.10 dev. Maybe the Linux build doesn't like it xP
it worked for me using the latest Chromium nightly on Ubuntu... it did take a little while to load all the textures etc... also I have GPU acceleration flags turn on in the about:flags page.
You may need to launch chrome with --enable-webgl to make it work.
Works great on Firefox 4.0b7
Well done! Very clever techniques at play in this demo.
http://www.romancortes.com/blog/how-i-did-the-1kb-christmas-tree/
I was going to originally write "if only the JS 1k contest was pushed up a few months"...then i saw the URL. touche OP.
Seems to run about the same in Opera 11 and Chromium 9. Awesome!
Ditto. 9.0.597.10 dev on Win7 doesn't work.
8.0.552.224 and 9.0.597.19 dev runs it fine for me.
thanks, I couldn't figure out why it wasn't working even with the latest beta.
source code: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JS1k, 1k demo submission [856]&lt;/title&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="c"&gt;&lt;/canvas&gt; &lt;script&gt; var b = document.body; var c = document.getElementsByTagName('canvas')[0]; var a = c.getContext('2d'); document.body.clientWidth; // fix bug in chrome. &lt;/script&gt; &lt;script&gt; // start of submission // M=Math;Q=M.random;J=[];U=16;T=M.sin;E=M.sqrt;for(O=k=0;x=z=j=i=k&lt;200;)with(M[k]=k?c.cloneNode(0):c){width=height=k?32:W=446;with(getContext('2d'))if(k&gt;10|!k)for(font='60px Impact',V='rgba(';I=i*U,fillStyle=k?k==13?V+'205,205,215,.15)':V+(147+I)+','+(k%2?128+I:0)+','+I+',.5)':'%23cca',i&lt;7;)beginPath(fill(arc(U-i/3,24-i/2,k==13?4-(i++)/2:8-i++,0,M.PI*2,1)));else for(;x=T(i),y=Q()*2-1,D=x*x+y*y,B=E(D-x/.9-1.5*y+1),R=67*(B+1)*(L=k/9+.8)&gt;&gt;1,i++&lt;W;)if(D&lt;1)beginPath(strokeStyle=V+R+','+(R+B*L&gt;&gt;0)+',40,.1)'),moveTo(U+x*8,U+y*8),lineTo(U+x*U,U+y*U),stroke();for(y=H=k+E(k++)*25,R=Q()*W;P=3,j&lt;H;)J[O++]=[x+=T(R)*P+Q()*6-3,y+=Q()*U-8,z+=T(R-11)*P+Q()*6-3,j/H*20+((j+=U)&gt;H&amp;Q()&gt;.8?Q(P=9)*4:0)&gt;&gt;1]}setInterval(function G(m,l){A=T(D-11);if(l)return(m[2]-l[2])*A+(l[0]-m[0])*T(D);a.clearRect(0,0,W,W);J.sort(G);for(i=0;L=J[i++];a.drawImage(M[L[3]+1],207+L[0]*A+L[2]*T(D)&gt;&gt;0,L[1]&gt;&gt;1)){if(i==2e3)a.fillText('Merry Christmas!',U,345);if(!(i%7))a.drawImage(M[13],((157*(i*i)+T(D*5+i*i)*5)%W)&gt;&gt;0,((113*i+(D*i)/60)%(290+i/99))&gt;&gt;0);}D+=.02},1) // end of submission // &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; With some futher optimizations I think it might actually fit into 1024 bytes :)
&gt; Strict mode requires that all variable binding be done statically. That means that the features that previously required dynamic binding must be eliminated or modified. What?
One frame per 3 seconds on the iPhone 4. 
i love slickgrid. there can be a bit of a learning curve, but it's amazing when combined with an mvc. i worked with it on an enterprise project and now i'm using backbone.js and slickgrid to churn out apps in a few days
10.0.606.0 on linux, works great
thanks for that
Chrome is so weird. I had been closing tabs trying to figure out why I was at like 80% cpu, when I accidentally clicked on that link. After it loaded and I closed that tab I'm at 20%. WTF? (that aside, awesome work).
I read on Reddit recently that Microsoft made a similar browser demo. But now I can't find that comment. Anyone know what they were talking about?
I've been doing some work with Groovy lately, and I have to say that I find the Groovy syntax for closures to be quite nice. example javascript function function (a,b,c) { doWork(a,b,c) } equivalent groovy style {a,b,c -&gt; doWork(a,b,c) } Though, the javascript syntax isn't really so bad that I would bother to make my own parser/code modifier to replace it.
Maybe it's the graphics acceleration. I might get unlazy and disable that to check.
Yeah this one is very cool, put my tree to shame. http://js1k.com/2010-xmas/demo/849 he posted his like 30 mins before mine too lol, i was too far completed to just give up though.
that would be insanely hard to implement within the constraints I imagine, and not lose something else in the process. But cool i agree.
Chrome just aggressively pre-caches... 
Looks like StarFox!
haha yeah, was making it really basic. My wife says it looks like the star is just shining beams down.. not really like a Christmas tree :?. Not trying to hijack this reddit post though, Roman Cortes tree is friggin badass.
nice, different than i assumed, i assumed it was just a bunch of lines attached in a pattern of varying lengths. Using billboard sprites was definitely a good idea.
This really is quite spectacular. And the performance difference between FF4 and Chrome is disappointing, but not surprising. 
awsome !!!
Well, that way the code would have been even more little, and would work without a lot of changes for static image rendering. But, the rendering time would have been much longer... and definitely not realtime. Right now it is rendering about 2k sprites, and its speed in Chrome is not specially bad for being software rendering (not impressive performance compared to native code software rendering in any case, and ridiculously slow compared to hardware accelerated rendering). Trying to draw directly the lines, it would need drawing near a million of them... with luck Chrome would render an image in 10 seconds... it will be the way to do it realtime in JS1k year 2020 edition :)
I developed the thing in linux, with the latest Chromium, but then I tried it in a lot of different browsers, including Windows browsers, and it seems to work. One thing needed in linux is the font Impact, from the MS Core fonts package, but I don't think this could be your problem
Impact is the only part that seems to be showing. I'll disable the graphics acceleration and see what happens. edit: That was it! Absolutely lovely effect, and really really cool. Now to go back and re-enable ;)
I downloaded the latest Chromium for OSX (Snow Leopard), entered the URL, saw the rendered body, spun it around, and just as I was about to praise how smooth WebGL was, my whole computer froze. Damn!
I liked yours so much (I'm Roman Cortes), I just think it would look much better adjusting the color palette. As a 3d engine, yours is much more complete than mine for example. I didn't used perspective, nor triangles, and it is not easy at all to fit a 3d engine in 1kb... in fact, I think there are just 2 or 3 filled triangle engines in the js1k compo, including the original compo, and yours is the one with the most complex 3d model on it. So, it is definitely an achievement. What I think fails a bit, is not your code here, but the fact that triangles have never been and are not the best suited shape for drawing trees... nor the most of objects from nature.
I did two versions of the tree, the first one had no snow, then I reduced the code size a lot, and I had two options: The first option was to add interactivity... at least to make it rotate with the mouse-x position. The second option was to add something... like snow or a star on top of it. I thought that adding a star was not going to feel like a very big change over the previous version, so 2 options: snow or interactivity. I don't think I'm going to update it, but if I do, I will add interactivity for you :D
Hey thanks for the compliments I didn't realize you were Roman Cortes. Yours is great because you thought outside the box. The effect you were able to get with sprites is just amazing. I agree triangles in a small number anyway are not good for making anything from nature look good. 
Quite a few of these were irrelevant micro-optimizations - for example do you really expect that re-evaluating the length property of an array will dominate the time for an array. Given the age of the article however I hope that Google have added hasOwnProperty to their forEach method - that one at least was a notable oversight.
Very nice introduction to genetic algorithms. I was wondering how certain aspects worked. Any idea how well this would work if you started with any length string and used [Levenshtein distance](http://en.wikipedia.org/wiki/Levenshtein_distance) as the fitness function?
&gt; big = true &gt; number = 100 if big &gt; &gt;Instead of: &gt; &gt; var big = true; &gt; if(big) { &gt; number = 100; &gt; } If you think coffeescript is a better way to write javascript, then maybe programming just isn't for you. If you are too lazy/inept to write javascript, coffeescript really isn't going to help you. 
The point is that JS is quite hairy for historical reasons (implicit globals, implicit semicolons, ...). CoffeeScript changes provides an alternative syntax with lots of syntactic sugar (e.g. adding language features you'd normally need frameworks for) and a purer structure (generally, everything is an expression). It has some warts (IMO) owing to its ruby heritage (e.g. the slightly awkward "implicit parentheses" for function calls), but they are far easier to avoid than JS's. It's "bad parts" are not as omnipresent as JS's either. It's not a universal replacement of JS and I'm certainly interested in seeing JS mature further (it's come a long way and is progressing nicely), but it's nice to have a choice. If your development process already involves minification or a tool like Sass, it's easy to integrate CoffeeScript into it. If you prefer to edit your JS "live", it's probably not an option for you. If you're doing both back- and front-end development or recently picked up node.js but come from a Ruby or Python background, CoffeeScript is a very nice and astonishingly robust language with some very useful idioms. In other words: it's not a better way to write JavaScript, it's a different scripting language that can be converted into JavaScript (which makes sense, considering browsers only reliably support JS). If you're too lazy/inept to write JavaScript, nothing can help you. But if you like some/most of the features of JS but want a language that doesn't carry its historical baggage and allows you to write your code with less clutter, CS is worth a try. I think comprehensions, splats, splicing and the existential operator are a better example for the power of CS than conditional sub-expressions (which are nice to have, but ultimately mostly about aesthetics). The difference between `big = true` (CS) and `var big = true;` (JS) may be minute, but the nature of JS's scoping makes CS's syntax quite useful: The `var` keyword is necessary in JS to avoid cluttering the global namespace, but provides a false sense of scoping because all declarations are yanked to the beginning of the function and re-declarations are silently ignored. CS simply does away with implicit globals altogether, thus avoiding the issue of watching your declarations. __tl;dr__ JS is becoming a very nice language, but that doesn't mean CS doesn't have its merit.
simple. beautiful :)
Same here.
&gt; I respect the authors of both libraries, so I hope they will take my ramblings here as constructive criticism rather than an attack. Nicely done. I'd be more than happy for someone to criticise my software that way.
Tested with FF4.0b7 definitely works well, rendering a joy.... Im impressed this is like already releasable... Really impressive! I suppose they just gobbled up another company tho that probably had been developing this for sometime.. 
Yeah, I thought of using levenshtein. So I just wrote a version which uses it ([here (warning, fairly slow)](http://www.puremango.co.uk/genetic-hello-world-lev.html)). Not great results, but after 150 gens I managed to get [HeÌle Wor dÎ] with 100% crossover and 100% mutation probability, 100 candidates. With 200 candidates I managed to get it to [Hello WorDd!]. But those were the best results after a few attempts - mostly it would come up with stuff like [Çell Wo7ldî] I think it's not granular enough; "Gello" and "%ello" are the same fitness according to that measure. But, possibly, letting it run longer and with more candidates you'd get it done. edit: it's also slower, but the JS is probably capable of being optimised. edit: Yeah, the problem is that you're relying on mutation to chance upon the 'right' answer. Maybe if I change the mutation to go from 0-255 instead of +5 to -5... edit: Whoa! yeah that works! 44 generations! Updated that demo page.
8.0.552.224 on Win7 64bit works fine.
Not that I know of but making your own preprocessor to do that seems easy enough. Just replace all instances of int or string, with var.
JSLint. Google Closure Compiler.
Seconded, Closure Compiler is awesome, but retrofitting an existing codebase with the required type annotations can be a pain.
Basic debugging .. Firebug, even has break points. Typing... sure, though it is a bit masochistic. var x = new Number(10); 
It strikes me as an incredibly bad idea to write a preprocessor to correct your own bad habits instead of training yourself out of them.
Umm, that isn't typing. At all.
heh. Ok, so I do c# &amp; javascript for a living. How do I swap my mind from c# way of doing things to javascript? If I had a fancy little button on the side of my head, that woooould make things easier... Edit: it's not a matter of correcting bad habits, it's a matter of having to switch back and forth between languages that are almost the same, but noooot quite. And having a compiler to help with typos... explain what the bad habit is here... not always typing correctly?
thanks, but i was hoping it would do some of the regular compile-time checking also...
thanks, i'll take a look. Edit: JSLint looks like it would help me a lot. It at least throws warnings for undeclared variables (w00t) and throws hard errors when declaring "int". I wonder if they'll find a way to 'notice' when it looks like it might be a declaration error and add that to the error message.
uh... i was looking for compile-time instead of run-time debugging. i already use firebug and the chrome-built-in-debugger.
One thing that might help you is different IDE color schemes (this can be done even in vim of course) for the different languages. The bad habit is obviously yes, making silly mistakes.
I've had to switch between Perl, JavaScript, Java, and C for years. It was a royal PITA for the first year or so but eventually it became effortless.
ah. I've been working for 5-ish years with c# and javascript... (edit: indicating that i'm past the 1st year thing. i'm not saying that i'm 'oh so smart', because i'm obviously pretty dumb for making these 'silly mistakes') not as bad as the few years when i was working with vb and javascript; the double-equals thing would always get screwed up... but at least VB would throw an error on compile in that case. anyways, i'm disappointed that you can flip-flop between languages so easily. if there were more people like me then there'd be more tools to do this kind of thing. (supply&amp;demand)... on the other hand, it probably doesn't help that i work 75% c# and only 10% javascript.
It's a little disappointing to hear that Souders and Zakas are in favor of browser sniffing. It's like finding out that Ms Manners advocates farting at the dinner table.
Well, stop using javascript or stop bitching. That's as close as you get.
I would have know that if I knew you, but I don't so I didn't.
This looks great! I intend to play with this for a bit this weekend. 
well, thanks for mentioning those tools. sorry for being a bit snippy. i did indicate in the description that i was looking for something compile-time, but that doesn't mean i should get snippy when you brought up possible run-time tools to help me. ... are there still people out there that don't know about firebug?
Thanks. Sorry it took so long to respond, I thought I would work on this and then get back to you, but it looks like It'll be a week or two before I get this far in the program. I was so naive :D But thanks!
Declaring a variable initialised with a number object is not "typing", it is in fact declaring a variable initialised with a number object. Nor is it "as close as you get": of course JavaScript has a type system, it just goes unseen because it rarely makes complaint: if you mix types rather than throw an error it'll instead coerce operands (usually through conversion to string or number). Going back to OP, he asked if it is possible to annotate what is otherwise JavaScript in some way, and process it such that mixing incompatible types will result in errors, to which the answer is yes, there are many, and to which I refer you to the other answers in this thread.
You do realize that Number is a function, not a constructor? Look it up.
It's not that they are in favor. It's just that they don't care much, judging by their "I'm not religious about browser sniffing" (which I've heard from both of them). I wish more people would understand that UA sniffing not only hinders developer productivity (and application maintenance) but also cripples the web — browser vendors can't introduce certain features, working groups like WHATWG (html5) or TC-39 (ecmascript) can't change or add certain behavior. It's simply inconsiderate and careless to not take browser sniffing seriously.
It's by Grant Skinner, who's a hero in the ActionScript community.
Have you tried JScript.NET? Runs pretty much anywhere C# will. Then you could stick to javascript and not have to switch languages. I write all of my back-end code in JScript.NET when possible. Works quite well.
Also if you're a java fan, you could use [http://code.google.com/webtoolkit/](Google Web Toolkit) , which compiles java to javascript and allows a full debug setup, as well as lots of other extras.
Wait... this looks *exactly* what I was looking for. Nice. Does anyone know other canvas-support libraries? There is Raphael, but besides that?
Coffeescript. It's much more than a preprocessor, but it was created to paper over all those easy to fuck up things about JavaScript. But if you just want to write better js then jslint is probably the easiest and best choice.
You should probably use a library like jQuery for this. This is not the best way to solve the problem you're attempting to solve.
Raphael doesn't support HTML5 canvas; it uses SVG or in the case of IE VML.
i have some constraints so let me give them to you. I this is in movable type, so I do not have access to the individual heads of each page, there is only one template that each module calls upon. also, each content module is going to have a different number of divs or ids that will need to toggle meaning that it will have to be a universalize script that can scale dynamically according to the number of objects per content module. Also, I do not think I can fire the js via the body.
one word.... getElementsByClassName https://developer.mozilla.org/en/dom/document.getelementsbyclassname You dont need jquery and u can generate a class name dynamically and add to as many DOM elements.
I love jQuery, but if this is all you want to do, jQuery is overkill. Javascript libraries are great if you want to do a lot of things, or one really complicated thing, but if you're just doing something small and simple, just write the javascript code.
Instead of storing the ids in an array, store the element in the array var eles []; eles.push(document.getElementById('id')); //in your funcs just pass the index that you want to show hide etc showDiv(0); //collect your links the same way var links = []; links.push(document.getElementById('link_id')); //this is tricky, but follow along // we're going to add click events to the link, but we need to create a closure to store the index for(var i = 0, l = links.length; i &lt; l; i++){ //dom 1 style event links[i].onclick = (function(index){ return function(){ showDiv(i); //you should probably add another loop in here to hide all of the other divs } })(i); } Everything else that you have looks okay, its just that you keep on running the selector over and over again with no gain.
Doesn't work in IE8 or lower http://www.quirksmode.org/dom/w3c_core.html#t11
A few things are wrong here... first this: document.getElementById(id).style.display = 'block'; and this ... document.getElementById(id).style.display = 'none'; If your element doesn't exist you will throw an error which will stop the execution of the code below it (which may be causing the weird stuff you describe as your first issue). Try this instead... var element = document.getElementById(id); if ( element ) { element.style.display = "none"; // or block } Now, if you want an array of all div elements in the body tag, you'd do this: var allBodyDivs = document.body.getElementsByTagName('div'); Note that this is an array of the elements themselves as opposed to an array of strings (ids) so you'd need to change your hide/show functions to reflect that. Now, if I were to write what you're doing, I would also not put javascript inline on the elements as you've done. This is a style preference, but I would have a function that goes through and sets the links onclick methods to do what you're attempting to do, and have that function execute right before the closing body tag (or anywhere after all of the links in your markup). Either way, assuming that you want to make the nearest parent div invisible, and all other divs visible that are in the body this is how I would write the function that goes on each onclick function onClickToggleDivs(link) { var makeVisDiv = link; while ( makeVisDiv &amp;&amp; makeVisDiv.nodeName !== 'DIV' ) makeVisDiv = makeVisDiv.parentNode; if ( makeVisDiv ) makeVisDiv.style.display = 'block'; var allDivsInBody = document.body.getElementsByTagName('div'); for ( var i = 0, ii = allDivsInBody.length; i &lt; ii; i++ ) if ( allDivsInBody[i] !== makeVisDiv ) allDivsInBody.style.display = 'none'; } and each link would look like this: &lt;a href="javascript:onClickToggleDivs(this);"&gt;show a3&lt;/a&gt; I would suggest that for the sake of not making your life harder later on, set the class attribute to the divs that you want to toggle to something, and check to make sure that the class exists before making the divs invisible. I believe you can even set random attributes and then check for those with something like... &lt;div myRandomAttribute="something'&gt; ... var doesThisHaveMyAttribute = theDiv.getAttribute('myCustomAttribute') === 'something' ? true : false; Of course then you'll fail HTML validation, but who the hell cares right? (that's a joke).
Are you using an editor that highlights syntax errors? Picks this stuff up pretty quickly and helps you switch contexts.
what? He wrote 12 lines of code to hide a div, and 12 lines to show a div - great candidate for a library, to handle all that browser-specific garbage. Having said that, I _think_ from the OP's comment above, they are stuck in a very limited environment. Though I'd still check whether that environment already loads JQuery or some other common library; it seems likely. 
Or code snippets/templates in your editor, for things like a for loop, for example, which could act as your own short hand.
youre welcome
Links to the previous discussions?
It's both. new Number().constructor == Number new Number().valueOf() == 0 new Number() == 0 new Number() !== 0 Using it this way is pretty much universally a bad idea, but it's there. *edit: not to be confused with (0).constructor == Number (0).valueOf() == 0 (0) == 0 (0) === 0 
Very great read. One point though: most of the FUBC is easily avoidable using Modernizr. For the uninformed, you add a "no-js" class to your &lt;html&gt; element and put the Modernizr &lt;script&gt; at the end of your &lt;head&gt; (it's the only script that should ever be there). If js is enabled, the script runs and replaces the "no-js" class with "js". This happens before a single byte of the &lt;body&gt; tag is rendered as far as I can tell. So in your CSS, you just prefix rules with ".no-js" to define styles when js is disabled, and prefix with ".js" for your styling when you're positive your js will be run. No in-line CSS rules or &lt;noscript&gt; tags required. If you know some text and forms will be in a modal window should js be enabled, you set the ".js" rule to "display: none;" so it doesn't flash on-screen for a second before the modal code hides it away. And you can use ".no-js" rules to place it right where you want it on the page for people with js disabled. This still won't fix some of the FUBC that you're bound to run into if your js files significantly alter layout or generate extravagant widgets/ui elements. For those circumstance you're still going to want to load your js files async with some sort of callback so that they arrive as soon as possible to get their rendering done.
You are aware that jQuery is over 7000 lines of code, yes? Even minified, it's 26k. 12 lines is much more efficient, especially considering the Netscape 4 and IE4 code could (and should) be dropped. function toggle_divs(my_class) { var allDivs = document.body.getElementsByTagName('div'); for (var i=0, t=allDivs.length; i&lt;t; i++) { if(allDivs[i].className==my_class) { allDivs[i].style.display = (allDivs[i].style.display=='none')?'block':'none'; } } } 
I'm making the (potentially incorrect) assumption that his app has a lot of DOM manipulation going on and this is just something he's stuck on. Doing any reasonably sized site without jQuery tends to be an exercise in frustration, why reinvent the wheel?
Good point, Pewpewarrows. Modernizr works becuase it is loaded synchronously with a normal &amp;lt;script&gt; tag, and so any logic that it does is pretty much instantaneous and synchronous. The FUBC I describe in the article is almost entirely caused by deferring the execution of JavaScript. The longer you wait to load or execute JavaScript, the more likely the user is to see content that is not yet "behaviorized" by the JavaScript. Also, as I mentioned (similar to what Modernizr does), you can choose to hide your content via CSS and then display it once JavaScript shows up, but then you've mostly defeated why Steve wants to delay the JavaScript. He wants the content to be visible before the JavaScript runs, so basically he *wants* the FUBC, and I'm suggesting the FUBC is usually an undesirable effect unless the site carefully plans for it and makes it a graceful change. You could design the UX of your site such that the changes made by your JavaScript are subtle and graceful and happen in small, spaced out bursts as things load gradually. But what most people do is have raw content that is radically transformed by a single-shot of JavaScript logic, and this creates a really jarring, undesirable FUBC for the user. The more you make that delay, the more obvious the radical FUBC becomes.
Looks great in Chrome - tried it on my Android phone and couldn't get any of the examples to work. Still in alpha, though, so its very promising!
Which is *exactly* what I said originally. &gt; I love jQuery, but **if this is all you want to do, jQuery is overkill.** The question was how to hide divs with a given class name. If that's all the OP is trying to do, jQuery is overkill. If OP wants to do more, it's not. But to jump straight to "use jQuery" for simply hiding/showing divs is lazy and wasteful. If this is only a part of what the OP is trying to do, then yes, I agree with you completely. Using a library like JQuery (or prototype, or moo, etc.) is a good idea.
It's actually been out and running for awhile. http://www.p2pu.org
Hey, jQuery is great if you don't know JavaScript and don't want to.
I'll look elsewhere. FF, you had your chance for 6 years, and you blew it. 
Oh I completely agree. I think it's ridiculous that developers find it okay to have all that raw, unmodified content shown to the end user for potentially seconds while the corresponding javascript files are loaded, parsed, and executed. On some sites it's as jarring as if you were to disable stylesheets until after the page has fully loaded. Which would be quite silly indeed.
As someone who is still getting his feet wet with JavaScript.. how many books/hours/projects/etc did this take? Sometimes I see stuff like that and feel I should get out of webdev and take up gardening..
You should ask for a refund.
Well, this seems dumb. &gt; Is it worth it? Eh, don't know ... really, I don't. Yep. Dumb. JSON is not a JS object. Don't treat it like it is.
Yeah this is pretty dumb. &gt; Array indexes are faster then hashmap lookups --- they just are. JavaScript Array is not an linear allocation of memory where indexes are just memory offsets. Even numbered indexes are object properties. Ignore this article.
I disagree with telling new people to run the bleeding edge Node.
[fabric.js](http://kangax.github.com/fabric.js/test/demo/)
Utter bullshit.
&gt; Yay! If only PHP could do this too (I know why it can't - so please no flaming) What would be left?
I understand how it can be misleading, but first of all: Java is not Javascript, hence, this doesnt belong to this subreddit. I recommend /r/java instead. (Or just the mighty power of google, as you were suggested, there are plenty of Java Database Connectivity (JDBC) tutorials/examples to be found)
I suggest you look at the modern spidermonkey and v8 implementations; which was what I was working with when I wrote this article because the source code says otherwise. And besides ... the use-case for this was high-volume JS object throughput ... it had to be in JS given some strange design constraints. When I tackled the problem and did this methodology; I increased the throughput over 300%.
Is there JSON I can emit that Javascript will not take as an object? The answer is no. You are correct. JSON is not done by the ECMA standards board as a subset ECMA-262 level 5. That is true. But it is also, totally, irrelevant. The point is that you can emit things from a myriad of languages inline to javascript and then run it as javascript without scaffolding for formatting inconsistencies. As far as different formats go, it would be correct to say JSON is nowhere near, say, Multi-Part Base-64 MIME; it is however, a damn near overlap of the EBNF for javascript object declaration; it's named professes this too; but naming is irrelevant.
Every performance metric I've run it against in Blind testing disagrees. Not only is there a very valid statistical different between the two, but I was able to identify what was what every time. I could back this up with real numbers if you want; it is scientifically verifiable by all methods that I know of.
I stand corrected. 
Why didn't you include the numbers in the post in the first place? You must have known that people would be skeptical about your performance claims.
Do you have performance tests to back up the claims about array index lookups?
I think a lot of this approach is excessive and trying to rewrite the javascript language into something heavy like Java. For large projects you can get away with crockford's module pattern and Resig's class method just fine. One important tip is to avoid closures in event handlers and be mindful of event delegation, that's where javascript can become slow and unwieldily. 
http://qaa.ath.cx/timer.html is some simple mockup ... as a direct response. **But** this wasn't really the point (comparing the hashing systems) ... it was approaching the problem from a point of caring about the bytes --- you know, like it's 1980 again; actually paid off. As far as code goes: In V8 there is a NumberDictionaryShape and a StringDictionaryShape. The Number one uses wangs hash functions (go to around the 7900s in objects.css) The string, well look around 8062 to see that rabbit hole. It uses some caching system for lookup which means that the second time through in chrome, you'll get a faster system there. But I could very very easily make this code in a way that the array will win every time. In FF, the array wins every time. In IE, it won't work because I'm using Date.now. But again, this is about the performance payoff of using a design methodology and placing concerns in a particular frame moreso then comparing one consequence of this approach.
I guess I'm just not used to people being skeptical of me. Besides, I hate performance metrics ... because the ones that go viral end up dictating a design methodology that sticks for many years after the problems which led to the performance issues were resolved. But I think the "keep your messages terse in your message passing systems" is a just a rule of thumb that ought to be applied. It's as if many programmers are scared of casting black magic and then just abstracting it away for the programmer and themselves - as if the entire stack needs to be easily human readable from the walled garden of the terminal. 
Interesting but very messy. It would cleaner if it was incorporated into something like http://jashkenas.github.com/coffee-script/ Google's GWT, where Java gets compiled into Javascript is messy as well. CoffeeScript maps to Javascript more directly. Google's overall programming style, with Closure Framework, GWT are unpopular for good reason. They have very complicated API's for a language that attracts people who hate Java and C++ or don't program well to begin with.
Why does JS need to be OO? What's the big advantage?
Coffeescript looks neat but seems like its trying to solve a problem that doesn't exist. It's hard enough to find good javascript programmers, now we have to hire people with experience in coffeescript? bleh
I wish I could upvote every single sentence in this post. 
&gt; I guess I'm just not used to people being skeptical of me. It's nothing personal, of course. You're arguing that people should do data transport in a different way, so you'll have to be persuasive. &gt; because the ones that go viral end up dictating a design methodology that sticks for many years after the problems which led to the performance issues were resolved. But aren't you doing the same thing? You're taking advantage of a (claimed) performance boost achieved by switching hash table lookups to array index lookups. Assuming that it even exists, how do you know it's not just an engine-specific quirk that will be fixed six months hence? &gt; But I think the "keep your messages terse in your message passing systems" is a just a rule of thumb that ought to be applied. It's as if many programmers are scared of casting black magic and then just abstracting it away for the programmer and themselves - as if the entire stack needs to be easily human readable from the walled garden of the terminal. Terse messaging is a Good Thing, yes, but not to the exclusion of everything else. It's a concern that has to be balanced with others. Is it worth violating the JSON spec and risk running afoul of any number of independent JSON parser/encoder implementations? Are the performance benefits worth the hassle of adding another moving part to your web stack? Or, most importantly: if your aim is to improve user experience, isn't it more fruitful to focus on your true bottlenecks — usually server response time and screen-painting delays — instead of shaving off a few bytes on the wire and a few milliseconds in the JavaScript engine?
http://qaa.ath.cx/parser.html there's a parser example. This design methodology goes through the entire stack. Array getters and setters in FF is a 10 fold speed increase, compact parsers is an 8-fold increase, etc. Something like this isn't engine specific. There are simply more bytes to transit over the wire, traverse and process. Every step along the way has greater requirements for this modality and the usability benefits can often be abstracted away. As you can see with my code from here and above, the object and the array accessors use nearly equivalent code paths; I'm not suggesting that people start coding in kanji with their big toes or anything. And again, it's not about dwelling on this ... I could illustrate further how every single part of the stack should use these design methodology. You will see a dramatic performance gain. Saying "Make everything 5-10 times faster by approaching it differently" I thought would be awesome ... but people around here decide to laugh at me for it instead. No wonder my bank site takes 45 seconds to tell me what my balance is. **edit**: You could use the non-native JSON parser with obj = (new Function("", "return " + verbose))(); which is how I used to roll. The split then offers about a 1,500% performance gain. These are real numbers; on the client side; aka "cloud doesnt help you here"
Interesting. Does this go Vala=&gt;JS, or Vala=&gt;C=&gt;JS? I can't find a FAQ. 
Well JS by default has Prototypal inheritance which is a big OO advantage. 
&gt; Is there JSON I can emit that Javascript will not take as an object? The answer is no. Which was one of the points of JSON's design, I thought. The other being that it's extremely portable and easy to deal with in basically any language. So, what you're doing here isn't "trimming JSON" as much as it is creating a new object notation that may play nicely with JS but may not work as well with other platforms. And then you haven't put forth any data to back up your claims of speed/savings.
OK, well see below (and above). I have some code there. If there are any specific parts of the round trip you have questions on I can make a test and show you the performance gains there. What you are essentially doing is message passing, it's functionally equivalent to IPC ... you have an application that sits partly on the server, and partly on the client with the network existing as the medium for the IPC. People go crazy nuts about libev, zeromq, libevent, etc on the server side, but then on the client side, they don't have the same concerns. However, the same type of gains can be had (see the two samples on this comment page)
&gt; and Resig's class method You have no idea now much that annoys me.
Please explain, I'm honestly curious to hear your opinion.
I "invented" the AOP inheritance pattern that his class method is based on. I feel like he rewrote my code and made it slightly worse (Class vs Base). He gives my original code some credit but the fact that the pattern is now remembered as "Resig's class method" really ticks me off.
I respectfully disagree, sir. EDIT: Enough to blog about it, in fact! http://bit.ly/hdi7kD
Closure code doesn't map to Javascript, it is just Javascript. Unlike GWT you don't have to use the compiler to run the code in your browser and unlike CoffeeScript all closure code is valid Javascript code.
Note that you could have had a JavaScript language with many built-in features like type, class and member visibility enforcement, if EcmaScript 4 had come to pass. But it didn't. And for all the preaching out there that JS had to remain pure, we're going to keep seeing more and more attempts like these to modernize the language and keep it usable on large scale projects. 
new Date() is slow!
&gt; ... for a language that attracts people who hate Java and C++ or don't program well to begin Not really true, javascript is mostly a forced decision due to having to write interactive web pages, not a choice for people sick of other languages.
&gt; Saying "Make everything 5-10 times faster by approaching it differently" I thought would be awesome ... but people around here decide to laugh at me for it instead. Please, please don't play the persecution card. Nobody's laughing at you. &gt; No wonder my bank site takes 45 seconds to tell me what my balance is. Your bank site takes 45 seconds to tell you what your balance is because they don't take shortcuts in JSON parsing? Or because they don't follow the aforementioned design methodology in every part of the stack? Don't you think a "make _everything_ 5-10x faster" claim ought to be supported with real-world tests?
Or, as I like to say, java is to javascript as ham is to hamster.
:D why thank you, sir! I hope you find some use for it.
I'm the author. The effect itself took about 2 hours to code it first, then about 7 hours reducing its size from 3kb to 1kb. Some days after that, I spent 5 hours more to reduce the code further and add the snow. So, about 14 or 15 hours... Fortunately my girlfriend is very patient with me and she understands sometimes I need my time to do crazy things like this one :) About learning how to code. I think it takes 1 to 3 years to learn how to code in a proper way and practice enough to do so. The most of the people take 5 to 10 years seriously coding and practicing with enough frequency (let's say, half to one hour per day of average time coding) to get an expert level. Remember that there is something not yet completely understood, but the brain does something during the sleeping time, maybe something like "reordering what you have learnt" that is how you *really* learn things. And, only what your brain decide are the most important things will be long lasting. So, what I want to say is that in the most of the cases, learning takes its weeks, months and years. It doesn't matter if you spend only, let say, 5 hours per week on something or 40 hours per week learning something, you will learn at almost the same speed. Learning requires some continuity, reading and practicing, as I said, not necesarily spending a lot of time and not necesarily on a daily basis. But, if you don't give up, feel completely and absolutely sure that in 5 to 10 years you will feel you are starting to be an expert. It doesn't matter what activity you want to learn, it takes always the same. At some point, the learning curve always slows down and you take more and more time for learning new things, and there is no point where you can say "I've learnt everything". You will continue always learning, during all the time you want to do so. There is something *really* important when learning anything. And it is that you should believe you are able to learn it. Never thing something is not for you, never be frighten by the apparent difficulty of anything. Remember that our brain is absolutely amazing. It is a learning machine. Feed data to it, be patient, don't give up and believe it is going to learn. It will take its time, but it will do it, for sure. If you ever have some kind of disbelief about this, just remember how difficult it seems to learn a foreign language... but you learnt your language when you were a child! Remember how difficult it would seem now a new alphabet set... but you learnt your language character set, and how to use it, how to read, how to write when you were just a kid. Remember how difficult it was to learn to ride a bike... and you did. There are a lot of more things like this one, and in all of these things you are so expert that these seem "natural" to you (and there is probably nothing more unnatural than driving a bike). Some might say that you can learn faster or more when you are young. This is false. You are continously learning, always. And your current knowledge helps you to learn new things, so the more knowledge you have, the older you are, the easier to learn new things. But, in any case it takes its time, you can't pretend to learn a new language in 6 months when your native language took 10-15 years to be fully developed, for example. Finally, remember about the positive feedback. Your brain is going to filter things it dislike. If you don't like something, you will learn very few or nothing at all. But, if you like something, it will be learnt and long lasting... just as you remember a lot of good moments in your life. If you keep learning something, and you like it, you will see your progress, and seeing that will make you happy. That feeling as a feedback is going to help you learn even more. The more you learn, the more you like it. The more you like it, the more you learn. Finally, when you spend a lot of years with something, you just don't like it, but you start loving it, and even being an integral part of your life. This is a very common thing within artists for example. From an outside, non-artist view, an artist who lives the art could be seem like a person faking or lying, but they are usually not; they are just so inmerse in the learning of art that they love it so much it is part of their lives.
Alright, I'm just being a bitch. In the real world, most projects have much larger and more severe problems; from not having a suitable hardware configuration for their problem sets to not having an effective data model that provides solutions in a timely manner. Not to mention poorly documented, poorly written code that is built on top of large heavyweight frameworks that could be done away with... These are nuanced details after an individual gets everything else right.
[Greasemonkey](https://addons.mozilla.org/en-US/firefox/addon/748/)? You could order your browser around, scrape nodes, and post the data to another webserver.
What's the point? I don't get it.
I remember programs (bots) you used to be able to run with AOL that would make gradient text in the chat automatically for you. It was pretty sick back then, haha.
There isn't one. It was just something I wrote one day. I thought someone out there might be able to find a use for it, so I decided to share.
Very clever. The precise gradient effect gives an illusion that you're changing colors more finely than on a character-by-character boundary. Nicely done!
Thank you kindly! :)
I look forward to you fixing the Opera error with the benchmark. Seems like this could be a nice cross-browser comparison benchmark.
I sat looking at this comment box for over 10 minutes, just know that your work is appreciated and it was enjoyed tremendously. 
:D **Thank you!** I'm very glad that you found it enjoyable. I love doing odd little projects such as this, so perhaps I will post more in the future!
It has very retro feel, circa 1990s.
It would be nice in a website with a black background, yellow text - for some swords and sorcery theme, and as you move your mouse over the text it glints white... It would fit in lovely there!
That's a cool idea!
Watch me break your script. Steps: 100000000000000000000
&gt;Watch be break your browser FTFY I just tried that in Chrome, and it locked up :P However it should be noted that I am not responsible for what happens when you use ridiculous input values! 
Why oh why isn't there a jQuery plugin for snowflakes?
Thank you for your awesome reply. It is inspiring :-) I found your blog post where you explain a bit about how to make the tree, and now that I at least understand what is going on it gives me more hope :-) It's just, at times I feel I'm getting too old to learn all the new stuff all the time.. (remember HTML 2?) But yeah, I'll keep at it, what else can I do :) I'll buy you a beer next time I visit the south of Spain :) (or when you visit the north of the Netherlands)
Link to your sources ? 
Are you serious? http://blog.pixelboxx.com/ska/stories/202/
Drop-down menus
Image replacement scripts, image caching scripts. 
Background music Thinking about it, I've never seen something good come out of "document.write" plugins.
If your drop down menu is in javascript at all, you've failed at writing good frontend code IMHO.
Falling snowflakes on a website is a must-avoid pattern.
http://www.somethinghitme.com/2010/12/09/jquery-snowfall-plugin-1-4/
Generally yeah, but idk if done right it can look cool in my opinion. This is one example using my snow plugin, http://www.infinite-eye.com/ I added the option to round them right after the site showed me that, looks great IMO.
u need javascript for usability. if you don't have any delay on the drop down menu, it will act jerky and wonky. 
Correct. Using javascript for high-quality drop-down menus is fine. If you're happy with substandard menus that don't use JS, then so be it.
Here's [an implementation using canvas](http://www.davidflanagan.com/2010/12/let-it-snow.html).
There is, but I've found them to look like ass as well. Just build one from scratch, it'll be a fun learning experiment.
I couldn't upvote this statement enough. "document.write" doesn't belong in any JavaScript code.
They look okay, but still detract from the site overall.
My favourite thing about iPads and iPhones is telling clients "people who use iPads or iPhones won't be able to use your site if you want drop down menus." Also replace "drop down menus" with "Flash" for another sentence that I just love saying!
Ah good. With [narrative javascript](http://www.neilmix.com/narrativejs/doc/) no longer being developed or supported, there was a gaping hole in the range of weird hacks to awkwardly mask core JS behaviors behind arbitrary abstractions. All is well again. 
If it's using PHP, then, you touched deeper than the bottom...
Well, there goes my last stumbling block to giving node a try. I was enjoying my free time, you bastards!!
LOL. You know, some simple regular expressions could fix that. That said, this is a great little program. Not sure what it could be used for exactly, but you did a great job with the gradient pattern. 
well, they can use it, it just takes twice as many taps as usual to activate the hover states (depending on implementation).
Best essay on learning theory I've read. Sweeps away some common misconceptions.
Using a "document object model" as a remote protocol to describe application interfaces.
I think I would trust the versions Google Code has been hosting for years a bit more :) http://code.google.com/apis/libraries/devguide.html
Agree with you 100%. Can't believe you got downvoted for telling the truth.
It would be very nice and subtle with a negative z-index. As it is, its kinda distracting.
And hover. F-ing hover.
The DOM is terrible, but what other markup language exists other than HTML/CSS that allows for variable resolutions, dynamic reflow, rich media, medium-dependent styling and can be serialized into an open interchange format, accessible to search engines?
Well it's a complex issue, but people who've grown to like Javascript, like the JQuery, Node.js, Coffeescript crews, typically prefer languages like Python and Ruby which are the current religious opposition to C++ and Java. The APIs, syntax styles, verbosity of Google's JS efforts are reminiscent of Java, while jQuery is closer to the Python &amp; Ruby camps. I'd argue that CoffeeScript is easier to learn than Google's coding style for the Google Closure framework. Between the weird inheritance http://www.bolinfest.com/javascript/inheritance.php this defining types in comments, there is significantly more boilerplate. With a preprocessor, this boilerplate could be removed, unfortunately the only preprocessor Google has uses Java's syntax. If Google's goal is to encourage adoption of their JS frameworks and techniques, I think forking CoffeeScript would be their best bet.
Actually, I was considering editing my comment to say ".... to manipulate marked up hypertext documents...", but I didn't want to further cloud the issue. Markup is designed to mark up text. the dom is a way of manipulate rendered representations of marked up text. A text document and an app interface have very little in common, and the history of HTML and JavaScript has been one of force-fitting, piece by piece, the latter into the former. Although text documents do, an application interface does not need to be indexed by search engines. SVG is an open interchange format. Swing, to give one example, allows for variable resolutions, dynamic reflow, rich media, and medium-dependent styling. This, imho, is one of the web's worst features. I can't speak for Sir Berners-Lee and all the other intelligent minds who designed the internet, but I don't think they intended *everything* to be jammed through port 80; that was the sad consequence of corporate IT policies in the '90's (firewall everything) and the evolution of commerce online according to the principle "the internet interprets censorship as damage and routes around it". It's our unfortunate heritage, and the only thing missing to fix it is consensus and will. Edit: &amp;lt;/rant&amp;gt;
Now you can use Ruby programmers to write Javascript and not hear them complain about the disastrous design by committee syntax.
actually.. it can be very handy for widget embedding. javascript and html were not designed with encapsulation in mind.
So, is this reddit thread a text document or an application interface?
Please don't hesitate to contact me on github (I'm the author of node-postgres) if you've got any questions or run into any snags with either node or postgres-node. I enjoy helping out.
CDN delivery of js libraries is never as good as loading all of your script files concatenated into a single minified script file that is gzip'd, from your own server. Reducing the number of http round-trips goes a long way towards speeding up your wepapp load times.
This is great! Not useless at all, I'm thinking of using it (possibly along with an incremental character or word size change) as a way of highlighting in a textual analysis thing I'm writing. Thanks for sharing.
Tell that to Google. The javascript snippet used for site analytics rely on it.
Ha ha. excellent point. Since I'm currently using the mobile version, I'm even more inclined to say app; but it's really closer to a document than it should be - it's a forum with a sprinkling of ajax dressing. If the site was designed from the ground up under the app paradigm (and assuming the proper toolkit existed), it would provide a way to browse documents (e.g. self posts, "current links" on each topic, and user profiles), an IM / chat -like feature, and a component for managing your (ahem) "experience". The "pages" made available on the web for search engines to index would be generated in the background (e.g. map/reduce) and would bear little resemblance to users' conversations. The reason reddit looks and acts the way it does is because it's a product of its upbringing. But the clever designers and programmers are the ones trying to see past that. On a tangental note, ajax is just about the best thing done to the web since macromedia killed shockwave and went full-bore into flash. But it will always be the gimpy child of its bastard heritage: it puts all the burden on the client-side, it's wasteful, fragile and kludgy. For example, ajax isn't very seo friendly either!
THANK GOD WE STILL HAVE W3SCHOOLS!!! /sarcasm
I had a job in college where I had to get certified by them. So useless.
You could just do a DOM search for the script tag and then append HTML immediately after it. It's not as simple as using document.write() but at least you're not using document.write() :P
Paul Irish's blog did this a few days ago, I swear, but it's since disappeared.
Exactly correct, just because its easy doesn't mean its the right way to do it. There are a lot of problems with document.write when dynamically implemented.
I will kill you with my bare hands if my client get any idea from this.
Well its not just Google that uses it in their analytic collection code, all the major analytic services use a document.write because its easy. Pull up your favorite debugging tool and run any document.write in the console, like 'document.write("hi");'. Notice the entire page is erased and only the word 'hi' remains. This effect occurs when you run a document.write too late in the page load process, consider what would happen if the Googly Analytics code takes a little too long to download? Your customer tracking software just lost you a customer. If you instead insert the code in a safe manner as mentioned by user meltingice above you will never have this problem.
Yep, they should be running on v0.2.5, in the code box of "Fetch node using GIT:" you should add "git checkout v0.2.5"
nice! just what i needed to fully play around with nodejs! But is there a work in progress for a DBI or PDO like interface? Are the mysql/postgres projects linked to a common interface?
yep I'm aware, just wanted to point out the handiness of it :)
I don't think there's been any work towards a common interface. I loosely based the library off of the [node-myslq](https://github.com/felixge/node-mysql) interface.
Great! Glad you could find a use for it! :)
"something hit me" I can imagine it being you if you ever see the guy. =)
In old-skool days before jQuery et all, I've never come across any of these problems you mention? edit: ah, I mean document.getElementById("blah").innerHTML=
document.getElementById("blah").innerHTML= ? or a script include tag...
I had ghosts at Halloween too!
How's he drawing the snowflakes to the document? I thought canvas's weren't transparent! Is he sending the canvas to a PNG then drawing those on the document? How's the transparency work? I need to look at the source! Ah he says about Canvas and CSS, and the source is here: https://github.com/davidflanagan/fractalsnow/blob/master/fractalsnow.js Oh wow! Canvases CAN be moved around on top of other items... I thought they were like Java tags!
Yep, canvases can be transparent and in fact [are initialized to be transparent black](http://www.w3.org/TR/html5/the-canvas-element.html)! Transparency can be set through many other ways too of course, by drawing a transparent image to the canvas, or by directly manipulating the image data pixel by pixel for example :)
well, i guess a wrapper library written afterward could fix that but the other way around (designing against the interface) could lead to nicely loosely coupled solution. var dbh = new DBI(connection);//could be mysql/postgres/oracle/sqlite var sth= dbh.prepare(query); var ret = sth.execute(params); Most all server side programming languages have already done a nice job at dealing with that (PHP introduced its PDO class to fix the error later but better soon than late) so perhaps choosing an interface to program against could be helpful to all 
What I often do is I load jQuery via CDN, and the rest of the scripts as a single minified script. Instead of loading 100kb (for example) from one server, the browsers can load 26kb and 74kb in parallel, as they're from different domain names. There's also a bonus that visitors may have that 26kb cached already :)
your talking about modifying an element that already exists, using document.write to insert a new node into the DOM is what is dangerous.
As in my reply to your other post, its not modifying a node that already exists that is the problem, its inserting a new node all together that is dangerous through document.write
I wonder if it's possible to grab canvas data of whatevers rendered underneath using some kind of ninja-code?
I must go and play with this new found information...
Ewwww.
&gt; Pull up your favorite debugging tool and run any document.write in the console, like 'document.write("hi");'. Notice the entire page is erased and only the word 'hi' remains. I encountered that once when trying to hook up the Google Analytics script with facebox... I ended up rewriting that bit of the script.
MEH
The actual demos are very underwhelming, but the example code and platform mechanics (gravity, left/right movement, jumping) on the home page are very appealing in terms of code size and readability. It is definitely at least worth a shot, but I'm going to wait to pass judgment until a couple games have been made with it. The entity-component model looks interesting as well.
lol why, its not hard to implement, and meh I dont think its that bad. If we can have horizontal websites, or websites with random carousel, light boxes, flashy (not flash, just flashy) galleries that are still considered "ok" I dont think adding snow is such a big deal for a small amt of time.
Depends on what your trying to grab, you can grab an image easy enough and use the data within canvas. You cant grab just any ol dom element though.
It'd be cool to see integration with a WebGL engine such as &lt;plug&gt; [WebGLU](http://github.com/onegeek/webglu) &lt;/plug&gt;
I would never hand privacy of my visitors to an advertising and data mining corporation. Just saying.
Nice to see that there are still some nice people on reddit.
Yes the demos suck but seeing as ImpactJS was just released, I thought I may as well release mine as 0.1 (not yet ready to be a full version). Hopefully through feedback about what needs adding/removing/changing will get to the first established version in no time. Also, today I plan on making a video tutorial for creating a Connect 4 game. Will post soon!
Memory's a little fuzzy, but: Form1.fader: Stevai loves McTessa?
On top of that, coffeescript implements/translates to javascript in such a weird way that it breaks JSLint. Seems JSLint doesn't like ternaries with commas in a function call.
If your CMS does not allow configuration for SEO, why are you using it?
Exactly what kind of a declaration error are you thinking of? JSLint has the disallow undefined variables option to point out potential global lookups, as well as showing unused variables and globals at the bottom of the report. Make sure that JSLint is fully able to parse the code before dealing with the information at the bottom of the report, as it can be inaccurate if an error stops it. Inner functions could also be called a global if they're used before they're defined, seems to be an inconsistency with the "used before defined" warning at the top layer. Closure compiler can do type checking on jsdoc annotated code. If you're worried about type issues, always use === and !== for strict type comparisons. == and != is a loose comparison and will evaluate if a number and string are identical in content (potentially masking type errors), and makes null, undefined, false, 0, and "" equal to each other, which is a major headache.
The shoehorning of applications on the web is indeed suboptimal, but web apps are still by far the minority. Today's web pages have rich typesetting and layout, rich media, with interactive elements woven throughout. Content is primary, and websites are designed for skimming. Making something similar with a UI toolkit like GTK or Cocoa is actually pretty hard. You can use WebViews to fill this gap, but it leads to an unnatural split between dynamic content and hand-programmed controls. So when people say "assuming the proper toolkit existed", I wonder if anyone actually knows what that would be. It would have to be powerful to programmers, accessible to designers, rich in capabilities, open to evolution and network-safe to boot. A camel is a horse designed by committee... and HTML/CSS/JS is a very good camel. It's been shaped by the demands to we have put on it.
Closure compiler (whitespace mode) found some mathematical parentheses that it deemed unnecessary for the operations performed, it's 1020b now, but it also added "0." to some numbers, 1016 without 0.\d nums. I haven't tested this code, but it should work. There were more savings in simple mode, but the program's been shuffled and may not work the same. M=Math;Q=M.random;J=[];U=16;T=M.sin;E=M.sqrt;for(O=k=0;x=z=j=i=k&lt;200;)with(M[k]=k?c.cloneNode(0):c){width=height=k?32:W=446;with(getContext("2d"))if(k&gt;10|!k)for(font="60px Impact",V="rgba(";I=i*U,fillStyle=k?k==13?V+"205,205,215,.15)":V+(147+I)+","+(k%2?128+I:0)+","+I+",.5)":"%23cca",i&lt;7;)beginPath(fill(arc(U-i/3,24-i/2,k==13?4-i++/2:8-i++,0,M.PI*2,1)));else for(;x=T(i),y=Q()*2-1,D=x*x+y*y,B=E(D-x/0.9-1.5*y+1),R=67*(B+1)*(L=k/9+0.8)&gt;&gt;1,i++&lt;W;)if(D&lt;1)beginPath(strokeStyle=V+R+","+(R+B*L&gt;&gt;0)+",40,.1)"),moveTo(U+x*8,U+y*8),lineTo(U+x*U,U+y*U),stroke();for(y=H=k+E(k++)*25,R=Q()*W;P=3,j&lt;H;)J[O++]=[x+=T(R)*P+Q()*6-3,y+=Q()*U-8,z+=T(R-11)*P+Q()*6-3,j/H*20+((j+=U)&gt;H&amp;Q()&gt;0.8?Q(P=9)*4:0)&gt;&gt;1]}setInterval(function G(m,l){A=T(D-11);if(l)return(m[2]-l[2])*A+(l[0]-m[0])*T(D);a.clearRect(0,0,W,W);J.sort(G);for(i=0;L=J[i++];a.drawImage(M[L[3]+1],207+L[0]*A+L[2]*T(D)&gt;&gt;0,L[1]&gt;&gt;1)){if(i==2E3)a.fillText("Merry Christmas!",U,345);if(!(i%7))a.drawImage(M[13],(157*i*i+T(D*5+i*i)*5)%W&gt;&gt;0,(113*i+D*i/60)%(290+i/99)&gt;&gt;0)}D+=0.02},1);
I agree fully. It's always easy to take a look back and mark all shortcomings and imperfections. But the web as a platform has given a lot of developers a lot of creative opportunities to build great, compelling and charming applications/sites/pages/interactions. It's the freedom that actually counts. 
&gt; 100% tested Bold claims. Bold. But still, great to see work in this area!
that is a little outside of the purview of this thread but thanks for your useless input. I will pose it to the dean of the medical college.
Well said. It's true that I'm only talking about hypotheticals, and html/css/js works well enough as the tool we have. But, when I think of all the time and effort that's gone into developing those standards, i have to think we could've done better. What I imagine would be something more like RPC and MIDP - where the functionality is specified and the client has more freedom in the implementation. Of course, designers want everything pixel perfect, which is one reason Flash has such a huge role on the web. Now, whatever happened to using PDF's as forms? ....
Yea I would rather hand it to some nobody start-up with no incentive to keep honest or any reputation to protect. Also what exactly is your concern? That Google will use these IPs of all these jQuery users to suddenly learn all about the jQuery needs of the world and advertise to them? It will be mostly cached anyway, except for one load per person...
"No Google" doesn't mean "Yes jQuewy". Google can fingerprint request using HTTP headers, in addition to tracking IP addresses, and profiling which pages the user has been visiting (through Referer HTTP header). Caching was a good point, but still they don't need to set Expires header to a long duration forever.
They already do set the duration to forever, each version of jQuery that they support is referenced by version number and is static. I was just saying if you are going to serve for free from a CDN you may aswell trust Google as anyone else, you probably already trust them with a lot more information... :)
Yes, sad fact is they already own us. :(
You can convert hex strings to decimal with parseInt. parseInt('FF', 16) == 255; // true Reverse the process with toString: (255).toString(16) == 'ff' // true
Sure, but the search index file could get quite large. Obviously this would be a rudimentary system that doesn't accommodate spelling errors, phrases, etc. Here's a proof of concept. Code isn't beautiful, but the actual search portion should be very fast (for js) even on a pretty big dataset. http://jsfiddle.net/rDwQK/2/ 
I did a really quick/dirty full text search scheme for http://nitimetables.com .. that's not finished, but the search bit works (try "dub bel"). The code wasn't designed to be reusable, but you can have a look here: https://bitbucket.org/dmw/translink-timetables-pure-js/ The search finds the intersection of route stop names containing words whose prefixes are listed in the query. It runs in under 100ms on an HTC Dream (with its incredibly slow JS engine). It runs ridiculously fast on any newer phone or a desktop. It's searching data scraped from 35mb of web pages into a 5.2mb SQLite DB, which is then transformed into a 1.1mb "CDB" file, which is carefully ordered so that it compresses very well, to 204k.
html5 has datasets for this sort of thing. http://html5demos.com/dataset
1. You're going to have to create some kind of low-level parsing for both terms being used as index terms and search phrases. The complexity of this is more or less directly correlated to its usefulness - the very least you'll have to do for sane results is stemming, stop words, and case conversion. 2. If you want your results to mean anything, you'll have to implement some kind of ranking algorithm, based on the data you decide to add to your index. Lucene's default similarity algorithm is documented in detail [here](http://lucene.apache.org/java/3_0_2/api/all/org/apache/lucene/search/Similarity.html). At the absolute least, you're going to need term frequencies, inverse document frequencies and a score factor based on the number of terms hit per document. 3. You're going to have to come up with a better way of storing the data than "term" : [document]. You can dig through Lucene's source code if you want to find out how they do it, but be prepared to wear your Java hat for a few days. For this to be *usable* and *useful*, you're talking a lot of work. It's much, much less work for you to set up a Solr instance somewhere, add all of wikileaks to it and write a javascript client to query it directly. Full text search is Hard. Citations: I deal with a search index with 100 million entries as a full time job.
Think of storing a also the position of a term in the index. Then you can fairly trivially implement a phrase search. i.e. if the query is "united states", then you look for documents that contain both 'united' and 'states' , then you check that the occurrences happen next to each other in the right order. As of your questions, if you use the approach above they are fairly easy to answer: 1. Since you know the positions of terms, you can adjust your relevance scores appropriately. You can boost the score if the term occurs near the beginning, is mentioned more than average etc. Most of those calculations you can do offline. 2. Whichever approach you take, the size of your index is going to be O(size of corpus). The total size of WL dump is a couple of GB, so its definitely an issue to think about. However, if you do download all the necessary data, then the search itself should be quick. 3. Tag cloud is next to trivial: just go through the index and use font size proportional to the number of occurrences.
It implemented a dataset navigator for logfiles (but that's just depending on the datastructure) that is configuration driven and works quite well with very large datasets. maybe somebody can use that as a starting point. http://blog.pixelboxx.com/ska/stories/100/ If not than at least it has colors. 
well thats cleared that up then... we can all go back to coding now :P
The [Sphinx Project](http://sphinx.pocoo.org/) implemented something like this for the documentation it generates. Not sure if their approach fits this use case though.
Wow, you're quite a dick about asking for free help.
I'd write a Perl script to extract all the words from all the cables, and then create a directory-backed trie with leaf nodes being JSON files containing an array of ids. This wins in index compactness, simplicity of use, and pre-processing simplicity, and requires nothing server-side other than the directory structure containing the index. So to (quickly! yay!) find the cables containing the word "potato", use the following jQuery: jQuery.get( '/path/to/index_root/p/o/t/a/t/o.json', function(cable_ids) { // ... cable_ids is a simple javascript array with cable ids :) }, 'json' ); Then finding two words just means two AJAX queries and a simple scan through each array to find common ids. So for example, if the the word "cat" appears in cables 12 and 14, and "catch" in 62, 3, and "cure" appears in 17,19,2, and "dog" in 20, 38, and 40, you'd have a directory structure like this: c/ a/ t.json contains the text: [ 12, 14 ] t/ c/ h.json contains the text: [62,3] u/ r/ e.json contains the text: [ 17, 19, 2 ] d/ o/ g.json contains the text: [ 20, 38, 40 ] EDIT: This is the simplest solution I've seen posted so far. It also solves 80% of what you need. Yay. The hard requirement here is having everything processed in JS and using only static files on the server.
Holy fuck that dial is annoying on a trackpad
I'm a recent convert. YUI is awesome. Perfect toolkit for building an event-based MVC framework. Highly recommended.
Coffeescript is a train wreck. 
The graphing tool look nice. I might use that to throw out the flash based monstrosity I use now. 
If you have to ask, you're not the one to do it. This sort of thing can be done in any language, although JS is a very bad choice, largely but not entirely due to its general lack of datastructures and filesystem access. If you insist on trying, google "n-gram search".
This is an extremely bad mechanism. Try benchmarking it against any other text search mechanism before rabidly insisting I prove it to you.
Don't forget battlers too. I loved pokemon battling in aol chats. You had to grab your own copy though so you could save your favorite team for easy loading.
Good point. You convinced me. What was I thinking?
Javascript is one of the easiest languages to learn and work with. Sure there are a few gotchas but they exist in plenty of languages and are so basic that any noob will learn them within a few months of working with javascript. Coffeescript won't give anyone an advantage in the struggle to deliver working software. At best it is a crutch, at worst it prevents someone from effectively debugging their code using the best tools available. Good luck finding great coffeescript programmers, while there are plenty of great javascript programmers. A great programmer could likely deal with coffeescript but would they really want to? I know i'd pass on any job that required me to code in coffeescript. I admit that I am a javascript purist and i've been coding javascript every day for the last 15+ years, so I don't really have any need for coffeescript, but I just don't see it as beneficial to anyone wanting to become a great javascript programmer. Coffeescript adds another layer of complexity on top of all the layers of complexity that occur in web development. I work on complex web applications with 100k+ lines of javascript code and there is no problem that coffeescript would solve that can't be solved by just using best practices and having competent javascript programmers. Until firebug fully supports coffeescript, coffeescript is a hindrance, it ads friction (frustration) to debugging, not a good thing. I get why non-javascript programmers might want to use coffeescript, but I don't see it helping anyone when they need to debug something written in coffeescript. 
I agree Javascript isn't that hard, but it has a lot of syntactical awkwardness required to get it to do what I want. And yeah, I've been doing it for 10+ years, and a lot of simple things still feel clumsy. I don't think using Coffeescript eliminates the need for really understanding Javascript, and I don't think that's the point. You still have to understand Javascript's object model, what inheritance means in Javascript, etc, but you have a nicer, more concise syntax to express those ideas with. It *is* another layer of complexity, which does feel a bit gross, and I agree that without firebug providing line-by-line debugging, it makes it more difficult to imagine using it in a production environment yet. But I used to think the same thing about sass vs css, and eventually the tools caught up, and now it's easy to debug sass with Firebug. It seems like the same thing is happening with Coffeescript. Maybe it's not ready for use in every JS situation, but it is definitely not a trainwreck.
Thanks!
Exactly. So the CDN is just another brick in the wall. If you already use any other service provided by Google (adwords, analytics, maps, ...?), adding the CDN doesn't make a difference. Of course if you want to keep your site Google-free, you shouldn't use the CDN either.
Next up: "Stop calling it HTML5!"
Oh all-powerful canvas, is there nothing you can't do?
This looks extremely handy, I'll definitely be giving it a shot. Thanks!
rePublish ( http://romeda.org/rePublish/ ) implements this for something useful, although it doesn't abuse canvas for it.
Similarish stuff: [.tar.gz streamer](http://fhtr.blogspot.com/2010/05/loading-targz-with-javascript.html) [ID3 Reader](http://www.nihilogic.dk/labs/id3/) [Exif Reader](http://blog.nihilogic.dk/2008/05/reading-exif-data-with-javascript.html)
post your findings, I'm still debating if this is worth my time or not :)
Or you could gzip it and let the browser un-zip it for you.
Well that's interesting.
 The code generated by coffeescript is awful, good luck trying to debug this shit. You must be a masochist to think this is the right way to do things. It's this kind of hacky shit that gets swept under the rug in a few years after the buzzword factor wears off, and people decide to just hone their javascript skills instead of messing around with worst-practices.
Upvoted for pure inanity. ;)
Fuck the snow
So far my biggest problem (using jslint via juicer) has been that it apparently uses triple space indents for some reason. Supposedly the output should pass JSLint though.
The benefit of CoffeeScript is that it tidies up some of the ugliness of JavaScript and prevents you from making some really silly mistakes. It's like a JS framework that's integrated into the language itself. The syntax is also a bit cleaner, though some of the ruby-inspired stuff takes some getting used to (e.g. function calls).
I didn't realize Tom Fuchs and Amy Hoy were this desperate for cash...
Yeah, screw this newfangled ruby/python inspired nonsense. A true JS substitute should try to look like Perl. Maybe with more ascii art in it.
Work on IE? http://instantrimshot.com/
Add this to the end of your code and all will become clear: i = "closures dude"; 
The problem is that i is a global variable. It loops through each node, so your alert in the for loop will indicate the state of i at that time. That is, 39. The for loop then continues on its merry way until i = 74. Now, when you go to mouseover that link, the anonymous function is called which runs the over function with the current value of i, which is 74, not 39. What you need to do is pass the value of i into an immediately executed function which returns another anonymous function. Something like: nodeList[i].addEventListener("mouseover", (function(k){ return function(){ over(k) } })(i), false); The variable i is passed into the function and stored in k. The anonymous function within there accesses the value k because of the closure.
Thanks for the help. Just out of curiosity why does it not use the value of i in the if statement. It seems that if I add the listener inside a if statement it should be added immediately and use the value of i within that if statement.
While it would work, a function returning a function is a bit complicated. Simply call an ordinary function and you'll have all the closure you need. For example: var nodeList = document.getElementsByTagName("a"); for( var i = 0; i &lt; nodeList.length; i++ ) fixup( nodeList[i] ); function fixup( node ) { if( node.href.match(/imdb.com\/title/) ) { node.addEventListener( "mouseover", function() { alert( node.href ); }, false ); } } Note that the index value `i` isn't used at all inside the function. You don't need it, because you have a reference to the node itself. You could easily pass `i` as another parameter to the function if you need the index value too, but I don't think I'd recommend this: what happens if some A elements are dynamically added or removed after your initial script runs but before your event handler is called?
Yea, you are correct in that the function doesn't even use the value of i in the function but wanted to address the OP's question of why i wasn't retaining the value they expected, since I felt this was really more the issue. For example, I usually wouldn't go through the hassle of creating a new style attribute and setting a nodevalue. I'd just do "node.style.color = 'red'".
Other people here have solved the problem. I would recomend reading "Javascript, the good parts". It deals with this topic and a number of others you are likely to be dealing with at this point.
JavaScript variables have function scope. So, the value of i continues to change within the context of that scope. The variable isn't declared within the listener, it's declared outside of that. 
So if I understand what you are saying correctly when the listener is added it isn't added with the value of i but rather with a reference to i itself. So then when the listener fires its not like it already has the value 39 but instead has the reference to i and since i is global it could have changed between when the listener was created and when it fires. Is that right? Thanks for the help I'm still a student and haven't had much experience with javascript outside of class so I'm still learning.
Yes, that's correct.
you may think i'm 'old' or stuck in my ways, but coffeescript is the equivalent of a rube goldberg machine. a programmer with any bit of wisdom would be skeptical of it.
which would you prefer, to debug 50,000 lines of coffeescript or 50,000 lines of javascript? You will be doing twice the work if you choose coffeescript, and that should be very obvious to see. 
The code it generates is not bad. Compared to Objective J and GWT Java, it's very readable. They're considering debugging tools that map JS errors to CoffeeScript lines, so hopefully this is a temporary situation. You'd be doing 30% more work if you encountered a tough bug, it would require in depth understanding of JS quirks, like those annoying Array.prototype.slice(wtf).apply().call() monstrosities that you probably avoided learning if you work in CoffeeScript. People are using CoffeeScript and I haven't heard any dramatic complaints about debugging. I wonder how Objective J handles it. Here http://www.postpeakliving.com/content/debugging-cappuccino-using-safari it's much worse.
Instead of regexing every single link in the Page you should think about using xpath to select the elements. I would give an example but im on the iphone right now, ill do it later! /edit: var links = document.evaluate("//a[contains(@href, 'imdb.com/title/')]", document, null, 6, null), i = links.snapshotLength; for (var x = 0, x&lt;=i; link = snapshotItem(x); x++) { doSomething(link); }
Why would you be doing twice the work? Debug the coffeescript and recompile. Am I missing something?
No matter if something maps to coffeescript line numbers, you are still going to need to know why it failed in javacsript and why the coffeescript that generated it caused the fail. The elegant simplicity of javascript + json is lost on those who won't learn it in favor of this muck. 
Js lint prevents silly mistakes
Not always. Either way we'll have to see from usage, not conjecture. The design by committee disaster that is JavaScript and DOM is far from elegant. They should expose lower level APIs to make efforts like CoffeeScript, JQuery and LESS easier. If it wasn't for JQuery and Prototype JavaScript would be irrelevant by now.
What would the advantages to this be? speed? I remember learning a bit about xpath but not too much about when to use it. EDIT: Thanks for this ended up using it
javascript throws an error, undefined at line number 3065 - this does not correlate in any meaningful way to a line number or piece of code in coffeescript. you have to figure out where in coffeescript the generated code that is throwing the error came from first, then figure out why in javascript undefined was causing a problem, and then figure out why in coffeescript an undefined was caused. this is just an example, it's possible there are no 'undefined' errors in coffeescript at all, but there will be other types of errors that are likely more frustrating to fix. it's a masochists dream come true. if you just coded in javascript, and knew the language it would be much easier to debug the code. I can't imagine picking up a large codebase done in coffeescript and trying to fix it/hack it without seriously pulling my hair out. it really would be twice the work, no matter how you slice it.
As wtfmf said you understand things correctly. I recommend [John Resig](http://ejohn.org/)'s JS tutorial [Learning Advanced JavaScript](http://ejohn.org/apps/learn/). It covers this common mishap and many more, but you can go through it in less than an hour.
Thanks for this I'll give it a look over. Someone else in this thread suggested using xpath instead of a regex is there some advantage to doing this? 
There is an advantage in code brevity and clearness of intent. In this case the xpath knowledge required is minimal so it's a good solution, and Xymak1y even gave you a nice example to use. Honestly, 9/10 times I'd go the lazy route and just [use a nifty jQuery selector](http://stackoverflow.com/questions/303956/jquery-select-a-which-href-contains-some-string). Probably not worth the dependency in this case though.
After text.innerHTML = "http://en.wikipedia.org/wiki/The_Game_(mind_game)"; Add text.href = "http://en.wikipedia.org/wiki/The_Game_(mind_game)";
Also, if you're just learning you should definitely look into using a framework such as jQuery. There's a lot merit in knowing vanilla javascript as well, but jQuery helps you keep code clean and cross browser friendly. :) Plus, great documentation.
Its much much faster! I dont have any benchmarks right now but using xpath handles the html site as a xml document and can navigate much faster. Regexing every single link is really slow. Also, regex should be avoided when possible in general so you should look into indexOf() when testing content.
Alternatively, you could take advantage of the much simpler querySelectorAll which uses CSS to locate elements. var links = document.querySelectorAll("a[href*=imdb.com/title/]"); 
I have to agree with the author. In all honesty, I've never ever ever had an issue that I feel a script loader is a valid solution for. 99% of the time, you shouldn't be including more than a half dozen JS files (usually a library like jquery/prototype and a minified/compressed version of your sites' JS). As long as all of your logic isn't fired until document.ready (or window.load if you don't need the DOM) - what is the point? Your users are still going to feel the page isn't loaded until the images have rendered, and by that time, your JS will have loaded and doc.ready will have fired.... perhaps someone can point me to a valid use-case where script-loaders are the only solution - I just don't get it.
Out of interest which datastructures, that javascript lacks, would be useful?
1) Gather a bunch of 3rd party plugins and tools to make jquery resemble other frameworks more suitable for a large scale project, such as Ext JS, Prototype and MooTools. 
I was under the impression that jQuery wasn't suitable for large scale applications.
2) And somehow get a better toolkit because the authors of these 3rd party libraries focused in on the domains.
Understood, but the point is still true that a function-returning-a-function is not the only way to get a closure. A simple function call is all that is needed, and it is much less daunting for someone new to the language. Here is your example written with a simple function call: listen( i ); function listen( k ) { nodeList[k].addEventListener( 'mouseover', function() { over( k ); }); } That does exactly the same thing, and I think it is much easier to understand. Don't you?
You are correct in that a function-returning-a-function is not the only way to get a closure. You're code does lose the visual clutter but it separates a single action into three parts instead of just two. A coding style judgment call and one I could go either way on. Generally, I use a JS library and would take advantage of object binding which abstracts the function-returning-a-function so that the code looks cleaner than both of our examples. :)
Not sure what the reasoning would be behind that. Large scale applications are more based on your understanding of JavaScript and overall coding not 3rd party libraries.
Yeah, but straight code is *usually* more efficient than library code.
Ah yes, using my own home-rolled code that I test on the limited numbers of browsers/OSs I have is a FAR better choice than using a lib that has a number of developers dedicated to it, an open bug tracker, and a huge number of sites both large and small hitting it every day with real world tests!
After modifying your test to actually compare similar things (csv to JSON arrays, instead of JSON objects), the difference is a negligible 5 to 8 milliseconds. That's a micro optimization in parsing, which isn't a typical bottleneck in UI responsiveness. Also, all of your retorts are valid only when you're considering arrays. Yet, how often is it that an application can get away with only passing simple arrays (integers only or strings with no commas)? Having to have two different mechanisms to encode/decode is one too many.
MM_* always sucked.
Regardless of the value of this article's content, I'm really, really, realllllllly not a fan of Reddit users who submit [all of their own content](http://www.reddit.com/user/legacye/submitted/). It's pretentious and conceited. Also not in love with the obnoxious header on the site that pushes the actual article entirely off-screen on a 1680x1050 monitor.
Doesn't work in Firefox 3.6
Nice, but the real question is, did you have any time left to play after you finished making it?
i dont think the current fox has good support for canvas :/
Other things in canvas work fine [like this](http://www.reddit.com/r/javascript/comments/es2d3/got_stuck_on_holidays_without_a_cribbage_board_so/) but it doesn't have animations.
I beleive this will work. used it a while ago. // convert to string data = data.toString(); // parse.. var xmlDoc = new DOMParser().parseFromString( data ); you should then be able to interact with it with jQuery by using it in the context for a selector. $('#something', xmlDoc ).jQueryMethod();
I was trying something similar to this but kept getting not well formed errors in firefox's web console is that because I'm doing something wrong on my end or is that the fault of the page I'm getting? FYI: I'm trying to get information from IMDB pages like [this](http://www.imdb.com/title/tt0414993/) for example
your HTML is not well formatted XML document. just parse using jquery $(data.toString()).find(...).jQueryMethod();
Seems sorta obvious; the problem with lots of small images is that the HTTP overhead ends up outweighing the actual payload significantly. When you're loading a bunch of large images, the payloads make the HTTP overhead relatively insignificant. Adding Javascript parsing to a lot of data is going to obviously decrease in performance as the amount of data to be parsed increases. Just use data-uri stylesheets for small images and call it a day.
I was wondering why google applied this pattern to the page previews - these images are huge. So I tested. Besides reducing server connections, which may help when the infrastructure has a problem with that, I can't see any benefit at all. Anyway, we are trying to realize any performance benefit possible with our imaging framework and already are at a point where single digit milliseconds saved are a huge percentage. The need for speed. 
Reducing http overhead is more easily achieved by reducing http chatter. That's cheap and simple. No need for a http image response header to be more than minimalistic.
How do I include jQuery in a greasemonkey script? Is there anything special I need to do?
interesting... the only difference I can see is that it doesn't use images or "setTimeout". i really should download a few more browsers for checking purposes.
just add this: var $ = unsafeWindow.jQuery; than try this: alert($('&lt;a&gt;hello from andray!&lt;/a&gt;').text()); 
I got this alert("Happy New Year andray"); :p Seriously though, I saw the alert is that good?
yes! :)
yes. the jquery parsed the xml '&lt;a&gt;hello from andray!&lt;/a&gt;' and query text out of it for alert(...)
So I should be good to go using jQuery then?
You should learn about document.body and the dom selectors like document.body.querySelector and document.body.querySelectorAll... Learn that before going and using jQuery... jQuery's DOM parsing methods are mostly just syntactical shortcuts to these things... you're not going to learn anything at all about what you're actually doing if you just jump right into jQuery. You can do this with external HTML/XML by just inserting it into a DIV in the current page (hidden if you don't want it to display), and parsing with the rest of the DOM.
thank you.
you have two closing noscript tags
I know this has been posted a thousand times before, but it is so good I have to post it again. http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
When I try to do this I get a exception "Node cannot be inserted at the specified point in the hierarchy"
Ah reddit!
What the hell- this isn't what jsonp is at all! The idea behind jsonp is to load json data through a quick function to allow cross domain requests to occur easier- this is all about quicker image loading by using base64 encoding. There literally isn't anything at all having to do with json or jsonp in this article at all. Don't get me wrong, this is an interesting idea (although I don't see why it would be faster than using sprites to load one single image), it's just not what it claims to be. Loading all of the images in one go- whether it be through a sprite containing all the images or through this javascript/base64encode technique, is going to cut back on some overhead and will allow all of the images to be preloaded and cached (making subsequent effects faster).
Here's to you, Mr. Web Developer Geek. You may be sitting on the sandy shores of a warm, Jamaican beach at 3 in the afternoon, sipping cocktails with fancy little umbrellas and playing cards instead of writing code, but what do you do when you realize you *don't* have a cribbage board? You don't reach for a sheet of paper, like a normal human. No, you reach for the laptop and you *get busy*, until four hours and four hundred lines of code later, you've made your own cribbage board from *nothing but ones and zeros*, delivered electronically to the *entire world* via intermittent hotel wi-fi. So enjoy that fruity cocktail, Mr. Web Developer Geek, and play that card game, and record those points on your virtual cribbage board *like the sexy beast of a nerd-man you are*. You've earned it. /RealMenOfGenius Seriously, though, nice work. :)
[html validator](http://users.skynet.be/mgueury/mozilla/download.html "for firefox, no chrome equivalent that I know")! 
Knew immediately what the link would be before even reading the URL :)
Chrome does it automatically. Just right click and hit "Inspect Element". See that red x in the bottom? That means you have errors or invalid code. 
Web Developer Extension for Firefox and Chrome seems pretty good. It has tools in its menu to validate html, css, links, feed, and a couple of others I don't know about yet. 
See: http://api.jquery.com/load/ (scroll down to "Loading Page Fragments")
Nice job, Firefox has great support for canvas. It works fine for me in 3.6, just slower than Chrome.
$(thehtml).find('table'); this will return all tables from your html markup. example: alert($("&lt;p&gt;&lt;div&gt;&lt;table a='jj'&gt;&lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;td&gt;world&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/p&gt;").find('table').parent().html()); 
the problem is that you are inputing an array object: ['a','b'] and getting back an object literal: {"0":"a","1":"b"} you can convert the object back into an array using a for-in loop, which would look something like this: function objectToArray(obj) { var arr = [ ]; for (var i in obj) { if (obj.hasOwnProperty(i)) { arr[i] = obj[i]; } } return arr; }
From JSON.parse, you are getting object not an array.you can't able to get length of the object by object.length (thats the way it's returning undefined). If you want to iterate the object use for-each loop.
thanks for that, added to the class im writing and seems to got me working again.
no problem :)
works sweet, now i have collapsible nlevel divs. thanks again!
make sure to use SGML mode
That's pedantic bullshit. Why is the JSONP pattern applied? * to avoid problems with cross-domain requests * to further caching in browser and proxy I've never seen these problems in any form of server to server communication. While JSON is a strict encoding, that resembles the javascript object literal notation, JSONP is loaded through an interpreted SCRIPT tag. So it's javascript. The goal is to get data. I guess, most wouldn't deny, that it's about doing that as fast as possible. The strict formal JSONP notation "padds" just a callback plus parentheses around the JSON format. Does anybody parse that besides browser applications? I guess not. So it is sane to "pad" and prepare the data structure as good as possible. And that includes reducing the amount of data that has to get copied around before it's useful. That's why I chose an efficient encoding for IMG data. Could it be encoded even more efficient? I guess not. Could it be encoded in strict JSON notation. Sure and that would look like that: callback ({i:[{d:'data:...'},{d:'data:...'}]}); Would that be faster? Definitely not. Is enriching my test case with actual metadata simply achieved? Sure and it's obvious. 
Nice write-up about jQuery vs Moo Tools: http://jqueryvsmootools.com/
Prototype/Scriptaculous aren't really used much these days unless you use YUI which I think uses Scriptaculous. I'd stick with jQuery personally, the many plugins it has makes it easier to drop in functionality, which imho is the whole point of adopting a javascript framework. 
I like jQuery better myself, but I'd have to concede to MooTools being more rooted in OO principles.
I've used jQuery for a while now. I've dabbled into the others when I have to support a legacy site using them, and I've never enjoyed how they go about doing things. It might just be that I'm too used to the jQuery way of interacting with the DOM, but jQuery just feels right and makes too much sense for me to switch at this point. The only thing I don't like is it missing some greatly needed default language type extensions for things like Strings, but ever since I discovered the wonderful underscore.js library I don't care about that anymore.
upvoted for using hasOwnProperty(). /slowclap
http://validator.w3.org/
&gt; In your experiences, which framework is better suited for full OOP class driven situations. MooTools wins hands down. If your needs are strictly DOM-related jQuery is the obvious answer. However, if you need to work outside of that problem domain MooTools is going to be much better. 1. MooTools' selector engine is just as fast as sizzle 2. MooTools evens out browser differences for *all* objects, not just DOM 3. MooTools has some excellent tools for doing inheritance and mixins 4. Awesome animation and effects tools **Edit:** Correction.
If you want to "develop in a proper OO way" go for Prototype. It has a nice Class object and feels more like a library and not like a DSL for DOM.
100%. Forget extensions and go to the source!
That was an excellent read. Thanks for the link!
&gt; proper OO way OO is not necessarily the best way to think about modern JS frameworks while you're developing them. I suggest that you pick some simple examples (ie a suckerfish menu) and develop it with each one, and see what you like best.
No, the point should be to solve cross-browser related issues. Plugins bloat the hell out of your pages, as they tend to be tailored to as wide a range of applications as possible. Sure, use plugins, but if you have a JS-intensive site you should be either writing your own, specific ones, or paring off all the unnecessary features in ready-made ones. Another issue is that there's a laziness with most developers with regard to use of plugins. There are plenty of really badly written plugins around.
&gt; No, the point should be to solve cross-browser related issues. That's encompassed by "functionality". Drop-in functionality implies it works cross browser, otherwise isn't not really "drop-in" now is it? I do agree bloat can be a problem, but I think that's an issue with the developer doing things they don't need rather than the framework... you can shoot yourself in the foot with just about any useful tool. 
YUI is its own thing. It doesn't use Scriptaculous. It offers OO based widgets. It supports css3 selectors across browsers. You can chain methods easily. Dav Glass has also done lots of demos showing how to use it with Node.js. http://developer.yahoo.com/yui
jQuery isn't a framework. It is a library that makes it easier to work with the DOM. It even says that right on the first page when you visit the site.
There really isnt "proper" OO in JavaScript, but frameworks like prototype and mootools tend to build constructors that will mimic proper OO, but does JavaScript-style (prototypical inheritance) under the hood. I honestly dont understand the jQuery hype. To me it is very difficult to get things done with because of the forced fluid interface (method chaining) and a lot of the method naming seems strange, I can go on. jQuery is very capable, I've built pretty large apps using it, I just wouldnt recommend it. MooTools is my preference. It does everything jQuery does and more, as mentioned above, check out http://jqueryvsmootools.com The main knock against mootools and prototype is that they extend the native objects and they do not sandbox their environment. That has never been an issue to me. If you're looking for full "oop" go with MooTools(my preference) or Prototype.
Ah, thank you for the correction then :)
I want to call out some misconceptions here. Javascript is an Object Oriented language. It uses [prototypical inheritance, and is very powerful at that](http://javascript.crockford.com/prototypal.html). Trying to kludge it into acting like a 'classical' inheritance system is missing the point. C++/Java style inheritance is no more proper than prototypical inheritance. In fact under strict thinking, even Smalltalk (what with its Meta-classes, and object constructors) isn't really even a classical inheritance system---its just that the tools we use hide that from us. Classical inheritance has its place, but it makes things like multimethods, and multiple inheritance harder than they have to be.
Extensions are great if you're working locally and can't be bothered to put things in a public IP staging area.
I have found ExtJS very nice for large projects.
I have not used Mootools, but I've used Prototype/Scriptaculous and jquery extensively. For standard DOM manipulation stuff, jquery is much better, but Scriptaculous is quite a bit easier to use for doing animations, drag/drop, and things like that. Prototype adds a lot of boilerplate to the builtin data types, which is very useful, but also has its drawbacks. I personally like that they filled in a lot of gaps on the basic data types, but I understand why people dislike them mucking about with the base classes so much.
Please take a look at Dojo Toolkit too. It has a pretty mature module, class and mixin system. It's also better suited to full-on web apps than jQuery IMO.
Hands down? Perhaps not all fingers. Something that still keeps me away from MooTools is their pollution of the DOM. It's almost criminal how much crap they dump in there. 
thanks Skeww and Andray71, that was exactly what I was looking for.
Keeping the script, markup, and stylization separate and encapsulated (JS devs sometimes call this unobtrusiveness) is a practice that has been recommended for years, with or without the use of a framework/tookit. jQuery is my reco, only cuz that's what I (and 80% of websites) use. It's plug-in design methodology encourages extensibility while reducing the likelihood of conflicts and runtime errors.
I take it you wrote this bullshit article then? Look, I'm not denying that faster is better. But I wouldn't call a sports car a bus. You can't just make up names for shit or call one thing another. JSONP means something, and what you're talking about breaks that meaning into something else. If you just ditched the completely false label then your other points- regarding speed and all that- would still stand.
People always bring this up as a negative, but I've never seen an example where it is an issue. And crap? They extend native prototypes with methods if they dont currently exist. IE. IE has Array.indexOf foreach, etc. 
at this stage im tending to lean towards prototype. Ive used it quite a bit in previous years. Ive been doing alot of reading on toolkits. Ive learnt that MooTools is a port of ProtoType. it seems that Mootools and Jquery are the most popular, but from reading, this is because they are quick to implement and are strongly DOM orientated. Then it comes down to Prototype, Dojo, and ExtFS. Ive built a CMS in PHP/mySQL/HTML5 and am now wanting extend its capabilities.
ive always worked that way. php, html, css, jscript etc, all kept in seperate class based files. Makes things reusable.
Pollution? How so?
I dont have the link handy, but a survey last month put Protaculous as the second most used library at 32% of developers, directly behind jQuery's 58%. MooTools and YUI comprised the bulk of the remaining 10%. If you're doing more then just DOM manipulation, it is the library of choice.
im still struggling to make a decision becuase of the long term development that is going to come out of it. I am however leaning now towards prototype as i have used it quite alot. Although reading, Mootools is twice as fast loading and working than prototype. So i still have to argue with myself to make a decision.
I'm far more bothered by jQuery's standard procedure of putting EVERYTHING on the $ object.
All four of your points also apply to Prototype/Scriptaculous
True and the only real advantage MooTools has over Prototype/Scriptaculous is size. (Even -core + -more is smaller)
With mootools you get a built in scriptaculous. MooTool started off as moo.fx, a scriptaculous replacement, then they decided to build a whole framework. I'd say take a look at MooTool since you're familiar with Prototype, you should be able to pick it up pretty easily
&gt; MooTools has some excellent tools for doing inheritance Not like that's a good thing.
MooTools attaches a lot of child objects to the window. * window.Browser * window.MooTools * window.Selectors * etc... This is bad for compatibility sakes. What if I have an existing intranet application that some (not very smart) previous developer created and crafted a window.Browser object. Now you have a situation where MooTools or the existing app could potentially replace data in each other's objects. Very unattractive situation. Keeping a global DOM footprint as small as possible reduces the amount of possible collisions. With jQuery you can even change the global object jQuery uses from $ to jQuery, DOMLibrary or anything else you want to name it. Handy.
 var htmlDoc = document.implementation.createHTMLDocument(null, "html", null); htmlDoc.documentElement.innerHTML = htmlString; // htmlDoc.documentElement.childNodes is now a list of the top-level HTML nodes from your string
I call it a negative because I have a whole slew of intranet applications that I'm exposed to that have JavaScript done by a range of developers, many who flat out hate JavaScript. That leads to lots of global functions. Some were nice enough to wrap them into global objects but there are definitely cases of window.Browser that these devs have created that would be destroyed by MooTool's window.Browser. As for IE doing Array.indexOf that isn't a strong argument to me. I can't change what a browser does to the DOM. However, I can choose what JavaScript library I develop with so I can reduce the global pollution. It's all about being a conscientious developer. Don't leave a mess behind. Make it easy for other people to work around your code. Modular is good.
Just putting in my vote here for Prototype/Scriptaculous (Protaculous). I've been using it fulltime for about two years now (first used it ten years ago, but wasn't doing a lot of dev work). The additions to the native objects like arrays and strings, and the more specific use objects it adds like Enumerables save me LOADS of time. I also prefer the fact that Prototype's DOM functions give me the actual elements, not wrappers for the elements (I don't mind the DOM pollution, as it makes things easier). The animation controls that Scriptaculous provides blows jQuery out of the water, you have far far more control over how an animation is rendered and the syntax is (imo) more programmatically sensible. Animations are collections of objects, not just sets of functions. Finally the really killer feature for me in Scriptaculous is the Draggable and Sortable classes. You can create drag reorderable lists with a single command, and tie that in to an ajax call with only a few more lines of code. It makes adding sort functions to a CMS dirt easy. I've also dabbled with jQuery and MooTools. MooTools is a very comprehensive library, and it's animation toolset is almost as full featured as scriptaculous. The thing that kept me from using it over Prototype was the lack of features for working with form data, and using that form data in ajax requests. Prototype lets me work with the data as both objects and as serialized strings; MooTools seemed to be strings only. jQuery is spectacular if all you need to do is basic animations, DOM manipulation and ajax requests. If you need to do anything more then that, such as working with data or form management; if you're creating an actual client side app and not just making a static page more dynamic, jQuery is not going to offer you as much as MooTools or Protoaculous. tl;dr: There's nothing I can do in jQuery that I can't do in Protaculous, and a lot I can do in Protaculous that I can't do in jQuery. Also: Neither of these three are _Frameworks_, they're all libraries. If you're looking for a framework you need to evaluate ExtJS or Dojo.
yeh its a tough call, prototype got updated last month, not sure when the last mootools release was. Mootools 1.3 + MooMore OR Prototype 1.7 + Scriptaculous. Looking at the MooTools documentation it seems to remind me a little of ActionScript.
Look at what you find in the real world - and what's all running under the JSON or JSONP label. There's an awful lot of wide interpretations for encodings, labels, using array or object notation, not to talk about encodings and charsets. It's either accept that and try to stay on the good side (of code that's tolerant and flexible) or be a strict nutpicker - but with breaking code. Web dev is one of the areas where extremely talented developers meet hazardous copy&amp;paste artists. I better see, that my code mixes well with both worlds. And, yeah, I think it's bad style to pad JSON only with an untested callback - the same as it's bad style to loop through an objects attributes without an explicit white list. 
&gt; To me it is very difficult to get things done with because of the forced fluid interface (method chaining) and a lot of the method naming seems strange, This is the number one reason I dislike jQuery. There seems to be no rhyme or reason behind their function naming, and everything is put on the same root object. There's no division of functions, nothing even approaching namespacing.
Yeah, I think that I read somewhere that their goal is to be as forward as the next iteration of EcmaScript as possible, so that is why it looks a lot like ActionScript. Funny that you said that, I havent done flash in YEARS and was tasked with doing some flash work. Shit was a cakewalk simply because of my previous MooTools usage. 
you hit the nail on the head for me, client side app. JQuery was fast falling down the ladder. It seemed like a designers library, not a developers. I do want to add some pretty things to my app, but im more interested in improving functionaility. As you have pointed out, im not after a framework, but i do need a library that i can create OO classes that are stored in a js folder. I dont want the JS to touch the PHP or the HTML.
&gt; Although reading, Mootools is twice as fast loading and working than prototype If what you read wasn't written after 1.7 came out, it's out of date. Prototype 1.7 switch to the sizzle engine, and put hooks in place to install any selector engine you prefer. It's now equally as fast as both MooTools and jQuery.
&gt; using regex on html [Relevant.](http://www.weebls-stuff.com/toons/aaaaaaaaaaaaahaha/) That said, many frameworks allow you to treat HTML strings as regular HTML, so you can use HTML in strings the same way you can use regular HTML elements.
Yeah I hear you. This first came to light for me when I used ele.position() and then tried ele.size() thinking that both nouns were about the element.
&gt; 1. MooTools' selector engine is just as fast as sizzle Sorry, that's not even a valid point. Even according to Mootools benchmark, jQuery is much faster: http://mootools.net/slickspeed/ I get 22ms Moo vs 1ms jQuery on my machine. That's a *huge* difference. And that's not even against the latest jQuery.
All your talk about whitelisting, copy/paste artists and everything completely misses the point. This isn't being a strict nutpicker, it's calling something what it is. My code works damn well, so making claims that I'm breaking code just because I know the difference between base64 encoding and json is a ridiculous thing to do. If you ever wonder why your articles get about 0 karma (give or take) and no recognition, just refer back to this. The people on this site tend to know what they're talking about, and when they see someone blatantly mislabeling something as the completely wrong technique they're just going to assume they don't know what they're talking about. Like I'm doing right now.
But, the Slick selector is more accurate. Would you rather have the wrong results faster or the right ones?
Excuse me? your problem is that I use base64? Since when is base64 in basically any transport protocol a problem? I'ld think none since 1972.
Sadly no one cares for Mochikit anymore…
It is the underlying fundamental way to think about these higher level application implementations. I don't see how it's possible to not think about them without knowing it's all OO underneath. But, using examples is a great way to get a grasp on what's going on, especially if it's something you like on output side.
not true. prototype at 160kb vs mootools at 138kb. scriptaculous at 154kb vs moomore at 328kb. SO Proto = 314kb, Moo = 466kb. but i guess you can minimise the scripts and also build them without things you dont need.
Huh? jQuery passed every single selector test, just like Mootools 1.3 did. http://mootools.net/slickspeed/
Mootools 1.3 has a time of 61ms and jQuery 1.4.3 has a time of 41ms. Everything else is an **order of magnitude slower!** And given the fact that most of the time you'll be selecting elements by id or class, mootools performance == sizzle's performance. (They're tied at 0ms for id and 1ms for class) &gt; That's a *minuscule* difference. And that's even against the latest jQuery. FTFY
you should cache it in a cookie so you can close the browser and come back later and finish a game.
Don't be a baby and fix it. You know what MooTools adds to `window` and you *should* know what your application code adds to `window`. If there are conflicts, fix them or use a different library, simple as that. I would also add that there's no reason to use more than one AJAX library on a single web app/site. If you want to use jQuery, use it. If you want to use Prototype, use it. And so on. But only pick one!
Could you elaborate?
Here's the same test against the latest jQuery 1.4.4: http://tests.nvh-group.ru/framework/index.php I get: Moo 29ms vs jQuery 16ms in Chrome (Moo is 81% slower) Moo 114ms vs jQuery 81ms in FF (Moo is 40% slower). I don't consider that a minuscule difference. &gt; And given the fact that most of the time you'll be selecting elements by id or class, mootools performance == sizzle's performance If you only select by ID or class, the argument about selector engine being fast makes even less sense.
Several things. First, your statement about classical inheritance having "its place, but it makes things like multimethods, and multiple inheritance harder than they have to be" doesn't really carry much weight in this particular case since the same can be said for ECMAScript's implementation of prototypical inheritance. Both multimethods and multiple inheritance aren't supported by ECMAScript natively. In fact, the designation of special "prototype" objects via the `prototype` property in itself is reminiscent of specialized class constructs. Yes, objects inherit from other objects, but the mere fact that those inherited objects have to be designated as a prototypes via `&lt;Constructor&gt;.prototype` makes the whole idea more classical than traditional-prototypical. It is only through the recent introduction of the `__proto__` property that the traditional-prototypical idea of direct proto designation has been brought into JavaScript. And `__proto__` doesn't accept an array of protos, only a single object, so still no multiple inheritance here. And since we're talking about misconceptions, perhaps it's good to clear out something about the MooTools class system. For one, the MooTools class system is built on top of the native prototypical implementation, and it doesn't "kludge" the prototypical implementation to act like a classical inheritance system just on a whim. What does the MooTools class system add? Aside from a unified abstraction of both the constructor and prototype (which are separate constructs in ECMAScript), the Class system implements things like weakly-coupled parent method access, protected methods, decorators and multiple inheritance via mixins. The reason why MooTools implements these things as a Class system is because there's no other alternative API that's both practical and elegant. What alternative, "prototypical" looking API can express something like multiple inheritance and decorators in a single declaration? Not to mention an API that could also take care of prototypical implementation issues such as shared object property references or instantiation-initialization separation.
SlickSpeed, I'm referring to SlickSpec which covers a broder range of selectors. 
My problem is you using base64 and calling it json (or jsonp). I think I've been pretty clear about that.
Is it even possible for human perception to distinguish between 29 and 16ms or 114 and 81ms, even? In any case, I'm not sure selector performance is *that* important. Network latency, repaint/reflow, &amp;c.
 * jQuery is a library, not a framework. It's meant to be minimal, and easily extensible, leaving you to pick the best-fitting tools to flesh out your project. * You're not forced to use method chaining in jQuery, but why wouldn't you? [It's fast.](http://tobiasahlin.com/blog/quick-guide-chaining-in-jquery/) * Most of the method names are directly related to existing names in the DOM/JS, this is easy to understand. Besides, the docs are great! * If everyone who writes JS had the attitude that native objects can be extended, there would be conflicts everywhere. Mootools only gets away with it because very few other libraries do it due to it being bad practice. * jQuery doesn't force you to use any inheritance model. There is jQuery.extend() to easily extend objects and a nice [widget factory in jQuery UI](http://docs.jquery.com/UI_Developer_Guide#The_widget_factory). Otherwise you're welcome to use [moo4q](http://moo4q.com), [LowPro](https://github.com/danwrong/low-pro-for-jquery), [Compose](https://github.com/kriszyp/compose), or any other OO setup that best fits your project. I think it's a big advantage that jQuery is so flexible.
Tell that to everybody else, who's using base64 encoded data within json, jsonp, xml or whatever. That will be quite a crusade. And start with inspecting the instant-previews on the result page of google.
You just keep ignoring my points and making shit up. Have fun posting your blog spam to this site and having it get ignored and downvoted.
I have a hard time believing that you are putting in an array and getting back an object. There must be something else wrong with your code and kbjr's work-around isn't fixing the problem that will most likely cause you hours and hours of hard-to-find issues later. You have either adorned the array with your own (non-numeric) property or you aren't using an array at all (for instance, you may be trying to stringify the arguments object).
I've never actually used MooTools, but I never liked Prototypes' variant on single class inheritance. It felt like I was using a different language---not javascript. And if then I tried any traditional prototype (small p) style inheritance, things would break and sometimes spectacularly. If MooTools behaves appropriately (like a library and not like a language refinement) then I have no problem with it. It'd save kludgy code from having to be written if you in fact want class inheritance.
&gt; Don't be a baby and fix it. Easy for you to say, guy. When I was on the maintenance team (thankfully long ago) it was a game of churning out fixes as fast as possible. We weren't allotted time to rearchitect or start over and do things right. &gt; ...there's no reason to use more than one AJAX library on a single web app/site. I agree. In the scope of my work I was dealing with Java and .Net guys who don't know JavaScript. They created a bunch of native JavaScript, tossed a bunch of it into the global scope and hid a little bit behind objects in the global scope. So this was me coming in with jQuery to clean up what I could of their code and reduce clutter.
Thanks for the reply, have an upvote. * Point taken, I like that about jQuery. * That example is **only** faster because the guy is doing $(selector).action(); $(selector).action2(); If he were to do var obj = $(selector); obj.action(); obj.action2(); would there be a speed difference? ** MooTools has the same method chaining as jQuery. The main difference is that what is run inside of some of the methods are object instances that you can pull out and manipulate and refer to later. var p_morph = p.get('morph'); button.addEvent('click', function(){ p_morph.start({}); //animate p's css }); * Ehhh I dont agree with the method naming (the docs are nice though). I've run into quite a few WTF situations with method naming while building jQuery apps. Dont get me wrong, I was able to get the job done, but it was still a "why is it called this?" type moment. * True and I dont have an argument against that. I just personally feel that if you're going to do js development with the aide of a lib, try to stick to that lib. I may be wrong on this, but this is how I feel atm. * MooTools or Prototype doesnt force you to use any model either, they both just have pretty decent ones baked in. When writing with jQuery, I wrote all of my code using the functional pattern. I actually find the widget factory approach limited. It took, what I consider a hack (making the widget instance a global var), to be able to refer to the instance later on in code. //inside of the return for a widget factory plugin $this.data('widget_name', new widget_name_global_fn(this, options)); //outside of the widget code function widget_name_global(obj, settings){ return this; } //usage I had to ask in irc as this isnt documented var selector = jQuery('selector'); selector.widget(//settings); var widget_instance = selector.data('widget'); *edit formatting
Nobody has said this, but the problem is the thing you are stringifying. If you stringify an array, JSON.parse() will return an array. So the problem is with the input. E.g: {0:23, 1:43} Is not the same as: [23, 43] You can't specify indexes when creating an array. While the hacks mentioned to fix the parsed result may work, you should really just fix your JSON.
&gt; Most of the method names are directly related to existing names in the DOM/JS, this is easy to understand. That's not true at all. Unless by "related" you mean "different to". If you learn jQuery then you have to learn a new API. &gt; You're not forced to use method chaining in jQuery, but why wouldn't you? It's fast. It is only "fast" compared with not chaining *jQuery* objects. Chaining itself means that you are repeatedly performing a loop on the same nodelist. This is the kind of thing that is frustrating about jQuery. It's terseness leads people to believe that they are writing fast code.
Definitely not a beginners framework.
jQuery all the way. Don't let a javascript framework dictate your project. jQuery is for dom manipulation and event handling among other shortcuts. It is not a project scaffolding system. Learn javascript first such as closures, scoping, data types, functions etc. Then use jQuery to assist you with dom related necessities. 
It is true for many methods. * All of the events: onfocus -&gt; focus(), onmouseup -&gt;mouseup()... * The DOM manipulation methods: appendChild -&gt; append(), insertBefore -&gt; insertBefore(), getAttribute/setAttribute -&gt; attr(), cloneNode -&gt; clone()... and many more * DOM traversal: nextSibling -&gt; next(), parentNode -&gt; parent()... &amp; more * Utilities: forEach -&gt; each(), slice -&gt; slice(), trim()... It's very useful to repeatedly perform loops on nodelists for actions that must happen sequentially, like form validation or animation. Chaining also saves many bytes/LOC, although that is becoming less important. jQuery's ease of use has lead too many people to learn jQuery without learning and understanding JavaScript first (or at all), that always has been a frustration for myself and many developers. However, *good* JS developers still write fast code with jQuery.
So with the exception of slice() they are all different? And onfocus is not really a method. It's an event handler. jQuery is an excellent API but it's still an API that you have to learn. No need to pretend otherwise.
I believe 100ms is the point at which the average person can perceive a difference. Obviously you'd want to keep script execution down to as low as possible, so as it adds up those differences in speed might push you into the perceivable territory.
Point taken. I tend to copy/pasta my code in or use one of my dev urls so I never thought of that but you make a good point. I would assume most extensions would make use if w3, no?
[also relevant](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags)
Not necessarily. Quick [googling found this Firefox extension](http://users.skynet.be/mgueury/mozilla/) but I can't say its good because I haven't tried it. It uses SGML which is the same parser found in w3.
Too me it's pretty easy. Do you want to deal with people who want to help you, or people who want to thumb their noses at you while they fart into wineglasses and sniff them afterwards. I love mootools but use other libraries because I can't stand the attitude of the mootools community. It's actually pretty easy to use, but they throw that "intermediate to advanced developer" garbage in there because they don't want to help anyone and think that anyone starting out in javascript deserves to be put down. How many iterations did mootools have before they finally realized that they need to actually work with other libraries? Prototype has a great community, extjs does as well - but nothing comes close to the great jquery community. Sometimes we need help and mootools is NOT where you find any. Remember that we were all noobs at one time. tl;dr - mootools is filled with ego, go with another library.
Spoken like a true mootooler. Thanks for the putdown but sometimes development isn't so black and white.
Did you find backbone.js?
&gt; Don't be a baby and fix it. I meant this in the kindest way possible.
Thanks for this its just what I was looking for wish I could give you more upvotes!
i prefer jquery. [maybe these guys will help convince you](http://yayquery.com/)
Old and new Twitter use jQuery. (It's right in the source or script tab. Why didn't you just take a look?)
Yes, it can be done using jQuery with a plugin called [Infinite Scroll](http://www.infinite-scroll.com/). The second website you linked to is using that very same plugin.
&gt;If he were to do &gt;var obj = $(selector); &gt;obj.action(); &gt;obj.action2(); &gt;would there be a speed difference? This is just like chaining except that there is one var more. You interact with the same object either way. So yea, it might be like 1 msec slower if you do it a million times in a row. Doesn't matter one bit. Gzipping your favicon will have a much bigger impact. (Still completely irrelevant though.)
Thanks for the response. For some reason I couldn't see it using the Chrome developer tools.
1. Open Chrome. 2. Go to twitter.com. 3. Hit ctrl+shift+j (or i or c, doesn't matter). 4. Click on the "Scripts" tab. 5. Click on the dropdown (initially reads: "twitter.com") 6. "jquery.min.js" is right there. 7. Click on it. 8. The version number is right at the beginning.
Awesome. Thank you!
I myself prefer *JavaScript*. It's neat and can do all the things those pseudo-languages do, but it's *native*.
I'd say this is better: [https://developer.mozilla.org/en/Code_snippets/HTML_to_DOM](https://developer.mozilla.org/en/Code_snippets/HTML_to_DOM)
i was looking at backbone.js, but working with MVC on and MVC on the client side almost seemed like double work. My first attempt at backbone ended with a halfbreed MVVM pattern anyways, as that seems more appropriate for a client side data display. But depending on your needs, backbone can be pretty useful. Currently for work i am building a web version of our thick client working on web services exposed to it. This is a rush to get the software on the web, with a rebuild of the business logic to come later. With MVVM i can keep all of the work done with the UI even after we change up our database layer and our business logic. 
I saw it; it was bad and must have been an old script.
"jerky and wonky"? Can you elaborate? I don't experience this, and all sites I build are done so on a p4 2.4GHz single core processor with 1GB RAM.
This is good news. I've been using Julian Aubourg's [jsonp plugin](http://code.google.com/p/jquery-jsonp/) to get a working abort method for JSON requests. Good to see he rewrote the whole thing ($.ajax that is). 
im sure each library has its pros and cons. My usage will be a long term usage in a content management system that i develop. So it wont be one site, i will be investing in development. This is one of the big reasons i moved away from jquery. its a good for complementing a page, but i want to integrate functionailty, tweak things, and also use things like JSON, AJAX and XML to talk with other parts of the CMS and then REST for API usage. TLDR, I have chosen prototype.
if its definately not a beginners toolkit, how does it stack up against prototype, which i have used before.
If I use this will I be able to use xpath? EDIT: nevermind I tried doing it this way and ended up getting "permission denied to get property XPCCompenents.classes" perhaps it won't work for what I am doing?
i come from writing functional language, this is my concern with limited libraries. Im using PHP/SQL/HTML/XML/JOSN/AJAX etc and im trying to decide on a language that will further its development, not just enhance a few things. hence looking strongly at prototype. 
If your Javascript runs on firefox, there's no better debugging environment than [firebug](http://getfirebug.com/). With it you can set breakpoints in your code interactively or by adding 'debugger;' statements to your code from the editor.
oh god, the noobness, it hurtz
Chrome has a JS debugger as well. Shit, even IE does at this point.
ah I see, adding breakpoints and conditional breakpoints. I've never used them before, only the way I initially stated. so, I guess this is how most of you guys debug javascript?
Yes. That's how I've learned it at school. 
You may use jQuery to load "infinite content" from the server and append it to the page. But to answer your question: static ("fixed") navigation at the top uses css property `position:fixed;`
Or, after step 3., type `jQuery().version` in the console and hit enter. It'll either throw an error ("jQuery is not defined" - so, no jQuery) or return version number of the library.
Yes, and also simply watching the Firebug (or other) console for errors. Once you're loading your page with one of these debuggers enabled, it will log errors automatically. You can also write to the console yourself with console.log(), console.dir(), and the like.
But they are still no where near as good as firebug mate.
Welcome to 2010, how is 1996? We use console.log() in this day and age :)
I tend to write a little helper method like: function myLog(a) { if ( window.console ) { console.log(a); } } That way if I want to change the way the information is displayed for whatever reason (say I need to test in IE6) I can simply change myLog to do something like ... create a document fragment and append to its innerHTML and push it onto the bottom of the page with appendChild. It also helps prevent stupid issues like forgetting a console.log in the code and having it break when your console is closed. You can get even more fancy and do things like run a Node.js application that accepts HttpRequests and outputs the body and then make calls to it using XmlHttpRequest in myLog. Things like this are cross browser compatible and can show debug data in real-time. The key is the flexibility you get out of writing a little wrapper method: myLog.
I would disagree with this assertion: the webkit developer tools (in Safari and Chrome) are at least on par with a bare Firebug, if not markedly superior (especially the webkit trunk one): the layout is cleaner and it's has more base features (though the DOM/elements pane still isn't as good as Firebug). Not to mention, it is orders of magnitude faster than Firefox with Firebug enabled, and far more stable (stability of devtools is Webkit &gt;&gt; Firebug &gt;&gt;&gt;&gt;&gt;&gt; IE8). And they're built-in. On the other hand, Firebug with extensions *is* still superior to the rest.
And `console.group`, `console.trace`, `console.{debug,info,warn,error}` (depending on the browser, those can add a hyperlink to the line which generated them in your JS files, very handy when you setup *a lot* of logging, which `console.log` does not do), `console.time` or `console.profile`
I'm purely talking about debugging JS. IE's debugger is the dogs balls, and Chrome's is just clumsy.
Dear god man, here is some help: [Fixing These jQuery!: A Guide to Debugging](http://fixingthesejquery.com/) Most of it applies to any javascript, and if you use jQuery, there is a bit that applies to it. 
&gt; and Chrome's is just clumsy. I would enjoy your explanation of this. I'm using the webkit devtools in Safari and the experience is very similar to Firebug's (or my IDE's). I'd even rank it as superior as I can get a console in the same pane as the debugger by hitting ESC, without having to switch back and forth. It also seems to get lost far less in complex, repeatedly loaded or dynamic JS files, with which Firebug has endless issues.
if you just toggle the css display or visibility properties for a menu on a mouse event, the erratic movement of the mouse over the menu items would cause many of them to immediately expand/contract. this affects site usability and does not look very polished. your best bet is to put a .5 second delay on the mouse event. jquery.hoverIntent is easy to set up and use for this. take a look [here](http://blogs.sitepoint.com/2009/04/01/the-right-way-to-make-a-dropdown-menu/) for more info
Are there any good web frameworks for JavaScript yet? I feel like one language for both client-side and server-side programming, and then some basic html/css templating would really make sense for web development...
Take a look at Helma http://helma.org/ or Ringo http://ringojs.org/ Industry proven and very mature frameworks for server-side javascript.
Here is a good [plugin](http://benalman.com/projects/javascript-debug-console-log/) it lets you neatly stack multiple variables into log and disable enable logging for different levels. Javascript also allows for try {} catch (Error) {} which let you track errors without fully crashing your code.
[Ben Alman Javascript Debug](http://benalman.com/projects/javascript-debug-console-log/) plugin is pretty great
[Backbone.js](http://documentcloud.github.com/backbone/) looks pretty sweet and it's by the same guy who wrote Coffeescript and underscore.js. It's a light and flexible framework rather than a black magic Rails-style thing.
Yes..and 2011 is also the year of desktop linux, and duke nukem forever.
What's so popular with server side javascript? It's not a very good language at all, though maybe I just haven't used it enough, but as bad as php is I'd prefer it over javascript (having not used ssjs), and I'd definitely prefer python. For obvious reasons it's not going to happen, but I'd be much happier to hear python is replacing javascript in the browser than javascript is gaining popularity on the server. edit: What's with the downvotes, I'm asking a serious question and yeah I'm attacking javascript to a degree, but it's widely recognised as a bad language, much as php is. I like it for what it is, but I'm curious if there's any compelling reason beyond not having to learn a new language that makes ssjs popular.
 &gt;&gt;&gt; jQuery function() &gt;&gt;&gt; jQuery.version undefined
[Express](http://expressjs.com/) for Node looks really good and many smart folks like it. Haven't used it myself yet.
Actually, 2011 is the year of DNF, you can pre-order it: http://www.amazon.com/Duke-Nukem-Forever-Xbox-360/dp/B002I0HAC6 (yes I'm aware you could pre-order it in 2007 as well, but there have been demos and it looks like it's actually coming out this time)
ExtJS isn't anywhere near the level of 'free' offered by jQuery or Mootools, even though it used to be closer. I won't go anywhere near ExtJS. Seriously, screw them.
I don't mean to troll, but why do we want to run JS on the server? node.js seems pretty cool, but it seems like one of those 'just because you can' type of things. I'm trying to keep an open mind here, but I honestly haven't seen a compelling argument for serverside JS. Would anyone care to share?
Prototype: MIT-style license. Mootools: MIT-style license. jQuery: MIT-style OR GPL license. Take your pick. (Hint: One is more free than the other) ExtJS: GPL or commercial license. You can't use ExtJS without paying for it or open-sourcing your entire project. Open-sourcing your project isn't feasible or even useful in many situations. ExtJS is and always will be a no-go for me.
we'll see to all three. :) i'm a huge fan of all three.
By "static navigation" do you mean keep the menu at the top of the page while the user scrolls? If so, it is position fixed. For IE you need to use JS, test if the page has been scrolled x pixels and then change the top attribute of the navigation element using the onscroll event.
right, my mistake. It's `.jquery`, not `.version`: &gt;&gt;&gt; jQuery().jquery "1.3.1"
Event loop based servers are very lightweight if you need many concurrent connections. You see, threads are pretty expensive. Each one takes a nice chunk of memory. Just for being there. JS is nice for this kind of thing, because writing async event-driven programs is very natural and straightforward with this language. Also, V8 is a lot faster than PHP and JS is also a much nicer (and more consistent) language than PHP.
&gt;I'd definitely prefer python Try Python's [Twisted](http://twistedmatrix.com/) then. &gt;I'd be much happier to hear python is replacing javascript in the browser Take a look at [Pyjamas](http://code.google.com/p/pyjamas/).
a problem with being a self taught web developer is I am missing some industry wide standard practices if I haven't read about it in books or online. thanks everyone for helping me improve. and rtpmatt, that jQuery slideshow was awesome.
&gt;desktop linux Well, there are already lots of Linux powered devices out there. Android's market share is growing and the whole market itself is quickly expanding. There will be also tablet PCs and netbooks running Android and of course there will be also tables and netbooks with Ubuntu. I also really like my little GP2X Wiz (Korean homebrew handheld running Linux). We certainly won't see a significant change on the desktop, but Linux actually is already a very big player elsewhere.
Yes that's what I'm looking for. Thank you.
You can also edit *running* code in Chrome and there is also syntax highlighting. So yea, that's clearly an area where the Web Inspector got an upper hand.
I quite like Linux and Node but I don't see them taking over the world either. Not sure why people like to speculate on this stuff, as if the year turns and suddenly people will make radical changes in how they do things. Realistically 80%\* of web developers are still going to write PHP code on Windows and ftp it to their servers, in 2011, 2012, and beyond. \* Pulled straight out of thin air
Also, `console.table`. http://www.softwareishard.com/blog/firebug/tabular-logs-in-firebug/
And the Linux desktop?
You could also pre-order in 1998.
To be fair, there is at least one syntax highlighting extension for Firebug.
Yes, that works indeed. I always wondered why there isn't a "version" property.
YUI 2 used this same approach. YUI 3 changed that to sandbox everything to avoid polluting the global namespace. It also sandboxes any old YUI 2 code that you load through the YUI loader. I imagine MooTools could be updated to use this approach.
Well, Firebug is already pretty sluggish the way it is. I certainly won't bother trying something like that with Firefox 3.x.
Personally, because the site I am developing at them mo does some client side computation that I also need to be able to do server side at times. Using the same code for both is the obvious answer.
I have no doubt that MooTools could be changed to use a single global object "namespace". It's just a question of if they will. The MooTools team seem like a bunch of smart, dedicated folks but compared to jQuery they move as slow as molasses. That's not necessarily a bad thing, given their goals, but I would enjoy seeing more frequent and incremental releases.
Well, most people think of JS as a "bad" langauge, but frankly, PHP is much worse. A lot of Java frameworks are pretty bad. There are some good langauges I'm sure, but please choose JS over PHP. Its a child's toy. A better reason to use JS on the server is that you can do client and server side rendering without repeating yourself. I think that could be really powerful if once we have the tools to really use it to its full power.
2011: the first year since 1996 to not be the year of the linux desktop.
I use express for the admin site of my startup since everything else is in Node and it does everything I need for that. I still tend to default to rails for quick websites though because of Heroku, but they're working on adding node support, so 2011 really could be the year of server side JS for me. Edit: I know Joyent offers node support already, I should give it a shot :)
What tools are you looking for that don't exist yet? Coffeescript and HAML are two powerful tools that come to mind that work on either side.
&gt; JS is also a much nicer (and more consistent) language than PHP. If you've know JS since the 1990s, that's saying a lot. It's true, though. And JS is getting better.
&gt; Realistically 80%* of web developers are still going to write PHP code on Windows and ftp it to their servers, in 2011, 2012, and beyond. Not me! I write PHP code on Windows using UTF8, Unix linebreaks and a cross-platform editor, and sftp it to my servers. OTOH, I also write code in other languages, plus I have a virtual Linux server for testing.
Although a little tangential to debugging you should also learn to use "throw" (and try/catch) at strategic points in your code. Writing code which throws errors when necessary (and possible handles them elegantly) can make debugging easier because it helps you test some assumptions inherent in your code and give you more specific errors. Just for example, something like detecting whether a string is formatted in the way you expect....something like that may not cause a run-time error....instead you have to watch for weird side effects (which may occur intermittently) and then conduct forensic analysis with the debugger to see what's going on. Even when it does cause a run-time error, it's probably gonna be farther down the line (maybe even outside the block where the error truly occurred)...say when some variable called "results" is now undefined because the string wasn't formatted as you expected...now you have to back-track through the program logic instead of just having the error at it's true source. A simple if ( !isFormated(string) ) throw "string format error" Will sometimes make your life much easier. If you have the debugger to "pause on exceptions" it will just stop right at the problem line, and even tell you what the exact problem is! Additionally error objects may provide little niceties like an error name and a stack trace. The hardest part is learning when and where it's appropriate to throw, catch, etc etc...you certainly don't want every block of your (production) code to have a million sanity checks which throw errors, and you probably don't want to catch every error you throw....you need to find strategic choke points in your code to throw errors, and if necessary handle them. Though I would say during development you might use them a little more generously. This is not a substitute for using the debugger, but something to enhance it, and which also has uses unrelated to debugging.
1. JS is a decent language, it just caries a lot of cruft. I consider Python cleaner, too, but that's largely subjective. It's definitely cleaner than PHP and also less crufty (a lot of the JS cruft is browser-dependent, so it's a non-issue on the server-side). 2. node.js is fast. I don't recall whether it's faster than Python (in many cases I would believe it to be indeed), but it's a lot easier to use than its closest Python equivalent, Twisted (you can run arbitrary TCP services with node.js, it's not a web framework). 3. JS in the browser is here to stay. I could see a similar platform as for Java and .Net being created in the future (i.e. a common bytecode VM), but for the moment it's unlikely. This would also mean that either the browser has to support every language (horrible nightmare!) or you would have to pass compiled bytecode. In either way, it would require a lot of major changes and a common standard.
 /** * Gets a list of all properties in array or object, * executes the callback function with the text. * the callback could be alert, document.write, * or console.log * @param obj - an object or array * @param callback - function such as alert, console.log, or document.write (no parens) */ function debug(obj, callback){ out = ""; for(i in obj){ out = i+" - "+obj[i]+"\n"; } callback(out); }
Its not a bad language, but its extremely easy to write bad javascript generally due to the lack of understanding regarding closures and variable scoping.
Also all the ancient (or just bad) "tutorials" still out there on the web.
I love javascript too but... &gt;It has some sweet debugging tools Dude, seriously? Firebug aside... like, what? Ever debugged in a language like c#? Theres no comparison. Again, I love javascript, but its debugging tools are comparatively sad compared to a lot of other things.
Thanks, that's pretty helpful. I didn't really think about the fact that the cruft, as you put it, would be cleaned up on the server side, but that's a great point. I guess if python, or anything, were implemented by browser devs independently as it were being standardised it would be a lot less sane to use as well.
The good debuggers are browser based. IE's debugger with 8 and 9 are definitely getting there. Debugging Javascript with older versions of IE in Visual Studio wasn't half bad, either (so long as you didn't need visibility to the DOM). Safari has a great debugger. You of course mention Firebug, which is widely considered to be awesome (although its road has been bumpy at times). Opera has Dragonfly and Chrome has something or another (haven't had to use it, yet).
I still wouldn't call any of these "great", merely "adequate". I'm not trolling. I mean I write javascript for a living... but it still has a way to go in the debugging department. Especially in terms of ajax and performance benchmarking. &gt;Debugging Javascript with older versions of IE in Visual Studio wasn't half bad It was pretty shitty, man. most of the errors thrown were uselesss, as were the line numbers. All that aside, I certainly think javascript is a great and expressive language, but lets be honest here. Its always lacked in the debugging department, and still does. &gt;It's the web browsers that I usually have issues with. Now that's certainly true :) (i'm looking at you older versions of IE)
Nope. I worked as a front end engineer the last four years, including 6+ months projects with tons of front end code; and never felt the need for breakpoints. I pause to think about what the problem may be based on the symptoms. Then I try to locate the problem with console.log() calls. Typically I have my own logger function that will pass arguments to console.log() if present, otherwise to a IE compatible script with no dependencies that dynamically adds a div and outputs messages into it. This means that I can do 100% of my debuggin in Firefox + Firebug. In IE I only read the debug output from my custom console log() function. Good code runs equally well in all browsers, taking their limitations in consideration, so there is no real necessity to use debug tools in each browser individually; only to test in each browser environment. Alternatively you may use debug consoles provided by frameworks like YUI 2. I prefer to use my own because it's only a hundred javascript lines, doesn't need an image and has no dependencies so it can be thrown into a lot of projects. In Firebug, I will typically use printf style arguments to print the content of variables. Once it is printed out, you can simply click to look inside arrays, objects, etc. For example console.log("MyClass::init(%o)", options). Something extremely helpful is to build tools that will strip out all the log calls from the production code. That way you can leave logs for the main functions, class constructors and such, which gives you at least an overview of where the code may have frozen. You can always check that every object created is properly destroyed (OO patterns), or simply that a log at the end of your app.init() routine was actually printed. The latter is very helpful to detect bugs. Always add a console.log('done') at the end of your window load/domready routine. I have a simple php tool that parses include-like statements, and a --strip option to remove any function calls. Better yet, this tool also works through htaccess so in development it will "build" a single javascript file from as many classes I want without manual build. The production build creates files instead of just returning output, and adds minification. The thing that drives me mad in Javascript is that I've never managed to use exceptions succesfully. Exceptions sometimes show, sometimes don't, I don't know why :( Personally, I've got a bad enough habit already of hammering the keyboard before I can document what a function will do; so I would rather slow down and fix problems by deduction than fix problems by "patching". 
Well, the first and most obvious are linked lists. There will be some agonizing pimply faced teenager stepping forward to tell me that arrays containing references to other arrays are lists, because he's never had a CS class and doesn't know that a set of connections doesn't make a list. Next are hashes. Javascript people usually run screaming to point out that objects are hashes, but of course objects are containers, not datastructures, and you have no performance guarantees. Indeed, if you look, they're usually c++ std::map&lt;&gt;s, which in turn are also containers, but specified in a way that they pretty much need to be red-black trees or an exotic variant thereupon. Next would be trees. At this point half the JS people will be saying "but you just said objects are trees," because they missed the point that just because something is implemented in one way in one browser doesn't mean it can be relied upon, which can cause critical performance problems in code. The other half will be pretending to themselves that nested arrays or nested objects are trees, because they think that if data is stored in a certain shape, then it's suddenly magically that datastructure. Multimaps would be nice, and are impossible in this language. Following that would be proper strings. The ECMA specification is written in such a way that not only are you unable to tell what encoding your string is, but even what encoding is safe - only Unicode is required, and for anyone who knows the difference between UCS4 and UTF32, that brings a spine-shudder of disgust and fear. This becomes especially apparent when someone notices that nobody's ever specified an encoding mechanism for AJAX, meaning it's not possible to safely transfer unicode data without some godforsaken home-rolled serialization. Queues, stacks, priority queues and deques would be huge. You can't implement a huge pile of algorithms efficiently without them, which is why you've never seen a video game server backend for anything more complex than poker in Erlang, which should be magic for this sort of thing (when you try implementing A* without a pqueue you'll get why; immutability is performance poison.) Following that we'd like the remaining basics - heaps, tries, real vectors, sets, multisets, binaries, et cetera. Honestly, if JS had a sandboxed pointer, a reference, a declense, an address, whatever, the whole thing would be moot, as 101 students could start filling in the gaps. Then we could move on to fun exotics afterwards. Same problem ActionScript, PHP, Haskell and so on have. But hey, Brendan Eich, the guy who couldn't even write a language where the end of the line wasn't ambiguous, says that pointers are too hard and too dangerous. (sigh)
I don't know c# debugging is pretty good, but still has shortcomings (like finding where caught unhandled unrethrown exceptions are coming from)
Heard this before. It was wrong last time too. No decent datastructures, no parallelism, no language extension. No hope. Web developers, it's time to learn a second language.
&gt; Well, most people think of JS as a "bad" langauge, but frankly, PHP is much worse. The hell it is. You have no justification for this other than the blogs you read.
&gt; Also, V8 is a lot faster than PHP Whatever you have to tell yourself, sunshine. Let us know when Facebook runs on Javascript backends.
&gt; It's definitely cleaner than PHP I am so tired of hearing novices who half-know two languages fake-compare them by reciting proggit wisdumb.
There are some damn fine tools such as JS Beautifier to fix type errors and JS Lint to show syntax errors.
&gt; Are there any good web frameworks No.
I didn't say its perfect, I only meant to use it as a benchmark to contrast with javascript- which I feel has many, many, many more shortcomings in the debugging department.
I would agree with this as well as misunderstanding of the language as being the biggest problem with JavaScript currently. Many people use JQuery and consider themselves to be JavaScript ninjas but in reality they don't have a clue about the language.
While it is crude, alert() works. But when you start doing fancy stuff in DOM events for drag and drop for example, you will be in trouble. That's why you need something "non intrusive" like Firebug's console.log(). I'm a big fan of Google Chrome nowadays, but continue to use Firefox+Firebug for development and inspecting pages. 
So I do VS/C# at work, but pretty much all the debugging features I use there, I have in Chrome. Breakpoints, conditional breakpoints (I think anyway, if not Chrome than Venkman), stepping, run to cursor, variable inspectors, and a REPL which is better than the crippled intermediate window. Javascript doesn't have threads or manual memory management, so I'm sure VS has some more complicated features since it supports these in at least some of its languages, but I've never really dived into that day to day at work anyway. Where does C#/VS blow it out the water for you?
Facebook uses a compiler (called HipHop) which generates C++. So yea, PHP was just too slow for them.
Sorry, Charlie, but Facebook actually runs very little on HipHop. Notably, PHP without HipHop ran FaceBook, the world's largest dynamic site, in 2009; the example stands. Claiming JS outperforms PHP is a gigantic red flag that the speaker has no clue what they're talking about.
I have used PHP. It was brief but horrible.
http://shootout.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=v8&amp;lang2=php
That you used a language briefly and now feel empowered to comment on it pretty much says it all.
I'm gonna add a bump for [BlackbirdJS](http://code.google.com/p/blackbirdjs/). Just include the js and it works on all platforms, not just one's with support for console logging notation. 
My god, a set of badly chosen performance indicators, implemented by people who don't know what they're doing, which have no basis for claiming it's a representative sample of the work done in production environments, which leans heavily on the standard library in one and hand-implementation in the other, shows a bias? The problem with idiot benchmarking is that it measures useless things. You might as well point out that a Geo Prizm has more horsepower than a Lamborghini Diablo, because you went to drag this safe across a river, and the Diablo couldn't even finish (after all, Diablos float, and Prizms don't.) Call me when you figure out how to measure this adequately. 
rofl
I would agree for a lot of JS devs, day to day debugging is largely "wait for/throw run-time exception"/"watch console log". Personally I only find myself actually setting breakpoints and stepping through a block fairly rarely...almost exclusively to track down weird Browser/Library quirks. However, I would say being adept at using the debugger is imperative for all JS devs, *especially* newbies. More experienced devs write code deliberately...in most cases when their code throws an error, they can usually relatively quickly infer what is going on based on the (un)expected results or by going back and looking at the code "oh, I forgot to toString() before I x'd..." When that fails though, the debugger will save you a lot of aggravation. On the other hand new JS devs write code in a groping and half hazard way. Being able to step through a block of code will help them infinitely in understanding what's actually happening in their code. Exceptions are weird in JS, I think the browser vendors generally hide them from the end users as in most cases you'd probably rather have your code just fail silently rather than popping up some scary box like "EXCEPTION" and freaking out your users. In Firefox for example, you have to turn it on in about: config.
you don't need to use $. you can use jQuery.
This, this, a million times this. Using firebug's standard API for logging has saved me so many headaches I can't imagine living without it. http://getfirebug.com/logging
You keep saying this. What shortcomings? All you're saying is that VS blows it away. I'm not even asking for evidence, just what it is that VS does so great. Firebug does 99% of what I ever want, and the other stuff I can get from tools like JSLint.
$ is an alias to jQuery, the point remains the same. It isn't the name that's the problem, it's the namespace.
Everyone can improve the benchmark code. If your version is faster and produces the right result without using a different algorithm, your version will replace the old version. Each of those little benchmark snippets was updated dozens of times and generally they do reflect very accurately how nearly ideal code would perform. The Computer Language Benchmarks Game is a good place to get a *rough* idea about the performance differences between different languages. In this case the median indicates that V8 is about 9 times faster than PHP. A factor of 2 could be ignored, but a factor of almost 10 is pretty telling. CPython for example is somewhat slow. On some weak embedded device it wasn't good enough for writing classic games. I figured I'd need something which is about 4-5 times faster (by extrapolating the figures I got from basic testing). V8 did fit the bill and it was indeed fast enough for classic games (like platformers and puzzles). So yea, it's not super accurate, but it does give you a pretty good rule of thumb figure. Especially if the differences are as drastic as they are in this specific case. **Edit:** Your fanboy-ish downvotes won't support your point of view, by the way.
&gt; Everyone can improve the benchmark code. But not the benchmarks. This is equivalent to saying "you could provide a deeper river." &gt; The Computer Language Benchmarks Game is a good place to get a rough idea about the performance differences between different languages. On this point you and I very strongly disagree. I take the position that the CLS is a good place to find warning holes for implementation methodologies due to language performance limitations. To me the two statements are extremely different. My expectation is that you will see them as roughly equivalent. I'm not saying there's a right and wrong here, just trying to nail down the core disagreement. &gt; In this case the median indicates that V8 is about 9 times faster than PHP. And yet there's never been a JS backend application that scales. My belief is that the core understanding here is simple: "just because your truck doesn't fly very well doesn't mean it's less a good truck than that eagle, which can both travel on land and in air." Look, I'm not arguing that V8 has some impressive basic number crunching. What I am saying is that just doesn't matter. When it comes down to it, the things on which JS' performance suffers are the places where PHP has been shining for ten years. Feel free to prove me wrong. Nothing would shut me up faster than a JS backend application I couldn't replace with a PHP backend with better performance characteristics. I enjoy writing both languages, and would feel no particular concern about switching. &gt; So yea, it's not super accurate, but it does give you a pretty good rule of thumb figure. Sure. What I'm contesting is that the rule of thumb, while accurate, is of entirely the wrong *kind* of measurement. &gt; Your fanboy-ish downvotes I haven't downvoted you. Notably, we've both been downvoted, because Proggit has no idea what downvote is for. When you've been here longer, you'll learn to ignore it.
Agree. The Firebug console in itself is a fantastic tool to learn Javascript (testing regex's and so on). Thanks for the about:config tip I will investigate.
&gt; Well, there are already lots of Linux powered devices out there. Are any of them desktops? And are there a huge number of them?
&gt; Web developers, it's time to learn a second language. Very well said.
Because some web developers can't be expected to actually learn a server-side language like the rest of us. Pretty much just that.
Another armchair php developer. How cute.
You could have very easily replaced Javascript with PHP, and you would still end up with this post being a huge circlejerk.
Too many words?
Maybe you didn't understand the two words you quoted. Here, I'll quote them again for you: &gt; **desktop** linux Emphasis added for better understanding. Smartass.
Agreed. I think most people dislike Javascript because of its use in web browsers and their multiple implementations. Trying to fit Javascript into the browser landscape without a standardizing library is a huge pain the ass. Actually using Javascript in a standardized or single-implementation environment is rather enjoyable.
&gt;server-side language That's probably the most irrelevant kind of categorization I've ever seen. It's even worse than "scripting language", which doesn't mean anything anymore. You can use any language anywhere. From embedded devices to clients, servers, and mf-ing clusters. Also note that it's a disadvantage if a language is less useful in a different environment. But it's funny that you tried to make it look the other way around. That was really cute. :)
I fail to see the problem? Keep all the stuff for a library under a single namespace? would rather have to remember what jquery function goes under what namespace? It isn't like it is as big as .net and needs the System._______.______ namespace.
&gt;[...] V8 has some impressive basic number crunching. V8 is actually sorta weak when it comes to number crunching. Well, the CLS basically tests math, function/object overhead, branching/looping, and string manipulation. These are all things you usually do in programs. If your program doesn't spend most time with these things, the bottleneck is an external one (e.g. a database or other IO) and the performance of the language itself doesn't really matter. &gt;When it comes down to it, the things on which JS' performance suffers are the places where PHP has been shining for ten years. Got any semi-realistic example?
Last paragraph.
That's the one where you acknowledge that 2011 will not be the year of desktop Linux, right? Would have been simpler to just say so instead of trying to mention all the things which are not desktop Linux. 
&gt; But not the benchmarks. Why do the existing benchmarks give a poor representation of a language's performance? &gt; And yet there's never been a JS backend application that scales. What does this mean? Per core? Per machine? Per connection? Per LOC? &gt; the things on which JS' performance suffers are the places where PHP has been shining for ten years. Please elaborate.
JavaScript is an awesome language. That said, given your choice of venue, you may be preaching to the converted. :) Honestly, though, what has made JavaScript usable for me is jQuery. JavaScript itself is nice, but its interface for dealing with the DOM is ugly, overly wordy, and difficult to read at a glance. document.getElementById('foo'), anyone? That being said, that's not really JavaScript so much as the DOM library that's been added to it for use in web browsers. :) 
I love Javascript. It's the first language I learned and up to this it remains my favorite. I never quite understood why it never made onto Desktops (apart from JScript), it woud have had potential. Just right between readability without being bloated. Perfect.
&gt; No decent datastructures Arrays and hashes alone are sparse, but for web development few other structures are used. &gt; no parallelism Fork. &gt; no language extension Unfortunately true, yet at the same time first-class functions get you much of that power. Now if only Javascript's function syntax was lighter-weight...
&gt; If your program doesn't spend most time with these things, the bottleneck is an external one (e.g. a database or other IO) and the performance of the language itself doesn't really matter. This is very rarely true in well designed applications. This only becomes true when scaling up to Facebook sizes. The problem is, in Javascript, the lack of fundamental datastructures is going to hit you *long* before this does. &gt; Got any semi-realistic example? Kinda what I've been saying to you. I gave the semi-realistic example of Facebook circa 2009.
There's gtk bindings for Javascript, and Gnome-Shell (the future of the gnome desktop) is written in Javascript.
CoffeeScript has the lightweight function syntax
&gt; Why do the existing benchmarks give a poor representation of a language's performance? Because cars aren't meant to drag safes over rivers. Look, I don't know what to tell you, here. Being able to select algorithms and datastructures, either it's something you know or something you don't. I can't write CLRS in a reddit post. Have you actually looked at the work they're checking? *Chamenos* ? When the hell is that ever going to matter? &gt; What does this mean? Per core? Per machine? Per connection? Per LOC? Only one of those isn't a nonsense metric. Who talks about scaling per connection? Per connection server scaling is always one. Scaling per line of code? What does that even mean? &gt; &gt; the things on which JS' performance suffers are the places where PHP has been shining for ten years. &gt; Please elaborate. Let's talk about scaling per line of code, first. That one has to be good.
&gt; Arrays and hashes alone are sparse, Javascript doesn't have hashes (objects aren't hashes), and what javascript calls arrays are neither arrays nor sparse arrays. &gt; but for web development few other structures are used. Wrong. &gt; &gt; no parallelism &gt; Fork. Fork isn't parallelism, and the operating system should not have to suffer the load limit of OS processes just to get paths of behavior acted out in a line of control. From having said this it becomes transparently obvious that you've never written anything that has scaled in your life. &gt; yet at the same time first-class functions get you much of that power. Javascript doesn't have first class functions. That isn't a fancy way to say lambda. Stop using phrases you don't understand. &gt; Now if only Javascript's function syntax was lighter-weight... Unless you mean writing fun() instead of function(), this is literally impossible. You're just trying to sound smart by repeating things you've heard other people say. Please do not respond to me again.
&gt;That's the one where you acknowledge that 2011 will not be the year of desktop Linux, right? Yes. &gt;Would have been simpler to just say so instead of trying to mention all the things which are not desktop Linux. Since "desktop linux" is a bit of a running gag, I didn't feel like it was necessary to bother with it.
Understood. 
don't forget HL2 Episode3
Chrome's debugger is actually the best of the lot (blows Firebug out of the water). May want to give it a try.
PHP also doesn't provide a huge variety of data structures. So, I don't really see the point you're trying to make. &gt;Facebook circa 2009. How's that something you can do with PHP, but cannot do with JavaScript? Every piece you need (loops, string manipulation, regexp, math, whatever) is faster with V8 and the memory requirements are about the same.
K.
I don't think that acronym means what you think it means.
JavaScript is a good scripting language for event based programming, particularly with support for closures. It's a pretty poor language for building large, robust and performant software. For example, the difficulty with object oriented support, error prone missing 'var', easy to fall for inefficient patterns, lack of data security. Tools like JsLint and WebStorm help, but my company's best solution so far has been to so as much as possible in C# web services and keep the JS as light and flat as possible. Also, we have had bad luck when trying to hire 'JavaScript' devs' just not enough computer science skill. Building non trivial systems in JavaScript takes quite a bit of understanding. We are looking at hiring 3-4 C#/Java devs with an interest in learning JavaScript in early 2011. 
&gt; PHP also doesn't provide a huge variety of data structures. So, I don't really see the point you're trying to make. PHP provides the critical three. Javascript doesn't. &gt; &gt; Facebook circa 2009. &gt; How's that something you can do with PHP, but cannot do with JavaScript? Try it and see. &gt; Every piece you need (loops, string manipulation, regexp, math, whatever) is faster with V8 and the memory requirements are about the same. Feel free to prove me wrong. If you really think you can describe Facebook as, and I quote, "loops, string manipulation, regexp, math, whatever" then you're clearly quite a ways towards being done. Next observe that they're Turing-equivalent.
&gt;PHP provides the critical three. And these are? &gt;If you really think you can describe Facebook as, and I quote, "loops, string manipulation, regexp, math, whatever" [...] Dynamic websites are build with these very basic building blocks. You fetch some data, push/pull it into your templates, and finally you send it to the client. If each individual building block is faster, the whole thing will be faster. Can't really argue with that, can you?
Functions that have nothing to do with each other all reside on the same object with no separation of context. Ajax functions sitting along side effects, dom manipulation, and dom traversal. Plugins also get dumped onto the same object, forcing plugin authors to make sure they have a unique function name that can't possibly clash with an existing function. It's like somebody went into a kitchen and dumped all the silverware, utensils, pots, pans, cookie sheets, plates &amp; bowls and countertop appliances into one giant drawer and then told the cook that his pantry and refrigerator contents also belonged in that drawer. They do this because they push the concept of chaining everything, and you can't chain everything without putting everything on a single object that can be returned by every function. The problem is, sometimes you shouldn't be able to chain _everything_. They also do this so they can brag that jQuery doesn't "pollute" the global namespace with tons of objects. Well just because the pile of tools is all inside one drawer doesn't mean it's not still a huge mess.
&gt;Javascript doesn't have first class functions. http://en.wikipedia.org/wiki/First-class_function &gt;In computer science, a programming language is said to support first-class functions[1] (also called function literals, function types) if it treats functions as first-class objects. Specifically, this means that the language supports constructing new functions during the execution of a program, storing them in data structures, passing them as arguments to other functions, and returning them as the values of other functions. [...] So yes, JavaScript does indeed support first class functions.
&gt; &gt; PHP provides the critical three. &gt; And these are? God, you're getting annoying. Maps, encoding-known strings and integers. Next tell me that JS objects are maps (they aren't, just like they weren't hashes,) that ECMA strings' encodings are always unicode (except one that's not an encoding, two that's not enough, and three that doesn't actually become true until 262/JS1.2, which currently excludes 1/3 of the web), and integers. &gt; &gt; If you really think you can describe Facebook as, and I quote, "loops, string manipulation, regexp, math, whatever" [...] &gt; Dynamic websites are build with these very basic building blocks. Translation: "I have no idea why you dared me to talk about turing equivalence." &gt; If each individual building block is faster, the whole thing will be faster. Can't really argue with that, can you? Of course I can. Any engineer with two or three years' experience can. You can take a Civic and a Yugo, put a Ferrari engine in the Yugo, and the Civic's still going to do laps around it. Those tiny little measurements you're seeing have nothing to do with the vast bulk of the efficiency of a toolsystem like this. I keep telling you to make one because there are dozens of topics under this, and you're just going to keep heaping on the "I've never done it so I'm certain" skepticism until you try it and watch that it *actually* *doesn't* *work*. Go on. Facebook as a frontend is really, really easy to roll. Throw one together, make a quick rig that tests performance with 2^n users, and test it for n=[1..20]. I'll be stunned if you don't see growth orders of at least nine. G'wan. Quit talking smoke, asking stupid vague questions, and get down in there in the dirt and build one. Otherwise you're just guessing.
and not one mention of JSscript.NET which has been around for ages... makes me think the lot of you have been hiding under a rock for the last 10 years. 
also called node-inspector if you are using ssjs =)
Wow, a wikipedia page. There's a reputable source of information that you couldn't possibly misunderstand. Next look up lambdas and notice that you can get the same definition out of them, then wonder as hard as you can why we don't use them interchangeably. No, Javascript doesn't support constructable functions at runtime. It supports lambdas which can change their bindings, upward closures and instance evaluation. Not the same thing. I'm sorry the wikipedia page, written by someone like you, does not get into sufficient detail for you to understand the difference. If you own a proper computer science textbook, now would be the time to open it, since you obviously don't believe me. The next time you reach for Wikipedia in a computer science discussion, just sit back for five seconds, and ask yourself whether you think the person who wrote your page got their understanding from some dropout's blog.
JScript.NET.. works great. the entire .NET framework can be used with JavaScript. 
ever consider JScript.NET? The .NET framework is massive, and it is all usable from JavaScript, quite easily. It also has a compiler. I've been creating JScript.NET back-ends for years, works great. SQL is no problem, anything you can do with .NET in C# you can do in JavaScript. Just because the msdn examples usually don't show javascript doesn't mean it doesn't work - it works quite well actually. Threading and everything. 
&gt;Maps, encoding-known strings and integers. Objects in JavaScript support all 4 kinds of basic operations you need for associative arrays or maps. You can add, reassign, remove, and lookup. Strings are stored internally as 16bit unicode and internally you always work with these. You can output it in any encoding you like. (It's similar with Java for example. This works great.) IEE 745 floating point allows you to work with sort-of integers up to 9 quadrillion (2^53 ). &gt;Otherwise you're just guessing. So, you tried to build a circa 2009 Facebook with JavaScript and failed?
Is "dogs balls" good or bad?
10 years ago I was 13.
and your point is? i started programming when I was 9. 
Brandon Eich and Douglas Crockford call these things first-class functions. And so does everyone else. But feel free to dig up a source which supports your unusual opinion.
&gt; Because cars aren't meant to drag safes over rivers. Meaningless blather. Please demonstrate concrete points. &gt; Chamenos ? What behaviour of that benchmark is uninformative about other workloads? More importantly, please demonstrate what is wrong with the sum total of the benchmarks. What I have seen so far from you is "it's bad". &gt; Only one of those isn't a nonsense metric. Here's some possible interpretations: * Per core: cache behaviour and memory bandwidth. * Per connection: how many concurrent connections can the app handle on a single machine without dropping connections or increases in latency? * Per machine: how much additional load handled for every additional machine added to a cluster (but this is more limited by network bandwidth and DB contention) * Per LOC: how much additional code is needed for every additional feature? You're being intentionally obtuse, or you're out of your depth. But all that aside, I want to know what **you** mean by scaling since **you** said it. All I'm seeing here is your attempts to dodge my questions. &gt; Let's talk about scaling per line of code, first. That one has to be good. Why should _I_ elaborate? You made the claim, so answer it already. Yet another dodge. But I'll bite regardless: JS and PHP are comparable. Indeed, JS comes out [a bit ahead](http://shootout.alioth.debian.org/u32/which-language-is-best.php?calc=calculate&amp;xfullcpu=0&amp;xmem=0&amp;xloc=1&amp;nbody=0&amp;fannkuchredux=0&amp;meteor=0&amp;fasta=1&amp;spectralnorm=0&amp;revcomp=1&amp;mandelbrot=0&amp;knucleotide=1&amp;regexdna=1&amp;pidigits=0&amp;chameneosredux=0&amp;threadring=0&amp;binarytrees=0) for string-related operations. Indeed, it also comes out ahead for most of them. So, what was this scaling that PHP is better at that you were talking about?
Classic ASP using JScript... Oh, wait, you said "good". FML
I have used PHP for years, it is hacky. It's rare that naming conventions are consistent, and it basically needs a framework to do anything more than a basic page. It's easy to use, as there are a ton of examples out there (with docs in hand to find the inconsistencies) and hosting galore, but PHP is good for one thing: cheap easy webservers. JS, like Python, has a ton of uses and a much longer life ahead of it than PHP.
I started at 12 I think, but I was programming C, not JS.
Firebug is slow and bulky. *Webkit's debugger works and it's fast (same debugger in chrome and safari).
Really kinda sounds like you are trying to come up with an excuse to dislike it. You are right, jQuery is built for chaining functions. If you don't want to chain something, you don't have to add that function as a plugin for the jQuery namespace. Just make it a function in your own namespace. Problem solved. And yeah there a couple of tools in that drawer, but not so many that you need to break them up into separate rooms. I mean i can kinda see what you are talking about, but anyways you are welcome to your opinion. 
 I'm not Level1, but let me just say that I'm kind of old now so "breif" time periods can be as much as a year and a half---or longer than the amount of experience some junior developers have in *in total* for all their programming lives. Honestly if you've used 10-14 languages, you don't need a decade long survey with every new language to find its short comings. You know what corner cases will bite you before they happen whereas a junior would be blind to them. PHP in short is a good language for quick projects---better than python for tiny web projects in fact. But once you get into a midsized project, the inadequacies of the language start to grate. And once you get to the point where you have C extensions written for your project, you'll truly begin hating the Zend interpreter. 
More or less the same story here. We're looking to hire 1-2 classical-MVC (not web-MVC) developers who are not afraid of javascript code. I guess SmallTalk developers would do fine :)
Chromes javascript debugger is a class act. Hit Ctrl-Shift-J on any webpage to check it out for yourself. It's built into Chrome. It's fucking excellent.
send mime-multipart. The first bit is JSON, which defines information about the images. Each part after that is a raw image, in binary or whatever multipart supports. http://www.faqs.org/rfcs/rfc2387.html 
well, i started 30 years ago, in assembly.. so? have you ever considered JScript.NET? that is the subect I was bringing up. I could care less when you started programming. 
&gt;I love javascript too but... &gt;&gt; It has some sweet debugging tools &gt; Dude, seriously? Firebug aside... like Firebug is a terrible debugger.
&gt; Javascript doesn't have hashes (objects aren't hashes), and what javascript calls arrays are neither arrays nor sparse arrays. This is a dynamically-typed language here. Does it look and quack like a duck? Hash: &gt; var foo = { 'a' : 1, 'b' : 2 }; &gt; foo['a']; 1 &gt; foo['c'] = 3; 3 &gt; foo; { a: 1, b: 2, c: 3 } Array: &gt; var bar = [1, 2, 3]; &gt; bar[1]; 2 &gt; bar[1] = 3; 3 &gt; bar[4] = 4; 4 &gt; bar [ 1, 3, 3, 4 ]; Good enough for most web dev purposes, I'd say. &gt; Wrong. That's it? "Wrong"? How convincing! &gt; Fork isn't parallelism What is the problem here? &gt; the operating system should not have to suffer the load limit of OS processes just to get paths of behavior acted out in a line of control. Implementing a M:N threading is difficult and ultimately inefficient. 1:N green threads don't use more than a single core. You could use N:N threading, but then there's problems of locking and contention. Now you certainly can go Clojure's route -- and the jury's out how efficient that approach can get although I have high hopes -- but claiming OS processes are bad is wrong. They're an effective tool that has different strengths and weaknesses compared to alternatives. But I'm all ears: what _do_ you intend to do with several thousand processes in a webapp? Furthermore, what do you intend to do with several thousand _event-driven_ processes? If you're talking about BLAST, that's definitely not node's strong point, but we're discussing web applications here. Nobody claimed node was good for HPC. &gt; Javascript doesn't have first class functions. &gt; var baz = function (x) { return x + 1 } &gt; baz(2); 3 …really? Perhaps you meant it doesn't have closures? But it has that too: &gt; function foo() { var x = 1 ; return function () { x += 1; return x } } &gt; var bar = foo(); &gt; var baz = foo(); &gt; bar() 2 &gt; bar() 3 &gt; baz() 2 &gt; Unless you mean writing fun() instead of function(), this is literally impossible. function(x) { return x + 1 } compared to an imaginary language: [x| x + 1] But yes, it can be lighter weight. I've seen some Schemers replace lambda with λ, resulting in (λ (x) (+ x 1)) In any case, I find it strange that one of the most commonly used keywords in Javascript is also the longest. &gt; You're just trying to sound smart by repeating things you've heard other people say. Please do not respond to me again. That is rich.
I don't use Chrome because it doesn't have a "text only" zoom, which is pretty much essential for me, but I do love the debugger.
Sweet, thanks!
Do have a look at GWT, it really makes a difference in team settings.
If you are a Java shop, I can't recommend GWT enough. We've been deploying the same code to server &amp; browsers, offloading the servers (Google Maps tiles, relatively short-lived and non-cacheable due to custom processing - side-effect was faster UI updates on mouse overs).
querySelectorAll is pretty sweet.
bad, "is the shitznet" would be good :)
Javascript is a frickin' awesome language. The DOM implementations are what people mostly hate. Any language with first-class functions and closures is a-ok with me. See also: Lua.
&gt; Brandon Eich and Douglas Crockford call these things first-class functions. Yes, and Joe Armstrong thinks Erlang isn't object oriented. What's your point? &gt; And so does everyone else. Maybe if your everyone else is bounded by blogs and irc. &gt; But feel free to dig up a source which supports your unusual opinion. Knuth 2. Any university. I'm bored of this.
&gt; This is a dynamically-typed language here. Does it look and quack like a duck? Datastructures aren't an issue of type, and Javascript isn't dynamically typed besides. &gt; Good enough for most web dev purposes, I'd say. Yes, you have displayed that both hashes and objects can implement the map interface. So can trees, tries, gaddags, sparse arrays, paired sets, lists of tuples, arrays of arrays, sets of sets, set-of-set, and dozens of other things. Let's just throw them all out because they can be used the same way, and since we're talking about using JavaScript as a server language, say "good enough for webdev to me." And this is why you'll never understand why PHP scales and JS won't. &gt; &gt; the operating system should not have to suffer the load limit of OS processes just to get paths of behavior acted out in a line of control. &gt; Implementing a M:N threading is difficult and ultimately inefficient. 1:N green threads don't use more than a single core. You could use N:N threading, but then there's problems of locking and contention. Oh god, please stop reciting things you read on Java blogs. Every part of that misses the point. This has nothing to do with letter colon letter phrases that make you feel smart. OS processes are really, really heavy, and invoke a massive amount of context switching both at the OS and CPU levels. A $350 walmart machine that chokes around 40k linux OS processes can run hundreds of millions of erlang processes. Saying "can't be made efficient" is code for "I have never tried nor have I looked for anything other than the first thing in my toolkit and therefore I assume it doesn't exist." Commodore 64s can handle hundreds of processes under Contiki, for christ's sake. You are 100% off-base here in a very, very easily demonstrable way. &gt; but claiming OS processes are bad is wrong That's it? Wrong? How compelling! Cough. &gt; They're an effective tool that has different strengths and weaknesses compared to alternatives. They're way too fucking heavy for handling web backends. Anyone who's ever even tried to build one knows this. You're complaining that saying using a sledge hammer to put in a map tack is bad is wrong, because sledge hammers have different strengths and weaknesses. Put down the book of engineering platitudes. You aren't fooling anyone. &gt; But I'm all ears: what do you intend to do with several thousand processes in a webapp? Not a god damned thing. I said parallelism. You're the one who heard OS processes. Again, because you've never looked anywhere else. &gt; &gt; Javascript doesn't have first class functions. &gt; var baz = function (x) { return x + 1 } &gt; baz(2); &gt; 3 &gt; Really? Yes, really. That's a closure with updated bindings. You can try it with eval(), too, to pretend they're being created at runtime; they're actually new parsing passes. When you learn your CS from somewhere better than blogs and wikipedia, you may come to understand the important, subtle differences at play. You know, much like with the "see? Object acts like a map, seems like a good enough hash to me" crap upstairs. &gt; Perhaps you meant it doesn't have closures? No, I actually pointed out that it had closures in a [http://www.reddit.com/r/javascript/comments/et1d1/2011_is_year_of_the_serverside_javascript/c1aroxe](different thread). Why do you keep arguing with things I didn't say? Is it because you're having too hard a time with the things I actually did say? &gt; Unless you mean writing fun() instead of function(), this is literally impossible. &gt; function(x) { return x + 1 } &gt; compared to an imaginary language: &gt; [x| x + 1] It's always sad when someone thinks "the syntax is light-weight" means "I want to type a handful fewer characters, and misuse what's already a more powerful syntax for a more powerful action, comprehensions." Probably the funniest part is that if you're just playing letter trimming games, the natural extension of the existing syntax has fewer characters than that: (X)X+1 But, hey, you were just talking, right? And it doesn't matter that you've just subtly introduced a letter while getting rid of an explanatory label. After all, we want code to be as un-readable as possible, and having a bunch of shit in square brackets and pipes seems great. You should go write un-lambda. &gt; I've seen some Schemers replace lambda with λ, resulting in Oh. You're already one of those kooks. Have you ever noticed that Scheme has never produced anything of tangible value in its fourty-odd years of supposed superiority? &gt; In any case, I find it strange that one of the most commonly used keywords in Javascript is also the longest. And the rest of us find it strange that you're fretting over something as unimportant as the count of letters in the word "function," instead of actual language enhancements. &gt; &gt; You're just trying to sound smart by repeating things you've heard other people say. Please do not respond to me again. &gt; That is rich. A fool need not recognize himself to be so.
I came here to say the exact same thing. If JavaScript had originally been released as a "normal" scripting language like Perl or Python, it wouldn't be sneered at. But because it was originally introduced with several horribly broken and incompatible DOM implementations, it gained a reputation for being extremely difficult to work with and very poorly thought out.
&gt;Knuth 2. Any university. I'm bored of this. Then it should be very easy then to find zillions of websites which support your statement. Show me one. So, which language does support your interpretation of first-class functions and what exactly makes them different from JavaScript's?
Be careful with `querySelectorAll` for trivial matters. It's not fast. http://jsperf.com/getelementsbyclassname-foo-0-vs-queryselector-foo
I recommend that you rejigger the frobstat. 
Box2DJS is excellent. 
Well, me and a bunch of other people already experimented with this stuff and we all arrived at the same conclusion. Sending the images as gzipped b64 is the fastest way. It's also the easiest and - surprisingly - it's about as small as a zip file. I expected quite a bit of bloat, since b64 by itself increases the file size by 33%. However, Deflate works pretty well with text. So far the gzipped b64 blob files were even slightly smaller than a zip file with the same contents. (Others reported an increase of up to 5%, but that's about it.) I'm not using JSON though. I got a simple index at the beginning which contains the names of the files and their length and then it's just b64'd data till the end.
&gt; Objects in JavaScript support all 4 kinds of basic operations you need for associative arrays or maps. So do vectors of tuples. That doesn't mean they're all the same thing. You're obviously out of your depth. &gt; Strings are stored internally as 16bit unicode Says who? The ECMA standard doesn't require this, and this isn't what Firefox does. &gt; You can output it in any encoding you like. That isn't good enough. I need to be able to work with it internally. &gt; IEE 745 floating point allows you to work with sort-of integers up to 9 quadrillion (253 ). Whoosh. &gt; So, you tried to build a circa 2009 Facebook with JavaScript and failed? I've pushed JavaScript's limits quite a bit, though not through social networking. No more guessing, Sam; I'm bored of this. I get it. You don't have a leg to stand on, so you're trying to show the same of others. G'bye.
&gt; Honestly if you've used 10-14 languages, you don't need a decade long survey with every new language to find its short comings. Except I've got more languages than that in several of my public utility collections, *and* I've been using PHP for more than a decade, *and* I've been using JavaScript since it was still called LiveScript, *and* still haven't seen a compelling reason to take this seriously. &gt; But once you get into a midsized project, the inadequacies of the language start to grate. Yeah, except in the real world, that isn't actually the case. Web server applications tend to actually get much, much larger than the C++ applications of yester-year. (Mind you, C++ is my favorite language.) If you're writing C extensions for your project, the problem was it shouldn't have been PHP in the first place, or your PHP isn't very good. It isn't *that* uncommon that the right answer is to write a C++ application, open a socket, and speak HTTP. None of this affects the vague broad-handing that "php isn't good for big projects" - most of the people who say things like that haven't ever worked on anything as complicated as a WordPress plugin, let alone crap like Kayako SupportSuite. Not that I'd hold either of those up as examples of good code. Still, if you can write _that_ crap and it still works, *something* is going right. I challenge you - defy you, even - to put more than emotional assertions to this. I have never seen any evidence of any form that PHP is bad for large projects; it always just comes out that someone's griping about a badly run project they hated. Show me what part of PHP means you couldn't have just written code with more discipline.
You don't need a framework for anything, and if you're using them, then no wonder you think it's hackish. Python is not going to outlast PHP any more than Ruby did. PHP has the same immortality that COBOL has, in smaller doses; it has a decent chance of outlasting real languages, like C++ and Java. JavaScript will probably outlive them all, except COBOL, sadly. If the only specific criticism you can make of the language is that its naming conventions aren't particularly consistent and you don't know how to use it without a framework, I think we've pretty much got this one neatly sewn up.
&gt; &gt; Let's talk about scaling per line of code, first. That one has to be good. &gt; Why should I elaborate? You made the claim, so answer it already. I didn't say jack about scaling per line of code. I actually asked you to stop wasting my time, then told you exactly which of your four I meant. I want to know what you meant by scaling per line. I am unable to parse it into something meaningful. I'm also a little tired of your attitude. If you explain that, and start taking a more reasonable tone, I'll go back to answering the questions you asked after I asked you to go away. Remember that you're asking. I don't give a crap what you think, and I'm happy to walk away. If you really want answers, amend your tone. If you're just looking to complain and feel like you won because someone was tired of being spoken to in that tone, keep it up: you're about to get your way.
&gt; Show me one. Cue the "if you don't do my homework for me, you're full of shit" routine. &gt; which language does support your interpretation of first-class functions ML, Haskell, Fortress, Mozart-Oz, Mythryl, COQ, and I suspect probably clojure but I don't actually speak it. Doubtless a million other languages do too. Those are the ones I'm aware of offhand. &gt; what exactly makes them different from JavaScript's? That when someone says "I'm bored of this" you didn't immediately change your tune to make them less sick of talking to you.
&gt;That doesn't mean they're all the same thing. It can be used like a hash map and performance is also similar to a hash map. It probably is implemented like a hash map. Arrays for example typically got several different implementations (sparse and dense and maybe something else) and the JS engine then tries to pick the fastest one based on some heuristics. &gt;I need to be able to work with it internally. Why? Because you'd have to worry about the encoding 3 times then? &gt;Whoosh. This means you can at least do everything you could do with a 32bit integer. Some engines switch to actual integers under the hood if they think it would make sense. Also, V8 is better at integer math than PHP. So, what's your point exactly? &gt;You don't have a leg to stand on, so you're trying to show the same of others. Kind of. I merely reversed your statement. If one cannot compare those two languages without having written a circa 2009 Facebook in both of them, why should you be the exception?
I didnt think about compression. Thanks for that.
You can't even think of one tiny difference then? Pretty telling, really.
&gt; &gt; Cue the "if you don't do my homework for me, you're full of shit" routine. &gt; You can't even think of one tiny difference then? Pretty telling, really. Yes, yes, just keep asking questions until someone gets bored, then keep asking them until they refuse to continue, then claim that it's pretty telling that they get bored of you asking stupid questions that you could look up for yourself. Proggit troll 101. Can't prove one's own statements? Ask questions until the other side walks away, then declare victory.
Why didn't you use all that time and energy to write one little sentence about one little detail? But I do like how you try playing victim here. Bravo.
Are you done? 
No. What makes them different, bag o'lies? Tell me.
You could try oDesk if you don't get any bites here, but if you've never managed a software project or worked with developers expect a learning curve and at least 1 major headache along the way. Also make sure you've got your licenses figured out, you'll probably need to GPL any code you write on top of Harmony (e.g. DB serializing/saving). (If this is a for-profit project and/or you don't intend to contribute back to open source, this probably presents an issue.) FYI, I'd size this as at least medium-ish, but I don't do much JS. If you're not a programmer, best to leave the sizing to the pros or else you'll scare them away. Good hunting.
Ah, now we've progressed from assuming that two posts warning impending cutoff to can't do it to it's all lies. How easily we forget that every question was answered up until that warning period. You sure do escalate fast. Maybe next I'll be a rapist. Go make a high scaling server on OS forks, and point out how you believe that hashes, maps and sparse arrays are the same thing, some more. Not my fault you're stupid enough to fall for your own crap, and continuing to ask in increasingly ugly ways isn't how you get someone who cut you off for being ugly to respond. It's really just that you're a jerk, and when you get a warning that you're about to get cut off, instead of apologizing, you try turning up the volume, because you confuse exasperation with confounding. Frankly, I don't give a damn what an amateur like you thinks.
"Bad" compared to what? Sure, I suppose it's not a "bad" language but **it's certainly not a particularly good language**. I mean compared to other current dynamic languages it's stunningly mediocre. The "null"/"undefined" distinction is a serious design error. Implicit "this" is unintuitive and oh so confusing to beginners. The '==' operator is awful with respect to null/undefined/0/True/False/Strings. The looseness of its type-system is awful and oh so error-prone. Forgot a "var"? Obviously you wanted that symbol in global scope. I could go on and on. I guess I just don't see why I should use it for general-purpose programming over Python, Ruby, Lua, Lisp(s), Scheme(s), Perl, etc. I mean I can't think of one thing that Javascript (as a language) does significantly better than any of those. I mean all those languages carved out a niche because they did at least one thing (usually more than one thing) extremely well. It does have a fairly unique object model but it doesn't strike me as particularly better, just different. And you can easily write an object-model framework to mimic it in any of those other languages in probably less than 100 lines. Most people I've met from the "OMG Javascript!" camp share a couple things in common: * It's the first (usually only) dynamic language they've ever used. * It's the first (usually only) language that supports closures and lambdas that they've ever used. And it doesn't even do those things particularly well. Python, Ruby, Lisp(s), Scheme(s) are all more dynamic (i.e. provide the programmer better/more runtime introspection and modification tools) and provide much better meta-programming support. And really, Javascript, for a language that pushes lambdas so hard you're gonna make me type 'function' for every one of them? Come on. Sure it's not bad, it's a solid 5/10. 
Still can't think of one difference huh? You avoided this question all the time. I also don't see a reason why I should apologize for anything. My tone was (and still is) a lot friendlier than yours.
Are you done yet? I'm not interested in answering a question you asked me after I gave up on talking to you. The answer remains "no," no matter what stories you want to tell yourself.
You're preaching to the choir.
I take that as a "Yes, you're right. JavaScript does indeed have first-class functions.". :)
By definition, if Firebug is "terrible", something has to be better. What would you say is a better debugger?
Of course you do. You're desperate to be correct.
I'm not. You're just unable to provide any kind of evidence which would support your statement. Makes you look like a sore loser, really.
"You won't answer this question I asked after you said you were done answering questions, after you predicted this trolling explicitly! That means you're a sore loser who can't do it!" Does anyone ever fall for this besides the speaker?
&gt; You could have very easily replaced Javascript with PHP, and you would still end up with this post being a huge circlejerk. I would disagree. PHP, while not essentially a bad language, has very little going for it. The language is as crufty and inflexible as Java/C# but without the performance or static type checks to make up for it. JavaScript on the other hand, has closures/first class functions\*. That alone puts it in a class above many other languages. Prototypal inheritance is also pretty cool when you understand it. Oh, and everything being an object. JavaScript has a lot of great things going for it if you can get past the terrible DOM implementations. PHP and JavaScript both get a bad rap because they have low barriers to entry (read: lots of amateurs/idiots parading as experts) and don't force you to write code "the right(tm) way." The unrelenting hatred many people have for them is generally unwarranted, but to say that PHP is in the same class as JavaScript is a bit off. \* Yes, PHP 5.3 has closures, but compatibility problems keeps adoption down and the APIs don't really take advantage of them. If you want to get paying work, there is a good chance you'll be stuck with 5.2. JS has had closures from day 1.
Cute.
&gt; I am so tired of hearing novices who half-know two languages fake-compare them by reciting proggit wisdumb. I professionally code in both languages and JavaScript is definitely cleaner than PHP. Closures in PHP 5.3 is an improvement, but adoption is poor because of compatibility issues (I'm stuck with 5.2 most of the time) and the PHP APIs (which are mostly global functions, bleh) are still crap since closures are a late addition. Not to mention the bizarre array/class object syntax differences (why is $array['foo'] different from $obj-&gt;foo?), confusing reference/copy semantics (without pointers, why should devs care?), most of the API being global functions, etc. So I'm tired of people who apparently don't know the two languages, equate a language that is quite expressive because it had closures from day 1 to one that has bizarre semantics, limited syntax, and hacked in closures, if you're lucky enough to be able to use 5.3. People rag on JS because the DOM sucks. The language is pretty great if you know it. People rag on PHP because it really doesn't have anything going for it, other than ubiquity.
&gt; I professionally code in both languages and JavaScript is definitely cleaner than PHP The word "definately" is not a technical argument, and closures are a minor and trivial part of language design. I confess I see nothing here but bikeshed painting. Ooooooh, object members aren't the same as array membership, CALL THE LANGUAGE POLICE. And you wonder why you don't get taken seriously. Go learn a difficult language.
Its a little embarrassing in my opinion to start drumming up an anti-hate campaign for a programming language. JavaScript isn't going anywhere regardless of what people think about it.
This is really harsh and false. Firebug is pretty robust: breakpoints, value watching, call stacks, network traffic analyzation, a profiler to log all function calls, error reporting and custom logging. Firebug lite is also pretty handy for IE variants.
If your only gripe is forgetting var, then I would say JavaScript is pretty good. Tip: go to firebug console, type window and execute it. Check if any variables in your code appear in the window object that shouldnt be there (I.e you didn't declare those variables with var, therefore making them global)
I agree with most of what you said, but I don't think Scheme is more dynamic than Javascript. Scheme has dynamic typing, but is a lot less dynamic than people think by default -- the only polymorphism you'll find is with the default numeric stack, and no, Scheme won't let you join in that fun. Truth be told, Scheme probably shouldn't be called a dynamically-typed language. Untyped is more accurate.
The website it would be available on is product promotional so it's a for-profit project, but all code would be GPLed back to open source. This component of the project (enhanced Harmony) is aimed at kids on a sweets/lollies/candy wholesalers promotional website. The app will be free to use on the site using trademarked characters and background scenes which would be swapped out with generics in any open source code. I do code php but not javascript and the site is a reasonably small project. I'm trying to maximize content for my client by re-purposing open source stuff to meet his brief. Thanks for your link I'm there now. I've wrangled some flash projects in my time with external developers and I employ a php programmer so I'm aware of pitfalls to look out for. But I've never needed advanced javascript/canvas stuff before so this is new territiory.
I notice you have once again answered almost none of my questions. There's a lot of sound and fury in its stead. &gt; If you explain that, and start taking a more reasonable tone, I'll go back to answering the questions you asked after I asked you to go away. The gall you have is amazing. Have you read your posts? You start off with some condescending passive-aggressive posts, get flack back asking you to back your assertions, you don't, you even demand people stop responding to you, and then you demand **I** take a more reasonable tone? My mind boggles at your cheek.
I tried explaining that to him and he said that using acronyms properly was "pedantic bullshit". He's basically just here to spam his blog and has no interest in actual discussion, particularly that which proves him wrong.
Truth be told I haven't actually done much (read hardly any) Scheme programming personally. But in terms of dynamic-ness in Scheme I was more thinking along the lines of things like first-class continuations. Whether it's more dynamic than Javascript is debatable and it's quite possible I'm wrong in my assessment. I was under the impression that it's certainly a typed language though in that it has disjoint primitive base data-types (numbers, strings, symbols, procedures, etc.). Although I'm anything but an authority on the subject.
&gt; I notice you have once again answered almost none of my questions. That's because I asked you to stop talking to me quite a while ago, and because you're answering *none* of mine. Please find someone else at which to complain. &gt; &gt; If you explain that, and start taking a more reasonable tone, I'll go back to answering the questions you asked after I asked you to go away. &gt; The gall you have is amazing. Have you read your posts? Yes. I'm not asking anyone for anything but to defend their own claims. &gt; and then you demand I take a more reasonable tone? There is no parity. If you want something from me, act like it. Capiche?
It took me a while to switch away from firebug, but chromes debugger tools are way better.
&gt;I never quite understood why it never made onto Desktops [...] That's not entirely accurate. Firefox, Chrome and so on contain relatively large amounts of JS. Also, all addons are written in JS. Same thing goes for applications which use the Mozilla platform. E.g. Thunderbird or Komodo. JS is also an option in Unity3D. Nowadays it's a pretty good choice for game scripting. I'm sure we'll see more JS-enabled game engines/frameworks in the future. V8 is fast, small, and its license allows you anything you might want to do.
I wouldn't say great documentation. If you google something, it's probably going to be from way back. Mozilla has some good docs, but not much in regards to the newer stuff. Seriously, look at Object.create() There's really no helpful information on it.
You got to understand that people that are unnecessarily impressed by stuff like Firebug have likely come from the IE6 world where error messages were next to useless and `alert` was your best hope for debugging.
It's part of the reason why I switched to safari/webkit nightly as my main browser
jsFace is a framework to facilitate Object Oriented Programming (OOP) in JavaScript. It is designed to work on both server and client side JavaScript. Features: * Focus on facilitating Object Oriented Programming in JavaScript. * Work on both server and client side JavaScript. * Plain JavaScript, no dependency. * Frameworks friendly co-operating by introducing only one namespace to global scope. * Support method overloading. * Support parameter type checking and validation. * Support Aspect Oriented Programming (AOP). * Support profiling. Check it out on Github https://github.com/tannhu/jsface and let me know how you guys think about it :) 
Oh. Sorry. Obviously ten years of using both leave me with no knowledge about their differences whatsoever. Please stop making assumptions like this. It's insulting and makes you look like a babbling idiot.
Just be thankful nobody else bothered to implement VBScript.
But PHP 6 will have Unicode! Nah, honestly, modern PHP is dead to me ever since it adopted a backslash as module separator.
Quite literally. This is r/javascript after all.
&gt; Javascript isn't dynamically typed besides In Javascript the type is part of the value, not the variable. &gt; Let's just throw them all out because they can be used the same way, and since we're talking about using JavaScript as a server language, say "good enough for webdev to me." That's a strawman. Nowhere did I say we should throw them out. Here's what I actually said: _Arrays and hashes alone are sparse, but for web development few other structures are used._ And this is true. While Javascript doesn't have a rich set of data structures, the vast majority of the time web developers find these two adequate. I've worked long enough, with enough different people, in sufficient different projects, and a variety of languages, to know what gets used a lot and what doesn't. &gt; Oh god, please stop reciting things you read on Java blogs. It's from reading papers and implementing this stuff for fun, but please continue to be insulting. You complained in a separate post to me that you dislike my tone, but you continually denigrate everyone else. My tone is a result of your own, and I think I'm being much more polite than the situation warrants. &gt; Saying "can't be made efficient" is code for "I have never tried nor have I looked for anything other than the first thing in my toolkit and therefore I assume it doesn't exist." My claim is based on a [paper I read](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.9476) and discussions with some Solaris kernel hackers. Solaris used to have M:N thread scheduling, but they removed it in version 9 because of the problems it caused. The paper, by Bryan Cantrill, described some of these problems before he was hired by Sun -- it's raw, but it gets the point across. As for Erlang: I have used it, back when Erlyweb was still under active development and Programming Erlang was hot off the press. It's a good language and implementation, but it isn't particularly efficient, nor is it the only answer to concurrency. &gt; You are 100% off-base here in a very, very easily demonstrable way. My assertion is backed by data and a group of veteran kernel hackers. I know OS processes are heavy weight, but they trade it off with better scheduling and protection. So what's the problem with node forking? &gt; That's it? Wrong? How compelling! Ignore everything I wrote before that sentence so you can get in a snarky comment. I actually provided arguments for mine. &gt; Is it because you're having too hard a time with the things I actually did say? The reason I mentioned it is because I do not understand where your claim is coming from -- I still do not -- and in case there was a misunderstanding I covered closures too. Please give a concrete demonstration how they're not first-class functions, because the definition you're going by seems quite alien to me and others. &gt; It's always sad when someone thinks "the syntax is light-weight" means "I want to type a handful fewer characters, and misuse what's already a more powerful syntax for a more powerful action, comprehensions." I could have sworn I was arguing Javascript should have that syntax… no wait, I wasn't. It was a demonstration, nothing more. What is wrong with wanting a shorter keyword for Javascript? First-class functions are used often, so fewer characters could make it more readable. I think Larry Wall had a point here.
http://jibbering.com/faq/notes/closures/
TL;DR version [here](http://blog.morrisjohns.com/javascript_closures_for_dummies.html)
&gt; That's because I asked you to stop talking to me quite a while ago Classy. You expect others to listen, but will not do so in turn. &gt; Yes. I'm not asking anyone for anything but to defend their own claims. I and others have provided code, links to benchmarks, and links to papers. Since when is this not defending our claims? It's a stark contrast to the insults from your direction.
The second moveover function overwrite the first one. Make the names unique, and put all in a single script tag to make it easier to read.
Clearly, I should assume you know something that I believe doesn't exist, because you didn't say it, instead.
Until you explain your notion of per line of code scaling, we're done. You're just talking, and missing that every single time I express an interest in not talking to you.
Is this what you wanted? Just renamed functions and cleaned up superfluous html, but I think it works now. Let me know if it helps. &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src="http://imgur.com/tBLDf.png" alt="Other Websites" height="60" width="643"/&gt;&lt;/td&gt; &lt;td&gt;&lt;a onclick ="javascript:ShowHide('mntazndisp')" href="javascript:;" &gt;&lt;script type="text/javascript"&gt; function moveover() {document.getElementById('azndisp').src="http://i.imgur.com/2nltH.png";} function moveback() {document.getElementById('azndisp').src="http://i.imgur.com/snu54.jpg";} &lt;/script&gt;&lt;img id="azndisp" src="http://i.imgur.com/snu54.jpg" onmouseover="moveover()" onmouseout="moveback()" /&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a onclick ="javascript:ShowHide('mntrdtdisp')" href="javascript:;" &gt;&lt;script type="text/javascript"&gt; function moveover1() {document.getElementById('rdtdisp').src="http://i.imgur.com/LqBEF.jpg";} function moveback1() {document.getElementById('rdtdisp').src="http://i.imgur.com/DsSuq.jpg";} &lt;/script&gt;&lt;img id="rdtdisp" src="http://i.imgur.com/DsSuq.jpg" onmouseover="moveover1()" onmouseout="moveback1()" /&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a onclick ="javascript:ShowHide('mnttwtdisp')" href="javascript:;" &gt;&lt;script type="text/javascript"&gt; function moveover2() {document.getElementById('twtdisp').src="http://i.imgur.com/LupU6.jpg";} function moveback2() {document.getElementById('twtdisp').src="http://i.imgur.com/dtOpw.jpg";} &lt;/script&gt;&lt;img id="twtdisp" src="http://i.imgur.com/dtOpw.jpg" onmouseover="moveover2()" onmouseout="moveback2()" /&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;
The HTML there is horribly invalid, to say nothing of your javascript problems. 
&gt; &gt; That's because I asked you to stop talking to me quite a while ago &gt; Classy. You expect others to listen, but will not do so in turn. Asking someone to go away and not listening to them are complimentary. I haven't asked you to listen. I've asked you to stop talking to me. &gt; I and others have provided code, links to benchmarks, and links to papers. Since when is this not defending our claims? The code isn't valuable because it won't scale. The benchmarks measure random code toys, rather than real world performance, and aren't of your code besides. I didn't see any papers; where were those put? Was that in this chain somewhere and I missed it? If so, I apologize. &gt; It's a stark contrast to the insults from your direction. Then why are you still trying to talk to me? I obviously don't want to talk to you. If you don't like it, stop asking me questions. I'm not asking you any questions. I'm just asking you to stop complaining at me.
I wouldn't say that it's "literally", but yeah, that's what I'm saying. Why the hell would somebody defend JavaScript from r/javascript..?
will do! I've been using firebug, and its not bad, but I can't wait to see what progress the future will hold for some seriously hardcore clientside debugging.
I knew about JS lint, but thanks for showing me js beautifier :)
It pollutes the global object. You should fix that.
Your HTML is horribly invalid. It looks like all you're doing is an image rollover. Why are you even using javascript for this? [CSS will work just fine](http://css-tricks.com/css-sprites/). That said, if you want to use Javascript, clean that up too! &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src="http://imgur.com/tBLDf.png" alt="Other Websites" height="60" width="643"&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#" onmouseover="swap_img('azndisp', 'in');" onmouseout="swap_img('azndisp', 'out')"&gt;&lt;img id="azndisp" src="http://i.imgur.com/snu54.jpg"&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#" onmouseover="swap_img('rdtdisp', 'in');" onmouseout="swap_img('rdtdisp', 'out')"&gt;&lt;img id="rdtdisp" src="http://i.imgur.com/DsSuq.jpg"&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#" onmouseover="swap_img('twtdisp', 'in');" onmouseout="swap_img('twtdisp', 'out')"&gt;&lt;img id="twtdisp" src="http://i.imgur.com/dtOpw.jpg"&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script type="text/javascript"&gt; images = { 'azndisp': { 'in':'http://i.imgur.com/2nltH.png', 'out':'http://i.imgur.com/snu54.jpg' }, 'rdtdisp': { 'in':'http://i.imgur.com/LqBEF.jpg', 'out':'http://i.imgur.com/DsSuq.jpg' }, 'twtdisp': { 'in':'http://i.imgur.com/LupU6.jpg', 'out':'http://i.imgur.com/dtOpw.jpg' } } function swap_img(elem, direction) { image = document.getElementById(elem); image.src=images[elem][direction]; } &lt;/script&gt; (edited for typos)