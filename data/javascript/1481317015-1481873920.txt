https://www.reddit.com/r/javascript/comments/50u77r/douglas_crockford_removed_as_a_keynote_speaker_at/
Sounds like you're simply stuck in 2004.
If a developer writes bad code in the project's webpack config, then they've probably written bad code all throughout the actual project itself! YAML can't stop them there. So you're going to have a bad time in any case.
Thanks for the in-depth reply.
Alternate proposal? Why not have all of them - make it like eslint. * It'll read from `.eslintrc` and warns you it's deprecated. * It'll read from `.eslintrc.json` and parse as JSON * It'll read from `.eslintrc.yaml` and parse as YAML * It'll read from `.eslintrc.js` and parse as javascript. If you want to use yaml, use yaml. If you want to use javacsript, require things and have dynamic configuration, that'll work too.
What did you try already, and what error happened when you did?
Afaik the switch function only takes one argument. For more complex conditions you should use if statements
I don't believe this is a supported thing at all. I've never seen it, and I can't find any documentation about it. One variable is it. **Edit:** Just to expand my answer, you *could* accomplish this, by doing something filthy like switch(true) case (trafficLight === 'green' &amp;&amp; pedestrian) ... , but if you do, you should immediately take a bath to clean off what you've done. You could also concatenate the two variables, and have cases for each combination. This would also require some hand washing afterwards. switch (`${trafficLight}::${pedestrian}`) { case 'green::false': ... Just use `if`s.
The performance of let will get better as browsers optimize. Arrow functions are helpful and correct one of the more confusing aspects of Javascript for a lot of developers (binding this). Today's tooling is amazing. That means there is complexity, but we can do so much more now.
This should be in other browsers. Would be even cooler if we had it in some editors
just your typical programmer drama
As far as I know, a switch statement won't accept 2 expressions. You would be better off including an *if...else* statement to check your boolean first. var trafficLight = 'green'; var pedestrian = true; if (pedestrian) { switch (trafficLight) { case 'green': document.write('Watch out for the pedestrian.'); break; case 'yellow': document.write("Slow down."); break; case 'red': document.write("Stop."); break; } } else { switch (trafficLight) { case 'green': document.write("Go!"); break; case 'red': document.write("Stop."); break; default: document.write("Unknown circumstances, be careful."); break; } } 
It sounds like you are on the right path. Try disabling the button and then using $timeout to check the time every so often to see if it should be enabled.
And you're not really supposed to, he was just showing some crazy ways to acomplish that.
That's somewhat relieving. 
If you need to constantly tap on people's shoulders, then you shouldn't be programming. &gt;care to elaborate on your genius? Sure. We're programmers. Any programmer can do what we did. You obviously can't but at least you admit it. It has nothing to do with having a big head. It's just knowing how to program. Again, you obviously can't and you say so.
Hi, sorry -- as far as I can tell the code that is working is calling an ajax addToCart : addToCart = function(cart_form) { return $.ajax({ type: "POST", url: "/cart/add.js", dataType: "json", data: cart_form.serialize(), success: addToCartPass, error: addToCartFail }); }; I have no idea what the other one is calling -- when i inspect in console it says the initiator is 'other'. Do you know how I can trace it / find out what it's calling exactly? 
What you have in the header of the [`switch` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch) is a pair of identifiers separated by the [comma operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator), which evaluates both operands and evaluates to the right operand; this means that it's the same as if you just `switch`ed on `pedestrian`. --- Similarly, between the `case` keyword and the : token is an expression; each time, you have two expressions separated by the comma operator, so it's as if your cases were, respectively, `false`, `true`, `true`, `true`, and `false`. During runtime, the `switch` statement evaluates the header, and then compares this value to the expression in each `case` clause, and then starts running the statement right after that clause if there is a match, or runs the statement right after `default` if there is no match, or exits the `switch` block if there is no match and no occurrence of `default`. Execution then continues through the `switch` block, ignoring any other `case`s and any `default`, and skips to the end of the block if an unlabelled `break` is found. (Labelled `break`s are mostly used to exit outer loops: You might label a `while` loop that has a `switch` statement inside, and if you find what you're looking for inside the inner `switch`, you would use a labelled `break` to exit not just the `switch` block but also the `while` loop; you can't cross function boundaries with labelled `break`s, by the way.) --- In your case, the header of the `switch` statement is the value of `pedestrian`, and execution resumes at the first `case` if `pedestrian` is `false`, the second `case` if `true`, and the `default` otherwise; because of the `break` statements to prevent `case` fallthrough, the statements associated with the other `case`s never execute. --- As the others have said, a better idea is to use `if` and `else`; another idea is to `switch` on just `trafficLight` and then, within each `case`, use `if` and `else` to deal with the value of `pedestrian`.
Awesome thank you! 
Those numbers aren't realistic numbers, so I wouldn't trust them for practical application. These numbers are derived from simplified tests in a vacuum. Real world use is diverse and hardly simplified. That said the only value in these numbers, at all, is in comparison to other experimentation criteria. A more practical consideration is if you have two relatively small nested loops that do different things and one of those things is evaluation of one or more DOM nodes. The number of iterations is the multiplication of iterations of each loop. If each loop has a 1000 iterations then there are effectively a million total iterations occurring. If evaluation of an abstracted collection of nodes occurs in this scenario than that 3000 ops/ms is actually closer to a total execution time of 3 ops/second excluding any additional JS overhead, and that isn't so fast. These sorts of problems sound artificial, but occur more often than you might initially consider with respect to looping through classes or specific child of elements of certain classes. When this occurs UI slows down drastically, and this sort of design made many jQuery based sites extremely slow. In this case the problem is two fold: querySelectors are much slower than vanilla DOM methods and using class values as a method of identifying nodes (poor man's abstraction) is a bad design decision from a performance perspective.
Yes, I guess, by terse I meant readable. Notice how all these punctuators used in my pattern are a problem for readability. I hope it’s possible to run `async` code with fewer punctuators.
But I’m in global code. There needs to be *some* form of async function around my code for `await` expressions to work, right? I dislike the `(async () =&gt; { … })();` pattern because there are so many punctuators in sequence, which I think makes the code harder to write and potentially buggier. Ideally async blocks would be cool: async { await stuff; // work with stuff } Btw, how do I insert code blocks here on r/javascript?
I was obviously exaggerating a bit. The point is that in most cases inheritance is the wrong paradigm and you should choose composition and functional patterns.
Not exactly following the book, but closely related to it and highly recommended: https://www.gitbook.com/book/drboolean/mostly-adequate-guide/details See here for the details about Container (called `Box` in the Lesson 1) https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch8.html#the-mighty-container
Does anyone have any suggested material that may help a fellow learn to create cool js animations like this? 
Google "canvas blending modes" -- basically draw your circle, draw your image in a square of the same size, "and" the two together using `source-in`
Switch (animal){ Case 'dog': return 'woof' Case 'cat': Return 'MEOW' } If you're not returning something immediately then use break; That's it. Don't complicate switches until you have a better understanding. Hope.this helps. If you're doing more than a single compare a switch isn't the best approach. Use if. 
I'm on it thanks.
Gotcha so that code would be outside of the render function that gets called by requestAnimationFrame?
Sounds like you want to do clipping. https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clip https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing
Dude. I love your stuff. Your book is a must read. 
Could you share how to insert code blocks into comments here on Reddit?
Thank you
Thanks so much for this series, drboolean. Amazing stuff!
https://www.reddit.com/r/javascript/comments/50u77r/slug/d77wvlg
The devs who can't stand the idea were mostly people who are behind the popular projects. At least that's the impression I got on Twitter.
I love the voice!
1 - (-1) Simple math rules applied I guess.
Always consult [the operator precedence table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table) for these kinds of things. Unary-negation has higher precedence than subtraction, so your expression is interpreted as `(1 - (- 1))` or one minus negative one, which is two. 
oh sorry. that was my fail. Already fixed. Thanks
This is the case for anything web, though, until WASM. Correct me if I'm wrong, I am relatively new to this.
How do I make an AJAX post request in a babel script? I'm using React to show my feed.
Gee. So you think writing code that doesn't exist at the time is a bad judgement call? Typical redditor. What would you say to the guy who wrote those frameworks? He's out of his mind?
Nice talk. I've been playing with promises, but hadn't looked into async/await. FYI: I found that listening at 1.25x speed was more comfortable. The speaker talks fairly slowly.
Interesting. I ended up figuring out, but I will definitely implement the event listener. I can show you the working script if you would like.
Heh. And your typical reddit-speak ignores anything I said before. You are a loser and you prove it over and over. You admit you can't do what a real programmer can't do cause you need help to coding your way out of a paper bag. And you have to buy someone else's bag! What a dope. In fact, you're a bottom feeder. It's so easy to pick people like you out. Probably out of work or working for the minimum writing HTML but not allowed to touch the CSS and only after a HTML code review.
It's so old now, you should repost if you want anyone to see it.
&gt; weren't so touchy Of course, maintainers and creators of some of the biggest projects we used don't want to promote a popularity contest and wanted their projects removed in favor of supporting the little guys, such horrible people. Dang them all to heck.
$$$$
Thanks for the help everyone! Really appreciate it. :-) Sounds like I'll have a good time in the Linux world.
Its why I suggest being adept at JS before pursuing other ventures. If you are doing development on the web, you can't avoid JS. I think Ruby/Rails is great, but the eventual wall of JS will appear at some point. 
loved your course on front end masters, illl be sure to check this out!
Not sure if it's still true, but when I got my XPS13 just over a year ago you could just buy one with Ubuntu on it. I've had no issues doing web dev on it, although in fairness I haven't been at it for long. Certainly, I'd have run into more issues due to windows being windows than I have due to linux-y things while developing. 
What sort of headers are being sent when the PDF is given to the browser? Make sure you're setting the `Content-Disposition` header to `attachment` and if you aren't, see if that fixes the issue you're seeing.
Can you give an example of such troublesome component? Maybe problem is with components itself (maybe they are too big? Maybe they can be splitted into few smaller components?). And why changing version of one component breaks everything else? Are they decoupled enough from the rest of application? 
Answer fee more like it :P 
Call me a dissenter, but.... I feel like I've been doing imperative and object-oriented programming so long that I see these functional abstractions as completely unreadable. From the `parseDbUrl` example in Lesson 5, the explicit `try/catch`, explicit conditional branching, and explicit returns is 1000x more logical and readable to me than the functionally composed example. Hiding from these language-level keywords in arbitrarily named abstractions like `chain` and `fold` adds enormous mental overhead, for what I see as very little gain. Sure, you could argue it's *less* code, but it's denser, less explicit, and more abstract. I suppose if you've been working with these abstractions day-in and day-out you can understand them well enough, but it doesn't change the fact that they *are* abstractions, and add indirection to otherwise simple code.
My new thesaurus is terrible. Not only that, but it's also terrible. 
At least until webassembly code can allocate DOM objects, then you can write your code in C/C++ -- oh joy! -- until they support other languages. Webassembly is indeed very interesting and exciting, but I think it's a little overhyped in it's current state.
done. but can not delete or hide this post. Hide button is not clickable at my phone 🤔
My workmates try to push functional. I think it's interesting, but I see no reason to intentionally create code that requires more work to understand. I've yet to have heard a reason, that fixes a real problem I have, for why we should use functional. 
yeah! react [react-virtualized](https://bvaughn.github.io/react-virtualized/#/components/Collection) is cool! I not want to create another component alike this. so I just create a lib not in react but also can use in react.
Interesting videos, but this looks SO slow compared to the imperative functions.
I mean I scaled a side project to 13,000 users while working a full-time job writing React applications, and was also nominated for a Canadian Developer 30 Under 30 award but sure man, whatever you say :)
&gt; And you cut out half the potential applicants by advertising the framework you use because they don't know it and you still have to pay to train them on yours. Same thing. Not the same thing, no. Even if it were the same thing, and I have half the applicants, that half already know how the framework that underpins my code works... Training effort once I decide who to hire is therefore focused on the things that make my business different, instead of focusing on the things which make my business the same. &gt; Before there was Angular and React and all that, there was our framework that still does more than those do and ours did it better then and they still do parts better now. Terribly easy claim to make. You can sit behind the argument that it is proprietary code and you never have to prove whether or not you are right. But let's assume that the majority of companies out there are not employing superhuman developers who can write solutions better than those written as a result of the refined experience of thousands of people across tens of thousands of projects - in those cases, businesses would be better off treading the well-worn path, would they not? &gt; Redditors like to call it NIH when they don't understand how that programmers can write these things, too, without outside help. Redditors didn't invent NIH. It's a well-understood problem which predates reddit. It is the observation that instead a group of programmers think they know more than everyone about every single problem space. The reality is that most developers are not this good, and we specialise in certain things within the craft. We can do this because we can leverage the work of others to fill in the gaps. Developers who suffer from NIH _generally_ show a surprising lack of maturity and ability - there is a strong correlation between NIH and the Dunning-Kruger effect...
some people don't write much JavaScript. I wouldn't expect another language's community to keep up with latest releases of a different language. It naturally a low priority for them.
Webstorms tooling around conflicts are glorious. Best experience I've ever had fixing a fubar merge. 
In HTML5 test with Technical Preview, it's not 100% or a full score? https://html5test.com/
Your familiarity with OO abstractions is likely skewing your perspective on how complex they actually are. Especially in comparison to their analogs in FP Rich Hickey talks about this a lot. https://youtu.be/rI8tNMsozo0. 
That has landed in Chrome and Firefox if I'm not mistaken. 
Instantly reminded me of this movie http://www.imdb.com/title/tt0307479/ (yes, I know, a remake of http://www.imdb.com/title/tt0069293/)
Do you still need help?
Me, too!
Typical child-like reddit thinking that nothing outside of popular frameworks can be accomplished. How framework writers ever accomplished what they did is never questioned but no one else can do that. It's magical, mystery fairy dust. When Dennis Ritchie decided to work on C, I'm sure redditors would have been all over his case telling him he can't possibly do that. Or create Unix either with Thompson. The reddit world is as blind as can be and I love it when they tell me we can't do what we've been doing for 12 years.
I really don't like this code style. Why is everything made of const single-statement arrow functions? What happend to function and return?
They would make the code distractingly verbose 
Bad clone...
To reassign a variable in an enclosing scope, Python actually does require the nonlocal keyword to avoid ambiguity.
Can some1 tl;dw why are they terrible?
It's very laggy even in Chrome but I like the idea and I bet it was fun experience. Now do a Skyrim table clone pls.
This is great 😂 High score was 6.
Can you give a concrete example to demonstrate the advantage of the explicit `return`-writing style?
I feel like the point of functional programming is that you get implicit safety out of it. In OO you have state potentially everywhere. So then you have to do design to solve that, but people can mess up design easily. In functional programming your only state/data is at the start. So random variables or properties aren't being changed from any random part of a program. So yeah it's more abstract and sometimes harder to reason about, but the abstraction leads to more safety, especially in a language like JavaScript.
The video description says the guy prefers callbacks. Not why, though. /Edit: Watched it. He presents a code example in three versions: Callback, promise, await. He actually says the promise version is better than the callback version, but he still prefers callbacks. So the title is bullshit
&gt; Ignoring the tiny standalone distro's and slackware there are only 2 main branches of distro, those that stem from the Debian side and those that stem from the Redhat/fedora side. Don't forget Arch!
`brew uninstall node` seems pretty straightforward...
Kinda funny, back when I was writing my first code (it was in JS) and had zero programming experience, my initial code styles were a mix of imperative and functional. I've always treated code as immutable in my head, wrote pure functions, and have never ever dealt with context (outside of React components), all without knowing what functional programming was. When I went to college I dropped out because I couldn't understand OO paradigms (learned C#) or grasp constructors, how mutability is a good thing, or classes in general, and I flunked because of it. I know it's anecdotal, but I've realized my brain is just wired for fp and OO is the one the looks like a foreign language to me.
Only if you ignore how the implementation of "classes" is. It's wrapper around a prototypal inheritance system. Which divides it's responsibilities in a wildly different manner that what you'd expect from true class system. Authority flows down a series of classically inherited class toward it's final implementation. In JS. Even with the addition of class that's reversed. You travel up the prototype chain. The underbelly of JS feels more like Scheme than anything else. Which was and is a language geared toward FP. And FP does not. And has not ever require strong typing. Or any typing for that matter. Early FP style languages didn't have that. It's not a hard requirement. 
I'm not a hardcore FP guy so if they tell you not to listen to me, fine, but: `chain` and `fold` are more complex to you only because you're understanding them by translating into your previous model, rather than understanding them directly as you do your previous model. It's possible to understand FP directly, which allows you to wield it as easily (some say more easily) than you do imperative. And, yeah, the imperative model is more "real" in that it's closer to the machine, and thinking only in terms of FP will (in current implementations) sometimes create performance nightmares. FP people say (a) implementations can improve and (b) higher-level programming is what enables greater products, and the nature of stepping up a level is accepting a performance hit in order to delegate work to the machine, which we already see today in very wasteful languages like JS and Python; FP is the next step. I don't quite buy it, as least not on today's hardware, which is why I haven't dove deep into FP to see if it's really that good. Anyway, point is, the mental part of that overhead can disappear and the perf part may shrink and may be worth it.
I bet it's a great course but, a caveat, right on the site's front page "This isn't JavaScript from scratch, so if you are looking for a beginner course this probably isn't it."
Edit: the post was getting downvoted initially, thanks for those who replied.
Thanks!
I've used it. I like it a lot. If you understand react eco-system, RN comes very natural. The interactions with the build are buttery smooth. There are limitations with RN of course, but if you're not doing heavy animations or strange custom UIs; RN should be a good pick.
[egghead.io](https://egghead.io/courses/learn-es6-ecmascript-2015) is pretty consistent with high quality material. I haven't seen their ES6 course but I watched a few others and they were great. 
I'm most of the way through my second RN app. Much better than the Xamarin experience. We still use Xamarin for our work projects, but when I tell the coworkers about things like code push they get jell. &gt;:-) I've had 100% code shared between android and iOS on both my RN project, besides a couple style sheets. Couldn't rec RN enough. 'react-native link' has been amazing, too. I've only had to drop into Java/C# to do things like change background colors on app startup. Maps/code push/image picker/geo locations have been effortless. Changing the name of an iOS app is still a huge pain point, but that has always been in any app I've made. Disclaimer: I've been using React in web projects for quite some time now.
Could anyone please explain the `inspect` trick? It is working in node, but I don't think it works in Chrome dev tools console (at least it didn't work for me). Do console.log's behave differently in Node and in browsers? /u/drboolean ? Halp?
It used to be Atom, but after a couple of days working on an Angular 2/Typescript based project I'm deeply smitten with VS Code - the intellisense is just fantastic.
I don't agree with this idea of "learning ES6". They're just features of JS that happened to get released later. Find some good, recent JavaScript learning resources, and hopefully, if they're competent, the relevant ES6 features will be brought up at the appropriate times, just as the relevant ES5 features are. The right time to learn about arrow functions is not "when you're learning ES6", it's probably some point after you've learned about objects and how the `this` keyword works, and how the arrow function can behave differently in relation to it. And maybe earlier on the teacher could mention it while they're explaining functions, while noting that there are more differences than just syntax, which will be explained later. 
Check out Stephen Griders ES6 syntax over at Udemy. Google his class name and Udemy coupon to find discounted price at 10 bucks instead 
I really like the class and extend features of es6.
I think I'm like that too. It's interesting that people can do better in different paradigms.
Hoisting gone wrong?
Yeah, just node :/ I often make a toString() for the browser, but I don't think it's implicitly called so: console.log(String(Box(3))) Would love to know if there is a better way. 
If you're not using *any* abstractions and just using basic language features and combining them, you're programming in old fashioned assembly, and that doesn't scale at all. Like not even to medium sized projects. I'm not saying your code is not scalable; I'm saying it likely contains abstractions. I find it interesting that most people in the FP world say that imperative abstractions are harder to follow than FP abstractions, and people from the imperative world say that FP abstractions are harder to follow than imperative abstractions. What becomes the tie breaker? To me, the tie breaker is that most people in the FP world (myself most definitely included) started in the imperative world, learned FP, and never looked back, while most people in the imperative world (most that I know anyways -- I'm thinking mostly of my brother) simply never learned FP abstractions.
I looked into your course javascript30(Mainly the project 1 Drum kit). Just wanted to know if there is any particular reason why you did not choose to use arrow functions ? 
Pure functional code must be composed or the output gets lost. It's okay to "cheat", but for the purposes of learning, no return means you are doing it right.
Indeed, some examples are hard to read but the formatting is easy to improve. I have tried to do it in https://github.com/dmitriz/functional-examples and you are welcome to make an improvement suggestion ;) 
But most of it is just syntactic sugar and not actually new features. If you don't understand ES5 they won't mean anything for you except that it is a shiny new thing.
This...is...reddit
Remember the torture scene in the movie Payback? Well, RN was more painful than that. Happily got the fuck out and rewrote everything with Swift in half the time. 
Just a spoonful of syntactic sugar makes complaining about js go down.
I used it like a year ago, so things may have changed now. Pros: * Workflow of testing and deploying to a device is awesome * React makes building UI way easier than with native or Xamarin * CodePush is the best thing that has ever happened to mobile dev although this is not exclusive to RN. Cons: * Bad documentation * Still in beta and moving fast. At the time there were serious bugs and most tutorials and guides were outdated * Styling is cumbersome compared to CSS (although still better than native). * Performance is better than Cordova for sure, but it doesn't feel native in my experience unless you have a high end device. * Not solid enough for production use I'm afraid. The instagram app is made with RN and is the app [with most crashes in iOS](http://cdn.bgr.com/2016/11/ios-crashing-apps.png). [Source](http://bgr.com/2016/11/17/iphone-vs-android-reliability-crashing-apps/). * The Facebook guys at Github are not so friendly. In my experience PRs are ignored and closed after months. It makes sense, since React and RN are internal project they share with the world, but still. I tried it. I hit a wall, and since I ran out of time and budget I had to resort to using Cordova. RN may be better now, but I'm moving out of React and RN. For my next mobile cross platform project I will give [NativeScript](https://www.nativescript.org/) + Angular 2 a try. It's much more mature and it has many advantages over RN. For example you have [direct access to all the native API](https://docs.nativescript.org/core-concepts/accessing-native-apis-with-javascript).
I think this goes way to far. (immutable) values and pure function based programming solve a problem, but making everything as terse and similar as possible mostly just hurts. I don't see a solution to a problem but an abstract soup of maps and folds kept together with brace webs and dots with no clear view of actual business logic achieved. 
there are various ways to structure it, but the general idea is that this operation is relatively expensive so you can do it just once and then cache the result
Yep. Everytime I try to build a JavaScript project on github.
No man, the weird js parts will still be weird. It's strongly recommended to learn es6/7/8 features at the appropriate time. 
I've been building an app with RN on Android / iOS. The performance seems to be on par so far. Also so far I have 100% shared code which is cool. I'm sure it depends on your application, if you're crunching huge amounts of data the js performance on Android is inferior to iOS so that will affect your app. If you're just making a bunch of scrollviews with animations they're equal.
FYI, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a source of good info on more advanced concepts.
&gt; If I were building a game or something really sophisticated without much standard UI, I see Xamarin as the nuclear option. Wouldn't Unity be a better option?
Intuit has also adopted RN, and it has been a major factor in their success. 
yeah, Unity would make more sense for a game, although Xamarin could do it too, it just wouldn't have a lot of the graphics tools Unity provides 
Please Excuse My Dear Aunt Sally https://www.mathsisfun.com/operation-order-pemdas.html
Okay, did not read correctly the. But that is, when you run them in the browser. If you run them in node with a decent test runner and enzyme for react components it's more easy to test and debug.
Did you alraedy know Swift?
Exactly 🙃, there were so much dirty libraries I remember from my Angular 1 development period. JQuery libraries ported to Angular directives, doing all kinds of dirty $scope manipulations to get it to do what they needed. Angular decides when to re-render, changing that requires you to get your hands dirty. In React you are in the middle of this re-rendering process. You can explicitly set state or decide props to trigger or not trigger re-renders. But when you do not need to do anything special the default behaviour just works fine. To me NG2 feeling "enterprise" is just because it's presented like it is. It has a design that makes components look like C#/Java classes which makes those "enterprise" devs feel at home (some lot of them think web development is a less "enterprise" thing anyway).
Hi. Slightly belated answer, coming back around to this thread. /u/KatyWings is correct. With the React-Redux library, the normal approach is that the store instance is made available to all React components in the app using React's `context` feature. Each connected component subscribes to the store separately, and provides a function called `mapStateToProps`. Whenever an action is dispatched, the store notifies all of its subscribers, and each `mapState` function will be run. The wrapper component generated by `connect` checks the result of its `mapState` call to see if anything actually changed, and if so, re-renders the wrapped-up component using the new data. So, while each wrapper component is subscribed to the whole store, each wrapped component effectively only "subscribes" to the pieces of data it cares about, which may have come from anywhere in the store (or have been derived from that data). There _are_ a number of addon libraries that add various approaches to managing subscriptions on top of the core `store.subscribe()` primitive that Redux offers. I have them listed in the [Store#Store Change Subscriptions](https://github.com/markerikson/redux-ecosystem-links/blob/master/store.md#store-change-subscriptions) section of my [Redux addons catalog](https://github.com/markerikson/redux-ecosystem-links).
I prefer "free" functions to methods. So say you build up a collection of free functions (or use [Ramda](http://ramdajs.com/)): const map = f =&gt; x =&gt; x.map(f) const fold = f =&gt; x =&gt; x.fold(f) const trim = x =&gt; x.trim() // etc... Then you can change this... const nextCharForNumberString = str =&gt; Box(str) .map(s =&gt; s.trim()) .map(r =&gt; parseInt(r)) .map(i =&gt; i + 1) .map(i =&gt; String.fromCharCode(i)) .fold(s =&gt; s.toLowerCase()) To a point free function composition. This is useful because it allows you to drop all the intermediate `s`, `r`, `i` variable names. And, IMHO, represents the functional data flow better than method chaining. const nextCharForNumberString = compose( fold(toLowerCase), map(fromCharCode), map(inc), // const inc = x =&gt; x + 1 map(parseInt), map(trim), Box ) Or, because `map g . map f == map (g . f)` we can refactor the above code to: const nextCharForNumberString = compose( fold(toLowerCase), map(compose(fromCharCode, inc, parseInt, trim)), Box ) Also note, well named, intermediate functions help, so maybe in the above code you pull out a couple functions for clarity. const toInt = compose(parseInt, trim) const nextCharFromInt = compose(fromCharCode, inc) // String -&gt; Char const nextCharForNumberString = compose( fold(toLowerCase), map(compose(nextCharFromInt, toInt)), Box ) And so one, until you reach some clear composition of functions that clearly represents your intent!
What's a module-level function? I don't believe JS makes any distinctions among function types.
&gt; My workmates try to push functional. I think it's interesting, but I see no reason to intentionally create code that requires more work to understand. I've yet to have heard a reason, that fixes a real problem I have, for why we should use functional. That's fine. But think of it the other way - you learned imperative programming first. It makes a radically different style of programming difficult to learn. Some universities teach FP first now, since the concepts actually make more sense to those beginning programming. The goal of functional programming is referential transparency, often accompanied by a strong type system, which makes it easier to reason about your code, and for the compiler to point out mistakes. That's all. Advanced concepts like composition, currying, monads, functors, etc. are just generic patterns that are available because a language like Haskell adheres to so many formal rules. You can take them or leave them. But if you do embrace these concepts you will generally see huge leaps in code simplification and code reduction over time. The goal is not to "to intentionally create code that requires more work to understand". Either you've misinterpreted that, or your workmates haven't done a good job a teaching/learning. But you don't have to change, that's fine! Just say you aren't interested in learning a new coding style, instead of mislabeling functional programming as foolish. 
This comment is correct, but right now AMD support isn't implemented. Check out [this issue](https://github.com/Microsoft/TypeScript/issues/6942).
It is written in ES6. The react/react native imports are split. I have tried every version of React. Trust me, if this was fixed then that issue would be closed.
Yes. But I've also developed with JS for over 15 years. 
Believe me, even like that, getting the boilerplates up and running, development and debugging went much faster. 
I'm not saying FP is foolish. Just stating the commonly stated problems it solves aren't problems I have. Obviously, FP does have benefits or it would never be discussed. One of the workmates wrote an app in common lisp. I'm the only person on my small team who is proficient with lisp or really any FP language, so it's my job to maintain it when problems arise. The app is just a simple website. There's literally no reason to use lisp other than RDD (resume driven development), especially when you take into account that only a few developers have worked professionally in lisp. The obviously better choice for a language would have been the language we use for all of our back-ends, java. 
This guy just likes callbacks better, for imperative programming purposes. I don't like them because they're they're eager and stateful, which makes them slow and clunky for declarative/FP purposes.
I use P4Merge. Even though it's free, it's absolutely the best tool for 3-way merges, and it's also a pretty damn good differ. For maximum productivity, make sure you configure p4merge as the mergetool and difftool in your .gitconfig: https://gist.github.com/tony4d/3454372 With P4Merge, git rebase becomes soooo much more enjoyable.
Like in your main script or the scope of a module; the named stuff you plan to reuse and possibly export (as opposed to defined in local scopes in these functions).
Wow, that's a wildly inefficient and unnecessarily complicated script. `var response = JSON.parse(result.responseText);` Now just grab the data you need directly from the response object: `response.imdbRating` (which in your script was set to `rating`) or `response.Metascore` (which in your script was set to `meta`). Also your modified code is failing because (I'm assuming) you're attempting to use variables that you are no longer assigning. For example: `" &lt;br&gt;&lt;br&gt;&lt;b&gt;Awards:&lt;/b&gt; " + Awards + "`, where it says ` + Awards + `, that's a variable you've gotten rid of. I recommend running `console.log(response)` after `response` is set and checking your browser's console output to get a better understanding of what the object contains and how to access its data.
I'm not 100% sure on your goal and what you're trying to accomplish here but I will say that attempting to scrape and use other sites programmatically is a slippery slope. First of all because it's probably against the TOS of the site you're trying to automate or pull data from. Second because if they change the structure of their DOM or somehow change their site in any other way your service will probably break. Third because you might get rate limited and stop receiving responses from their server. There's probably other issues as well, but these are the ones that come to mind.
It sounds like you probably write good OO code. But I think that's one of the reasons I like a functional approach better, because not everyone writes good code. You write a program in a functional language badly, well it might take forever to run, but you can atleast be confident it works correctly. You do bad OO code, it might be inefficient as well, but you can also never really be confident in it working correctly. Potential bugs arising anywhere. But at the end of the day, all that matters is if you're writing good code. So if someone writes good OO code, I see no reason why they should switch paradigms.
Any time you replace HTML with new HTML, you have to rebind all the listeners of the HTML that was replaced; so that's why your cells are losing their functionality. jQuery handles a ton for you that you're probably not aware of yet, but it doesn't handle rebinding the events/listeners. So each time you replace the HTML, you should also recall the jQuery method you used to bind your classes accordingly. In native JavaScript, which is what jQuery runs under the hood, you have to add individual event listeners to each and every single node you want to add a listener to (there's no "add all listeners to a class function" =&gt; you actually have to iterate over each and every one), so jQuery doesn't have some continual method running that constantly checks if it needs to re-add listeners or not (you'd have to write that, or just manually call it each time you append new html).
That's true for most JetBrains IDEs, but the plugins that make AppCode and Rider work aren't available for IntelliJ.
Hi /u/svgiardia, please use an online service to host your code. We can't tell you what to do without seeing the code. Here are a few ways you can post your code: * [Codepen](http://codepen.io/pen/) * [JSFiddle](http://jsfiddle.net/) Please reply to this comment once you have done that and I will make the post public. Thanks!
Between the amount of dom manipulation jQuery is already doing and as azium mentioned rebinding all the event handlers I doubt it would be slower.
Hi /u/kenman, and thank you for the suggestion! I am even having trouble getting these services to display my site correctly (I don't know how to use them to reference multiple external stylesheets/external.js files. IYO, is it safe to give redditors the url to the actual website I am working on?
I think it nowadays boils down to your habits and personal preferences. I use Linux for all my development and when I tried switching to a Mac, it was just plain horrible for me. Not because Mac or OS X is bad in any way, but I'm just very used to all the tools, keyboard shortcuts etc. so it was a huge challenge to switch, so I just went back to Linux. I feel you may find yourself in a similar position when you try to switch from a Mac to either Windows or Linux, so brace yourself and keep an open mind. Things are rarely "good" or "bad", but are "different" which can be a challenge to get used to.
Yeah I'm pretty sure I have that wrong there, my bad.
What you might be looking for is [MutationObserver](https://developer.mozilla.org/en/docs/Web/API/MutationObserver#Example_usage). It allows you to listen for changes to the DOM and run some code when something changes. 
For mobile development I've written native iOS apps with Swift and Objective-C. After that at my previous company we moved to React Native because we were all familiar with JavaScript and we were really digging what the React team was doing on the web. I'm at a new company now that has been using Xamarin and Xamarin Forms for an internal app. I like RN and Xamarin since they both compile to native code. Xamarin is nice because the wrapper it provides maps almost directly to the platform you are targeting. My preference is for RN because I have a lot of experience with JavaScript. It presented a low barrier of entry for the team. Additionally I found it easier to share code between platforms without resorting to platform specific APIs. Xamarin is nice because it wraps native APIs in C# so if your team knows Android or iOS they should feel at home. Personally if I were starting a mobile from scratch I would go with React Native. For React Native specifically I enjoyed being able to develop with JavaScript in my editor of choice and then compiling the code with Xcode. Building and deploying with Xcode was nice because it's a workflow we were already familiar with. Another great feature is being able to inspect the rendered views directly in Xcode. Let me know if I can provide any other insights as far as native code, RN, and Xamarin are concerned.
Exactly, in most cases fold is reduce. Something like `fold :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b`, where you have to pass an initial value in addition to the folding function. In the example above it's a little strange - they are using it to "unwrap" the value and apply a function to it. That looks more like [Haskell's `foldMap`](http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:foldMap). Really, the `fold` method in the example is a specialized version of fold where you ignore the accumulator. 
The only way to avoid the error is either they have configured their server to allow cross-origin requests (they haven't) or they support JSONP.
I'm a contractor and started working on a new contract using RN for the first time about 6 months ago. I'll try to list out some of the pros and cons that I've experienced which aren't so commonly listed here. **Pros:** * HOT!! Lots of attention buzzing around RN right now in the dev community which really helps with 3rd party lib development for anything that's lacking. * Because of the previous point, you have a lot of influence to add to or make suggestions to libraries that you use, and even to the RN team itself. * Very easy to build modules that communicate with the underlying native OS for custom functionality and hardware access. * Lifecycle. RN has lifecycle methods that feel similar to mobile lifecycle methods and give you control over when you execute your logic. **Cons:** * This is the biggest issue IMO. RN and many of its core libraries are very forgiving and flexible due to being built with Javascript. Sometimes this may be refreshing with the dynamic/type freedom it offers, however...You CAN make RN work in many ways, but it will work very poorly in terms of performance / responsiveness when coded carelessly. This is especially apparent when you're using some type of data flow framework such as Flux or Redux (with bad coding practices). **TLDR;** RN has many positives, but also has some negatives when used carelessly. Now that I am familiar with it, I have a new mobile contract coming up that requires cross platform development and I have chosen to use RN for my platform.
it's fine. we need to be able to stand up to more than that so as not waste our time caught up on tone. im from the camp that believes: toughen up. if you run a project or forum, there are measures you can take to silently ignore people not following your rules of tone and upVote those participating according to your rules. Complaining about it is to admit to defeat. It's defeatist. Through leadership one can carve out the tone one wants out of the community surrounding their project. Through actions. That said, I do like the idea of a javascript community sensitive to each's work. It's important. But we must be balanced about it and not swing the other way and become tone police. I'm hopeful that we are moving in a productive direction and have been for a while. I think the the good in how people communicate to each other on github and stackoverflow outweighs the few attention-grabbing negative times. 
Granted, this is the JavaScript subreddit, but from the perspective of a native developer, it's still far behind.
[removed]
Let's learn es6 from Ryan Christiani, the YouTube videos are good if you know javascript and want to learn "the new stuff" On mobile so I can't provide a link, but search for it and you'll find it. 
Right now I have to work with this version of node. How can I fix the current system? 
Cool. You might want to display a message for zero "in the area" results
JavaScript is free, and if you have a web browser you already "have" it.
You can create a server side proxy which will allow you to access the content as if it was on your own domain. 
Not sure if you've figured it out yet or not, but [this](http://pastebin.com/8RfqAJhf) should do what you want.
&gt; fetch('https://www.reddit.com/r/javascript.json') &gt; @azium the thing is that I need my data in my babel script to display it. What do I do?
&gt; That is nice. Some people can't stand a build step, not needing one is nice. Especially if you have some legacy enterprise application where you just need better interactivity on a server rendered view and your needs aren't very complex. 
All we are saying is give Vue a chance ♫♪♩♬ https://www.youtube.com/watch?v=RkZC7sqImaM 
&gt; You choose not to use it, but that doesn't mean it doesn't have first class support in the React world. [...] Any semi-professional developer using Webpack or React Native can go without bind like it's a piece of cake. To paint it any other way is missing the essence. Well, that's a very shaky generalization. Just because React as an ecosystem supports proposed syntax that is not yet part of the spec doesn't mean that this is being fine for and being use by all of the React community. I've read a number of articles about how people don't want to use features that might change in the future, and those are left with syntax that is, in the end, worse that ours that aims to be maintainable painlessly with syntax from the current specs. Others argue that React classes shouldn't be used in most cases anyway and most of your app should be made from functional components - so this disussion is moot for these people, etc. It may simply be a question of philosophy, and that's fine. React doesn't focus on the ability to be usable directly in the browser without a build chain as much as Vue does, so naturally there are different priorities in what each has to / can support to achieve their goal. But in this post here we were arguing about why Vue is not using ES6 classes. And I think arguing for ES6 classes with the sentiment that "they are totally cool if you also use this proposed syntax with it, maybe it's par of the spec in one or two years" is weird to me personally.
There are good things about Vue, like its simplicity and performance, and I think it's great for a small, simple app. But there are a few things that are lacking for me. IMO they should have copied Angular 1's excellent dependency injection framework, rather than the clumsy template syntax. On a large app the templates quickly get out of hand and the lack of a DI framework makes state and service management more difficult. Also, directives don't seem to be able to be reactive to data in the same way that components are (i.e. you can't specify a `data()` function inside it, and watch for changes). The single component files are a misjudgement - it looks like you're making things easier by having everything in one file, but you then have to get it to work with eslint, and then the eslint html plugin doesn't like th `@` template syntax. A mess. They should have made things simple and had separate files. Now, I know what you're going to say, you can use JSX, or you can separate into different files, or you can use your own DI framework (Angular 2's is excellent too), but this is the same for any modern framework, these things can be swapped around at will. The difference is that here they are the default and that's what you're going to see used in the community. The community, by the way, is small. Again, fine for a small app, but with a large production app I'd rather see better support. I would also like to say, however, that I am using and enjoying using Vue. Just, let's not get carried away.
can you link to your site or show some code that demonstrates the problem? it's a little hard to understand from your description. It sounds like later releases of your app no longer match the structure saved in local storage by older versions. You would need to fire an action to restructure localStorage if there's a discrepancy, not sure if there's a lib for that. Do you have tests for your reducers?
You can pass data to directives and watch for changes in the `update` hook.
Your best bet to getting started is http://jsforcats.com (silly title; excellent content). It'll walk you through everything you need to get started today, including all the software you need (hint; it's all free, and you probably already have it). JavaScript is an excellent tool for being creative and building both simple and complex things, but it's not always going to be easy. Stick with it even when things are tough, and pop back in here to ask more questions as you go along! Good luck!
This isn't "shilling". Shilling is a paid thing. This is just enthusiasts promoting something they see offering value to the community. We shouldn't be discouraging that. This is just [Garner Hype Cycles](http://cdn.business2community.com/wp-content/uploads/2014/05/Gartner-Hype-Cycle-v2.png) in action. Vue's visibility is unusually high at the moment, but it will settle down and find a more stable long term place. 
I know that, but then that data has to come from the parent, rather than from an imported service.
You can use Vuex (The redux of Vue) for state management, and use regular imports as a service. for example: import authService from authService: // authService.js export default { login, ... } 
Ahh yes, I am talking about SPAs. Well, I haven't tried anything else than Angular. I think I should give it a try. Thanks.
I'm not advocating Vue. I actually don't like it. I'm just saying it **can** do what you asked. Look into Aurelia, Angular 2 or Ember (my preference) if you want to build a SPA.
Isn't this just advocacy? Where do you draw the line?
This is a great series on egghead.io. If you listen to the first few seconds and think WTF just keep listening. The author clearly knows his stuff. And even if you do not buy into this style of programming (functional) you can still learn a crap ton of stuff. I have made it to video 19 so far, really good content.
Look at my username and tell me if I have interest to advertised Vue. I am Angular developer that just like Vue.
I understand Vue supports JSX, but fail to see how it's an improvement over React with that premise. It doesn't help that most examples use the Angular-like deformation of HTML. Basically React is fine (to me) as a view library but I'm not too keen on the Redux/Router boilerplate, is this where Vue shines?
Oh yeah, nice cover, SHILL. :)
I'm not trying to force or convince anyone to use Vue. I just want to understand why people are "afraid" or preferred not to use Vue.
You can explain what Vue missing from Angular perspective? Vue has a great router, components, directives, her own redux, and even server side rendering. The only thing that is missing is the DI. In React you don't have DI, and I don't see any developers complaining about that.
But that _is_ uni-directional, because it is reactive to a service. Data doesn't have to come via the parent to be uni-directional. That's why there are concepts such as `connect` and `context` in React - it's to bypass the parent, but still be uni-directional. It's uni-directional if you can't pass data back to the service, whether it comes from the parent or not.
[removed]
I think what /u/mini_eggs means is that Vue does not use classes, instead components are described solely by an options object. And because of the way Vue is architected, it is very difficult/impossible to use with typescript in a class-y way.
Not true. https://github.com/vuejs/vue-class-component
how to do this? 
I personally choose the most popular framework because I personally prefer to make my project more accessible and easy.
So, this happened: fetch API as a Task. https://www.npmjs.com/package/fetch-task
So, I am a shill if I like framework X ? Not to mention that "shill" (and shilling) has a negative connotation...as it implies corruption (shilling, by definition, means that motives do not stem from genuinely liking thing X, but from some other form of interest) You see...back in the days we used to call it simply "fanboysim" and it referred to...liking thing X more than thing Y, regardless of the X's flaws....and it existed since the dawn of programming languages and frameworks. It didn't have negative connotation and it didn't judge your morality,it just implied that you have strong passion towards X and that you might be blindsided by it ...but these days "I like framework X" "Fucking shills." I blame the last few months and election hysteria and paranoia when opposing opinions would be classified as "shilling",m when in fact they were just...opposing opinions
&gt;**This page has been removed!** &gt; &gt;This page is no longer available. It has either expired, been removed by its creator, or removed by one of the Pastebin staff.
I would use React Native only if there is some hardware or OS depency like listing files in a folder recursively that is not available on the web platform. Progressive web apps have some advantages over native apps like not needing the user to install it before using.
Do NOT ever get ANYTHING from Microsoft; the destroyer of worlds. Once you fall down that rabbit hole, you will never be seen again. The anti-religion of all things internet.
I'll sell it to you for cheaper. 100% real. No fakes!
I agree that there are good reasons to do your own class system, but I don't think "not having to transpile" is a very good reason. The translation from ES6 class syntax to ES5 prototype manipulation is really trivial, and you could make a functionally-identical shim for them in half an hour. So if your only reason for eschewing ES6 classes is to not require a compile step, it's not hard to make your library _compatible_ with ES6 classes.
Why would you want to use exports? Their not nearly as powerful as module.exports. 
Seems like basic stuff. Also does not work on chrome mobile on Pixel XL
Thanks for your reply, When I use console.log it doesn't show up on the webpage. Is there another way to make it appear, because only document.write seems to work for me.
I'm not the greatest designer so that's all you get haha. I'll work on the F/C switch though.
example: At the moment we are using Backbone (AMD modules) for UI components, and where we need some *DropDownWithSearch* we include it from our UI library. The trouble begins when someone must modify that dropdown to meet requirements for the new components he is building, and that change happens to be backward incompatible. Because we don't have versioned components at the moment, we must find time to go and fix every usage of existing component, modify it so that it works with new API, test it and only then we can deploy new component we wanted in a first place. And then, as the Murphy's law commands, it might turn out that the new component is not that well received by the users, and we need to revert it to the old one. In our current scenario, both upgrade and revert are major pain and time waist and people management/juggle. If we had versioned components we could test the new *DropDownWithSearch* in new app, see how it behaves and it its ok update rest of the apps asynchronously, and if its bad, revert it just there.
It's not "afraid" or "not preferred to use", adopting and learning a whole new framework is a lot of work, and for most people it seems the current solutions are "good enough". Already tried so many frameworks and new tools and libraries, vue is "just another js framework" in a saturated world. It's nice that it works better for some people, but it's not so needed apparently.
I can't from an Angular point of view, but I can from Ember. The problem is that you're going to just yell **You can add that!** for anything I say. The difference is that these things are **already there** in Ember. You say "Vue has" these things, but Vue doesn't actually have jack. You simply have the ability to add them. Which... reminds me of the days when you bought a TV that was "HD Compatible". However, there are things I'd say that Vue does NOT have. For example, command line. Ember (Angular 2 has the same thing) has Ember CLI. The command line interface does a huge amount of things. Aside from scaffolding - literally the only thing Vue CLI does and it does it badly - Ember CLI is the full build tool, handles dependency management, test running, boilerplate generation, an auto-reloading dev server, and is extensible to do a bunch of other stuff including deployment. Vue devs love to dismiss this by saying "Sure, but scaffolding is only done once!". Which is simply because they're unaware of the amazing functionality afforded by Ember's CLI. Let me give you an example. ember new my-new-project &amp;&amp; cd my-new-project ember generate route about ember generate route post ember generate route post/show ember install ember-bootstrap ember server At this point I literally have a SPA. The router is set up with all of my routes, they're already configured, including the dynamic one, with a url of `/post/:id`. The routes I need to support exist, I just need to set up the model they return. In the case of the `/about` route, there's no model so I can ignore it (or even delete the route file). Then all I need to do is modify the .hbs templates. Which have already been generated in the right places and are already built and being loaded. I can actually already use Bootstrap classes for my grid, etc. No need to add them to anything. With a few commands and a little HTML I can make a working (if trivial) SPA. You have to ask yourself honestly what that would take in Vue. Don't dismiss it and just say "oh it wouldn't be hard". Think through the process, the steps to do it. Installing the router, installing bootstrap, running the bower install, adding it to webpack or whatever tool you use, setting the router up, pulling in the bootstrap css, etc. Disregarding NPM time, this is *seconds* in Ember. Moving on, and I'll just say one more thing, Ember Data. Ember Data is the unique model layer for Ember. It essentially transforms persistence into an ORM style, and it uses a pattern that provides an "adaptor" for different formats. For example, you can get a REST adapter (available by default), or a local storage adaptor, couchdb, firebase, airtable. Anything like that. Regardless of what you use, you can simply define your model, and then request and save them directly. Our posts route from above would simply return as its model call `return this.get('store').findAll('post');`. It could save one with `model.save()`. All promise aware, and you can even mix different model adapters. This rich model layer allows addons to Ember like Mirage. Installed and configured as simply as `ember install ember-cli-mirage`, Mirage is able to use your model definitions to generate fake data, intercept your API requests, and return that fake data as you determine. This trivialises data setup for rapid application development (before you have an api) and especially for the arrange step of testing. Speaking of testing... that's another area Vue is **terrible**. The commands I generated above? Should have created three different acceptance testing specs. The testing framework is already configured and working, assuming you have phantomjs installed. Simply running `ember test` will run those acceptance tests. At present they just have stubs to say the route loaded, but adding more functionality tests is easy. Anyway, I could go on for way too long. Best I don't do that. If you have more specific questions, feel free to ask. But don't just reflexively dismiss or evade. &gt; The only thing that is missing is the DI. In React you don't have DI, and I don't see any developers complaining about that. No one mentioned React. This is a comparison to Angular and Ember. The existence of React doesn't give Vue a free pass on criticism.
`querySelectorAll` and `querySelector` (which is like QSA, then picking the first element) are used to *find* nodes, more akin to `getElementById`, `getElementsByTagName`, `getElementsByName`, and `getElementsByClassName`; I can easily see `querySelectorAll` being much slower than `getElementById` at least. The methods `appendChild` and `insertBefore` are best used in conjunction with the `createElement` method, BTW.
ES6 classes are syntactic sugar. They are still prototypes. I don't get all the hoopla over how not using ES6 classes is bad; in fact, there are times where using the class sugar limits your expressiveness. Class syntax is useful in a lot of ways because it's simpler than doing something like Object.create, but it's not a big deal that this library doesn't use that stuff. And this is coming from someone who doesn't even use vue. I solely use react. There's a decent sized population of people who even prefer the React.createClass function over the ES6 class components. I personally prefer the class syntax when I need state/lifecycle methods, but then again, learning a tiny api isn't that bad, and I'm never going to use inheritance over composition in something like react anyways. 
I'm not following. It sounds like you're just describing basic inheritance. How is class Foo extends Bar {} different from what you are talking about? Foo will get all members of Bar that aren't explicitly redefined inside Foo itself. This is just basic inheritance.
`The trouble begins when someone must modify that dropdown to meet requirements for the new components he is building, and that change happens to be backward incompatible. ` It sounds like violating of open/closed principle. https://8thlight.com/blog/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html 
I'm not saying you were, but a few people obviously had. My question was in negatives. Seems back up now. For what it's worth, I'm not actually a React programmer. I don't like React much more than Vue, and for a lot of the same reasons. Both React and Vue follow a very similar pattern, a simple view binding library that can be extended. The differences between them really are syntax and implementation. It's that pattern I'm not a big fan of. That's why I said I prefer larger frameworks. If I wasn't using Ember (my preference by far) I'd be using Aurelia. If not that, Angular 2. I want an opinionated, productive, disciplined solution. I don't like messing around with build tools. I value testing and I very much like the productivity gains that come with CLI tools. These are all distinctly lacking in either Vue's architecture or its community. &gt; In general in this sub I wish people were more about sharing / learning rather than being right or proving someone else wrong. I couldn't agree more. I wish people were quicker to say "Oh, that's an interesting approach, sounds pretty cool." and less quick to try and counter things.
Can you go full Vue for a simple CRUD API app?
Absolutely, in general I think there's huge knowledge in this sub and it should be a great resource for learning and growing. But, these damn points make people act weird sometimes. As far as your other points go I'm actually the same way. Except I prefer react, and a large part of that is the community with the backing of Facebook. I simply don't have enough trust in Google to follow through with anything and to truly support anything long long term. 
Of course you can.
If only they could make the web inspector UI not complete ass too.
Visual studio code. It is a great text editor with lots of extensions and they have pretty good vim emulation. 
I think there's a misconception people have that Google is super invested in Angular. They're really not. Google actually has **a number** of frameworks they support, including Angular and Polymer. 
Codecombat.com teaches JavaScript. They have premium features but you don't need them to learn. 
Sounds cool. Likely your biggest challenge will be determining what movie a file represents. I am down to help if you are open sourcing it. 
Console.log shows up on your development console. In your browser, press f12 and select the console tab.
It's likely oauth. Take a look at implementing oauth with passport in this tutorial. https://scotch.io/tutorials/easy-node-authentication-setup-and-local oauth is a way of letting services act on a user's behalf for some other service. If you see buttons like login with Google or Facebook. That is oauth. Note however that not all services provide oauth. 
I will probably open source it. There is a python pip doing that exactly. https://github.com/guessit-io/guessit Would be more awesome to have this library in js
Sweet! Good enough for me. 
&gt; don't try to insinuate that people not using your framework du jour owe you an explanation, it's deeply insulting He's just trying to start a conversation, for fuck sake. Take a chill pill. You must be fun at parties, man.
Don't listen to this guy, Ill sell you JavaScript for only $10. ^^^/s
I really thought this was /r/programmerhumor
That's not the same thing though. I want to be able to react to that data from a different part of the app, not from a child component. DI is the best solution for this at present, and I honestly thing Vue made a big mistake not implementing this. Perhaps they were thinking it was then too close to Angular, but then they kind of have that label anyway with the templating system copy.
Totally agree. I hate build tools. That stuff isn't development to me, it's... paper work. I just want that shit to work, I don't care how. I didn't use Ember pre-1.0 but I definitely used it pre CLI, and it was. Good. It had a good pattern. I always liked its overall design pattern of routes, models and templates. It's not like any other js framework but it's a **lot** like the PHP framework (Laravel) I was using at the time. But CLI changed everything. I was a pretty early adopter, and a very resistant one. Early Ember CLI was pretty unstable and prone to breaking bugs. At the time I was using it, Ember Data was similarly beta. Was a rough time. But it didn't take long before it was amazing. At a time when Gulp was the default, being able to instantly set up a working, building, instantly auto-reloading web application was grounding. Webpack only recently started facilitating near that level of functionality.
Making your own polymere is fun and intersting. No need a big framework for that. Now, keep in mind that doesnt get well indexed. Dont use it yet on html part used in SEO.
I have begun to think of the apps I build as redux apps that happen to have a react view layer. I believe in isolating all side effects to the middleware layer (using redux-observables or redux-sagas), having only synchronous actions in app, and treating the routing like just another piece of data. As long a a view library has a few key properties, I should be able to plug anything in. I want a view layer that is primarily stateless—the only stateful things I want to handle in the component are things like animation ticks or temporary event handlers (click anywhere on the page to dismiss this modal type of thing). This allows me to reduce my testing burden to snapshots and build extremely composable components. I've been using react for a few years and, with the growing ecosystem around redux, feel like it is just now getting around to fulfilling its original motto "The V in MVC," so I'm not ready to jump ship just when things are starting to heat up, but I'm not primarily interested in react anymore (I'm just not willing to throw it off so casually because it has a load of work behind it and is finally starting to mature).
Thanks for your answer, you have some good points.
There are some really great plugins for Notepad++ (look them up via the integrated plugin manager or [install the plugin pack from Sourceforge](https://sourceforge.net/projects/npp-plugins/) (includes function list.The [NPP bookmarks](http://www.martinrinehart.com/frontend-engineering/engineers/tools/notepad-pp/bookmarks.html) can also be useful.
Cleaner code and features that make sense
&gt; Sublime, Atom are probably the most commonly used for JS. They are both free. Sublime is not free. Though you *can* use it without paying.
Find your browser's developer tools, open the console, and type in: `console.log('hello world');` You have Javascript, congratulations!
Because static analysis is pretty cool
I will respond in more depth later (I am on my phone) but the gist is that you run in to UI/UX and performance problems with non-native solutions. If the app is very simple, you don't care about native UX, or performance doesn't matter, learning and using a non-native framework is fine. To be fair, I have worked on projects like that before. Most, however, need the fluidity that comes from a native app to really work well.
This is absurd. View components are nothing more than view models. They SHOULD only need minimal object configuration. You can defer any and all additional business logic out to services which can be written however you choose. 
&gt; Single file components Nonsense. You can keep your JS, CSS, and templates in totally separate files, and then just import them to a 3-line .vue file.
Use notepad.
The cheat sheet is a good idea, but stretched typography is always ugly
Well given Vue has no ajax library, and data store, it's obvious to me that it's a view-model for building front-end components the same way react is. It's primarily a view library. 
'Solves Complex Problem' with an SPA. Lol. The *complex* problem of *how* to do this is being worked on by the Angular, Ember, React, Vue teams. These teams are dealing with the *intrinsic* issues of state management with JavaScript and http. You solve *complicated* problems by abstracting away state management. *Of course* you want a monolith. The difference is that your job is to please client/boss/designer/Satan by breaking the web. The problems you are solving are extrinsic to the language you are working in. So check your ego, and keep on building, but dont kid yourself that SPAs are solving anything *complex.* They are Just a band aid to give the end user something resembling a native app, and will be completed deprecated by WASM (hallelujah). Vue also fits much closer with the Unix philosophy (look it up) and lends itself better to *complex* problems because at its core it is just a component. That's why people like me prefer it.
There's no need to be a dick. 
Side note: https://redditcommentsearch.com/ is a pretty useful tool for searching past comments.
Hi /u/greyed-out, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your homework for you.
I mean isn't the same true of react-{{package}}, and redux? You can use them if you like, but the library itself is still generally considered and talked about as a view library. 
Are you using Chrome? Hit f12. Select the "console" tab in the window that pops up. Type "alert('Hello World')" and hit return. Congradulations, you just did your first javascript. Javascript files are just text files with a specific format and .js (or .html) ends on the names. A good text editor / IDE helps you format the syntax, but there's nothing to buy, and plenty of great tools to be had for free. I do javascript for a living and everything I use on my work computer is free.
Yes.
You can look for anything built on Three.js as it has canvas fallbacks
It seems like devs coming from Angular think Vue is worth trying. Most of the React folks seem very "meh" about it. I think this says more about Angular than Vue js.
I'd say that a 15 year old project with hundreds of thousands of lines of code isn't in a position to be considering introducing a **framework** to begin with. You build your app ontop of your framework, you don't shove a framework underneath an app that is old enough to have grandchildren. Or if we're talking about strictly ES6 and not these frameworks, then the point is roughly the same - why would you be considering shoehorning in ES6 style code into an app with &gt;100k lines of ES5 code? Of course that's a strange idea, build step or not. In other words, your app isn't the target audience for this discussion. 
I think Vue has added too many thing in an attempt to appeal to everyone. 2 way and 1 way data binding, writing components in a single file or spread them out, use Jsx or don't, use this style or that. The official docs and most of the examples use a certain style but there are other ways to do things too, and it can get confusing and the library loses focus. The appeal of Vue is unlike most of its competitors you don't need build steps or buy into a framework and you could possibly replace a few pages with Vue while keeping the rest of the app stack. I don't want to learn another DSL and in that regard Vue is not that desirable.
Disclaimer: my time with it was brief and in no way thorough. I did not get very far into using it but found it rather frustrating. In my attempt to get basic Facebook login working, I needed to open up XCode, install some dependencies, and modify the app config in unfamiliar ways. I don't mind doing this stuff, but I got the impression that I'd have to become very familiar with the traditional iOS dev and build processes. It left me wondering why I'd invest in this instead of just using Swift directly, which seems like a great language.
US ZIP Code, Canadian and UK postal codes, other countries as well. Maybe add support for IPv6 addresses and MAC addresses as well as IPv4. For dates, maybe dates in the future and past. Not a pure regex but definitely useful.
Number 1 thing you need to do: explain what it actually is. I can see it does something to do with deployment - but specifically what? Does it use FTP? SSH into a host and copy files? Set up a Docker image on the configured cluster and deploy some number of containers? Peel an orange? Also it'd be helpful to know what TWL stands for
You can make your first steps at [hackerrank.com](http://hackerrank.com) 
[deleted] ^^^^^^^^^^^^^^^^0.9641 &gt; [What is this?](https://pastebin.com/64GuVi2F/53069)
Imagine if every website was static and every interaction caused a page refresh. You can live in the world where an upvote costs more bandwidth than you have connection for. Or you can JavaScript.
Where abouts in the UK? There are quite a lot of local meet ups.
Start by making some, and we'll see what we can do. Note: vague condescension isn't actually an argument. 
You're correct. It's effectively free, but you'll be prompted to pay after ever few saves. I used it for months before paying. I'd recommend [Atom](https://atom.io/) which I use at work. It's simple and easy to use. It has the added bonus of being open source and built with JavaScript. Many people would not consider that a bonus, but as a full-time JavaScript developer I like that. It has a lot of great packages. Most importantly, it has a beautiful UI. Just don't open a large JSON file with it - although it's performance has improved a lot over the past year.
This is a big one for me. I feel it takes about half as long to mentally grep. Also, scoped CSS in a preprocessor lang of your choice. Template lang of your choice. Single file components combining them for smaller components. *Yes*.
Nice!!! I've only begun learning react recently and enjoyed taking a look at this. Thanks for sharing :)
I actually didn't have streaming media anywhere in mind while posting this. But it's definitely a good idea.
I play movies on my laptop all the time and connect it via HDMI to my TV. This is what actually brought the idea to my mind. But of course streaming can be a killer feature
He is still right, that vendor locking on a text editor literally makes no sense, though. As long as the files i am editing are not in a propriatory format Microsoft cant really do anything.
You mean other people won't be able to upvote me to the moon because they don't have the bandwidth?
Actually yes. Just the vue-router is worth giving Vue a try.
Oh wow, that's really cool, I thought I had to buy Javascript because I was trying p5js because I saw Daniel Shiffman use it and it looked great, but it came up with an error so I assumed that I needed Javascript. Thanks!
That makes a lot more sense, thanks for the help!
And I am still using browserify instead of webpack. But is hard, feels like I am wrong. I didn't feel that way when everybody was using vanilla JS or jQuery
Ok thank you, this makes more sense than what I previously thought.
The only functionality that we will have to support that can't be done without native code is ABR music streaming. We already have native solutions for that and the plan is to wrap them up, write a JS bridge and open source them. I looked for community solutions but nothing is good enough for me to use in production. Other than that we have relatively simple requirements. We need 2 dozen or so views, a few forms, users accounts and so on. I am a little worried about the network layer, I'm not sure how well the few RN libraries that are available perform. I would assume requests get handed off to a good native solution that will queue them up based on priority, but if not I can tackle that too. The main thing we are looking to improve is the speed of development and the ability to push code without a full app update. RN definitely has advantages in those categories. We are willing to sacrifice performance to a degree.
It was mainly because I downloaded p5.js and wanted to use it because Daniel Shiffman used it, and when I tried to use it, it came up with an error so I assumed that I needed Javascript to run it, it came up with the same error whenever I saved something as a .js file and tried to open it.
It was mainly because I downloaded p5.js and wanted to use it because Daniel Shiffman used it, and when I tried to use it, it came up with an error so I assumed that I needed Javascript to run it, it came up with the same error whenever I saved something as a .js file and tried to open it.
Javascript is primarily run in two environments: a browser, or node.js. I don't know what p5 is, but I'd bet it's meant to be run in a web page or in node.
We were all here once. You have a lot to learn, young grasshopper. 
Thanks for the help
YES! You need so little to start a new app
Notepadd ++ isn't bad. It should recognize .js files You can't "run" a javascript file because they don't execute. As the name implies, they are scripts - in this case, scripts that a browser executes. (This isn't 100% true, because there's something called node that actually does execute javascript like a program, but ... well, that's beyond my paygrade.) You need to have a web page that references the script file or includes the script directly (both done via the HTML &lt;script&gt; tag). Alternatively some sites out there allow you to type javascript into a text box and execute it, is great for learning - [jsfiddle](https://jsfiddle.net) is the best I know of. Lots of tutorials include links to such pages, already pre-populated with code, and you can save your own as well. Its also nice because it allows you to include external resources (helper libraries) without having to reference the files etc. I sometimes use it to share simple projects [like this one](https://jsfiddle.net/sebwiers/yh8stou3/) 
Ok thank you
np man, good luck.
Actually you _could_ build the upvote feature without javascript or (visible) page refreshes with just html. I'm thinking a hidden frame for the upvote refresh, and a target link. 
Why use a DI container when you have a nicer store-based pattern in Vuex?
&gt; The complex problem of how to do this is being worked on by the Angular, Ember, React, Vue teams. These teams are dealing with the intrinsic issues of state management with JavaScript and http. So, you could almost say that one is "solving complex problems with a SPA"... &gt; They are Just a band aid to give the end user something resembling a native app, and will be completed deprecated by WASM (hallelujah). In how many years? And even then you'll have tons of frameworks and mindshare occupied by JS that I'm not even convinced that WASM -- at least in it's initial/early form -- is going to spell the death of the SPA. Are you going to rewrite Angular in C++ once WASM can access garbage collected (DOM) objects? Or are you going to wait until they role out support for Python etc first? WASM isn't being built so you can can rewrite client side framework X in your favorite language... it's for incorporating native libraries in your web app -- game engines etc. 
Maybe I'm misunderstanding your code setup based on the way you've pasted it here, but there's a couple of problems. Let's trace it down from the point of error. In the render function you are doing this: ` var listItems = this.props.items.map(...)` So we know that items has to be passed down as props. You have a `getInitialState` in this component that sets items as an empty array, but you are never using, or modifying that, so there might be some confusion there on your part. Anyway, in the ReactDOM.render, you *are* passing the `items` variable in as a prop. The problem is that by that point, `items` is still undefined, because that's what you left it at in line 1. `$.get` is obviously asynchronous, but ReactDOM.render doesn't wait for that, so it's happily passing undefined down to RepeatModule, which is where your error is coming from. Another point where you seem to be confused is line 4, where you are setting `this.state.items = data`. `this` would probably refer to some jQuery context there, so I'm not sure what you're expecting `this.state.items` to be. It's certainly not the React component. But if it was the React component, setting `this.state.items` directly is the wrong approach, because React wouldn't be notified of the change. You should use the `this.setState()` function for that. --- Anyway, so that's the problems. The solution is to handle the data fetching *inside* of the React component (you can use the componentWillMount hook for this), and conditionally render based on whether or not the data has arrived. I will write this in pseudocode, so you can try to implement it yourself: RepeatModule class: getInitialState: items: [] componentWillMount: get products, then: use this.setState() to update the React state (make sure you use the correct `this`, because in the $.get callback, it will no longer be the React component) render: is items an empty array? render a loading message else map through items and render them
What problem does Vue solve that other frameworks don't already?
NP. The program I use for development at work is NetBeans, which is a fairly old IDE. Basically just a beefed up version of Notepad++ (shows you the file structure, lets you search multiple files, etc). Sublime is also very popular (similar features, plus a zoomed out view of the file that some folks like). Both are free. But really, notepad ++ is GREAT until you get to the point where you are doing multiple files with 1000+ lines. I still use it for banging up quick, short files &amp; text snippets, and have it on my computer at work. I hope you weren't put off by some other smartass responses. I still remember when I was first learning Javascript, I think it was only 10 years ago or so. The first steps were, by far, the hardest. Once you figure out the context for working with it, the things you read will make more sense, and you will be able to ask questions that are more on point. Its also worth noting that a huge portion of what people use javascript for is to control site interactions with items inside the browser (IE, when you click one thing, new information is sent / downloaded). That's not going to make much sense at first unless you already understand how a web server works. Find a book or tutorial that digs down to the basic of the language. What you really need to know about are syntax (how to write it), logic (loops and branching) and variable types (arrays, strings, integers, floats, nulls). Javascript is a bit tricky (but also easy) in that last regard because it is "loosely typed", meaning if you perform an operation on a variable that doesn't make sense for what is stored in the variable, it will change the "type" to something that does make sense in that context.
Was hoping the package description would be sufficient. Basicly it starts up a webserver on the server you want to deploy to, and then from the client side makes a curl with the files you want to deploy. Uses a token to verify the request.
Thanks, ill look into that :)
Yeah so you should explain that in the readme. Instinctively though, that sounds very likely to be vulnerable to remote code execution exploits. 
If you've got a few spare bucks kicking around, [SublimeText](https://www.sublimetext.com/) is a great investment. Hell, even the evaluation version is fully featured. And -- what's not fully supported is more than taken care of by the community's excellent plugins.
Also. Nice docs.
I'm not sure what libraries you're talking about. I haven't really seen any libraries that re-implement Promise.all and Promise.race except for polyfills.
:/ The marginal benefit of a library such as yours is low when Promise.race and Promise.all work fine for most people. I'm sure your library is great for some things but mods of the helper functions are... meh
Ok, well the first thing is that I forgot you can't even put properties on the prototype with class syntax, which is its own limitation. They want you to do getters and setters. So my example isn't the best. What I was thinking was this (invalid) syntax: class Foo { items: ['a', 'b'], } class Bar extends Foo { items: ['b', 'c'], } let b = new Bar(); console.log(b.items) // --&gt; ['c', 'd'] (In valid ES6, you'd actually have to do that by modifying the Foo and Bar prototypes directly to add the 'items' array) With a custom class system, you could do something like this: let Foo = Obj.extend({ items: ['a', 'b'], }) let Bar = Foo.extend({ items: Obj.inherit(['c', 'd']), }) let b = new Bar(); console.log(b.items) // --&gt; ['a', 'b', 'c', 'd'] To do this, you'd basically have the `Obj.inherit` static method wrap your value, so that `extend` will know to concat it onto the parent class's array. Like I said, this turned out not to be a great example. I haven't been using ES6 classes a whole lot lately, so I forgot that accessors were the only way to directly add non-function members to the prototype. That situation still makes it clunky to do this kind of property-merging inheritance, which is super helpful in some cases, like if your views have an `events` hash, like in Backbone, and you want subclasses to inherit the parent's event handlers.
I. Just. Learned. React.
But kodi is a very heavy app and it targets TV UI. What I am proposing is a much lighter weight kind of app customized for the notebook / desktop experience. 
I've been using the alpha version of Choo v4.0.0 on a couple projects at work for about month now and it's awesome to see 4 get merged into the master branch! I highly recommend it as framework that handles views, routes, and state but without being needlessly complex. 
Really good. 2 production level apps and never hit any problem in Android vs Iphone wrt performance.
Basically anything P2P. Webtorrent, hypercore, dat, ssb, and such projects are making strides to make building P2P applications easier, but the whole ecosystem is so new we still don't really have a good idea of how to go about building P2P web apps. Imagine that when I hit `save` on this comment, rather than it being sent to a server, with authentication and all that, the response was set directly to you and other clients. Sounds simple, but there are so many edge cases we haven't completely fixed yet.
The template is just html, since it is not interpreted as Javascript, it doesn't do the string interpolation. You'd either have to use eval, Function, or a third party library. You could use Function like this. var template = $("#x").content() var computedTemplate = new Function('name', 'return `' + template + '`')(name) It's kind of hacky though
Im not sure what p5js js, maybe you have to buy/download that. You need to tell us what error you're getting. 
don't worry bro. browserify is for enlightened people. just like gulp &gt; grunt
If I don't use componentsWillMount, can something like this work? The simplest solution here is to only render the component once AJAX request has finished. But for some reason, the items won't display. var RepeatModule = React.createClass({ render: function() { var listItems = this.props.items.map(function(item) { return ( &lt;div className='brick'&gt; &lt;div&gt; &lt;a target='_blank' href={item.productURL}&gt;&lt;img src={item.imageURL}/&gt;&lt;/a&gt; &lt;p className='itemName'&gt;Short Sleeve Oxford Dress Shirt, White, Large&lt;/p&gt; &lt;p className='storeName'&gt;Nike Factory Store&lt;/p&gt; &lt;img className='foundPicture' src='../images/rohit.png'/&gt; &lt;/div&gt; &lt;/div&gt; ); }); return ( &lt;div&gt; {listItems} &lt;/div&gt; ); } }); $.get("http://localhost:3000/getProducts", function( data ) { ReactDOM.render(&lt;RepeatModule items={data} /&gt;, document.getElementById('clothing-content')); }); 
No, you don't. p5 is supposed to run in the browser. You don have to download anything. Be sure to learn HTML first.
A lot of people favor composition over inheritance because it allows you to share functionality across objects without having to maintain complex taxonomies. This reduces overhead and improves maintainability. See the Gorilla/Banana problem. &gt; “The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong
Thanks! 
&gt; If I don't use componentsWillMount, can something like this work? Why wouldn't you use componentsWillMount it is baked into the component lifecycle ? But as Magixxxx pointed out, you seem to have `state` and `props` mixed up. 
What I love about Vue is it lets me use browserify and still get the nice .vue syntax through vueify. 
I can only shrug; that's how I felt, a little, about React being popular this entire time. People can use what they decide to use and talk about using it. 
[Ractive](http://www.ractivejs.org/), which doesn't appear on this list, has been my secret weapon this year, and I've been profoundly grateful for discovering it. I don't have time or resources to learning a huge toolchain - front end programming is only part of my job; and yet I've been able to produce a number of highly interactive client-side tools in the last couple of months with it.
1. If you are passing props and you have no other way you can set state using the following: getInitialState: function() { return { items: this.props.items } }, see: https://zhenyong.github.io/react/tips/props-in-getInitialState-as-anti-pattern.html 2. Also `this.state.items = data;` should be `this.setState({ items : data });`, you should call `setState` as it manages the state for you and calls `render()`. 3. Then change `this.props.items.map(function(item)` to `this.state.items.map(function(item)` 4. Props are immutable, and state is mutable. 5. Remember that React Passes data forward. 
well obviously he cant predict the future, hes just looking at today to make his decision. For all we know there will be some shit called Best.js (theres propablly something called that already) tomorrow that will beat all of them in 6 months.
There are also good text editors and IDEs that don't cost money.
Hmm I am using grunt hahaha
Why is the whole page shaking?
I think the problem is there were and are people that think inheritance is the end all. It's useful when it's the right tool for the job. But I recall a lot of people pushing it like it could solve any problem. That's not true of anything.
My point is that this isn't even a guide to today. For instance, you can't simultaneously be seemingly unaware of the incredible advances in Virtual DOM tech that have happened this year and also pretend to provide a comprehensive statement on JavaScript in 2017. 
but thats not adopted enough to judge today.
Netbeans or Sublime
Not a terrible idea -- throw a frame around each comment I guess?
I don't think you're wrong about the "You can add that!" counterargument and its weakness. However, if you have as part of your goal to avoid ecosystem lock-in, which Ember suffers terribly from, this is a feature, not a bug. Vue.js is a lot closer to "it's just javascript!" when it comes to writing components and when it comes to interfacing with third party libraries. I look at almost any CLI I've tried out (and I've tried out a lot, from Angular 2 to Aurelia to preact, I think) and react extremely negatively. The examples you're listing demonstrate so much Ember-specific knowledge and they aren't any better than, I dunno, coding my Router in Javascript and using Browserify. I just look at all of these CLIs and say "Why would I _need_ that?" There are also those of us for whom Ember's performance on mobile is unacceptable, which is something that is never, ever going to get better (guess what just recently crossed 60k lines of code?). But I'm doing the opposite of preaching to the choir when I touch that point. I'll just say that there are those for whom Ember is a workable solution, and those for whom it is definitely not. And testing in Vue is still a big question-mark for me, too. 
"ISA" sounds like an abbreviation, but I think you mean "is-a"
Source http://siliconangle.com/blog/2013/04/01/the-birth-of-node-where-did-it-come-from-creator-ryan-dahl-shares-the-history/
Indeed, and most likely you'll do fine with the free ones. DAE remember when BBEdit was the go-to Web-oriented text-editor on the Mac? (It's not free.)
I understand that you think my distinction between complex and complicated is pedantic but read up on the latin roots 'plex' and 'plic' and get back to me. Once WASM has dom bindings you will see gui/ux libraries popping up that will overtake the current frameworks. We are building 'Single Page Applications' on the *Web* ... a platform that is inherently multipage ... because what we really want is a write once, run anywhere application that has native graphics access and can be loaded through a just url (not downloaded and installed). I'd wager that in five years you will start to see the SPA being deprecated.
I've personally never been a fan of that quote. First, it sounds like a strawman to me. "A gorilla holding the banana and the entire jungle" sounds like a symptom of a [god object](https://en.wikipedia.org/wiki/God_object), which is a well known bad practice. Imagine if we deliberately wrote bad functional code, then used that bad code as an example why functional programming is terrible. That's what this banana example is doing. And second, the Armstrong quote continues... &gt; If you have referentially transparent code, if you have pure functions—all the data comes in its input arguments and everything goes out and leaves no state behind—it's incredibly reusable. But we can write code that is *both* object oriented *and* referentially transparent. And it's as simple as not mutating the arguments -- including "this". Rather than mutating the "this" object, we would instead make and return a new object. For example... const a = [1, 2, 3, 4, 5]; const a2 = a.slice(1, -1); // referentially transparent // we could skip the call and replace the expression with `[2, 3, 4]` We can be pure and referentially transparent -- or not -- regardless of whether we're object oriented or not.
ISA is a common term for that relationship in data structures and AI courses in my experience.
Agreed. It does seem like a straw man to me as well. The only time I've ever ran into problems like this was before PHP had autoloading. You would have to `require` the file the class lived in, in order to instantiate it. But then that class might new up another class, but didn't require the file, so now you had to require the file in the same place you required the top level class, and so-on and so-forth. But now with autoloading, everything just works. Even better now that people understand what dependency injection is, and you rarely ever encounter issues with `new &lt;ClassName&gt;` inside of another class. So the Gorilla/Banana problem was applicable ~10 years ago in the PHP community, but not anymore. It's definitely a strawman argument.
An easy one to watch is Inferno. Read through some of its motivations and accomplishments. https://github.com/trueadm/inferno I'm not saying that Inferno is something everyone should learn, and I'm _definitely_ not saying Inferno is something everyone needs. For most basic purposes Angular or React will do what you need them to do to get an app out the door. But it's definitely something to know about, if you use React and ever expect mobile performance to be a need. 
Given what you said about states is this a bad React example? var RepeatModule = React.createClass({ getInitialState: function() { return { items: this.props.items } }, render: function() { var listItems = this.state.items.map(function(item) { return ( &lt;div className='brick'&gt; &lt;div&gt; &lt;a target='_blank' href={item.productURL}&gt;&lt;img src={item.imageURL}/&gt;&lt;/a&gt; &lt;p className='itemName'&gt;Short Sleeve Oxford Dress Shirt, White, Large&lt;/p&gt; &lt;p className='storeName'&gt;Nike Factory Store&lt;/p&gt; &lt;img className='foundPicture' src='../images/rohit.png'/&gt; &lt;/div&gt; &lt;/div&gt; ); }); return ( &lt;div&gt; {listItems} &lt;/div&gt; ); } }); $.get("http://localhost:3000/getProducts", function( data ) { ReactDOM.render(&lt;RepeatModule items={data} /&gt;, this.setState({ items : data }), document.getElementById('clothing-content')); });
But how much does it cost?
/r/madlads
Can you describe how multiple inheritance differ from composition? 
This is is the realest thing ever said. Fan of both React and Vue myself, not so much of Angular though and that's completely fine. 
 var RepeatModule = React.createClass({ getInitialState: function() { return { items: this.props.items || [] } }, componentWillMount: function() { $.get("http://localhost:3000/getProducts", function( data ) { this.setState({ items : data }) }); }, render: function() { var listItems = this.state.items.map(function(item) { return ( &lt;ListItem item={item}/&gt; ); }); return ( &lt;div&gt; {listItems} &lt;/div&gt; ); } }); /* make the items stateless */ var ListItem = function(props) { return ( &lt;div className='brick' key={props.item._id}&gt; &lt;div&gt; &lt;a target='_blank' href={props.item.productURL}&gt;&lt;img src={props.item.imageURL}/&gt;&lt;/a&gt; &lt;p className='itemName'&gt;Short Sleeve Oxford Dress Shirt, White, Large&lt;/p&gt; &lt;p className='storeName'&gt;Nike Factory Store&lt;/p&gt; &lt;img className='foundPicture' src='../images/rohit.png'/&gt; &lt;/div&gt; &lt;/div&gt; ); } ReactDOM.render(&lt;RepeatModule items={data} /&gt;, document.getElementById('clothing-content')); I think that is a better way to write it, Can you explain why you cannot use `componentWillMount()` ?
An interesting thing for inheritance with JavaScript: the longer the prototype chain, the more inefficient property lookups are, since possibly the entire prototype chain has to be traversed. So if you have a complex inheritance setup, simply doing foo.bar can be really inefficient, particularly if bar is not actually a property of foo (i.e. going all the way until a null prototype). Edit: MDN link for reference https://developer.mozilla.org/en/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#Performance
I have a couple older replies [here](https://www.reddit.com/r/programming/comments/5dxq6i/composition_over_inheritance/da8bplv/) and [here](https://www.reddit.com/r/programming/comments/5dxq6i/composition_over_inheritance/da8ea5v/) about that.
Favoring composition over inheritance has been known to be the preferred method of OOP for a long time, at least as long ago as 1994. https://en.m.wikipedia.org/wiki/Composition_over_inheritance My theory is that computer science instructors teach inheritance as the important, standard-operating-procedure of OOP, when, in fact, it should have been taught as an advanced, last-ditch solution to edge cases. The students never questioned it, and therefore, never saught out alternate patterns. Usability through familiarity. JS, in particular, while it appears to be like Java superficially (by design), it fundamentally operates a different way than traditional OOP languages. When the community collectively realized this, they saught out native patterns, which tend toward functional style anyway. As for me, one who has used lots of languages, from Scheme, to Perl, to C++, to Basic, to C#, to Java, to PHP, I had to unlearn my training through immense struggles to finally recognize that inheritance is almost never worth it (in any language), even in languages that are designed for traditional inheritance (aka, not Javascript).
Not knowing PHP's implantation of traits but having worked with a Perl implantation of the original concept for ... nearly a decade now ... traits don't work like that. You should get compile time errors if you've composed two traits that are incompatible but haven't manually implemented the colliding methods. This is actually the biggest difference between traits and multiple inheritance, the rules of composition are more explicit with traits and are resolved at composition time rather than during method dispatch. Inheritance typically resolves at method dispatch time (often the first time the method is called even if it is subsequently cached after that).
A car IS A vehicle. A horse IS A vehicle. A submarine IS A vehicle. A helicopter IS A vehicle. An Infinite Improbability Drive Ship IS A vehicle. The planet Earth IS A vehicle. What meaningful thing can be said about all of these, without inappropriately attributing aspects incorrectly?
to clarify would it be the following? var RepeatModule = React.createClass({ getInitialState: function() { return { items: this.props.items || [] } }, componentWillMount: function() { $.get("http://localhost:3000/getProducts", function( data ) { this.setState({ items : data }) }); }, render: function() { var listItems = this.state.items.map(function(item) { return ( &lt;ListItem item={item}/&gt; ); }); return ( &lt;div&gt; {listItems} &lt;/div&gt; ); } }); /* make the items stateless */ var ListItem = function(props) { return ( &lt;div className='brick' key={props.item._id}&gt; &lt;div&gt; &lt;a target='_blank' href={props.item.productURL}&gt;&lt;img src={props.item.imageURL}/&gt;&lt;/a&gt; &lt;p className='itemName'&gt;Short Sleeve Oxford Dress Shirt, White, Large&lt;/p&gt; &lt;p className='storeName'&gt;Nike Factory Store&lt;/p&gt; &lt;img className='foundPicture' src='../images/rohit.png'/&gt; &lt;/div&gt; &lt;/div&gt; ); } var data = [] ReactDOM.render(&lt;RepeatModule items={data} /&gt;, document.getElementById('clothing-content')); Because for some reason, I'm still getting nothing to show up. And I double-checked my endpoints they look good.
Although I agree, I think everything he recommends to learn is valuable, even fp. The reason Angular and React are suggested is that they are listed everywhere on job descriptions. Knowing at least one framework is going to help you get a job, and prove you are able to learn and use them, but knowing one that the employer is using is going to be more appealing to them. I'm still not sold on Aurelia, I love the ember style everything is included, but I don't think I'll ever like the js in html props, like `repeat="item of items"`.
IS-A needs to be applied *behaviorally*, not conceptually. For example, conceptually a square is a rectangle, but behaviorally a square does not *behave* like a rectangle, and so fails the IS-A test. Check out the [Liskov Substitution Principle](https://web.archive.org/web/20151128004108/http://www.objectmentor.com/resources/articles/lsp.pdf) (which is the "L" in [SOLID](https://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)))
I am going to use you are using chrome or something similar, with dev tools. 1. Are you seeing the ajax request happen, and what is the response ? 2. Are there any errors ?
I'm getting this warning that's prolly insignificant. `Fetching scripts with an invalid type/language attributes is deprecated and will be removed in M56, around January 2017. See https://www.chromestatus.com/features/5760718284521472 for more details.` This is what I receive from my GET request in my console. [ { _id: 584d1e36a609b545b37611ac, imageURL: 'http://ih1.redbubble.net/image.252113981.3904/ra,unisex_tshirt,x1350,fafafa:ca443f4786,front-c,30,60,940,730-bg,f8f8f8.u2.jpg', productName: 'Drake', productType: 'T-Shirts &amp; Hoodies', price: '$29.97', productURL: 'http://www.redbubble.com/people/misfitapparel/works/22923904-drake?grid_pos=6&amp;p=t-shirt', __v: 0 }, { _id: 584dcbfa8d608c5677d7f3a8, imageURL: 'http://ih1.redbubble.net/image.294108699.8379/ra,triblend_tee,x1350,navy_triblend,front-c,30,60,940,730-bg,f8f8f8.2u3.jpg', productName: 'Pizza is LIFE', productType: 'Tri-blend T-Shirts', price: '$25.79', productURL: 'http://www.redbubble.com/people/laurenramer/works/22528379-pizza-is-life?grid_pos=31&amp;p=triblend-tee&amp;ref=shop_grid', __v: 0 } ] However, I'm not able to console.log(data) and see anything. EDIT: For full context this is my getProducts endpoint. router.get('/getProducts', function(req, res, next) { // get all the products var productResults; Product.find({}, function(err, products) { if (err) throw err; // object of all the products var productResults = products; console.log(products, "printing all the products"); }); res.json(productResults); });
&gt; this is likely because the sort of people that like Vue are a lot less interested in a CLI. Bit of cause and effect there, though. I've seen Vue users dismiss CLI tools because scaffolding is only done once. IMO the CLI tool offered by Ember is truly and objectively useful. Functionality would be useful in vue, too. It doesn't have to be comprehensive. `vue make component my-component` to make boilerplate, etc. There is value there, I would think. At the moment the only option is a scaffold and even that requires deciding what build tool and and what version of the build tool is to be used, in advance. &gt; One of the things I really admire about Ember is its consistent intake of external innovation. Yeah, I agree. The DBMonster demo from React was embarrassing for Ember, and it forced them to redo their entire render layer. They've often taken approaches from other frameworks and technologies, and I think that's a great thing. It's smarter than getting all huffy and saying your approach is better no matter what. &gt; The concern is the massive performance penalty in parsing that much freaking code; I don't know if it's clear just how incredibly huge Ember appears to those outside your worldview. No, it is. It's huge. No one is disputing that. There **is** some dispute about how much it matters. For example, people are happy to download a 40 meg native iphone app... viewed as an alternative to that, Ember looks positively trim. :) It really does make a huge difference on mobile though, especially. Developing progressive apps includes developing for reduced (or expensive) mobile bandwidth. File size matters. Most particularly, file size drastically affects time to first-post. Something Ember is particularly dire at, and which will not be helped at all by Glimmer 2. Or not significantly. It does make templates significantly smaller, so apps with a lot of templates will shrink notably. Point I was trying to make before though is that the RFC about modules is largely dedicated to this question of size, and shows that it's being worked on, and at a high level. There is a fair bit to go, but it is an area of active development and improvement.
&gt; componentWillMount: function() { &gt; console.log("componentWillMount()") &gt; $.get("http://localhost:3000/getProducts", function( data ) { &gt; this.setState({ items : data }) &gt; }).fail(function(err) { &gt; console.log(err) &gt; }) &gt; }, So it looks like it's being called, but not able to get the data componentWillMount() clothes.js:11 Object {readyState: 4, responseText: "", status: 200, statusText: "OK"}
How so? I hated using Angular's DI, it was clunky and hard to test. 
I will start by saying, I applaud Eric for highlighting the need to learn the core language, I'm not sure I can totally back his list. I don't love that he suggests using lodash/fp when it was clearly a reaction (and a rather hasty one at that) to libraries like Ramda and JFP which are actually providing simple, well thought out functional alternatives to the stateful behaviors built into lodash. Moreover, these alternative libraries speak directly to Javascript's Scheme heritage. Functional programming is capturing a lot of mindshare which is evidenced in languages like Purescript, Clojurescript and Elm, which represent solutions in language analogs to Haskell, Lisp and ML respectively. Although these languages are rather fringe technology, they are really important players in the changing landscape. Typescript is the weakest and, possibly, smallest real change to the alt-JS landscape and it is important in the same way that Objective-C is in mobile devices -- one influential company standardized on it. In the end, if you are looking for a job today, and you already know these technologies, this list is for you. If you are just getting started, some of this guidance may actually put you behind. 
A relative distance (x, y, z) distance from the sun, perhaps? It all depends on why you are defining a vehicle and why a car and earth is viewed as a vehicle in the program.
&gt; router.get('/getProducts', function(req, res, next) { &gt; Product.find({}, function(err, products) { &gt; if (err) throw err; &gt; // object of all the products &gt; var productResults = products; &gt; console.log(products, "printing all the products"); &gt; res.json(productResults); &gt; }); &gt; }); I just figured that out, haha now we're onto something... Looks like it says Uncaught TypeError: this.setState is not a function re: looks we have to bind http://stackoverflow.com/questions/31045716/react-this-setstate-is-not-a-function
silly mistake on my end about the productResults!
it happens to all of us :)
If you buy it from me, I'll throw in "the internet" as well
Sure, but that's my point. A horse can have legs, a car can have tires, a planet can have gravity, etc, without interfering with any of the other things, even in principle. Likewise, if they do truly share something (a relative xyz position or a maximum speed in mph), they can HAVE A position or speed as well, rather than inheriting it from some vehicle base class. Where is the advantage gained by using inheritance?
Some good answers here so I won't repeat, but I'll add in that after using Swift and C# (via. Unity) a bit, I'm really liking single inheritance + interfaces. It makes the inheritance tree very simple. And when the analogy of classes and objects stops working, I don't try to force it, I just say that certain classes also implement other behaviours. Since I'm not explicitly inheriting those behaviours (I'm reimplementing them for each class), I don't incur weird dependencies or the inheritance of wrong things. Reimplementing doesn't mean I have to write the same code twice. Maybe my Dog.move() and Car.move() uses many of the same functions. If I used multiple inheritance, I would end up with both getting move() explicitly, and then I have some frustration when I want dogs and cars to move in different ways. 
&gt; Looks like it says Uncaught TypeError: this.setState is not a function &gt; Haha I still have a lot to learn about React. Thanks so much for the help! I really appreciate it. What do you do? 
On the flip side, the React team is currently making good progress on the "React Fiber" internal rewrite, which promises to unlock the ability to make some major improvements in the framework.
That's basically the Class Properties syntax, which is currently a Stage 2 proposal. It's already being used by the React community with a Babel plugin, as it enables things like defining a component's initial state without needing a constructor, and creating callback methods using arrow syntax that are already bound to the component instance.
Great point. Do you mind elaborating on what you mean when you say `when the analogy of classes and objects stops working,`. Does that mean when code bases grows you lose sight of the design you had in mind (or that it deviated greatly from the original design)?
Or Instruction Set/(or Standard) Architecture
&gt; JS did not make it easy to use inheritance. It uses a different model than Java and the like *prototype* vs *class*
Inheritance works really well when there's an analogy you can keep in your mind. Ie. "y IS AN x". "Dog is an animal." "Car is a vehicle." When that starts breaking down, it's a sign that inheritance is only going to cause you trouble perceiving of what these classes are. One reason classical inheritance is powerful is because it allows you to minimize the mental load on understanding what classes are and do. My PolygonSerializer is a GeometrySerializer so I know it accepts GeoJSON as an input. Without digging into code, my PointSerializer that's a GeometrySerializer must behave very much the same! I have to start doing mental gymnastics if I were to get clever and implement PolygonSerializer as an AreaSerializer too. Because later I get clever and make a CircleSerializer that is a PointSerializer that can also calculate Area... uh oh.. my class analogies break down. Maybe I should have just added a CalculateArea interface to my PolygonSerializer and CircleSerializer.
New article: Why we chose Vue.js over React http://pixeljets.com/blog/why-we-chose-vuejs-over-react Git lab opinion: https://about.gitlab.com/2016/10/20/why-we-chose-vue/ 
I understand the arguments for composition over inheritence, however, I find that any time ever mentions the gorilla-and-banana argument I can almost guarantee that the following example of bad inheritance will be a deliberately wrong use of inheritance. The problem is that developers love a cargo-cult, I mean, I'd love it too if it meant I get sent all over the world to speak at conferences all expenses paid. The problem is, we stop looking at things practically and just see tools or processes in a black-and-white good/bad manner.
I use classes for their terser syntax only, they do give you an easy way to do inheritance but I'd use that very carefully.
&gt; First, it sounds like a strawman to me. "A gorilla holding the banana and the entire jungle" sounds like a symptom of a god object, which is a well known bad practice. It's not a strawman, it's actually very common in object oriented codebases and I wouldn't even say it's bad design. Rather than being a symptom of a God object it's actually necessary to prevent God objects from occurring. The problem he's pointing out is when you have dependencies that point inward instead of outward. The Banana object needs a Gorilla object (so that when you have a Banana object you can call `banana.getHolder()` and get back the Gorilla holding it) and you have a Gorilla object that needs a Jungle (so that when you have a Gorilla object you can call `gorilla.getJungle()` and get back the jungle it occupies). However this now means that you can't just have a Banana object in isolation (e.g. for a test) because every Banana now needs to be hooked up to a Gorilla and every Gorilla needs to be hooked up to a Jungle. In a game this might manifest as an `Aura` object that contains a reference to the `Unit` it's applied to, and that `Unit` object contains a reference to the `World` it's in. But what's the alternative? If we only allow references to point outward, that means that Aura cannot have a reference to Unit and Unit cannot have a reference to World, ergo Aura has no way to affect the Unit it's applied to, and the Unit has no way to affect anything else in the World at all. This means that behaviors must be pushed up the tree, causing the inner classes to grow and take on concerns that should be further out, making God classes *necessary* for the program to work, not preventing them. If your Gorilla doesn't have a reference to the Jungle that means the Jungle now has to deal with gorilla behaviors that are outside the scope of a single gorilla, bloating the Jungle class and turning it into a God object. [This video discusses the problem in detail along with the original conception of OOP](https://youtu.be/QM1iUe6IofM?t=18m8s) and I'd encourage you to watch it if you haven't even though the title might put you off if you're a fan of OOP.
I must admit that I'm waiting for more people to adopt Aurelia, before giving it another shot. JS frameworks are often short-lived, and I have to keep supporting most of my apps. I *do* like Aurelia, though.
No, you shouldn't be using ReactDOM.render inside of componentWillMount. cwu already automatically updates React when the state changes. Honestly I'd recommend reading some React basics, and maybe even some async javascript basics before proceeding. There's large gaps in your knowledge that will make it very hard for you to do anything properly here. Even if you stumble into a solution, you will not understand it properly and it won't be helpful in the long run. You've also ignored my comment about `this` referring to the wrong object in the $.get callback. Your componentWillMount should look like this: componentWillMount: function() { var self = this; $.get("http://localhost:3000/getProducts", function( data ) { self.setState({ items : data }), }); },
With MI, specifically with interfaces, things are a lot clearer - both in your intent in the code, and to tools like your IDE. The typical problem with MI is the diamond problem - i.e. what do you do when you inherit from 2 classes who have a shared base class - which methods on the class does it resolve to? This is one of the reasons its not supported in many languages. With interfaces, e.g. public class Panda: IAnimal, ICute its clear to humans and tools than a panda is a cute animal. But if you do - public class Panda { private IAnimal _animal; private ICute _cute; } then its a lot less obvious. Now, the first way is also a common way to implement composition in languages which support it, and another term for this is mix-in, so it technically isn't MI. Prototypes in JS are kind of a cover all since you extend them as much as you want as long as you don't have name conflicts. But if you simply point an objects prototype to another its just single inheritance, and you can follow that chain all the way up tp Object. In the end I believe this isn't so much about what's better but being aware of the tradeoffs. MI is considered less flexible because it places more constraints, while composition allows you to mix things more freely.
To me at least an ‘open with [app]’ would be great because it decouples the library from the streaming software (of which there are an infinite amount of options). Additionally feeding the app a subtitle file would be the sugar on top. 
VueJS alone is not a complete application framework, it's a library that allows you to write reactive view components. If you want to build a SPA you might want more than that, for that vue provides optional components you can choose to use, but you are free to use a different router for example Also I don't know about Ember but Vue does not dictate which language you have to use, because it assumes that is the responsablity of the loader, e.g. webpack. Though of course it works best with ES6, because Vue is also written in it.
thanks for the assistance. I took a look at using interval .every and a few other methods in the D3. JS documentation before someone presented the right answer by using invert() to populate the array. You can see here http://stackoverflow.com/questions/41085866/returning-an-array-equally-spaced-between-two-given-times-with-a-given-variable/41085944#41085944 
We worked hard to get it released. I think we will add more nice stuff in future.
i have never heard this abbreviation in my classes (i have master degree), so its probably not so common as you think. (just my 2 cents :))
First of all, best way (from our experiences) is to structure "by feature" not "by layer", which applies both to Java, Javascript and others. (We do some Java, Spring, hibernate, Js, jquery, react) Specifically in JS, it depends on your framework/library usage. But even for small JS projects in jquery, its worth to transpile ES6 import statemens, or invest to RequireJS(commonJS, ...) structure. Then do things in similar way, you usually do in Java. For our redux/react app, we use roughly theese approaches: * http://jaysoo.ca/2016/02/28/organizing-redux-application/ * https://github.com/erikras/ducks-modular-redux
I'm annoyed that people downvote you without explaining (never understand that, it's so stupid and doesn't help anyone), so here: You're fundamentally misunderstanding the problem; your solution is a technical solution to the problem of finding where the classes are in your filesystem, and remembering to do the wiring. The example pertains to architecture. It's about dependencies, and how the less of them you have, the easier it is to reason about, test, and share parts of your software.
And here you are saying composition is better in this case, which is the discussion after all. &gt; Favor composition over inheritance 
and? It wouldn't be bad to have a different model if it had been easy to use, which it wasn't until `Object.create` (es5, ie9+) or `class` - syntactic sugar around a construction and a prototype - (es6).
I am not trying to. I am trying to find a use for it at all. See, we both agree that it has common misuses, but I have yet to see a practical example where inheritance usage is objectively better than the equivalent composition form EVEN for cases where inheritance is apparently appropriate or encouraged.
What would be the disadvantage of specialization via composition?
Point your dependencies outward. That's how you solve your problem. The aura doesn't need a reference to the unit, the unit needs a way to determine active effects - maybe it's an array of objects with an effect method and these are checked every tick. The unit doesn't need a reference to the world, it needs methods that other objects invoke on it to affect the world. Pathfinding could be a function of the world that accepts a Unit object and a location to move to. Or it could be a service class that accepts a World, Unit, and to/from locations. Ultimately, you're talking about bad dependencies and design rather than inheritance. 
You're confusing weak/strong typing with dynamic/static typing.
&gt; What does this actually mean? What's not easy about assigning an object to the prototype property? except that's not really inheritance like OP is talking about, what OP is talking about is more like function Child(){} Child.prototype = Object.create(Parent.prototype, { constructor: { value: Child, enumerable: false, writable: true, configurable: true } }); which allows for classes to inherit from classes. Your talking about some one of the many non classical types of inheritance that a lot of people in JS were pretty ok with.
I have never liked inheritance, but then I also did not learn C++/Java/C# before learning JavaScript. I have always found inheritance to require substantially more code and convention to achieve very minimal code reuse. Why should I have to deal with this madness and increase my maintenance burden if I don't have to. Instead, I prefer to write code in such a way where its execution flow control is as close to how a human reads the code. This makes the code so much easier to maintain and it also means less code to write. The biggest problem with inheritance is that when reading code you might know what a small fragment of code does but you have no idea how its called or where its used without setting a bunch of breakpoints and considerable guess work. This is archaic stupidity that wastes peoples' time.
Cool, thank you! I have to try it out
Brilliant. Thank you.
I think you mean `super.sleep()`, `super.eat()`, etc. in your example (was confused for a second).
Manual interface forwarding. You'd have a lot of boilerplate to make Special::general() call and return the wrapped General::general() methods. Inheritance is pretty much just automatic composition of your overrides composed with the base class, including automatic method forwarding.
Execution environment plays a huge role. Here is how I like to organize my code. **Pure computation (API agnostic application libraries)** * Imperative functional is the way to go. In the case of this code you are not limited by concerns of human interaction and probably not by asynchronous concerns, so you are free to get right to it and solve problems directly. * I will typically wrap the entire file in a single function. This provides a common file-wide scope without global pollution. I call this sub-global. Sometimes I will make this outer function an IIFE depending upon how this file consumed as it eliminates yet another global reference. * Inside this global space I do only two things: 1) I declare storage references (typically arrays) and 2) organize my principle tasks into child functions. Directly in this sub-global space I will limit my use of conditions and never use loops or other logic as logic should be organized into a child function. * The child functions will generally be organized around a single principle set of logic whether its a loop or a condition list or something similar. A child function (principle task) may also be instead composed of sub-tasks. * Organization is important. Humans (to our detriment) tend to write code faster than we can read code. Reading code is important. When code is organized in such a way that its execution flow closes mirrors how humans would read the code from top to bottom the code is easier to understand and problems are faster to find. **Synchronous API driven code (typically large interfaces to the browser)** * Separation of concerns is important in all things, but here its the most important thing. * I prefer to organize my code as DEA: data, events, and applications. Data refers to storage which can be either objects or arrays. Events refer to those functions that touch human interactions. Applications refer to those functions that are just used internally, typically for code reuse. * To make this organization explicit I prefer to create three objects in my sub-global space: events, apps, and data. Every internal reference then becomes something that is forced into the explicit organization or is a local reference. **Asynchronous flow (typically Node applications)** * This is harder because the logic will likely be callback driven. I know promises and asynch/await are things now, but callbacks remain the foundation in most of these cases. Understand callback flow. * When callbacks become deeply nested you get something called callback hell. Promise chains are exactly the same thing, but are written in a more linear (less structured) order making them faster to read. I have found that with a fair amount of practice and enough organization callback hell becomes less confusing. The hard part is ensuring callback hell is well separated from surrounding logic to ensure readability. * To ensure organization I take the DEA concept from above and modify it a bit so that all reusable functions are applications and there are no explicitly declared events (all code reuse is equal). Inside these functions prefer to allow logic as normal to solve the given problem and then provide callback hell as explicitly as possible so that it is visibly different than the surrounding logic. * When you get a bit deeper callback hell is really not a big deal. The real problems come from recursion (whether logically or in execution if the code calls itself as a child process). It becomes really hard to figure out whats happening when something goes wrong. Your best friend is error messaging. A stacktrace is a good start, but it isn't enough. Better is knowing exactly what function generated the error, whether recursion has occurred, and if there are steps in the flow control/data that helps to reproduce the problem. * You can identify if the execution is in a child process by passing in an argument (I use *childprocess*) and then pop it off at the top off of process.argv at the top of the outer function. **Things I didn't mention** * I don't use inheritance... ever. I find inheritance to be extra code and confusing. Its like choosing between paying money to hurt myself and great food for free. * I avoid unnecessary abstractions. I find extra layers of bullshit are exactly that. Everything is awesome until it isn't at which point you have to swim through the sewers to find why the problem has occurred before you ever get to your own code. It reminds me of my teenage children crying that it *isn't their fault*. It's bullshit. * Good abstractions tend to be extremely shallow (aliases, which can make code easier to read and without introducing logic that will ultimately fail), and exist to solve valid problems (code problems, which is different than a developer's failing confidence).
Oh, yes. True that. Sorry, just s/ that, but otherwise I stand behind that ;) 
I think you and I have very similar views on this topic. I'll try to explain how I see it, for the benefit of anyone caring to read. OOP has a lot of say about encapsulation and how to use inheritance to build a tree of related classes. But these things are really concerned with how your classes appear to the outside world (=user of your library/code). OOP doesn't say a lot about how you should *implement* your classes. Sure, you can use inheritance to take a class, subclass it and modify its behaviour and/or add new methods etc. But generally speaking, using the inheritance tree as the primary way of sharing and reusing the implementation code for your classes is very limiting and problematic. For example, superclasses tend to get bigger and fatter as code is pushed into them for the sake of code sharing and reuse. Bogus abstract classes tend to sprout up around the root too, such as DragableBase, ThemeBase, LayoutBase etc. Simply put: Think of your class hierarchy/API as being separate from how you implement it. Just because Dog and Car both have move() methods, doesn't mean they should be sharing implementation code through the class hierarchy. (From this point of view "protected" methods and fields are an anti-pattern or symptom that something has gone wrong.) These days I do a fair bit of TypeScript programming, and here I've tried using simpler and shallow single inheritance hierarchies combined with interfaces for things which are more cross cutting. For example, my components often need to have configurable keybindings but there is nothing in the base class about keybindings. Instead classes can implement AcceptsKeyBindingManager interface which defines a method where a keybinding manage/config object can be supplied to the class. Instances can be probed at runtime to see if they implement AcceptsKeyBindingManager. Putting keybinding stuff in a separate object also makes reuse easier and more flexible. 
As coincidence would have it, I just watched a video by Source Decoded on the subject of Inheritance vs Composition. I think they make some really great points. https://www.youtube.com/watch?v=dYUZiJEy0JE The takeaway for me is that inheritance is essentially a form of composition, but one which isn't flexible at run-time.
Agree. I want the mixin pattern so badly in languages like C#. I want independent behaviors without having to reimplement them over and over and over... C# extension methods are a half measure here.
Instead of asking for an answer, tell us where you are having issues and we can point you in the right direction :)
It's a bit like handlebars on steroids. Handlebars gives you one-way data binding: you feed in a template and some data, and you get out DOM nodes. Ractive gives you two-way binding with live updates. If you change your data, the DOM nodes update as you do so. And if you change the DOM (e.g. by entering values into a form), the data updates. [Here](https://codepen.io/trvrm/post/ractive) is a very simple example.
I realize that, but the variable `animal` is not defined anywhere. `super` here is not a keyword, it's the name of this property: Animal super;
same reason why OO was gonna save the world 20 years ago
A perfect example of state!
&gt; The Banana object needs a Gorilla object (so that when you have a Banana object you can call banana.getHolder() and get back the Gorilla holding it) It would ba a strange banana if it could not exist without someone holding it. Are you sure this is a valid example proving that unit testing with OOP is impossible? 
One of the bare-minimums I want to see in a FE structures is directories that mimic the apps routes. If I want to see the model-loading, action-handling, view-rendering etc code for the `/foo/bar/baz` route, I should be able to go to `ROOT/src/foo/bar/baz` to get there, ideally the code there should be pulling in lots of shared functionality/components from elsewhere but the base should exist there. 
OOP requires two things, 1.) planning, 2.)That the requirements do not change. Applied to the art that's unreasonable. I'm self taught over a span of 10yrs via work experience with a focus on web development and I commonly use OOP one level deep to incapacitate state for objects that will be created multiple times or need for state not to leak out, but I never have those new object inherit from another object. There are points where I need inheritance to augment things but I use it as a last ditch. Making large chains of relationships is not maintainable or realistic when you cant get requirements and requirements come that destroy the programs paradigm. In programming there is data, and math done to that data. Using OOP for anything other than the creation of data or organization will break the program over time. OOP is taught way to soon in colleges, from what I've seen in the field colleges overall do a bad job preparing students when compared to other professions.
This is cool tech and congratulations to the project maintainers. With no disrespect intended, I still do not understand the interest in modular CSS. The best argument I've heard is the ability to determine styling dependencies, but even that feels like a stretch. Can anyone please share any anecdotes about how they use it professionally, how it's changed their workflow for the better, and/or why they'll keep using it? Bonus points if their workplace has both JS engineers and folks who just focus on interface styling and can give me an idea of how _they_ feel about it?
Yeah, PHP will go straight into an error if you try to combine two traits with colliding names, it will throw [function] already defined errors.
Java got mixins in v8, kinda.
"No Battle Plan Survives Contact With the Enemy" - Moltke It is a nice plan theory but when implemented by your average software developer it turns to shit. Also there is the part where JavaScript doesn't have classes so inheritance becomes even more fragile.
Man, I hate being a hater on things like this but I very strongly dislike the approach encouraged by both of those links. In my opinion, they both create brutal sprawl while discouraging code reuse and making it harder for an app to grow. On organizing by feature: splitting up by feature is great when you have small, completely independent chunks of code, but it seems so rare that I have a feature that is both completely self-contained _and_ needs a completely isolated folder structure. It sounds so nice but it just doesn't work for me when dealing with views that, by nature, often mix content from different features. On "Ducks": The approach just feels wrong for Redux. It's fine when you have some actions that are only picked up by a single reducer. As soon as other reducers start seeking those actions, it stops making sense. Of course, if it works for others, that's awesome and in no way is this a knock on any individuals' decisions or practices that work for them. I'm only bringing this up because I stumbled upon these patterns early on in my deep dive into JS and they were the source of great frustration. Maybe it's my Ruby background, but I find the function-oriented actions/components/containers/reducers approach to be much, much easier to work with.
The main benefit is to write styles without worrying about name collision. You can achieve the same~ using various naming techniques, such as BEM or OCSS.
Hi /u/plavookac, please don't post blogspam like this -- post a link to the original article instead. Thanks!
&gt; I think parent is trying to say the example is a strawman, not that it isnt a common problem with OOP. If it's a common problem with OOP how could it possibly be a strawman? A strawman is a flawed argument that doesn't reflect reality, the Banana-Gorilla-Jungle example is very realistic (though obviously no one is actually going to write a program with literal Banana, Gorilla, and Jungle classes). &gt; why would the banana need to know who is holding it? What if the banana expires after a few minutes and needs to remove itself from the gorilla's hand when that happens? What if the banana gives a buff to the gorilla that is holding it? What if the banana causes flies to attack the holder? Either you move these behaviours up into the Gorilla class (which now has to be responsible for Banana behaviour, along with the behaviour of everything else it might hold or interact with) or you give the banana a reference to the gorilla somehow (via the constructor or as a parameter to most of the methods) and you're back where you started, Banana now depends on Gorilla. Either choice is a bad one, but they're the only choices we have in an OO environment. This is one of the fundamental flaws of OOP: the most important behaviours are always the ones that concerns interactions between objects, sometimes two but sometimes many objects, but OOP forces us to assign these behaviours to a single object that effectively owns the behaviour. Who owns Banana-Gorilla interactions? Does a gorilla eat a banana, or is the banana eaten by a gorilla? Does the banana buff the gorilla, or does the gorilla get a buff from the banana? To me it seems like the only way to win the game is to not play the game at all. I don't write everything as noun classes with behaviours any more. I design systems that encapsulate a one or more concerns for all entities, and that collaborate with other systems by sharing information about what has happened, rather than telling other systems how to do their job (since how the other system reacts to the information is by definition outside of their concern). There are places where OOP makes sense, I've never seen a String class I didn't like, but I don't think it belongs at the core of even a moderately complex program because it prevents any meaningful separation of concerns by bundling them together inside of nouns.
Are you saying things are changing too fast? ... or that you're officially "old"? ;) _Edit: added a winky to sound less dickish_
classes !== inheritance Classes are useful even if we don't use inheritance. Classes are useful even if we're doing composition. Here's an [older post](https://www.reddit.com/r/javascript/comments/5g6rmr/for_all_of_us_oopers_maybe_classical_inheritance/daq2umc/) where I showed a good use of inheritance, then I converted it to instead use composition. But both examples still use classes, because classes !== inheritance.
Python doesn't have private member support either. They use underscore prefixes just like we do in JavaScript. Having language-enforced privates is *nice*, but not having them doesn't make the whole thing useless.
Agreed, the rate of change in infrastructure tools is ridiculously fast. I wish developers weren't so ADD about it. I get it, change is good but let's improve things that are in place rather than replace an entire technology. [I mean we're not driving these anymore](http://salvationlinks.com/wp-content/uploads/2013/01/AAAA1912-ford-model-t.jpg) but we still use them. Entropy is a thing fucking deal with it!
Funnily enough, the first time I heard about favoring composition over inheritance was on [a talk by Mike Acton](https://www.youtube.com/watch?v=rX0ItVEVjHc) (game developer (Engine Director at Insomniac Games)) [slides](https://github.com/CppCon/CppCon2014/blob/master/Presentations/Data-Oriented%20Design%20and%20C%2B%2B/Data-Oriented%20Design%20and%20C%2B%2B%20-%20Mike%20Acton%20-%20CppCon%202014.pptx)
I'm 37 and just took up programming after a 10 year break. I'm actually really enjoying learning the new technologies. Go for the backend, javascript/jquery/angularjs for the front end. I find it's so much cleaner and more powerful than how I used to do things (Perl for the backend with a tiny bit of javascript for the frontend). I feel like I can pick up any language. And I like change. I hope I can be a decent programmer well into my later years. I work with my father, who is in his mid 60s, and he recently took up angularjs to help me work on this latest project.
Amen! A class is a template for an object, nothing more nothing less. Inheritance is a completely separate concept where you layer those templates on to each other.
I'd actually argue that the underscored-privates are *superior* IF your team is made of responsible programmers. What I mean by that is IF your team is made up of responsible people, then they will understand that `_foo` = private, and will never call it from outside an instance of the class. If your team has a lot of junior or "non-team-player" coders, this might not be the case. But if it is the case, underscored-privates are superior because they let you "drop the privateness" when convenient. Want to stub out a private property/method in a test of a public method? No problem. Debugging a tricky problem and you really want to see what that private property is set to? No problem. With a true privacy system you're screwed in both of those situations, and you have more complex tests and take longer to debug problems involving private properties as a result.
I think it is simple: In the beginning, client-side stuff was rendered on the client, client-side logic run on client. Then web came, meaning everything had to be rendered and run on server-side due to limitations imposed bu browsers. Once browsers improved it came back to where it started from: standard client-server architecture where client-side logic runs on client-side, server-side logic runs on server-side. 
&gt; I think you mean Yeah, you're right. I was half asleep trying to write a psuedo-code example of composition that looks like inheritance and I confused myself. Thanks! Fixed.
How do you figure?
Certainly there's enough data by now to prove whether #2 is actually the case.
The fewer number of instructions executed server side for a single user the more users can use a server. Increasing scalability in this scenario is about moving certain computation from the expensive server to the free client. 
Thank you, actually i had the same mistake in more functions from my script.
Every 10 years or so it flip flops. Only constant is change.
Thanks for the response, i was stuck with a "can't get the href attribute for 'undefined'" error when i put: getAjax(document.querySelectorAll("body a")[i].href) Your code worked well.
If you'll forgive me for playing the "old programmer" card, let's take a step back. Programming in general, and web programming in particular, has fads. Consider jQuery. With all the abstraction layers in today's frameworks (eg. React's virtual DOM) having jQuery in your project is now seen as a sign that you're doing something wrong. But less than a decade ago it was the exact opposite: if you *didn't* have jQuery in your project, you were doing something wrong. My point here is that web dev opinions fluctuate. Whether or not to use OOP (and specifically using it with inheritance/polymorphism) is one of those opinions. When Java came out (not *that* long ago) OOP was considered essential, and the entire language was built around it. But now in today's Java**Script** community it's largely frowned on. The thing you have to understand though is, opinions aren't a steady march of forward progress, they're much more of a "two steps forward, one step back". Consider another example: Mochikit. Mochikit is a library you've probably never heard of, because it competed with (and lost to) jQuery. But what's interesting about it is that it had a system of generating HTML elements that was *very* similar to React: DIV('foo', {class: 'some-class'}); // Mochikit for &lt;div class="some-class"&gt;foo&lt;/div&gt; &lt;div class="some-class"&gt;foo&lt;/div&gt;; // React/JSX for &lt;div class="some-class"&gt;foo&lt;/div&gt; When jQuery was beating MochiKit every developer at the time would have told you that using JS to build elements was idiotic when you could just use jQuery and strings of HTML. But then React combined JS-based element-building with two unrelated technologies (the shadow DOM and transpilation), and now every React programmer in the world will tell you that building HTML in strings is idiotic when you can just build it with JS. My point in this long history lesson is that just because "everyone" agrees a technology or technique is the wrong approach today doesn't mean it is. If the React people had "learned their lesson" from Mochikit and listened to the "JS-based element generation is bad" consensus they never would have built React. So similarly here, I think what matters is understanding the bigger picture. JS-based DOM-generation wasn't bad, it just wasn't as good as jQuery in the context of web development ten years ago. Similarly, I would argue inheritance isn't *wrong*, it's just inferior to composition in a lot of cases. A big chunk of those cases are multi-level systems: when you have a class that's a subclass of a subclass of a ... the code gets a lot harder to maintain. But, speaking as someone who's been doing web dev for quite awhile now, my opinion is that if you generally favor composition and keep your inheritance trees as shallow as possible, your code will be better off than if you completely abandon OOP entirely. P.S. When I say "as shallow as possible", you could even take that to the point of "never make sub-classes". Even if you do, I would still argue classes have a lot of value. After all, the React crowd is probably the most anti-OOP pro-functional group in JS development, but even so the vast majority of React codebases I see still use classes, at least for "smart components".
No for sure, I agree with you. I was just more trying to hit on the fact that all these ideal scenarios people come up with where X tech is the best for Y job never have to deal with real world scenarios and convoluted work environments where there are numerous other reasons tech paths/etc are chosen.
&gt; whole new library that completely changes everything you do CSS-wise Thats a rather vague statement. The only thing that changes is that you don't need to use a naming convention that prevents name collisions across multiple components/ projects. What else changes?
So it is just more expensive really. It is scalable, but it costs money. However, not being SEO friendly also costs money. 
What problems have you run into with your vanilla JS implementation that you think a library could help with? Sort of hard to recommend anything without knowing that bit.
The initial performance hit of bootstrapping larger SPAs causes pretty low score in Google ranking, even if we are indexed properly now. I haven't needed to or been able to focus on this problem myself for what I work on, but I've seen the effects and benefits from my colleagues who are working through this problem. They have had to jump through a lot of hoops to get below the fold scripts, css, and other negative hits to ranking to play nicely with the needs of the apps they are optimizing. 
Okay so it's endemic ADD in the industry. That's even worse.
I never said it wasn't capable of being scaled - the nature of the beast is the more work you do on the server the more servers you need for your users. Scalability is all about distributing work through client side code, sharded databases, a load balancer, etc. A website/app is scalable if it was designed to handle large fluctuations in use IMO.
Being SEO friendly is also about determining which search engines you care about. If you only care about Google (maybe others as well), then client side rendering can work fine. Each search engine can handle indexing a website differently... so we always define a subset of search engines we care about.
The first three points (no postback, lazy loading, and rich interactions) have all been possible since Javascript and AJAX became well supported. The next three (cheap hosting, use a CDN, and easy deployments) should really be a single point: it's cheap and easy to deploy static files to CDN. "Learn Once, Write Everywhere" feels out-of-place. Yes, Javascript is becoming more and more popular. What does that have to do with server vs client side rendering? The author does make some good points about the benefits of client-side rendering, but I still don't think the benefits of *only* rendering on the client-side outweigh the losses.
Or... you cache the expensive parts in memory and send the pre-rendered data to the user for as long as it makes sense. Even a server side cache of ~15 second duration negates this issue.
I wouldn't say problems. But I'd like to add some form of structure, maybe I'm lacking good practices to make it more organized.
Server side rendering does not reduce the number of developers you need.
You're talking about components that aren't personalized to the logged in user - depending on the application caching might not make any sense in most cases. Either way - it's still more work on the server.
I am, I didn't think it really needed to be explained... so I was interested in people thinking why I'm wrong.
Maybe because he thought it would be obvious that server-side rendering requires more work from the server per user, and that having the server do more work per user makes you app not scale as well.
No, it's not. The server has to return the personalized data either way. It's makes no difference to the server whether it returns `&lt;div&gt;Hi Joe User!&lt;/div&gt;` or `{ name: "Joe User" }` I've oversimplified, or course, but the suggestion that server-side rendering is inherently *more work* is not true.
&gt; he thought it would be obvious that server-side rendering requires more work from the server per user It's apparent that many developers don't have a solid understanding of performance optimization and where the load really exists. Offloading responsibility to the client sounds like a panacea but in reality you're just relocating complexities elsewhere. Example: [http://www.charter.net](https://i.imgur.com/h6sXKVu.png) This is a site whose development team obviously decided that client side was better for whatever evangelistic reasons they were spoonfed, but no matter how many times I visit the site (at least once monthly to pay my bill, but typically more often than that, I'm greeted with the nearly blank page every time I click a navigate to a new page on the site. Had they instead rendered the basic page content server side, they could have simply refreshed the user specific portions with data once it was available via ajax or whatever. But they didn't. They chose to simply delay the entire page UI load until their client side code could execute. It's bad form and too many people are running blindly with it. 
For an SPA, yes. I agree. Gmail is a classic example of this. Not every client-rendered site is. And not every site needs client side rendering. It's not a magic bullet for scalability as OP I responded to would suggest.
i enjoy using mithril for smaller projects when react and angular seem like a bit much. 
I disagree with this article so hard. I work on an enterprise SPA that simply gets its data from JSON endpoints on the server. The amount of time we waste dealing with state (history state, app state) just so we can get fancy transitions between pages, is not at all worth it.
Unless you're doing something crazy, the actual rendering of html is a pretty inconsequential part of the load on a server. Add in a robust cacheing strategy it's basically trivial.
&gt; ergo Aura has no way to affect the Unit it's applied to, Well, in this specific example you'd make the Aura just be a description of what the aura does rather than holding a reference. This is how entity-component systems work 
Inheritance in JS is pretty useless due to the lack of strong types, interfaces, and abstract classes. 
Agreed - both have pros and cons. I'm not saying server-side is inherently worse - but I am saying when it compares relative to client-side it is at least slightly less scalable - to potentially several times less scalable. 
I gotta say it's pretty sad you are being downvoted
But also `NaN !== NaN`
&gt;sessions, state, shopping carts, and checkout Most of that must be handled on the server regardless &gt;If you spend your life working in a framework you won't see any of this Why's that?
It's almost as if rooting for a tool doesn't make any sense...
Yeah I dont know... I don't really care about karma, but I do care about the competency of people in the industry to understand relatively simple concepts. 
If the only reason you're client-side rendering is to get fancy page transitions, I agree, that likely isn't worth it. But I suspect there are other benefits of client-side mentioned in the article that also drove your team to choose client-side rendering over server-side?
This only applies if your largest driving cost is processor time. Many sites / applications spend much more on bandwidth, and dependency loading for SPAs will drive bandwidth costs much faster than it will reduce CPU cost for many types of applications.
haha, true. You know what I meant though :)
Mithril has a very traditional MVC structure and a super small footprint compared to React / Angular.
&gt; "Learn Once, Write Everywhere" feels out-of-place. Yes, Javascript is becoming more and more popular. What does that have to do with server vs client side rendering? It has to do with client rendering because JS is the language used for client-side rendering. This contrasts with traditional server-rendering which typically utilizes a dedicated server-side only language like C#/Java/Ruby etc. 
haha thanks!
I agree on your 2nd point, but client-side rendering didn't win *purely* on economics. Economics is merely another valid benefit.
My position also applies to bandwidth - compiled HTML most often takes more space than JSON.
That's almost right, but obviously in the beginning beginning, client-side stuff was rendered on the server because line printers, VT52s, IBM 3270s and anything else supported by curses was all done on the server.
Client side does, if optimized correctly. Although it really depends on how you do it. For example, if you bundle your entire app into one bundle that will lead to an overall higher load
Client-side rendering seems like an amazing idea. However, there are two issues with it that we are still coming to terms with. First, internet usage will be via smart phones more and more as a percentage. Second, client-side rendering on constrained mobile devices is a terrible experience, so far. 
He's being downvoted because his statement was offered as if it's a universal truth everyone knows, when in fact at best I'd call it mostly true some of the time.
You have to import in your modules into every JS view file; I'd argue that's pretty different vs. having a single &lt;link&gt; tag in your HTML. Is it a huge onerous burden? Of course not. But it's also a completely unnecessary one IF you simply adopt a proper CSS naming scheme such as BEM.
I worked with a large Marionette application at a job a few years ago. I really liked it. Much better than backbone alone.
I will take a look at mithril docs more carefully, I've seen it in the past... thanks!
I think that wall of code might have intimidated others from responding, and it intimated me from reading the whole thing, but I did read some and I *think* I see the problem. From the jQuery docs of `on`: &gt;When jQuery calls a handler, the this keyword is a reference to the element where the event is being delivered; for directly bound events this is the element where the event was attached and for delegated events this is an element matching selector. (Note that this may not be equal to event.target if the event has bubbled from a descendant element.) In short: instead of using `this` inside your event handlers, try using `e.target` instead (where `e` is the first argument passed in to your event handler). 
There are multiple approaches for handling SEO with client-side rendered apps, the most notable being isomorphic/universal rendering as mentioned in the article, and doable today in Ember, React, Angular 2 and more.
This is just not true. If you want a site to perform well on mobile and be feature rich you need to do both client and server renders. Even removing the network using things like a service worker do not make your site fast if the device has to spend 600ms+ parsing and executing JavaScript on a new page load followed by a massive Dom paint.
Client-side rendering hasn't "won", because that implies server-side rendering *lost*. *Most of the web* is still server-side rendered. After a flirtation with client-side-only rendering as it was first populised (during which its many benefits and limitations revealed themselves), *both* React and Angular 2 (by far and away the two biggest "front-end" frameworks/systems[1]) now support server-side rendering as well. It's not a win/loss result - it's a *merging* of front- and back-end code and technologies If anything's "winning" it's *isomorphic javascript*, allowing developers to get most of the benefits of client-side and server-side rendering from a single DRY codebase. ---- [1] Not to mention Ember FastBoot, RendrJS for Backbone, and any number of half-arsed abortions built on intercepting requests and routing them through a PhantomJS instance running on the server.
In summary, you're saying a poorly built client-side app will perform poorly. I agree. All approaches can be abused. However, server rendering isn't a requirement for good performance. Carefully selecting one's dependencies, minifying, bundle splitting, tree shaking, and lazy loading are a few approaches that help assure a client rendered app loads quickly.
Links will work though
Fair enough. I'd say isomorphic (or universal) rendering is the way of the future, for really performance critical apps.
More load for the client, which is bad news for slow devices. But also the ability to compensate network issues via more useful offline interactions, which is good news for slow networks. And as slow devices sometimes come with slow networks... Guess once again it depends on your user needs.
If you haven't used at least 4 of these you can't understand, come talk to me in 5 years. * ant * maven * Rake * JSmake * grunt * gulp * ~~yarn~~ 
Check the post! Started https://github.com/daedlock/MovieMate
It's a good question as to where the problem really lies. I haven't read the spec for the `&lt;object&gt;` tag but I blame safari for not following the redirect. The workaround that I've settled on is to do the redirect by hand. I created a new endpoint that will return a json blob with the correct URL. Then, I just use the result of that call in the object's `data` field and all is well.
So nothing that couldn't be done with composition, if willing to pay the boilerplate price?
* Get the scroll distance of the page. * Get the current scroll location in the page. * Use division to calculate a percentage. * Attach code as a handler to the page's onscroll event. --- var body = document.getElementsByTagName("body")[0], scrollEl = (document.documentElement.scrollTop &gt; body.scrollTop) ? document.documentElement : body, scroller = function () { var distance = scrollEl.scrollHeight - window.innerHeight, now = scrollEl.scrollTop, percent = 0; if (now &gt; 0) { percent = (now / distance) * 100; } return percent; }; body.onscroll = scroller; 
Man, I used to really like ruby (and rails), now it seems so foreign. What the heck is a "JavaScript Sprinkle" lol.
Take a look at this: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString
Basically. Composition and inheritance are just automated means of reducing duplication and boilerplate; you can compose and inherit in C if you're dedicated enough.
No worries! &gt; I have been working on are using BEM ... [but] I am bothered by using it because ... I find the code base a lot easier to scan/ understand when it is using CSS modules. I agree: I think the principle of keeping CSS localized the same way JS is, both conceptually and in the file system, makes perfect sense. But React CSS modules is only one way of going about it. You can also use Webpack to "import" CSS files in (but without having to mess with your class names in your JS). Or you can use a task runner (eg. Gulp/Grunt) or a CSS post-processor (eg. Less/SASS) to keep your CSS next to the JS in the filesystem but then compile it all out in to a single file that you can include in your HTML. Any of those three options are viable, and they all let you keep your CSS in feature-focused files that live right next to your feature-focused JS code. But for me personally the real "bang for your buck" comes from adopting any of those approaches: the added benefit using React CSS Modules (which is that you avoid name collisions) is one I can get elsewhere (from BEM), so any extra hassle from it, even a small hassle, isn't worth it. But I freely admit that personal preference plays a huge role in what's the "right" approach. I like BEM because I'm the kind of person who names a class "LongNameRecord" instead of "LongRec". I don't mind verbosity because I think it makes the code clearer, but many people find that overly-verbose class names (such as the ones created in BEM) make the code less clear. If that's the case, React CSS Modules might be a better way of avoiding name conflicts.
This is extremely helpful for those tiny conflicts you sometimes get when working on a project. Awesome!
Because you can't tell if you're getting old either? I would say in your mid-20's... yeah, you still have a ways to go. You're in the clear!
I use jquery when I'm not using a framework like angularjs. Unless jquery has been deprecated all together?
OF COURSE!!! I am making client-side rendering since 2011, when I discovered it was possible. I can't believe a javascript subreddit is even discussing about this, it's so obvious!
What would you do if your product needs a mobile App now? I am making Rest APIs so javascript and mobile apps can use the same logic. I work only once in the server. And all clients uses it.
None listed in the article, no. And some of the things listed in that article aren't even due to client-side rendering. &gt; With client-side rendering, separation of concerns is programatically enforced. False. You can put gobs of JavaScript in with your templates and vice-verse. Being able to query from a DB or not is not what separation of concerns is, in general. I could just as easily make REST calls to a totally separate backend within an Angular template by using &lt;script&gt; tags. Client-side rendering in no way, shape, or form, enforces separation of concerns. When I write PHP applications, I have blade templates that simply spit out the contents of variables. There is no logic being performed in those templates aside from typical conditionals and loops. Server-side rendering lets you practice separation of concerns just as easily as client-side rendering.
It's in active development.
But then you have C#- or Java-to-JavaScript compilers, and even though frameworks for that setup may not be popular, it's entirely possible to do client-side rendering without JS.
Accessing unicode values in javascript with their name https://github.com/zombieleet/unicode-js
Well said. The title obviously can't be taken literally. The real message is about why JavaScript-based rendering has become the predominant approach for new web apps. But that doesn't make quite as catchy a title. 
In short: React.renderToString. Example: https://github.com/DavidWells/isomorphic-react-example
This looks awesome. I've written a DBAL/ORM in the past and am well aware of the amount of work it involves. This library is well written. Hot damn.
Nice work, and interesting idea for tagged template strings, however... es6x uses regex-based string parsing to generate html. I hope you have fire-tested this against the thousands of possible script injection attacks out there. es6x is not a standard either, so it is on equal footing with jsx in that regard. Using babel only for jsx conversion, while leaving the code as es6 is easy, just remove the preset that transpiles es6 to es5. Transpilers are not just for making es6 code into es5 code. Your own tests show jsx with much better performance. How do you use your system to create whitespace collapsed dom?
&gt; Someday we will be compiling to webassembly and it will be a lot faster. I think that statements like this are not in general correct. As an example, if you're rendering simple content like a relatively static navbar, then how much *faster* would it be in JS vs WASM? 0.001s? 0.1s? It could very well be negligible. Think of it this way, if I write a simple function that iterates over `x` values is it going to be *much* faster in C or JS (node)? Furthermore, `JS` *is* compiled (JIT compilation), so I'm not convinced that execution time will in general always be *significantly* quicker. It will depend on factors like bundle size. All in all this comment kind of irks me... someone suggests using `template literals` instead of `jsx` and you go ahead and bring up web assembly. Every 10th thread on this subreddit has someone making a comment about web assembly without *really* understanding the implications -- not that I do. I guess it's fun to speculate and (at times) interesting conversation, but I'm really getting tired of the whole "when web assembly *hits* we wont have to worry about X at all!" associated resources: [js JIT compilation](http://creativejs.com/2013/06/the-race-for-speed-part-2-how-javascript-compilers-work/) [primer on web assembly](http://www.2ality.com/2015/06/web-assembly.html)
I've been thinking about doing something similar with [custom elements](https://developers.google.com/web/fundamentals/getting-started/primers/customelements). It should be easy enough to make simple components without requiring react/jsx or framework Y.
I've tried most of these and I think you've correctly described their problems. Feathers looks great, haven't tried that!
Wowowowowo chill out man, I didn't knew everyone was talking about this but I believe it is relevant for this thread. I just think webassembly might be the result of a compilation of any language and if people want to right code in another language is ok by me. 
Fucking FINALLY!!!
the thing is client side rendering won long ago. Before javascript was even a thing we had client/server with varying degrees of richness.
&gt; there is the part where JavaScript doesn't have classes ES6 disagrees with you. ^^^^^I ^^^^^know ^^^^^it's ^^^^^just ^^^^^syntactic ^^^^^sugar.
The problem is look-ups. Client needs to send an HTTP request to the server every time it needs to query a database. If not for that, client-side wins hands-down.
Would you prefer EW Dijkstra? &gt; Object-oriented programming is an exceptionally bad idea which could only have originated in California. 
Extending prototypes existed well before Object.create came onto the scene. 
Yikes, how do you manage this: &gt; For example, rather than create extra properties on VNode objects, Inferno reuses previous properties (even if the property name doesn't really align anymore with what's being put within it).
thank god i left the office and waited till tomorrow to resolve my conflicts
I've used Rake on a javascript project before. It used ruby, sure, but it used ruby to build and package javascript / html / css / etc. I think that was before node existed, though.
Sprint.com is built in Angular for example: https://www.sprint.com
Well if it was a primarily Ruby project then that could make sense. I've used Make for javascript builds in the past (typically just aliasing "npm build" or something like that), and it worked perfectly fine. I don't get the hysteria about JS build tools. First of all, build tools have always been a pain in the ass since the dawn of programming. That's just the way it is. Are JS build tools really *that* much worse than other languages? I'd argue the opposite. In general, JS tools are easier to use than things like sbt or maven. In fact its odd that OP lists maven as an example of a modern web technology, when it predates the modern web. 
thank you
This'll probably get me flamed but... this is what I do. const $ = React.createElement; Component = (props) =&gt; { return $('div', null, 'Best ', $('strong', null, props.count), ' things'); } I'm not using jQuery and React at the same time anyway, and this still _feels_ like Javascript code.
I'm surprised you didn't mention that Javascript is prototype oriented, what do you think about adding all that syntax sugar to create 'classes' in JS? You ever worked professionally with Scheme? I'm reading bits of SICP and I'm hating the interpreter.
I didn't mention prototype-oriented because I don't use it either. I mostly use dumb data and pass it to pure functions, usually transforms, with the occasional closure. Works for 100% of my current codebase. JS can be prototype oriented, but it need not be. My code is very easy to reason about with not prototypes, new's, or this's. i don't use classes if I can avoid them. Never used Scheme, Basic, Java, or Perl professionally. All the others, though, and a few more.
This only happens for synchronous javascript.
Could simply need reddit sign ups in volume the system doesn't like
Check out [Sinatra](http://www.sinatrarb.com/) or [plain Rack](https://rack.github.io/) if you're looking for something more bare-bones. Rails 5 also has a more minimal [API mode](http://edgeguides.rubyonrails.org/api_app.html) if you're just building a backend, which you can evolve into a full Rails app if needed.
This problem has been around for quite a while and is long since solved. Both can scale equally, it's just where the cost comes. With SSR, you can load balance multiple machines and geo-load balance across locations to ensure each user gets a speedy response from your website. There's also caching and a whole slew of tools that I know I'm leaving out. But, the cost of that is that servers are expensive. And you need some level of presence across multiple colocations (and the cost of renting the space in those colocations). With client-side rendering, you cut down the cost of servers, since serving static data is cheap. But, instead of writing code for a single target (PHP5, Python whatever-version, etc.), you have to worry about IE, Edge, Chrome, Firefox and Safari. And then, since people are allergic to updates, you have to worry about older versions of each of those. Then, you have to worry about mobile browsers. Then you have to worry about bandwidth usage for the users using your webapp over their data carrier. Then you have to worry about the 3 people who have javascript disabled. Your hardware costs have been reduced and you can probably also get away with less colocations but, now you have to pay more for developers. A team of developers that can manage all that isn't going to come cheap.
As someone who has developed in Javascript since the year it debuted, you can pry babel from my cold, dead hands.
&gt; you are by definition forced to "code to an interface" rather than directly calling SQL on your DB JS doesn't have interfaces, there's no "coding to an interface" in client-side rendered apps. There is nothing stopping me from doing `var xhr = new XMLHttpRequest();` right in my client-side template code. This is 100% analogous to doing `$pdo = new PDO("mysql:host=localhost;dbname=foobar", 'root', 'password');` in your server-side templates. &gt; This means your UI can be tested in isolation from the DB by mocking API calls That is not at all guaranteed merely because it's client-side rendered. If you're doing raw `XMLHttpRequest()` right within an Angular or Vue template or even React JSX, you aren't going to be mocking API calls, and you're really not going to be able to easily unit test that logic *anyway*, since it's baked into the template. &gt; This co-mingling cannot occur in client-rendered applications. Again, false: &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;Foo&lt;/div&gt; &lt;script&gt; var xhr = new XMLHttpRequest(); // etc..... &lt;/script&gt; &lt;div&gt;Bar&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
Interested in knowing what was melting, and why.
Thought process when viewing page. 1. Hey, this is pretty neat. 2. Am I the only one trying this, because it's pretty snappy? 3. Is this a lie? It's low frame rate video, so does a selection just swap out several images? I accept that this works and is pretty neat. Good job. 
My statement still stands - you aren't talking about scalability - you're talking about responsiveness. Either your user is going to watch the loading bar in the browser for server-side rendering or they could watch a client-side loading screen. Choosing a singular bad example doesn't really prove your point - I could find some very poorly performing SSR websites that take FOREVER to do anything. That website is probably so slow because their development team didn't focus on responsiveness or have TOO much code to load. With CSR (once it's loaded) it's easier to be responsive because you can take what the user requested and instantly update the UI assuming what they did was allowed (in the rare chance it wasn't allowed, it can be undone). You can even have lazy loading with CSR. With SSR you have to wait for a server response until you update the UI. With CSR you can create offline-capable applications and with SSR you can't. 
I never said it was a magic bullet - I simply said "[SSR] is not as scalable" - that's it. 
&gt; If you're doing raw XMLHttpRequest() right within an Angular or Vue template or even React JSX, you aren't going to be mocking API calls You can, just need to use a testing framework which monkey patches XMLHttpRequest.prototype
Off-topic but it would be pretty hard to get a more clickbait title :)
How do you achieve monkey patching in PHP in a codebase that uses mysql_* functions? 
Using this: http://php.net/manual/en/function.runkit-function-redefine.php
Very Cool!
I don't use vscode, but a useful feature might be to make it try to put the import in the alphabetically correct spot at the top of the file. Also, how slow does this get for larger projects?
We are refactoring our application from Angular to Vue. It's been a lot of fun to learn and I love the similarities it has with Angular. I recommend learning it. Egghead is forecasting it to be very popular in 2017. Guess we'll see!
&gt; Every 10th thread on this subreddit has someone making a comment about XYZ without really understanding the implications this is basically the entire site. the "well, what I think is..." crowd 
Brilliant.
Try this: http://up-for-grabs.net/#/
/u/zappsg's recommendation is a lot better, but for the purpose of learning, here's one way you could do it with some comments explaining how it works: function formatNumber(num) { // If the number is less than zero, make a note of this var isNegative = num &lt; 0; // Convert the number to a string with two decimal palces, // then split that string into an array of characters. If the // number was lower than zero, throw away the minus sign var tempNumArray = isNegative ? num.toFixed(2).split('').slice(1) : num.toFixed(2).split(''); // We're gonna keep track of the period so we know not to add commas after it var dotIndex = tempNumArray.indexOf('.'); // The number of digits to the left of the decimal point // is 3 less than the length of the array var integerCount = tempNumArray.length - 3; // Map over every digit in the array var formattedArray = tempNumArray.map(function(digit, index, arr) { // Check if we're in the whole digits var isBeforeDot = (index + 1) &lt; dotIndex; // If we're in the whole digits, check if the number of whole digits still left to go % 3 is 0. // If it is, we need to add a comma, so we'll return the current digit plus a comma. if (isBeforeDot &amp;&amp; (integerCount - (index + 1)) % 3 === 0) { return digit + ','; } else { // Otherwise we just return the digit. return digit; } // Join our newly mapped array back into a string }).join(''); // If our number was negative return it with a minus sign in front, // otherwise just return the number return isNegative ? '-' + formattedArray : formattedArray; } Then, to use it, you'd just do: `"$ " + formatNumber(var1 + var2);`
Also, I've been using GitKraken for my conflict resolutions. It's pretty sweet. 
Not yet. Although I recently moved to a country with mountains where winter sports are the major national pastime, so... maybe!
Please!
Your last paragraph depends on the framework and the developer of course. For Angular you can resolve dependencies in your route definition, which would block the loading of the view while your APIs return the data. To a bot this would look like a loading page until the data loaded completely. When the view loads all of the data would be there, no spinners. Obviously this depends on a fast API so that the bot doesn't get bored and move on. The other way, like you eluded to, is to load the view with spinners in certain areas and perform lazy loading for the necessary data. Bots might not like this because they would get a valid HTML layout but no content. I believe Google still waits for some time to make sure the page isn't changing. As a fallback you can always use a prerender server to take snapshots of the page for the bots, but I think this option is falling by the wayside.
The initial load for a SPA is often relatively huge, JS bundles are easily larger than some HTML file. 
You don't lose the power of using long clear class names with css modules. Instead you can use a name that is clear in the local context instead of being clear in a global context which I think is a big win when it comes to clarity. Also without CSS modules you have to pay for the long class names in production. It really adds upp when using BEM style naming convention in big projects while with CSS modules we generate 5 character long class names for production. It saves quite a lot in both CSS file size and our server rendered React document.
Assign all properties to a single object, then at the end assess what you need. 
woops yarn doesn't fit in there. JSMake was the npm build tool to use before grunt was popular. Those are all tools I've used to build/concatinate css/js over the years, In order of the years I used them. I'm tired of learning new tools.
You set it up once, then copy the config per project. Such a small investment for so many added features.
And how is this different/better with server-side rendering?
Good suggestion. Currently it just adds it to the bottom of existing imports. There is a small slowdown at the beginning, because all JS/JSX files are parsed with babylon, but it isn't drastic, because only one file at a time is actually parsed. On my fairly large project with like a 1000 JS files it is under 1000 ms on my Intel core i7-4770 workstation. I tried parsing 120000 JS files in my node_modules, that took still under 10secs. After that initial work, internal VSCode watcher is utilised, so any changed/added file gets parsed. Unless the files you work with are huge(like 10000 lines plus), you should not have any problems even on oldest mac air.
Lol where have you been
One question.. why are you making this as a bunch of functions that return a character, rather than making an object literal and referencing characters by the hash code? Both would be just as discoverable by auto-completion and you can `freeze` the object to make it immutable. Smaller code... and I can't imagine there would be a performance penalty for property reference over method reference.
why not use `i-=2` and skip checking if `i % 2 != 0`? not to mention that this is a simple arithmetic series and can be calculated with: function sumOfOddLessThan(n){ n = n % 2 ? n - 1 : n - 2; return (1 + n)/2 * (n-1) / 2; }
Neat!
Cool stuff, dude! One thing I would like to have is, if the keyword follows 'import', e.g. `import Mo`, then it should replace the current row with `import Modal from '../../src/modal.js'`. Even if it doesn't wrap it with {} for named exports, simply selecting the whole word in the last step would be awesome.
I haven't thought about this usecase at all. Issue [noted](https://github.com/capaj/vscode-exports-autocomplete/issues/3). Thanks! Will fix in version 0.2.0
"I hope you have fire-tested this against the thousands of possible script injection attacks out there." I don't think that so many vulnerabilities can be there: 1) anything inside ${} is interpreted by javascript engine 2) no any eval with parsed data, including caching "Your own tests show jsx with much better performance." Just 30% faster. It is a cost of run time parsing. I think it is acceptable in some cases. "How do you use your system to create whitespace collapsed dom?" There are no white spaces between elements. White spaces inside text or between text nodes and elements remain unchanged. I do not think that whitespace collapsed dom is the task of this engine. On client no matter white spaces. On server you can use any tool for this task to resulting output.
If you need features from ES2016, ES2017, then surely. But if you are enough features from ES2015 you can remove transpilers in the near future. I think, it is always possible to find a replacement of not implemented feature.
I have started using Vue 2.0 and I love it. Clean and simple API, clear documentation. Good router, redux style store, time traveling debugger, server rendering/data prefetch, hot reloading. This is a really good sample project (hacker news clone in Vue) See the code, and think about how you would do it in react or any other framework. Judge for yourself. https://gomix.com/#!/project/vue-hn
Yes, what I meant was using the same Model definition in the client, and the decorators will be handled differently to produce a REST serializer service. 
you can use shared models on the backend and frontend, however they dont do anything. The key is to configure your webpack/systemjs properly. I didnt get completely what your idea is, but I appreciate if you describe it in more details, or maybe create a github issue in our repository to discuss it collectively 
&gt; Should I download from that site or is there an official one? This looks very fishy! [Read about JavaScript and how to use it here](https://developer.mozilla.org/en-US/docs/Web/JavaScript) [Check those editors if you don't want to use Notepad](https://www.elegantthemes.com/blog/resources/the-11-best-code-editors-available-in-2015)
Of course its going to be the morse code for Hitler did nothing wrong
released
&gt;Interested in knowing what was melting, and why. "We stuck a RaspberryPi in an old traffic light, put a node server on it, and let you control it through your browser!" Kinda writes itself :)
It's built into JavaScript already. By default it tries to detect the client's locale and uses this. You can force it, if you want. [See here for details](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString). var number = 1234567.89; var result = '$' + number.toLocaleString('en'); //force to comma as separator http://codepen.io/anon/pen/woYaep?editors=1010
 setInterval(function(){$('.light').trigger('click')}, 100) Disco!
Hmm interesting... I really liked this idea. Do you have any other resource I could read more about this architecture? 
Client-side rendering in 1996? All I remember was doing mouseover image changes.
I feel uncomfortable when I see this with no clearInterval in sight. 
I'm just saying it is the most bodgetastic thing I've seen in a while (oh, and add adobe flash to the stack for the vid)
In 30 minutes or so you'll start seeing people in the background, getting popcorn or just walking around. You may be the only person sometimes, it isn't as busy as it used to be
My example was off the top of my head but here is an article that approximates it: https://medium.com/sons-of-javascript/javascript-module-pattern-d6a418d11b41#.qc1riixjk.
Blame nest for the flash video, I'm annoyed that they still use flash aswell =p
Thankfully traffic lights are designed to direct most of the light forward. Our neighbors shouldn't notice unless they look in, and they know we're a tech company so they shouldn't be that confused edit: should also add that there aren't any Windows on the entire wall that the light is facing, so no worries there either
There's a hammertime endpoint, but it's not publicly available. It's triggered when someone says "hammertime" on our slack ;)
I love socket.io, and I'd love to use websockets, but sadly aws lambda/apigateway doesn't support them, and we were really trying to go serverless with this =p Looks like SI digital had the same problem we did, with people going crazy with it and burning out parts, haha A ticket system is something we've talked about, and we're implementing for our next web controlled project, but we just felt it was overkill here. Most people don't wanna wait, they just wanna spam the light
It's an Angular site that ranks well for their key keyword - The company name. Whether you like their design/content is irrelevant. 
It's not that I like the content or not...there is NO content on that website. And there is absolutely no reason why client-side rendering makes any sense in Sprint's case. I'm working on websites with thousands of pages of content, and that's the specific use case that interests me regarding client-side rendering, and the fact that it supposedly has already won. So do you have a real, big web site exemple where client-side rendering shines, and where SEO is good ?
When it comes to raw performance, reliability and scalability nothing comes close to Firebase. It's rock solid and can easily handle anything you throw at it. And I disagree it's expensive. It's actually rather cheap these days if you use their Blaze plan. Also, you can easily combine Firebase with RxJS and your JavaScript framework of choice to get reactive, composable datastreams all the way down to the UI. IMO it's the sweet spot you want to be at when making a real-time app.
IMHO, it was confusing for novice JS programers (which before webapps or server side js , most js programmers were) and there was no idioms to do OOP (every framework had its own way, its own object factory, class factory if they were into that, etc...). 
I was focusing on Python.
This is frowned upon, but cross site scripting might do the job for you. 
Source on Github: https://github.com/pakastin/redom-state
Could you share source code of it? Or describe how you did it? 
You could analyse the user agent in the server and respond with different JavaScript files. But I am not sure how reliable and the benefits of this solution.
Why do you need it to execute in es6 at all? Why not just have everyone download the es5 files? Is there something about performance you are concerned about?
Performance *is* a major concern with transpilation.
See current compatibility table http://kangax.github.io/compat-table/es6/ All latest versions of browsers and nodejs have compatibility close to 100%: Edge 15 - 95% FF53 - 96% Chrome 55, Opera 42 - 97% Safari 10 - 100% Node 6.5 - 97% Safari iOS 10 - 100% Chrome Android 6 - 97%
On the page is a link to the blog post I wrote about it, which has a list of ingredients (it's just a raspberry pi and a set of solid state relay switches), and also on the blog post is the [link to the code on github](https://github.com/flygoing/Trafficlight/blob/master/index.js)
setInterval(() =&gt; {setJust('red')}, 10) Then I died laughing
*can be a major concern. Always be 100% sure it's a problem for your users before optimization. 
While it's possible, I wouldn't recommend it. I'm not really seeing an advantage to that, and it's got some disadvantages: * It adds a ton of complexity, both to your build process (you'd basically need to build two versions), and to the code that the deals with the client (you've got to correctly figure out which version to serve, then serve the right version). If you get that logic wrong and serve the ES6 version when you shouldn't, then things will break. * Either you put the logic to determine which JS to serve on the client-side: in which case you're delaying your page load with an additional round-trip before you can actually serve your real JS: or else you do it on the server-side, in which case you're forced to have a server architecture, instead of just serving static files from a CDN. * Having two versions of your code running in the wild makes it harder to reproduce and debug reported bugs. It's the worst of both worlds, because you have to deal with both bugs in the non-transpiled code and also bugs in the transpiled code. And I don't really see any advantages. Maybe some specific features might be slower or more memory-intensive when transpiled; but if anything I'd expect the ES5 code to run faster, since JS Engines have had years of optimizations for ES5 code. (IIRC arrow functions, for example, are still slower than non-arrow functions) I'd really suggest just transpiling any features that aren't supported by browser versions that you need to support, and not messing with trying to serve two versions.
UPDATE: http://codepen.io/ryanmunger/pen/PbyGQP Hey guys. I feel like I am getting a lot closer with this technique. After zooming into the gif, I noticed it's just a bunch of little bars, that cycle through 4 shades (white to black). This code pen is obviously not very performant at all and has some issues with the timing of cycling through all 4 colors. I'm just wondering if there is any feedback based on this current implementation. Here are some things I am aware of: - Optimizing the effect to go full screen with it (maybe use canvas instead of looping through a bunch of divs using jQuery? (ugh, I know)) - Get the animation of each little "bar" just right, so that it doesn't reset. Notice all of the "lights" kind of go out at the end of the animation - Set variables to control the colors and speed Again, thanks for all your help. Learning a lot on this one!
Plugins like that already exist for Atom, from a quick search the [top four](https://www.google.com/#q=atom+import+autocomplete) results seem related.
There's [one of those as well](https://atom.io/packages/js-autoimport), though it seems to make my editor go crazy and open a bunch of random files. So maybe it's not viable
Sorry, I didn't mean to imply that you can't have descriptive class names with CSS modules. What I was trying to say was that IF you already have descriptive and "scoped" class names (eg. BEM ones) you no longer have the problem of "oh crap, one of my classes on page #1 just had an unexpected effect on page #55" ... which is the problem that CSS modules solves. So, you can totally have descriptive class names with React CSS modules, but since you can have descriptive class names *without* React CSS modules also ... why use them? But that's just my take on them: I certainly wouldn't tell anyone using React CSS Modules (with or without descriptive class names) that they're doing it wrong.
Think of the app that does your server-side rendering as another client app. It can consume the same REST API as the other client apps, and can probably share the bulk of its code with your current client-side web app client. Ideally, your server would render the initial view. Your browser could then display the page as soon as the HTML and critical CSS are loaded, and your Javascript could be downloaded, parsed, and executed in a non-blocking asynchronous way. That script could then "bootstrap" the elements already being displayed, and take over the routing and whatnot so that it is "upgraded" to a SPA.
Yeah one of the guys walked up to get coffee or something and I was hoping he would laugh at it as much as I was. I wasn't trolling by doing that just couldn't stop laughing at how responsive it was!
Great!
Is that website an example of what can be generated?
Looks like the endpoints are: Turn a light off https://jiy8fwbi1l.execute-api.us-east-1.amazonaws.com/prod/green/off Turn a light on: https://jiy8fwbi1l.execute-api.us-east-1.amazonaws.com/prod/green/just
This is awesome!
I'm lost
actually, most ES6 features that are implemented in browsers today are slower - often much slower - than ES5. it'll be some time before they reach speed parity across all browsers. V8 is still playing catch-up [1]. [1] http://v8project.blogspot.com/2016/12/v8-release-56.html
Sure, so you do the queries on the server and send back the data in single response. This is independent of where the UI template is rendered. But maybe I'm not following. 
That was pretty interesting, thanks for the link.
Correct!
To be fair this is the relaunch because after 2 weeks when we first launched it, it started smelling like melting plastic.
Where can I see release notes?
You want to be using feature detection, not browser detection.
Wat? I can't tell if this is serious or not. 
I usually don't like to brag about my own Framework ;) but as you mentioned, Feathers exposes real-time data as RXJS stream with the feathers-reactive (https://github.com/feathersjs/feathers-reactive) plugin and it is pretty awesome. You can watch a talk I did about it at https://www.youtube.com/watch?v=IOwilPI4LFg where we build a real-time voting app with Feathers and React from scratch (no generators) in a total of 140 lines of code for the server and the client.
Pretty cool, y u no websockets tho?
Impressive performance and polish. Thing is, trivial products don't expose flaws in the system. I could write the same thing in vanilla JS without feeling like I need a framework. While this is nice as an intro, a fuller example app would be much more of a selling point.
After updating my version of ionic I managed to get this running. Great little app, works for me and I like the way it was done.
The next step is to put it next to a road and let us control traffic.
Hi /u/delo007, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Also don't forget about babili, which will most likely become the defacto standard for minification.
? Bit confused by your comment sorry. Angular 2 was officially released months ago. 
My favorite script for it so far: var lights = ['red', 'green']; setInterval(() =&gt; lights.forEach(setJust), 100); 
Great plugin, thanks! Is there any chance you could make the same functionality work in typescript files (.ts &amp; .tsx) as well? 
Is this like Windows 10? What happened to 9?!
True. I'm about to include those [dispatch and listen](https://github.com/pakastin/redom-state/blob/master/js/utils/dispatch.js) functions to RE:DOM with documentation. This is just an example.
cliff notes: They skipped version 3 because the router is misaligned and at v3 so they're moving everything to v4. It's not like going to be a change like going from 1.x =&gt; 2.x
This is a clear indication that they want people to use angular's router. Which is already a big no no for me. One of the good things about ng1 was that you were able to ignore the builtin router. edit: that said, did not try the ng2 router yet. Could be good.
Great explications, thank you. Sorry for the late response, i've got some exams
How did you learn your first language? I'm not convinced that learning `js` is that much different than learning another language. Albeit some languages are not as simple and may take more time/work, but the process should be the same. So, basically just improve your learning methods from the last language you learned in any way you see fit... if that means watching tutorials on YouTube then go for it. btw, this guy does seem pretty entertaining.
Angular: Genisis
ok cool...
because aws lambda/apigateway doesn't do websockets ))= and we didn't want 1000+ people spamming our network at once so we set it up, basically as a proxy. plus lambda is super easy to use
we've had our fair share of discussions on this. these discussions usually end in it being a bad idea
Angular: The Revelation
Um, ya...
They aren't as caught up with making everything a pure function and trying to promote unidirectional data flow as much imo. Edit: To further expand, from my experience with angular 1 it felt like they made some poor design decisions regarding state and I felt like angular 1 wasn't a great production framework whereas react was. Haven't looked too much into angular 2, which I heard fixed a lot of state involved issues, but would react with add on libraries, such as a flux framework and/or react-router provide everything angular 2 does?
Chill out, guys. A breaking change ≠ Redesigning the framework from scratch. For example, jQuery had a breaking change from version 2 to 3, which was mainly with stuff like Promises, and it didn't break how you did things with it before.
Thanks!
Right, but they bumped 3 to 4.
&gt; Now I'm pretty tired of react and the bad steps from paradigms it encourages, like the merging of views, styling and logic. That views and styling belong together is only natural, I'd say. They're literally part of the concern: UI presentation. Still, you can easily keep your CSS separated, if you prefer. But either way, logic shouldn't be in there. Maybe if it's trivial UI logic (is this dropdown open or closed, to give an example), it makes sense to put it in the component, but domain logic definitely shouldn't be. But personally I don't see how React encourages that kind of mixing concerns. Can you elaborate on that?
As an React developer. Moving back to using loop directives and other shit from the past angular world (for me) gived me the creeps
Applying a similar solution to car accidents would be to outlaw cars. There's always risk/reward to technology, this seems like an overstatement of the risk. And the reward brought to the web via JS is pretty remarkable. Most people allow their browser to auto-update (to do otherwise would be *really* risky). "It's from a trusted source" you say. Well perhaps treating JS from HTTPS similarly is a more reasonable approach than to never run JS.
What are you specifically concerned about?
This scheduling seems silly to me: * patch releases every week, * 3 monthly minor release after each major release and, * a major release with easy-to-migrate-over breaking changes every 6 months. They did the same thing with Nexus &amp; Pixel phones - deciding ahead of time that they would need monthly security updates. I think it makes more sense to push out security fixes depending on need. Actually, same goes for all types of updates - **it's ridiculous to put out a 'major release with breaking changes' every six months just to stay on schedule**. I realize that enterprise customers want a schedule and no surprises, so many companies are doing this, but there has got to be a limit.
Running entire asset pipeline through webpack and spitting it out into a single js file to be downloaded on every page. Cool!
/u/devils_plaything's answer looks to be a good translation of your code. Alternatively, I think the following works with some performance gains. function sumOfOddLessThan(n) { return Math.pow((n - (n % 2 === 0 ? 0 : 1)) / 2, 2); } Edit: Funky version, just for fun. :) function sumOfOddLessThan(n) { return (n = (n - (n % 2 === 0 ? 0 : 1)) / 2) * n; } 
I use create-react-app and tear out the React. The Webpack setup they have going is great for one-off projects. Edit: react-scripts without react
Oh joy of joys. Been looking forward to this. I assume typescript typings are included as well? Can't wait to fire this up. Been evangelizing typescript/rx combo to every dev I can.
This is incomparable. jQuery doesn't release two major versions per year, jQuery is also not known as jQuery 2. It has always been known as just jQuery. There are thousands of Github repositories, books, conference talks, Tweets and more refering to the new version of Angular as Angular 2. It seems to me the Angular team really didn't think anything through, the design-by-committee approach they've taken has really come back to bite them. Angular does a good job at pretending to be an open source community project, but really it is closely controlled by a handful of core team members.
&gt;It’s just #angular” &gt; &gt;Also, we should start avoiding GitHub/NPM libraries prefixed with ng2- or angular2 No, no it is not. Angular 1.x is still in use by *many* companies, and will be for a long time. The new Angular team wanted breaking changes - fine - but don't clusterfuck everyone by suggesting it's all angular, because there are clearly two distinct frameworks called Angular, one has been around for years and is the *real* Angular, and the other is *very* different and shouldn't even be called Angular. They even expect you to use Typescript, so no, there isn't one Angular. It seems the new team wanted to ride the coat tails of Angular 1 to gain popularity. I'm not sure that plan is working for them, so now we're being told this BS.
Before we made it public we used it for stuff like when you started the popcorn maker/coffee machine (we hacked them to collect usage stats)
The Fate of the Angular
Yes, I agree that you can most likely build two apps that are functionally similar with either angular, angular 2 or react w/ bells and whistles. It would be overly bold to say that you could only build X with react and not angular or vice versa -- where there's a will there's a way. Certain frameworks may enforce, or encourage, specific ways of writing your program, for instance unidirectional data flow, but you could write an angular1 app with unidirectional flow if you wanted. It just that certain ways to architect your app may not be obvious with framework "hints". I think the main differences between angular and react is that angular aims to be more of a platform whereas react is more an ecosystem of relatively disjointed libraries. I think it's a matter of opinion as to which is better in that respect. Another difference is that angular toolchain is more "complete" in that the `CLI` provides bundling and compilation. And I think the compilation factor is underrated. Google has been building JS compilers for years with Dart and the Closure compiler as examples. I have a high degree of confidence that as the ng2+ compiler matures we will see production code that consistently becomes more and more optimised. 
I'm confused... why would it be harder to "figure out" angular1 dependencies?
Thankfully us front-end developers have never had so much choice and say in what we decide to use. I think this is the final nail in the coffin for Angular, developers abandoned it in droves for React when the Angular 2 syntax was revealed and now we have yet another reason to consider using something else. Maybe it's time people start exploring other options like Aurelia. The Angular team has made it quite known they are a design by committee framework, what the community thinks &amp; wants versus what the core team deems to be best are two different things. Two major breaking change releases per year is going to make this a framework that enterprise will think twice about using.
Best tech post I've seen in a long time. And I don't even know React. But the writing and the reasoning were a cut above. Thx,
Yes, that is going to be a terribly hard thing to figure out thanks for clearing it up for me! I was under the impression you were talking about the framework dependencies, but I see now that you're talking about 3rd party libraries/modules. I imagine they'll have to clearly state dependencies and support breaking changes -- unlike angular 1. On the bright side this change might be able to help you determine active maintenance. 
&gt;1: Multiple simple components are better than one highly customisable one So follow the Unix philosophy 
Google doesn't seem to like the version number 3. They messed with it on Android too! :P
I need more minutes in the day to finish these egghead videos. 
Ah, yeah [that](http://imgur.com/a/cGg8G) will do it. 
Ah, sorry about that. I changed it and forgot to update the readme.
Hi /u/shahad1990, can you be more specific? Creating an animated gif has nothing to do with JS and HTML at all.
Not sure what you're asking, but you can put your code in a function and call that twice, or, if you need two separate environments, you can run your code in two different iframes.
Try touch events.
The issue is Google has failed, unsurprisingly, at their attempted rebranding. Official documentation from them says angular 1 is now officially Angularjs and what we've been calling Angular 2 is officially just Angular. But good luck getting a huge existing ecosystem and developer inertia to make the switch to the new official naming convention
Well the link pretty much sums it up.
Exactly. Angular 1 and 2 have in common the name, and that's about it. I find it amusing that the core team is QQing because muh ng not ng2. I don't know if they have any idea of the reality of companies that currently use Angular. I have yet to find a single startup in Paris that actually uses this framework. Big companies, on the other hand... But they'll switch frameworks once every ten years.
Well it makes sense I guess. Nobody complained when React went straight for React 15. It's more fuel for the already well-stoked anti-angular train though. 
yeah but `don’t worry about version numbers` 
Angular uses it for their event system. I'm sure rx is going to be gaining a lot of popularity in the coming years. 
I'm calling it now: Angular 36 in 2020.
You got example code we can take a look at?
OK. But what about console.log("Happy cakeday!":-)?
Check out vuejs.org. It is basically "angular 1: the good parts" + "react: the good parts"
[Citation needed] Also, worry about performance on a case by case basis. Optimize your hotspots. Don't worry about the 99% of code that runs .01% of the time.
I don't think jumping to 4 is particularly a problem in itself. React has at least remained consistent in theme and overall approach. Angular 2 is 100% a different framework, so there is a bad taste in people's mouths from the 1-&gt;2 jump. So naturally people see "Angular 3 already? WHAT NOW IT IS ANGULAR 4?" as work they're going to have to do. Additionally the Angular team has a horrible track record of breaking changes, and really has never committed to stability.
I worked on a small Vue.js project recently and it was fantastic, way better than React. Reminded me of Angular 1.x, but it wasn't horrible or confusing. Just straightforward code. I think what Evan has done with Vue is fantastic, one man against the establishment and he is winning.
It's a certain type of hammer for a certain type of nail. I agree with you though: If it came from FB, it would be a lot more popular (and a lot more misused IMHO)
Here's my "I'm a hipster" version: const sumOfOddLessThan = n =&gt; [...Array(n).keys()] .slice(1) .filter(n =&gt; n % 2 == 1) .reduce((r, n) =&gt; (r + n), 0)
Then you'd have even larger JS files. The trick is to separate JS and CSS files and have a corresponding CSS file each JS file you have, so it would be easier to reason with it. Most of the times you are either doing something functional (like playing with events or passing data around) or implementing styling, rarely you do both at the same time.
Not to mention googling **Angular ____ random question ___** will have all sorts of Stack overflow posts that talk about the OTHER Angular. Why commit to a bloated, slow, with an extremely unnecessarily and convoluted DSL. What makes me made about Angular is that they invent a whole new syntax and "language" which unlike learning a real language such as scala/python/rust etc. is only applicable towards Angular, nothing I HAVE to learn is transferable or advances my abilities as a programmer. All that effort to learn Angular for **ZERO** benefit! Angular is not faster(it's pretty slow), it's not lightweight(it's massive), it's not widely used so it's really nothing but technical debt and VENDOR lock-in. Angular **ONLY** benefits consultants, because once companies pick Angular they're stuck! And the DSL is bound to change which means more consultant fees as well as maintain legacy NG-Monotliths. People think "Ooooo but google makes it!". . . . yet Google doesn't even use it themselves. I am glad Angular has these public blunders since they're currently trying to trick the company I work on into using it. But there is already a rebellion brewing, because our developers know better. Monoliths are a mistake! Modular, portable and transferable code bases FTW!! 
That's not what I'm asking sir... I have already submitted what I have even though it was a broken code... I just want to know how to do it,, if you can recommend a video or a website to teach me how... I would appreciate it... thats the point of going to school is to learn... I have already attempted to talk to a atutor wasn't able to to help me lol.. Thank you kindly.
It is evaluated from left to right. a = null == undefined // true b = a == 0 // false c = b == '' // true, this is the end of your first example d = c == false // false, your second example To make it more clear, this is also the same way to read your example: ((((null == undefined) == 0) == '') == false)
typescript is a poison pill.
The problem isn't so much that Angular 2 is not Angular 1 - it's that Angular 2 practically goes hand-in-hand with Typescript, and the examples look foreign to people who are used to Angular 1 and ES5. Anytime I read an article about Angular 2, or read the code of a project, I pretty quickly close the window and go back to coding Angular 1 and Javascript. The Angular 2 team made a gamble and it's looking like they lost, bigtime.
That's why I use flow. Flow only does typing at my leisure, keeping Typescript's .NET ~~vomit~~ ideology away from my project.
&gt;Nobody complained when React went straight for React 15. Except the folks at Reddit, hacker news etc.
You should look into [TouchEvent.touches](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches) which is a pseudo-array of touch points.
Well `async/await` *transpiles* to a `generator function`, but in browser compilation is undoubtedly more complex and I think it's unlikely that the browser would transform `async/await =&gt; generators =&gt; compilationChain =&gt; native code`. I'd wager it just goes `async/await =&gt; compilationChain =&gt; native code`. Otherwise it doesn't sound like the browser implemented `async/await` at all... just generators.
I'm pushing myself into React imminently. These thoughts were very useful to me. Thank you.
Well even if you jump to React it will be very much the same as many React devs show examples with ES2015.
Hilarious. The issue here is that they: 1. Want to increment the major number for small changes, promise not to make large breaking changes, and believe that the major version number should be mostly ignored 2. Recently released a massive breaking rewrite that means major numbers need to be watched carefully. Both are good policies but *you can't do both*. Major version numbers are important or they aren't. If this announcement was from the Xangular team announcing that they were going from version 1 straight to version 3, nobody would care. if this announcement was from the Angular team announcing they were going from version 2.0 straight to version 2.2. nobody would care. Sorry guys, but after you pulled a massive incompatible rewrite, you have to start respecting major version numbers more. Facebook can get away with "React 15"; you can't. (Cross commenting from another thread about this.)
YES, THANK YOU SO MUCH!!
Last I checked, Google uses Angular for almost none of their public-facing products.
Interesting thanks for sharing.
Is that not what views and styling together is? (corresponding CSS file for each JS file)
to be fair, google has a hell of a lot of products
As a dev team who is still actively developing on Angular 1, this only further worries the future for the framework. Further fractured from the seriously shortsighted direction that Angular 2 tried to push the community towards. I have almost pure skepticism moving forward from this announcement. I wish I was excited. I really REALLY do. I understand the angular team probably worked a lot on this, but it's not a healthy direction for the community. It's NON-SUSTAINABLE for any sized company. Also quite hilarious that they have comments disabled on this post.
Another blog from someone faking it....surprise, surprise... Tip to you: You don't know what you don't know....everyone else can see it
Typescript has nothing to do with .net.
You'd be surprised.
[removed]
[removed]
This is just Brad Green wanting to live up to the sound bite "We may not ever need an Angular 3". or w/e the actual quote was
`EventEmitter, Router, Reactive Forms, http` and probably some others I've forgotten or haven't been exposed to.
&gt; We're using semantic versioning. Awesome!! Finally there will be an easy way to... &gt; We're skipping v3 ...
New wannabe developer here. I've been trying to learn Angular 1, but now... Eff it, I'll just try React or Vue. 
&gt;small Vue.js project I've heard this is what Vue is good for, small projects. It's easy to get up and running without unnecessary complexity. However as your project gets larger, more management is necessary. Has anyone used vue on a larger project that can confirm this? &gt;way better than React in what way?
You should call it Brendan, so that 5 and 7 would basically be the same version.
I think they want you to refer to v1 as Angular.js and v2+ as Angular.
Vue is a [one-man project](https://github.com/vuejs/vue/graphs/contributors). I think it's really bad advice to ask people to depend on something like that. What happens if the dude gets bored and decides to radically change or even scrap the whole thing?
Aurelia is another [one-man project](https://github.com/aurelia/framework/graphs/contributors)
"PHP Leonard" ? 
That is not necessarily a bad sign. It implies it has a single vision and is simple enough to be managed by a single person. Also: it's definitely not "design by committee".
Thanks for your hard work on Redux! I checked the performance gains - https://github.com/reactjs/react-redux/pull/416 - it looks like it's an order of magnitude faster And with no breaking changes in the API updating should be easy and pain-free :)
Not that it's reason enough for most, but React's license is not acceptable to many companies.
&gt; Nobody complained when React went straight for React 15. I did!
This article focused too much on the mechanics and failed to state clearly the fundamentals of why a proxy exists. Basically, from what I understand, the Proxy Pattern is a pattern that was presented in the GoF book on design patterns for Object Oriented Programming. In this case, the purpose of the mechanics is to allow us to be able to change the behavior of an Object Literal (treated as an OOP object) while keeping the original interface defined in the original Object Literal. The idea is that the proxy just defines an alternative behavior for each of its operations (methods) and that behavior can be plugged or unplugged without changing the structural correctness of the system. Someone correct me if I missed something.
I agree that it has its benefits, but I think that using a one-man-project with a low user count as the foundation of a (serious) project is probably not worth the risk, no matter how nice the framework itself is. 
Explain yourself
Vue/Vuex is a great alternative, not objectively superior. Checking it out and giving it a shot is definitely worth it, but let's not pretend it's simply *better*. The performance is great and they've made the learning curve as tiny as possible with their 'no build step required' -approach, but it's not like it isn't opinionated and require compromises for it's approach just like any library. It's also worth considering that while Vue 2 is picking up the pace quickly and practically every r/javascript thread is praising it, it's still relatively young even by JS standards. Whenever you introduce new parts to your application from FRP libraries to logging middleware utilities and whatever you might think of, there's a chance you'll have to figure it out for yourself with a framework that isn't so popular and widespread yet, while with something like React/Redux stack you've got a bunch of examples showing you exactly what to do. Don't get me wrong, I really like Vue, but "React: The Good Parts" is a little rich. It doesn't need a sales pitch, it's one option.
Awesome work! will roll to production immediately when redux-form updates its peer dependency!
[removed]
Exciting times for all us react+redux groupies. Even React Fiber seems to be getting close to be useful - http://isfiberreadyyet.com/
Hmm... I was more prepared to Half-Life 4 announcement.. not Angular 4... At least now I have a good reason not to jump in Angular 2 :)
From changelog and linked pull request, it seems they made old api completely backwards compatible, with testing in alpha version from June to today. So i assume, somebody would notice any breaks. Not tried personally yet though.
Did they learn nothing from the Python2/Python3 sham? Angular versioning seems like a nightmare from all the articles I see about it.
They do explain it in the changelog. &gt; Version 5.0 maintains API compatibility with v4.x but due to major internal changes and **potential behavior differences across nearly all API surfaces**, semver dictates a major version bump. &gt;... &gt; Store state change notifications sent to components are now guaranteed to occur top-down, so if **your code may behave differently** if it relied on notifications happening out of order. You could argue it was unintended behaviour nothing should rely on and there weren't any actual breaking changes to the public API, but I'm guessing they want to also play safe. Clearly this update has the potential to break existing applications. Obviously not every bug fix should be considered major because it can break any code that happened to rely on that specific bug, but perhaps the other extreme isn't good either. I don't know what exactly is the best practice here, but if the execution order changes in the most significant part of the API, I think a major version isn't unreasonable.
You can't instantiate an arrow function: const fn = () =&gt; { }; new fn(); // TypeError: fn is not a constructor My guess is that the Service() { } is converted to an arrow function like this: const data = { Service: () =&gt; { /**/ }, }; I'm not 100% sure though.
So the variable `step` gets its value from the code that runs it; &gt; var inc = createInc(5); Makes `inc` the function: function(step) { startValue += step; return startValue; } Where `startvalue`, in this case, would be 5. When we call `inc`, in the line &gt; inc(1) We are setting step to be one; and the line: &gt; inc(2) Sets step to be 2.
I don't think that's the case. `data.Service.name` returns 'Service' in both cases. Isn't an arrow function always an anonymous function?
What I could find out: If you output the first version on the console (in Chrome) you get `function Service() {}`. The second version outputs just `Service() {}`. Arrow functions on the other hand output `() =&gt; {}`. So there is indeed something different. (But I have no idea what it is) Another thing is: Shorthand functions are missing a `prototype` property. Constructors need it. But adding one doesn't make it a valid constructor though.
Thanks! Beyond the current workflow being tailored to a developer working with Node and the open-source command-line tool being distributed via. npm, the registry has been built with Node :)
Thanks for the post. As a react contractor myself I found this helpful.
Personally I'd prefer react motion or any other animation library over css transitions. Not because css transitions are slow, but because it's easier to read and easier to do physics bases animation.
In my example, the `fn.name` returns `'fn'`. We can not conclude that `Service` is an arrow function, but neither a normal function.
I think this is the bit that is confusing me - 'var inc = createInc(5);' Now, inc is assigned the value from the function call to createInc(). This 'value' is a function? Ahh, inc(1) invokes the anonymous function that was returned from the assignment 'var inc = createInc(5);' So inc is now a function 'function (step) { startValue += step; return startValue; }'
No, because with an arrow function `this` would be passed in from the scope at the point it's defined, whereas a proper method needs `this` to be dynamically set to the object it's called on, so it must act like a normal function in that respect.
 .ts Actually means totalshitstorm
Im in absolute agreement; however, not all applications need to be an RIA. If you're creating a basic CRUD system some pages could be dynamic (if needed for complex operations) others could be handled by server side rendering. 
Seemed closer to a 20s delay for me which sucked. Very nice and fun to play with though.
Recently? Nobody.
I'm aware of the difference between the two technologies. What I wasn't aware of, was that Opera also switched JavaScript engines. Oh, well, that's what I get for not researching before commenting.
Using flow is just about as wise as thinking .NET had anything ever at all to do with Typescript 
Hi /u/fagnerbrack, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
That's because it's more suitable for big companies. They want a framework that's backed by a large engineering company, doesn't matter if it's "the best" or not. Startups with less complexity will likely use a faster framework, as they also have less engineers
&gt; Multiple objects are better then one GodAlmightyObject
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 3950 times, representing 2.8241% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_db6owm3)
So there is only Ember left as stable enterprise framework. Shame. But I do hope that Vue will get some everything-and-kitchen-sink addon that will pick up some of Angular's disappointed community. Or maybe Aurelia. Or maybe enterprises will finally embrace React in full. Can't wait for any of those. Because reading OP is just so bizarre.
Because that won't confuse anyone. 
Yeah, it seems like they've given us a longer delay =/ maybe because our stream has gotten much usage
Classes do have `[[Call]]` (otherwise they would not be reported as functions in `typeof` and `Object#toString`). See step 2 of https://tc39.github.io/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist
How does compiled HTML stand up to JSON after gzip has had its way with them?
From a development perspective MS have definitely been turning it around in the past few years (VS Code, Edge, supporting TS) but I think the stigma is still definitely warranted. Personally had no idea Reactive Extensions was an MS project! And I have known about it for a while now. Hopefully solid MS-backed products like this and TypeScript keep flowing and they are taken up more by the community. I feel like TypeScript is the best direction for JS - gets rid of some of the "toy language" stigma and makes JS development more familiar and safer for those who come from a CS background.
I ran my personal site as a client-side JS-built SPA, and as a compiled set of static pages. Was ranked equally low both times, so, yes :p
That's a good question, and definitely depends on several factors. You often don't have repitition in JSON but most definitely have it in HTML. Depends on the complexity of the components being rendered.
Really good explanation, thank you!
Great contribution. What a thoroughly practical and honest approach.
It's backwards compatible in that the old behavior was [considered a bug](https://github.com/reactjs/react-redux/issues/292) and most people probably never ran into it. In the rare chance that someone's code actually depended on this incorrect behavior, this upgrade would break them.
&gt; I guess the diffing of real DOM to make VDOM is more expensive than starting fresh? Kind of like inheriting someone’s legacy code! This may be true in some cases, but certainly not all. Hydration typically assumes that the provided html already matches the vtree built from the provided data/state. So it simply needs to traverse both simultaneously and link them together. While doing this it may also attach event handlers. This process is very fast if done correctly (a few ms) even for trees with thousands of nodes. Usually the overhead in SSR is in *additionally* transferring the dom-generating app code, data/state, parsing it all and regenerating the vtree. The hydration itself should be the fastest part of the whole thing. As a side note, the code used in the vanillajs example [1] is not ideal. Using `querySelector` thousands of times will be much slower than simple dom iteration with an assumption of a matching vtree structure (hopefully no libs actually hydrate using dom-querying selectors). `addEventListener` thousands of times will also be much slower than using event delegation. Neither of these invalidates the main points, but the timing disparity would be significantly different. For pure CSR apps, a big problem is that any resources that must be fetched cannot be fetched until the dom is created and the `&lt;img src=""&gt;` elements are inserted. This causes FOUC [2] which is very noticeable and annoying. It should be easy with a bit of work to preload the images before rendering the full vtree to the dom. [1] https://github.com/GoogleChrome/sample-framework-boot/blob/master/src/vanilla/app.js [2] https://en.wikipedia.org/wiki/Flash_of_unstyled_content
Have to say I love nodejs as well, but I think the point of trying to sell it based on the fact that it's essentially JS and thus front end developers should like it the most is a bit misleading. 90% of what you do will be async, understanding server design, understanding differences between client side environment vs server side, etc and thus you'll be learning tons of new methods/design anyways (so the benefit of a similar syntax kind of goes out the window short of standard sorting methods, etc). There's a great ecosystem though and the convenience of npm (and thus the ability to easily pull in any resource you want) was what sold me on it very quickly. I also appreciated how similar developing front end assets vs back end is; need to know how your build is config'd? Start with package.json =&gt; look over any custom scripts, go to other pointing files, etc (my point is; the whole project structure is designed so essentially all developers are intentionally forced in to a similar semantic design pattern [at least for the start of any application/etc]). Our entire front-end is slowly converting to node (primarily as our task runner), but the back end is massive and thus will be much slower to switch over to any new tech unfortunately.
Basically, when in doubt, always bump the larger number. 
Any effort at all put into accessibility?
And has full-time Patreon support (plus the community).
Could you elaborate what you mean by this?
Forgive me if I'm wrong, but is this really what metaprogramming is? Isn't this just the details of javascript objects and how you can manipulate them?
I think OP would say Angular.bs
Are you serious mate?
Thank you!
I did, but like, eight years ago.
that is completely badass! Cheers to whoever built that
But it would appear that that number will likely decrease instead of increase. In other words: it's not unthinkable that lots of people will will abandon Angular, especially if you need to update all your projects just to be compatible with the current state of Angular. Just like there used to be a lot more extension developers for Firefox than there are now. 5at least: plenty of add-ons have been abandoned.)
Thank you!
As someone who flips between ng1 and ng2 inside a hybrid app, I have never had this problem and don't see why it would be any more difficult in the future. I just read the README files.
Definitely. I'm referring to Accessibility with a capital A. Users with disabilities, primarily. I've started a critical project at work with Vue JS, and Accessibility has become an important facet of what we do. There are no VueJS component libraries that consider Accessibility, and frankly there aren't very many UI Frameworks in general that do either (just adding aria tags isn't sufficient).
I view this as being more of a way to rapidly move beyond Angular 1 expectations. Angular 1 served a need in 2013 but the past few years have seen rapid progression and I feel like I'm one of the few people who can see why Angular 2 and beyond would want to evolve with other frameworks.
I was on the same boat, but after being somewhat-forced to consider Typescript, I'd advise that you give Typescript a chance. It encourages patterns common to stricter OOP languages, which I view as positive for front-end web development and it helps front-end dev be seen as less of the step-child of "real" development. Also you can throw "&lt;any&gt;" in front of most variables to make TypeScript shut up or just write what you want in JS still.
I agree. Still… BECAUSE it's so completely different from what Angular 1 was, it should've been named something different to avoid confusion and set appropriate expectations. 
You think nobody has told me "give typescript a try" before? Do you think anyone has told me "give coffeescript a try"? No, I don't need or want transpiled languages. I am perfectly happy with javascript, dynamic typing, and not chasing new/shiny. I will wait out the typescript hype, just like I waited out the coffeescript hype - by developing awesome things with *javascript*. I'm really not interested in anything typescript brings with it. I've already done plenty of javascript with static typing and classes over the last 15 with Jscript.net, and I've seen plenty of typescript to know it's not for me. So, thanks for your advice but I really don't need it.
That looks really good. 
Order No.: 2WJ-uu22591b1b-fp7 Seller website: leistung-erfolgreich-optimieren.de Payment Date&amp;Time: 2016-12-01 02:35 Amount: 49.27 EUR Payment No.: YKF1612010236173743 What happens with this?
You are confusing two different types of components. Presentational components should *never* be passing data around. That's what Containers are for. Properly separating your logic from your presentation should make your components small regardless of whether they have styling inline.
You're probably right. All the same... TypeScript: Making .NET Developers Comfortable with JavaScript https://msdn.microsoft.com/en-us/magazine/jj883955.aspx
Again, keeping in mind that these semver changes are really stupid, why is it 'likely that the users will decrease instead of increase'? I'm currently learning Angular v2 very in depth at the moment and I find it very pleasing to use. I think something people are seriously forgetting in these discussions is the fact that you simply don't have to upgrade your project if you don't want to. So what if I push an Angular v2 project in to Production this month, and then in Q2 2017 Angular v3 rolls out? I'm not updating that project until I'm ready. I really don't understand why that's an issue. Also they explicitly say in OP's article that these increases in major versions are related to breaking changes, but they could simply be a few methods or interfaces in an @angular/core module being broken. That upgrade path would take half a day at most, and as the article also states, Google is gearing up to release automatic updating tools to the public. Edit: Other frameworks and libraries (*especially* JS ones) have played fast-and-loose with semver for quite a while. Ember.js 1.0 to 1.13 has so many project-breaking changes it was essentially a new framework with new engines three times over, and people DID complain about that too. I think, in a weird way, it's admirable that they're actually taking semver seriously.
No it's not. Angular is angular 1, and angular 2 is whatever else is shit out
Like in politics, theres some 'necessary evil' that comes from multiple strong contributors to a project. You should be more concerned about whether your developers, when reviewing the code base, find the patterns and documentation acceptable. You're always allowed to fork things these days.
anytime I read an article that has a compile step, I ignore it.
vuejs has tons of chinese support 
I would say you basically have no upgrade path.
They use it at Netflix along with React + Redux https://www.youtube.com/watch?v=AslncyG8whg
quasar framework is extremely easy to get a sense for how well vuejs integrates. http://quasar-framework.org/
SEO is dead
Hi /u/Thenewguy0322, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your homework for you.
Acessibility for new users to vue, using component frameworks, documentation.
*googles question about vueify* Google: "Did you mean vuetify? Showing results for vueitfy instead" *googles question about veutify* Google: "Did you mean veuify? Showing results for vueify instead"
On the homepage you have flash of unstyled content happening, any way to fix it when using SSR?
long live SEO
Menu does not scroll on mobile. 
You are correct, this is not 100%, and I should better set expectations for that. I will be working diligently to make sure Vuetify meets material design spec before 1.0 release. 
What phone are you using?
Really? You really don't see the potential for people to get confused when searching for "Angular" tutorials, resources, etc? :\ I'm fairly familiar with both Angular 1 and 2 and I find it confusing, especially when it comes to Angular 2. I've tried building a few Angular 2 POCs over the last 8 months and each time, I've run into obscure issues because what I was looking at didn't really match up to the version of Angular 2 that I was using. Feels like it ends up being a game of "ok, whats changed?". Can't imagine what it's like for new comers. Really feels like the Angular teams burning a lot of bridges in the community.
&gt; Store state change notifications sent to components are now guaranteed to occur top-down, so if your code may behave differently if it relied on notifications happening out of order. Seems that the only way one's app will break is if it has massive built-in race conditions.
Yes, but I removed it's implementation before this announcement as I was not happy with how it functioned. The reason you see a FOUC is due to the deferred loading of styles. This is for better page speed scores, but can be unsightly on initial render. I am working on a better solution to offer in lining of critical styles to avoid this, in the mean time, you can simply move the css files in src/index.template.html from the noscript tag into the head.
&gt; this.greet = this.greet.bind(this) This is actually useful if you plan on using that a callback for an event listener you plan on removing later on. I found that concept frustrating a couple of years ago trying to remove an event listener, thinking: this.greet.bind(this) === this.greet.bind(this) would be true, but it's not since every time you call .bind() it creates a new function in memory. Looking back, it seemed like a stupid assumption on my part, but at the time, I thought Javascript would magically hold that reference in memory. Also, since .bind() is creating a new function in memory, it can be a relatively expensive call. If you're going to use that reference more than once, it's better to cache it anyways.
I'd much prefer to directly declare the action on the component rather than tying them together via an error prone css-selector string. I suppose you could create a constants file for all your classes and use that in both the actions and the view (you would have to if you use css modules.) But it just seems cumbersome compared to declaring the function on the component directly.
I feel like reading this code is good for devs who aren't familiar with streaming data and range headers, but I'm pretty sure you can just use serve-static for this just like you do for other static data and it will automatically handle everything for you, including range requests.
What does "with a capital A" mean in this context?
I dont see why would this be more error prone than defining it directly, can you elaborate on that? There is a good explanation of this issue in [Cycle.js documentation](https://cycle.js.org/model-view-intent.html). I'll copy/paste it here. All of this stands for Recycle as well: Some programmers get concerned about DOM.select(selector).events(eventType) being a bad practice because it resembles spaghetti code in jQuery-based programs. They would rather prefer the virtual DOM elements to specify handler callbacks for events, such as onClick={this.handleClick()}. The choice for selector-based event querying in Cycle DOM is an informed and rational decision. This strategy enables MVI to be reactive and is inspired by the [open-closed principle](https://en.wikipedia.org/wiki/Open/closed_principle). Important for reactivity and MVI. If we had Views with onClick={this.handleClick()}, it would mean Views would not be anymore a simple translation from digital model to user mental model, because we also specify what happens as a consequence of the user’s actions. To keep all parts in a Cycle.js app reactive, we need the View to simply declare a visual representation of the Model. Otherwise the View becomes a Proactive component. It is beneficial to keep the View responsible only for declaring how state is visually represented: it has a [single responsibility](https://en.wikipedia.org/wiki/Single_responsibility_principle) and is friendly to UI designers. It is also conceptually aligned with [the original View in MVC](http://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf): “… a view should never know about user input, such as mouse operations and keystrokes.” Adding user actions shouldn’t affect the View. If you need to change Intent code to grab new kinds of events from the element, you don’t need to modify code in the VTree element. The View stays untouched, and it should, because translation from state to DOM hasn’t changed. The MVI strategy in Cycle DOM is to name most elements in your View with appropriate semantic classnames. Then you do not need to worry which of those can have event handlers, if all of them can. The classname is the common artifact which the View (DOM sink) and the Intent (DOM source) can use to refer to the same element.
I'll have to spend more time with it at home, but first impression on mobile was not very good. I did not see any mentions of ssr support or seo specific optimization. 
Why?
Regardless, you should be using a class in every place where you were originally using constructor functions: const data = { Service: class Service { constructor() { /**/ } } }
Xsl is really great! Great idea
ramda is awesome.
it's more error prone because there is now a string linking actions and view that needs to be updated in two places. Passing functions to components makes it so you can modify your view without ever having to modify your actions. Probably not the biggest deal in the world but it feels a little off. I would prefer if actions were passed into the view as an object so you can attach them that way. even if they weren't the actual function, but rather just an object of 'action binding identifiers' or something like that. I don't really buy the reasoning that cycle docs give there. If all actions are bound to css classes, and those css classes are defined in your view. Then your view defines behaviour. The fact that you've put a string in between the view and the behaviour doesn't seem like it should matter.
Yep that worked perfectly, thanks. The [original script](http://userscripts-mirror.org/scripts/review/167800) also showed # of imdb rating votes right beside the actual imdb rating in a bracket but it got taken out in the modified one I posted above for some reason. Do you know how to add it back in with your script above? I know this line would need to go below line 34 but I don't know how to change line 39 to match the one below like in the original. var votes = JSON.parse(result.responseText).imdbVotes;
If anyone wants to compare, run these through Chrome Devtools timeline: VanillaJS (does not build vtree, `querySelector` hydration): https://rawgit.com/leeoniya/sample-framework-boot/domvm/src/vanilla/no-ssr.html https://rawgit.com/leeoniya/sample-framework-boot/domvm/src/vanilla/ssr.html domvm (builds vtree, dom-traversing hydration): https://rawgit.com/leeoniya/sample-framework-boot/domvm/src/domvm/no-ssr.html https://rawgit.com/leeoniya/sample-framework-boot/domvm/src/domvm/ssr.html keep in mind, most of the initial loading delay is actually HTTPS negotiation and maybe some browser extension scripting (like uBlock origin, uMatrix, etc). reload the demos a couple times if needed.
Barely anyone actually uses TypeScript in a professional capacity. Learn about it so you can speak intelligently when people bring it up (which will happen), but I would not invest a serious amount of time in learning it if you don't see it solving any problems for you personally.
I'd argue that TypeScript is not very useful for most JS projects. Most of the time you just get data from an API and shove it into react, you don't do much manipulating of data.
Because this is /r/javascript, not /r/html or /r/html5.
Arrrgghh matey! Are you ready kids!? Whooooo lives in a trash can under the bridge? Trash can troll pants!
This one is especially self-righteous 
That looks nice. Can you hook polymer components into this? There are tons of them already made.
&gt; Are they trying to make Javascript a OO language like C# and JAVA Types aren't solely for `OO` languages... look at `Haskell` arguably the most pure functional language -- it has *very* strong typing. I struggle to think of a functional language that isn't typed. I know some will say `lisp`, but really a `lisp` can be whatever paradigm you want -- `CLOS` anyone?
Sorry for you :/
Just tried it again. I still cant wrap my head around how it handles CSS. From what I can tell, it still doesn't support the old paradigm of SCSS entry file goes in, CSS file comes out (not without what I would consider hacky workarounds). I really wanted to like it too.
Ah, I misunderstood. This is doing byte serving -- I thought this was using MediaStreams.
Maybe the article was edited but I noticed ramda and redux were mentioned, as well.
I'm probably in the minority but both my current and previous job use Typescript, even for non-angular projects.
NICE, time to UPDATE
TypeScript PM here - we are not trying to make JavaScript more object-oriented. The power of TypeScript is not in the object-oriented features (because those have already been brought into JavaScript). The power of TypeScript is in the type system, which gives you safer checked code with great tooling. That means that TypeScript is a powerful tool regardless of if you use OO patterns or functional patterns. In fact, in our compiler, we use **almost no classes** - it's written in a functional manner that makes the most sense for us, and we reap all the benefits of the type system. As for who's using it: we have [an page of users](https://www.typescriptlang.org/community/friends.html), but of course that doesn't include everyone (especially those who need to go through lawyers to publicly state they're using TypeScript). The thing is that TypeScript has been many different communities in the JavaScript ecosystem. You already know that the Angular community has adopted TypeScript and while I understand the apprehension, [I think that Angular 2 users have primarily viewed the decision as positive](https://twitter.com/robwormald/status/808764881587478528). This has certainly been the experience I've heard from Angular users. You'll also find many examples of TypeScript users in the React world as well - for instance, [Mobx](https://github.com/mobxjs/mobx) is an awesome tool written in TypeScript. Additionally, Palantir and Alibaba each released [Blueprint](https://github.com/palantir/blueprint) and [Ant-Design](https://github.com/ant-design/ant-design), two awesome UI frameworks. While not React itself, [Inferno](https://github.com/trueadm/inferno) is the fastest React-like library around. The Ember community has benefited from TypeScript in the form of [Glimmer 2](https://github.com/tildeio/glimmer), Ember's incredibly fast rendering pipeline. If you look at the Polymer team, a bunch of their new infrastructure and tools are built in TypeScript as well. [Aurelia](http://aurelia.io/), while not built in TypeScript, provides excellent first-class support for TypeScript users. I'll finish up mentioning [RxJS](https://www.npmjs.com/package/rxjs), which is also written in TypeScript, because they deserve special mention - they released RxJS 5 this past week. Congrats to them. :D I feel like I will almost certainly miss some users (and my bus ride is ending very soon!) - but really what I want you to take away from this is: * **TypeScript isn't about OO** * **TypeScript isn't about one framework** * While the JavaScript community is strong, **yes**, TypeScript has grown quite popular and has a strong vibrant community! :) 
You are right in that we don't create explicit separate only asset entries. Like @trappar said you can use a plugin however we know that the user experience is a pain in the ass. But now that we are on the verge of release webpack 2, we can get ready to make some breaking loader API changes for webpack 3 that will make it a way better user experience to create css bundles!!! If you want maybe some more info overall on concepts and such we created some new documentation that covers such: webpack.js.org/concepts
To be honest it takes a lot of composure to not burst out laughing on camera while people are making the light go crazy
I don't think this needed to be posted...
Dad get off Reddit!
Yes, we came to feel that our project was too big *not* to use it. We're writing all new code in TypeScript. We like it because the tooling makes it easier to navigate and refactor our very large code base and the more we use features like interfaces, the more obvious some code becomes to read (ie it documents itself better in some cases) Plus we can use some excellent features JS doesn't have or doesn't yet have (eg Promises/async/Object Rest &amp; Spread) without worrying about whether the browser supports it yet.
Maybe this will help. Webpack defines its first-class entities to be called "modules". Conceptually, modules are similar to "compilation units" in other languages. At the most basic level, Webpack modules are single Javascript source files in the CommonJS packaging format. That is, within a single source file "A", a programmer may assume that there's a global variable called "module", to which they may assign any value. When another file calls the function "require('A')", the object returned contains whatever was assigned to "module" in file "A". Based on this logic, Webpack can handle Javascript files by default, by transforming "source file A" into a single function within a larger file ("bundle.js") which *returns* "module" instead of assigning to a global variable. The insight is that file "A" doesn't need to start out as Javascript, as long as we can define a way to transform it into Javascript before it gets stuffed into a function inside bundle.js. This is the idea behind "loaders". They define a transformation from source file to Javascript value. However, that transformation need not be "pure". For instance, it may be convenient to insert the URL of an image file into our Javascript. To do so, we need two things to occur: * We need to assign the URL of an image to a Javascript variable * We need to ensure that at run-time, that URL resolves to the image we specify. For this, we need a "loader". The "file-loader" does two things- first, when a Javascript file calls "require('file-loader!B.png')", Webpack says "hey, file-loader, do what you gotta do with B.png and give me a Javascript value to insert in A." File-loader says, "okey dokey". It copies "B.png" to the output directory and then goes back to Webpack. It knows, because of invariants, that B.png will end up in the same directory as bundle.js, so it tells Webpack "okay! B.png is a Javascript module whose code is 'module.exports = "./B.png"'. Unwinding the stack a little bit, we ask ourselves, "okay, but how about CSS?" The black-magic here is realizing that to make "require('C.css')" make sense as a Javascript module, we can wrap the contents of a CSS file in a bit of Javascript that adds it to the page- and then run that bit of Javascript as soon as the page loads. However, this isn't fast enough for production, so a typical Webpack setup uses ExtractTextPlugin. It includes a loader which remembers which CSS files you've included, and a Webpack plugin which waits until Webpack is done bundling and then goes "oh hey! Take that shit outta bundle.js, I'll deal with it myself" and packages it into a big CSS file in dist/. Now that I think about it, it's not that straightforward... but honestly, if you're looking for simplicity in any build system, you need a new hobby. Best of luck!
That's actually a pretty good summary. Might be worth expanding that further and writing it up somewhere permanent.
You are right. I made the changes. (Seems can't do it to title). I will do the same changes in github. Thanks :)
It only continues if you ‘throw’ it, if you scroll to a halt it stop right there. Unless it's gamebreaking I'd rather not touch scroll behaviour as you're likely to break stuff. 
Are you sure that the issue is commonjs itself, and not rather the trend of exposing everything in the main file of the package? 
No, not the entire pipeline. Sprockets will still be there, yet! Of course we need this for Images. But I think they will not ship CSS with the JavaScript. 
As a Javascript newbie, what's the advantage of using webpack over browserify?
The design motto for ES6 classes was “maximally minimal”, for two reasons: To ensure no mistakes were made. And to get consensus in favor of this feature. For now, I either use symbols as keys for private properties. Or I prefix property names with underscores (relying purely on a naming convention without actually protecting them in any way). Improvements take time, a proposal for private fields is in the works: https://github.com/tc39/proposal-private-fields
No, it's really metaprogramming; Proxies enable you to “listen” to things like the `in` operator.
Thanks for the great reply :D What's the advantage of Reacts virtual DOM?
One example of what this allows you to do is dynamic imports (`import()`), something that iirc is only a stage 2 tc39 proposal and won't make its way to browsers for a while. This allows you to lazy load your app whilst developing apps in the same modern workflow.
Why would I upgrade from v1 provided that I don't care about tree shaking?
HTTP2 doesn't mean faster speed though. If you care about speed, bundling is still the way to go, you just need to change your bundling strategy. Instead of 1 big file, separate it into chunks. http://engineering.khanacademy.org/posts/js-packaging-http2.htm https://medium.com/@asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-http-2-437c37efe3ff#.m4fkxxhkr 
Composition over inheritance, example: a human being. Tens of trillions of cells mostly tightly coupled (sometimes extremely so, forming a [syncytium](https://en.wikipedia.org/wiki/Syncytium)), but some loosely coupled (esp. blood and immune system cells), plus slightly more bacterial cells (but they are several orders of magnitude smaller), all mostly loosely coupled with each other and with the human cells. Fast direct 1:1 and 1:n (with n being relatively low) signaling between *some* cells (through neurons), and indirect slow signaling on a global bus (all of the extracellular fluid - interstitial fluid plus blood plasma) and a few local message buses (local interstitial fluid, does not spread further because it's quickly removed). Recipients on the bus(es) check message signatures and only react to matching ones. Object factories that produce new objects (cells). A beautiful composition instead of one gigantic mega-cell.
Look at http://koajs.com/ (koa: successor to the Express framework). That's a node.js framework to write web servers.
Why you no prototype?
prototypes are for constructing objects, I don't see how they would give me the name of a variable or key in an array
Javascript does not have associative arrays, so you can't easily do what you are trying to do. We can however use Object.keys() to get an array of an objects and check for the value we are looking for: https://jsfiddle.net/gxvbszm6/1/ But we need to know which object to look in. After creation your bear object contains no references to ant, its simply using the strings as keys.
Nah, work on it today then push to prod tomorrow evening. 
You lost me at hot module reloading and treeshaking. Whatever happened to Gulp with babel and sourcemaps? I must be behind. 
That's what I'm saying. Also, I was googling "vue vs aurelia", and found out the Aurelia dev just started working for Google 2 months ago. If you look at the [commit graph](https://github.com/aurelia/framework/graphs/contributors), you can see that there's been almost no commits since October, whereas activity was regular before then. The entire project went dead once the dev got a new job. If not officially, then at least in practice. The very few commits since October have mostly been fixing typos and other doc. 
This is really nice. I'm not a fan of material but this is a great example of a framework and documentation done right!
What I see here rather is that you're trying to approach a problem with a wrong solution. There must be a better way to do it instead of reverse value-to-key resolutions. Because, you know, there's always a solution to every problem, it just might be not to your taste.
Can I ask what does treeshaking mean?
&gt; this heavily depend on your definition of "JS Dev". I guess you kinda have to include those who just glue some jQuery plugins together with a few lines of code. There are tons of very simple brochure sites and blogs. More app-like sites are a minority. Plain JS works just fine at that 50-200 lines of code "scale".
Iterate over files recursively in node. const fs = require('fs'); const path = require('path'); function *walk(root = '.', folders) { try { for (const file of fs.readdirSync(root)) { yield *walk(path.join(root, file), folders); } if (folders) yield root; } catch (error) { if (error.code != 'ENOTDIR') throw error; yield root; } } module.exports = walk; 
&gt; I would not invest a serious amount of time in learning it If you know ES6 and have used generics and types elsewhere, it doesn't require much time to reach a level where you can be productive. You basically just have to skim through the handbook and you're good to go.
Tree shaking is one of the techniques used to remove unused code from the final javascript bundle. It works by seeing which code you imported from an ES6-style module, and throws away the rest. For example, let's say you have an ES6 module like this: export logger = (value) =&gt; {console.log(value)} export otherThing = (stuff) =&gt; { .... lots of code } And you're going to use one of those functions in your own code: import {logger} from './theabovemodule' logger('Test') With webpack/rollup treeshaking, the `otherThing` function would not be included in the bundle. 
I have a theory that Vue has become self-conscious, and write all of these posts by itself.
Ah yeah, that happened last week right?
f is a function that returns an array (assumably of functions); so here, that function is returned and then executed. so the returned function at array index [1] of f() is executed and then logged.
I agree with alexontheweb, you could rewrite the function to instead return an array of all the matching keys, but I think a better solution would be to look at the shape of your data and use some that's easier to represent in javascript.
No. That's like calling someone that changes their own oil a mechanic
It calls `f`, then accesses the "1" property of whatever that returned, then it calls the resulting object, and passes the result of that call as an argument to `console.log()`. 
For further reference, see http://stackoverflow.com/questions/9907419/javascript-object-get-key-by-value
&gt; I haven't seen the need to look at anything else Then don't :) If you have a setup that's working for you, keep using it. gulp/webpack/whatever become useful at scale, not much for smaller projects.
Launching a dev webserver with hot reloading etc. is easier with these established tools I'd say. They do a couple more things out of the box with zero configuration. But I don't think there's anything wrong with sticking to npm scripts. There have been several articles about people doing the same. Whatever works well for you.
The reason why that book used an IIFE in the for loop is because **var** will always be hoisted up. An alternative to using a IIFE is to specifically create another function which returns a function. function f() { var result = []; function createFunc(i) { return function() { console.log(i); } } for (var i=0 ; i &lt; 3; i++) { result.push(createFunc(i)); } return result; } console.log(f()[1]()); To answer this question, I read the statement as: * f() - when invoked returns an array of functions * [1] - taking the 2nd element of the array * () - Invoking the 2nd element function of the array 
It might not, honestly. If you're not finding anything wrong with your tooling, there is no need to change it. The only point you should be looking at more advanced build tools is when your current tooling is becoming cumbersome. Personally I've used both gulp and webpack and then can be really helpful for certain things. I found gulp really flexible with slightly older code bases, can build pretty much anything, move it around, do config etc. and that was great. With Webpack you get loads of really cool bundling and more "modern" JS workflow with modules out of the box. It could be worth learning on a separate project to see if you them though. Each one has it's own strengths and weaknesses.
Probably because Vuetify uses Vue's internal prototype method called `this._h` (CreateElement shorthand). This function was removed in vue@2.1.5 therefore webpack throws this error. Use `this.$createElement` from now on
Reminds me of RAML. Cool idea!
I think webpack/babel6 is not meant to work out of the box. Their target is to provide a versatile tool for current meta and drive it to the future. Gulp is to DO things based on your input, efficiently and automatically. It can minify, convert, rename and concatenate files leveraging pipes via plugins. It connects CLI with JS. ( formerly rm -rf build ) It is also async and easier to compose than npm scripts. Webpack is to BUNDLE your frontend(and node.js) workflow. It does more than minifying and concatenating. It takes full control of files and re-evaluate everything through javascript. It does everything on JS world and and rely on NPM environment to extreme. This include transpiling toolings like Babel, Less/Sass. Since it knows every assets in your project, everything is very malleable. Batch renaming is a piece of cake. You do not need to pollute global scope to have an access to another module/plugin. Your webapp becomes more solid and less prone to break. Kickstarting a project will become as cumbersome as its mighty ability. But I assure you, IT PAYS YOU BACK really well. And you can skim its good part by using boilerplates, as long as they fit your needs. Some kickstarter kits provide both "easy mode" and "expert mode" via eject feature. (cf. create-react-app) You're gonna have a bad time ignoring them for next 5 years minimum, fo sho. :)
Check your pm.
why? components style is very interesting comparing with this old way :) the name (if you want to search info) is 'by functionality/Feature'
Basic MVC principles. That doesn't mean you actually need a Rails-style MVC app, but keeping rendering, logic and data services properly separated is important for separation of concerns, loose coupling, etc. Your new approach is also only really suitable for the most basic of CRUD apps.
nice answer :)
I, as far as I know, do not use this._h.
It's not. People who change their own oil aren't paid for doing that. You're still a "JS developer" if the things you do require very little skill.
I think that is better by features as Angular 2 does but I understand your point of view :)
You are completely missing the point of monads.
Generators make a LOT of sense if you end up with a heavily recursive routine that needs to stop executing from time to time. For instance, I have a JavaScript routine that takes about 5 minutes to run, but I don't want it to freeze the browser for the whole time. Because of the recursion, it is not easy to simply use `setTimeout` and run it chunk at a time. That would involve storing too much state between runs and duplicating what the Javascript runtime does. So.. I am able to use a generator and run a few hundred rounds of my generator, then let the UI run and set setTimeout to resume consuming the generator.
Those tools still work great, but they are primarily for node-targeted code. Once you need to bundle for the browser they don't produce useful output on their own.
I was wondering if tree shaking does anything more than uglify can.
Ahhh, okay
Bleph.... build tasks. Here is my negative vibe: * Time spent dicking around building and maintaining build tasks is time not spent on the real product. * Waiting for code to build is throwing away time. It is completely unproductive. To determine how horrible it is use this simple math: `(# of employees building) * (mins to complete a build) * (# of builds per day average)` Sometimes build tasks are less evil than running code by hand. Here are some examples: * test automation * dependency management (availability and certification of both code and services) * code validation Here is where you should avoid build tasks: * Executing code. If you are manually executing an application then you are don't need an automation step. You are the automation step. If there is an extra automation step somebody's incompetence is more valuable than your time and you are not valued. * Updating code that you will manually execute. If you have to do more than `git pull` you probably need to ask why. Brace yourself and expect the answers to be bullshit excuses or a lack of technical vision. If you are going to run build tasks your build tasks need to take the experience of your software into account. If your software runs in a browser then you need to test in a browser. If your software runs from the command line then you need to test from the command line. If your software runs in both then you need to test in both. That means your build tasks have to account for various environments and run time solutions. In the end I found writing my own solution was just faster. Yes yes, its reinventing the wheel and that makes people cry. Don't care. The real time suck is not standing up build automation, but actually writing each automation task. This would take the same time either way. Standing up a new task automation run time is as simple as writing a shallow Node function and pulling in some services plus tools I had already written for prior projects.
Okay, my analogy was a bit off. My point is that this bucket is _huge_ if you classify it as "anyone that touches JS". I'd narrow it to "real" JS developers, but specifically what that narrowing is is up for debate. People plugging together jQuery plugins are definitely outside of it though.
Apparently f() should return an array of functions. We want to execute the second one and print the string output.
Here are some quick solutions: * Object properties can be referenced by a way called *array notation*. Some example code var obj = { cat: "meow", dog: "bark", lizard: "grrr" }; obj["cat"] // returns "meow" Since all object keys are strings you can assign an via array notation to store things against keys that do not make for valid references: obj["1234!@#$ asdf"] = "this works just fine!" You can get all the keys from an object thanks to this handy dandy ES5 method: var keys = Object.keys(obj); //returns an array of strings // ["cat", "dog", "lizard", "1234!@#$ asdf"] Sometimes your key can be dynamically supplied as a reference. That is fine too so long as the data type of that reference is a string. obj[myVariable] //returns the value of a matching key or undefined That is all there is to know. Easy peasy.
its an object, not an array specifically but it could be.
All this &lt;IE9 talk. My first and last question while interviewing a potential employer supporting &lt;IE9 is "What is the least version of IE do you support?" It's not worth my time if that answer is less than IE9. Also, I've found if you're targeting the iOS browser, defer will delay HTML rendering until the script is loaded if you put the script tag at the end of the body tag. Async doesn't do that. That's not a pro/con for this post; just something I've discovered.
JavaScript *is* object oriented. TypeScript is really great for much larger projects, but for what you seem to be doing, your ramp-up is going to be much quicker with JavaScript.
Wish I wasn't on mobile so I could play with this some more 
You can reference objects like this as well
I don't think you need typescript for this project, but if you want to use it you can. Sounds like you're just building a basic dynamic website, which can be achieved using any js frontend, would recommend react personally. If you're into typescript you might want to check out angular 2, but people are kinda hesitant on the new angular release schedule (including myself so personally wouldn't use them). 
Of course you can - I just don't see the point of assuming it's extraordinary case without any clue. Maybe I just took it as pretentious bragging.
There's no IIFE here. `f` is just a variable, which is presumably a function defined elsewhere.
&gt;Marketing specialist wants to run a simple A/B test on site's hero text, VP of sales wants to add a script for a new analytics service. Ha! Not only would they not know how to do that, or want to do that (they'll just ask you to do it), you don't even want them to do it. &gt;hey have two choices - chase after an engineer to get this seemingly trivial tasks done or google some obscure npm / gem installation errors for the rest of the day! Yeah, the first one. 
Well played sir. 
This is the first I've heard of VR websites, do you have any links to any good ones?
The best argument against TypeScript is that it appears to encourage an OO approach to JavaScript development which many people (including me) disagree with. The truth is that all it really does is empower you to do it if you like while also making functional styles easier at the same time. There is a learning curve and it does add complexity to your project, but I think that it's a good trade-off because typings make your tools a lot stronger by enabling good IDE based syntax completion and error checking at build time. So, if you are also going to start to use a lot of libraries you aren't familiar with and you haven't already internalized a lot of js best practices, the time you spend getting everything set up will be paid back many times over in faster development that has a higher level of quality out of the gate thanks to the tools. Edit: This is my first time in this sub. Not sure why the downvote, but I guess discussion isn't this sub's strong suit looking at the other threads.
Please don't ever use any languages which will be compiled to Javascript. You don't need it, really. Just use ES6 Javascript, it's great enough for web.
iPhone7 safari had problems displaying the game mode select menu. Images where behind the mode descriptions. 
Nativescript is NOT a superset. Nativescript is a platform for building native cross platform mobile apps with Javascript (or Typescript). Might be rocky getting into Nativescript without some experience using Javascript on the web.
And by good we mean NSFW
I got the same error on the webpack non-SSR template
Oh I didn't read any harshness, sorry if you got that from my response. Thanks for the kind words :)
Awesome! Really freaking awesome! 
&gt; The first element of an array is its "1" property in JavaScript The first element of an array is its "0" property ;) Muphry's law.
Wow this is great! For someone that's never touched polymer can you explain a little bit about how it's different from other component-based ui libraries like React, Vue etc?
You can write asynchronous code like synchronous code with generators: /** * Calls the next method of a generator until it is done. * Passes the yielded result back in to the next next call. * @param {function*} generator A generator which yields Promises. */ function asynchronously(generator) { var g = generator(); (function go (err, result) { var step; if (err) { step = g.throw(err); } else { step = g.next(result); } if (!step.done) { var promise = step.value; promise.then(function (resolvedValue) { go(null, resolvedValue); }).catch(function (e) { go(e); }) } })(); } /** * Retrieves some content asynchronously. */ function getContent() { return new Promise(function (resolve, reject) { // throw new Error('ErrorMessage'); setTimeout(() =&gt; resolve('RETRIEVED_CONTENT'), 0); }); } /** * A main method to test out asynchronous code looking like synchronous code. */ asynchronously(function* () { var content; try { content = yield getContent(); } catch (e) { content = e.message; } var content2 = yield getContent(); console.log(content, content2); });
Eh, yes, although those are sometimes called "zeroth" and "first" too. I find it's best to just call them "index 0" and "index 1" to be clear. I fixed it at any rate.
&gt; My first and last question while interviewing a potential employer You only ask one question? Or do you ask twice just to be sure?
&gt; I know its still long path ahead of me but Im really motivated and I will success no matter what. You're young, motivated and strive for success. This is what matters most of all.
keep at it, its not that hard, thats exactly what i am. I rarely get asked about my education and the interviewers are usually more focused on my breadth of knowledge and overall capabilities. read up on common interview questions related to front end interviews, i've gotten quite a few of them over and over again. dont let the anybody hold it against you or put you down. i had an interviewer start to tear into me during a 2nd interview, everything was going great with everyone else, but he took me into a side office and started putting me down. making statements like "your a junior at best" which couldn't be further from the truth, especially since i have proven otherwise to him. I told him i would never work for him, thanked him for his time, and walked out.
In you are new to JS avoid inheritance, which includes this list: * bind * call * apply * this * new * Object.create Get familiar with the rest of the language first and then come back to this mess after a couple of months. You will likely find your code is smaller and easier to read without it, and if you do need it you are in a more confident position to understand how it works with other parts of the language.
Thanks for the response! To be honest Im not afraid of interviews. I have been through many interviews already and I think I can handle that part but I will definitely check all possible questions before and prepare for it. Thanks again ! 
Do you have breakpoints in your grid system for smaller devices (responsive)?
Ah, thanks.
Yes I totally agree with you but in my case apprenticeship is not an option as I cant afford to work for national minimum wage not to say about Apprentice minimum wage. Im not worried I might not handle it or something as I can see my progress already after just 2 months of learning and I want to learn more and more. I never had such a desire to learn like I have a now , even tho Im working full time plus workout everyday + runing every morning I manage to spend at least 2/3 hours a day on learning. And much more over weeknds. And Im focused on my path and I wont give up on learning as I simply really like it. But hey, any advice is very very much appreciated! Thanks ! 
Shame it doesn't work on IOS probably but I can see a lot of work has been put into it so good job! 
Hello! I'm someone with a degree and I am a full stack developer but I mainly do front end at the time being but I would honestly say don't worry! People without degrees are fine and that as long as you show tenacity and willingness to learn (which you have already started doing ) and you make this clear in your interview, it will be enough. No one expects you to know everything and a lot of today's industry is still stuck in a loop where they're too used to using or doing something a certain way. Show them that you have been trying to keep ahead of the industry by learning ES6/7 or even build a website with a robust framework and I'm sure you'll go far. Most developers are self taught and it's impossible for someone to know everything. I'm sure you'll find somewhere, that'll allow you to fill a gap and mark your stamp. Once you get your head in the ground then you'll just see that you're introduced to this whole new environment where you'll be learning a whole lot of new stuff and you're gonna look back and see how far you have developed! 
Loving the [sprintf](https://vocajs.com/#sprintf) function. No more string concatenation!
Why not just use es2015 template strings / interpolation? 
Here's some nifty code: function promiseMaker(i){ return new Promise( function(resolve, reject){ console.log('init: ' + i); setTimeout( function(){ console.log('resolved: ' + i); resolve(i); }, 1000 ); } ); } [promiseMaker, promiseMaker, promiseMaker].reduce( function (p, next, i) {return p.then( function(){return next(i)} )}, Promise.resolve() ); Once you make a promise, it will just start executing whenever it feels like it. In order to have some control over when the promises start executing, you can wrap them in a function (a thunk), and when you call the function is when the promise start doing their work. That's more or less what `promiseMaker` is doing. Then later, an array of these promiseMaker functions (which, again, when called will return some promise), is folded (reduced) in order to basically construct a `then` chain. So each promise in the array will end up waiting until the previous one has resolved. Edit: An already resolved promise is passed in as the initial accumulator value on line 20. This allows us not to have to special case the first value in the array, and simply keep hanging things off of the `then` method. Edit: I'm semi-familiar with tasks in the context of scala, but not so much with JS/folktale. A quick peek at their GH repo, though, suggests that `chain` might be a more appropriate method. 
One way: const promiseSeries = arrayOfStuff .reduce((promise, item) =&gt; { return promise.then(resultOfLastPromise =&gt; { return actionThatReturnsPromise(item, resultOfLastPromise); }); }, Promise.resolve()) // Or some other preformed promise .then(() =&gt; console.log("All done")); Edit: exactly what you do depends on how you're getting your promises and what arguments you need to pass in to those functions. If you need more flexibility (for instance each promise in the series comes from a different function) then the array-of-functions approach /u/tyroneslothtrop showed is more suitable. Or if it's really hard to shove things into a `reduce` loop because of varying arguments or whatever, there's always the standard promise chain. And I don't know anything about Folktale. Personally these days it's `async/await` all the way for me.
Both of those require extensive i18n functionality, and something that probably shouldn't be part of Voca's standard library.
I think [you should just try it out](https://www.typescriptlang.org/play/). Try writing some code in the playground, right click on some variable names, and see how you like it. Just use features that you're interested in and you can adapt as you learn. I'll admit I think that if you're learning TypeScript, but you're not familiar with modules in ECMAScript, it might start out a little rough. Modules tend to be the biggest hurdle new users run into, but that's more an ECMAScript 6 thing than it is a TypeScript thing. We're working on making it easier for new users though, and over time these things should smooth out. But I'll mention that once our users've gotten the gist of the language, they typically end up loving it.
Yes. The grid system has options for large, medium, small and extra-small breakpoints.
&gt; I dont see why would this be more error prone than defining it directly, can you elaborate on that? because a misspelled string will result in a silent fail while using actual language constructs lead to run time errors.
It is eminently possible and exactly the way my career panned out. One advantage I had was starting in the late 90s early 2000s when people were just looking to "get on the web" (in the UK anyway). Started a small business doing static web stuff with a bit of CGI scripting. The business didn't last and didn't pay much, but it gave me the experience needed to get my first permanent development role. Now, after many years (now as a contractor) my education is not even looked at by employers.
In my experience, once the build tasks are set-up and functional they tend to just run without a problem. The ability to use ES6 features and CommonJS requires makes it very worthwhile in the long run, I believe.
Those are not string functions. Those are english specific NLP functions.
This is resolved as of 0.7.4.
[HTML5 has JavaScript APIs](http://www.htmlgoodies.com/html5/javascript/a-5-minute-overview-of-all-new-javascript-apis-in-html5.html#fbid=K4xJyP-XHRH). I disagree with this removal. As from the [/r/javascript subreddit guidelines](https://www.reddit.com/r/javascript/wiki/index): &gt; Posts must be related to JavaScript, even if indirectly. News regarding HTML 5.1 spec are relevant to JavaScript developers that use Service Workers, for example. Just because there's HTML5 in the name that doesn't mean it's just related to HTML or just to HTML 5.
While I love JSON I can't help but think we already have XML in form of html, and the concept would be the same. Unless I'm understanding something wrong, in the end of the day you are using a builder with some pre-defined components and the same could be accomplished with most frameworks. Except that xml is probably a little bit more friendly for non coders
requestAnimationFrame is determining the "step speed" since I'm storing the time when my update callback is called during the animation cycle. These don't happen at set intervals.
The link wasn't specifically about HTML5 JS API's, it contained only brief references to said API's. If you want to submit something more substantial regarding the API's, feel free, but the link you submitted has much more to do with HTML than anything. And wow, 129 submissions of your own Medium blog in 236 days, more than 1 post every 2 days. It's almost as if you're intentionally submitting a lot of low-quality content in order to keep your numbers respectable...
Thanks for the pointers guys! I figured out what I was after from Brian's video at about the 2:40 mark. I needed to use chain to merge my tasks down to one that I can fork. Here's his video https://youtu.be/mMCgJA8HScA?t=2m40s Here's my code // getValuePromise -&gt; {foo: value } const asyncTask = new Task((rej, res) =&gt; getValuePromise('Hello').then(res).catch(rej)) .chain((resp) =&gt; new Task((rej, res) =&gt; getValuePromise(resp).then(res).catch(rej))) .chain((resp) =&gt; new Task((rej, res) =&gt; getValuePromise(resp).then(res).catch(rej))); asyncTask.fork(console.warn, console.log); // -&gt; { foo: { foo: { foo: 'Hello' } } }
That's a fair point.
This video shows how to animate a bar chart using chartjs library. It is very easy to animate it. Please go through chartjs.org for more detail
"No dependencies" is not a feature. There are tons super fast tiny packages out there. And it worth using it.
Here's a pretty good starter kit: https://github.com/kriasoft/react-starter-kit Getting started with React is still a whole lot easier than getting started with Angular 2.
Everything acemarke has said, and a good getting started video is: https://www.youtube.com/watch?v=A71aqufiNtQ
Thank you
Thanks
Maybe you're just trying to be a dick or my question sucked. I asked for tutorials. 
You're probably looking at my activity in all subs. I usually post links in web and programming related subs I participate, there are also subs I don't blog about like CSS and web_design. I blog for the purpose of elaborating arguments in [Open Source](https://github.com/FagnerMartinsBrack/), HN and Reddit (with links to each concept in the middle of the comments that I have elaborated better because I couldn't find an efficient resource somewhere else). The reason I post my link in subs is to receive feedback and share something new, if I wrote about it then it means there's a big chance nobody has talked about it (otherwise I would be linking and posting another resource that doesn't make me spend any time writing). Also, you will see a lot of submissions because I x-post things in related subs. I have friends that want me to share links I find on a day to day basis (yeah I read a lot too), so instead I suggest for them to subscribe to certain subs because I usually post the best things there anyway and it doesn't make sense doing it in a lot of different places. Since not all of them subscribe to all web related subs, I repost in all of them if the same link is related. Other people have also told me it's nice to do so. I don't think what I submit is low quality because most of the comments have been positive so far (there were some negatives in the beginning and that helped me to identify the best content for each community). You can see submissions that got a lot of stream too. This is becoming off-topic, but I would like some feedback on how to improve this impression of "It's almost as if you're intentionally submitting a lot of low-quality content in order to keep your numbers respectable". That's definitely not what I am doing and I don't want to cause that wrong impression. What I want is to use the communities to [grow](http://cdn2.business2community.com/wp-content/uploads/2016/05/fixedvsgrowth-670x821.jpg.jpg) myself and encourage others to do so. I have some strong opinions regarding the lack of professionalism in this industry and I hope that by doing that I can do something to change it. Also, I believe this sub could be more open to fundamentals and not just syntax. There is a lot of background on decisions regarding JavaScript and making people here learn fundamentals will help them to develop better software. The JavaScript community doesn't seem to be interested in this kind of things. As a mod you have the power to actually help to change it. Make sense?
thank you for pointing out this. I did not know this.
remove() is a better method name than get(). As I said it is a pointer to show capability of Java Script. So I just wrote that method. thank you
Similar material to the egghead video, but easier to refer back to: https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch9.html#my-chain-hits-my-chest
Python has a *ton* of syntactic sugar, so it can be jarring moving to another language from it. That's just something you'll have to get used to. Additionally, your if statement has extraneous parentheses. You could simply write If (5 &lt; num &amp;&amp; num &lt; 10) Although, you'll find a lot of style guides discourage "[Yoda conditions](https://en.wikipedia.org/wiki/Yoda_conditions)" such as *5 &lt; num* in favor of consistently keeping your constant values on the right. I would personally write it as If (num &gt; 5 &amp;&amp; num &lt; 10)
You can probably cut out half that code by using window.setInterval and window.clearInterval. You'll have easier to understand code, too.
[removed]
Of course I spent too long writing a script to do morse code. var charToMorse = { a:'.-', b:'-...', c:'-.-.', d:'-..', e:'.', f:'..-.', g:'--.', h:'....', i:'..', j:'.---', k:'-.-', l:'.-..', m:'--', n:'-.', o:'---', p:'.--.', q:'--.-', r:'.-.', s:'...', t:'-', u:'..-', v:'...-', w:'.--', x:'-..-', y:'-.--', z:'--..', ' ':'/', '.':'/' }; var dotDuration = 200; var morseToBeep = { '.': {on: true, delay: dotDuration}, '-': {on: true, delay: dotDuration * 3}, ' ': {on: false, delay: dotDuration}, // gap between dashes '&gt;': {on: false, delay: dotDuration * 3}, // gap between letters '/': {on: false, delay: dotDuration * 7}, // gap between words }; function convertMessageToOnOff(message) { return message.replace(/[\.\?\!]/g, '') .split(' ') .map((word) =&gt; { return word.split('') .map((char) =&gt; charToMorse[char].split('').join(' ')) .join('&gt;'); }) .join('/') .split('') .map((morse) =&gt; morseToBeep[morse]); } function playMessage(message, repeat) { var onOff = convertMessageToOnOff(message); var startTime = new Date; var first = onOff.shift(); function playNext(next) { setJust('red') console.log(next.on ?'on':'off'); setTimeout(() =&gt; { if (onOff.length &gt; 0) { playNext(onOff.shift()); } else { turnOff('all'); if (!repeat) return; setTimeout(() =&gt; { playMessage(message, repeat); }, morseToBeep['/'].delay) } }, next.delay); } turnOff('all'); setTimeout(() =&gt; playNext(first), morseToBeep['/'].delay); }
What was the best bit?
Awesome!