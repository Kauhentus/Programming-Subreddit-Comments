It should integrate much better with platforms like Electron and nwjs since they come up with node built in. Some users complain about Electron's memory consumption and how big the software is once it's distributed and honestly, they are right. Electron's quick start project takes up almost 200mb and it's nothing but barebones boilerplate with some settings. Imagine how much can packaged version of some real production ready Electron based software take up in comparison with "true" native software. Perhaps lighter npm could help with this issue. Perhaps if the built in node didn't have full featured npm it could help out with this issue.
&gt; The browser creators (MS, Google, etc.) don't like it because it's inefficient at DOM manipulation. Do you have a source on this?
Not everyone is looking for a job. Many people have stable employment, and teams that aren't going to be hiring anytime soon---but they're still interested in adopting better javascript practices.
Why not just add a class "active" to the currently active tab and work off that? Rather than maintaining seperate active states for each tab individually. eg $('.button').on('click', function(e) { if($('.tab1.active').length) { $('.tab1').removeClass('active'); $('.tab2').addClass('active'); $('.tabn').removeClass('active'); } } Then simply use css to describe any tab without the active class as hidden, and have the active class change that to visible. eg. .tab { /*styles here*/ display: none; } .tab.active { display: block; } The javascript could even be improved further by removing the need for each tab to have a specific number, since they should be found by jquery already ordered.
This project isn't going to take off and become something big, but I was thinking about re-working [https://github.com/ben-denzer/list-manager-react-redux](https://github.com/ben-denzer/list-manager-react-redux) - You might see from the name, but it uses React and Redux.
If you have to do any legacy browser work with cross compatibility, jQuery is absolutely invaluable.
What I don't understand is why anybody would want to install jQuery in Node. Hell, this is a library for websites, that needs to be loaded in a browser. 
On click on the list of tabs, iterate through all the tabs to remove the potential ".active" class, then add the class to target of the click event. This way you don't have to keep track of the number of tabs and their index.
`input` elements can have the attribute `autocomplete="off"`. However, Safari and Firefox ignore this for username, email, and password fields, and IE and Edge ignore it for password fields. They detect username and email fields by looking at the associated `label` element (in Safari's case, even if you only set that label using JS after the fact). There's a hacky and annoying solution to this. Because they'll only autofill *one* login field per page, you can create inputs labeled username/password and then hide them from the user, so the browser will autofill those and leave the *proper* fields blank. They usually ignore fields set `display:none` so instead just position them way out of the viewport and set `tabindex="-1"` as an attribute on the element so tabbing between fields won't reach them. Then hope that doesn't mess with screen-readers. It probably does, and we want to maintain accessibility for our blind users, but as far as I'm aware there's no way to solve your problem while doing this. Here's hoping that someone comes along and shows me that I'm not aware of everything. The last time I dealt with this problem I just gave up and accepted the autofill, although that was ~3 years ago.
`for...of`
$('.wax').on() $('.wax').off() 
Or you can write your own password input, which is tough task but rewarding you with absolute controll on it.
If pressing the keyboard shortcuts doesn't work, or right-clicking on the web page doesn't bring up the popup menu, you'll have to use the Chrome menu (the three horizontal bars icon) to open the console. i.e. `Menu &gt; More tools &gt; JavaScript console`. If you want to prevent web pages from disabling the shortcuts or the popup menu, you can use Violentmonkey or Tampermonkey to create a GreaseMonkey script that overrides websites which have that kind of bad behaviour.
Try Heroku. https://www.heroku.com
It depends: are you developing websites or web applications? A web site often is mostly static content "enhanced" by a little bit of JavaScript ( or jQuery) magic. Good chance that jQuery will perfectly suit your needs. If you are a web application developer, than chances are you are creating highly interactive user interfaces, which requires a lot of coding in JavaScript. In that case, jQuery is not a suitable companion anymore, and you are probably better off using (more) modern MVVM frameworks like React, Angular or Vue. 
It is not sad, it is actually great. It is a sign that jQuery contributed a lot to the web development community, and that it has now moved forward in such a way that it is not needed anymore. In my opinion, jQuery not being useful anymore is equivalent to saying "well done jQuery - mission accomplished".
Exactly, that's what I thought.
How about this instead? https://github.com/cheeriojs/cheerio
Or dom-parser, or jsdom, or xmldom, or regex Lots of solutions, jQuery is just one of them and one many people are familiar with. Not saying it's the best, or the one you should choose but it explains why people may include it in NodeJS.
Besides all that.. jQuery is still the best go-to for institutional websites or projects that don't actually need a lot of client side rendering. The one modern library that seems that could somehow remove jQuery from the "comparative" would be Vue (in my humble opinion) but then you ask "why the added complexity?" so...
I use cheerio a lot. It's (intended to be) compatible with jQuery, so *user* code, and Javascript code found in downloaded web pages that is using jQuery, can be run unaltered, but it's based on a different html parser, and a different DOM. jQuery is built on top of the browser's DOM. So you can't use jQuery in Node, AFAIK. 
[removed]
If anything TS will improve the readability of your code.
 $('body') .on('waxing', '.wax') .off('waxing', '.wax');
es6 is essentially just the latest spec for JavaScript. Make that a priority.
I do `console.log('label', var)` or some variation. I don't really see why you'd want the var to be part of a string. 
Seriously? I've heard from a handful of speakers at a Microsoft-run code camps where the presenters are in touch with the actual developers. They were abundantly clear that jQuery is not efficient. But I guess internet-know-it-all knows better than the browser manufacturers. Carry on. 
Handful of speakers != IE/Edge team Source: Work at Microsoft, used to spend a lot of time with those guys.
Why do you convert the nodelist in an array in the first place?
I do agree but normally to enable upvote/downvote, you need an authentication mechanism, but I don't offer user registration, not sure if adding that in would make sense for such a simple website.
Nah the answer is ["Separating Axis Theorem"](https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169) and it's not too difficult to implement... but longer than the 20 lines of code required for circle collision response ;)
You mean for..in ? for(var a of {a:1,b:2}) { console.log(a) } &gt;&gt; Uncaught TypeError: (intermediate value)(intermediate value)[Symbol.iterator] is not a function
JQuery is a great language... sometimes. I think due to growing libraries in JS and CSS, people are just not needing it as much. I still use it often. Sometimes even JUST for the selectors. There is just a lot of cool things coming out of other libraries that are having people switch.
Check if your shared hosting supports Node. If it doesn't, try Nearly Free Speech, Digital Ocean or Heroku. 
Sound a bit tense there, I wasn't claiming its "parsing XML", I just said you can parse html documents with it, that you can. Doesn't matter how well it does it but you can do it and get results from it! Worked for me for 3 years, this was doing 1000+ pages a minute. Only reason I dropped it is because I suck at regex.
You were claiming it's parsing HTML, which is a kind of XML, which is impossible to parse with regexp.
It is not impossible to parse HTML with regex. Which is what I said.
&gt; $('a.navitems').addClass('disabled'); I agree totally. It'd be nice if the nodelist was a real array, and had map, then we could do. document.querySelectorAll('a').map((item) =&gt; item.classList.add('disabled')) 
Mostly learned about them reading various things and trying it out by creating little components here and there. I think a good starting point to learn about them is this page: https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom You can also watch this github repo where discussions about spec things go on: https://github.com/w3c/webcomponents Other than that, r/javascript and hackernews are good sources to read in case anything interesting pops up. 
I think you mean less sugar, and more boilerplate. Regardless, the problem with JS is that the DOM API isn't intuitive. Not all lists are arrays with array-like methods. Some things are just bare strings. Even today, cookies are still something you have to construct manually instead of being a map.
You could convert it to an array I guess? `Array.from(querySelectorAll('img')).map((item) =&gt; item.classList.add('disabled'));` Still clunky, admittedly.
Is it possible to rethink some of the naming conventions for components? Looking through the site for the first time, I couldn't find a table component, but it was actually a subset of the detail list component. Pivot is better known as a tab for example.
That's simply not true. Bootstrap won't work without it.
I have them individual because each tab has a different image. Set with background. I want to use the same code I have working, but I need the 2nd click to do something else, which would be the "if" jquery?
Thanks so much! This worked omg that was such a simple fix!!!!! my code: var countBits = function(n) { var bits = []; var count = 0; bits = n.toString(2).split(''); for (var i = 0; i &lt; bits.length; i++) { if(bits[i] == 1){ count++; } } return count; }; countBits(1234);
Sweet. I've wanted something like this for a while.
Jokes on you. You already know most of Vue and don't even know it.
classList is a read only property and doesn't return a real array so you would need even more code to use it.
I was looking for something similar recently, and it looks like [cheerio](https://github.com/cheeriojs/cheerio) is really popular. You'd use something like `fetch` to grab the html, and cheerio to parse it.
The only way for jQuery to disappear is the browsers incorporating is syntax. But then you would have to polyfill it anyways.
Did you actually read my comment? I left a statement in there specifically for people like you.
 document.querySelectorAll(".className").forEach(callback) These statements are so similar that I think it's impossible to say one "wins". Well I mean the document api doesn't require a dependency, so I guess there is that.
redux-forms, the end
The property itself is read only but you can totally do `classList.toggle('foo bar')` or `classList.add('foo')` and so on like with jQuery https://developer.mozilla.org/en/docs/Web/API/Element/classList
Of course it is. Inputs emit events, you validate them and then use them. What the fuck...
&gt; Fourthly, there is the plugin library. It's huge. Some of them are very well designed True that. It does have a huge plugin ecosystem. Agree on the crappy decisions the authors made to lock in to depending on jQuery. Definitely weary of 'not invented here' syndrome too. But I do a lot of mobile web and animations are a waste so that pretty much leaves dom stuff and AJAX. Even if you want both of those you can get smaller individual libraries. The biggest thing I want when I'm doing anything bigger than little animations or click handlers on a static page is modules, that means browserify or webpack. And I would rather use libraries that play well with that paradigm. JQuery is great - for legacy stuff.
It is mathematically **impossible to parse** HTML with regex. It is **possible** to detect some special parts of a given, known HTML structure though, which is what you're doing instead of parsing HTML.
/r/onewordeach
I think this is a better example (same site though): https://developer.mozilla.org/en-US/docs/Archive/Web/E4X_tutorial/Introduction Either way, interesting find. Here's an overview from Wikipedia for those interested: https://en.wikipedia.org/wiki/ECMAScript_for_XML
you learn something new every day! So let's try to reduce this further then for (var el in document.querySelectorAll('a.navitems')) { el.classList.add('disabled'); } It's better than my first example for sure, but I still prefer the jquery syntax to this ultimately.
You make it sound JQuery is some kind of legacy crap. Major frameworks such as Kendo UI are completely built on JQuery.
And given a known HTML structure, I can use regex to [parse](https://www.google.co.uk/search?q=define%3A+parse&amp;oq=define%3A+parse&amp;aqs=chrome..69i57j69i58.2360j0j7&amp;sourceid=chrome&amp;ie=UTF-8#dobs=parse) content out of it. Not impossible to me :) You can argue all you want but you won't get anywhere, fact is I have used Regex to get content from a HTML file by parsing the HTML structure, it worked for many years through thousands of requests (page did change a lot and it handled it well). So your impossible is just trying to justify the meaning.
Yes! Check out [Jr.DevJobs](https://www.jrdevjobs.com/jobs#query=javascript&amp;page=1). It exclusively list jobs for junior and entry-level developers. * You can [search for jobs](https://www.jrdevjobs.com/jobs#query=&amp;page=1) * You can [research companies](https://www.jrdevjobs.com/companies) that have posted with them. * Read [articles](https://www.jrdevjobs.com/articles) that will help you with your job-hunt and continuous learning * Join [their Slack team](https://www.jrdevjobs.com/slack) to chat with other developers * [Create a profile](https://www.jrdevjobs.com/developers) to show off your skills and projects * You can even see the [skills in most demand](https://www.jrdevjobs.com/insights) * There's also [stories told by other junior developers](https://www.jrdevjobs.com/featured/developers)
I miss E4X :(
Not in IE
Wow, didn't know that! Isn't it about time to bring it to me again?
It's a completely different kind of language. RegEx isn't powerful enough to handle HTML. I do believe you that it worked for you, but that doesn't proof or even imply that RegEx is able to parse HTML. Regular expressions belong to the Regular Languages (hence the name) which are Type-3 in the [Chomsky Hierarchy](https://en.wikipedia.org/wiki/Chomsky_hierarchy) [XML belongs (at least) to Type-2](http://softwareengineering.stackexchange.com/a/205725), which is mathematically proven to be more powerful. [HTML is sometimes Type-2 and in practice either Type-1 or Type-0](http://stackoverflow.com/a/5207677/2857873), not sure about 1 vs 0 in this case. Look into it, there just are things that are impossible to do in any Type 3 that are easily possible in Type 2, Type 1 and Type 0.
Hi /u/netxm, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
As from what I know (i am developer of whitestormjs): - ReactVR - A-frame (built also on three.js, but not sure if you can acess it from there)
I have ported [TAL](https://en.wikipedia.org/wiki/Template_Attribute_Language) (edit: TIL my project is listen in wikipedia) to JS using E4X. Fun times. https://code.google.com/archive/p/jstal/ I still have [E4X support request](https://bugs.chromium.org/p/v8/issues/detail?id=235) in chromium starred ;) Edit 2: The [project wiki](https://code.google.com/archive/p/jstal/wikis/usage.wiki) demonstrates how many server-side JS options were available even before node.js has dominated the market. One of the cool things was that E4X has worked in CouchDB (it ran spidermonkey under the hood) so it was easy to drop in JSTAL and render HTML views straight out of the database.
http://stackoverflow.com/a/1733489/128023
[vanilla-js.com](http://www.vanilla-js.com)
I tried this on mine and it validates it server side ;(
The React team talked a lot about E4X in the initial JSX release. JSX was, from the start, "E4X, the good parts". ~~Hence the "X".~~
its still easier because you shouldnt use for..in without hasOwnProperty check + you dont get both key and val. In reality its: for (var prop in obj) { if (obj.hasOwnProperty(prop)) { } } Object.entries is ES7 but i guess this tread was about stuff you dont need jQuery anymore today... besides its terribly ugly...
You disagree because, apparently, you're unaware of the new APIs he's talking about. document.querySelector('#something').click(); document.querySelectorAll('a.navItems').forEach(el =&gt; el.classList.add('disabled')); // With a simple alias: $('#something').click(); $$('a.navItems').forEach(el =&gt; el.classList.add('disabled')); Also, looping over elements and setting a class on every one, rather than setting a class once on a parent, is an anti-pattern that jQuery encourages. So I'm quite fine with the native API leaving the looping explicit.
I feel thats like saying "Purified Water is water but with the good parts, hence the 'Water'."
I just meant that the "X" refers to "E4X", not that it implies "the good parts".
&gt; Uh, fiber is coming for speed Are you serious? If you are, please quit your job and join a profession where you will do less harm to the world.
 setTimeout(function(){ console.log('X 10:10 11:00 X 10:15 11:10 X 12:05 12:30 X 17:25 18:01 Y 12:45 13:25' }, 5000 //waits some time to pretend we are doing some hard math );
Netscape Server has a JS runtime as well.
Ah. Yeah, I thought it was homage to E4X, but that makes sense too. To be honest, I remember the "the good parts" phrase from the early announcements, not the naming part, which I assumed.
&gt; ActionScript My man
I still use this everyday at my job. 
Many applications have significantly more complicated requirements around forms.
I was the tester on the original implementation of E4X back in the BEA WebLogic Workshop days. It was a pretty fun to extend JavaScript with better XML support. Regrettably, the language has some warts, but it is still fun to use once and a while.
Thanks. That works but can you explain it? Also when I scroll to the last div, the sidebar is no longer clickable.
For 95% or more I'd wager 
there is also the (now obsolete) convention for converting xml and json from and to each other: https://developer.mozilla.org/en-US/docs/Archive/JXON i also discovered that `&lt;style scoped&gt;` died last year. it was supposed to allow non-global css styles. would have made components easier to make without relying on frameworks. shame.
If you want a service there's also http://stdlib.com/nemo/scrape
I'm still using this for my project
Yeah you are probable right
Me too In Mirth thanks to its dependence on Rhino.
Use a textarea input field. 
It's also used in healthcare, HL7 messages often end up as XML at some point and a popular open source interface embeds the Mozilla Rhino JS engine which supports E4X to make working with the messages fairly easy.
Useless article. Vue is amazing tho, Vuex aswell.
After using react, angular1 and Vue, Vue is easily the winner for me personally. And Vuex is much easier to work with than redux or flux or whatever it's called now. Setting up webpack etc manually is a hassle, so I recommend this boilerplate. https://github.com/vuejs-templates/webpack
Wow! Digital Ocean is very affordable, instances start, well... Instantly! haha pretty cool. 
The variable `player` is "destroyed". But the memory containing the player data (new Player) is retained because a new reference now exists within the objectArray. So the player itself persists, but the variable that was containing it in that function no longer exists after that function resolves. Player persists because objectArray exists, which itself persists because it was saved to the `this` object rather than being a declared var in the local scope.
No, in this case, I would use `const`. Unless you're reassigning player to a new player. If you're new to ES6, start out using `eslint` with the air-bnb rule set. If you use that. You'll learn es6 *really* fast. Note, this endorsement of the airbnb rule set does not come in complement agreement with every decision they've made.
I typically write in es6 these days. With this version, `var` isn't really used any more. If you intend to reassign `myGame` you would use `let` and if not `const`. Pretty much everything is `const`
&gt; Now that we have shadow DOM there's less of a need for it. we're a long way from styling the shadow dom though. [only chrome](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot) supports its api, the shadow css selectors (`/deep/` aka `&gt;&gt;&gt;`, and `::shadow`) are defined in [this w3c spec](https://drafts.csswg.org/css-scoping/#deep-combinator) dated today but are deprecated from chrome and to be removed soon, but possibly [in the coming years](https://bugs.chromium.org/p/chromium/issues/detail?id=489954) (!). so basically, short of a framework that shims its functionality, the shadow dom is of no use.
Eric Elliott tweeted yesterday that "advanced users have learned to avoid `setState`" , which led to a ton of discussion: https://twitter.com/_ericelliott/status/842486206122217472 .
Lack of /deep/ selectors hardly makes shadow DOM useless...
The appropriate Array method is `forEach`, not `map`. And `forEach` actually is available on `NodeList`s. `document.querySelectorAll('a').forEach((item) =&gt; item.classList.add('disabled'))` works.
Serious question... Why not excel and vba?
I think I remember reading somewhere that Rhino was kind of a precursor to Node? Or you could somehow use Rhino on a server?
Linode recently released new plans and they are even cheaper than DO.
&gt; However, I'm not sure if it's an optimal code since I believe that every time a call a static method category it creates a brand new object, which would be very slow. I think "very slow" should be put in context. One of these operations takes like 10ths of a millisecond. 
I was going to say exactly this. At my previous job, a lot of their system was in modern ASP.NET WebForms and MVC, but I still had to deal with some legacy webpages. Some of those scripts were Classic ASP JScript pages created in the early 2000s
i'll have a look good sir. thanks!
I'm very confused now. These people spent time with the Edge team too. They all seem to love Angular and don't think much of jQuery, and they really seemed to know what they were talking about. Can you elaborate?
Open the developer console and type "alert('hello world');" You'll get an alert. Mess around with random sites on the internet, just to see what you can do to the DOM using pure JavaScript. Its fun! 
It's what Demandware is built off of.
This is the exact explanation I give for why I loved working with AS3 so much. The type system is fantastic.
I will definitely need to handle js events - keen to know more about the api. Would that first method be headless, or a physical windows? 
Nice - I would need to handle the js events though, so probably not suitable? 
Cool. You can eliminate the CORs problem by fetching the URL's content using the background page then injecting that. You may also be able to fetch it from within injected extension code, I'm not sure. Point is, extensions can get permissions enough to bypass CORs.
https://chromedevtools.github.io/debugger-protocol-viewer/tot/ this is the protocol, as I said, use it with https://github.com/cyrus-and/chrome-remote-interface. Latest Chrome on Linux does have a --headless mode, but there are still some kinks to be worked out when you want to have multiple sessions. Depending on your need, you have to evaluate whether headless works for you right now. https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md
Oh yeah. thanks. this is the easiest way!
this aesthetic reminds me of boy scout patches
what do you mean by mostly headless?
Slow down
Here is a [link](http://obliv.me/) to the website and playground too!
Great demo of the shortcomings of not using a type system. I've switched to TypeScript a long time ago and I'm never going back. 
Same here. I love how types and etc. makes it more like real programming language (I don't care about types that much as I care about their declaration syntax)
You are right, I am definitely not down with this.
&gt; I don't care about types that much as I care about their declaration syntax Care to expand/clarify? I don't understand how you can care more about the declaration syntax for types than static typing itself.
Of course. But it's very fucking easy to work with forms and "just" React.
What the fuck?
react itself uses a class as a recommended way to create a component, if you're not using stateless components. The actof writing a react app is itself a **functional composition**. Components are just functions-render methods that you compose together to form your whole UI. React is very heavily functional. Don't let anyone tell you otherwise.
I argued for keeping it in 4. Too many haters. But they were looking to trim the fat and it was an easy target :/
It wasn't that bad. It had all the basic features you could expect when doing dynamic websites back then. Pretty much ASP without the COM/ActiveX layer. And it made me earn tons of money back then :)
In the article: &gt; So that's one strong advantage of immutability over mutability: we can't change the internals of an object without informing the object. That's not true-look at the library like [MobX](https://github.com/mobxjs/mobx)-that one achieves the same with mutable objects. What's even better is that it allows for much more granular subscription to changes making the whole rerendering much more performant.
Safari is supporting it this year and Firefox has said maybe this year, Edge I think said they had higher priorities.
And you can in as3 as well if i recall? Please tell me where as3 and ts types behave differently in that example?
You mean the equality == operator? You should always use === even with TS because last I checked it was still possible go get mutations dealing with arrays or collections, and you don't need to in ActionScript or Dart. Compared to AS and other compile to JS languages, TS is an unsound "language". Maybe that's changed though, I've mostly been doing backend work for the past year and TS is always improving. But that's what I was implying before. It may be trivial to some, but I started off in all the typical C-like languages before using JS for anything serious and to this day I forget to use ===. It's annoying. Semantically I think TS looks closer to AS than Dart does. But from coding in both and just even the dev environment, Dart feels closer to ActionScript when I use it. They all have their headaches and pains though. If you loved AS you'll still be right at home with TS compared to plain JS. What's really missing is something like Flex which was just so clean to use. JS frameworks with single file components are slowly starting to recreate that MXML component feel, but there's often boilerplate to do things that feel like they should be abstracted away.
You're welcome. BTW, I hate websites that don't let me save my password. You can rot in hell for doing this. lol ... ^^^I ^^^am ^^^a ^^^web ^^^developer ^^^no ^^^worries
+1. Best tech decision I've made since bailing on PHP years ago.
This :) https://headlesscms.org/rules/
Sure you could. My main complaint is that the DOM api tends to return special objects that kinda-sorta-look like arrays but don't derive from array, so you have to remember exactly which methods you can or cannot use. Someone mentioned you can use 'forEach' on NodeLists. I tend to reflexively use .map() because you can chain maps, and map is found in pretty much every language so its imprinted deeply on my psyche. In JS, Iterators, Arrays, and Array-likes (e.g. node list) are all different objects and you have to convert down to an 'array' just to get the protocol that you are used to. 
&gt; This is actually less than what I was expecting for a VM/run time environment for a dynamic language. Yea, Lua's runtime is extremely small. That's not the case with Ruby or Python, for example.
Sorry, I'm not sure i could explain it much more than I did in my last post. I don't think I'd be able to help with that other part without having access to your code.
Mdtang.github.io here
Whenever you access Constants.DocumentElement, the document is queried for all those elements. Also, an all static class makes sense in Java because everything must be inside some class, but it doesn't make sense in a language like JS where that's not the case. Just use a module to bundle things like top-level functions or constants.
And this article teaches you how if you didn't already know. 
Now that's a substantive post. 
Any material covering authentication for client side/spa apps? I'm always curious to learn how people handle this situation 
* There is a browser API for full screen. * A design goal of Wasm is to reach native code level speed. I can't think of a reason why they can't achieve it.
I've tried my best to explain everything in one go :)
My name is also Tim, and on behalf of the other Tim's: Congrats, this is an awesome effort. Edit: WebSockets + ML would be my picks for new topics.
AS3 had a pretty limited type system AFAIK. No generics besides for Array, limited inference, no union types, intersection types, no structural typing, type narrowing, etc.
Nothing wrong with people learning through experience rather than theory. I know a lot of BE devs and very few who can actually build a decent UI app. There's more to it than just CS
Thanks! WS/ML comment is also noted, thanks for feedback :)
you've missed the point completely.
seems like what they mean is serverless. /u/paul_h
no just that: &gt; if you don't learn from history you are doomed to repeat it and leave people with buggy broken code and inferior products that require hacks a plenty. I like experimenting with new stuff, but this crap seems to perpetuate that FE is producing hot new stuff. It's not it's a repeat of ideas that are respected by those who know and disrespected by those who don't.
Cheers
&gt; It would be impossible to talk about React without talking about JSX. This is highly subjective. I hate JSX. I think it’s awful. Maybe I’m old and those days are long gone, but I’ve spent two decades being told that you do not output markup from a function. And I’ve spent a decade laughing at Wordpress and pointing derisively at the fact that it does that. To come along and say all the rules are different and separation of concerns no longer matters… Having your markup as a function of the state is the power of React. You just explicitly state on which parameters the markup depends on. *That is the beauty of a function.* An angular template also depends on variables, but they are just not so explicitly stated. If you write pure functions, you have to be very explicit about your dependencies.
I second that other Tim, both great topics
Would be very curios to read about your experience if you ever get around writing about it :)
There's actually a move away from classes in the community (which of course not every React programmer knows about/agrees with). Many teams are eliminating classes entirely and replacing them with function components. Personally I think it's swinging too far, as I find classes with a shallow (or better yet no) inheritance chain quite useful.
If I get around to it I'll post something when I'm finished
I can't wait to dig around in this course! Thanks a lot, Tim!
I LOVE YOU
 I just get embedded from YouTube. And put it in HTML
Thank you. As someone coming from other class based languages this helps me a lot.
Aww :3
Static methods don't have access to `this`. That method shouldn't be static anyways.
Not a fan of this blog author. Don't have the patience for his mental exercise in "objectivity" as he called it. Appreciate that he is being "honest" in this post, but it's just a waste of time to read and I don't care much what he thinks at this point. Doesn't really add to the real discussion in my opinion. As a beginner in JavaScript, what I find annoying is that a TON of tutorials on the internet are pushing JQuery or some framework right out of the gates with no background or context for all the things that a framework can do vs. how little it is doing in most beginner tutorials. I understand that the blog post is probably not intended for me as an audience (since I don't have much JavaScript experience), but it's definitely not relevant to what I think the discussion should be. How many JavaScript developers are just using frameworks as a crutch? How often is a framework or large portion of a framework being added as a dependency for a web page, and only a small portion of the framework being used? I think that happens a lot more often than needed. Also can tutorial sites push more non framework content for beginners trying to understand the core of the language/DOM manipulation, etc? What the heck... I realize this happens in other languages too, but man are bloated frameworks prevalent in JS.
I see. You want `this.xCoord` and `this.yCoord`.
Not heard of you before and not even looked at the course yet, but mad respect! Thank you for this enormous effort! I'll be sure to check it out. 
Why do you set delta and then add to it? Is that a copy-paste error?
cheers! :)
Thanks for the detailed reply. Yeah, I mainly work with JDEdwards in all facets (development, installs, upgrades, etc.) I'm going to keep going forward with it, I figure if I can get a good handle on using a framework and developing in JavaScript I can always adapt to something else. Their UI controls are pretty standard amongst alot of their stuff (and pretty nice) so might also be easier for a customer to accept as sometimes they get nervous with open source. As an aside, I often wonder how hard it would be to go from JDEdwards to SAP. 
I wonder if you can help me how does a site like C-SPAN send video requests at a certain time in the playback?
Never used it, can you give an example link? Is it similar to youtube timecodes? Than it's quite trivial.
Yea, that's a copy-paste error. The "delta =" line isn't supposed to be there. Check the snippet before the "FPS control" headline. Anyhow, a fixed step with interpolated drawing is rather complicated. I recommend to go with a simpler loop where the game just slows down if the frame rate is too low. let previous = 0; (function loop(now) { let t = Math.min((now - previous) / 1000, 0.04); // 40 ms, 25 Hz previous = now; whatever.update(t); whatever.render(); window.requestAnimationFrame(loop); })(0); The delta passed to "update" is in seconds.
What calls `keyDown`? What is the code you're using to call your `keyDown` function when the user presses a key?
That line should be window.addEventListener("keydown", game.keyDown.bind(game), false); If you're not sure why that fixed it, read through the MDN link I posted above. How `this` works is a fundamental JS concept, and it's really important to understand it. If you have any questions after you read through the link, I would be happy to help answer them.
The type can be inferred there, though. E.g. "let foo = 'bar'" is obviously a string.
I'd like to point out that react is essentially just a library for generating views which you can use to sprinkle on top of your existing code. 
It is called walking the DOM, and walking the DOM is side-effect free. You use the native API and make changes as necessary. This isn't foreign, impossible, or challenging to manage even though it may appear implausible to somebody who has never written code this way. The React approach is instead to build synthetic node trees in JSX which then get parsed into instructions under the hood for injecting node fragments into the DOM. Injecting new structures into the DOM this way isn't inefficient or measurably slow compared to using the DOM methods to inject new nodes. What makes React far slower is that it doesn't have a mechanism for updating DOM nodes. Instead it is always destroying and injecting new node trees, which is far less performant than simply modifying DOM nodes already present in the page. While I am sure the React approach feels far more *managed* because you are working on blocks of markup instructions at a time and they get executed behind the scenes it isn't as efficient. This is most true with single page apps, which (ironically enough) is where React is used the most. This is because memory leaks and uncollected references build over time to create a non-linear slide towards degraded performance and single page apps tend to have a longer lifespan than other pages. This means that performance impacts are not immediately observable, but increase in presence due to various factors prominently including active time.
Hi Tim! As a web developer student, thank you for making these! I've already subscribed! Can't wait until I'm good enough to create something cool to open source ;)
&gt; What makes React far slower is that it doesn't have a mechanism for updating DOM nodes. Instead it is always destroying and injecting new node trees, which is far less performant than simply modifying DOM nodes already present in the page. React updates existing DOM trees. &gt;While I am sure the React approach feels far more managed because you are working on blocks of markup instructions at a time and they get executed behind the scenes it isn't as efficient. Try your awesome vanilla js skills in this benchmark[1], I'd be happy to add your vanilla implementation if you can beat fastest virtual dom implementations in all update cases :) [1] http://localvoid.github.io/uibench/
No, www.c-span.org.
I was an intern on the team that implemented the parser funny enough. 
Who thought this was a good idea... like wtf did I just read
Awesome! Thank you!
yea, let's just use React everywhere
I'm starting to think that avoiding "this" should be a fundamental JS concept in the new era of Javascript :) It's so much easier to reason about when you are 100% sure what a variable is at all times. 
It's a feature marked with a unicorn emoji on the design docs, so not in the immediate future -- threads, SIMD, zero cost exceptions are ranked more highly iirc.
Instead of binding `this` in the event listener, which would make it impossible to remove the event listener since `.bind` returns a new function, you could do the binding of `this` in the constructor like so: class Game { constructor() { this.objectArray = []; this.keyDown = this.keyDown.bind(this); } update(delta) { for (let i = 0; i &lt; this.objectArray.length; i++) { this.objectArray[i].update(delta); } } keyDown(e) { for (let i = 0; i &lt; this.objectArray.length; i++) { if (this.objectArray[i].getID() == "Player") { console.log("player found!"); } } } } This is not always necessary but it's super helpful if you need to remove the event listener at some point.
Sure, understanding how it works is, because for the most part, you *had* to deal with it at some point. I'm pretty sure that if I did a complete search over all the javascript i've written in the last two years, there would be literally zero usage of "this" except when using libraries where that's the only way to get to the data needed. When there's a variable that you can't 100% guarantee knowing what it is, that's an error. I don't care if that's the way the language was built, it's a shit design, and it's no longer necessary. 
So no more OO in JavaScript?
If you're working with classes, you're going end up using `this`. Also, it's a core part of the language, so I don't get why you'd ever just write it off.
This is a subjective question. You're not going to find a site that has a list of functions inside a currency converter program. It's like asking what sentences are in a paragraph explaining currency conversion. 
As a non-Tim I'd also like to thank you for all the effort you've put into this course material! :) Keep up the good work.
Your right it's not a framework I miss spoke but being a library it's has a lot of stuff packed into it. It wouldn't make sense to use react if your not going to leverage all of its other part. If you just want simple routing then you can use all the other simple routing libraries out there. If you want something more complex use react
This requires jQuery, which also doesn't really make sense if you aren't going to leverage all of its other parts.
Basically every website uses jquery it's common as fuck so what's your point
It's an app that allows asking questions with open answers - essentially a CRUD app with some user management (at least at the moment).
So, I see the video player there that's not that different from youtube one. Can you elaborate the feature you are interested in?
I'm.. not sure how to react to this :D
React is a library, yes. However, the consensus is that React refers to the ecosystem as a whole not just the library itself. That way it is comparable to Angular, Ember which are frameworks. 
I made a desktop bookmarking app with electron: https://darkle.github.io/MarkSearch/
This is awesome! Thanks!
All 50 elements in *box* are the same shared *boxRows* object. When you passing in *boxRows* you're not passing in a unique copy, you're passing in a reference. [Call by object-sharing](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing) \*edit: [50 unique boxRows](https://jsfiddle.net/g4djkxwb/)
There arent 3 of them, there is only one of them. boxRows is an array of 50 objects. There is one boxRows array. box is an array containing boxRows, the only one that exists, in each of its 50 elements. So box contains 50 references to the same array. box[1], box[2], and box[3] all point to the same thing. When you're changing box[anything][1], its going to be the same object. Only when you change the second index (1), will it be different because then you're referencing different objects in boxRows. If you want each of the box values to be different, you'll need to create new boxRows arrays for each of them.
Thanks :)
... why are you storing code on Dropbox?
It's a common problem for beginners throughout. I was in a bootcamp, and barely any attention was paid to the foundation of JS. JS and DOM should just be a crash course when you're a beginner. I'm still entry level but i'm picking up React. What's his deal with JSX? Especially now with template literals it makes things easier in my mind. I haven't used Angular or Ember, but I hate view engines like Handlebars. React feels much more natural to me when using a Flux architecture (Redux, like i had to say it). One way data binding, centralized store, immutable structures, pure functions, and modularity just make more logical sense to me. I think it enforces better habits when you're a less experienced Dev too, and certainly less side effects. I like React Router too, I'm really not 100% sure of all the differences between something like using Express to route and use API endpoints, but React Router so far has been logical. Another benefit is I just instinctly use WebPack/Babel which I think is a pretty sweet bundling kit, also transpiles my ES6 code and even ES7. But I haven't really scaled anything crazy, just personal projects. I do think JS and the DOM should be taught/learned exclusively, it's crazy how many Developers are out there that use frameworks as a crutch. Too many. 
Non-Mobile link: https://en.wikipedia.org/wiki/Law_of_Demeter *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^45388
This is great, thanks for making this.
Thanks! Glad you found it useful :)
If that wasn't obvious sarcasm, idk what is.
r/java
I Read that all over google results. But Would not find why it is good
Imagine websites could simply disable your adblocker.
OP is actually (strangely) saying that he prefers writing out types. Type inference would therefore be an anti-feature for him ;-)
Yeah, I probably over-reacted to the blogger, but I had been trying to google for foundation JS stuff and ended up reading his first two posts about frameworks are awesome and frameworks suck, and then I was like I know Reddit has to have something more like what I'm looking for, and this was the first thing I found haha. I realize there is value in frameworks, I'm just trying to learn some fundamentals and DOM stuff before I can find my place in all of that (cause there's a lot). I have more experience in Java, Python, and C/C++ (in that order), and I find that JavaScript is pretty flexible and straightforward (sometimes), but maybe it's my DOM knowledge that is lacking for me. I thought google script was super easy (for google sheets), but that's pretty different from actual front end stuff. Ok, so what do I typically want to do (at a basic level ) with JavaScript? (This is probably pretty noob) - DOM manipulation stuff for UX - XMLHttpRequest to interact with back end - Use JS to display data from AJAX responses (DOM again) So, I have done these things to some degree, probably not great, but definitely not with any confidence yet. So looking at the list I made, 2 of them involve some DOM stuff, which is probably where I am weakest so I'll work on that. Now for the actual language, I guess I'm still lost reading about "classes are bad", "classes are good", or "this way is the best way to OOP in JavaScript", or "don't OOP in JavaScript", "inheritance is even worse in JS", etc. Seems like the language is super flexible and there are a large variety of opinions about it as well. This contrasts my experience with Python which is a super flexible language, but the community seems to accept only the "pythonic way" (or most "correct") as the right way to do things. I just don't know enough to know what I'm doing yet to feel comfortable abstracting things away with a framework so I guess I'll worry about the DOM for now.
This is how I do it currently in Jest. let names = [ 'Adam', 'Bo', 'Ch@d', 'D', 'Ed!']; let expected = [true, true, false, false, false]; expect(names.map(testUserName)).toEqual(expected); A big disadvantage to this is that the test results you get back aren't very descriptive. The failure will say `Expected [true, true, false, false, false] Received [true, true, false, true, false]` (or whatever). But for me, the advantage is that this code is less likely to cause problems for me in the future. This is just my opinion, but for me, the #1 priority in testing -- by a huge, huge margin -- is that it be easy to do and easy to maintain as my project grows and as it ages. I've had to switch testing libraries too often in the past and an over-reliance on some advanced feature ended up meaning entire suites had to be rewritten from scratch. Even if I had to switch from Jest to something else, there is a good chance that I could do it with a few search-and-replaces. 
Can you give more detail? Are you talking about ES6 classes or prototype style subclassing
I made permutest (https://github.com/andrejewski/permutest) two years ago, which does about the same thing with multiple arrays also. I would say the benefits of permutest would be: 1) test framework agnostic, 2) you can put your test case inside permutest to give you some control of the test title given the inputs, which is a lot more readable that n tests with the same name. I am glad someone made something similar; it validates my belief in killing redundancy in tests.
If you know the basics and know how to read docs - you should be OK. I'd also be happy to help you with any problems on our discord channel.
Why don't you put the it(name + ' should result in' + bool, () =&gt; expect(...))
Thanks Tim.
 const names = ['n@me', '123Josh'] const valid = names.all(name =&gt; validateName(name)) expect(valid).to.be.false On mobile, but that should work out just fine.
In JS, you have to be careful that `this` is what you think it is. Unlike some other languages, the value of `this` in JS depends on *how you call the function that contains `this`*. Eg. class Game { foo() { console.log(this) } } let game = new Game game.foo() // game let foo = game.foo foo() // window Unless you're explicitly setting `this` using `.call()`, `.apply()`, or `.bind()` (or a few other more exotic cases), `this` will point to the thing to the left of the dot *when the function containing `this` is called*. In the examples above, `this` points to `game` the first time you call `foo` because the thing to the left of the dot in the first call is `game` (as in `game.foo()`). The second time you call it there is nothing to the left of the dot, so `this` is set to its default value, which in the browser is `window`. Does that make sense? 
The code in itParam builds as many `its` as there are array items. This causes excessive buildup and teardown of the code, running each beforeEach again. This might require variable reinstantiation or HTML interpolation, which is very time consuming. It can also lead to massive memory leaks if your HTML has event listeners that don't unbind during each iteration. If speed is your concern then you should do as others have said and write a single `it` with simple for loop or use an array's helpers such as forEach, or all. /u/stutterbug's [implementation](https://www.reddit.com/r/javascript/comments/60a10r/improve_your_javascript_unit_testing_with/df4trmx/) expects different values from the function, but you wouldn't want to test this way because you're changing the outcome of that one `it`. it('succeeds', function(){ ... let expected = [true, true, false, false, false]; ... //true or false? why would we expect it to not succeed? //build another it for the false cases instead }); /u/droctagonapus's [implementation](https://www.reddit.com/r/javascript/comments/60a10r/improve_your_javascript_unit_testing_with/df4vu2v/) is better because it uses one `it` and one type of expectation. You can use as many expects as you want, but in this case the one that's there doesn't have to dynamically switch from true to false. it('succeeds', function(){ const names = ['n@me', '123Josh'] const valid = names.all(name =&gt; validateName(name)) expect(valid).to.be.true //modified slightly }); I personally don't use "toBe()" in Jasmine tests (I know this is Mocha in the article) since [toEqual does a better job of testing for deep equality](http://stackoverflow.com/questions/22413009/jasmine-javascript-testing-tobe-vs-toequal). I would rewrite the above like this in Jasmine: it('succeeds', function(){ const names = ['n@me', '123Josh'] const valid = names.all(name =&gt; validateName(name)) expect(valid).toEqual(true) }); Here's a forEach example: it('succeeds', function(){ const names = ['n@me', '123Josh']; const valid = true; names.forEach(name =&gt; { valid = valid &amp;&amp; validateName(name); }); expect(valid).toEqual(true) }); And a for loop: it('succeeds', function(){ const names = ['n@me', '123Josh']; const valid = true; for(let name of names){ valid = valid &amp;&amp; validateName(name); }); expect(valid).toEqual(true) }); The lesson here is don't add excessive "its" which test the same thing when you can modify the input and test within the same "it". You can create as many "expects" as you want, but limit the number of "its" that you create to match the number of code paths (paths created by blocks of code such as if/elses).
I'm a bit confused here. Why do you include a second parameter to 'map'. In the [documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), the 2nd parameter to map is always an optional 'thisArg'.
My point is that your argument against using React is the same argument some have against using jQuery. Don't get so defensive.
NEVERMIND! Sorry, user error, works great! I can't thank you enough!
just so you know, HLTV will block you once they notice this.
My suggestion would be to just find something you would like to make, pick a framework you would like to learn or looks like something you'd like, and make it. It doesn't really matter as much of what you make, but rather how you make it. It does help slightly to use a more popular framework to help integrating with an existing team, but you could go with plain JS, though that would likely take a lot more time. Really learning various frameworks and libraries is really less about learning the framework, itself, and more about learning how to use them in a meaningful way. There are a lot more wrong ways to do something, so you just have to get experience with it so you can learn the *right* ways. You can conceptualize things for a long time, but realize it doesn't work in practice. Really, portfolio projects should just showcase that you know *how* to do things, rather than exactly what it is that you're doing. Have good practices. Use proper version control, use industry best practices, make sure your code is understandable, document your code well, implement testing when necessary, etc.
/u/ugwe43to874nf4 has got it right. Also, bounce should be be defined outside the constructor, like... Ball.prototype.bounce = function() { this.vel.add(this.acc); this.loc.add(this.vel); ellipse(this.loc.x, this.loc.y, 50, 50); if (this.loc.y &gt;= 425) { this.vel.y = 0.8*(this.vel.y * -1); } if (this.loc.y &gt; 425) { this.loc.y = 425; } } That way it doesn't have to instantiate a new copy of the function every time you create a new ball. It just goes and looks up the function on the prototype.
I am not willing to spend the time to do that considering I am struggling to make up lost time on my open source application while drinking from a fire-hose learning CCNA material at a military school. If you are actually interested in the numbers here is how you experiment for it: * Create a table with 5 columns and 30,000 rows with text in each table cell. * Inject the table into the DOM by any means. innerHTML of a string will probably the fastest way. * Change the text in the 3rd column of row 27,005. A simplified vanilla JS approach would just be something like: table.getElementsByTagName("tr")[27004].getElementsByTagName("td")[2].innerHTML = "my new text"; I am thinking that would execute faster than making an equivalent change to a React component. If this is not satisfactory for you then I will concede I am completely wrong and simply move on to maintaining my own application.
Yes, that is *much* better. Good work :)
Thanks for your quick answer but i thought of something like the GoF Design Patterns or something more JS related... Any ideas?
If you're programming in an OO style then probably most OO patterns hold. On the other hand if you're programming more in a more functional style, then [this slide](http://blog.cleancoder.com/uncle-bob/images/fpvsoo.jpg) comes to mind.
Ah gotcha. 
No no no no please never do this. The most useful thing when you're writing a unit test is the error message that it will produce. Unit tests are most useful when they're failing, because that tells you that something is wrong with your code. The next step, then, is to work out what exactly *is* wrong with your code, so you can fix it (or change the test to match). The minimum possible amount of information is whether the test passed or not. However, if this is all you've got, it's on you to then work out why the test failed. More work for you means slower bugfixing. For example, say we've got two objects, and we expect them to be "deeply" equal to each other. We've got two options: const expected = // ... const actual = testFunction(/* ... */); expect(_.isEqual(expected, actual)).to.be.true expect(actual).to.equal(expected) (I have no idea what the correct assertion here is in this library - I'm more of a Jasmine guy! Assume these to be identical for now.) If the first one fails, we know that expected and actual are different. However, if the second one fails, we will almost certainly get a printout of exactly why the assertion failed, and where the differences are. In 90% of the cases where I'm debugging failing unit tests, this is the point at which I suddenly realise the stupidly obvious mistake I made, and fix it straight away without even turning on the debugger or adding a print statement. Not having this information is mildly irritating, but at least you know what the failing inputs are, and can go and print them out. Your method adds an extra layer of indirection - not only will your assertion library be unable to tell you exactly what the differences between the expected and result are, but you also won't know which expected value failed. There's less information by default, which means you need to go and find more information when something breaks. /u/Buckwheat469 raises a good point that too many `it` blocks could impact performance and cause other problems, but there's a way to use a single `it` block, *and* get full-fat assertions, and that's by putting the assertion itself in the loop: const names = ['n@me', '123Josh']; const valid = names.forEach(name =&gt; { expect(validate(name)).to.be.false; }); This way, we get genuinely helpful assertions that are applied to all the parameterised values. Plus, depending on how your assertion library throws assertions, this may not necessarily fail as soon as it hits the first invalid case, meaning you'll be able to see how many different parameters are failing.
Thank you! :) And, thanks for sharing. :)
Good point about knowing which expectation failed. In retrospect I would move the expect block inside the loop and add a handy message to show what you're testing with the (possibly undocumented) Jasmine comment code (not sure if Mocha has something similar): expect(someObject.returnWhateverIsGiven(true)).toBe(true, 'should return true when given true'); You can also create your own custom matcher which outputs a custom comment.
Hey there! Nice that you are learning to programm. As you already noticed Java and JavaScript are not the same But regardless, many *problems* can be solved in similar ways even though the languages are different. To compare user input you could first transform the text to lower case, this will disregard any different casing the user might have used. In Java: String s = "Hello World"; System.out.print(s.toLowerCase()); In JavaScript: var s = "Hello World"; console.log(s.toLowerCase()); Both returns: hello world For reference I can recommend [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript). It is a great source to look up the JS Documentation, with all its functions. For a later date you might want to research a bit about input sanitization (like for example [validator.js](https://github.com/chriso/validator.js)) For learning the basics I can also recommend [codeacademy](https://www.codecademy.com/learn/javascript), they have great courses which will teach you the basic elements of many languages. 
Also, stackoverflow mate
&gt; var skip = function () {} new MutationObserver(skip) Right so this is what I have to paste in my script? I'm really a noob in that coding haha. Sorry for that, tried to understand as much as I could! 
Sure man, I'll refresh reddit in an hour to see your reply. Thanks alot!! Do you know of any userscripts that you recommend for productivity?
This is unrelated to modules. Look at `i &lt; numberOfPlayers.length`. `numberOfPlayers` is a number. `numberOfPlayers.length` is `undefined`. `0 &lt; undefined` is `false`. A static typechecker such as TypeScript or Flow can catch these kinds of coding errors.
wish i had had more simple, easy broken down, and modern real world examples of how the dom and html elements relate, via the javascript object models
Cool (: One small problem I'm having, the script does not work in youtube playlists:( Not a problem if you can't solve it though, you helped me enough already. In addition, is there any way to force youtube to play at lowest quality? I tried installing few scripts from userscripts-mirror.org but none of them seem to be working.. Thanks alot man
In regards to your lowest quality thing, I think that's just something you should change in your YouTube preferences. It'll be an utter bollock to implement it by just making javascript kinda "fake click" elements in the DOM.
Why is an additional package needed for this? I generally just iterate over the inputs and `expect` on each output. describe('Test form validation', () =&gt; { it('will reject invalid inputs', () =&gt; { var inputs = ['Adam5', 'Ad@m', 'Ad-am']; inputs.forEach(input =&gt; expect(validateName(input)).to.be.false); }); }); This seems to be an equivalent to me. It also appears that [mocha-param will create an `it` statement for every input](https://github.com/mikejsdev/mocha-param/blob/master/lib/index.js), which means an individual unit is made for every individual input. It's okay for a unit to cover multiple inputs, I don't really see why I'd want to generate an exponential number of unit tests. For example, instead of function itParam (desc, data, callback) { data.forEach(val =&gt; { it(desc, () =&gt; callback(val)) }); } it seems more ideal to do function itParam (desc, data, callback) { it(desc, () =&gt; { data.forEach(callback) }) } And at that point, it seems a bit overkill to need a library for this. 
It is not waiting 20 seconds though, it's skipping directly in the playlist. It works fine if it's not a playlist. Also, any way to force low quality playing(144p or 240p if that's the minimum). Thanks alot
Yeah sorry about that, seems that the event that catches DOM changes fires more than once which sends it into a spaz. This is better: // ==UserScript== // @name Youtube skip // @match *://*.youtube.com/watch?v=* // ==/UserScript== var resetting = false; var reset = function () { if (resetting) { return; } resetting = true; var waitTime = 20; // Change this to the number of seconds to play the video for var nextLink = document.querySelector(".ytp-next-button"); setTimeout(() =&gt; { resetting = false; nextLink.click(); }, waitTime * 1000); }; // select the target node var target = document.getElementById('movie_player'); // create an observer instance var observer = new MutationObserver(reset); // configuration of the observer: var config = { attributes: true, childList: true, characterData: true }; // pass in the target node, as well as the observer options observer.observe(target, config); Only problem with this method is that it's waiting the 20 seconds on video change but it doesn't know anything about video being paused or any other kind of interaction, so it's naturally going to be super buggy. The only way to get solid results is a) find the events being fired and listen in properly, b) write long and irritating code to account for every action, c) make this whole skip-after-20-seconds thing outside of a userscript and use proper APIs. All these options are going to be effort to implement mind. Also it's 11:30pm where I am so I will have to do that sleeping shit soon ha
&gt; Example for 2: JSON shown above could be split into at least 3 prototypes: Places (which is a list), Place(which is a concrete place), Person (for every famousPeople in a place). It would probably be better to just have a Person and Place object(prototype). Places is just a Place array. Maybe I'm misunderstanding you, but you don't need a `Places` class if it's just an array. &gt; This looks like huge performance hit, is it worth? Maybe if you're streaming real time financial data or something like that, but for most apps I doubt this is going to matter so much. It take my machine 1ms to instantiate 1k Place Objects. Now, for if it's "worth", in your example it appears as though you're just treating it as data, so it makes little sense to instantiate (imo). 
Not working in the playlists, nor in the normal videos now haha(:
Ah shit lol. Sorry, dunno. Will look again tomorrow
No worries mate, sound previous advice though, cheers and goodnight hahah(:
hahahah no man I didn't even know about that pay for view thing, cool. I am just using it as a tool to keep playing new music till I find a track I like(: Thanks for the advice! The code is working. Do you know of any script I could force youtube to play at lowest quality? Cheers (:
A setting in Uglify controls that behavior. By setting toplevel: true it will mangle even top level functions. I did it to force the most aggressive Uglify settings possible. In this particular example it will be ok since there is no "external" API to worry about.
Fastest ui libraries doesn't even walk the DOM the way you are describing, they store references to DOM nodes in javascript objects, so they can immediately get access to the node they want to update. Nothing that I'll tell would change your mind, and the easiest way for you to learn is just take that simple example (108 lines of code) and implement it in a way, so it can at least beat React performance. Don't try to beat fastest virtual dom libraries, you'll need to learn alot before you'll try to do so.
You might try looking for some Gitter rooms for what ever libraries or packages you use most.
I wrote a small tool to do a similar thing with Tape last year: [tape-scenario](https://github.com/ksmithbaylor/tape-scenario). I also ported it to Jest when my team switched recently ([jest-scenario](https://github.com/ksmithbaylor/jest-scenario)). It's definitely nice for some cases, but we found that a lot of times it is simpler and easier to understand tests when they aren't necessarily DRY.
JS.LA has one. Check the site for details. 
Here's a codepen example. You can compare it to the above answer: http://codepen.io/anon/pen/ZerEWv?editors=0010 The point is that each ball shouldn't have to carry a copy of its methods like bounce around with it when its prototype (the object that contains all the properties universal to every ball) already has it. You can think of it sort of like cloud storage for the balls. :) When you start using ES6, you'll encounter the `class` keyword which makes this syntax a little prettier (you won't see the .prototype, e.g.) but it's still good to understand what's going on under the hood. Let's say you wanted to make falling ball program into a snow particle system. If you had to make thousands of these little balls, you wouldn't want to have unneeded baggage (a new instance of the bounce method) for each one. Only the stuff unique to any given ball should be inside the constructor.
Because the first thing everyone does with JS at the moment is reach for a library, even with trivial things like this or an isNull check.
Inside the game class have an object which holds whether or not a key is pressed. Call it current_keys or something. So in the game.keyDown function, if you press up, you set current_keys[ 'up' ] = true. When you unpress up in the game.keyUp function, you set current_keys[ 'up' ] = false. Then back inside the game.keyDown method, check if current_keys[ 'up' ] is already true. If it is, then just return early. Something like this: module.exports = class Game { constructor() this.current_keys = {}; ... } keyUp( ev ) { if( this.current_keys[ ev.which ] ){ return; } this.current_keys[ ev.which ] = true; if( ev.which === 38 ) { // 38 is the 'up' key this.jump() // or however you jump. } } keyDown( ev ) { this.current_keys[ ev.which ] = false; } } 
If you are going to create a bunch of copies of a class-like object in Javascript, you probably want to use a prototype. If you only really have one then it doesn't really matter. Also if you're manipulating data that's just going to get converted back into json, its better just to leave it as an Object without processing it into a prototype class 99% of the time. For simplicity's sake.
Map is technically wrong in this case because you're causing side effects by changing nodes outside the function scope. A map implies a new collection of nodes is created which isn't the case, you're modifying nodes within an existing collection. 
From what I've seen they aren't opposed to JS in general, only with specific libs you might be better off somewhere else.
The downside is that you reduce the isolation of your tests, increasing the chance of tests influencing each other and a failure in one leading to a failure in another. Also, I consider an important function of tests to be to track down the source of an error, rather than finding that there's an error in the first place. That is made more difficult with enormous tests with many expects. An alternative is to aim for more efficient setups and teardowns. This could e.g. be something to consider when picking a framework, where virtual-dom frameworks are often faster than frameworks where you have to instantiate a browser and interpolate HTML.
Just jumped in - this is amazing!
I'm trying this from Safari, but I'll try in Firefox and get back to you 
Tried it with Firefox and worked, like you said. Now is there a way to correctly fix this? I'm guessing that "fixing" it that way isn't really fixing it right?
For me it feels like they only want to scratch the surface. In the docs of AngularJS (1.x) they went even into the deep stuff. Well we are at the beginning I suppose and I hope they fix some of those stuff. I still dont understand where $compile went. In some of my previous projects it was essential
That's great. I'm glad you like it! See you in there.
Oh my. It was getting late last night. Thanks so much for the heads up. I think I tend to get full of myself and whenever I face a problem decide its probably much more technical than it ever ends up being.
bin is no longer available
&gt; Fastest ui libraries doesn't even walk the DOM the way you are describing Mithril does, but this is a different conversation. The subject here is that React is less efficient at simply updating a complex interface already present in the document than simply walking the DOM. The weird scenario I described actually isn't weird or an edge case.
&gt; Mithril does, but this is a different conversation. No, it doesn't :) It stores refs to DOM nodes on vnodes when they are instantiated, and never walks the DOM with DOM api, because it is slow. You obviously have no idea how modern UI libraries like React and mithril are working internally.
It's one simple tutorial. Personally, I've never gained significant understanding of anything by completing a couple hours tutorial or lesson. 
None of your business. It's personal.
&gt; and never walks the DOM with DOM api, because it is slow. Walking the DOM isn't slow. You have benchmarks for that? Yes, it is slower than executing only synchronous JavaScript logic, but it is still faster than everything else including updating any sort of presentation. Mithril stores DOM nodes as references just like most vanilla JS apps do, but it still has to be able to interface with the DOM to access nodes already present. Mithril's API is a shallow layer over the DOM methods which is why it's so much faster than all other frameworks. &gt; You obviously have no idea how modern UI libraries like React and mithril are working internally. Perhaps, but I know how to make applications fast and read benchmarks.
To make the most whilst working the least. 
Vagrant using Ubuntu (whichever ver matches requirements) and then whichever tech stack im using, usually Apache or node. For tests specifically usually phpunit or karma/jasmine
That is a really good course! Thank you very much. I'm looking forward to the next series.
Thanks, really glad to hear you liked it :) What would you personally want to see next series talk about?
I clicked it just now and http://schalk.net:3055 loaded. The site was unavailable for about one minute yesterday. Might that explain your getting no response. Did you see error code 404? Or did the page load but one of the demonstrations failed to perform properly? I would be very grateful if you would try again and tell me exactly what your screen shows immediately after you click the link. 
make $$$ its all about the benjamins
Hi /u/fakiolinho, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/backefrain, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I’ve written a series of books explaining JavaScript to programmers. They are free to read online: http://exploringjs.com/
That was my location history entering and leaving my home. Couldn't publish actual client data. 
As /u/mikejoro said, the Reactiflux community is a great place to hang out. We primarily discuss React + related technologies. Invite link is at https://www.reactiflux.com . 
This is the internet. Use `/s`
CoffeeScript, on the other hand, was a terrible idea.
The gitter for freecodecamp is pretty good if you're a relative beginner
I don't see how this is a good decision mechanism. Redux state isn't persisted across refresh...
Redux = data grabbing and global state that's shared across more than one component. setState = silo'ed state that is isolated from other components.
Yup, covering that was an obnoxious meeting and i will always regret suggesting 'of' as the context dependent keyword rather than ':'. I can't recall whether there was a rational for that not being feasible.
This is the correct answer. Do very disparate components need access to the same data? Use Redux. Everything else can be local. 
I'll quote the relevant section of the Redux FAQ, at http://redux.js.org/docs/faq/OrganizingState.html#organizing-state-only-redux-state : &gt; **Using local component state is fine**. As a developer, it is your job to determine what kinds of state make up your application, and where each piece of state should live. Find a balance that works for you, and go with it. &gt; Some common rules of thumb for determing what kind of data should be put into Redux: &gt; - Do other parts of the application care about this data? &gt; - Do you need to be able to create further derived data based on this original data? &gt; - Is the same data being used to drive multiple components? &gt; - Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)? &gt; - Do you want to cache the data (ie, use what's in state if it's already there instead of re-requesting it)?
Well, if you're iterating a plain object the hasOwnProperty check is quite obsolete, because it consists of own properties only by design. 
&gt; all No. 
&gt; Do very disparate components need access to the same data? Use Redux. Everything else can be local. The factor should be "application applicability", if the data is important to the application, part of the application's schema if you will, if you could imagine it being persisted, it should be in Redux. setState is the widget's temporary/internal state (hence the name) e.g. a current input state ("scratchpad" for the widget) or a visibility status. And *even then* it could actually be useful to globalise it and keep it around. It's got nothing to do with "disparate components".
ps:it the effect cannot be viewed on mobile
 function get() { const path = arguments const length = path.length return function(value) { let index = -1 while (++index &lt; length &amp;&amp; !isPrimitive(value)) { const key = path[index] value = value[key] } if (index) return value } } function isPrimitive(value) { return value == null || typeof value != 'object' &amp;&amp; typeof value != 'function' } Returns the (nested) property value, or `undefined`. const getConstructorName = get('constructor', 'name') getConstuctorName([1,2,3]) // "Array" getConstructorName(null) // undefined
He's using https://threejs.org/docs/api/math/Vector3.html here's an intro to particle systems: https://www.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-particle-systems/a/intro-to-particle-systems
My knowledge of redux is limited but since state is centralized and mapped to actions, things like time travel become more accessible, as opposed to all components needing some sort of API specific re-hydration process. So serializing / deserializing application (store) state is an advantage you get from using redux.
I understand the idea behind framework performance is to minimize loss of execution speed in using a more convenient interface and reducing cognitive load is important. What I don't get is the complete lack of objectivity and nearly fanatical cognitive conservatism I frequently encounter on this subject. For some reason the mere mention of vanilla JS or DOM scares the shit out of people. It is as though they are corrupt ministers who fear exposure for fraud more than the death of their family or bankruptcy. I have found your ad hominems and inability to follow a simple conversation in the face of minor technical challenges very off putting. &gt; Even I won't be able to do it, and I know a little bit about performance :) I don't believe you and I don't believe you really care. Although this may be your stated objective your primary point appears something completely different.
Is using the callback inside the setTimeout() function the only way to do it, because for my case I see no reason to pass a callback to console.log(), I could simply do `console.log(data)` instead of `cb(data)`. Is there any other way? Edit: Now it makes sense, it should be a function because this way I can do whatever I want with my data, but the above question still remains valid ;)
Yeah thanks, I've since downloaded MAMP and set it up (there wasn't much setting up at all) and all is fine now :) Thanks for the help
&gt; I see no reason to pass a callback to console.log(), I could simply do console.log(data) instead of cb(data). Is there any other way? You're not passing a callback to `console.log`. `console.log` *is itself the callback.*`cb` can be any function you want, including `console.log`. Try this: function fetch(cb) { setTimeout(() =&gt; { cb("Hello!"); }, 1000); } fetch(console.log);
Looks to me like requestAnimationFrame(run); Should be changed to requestAnimationFrame(() =&gt; run(Date.now())); // edit - changed syntax
I finally got this thanks to you, now I can move on to promises and generators. Thanks again dude, you told me things I've never read before. `without ever caring about the return value`, This really made me get it!
From the article: &gt;It allows adding more than a single handler for an event. This is particularly useful for DHTML libraries or Mozilla extensions that need to work well with other libraries/extensions. &gt;It gives you finer-grained control of the phase when the listener gets activated (capturing vs. bubbling). &gt;It works on any DOM element, not just HTML elements. Ultimately preference is going to be based on you or any styleguides in your code. The speed difference is negligible and there shouldn't be a memory difference. You posted the two uses, so you can see the stylistic difference yourself. Ultimately, unless you have to have explicit support for those older browsers I would lean towards using the newer version since it adds more support without paying any real penalty.
and yes, you need to do it in the setTimeout because that's when data is defined. You have no other way to access data. Even if you declare it outside of the setTimeout, that value only gets set _within_ the timeout handler - all of the code not within the handler has long since executed, including anything below the setTimeout call (where your return was before).
[requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) passes a timestamp in to the callback.
If you call `fetch` function the value will be undefined because you returned data before `data = {"Hello":"world"}`. The best thing to do is to use` Promises` or `async await` or CPS ( callback passing style ). All this techniques hav already been explained by /user/senocular and /user/kwazykupcake_
I am working on something similar, interesting to see how you are doing it :)
Has nothing to do with JavaScript. It is a standard mathematical operator: https://en.wikipedia.org/wiki/Modulo_operation
It returns the remainder. function mod (a, b) { return ((a / b) - Math.floor(a / b)) * b; }
That doesn't mean the analogy is useless though. Instead of a page refresh, you could think of it as navigating to another page in a routed SPA.
% is actually remainder, not mod. There is no mod (yet). As a remainder operator it simply returns the remainder of the division between the two numbers 43 / 10 = 4 rem 3 =&gt; 43 % 10 = 3 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_()
what about adding more than one event listener to the same element? with the second one you can't. I'd definitely use addEventListener
You will need to wrap everything in a function that you can call again. function game_start () { var user = prompt(); // ... } function compare (c1,c2) { if (c1 == c2) { if (confirm('Tie! Do you want to play agian?')) { game_start(); } else { // ... } } // ... }
Lovely, the more the merrier. I figured I'd simply throw together a quick solution for testing/prototyping purposes, then just improve it to suit people's needs a bit more as time goes on.
**This isn't best solution, but should work.** I think you could just add: else if (c1=="rock" **&amp;&amp; c2 != "rock"**) else if (c1=="paper" **&amp;&amp; c2 != "paper"**) else if (c1=="scissors" **&amp;&amp; c2 != "scissors"** ) 
&gt; It's got nothing to do with "disparate components". Of course it does, because the alternative requires you to pipe a common `prop` through your entire DOM tree, when it would be way easier to just `connect` it to the store. This is literally why `connect` exists, so you don't have to pipe your `props` wherever you go, which necessarily means various, unrelated components can access the same data. Edit: Lol this was literally lifted from the docs you guys: http://redux.js.org/docs/faq/OrganizingState.html
You shouldn't treat Redux as a database, that's only going to lead to an inefficient and slow application. That would not scale at all. It's also not how Redux was intended to be used; one is simply describing your application and what it needs to function in a particular instance, the other is a persistent data store. Application state, and data state, are two very different things! Store only what you need and nothing more, otherwise you're using up memory pointlessly. If you fetch something from an API, store only what is relevant to your application.
It's pretty standard to persist your store across refreshes
Sure you can!
&gt;I understand the idea behind framework performance is to minimize loss of execution speed in using a more convenient interface and reducing cognitive load is important. If your application just modifies some value in a huge table with 30k rows, then I guess yes, you can beat React and it is easy, I just haven't seen such applications. As soon as your application changes the shape of the DOM tree in response to some data snapshot sent from the server, it is highly unlikely that you'll be able to do it efficiently without some kind of abstraction like React, and that is what is actually important, because during this operations you will trigger long-running reflows, etc, and that is why such cases should be fast. It is about performance of real applications, not some weird scenarios that are easy to implement with vanilla. I don't see any point in discussing it any further, I give up :) I just hope that you've learned that React has a mechanism to update DOM nodes, and without it everything will be broken, because DOM nodes have internal state like scroll positions, input values, iframes, etc.
Recompse [withState](https://github.com/acdlite/recompose/blob/master/docs/API.md#withstate) gives you the best of both. A piece of state can start as local component state, if it needs to be moved to redux, just takeout `withState` and use `connect` instead. The wrapped component remain pure and unchanged.
Actually... once you start getting into normalizing data in your store, Redux becomes almost _exactly_ like a small client-side database. As a few points of reference, see [Redux Docs: Normalizing State Shape](http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html), a [Redux-ORM issue discussing managing relational data](https://github.com/tommikaikkonen/redux-orm/issues/13), and a recent article on [SQL view-like "key windows" for selecting normalized state](https://medium.com/@dcousineau/advanced-redux-entity-normalization-f5f1fe2aefc5).
My mistake, I think I had it confused with generator functions. Very good article by the way :)
thank you I tried but did not work again. 2 function I called again but ..
None of what you've linked points to Redux being a database... There are similarities but also fundamental differences. By that logic, any JSON object could arguably be "*exactly*" like a small client-side database. A database is a persistent data store, whereas a Redux store is a description of your application and the data which *that specific instance of your application* needs to function. It isn't necessarily going to be persisted, if it is persisted across loads, that's what you use an *actual* database for. A Redux store could be a subset of data in your database, but that doesn't making it a database, and in almost every real-world situation it will also be a description of your application. Not to mention, loading that much data into memory is going to *create* redundancy, hence why you only take what you need. This is one of the core tenants of good store design. Data normalisation is all about reducing data redundancy, making it more comprehensible and easier to work with. Just because it's intrinsic to database design doesn't mean that normalisation can't be used elsewhere.
[removed]
What's the problem exactly? I fail to see how Rails affects your JavaScript test framework.
Amazing! Shall check it out now :) thanks for that one 
Did you at least try to google "question mark in URL"?
I am definitely going to take a look at Passport since you took the time to reach out. Going to make an account and check it out. Thank you.
Since I'm currently getting myself familiar with AWS, a series such as yours that uses AWS services/infrastructure would be really cool. As for the topics you suggest yourself I'd pick: - Building real-time apps using WebSockets (or maybe with GraphQL and it's new "subscribe" method?!) - Adding features (e.g. offline, push notifications) using Service Workers :)
Not at all, the article is rather strange. The author simply complains about the ecosystem and then complains about spending hours looking for twelve lines of code that could have been written in under ten minutes. I've never understood "JS fatigue" and I feel the author is grasping at straws for something to complain about.
Note that the timestamp is different from a Date instance.
I'm curious, why not use Twitch's official API instead of a third party one?
I do not have an answer to that. Maybe it is completely useless? I just found it interesting that one can grab HTML comments out of the DOM and evaluate them, if they happen to contain JavaScript.
I haven't really worked that much with AWS (mostly use either our own or hosted servers), but I can try to look into it. Any specific things you want to see about AWS? Other feedback noted, thanks! :)
it would be much faster to use DOMParser instead
`7 + "3"` becomes `"73"` (note that it's a string), which essentially means you're calculating `43 % 73`. So the answer is indeed `43` in that case. Bottom line is always be aware of type coercion.
I've been searching for anything related to excel in node.js, and unfortunately, there is absolutely nothing really complete. node-xlsx is the best library available and it still lacks some features. If you need to manipulate excel files from any kind of server, you're pretty much doomed to use PHP, Java or ASP.Net, but node.js is - for now, hopefully that will change in the future - not able to do it properly.
there are still other methods for parsing HTML, using regex is not a recommended one
It now trend to criticize javascript while we forgot its favor on us.
First, it is static or Dynamic site. If static no issue in using plain code Also, dont't forget to get minimisation on your Javascript code
Why don't you declare x outside of the object? var something = 100; var obj = { x: something y: something + 100 }
Yes , but can't object access its own values ?
Wow, there's a lot to unpack here... Rails being an MVC framework doesn't really impact your JS code. The basic flow in Rails (and other MVCs) is: request comes in and gets routed to a controller, the controller does some logic (maybe pulls some data from a database), then renders a view (HTML, JSON, etc). The view is likely where your selectors would be with some HTML elements with classes or ids. That JS code is probably loaded automatically by Rails (there's lots of "magic" autoloading in Rails that's confusing if you're not used to it). jQuery objects are just wrappers around collections of HTML elements that you can do particular [jQuery things](http://api.jquery.com/) on (hide, show, animate, toggle, etc, etc). So I'm not sure what the purpose of that code snippet is, but it looks like given a list of CSS selectors, it's looping through them and finding them in an HTML container and storing them in another object. `this.tp[key]` is just a different JS object syntax but using the bracket notation because `key` is dynamic as it goes through that loop. Setting up your JS unit tests for Rails should be similar to any other framework, you just might have to configure Mocha/Jasmine to look in a different directory to find your tests.
This week I used CSS to make the on-line demonstration of my project more visually presentable. I also added a section for comments. The demonstration shows monads encapsulating state and procedures in a Cycle.js application. It is meant to be run on desktop computers. You can find it at [JavaScript Monads](http://schalk.net:3055).
Nice insights here. I disagree about 'knex' and 'bookshelf' being "not well known", but the sentiment about how complex everything feels is something I can relate to. I think that feeling has more to do with our past experiences, though. Products like ASP.net MVC and Rails hide so much of the complexity from you, that web dev feels much easier than it truly is. There are some more "ready out of the box" solutions out there like Adonis, Sails, and Feathers if you end up giving Node another try. I'm currently about 50% through a project using Hapi, and keep considering scrapping it and using ASP.net Core w/ MVC &amp; Identity. C# just makes me feel more confident that I haven't forgotten to handle an error somewhere.
I guess maybe that's my problem. I thought rails DID affect it.
Thanks, this is helpful. I had Mocha working originally...but for some of them I had to interact with the DOM...and mocha doesn't come with fixtures automatically. Do you know if theirs some way to make a HTML Snippet in the code (Mocha) to just have it check on? I would use teaspoon, but I had a hell of a time getting it to work, im not sure if it's because some of these modules are ES6.
Following from your edit, I think this is even more better: ``` export const widthInPxToPercentageImplementation = (widthInPx, screenWidth) =&gt; (widthInPx * 100) / screenWidth; ``` ``` export const widthInPxToPercentage = widthInPx =&gt; widthInPxToPercentageImplementation(widthInPx, Dimensions.get('window').width); ``` The top function does not need to call a potentially side-effecting function and only deals in easily plugged values.
I would start with a blog series/video series that you work through the ideas/concepts that will go inside of the book. That way you can iterate over the ideas/topics in the book and when you find your voice and how to express those ideas, you can format it into a book
What would you want to see from these examples? I'm currently working on a video series that will walk you through browser-side JS and my idea is to start with nothing and build our own UI library in order to understand how the DOM works and what React/Vue/Angular/et al are abstracting away from.
And my whole point was that treating it like a database is the wrong way to use it, and normalisation doesn't make it more like a database; it just makes the data more manageable.
Uh, there is [this](https://www.npmjs.com/package/ts-node)...
any other webdevs find the inspector *mildly fucking infuriating*? Like when you could only copy/select css text in the inspector by dragging the cursor from the bottom up and not from the top down? or how opening an object in the console will randomly spazz out and scroll to the bottom of the page? Don't rely on the chrome inspector for your work flow. It's an awesome tool, but holy fuck is it buggy. 
Oh whoops, wrote it on my phone on my way home from work. Fixed it, I also declared the index in the the outer function which was problematic on reuse.
Yes indeed, I appreciate the humor. In this case there is not much value in using a high-order function, the pattern is valid and useful though in many cases (the blog post explicitly calls out the fact that in practice the parameters will often be high-order functions).
&gt; completely dead minus a few big-name projects. Gosh, how terrible. Imagine only needing one or two dependencies in a project. That'd be just awful.
See [JSFiddle](https://jsfiddle.net/jkemyj4x/). As SamSlate mentioned, you're not yielding a promise, which is how `async`/`await` works. All `await` will do is wrap the invocation in `Promise.resolve`, which is not what you need, as the only effect will be making the `wait` invocation asynchronous, however it wouldn't take into consideration the `setTimeout`.
The problem is that `return` is scoped to the function it's inside. The callback you've passed to `setTimeout` returns `'i am done'`. Your `wait` function returns `undefined` since it really returns nothing. The only way to do this with `setTimeout` is using a Promise constructor ( which otherwise is advised against in most cases ). async function wait (time) { return new Promise(resolve =&gt; { return setTimeout(() =&gt; { resolve('i am done') }, time) }) } async function main () { let p = await wait(2000) console.log(p) // -&gt; 'i am done' } main() But it would be better to have a generic `wait` function. async function doSomething () { return 'i am done' } async function wait (time) { return new Promise(resolve =&gt; { return setTimeout(resolve, time) }) } async function main () { await wait(2000) let p = await doSomething() console.log(p) // -&gt; 'i am done' } main() 
Did not know you could that - would think the underlying "compiler" would have a hard time understanding the scope of the return statement. I may be way off though
The only reason I'll include them is simply for readability and/or scoping. In your above example, both are technically fine, but again I prefer the first simply for readability (it makes the component from a reader's perspective feel more like nested HTML). Nonetheless, you can even just one-line it via es6: SomeComponent = () =&gt; &lt;Component&gt;&lt;SomeChild/&gt;&lt;/Component&gt; ** edit ** another example where scoping them is useful (e.g. more readable, especially on large components) is when you want to render different components/HTML based on some conditions; e.g. const SomeComponent = ({ someProp }) =&gt; someProp === 'someTest' ? ( &lt;ExampleComponent1/&gt; ) : ( &lt;ExampleComponent2/&gt; )
that is so awesome, thank you so much! Just a quick question, where can I find all the syntax errors? 
Not upon creation - and not like that. A = { x: 100 } A.y = A.x + 100 That would work, but....
https://github.com/agershun/alasql Found AlaSQL, it resembles familiar SQL syntax.
The embed tag is using a plugin to render the content. The DOM isn't involved at all. You might be able to read the PDF as binary data with an XHR request, but you would then need to parse it in JS as well.
Great, if you are interested in a quick walk through of our platform don't hesitate to reach out (kelly@inversoft.com) 
In terms of what?
thank you both for you fast replies:)
Very informative article 
Here is a TLDR: &gt; This is Mozilla's draft proposal for the GPU API for the Web, called Obsidian. It is a low-level API that provides maximum feature set of the GPU to the web applications. The API is designed for WebAssembly, modern GPUs, and multi-threaded environment in mind. Also, [here is the Github page](https://github.com/KhronosGroup/WebGLNext-Proposals/tree/master/Obsidian-Mozilla).
Pardon, what question do you mean? From a guest? For me that was a part of the discussion (in general), because I also have a boss who doesn't happy with "new features" just because... You know. So Axel's answers were useful.
Nice!
Does it _have_ to be a string? [sift](https://github.com/crcn/sift.js) is actually pretty cool, but you provide a filter object, not a string. Filtering can still be dynamic, and if you need to send data over http / whatever, you can stringify the filter and put it in a query string (or whatever).
I'm intrigued by the whole "serverless" movement, so anything on how to create a backend with API Gateway and Lambda would be swell. Especially working with a Framework for that such as "Serverless". You're welcome :)
Ah, that makes more sense. Tbh, I know Jasmine does it, and I know Node's built-in assert doesn't - I honestly haven't really noticed the others. I think Jasmine is in the minority, though.
uugggghhhhhh.... JavaScript is less good out of the box because the dude cannot write code elegantly enough without a transpiler and diving into the limbo of a billion NPM package configuration stupidity. All the examples he gave for cannot live without NPM I have easily written on my own. Yes, JavaScript is still a write and refresh language.
Thanks, will have a look!
I've been at this on and off for about a week now. Lol. Having trouble bypassing the authentication. I have a tp-link wr841n with v.9 firmware. Using insomnia to modify the url coding but it bounces back saying I don't have authorization. Any suggestions on what next?
This is awesome. Thank you 
Well.... WebAssembly turned out well. Can't wait for this to be mainstream :) With all the async Rust under the hood I bet Firefox will be really fast with the GPUs soon.
why not just link to the github?
At this point it's really ignore it (or Flow) at your own peril.
Fundamentals focused.
For explanatory purposes 
Sure Python has a better standard library (I would fully admit that Javascript needs a better one) but there are more projects (like redux or numpy) that don't belong in that category. It's there that Python is lacking
I don't really know anything about CoffeeScript but the impression I had was that it was almost the opposite of typescript
I dont think any of these are pitfalls of Async/Await. They're just a couple of examples of badly written code that just happen to use async/await. I think the thing to remember about async await is that you're really dealing with promises, but with a different syntax. A common pitfall with async await is not dealing with error handling. Wrapping an await in a try/catch goes against everything we've been taught about code optimisation, that was until V8 optimised the bejesus out of try/catches. (https://v8project.blogspot.com.au/2016/12/v8-release-56.html) Go forth and spread the good word. Another way to deal with error catching is to tack a `.catch` on the end of the promise your async function returns. Either way, the important thing is that error handling is not forgotten about. 
Really is 
I wouldn't worry about that too much considering all the work on otimizing compilers and the amount of js code that would be untyped (dynamically weakly typed or w/e) in the wild... so much work would just be thrown away. I think the idiom "Don't throw the baby out with the bathwater" applies here. 
You can always bail out of TS or Flow by emitting plain ES6. But anyway *if* types get added to the spec, I figure they'd be influenced pretty heavily by what TS &amp; Flow are doing.
When I need to put some new style, I always end up opening the settings because of the colon lol
Imagine the near future: WebAssembly supported everywhere, it's fast and has native threads. You, as a developer, built an AAA game in C++ (or Rust?), have a Vulkan backend, and all you need is a few steps to get it running in a browser.
Their would be issues with this though. First being, having browser tabs support differing CPU priorities as not to lag your other web content or whatnot. Second their would be a new paradigm shift to make a specific form of DRM to ensure the product goes only to those who the makers want it to go to. Third all of the work on trying to update browsers to support such an ecosystem would need to be more inviting than the games that currently download assets onto the local machine. Finally you might also have the issue of always-online requirement. Oh and also you would probably need the framework of whatever language the game is being written in - actually less of a resource hog and less of a bottleneck than natively coding the game that is compatible with most machines today. Idk it just seems like a massive paradigm shift and so much work when browsers today themselves are strife with not supporting certain web standards more than others by very wide margins of difference. If it's not going to be used for most games, then this is great, you could have the doors open to the GPU doing most of the heavy lifting, and with that, spawn a whole new sea of programmers that would focus on engines and things that are mostly associated with game development. I know designers would be thrilled beyond measure since some of their work is shot down or heavily altered mostly because when the programmer sees their plan they flat out have to let him know that sort of thing is impossible with the current web technologies being the limiting factor. 
Many applications like Atom, Visual Studio Code, Slack all run in a browser wrapper. This could enable much more portable games. If it runs in the browser you could easily create an game that runs on any platform.
Anyone who thinks TypeScript and CoffeeScript are alike is crazy. CoffeeScript is horrible and hard to read, TypeScript is the exact opposite of CoffeeScript in that things are strongly typed and more declarative. Considering TypeScript gives you all of the benefits of Javascript, there really isn't any reason not to use it. There are just too many benefits to using TypeScript to not use it. Seriously, learning TypeScript is one of the best things a developer can do in 2017.
&gt; Third all of the work on trying to update browsers to support such an ecosystem would need to be more inviting than the games that currently download assets onto the local machine. Your wording is confusing me, but If I undertand you correctly, then this problem is already solved via wasm -- "updating browsers to support such an ecosystem.." &gt; Finally you might also have the issue of always-online requirement. Sorry, but I don't understand this point. Can you please clarrify? &gt; First being, having browser tabs support differing CPU priorities as not to lag your other web content or whatnot. Chrome is implementing a throttling mechanic for background tabs [source](https://docs.google.com/document/d/1vCUeGfr2xzZ67SFt2yZjNeaIcXGp2Td6KHN7bI02ySo/edit) 
&gt; CoffeeScript is horrible and hard to read It has a lot of dangerous real problems and "hard to read" is definitely not one of them. It isn't really that hard to read once you get the syntax (just like the learning curve of any other language). Memory leaks, public/private members obfuscation, argument obfuscation by using simplified object literal notation... and a lot of other problems is what makes coffeescript outweigh its benefits
&gt; it can't be called WebVulkan, as that would imply it surfaces all the features of the Vulkan API WebGL doesn't give you all the features of OpenGL either, so I don't see much of a problem naming it WebVulkan.
Minifiers serve a completely different function than typescript. If you think adding an additional transpile step and additional source mapping complexity are a good trade off, great. But comparing a language intended to rectify a non-issue in javascript to a step used in production only to minimize load time is inaccurate at best. If working with static types makes you feel more comfortable, great, use typescript. There are a lot of devs who write clean, testable, declarative code without the bloat of introducing another transpile step / dependency to their code base.
CoffeeScript made CoffeeScript irrelevant.
So what about template literals? Splats? Arrow functions? Structuring/Destructuring? CoffeeScript features inherited by ES6. Syntax is one thing, but the features made it great. It might be over for CS, but to write it off as an unnecessary Ruby clone is too easy. For the most part I'm over on ES6 too after many years on CS. Still miss language features such as the existential operator (`object?.someMethod?()` or `car ?= 'ford'`).
Sounds like the perfect situation for [web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
Alternative: [https://github.com/yeoman/update-notifier](https://github.com/yeoman/update-notifier)
Yes, it is real data, town names from a several counties in England. Actually, I want areas to represent the major European "cultures" (considering a fantasy element): German, Anglian, French, Italian, Slavic, Nordic and Castilian. So I have 7 namesets already created. I took real names for towns and even real historical common personal names for the characters (I'm creating this map for my Medieval Dynasty simulator). As I am from the Slavic state, Slavic townnames sound a little bit odd as they are too familiar for me. Another one are mostly meaningless, so they are ok.
Those aren't features first found in CoffeeScript, so I'm unsure what effect has CoffeeScript had on ES6, or it's mostly an overlap. And they're not the *same*, so saying they were "taken" from CS and planted into JS is misleading... Say take arrow functions. I'd argue the most important part of ES6 arrow functions is the way they handle "this" differently than classic functions, a feature that is not present in CoffeeScript. But even then, those things are not the most important ES6 features by far. Things that are important day to day in ES6+ are things like generators, typed arrays, native Map/Set, weak maps, Proxy, symbols, promises, additional methods for strings/arrays/numbers and so on. Those things are the cake. The syntax features are just icing on the cake. You can't just survive on icing. 
Yup, that's what modules are for. Node supports CommonJS modules by default, so you can do this: // file-a.js module.exports = { foo: 'bar' } // file-b.js const foo = require('./file-a.js').foo Alternatively, you can use the ES6 module standard through something like babel-node: // file-a.js export const foo = 'bar' // file-b.js import { foo } from './file-a.js' 
Nice. A similar method came up a short while ago, with implementation details and "walk through steps" which might also be interesting if you are inspired by this link. It has a slightly different but related goal (creating the effect of "drawn" maps for books) so the output is a different style but the overall method is probably very similar.
I used to minify my code, but now I don't. It wasn't worth the trouble.
I don't see how that's more onerous than running a test to test your code, but suit yourself.
As a JS developer, and someone who does a _lot_ of work with d3, I tip my hat to you :D Well done!
To be honest, modern JavaScript more closely resembles Scala-without-types than CoffeeScript.
Critism: Lacking content - you have only presented an example with virtually no explanation. JavaScript is actually a high level language. https://en.m.wikipedia.org/wiki/JavaScript
Non-Mobile link: https://en.wikipedia.org/wiki/JavaScript *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^46678
I think it's getting passed to the JSON parse string without double quotes if Im reading the code correctly.
To replace webGL, so web pages can take advantage of the GPU in a secure fashion.
First lines of the article : "Obsidian has been published as a possible proposal for WebGL-Next. As we reported a few days ago, The Khronos Group now has a staging area for WebGL-Next proposals and just a few minutes ago was the first proposal submitted."
Thanks! But this is only my first attempt with d3 and I'm not an experienced js developer. So I expect I log of things done in a wrong way. Currently I want to apply a pathfinding system that will allow me to create plausible roads. But this blows my mind as I can't implement even a simple Dijkstra’s algorithm. 
Hey - you're miles beyond me in this respect; I do visualizations and graphs, so the pathfinding stuff is crazy impressive AFAIAC :) Keep it up! If you're looking for help, I suggest posting this to /r/javascript!
In your case the `data-table-options` looks like it's malformed, so the `data` method will just return the string between the double quotes. First of all, it looks like you have the entire thing surrounded by double quotes *and* single quotes. The general idea is to choose one for the surround and then use the other for quotes inside the string so that you don't have to escape them. Following that it would become `data-table-options="{'head': ['value1', 'value2']}"` However, if you want jquery to automatically parse the contents of the data rather than just return a string ( ie return the object `{head: ['value1', 'value2']}` ) then the string has to be valid JSON, and JSON must use double quotes as a string delimiter, not single. So, just flip your usage and use single quotes on the outside and double in the inside: `data-table-options='{"head": ["value1", "value2"]}'`
I learned JavaScript as my first language over 20 years ago. People will tell you it can cause you to learn bad habits, and that it's loosely typed is a bad thing. This is true. But as someone who was self taught and who had limited resources, it was a good thing. Also, there's something to be said for immediate gratification. There is a very low barrier of entry to getting your JavaScript to run. Go for it.
Im writing unit tests actually, so I was merely trying to figure out how what I described above would get parsed (since thats what's getting passed). (For setting up an example fixture).
Nice API but I've got a few opinions on it. * for general language consistency I would prefer `rgb()` and `hsl()` to be either (read-only) properties or, preferably, `toRgb()` and `toHsl()` * I haven't checked to see if r, g, b, etc properties are read-only. I think polychrome objects really should be immutable. It seems to be so. * I really don't like that `darken()` etc take integer percentages. I'd much prefer the options float 0-1 or string `"25%"`. Got me thinking about a babel plugin that would transpile `33.3%` to `.333` but it'd need to disambiguate the modulo operator and unless it was part of a larger, popular language extension I couldn't imagine much adoption. I'm not even sure it'd make sense, but that's enough of that tangent. * I would suggest a `col1.blend(col2, .67)` method. * Maybe a `col.override(r, g, b, a)` where any `null` argument keeps the original value for absolute control.
I released Uncover, an aggregator that tracks new releases from your favourite authors. Built with Node and Vue. https://uncover.cc/ Source: https://github.com/joshwcomeau/Uncover
No, it's fine. 
"Surprising absolutely nobody, the language included in every web browser was the most popular language again..."
Not sure why you singled out that statistic, but it was an interesting read regardless ^^^with ^^^[apologies](https://www.reddit.com/r/webdev/comments/60tux8/726_of_respondents_to_stack_overflow_developer/df9a6tk/) ^^^to ^^^Professor ^^^Plums.
you wouldn't get to learn a lot of important low level programming concepts. everyone needs to start somewhere though and if js is the only language one would ever learn then maybe you're right, but that would never be the case. it's like telling someone going to cooking school they should start learning to bake or do flour based recipes. they'll eventually have to learn much more if they want to become expert so it doesn't matter what they learn first.
You can use jQuery's `closest` - https://api.jquery.com/closest/ ex: var $thing = $('.your-thing'); var $container = $thing.closest('.your-container-selector'); This is better than chaining `...parent().parent().parent()...` since you can add more nesting to your DOM without necessarily needing to change the JS to match how many parents there are. Also, I noticed you're not really fully utilizing jQuery. Your code can be simplified a bit if we make use of `$()` selecting, `each`, `closest`, etc: // using $ in variable names helps keep track of jQuery objects const $search = $('#search'); const $images = $('.image'); $search.on('keyup change', () =&gt; { // we use the same search value in each loop, so we can // just define it here for now const searchValue = $search.val().toLowerCase(); // you can loop over jQuery collections with $.each $images.each((index, $image) =&gt; { const hasSearchValue = $image.attr('alt').includes(searchValue); $image.closest('.thumb-div').css('display', hasSearchValue ? 'block' : 'none'); }); }); 
There is no one perfect language to start learning with. It's fine to start with Javascript, but after a few months it wouldn't be a bad idea to learn another language. This would give you another "perspective" on programming. I'd suggest following JS with a managed language like Java or C#, then a native language like C/C++, but it's up to you.
Assuming that the retrieved JSON data is stored in `data` variable (unaltered), below code won't trigger an error if the data is a valid JSON format. JSON.parse(data); 
Not hung up at all. Just pointing out that it's a stupid joke, and why that's the case. Humor is best when it contains some element of truth, for instance: "We should avoid babel as too!", there you might have a point. You might as well have said "We should avoid oranges too!", which would have been about as funny and relevant. Glad that you have an opinion, I have one as well. If you'd care to fill me in as to *why* you think mine is incorrect, we can have a discussion. Otherwise, you can step back from the keyboard and go fuck yourself, lol.
I love VS.
If you're a JS developer, PHP developer, etc you have your choice of many editors/IDEs. If you're a .NET developer you have to use VS (unless you want to use the awful MonoDevelop). 
For any meaningfully-sized project (i.e. more than a couple of hundred lines), you're doing yourself a disservice by not using static type checking. There may have been a time when Typescript (and Flow) were too new to invest in, but that's long past now.
Because it's very high quality.
&gt; ... have to use VS (unless you want to use the awful MonoDevelop). That's not true at all. ------ Why is there contention over this? You can use a plethora of editors and IDEs to work with .NET, including the ever popular VSCode. VS is not a requirement. No where have I stated that VS is inferior to these other options, only that it isn't required.
Are they including VS Code under that umbrella?
nope, VScode is listed separately.
&gt; ... scares me about TS is the MS badge on it. Grow up. 
I was Sublime/Vim for a long time but after getting into Unity dev I picked up VS (it can be integrated with Unity projects to replace Mono)... I have to say it's pretty great. 
Apologies. Essentially, by not using static type checking you lose the benefits as outlined [here](http://stackoverflow.com/a/34003775). Note that both TS and Flow allow you to be dynamic when you want, so really you get "the best of both worlds".
Is the ability to run eslint and webpack your definition of quality?
Js doesn't have a manual GC method but you shouldn't ever need this in the first place. Dereferencing objects should be enough to trigger the GC.
I'm not saying that Visual Studio is not a quality product. I'm just asking questions in case I'm missing out here. I've been using VS Code.
[It's also the 3rd most loved Programming language](https://stackoverflow.com/insights/survey/2017#most-loved-dreaded-and-wanted)
X-Post referenced from [/r/typescript](http://np.reddit.com/r/typescript) by /u/273874 [TypeScript 9th most popular Language in Stack Overflow 2017 Developer Survey - Above Ruby, Swift, Objective-C](http://np.reddit.com/r/typescript/comments/60w6gt/typescript_9th_most_popular_language_in_stack/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I agree. C is a bitch to learn, but understanding pointers and a strong/explicit class/object building is absolutely worth learning, and you won't learn it in javascript. 
In my experience, Visual Studio is the most versatile IDE out there, bar none. There are so many things you can do with it. 
What about Dart or kotlin 
Based on open survey and many developers may not be proficient in Javascript and TypeScript. Smalltalk is interesting.
JS doesn't really have a solid introductory text like SICP or C++ primer. 
I suppose you can use VSCode for .NET Core / ASP, but VS is so much better.
How is it so much better? 
I haven't got any experience with IntelliJ, so I'm not sure how it stacks up, but I can't imagine it having the same amount of possibilities as VS. With VS I can create Web pages, web apps, both php and asp.net, windows applications, xbox applications, windows phone, android phone and iphone applications, and there's undoubtedly more that I don't know about. Those things cover the vast majority of IT platforms used by most people.
What's your definition of quality? 
&gt; the standard of something as measured against other things of a similar kind; the degree of excellence of something.
Might as well set `i = 1` instead of checking for 0, or `i = 4` since the first 3 numbers don't matter.
This needs to be `i &lt;= 24` to catch the final number.
WebAssembly is interesting. Now we only need something to replace the whole HTML DOM stack, and we have ourselves a true Internet application platform.
Doesn't surprise me. My experience is that JavaScript developers tend to want to solve everything with JavaScript. 
And the tools still suck 
Cool! Still awesome and micro!
X-Post referenced from [/r/learntocode](http://np.reddit.com/r/learntocode) by /u/o-piispanen [Object Oriented Javascript](http://np.reddit.com/r/LearnToCode/comments/60xd70/object_oriented_javascript/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
If you are creating and destroying objects constantly you may want to look into object pooling.
"Someone that specialises in something wants to use their speciality". Literally what you just said.
I'm as big an advocate of JS's strengths as you'll find, but there are definitely issues with starting with JS. 1. Low level programming concepts are hard to demonstrate in a loosely typed memory-managed language. I started with C++, and while it's a monster of a language, it did a great job of helping me understand what's going on under the hood. 2. JS is still very intertwined with the browser environment, and that can obscure what is and isn't a language feature. I know a lot of seasoned JS developers who probably wouldn't be aware that "setTimeout" isn't a JS language feature, but instead an API exposed by the environment (browser, node, etc). All that being said, I don't think any single language is perfect, and ideally, I think students should be given a look at multiple programming languages while they're learning. Especially since the majority of concepts they should be learning are language-agnostic.
This depends on how 'real' you want your game to feel. What it sounds like you're missing is gravity. Ideally, every tick you'd be running your objects through some sort of physics processing, do the math and apply downward acceleration over time to reduce and reverse upward momentum. 
That link looks pretty shady for me, why don't you give a try to this one: https://www.sitepoint.com/bringing-vr-to-web-google-cardboard-three-js/
Haha not really. And the part that's true is still far less than in JS. Python 2 code examples aren't noticably different from Python 3 ones (the devil is in the detail). And as a long Python user I don't know anything in the python 3 stdlib that's deprecated apart from %-formatting (use f strings and if not applicable, use str.format) and os.path (use pathlib)
Add an argument to your hello function: function hello(id) { document.getElementById(id).innerHTML = 'Hello ' +id; } You may even want to add a second argument of the name you want to pass. Hope that helps! 
Have you never used it? People can hate on Microsoft all they want, but Visual Studio is regarded as one of the best IDEs out there. As compared to VSCode, it's more or less like switching from notepad to notepad++, but VSCode is also very good. 
So, I tried out Typescript on a personal Angular 1.5 project about a year and a half ago. I enjoyed using it, however, there were a few hangups that caused me to 'give up' on it. One thing I found really annoying was having to install custom typings for every single 3rd party library that I wanted to use. Some libraries didn't have typings available, so I had to make my own to get them working properly. It was a lot of hassle for something I felt should otherwise be trivial. So I guess my question is, how is this situation now?
Still, IntelliJ supports more languages than VS can ever does. PHP, Android, Java, Scala, Go... 
It's been included in every web browser for longer than 5 years. 
You are trying to do string concatenation with commas (,). In Javascript it is done with the plus (+) sign. Also, if the &lt;h1&gt; and &lt;p&gt; are already in the document, you don't need to do "innerHTML" and then add the &lt;p&gt; again. It would be better to use "textContent" and assign it to just the string you want without any tags inside. Another thing that looks strange is that 3. Is that always 3? If it is always 3 then you don't need to do ...radius of " + 3 + " is: " you can just do ... radius of 3 is: " If that 3 is going to change then it should be in a variable that you pass to your function.
Visual Studio supports php and Android (not a language). What can you do With Intellij that you can't do with VS? Like I said, you can create applications for Windows, Xbox, Android, iPhone, Windows Phone, Web Apps/sites, all with VS. That's the vast majority of the technological ecosystem covered there. What more could you want? 
Anything that doesn't need Microsoft products to run.
They don't know. It's what they see on reddit headlines. That's all.
No problem! If this course is so bad why are you taking it? Is it a requirement for a degree? There are some great resources online, either free or costing $25 or so per month, where you can learn these kind of things. (e.g. https://www.codecademy.com/ https://teamtreehouse.com/ https://www.codeschool.com/ https://www.lynda.com) In those cases you don't have a professor to talk to, but if he takes days to weeks to reply then he is useless. You can get a faster response from online forums. 
Can it produce Windows applications? Or UWP apps? 
Nope :) the same can be said about VS: can it support Scala and Elixir and Go? Is it even better to use VS for Javascript (than WebStorm) and PHP (than PHPStorm)? Well, I guess it doesn't matter to you anyway. Because you consider a good IDE to be the one that can support many (Window) platforms, which is not my concern at all.
Vscode is fine but I went back to atom
React is pretty amazing with typescript. Why wait till it's in the browser to know if you are giving the wrong props.?
Is HTML a text format or a binary format? HTML is a text format. JPEG, for example, is a binary format.
Yes but the text format is just serialized representation. It has nothing to do with how fast DOM is. 
You never mentioned speed. Right, it has nothing to do with speed. It is why you need it though. I don't understand how think the DOM is slow though.
Would using this module be more performant than doing JSON.stringify when storing the data and then JSON.parse when retrieving the data in Node? 
I cannot speak to Electron. You would have to benchmark the differences between Atom and Visual Studio and then differentiate that difference between the DOM method execution and the output render (this visual stuff), which V8 won't allow you to do. In the browsers the DOM is the fastest thing outside the primary synchronous JavaScript execution thread. It works at billions of operations per second and is typically 2800x faster than using querySelectors.
There is more info in their github : https://github.com/KhronosGroup/WebGLNext-Proposals/tree/master/Obsidian-Mozilla &gt; The context obtained from Document is similar to vkInstance: it doesn't provide a single GPU device, but instead allows the user to query available GPUs and work with them manually. The browser can filter out the physically available devices, based on settings, available hardware, and the active power modes. Creating a GPU device also produces the command queues that can execute command buffers. &gt; The user creates a swap chain manually as well by providing the Canvas object. This is different from WebGL, where the context is obtained from the Canvas. Disconnecting the context from Canvas allows managing multiple canvases, potentially using different devices and command queues. So it still uses the canvas object, but through a different API. There is an example there too...
This was the very same question I had. After reading the article, I gather that with ReJSON they are walking the JSON tree and storing each individual key/value separately, so you can do searches on it and stuff. I would have to assume that this is relatively slow vs storing a single blob of JSON with stringify. Seems like the latter would be orders of magnitude faster. However, I have not tested this.
Open up the browser console and look for any errors. If you don't see any errors, I know one of my rookie mistakes I made a lot was forgetting to actually call a function after I wrote it. If you paste a code sample we can help you a little more.
There is a chance that JS will lose a lot of relevance if Webassembly is the killer stuff that looks it is.
The situation is different now. You now no longer need types for 3rd party libraries unless you use the strictest flags possible. it was technically always possible not to need `.d.ts` files, but we've made it much easier to do this stuff. On top of that, the number of `.d.ts` files has likely grown, and the quality has improved as well.
In fact, you can do both. Check out [the prop-types-ts project](https://github.com/gcanti/prop-types-ts) which allows TypeScript to base its types off of `propTypes`. It takes advantage of some awesome TS 2.1 constructs like mapped types.
Hey, your site is really frustrating to scroll through on mobile :)
I think I'd suggest three things: 1. Pick a language that is commonly used for whatever it is that you want to do, regardless of its warts as a teaching tool. This language may be JS and that's fine. Just make sure you: 2. Take a look at other languages every once in a while. 3. Follow a course, or book, that will teach you *programming languages*. For example: http://papl.cs.brown.edu/2016/ And you could do those three things simultaneously. And probably should. You don't want your world view to be shaped by the (usually accidental, rushed, etc.) programming language design decisions of a particular version of language of a particular kind. This way, you'll learn a tool that "everybody is using so I can get support everywhere! yay practical!", or whatever, but you'll also know *what is possible, in what ways*, in different kinds programming languages and theories. So I guess my answer is: Yes the reason for NOT learning JS first is when you DON'T do items 2 and 3 on my list. Because there's just so much that is impossible and nonexistent in JS (including ES6+) that you'd simply be missing too many other points of view of programming (especially concurrency-related topics, and data/process/function modelling-related topics)
It could have been a garbage-collection issue; when I tried it, the first one took 30.5ms, the second took 31.9ms, and the third took 31.7ms. The second time, 28.2, 28.2, 89.5; when I kept re-playing it, I got the behavior that you were talking about, and re-ordering them didn't change the micro-benchmarks. Consider adding this to JSPerf: https://jsperf.co/
First, you *can* just pass `loadSite`directly as the second argument to `chrome.extension.sendRequest`; more importantly, it looks like you need to `return true;` from your event-listener: https://developer.chrome.com/extensions/runtime#event-onMessage
Alright, sounds like I have something to do tomorrow, thanks!
Emacs is a highly configurable operating system masquerading as a text editor. Its not really fair to compare it to a stock IDE.
Ah we already use linters for code standardization, which includes a react/jsx rule set, so we catch anything like that in our node output immediately during compiling the code (which is happening live via webpack/our own express server/etc). Our build doesn't of course do it in the IDE up front though like typescript, but introducing something like this to our code base just for that doesn't seem worth it to me.
Actually, even [the original](https://jsperf.com/) is back (jsperf.co was created during the downtime).
Ok, sounds good
if you're building a game, one of the architectural things you *could* do is try to avoid the garbage collector, since it consumes enough time on the cpu to stutter games and it is also executed at (seemingly) random times. a trick for this is to instantiate all the objects you need at the very beginning, when your game first loads, and hold your references to all of them in a single game state object. (something like redux would be useful for this, but that's a tangent...) you can modify the properties all you want (visible, not visible, etc) to make the game work, but by having the engine work on this principle, you can avoid GC almost entirely and get smoother gameplay.
What's your point exactly. That the Atom team are simply shitty coders? If so, no, that's not the reason why Atom is slow. I'm standing by what I said.
Mighty presumptuous of you.
the scrolling is sticky and i get stuck right after the first code snippet
Hey, it's not took developers faults that y'all decided to congregate around a language with such poor typing that it makes static analysis all but impossible. :) Come give typescript a shot! The water's fine...
While you're right about the client side of things, I think what they were trying to get at is maybe you shouldn't also write your build system and server in a language that was originally written in a week and primarily designed to augment a tempting language.
reddit app browser, ios
Go creeping up big time this year. 
I use notepad.
https://github.com/atom/atom/issues/10188 I don't know why you think it doesn't perform better. There is a ton of anecdotal evidence of there and a few benchmarks. I've yet to see an opinion the vs code feels sluggish. If anything, vs code is held back more by using JavaScript than it is by using HTML.
/r/iamreallysmart 
If someone is walking around calling themselves an XXXX developer, whose fault is it when you (or others) expect more from them? IMO calling yourself an *insert language* developer implies you're not well rounded. It has negative connotations from the get-go. How anyone can act surprised then is beyond me.
Do they? Wake me up when the other languages get transpilation, [hot module reload, time travel debug](https://camo.githubusercontent.com/a0d66cf145fe35cbe5fb341494b04f277d5d85dd/687474703a2f2f692e696d6775722e636f6d2f4a34476557304d2e676966), etc. The tools are pretty much Javascripts strongest argument.
Or maybe [jsrsasign](https://github.com/kjur/jsrsasign) is what you are looking for?
That's not standard. That's how web pages were made many years ago when modules still weren't around. 
`querySelector` is part of the DOM. What are you talking about?
I think there's an eslint plugin for typescript but you'd be better off with tslint, which is extremely similar but built on typescript. It has already a ton of built in rules, and like eslint you can extend it with custom rules. I believe there's a plugin that tracks parity with eslint if you're missing something.
I think most node libs should run in the browser unless they use native helpers. The first search result in Google ran without issues: https://github.com/rzcoder/node-rsa 
Look. Javascript is a very nice language. I've fallen in love with it. But I am very aware that to be a truly productive programmer you **need** to have an understanding of memory management. Whilst you could grok through articles on JS's garbage collector, you would have a deeper and much clearer understanding if you: 1) Sit down for a week to learn C. It's a VERY small language. It also forces you to learn about pointers and memory allocation, as well as being very clear on types. You could be up in running in hours, a week is just for everything to fully sink in. 2) Read about Javascript's Garbage Collector. Javascript engines (except Rhino) tend to be written in C/C++, so having a background in those will help you get a sense of what's going on with garbage collecting behind the scenes. 3) **OPTIONAL** Read up on symbol tables and object files.
It isn't: https://www.w3.org/TR/selectors-api2/ The W3C spec mentions the DOM as a reference, but they are completely separate and unrelated works. querySelectors document is managed by the [Web Applications Working Group](http://www.w3.org/2008/webapps/) while the DOM is managed by the [DOM Working Group](https://www.w3.org/DOM/). I don't see the W3C integrating these efforts either. It is safest to consider querySelectors as an unrelated extension of the DOM, because a querySelector string parses into the standard DOM methods under the hood. This is primarily responsible for making querySelectors so much slower than the DOM methods, because you still have the DOM methods anyways.
VS Code and Atom both use Electron though, which is where their DOM interface comes from. If one performs differently in that regard then it isn't Electron, HTML, or the DOM causing the delay.
but what if xxxx development pays really well and that name somewhat implies specialisation in xxxx? 
If you are trying to achieve this from clientside javascript... Im sorry to say that the backend needs to facilitate a list of files for this to work
what sort of backend needs to be implemented? 
You'd learn way more if you took the time to research basic programming language functionality like objects, methods, arrays, etc. If you're thinking about turning this into a career then there's no way you can just skip learning JavaScript.
Hard question. Especially with a world where no-one represents the point that status-quo is not utter shit, it's passable. You should make talks about how functional approach is sometimes not worth it, put it on youtube, get bots to get it popular, and hope to see your viewpoint back at the brainwashed. I guess, if you should try giving them a hard problem, with hard deadlines, and show them that failing for the reason of aiming for perfection is not something that's accepted within engineering realms. Delivery is first - 
Wow, that's all I need, thank you!
You could generate a JSON file that you load from your webapp if you don't want a backend for this. A simple example: Ex `generate.js` (run with nodejs): const fs = require('fs'); const images = fs.readdirSync('public/jpegs'); fs.writeFileSync('public/gallery.json', JSON.stringify(images)); // Results in ["file1.jpg", "file2.jpg"] etc And then in your webapp, for example with jQuery: $.getJSON('/gallery.json', function(images) { // Results in ["file1.jpg", "file2.jpg"] etc }); Note, that this requires you to run from a webserver (and not `file:///`) 
I don't think the word functionality means what you think it means. Functionality is the set of features (often user facing) of a piece of software. e.g. registration, log-ins, comment posting etc.. It has no particular connection to one programming paradigm or another. 
You're 100% correct. I think I know where that opinion comes from, though: If you look at how to do stuff in JS/CSS, 99% doesn't mention anything about these things and JS makes it easy to let it rain forced layouts if you don't have any knowledge about a browser's inner workings so they probably just assume thats how it is - slow. Most devs know when caching makes sense, but who would expect modifying a DOM element the wrong way may cause a rerender of hundreds of elements? It's just not obvious.
&gt; are benchmarks really needed for that? **Absolutely.** In experimentation we call that bias. Your observation could be valid, but without empirical evidence we don't know how invalid or biased your observation is. Perhaps more important is knowing how much slower, which can only be obtained from benchmarks.
&gt; plug n play renderers This sounds interesting. Can you give me some examples of this? There are some examples of beautiful and performant mobile web apps out there e.g. Flipkart Lite https://www.youtube.com/watch?v=MxTaDhwJDLg 
&gt; plug n play renderers This sounds interesting. Can you give me some examples of this? There are some examples of beautiful and performant mobile web apps out there e.g. Flipkart Lite https://www.youtube.com/watch?v=MxTaDhwJDLg 
Nice! Repo must have more stars.
its getting passed to a function that does json.parse (and also replaced single quotes with double quotes)
&gt; If you look at how to do stuff in JS/CSS, 99% doesn't mention anything about these things That might just be because a good majority of articles/tutorials out there are aimed toward beginners. Getting into browser mechanics can be a really daunting subject matter. &gt; It's just not obvious. It's not obvious at all :/ ... but with the Developer Tools we now have it has become a lot easier to pinpoint bottlenecks.
Tendency is a fact. It means a majority has come to similar conclusions through individual experience. But if that's not enough, i have nothing to prove. For all i care be the person then pestering mobile users with dom-views, like the goofballs that made my banking app, and karma will get them. ;]
&gt; At this point, are the original objects still in memory? Most likely yes, but you have no references to them anymore so as far as you are concerned they are out of your domain. The garbage collector will come around and clean up the memory whenever it wants to, it could be on the same call frame, in 10ms, or five minutes from now. &gt; Should I be setting them to null after removing them from the array? No, since the reference is no longer held anywhere it doesn't exist, setting it to null before throwing it in the garbage isn't needed. &gt; Could I loop through the array setting each index to null or will this not affect the objects themselves? You could, this would be the same as just throwing away the array tho.
When you can build a basic react TODO app. I really mean basic though. Just add items, sort them, display them and save to/load from JSON. Once you've got that, put it up and apply. Whilst applying, start looking into writing tests for it (check out TAPE) as an added bonus.
I use it everyday pretty much. Whenever I need to google something Web-related, I add "mdn" to the search. Example: "file api mdn"
Java is a protest situated dialect like C++, yet improved to take out dialect includes that cause regular programming blunders. Java source code documents (records with a .java expansion) are gathered into an organization called bytecode (records with a .class augmentation), which can then be executed by a Java translator. Arranged Java code can keep running on most PCs since Java translators and runtime situations, known as Java Virtual Machines (VMs), exist for most working frameworks, including UNIX, the Macintosh OS, and Windows
It depends on scale of what is slow for you and your use case. Manipulating DOM is IO operation, and IO operations are generally much slower that few instructions for CPU. 
Hey, I've seen your books mentioned in a few places and we actually have a hard copy of one of them (Speaking JavaScript) at work, but I hadn't realised you were a Reddit person! I'm not OP but I just wanted to say that they're good books, thanks. Side note: MDN is also a fantastic resource, though.
MDN is head and shoulders ahead of any other documentation sites. I had high hopes for https://webplatform.org but it's documentation is taking too long to complete. MDN for web as a whole is what MSDN is for Microsoft products.
As said elsewhere in the thread, it's the rendering and layout shifting of the DOM that takes a long time. That's why the best frameworks use a virtual DOM which lets them make more DOM changes in batch. But the more important part (IMO) is that until React/Vue/etc. became fully accepted, DOM manipulation was king and it was easy to mess up. The status quo had a lot of misguided uses of jQuery (`$('.cta.big_thing .list li').slideToggle();`) where DOM nodes were rarely cached to variables and few people were aware of the impact of non-composited changes (everything that's not opacity or transform). Really, just caching variables solves most "slow DOM" issues. const $bigThing = $('.big_thing'); const $bigButton = $bigThing.find('.btn'); const $thingItems = $bigThing.find('li'); $bigButton.click(function() { $bigThing.toggleClass('something'); $thingItems.hide(); });
Maybe virtual DOM libraries, which do write changes faster than previous full DOM rewrite libs, are also driving some misconception as well. Some people might take away "VDOM is fast, DOM is slow".
I agree it's the wrong word for it, but I'm pretty sure he just means 'development done in a functional programming style'. You could just replace functionality with 'functional programming' and the whole thing sounds a lot better.
MDN is what I always use. Also the version on [DevDocs](http://devdocs.io) is easier to navigate (same info, different stylesheet). [Microsoft's docs](https://docs.microsoft.com/en-us/scripting/javascript/javascript-language-reference) are pretty decent too.
Good insights! Both points are valid. &gt; I immediately assumed I could click somewhere on the wheel and it would set that as the color, but it didn't. We'll see how this can be implemented. One might even argue that this is a *must have* feature. &gt; When dragging the selector around the wheel you need to actually follow the wheel around to the color you want. I had tried to grab the selector then cut straight across the wheel to the color I wanted and it did not perform how I expected it. A fix is on the way. I assumed that if it works okay on my phone then it should work with the mouse pointers too.
Agreed man, the fucking python docs have thrown me for a loop on multiple occasions 
people misuse the DOM when better methods are available. - animating CSS values with setTimeout rather than using CSS transforms/transitions - not using requestAnimationFrame - writing inefficient js code in hot paths that does too much heap allocation and forces GC jank - using dom abstractions that try to reduce cross-browser issues (like jQuery) rather than finding a different solution - using unthrottled mousemove, resize, scroll events to do any of the above. inexperienced devs *will do all of the above at the same time* and never bother to profile their code. this leads to a bad day for the end user.
Even if you do all of these right which i'm sure most people do because that is by no means elevated knowledge but sums up the most basic and fundamental aspects of web development, you'll still end up with something that performs worse than its native counterparts. 
&gt; Note it does require the ES6 spread operator More specifically, it requires [object spread](https://github.com/tc39/proposal-object-rest-spread) which is still a proposal and not officially in the language spec (currently at stage 3 which puts it I guess in ES2018 at the earliest?)
You can set it up as a "Search Provider" in Chrome I believe. Which makes it so that when you type "mdn " and then start entering your search it will only list results from mdn in the autocomplete dropdown.
Very accurate, I'm in the same boat.. Left my programming career 7 years ago to work on my hobby and in trying to get back into it, hoping I can find a job. https://youtu.be/LV0wTtiJygY
Honestly I've used MSDN some 10 years ago. It had best Microsoft resource on internet. I've no idea about their current state.
The MSDN docs are trash IMO. The MDN docs tho are 👍.
Hey /r/javascript, I wrote a quick guide on creating a continuous integration, delivery, and testing pipeline with a Node.js app. [**Set up a continuous testing pipeline with Node.js**](https://assertible.com/blog/set-up-continuous-testing-with-nodejs) [**Code repository**](https://github.com/assertible/nodejs-example) The tutorial goes over the different components of a complete CI pipeline: - Push code to GitHub, build and run unit tests on CircleCI - Deploy new app version to Heroku - Post-deployment tests with Assertible The whole workflow is surprisingly easy to set up, so I'd love to hear some feedback on this approach and how other teams manage their CI setups. What does your CI pipeline look like? Anything you would add or change about this workflow?
Slightly unrelated, but here's a handy tip for anyone using MDN. You can use the short url mdn.io followed by a query which will redirect you *I'm feeling Lucky* style. For example: http://mdn.io/arrayreduce
Technically Correct™ They *did* ask for the "most complete" documentation of **javascript**. MDN also has DOM API, CSS, etc. and doesn't read like spec so it's probably a bit more helpful and readable.
Their section on Roslyn (analyzers, code fixes) doesn't even have examples or much text. Just lists of methods and properties.
It's the same for the compiler if it's targeted by loop-invariant code motion optimization.
&gt; Scrolling isn't a DOM subject. For your personal web page maybe not. You're right. For everything else it *has* to tie a virtual list to it, which obviously renders every frame. Without it making long lists would be unsustainable. So it's blowing dom nodes onto the screen, each line, each marker, each decorator on each scroll-frame. Anyway, i just opened Atoms dev console to check and scrolling causes *tons of writes*, the entire editor-view renders, also chunks in the minimap. This is exactly the kind of bull that a developer has to face when rendering desktop-class apps with web technologies. Native often occludes by default, can prioritize or handle threads doing things in parallel while the dom was essentially made to display blobs of text and images, it was never intended for realizing *applications*. 
This may come off as excessively pandering, but I've long held that his site http://2ality.com/ is the best JavaScript focused "blog" as well.
Complete yes, concise, not so much. If you're looking for something more concise for quick reference, I'll be downvoted to hell but you can always use: https://www.w3schools.com/js/default.asp
... under what conditions would you ever do this? and as /u/senocular points out, this is not ES6. 
&gt; Even if you do all of these right which i'm sure most people do you're very wrong.
You have put into words my feelings for a number of years now. 'reddit insane comments' are a class above.
Wait but what are you comparing the node property access to? I thought the debate was more along the lines of why is say using a virtual DOM faster than DOM access
&gt;Quick question: the $ in the variable name is just there to show it is a jQuery object right? It doesn't "have" to be there? Yep, you're totally correct - you can name them however you want, it's just my personal preference to use `$` in my vars to know what's what. &gt;Does your closest() example do that for an element two levels up? Yep - it finds the _closest parent element that matches the given selector_, even if it's a few parents up. 
It is missing some IE implementation details. xD
Dozens, yet you provide 0 links.
Always refer to MDN, it's the best.
Thanks
Have a look at [devdocs.io](https://devdocs.io), it's great source for loads of documentation, you can download docs so they're available offline. and yes it uses MDN for it's javascript docs.
Well said agreed but you can't just forget about the DOM. It can't become this mystical thing that just powers the view renderer I don't think it's that bare metal
Sounds like a fun project, I'm very interested. Will get in touch with you by PM after work 
I in general agree, but your example is not good. Atom has issues smooth scrolling code but VS Code (also running in Electron) does not. This is due to poor coding on Atom's part. 
Is it my job to prove something that is plainly obvious? Just out of curiosity i read a whole bunch of them while this is going back and forth like all these heated discussions do where someone perhaps has a personal stake in it. I will just use the faster alternative, so will mostly everyone else. Use the dom for your companies mobile apps if you can't find the data that you need.
As most things go, I realized, while taking a crap, that you can just do this: for(var i = 4; i &lt;= x; i += 4) { ... }
Yes, in part, though VSC [also struggles](https://github.com/jhallen/joes-sandbox/tree/master/editor-perf). The point is that it is extremely hard to make performant apps. I read about the guy that made the editor view for VSC, it is supposed to be a crazy complicated thing no one else is about to repeat in It's the same in the web where you have to resort to all kinds of hacks and circumventions. And even then, it will not be enough because one threaded dom without native backing for essentials like virtualization and so on is often helpless with the tasks that we need it to perform.
Ancient? Damn, that hurts ;-)
Module's author here: no, it won't be more performant because the module destringifies/parses the JSON so there's a performance price to pay compared to plain BLOB storage. The included benchmarks show that clearly, but for anything but full read/write the module is a winner.
[Any headline that ends in a question mark can be answered by the word 'no.'](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines)
Possibly/probably. In 6.9.2 I get the same problem, 10000000 test1: 23.951ms 10000000 test2: 21.725ms 10000000 test3: 40.994ms edit: formatting
It's comparing property access of on a Plain Object {} vs a DOM Object {Node}. Since a virtual DOM's data structure uses non-{Node} Objects, it's faster to access virtual DOM properties than DOM properties at-least that is the case in chrome. Though this only applies to native getter/setter Node properties.
Is there a resource where I can learn more about this stuff?
You can make this clearer with `Object.assign` which i believe this transpiles to anyway. const myObject = Object.assign( { key: value }, condition &amp;&amp; { key2: value2 }, ); This works because `Object.assign` simply skips over values that resolve to `null`.
Given time, no doubt better implementations of the DOM that are closer to the metal will get built - [Server#Design#the-copy-on-write-dom](https://github.com/servo/servo/wiki/Design#the-copy-on-write-dom)
It does append a new element to an array and returns a length of said array (after appending). Here is more info: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push
You are losing the original myObject in your example but I get what you're saying :)
MSDN docs are terrible
I did not compare these to anything. It is just raw numbers from single operations. What I have found interesting though is that equivalent querySelector operations are about 2800x slower cross browser. That is a really big difference. That difference multiplies when there are successive or consecutive operations. The degree of multiplication is variant based upon the complexity of operation and number of operations. 2800x is a big difference. The tallest building in the world is only 2717 feet tall. The closest black hole to Earth is 2800 light years away while the closest star (aside from our sun) is 4 light years. A walk across my neighborhood is about a mile but a drive across continental US is about 2800 miles. Conversely I have also found that looking up nodes by attribute name where that name is not *id* or *class* is about 16x faster using querySelectors opposed to the DOM methods.
This isn't directly rated to your comment but I just want to thank you for all the resource, especially your blog, that you have created for ES6+. They're very well written and extremely helpful :)
Definitely yes, and I would add that it is also one of the best JS tutorials out there.
From what I understand, JS arrays are generally implemented as C arrays or sometimes as tree data structures to accommodate sparsely packed elements, but never as linked lists. It just wouldn't make sense to have indexing on LL.
Just to be complete, I should add that some of the MDN documentation is also proprietary. 
Dude ... definitely gonna check out the ES6 books. I have yet to find a resource that doesn't make me want to hit myself in the face with a hammer. 
You absolutely can inspect the canvas though, check out Firefox's canvas inspector tool: https://hacks.mozilla.org/2014/03/introducing-the-canvas-debugger-in-firefox-developer-tools/ I'm not sure if it's included the main firefox release, but it's available right now in firefox developer edition.
&gt;Both technically do the same underlying thing So you agree with me. What's your point? &gt;most people in most contexts would not say that they're the same. I am not aware of any such people so your source is bad. In any case, you stated, not concisely, that I said the fact correctly and I will not argue about it.
you should add href generation. from a given a route object (or named route) + params -&gt; href string that can be used in templates. i use this functionality in my pet router [1] [1] https://github.com/leeoniya/domvm-router/blob/master/src/router.js#L331
Hi /u/neo486dx, English only please.
VDOMs would be more efficient if they too could pause reflows. The VDOM helps you limit the # of changes you have to make, and helps reuse existing DOM nodes, but in the end if you have multiple changes to make in a single 'cycle', the DOM will reflow for each individual change to a node. There's no way to tell the DOM, okay make *all* these changes all at once to existing nodes. 
Your issue is one of remembering what libraries are available for execution? I'm not even sure what to say to this. The fact remains that an IDE is not required, and other frameworks and languages have the same capabilities and pitfalls that you're hung up on regarding .NET. I'm not arguing that IDEs don't help. In a separate vein, regarding C#'s simplicity, this is where you've revealed your lack of knowledge about the language. While I appreciate your passion for language design, possessing knowledge of what you're arguing against is important. We could argue all day about what languages are simpler for not and for what reasons, but it doesn't matter. I encourage you to study C# when you're ready to expand your horizons.
My point is that it uses the the standard "node as a build tool" ecosystem, which includes module bundling and all the other little nitnacks that people use node for on the front end.
So you don't think the specification documents how the language is used? You're as dumb as the rest of the redditors.
It does ... and documentation *specifies* how a system should work. But documentation still isn't specification and vice versa.
your app.js is 5.7MB, how about building it for production?
When one is sufficiently competent to regard oneself a 'junior level react developer'. Not before, not after.
in general i have a strong distaste for what i call "ui-designer porn". parallax, scroll stealing, giant heros with slow fade-ins, padding...padding everywhere, practically 0 content above the fold. this leads to complete shit UX. just show me the fucking content already. a situation made exponentially worse by a 20 second page load time. a website made in 2017 should load in &lt; 1s on a fast connection. my attention span is a generous 3s before i start billing. i bounced. this may sound like harsh criticism, but if you're gonna use fancy HMR, vue, webpack and 3000 other "modern" stack deps [1], how about making sure your result has at least half-decent performance? lol "modern", no thanks. [1] just look at this fucking thing: https://github.com/aswdesign/hypersurface/blob/master/package.json
appendChild &gt; innerHTML
&gt;writing inefficient js code in hot paths that does too much heap allocation and forces GC jank Could you share an example of this?
it's difficult to provide a simple example because most of the problems occur in complex codebases where huge numbers of objects are either over-allocated, not fully unreferenced or hang around too long, resulting in mem leaks. these mem leaks force the GC to do excessive work as it has to evaluate the entire heap to see what it can purge from mem. even doing something as simple as prefix testing a string can have a huge impact on perf if it's done in a loop on thousands of objects via `substr` which creates new string allocations vs testing individual characters in the already-allocated strings: https://jsperf.com/string-prefix-test http://stackoverflow.com/questions/18364175/best-practices-for-reducing-garbage-collector-activity-in-javascript https://github.com/pixijs/pixi.js/issues/1926 https://github.com/petkaantonov/bluebird/issues/610 https://www.voxxed.com/blog/2015/01/real-world-javascript-performance-tips/
Telling ignorant people they are ignorant is not an insult. &gt;making tons of false assumptions You must be new around here to think those are false assumptions. 
I fully endorse it. Try it at once!
You are as dumb as I thought.
[Dash](https://kapeli.com/dash)?
open Chrome devtools' network panel, set connection throttling to "Good 3G", check "Disable Cache" open https://letsencrypt.org/ as a benchmark of a fast site. observe the "DOMContentLoaded" and "Load" timings. also look at KB transferred at the bottom. then open http://www.hypersurface.org/welcome compare results. your site should take &lt; 5s to fully load on a Good 3G connection with no cache. bonus points if you repeat the same experiment with CPU throttling in the Timeline view.
https://en.wikipedia.org/wiki/Mystery_meat_navigation
Yea, thought for that feature through the university day.
Name or description may not be the best, tho, sorry for that - suggestions welcome, i'm not native english. Anyway. The point is that in our stack traces, even if they are cleaned, we have few callsites on the top of the stack, that we may don't care (in most times). The very first thing that we should see while testing is where it _really_ starts (think for that as stackStartFunction in Assertion Error), the exact line and column in some of our tests in the test file, so we can just jump to that line and fix the error. Basically almost the same thing can be seen in `tape` errors. But I'm not sure it works so well and actually seen couple of failing cases. It intentionally don't use `parent-module` for at least two reasons - 1) it does a bit different thing, 2) node &gt;= 4 required. This modules uses `module.parent` and recursion. Hence, I just don't like to use modern things just because we have it and drop support because one arrow for example. Such packages are also known as "small modules philosophy" and they are one-two functions in ~250 characters.
Not sure about *most*, but yes I absolutely recommend it as a learning resource.
I'll actually agree with this. As a school, W3Schools has issues, but as a *reference*, it hasn't steered me wrong yet on the proper method signatures for various things. (Of course, OP was asking for a learning resource, so I must regretfully downvote you.)
That's the one 
Do you have any examples of content in the javascript MDN that are proprietary? My understanding is that most content is licensed under the creative commons.
I think you're talking about different things. The OP means that some of the APIs listed are proprietary. Certainly, I've seen a load of FirefoxOS stuff in there.
I've never used Flow, but I love TypeScript, so you can give that a try. TypeScript doesn't force you to add type annotations. It also has an "implicit any" option which means, for example, that loading an unknown module will simply be of type "any". Then you can use npm to install typings from the "@types" scope and they'll automatically be picked up by the compiler. I now this is not a comprehensive answer, but I'm happy to answer any questions about getting started. Again, I've never used flow, but I'm well versed in TypeScript.
Whoosh, lots to answer here but I'll try to knock off a few points. First of all---I was *exactly* like you. I think I can even dig up some posts of mine in this very sub asking a very similar question. Over time, a good setup (Nuclide) and certain class of errors being caught has shifted my opinion to largely happy pro-flow user. &gt; the type checker will force you to add type annotations whenever you export a variable. So.. this is a good thing. The flow checker wants your code to be 100% runtime safe. When people say you can add types incrementally, they mean you still get some benefit without having to retrofit your entire codebase with types. Like any linting, things can be turned off while typing, or ignored entirely to make flow "pass". &gt; Usually, an : any type annotation will silence the checker. That seems pointless, why not make that the default? That's an interesting point, but I suppose you could say that `any` may as well just be removed. I don't think I've ever seen `any` be used except for getting flow to stop complaining. &gt; inline (Java-style) instead of being defined on a separate line (Haskell-style). If I had to inline my types everywhere I would *never* use flow. When I see code like this I want to hurl: let fn = (fn2: (arr: Array&lt;{}&gt;) =&gt; {}, st: string): ((Array&lt;{}&gt;) =&gt; Array&lt;{}&gt;) =&gt; (arr) =&gt; [{}] It's impossible not to inline at least the type name annotation, most of the actual typing can go above elm/haskell style type User = { name: string } type Users = Array&lt;User&gt; type UsersTransform = (arr: Users) =&gt; User type TransformTransform = (fn2: UsersTransform, st: string) =&gt; UsersTransform // just needs type name once let fn: TransformTransform = (arr, st) =&gt; arr =&gt; [{}] &gt; It's yet another flavor of non-standard ES6 Between TS and flow I think flow is a little closer to the ground since it's part of babel. I could be wrong on this, but I'm fairly certain TS deviates more. I mean.. because of the above ^^ `type` style annotations most of the typing can be removed without affecting completely standard JS. not completely though I guess ------ I want to point out the "type of error" that flow catches a LOT, and it coincides with my favourite eslint rule `no-unused-vars` `no-unused-vars` catches tons and tons of spelling mistakes. let foo = 3 &lt;----- foo is defined but never used if (fuo) {} In my react code I might have a component: type Props = {| foo: string |} // must have only the prop `foo` let C = ({ foo }: Props) =&gt; &lt;div&gt;{foo}&lt;/div&gt; Then in some completely other file I do: &lt;C fuo="bar" /&gt; In this other file I get the warning saying prop not defined in `C` which is great and i can hover to see which props I actually need. Even better... in the `C` component file... it squigglies saying "the following files import this component but do not pass to correct props".. I can just click on the squiggly and takes me directly to the other file so I can see that yes I indeed have a spelling mistake, or maybe I changed the name of a prop now I know exactly all of the files that need to change. Hope this helps 
&gt; Between TS and flow I think flow is a little closer to the ground since it's part of babel. I could be wrong on this, but I'm fairly certain TS deviates more. I mean.. because of the above ^ type style annotations most of the typing can be removed without affecting completely standard JS. not completely though I guess I think TS and Flow are about the same. For example, your sample code is also valid TypeScript. TS's only deviations -- namespace syntax and enumerations -- are optional and have essentially been replaced with ES6 modules and literal types. I enjoyed reading your post. I'm not for or against either tool; whatever gets people using a typechecker is a win in my book.
this is often handled by debouncing the redraw. domvm, for instance, uses requestAnimationFrame to debounce, so all mutations that can be queued within 1 frame (16.6ms) will reflow together. this works well for 99.9% of apps.
Actually, concat returns a new array. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat
something substantial ? like what !! 
You have low standards, maybe: https://www.reddit.com/r/programming/comments/612v99/vs_code_uses_13_cpu_when_idle_due_to_blinking/
Well lookie here, looks like we gota college boy here! What's the matter college boy, too college for us!
YDKJS is fantastic. That being said I don't go there every time I forget the callback argument order for Array#reduce
TypeScript is light years ahead in terms of development tooling and community adoption. (It's also had a large head start to be fair)
Let me know what you think! (If you are still alive after reading my book, that is ;-)
Thanks, always glad to hear that! 
W3Schools is much better. /troll
High CPU utilization is not the same thing as poor performance or poor user experience.
I have not seen that tutorial but my guess is that you'll need an intermediary server to broke the initial P2P connection between the two computers.
Interesting what's a better middle ground than using querySelector?
I'd like to point out that namespaces aren't just optional in ts but have even been deprecated and are listed as such in the official documentation.
In a world that's converting almost exclusively from desktops to laptops, constantly high CPU utilization, especially for *no good reason*, in the very least means shitty battery life. It can mean the difference between 6 hours of battery life and 2 hours of battery life. And that's a very poor user experience. *Electron: our platform is awesome, but please don't use it on a laptop ^^tm*
Yeah we use TS for the front end at the company I've been with for about 3 months. From day one I felt like the only thing I needed to get used to was ES6 syntax, and that's really just a style choice. Typing is optional and great.
How is it ahead specifically?
FYI, viewing on mobile app is a bit difficult. Everytime you ask for input from the user, I touch the input box and my qwerty keyboard shows up on the screen and the app asks me to rotate because it's best view in portrait mode. So I can really see what I'm typing until I drop the qwerty from the screen. Just thought you should know.
This is basically how I feel about typescript. I just don't add too many types and it seems to stay out of my way. 
For non-programmers, it probably makes sense to start with material that also explains how to program. I’ve heard good things about: * [Coding for Visual Learners - Learn JavaScript with p5.js](http://www.codingforvisuallearners.com/) * [JavaScript for Kids](https://www.nostarch.com/javascriptforkids) Once you know how to program, you can check out my books on ES5–ES2017 (which are free to read online): http://exploringjs.com
What happened to 3.0.0?? 😱
[http://angularjs.blogspot.ca/2016/12/ok-let-me-explain-its-going-to-be.html](http://angularjs.blogspot.ca/2016/12/ok-let-me-explain-its-going-to-be.html) tl;dr: &gt; The core Angular libraries live in one single GitHub repository at github.com/angular/angular. All of them are versioned the same way, but distributed as different NPM packages: &gt; @angular/core v2.3.0, &gt; @angular/compiler v2.3.0, &gt; @angular/compiler-cli v2.3.0, &gt; @angular/http v2.3.0, &gt; @angular/router v3.3.0 &gt; Due to this misalignment of the router package’s version, the team decided to go straight for Angular v4. In this way again, all the core packages are aligned which will be easier to maintain and help avoid confusion in the future.
SPA doesn't mean there's only a single page. It means the application is controlled by something like a router and the pages are modules that are loaded on demand. These components can still be server rendered. That in itself is the improvement over the stack you're using. You could of course use a view framework to get rid of jquery which would be an improvement but it seems to me reading up on modern SPAs and SSR, routers and so on will be more effective.
The hilarious thing about this is that if you just type queries like `mdn array splice` into your browser location bar or Google search box, it already takes you to a *Google* search results page where the correct MDN page is at the top every time anyway.
Not going to argue against it, that's your personal perspective. The template parser that ships in Vue and the jsx parser that ships in babels script tag, there isn't much difference. &gt; no need to install node, learn jsx I would be ok with this if that was your opinion, but you just argued for learning a template syntax instead that is margins and worlds in complexity from the minor (and optional) extra semantics in jsx. [And again, you don't need node or build-tools for jsx, that is a common misconception](https://www.reddit.com/r/javascript/comments/5sz52d/whats_the_most_out_of_the_box_frontebd/ddixjqz/). 
If your object contains getters/setters this approach won't cater for those i.e. you will lose them in the copy. What I suggest is to have a look at lodash which nicely handles those cases: https://lodash.com/docs/4.17.4#clone https://lodash.com/docs/4.17.4#cloneDeep But if you really need to just clone a simple object you can use Object.assign: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
&gt; A brand new feature that it had before the spec was even finalized? What? TS features drafts and always has, be reasonable. But they select to their whims, staffing and abilities wheres Babels large community keeps close contact with the tc39 proposals. I've been coding async for several years. Half of the modern web has been deploying spread with redux for years. Yet you couldn't unless you'd route through another Babel pass, because you decided to let Microsoft define the reach of your language. &gt; These issues being...? There have been several parsing issues in the past, all tracked on the TS git. We're talking a minor type checking tool that tries at the same time to transpile ESnext and foreign DSLs. Of course they'll make mistakes. Flow on the other hand concentrates on types as it should.
Async and spread came i believe in 2.1, which was released *recently*. Until then spread for instance was a living draft for a long, long time and TS could not parse it. Before that it was npm which you couldn't use because TS broke it. There are many new proposals which right now you can't use. And there's hardly a reason why it should get in between you and the language in the first place. Flow proves that a typechecker can behave like any other modular tool. That's why FB wrote Flow, because without it you'd have had to decide between idiomatic Redux or types and that is just silly.
I'm more of a fan of this one: [http://www.jsoneditoronline.org/](http://www.jsoneditoronline.org/)
Anybody else just chilling on 1.6?
Your only options are the standard DOM methods, querySelector, or some custom abstraction. Mithril is the fastest abstraction among popular frameworks I have seen.
Thanks, a lot of good points :)
You could use a `\` to go directly to the first result. \mdn array reduce Or just as easily use a single bang for the same effect, don't know if there's anything different about them but they both produce the same result. mdn array reduce !
Eh, a fine comparison, albeit it's very superfluous. What about having subroutes inside components in React? React Router 4 can handle that. Route dependant rendering inside a component too. Angular 2 contains the whole shebang for having MVC, while React is really only V. The article is fine but doesn't really bring anything new to the table, nor is particularly in-depth.
For deepcopies: import cloneDeep from 'lodash/cloneDeep' let clone = cloneDeep(obj) clone.name = "new name" For shallow-copies: let shallowClone = { ...obj, name: "new name" } And should you want to do the same with an array: let shallowClone = [ ...oldArray, newItem, anotherItem, ...someOtherArray ] Just consider that deep clones are expensive and often unnecessary for the task at hand, depending on what you need to do of course. Use shallow clones whenever you can.
I was hoping to see a tutorial here... It's better.
Wow, thank you! That was super helpful :)
More chatter here : https://gitter.im/aurelia/home ;)
That was fast https://github.com/angular/angular-cli/blob/master/CHANGELOG.md#100-2017-03-24
&gt; avoid confusion Nailed it
Browsersync, as far as I know always does a full page reload.
&gt; By using static typing you'll catch bugs early and save a lot of debugging time. I think that bugs can be caught early by having a really high test coverage without such an intrusive paradigm shift. For you it may be a paradigm shift, but this is nothing new, and a lot of languages use it with great success (Java, Swift, Haskell, C#). Even a dynamic language like Python includes something like Flow out of the box now (3.5+). &gt; I think that bugs can be caught early by having a really high test coverage without such an intrusive paradigm shift. That is an option, but tests take much more time to write and maintain. If you just follow the auto completion with Flow, you will never write a method that doesn't exist. If you refactor something, you will get warnings immediately, that some method doesn't exist anymore etc.
Hits the hammer on the head.
Yes the initial release of Angular, v2, is what I am referring to.
Circa 1.5, I moved to React and never looked back. Well, sometimes I glance back, just to see how she doin.
You probably mean Preact and Inferno. Vue is a derivative as well, but more under the hood and probably more appealing to Angular users as it sticks to its OOP and templating approach while the former two are following Reacts functional principles inside and outside and can partake in its eco system. The license did change after Google complained. It still has some awkward wording but it's an improvement. Anyway, if you wanted you could run Reacts code and components elsewhere. I always alias to another engine for production builds. Inferno for instance is just 7 kb.
I'm on Aurelia 
About your favorite type of error, I'd say that propTypes serve a very similar purpose. I know those work at runtime, but ESLint on it's own catches a lot of validation problems with JSX (if it doesn't, you'll get runtime errors that you will see when you test what you're working on). Anyway, drawing the line at "type-check your components, leave your functions alone" is reasonable to me. What isn't is "make your entire project a mathematically correct model even if it takes you 3 times as much effort to write code". I see what you like about those errors. They're useful. To me, they're still not worth adding an entire layer of complexity to my projects.
You can do it on GMxhr but I don't think it's possible to do it on (a href)
It sounds like TS is more fogiving that way. Flow, however, intends to be a "sound" type checker, and so it forces you to annotate a lot of code.
I understand this is nothing new. That is **exactly** my point. The industry has had this discussion a million times. If Flow means turning JavaScript into Java, then I'm most certainly not convinced. In fact, I'm pretty convinced that would be a horrible idea. What I want to know is if there's something special about Flow's type system that would make JavaScript better. Also about types being a replacement for tests: They're not. Tests verify that your program does what it should do. Type checking merely verifies that you pass valid values around, it has nothing to do with alorithmic correctness. If you don't write tests, then your application will be very fragile, even if you add types everywhere.
Thanks for offering help! Right now, for work reasons, it's got to be Flow.
Sorry but you aren't going to write type tests that are anywhere near as good as a compiler. Why waste that time when there is a tool to do that for you?
I like angular 1 I use it at work. It's one of those things I feel like I could do in my sleep so it seems like the best and fastest way to get things done. I'm glad I can fall back on it.
[Effective JavaScript](https://www.amazon.com/Effective-JavaScript-Specific-Software-Development/dp/0321812182) It's broken down into 68 items that are each just a few pages. I read through 3 items a week at work. 
I have to agree here. Typescript tooling is much, much better. Flow is not ready for production use IMO *unless* you have a small team or highly homogeneous development environment (everyone use the same editor and tools), but even then I'd pick Typescript because it's just more mature and easier to use at this point. Edit some of the issues with flow vs ts: It's slower and buggier than ts New releases bring frequent major structural changes every month, forcing code updates to keep-up-to-date, and tooling often falls behind and doesn't work with latest version. Error messages are confusing and difficult to understand compared to ts It's written in oocaml. Good luck reading the source or contributing patches. Editor support. Nuclide: good, but ugh Nuclide is terrible, vscode: best, but not as good as ts, Webstorm: bad, Vim: ok. There are more and higher quality ts definitions available for 3rd party libs.
Serious question, completely skipping v3 and seemingly being semver, what are the breaking changes from 2 - 4? Is 2 - 4 a big deal or really more marketing/version alignment?
I did pretty much use the default `vue-cli` configuration, although I had to add an build config for a Cordova environment, but the vue-loader is extremely effective for processing all css preprocessors. I think the only other change I made to the build config was changing the '@' alias to map to '/src/js' instead of '/src'. As for authentication, our API is stateless, so I have to use a token stored in local storage to check if the user is authenticated when the app initializes. Unfortunately, I couldn't find a way to have `vue-router` wait for the async http request to resolve to decide how to route the user, which is important because the `beforeRoute` hooks must be synchronous, so I took advantage of Vue's flexible nature and wrapped the main Vue instance in another one, which i call Load, which imports the session class, makes the initial authentication request, and upon resolving, i use `require('./app')` to load the main Vue instance, which includes the router. From there, I can determine whether the user is authenticated in a synchronous way, so I can use the `beforeRouter` hook to decide how to route the user.
that jquery dependency seems especially harsh in react-land
The license thing was never really resolved. A few lawyers chipped in saying it's basically impossible to end up in legal trouble unless you're recoding Google+. Fear, uncertainty and doubt is forever entwined with internet. But no, Vue got popular because it's small, clean, and really well thought out. It has a full ecosystem, but you're free to ignore all of it. Server side rendering is easier with Vue than any other major framework.
&gt; Oh and one more thing: at least for now don't use angular if you aren't trying to make an spa. It really isn't suited to traditional websites and leans heavily in the spa direction. But it is very good at that. I haven't looked closely, but I see there are some projects to bring angular and Bootstrap closer together. I wonder whether these are an attempt to address that issue, ie. a good way to use angular 2/4 for non-SPA sites. https://ng-bootstrap.github.io/#/home http://valor-software.com/ng2-bootstrap/#/
So far I know arrays, objects, etc, can write an effective for loop, can do some basic coding with JavaScript, event listeners and replacing HTML, text, etc. But I'll check these books out for sure. Thanks. 
Makes sense! Invig tries to push towards standardization. After two weeks of no semicolons and trusting on ESLint to prevent any cases where that could cause issues, it's hard for me to now look at semicolons and not think of them as noise. But this is a taste thing. Invig is opinionated, and so probably not for you.
Now there's a win. Thanks!
And?
JS performance optimizations are being constantly made, and while I'm familiar with the idea behind hidden classes (which I'll briefly summarize), I'm not sure where exactly they get applied and how. Basically, the idea is that given a "class" in JavaScript, VM optimizations can be made to represent that class definition as a native class structure to help with member access and whatnot. Given that a JS constructor pumps out objects with similar prototypes and a consistent set of properties defined in the constructor, a single native class can be used to match those members and be used as a surrogate of sorts to help speed up use of those objects. Now, the obvious application of these "hidden classes" as their called is with the pseudoclassical constructor pattern for object creation. You have a pretty clear of intent when using a function with the new operator that you're treating that function and respective prototype definitions as a class. I would also guess that its possible similar optimizations could be applied to other kinds of instance creation - possibly with Object.create - but I don't know. Elliot (who is a bit of a zealot, so tread carefully) seems to be implying that Object.create does not have this optimizations while constructors to. But he's also saying, which is in my opinion is true, not to worry about it. Chances are that this optimization would not likely matter to your code and any slowdown you do see is likely the result of a bottleneck somewhere else. So to answer that question, no. The difference would not be 'dramatic'. There are optimizations everywhere and what may be true today may not even be true tomorrow. What you need to do is find a style that you feel comfortable with and use that, whether it be using constructors, or other forms of object creation like [stamps](https://medium.com/javascript-scene/introducing-the-stamp-specification-77f8911c2fee).
I was at a Meetup with an older programmer organizing it and he was talking to some friends of his about their product and they said they were just finished on switching to angular two and they were getting ready for 4. And he looks at them angular has already gone from 1-4 ? Well I guess I don't need to learn angular
I didn't bother to check your code, as my Dutch knowledge is rather lacking. This is how I wrote it: // Set up the initial variables const primes = []; const total = 1000; const last = 20; // 1 doesn't count as a prime, start with 2 let i = 2; let j, notPrime; // Continue to check until 'total' primes have been found while(primes.length &lt; total) { // Assume prime number notPrime = false; // Perform check to see if it's not prime for (j = 2; j &lt;= i/2; ++j) { if (i % j == 0) { notPrime = true; // Number is prime, no need to check more numbers. // Therefore, break break; } } // Only add to list if it is a prime if (!notPrime) { primes.push(i); } // Increment the counter to use as the next number to check i++; } // Slice the array from the back const lastPrimes = primes.slice(last); // Print out the result console.log('Primes', lastPrimes);
You may be running into security restrictions if you're going cross domain. I'm not really an iframe expert, though, haven't really used them since literally the 90s. Here's getting the url of the same domain (same host/domain, protocol and port) via [document.getElementById("iframe").src](http://codepen.io/anon/pen/zZaLgP) 
There is also [Reactstrap](https://reactstrap.github.io) that is Bootstrap 4 and all the JS components are ES2015.
Thanks! It's very clear and I will find some way to compare it with my code and finally hand in a combined result! 
Not a criticism of your drive to be a better programmer, but stringifying and parsing an object isn't inherently bad. I've worked on applications processing millions of requests per day that use this method in production just fine. These are all just tools at our disposal. :-)
Yes.
Thanks for this clarification
Still rocking 1.4 here... no need to upgrade I understand the power of typescript, but JavaScript is universal at this point and will stick with it until another browser native i.e., non-compiler required language for the browser is created. 
2nd-ed. Regarding performance... I've made a small bench of Object.assign vs JSON.stringify/JSON.parse: https://esbench.com/bench/58d546c899634800a0347b1c
From a quick skim of the changelogs, 1. No more extending from Lifecycle methods, instead you need to "implement" 2. OpaqueToken is now deprecated, use InjectionToken&amp;lt;T&amp;gt; instead. 3. SimpleChange now takes an additional argument that defines whether this is the first change or not. This is a low profile API and we don't expect anyone to be affected by this change. If you are impacted by this change please file an issue. 4. Animations are moved from core But honestly it seems more of a marketing thing. I personally would've moved to Angular 2 V4 but that's me
and if anyone wants to tell me how to make the code look nice in that box above 
Chilling on 1.5.5 tbh, and that's basically pending an overhaul to React to bring the project I'm on in line with the rest the projects where I work.
Looks like in this case that `Object.assign` is faster? I interpreted this comment tree as being more favourable to `JSON.stringify/parse`. Maybe deep nested objects make a difference?
That's what angular 2 is
Thanks. Speaking of iframes… What if I change the approach: instead of trying to affect links on abc.com, I can actually collect all the links of interest from that server and generate an HTML file on my server. Is it possible to inject some JS into that HTML such that opening links from that file (hosted on my server, as I've said) will produce referer like opened from xyz.org?
I agree fairly strongly with this. I've been shipping Angular, Vue, and React sites. Vue largely reduces to React where the functionality is similar. I was a big fan of Vue but I've largely become content with React and what I can do with it. I have far more flexibility and it more closely follows the development philosophies that I find successful over time. However, if you're coming from Angular, Vue is going to be a whole lot more comfortable of a move than React.
What you're asking is correct. It is 2. Its 2 because that's what the while statement reduces x down to. At 45, x &gt; 2 is true, so x-- is run, reducing it to 44. This happens down down down looping in the while until x is 3, where 3 &gt; 2 is true, so x-- gets called one last time until x = 2. At this point in the while 2 &gt; 2 is compared and resolves to false. Being false, x-- doesn't get called againand the next statement with the alert gets called with the current value of x which is 2.
I'm not sure why Vue has any advantage over React for incremental changes to an existing project. Both Vue and React just signal in their own way what part of the DOM should be targeted. I can easily imagine a website adding a Vue or React "widget" for advertising or news without converting the whole site.
You can export postman collections to git, at which point they are diff ready, also tag ready, at which point you can run the tags in Newman. 
I dunno about you specifically, but I've seen quite a few React fanboys who're Haskell-fanboy-level extreme, including on this very subreddit. All of those frameworks have some hardcore fanboys, unless they're *really* old, or *really* shitty. That's more or less a given. Besides, it's not *that* circlejerky of a story. It just says Vue is becoming slightly more mainstream. Which is obviously good news for people who like Vue, and might want to get a job writing Vue. It's not one of those "how I realized X is really the only way, everything else is The Wrong Way" posts. Heck, it doesn't even say Vue is better at all, let alone try to convert you.
[Image](https://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 4385 times, representing 2.8622% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dfd2yjy)
Thanks to you for this anwser. There is two main ideas behind getting into this kind of project. The size of the chair is pretty basic ^^ Indeed like you explained i think i'll do something very basic and next expand step by step. Also what i'm looking for by expanding my game in javascript is preparing for the transition Wordpress is operating from PHP to JS. I've learnt basic PHP... i'm not very confortable with Javascript so i'd like to learn so i can catch up with the developments of the project (and globally with the moder web i guess ^^) Thanks also for giving me the reference of localStorage indeed that seems like the kind of thing i' would be looking for. I'm pretty curious also about, and i know it's pretty far away from where i am currently at, how RemoteStorage works. I use several services that use it and i'm pretty convinced /r/selfhosted is a good way to go for a more open and free web. And i guess it's a JS API or something like that. Anyway, i will not forget to conceive this project in a progressive development way :)
No, Sentinel or whatever package will store data in the session which will allow it to know if the user is logged in. So every page the user goes to, Sentinel will check to make sure the user is logged in before allowing them access to the page.
Well first a css framework has nothing to do with whether it's an spa or not. You can freely use ng2-bootstrap or just regular bootstrap with angular. The important distinction for an spa is client side rendering. Second, the reason not to use angular in a traditional manner atm had to do with angulars boot times. If you aren't doing aot, ahead of time compilation, then every time angular boots on a new page it takes at least 2 seconds to start up. On an spa that isn't ideal but it also isn't the end of the world if it only happens once per session. If you use aot then angular will boot up in less than half a second making it far more usable on a traditional server rendered website. But the cli currently does not support making multiple apps all together that share code. So you can't use the cli. And doing it yourself is technically possible but it's a pretty big pain. 
Have you tried jmeter?
&gt; Templates are just sugar (for which you get penalized). Penalized how? Both JSX and templates get compiled down to the same thing.
Ember is already the Rails of the front-end, but it didn't catch on as much as React. The thing with Ember is that it has to be all or nothing. It's for starting greenfield. With React you can start implementing it and experimenting with it on specific parts of your app, so buy in is easier.
That's good to hear. I use requestAnimationFrame in our legacy jQuery systems, but I didn't know it would queue all mutations in every single browser---at least MDN didn't mention that. 
Take a look at Marko (http://markojs.com/). Honestly, it's the best of React and Vue put together.
We're deploying cross framework components. React, Angular, Vue and others. That has me doing the same thing for all frameworks that are being used by customers. I enjoy many aspects of Vue, maybe it doesn't come across that way, it's only that it itches in my fingers when i read that Vue is supposed to be magically easier and all that. 
I have been trying to understand what exactly made the react/vue.js framework or approach so popular, maybe from a code quality point of view. Is it just that it modularizes/componentizes apps? Compared to just like jquery spaghetti where you can access any DOM from anywhere and no modules are really defined, that is the only thing I can come up with, because other touted benefits like vdom dont seem like that great of a benefit to most apps (I am not a user of vue/react for any projects btw I have only dabbled)
With a runtime parser. It parses templates into functions with an extra blob of javascript you have to include. Unless you use Webpack and single file components, where it does it at compile time. That is the same with JSX, it also gets processed runtime when you use the script tag. Though React doesn't nudge you into that pit, it encourages best practices. These apply to Vue as well, but once you're in the pit, figuring that it is limiting, you climb out, get a build tool, and end up with something that is far more complex since you're confronted with extra loaders, arbitrary file structures and whatnot. 
Yeah ember's built in tooling blows vue's out of the water
New fanboy here. I have used just about every framework and even rolled my own, but vue has really hit the sweet spot for me. Just started using it on a large app and it's been a dream. The gitter chat has been a huge help.
The virtual dom technology makes the unidirectional data flow pattern possible. The benefit of this is that you can treat a two-way binding system as if it were a one-way binding system. One-way binding systems are obviously less complex and easier to reason about. 
In WeakMaps, the keys are weak, not the values. In your example, the weak object would be index. But since you retain a reference to index, its never up for collection.
&gt; Another myth is that React needs build tools. It doesn't. Oh jesus christ no. Don't do that in production, ever. You're literally just making bundling your build tools with your product and making every user download and run them on every page load, instead of just doing it once yourself. You're not even wrong that React doesn't need build tools, you're just proposing a terrible way to do it. If you seriously want to drop the build tools, then [write JavaScript, not JSX](https://facebook.github.io/react/docs/react-without-jsx.html).
Writing out your problems so often clears the mind! 
We also recently published an article on the release of Marko 4.0 for context: [Marko 4.0 is here](https://medium.com/@mlrawlings/marko-4-0-is-here-837884c5f60d). Feedback and questions welcome! Also, here is the earlier discussion on Reddit for the previous post: [/r/javascript: Marko 4.0 released – the friendly and fast UI library from eBay](https://www.reddit.com/r/javascript/comments/5xgk9q/marko_40_released_the_friendly_and_fast_ui/)
What you're looking for is a weak value map. That's not in the core JS language, but if you're targeting node, you can use something like [weak-value-map](https://www.npmjs.com/package/weak-value-map). Weak key maps are the only weak references that exist in JS core today, and you need a reference to the weak object to get at value within the map. You have no introspection (by design) into what the state of the weak reference is. Does it still exist? Has it been cleaned up? No way to know. If you're trying to get at an object that may or may not exist somewhere in memory, there's no way to determine that currently without you keeping track of it yourself. Plus you're trying to look up objects through strings and weak maps only allow objects as keys - not that it matters since its not a weak key you're after. I'm not sure there's a way to get what you're after without doing some kind of animal tracking manually.
I spend the last 2 hours googling over it. I'm sad, but you are right. The thing I want to have is equal to a WeakHashMap in java and this is currently not possible with browser-javascript. :( In the end, WeakMaps are pretty useless.
So now 6 people use it? 
I hope that never happens. As great as Rails seemed when I first started using it, I eventually grew to hate it because of the way Rails and every gem monkeypatches the shit out of every fucking core object. And since the Ruby world is essentially a monoculture of Rails, it's really hard for newer, better ideas to take hold there. It's a shame because I like Ruby the language, but hate Ruby the ecosystem.
They're good for mapping objects to other objects, for example mapping an object with custom properties to a frozen object or some other object you can't/shouldn't be adding properties to yourself. They're used for implementing private members in JavaScript classes too (similar idea).
I don't know. If Ember really was the next generation I think I would hear about it more than I do and the little I do hear about it doesn't lend me to think most people look at it that way.
I've been using it and enjoying it quite a bit, even only for the templating syntax portion of it. The template language is so much more natural and powerful than handlebars, so much less cumbersome than JSX... the performance benefits to me are a minor (but nice!) side effect. I highly encourage you to mess around with it for an hour or two, start with one of the example projects and see if you like it. --Robert
Would love to get your feedback on [Assertible](https://assertible.com). We're heavily focused on automated post-deployment testing. *Disclaimer, I'm a co-founder*
I can't deal with React platform and everything associated with it to make it work. It's all over the fucking place. I prefer Angular headaches any day.
Watch a Gavin Joyce video and you'll be immediately turned off to the rest. lol
Wow, that's a blast from my past! Do you use it for api endpoint testing?
It would be 7... unless you know someone who's only 85.71% person. ;) "grown by 600%" means 1 + (1 * 6.00)
okay 
SV has settled on react. kind of. if you apply for jobs in SV a lot that are on any framework tend to be on react it seems Alibaba's adoption of vue has led to lots of Chinese webdevs to go in that direction
Anyway, you're also making the assumption that "I' will use it to develop a Node app, which is a small percentage of the wild. Web Reload is just meant to become a better Live Reload, zero configuration and no server by default.
New flavour of the year. (:
Aren't they solving different problems? Ember is a full application framework, react is just a highly opinionated view library. Rails is to angular or ember as lyft (Scala), or blade (php) is to react or vue. I wouldn't say react and ember are in direct competition.
Angular just released v4. Some major companies were waiting for this release, to the point of sticking with angular 1.x until a more refined version of angular2 came out. So... may the battle rage on. 
This is so, so biased. The article positions itself as this objective comparison between frameworks, but it's written by one of the Marko maintainers. The React examples are either purposefully made to look more irritating than they actually are, or the author just hasn't used React much. Either way, the comparison is unfair. React has its share of thorns and Marko looks interesting from what I've seen, but this article bugs me. Should have a disclaimer right at the top that explains that it's actually a sales pitch, not "An in-depth look". EDIT: So I re-read this comment this morning, and it feels much harsher than deserved. I [added a reply below](https://www.reddit.com/r/javascript/comments/61c0l6/marko_vs_react_an_indepth_look/dfe1ixi/).
Looking at Marko for the first time right now thinking: "..." "FIRST CLASS SUPPORT FOR JADE TEMPLATES! YES!" ... *proceeds to cry profusely* You have no idea how much I've always wanted this in React.
They're not talking about competition, they're talking about what would be analogous to Rails as a client-side framework.
There's simply too much competition. I hear a lot about Vue on Reddit and other dev sites but in the corporate world it's non-existant. It seems that React ate Angular's lunch thanks to the 2.0 upgrade fiasco and unless React majorly screws up it will continue to grow.
Yo. I faced this exact problem about two months ago. I was using Knockout and firebase as my go for everything. My problem was keeping my code organized enough to maintain, and clean enough that I could effectively move team members to and from projects on a whim. I couldn't do it. But two months ago I switched to Vue, and in combination with Vue and the AirBnB style guide (crucial, you need need need a style guide for this to work well), I can keep my whole project/view model organized like this: let viewModel = new Vue({ el: "#selector-for-view-context", data: { // anything }, methods: { // functions to bind to elements } }); And there's a lot more but I don't wanna write it. You can read a way better explanation on their site which is the second best thing about them. Their documentation is unparalleled! It's amazing. Only took my team two weeks for a full transition from knockout to Vue. On top of that, it has fantastic scalability. You can create custom elements called components that can be simple or incredibly complex and act as their own micro view model. I have been able to scaffold and make huge design improvements, feature expansions, and bug fixes faster than ever before. It is so much better, in fact, that I am having an intern convert past applications we've made into Vue from Knockout so we will have a more efficient flow. TL;DR [Vue](www.vuejs.org) is the fucking cheese and I love it and you should too. 
It absolutely does and a lot of the haters just haven't kept up with it or are swayed by popular bias IMO. I have fun tooling around with different frameworks/view libraries but using Ember for work is a JOY. Hope to see some of you at Ember Conf in a couple days :). Ember-CLI is basically a 0 configuration webpack with a great addon community as well, check it out.
React by itself isn't great, but where I work we use a mix of React-Redux and Virtualization and it can handle a list of any size perfectly fine. You can dig pretty far into react performance. That being said, I understand some people not liking the configuration aspect of the React stack
I'm sorry this article rubbed you the wrong way, however we're not trying to tout this as a totally unbiased view, in the very first sentence we say "from the perspective of the maintainers of Marko". This post is obviously motivated by our desire to share Marko with more developers and show, if you're coming from React, a lot of the concepts you've learned will carry over. That said, we have made an effort to be objective. As for the example, I'm guessing that you're referring to the first one (the counter) as the others don't have a whole lot going on. I did take another look and you're right, so, we reduced the code a bit by using an implicit return and passing the property accessors directly to the onClick method. However, it's not hugely different. I think this also speaks to the nature of JSX - there's so many possible ways to write some of these things (Here are some other options: https://gist.github.com/mlrawlings/117171c08eb61b91cdb4ab9710d98887).
Hah. I'm glad you appreciate! I'm not going to lie, we spent a lot of time working out the exact details of the language and the parser (countless hours of discussion...) to make sure we could properly handle every edge case. The grammar for syntax highlighting was work on top of that. I'm really pleased with the final language and hope others enjoy it.
Oh good, I was worried we wouldn't have 5 new js fameworks this year ;)
If you look at this site's stats, react doesn't even break 0.1%, meaning Vue is already passed it. AngularJS (presumably 1.x) is at 0.4%. React only is ahead in certain echo chambers, most companies don't care about JS fads unless its a new project.
haha! Pls no. I was hoping there would be a super elegant way to do the same thing naively. Like `var newObject = new oldObject`
Asynchronous and non-blocking server-side rendering. ~30% faster than React's `renderToString`. [https://github.com/FormidableLabs/rapscallion](https://github.com/FormidableLabs/rapscallion). I've incorporated this into our SSR and it's been great.
The best part about Vue to me is that you can use it as a full fledged SPA or you can sprinkle it in existing applications. 
Yeah, the stat is utterly meaningless. But hey, Vue is pretty awesome, so I gave it an upvote anyway.
Listening to Evan's talk at Laracon last year, he showed a chart of activity after Laravel's author (Taylor Otwell) tweeted about it. It definitely gave Vue a nice bump in numbers. Also there are some awesome video tutorials about Vue on [Laracasts](https://laracasts.com/series/learn-vue-2-step-by-step) so I'm sure that doesn't hurt either.
No. The JSON encoder/decoder is native and built into the JS engine so `JSON.parse(JSON.stringify(...))` will almost always be faster than an object cloning algorithm written in JS. Here's a benchmark to compare it against lodash.cloneDeep: https://jsperf.com/lodash-copy-vs-json-stringify-parse
Yep it works awesome
I'd never really been introduced to JavaScript, I knew php and html, but vue made the transition so simple. I honestly love it and I'm glad I didn't end up going with angular which I very nearly did.
You are confusing over-posting with most popular (or most referenced)
Yes. Use `&amp;&amp;`. const filtered = myArray.filter((value, index, array) =&gt; { return value % 2 === 0 &amp;&amp; array.indexOf(value) === index; }); 
You can just chain it. Do one filter followed by another. That's 1 variable and easy to read. 
IMHO you should also write about the features that React supports but Marko does not, to make it at least a fair "X vs Y" article. I have to assume there are at least some, only because of the file size difference... Otherwise you could just call this article: "Why Marko is better than React." Never the less Marko does look like an interesting framework. Good job.
You should try my favourite framework, it is much better then your favourite.
Yes. React is fantastic as well. Vue just seems like a more cohesive product to me than React right now (or a few months ago when I was making the framework decision)
&gt; Lots of people hate jsx Worst engineering argument ever.
It does not ship with Vue. 
Same, I had created a few react apps and I liked the direction that the web was heading with states and the component being a rendered version of the current state. I didn't enjoy redux at all, though looking back I probably used it for way too much. Vue definitely hit a sweet spot. I like how I can drop it into an existing page and use it for a small component, or make it the basis of a page entirely, or even go for full SPA. 
The reason people like jsx is because it's not prescriptive; it's essentially plain Javascript. So while that means there are a lot of ways of doing things, it also means that none of those ways require domain specific knowledge of react because it's just plain Javascript. There's no need to make everything the most verbose version Javascript has to offer. class Counter extends Component { constructor() { super(); this.state = { count: 1 }; this.increment = this.changeCount.bind(this, 1); this.decrement = this.changeCount.bind(this, -1); } changeCount(amount) { this.setState(({ count }) =&gt; ({ count: count + amount }); } render() { const { count } = this.state; return ( &lt;div className="counter-container"&gt; &lt;div className={`count-amount ${count &gt; 0 ? 'positive' : 'negative'`}}&gt; {count} &lt;/div&gt; &lt;button onClick={this.increment}&gt;+&lt;/button&gt; &lt;button onClick={this.decrement}&gt;-&lt;/button&gt; &lt;/div&gt; ); } } I just want to illustrate that you can make your component as verbose or succinct as Javascript will allow. So to a more seasoned Javascript developer, you're free to use all the 'tricks' to make code more compact. The article mentions that react requires if/else/for but it's completely untrue. You can easily iterate inline with things like `Array.prototype.map` which is much more intuitive than any template for loop syntax (plus you can do things like `filter`, `reduce`, etc.). Similar thing with ternaries, or I can pull in a package like `classnames` to simplify the example further. I don't want it to sound like I'm shitting on Marko, it seems like a cool framework and idea. I just think it's important to stress that the beauty of react is that it's all 'plain Javascript', so if you code verbosely in Javascript, the component will be verbose. If you don't code that way, it won't be. I'd like to see how react performance matches up against these newer frameworks once 16 is released with fiber. No one is arguing react is the fastest thing out there right now, but react is also pretty 'old' and sort of pioneered the vdom implementation. A lot has been learned from then, and it's overdue for performance release (which is coming with fiber).
Same here. Been doing single page apps since 2010 but VueJS really is a pleasure to work in. Coding with Vue is fun!
Marko looks awesome, but the ecosystem is not nearly there, and I doubt it will ever be.
The mounting function looks similar, true. But the result is not the same. It's closer to ng-app in Angular. You create a new Vue, add a few attributes to existing HTML, and you're good to go. No need to create any components. Just look at the examples in the intro section on the vue.js site. They're closer to Angular than what you'd get in React. They just compile to something React-like behind the scenes.
Very true, though the creator of inferno now works at Facebook on react so I'd imagine some of his learnings from inferno would eventually make it into react. Plus my understanding is inferno is almost an exact copy of the react api which means migrating from one to the other is trivial. I could be wrong about that though. 
You're not understanding. With vue, I can mount it on an existing dom element and have it use that existing dom element's HTML as it's template or component tree. Put it a different way - with ASP.NET there is no real solution to server side rendering. ReactJS.net is a band-aid at best. So, either I accept client-side rendering only, or React doesn't work for my development process.
On the other hand, you're locked into using ember cli for everything, and you can't install frontend dependencies via npm unless they have an ember shim. Our team is gradually migrating from Ember to Vue, and we've been investing some time in improving the tooling situation ourselves with a new build tool, [vue-build](http://vue-build.com/). We're trying to bring together some of the things we like about ember-cli (one touch project setup, convention over configuration) with things we like about using Vue with webpack (ultimate customizability when you really need it, sharing tooling with other framework communities like React). It's not finished yet by any means, but we've been dogfooding it for a few months and I'm extremely encouraged by the progress. All this to say: if you liked Vue but were put off by the tooling situation, I'd encourage you to check out our project, and even contribute if you feel so inclined! I really do think it's possible to have the best of both worlds here.
You can drop in React components anywhere you want, i don't understand your point. You don't convert pages into components, unless you want to? That mount call `render`works for everything, you could be in Angular and use a React component or any other context or framework. You can even turn React components into web-component directives and use them in generic HTML as well. 
As I said in another comment: that assumes you're adding new functionality, and that this functionality is self-contained enough to be considered a "component". It's a common use case, but there are many times where it doesn't apply. Think of utility directives, or even some simple "I click here, and then that thing there disappears" kind of functionality. I'm specifically *not* talking about easily compartmentalized "areas of high interactivity and state management". If it's confined to a specific section, like user reviews, comments, a news ticker etc., that's great. If it's just little bits of interactivity sprinkled liberally across the page, because the design requires it, it will indeed require replacing huge parts of the page with a component, and that's a bummer. And I'm not comparing anything to a single line of Vue.js. That line, by itself, is no simpler or more elegant than the React bootstrap function, and that wasn't my point. I just meant that you can add a tiny bit of JS code (more or less like that line), and a few attributes to existing HTML, instead of creating a new component. For some use-cases, mostly outside of the world of proper "webapps", it's very useful.
Are them Valve's partner? We still wait for halflife3 FeelsBadMan.
One thing to consider, if you find another framework you like better than Marionette, is migrating incrementally. After our team decided we really liked Vue in a greenfield protect, we tried rewriting part of our old Ember app in Vue and embedding it into the Ember app. We're not done with it yet, but it's going surprisingly well and has been less trouble then we expected. I'm not saying jump on Vue or anything else necessarily -- just know that if you do want to move, you don't have to do it all at once. And keep your head up! The framework churn is real, we all know it. I believe that it's because we're still figuring out best practices for frontend development and that once we do things will slow down a little. Until then, you're doing the right thing by just keeping your ear to the ground and giving it some thought. Eventually you'll see an opportunity to try out something new on a side project or a small piece of the thing you're working on now. Or something. And that'll give you the opportunity to figure out if any of this new shit can make your life better somehow.
[So do it yourself in java then.](https://developers.google.com/youtube/v3/code_samples/java#create_and_manage_comments)
This is true. Although I must mention that using inferno-compat reduces the speed, compared to the native Inferno
&gt; The mounting function looks similar, true. But the result is not the same. In what way, though? I've never used Angular or Vue, so maybe that's why I can't see the difference. &gt; It's closer to ng-app in Angular. You create a new Vue, add a few attributes to existing HTML, and you're good to go. No need to create any components. A component is just a function or class/object (if you want life cycle methods)? Can you show or link to a real example? I'm genuinely interested in seeing what I'm missing here. 
&gt; Vue runs JSX You either don't know what JSX really is or what Vue really does. In either case this is wrong. What Vue does similar to React is (just) use Virtual DOM. As does (in it's own, third and equally unrelated way) Angular 2 but that doesn't make Angular use JSX any more than Vue does. However, the way Vue does it, enables you, if you're that infatuated with JSX is to use JSX with Vue but it does not use JSX nor does it put it as the prefered or default option. Equally, Vue can work with Flux but it has Vuex which is it's own state management solution based on it's design. Vue tries to be both batteries included (for people that want that) and free-for-all (for people that want that or don't need the batteries) and suceeds pretty well. As for the API comparison, what the two frameworks provide with those APIs is also different. React is just a glorified templating engine. Vue provides a lot more viewmodel structure for the price of slightly more complex API. It's also got a lot of the the things Angular did get right and implemented them nicely, which many people miss in React where they either have to use a third party solution or dabble with DOM themselves. If people liked working with DOM there'd never be any of these frameworks. Yes Vue took many hints from both AngularJS and React. It clicks witj many non-religious developers exactly because it tries to take the best of both worlds. It is a good choice for people that liked AngularJS, but would like some of the stuff that React (better yet, React's ecosystem) offers much like Angular 2 went for the people that like J2EE frameworks and perhaps Ember. If you're religiously into React Vue has nothing to offer you.
Doesn't seem to have a router or state management.
Except lot's of people hate JSX because it's a shot in the head of one of the most fundamental thing in web developmet and that is separation of declarative UI from the stylistic and the functionality. It tries too hard to make all things JavaScript and many people, me included, are fundamentally against that.
Not sure if real or sarcastic.
Vue components display through a render call similar to Reacts, if you use it or not. [You can supply that render function with JSX](https://medium.com/js-dojo/whats-new-in-vue-js-2-0-beyond-templates-with-jsx-4b8cda05f95f#.9htr0ou8g). Angular can't partake in this because it's rooted in templates without functional backbone. React is not a "glorified template engine." JSX is a *compile time DSL*. This is React: const Header = ({ text }) =&gt; &lt;span&gt;{text}&lt;/span&gt; The simple idea that a function takes props and results in a functional description of layout. It translates into something like: const Header = ({ text }) =&gt; createElement('span', text) *Vue switched to that model in 2.0.* Your template `&lt;span&gt;{{text}}&lt;/span&gt;` gets translated into render() { return createElement('span', this.text) } *Which is the same thing.* The big API that is has is needed to wield and handle its Angular coat, because MVC is a complex thing and always was. React was born out of necessity to evolve the view out of the 2 way bound model approach. I found this quote in Teleriks discussion about the subject: &gt; I suspect this will become a sticking point for Vue. It is frankly a blast from the past - similar in feel to Knockout.JS and Angular 1. The view is defined in HTML extended with its own vocabulary of directives. So I suspect it is attracting Angular 1 refugees. It seems unlikely to pursade many React users however, because of the huge advantage React derives from its "everything is JavaScript" approach. No need for HTML directives for looping/logic. And templating integrates with modern JavaScript's modular name spacing and TypeScript's static checking and intelligence. React's approach creates a virtuous circle of mutually supportive elements.
So I re-read my comment from last night, and it feels unnecessarily harsh. Sorry about that! Also, apologies for missing the line about "from the perspective of the maintainers of Marko"; I think that it could be made much clearer, but having seen it now, it doesn't seem sinister to me in the way it did last night. Ultimately you guys are doing good work, trying to build tools for the community, and that should be encouraged. Creating open-source work is often a thankless job, and while I think my original point is still valid, I also think that I wasn't being particularly constructive. I'm gonna give Marko a shot on a side-project soon :)
r/theydidthemath
Salaries for most jobs, particularly career oriented ones, in the US are just higher in general than Europe - not just JavaScript or software development. I came from chemical engineering and an equivalent position in Britain, after doing my best to factor in cost of living, etc., was still a huge pay cut. Obviously benefits, work hours and work/life balance and healthcare are better in Europe. Although I have to say coming from a manufacturing background that the work hours &amp; work life balance are SIGNIFICANTLY better in the software world. And any decent job offer is going to come with a decent health care package. However I think the largest JavaScript specific difference is the demand. The tech industry is just so much larger and demand for developers is so high. Silicon Valley may be the stereotype, but in almost any city, even small ones, you can find competitive job offers. For example I live in the south-east, and Atlanta, Charlotte, Charleston, the research triangle in NC are all having large growth in tech (and therefore JavaScript).
Nothing to be anxious about. I'm a sr dev in what is now called "full-stack" (which probably isn't a popular notion in this sub) but for the longest was just called "web dev". Have spent a significant amount of professional and personal time in Backbone, really love it's targeted simplicity. Also have a big personal project in React, mostly as a portfolio project. I say it's nothing to be anxious over because the concepts are all the same. You're still generating HTML, managing state, and communicating with a RESTful service, just each framework takes a different approach. On a deeper level, though, I say don't be anxious because the JS sphere is in this flashpoint phase where it's insanely subject to fads and fanboyism. It won't last. Eventually, developer fatigue will reach critical mass (as several other devs in this post are pointing out) and the churn will slow to something more manageable. I wouldn't worry too much about the marketability of your skillset re:specific frameworks. Unless you work in a tech hotbed where employers chase the fads as badly as the devs do, desirability is more about your ability to learn, adapt, and your maturity as a dev than "are you an expert in XYZ framework that's popular today but maybe not tomorrow".
I'm a one-man shop, so "full stack" for me is server security and physical installtion, on up to animations. So, yeah, I have "fatigue", and am anxious because maybe these newer frameworks would have made my job easier, and the older ones will stop updating and improving. But I'm a Backbone man for I think 2 more years. I'm already having to replace all my RaphaelJS stuff, due to an apparent end-of-life (and wanting to move to &lt;canvas&gt; anyways)
Poorly phrased. I imagine taking classes in "Framework X" in your sophomore year, and by the time you graduate, the world has gone on to "Framework Y". Yes, you can learn it, of course you can. But maybe you're not hitting the ground running. I realize the college will teach them to adapt, and they'll be just fine. It's been a while since I was in college. They taught me FORTRAN, which was already outdated when we were learning it, but they didn't have a C teacher that year. It was that example I was drawing on. No one needed a FORTRAN programmer in 1996. ...and I was on my second scotch during this post. :)
The negative reactions come from an article called "Marko vs React: An In-depth Look", which is actually written by one of Marko's developers and is shitting on react: - the react example is overcomplicated, and nothing a react developer would ever write. - the term "Improved performance" can be found 7 times, and there are 0 statistics (besides filesize, which 1) is cached a lot and 2) that number is worst case - if you use a modern bundler with tree shaking). - the term "Improved ease of use" can be found 19 times, all of them are nitpick opinions (imo). Some of them don't even improve the ease of use (like marko tools vs babel tools). ----- Imagine someone just started out, seeing this article after spending a week messing around with React. This article can make him focus on a new/untested/unknown library that no company is hiring for. Not understanding that this "comparison" is actually the opinion of one of the people behind Marko. ----- This article was my first impression of Marko, and because of the attitude and biased "comparison" I lost all interest for now. Will just stick with Vue until I read more positive things written by other people than the developers.
I rarely e2e test APIs, why not simply unit test middleware?
js noob question, how do you use System.import with regular browsers?
it makes perfect sense, and it is also working. Thank you :)
just stupid :( thanks a lot for your answer, it solved my problem
Interresting. Not surprising they'd use that as leverage to cut wages in that your boss can basically kick you out of the country if he decides to fire you.
React elements are objects. They have internal state, an external facing API, and even correspond directly to ES6 classes. Yes, there's some aspects of 'functional' programming involved in the virtual dom, and unidrectional state via Redux but none of that is inherent to using React and Javascript is *not* a functional language but a multi-paradigm one. 
So basically [transducers](https://github.com/cognitect-labs/transducers-js), but with a less functional API. Seems nice :)
Seems to have a lot of open issues.
But isn't deference and basic priority matching already merged? I've been playing around with the examples and 16alpha for a bit and it seems to make quite a difference to the version rendered with stack. Either way, i'm excited about what you guys are cooking up. 
What standalone does is it wraps a fully baked "real" component made with React into a web-component that you then can use as a directive anywhere you like.
What do you use if not `onClick`?
Do you always troll, or do you just pointlessly add your lame comments for no reason at all? 
Yeah, that's sort of the point. The whole unstructured, non-componentized thing was kinda shit when it was the only thing you had (like in classic Angular), and i. But it still has have some uses. Like if you're writing a mostly static content site, and the JS functionality is so tiny it doesn't warrant an individual component. Especially if you have non-JS-programmers writing the HTML/CSS, and want to add minor dynamic behavior (*not* an actual dynamic component) to a largely static page without "learning how to program". I know it sounds like a niche use case, but there's a fuckload of those kinds of sites. And in my experience, they currently either use a blob of jQuery, or a pitifully unnecessary Angular 1 monstrosity, with all of its performance issues, weird API and boilerplate. Just to hide a group of checkbox when another one is checked, add a class to the body when a button is clicked, etc.
On my machine JSON is 200% faster than lodash (Chrome 49.0.2623 / Mac OS X 10.8.5). Good to know that even in modern Chrome JSON stringify/parse is still basically as fast as cloning.
`document.querySelector('#some-id').addEventListener('click', someHandler)` and for classes `[].forEach.call(document.querySelectorAll('.some-class'), function(node) { node.addEventListener('click', someHandler)})`
TS supports object rest/spread
I sort of agree with you and it's one of the things that annoys me with Angular, all those "ng-" attributes in the markup. But with Vue, the attributes aren't there anymore when rendered, and you're already adding all sorts of other directives as attributes (like v-for, v-if and bindings like :some-prop for child components). I just feel like the end result is cleaner and by writing *.vue template files, the component's behaviour is easily scoped. 
When you say "when rendered" you mean this kind of code has to be compiled/processed? 
That is an older style of coding, and that is unreliable when running a view engine that relies primarily on your virtual domain. With Vue and react, among others even listeners sit on the domain, while the rest of your code would be running on the virtual domain causing unreliability in your functions. In modern web apps we do not even use id's any longer as no longer serve the purpose of a unique identifier as they are part of the DOM and not the VDOM. So code you bind to an id, may be attempting to bind to something that has not yet been written to the DOM itself. These component you create also have life cycles, conditions of the component, so you can initiate functions based on the render state of the component, react has 8 life cycle conditions of a component, Vue has less, cannot recall the exact number. Through these cycles you can run events like api calls when a component is in a pre rendered state, and once data arrives it will continue rendering, you can do manual clean of stuff in a component destruction cycle. The other reason for using the attributes is data access, the function may need context of the data of the element or its parent container, you may be passing down functions from a wrapping component, this information will only be a ale withing the components state and not the DOM. There are other more complex reasons when you throw in Redux state management and what not. Simply put, its an evolution created out of a disconnect between the code we write, and how it is processed in context of the DOM. 
The difference between JSX and other template engines is mostly about how much control does it give developers. JSX is a nice XML syntax on top of Javascript, while template is its own language in which they dictate how to do some basic things like: - Declaring temporary variables in - How to loop through collection (v-for, ng-repeat) - How to do conditional rendering (ng-if, v-if...) - How data and event is bound to an element. Writing JSX, it all feels natural because it's just Javascript. You want a click event on a button? &lt;button onClick={ aReferenceToAFunction }&gt; You want the click event to be delayed by 200ms? &lt;button onClick={ delay(aReferenceToAFunction, 200) }&gt; You want to dynamically inject click event? const clickHandler = condition ? handler1 : handler2; &lt;button onClick={ clickHandler }&gt; And so on. While using template languages (I use Angular 1 specifically), I feel like I have to use a string for everything, like there is no freedom in the way I define a component. For complex projects, I'd prefer JSX.
You can't yet. I'm pretty sure it's still just a TC39 proposal (https://github.com/tc39/proposal-dynamic-import)
HTML is a markup language, hence the name. Browsers parse HTML to create DOM. In Vue the HTML based templates are compiled into pure JS functions which in turn get turned into DOM (note this is simplified, there is some added complexity with virtual DOM etc). This is either done in advance using vue-loader or at runtime with the larger runtime included build of Vue.
Iterating over the array twice by chaining .filter will have a big performance penalty for large arrays.
It actually does seem nice compared to the examples I saw for transducers.
It is true that they're solving different problems (and scope of problems), but in practice you have to choose between Ember and React; it's not really a case of plug-n-play where you could use React on top of Ember (but it ought to be). React is a library in theory, but I'm seeing that there are several library combos that end up looking like a framework in practice; even more so when you go looking for articles, books &amp; recommendations. In theory React is a library but in practice it's treated as a framework, more so when adding some of its friends to the project.
Ok that makes sense, along with the comment below from RemeJuan, I'm wondering still why it cant be processed and understood without needing the attributes. If it's parsing the template, building virtual dom with it, and then reading an "on:click", surely it could "bind" the same call within the Vue component code?
&gt; the react example is overcomplicated, and nothing a react developer would ever write. I don't agree, but that's subjective. See earlier comment from /u/mlrawlings: https://www.reddit.com/r/javascript/comments/61c0l6/marko_vs_react_an_indepth_look/dfdoxdx/ &gt; the term "Improved performance" can be found 7 times, and there are 0 statistics (besides filesize, which 1) is cached a lot and 2) that number is worst case - if you use a modern bundler with tree shaking). We have been benchmarking and optimizing Marko for a long time. Here are some links to benchmarks: - markojs.com homepage: [http://markojs.com/#benchmarks](http://markojs.com/#benchmarks) - Benchmarks repo: https://github.com/marko-js/isomorphic-ui-benchmarks - [Server-side Rendering Shootout with Marko, Preact, Rax, React and Vue ](https://hackernoon.com/server-side-rendering-shootout-with-marko-preact-rax-react-and-vue-25e1ae17800f) We have plenty of benchmarks to back up our claims on performance. I encourage anyone to review and run the benchmarks. &gt; This article can make him focus on a new/untested/unknown library that no company is hiring for Every JavaScript library started out new at some point. With that said, Marko is actually not new, but it has gone through a significant transformation in the last year while being used to power much of ebay.com (and growing). Also, I know at least eBay is hiring Marko developers and there are other companies using Marko so that statement is not true. It's worked out very well for us at eBay and others companies and I hope others will find it beneficial and that the community will continue to grow. &gt; Not understanding that this "comparison" is actually the opinion of one of the people behind Marko. It's made clear in the first sentence: "from the perspective of the maintainers of Marko"
But then you would need to add some sort of identifier (normally an id attribute) to each element you want to bind a click to, then you need to look for that identifier to bind the click handler, why not just bind the click handler directly?
There's a difference in this onClick and the built in html onClick, html onclick is very limited with regards to expressions, you can use either anonymous functions (declared inline) or global functions. With VueJS/Angular html attributes, it generally will search inside you controller, so there's no need for creating global variables. Also there is way more attributes than the default html markup allows, things like conditional hide/show are really great for me. Again, all of this without touching the global scope. But the big thing you get from all this is, you can look at your html and kinda understand what is going on without going to your javascript (of course for details you will need to visit your js anyway). With jquery for example, where all the binds are inside the javascript, when you look at your html you'll probably only see a bunch of empty divs and you won't be sure what they do, you will need to look at the specific javascript that is binding events there, and then double check with your html to get some "ah, so this bind is for this div, ok, let's continue...". Of course on this paradigm, the next step is JSX, where all you only need your javascript to understand all that's going on.
I see where you are coming from, but starting out with HTML and layering JavaScript on top has some nice benefits related to reducing boilerplate and keeping markup readable. And yes, you can absolutely pull in the `classnames` package for React (and Marko as well...), but Marko provides it for free for the main purpose of removing as much boilerplate as possible so that developers can just focus on writing the code that matters. Also, just want to point out that Marko allows any module to be imported into a Marko view and developers can inline JavaScript code so there's not much you can't do in Marko that you could do in JSX.
Seems more like an anti-marketing to me... Especially coming after "writing a radically new framework and calling it v2" fiasco. The whole thing is a next-level branding failure.
~$110-120k in the Bay Area. 
It does now, as I said in my post.. but it didn't for a very long time while I was able to use it with babel.
I guess that's where my older patterns conflict in my mind, I think it's so that you have slightly nicer looking separation of concerns afaik. Edit: you are still passing an ID when you tell Vue to use the template, so using simple child selectors and/or classes and 'this' context to bind clicks doesn't seem wrong to me
Some context: I knew zero about Marko, I read the article (formed an opinion based on that) and read the comments here. ------ &gt; We have been benchmarking and optimizing Marko for a long time. Great! I didn't know this, the only thing I read was: &gt; it will require less time to load and parse and this will drastically improve page load times on slow connections or on older devices. Based on our benchmarks, Marko consistently outperforms React I interpreted it as if they were some sort of parsing/loading benchmarks (and I did not click through). To me it did not sound like I should take them all that serious. &gt; I encourage anyone to review and run the benchmarks. I did this just now, and I am [getting errors](https://gist.github.com/askmike/c4fb61cd4744457a55e72be33e4c2e44). &gt; It's made clear in the first sentence: "from the perspective of the maintainers of Marko" I know, It is just the that the way I read the article (and I was not the only one, see [top comment](https://www.reddit.com/r/javascript/comments/61c0l6/marko_vs_react_an_indepth_look/dfdm915/)) I felt betrayed that only after clicking on the article which I thought would be objective I realised this was not actually a comparison (it might technically be a comparison, but it's obviously extremely biased). But it is still very written like a comparison. &gt; I know at least eBay is hiring Marko developers and there are other companies using Marko so that statement is not true. You are probably right, I know nothing about Marko. I think when marketing a framework it should should go something like this: 1) create better framework 2) convince famous/influencing JS people 3) build ecosystem 4) social/offline movement (meetups, etc) But it seemed to me (once I read the article), that this "comparison" was just marketing. And the javascript subreddit is not a very big community, with potentially lots of beginners to very easily convince (esp if you look at some of the questions posted here).
NYC: ~$150k/yr for a Senior Developer
The MIT youtube Channel might be helpful. There is a video series about algorithms and data structures: https://www.youtube.com/watch?v=HtSuA80QTyo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb
&gt; Coming from [I guess] an older style of coding frontend, where we were happy to no longer use things like the onclick attribute I know exactly what you mean, when I started out with PHP a whole movement was just starting that moved all logic out of templates. At the same time jQuery was gaining so much traction and it was considered bad to have any code/logic inside your HTML (HTML is for markup, CSS is for looks and JS is for logic/manipulation). "You can just use jQuery and select what you need using css selectors". Ever since angular 1 the trend reversed, we are now driving events through this markup layer (which is not really HTML any more). I guess the main reason being that we were using jQuery for basic animations (it enhanced the HTML), where now we use the HTML to build interactive apps.
If you are using vue, I think it only makes sense to do most things the "vue" way. AFAIK "v-on:click" will not actually attach DOM events to that specific element.
For that use case you can simply use multiple Vue instances (manually created or using https://github.com/karol-f/vue-custom-element) communicating via event bus or Vuex. 
Hi /u/thospray, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
for some extra perspective in this thread, javascript developers get paid a ton in Australia and you get all the workers rights you would in Europe (4 weeks holiday etc) [example](http://i.imgur.com/HWcfcAE.png)
Yep you are right, it's a way more declarative approach that makes it harder to get into that kind of problems. I think the whole 'separation of concerns' was something needed back them because of what people were doing with inline scripting and inline styling, we had no good resources to deal with it back them, so separation was good for sanity. But now we have ways to be more efficient with less separation. With these 'enhanced' attributes we can connect the DOM in a better and clearer way with the javascript. If you keep researching you'll find out the new big thing, that is JSX (used by React and Vue as well). Everything is done in the javascript, even inline styling. It's weird at first but it's actually really smart, since you're actually 'extending' dom elements and creating yours. Polymer also has a similar methodology in that regard
I've never heard of this site and the sample size is tiny. React is only ahead in echo chambers? How about the real world chamber? Github stars, github watching, devtools users, real companies, big sites. Go to Monster.com and search for "ReactJS" or "React Javascript" - 1,000+ results (max it will show). Now search for "VueJS" (16 results) or "Vue Javascript" 69 results. I mean, it doesn't get any clearer than that. It's no contest. Sites using React: * Facebook (Partially) * Instagram (Completely) * Khan Academy (Partially) * Codecademy (Partially) * New York Times (Partially) * Yahoo Mail (Completely) * Dropbox’s new photo and video gallery app Carousel (Completely) * WhatsApp Web 
Heh, 69 *^^^^I ^^^^am ^^^^a ^^^^bot, ^^^^bleep ^^^^bloop.* *^^^^I ^^^^am ^^^^still ^^^^in ^^^^development, ^^^^PM ^^^^me ^^^^if ^^^^you ^^^^have ^^^^any ^^^^concerns*
Great feedback thanks!
Hence the "(shouldn't)." While I get the goal of the AOT compiler, I'm not familiar with it. I did look into it, and it seems to be an unfortunate limitation in Angular's `ngc`. I'm practiced with TypeScript, however, which doesn't have this limitation for the aforementioned reason. [It seems I'm not the only one thinking this](https://github.com/angular/angular/issues/11700). I wonder though, because all of TypeScript's additional features are optional (in `tsc`), where does `ngc` draw the line? Can you simply type your constructs as `any`?
You can use.bind to do currying in ES5 and later: http://kishorelive.com/2012/02/06/currying-in-javascript-using-bind/
I could care less about JS frameworks, but you didn't bother to look at the numbers for sample size. The site samples 10 million of the top sites, excluding random experiment projects and other small potatoes. None of your examples compare to that. Github doesnt correlate to production, otherwise "freeCodeCamp" students would have built the entire internet. Obviously some companies use React, otherwise nobody would have heard of it, but its not in a position of dominance. It will probably have a life cycle similar to Angular 1 where the sites being built with it now will have to be maintained for a few years.
blink twice if you learned react and just have no idea how better angular 2 is, because you can't just be bothered to learn it
Thank you, initially I was inspired exactly by the first work. proceduralgeneration - year, I know, this port is copied from there.
They think people who belong to a racial/gender group all think similarly. So if you want different viewpoints, get people from every group. I personally don't agree with this, but I think it's what it ultimately comes down to.
As someone starting to write a new application, trying to get started using marko, looking through your web site and documentation, is very confusing to me. Here is a random list of things that I seem to stumple on: * Try marko - Well, no. You can't really. It is really just a demo. You can't create a new project and add files and try new stuff. All you can do is look at the examples and perhaps tweak a couple of things. If you want to try marko you have to install it. * Installing marko - Ok, so I am confused just looking at the first examples. If this was a normal view library like vue, I could just add a script from a cdn and try stuff out in the browser. But here I have to first install marko, create a couple of files, use lasso(?) apparently to compile it, and then I get a static file I can launch in my browser? So it's more like a template engine than a view library? * The marko starter project uses some kind of routing system? Something specially coded for the starter project? Does marko include a router like vue-router or react-router? How does it work? Magic? Is it important. The point is, it throws me off of what I am trying to achieve. I end up trying to figure out how you build it instead of trying to actually make stuff. A simpler starter would be preferable to me. * Then there are examples with using express, koa or hapi. I kind of like hapi. The example uses marko as a view engine for hapi. Do I need lasso here? Why not? Would client side routing work? I am guessing no? - I don't see any client side routing components for marko? If no client side routing exists, wouldn't it be simpler to just show an example of creating a SPA-like application without routing? Or maybe I should look at marko more like a templating engine with the possibility of some client side rendering? * The marko-starter project builds a static web site in the cache folder? Is this right? When I run the build command I just seem to get a bunch of junk in the static folder. Nothing that looks like html, css or js? What server do I need to serve these files on? Can I serve the static folder from any static web server? How does the build command work? Where is the result? In my experience, the simpler the boilerplate is, the less questions that I run into, the faster I will be able to get up and running and see something working. Something like vue-cli with the simple templates for easy prototyping would be nice for me.
Just published the first version of my CLI - [Northwest](https://github.com/rohan-deshpande/northwest) which allows you to easily make [NW.js](http://nwjs.io) desktop apps with the JavaScript boilerplate of your choice. As far as I'm aware it's the first CLI to cater for NW.js in this fashion. I still have a bunch of work to do, putting up some examples is one, but it is working satisfactorily now. In case you're not aware, NW.js (originally node-webkit) was the the first runtime to enabled the creation of JavaScript apps for desktop. While electron might be the front runner these days, NW.js has, for some time, offered one critical feature which Electron does not - source code protection. Previously this was looked at with caution as it would degrade the performance of protected code by something like 30%. HOWEVER! This week the NW.js team announced that this performance impact has been [greatly reduced](https://nwjs.io/blog/js-src-protect-perf/). So, until Electron answers the numerous requests for this feature, NW.js is the only tool you can use to get better source code protection for your JavaScript app out of the box. Have a go at the CLI, any feedback/suggestions/issues are welcome!
Nice! This inspired me to write an example of how to use generator functions in order to transform a collection in a single iteration while preserving a functional-style syntax: https://gist.github.com/tweinfeld/f2a25378beebe727bbb99967b09ccf8f
I agree with the verb and noun distinction for functions and variables respectively but was not something I actively thought about. Thanks for the reminder.
lol I'm sorry but monster.com and a few big name sites does not compare with the 10 mil sample size of OPs article. No doubt React is one of the major players, but it's not ahead in terms of deployed sites. 
For what level? Junior or Mid? Sounds low for a senior dev in SF.
Your observations are correct that I am not using ESLint or running tests currently, both of which I am implementing right now. Thank you for your recommendations and good reminders!
Mid level in my experience. Junior knock off 20k, senior tack on 20k-100k. 
Conventions are only as useful as they are enforced/followed. And if I was on your team I'd find it tedious, I'd argue against it. Differentiating between functions and variables is pretty obvious anyway just in the way they are used.
It's CSS issue. Your img elements are not centered inside slides. Original Slick rule: .slick-slide img { display: block; } Your new rule: .slick-slide img { display: block; margin: 0 auto; } You can move around buttons too with proper CSS change. 
Unless you have an extremely high amount of traffic on the site there is no reason to not use something newer to help you up skill at the same time. You're familiar with react and that would serve your job beautifully, you can also try vue.js or do it in a2 if you wanted to learn new frameworks. If file size is an issue vue.js can do for you pretty much the same as react, for much cheaper resources. They also use templates or render functions so you can use what you are familiar with. Polyfills for now and native es6 is the future and es6 solves most of the problems solved by jquery. You can also create a utils library as you go for future use, organise it in es6 and you can benefit from tree shaking if you destructure your imports. So if you can build es6 code but have to use a generator, then do so. If you can set yourself up without one, then make a boilerplate and fork it for each client. Makes managing updates easy, solve once apply over all. Getting familiar with Webpack means that you can utilize things like the library generator, Hot Module Replacement, etc. If you must use a server connection for local dev, check out http proxy Middleware, for custom setups, and Webpack dev server has a proxy object that you can use to redirect your calls to the server. Also Webpack 2 has amazing documentation compared to its predecessor, and I would start with looking at the page migration from 1.x to 2.x if you have ever used Webpack before. Edit: to address your lawnmower theory, yes it is completely overkill IF you are importing everything and not just the parts you need. The knowledge you gain doing things the more difficult way at first will buy you time over many iterations as you create reusable pieces of code. Edit2: considering that it's a single page, you can create all of the html and Css even before you have to get to a choice of js, evaluate the time you have remaining after you do the html and Css, then decide if you want to spend a few extra hours to set everything up on react, which in my opinion is a better choice to set yourself up as higher quality to your clients, which will in turn create the opportunity to find better clients and more interesting work in the future. Time is always a factor but using the best of your skills at every point is what will set you apart from the rest of the freelancing world. 
yes exactly! that is a great example. I would really like to use this idea for another application. Any tips on how to make it?
I agree. Proper coding starts with basic principles like this. You can inherently deduce the logic applied by the names of the functions and variables.
I really hate the UPPERCASE_UNDERSCORED constants. What is wrong with simply using *const camelCase*?
You very rarely chain an iterator method after `reduce`, but it's quite common to have `reduce` at the end of an iterator method chain, despite the fact that performance-wise it would be better to do all the work inside the `reduce`, because usually it's nicer to look at and follow and have stuff be reusable. Really it depends on what the higher priority is for your specific use case, but I guess with this library you get the best of both worlds?
You can by multiplying velocities/etc. by the elapsed time every frame. However, this makes your game nondeterministic and bugs with collision, etc. are common. Consider using a fixed frame rate for your game logic but interpolating between those frames to render.
Yes and people on reddit can talk about it however they like. I simply gave my reasoning for not being interested anymore since I felt cheated. They can do with that whatever they like, and you can comment on it however you like :)
If its really easy, just use vanilla JS. No framework needed. update: link to learn more about http://vanilla-js.com/
Sorry I should have been more clear in the post. I'm using Webpack in combination with Babel to transpile React code into plain JS that the browser can understand. Fastest way to start way to get started would probably be [create react app](https://github.com/facebookincubator/create-react-app#quick-overview).
So that's like making 40-50k in the rest of the country?
const was only added in ES6. What were supposed to do before then? It's possible the practice/convention came from bash shell scripting.
I think they should have APIs. What framework should I learn within js to accomplish this?
I would have a huge issue with it. I work in a Rails shop as one of the few pure frontend developers and I find underscores all over. It's frustrating because the language itself (Javascript) has a pattern that's been used since the beginning of its creation and people coming from other languages are trying to upend it. The argument is that people use snake_case in the other language (Ruby), so they don't want to have to contextually switch to another language. My problem with this argument is that you already have to contextually switch from Ruby to Javascript/Coffeescript/Typescript, CSS/Sass/LESS, HTML, and anything else, why not use the correct variable format? This goes along with CSS. It's an agreed upon standard to write CSS with dashes, where class names and IDs are dash-cased. It's pretty standard that you don't use underscores, so why would you argue *for* using underscores if that's your position? With that being said, a personal project is something you control, so if you have a process that you like you can do whatever you want. If you decided to open that project up to outside support you should simply create a developer doc that describes the syntax so that other developers can adhere to it. The problem you'll run into is third party utilities will use camelCase while you use snake_case, so you'll inevitably get a mixture and your code will start looking random.
I don't have a dog in this fight, because I'm indifferent about either style. But in terms of coding efficiency, isn't it faster to camelCase rather than to add an underscore after each word? Seems like more work that Frederick Taylor would disapprove. 🙂
That's a pretty simple job for a competent JavaScript person. It's not discrete movement from one state to another pixel by pixel, it's 15 imagemap polygons with hover and click events. Any decent web developer ought to be able to hook you up for a couple of hundred bucks/hours work.
I've tried several different ways to classify functions/methods over the years, and your list of verbs intrigues me. Would you mind expanding that to a fuller list, with descriptions where appropriate? Also, I'm with /u/farfromunique in not being clear regarding the "should" verb. Does shouldX *cause* X to happen, *advise* that X is going to happen, or check for a request for X to happen? To compare, here's three different uses of "should" in English: * "You *should* put on the top shelf now." &gt; "Okay, I'll try that now." (caller is making request) * "When *should* you be going?" &gt; "I *should* be leaving in 5 minutes." (caller is seeking information) * "*Should* I clear the table for you?" &gt; "Yes, please clear the table." (caller is checking for a request) Perhaps a fuller list of the verbs you tend to use would make that clar.
I can't give you a conclusive answer, but some thoughts: - The JS world is pretty well standardized on camelCase. - If other projects interface with your project, eg if your project is a library, then sticking with what's common (camelCase) is an easy way to improve ease of use. - Just like indentation distances and code style, everybody used to a different way will have a knee-jerk reaction of "that doesn't feel right". That doesn't mean it's not right, that's just human nature, people get over it. On a semi-related note, I find that some of camelCase's nastiest edge cases are smoothed over by allowing capitalization to solely serve concatenation rather than English grammar - so, not capitalizing abbreviations. `innerHtml` not `innerHTML`, `innerHtmlLength` not `innerHTMLLength`, `idList` not `IDList`, etc.
so instead of checking pixel by pixel, you've got these mini triangles each with their own hover and click events associated with them? 
It's actually around 90 (25 if you just wanted to cover the colored sections only though) and a "competent JavaScript person" would still use the continuous function to make a discrete version as it's way easier and dynamically flexible. Not that I think they actually want a discrete version more than continous anyways. Couple hundred bucks for a themed selection widget? I need to change gigs...
im just thinking about the implementation of this. create a canvas create a triangle object lol fucking...??? profit. like how am I then going to tell the html code that I have a triangle (will this work with any shape?) and I only want it to set off some other piece of code when the mouse either hovers (or clicks on, or whatever) the triangle? 
That's what's in the example, yes.
You don't need canvas. You can do it with imagemaps which go way back to HTML 2 or whatever. Just define polygons. Imagemaps are there to make irregularly-shaped links so the click stuff is built in.
ah, never heard of imagemaps before. So define the imagemaps, and then can use things like click and hover on a polygon and it'll work no matter what the shape huh? cool beans! :-) 
from a math perspective I would think that resizing it wouldn't change anything, but perhaps I'm full of it. Thank you very much for the reply! 
Well in the old days an image was an image and a pixel was a pixel. Now that screen resolutions don't match pixels and images can be constrained to a max- or a min-width, I'd want to do some testing, that's all.
&gt; However, i want to also add a command that will allow me to end the For loop completely. You can use [break](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/break).
If you end up doing this suggestion, read the Factorio blog entries on the subject, they're great.
You should check if the textToSave value is empty. ``` textToSave = textToSave ? textToSave : 'predeterminedName'; // rest of program ```
&gt; find...annoying...personal opinion For what it's worth, I find that using capitalization as a word boundary can get annoying when you have lots of short (1-2 letter) words, and/or have words/acronyms that normally have special capitalization on their own. Which is an issue for some projects and not others. When it's not an issue, camelCase is nice in that it's shorter, so there's less visual clutter to go through to find meaning.
You could, for example, use refs and bind all your events manually: &lt;template&gt; &lt;div&gt;&lt;button ref="submitter"&gt;submit!&lt;/button&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { mounted() { this.$nextTick(() =&gt; this.$refs.submitter.addEventListener('click', this.submit)); }, methods: { submit() {} } } &lt;/script&gt; But then what about this? &lt;template&gt; &lt;div&gt; &lt;button v-if="flag" ref="submitter"&gt;submit!&lt;/button&gt; &lt;button v-else ref="canceler"&gt;cancel!&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; Now depending on the state of `flag`, either of those elements might not exist when your component is rendered, so you couldn't bind events to them. You'd have to manually watch `flag` and when it changes state, bind events to the new elements that just got created.
What's an example of handling them gracefully?
Nope, sorry.
num = parseInt(message.substring('floofCount '.length)) + 1; or...break;
Is something supposed to happen when we click?
Your loop runs immediately, setting up lots of delayed messages to be sent over time. The entire loop is finished before any message gets sent. Because of that, a `break` (which can normally end loops prematurely) will not really work since the loop is done long before anyone can ask the bot to stop. You probably want a recursive helper function that will: * Check if the counter has been reached, or someone has asked the bot to stop (and if so, stop) * Send a message with the next number * Invoke itself again via setTimeout There are some other things as well: * Just save the number you are counting to instead of parsing it over and over * You cannot meaningfully return a value from within `setTimeout` # (101 &lt;= parseInt(message.substring("floofCount ".length))) will let the bot count up to 9999100, but I'm guessing your goal was up to 100? Just get rid of most of the spaces, or better, compare with the target you've already saved.
In case the element persists? Yeah good point. That makes doing it this way even more complex.
I don't think `shouldX` is that confusing from a code perspective, even if the English examples have different meanings. The English examples don't necessarily translate to code that makes sense, only the third example there really maps to what would be written in code.
Nice job, but is there a reason to call `clearTimeout` when the timeout is already triggered? Also, I think the delays between each message will end up growing at this rate, while the original intention was to have 1500 ms between each one (since now you are waiting for each timeout to go off before setting the next).
I really doubt that just because someone is white that they will problem solve the exact same way as I do. Doesn't matter. The whole diversity talk is annoying and disruptive. Back in middle school (the award winning diverse school) I remember there was an auditorium day and they told us how diverse our school was. We, the kids, were confused. So what? This is normal to us, we don't care about the diversity of our school. They pretty much opened a door to racism and exposed us to the idea of it. In a way we kind of just said "so what?" and turned around and continued to be "diverse". I don't really understand the obsession with it to be honest. Sorry if that comes off as incorrect. 
But functions _are_ variables. I learnt not to be pedantic about variable naming in general. Junior devs will construct large pieces of difficult code where every variable's name spells out its role in detail. Senior devs compose simple pieces of code, where each particular concept appears only once, foregoing the need to disambiguate siblings. Variables aren't names, or nouns, they're pronouns. The key is to write better paragraphs.
On the clearTimeout, it's just habit. It doesn't really hurt performance-wise or maintenance wise to include it, and code like this is 100% likely to eventually need a queueing system (think if a user starts a count while a count is already in progress) - it just saves time spent typing for when that code is introduced. As for the 1500 quantifier, I wondered about that but asked myself why the OP didn't just set it to 1500 in the first place, so my official answer for why I left it in: that's just there for demonstration that the interval can be computed with a function. Something I've learned over time, is that it's good practice to abstract functions as parameters for behaviour-controlling settings like durations / intervals, because it gives any outside context the ability to modify behaviours based on inner contexts in a pure manner. When slotted in as a piece of a larger system, these abstractions tend to be very useful in the efforts to reduce boilerplate and state management. In fact I would probably compute the stop condition as well with a function version of maxCount, but figured the abstraction there wouldn't be as easy to understand for OP
Hey, you might want to check out my [uni project](https://github.com/setlxjs) from last year. It is not entirely dogmatic (transforms source AST directly into JavaScript, no AST to AST transforming). [Docs](http://setlxjs.github.io/docs/) are in German unfortunately. If you are interested I can elaborate more on this :)
When a majority have been open for over 4 months, absolutely.
It was a "not only that, but.." kind of comment so don't get yer knickers in a twist, ok?
I don't get it. Are you or are you not retiring jQuery from your toolbox? :-)
Use jquery if it's your first choice. There's nothing wrong with it. If you decide you need the lifecycle methods provided by react, then use React. I have noticed that after using React, and Vue i have been structuring my jQuery code differently. If it was me, I would probably just use jQuery, flexslider and animate.css. This is based off 1 page, with a couple slideshows and animations. 
You can put tables in the console: Just structure your data the the correct way, and do console.table(myData); https://developer.mozilla.org/en-US/docs/Web/API/Console/table If you're going to third party apis, and want to stay with "pure" JavaScript, look into fetch: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch You shouldn't need much more than that! 
[This](https://github.com/maierfelix/mini-js) is a small self-hosted (written in it's own language) compiler, providing a minimal JavaScript language with two features on top (enums and pass-by-reference) in only 1k lines of code. [This](https://github.com/maierfelix/toy-compiler) one is a extended version of the first compiler and includes classes and a simple pre-processor. A more complex example is [this](https://github.com/maierfelix/hevia-compiler) project, a [Swift](https://developer.apple.com/swift/)-like language compiling into JavaScript and non-garbage collected plain C89. It's main features are type inference, custom operators, classes and Swift's inout keyword.
Maybe phrase it like that then, so you don't sound like you're trying to tell me something I'm already perfectly aware of. 
For parsing, check out nearley on npm.
Thank you so much! I've just got the dots added to the page. They're currently overlapping the images. I think the relevant code is: .slick-dots li button { font-size: 0; line-height: 0; display: block; width: 20px; height: 20px; padding: 5px; cursor: pointer; color: transparent; border: 0; outline: none; background: transparent; } I'm not sure which bit of code to adjust to prevent the dots overlapping the image. I thought it was the padding, but that's only increasing the distance between the dots themselves. With something like this, what the the variable called I'd need to modify?
Cool project! I'll poke around a bit :)
First thing i'd do is getting rid of Jquery. It then becomes a pretty easy thing to do: http://codepen.io/drcmda/pen/zZLJdp You have many of UI components libs to choose from. I'm using [ants Popconfirm](https://ant.design/components/popconfirm/) here.
I just took over the front end responsibilities on a large .net MVC based project. Using plenty of jQuery with no plans to change. Why would we? This is true of a great many projects out there, btw.
I don't know what would make React a harvester in that situation, a small view layer that enables components? It's smaller than jquery, would result in less code, less complexion, has larger support for ready-to-use components you can drop in, and it would break up the thing into maintainable and reusable pieces. I'd alias to preact or inferno in the end and the weight of the whole thing comes down to what, 5kb? Of course Jquery is passé, what would it actually gain you? 
Are you implying the OP isn't competent? Not decent? 
Because they're used to it? I wouldn't know.
Nice code, I was going to be lazy and skip the canvas for the demo but this is like 80% of the whole shebang. I think your U and W are flipped though, moving horizontally on the bottom W stays constant while U changes.
Also, it's not just a question of idiom, it demonstrates a fundamental misunderstanding of how the language works. Functions *are* variables since they can be used first class in JS.
```users.find().each()``` returns a promise (which allows you to call its .then method). The ```.each``` call matches your intuition -- it will provide each user to the provided call back function, as well as functions for closing/pausing/resuming the stream. 
Except that we've been there bdfore (at least some of us). JSX is just to JavaScript what *Faces was to Java, trying to pull everything we're not that comfortable with into our realm of comfort, despite all the kicking and screaming. There are obvious benefits for projects made today but in time as the world moves on drawbacks prevail. Being religious about technology is pointless, there are more churches than faithful, and cycles are hella short. Angular and Vue are making more future proof bets. 
Just choose a style guide and stick to it for all your personal projects. Even if you don't like some aspects of it, the point is to be consistent. I generally use the Airbnb style guide. When working on other projects, stick to their existing style. IMO you should stick to camelCase. It's the standard for Javascript. Functions are variables, so you can't differentiate between the two lime that. 
I am currently doing the same thing: I defined my own language, and am now writing a transpiler to convert it to JavaScript code. Honestly, looking at other transpilers, and most answers about the topic, usually made me feel pretty lost, so I decided to take a learning-by-doing path, and write everything myself from ground up. For example, many guides/people will tell you to use parser generators (like peg.js), but the whole goal for me is to learn and understand what's going on, so I prefer to write my own parser and actually understand how it works! Also, I find the process of discovering that kind of stuff very satisfying. It may be different for you, and you might have much more starting knowledge about this topic or CS generally than I do, but that's how I feel about the whole thing. Here are a few tips/thoughts from my experience so far, whether they help you or not: **Your language** * Write a language specification, try to do it as formally as possible. Read other language specifications to get an idea of what belongs in there. I looked at the Java Languages Specification a lot, but there are others out there too. * Think about what type system you want to use, before anything else. Take a look at type inference, that can be a pretty cool feature IMO ;) * Start small! The first time I started this project (I am not at my first iteration ;)), I defined a language that had already several types, with lists, and functions, loops and conditionals. It was too much... start with a few basic types (like int and bool, and floating point numbers) and few language constructs. You can always extend it later! * Think everything through, even the most basic things, like how is whitespace handled, what chars are allowed in identifiers, what is the range of allowed integers (like, if "int" means "32-bit signed two's-complement integers", that entails a range of -2147483648 to 2147483647)? * Don't overcomplicate. You want some list/array type? Maybe stay away from JavaScript-like arrays, because they are also an Object, and have A LOT of ways to be used, A LOT of methods and stuff. That is complicated. Maybe aim for some lower level list types like in functional programming languages, where they have a head and a tail. * Scopes: when a variable is declared, in what scope? How are different scopes handled etc. **The transpiler** * First comes a lexer or tokenizer. That is relatively easy. Makes a token list out of the source code string. * Then comes a parser, which is more interesting already. The parser takes the token list and builds an abstract syntax tree (AST). A tip, I first tried to find a way to parse expressions with infix operators myself, through trial and error, but didn't manage to do it. There's the "shunting yard algorithm" that takes care of that, it's on Wikipedia ;). * You then have to do "name resolution" or however it is called. You can enrich your AST with "symbol tables" on nodes that define a scope (like a code block/function code block). When a variable is declared, it has to be registered in such a table - depending on how you defined that in your language specification of course - and when a variable is used in a statement/expression, you have to look up whether it was declared already. * After that comes type checking, I haven't found that very complicated so far, but I haven't implemented much of it yet. * I think you can do name resolution and type checking on the same traversal of the AST. You start type checking at the root and travel down. When you encounter a declaration, you register the identifier (so you travel back up the tree until you find a symbol table), then continue type checking from where you were. When a variable is used, you try to resolve it (so you travel up to symbol tables again). But I'm currently not that far along in my project so that is just my thoughts about it. After that, usually there would be optimization, but I don't plan on doing much of that for now, so I haven't thought much about it. In the end, your AST is ready and checked. Type errors, non-declared variables, variables used without a value would have been found, so you are ready to generate code. So you need to traverse the tree again, and generate the matching JS code. I have not looked into that at all so far, but I think it shouldn't be super complicated... *** All in all, if you are really doing that for learning purposes, don't take people to seriously when they tell you what to do/use or not do/use, so that the language/transpiler is "optimal", "efficient", "practical", "useful", etc. I don't think you are really trying to develop the next big programming language. Of course a hand written compiler done for learning purposes will not be able to compete with others... so what?
Don't forget to look into web assembly standard 
One of these days I will try again and tackle webpack. I tried recently and got frustrated probably because like a lot of things I have to unlearn what I'm used to. Time constraints also didn't help so hopefully soon I can give it another go.
Making programming languages is fun! [This tutorial](http://lisperator.net/pltut/) might be exactly what you are looking for, and it is just excellent. You will be writing a language that you will lex, parse, interpret, and finally compile to JS.
Man you really need some actual drama IRL... 
Got you covered: [Data Structures and Algorithms](https://github.com/Developer-Y/cs-video-courses#data-structures-and-algorithms)
The webassembly docs are great to get a taste of (more or less) high level assembly and it's general design. However the starting point should be focusing on parsing and AST transformations and then digging deeper step by step.