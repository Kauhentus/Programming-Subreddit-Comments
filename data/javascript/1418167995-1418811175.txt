I'm working through it right now. I completely agree, this is a great resource. I love that the code segments are executable in the HTML version, and popping open your browser's console helps me satisfy my curiosity about the many curious corners of JavaScript.
https://www.youtube.com/watch?v=0xx_dkv9DEY is a talk Paul Irish did about performance issues like this. Its really good for understanding how to use tools available in your browsers for understanding how your site is being loaded and rendered. 
Start with eloquent.
ok sorry yes my description is a little vague. Im often told this by colleagues. The object 'ret' is a bunch of DOM elements. These are returned to a php file as $GET, if 'Token" isnt set he wont get written to the DOM. That part works fine. So I loop through the ret object and push these to an array 'stsrt'. I want to ignore the property however if it is not present in the DOM. Yes the 'Token=' part is necessary Im rebuilding a query string t ocheck a hash eventually, sorry for my poor explanation and execution ( im learning and this is a hobby not job). Ideally i guess Id loop through the $GET response and pull all the fileds from there but Im not there yet and im more interested in getting javascript to work cheers 
I'm just making a point here of how unbelievably bad NPM is from a security POV: you can't even download a package and inspect it before running the code contained in it. On my system npm is aliases to "sudo -c dev npm" but who does that?
Seems good, this will be my next JS book. Went though "Expert JavaScript" by Mark E. Daggett. Not basic, but explains good practices &amp; touches on ES6 at times. 2nd half is all over the place, IOT, etc.
You can; there are [many ES6 polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#ecmascript-6-harmony) available. Most of ES6 seems more stabilized, &amp; IE12 (beta) native coverage is 70% or so.
JavaScript Allonge: https://leanpub.com/javascript-allonge/read Easily my favourite JS book, having read a few of the more popular ones.
I like "The Good Parts" because it's fairly short and to the point, but it only tells part of the story. It's important to read other books to balance out Crockford's fairly heavy agenda in TGP.
If you have some programming experience, it shouldn't be over your head. It wouldn't hurt to start it and, if you don't understand something, come here and ask. I always learn more from resources that might be a bit over my head than those that are dumbed down for me.
That's fair enough I suppose. I came at TGP as someone graduating CS who had a week to learn JS before starting my first web dev job, so I appreciated the brevity and opinionated nature of it. By contrast, I read W(P)GtR in first year just for the sake of it and enjoyed the rather lackadaisical approach to conveying information. I still think the world could use a "Javascript for Programmers" resource that gets right into the meat of what distinguishes JS from other languages and what features have analogues elsewhere.
&gt; I very rarely see anyone talk about MariaDB https://www.google.com/search?q=google+mariadb&amp;ie=utf-8&amp;oe=utf-8 (But yea, hard to keep up on ALL the interwebs news)
I recently published an [isomorphic React / Flux demo](https://github.com/chadpaulson/react-isomorphic-video-game-search). I am currently working toward another demo that will use different React libraries / components and, hopefully, an isomorphic Flux solution that rehydrates the stores directly.
if i change '==' to '!==' or '===', nothing works anymore&gt;? any ideas? Yea, about eval will definately read and watch that video, as even my text editor (brackets) says - 'eval is evil'. 
Nice, I really enjoyed these examples. Up until now I felt proxies were just fancy getter/setters
&gt; Both teams are still attempting to adhere to the ECMAScript standards, so at the end of the day they won't be significantly different. They will run the same language. That is fine. The problem is when the core built-in libraries diverge. &gt; We're used to fractured systems where some features only work on some browsers, this won't be significantly different. It is still a huge PITA. 
Did you get chapter 15 to work? Was stuck on it today. 
I'm usually the guy pushing this book. Glad to see someone else recommend it. Also check out [JavaScript spressore](https://leanpub.com/javascript-spessore/read) by the same author.
With a little bit of programming experience, I really like "Professional Javascript for Web Developers (3rd ed.)" by Nicholas C. Zakas.
In the throes of a mid-life crisis, after years owning/managing restaurants, I dived into 2.5 years of tech school, studying lots of C++ and Java and a bit of SQL and Web Dev, all of which I took very seriously. One month from getting my associate's degree I answered a school job board internship posting from a startup doing enterprise customer/data/product management web apps. I've been there for 8 months, and I'm getting the upgrade to junior dev with very good salary come January 1st. Work your butt off. I damaged my health, no lie, what with a full-time job and 40+ hours/week studying. You don't have to go quite that hard, but there isn't really any subsitute for hard work. Study, study, study. Do it for fun, but be really serious about it. Studying those "real" programming languages really helped me, but so did the Web Dev stuff: mixing hard C-family logic with a deep tour of HTML5/CSS3 was almost the perfect thing for me. And it's tough to over-state the importance of SQL. DB is everything, it sometimes seems. Happy now, loving life. Good luck! 
legend x-skeww, thanks. im yet to get it to work, but i think ill be able to figure it out with that.
Sounds interesting, but I'd like to see a demo.
I like the Types "baby step". I've heard from someone at a Meetup that TS's types have saved him hours of testing.
Haha the last time I commented on this about the definitive guide I got downvoted so much. Glad to see it did better this time around :)
http://ampersandjs.com/ Use like a framework or pick and choose each npm module as required. Is a 'spiritual successor' to backbone and has incorporated all the good bits and many of the lessons other libraries have solved or tried to solve by extending backbone.
I've used Intro.js [successfully](http://tombyrer.github.io/jsperf-tutorial/).
Generators are their whole own ballpark, but everything else is simple enough. Except maybe proxies, too
For every one of us who learn the language in depth there's a couple dozen who don't. Just because I can code jsfuck by hand doesn't mean I should. Unless you are capable of maintaining the entire codebase on your own, you need to limit yourself to the maintainable parts. Crockford may be too stringent in some areas, but I can't argue that adhering to his standards has enabled the average programmers I've worked with to get things done faster and with fewer bugs. Unless you can offer compelling evidence to the contrary, I'll continue to learn the idiosyncrasies of JavaScript, but stick to the good parts for production code. 
Don't forget [Learning JavaScript Design Patterns](http://addyosmani.com/resources/essentialjsdesignpatterns/book/). It is a nice lead-in for Design Patterns, and inspires you to want to read the Gang of Four material!
Interesting question, it's different for every project. Flux, to me, is a conceptual idea and folder structure, similar to MVC. It's implementation feels like the wild-west. I use React-Router in most projects. One of the more interesting patterns I used was having Immutable.js inside the store.
I'm kinda liking this site better than the old one. The old one just felt like one of those websites that's old and never maintained. I think this one. 
Effective JavaScript is also one of the best books on JS out.
Well, the way typeof now is weird. It makes sense if you look at it but at the same time there's no reason why it should be that. typeof should let you know the type of things, so, regexps should be regexp and null should be null and arrays should be arrays. However, I do agree that JS:TGP isn't really that great a book, particularly as an introduction to the language.
I am using Flux for my project. After using Angular extensively for the past year, Flux is easy to work with.
Fair call, but just like *any* open source tool, you can check out the code before you run it: $ npm info flattenify repository.url Or, if you're just interested in what scripts will be run: $ npm info flattenify scripts **edit** *[flattenify](http://npmjs.org/package/flattenify)* is a module I published.
Any reason you wouldn't just set the prototype as the object itself? If you're doing inheritance then obviously that's a different story, but in your example the prototype object is just empty anyways. Why not override it?
Agree. If it ends up with a stable 'enterprise' version from Joyent and a bleeding edge io.js with rolling releases that's fine by me. This has worked well for Linux. 
Yar, +1 for Effective Javascript. Plus, dherman is a great guy.
I'm not sure that just mixing any of those frameworks you've listed into your existing jQuery code is going to be smooth by any means. jQuery is a very different paradigm that focuses on DOM manipulation. Those frameworks all focus on having a JavaScript model that your markup gets bound to. I usually tell people to avoid using jQuery unless you're creating some extension point because you've exhausted all options within the chosen framework. That being said, I think you need to do some googling on the whole MVC/MVVM stuff. How a framework determines changes in the model is pretty much independent of the architecture pattern. As for environments, I think it's a mixed bag. I use Visual Studio because I frequently write C# as well. I've also heard good things about [WebStorm](https://www.jetbrains.com/webstorm/).
This is what I love so much about Typescript. As Soon as I start talking about it people always roll their eyes and think "oh great another coffeescript/dart/etc whatever" but it's not. It's just javascript with types, interfaces, proper intellisense, and the code it outputs is clean and perfectly readable. I'll never go back to writing JS without it.
seems interesting ... will be following it ...
Doesn't appear to support sorting packages by popularity (ie. downloads), date updated, etc. Is such a feature in the works?
You're right. I've added a comparison section to the readme.
You're welcome. I hope you find it useful.
Curious how you found that. Ross is a good friend of mine.
I am used to doing this sort of thing :)
A caddy tries to help you save any more bytes if possible. You create a gist and I have a look at it and try to create a smaller version or one with more functionality. Nice one. It is actually 110 bytes. I don't see any bytes that could be spared. It wouldn't be cheating to accept c and e as actual arguments (maybe we should change the order), so we can lose the "return" statement and include recursion.
Seems like their deploy cycle is pretty long. Found an issue with their styling that was fixed 12 hours as of now, but the fix hasn't been deployed yet. Kind of disappointing.
That's the case, it implements only minimum set of features to match Promise/A+ 1.1 Spec. You can be sure it works correctly, cause it passes 872 test from A+ test suit. Also p0 is the fastest implementation https://pbs.twimg.com/media/BnLftd9IYAABLLS.png. So you can just take it, forget about all the promises stuff and concentrate on implementing API you like or you need for you project. It could be ES6 Promises, could be something like rsvp or bluebird.
Pronouns only work reliably if you establish some kind of context first. It's not clear who (or what) you're referring to. I also recommend to use the [gender-neutral they/their](http://en.wikipedia.org/wiki/Singular_they) to refer to other users of unknown sex.
JavaScript: The good parts -Douglas Crockford Start here if you ever want to work in a team.
No. Why? I'm not kangax. I even have my GitHub username in the flair.
Sung to Extreme's "More Than Words": Saying "plz help me" is not the words I want to hear from you It's not that I can't be helping you, but I can't see it through so first of all, can you tell me what your problem is more than worse, the next thing that I miss is all the code that I need to reproduce what's your problem 'cause I would need to know What would you do if nobody answered you would you think we're not involved or your problem can't be solved what would you say if we took your post away more than worse: you'd write it new only saying "help me" too Now that I have tried to talk to you and make you reason that all you have to do is try to find the spot where things go bad comment things out, think it through and va-li-date your code more than worse is that your question shows you did not google nor read any document on the matter to reach your very end What would you do if nobody answered you more than worse I think you'd feel that we don't take you for real what would you say if we took your post away though I guess you'd write it new only saying "help me" too 
It interrupts the prototype chain. This isn't a problem in many cases, but sometimes you may want to preserve the prototype (for inheritance). E.g: function Foo() {} Foo.prototype = Object.create(Bar.prototype); extend(Foo.prototype, { // ... }); EDIT: Good catch.
The Egghead videos are great for introduction!
I actually prefer knockout, even though it doesn't seem to be what is fashionable right now. Knockout is quite "simple" and self-contained and since it's more of a library instead of a framework it's possible to just use it in smaller parts of your application instead of going "all the way" which angular etc forces you to do (Though I still recommend going all the way with it.) Learning how to use it is quite simple, you can be up and running and writing application code very fast. Knockout is quite stable and works well, and it doesn't have a major "we're going to rewrite every single thing in version 2.0 and change all api's" on the horizon (looking at you angular). It's also much more composable than the "one framework to rule them all". Knockout is just a data-binding mvvm library, it doesn't contain anything else. This means that you're more free to compose it together with other libraries that do one thing and one thing well. If you choose angular you're stuck with angular all the way. This is of course both a pro and a con. But I find it quite liberating to have the freedom to choose. Of course, all of your choices are good libraries/frameworks and you're most likely going to be happy whatever you choose. Going from the "All the dom manipulations!"-jquery to the "don't touch the dom ffs!"-mvc/mvvm frameworks is imho a fantastic experience.
Why would anyone ever run an obfuscated Greasemonkey script?
Does anyone here want to recommend some of these, or share some experiences? A list of 40 closely related libraries isn't much of an article or blog post. It's just neatly formatted google search results. The other articles on that site are similar. "25 Best jQuery Notification plugins", Really 25? Couldn't someone go through there are find the good ones and write about them. That would be information, and not just raw data. 
Thank you very much! Will try to finish up all this now. You know any other "calculator like" projects i could do, to keep learning JS?
Hey guys, I'm the author of inscribe.js. Happy to take any questions. :)
To evade virus detection ?
Github: https://github.com/jonroig/armyofjon
I Googled for an example the other day for someone. Don't remember exactly what it was I searched for.
It actually would be quite annoying to use P0 as the base for an ES6 Promise replacement. It would be faster and cleaner to rewrite from scratch. In it's current state you would have to override the contructor to make it match Promise(&lt;function&gt;(&lt;resolve&gt;,&lt;reject&gt;)) and delete the prototype properties P0.prototype.fulfill and P0.prototype.reject, plus add all the missing API methods. I assume the benchmark is in Node? P0 is going to be pretty slow in the browser since you are using setTimeout. It needs to include or allow the use of a setImmediate polyfill to be fast in the browser. Something like this https://github.com/YuzuJS/setImmediate
Am I the only one who actually finds ES native query and aggregations API simple to use out of the box?
52 different web apps written in many different languages? (Just have a look at [their public github](https://github.com/hailocab?page=1) for a taste of the madness that ensues.) This is the sort of thing you do when you've never had to support a service, it is absolutely unmaintainable and unscalable. I'm not saying to build monolithic applications, either - but don't make extra work for yourself by breaking things into unnecessarily distinct pieces. If your team needs to know 12 different tech stacks just to keep things running, you're setting yourself up for failure from the start.
Do you want a new report? Write your own, scumbag.
Um... what?
Right that's what I was alluding to. Also you'd want to extend Foo.prototype instead of Bar.prototype.
I vote for chart.js
I think at the very least, there is a substantial learning curve. I would never argue that they're not powerful, I just think they're overkill for a lot of situations. Having a familiar feeling way to write filters for a lot of devs, specifically non CS ones who may not be used to the AST like structure of ES queries, has value. It's not a replacement, just a quicker way to do already simple queries.
This comes at a great time for me... I've just been exploring different libraries. Great list.
Everyone talks about this book, but i didn't like it. I think Crockford is great, but the book didn't do much for me. The railroad diagrams at the beginning are miserable. And the Eloquent Javascript book does a better job of explaining the OO and Functional etc for me anyways.
I doubt the author actually tried all 40. Jfreechart is not even a JavaScript library. It's Java
I would not bet anything that was 100% free; I'd prefer to have support available when needed, &amp; would want them to have income flow so they can keep devolving. But their price structure is very generous IMHO.
A smaller list for graphs, with commit details: http://anvaka.github.io/graph-drawing-libraries/#/all
Could you recommend is the best resource to learn it? Besides applying to the real task, of course.
I guess? I like how comprehensive the documentation is for ElasticSearch, but I fee like unless you already know the name of the filter or aggregation you want to use, it's difficult to figure out exactly what you want to be using.
Consider X-posting to /r/elasticsearch 
I've tried like 10 of them. My humble opinion: * I'd use chartjs for everyday jobs (simple, small and has a decent amount of different charts) * I would learn d3 if I have the time or need very specific graphs * Plus: If you are using ruby chartkick http://ankane.github.io/chartkick rocks (also has a js version). I use it when I have to chart of research result data quickly and efficiently. It lets you use Google Charts or Highcharts for the charts. When you are looking for a graph library sometimes the look and feel is as important as the format the data must be entered. Even if you write the API/app that generates the data having to format it on a weird way (either server or client side) takes more time than anything. Chartkick excels on this subject.
http://mycodde.blogspot.com/2014/12/simple-login-and-sign-up-using-facebook.html
Yeah, not like Reddit with its blue links on a white background.
Will be getting the demo up asap!
`typeof` is not about figuring out the constructor of the object pointed to by the variable. `typeof` is about the ["ECMAScript language and specification types"](http://es5.github.io/#Type). This is why `typeof new Boolean(true) === 'object'`, `typeof new String('') === 'object'`, and `typeof new Number(0) === 'object'`. What you want is some sort of conflation between `typeof` and `instanceof`. `Array`, `RegExp`, and `Date` can all be checked with `instanceof`. Additionally, they all inherit from `Object` (and ultimately `null`). Are you suggesting that everything that inherits from `Object` get a custom string from `typeof`? TL;DR: "Type" in JavaScript is not the same as "type" in other languages. If you learn about JavaScript instead of only the things that an opinionated author thinks are good, you won't get tripped up.
I think you missed my point. I understand what typeof is doing and why it is doing it. I'm saying it would be nice if typeof would be doing something else or we need a better way of checking for actual types (beyond doing `Object.prototype.toString.call(...)`).
have a look at https://www.npmjs.com/private-npm
Sinopia
Oh, so private modules are coming.
I think the short answer is simplicity. "Classes" in JavaScript are kind of unsightly in many contexts and don't really give you any crazy useful benefits. That being said, I think part of it is functional style as well. JavaScript looks pretty cool when you use it functionally and the configuration pattern you've described somewhat goes with the flow that you see a lot in Node development. 
One reason to use the module pattern (or Immediately Invoking Function Expressions specifically) is to avoid polluting the global scope. If you're using new, you have to have defined a constructor, and since you wouldn't want that constructor to pollute the global scope, you're going to use an IIFE (or namespacing on the global scope). If you're using an IIFE anyways, the module pattern follows naturally.
Another reason to use the module pattern over new is that new creates an instance of an object and applies some references to it, and you may not need that. You may simply want to take an existing instance and modify it in a uniform way, making the creation of a new instance unnecessary overhead.
I was referring to OP. My bad, I'll keep it gender neutral next time.
That for-in loop does iterate over an object's properties though. I actually just copy-pasted that piece of code. I only renamed "ret" to "o".
I was just stating that his ret variable is an array not an object. So in his code he's getting ret[ret[I]].
Woops in his/her code.
"ret" is the object with the "Token" property. "stsrt" is the array.
We started with just react because we already had a self-made framework in place. After a few weeks we moved most of it to React, and added flux (fluxxor specifically)... React saved my site. Development is so much faster and easier to understand. 
To the other answers I would add: IIFEs are added to memory when the script runs. So in that respect, your namespace architecture is present at "runtime". (AMDs being somewhat of a limited exception to this, but only partly). By using "new" instances, there is not the same way to ensure that everything that you need to exist in your namespacing / architecture will be there when it's needed /called. So either you have to be very careful and do a lot of checking throughout your code (and never being sure where things are going to instantiate), or you have to (as vproman said) use some kind of IIFE around it anyway. But that's not to say that there aren't good reasons to use object constructors. One very good case is if you are doing an animation and need to create x number of sprites that all have common properties and methods. Another is certain types of plugin architectures (there are some good jQuery plugin patterns for example that instantiate themselves using the object constructor). But note that these cases are both for objects that are instantiated *during runtime as a benefit*. Hope that helps.
I have used Highcharts quite a bit and it was really simple to use and very customisable with a lot of community support
What about file size and supported browser versions?
is the id=Token div in the html file or created after load? If created via js; document.getElementById will not being able to find it unless you use insertBefore or some such. If it is in the html, I'm at a loss as to why it can't be found.
Looks like link is missing? https://github.com/af/JSnoX This is a great idea and reminds me of http://emmet.io/ where you also expand CSS selector into a corresponding markup.
To run example use instruction from https://github.com/angular/angular#hello-world-example. From Brad's Green "Coll things in the World of Angular" - https://docs.google.com/presentation/d/1m8WiXodW-Wz78DExjG6SzS_e8rY3oE14u9d9VJ_wJN4/mobilepresent?slide=id.p
Yes, thanks :) Not sure how that happened...
Most welcome! 
And yes, the approach is very much inspired by Emmet, Jade, and to some extent jQuery. Mostly though the project exists because creating React element trees is very verbose without JSX, and with the changes in 0.12 (the need for createFactory()), now even moreso.
Sinopia is a good option. It is easy to install and works as a cache for external packages. You can also publish to it and keep your published packages locally, or have them published through to an external registry, whichever you prefer. 
I have a super simple little svg pie chart generator http://www.piely.net/ You send pass in the config over the url like the placeholder image resources do http://www.piely.net/128/4,5,6.svg ideas and suggestions are very welcome
I'm sceptic about the jsx approach, looks bad to me strings without limited by quotes. This approach much more elegant, I like. Congrats did you build it?
It's like JavaScript turd proliferation.
Thanks, and yep, I'm the author. Let me know if you find it useful (or find bugs)!
thanks for linking to this book. I'm currently reading the part about closures. Although I've understood it enough to use it somewhat practically, this has clarified it at a much lower and fundamentally useful level. By far the best explanation of closures I've read to date!
Without meaning to sound too intrusive, I was wondering what your job is like and how you implement d3? A career path involving data visualization and manipulation sounds very interesting to me.
I could have licked it... If it was in javascript. Edit : wait, is it written in ecmascript6, or in some other language that compiles to js? The file extension is in .js, but I thought angular 2.0 was going to be in AtScript.
It... Just... It just seems like an enormous amount of bullshit for "Hello World". Don't get me wrong. This is not a slam on Angular 2.0. Or Angular 1.0... I *like* the idea of an MVC framework for javascript. I've been playing around with a few (Backbone, Ember, Angular, a few others). Also, I was all set to embrace Angular and really get into it... and then the whole blowup with the Angular 2.0 happened... Now I'm skittish about investing my time learning it. And I've read many articles about people complaining about there being "too many" js frameworks that change too rapidly... I guess I am saying that I would personally be happier if there was one common, widely adopted, easy to use yet powerful js framework. I don't think I am alone here. Maybe this is the wrong place for this. Sorry.
I'd quibble about *"Dependency loading is async"* -- the page locking issue is an optimization, not a point about code organization and maintainability, and it's potentially better solved in other ways (including scripts at the end of `&lt;body&gt;`, for instance). Furthermore, it sounds like the author isn't using `r.js` to bundle and optimize their code (at which point the dependency loading would no longer be asynchronous), which is a must if you're using RequireJS. Personally I prefer Browserify over RequireJS, but using either tool is a significant step over none at all. Good article! We ran into these issues at my company a couple years ago and implemented many of the same fixes, and have been reaping the rewards ever since.
there's an authentication within the script. it's a "proprietary" script persay. so they don't want people to be able to figure out what it is. but it's slightly broken so this is my attempt to try and fix it. no plans to remove the auth or anything, just want to debug it.
I love this idea... I'm very turned off by JSX. Question: I see you reference "react-hyperscript" in your README. I looked at that project and it seems to be very similar to yours... are there any differences? (I haven't used either yet so I'm just going from a quick glance of both of your README files). Thanks!
The projects are definitely similar, but there are a few differences worth noting: * JSnoX's string-parsing function is memoized, which in my [unscientific benchmark](https://gist.github.com/af/15e6e605e5036059ba7b) gave about a 15% speed improvement. It makes sense to cache these results since with React render() can be called often. To be fair, react-hyperscript could add that pretty easily :) * support for attributes (I [asked](https://github.com/mlmorg/react-hyperscript/issues/5) about this before starting this project, but didn't get a response so I decided to try my own approach. * shorthand for the "type" attribute (eg. 'input:checkbox' =&gt; '&lt;input type="checkbox"&gt;') * react-hyperscript parses [hyperscript](https://github.com/dominictarr/hyperscript), which AFAIK has multiple implementations. I don't know if compatibility with other hyperscript implementations is a priority for that project, but if so it couldn't add other syntax like the above
Yep use this, it can proxy the main npm registry so I doubt need to mirror the entire thing, has a security model, supports private publication, supports scoping (though either it or npm had bugs with the scoping)
Yeah I agree. Maybe its because I have learned so many languages that are just useless now. Actionscript, Coldfusion, Actionscript 2, Actionscript 3, Flex, and on and on and on. I like angular.js. I just feel hesitant because I can just write the damn app in html/jquery/php/MySQL so quick, why do I want to re-invent the wheel (again)? Ahh but I digress. Job security and all that. 
It is TypeScript with decorators, which compiles into JS.
React.js looks much more appealing all of a sudden.
Yes and no, can you prove that you have the skills (for example, by projects you've worked on) you could get a job. But you probably won't get passed the guy that is checking your resume. If you have contacts, and people can help you get in contact with the recruiter, and you have the skill, sure. But you're probably better of having an actual degree. I quit my job as a developer a few months ago because I wanted to get a degree first. 
Awesome, thanks!
Looks promising, especially with 0.12 support. :) Are there any plans to implement an optional compilation step? Mithril does this IIRC by emits an inline virtual dom structure.
Here you go: http://wiki.jetbrains.net/intellij/Developing_and_running_a_Java_EE_Hello_World_application
You may want to have a look at [Mithril](http://lhorie.github.io/mithril/). It is a tiny, but complete MV* framework. The API is small and consistent, and it performs well. Be sure to read the [blog](http://lhorie.github.io/mithril-blog/) as well for hands on advice on how to best use it.
Hello World is not a strong example of Angular 2.0's benefits. This kind of example is merely a starting point for learning the new syntax and how, when introduced with the simplest of tasks (a Hello World app), that syntax might look. It's not a competition to beat out Javascript or jQuery or React.js at Hello World apps. I will agree the new syntax is looking even more ridiculous than before, but luckily I don't use Angular myself so I don't need to explain or even worry about why that is. :)
Quick note, Java is not related to JavaScript, so don't ever indicate that to a potential employer. Also, you might have better luck in /r/seattle or /r/java. Seattle is generally C#, it being Microsoft's backyard. That being said, it's not too hard to transition from Java to C# if you want to adopt a more "in demand" skill in Seattle, and want to stick to the same language type. Alternatively, Amazon *is* moving in, so Java may come back to Seattle, but they really want you to have some Java wiz-skill and a Computer Science degree. 
I see, will your pay increase dramatically once you have a degree? what is the main motivation for leaving current job?
I don't know what I'm looking at. This looks confusing as fuck. 
To be fair that page includes IDE setup, server with web service, front end submit form, build xml and others. I think this would be equivalent to adding gulp, webstorm setup, nodejs server, etc. If you just compare the front end code Java EE is almost _easier_ to read. Hell, the fact that we're even comparing Java EE to Angular 2.0 is sad. 
gotcha- thank you!
I'm not sure of that, but I'd assume so. It also gives me more time to go in depth into other areas, like cryptography. My main motivation was that I already had everything set to get a degree before I got the job. I hesitated a bit, but I chose for the degree, as I have more chances to get a well paid job afterwards.
AngularJS 2.0 looks very overengineered…
This is actually more than a simple hello world. This is essentially 3 hello worlds one for each type of component in Angular 2.0. A hello world example really doesn't need a service and the decorator component. Realize that Angular2.0 is still in development. The target audience for this hello world is experienced Angular developers. In which case this example is not confusing and is well documented.
/r/lolangular
Yeah.... Ha... Coldfusion... I never got into Silverlight, but I know a lot of people who did and are kinda pissed about it... Sigh.... It would be nice... If there was a good MVC pattern that used simply javascript... Maybe with some jQuery. Those two are going nowhere...
It depends what you want out of a module. Many modules are essentially singletons, as in you only ever have one instance for the whole application. In other cases the module exports what is essentially a factory function. This works just as well as exporting a constructor. I'm always confused as to which is the best approach. That's the thing with JS. So many different ways to achieve the same thing.
Fixed. Thanks for the tip :)
Agree, a Hello World is not very good for comparison but more of a way to introduce the syntax. You don't see the true power Angular until you work out a medium to large single page app. Even the To-do app is kind of too simple for what I would use Angular for, compared to other frameworks - but still better. Otherwise it just gets silly. For instance, this my Hello World example of how I would do it the most efficient way: &lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; I call it the "noJS" framework and it beats pretty much all other JS frameworks in simplicity, speed, overhead and code base.
While the type annotations are in the TypeScript style, it's definitely not TypeScript. TypeScript has been extremely slow to add ES6 features, and thanks to the type annotation extensions to Traceur from the Angular team and WebStorm support for them, Traceur is a much nicer option for now. The 'rebranding' to AtScript hasn't really mattered from that perspective. https://docs.google.com/document/d/1uhs-a41dp2z0NLs-QiXYY-rqLGhgjmTf4iwBad2myzY/mobilebasic You can even use async/await with traceur --experimental which is sad since it's C# syntax in an ES7 proposal supported by Traceur way before TypeScript, who kicked it out of their 1.x roadmap. https://github.com/google/traceur-compiler/wiki/LanguageFeatures#async-functions-experimental
I'm not familiar with how Mithril works, could you expand on that or point to an example?
Nice work
Which did you switch to?
It's the official Angular repo, so probably not.
I've been working exclusively with Angular for the past year (due to my job), I'd say I'm pretty good at understanding its code and inner workings. However, this 2.0 demo is beyond a steaming pile of shit. I like to call this phenomenon in programming the "look at how fancy my code is" aka over complicating things needlessly.
Great points. They should add a read.me to the root to make it explicit.
MithrilJS for my personal projects exclusively, I still have to use Angular 1.3.x for work, but my bosses are not too keen on switching to 2.0 (gee I wonder why)
I see :) 
This has none of what made me go with angularjs in the first place. Have fun guys.
Why is it a must? I'd gather that it greatly depends on the application. Huge applications with lots of small pages/components can benefit from async loading these seperately and not bundling everything in a single file.
terribly, horribly false.
&gt; evoked Should be invoked. Not sure why this one thing stuck out to me during my skim...
I have not read much into 2.0 but from quickly looking at the index.js a component is a directive and a class is the controller or a service. I'm a but lost with the export function part. Its going to be a fun jump from 1.3.x to 2.0 
This is just the post to start a fight, I had a simulator post a while back. "Well written code does not need comments" was a point made to me many times. There is a time and place for comments, when you need them you'll know. 
What specifically do you find confusing about it?
You'll always need some comments. However, if you can decide between "clever" + comment or straightforward code without a comment, you should probably just go with the latter. In general, whenever you feel incredible smug about a piece of code you just wrote, take a second look to make sure that it isn't unnecessarily cryptic. Everyone hates "clever" code. Future-you included.
ITT: People who don't understand this is a demonstration of Angular 2.0's proposed features, not how to print 'Hello, world!' on a web page.
The separation of `HelloCmp` and its `@Component` and `GreetingService` and its `@Decorator` feels strange. What advantage does that have over, for example, `class HelloCmp extends Component`?
Mithril uses a custom SweetJS macro to convert calls to the virtual DOM creation method ('m' in this case) to the actual output of the function (an object structure). My explanation may be somewhat lacking, though, so here's the [official description](http://lhorie.github.io/mithril/optimizing-performance.html). All in all, not a necessary feature since JSnoX already uses memoization and other optimizations as you mention below, but 'tis certainly interesting.
But does it support function currying?
Sorry, noJS does not support "functions". It's really, *really* fast though. Don't you like fast?
Google is making this for Google, and they're a big "enterprisey" mess, so making JS more like Java is totally a plausible goal Does no one remember the abomination that is Google's [Closure Library](http://docs.closure-library.googlecode.com/git/index.html)?
Dev cycles &gt; CPU cycles
Brought to you by people who like Java.
Not always.
One of the main problems JSX solves is the syntax of DOM building with JavaScript's existing nested structures, be they function calls, arrays or objects, particularly once you get into deeper nesting situations. Comma management completely disappears and closing parens are replaced with closing tag names which provide [context](https://twitter.com/jbscript/status/540666683523084289/photo/1). Having said that, this looks like a nice module for people who don't want to go there for whatever reason. Hell, I even started porting [domBuilder](https://gist.github.com/insin/7927898) when I was first considering using React, but after having tried JSX for the "5 minutes" they ask for, I never went back to raw JS for DOM building, and am never going back!
This is the first time I've upvoted an "ITT" comment but you're spot on.
You forgot to include vanilla.js
False. Comments are more informative than variable names. Describe what a variable is doing in code comments and not a variable name. Long variable names are a sign of developer incompetence, on one hand, while also making the code challenging to read on the other.
Your code tells *WHAT* you're doing, your comments tells *WHY* you're doing it. *Edit:- Also, worth reading [this](https://github.com/airbnb/javascript#comments).*
Who cares? It web-scales!
Ok, I wouldn't mind this hello world if it weren't for the AtScript. I officially hate that. I would rather register a factory function and pass in a class definition than bother with all that annotation crap. But then, I also tried and rejected TypeScript for the same reason. I like ES6... I liked ES5. Is there some reason we can't just use the language the way it's designed? Why do we seem to have this need to add all this cruft to the language? 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Second-system effect**](https://en.wikipedia.org/wiki/Second-system%20effect): [](#sfw) --- &gt; &gt;The __second-system effect__ (also known as *second-system syndrome*) is the tendency of small, [elegant](https://en.wikipedia.org/wiki/Elegant), and successful systems to have elephantine, feature-laden monstrosities as their successors due to inflated expectations. &gt;The phrase was first used by [Fred Brooks](https://en.wikipedia.org/wiki/Fred_Brooks) in his classic *[The Mythical Man-Month](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)*. It described the jump from a set of simple operating systems on the [IBM 700/7000 series](https://en.wikipedia.org/wiki/IBM_700/7000_series) to [OS/360](https://en.wikipedia.org/wiki/OS/360) on the 360 series. &gt; --- ^Interesting: [^The ^Mythical ^Man-Month](https://en.wikipedia.org/wiki/The_Mythical_Man-Month) ^| [^Sophomore](https://en.wikipedia.org/wiki/Sophomore) ^| [^Publish ^and ^Subscribe ^\(Mac ^OS)](https://en.wikipedia.org/wiki/Publish_and_Subscribe_\(Mac_OS\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmrexbl) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmrexbl)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Those are fair points, and I definitely can see why people do choose to use JSX. The big issue for me is that I hate how JSX completely hijacks your tooling. It's probably less of an issue if you're working with React/JSX all of the time. Re: commas and parens, I think that's a very small issue if you indent properly (making the structure self-evident) and use a good editor that highlights paren/brace pairs for you and lints on the fly.
Don't remind me... I work with it every day. Our javascript application has a 30 minute build time.
Attach an event that fires a callback on the node that is having the markup injected, you can then have the callback attach events to the newly injected elements.
Curious - how many LoC are you at? Are you using the module system?
Can you elaborate on this a little bit more?
Does it have non-blocking IO?
&gt;How do you go about binding your events to the newly injected elements? The simplest option is to just not do that. You can just add a listener to html or body. The events bubble up and you can then check where they came from. If they came from an element you're interested in, you can react to this event. Otherwise, ignore it. It's pretty convenient with jQuery: http://jsfiddle.net/2eyhkywt/ http://api.jquery.com/on/ The events of freshly added elements will bubble up the same way. You can add a 4th button via your browser's dev tools and it will work just fine, too.
I find it confusing that it's not javascript. But I've expected that. So I'm not surprised, just confused.
Thanks for the feedback! I'm the author of the blog entry, and we spent a lot of time evaluating different dependency management solutions. Browserify was on the top of our lists, but in the end we chose require.js because of its built-in shimming support. This allowed our code (as well as 3rd party code) to play nicely in our unit testing environment, which is powered by Karma with Mocha. I believe Browserify supports shimming if you use a 3rd-party plugin, but in the end require.js was easier to work with. We also use jshint, but this blog entry was more focused on dependency management at scale. I would definitely recommend jshint if you're working on a team. I'll look into jscs -- thanks for the tip! Edit: jscs looks awesome!! Thanks, we'll have to add this to CI soon!
If you are expecting the markup injection, you should know where in the markup that the new HTML is being added. So that node can watch for DOM mutation events and execute a callback function when those events happen. The callback can then select nodes in the injected HTML and apply event listeners for whatever it is you want them to do.
&gt;and I said 50℅ Lol. I wouldn't worry too much. A lot of the HR reps don't know too much of the technicals. And most of the time, those doing the hiring just want someone who can quickly catch on. You'll do alright.
I had a hard enough time wrapping my head around AngularJS 1.0. Damn.
Good catch, thanks!!
You want to use CSS for adjusting position. Can try changing the padding of the image.
The pay seems very low. Take the job, study and practise as much as possible! even if you are only there for 2 months it is worth the training you will get. It's a start into a well paying career if you don't give up. Remember that anyone can learn anything. 
A crappy workaround I used in the past was to put a script tag into that piece of HTML which fires an event. Anyhow, for an accordion (tabs, expandable boxes, etc.), you can just output the final HTML and use a generic click listener. Here is an example for tabs: http://jsfiddle.net/x9fu5duz/ An accordion works pretty much the same way.
Not intrusive at all! I work at a company that does a mix of data science, data visualization, and custom internal data tools (like dashboards and customized database frontends) for various companies. Since it's a small team, everyone touches everything in the process. For straight data science type things where people come to us with a list of questions and a ton of data, it's mostly the usual bar, line, pie style charts to be included in the findings. When it's for internal tools we can have more fun since they tend to work with a specific type of data and so we can be creative on how to best show things for their specific needs. My favorite involved exploring the delta of a myriad of chains by going "forward" along the Z access. Start with the 4 possible initial pieces of a chain, and everytime you go forward they split as they become unique. It's more involved, but it as at least alot of fun to think up. Then we have an open source graph visualization library/tool (not graph as in chart, but graph as in graph theory) called Alchemy.js . It's open source so client work comes first, but when we have time we work on it. The goal being that it's supposed to be configuration only (though you can use callbacks in the config, so it can get pretty complex if you want to go there), so it's easy to just plug in data and get something out instead of having to learn a whole library and build something yourself. This uses D3 but as it's gone forward we've found ourselves wanting to implement more and more of it ourselves, and at this point we are using it more as a jquery alternative than anything, haha. D3 is used in pretty much all of those things, though charts.js makes occasional mock up appearances and if it's for showing results for some analysis it's not uncommon to just do it in with Python or R libs since we're working with the data in there anyway. I should really look up if there are any good stats/math libraries for JS. If not it'd be alot of fun to work on one. Anyway, sorry for the rambling. Hope that helped. :)
I work as a frontend developer in Seattle. As part of my job I perform technical interviews. I don't disregard people without degrees at all, but you do have to prove yourself. You can get an "entry level" position and work hard to prove yourself. The codewords for that position in the frontend world are "email developer" and "production assistant." These jobs are fairly plentiful if you keep an eye out. Just yesterday Oracle listed this: http://www.indeed.com/m/viewjob?jk=12e1dc94b93963bf&amp;from=serp just, whatever you do don't conflate Java with JavaScript at that interview.
If I asked a junior-level candidate how much javascript he/she knew and they gave me a percentage I'd have a hard time not laughing over it. I think OP would do better to identify concepts that he/she has familiarity with absent any hands-on experience.
Applying to the real task is how I really learned it, since it's such an idiosyncratic api design. Everything is built in a similar way so you sort of just need to use it enough that you can almost guess how something would be. That being said I remember really early on the free tutorials on egghead.io were nice because they were at the right pace for me. https://egghead.io/lessons/d3-get-started-with-d3 is the first one. They have paid ones too which I'm sure are great, I just never used them. http://bost.ocks.org/mike/bar/ &lt;-- that is a 3 part "Let's Make a Bar Chart!" tutorial. They start with simple methods and build from there. That was the one that really got me to start thinking in a d3 way. Do the whole thing and type it out by hand. One of my coworkers got a ton out of this book: http://alignedleft.com/work/d3-book , but I honestly just sort of flipped through his copy so I can only go on his recommendation. Other than that it was just playing with it. Our CEO is currently working on the [Treehouse] (https://teamtreehouse.com/) d3 lessons, so I'm sure those will be good but I have no idea when those will be done. Most importantly though, is that Mike Bostock (the creator of d3) is so insanely involved with the community and has hundreds of examples up with full code and often explanations. Check this: https://github.com/mbostock/d3/wiki/Gallery ... All those examples? Click one. It has all the data and the code for them! The number of these things are simply astounding, and no matter how custom you are getting with your visualization, I guarantee that somewhere on there is an example that is similar to what you want to do. Hope that helps! If you ever have any questions, feel free to pm me too...I love helping with stuff like that :)
That's actually their tagline.
Like scope? Do you know why that's no longer necessary?
The pay is laughable, especially in NYC. However, if you don't have another job and no prospects on the horizon, it's probably a good thing to do if you really want to get into the field. If they say they're willing to teach, they probably mean it and you should take every advantage of what they're willing to provide. But you should stop lying to them. Be honest about what you do and don't know. Honesty will get you further than trying to fake it.
You are getting paid peanuts - so I am sure they will be pretty flexible with you. Just take notes when people talk to you and remember what you hear. Go to the meetings and pay attention. Come in early and stay late if you can. Right now you are using them as a learning tool. Just stick with it, though. Pick up some books like Javascript the good parts. Learn about ES6 - classes and promises especially. Learn about closures and how to structure code to compose functionality. Every bit of effort you put into this, though, will pay off in the end. In 6 months - you will move on to a real job making decent money with the experience you've gained. Things to learn: * GIT - learn it love it. If they use SVN or Perforce or something you will just have to roll with it but Google is your friend. * SCRUM - learn to estimate how long it will take to do a task - stick to it - burn down your time on your tickets * UNIT TEST - Get into Jasmine or some other testing frameworks for unit tests. They are easy to write and read like english * SPY -- with unit tests look up creating spys for testing services * REST - learn everything you can about using rest APIs Good luck - stick with it - you will rule
In my humble opinion, **naming** things is actually one of the hardest aspects of programming with others. When you write code, you see it in the context of the big picture. When someone else reads your code, they don't have that same context- and so it's easy to assume a different meaning from only a name, unless you expect your peers to spend hours pouring through every line of code in your project.
Data management - except that the app receives an initial dump of the state of the system (its a distributed system), and a flow of changes to objects in real time, and must represent those changes in real time in the DOM. Also, I wanted it to be an SPA for better flow between areas of the app, so you could jump from any page to almost any other page instantly. Currently have 27MB of data held in the test system inside the db. Data arrives async via web sockets and gets jammed in the DB. Inserts with indexes are about 100 per ms, including JSON conversion. Batches of inserts then flow their changes to other objects in the DB, then to the DOM. 
I agree that giving a numerical answer to a straight question like that would be funny, but I think OP should not be worried. I've been asked "On a scale from 1-10 how well you know JavaScript?" multiple times in interviews. It's always followed up with an invitation to explain why. I think it's a useful question because in a field as broad as this, usually the more you learn, the more you realize how much you don't know. If an entry level applicant told me 8-10, I'd be worried. If they say 5 and then explain how much they've learned but also about all of the areas they've uncovered that are a mystery to them still, now I'd see an applicant who understands how big of a field web dev/comp sci/software engineering is. I've been building stuff for the web for 20 years and I'd still say I know JavaScript as a 6 or a 7. :)
&gt; I'm a but lost with the export function part. It's their module system. I believe AtScript will default to ES6 modules (import export etc) first. They said in their original unveiling demo that they thing web standards are going to be where they need to be in a year. Good luck with that... 
* How big will it grow? Check the business model and expectations * How fast will it grow? * Are you doing standard stuff? i.e. HTTP GET? * Do you need push notifications, vast scalability, 3d graphics, offline mode, 10k+ DOM elements, phonegap, CEF, etc? * Can you shard it? * What's the required delivery timeframe? * How much VC do you have? * What's the risk tolerance of the organization? * How much control do you have over the project? * What kind of recruiting will you do? * What geographical area are you in? * Does the problem domain lend itself to relational, graph, or document databases? * How many programmers will you need eventually? * What community of programmers will you hire from? * How long will the programmers work on the project? Are they invested long-term employees? Or will this be contractors or outsourced to India, or a throw-away app? And the #1 concern: what is there already? If there is anything of any value at all, start with that and build it out. 
My experience is that you should use an IIFE for a singleton/module, and use new when you're going to create many. Of course, I seem to notice an aversion to using new, which I think is part of the reason that people go with factory functions inside an IIFE. You can also establish a class closure whose scope is available to the objects produced from the factory function... that may or may not be a good idea, but it is made possible/cleaner with IIFE and factory vs. simple new constructor.
The "1-10" scale is more of a rating system rather than quantifying how much javascript a person knows. I agree with what your saying about having a junior-level person tell you they rate themselves an 8 or higher. It would suggest that they aren't yet aware of how much they don't know. &gt;I've been building stuff for the web for 20 years My first reaction to this was "wow, you've been at this a while!". Then it occurred to me that you've only been at it two years longer than myself. I don't think I could give myself above a 6 or 7 either. The way the language has shifted away from being dom-centric to seeing people really take advantage of the language features has really taken off in the last couple of years.
The fact that you have a 2 page explanation of a hello world app doesn't necessarily lend itself to people believing it's more simple.
Probably shouldn't have been named "hello world" then, huh? As developers, we all know hello world apps are simply for printing hello world to the screen, that's all they've ever been.
Awesome, sounds like you are definitely Doing It Right[!](https://www.youtube.com/watch?v=LL-gyhZVvx0) RequireJS is a great solution, and you're right, having no build step during development is a nice perk compared to Browserify. I slightly prefer the synchronous form of CommonJS-style `require()`, but really it's just preference either way.
Good question! The problem with having tons of small components is that what you save on loading only the code you need for a given page tends to get overshadowed by the basic cost of doing a lot of HTTP requests. Every request incurs some level of overhead, and browsers will only execute a handful of requests in parallel ([source](http://stackoverflow.com/a/985704/1188341)). Obviously profiling will tell you the real story, but my base assumption based on experience with some apps of different sizes (a couple dozen files and a couple hundred files) is that bundling is almost always going to be advantageous. There is a case to be made for bundling into a page-specific bundle per page plus one common bundle, which is the approach I would take for a multi-page website like you suggest. With Browserify you can do this using [factor-bundle](https://www.npmjs.com/package/factor-bundle); there's probably a way to do it with `r.js` as well.
This thread has been linked to from elsewhere on reddit. - [/r/FreeCodeCamp] [How to Ask for Help - when programming.](http://np.reddit.com/r/FreeCodeCamp/comments/2oy9ua/how_to_ask_for_help_when_programming/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
If you've got no other options, I'd say take it. Keep looking for a better job (never stop doing this) and move up when you get the opportunity. $10/hour is not fair for anyone, but if it's an entry point to the industry for you, it might be worth it. Remember that everyone starts out not knowing what they're doing, and you basically have to fake it 'till you make it. Work hard and learn on the job, get better, and move on. After one year of working in the industry you should be qualified for at least a junior engineering position at any company making at least $60k/year
Thanks for this resource.
I hope this won't sound harsh, but if you're in the state where you confuse Java with JavaScript, you might still have to teach yourself a bit more before being employable. So yes, it is possible, but you have to show some degree of understanding of the language during an interview. And online courses might not be the best for that. I recommend reading a book, one of the best for beginners is "Professional JavaScript for Web Developers" by Nicholas C. Zakas. Also, being a javascript beginner, you probably won't find a pure-javascript job, chances are you will find a general front end one, where HTML and CSS are required. So play with them too
Javascript alone, no. You'll probably also need fundamental knowledge of HTML and CSS. But if you get to the point that you can make some simple systems with that, you can get your foot in the door at a number of places. The keys in your position are proving that you can learn, flexibility, and curiousity.
Good read. Just started migrating an Angular project to Typescript in lieu of AtScript and eventually ES6. Coming from a Java background, the code in general looks 10x cleaner to write. No more `function` or `prototype` and IntelliJ has really descent type checking... The only thing that is tricky at the moment is dependency definition referencing. `tsd` does a pretty good job at handling all the definition files, but there are some strange gotchas when it comes to two modules using different versions of the same definition. https://github.com/Microsoft/TypeScript/issues/575 Also, one suggestion, `tslint`. For all the stuff TypeScript misses.
*Compresses lots of code into a few complicated lines* "Sweet! I'm a genius!" *Sips coffee. Uses bathroom. Comes back. Sits down and looks at screen.* "What does this even do?"
But two pages really isn't much to describe 3 core features of a UI framework. All frameworks have a higher initial learning curve than a basic library. In return, successful frameworks reduce development times when for larger projects (angular 1 falls in this category for single page apps). What matters is how extensible they are, and how they can be applied to larger projects. In both cases the code for angular 2 looks encouraging. A hello world app for rails or ASP.net mvc would require a similar sized explanation, that doesn't mean they are bad technologies.
oh, so they created backbone? angular 2.0 is now backbone.
imo, atscript will be the death of angular. people don't like that shit. they like javascript.
my thoughts exactly. glad we agree.
Go for it, you won't regret it. Don't worry about your self ranking...I never say less than "8" when they ask my rank. Otherwise, they will just go to next guy. They should be able to ascertain your skill level from a technical screen regardless of what you ranked yourself as. Also, be aware, you may not like it if the demands are unruly. Just get the experience for 6 months and jump ship if that's the case.
you do not need a comment for that. it should be obvious what you're doing...what you do need comments for are complete gibberish algorithms written by first year intern monkeys (or ex-microsoft employees).
exact thing happened to me. Except my boss was telling me to write it that way. He replies with "...now let's see if the architect can decipher that!"
Java???? wtf man.
Yes. Yes it does. 
PRO TIP: they gave you an interview because there wasn't much competition for that pay price. PRO TIP: Fear not as they know 10$/h is a pay for a beginner coder, so be one! PRO TIP: register an account on https://tests4geeks.com/javascript and have the test :) If you need that job, take it, you'll learn by doing and develop skill. If at one point that job seems meaningless, just quit, as you won't lose much. 
Why do they invent this annotation sytax? you could just pass the object to the class directly ... 
It's about time that someone made an enterprisey web framework. /s
Very interesting. Thanks! I'm learning Javascript/frameworks and are having a struggle with it of course )};)(};] (you know! :-) I've decided to use Visual Studio as editor/IDE. It's free to use now and a very nice. I started tutorials on React/Flux since it looks most interesting in terms of what I want to do, but got into trouble with the JSX syntax. I like to be hold by the hand by Visual Studios Intellisense/Web tools right now since I have little experience on Javascript syntax. But VS does not support JSX and I get errors from Intellisense/Web tools. I googled and found out that native JSX support is very requested but not planned in VS at the moment, so I tried compiling JSX into pure Javascript by hand and looked at some other options, but eventually put React on the shelf for now and are looking into Backbone instead. I was a bit annoyed by JSX. I understand the need to express XML/HTML-like stuff more elegant than by nested Javascript functions, but also thought there should be a way to do that in pure Javascript and this seems to be it! Thanks again!
Depends on what the code does. A line like for (var i = 0; i &lt; arr.length; i++) { is rather obvious, while location.search.replace(/([^?&amp;]+)=([^&amp;]*)/g, function(_, key, value) { key &amp;&amp; query[key] = value; }); will probably benefit from a small comment line saying // using regexp to read in query parameters into query object I invite you to have a look at http://140byt.es, where you'll find some snippets of code that a) are rather well written (probably even perfect in the meaning of "you cannot take any byte away") and b) really do need comments for anyone to understand what happens.
Since OP said that English is not his first language, 10$ per hour might not be that little. In Romania, 16$ per hour is considered a very good rate for web stuff. 
Well New York City is not Bucharest and $14/hour is on the low-end of income. A senior developer salary is about $120 grand and this is about $27 grand. I know it's a junior position, but still I think it's too low... although it might grow exponentially afterwards.
My bad, I didn't notice that he is in NYC. In that case my comment is invalid. 
Is this sarcasm? I'm currently building a large application from the ground up and it's been a pleasure to work with so far.
Yeah, I mean I can speak it fine, but it's still my 2nd language and some of the fancy words I just can't seem to pronounce right lol. We'll see what happens, hopefully I'll make it. 
Honestly, I think that is the major reason for angular 2.0. 1.0 has a lot of complex nuances, 2.0 tries to get rid of almost all of them. (DDO's, Controllers, $scope, etc.. All of these things are dieing and mainly because they are somewhat complex and error prone)
Why do you think so? What would you recommend for large apps?
I feel the same with JSX and React. You're not forced to use it, but then it's way too verbose. (Only glanced the docs and tutorials though)
Uglyar ?
It will take at least a year until the first somewhat stable-ish release. The documentation and examples are in flux and there is no polish whatsoever. What you are looking at is some directory with some example which demonstrates way more features that you'd need for the simplest kind of demo application. It's not something that has been published. It's just some directory of some repo. You can only look at it because the development happens in the open. When it gets closer to its release, I'm sure someone will write (and actually publish) a more "classic" Hello World which only showcases a single essential feature.
Agreed, you should never lie about your knowledge as you'll be screwing yourself over in the long run taking a job you are super unqualified for. The pay is laughable but you gotta do what you gotta do to get that real world experience. This will be a stressful couple months but once you get over the hump then update your LinkedIn and portfolio and find a job that will pay you what you're worth (I was fortunate to get a $30/hr entry level job and now getting offers for much more).
I think what you're describing is the actor model. 
could you elaborate? Actors seem to be principally about controlling concurrency - microservices are about breaking an app apart into smaller apps
Well, if I can use angular 2 without atscript I might be happy with it. 
* They know they are hiring an entry level person * They are wanting to hire a person that can learn fast - they want to see what you can learn to do, not what you 'can' do right now * It's part time * The pay rate reflects what they expect - $10/hr for 15hrs a week isn't exactly killing it Take it, and give it a shot. 
This rating seems vulnerable to Dunning-Kruger. Why not just test?
It doesn't fit well in the browser but the actor model is what would essentially be microservies in a webapp. Actors are essentially threads that send messages to each other. So if you think about microservices, they're a cluster of processes that you send messages to from a different application and they respond. You have no access to their internal memory and can only get access to their internal state by way sending a message and getting some sort of response. Actors are the same thing but they run inside your program. They're separate threads that other threads sends messages to. They are a way to do concurrency in a sane way. I have my doubt's that the actor model would translate well to the browser but if you were to translate microservices to the browser I suspect it would look like actors. 
~~It only works on chrome~~? ***It doesn't work at all***
You drop it inside the box
Yep ... just loaded my file in browser window
Yeah, you're right. We can wait for the [todoMVC](http://todomvc.com/) example which might be a little more realistic. 
Ah ok I get it! (just read up a little and am playing atm). It seems very good actually! Nice and modular! Just how I like to build usually, may have to look into ways in which I can use this best
Modules are definitely the way to go for large projects. But completely unnecessary for something small like this :)
What else are you using to build your large application?
Would say no, not a good idea. More important to focus on loose coupling and passed dependencies. Modules as done in browserify is nice and all, but does not prevent novice programmers from writing tightly coupled, untestable code. You don't need microservices to write loosely coupled code.
In my personal experience it doesn't work very well, for several reasons: microservices work via the principle that instead of creating one big app that does everything you use many small apps that all do little. They (usually) communicate via some event or message based system. This is useful for back-end code primarily because it allows for better horizontal scalability. However, the browser is just one machine. It doesn't make sense to write your front-end code such that it can scale better horizontally, since you can't scale horizontally. In modern front-end frameworks like AngularJS it is encouraged to build your application modular: you create a lot of independent components, and you put some of those together to create a page (or view). Most frameworks allow you both to communicate directly with the components (e.g. function calls) and to use an event-based system. If you were to use an event-based system you essentially have created a micro-service architecture for the front-end. However, a micro-service architecture also comes with a cost: you need to coordinate the events/messages from a *global* level. There needs to be contracts on naming conventions, what kind of events/messages you can send, how the data is formatted, etc. In the back-end this is definitely worth it: you often want to be able to have many service react to a single change (e.g. cache update, event logging, recalculations of some data in your system, etc.). In such situations it makes sense that you create a contract such that any component can react to anything that happens on the system independently of other components. However, in the browser you *usually* don't have that much going on. An action usually only needs to update the UI at some place and send data back to the server. This is much more manageable by just using controllers that glue the individual components together. Often you pass data objects around to your (gui) components using controllers, and any non-gui action listens for changes on the data objects. You still have individual components that each do their own thing, but it's not really a micro-service archicture. 
Browserify is just for breaking up your code into multiple files. That has very little to do with your architectural design.
That would be nice also, I guess you can [add it](https://github.com/anvaka/graph-drawing-libraries/tree/master/src/src/scripts) if you happen to look for yourself.
&gt; React reminds me a lot of developing in CF because you can build your components and build up the HTML using those components. Huh. I'll have to check that out. 
I think its because no one good, or even bad, would look at $10/hr jobs. I know people are already driving in the low pay thing, but that is SERIOUSLY low pay for any kind of agency in NYC. For awhile (in NYC) I was interviewing front end developers for a role on a project, and we were looking at freelancers in the ~$90/hr range, and they were all crap. Really great devs can easily get that (and way way more). Once you get a handle on JS, immediately jump ship and go for the ~80,000 range at any of the big digital agencies. They are always hiring.
I really don't put any thought into it. That's why I'm senior level in enterprise-land.
It's harder to use different components that aren't part of the framework. JavaScript frameworks should be agnostic and interchangeable for large apps (all apps?) because we're very fickle, one week this lib is super hot and new, the next week we're on to something else. It can't be too hard to switch parts out. I should be able to bring in the new views, and require the lib to the same identifier on the back end. Or better yet not even change the views. Express, Socket, Passport, etc, are all agnostic on the back end. Edit: Traditional, more popular answer: Putting all that logic in the view is still really messy and has people with different talents working on the same file. 
Would it have been difficult for them to create: Hello World Component, Hello World Decorator, and Hello World Template projects? (Or whatever the demonstration was supposed to show.) Putting all three into one project just makes it overly complex.
Sorry, I should have been more specific - the way Hailo is doing it, with a dozen different tech stacks per OP's article, is terrible. Unless you've got a lot of legacy systems, then I grok why you'd *have* to do it, but otherwise you shouldn't engineer around adding multiple points of failure and having a team that needs to know a dozen different stacks; that's madness.
Have you ever written in TypeScript? Since my company converted to TS I would never go back to that nasty JS.
You're absolutely right!
Right now I'm at a point where in trying to do all that I can with Node and NPM. I' having fun with them so why stop.
Could I see some of your react components? I'm clearly doing something wrong because I just see useless prop passing and messy code.
&gt; a) are rather well written (probably even perfect in the meaning of "you cannot take any byte away") Perfect? That's subjective. Perfect code to me is readable by someone without needing a separate 600 page document to explain what's going on. What those are is a challenge to create the most impressive demonstration with the least amount of characters. Nothing more. Using compression techniques to squeeze every possible operation into 140 bytes is a fun exercise, but it's hardly perfect code to pick up and modify later if needed. &gt; and b) really do need comments for anyone to understand what happens. Which is a really poor programming style. Code is for us. If you want to battle for the smallest most efficient algorithm: that's one thing. But creating code that a Junior can read through and fix or modify is not the goal of this page. I joke with the guys at work that code should be self documenting and that comments are never needed, but absolutes are a bitch. While my code is comment lean, I do throw in comments where I think something might be confusing or non-obvious.
Just because you doing microservices, doesn't mean that you need to have a different technology stack for each one. 
I gave it a serious try, yes. Wrote a whole non-trivial app with it. I did not like it one bit. Not only was the language itself buggy and a little annoying, the compilation to javascript step got real old real fast. 
I haven't had much luck with landscape mode but it's early days. They have plans to allow theming which would take care of the Android issue.
Don't worry about it. Do some reading up, like others have suggested, and you'll be fine. If you don't get the job, you'll still learn lots and be better for the next interview. I know this sounds like a bit of a cop out but it's true. I completely screwed up my first Web development interview, but then I knew what to expect the next few times and aced it. Each time, I thought "I should learn more about node and WordPress and php classes and how JavaScript handles inheritance and... Etc etc. There's so much you can learn that it feels overwhelming. They're not looking for an expert. You know what you know, just go in and show them that. It's all you can do. Point is, don't worry too much. Worst case scenario, you gain experience from the interview. Best case, get a cool job. Good luck.
What was buggy about it? I assume you are not using Visual Studio 2013 then? There you hit save twice and it compiles it to JS, or when you build the project. We use it because of the stronger types you get, try to avoid many as much as you can, the build server then picks up any compiling errors. Saved us alot of bugs and time.
I probably should have added &lt;sarcasm&gt; tags for those who had their sense of humor surgically removed.
I'm not saying that I would, I'm just interested in discussing the idea. Microservices seemed somewhat analogous to N.Zakas Sandbox pattern - and I was keen to explore that.
I'll give you one example. Corporate people who're refusing to move to modern browsers. In that case CPU cycles become really expensive. 
Of course. I was commenting on OP's article, apparently not obviously enough.
Modular design isn't quite the same - all the pieces are still aware of each other in that pattern. But *that* is really commonly used these days - you can even use Node's `require` via Browserify, as mentioned elsewhere in this thread.
It reminds me the [Web intents](http://webintents.org/) which have been abandoned since 2012.
Wow, sounds awesome! Thank you for the detailed reply!
Loving the influx of interest in hybrid mobile apps over the past couple of years! I'll be playing around with this one
Actually most of the people use raw JavaScript and not CoffeeScript, TypeScript etc. You can checkout the dailyjs past surveys for example. Also some popular projects were rewritten from CS to JavaScript for that exact reason (to get more contributors).
If you have been primarily looking at frontend development and they are giving you the opportunity to work on full stack projects I would take it. As others have mentioned the pay is quite low, but the experience is invaluable. Full stack work experience will definitely improve your future income potential. Furthermore, if the only expect 25 hours a week from you, that gives you plenty of time to learn and produce better quality product while demonstrating you will do what it takes to get the job done. Most employers want familiarity with basic programming fundamentals and the desire to learn. Nodejs is a new enough paradigm that they don't expect seasoned JavaScript coders to by applying for a entry level job. 
Sorry, I should have used "most" rather than "some". My point was that these "compile to javascript because we hate javascript for some unfathomable reason" languages keep popping up, so obviously not *everyone* loves javascript. Which is unfathomable to me. It's a fine language for its intended use cases. Is it flawless? No. But what language is?
Why does everyone hate on JSX so much? I'm working with a few designers and they absolutely love working with it since it's close to what they're used to.
Ah, that makes sense. I don't have any plans on using precompilation like that myself, but if others were interested in building that, the library could certainly accommodate it.
That's true, but breaking your application up into modules still has nothing to do with any *architectural* design pattern like a micro-service architecture. It's still one big application when you *just* break it up into files.
[Me right now](http://i.imgur.com/axJmn.gif).
I applaud you taking the time to learn the low-level stuff. It'll be a lot harder at first, but down the road you'll feel a lot less lost and be capable of a lot more. That being said, this is definitely a work in progress. I'm not going to try to give you a complete code review (honestly just because I'm lazy and not very helpful, sorry), but here are a few things you can work on. If you fix them and come back, I can give you more tips. - You need better variable and function names. Names should communicate meaning with no context other than the scope they exist in. For example, you have a variable named "selected". Selected what? "is selected" or "the thing that is selected"? You explain in a comment (which is great, much better than never explaining), but better would be to give it a name like "currentSlide" or "currentSlideIndex", making the comment unnecessary. Be specific first, concise second. - JavaScript has booleans, so you can use `true` and `false` instead of `"true"` and `"false"`. Though I think it's cool that you came up with a perfectly adequate substitute. - Using variable naming conventions will help make your code more regular, readable, and (sometimes) meaningful. JavaScript's convention is to always use camelCase (first letter lower, subsequent words capitalized) for variables that can change, UPPER_CASE (all uppercase, underscores separate words) for variables that should never change, and TitleCase (first letter of each word capitalized, no underscores) for classes (functions that you call with `new`). You don't currently have any classes in your code, but you do use a native one, `Image`. - Your data structure is awkward. The two `Array`s need to be in sync, so it would be much better if there were a relationship between them. I suggest replacing them with a single array of objects, where each object specifies both the URL and the caption, like so: `var slides = [{image: 'url1', caption: 'text1'}, {image: 'url2', caption: 'text2'}];`. - Paste your code into [jshint](http://jshint.com/), it'll catch a few mistakes like missing `var` statements. JSHint is a linter, a program that parses your code and tells you about things that are probably mistakes but which aren't technically errors (it also tells you about actual syntax errors, but you don't have any). JavaScript has the unfortunate design choice that it tries to just guess when it encounters the sorts of things that other languages would call an error. The goal was to make JavaScript easier to learn, but instead it just forced us to right tooling to catch those errors. In the case of your program, most of the not-errors are missing `var` statements, which JavaScript is handling by making them global variables. So it *works*, but it invites naming conflicts were you to try to run this on the same page as something else, and it's slower. One last thing - if you do reply, could you tell me if I'm right in assuming that you're new to programming in general, not just JavaScript? If that's the case, I don't want to waste both of our time explaining concepts that you already know.
Exactly. In fact the title really should be "Five defining features of using RequireJS".
I've been working with keystonejs for last year (same people / company). If this tuend out as good as that I'll be impressed.
since (excluding web workers but there are limits what they can do) you are always single threaded in the browser *architecturally* you are limited to having a single application with a single thread so the closest you can get to a micro-service type design is modules that if done well can be quite independent of each other.
Just a nitpicky thing: `id` names should be lower-case.
`Foo.prototype = Object.create(Bar.prototype)` creates the inheritance, `extend` modifies the object in place. So no, it doesn't break the inheritance.
This isn't going to be very cohesive, and is basically a stream of consciousness: * The fact that you are worried about misrepresenting your skills to this employer is, in itself, an indicator that you will be fine. Don't waste time feeling guilty that you may have misrepresented yourself. You understand where your short comings are, and that's half the battle. Armed with the knowledge of where you can improve, you can sure-up your knowledge in those areas and, in turn, be more productive. * Use the engineers you will be working with as a resource. The company said they want someone coachable, they understand you don't have everything they need and they're willing to invest their resources to turn you into a valuable resource for them. Use that to your advantage. Soak up knowledge from the other engineers, and the existing codebases. * Don't be afraid to ask questions and don't be afraid to say you don't know something. Nothing is more frustrating than trying to teach someone that refuses to tell you what they don't know. * The pay is incredibly low, for just about any region of the USA, and especially for NYC - one of the most expensive cities in the country to live in. The company knows this, they're not stupid. They're taking a risk hiring you with minimal experience and knowledge, and they're mitigating the risk by paying you such a low salary. Use every opportunity they give you to your advantage, because ultimately they are paying *you* to learn. The experience you'll get in 6 months, alone, will be more valuable than what some students pay $20k/semester, or *more*, for. * Their bar for success is not set very high. At $10/hour, if you could take 10 hours of low-level work, per week, off their other engineers you'll more than pay for yourself. * If you really are a fast learner, you will be able to use this experience as a spring board in ~6 months to either a) a higher salary at the same company, with all the things that come with it or b) a higher salary at a different company. Either way, you win. The only trick is that you have to make a conscious effort to bust your ass, get work done, and improve yourself. * finally, work hard. so many people these days are afraid of hard work. Go above and beyond, go the extra mile, all that. Do your damnedest to over-deliver. Yes you're getting paid peanuts, but that's more than not being paid at all. If this was the only opportunity you were able to take - your choices were effectively: get paid to learn and better myself, or don't get paid at all. Put 100% of your effort into this job, don't be lazy just because the pay isn't what you want. Do everything you can to learn everything you can, earn a good recommendation, and use the knowledge and relationships you acquire to improve your position. Good luck
But that's not really true: using browserify in now way tells you what design pattern to use. E.g. with (or without) browserify I can create a modular application using small components that communicate over a shared event bus (= similar to micro-service architecture), or I can create an MVC based architecture, or I can use it to specify my components that I use with a DI framework, or I can use it to create on big clusterfuck of spaghetti code, or I can implement any other design pattern I like. Browserify does not in any way whatsoever even hint to any design pattern. It's really nothing more than providing dependency management (and that's a good thing!). To put it in perspective, the functionality that Browserify offers to JavaScript is pretty much the same as that the (built-in) import statement does in Java/C/C++/C#. But just like the import statement does not in anyway enforce a design pattern, Browserify (fortunately) does not do that either. 
It's pretty polarizing– I can see why some people love it, but it's not for everyone. Anecdotally, I've noticed quite a few people who shrug React off because they think they need to use JSX.
Looks to be free *web* access to the contents, the ebook needs to be purchased...Though please correct me if I'm wrong, if I can get a free version on my Nexus 7, I'd take it.
&gt; Great and simple breakdown. But one point caught my attention — "whatever is left of the dot at call-time". Seems pretty self-explanatory. For foo.bar(), this would refer to foo; for foo.bar.baz(), this would refer to foo.bar, and so on. But what about something like (f = foo.bar)()? After all, it seems that "whatever is left of the dot at call time" is foo.bar. Would that make this refer to foo? No, it wouldn't because you're not **calling** it at that point. Your example of `(f = foo.bar)()` is equivalent to: f = foo.bar; f(); &gt; The keyword "this" refers to whatever is left of the dot **at call-time**.
I see- thank you for the advice :) I'll be sure to be clear about the JavaScript also! 
Hi osvaldas, please read reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. In short, you should post from a variety of sources. **Consider this your only warning.** Continued posting of a single source will force us to take action. Thanks for your understanding.
You're right; poor choice of wording on my part. Unlimited free online access.
You get better tooling with AtScript/TypeScript/Dart/etc, which means there is actually a lot less you have to remember.
Relatively new to coding. Less than a year. I am more used to coding Ruby and Python than I am C similar languages like JS. I do have a tendency to not follow naming conventions and adding var to place scope. I used to be better about it but I have been going through so many code tutorials lately that don't I think I'm picking up bad habits. As far as where I am at with JS (and honestly a lot of coding in general), it's that odd middle ground where I am starting to need to learn the advanced concepts. Things like Anonymous functions still kind of boggle my mind. Or like the fact that I have to store setInterval as a variable even though it looks like a callable function. 
Composer is like package manager for php. For ex. You need to deliver good email service so you go to composer package lost, search for your interesed script, in this example its email sending and you will find many packages which provides email sending. Then you just include this package where ever you want to use it, load it into variable and here you go, mailing system ready.
One possible solution is [ES6 Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) (in the event handler for the first user action create a promise that resolves once the new markup is loaded, attach the event handler in the 'then' clause), but they are not yet supported by IE or older versions of other browsers. (jQuery also supports promises via deferred objects). Another is to trigger custom events, which I have done with jQuery, but I am not sure how easy it would be to do without. Looking back I think promises/deferreds are the better solution than custom events, but it's a newer pattern than events so might require some getting used to. 
PFL
Why are you asking here? /r/php
A lot of good stuff here. Watched it twice!
I know about 5% my self, but I think the good parts are all you need ;)
I find that writing components that are somewhat messy is okay as long as your data layer is clean. Are you working with some version of the Flux architecture? If not, you should look into integrating one of the available libraries into your application. Personally I'm using a custom built declarative library for wiring data into components; I can link it to you, but I wouldn't recommend using it in a production application because the documentation is next to non-existent.
Not javascript, but a lot of game development tends to take on a lot of the same design idioms. There's a good collection of them here : http://gameprogrammingpatterns.com/ and the web version is free. I recommend starting with the basics: http://gameprogrammingpatterns.com/game-loop.html 
Thank you! That looks promising. I will look into it. 
Of course I can't find it right now, but one of the Angular devs (I want to say Misko) explicitly said once that Angular isn't for large &amp; complex apps. I believe it had to do with the change detection not scaling well past a certain point, but I could be wrong. Damn I wish I could find that quote...
Vertext is right here, it is a PHP package manager. In Javascript, checkout bower
As others have said, you are going to have to pick up more than JavaScript. Learn as much as you can about the field (and specializations [ex: front-end, back-end, mobile app dev, etc]) you want to be in. You got to get a portfolio up, throw some code on github, be active/active lurker in places like stack overflow, webdev related subreddits and even twitter. It's possible to get a dev job without degrees or certs, but it's def hard work to self-teach AND get your foot in the door. [This guy](http://www.reddit.com/r/webdev/comments/2ozb4f/i_just_accepted_my_first_development_position_and/) managed to do it. "Old money" corporations usually are the type to care more about degrees, newer generation companies and startups care about experience. Or you can freelance and start your own thing. Idk about the webdev market in Seattle, but its worth considering looking for a remote position too. Keep practicing, don't be afraid to ask questions, never stop learning.
Awesome, downvotes without explanation. Does someone care to defend requirejs? I'd like to hear it.
Not a big fan of flux to be honest. The crazy amounts of boilerplate reminds me of a 2005 Java app. And i'm not completely sold on the idea of doing away with models in lieu of these amorphous blobs of state called "stores".
I'm looking for a Yeoman + AngularJS with Gulp instead of Grunt... anybody?
thank you! this is super helpful! 
You are right - the number of watchers used to be limited to about 2000 before everything slowed down to a crawl. Back then we had to use the bindonce directive to move around this problem. However, today is much different. Angular also has native one-time binding now but even watchers have been optimized quite a bit. Just a couple of weeks ago I finished an app that uses large tables of data. I tested it with up to around 4-5000 rows, each having about 10 fields, half of them one-time and half of them watchers. It does take some seconds to load but once loaded, it runs totally fine. The answer above by snlacks is certainly a valid concern though.
I'm not sure about the traditional answer. I actually kind of like having a lot of logic in the view as you can quickly glance over the HTML to see what is going on. It gets even more manageable if you split everything up in directives and have a consistent folder structure for everything. It does require everybody to be pretty organized though. However, of all the things you could say I never expected you to mention long-term maintainability and modularity. This is also the biggest problem I see with Angular at the moment and Angular is almost impossible to incorporate in existing apps, unless they are quite small. I also just tried hooking it up with Gulp+Browserify and honestly, the dependency injection and global variables of Angular kind of clash with this setup. It works, but it ain't pretty. It seems like React.js is taking a path that much more resembles the modularity of Node.js which I really like. I should probably look into this.
Have you checked ReFlux? Any thoughts? 
&gt; Things like Anonymous functions still kind of boggle my mind. I'm not familiar enough with Ruby to know if this is the case there too, but this can be understood pretty easily if you think of functions as values, just like strings and numbers and `Array`s are values. Which they are, in JavaScript. Like any value they be referenced by one or multiple or no variable names. They also have a "name" property, just like a string has a "length". That name property can be the empty string, in which case we call it anonymous. There's really nothing more to it. &gt; I have to store setInterval as a variable even though it looks like a callable function. Ah, that explains that part of your code. You actually don't. The reason you see people storing the result is that the way you cancel an interval is by calling `clearInterval(intervalID)`, and the only way you can get `intervalID` is as the return value of `setInterval`. So, `setInterval` really is a function that does what you think, and it also returns a value that you need to remember if you ever want to cancel that interval. For a sanity check on that, try not storing the return value (it'll still work) and try `console.log`-ing the value returned (it'll be a number, different for every call to `setInterval`).
Angular breaks down when updating lots of items at once. That's its main feature -- data binding, and it's not very good at it. So there are other frameworks that are faster. The obvious choice is React. Even innerHTML strings (Handlebars) might be faster than Angular. This matters either for when you have a lot of items, or for when you don't want javascript interrupting your animations on slow-CPU devices (eg. mobile).
this
Wouldn't the "Stores" just be a normal Model? And that model could be implemented with backbone. Then the "Dispatcher" is just backbone's event systems. Finally, the "Creators" are backbone's views. When you think about it like that, it's no different than any current system, except it comes prescribed with one-way-data-flow rules. **Note:** I haven't used Flux myself, and am still working on my first project in React, so please correct me if I'm wrong :)
Pwnd. Thanks, the article actually confused me on that point, thanks for clearing it up.
You are completely missing the point. The above hello world program in angular 2 is there to demonstrate 3 of the core features of the library. You are comparing that to a hello world which demonstrates none of c++'s core features. If you wrote a c++ program that demonstrated classes, templates and memory management, it would be a similar complexity the the angular 2 example they posted. However maybe you feel all hello world programs must be the minimal possible solution (I don't know why, but it seems to be a sore point for you). In that case, the alternative hello world solution I posted is only 13 lines of angular code, so it is hardly insurmountable. Also, make sure you read and understand the second system effect link before posting it again. You are implying that angular 2 is a lot more complex than angular 1, however the opposite is the case going from this example. 
&gt; Browserify [...] is pretty much the same as [the] import statement in Java/C/C++/C# I'd like to point out that Browserify itself doesn't actually have anything to do with splitting your code up into modules, or even defining how those modules are written. It is only concerned with combining existing modules, injecting a shim, then bundling it ready for execution in the browser. The modules themselves are written conforming to the [CommonJS module style](http://wiki.commonjs.org/wiki/Modules/1.0) (which is most commonly [used in node.js](http://nodejs.org/api/modules.html)). Browserify is just a tool. There are other tools such as CommonJSEverywhere, WebPack, Require.js, all of which attempt to meet the same need (in slightly different ways).
My view has always been that comments usually don't hurt. It takes like 30 seconds to make sure you can come back to the code later and know exactly what was going on in your head.
You don't know how tired I am of seeing that title.
Recursion - pass in a 3, and does something along the lines of: - first time it runs, x = 3 - see's that x &gt; 0, so returns 3 * factorial(2) - since factorial is a function - it runs it again before returning, - second run returns 2 * factorial(1) then once it gets to the last thing that is simply a return without calling itself - it sort of 'unwinds' and you get your final result. If you do factorial(20000) or some other large number - you can blow the stack and get an error along the lines of maximum call stack exceeded. 
Everyone thinks that all that code is required. They didnt read it. If angulars future was based solely on this example the majority will be scared away. Better examples will come, this will be ignored and angular will be just fine.
Hey, JavaScripters! I just built a pretty big application using Flux and figured I could help other people out. EMF puts common Flux components into more useful classes and reduces boilerplate. Unlike Reflux and others, EMF tries to stay as close to the core Flux project as possible and does not do everything for you. I'm here for questions too if you have them.
I'm not entirely sure you read the whole article. He mentions this...
Not sure if you're being enthusiastic or sarcastic. Probably depends on how your comment was posted.
Try to walk through it step by step, as you would a Maths problem. We know that factorial(0) will resolve to 1 because it fails the conditional. Looking at factorial(1), we can take: factorial (1) { if (1 &gt; 0) { return 1 * factorial(1-1) } else { return 1 } } and think of it now as: factorial (1) { if (1 &gt; 0) { return 1 * factorial(0) } else { return 1 } } Then, we can substitute in factorial(0) with 1: factorial (1) { if (1 &gt; 0) { return 1 * 1 } else { return 1 } } // So factorial(1) returns 1 As we provide the factorial function with higher values of x we see through subsequent substitutions that this chain continues: factorial (2) { if (2 &gt; 0) { return 2 * factorial(2-1) } else { return 1 } } factorial (2) { if (2 &gt; 0) { return 2 * factorial(1) } else { return 1 } } // We know factorial(1) returns 1 factorial (2) { if (2 &gt; 0) { return 2 * 1 } else { return 1 } } // would return 2 and for factorial(x) where x = 3: factorial (3) { if (3 &gt; 0) { return 3 * factorial(3-1) } else { return 1 } } factorial (3) { if (3 &gt; 0) { return 3 * factorial(2) } else { return 1 } } // and factorial(2) returns 2 factorial (3) { if (3 &gt; 0) { return 3 * 2 } else { return 1 } } // 6!
could components be used for a web app? ionic has good components but they are webkit based and not supporting IE.
Isn't that what I explained further? :) The point is that "left of the dot" is sometimes ambiguous. It's a nice and simple explanation but will only get you so far. As I mentioned, `(1,foo.bar)()` is a good counter example. Would you also write it out as: 1; foo.bar(); It doesn't "work" because we're talking about references vs. values. You could argue that it's a contrived example — and yes, it is (although I used exactly this grouping operator to [derive often-useful indirect eval concept](http://perfectionkills.com/global-eval-what-are-the-options/#indirect_eval_call_theory) a while back — hey, contrived examples could be practical too!). But I think it doesn't matter. If you understand what constitutes a Reference and what doesn't, it's easy to figure out _any_ case — `eval('foo.bar')()`, `(function(){ arguments[0]() })(foo.bar)`, `with (foo) bar()`, etc. And speaking of `with` — I didn't go into that in a post, but here's a good example of "to the left of dot" falling apart once again (putting aside the fact that hopefully no sane person uses `with` these days). with (foo) bar(); } Why is `bar` invoked with `this=foo`? There's no dot anywhere in sight. Isn't that because `bar` is (in pseudo code): var Reference = { name: "bar", base: EnvironmentRecord // =`foo` object itself, as injected by `with` strict: false }; ..which explains why `bar` is what's used as `this` in this case?
Angular is a nice way to learn the concepts and organize for small teams. There's nothing wrong with that, it's not impossible to use either, if your ng-app is kept finite. Like many miniapps in a larger app. It's modular in that way. Unless I'm missing some bigger picture here. I get what you're saying about logic in the view, but I think it requires too much design from a Dev and too much Dev from a designer. It really depends on the use for the tool.
&gt; doing away with models What do you mean with that? Stores just contain "models" in a way.. I think the benefit of the flux/react approach is that you can skip having a fine-grained update detecting / eventing / dirty-checking in favor of a much more coarse-grained store updates, thus not wasting as much time on state change handling while still getting more than decent default performance thanks to react's updates and also a good path for optimization if you stick to immutable models.
Firefox bug?
Aside from the iOS specific design, one convention that will likely not translate well when used on Android is Android's use of the back button. Since the app does not update its URL, using the back button is not an option.
I'm currently building something using React + Flux architecture and found [this](https://egghead.io/series/react-flux-architecture) to be very helpful in getting to understand Flux.
Thank you. What is meant my // 5!
tried browserify?
Ruby has blocks procs and lambdas and as far as I understand lambdas are similar to anon functions but I'll be honest I am not good with those either. The thing with anon calls for me is like how you build the request animation frame function var requestAnimFrame = (function(){ return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback){ window.setTimeout(callback,1000/60); }; })(); for some reason trying to break down the way this works just boggles my mind and that is fairly simple with the one closure in it. I have seen anon functions in anon function in anon functions and it just makes me dizzy. 
I really enjoyed reading your indirect eval concept. Your knowledge of the language is humbling to say the least.
Node
Wasn't he implying that he's often told that he doesn't know JS?
Any good suggestions about how to read these on my kindle? Is there an easy markdown conversion app or something? Edit: I figured this out; I guess it's good enough. Buying it is obviously going to give you a better copy. I used KindleGen and pandoc.
Eventually you wanna learn both, so just pick the one that seems most interesting right now.
True, but it should be trivial to work in the HTML5 history API. That would add the back button support, as well as links to specific views 
Looks like there is no love for android 
There doesn't seem to be a horizontal demo. I haven't looked at the source code too far, so it could be there. 
AngularJS is my current favorite. I can't recommend it enough. 
Node. After that I'd recommend React actually. Meteor is solid too though.
1. It's an entry level job. They're not expecting you to know shit. 2. $10-15/hr is a fucking joke in NYC. For Javascript/Node.js you should be making $70-100k at the entry level. That being said, if you're totally desperate and think this will be a good learning opportunity, it may be worth doing for a little bit until you can land yourself a job paying a salary above the poverty line. Make sure you're really going to learn a lot though. Will they be mentoring you? Are they using modern tech and best practices? If not, keep looking.
Buy the eBook on O'Reilly? Side benefit: supporting the author.
Depends why you are learning. To get a good job right now, you probably need: Javascript + jQuery or Javascript + NodeJS or Javascript + AngularJS + some jQuery plus of course a decent knowledge of html and css. 
Just posted our version of a idea for the logo :) https://cloudup.com/i39zw4ahwmE
The code you posted is equivalent to this: function getRequestAnimFrame() { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback){ window.setTimeout(callback,1000/60); }; } var requestAnimFrame = getRequestAnimFrame(); Which is equivalent to this: function getRequestAnimFrame() { function myImplementation(callback){ window.setTimeout(callback,1000/60); } return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || myImplementation; } var requestAnimFrame = getRequestAnimFrame(); Does that help? If it's the first `(function(){` that's confusing you, then you just need to train yourself to recognize that particular pattern as a scope rather than a full-fledged function. In JavaScript scopes are only created by functions, so you'll see people create functions that they only ever invoke once, right after creation, because it's the only way they can make a new scope. (Side note: there will be other ways to create a scope in the next version, but the next version isn't widely supported yet.)
That's probably the best option, but I really don't have the money right now. Since it's open source, I don't feel too guilty doing what I did in my `edit` above.
makes a little more sense. still not really getting the closure in it though. that however may be an issue with my fundamental understanding of the return value of setTimeout though. 
Thank you, a really good article! 
I certainly appreciate it if you buy the books if you find them helpful. Any little bit helps me keep it going. But they're released in the open so that everyone can benefit from the knowledge. :)
That's definitely the tongue-n-cheek implied joke I was making, yes. :)
Consuming the content (even for free) however you want is totally OK with me. Please just don't try to re-distribute the content in those converted forms, as that is against the spirit of both the CC license and the publishing rights that O'Reilly has with me. :)
Thumbing through those books it's just a super complicated way to explain very simple concepts about compilers.
Exploring these ideas is one of the reasons I founded the [Graft project](http://github.com/graftjs/graft). Check out some more about the project from [these slides from nodeconf.eu](https://github.com/mcollina/nodeconfeu-2014-full-stack-through-microservices). To answer your question though... Microservices and the browser don't quite gel together. At least, most of the popular frameworks don't gel well with them. I personally feel that this is due to the DOM, which really is the scariest piece of shared state out there. The browser is a very stateful environment, and it is reflected in all the libraries built for it. The closest I have seen to things lining up a bit, is the flux stuff from facebook's react team, and maybe NoFlo. But even then, I think that [mercury](http://github.com/raynos/mercury) could be a better fit in this space. 
You got me thinking why I didn't use the HTML5 history API. I just remembered why after looking at http://caniuse.com/#feat=history. Android &lt; 4.3 do not support the feature. ~59% of android devices are running &lt; 4.3.
i like your ideas...but is it possible to get a PDF for kindle?
For comparison, people fresh out of school here in the midwest usually make $25 an hour and up. The cost of living is about half what it is in New York. Your pay is nothing close to fair. However, if it's the best you can get for now, you may have no better option. Getting some proper experience should open up plenty of better jobs for you.
You are awesome. I'm going to edit away those instructions as they seem to enter a legal gray area. Thanks for being so cool about this!
are you learning for fun and education, or are you looking to get a job? if the latter, I'd go with what's popular now. if the former, I'd go with what's going to be popular in 2-3 years.
 items.forEach(function(item){ //do something with item });
When our view management matures a bit, we're going to have an internal stack of app / view states that will be able to be used as a history stack. That, combined with Cordova's support for handling (and overriding) the back button behaviour should make it possible to implement native-like support for the back button on Android.
Same here. I've asked about Flux before here on reddit and got some helpful answers, but I'm still not really sold on the concept. Actions and events don't feel transparent to me. Also, stores don't care about actual data retrieval and persistence. This part is missing in Flux.
i would say that's a safe bet. also, koajs, rethinkdb, these things leverage stuff that's coming down the pipe in es6. i'm learning them now, in the hopes that in a year or two they'll be jobs for them.
&gt; `// Due to an unfortunate bug in older versions of Firefox,` If there were no bug the expression `('localStorage' in $window &amp;&amp; $window['localStorage'] !== null);` would never (for all intents and purposes) throw an exception so without knowledge of the bug the try..catch looks superfluous.
that's not a bug. its a feature...or lack thereof. This isn't just firefox. This is to guard against someone using any browser that doesn't support localStorage.
The expression would evaluate to false, not throw an exception.
I'd highly recommend React JS and Underscore / Lodash. You may be somewhat familiar with underscore/lodash already via backbone due it's dependency but it's well worth learning the full library. React is relatively new but has taken the community by storm and is well worth looking into
var isSupported = !!window.localStorage;
Indeed. But that would throw an exception in some older versions of Firefox when cookies are disabled because of a bug, hence the try..catch and **hence the comment explaining the try..catch**.
Yeah I see that. 59% of android is still a whole lot. That number will rise everyday. There is also a very good polyfill for the history API. I think it supports all the way back to IE7 if not 6. 
I am using flux for my next web app and I love it so far. The app feels rock solid and it is easy to write and extend. If you fear there is too much boilerplate then you should try reflux.
If I have an objection about this language it is the tomes and tomes of blahgs from confused developers analyzing the ambiguity which begets more confusion and others regurgitating the ambiguity, re-referencing those blahgs on their blahg. All over an ambiguity which in a statically typed language would have been wrapped 100 times over by now in libraries and frameworks eliminating the need for anyone else to ever come across it. It's the mandatory starting-from-scratch process that each developer confronts that is a huge con of JS. 
Google has over 50,000 employees, over 1600 internal apps using Angular, and run hundreds of thousands of servers. Their needs are not what most of us would consider typical. They probably want a lot of enforcement of safety features to ensure things go smoothly between different devs on different projects at scale. Javascript simply doesn't provide those.
Pretty much, yes...
I've been using webpack instead, seems a bit more powerful. There's modular and there's modular - Zakas/Osmani Sandbox/Mediator pattern is distinct from module.exports or IIFE modules (although these make it easy to implement). The architecture they espouse proxies system/3rd party capabilities through an API that gets passed in to each module.
This is a really great write up and that NODE_PATH tip is very useful. I just started our latest project with browserify so this would have been great if you posted it a few days ago. 
+1. In my experience the word "module" is such a general term used to denote "a unit of code", which could be formatted in AMD/CJS, RMP, IIFE or whatever. It does not in and of itself impart any architectural patterns. Note that Zakas' use of the term "module" in [this talk](https://www.youtube.com/watch?v=vXjVFPosQHw) is not the same. You can certainly implement this (or other architectures) using module.exports - but module.exports is not a design pattern. You can see the same pattern and term used slightly differently [here](http://www.slideshare.net/matt-briggs/marionette-structure-with-modules) 
Way better ;)
backbone.marionette
There needs to be an authoritative reference where it is all documented as a *de facto* standard manual (like MSDN for MS tech). It pains me to say it but it would be far better to RTFM some topics because so much energy and time re-discussing the same things over and over and over.
Thank you, I found this a while ago and lost the link!
I was actually just looking for something like this since i have recently started learning angular and ember. I was curios what the pros and cons were for each so this should be a good place to start. Thanks!
I am confused.
angular promises are either mostly or completely A+ specification compliant, so there is really no difference except the name of the service that hosts the promise. This is pretty much everything you need to know about promises var Q = require('Q') function test() var deferred = Q.defer() doSomethingAsync(function(){ // assume this function will be called after some asynchronous procedure q.resolve('message!') }) return deferred.promise } test().then(function(val){ // val =&gt; 'message!' // happens after q.resolve(val) }) .then(function(val){ // if the return value of the previous "then" is a promise, // this code will not be run until that promise is complete // if the return value of the previous "then" is not a promise, // this code will run immediately after the previous "then" has // been loaded into Q. In this way, promises have a complicated // but manageable chaining process }) 
I still think I prefer promises...
Yeah my last project was about 200k LoC but a good chunk of that were the unit tests which we didn't run through the advanced compiler. When we started the compiler was pretty basic (no generics for lists was a real killer when you're writing code in a Java-like style) - it has gotten some new features in the last year that can improve the quality of the analysis. My understanding is that Closure Library is the result of open sourcing a good amount of the library that went into building Gmail. Because of that I'm pretty forgiving of its code style - there was basically no JavaScript community at the time of its initial development. I'm really impressed that Google even cleaned it up enough to open source it - nobody really was going to make them do it. Of course better libraries exist today but once you break 100k LOC everything's going to unfortunately start getting a little painful :)
/u/Paupir, bkagn wants to send you a Bitcoin tip for 2,839 bits ($1.00). Follow me to **[collect it](https://www.changetip.com/collect/244535).** [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
I started out at $250/wk flat as a contractor back in 2000 and within 2 years was up to $60k salary, and within 4 years up to $85k. It's not a hard ladder to climb, and without a degree you will have to put in some years of work for less pay. That's just the business. If the job interests you and you can make it work financially, just go do it. Maybe take another part time job to supplement.
The code is licensed under Creative Commons Attribution license 4.0 Can be sold or distributed. I chose to put it to sell at pastecoin. If the first buyer wants to share it for free after buying, no problem with that. :) ------------------- This work is licensed under a Creative Commons Attribution 4.0 International License. http://creativecommons.org/licenses/by/4.0/ You are free to: Share — copy and redistribute the material in any medium or format Adapt — remix, transform, and build upon the material for any purpose, even commercially. The licensor cannot revoke these freedoms as long as you follow the license terms. You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. 
You're right. I think I was thinking about jQuery promises.
why ;-;
Those are very different than the ES spec (A+) promises.
you might have syntactic diabetes
No you won't, and stop being a downer. While syntactic sugar doesn't have a whole lot to do with building apps and the like, languages with good syntactic sweets make for fun golf competitions. ...^^^syntactic ^^^sugar
Maybe since it's not technically the "real" way for doing things , they should call it "syntactic saccharine". (Or maybe just "shuge"...) :)
I was trying to learn about Promises myself a couple weeks ago and put together an interactive API reference with what I learned at: [http://www.javascripture.com/Promise](http://www.javascripture.com/Promise) I'd love any feedback you have on that page.
Oh...thanks so much.
Good call on using Cordova to override back button behavior. I forgot that was an option.
https://github.com/CollectionFS/Meteor-CollectionFS/issues/489 Here's what I've accomplished and what I'm having troubles with in depth. It would be greatly appreciated if you took a minute of your time to look at it and tell me what I'm doing wrong. Thank you!
If you remember what that polyfill is, let me know. I'd be interested. From the documentation I've read on the back button, is that it can't be intercepted without the HTML5 history API. I'd love to be proven wrong about that.
Use this: - https://chrome.google.com/webstore/detail/word-filter/hhcjejiphdooogohnbfompmnglmgeiol I accept bitcoins. 
Have a look at Mist: https://www.youtube.com/watch?v=bYpOtAr1WiI
Consider Hapi also.
On the other hand, Q has some weird patterns, like the defer() in your example. Instead use the regular promise pattern: function test() return new Promise(function(resolve, reject) { doSomethingAsync(function(){ // assume this function will be called after some asynchronous procedure resolve('message!') }); }); }
The text he's typing is so small as to be unreadable. And he talks so inaudibly I had to crank up the volume on the computers, and all the other sounds are blaring.
I think it's great that he showed that a rejected promise should be seen as an error. It's quite common to see devs signal a "bad" result with a rejected promise when it should really just be resolved with the bad result.
You think that's better than any other resources out there? I'm trying to learn past the fundamentals
JavaScript's syntax flexibility makes it a versatile, loosely typed language. I like learning how others use it :) One language. Many techniques.
Forking is a form of flattery. That being said, project management of such big modules is a PITA.
Opinions.
I agree. But he is covering important subjects though. It looks like a very young channel but if audio/video issues are resolved, then, it could become a good resource. 
I'm a big fan of [Derek Banas](https://www.youtube.com/user/derekbanas). He does tutorials on everything from HTML to C++. And he has a really good [Javascript video](https://www.youtube.com/watch?v=_cLvpJY2deo)
$q in Angular (and probably the real one, offers something very similar, in the form of: return $q(function(resolve, reject) { // your code }; But the more I work with Promises, the more I realize I complicate them! More often than not, you can chain off a promise (especially useful when processing the result of one promise via returning a *new* promise), or use $q.resolve/reject to return a resolved or failed promise. If used correctly, Promises lead to code with no nesting, and a very synchronous-looking code flow.
The reason behind it is that when you return the above promise, anything has access to resolve it. Q.defer().promise gives notifications of updates, but you cannot resolve it form anywhere that doesn't have access to the Q.defer() instance.
You can make synchronous-style code with generators.
Thanks for the heads up. It's fixed now.
Cheers! Glad the content is useful. Let me know if I can ever help with anything JS learning related. :)
I see you made it roughly thirty pages in and stopped *golf clap*. Wow. Such opinion. For the record, the books *don't* discuss compilers across 700 pages, actually only a little bit in the first sections. they *do* discuss things like scope, primitives, native constructors, functions, coersion and lots of other *not compiler* stuff. Do you know how I know this? ...Because I actually read the damn books and didn't just "thumb through them". 
It's really beneficial to understand how compilers figure into your code, though. You might understand it already, but for a lot of people it could be very eye opening. Personally I've gotten a lot more than a complicated explanation of compiler concepts out of it. And plenty of stuff in there is familiar to me, but the guy does an excellent job of summing up JS resulting in plenty of 'aha' moments for me. I really disagree with your summary of the books. You're totally welcome to your opinion (I have no say in that), and your feedback is probably useful to the author. I just felt like adding my cents as well.
Be wary confusing language semantics for compiler semantics. A lot of things like type coercion are language semantics. This is why Numbers act differently depending on operation, and is what led to a formal definition of a sane subset of these things in asm.js to guarantee types through the language not the VM. Also note that FPUs are often slightly different in calculations for large numbers so the infamous floating point division results occur in most languages but not the JVM (due to specification of the VM, not the compiler no less!).
dude, give up, or just actually read the books you're knocking
I'm not a lawyer, this is not legal advice. From a copyright perspective, you need only comply with the license. MIT would allow you to fork so long as you leave the original copyright notice in tact. Ideally you would have a clear delineation between code that is copyright the original author and code that is your derivative work. This is often achieved by using the copyright info in the file header - add your own copyright when you make a derivative. From a trademark perspective, you need to be careful not to infringe on any trademarks. You should probably avoid using the name of the original product except for documentation purposes. Depending on the project there may be other risks.
Limitations would mostly be designing for touch interface, dealing with screen rotation and other mobile browser quirks. You should be able to capture touch events without trouble. There are JS libraries out there for interpreting gestures. WebGL support in the old Android Browser is pretty bad (though it's being replaced by Chrome.) Overall, support for WebGL on Android devices is mixed. Chrome blacklists some devices with bad drivers. iOS 8 or later only. Mobile 3D hardware is generally more limited than desktops. You'll need to check to see if certain OpenGL ES2 features are available.
So, You think that's better than any other resources out there? 
Read through some pages today, and really like the style + examples used. Looking forward to more! Will be picking up a paid copy if I can find it on Google Play. EDIT: [this and object prototypes book on Play Store](https://play.google.com/store/books/details/Kyle_Simpson_You_Don_t_Know_JS_this_Object_Prototy?id=BE8BBAAAQBAJ)
Go to buckys room.com over 200 JavaScript videos 
I like seeing someone making a contribution on their own time and for nothing in return. It is what it is. I don't see things in terms of better or worse than the other. I think for a beginner programmer this is a good resource. For more experienced probably something else would be considered good. There is plenty of stuff out there for everyone :)
By closure, you're referring to the function that most contains only the `setTimeout` call, right? The point of it is to assign an appropriate function to `requestAnimFrame` - it doesn't call it. So `setTimeout` is wrapped in a function because we don't want to call it right now, we want to define a function that calls it. I wouldn't call either of those closures though. The outer function is completely unnecessary, it changes nothing. And the inner is used as a plain old function, not to store values away.
This can not be done in pure client side JavaScript. You'll need something on the server side to process the form data sent from the client and append it to the text file.
I like Jesse Warden [https://www.youtube.com/user/jesterxl/videos](https://www.youtube.com/user/jesterxl/videos)[?sort=p](https://www.youtube.com/user/jesterxl/videos?sort=p)
chackaz, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Looks promising :-) 
Well, which server side languages are you familiar with? I Node.js you can for example use the [express](http://expressjs.org) framework. Then you must use your the file system functions available to append the file with data coming from a HTTP POST request. Basically, `fs.writeFile('filename.txt', request.body);`.
thanks!
The concept of syntactic sugar is far too useful to be disposed of. We need a term to describe syntactic structures that exist simply as a shortcut to a longer traditional syntax. So, if you are going to replace the words "syntactic sugar", you can only do it by coming up with a better phrase. That will be tricky, "syntactic sugar" is like the term "eye candy", it feels very satisfying to use the phrase, like you have made an insight into the world. I think you will never give away your $1000
dude i just said thumbing through it it seems that way, you don't have to be a jerk about it.
There was an article recently published that compares Express vs Hapi vs Koa here https://www.airpair.com/node.js/posts/nodejs-framework-comparison-express-koa-hapi I don't know much about restify but Express is perfectly capable for building a REST API.
I was watching an egghead.io tutorial and I felt that there was way too much useless code for how little of a project he was creating. Stores just seem like angular factories, or an MVC Model really. The actions seem stupid and I feel like there is a better solution there.
Homelessness has many causes, including accident, illness, the loss of a provider, divorce, and rising cost of housing (see the SF bay area for lots of examples). The one working strategy I have seen to curb homelessness is housing-first. We're working directly with housing-first programs to help a subset of recently homeless learn a valuable skill. You're wrong if you think that's a bad thing, or that we're doing some damage. We're giving people hope for a brighter future.
I really like this guys as well +1
React has a bad case of being unfortunately named while 'reactive' is a thing. 
React never claimed to be reactive programming. The goal is to avoid the usual process of mutating DOM state by allowing the programmer to specify how a component should look in a given state and then automatically making the necessary changes.
Speaking simply a promise is merely syntactic sugar over a recursive setTimeout. When you take the sugar away you tweak the performance. You can shorten the delay between intervals and increase the performance of the promise but that gain comes at cost to everything else in the app. An average delay of 50-60ms from 100ms intervals is usually negligible compared to network delay, particularly on mobile. You could reduce the intervals to 10ms, but that means you are halting code execution elsewhere 100 times a second, which is typically noticeable.
I love Derek, he's taught me so much over the last year or two! He even does food recipes!
Ok, I get it: I like pizza! And by pizza I really mean spaghetti! ;) live with it
there are way better tutorials out there, try reading this free book http://eloquentjavascript.net/
For nothing? They get ads revenue the more eyeballs they garner. 
I only code for ever green these days. who cares about old browsers?
maybe I really don't understand closures then T.T
I LOVE angularjs but would not recommend it next. Meteor looks like the next thing. 
any presentation that mostly attacks another framework while peddling its own is laughable. facebook's React didn't even need a mention because it has nothing to do with Reactive programming. the fact that he says one library is a direct competitor with another one is also hilarious. didn't know there was an ongoing competition. find a library that works for you and use it. i think this presentation misses the mark.
If you are really using 300+ js files in your app, it can/should probably be broken down into separate modules (npm or otherwise) each with their own transpile/build... it just sounds like something that isn't very maintainable in the end. A lot of ES6 capabilities can be shimmed in (not transpile required), though arrow-functions and generators are the big ones that cannot...
if you use co, you can use thunks or promises... which are easy enough to generate from the callback methods. it works pretty well.. once async/await are supported, it'll pretty much move to promises only, which is slightly less performing but more flexible.
That article is over a year old. Are there any performance issues with today's native promise implementations? I also don't really see how tail calls are related to this.
Can you plug and play rules as modules of your choosing in JSHint? While JSHint is less opinionated than JSLint ESLint is completely rule agnostic.
Not sure why you're being down voted, I use to exclusively watch his content.
You wasted your time making this. Its already been done for free. Who would waste their money buying such a simple thing to implement?
Those are [deferreds](http://api.jquery.com/jquery.deferred/) Which are like Promises (and in fact the jquery API is changing to adhere better to the Promises/A+ spec). You can play with Promises today by using a shim, either [es6-promise](https://github.com/jakearchibald/es6-promise) which is a fork/subste of the rsvp.js project, or with the full [es6-shim](https://github.com/paulmillr/es6-shim/).
If you want a minimal databinding library then you'll probably want to look at Backbone or Knockout, both of them have larger frameworks that you can transition to if you need more than what they have (e.g. Marionette and Durandal respectively). That React example isn't a very good one as far as amount of code goes, it's not supposed to show the easiest way to do a Todo. It's supposed to show everything there is to React.
Wow. Looks like this is it. Are there frameworks for it? It looks like a library only.
Another good one is Bluebird https://github.com/petkaantonov/bluebird/
Knockout is a decent choice and you might also check out RFP libraries like baconjs. I would suggest that you give react a try though. The simple todo has quite a bit of setup, but unlike most frameworks (where you don't find out the true complexity until it's too late), it doesn't get worse when you need to scale. 
On line 6, you are depending on the user being on http, whereas many people browse Reddit on https, so you may want to account for both cases. Also on line 78/149, you may want to use whatever the current protocol is they are using.
There are a lot of performance issues with today's native promise implementations! Specifically, [they're really fucking slow](http://jsperf.com/bluebird-vs-rsvp/9). Fortunately, Bluebird exists and we can use that instead for now. [Native promises in Chrome are also horrible at handling errors.](https://code.google.com/p/v8/issues/detail?id=3093) Bluebird fixes that too.
Hmm, I hadn't thought of that. Do you know if browsers redirect someone who opted into https if they are sent into a standard http url? Right now I have the script itself setup to just bring them into `http://www.reddit.com/?submit...` so I was validating just based on that since it's stripping an invalid unique GET id off the url to prevent reddits duplicate system from middle-manning the redirect. I guess I could just determine their protocol right at the start and plug it into everything else as I go to make it easier? Thanks!
Oh shit, I just realized that that validation won't do anything now if people are using just the bookmarklet without them reloading it meaning that the unique string won't be stripped off of the URL... Hmm...
TIL Jim Gaffigan is now doing JavaScript tutorials.
Seconded knockout! Great library, easy to understand and maintain! Combine it with http://pagerjs.com/
On my phone, so I didn't get to take too deep of a look. Just wanted to give you a heads up that you don't need a semicolon after function declarations: function() {} You should, however, put them after function expressions: var foo = function() {}; 
just to comment on this, buckysroom or better known as thenewboston is on r/learnprogramming's "discouraged resources" list http://www.reddit.com/r/learnprogramming/wiki/index#wiki_discouraged_resources
Look into TodoMVC, there are quite a few libraries that have two-way data-binding. On a side note you said that data searching and sorting is complex. Have you looked into filters? I just looked into how I do sorting in one of my apps: ng-repeat="post in posts | filter:searchText" Angular is massive and everyone goes through the same rollercoaster of hate/love. I still hold an unpopular opinion that Angular is OK for most SPA projects. But that totally depends on the type and needs of your project. 
Actually I'm building a small application for prototyping/testing of ideas. I don't need a huge framework like ember or angular. Ractive looks good. (:
Yup. I'm using as simple a filter as this: &lt;tr ng-repeat="student in main.datalink.allstudents | filter:searchText"&gt; where searchText is a simple ng-bind textbox, and with all the head-scratching, this doesn't work. It doesn't filter any rows, just shows blank! I had to create a workaround on the &lt;tr&gt; tags using ng-show to display only those rows where student.name matched the textbox value and only then it worked. I'd even made a help post on r/angularjs, but no solution could be found: http://www.reddit.com/r/angularjs/comments/2o1vy1/angularjs_filter_not_working_in_routing_based_app/
I worked on a Flex application for quite a few years, but switched to Java/JavaScript somewhere down the line. I gotta say, it's going to be different for you, but probably for the better. Flash seems to be dying quickly in favor of HTML5... unfortunate. The nice thing about Flex, it was really an all inclusive package. So maybe I can point you in a direction as you won't really find a good all-in-one unless you chalk up some money. Even then money doesn't buy you developer-friendliness. If you liked the two-way data-binding, I would go with [AngularJS](https://angularjs.org/) as a framework. To me, it most closely resembles the Flex and MXML model as there was a clear separation of services/controllers &amp; bound HTML. Maybe take a look at using TypeScript with it as well if you're still interested in the OOP aspect. The part I find best about Angular is the community size. So there is quite a wide variety of pre-canned widgets that are available for you to use. If you're looking for a grid, I'd say check out [ui-grid](http://ui-grid.info/) If you're not looking for a framework, but simply just a grid for a webpage, I'd suggest [SlickGrid](https://github.com/mleibman/SlickGrid).
Pretty sure he's some kind of wizard.
I heard knockout has messy templates.
This works for me: &lt;style&gt; p#the-notice { display: none; } &lt;/style&gt; &lt;button id="the-button"&gt;Click Me!&lt;/button&gt; &lt;p id="the-notice"&gt;You clicked the button!&lt;/p&gt; &lt;script&gt; var myButton = document.getElementById('the-button'); myButton.addEventListener('click', myButtonFunction, false); function myButtonFunction() { var myNotice = document.getElementById('the-notice'); myNotice.style.display = 'block'; } &lt;/script&gt; Does the javascript that attaches the click handler appear after the html element -- do you run the code on load? If you don't run the code onload and it's in the head, you'll get `TypeError: myButton is null` logged to the console. The only other thing I can think of is if there's an element on top of the button that is swallowing the click -- but you'd be able to see that because the button wouldn't depress. (most often this is for absolutly positioned elements on top of other elements) Try recreating the problem in a jsfiddle. 
Take a look at KnockoutJS if data binding is the only thing you need.
&gt; You should use bind() instead of higher-scoped variables and inner recursive functions to increase clarity and remove that nested function He doesn't need to use the `bind` method since the code of `run` is not object-oriented (e.g. no presence of `this` in the `run` function). He can just pass the parameters to the `setTimeout` function. https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout
Because contributions are being ignored.
https://sketchfab.com/ is like Youtube for 3d files, and uses WebGL extensively. It works on mobile. If you are interested on the support of WebGL on mobile, you should check out http://webglstats.com
You can use urls like: //reddit.com/submit to make browser choose if it will use http or https. Source: http://www.paulirish.com/2010/the-protocol-relative-url/
I didn't waste my time making this, because I wrote it for myself. It's something I use a lot, so I can say it's been tested for more than one year. And that I find it useful. And i agree with you partly, as value is subjective and depends on the person situation. If someone thinks it's not worth to pay for something so simple as two arrays plus a binary search and prefers instead to look up for it on google, or to write the code themselves, it is perfectly reasonable. But if you need one of these things and you don't want to use more time looking for something like this on google and you feel like not writing a binary search, and you can spend 0.002 bitcoin, well. That's the same and perfectly valid logic for buying basil at a store instead of growing it in your house. And that's why people sometimes pay for simple things. I am not forcing anyone who wouldn't pay for it. I am looking for those who wouldn't mind paying for it. If they consider the time and work saved is worth it's value. And as I said, it's a creative commons attribution only license. You can modify and distribute it at will once you have it. ps. do you think 0.002 is too expensive? :x 
We use C#'s MVC at work (for routing only, really) and Angular for binding, then $http + REST for the Db interaction and it's sweet. Soo easy to do the UI with Angular (after the learning curve, which is STEEP), then just update a JSON object and post the bastard to the server (or pull one). Really, I can't ever see doing a web app any other way, this stuff is just too easy with JSON + 2-way binding + REST!
you're comparing apples to oranges
will this work currently in a js-fiddle or stackoverflow snippet? or is it hypothetical code (e.g. fantasy)?
Yes, rendering the initial view on the server-side is faster. It typically only takes about 100 msec to create the whole document. If the CSS is cached, you'll see the whole thing in its almost-final state as soon as you got the document. The new images start to show up... and it's done. That's faster than getting the document, then being told that you need some scripts, then fetching/parsing/executing those, then fire some XHR to get the content, and then render that content. As you can see, if you do everything on the client side, you have to go back and forth a few times before you're able to produce this initial view. Basically, the idea is to make everything that's supposed to be in the initial viewport position show up as soon as possible. That's what makes it feel fast. Things which are further down the page or which require interaction or things like that (e.g. slide #2, #3, and #4 of your slider and the JS which makes it work) can wait. Anyhow, it's less of the problem if everything is cached. E.g. in a Phonegap app, you won't have this initial back and forth, because everything you need is already there.
That's what "I thumbed through it means" you egotistical cockmaster. You made a bullited list to fight against a point made by a guy who started out by saying "I don't know this book but". Congratulations on making a point on nothing. You win. . . nothing
Maybe something like this: function squareDigits(num) { var str = parseInt(num, 10).toString(); var result = ''; for (var i = 0; i &lt; str.length; i++) { result += Math.pow( str.charAt(i), 2 ); } return +result; } Maybe a little more performant (there's only one loop) but at least a little more readable IMO. This is a common pattern, where we take some set of items (in this case, the digits in the number) and iterate through them to build up a single new value (here, a string with the squared digits). This pattern is generally called `fold` or `reduce`. I don't think Code Wars lets you use any libraries, but usually I would just use Underscore or Lo-Dash's `_.reduce` for this: function squareDigits(num) { return +_.reduce(parseInt(num, 10).toString(), function(squared, digit) { return squared + Math.pow(digit, 2); }, ''); } 
Hm, doesn't look like JSHint has it. There's this closed issue where they said they were working on it — https://github.com/jshint/jshint/issues/908
I also dislike this trend.
It works works in the current version of chrome but you might have to turn Enable Experimental JavaScript on.
I don't think that will retain scope though, will it? Also it's surely abusable: var foo = "location.replace('http://www.reddit.com');" eval(foo); Edit: Fixed double-quote shenanigans in code.
Awesome, thanks! I had not heard of Frontside. It sounds really interesting. 
For what reason?
Sure it does, well, replace the inner quotes with simple ones. 
You won't be able to get the measurement like that because the letters don't have a fixed width and you're just counting them. If you want to do an autocomplete then look into how Bootstrap Typeahead does it.
So, wanna go back to the 10px days? 16+ px is pretty normal nowadays. 22px is fairly large, but far from being ridiculous.
&gt;The problem is further exacerbated if you do not have a high-specification machine or if you’re running an older browser. This is always going to be a problem if you're running a public facing website. You can't assume that everyone is running the latest, many people are running several year-old computers with the browser installed by the manufacturer and has never been upgraded. Some people even suggest that developers should develop on old, slower machines to experience the pain that their customers feel, so that they build sites that are fast on old websites, not on the newest.
If you want to embed JavaScript within JavaScript, I heard some talk about using the `Function` constructor to sandbox user code to some degree (as opposed to `eval`).
I would have paid for an object to do that for me! &gt;&lt;
This makes me think that something is wrong with your screen setup or something. The style here amounts to ~75 characters per line which is the upper limit for good readability. The text is readable from pretty much all reasonable distances.
Any language would do. Javascript would be hard, because I couldn't stop the code accessing the DOM et al without some problems.
Well, as /u/seigfryd says you cannot do it that way. Each rem unit (also em units, makes no difference) is based on the height of the font-size. And you're just counting how many letters there are, but not taking into account that those letters can have different widths. (Also not accounting that the font-size is defined on the height of the typeface, not on the width and generally all fonts tend to be taller than wider, but let's ignore this for a moment) What you want to do, the general idea, is simply measure just how wide is what is currently written. You could do this in various ways. One way, you could copy the content into a *similarly sized hidden `&lt;span&gt;`* and then read its width. http://jsfiddle.net/ugkzdjsy/4/ (that was just a quick p.o.c. you probably need to refine it. comment out the `opacity: 0` to see it working) You could do it like most auto-suggestions do it: placing it *below* your input, which is considerably easier. [Typeahead.js](https://twitter.github.io/typeahead.js/examples/) does a nice thing which is putting an identical `&lt;input&gt;` behind the one you type in and yours is made transparent so the effect fits perfectly.
Hi, Thanks! a lot for the help! Best regards!
Execute your eval code in a webworker. That acts as a sandbox. Also your eval has access to the enclosing scope, so you can retain state.
Worker have access to same origin XHR AND have access to open WebSocket to any other domain, allowing malicious attacker from evil.org to do anything what attacked user can do (like transferring private messages to cracker). 
http://nodeup.com/
I know, I love MDN. I probably didn't research enough nor well enough. So I used my time to make my own way. But what alternative is left then for people who don't want to research nor want to use time on figuring it out themselves? Why do you hate the people who'd like to pay for a solution so much?
&gt; Speaking of web design, what's with this trend to make fonts so big you need to either stand 3 feet away from the screen or zoom out several times? This is caused by two (well, a bit of three) forces: 1. **Desktop pixel density (the number of pixels jammed into a square of a given size) has been increasing over the years.** When I started doing design, we assumed monitors were about 72 ppi. Five or six years ago, it was closer to 96. With the transition to laptops and HD, it's even higher today. An 11" MacBook Air is 135 ppi. If you want a piece of text to appear a certain actual size to the reader, then over time, you have to increase its pixel size. 18px on a relatively modern display is actually a good size when compared to comfortable print text sizes at the same view distance. 2. **The increasing importance of mobile web.** Web users are likely to be hitting your site on a phone. While very high resolution, phone screens are still physically small. To accommodate that, you tend to need to scale up your design. Responsive design is hard enough as it is, so many sites tend to have a "similar" look at both mobile and desktop sizes. 3. **Fashion always comes into play.** While the above two points are real and valid, they have also led to a certain "look" being popular right now: single-column layout, big text, big high photos. Other sites then start following that. Personally, I love it. 12 pt is incredibly small on a modern display and my eyes aren't what they used to be.
True enough :)
If you want to do back-end coding, then learn Node. As far as front-end, learn all the standard stuff first. In other words, learn HTML5 -- which includes standard javascript (ECMA 5, and soon 6), CSS3, and HTML (especially Web Components). That gets you a solid foundation. And HTML5 has advanced so much lately that a lot of these other libraries/frameworks are no longer needed. But generally, if you "truly" want to learn Javascript, then start with standard Javascript THEN proceed to learning libraries/frameworks like jQuery/Backbone/Emberjs/Angularjs/React/etc.. On the other hand, if you just want to build stuff in Javascript and want to do things on a higher level, then do the opposite of the above: learn libraries/frameworks first, then figure out how they work afterwards by drilling into the underlying javascript implementation. Ultimately, no matter which way you start, so long as you keep at it, after several years, you'll end up at the same place: having learned both standard javascript and a number of libraries/frameworks. Personally, I'd advise against using a javascript framework -- instead, put things together yourself with libraries that each do a single thing but does it well. In other words, instead of going with an all encompassing framework such as Emberjs which has MVC, Router, data-binding, UI controls, etc., I would just put together libraries like jQuery, Crossroads, hasher, handlebars, requireJS, and so on. That way, I'd have an equivalent solution, but without the "opinion" that Emberjs would impose on how I do things. Good luck.
DotNetRocks - http://dotnetrocks.com
Thanks for your insight! I was running these snippets through JS Bin. If I were to have each file separated .html .css and .js, I’d definitely need to put the &lt;script src=“myFileName.js” &lt;/script&gt; tag in the &lt;head&gt; (or &lt;footer&gt;) section of the HTML document as you referenced. If I had created a runtime error, could I see that in JS Bin? Or would I need to separate the files, open the .html document in a browser, and use the developer tools to see the what the Console returns? I wasn’t using developer tools in the browser for this particular exercise because I thought it only accepted JavaScript under the Console tab’s command line. Is there a way to enter the HTML, CSS, and JavaScript in browser without files? How should debug style messages / logs be entered into the code? Again, I appreciate your time and response.
Yes it is still generally faster, but do remember that a typical user of Twitter reads a tweet in a second and then moves on. Twitter need to optimise for speed. On other websites people sit on a single page for hours, interacting with new data coming in via websockets/ajax. Those sites need to optimise client-side rendering much more. So it really does depend on how your users use your site. Also it depends on the software stack that you're running (e.g. you can run react.js on both the server and client to unify your templates -- then the question doesn't matter). See also: http://www.reddit.com/r/programming/comments/2nur45/clientside_vs_serverside_rendering/
either_this orThat - surely_notBoth
Change event should fire when the input loses focus. Are there any errors being reported in the browser console? Try removing your script tag and setting the onchange property to "alert('test');" to see if it is even firing. 
Works for me http://codepen.io/anon/pen/YPqaYm
FYI, this bit of code, myButton.onclick = myButtonFunction(); Is setting the my button on click handler to the result of myButtonFunction, which is undefined. You should start by removing this line of code.
In my console I see the error : calcul is undefined.
When I change to an alert, it works. 
This is a good idea. Nice thinking! I tried it real quickly and I had some issues. Not on js fiddle, but in my actual implementation. But I may go with this. Thank you!
I could, but I'm looking for inline, not dropdown, suggestions like Google does in all their apps. If they do it, it is possible. I just need to figure out how. I tried looking at their code, but I can't even find the element the suggestion is stored in.
comment out the last line? http://jsfiddle.net/ydan3dLz/
&gt; Here is the whole script tag : &gt; &gt; &gt; &gt; &lt;script&gt; &gt; &gt; function verifytext() { &gt; &gt; //this function is used in calcul &gt; &gt; } &gt; &gt; function verifyfor(variable) { &gt; &gt; //this function is used in calcul &gt; &gt; } &gt; &gt; function calcul() { &gt; &gt; alert("I'm in"); &gt; &gt; ...... &gt; &gt; } &gt; &gt; function calculP() {alert("Good!");} &gt; &gt; function calculV() {alert("Good!");} &gt; &gt; function calculnM() {alert("Good!");} &gt; &gt; function calculT() {alert("Good!");} &gt; &gt; &lt;/script&gt; 
please stay w/ dotnot
Angular Air https://ng-air.github.io/
[vm.js](https://github.com/tarruda/vm.js/) is a "Javascript bytecode compiler/vm written in CoffeeScript." It provides sandboxing and a means to expose selective objects to the sandboxed code.
huh? why would you resolve a promise with an error?
Thank you! Can you further explain how / why myButton.onclick = myButtonFunction(); sets the myButton variable to undefined? I thought the function I created myButtonFunction() executes the code within the { } and as such myNotice is generated? Would I need to return the code run between the { } first? Side note – everything is working now in all my browsers except Firefox. 
Create a test case on JSFiddle/CodePen/whatever.
http://pastebin.com/PCPKJA0C 
Perfect! Thanks!!
I did it
&gt; Every browser that you care about now understands that a pixel is not an actual display pixel and abstract it away. Browsers have no way of knowing how big your display is. All they know is resolution. It's true that browsers/OSes with "retina" displays use a multiplier to convert between the "reference" pixels that CSS authors use and the display pixels the device actually support. But that's different from the gradual progression of increasing pixel densities that desktop displays have gone through over the past fifteen years. Browsers in 2004 did not have any kind of "1.2x" reference pixel to display pixel multiplier. This is why, over the first decade of the web's existence, it felt like text was getting tinier and tinier. I remember when 10px was considered an adequate body font size. Then it was 12px. Then 14px. Then 16px. Now it's about 18px. &gt; A 10px font on a 1.5x display will show the same as on a 1.0x display or a 2.0x display. If by "show the same" you mean "subtend the same angle of the reader's view" then it's not reliably true. It depends on the display's physical dimensions and (in the case of mobile) the viewport settings of the site. The multipliers some device/browser pairs use are super helpful, but they're a rough approximation and exist to accommodate widely different pixel densities of displays *in current use today* and not to account for the gradual increasing pixel density that occurred before retina displays made a big discontinuous jump forward.
There is a syntax error in line 16. This: var objets[] = ["pressure", "volume", "nMOles", "temperature", "gasConstant"]; should be: var objets = ["pressure", "volume", "nMOles", "temperature", "gasConstant"];
I can recommend JabJS. It's minimal and super-simple, allowing you to data-bind your native POJOs to the DOM. Full disclosure: I am JabJS's developer and would be happy to help with using and learning it. :)
Awesome job at: * presentation format. Very slick. Not awesome job at: * understanding what react is and the problems it solves. * Spelling the word 'speech'. 
Thank you ! But it did not solve the problem :(
I don't. I hate the fact that someone would try and profit from a free resource.
Well, that's the first syntax error. As soon as there is a syntax error, everything that follows will be ignored. You made the same mistake again in the next function. Chrome and Firefox do complain about these errors. That's how I found them. I just clicked on the link next to the error message to jump to the offending line.
In essence, javascript code only has access to elements after they've been loaded... When a script executes inline it only has access to elements before the script tag. Consider the following : ex1: &lt;div id="test"&gt;&lt;/div&gt; &lt;script&gt; document.getElementById('test'); // DomElement &lt;/script&gt; ex1: &lt;script&gt; document.getElementById('test'); // null &lt;/script&gt; &lt;div id="test"&gt;&lt;/div&gt; The way to get around this is to attach a [load](https://developer.mozilla.org/en-US/docs/Web/Events/load) or [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) handler to the document. The difference between the two is that 'load' fires after *everything* had loaded, including external resources like images... DOMContentLoaded fires after the entire html tree has been parsed but external resources (such as images) have not yet loaded. If you use a load (or domcontentload) handler, the following script can appear anywhere in the page and it will correctly load the target element : document.addEventListener('DOMContentLoaded', function(){ document.getElementById('test') // DOMElement }) If you've ever seen jQuery code do something like this -- $(function(){ // code here }); This is shorthand for attaching a load handler.
JavaScript is case sensitive, check your function names to make sure they have the correct case. https://developer.mozilla.org/en-US/docs/Web/API/Element.getElementsByTagName
I have solved this by looking in the console, I did not know how to do that before today. Thanks anyway
Add the () operator to the end, e.g. isNaN()
[VueJS](http://vuejs.org/) does a great job of this. Their docs are great as well.
The error message is rather literal. The script that you aren't sure of is just injecting the Facebook SDK into the document. That needs to happen before you do anything with Parse's Facebook utilities. You can find an example of how this should look within your document in Parse's Facebook Users documentation: https://parse.com/docs/js_guide#fbusers &lt;script&gt; // Initialize Parse Parse.initialize("YOUR_APP_ID", "YOUR_JAVASCRIPT_KEY"); window.fbAsyncInit = function() { Parse.FacebookUtils.init({ // this line replaces FB.init({ appId : '{facebook-app-id}', // Facebook App ID status : true, // check Facebook Login status cookie : true, // enable cookies to allow Parse to access the session xfbml : true }); // Run code after the Facebook SDK is loaded. }; (function(d, s, id){ var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) {return;} js = d.createElement(s); js.id = id; js.src = "//connect.facebook.net/en_US/sdk.js"; fjs.parentNode.insertBefore(js, fjs); }(document, 'script', 'facebook-jssdk')); &lt;/script&gt;
This did not work... document.getElementsByTagName(i)
In addition to using the browser console, you can debug you JavaScript code via the browser. In your code, add the statement "debugger;" on the line you want to pause the code execution. The browser will then execute code up to that point and then stop. You then should be able to type JavaScript code directly in the browser console. This is useful when you want to check the value of a variable when the execution is paused. E.g. If you type "i" in the console and hit the return key, the console will output the value of i at that point. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger
They aren't JS podcasts specifically, but my two favorites are http://devhell.info and http://looselycoupled.info They're both more about developer issues in general rather than language specifics.
&gt;In OO, you might set up some object (say, a form input), and turn that object into an event emitter, and set up an event listener that jumps through some hoops and maybe produces some output whenever the event is triggered. &gt;In FRP, you instead specify data dependencies in a more declarative fashion, and most of the heavy lifting is offloaded to standard functional utilities so you don’t have to reinvent the wheel over and over again. So instead I can use neat functional stuff? Great! But without a related example to the commentary on OOP and the form I don't see why this is good other than that I can use map and reduce and all of these other supposedly great things! Fwiw, I am speaking from the perspective of someone new to FP, even though I'm not, because I can't stand most of the articles written about it....pretentious hipster handwavy. 
&gt;Why does everyone hate constructors? Functions returning objects are a simple way to encapsulate state and privately use subobjects in a compositional manner. Something something "not proper OO like I use in Java, therefore it sucks", something, something. &gt;And why does everyone want to use prototypes for everything? They're awkward for non-scalar properties like functors or sub-objects (which is exactly what we're encouraged to use in a compositional approach). And they make everything public, which seems... icky. Yep, there's a lot of over use of prototypes. Sometimes I think it's because they run some test coverage tool and get a low result and go "oh, noes, I can't test this because it's black box, therefore I have to expose *everything*" just to pass some arbitrary bullshit metric made up by a project manager to make them look good. &gt;I'm not being confrontational, but I really think I missed an important memo at some point here. Those from a classic OO perspective missed the important memo: JavaScript isn't made to do what you think it does out of the box. Don't like it? Learn the difference or bugger off.
Nice, got it changed. Thanks!
Both the page watcher and the random string generator were taken off of SE, so I'm nervous to mess around with them. I'll try it out though. Got that empty value conditional changed though. Thanks!
Updated all extensions to have update urls, and haven taken all the advice from the thread so far. Thanks guys!
Right, I really do wonder why they didn't think of that! It's almost as if they made a product decision dependent on factors we're both totally unaware of. Shocking. 
IE pre-version 11 would let you [mix VBScript and JS](http://msdn.microsoft.com/en-us/library/ms970435.aspx), able to share variables and all. And at one time, [Java and JS could intermingle](https://en.wikipedia.org/wiki/LiveConnect) if you were using Firefox. But enough of the history lesson, because neither of those apply today. You mention Python, so I'll use that as an example, but the key for you is to search for something like `python interpreter javascript`, which gave me several promising results: * [skulpt.org](http://www.skulpt.org/): _Python. Client side. Skulpt is an entirely in-browser implementation of Python. No preprocessing, plugins, or server-side support required, just write Python and reload._ * [repl.it](http://repl.it/): _Online Interpreters in JavaScript. Try Python, Ruby, Scheme, Lua, CoffeeScript and more programming languages._ etc. 
Designed to be compatible with ECMAScript 5 and later. Therefore, rel. easy to shim for current engines.
If you have any interest in Meteor.js world: http://www.meteorpodcast.com/
I know I hate constructors because they are severely counter-intuitive to JS's functional scope model. It is very likely this is why many other developers hate them as well. I prefer to not use prototypes for inheritance myself. You don't need constructors, prototypes, classes, or other OOP concepts to achieve inheritance in this language.
From the for...in MDN page: &gt;Array indexes are just enumerable properties with integer names and are otherwise identical to general Object properties. There is no guarantee that for...in will return the indexes in any particular order and it will return all enumerable properties, including those with non–integer names and those that are inherited. So I was incorrect, it will return the index values, but it was also return any other enumerable properties on the array, and the indexes may not be iterated in order. Generally, if you want to iterate over an array, it's better to use a for loop: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for
To really learn FP concepts you cannot rely upon your OOP practices. You kind of have to think fresh, build a new foundation for organizing your code, and practice it a little bit. I presume this is excruciatingly frustrating for well training programmers new to functional programming, but you have to be willing to embrace it to understand it. This said a corresponding code example would not be helpful, and it may even make it only more confusing.
While I agree with the over arching theme of the article (As light on actual meaningful content as it was), that video at the end was the biggest pile of misinformed tripe I've ever seen, using some of the absolute worst examples possible to try and make static typing look bad, in one of the worst statically typed languages in existence. Both styles have their pros and cons, but he could have at least used genuine cons of static typing instead of pretending it can't handle parametric polymorphism.
Not true, you can use an iFrame as a sandbox! I've been working on a project I call CjsSS where I've embedded JS inside of CSS in order to add functions and variables to CSS (basicially LESS/SASS but vanilla CSS and JS rather than yet another language to learn and prereqs to install). [Check it out](https://github.com/campbeln/cjsss). For sandboxing, you'll want to look at [this code from `cjsss.js`](https://github.com/campbeln/cjsss/blob/master/cjsss.js#L570). If you have trouble making it work, let me know, but basicially extract the `createSandbox` function (as well as the `globalEvalFn` it relies on), then when you call `createSandbox` you'll get a `window` reference that is completely detached (note `parent=null;`) with the `window.$sandbox` object setup to do either a global (persistent) or local (non-persistent) eval. I've been doing a TON of work with Eval and I'd love to extract the code from CjsSS to do just that, I'll have a play this evening (AU-time) and point you to what I've developed ;)
Woah, that's pretty slick. So from what I can tell, with very limited searching, that querySelectorAll kind of makes a pseudo jQuery style interface? All of my script was originally in jQuery, but for some reason I couldn't get the extension script to utilize the jQuery file properly so I rewrote the whole thing in JS. Can that be utilized in the same fashion as jQuery with something like $('div.entry') or something? Also that template generator looks really handy. I'll have to do some messing around with it. Thanks!
The article is very high-level -- not meant to explain how FP works so much as to explain some of the foundational ideas, and why it's important. To see lots more details, and to work through lots of code examples, scroll to the bottom to the "Higher Order Learning" section.
Eh... it only inherits the global scope, but it doesn't sandbox. To sandbox you want to use an iFrame with a `null`ed parent, check out my response to OP below.
Right now I'm not sure what you mean about Google's apps. All the ones I remember use a dropdown. In any case, imho the nicest solution is the Typeahead.js one I linked.
How do you achieve inheritance without prototypes?
I think you are being unfair to me. But please, before replying to that statement, let me explain you why I think you are being unfair to me. I can do it with an analogy. Let's imagine there's a lake full of drinkable fresh water (A free resource) And I walk to the lake, I fill a glass with water and I come back to my seat and my table, which are 100 yards from the lake, besides a pathwalk where people are walking by. And I put a little sign on the table, besides the glass. "Water for 70 cents" (that's what 0.002 bitcoins is now) is my offer. You happen to walk by my table and you see the sign and you start telling me that what I am doing makes no sense and that I am wasting my time doing that, and that no one should pay me and I shoulnd't make profit for a free resource. While you do that, 202 people walk by my table, read the sign, look at the lake, and decide that they prefer to continue walking, or if they are thirsty, the prefer walking the 100 yards to the lake by themselves. I am not forcing them to do anything. They are not forcing me to do anything. I am not blocking them from doing what they want -except to have my glass of water, which is good because it is mine and I went to fill it without forcing anyone else to do anything for me. So they respect that this is my glass and won't touch it without paying as I ask for it. I am not forcing them to go to the lake, because me being there or not doesn't change the fact that if they want water for free, they'll have to walk to the lake. So imagine that someone passes by, see my glass and the price, and then look at the lake and thinks 'hmm... spending 70 cents to satisfy my thirst and at the same time not having to walk 100 yards to the lake... I'd paid for these benefits gladly!'. It's a fair and voluntary deal where both of us win something we are willing to give and receive in exchange. For the buyer, the 70 cents are less valuable than the glass of water, and I value those 70 cents more than my glass of water. If you see that, what would you tell them? That they are idiots wasting their money, that they should better walk to the lake instead of making me have a profit if giving them my glass of water? Then the buyers would tell you: "You won't tell me what i do with my money. I do what I want with it". And I'd tell you: "You won't tell me what I do with my glass of water, you can't force nor convince me to give it out for free. I do what I want with it.". And I'd say more: "If you think this is unfair, why don't you walk to the lake yourself, fill all the glasses you want to, and come back here and give it for free to anyone who is thirsty. Because all you've been doing is telling me what I do wrong and what the other people should be doing instead of actually doing something that helps them, without making me do it for you by giving out my glass of water. Less words, more doing." TL;DR ? In short, this is what I think is unfair: What I am doing: - I am not blocking anyone from doing what they'd do if I didn't exist. - I am not telling anyone what to do with they time nor their money. They can ignore me. - I am giving them the chance to save time, thinking and testing, by a small amount of money, and for that I get a little profit. Sounds fair. And I didn't force them to, they can still act as if I never existed and write the code by themselves if they want to. I didn't add anything bad to their situation, I am creating a new option that didn't exist before. Do we agree on that? What you are doing: - You are trying to tell me that I am wasting my time, so you are telling me what to do with my own time. Sorry, but I decide that. - You are trying to tell me what to do with something I created by my own mind and effort, and telling me I should give it out for free. - You seem to try to imply that me making a profit because of someone rationally deciding what to do with their own money is wrong. But they would be using their money as they want to do it, they are not being robbed. If they did as you say, to avoid giving me a profit would be for them not saving themselves the googling time and thinking time needed to obtain the implementation they want. Do we agree on that too? Now, to make this really fair, this is what I think should be done. - If you hate me making profit for something that is a 'free resource' so much, then you may easily solve this problem by writing a script that does the same as mine does, but giving it out for free. Or find an already written code that does the same, and share the link to it. I wouldn't be competition for something that is there for free. I haven't found any js object that does the same mine does. Yet. - If you don't think your time is worth it, then that means you don't really care much more than only for writing a couple of complaints about what I do, and leave the "injustice" (in your opinion) continue. - If you really don't want to write the code for free, it is fine too! No one, not me, nor anyone else, should be telling you what to do with your time. The last option i just gave to you is the most fair because no one is telling anyone what to do. Because it's up to you what to do with your own resources to solve a situation that is unfair in your own judgement. Not in mine, and not in some others judgements. And if 100000 people judge it as an unfair situation, even more, 100000 people should be able to deliver a much better solutiion without telling me what to do with my stuff. So what do you think? Would you write the code or now the idea of just letting someone paying 70 cents for code is not as bad as wasting your time on writing something they could research for themselves? 
Okay. Thank you again !
you need to prevent default.
Side note. Nothing prevents you from having your IIFE return an object constructor. var CustomConstructor = (function() { 'use strict'; var Factory = function CustomConstructor() { if(!(this instanceof CustomConstructor)) { return new CustomConstructor(); } /* do something */ return this; }; return Factory; }()); var custom = new CustomConstructor();
It's good to agree on something. By the way, for the same reason I hate copyright laws. Because copyright means that if someone is selling the glass of water, the police is blocking you to go and get the glass by yourself, or go to get water for others for free or for your own profit, without paying the first one selling a glass of water. And that's completely wrong. Because it's not just someone telling others what to do, but calling the f*** government to enforce injustice on everyone else who is thirsty. That's why even if I can sell the access to a copy of my code, I would never block nor try to stop anyone from copying it to others or modifying my code once they have accessed a copy of it (even if they hacked the pastecoin site). 
Actually, does 2 way binding work well with nodejs? If someone else updates a to-do list on the server, will I be able to see this update on my front end automagically?
Google Search and Inbox both use the completion in grey in the input and the dropdown for suggestions. I'm hesitant on trying typeahead because it seems it is only a dropdown not the inline completion.
Yes, opening the console on JSBin (and other similar sites) will show you the errors, usually. But like the other person mentioned, that last line is what was killing it.
That's fine so long as you aren't changing the base object, but inferior if you have a dynamic base. 
It's because you are assigned the onclick handler to be the result of running that function. Running that function returns nothing. In this case, returning nothing will give undefined. What you want instead (like you have in the addEventListener), is just to assign the function itself. myButton.onclick = myButtonFunction; By having the parentheses there, you are immediately running the function. It might help to think of it like this. var myButtonFunction = function() { ... }; You now have a variable which references a function. var a = myButtonFunction; // another reference to the function var b = myButtonFunction(); // b = the result of running b
Welcome to JavaScript?
What have you written? This is a place for sharing, not complaining.
The biggest issue with generators is that they aren't optimized in current browsers and there seems to be little desire to take on the challenge. For example, FF made their implementation faster than Chrome's simply by allowing generators to be baseline JIT compiled instead of interpreted. Going from there to Jaegermonkey is probably not happening any time soon (if ever). In contrast, because promises are regular functions, objects, and callbacks, they should already be optimized.
 #!/usr/bin/env node var cmd = require('commander'); cmd .option('-n, --number [n]', 'Number to square each digit', 9119); var digits = cmd.number.toString().split(''); var squared = []; squared = digits.map(function(num){ return num*num; }); console.log('digits %d squared to %s', digits.join(''), squared.join('')); 
Nope. nothing stopping you from doing that.
i just read about it the other day. That was something that was sorely missing from PHP....pear was horrible.
 console.log([100, 101, 97, 108, 32, 119, 105, 116, 104, 32, 105, 116].map(function(c) { return String.fromCharCode(c) }).join(''))
Unless you're sharing _fashionable_ complaints, like Angular criticism or criticism of repetitive Angular criticism. 
&gt; It seems like this is a knee-jerk reaction to the talk's title more than to the talk's content. I think you completely missed the point of the video. Thanks for your reply Eric. I watched the whole thing back to back (before my original post) and the impression I got from it was "Look how stupid static typing is". Clearly this wasn't your intent, but that's how your talk came across. &gt; That said, static types are far less useful as a code quality guarantee than unit tests are, and unit testing should be done in any language, regardless of its type system. I'd disagree that they are "far less useful", since in my experience when using a good static language (ML'ish), your code almost always works the first time it compiles, since the types exclude the vast majority of possible incorrect implementations. Obviously never 100% (Which is why you still need unit tests), but it takes a massive workload off writing unit tests simply to verify types and instead lets you just focus on business logic. - Types ensure your program will handle all possible inputs with viable outputs. It can guarantee your program will succeed, but not that it will produce the correct answer. - Unit tests verify business logic. They can verify the scenarios you've tested, but cannot verify that all inputs will succeed. They are both separate concerns. Attempting to verify type safety with unit tests is a fools errand, as is attempting to verify business logic with types. There's definitely a crossover, but they are for the most part *completely orthogonal concerns*. One does not replace the other, and neither is a complete guarantee of correctness. This isn't just academic theory. My team has written about 100,000 LOC this year on an in-production commercially successful project, with a mix of about half in Scala and half in Javascript on the same project (With a little Haskell thrown in). Working with both languages side by side every day gives you some interesting perspectives on the benefits of both, and this experience specifically is why I have changed from being a strong supporter of dynamic typing, to a religiously adament supported of static typing, with the belief that if only people would try a language with decent type inference they'd come around. &gt; When you follow a structured process with functional tests, unit tests, and code reviews, there are relatively few type errors left to catch, so the most famous benefit of static types are effectively nullified. From my personal experience, I disagree strongly with this. Even with very high levels of code coverage, I still see many type errors make it into production JS code, both on my own projects and others. Obviously everyones mileage will differ, but unit tests only catch what you thought of ahead of time. They don't always catch the user inputting something you weren't expecting. Types do. (Unit tests are also a lot harder to write). &gt; But seriously. Just look at Java's Collections.sort: public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &gt; To me, that syntax is verbose and ugly. All those pointy angle brackets literally make it look like a torture chamber. I agree with your sentiment about Java. It's a crappy language. &gt; No matter how much I tried to get used to this, as soon as I started using JavaScript I realized there must be a better way... I feel the same way - I was quite dissolusioned with programming for a long time because of Java. I went the other direction to you obviously in my search for nirvana, but probably have the same reasons for the transition. In either case you don't inherently have to give up static typing to avoid Java's verbosenes. Almost every other language would be cleaner. Scala: def sort[T : Comparable]( list:List[T] ) Haskell sort :: (Comparable t) =&gt; [t] -&gt; [t] &gt; In languages with strong types and good inference systems, that problem vanishes, because all function signatures are potentially generic. &gt; The same holds for JavaScript. You just don't have to worry about this sort of type system cruft. Not even remotely. Type inference has no effect whatsoever on how generic your code is. The above example in Haskell would have worked identically without explicitly putting in the type signature because of type inference, but it's generic because there's a `Comparable` typeclass, not because the compiler can infer it . You still need to design these abstractions properly - i.e. define an interface or typeclass for your generic trait. This is in contrast with Javascript, where you can use duck typing to avoid having to define the actual interface. This is both a good or bad thing depending on the problem at hand, and in some cases I would still prefer the dynamic approach to solving a subset of problems. You could use structural typing to have something that looks a lot like duck typing with static type safety, although I'm on the fence about whether I like this idea or not - I normally prefer to explicitly define interfaces, but that's just personal preference. If you prefer to work a bit looser but want some type safety then structural typing with inference may be a way to go. &gt; In languages with type inference, you still retain the benefits of strong types, with few of the headaches. I strongly agree - which is why I love ML-family languages so much. Type safety without the pain - best of both worlds. &gt; I believe that's possible in JavaScript, too, if we stop spitting on JavaScript as a language because its type system is not what we're accustomed to.maybe we can make some real progress in terms of both static and dynamic analysis tools. Absolutely agreed. I've always maintained that most well-formed Javascript could be staticaly typed if people weren't so stuck in the mud about it because they equate "Static typing" with the typical Algol and Smalltalk derived crap that has passed for production languages for so long. (Java, C#, C++). &gt; Maybe tools like tern, and Facebook's Flow can help. Flow is a fantastic tool that gives me hope we can bring true static typing to Javascript. It's already started making a difference on our projects. 
Woah! So many overreactions.. 1) It's stated clearly on the second line of text on the landing page that this is a, "ranty, opinionated series of easily digestible tidbits." So, it pretty much **does** say "My opinions on web development... [blah, blah, blah]." 2) There's a "C" (for CoffeeScript) in the upper corner that, if you click it, turns the code examples into JavaScript. Pick your own flavor. For the record, I too agree that this should probably be more clear. 3) The "touching the DOM" bit was in a section titled "Overview &amp; Bullshit dispelling," as you yourself pointed out. Now, I don't know what you mean by "modeling" (modeling an application? Backbone models? modeling data in general?), but I would guess that the author is referencing performance and testing issues, and application complexity caused by holding state in multiple places. This is bad. Store your state in Backbone models, or, if you prefer the DOM, use the DOM (via jQuery or vanilla JS). Don't use both. This actually does impact all three of my guesses as to what you meant by "modeling." Bottom line, don't be such a zealot. It's just one man's opinion and experience using a JavaScript library. And before going into a public forum and calling something "crap," please take the time to comprehend what you've read.
Javascript isn't Java, man!
too bad lel
Good point, i didn't really think about using an arrayList. We just started to learn about those in my AP computer science class. Thanks for the input. And I wasn't sure which subreddit to put it in so i apologize for that. 
ArrayList maintains insertion order, it's one of the basic contracts of the list interface. That said, the majority of the logic here could be simplified to something like : // shuffle a cloned list Collections.shuffle(clonedList); // return the first half of the shuffled list return clonedList.subList(0, (int) Math.floor(inputs.size() / 2.0)); assuming that OP is comfortable with the distribution of the shuffle method.
If you're just messing around with maps and communicating with an API you probably don't even need a framework. 
People like you remind me why I hate reddit...
Google Maps javascript api.
I'm not wound up, I was just looking for someone who knew something about programming. I didn't realize it was that big of a deal. /r/programming doesn't allow text posts so i just put it here... I think everyone kind of just hates reddit 
lmao, i do... i just don't get reddit
&gt; But I am wondering if script a which is loaded on dom ready can actually reference the underscore functions in use? You'll need to give us an example.
Try if Leaflet.js can help you with this. It works with any map source. 
Vanilla js
oh....haha. so there are subs. ./r/&lt;topic&gt; -- assholes like me will jump all over you for posting a java question in /r/javascript :) 
can you do a fiddle? But I think your problem is how you're triggering the form submit, by preventing default. don't attach to a click button attach to `$('form').on('submit', fn);` instead. ..and use `e.preventDefault()` there.
 if ( !parts.value ) { prompt('What part?') } 
Here's the [fiddle](http://jsfiddle.net/j212dLyh/). PHP doesn't work on it though. And I'm a little confused on what you said, I replaced the $('input[name="createacc"]').click(function(e) with $("#registerform").submit(function(e) But isn't that the same thing?
I think you are possibly helping me to have the user be prompted to enter an item if they enter a quantity? If so, the class for quantity is .quantity
Yeah...all about angular and node/iojs these days. Once es6 hits though, we'll have a whole new set of frameworks.
Nest functions.
All those comparisons with `NaN` you have... if (num != NaN) ...well, that just doesn't work. [You need to](http://jsfiddle.net/2jynzdrn/431/)... if (!isNaN(num)) ...because `NaN != NaN` so you will always evaluate to `true` with your code, whether `num` is `NaN` or not.
Will definitely be looking forward to that!!
Aaron Frost isvan amazing speaker. His ES6 talk is great. 
For DOM3, [keydown event already has a read-only property 'key'](http://www.w3schools.com/jsref/event_key_key.asp), supported by IE9 and Firefox23 only. Thus you cannot set it in IE and Firefox but it works in Chrome.
Asking questions like this when you have no basics wont help you. Set up a 2 screen/computer workplace. Run a video tutorial on Javascript of your liking on one screen and follow along on the other. Best of luck
Aww that was fast, thanks ! Guess I have to give it another name though.
What are you trying to run it on? Most of this is going to be happening in the console, not on screen. Is this from codeacademy? They have the console built in there to view it, otherwise you should be using some dev tools with your browser. 
It's 1am for me and I've not gotten to refactoring out the `eval` stuff, so tomorrow it will be. The functionality is already in a isolated clouser in the code I referenced, so it's 90% there already, but some additional documentation would be nice for you (which I do have, just need to post). From my research, the isolated and `parent=null`ed iFrame is basicially as sandboxed as you can get. And with the way I'm running the code in CjsSS.js I actually cache the sandbox (well, evaler actually) so I don't have to re-run the script blocks every time. Anyway, I hope you find the code useful! I'd love to hear a bit more about the game though,as my son has been asking to learn how to do that and HTML/JS it a nice toe-dabbler to have a start.
ng-conf 2.0 Wait no sorry, I meant 1.3. 2.0 presentations will be spoken in AtEnglish 
Yup, you can use `querySelectorAll` exactly like you would select something with jQuery (it uses any valid CSS selector). And with the code I provided you use can `$` just like it was jQuery. All that code is doing is reassigning `document.querySelectorAll` to `$` and binding its context to the `document` (the context must be `document` otherwise the function won't work). If you need me to explain how the template function works, let me know. Another use case I forgot to provide an example for is binding it to a template like this: var anchorTemplate = template.bind(null, '&lt;a href="{0}"&gt;{1}&lt;/a&gt;'); anchorTemplate('http://reddit.com', 'reddit'); This way you can reuse this function every time you need an anchor instead of passing the string each time.
huh... I swear I've seen what I'm describing in search. Well, here it is in inbox: http://imgur.com/fOAu1G4
It's a much better idea to not modify objects you don't own. http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/
On Mobile... (Firefox nightly build) Can see a cassette image in various colors... Some text below it to describe what it's inspirations was... Is there supposed to be a play button? What's it supposed to do?
You should be able to click / tap the cassette and hear audio. What platform are you on? Unfortunately, iOS does not seem to respect the HTML5 audio preload attribute.
Android. The play button doesn't show here either.
Maybe I explained it badly. What I mean is that some devs reject promises in situations where they would't raise an error in synchronous code. If you have a synchronous function which return null when nothing is found, that function when made asynchronous should return a promise resolved with null instead of a rejected promise.
Are you using Chrome? The play button will display as soon as the 'canplay' event has fired. Seems to be a network issue or, perhaps, a ReactJS compatibility issue with your browser. 
Firefox Nightly build. I don't think it's React. I've never had a problem there. Must be something with Audio.
If I had to guess I'm pretty sure I'd say they do that with the two inputs, like typeahead.js
Ah right... I always forget about that. Damn mini war over codecs really puts a damper on making cool stuff that just works.
 window.onload = function () { /* stuff here is run when window including ALL content within (such as images, css, adverts) has been loaded */ } 
Ah right, Set interfaces are what I was thinkng of. 
Since no one else will answer your question I will. Input fields have an event: onchange So if I say, for example. document.querySelector('#myInput').onchange = function(e){console.log(e)} The changes that occur to that field can be used to apply a function. If you want to change the value of other fields, you can sets its value like so: document.querySelector('#otherInput').value = Math.PI * document.querySelector('#firstInput').value You can also validate each field by checking if it matches a certain list of conditions before setting the value of another element. Hope that helps.
Love the concept. Too much angular for me to bother though.
Are you referring to a JavaScript application running in the browser or in node?
In the same vein, you could also use init.d to start any browser flavor of your choice and launch the JavaScript app. I use Chromium browser (in kiosk mode) on my BeagleBoneBlack which loads an app that's being served by NodeJS. 
Oh yeah - I get the same. 
Neat!
So you don't actually have that much experience with it, then?
You need to proofread your code more closely. There were missing semicolons and incorrectly placed quotes. I recommend using a syntax-highlighting text editor such as Sublime, Notepad++ or Atom in the future to help make these small errors more noticeable. Here's a rough clean-up of your code: confirm ("I am ready to play!") var age = prompt("What's your age"); if(age &lt; 13) { console.log ("You can play, but I take no rseponsibility :D"); } else { console.log ("CHEESE AND BACON!!!!!!!!!!!!!"); } console.log ("You are at a Justin Bieber concert, and you hear this lyric 'Lace my shoes off, start racing.'"); console.log ("Suddenly, Bieber stops and says, 'Who wants to race me?'"); var userAnswer = prompt("Do you want to race Bieber on stage?"); if (userAnswer === 'yes') { console.log ("You and Bieber start racing. It's neck and neck! You win by a shoelace!"); } else { console.log ('"Oh no! Bieber shakes his head and sings "I set a pace, so I can race without pacing."'); }
so for example on this page https://www.reddit.com/r/javascript/comments/2pa6vn/want_to_learn_how_to_write_a_clintside_js/cmus6xo?context=3# there's one line that says: " 1 comment (1 new) share save hide delete nsfw hide all child comments buffer" I'd like a new word/link to appear in that list called "resub" that will send the title and the link [bad example because this is a self post, imagine this is a link post] to http://reddit.com//r/jmdugan/submit and populate that page with the title and link from the referring page where the user makes the click. basically it would allow me to repost the title and link into /r/jmdugan with two clicks -- without retyping the title and copy+pasting the link . bonus: having the same 'resub' link link also appear on the list of posts for a sub would be great too, like in /r/truereddit on the line of operations under each link. 
Haha, nice work! That's exactly the opposite of a little experiment I made: https://github.com/AlexanderSelzer/jscss. Yours is of course much more sophisticated (there's no real parser in mine). It works a bit like JSX in converting the CSS expressions to JS function calls and concatenating everything. It then passes the JS mess to a Node.js vm context, of which the output (stdout) is the valid CSS. :) Of course this only works in node, not in the browser, but it is a perfect sandbox in this use case. (Sorry for being a bit off topic)
okay, thank you for the guidance.
Here's the article you all should be reading: http://perfectionkills.com/know-thy-reference/ It's actually informed and knows what it's talking about for the most part
I might not have read this as "nippleJS" were it not for the parasol...
&gt; (!isNaN(num)) I get it, thanks for finding that logic error. I fixed the js to reflect this change.
Also, age is going to be a string, and Javascript's type coercion is crazy, so you want to avoid comparing strings to numbers if you can. instead, go with: var ageStr = prompt("What's your age"); var age = Number(ageStr); //Alternatively, you could do: var age = parseInt(ageStr, 10); 
Node. Thanks for asking/clarification.
Heeheehee, how cool! I've never played with Node and I'd LOVE to setup CjsSS to be able to preprocess from Node/server side. You mind giving me some pointers on what I need to do to accomplish this? I'll definitely be exploring your code. Oh, and really, you should have named it JcssS ;)
Yes, [object Object] is a really nice book
What's the point of this functionality? If you want save/favoutire articles, then just use the already built in save functionality.
Cool! Some tips based on things that I discovered during my dev- * the Material ripples start on mousedown/touchstart, not a click event * you can have devices with both touch and mouse events (touch laptops), so install handlers on both, although this makes it tricky to dedup events
On windows you can create a shortcut that runs the app, and place it in your startup folder.
I think the same, but in case the app grows i want to be ready to handle that.
vein As in mining in rock. 
A Google Chrome extension to help you navigate Node.js projects on Github. Clicking on node require()s takes you to their Github project page, file, or a Node.js documentation page. Install directly from [Chrome Web Store](https://chrome.google.com/webstore/detail/github-nodejs-require-nav/ppkcefoejnbdgijdbbpnclfbnnfdfilj)
I'm experimenting with using /r/jmdugan as something like a blog space, but focussed much more on engagement and ideas sharing than ego-centric spot to spout ideas unidirectionally (the way I see most blogs). there are lots of things I'd like to chat with and about with a closer group of friends within a sub, so it's about making it efficient to post stuff there from other parts of reddit. each post will be 15-20 seconds vs 3 seconds. also interested because I want to explore how possible it is, tech curiosity 
Gracias!
Not if you want classic inheritance. Your example achieves prototypal inheritance.
http://brunch.io/ http://hexo.io/ http://www.metalsmith.io/
This is a great book. I started it today and am almost finished. 
Well, it seems I'm probably 6 years too late, then. Thanks for the warm reply, though. And please don't be offended when I say I didn't even notice there was a voting system before you pointed that out. I would probably fit in the C renegades category, I guess. More of an Objective-C-ish renegade, though... while I can totally see why most are usually attracted to the quicker, easier, more seductive C++.
It had some rendering issues a few months back, but most of those are fixed (and not really related to the HTML rendering engine from what I could tell ... it was mostly performance "enhancements" they were using like graphic tiling, etc.) For the most part, it's been just like Firefox on my Desktop as far as site compatibility. I use it over chrome because I got sick of Chrome constantly nagging me to sync bookmarks and crap all the time. Anyway, I keep using it because it mostly just works and I keep submitting bugs when I find them so that it can be better for everyone else. I wouldn't use nightly as the benchmark for readiness of your app, but the issue the page was having was a general Firefox/Mozilla MP3 issue so it could impact desktop as well.
Thank you for your kind comment. Factories actually saved my day until I mastered classes.
I remember when I was in school and OOP was still a decade from being widespread and probably a couple decades from being popular. But I never said I was JavaScript authority. If I was, I'd be probably emulating classes much earlier. I come from procedural programming, which was boring and difficult. OOP was already jailbreak for me. Studying it along with design patterns takes discipline and hard work but it surely pays off. OOP translates naturally from thought, if you know what you're doing. One perspective does not dismiss the other, though. But for me, personally... strong OOP is still the way to go. This whole new trend of "easier" paradigms can produce some artifacts fast, but can also lead to cheap, poorly-written software, which we already have plenty available.
JavaScript is a prototypal language. Classical inheritance does not exist, but can be emulated using the structure I mentioned. Your attempt at emulating classical inheritance needlessly instantiates parent classes to set up the prototype chain. This isn't just another way to do things, it's plain wrong and produces unexpected / unwanted behaviour. Consider your Parent() "class" does something upon construction, like binding an event to the DOM. When setting Child.prototype = new Parent(); You now call the Parent constructor, executing all relevant code, and binding a DOM event. This is unwanted behaviour --- we only want the DOM event to be added when we call new Child(); and Child has Parent.apply(this, arguments); in its constructor.
Thanks all for the great suggestions and making my commute better.
angular is pretty sweet...but I'm not too happy about the direction angular 2.0 is going....sans-js
Or just if(+age &lt; 13) 
Would recommend reading jQuery source to find out what it's doing. That's usually the best way to figure stuff like this out if stackoverflow doesn't yield you a satisfactory answer quickly.
haha, great! I intentionally went for the `document.body` approach: a global handler costs more in runtime, but adding specific handlers to every element feels painful in a different kind of way, and you have to re-run it if you modify the DOM. But it could work for you.
* https://staticsitegenerators.net/ * https://www.staticgen.com/ * https://github.com/pinceladasdaweb/Static-Site-Generators 
&gt; One perspective does not dismiss the other, though. But for me, personally... strong OOP is still the way to go. This whole new trend of "easier" paradigms can produce some artifacts fast, but can also lead to cheap, poorly-written software, which we already have plenty available. You would not think this about procedural programming. Procedural programming is more primitive, so there is (architecturally) less to get wrong as the application scales over time. In this same vein you can return back to a more primitive (safer) state of programming without sacrificing code reuse and modularity. This is both safer and faster. To presume some other approach must be poorly written, without knowing what that other approach is, represents a limited imagination.
Then just port it when later on, you'll just be wrapping all of your API code into whatever framework idioms whether you do it now or later.
should have turning spoke (?) in the holes too
http://bloggify.com?
I'm guessing you're the author? It felt way too choppy for me on chrome, would not use
Fwiw, I don't know how Firefox's add-ons work and am too tired to look it up but if you're not tied to FF, Chrome extensions are essentially javascript files in a pretty container. I write my own dirty extensions quite often and go the extra lazy and wasteful route of even using jQuery for most all of them. There are some good examples and documentation out there. Anywy, just tossing an alternative option out there in case it's of any help. 
I use https://ghost.org/ and another tool called buster https://ghost.org/forum/services/1667-static-site-generator-with-easy-upload-to-github-pages/ See the results here http://royka.github.io/
document.addEventListener("DOMContentReady", yourFunc)
Seriously cool, thanks! :)
Neat! Can anyone suggest a good open-source XMPP server?
I would have gone with var ifHemingwayWroteJavaScript = { name : "If Hemmingway Wrote Javascript", book : function () { console.log('I highly recommend the "' + this.name + '" book.'); }; };
Yes, I would. Like you said, procedural programming is still used, so that perspective has never been discarded, indeed. Procedural is perfect for small CLI tools, for example. I never said some other approach "must be" poorly written, I just said it "can lead" to it. Too much imagination on your part, perhaps?
That's the accepted answer, but is a controversial answer having 233 upvotes and 119 downvotes.
I would never have even thought about writing that material if it didn't work. I have been writing tons of JavaScript code which is running for years using those exact same techniques. They are so solid they can run on very old runtimes as well as the new ones, completely unchanged. It's not an attempt, it is an evidence. That's why it was written in the first place. Yes, you can emulate classes on JavaScript using the structure I mentioned, indeed. Enjoy! Why would anyone ever bind a DOM event in a parent class' constructor?! You can't blame poor design on classical OOP. Again, there's no unexpected behavior if you know what you're doing.
Nice work :) I should point out that lines 13-15 (x.toString()) don't actually do anything though.
The interesting snippet for that is here, from [the jQuery GitHub repo](https://github.com/jquery/jquery/blob/master/src/core/ready.js); jQuery.ready.promise = function( obj ) { if ( !readyList ) { readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called // after the browser event has already occurred. // We once tried to use readyState "interactive" here, // but it caused issues like the one // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15 if ( document.readyState === "complete" ) { // Handle it asynchronously to allow scripts the opportunity to delay ready setTimeout( jQuery.ready ); } else { // Use the handy event callback document.addEventListener( "DOMContentLoaded", completed, false ); // A fallback to window.onload, that will always work window.addEventListener( "load", completed, false ); } } return readyList.promise( obj ); };
Looking into the source you can see they always use `window.load`, albeit access via `window.addEventListener("load", func, false)`
Remnants, deleted. Cheers.
Hi, author of converse.js here. I use and recommend Prosody. It's written in Lua, which is a very fast scripting language which looks similar to Python. It's easy to set up, has a good selection of plugins and a great community. http://prosody.im/ Edit: The conversejs.org XMPP server runs on Prosody.
Have you looked into using Webpack as an alternative? It's fairly easy to set up multiple entry points and output different bundles.
"Time passes faster as you grow up", version: http://codepen.io/egeozcan/pen/JoXwyo
I did a [similar clock](http://clock.tuxkowo.fr/) few years ago, my code was... ugly. However, I didn't simply used time as hex (currently it is 13:57:42 here, so your code will use #135742) but converted it to an hexadecimal value. It would currently look like #90f69b, #000000 at midnight, and approching #ffffff at 23:59:59. 
Very cool, you could get a different variety of colours out of it using rgb(x,x,x) and scaling. var hex = "rgb(" + Math.floor(hours*10.625) + "," + Math.floor(mins*4.25) + "," + Math.floor(secs*4.25) + ")"; Although it does give a much more visible change.
Let's create a list ;) * http://www.jacopocolo.com/hexclock/ * http://whatcolourisit.scn9a.org/ * http://thecolourclock.co.uk/
http://whatcolourisit.scn9a.org/ (original?) Well this looks familiar... Not sure why jQuery is being used. Seems like a bit of a waste
assigning event listeners like this is a really, really awful idea. window.onload = function() { console.log('this never gets called'); } window.addEventListner('onload', function(event) { console.log('this never gets called'); }); window.onload = function() { console.log('this gets called every time') } attaching event listeners through assignment overrides all previously defined event listeners for that event. ALWAYS use addEventListener.
Isn't `setTimeout(function(){ dotime();}, 1000);` the same as `setTimeout(dotime, 1000);`? And wouldn't `requestAnimationFrame` be even better fit here, as that prevents unnecessary loops when not focused?
The drag and drop api in the browser 
Interesting! Here's a quarter on me /u/changetip
/u/bwd1992, keinur wants to send you a Bitcoin tip for a quarter (719 bits/$0.25). Follow me to **[collect it](https://www.changetip.com/collect/260296).** [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
Think of semicolons like the periods at the end of a sentence. They signify the end of one line of code. I'm going to share a link, but I encourage you to always use semicolons at the end of a line of JS code, even if it's "optional." It helps minimize errors and it's a good habit to get into, particularly when you start using strict mode. http://www.codecademy.com/blog/78-your-guide-to-semicolons-in-javascript
But not compatible with smartphone browsers. 
It's pretty poor. You can't make elements follow the mouse – only images. And there is no drag to edge to scroll in FF.
Try the partition-bundle plugin for Browserify. It splits your code into different entry files and a common modules file. It also includes scripts to asynchronously load your bundles. I also answered your SO.
http://www.html5rocks.com/en/tutorials/dnd/basics/
You could do this without jQuery. Also it would be cooler if the time was converted. 
Thank you. It seems like it actually has a chance to work. I will test it asap.
Yes to your first question: you can pass the function in directly. To your second question: if something has to happen every second, on the second (like a clock face updating), and you don't need to be concerned about performance, I find setTimeout better. If you used RAF, you'd need some additional code to track whether a second has gone by, and things get a lot uglier. Better to take the theoretical performance hit to make the code more readable.
[OpenFire](http://www.igniterealtime.org/projects/openfire/)
Can it connect directly to XMPP or does an intermediary server also has to be setup? EDIT: Never mind, [I found my answer](https://conversejs.org/docs/html/setup.html#what-you-will-need).
Here's the same thing but with the values normalized so you don't get the weird color transitions http://codepen.io/anon/pen/OPNdrY
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**JavaScript Style Sheets**](https://en.wikipedia.org/wiki/JavaScript%20Style%20Sheets): [](#sfw) --- &gt;__JavaScript Style Sheets__ (__JSSS__) was a [stylesheet language](https://en.wikipedia.org/wiki/Stylesheet_language) technology proposed by [Netscape Communications Corporation](https://en.wikipedia.org/wiki/Netscape) in 1996 to provide facilities for defining the presentation of [webpages](https://en.wikipedia.org/wiki/Webpages). It was an alternative to the [Cascading Style Sheets](https://en.wikipedia.org/wiki/Cascading_Style_Sheets) (CSS) technology. Although Netscape submitted it to the [World Wide Web Consortium](https://en.wikipedia.org/wiki/World_Wide_Web_Consortium) (W3C), the technology was never accepted as a formal standard and it never gained much acceptance in the market. Only [Netscape Communicator](https://en.wikipedia.org/wiki/Netscape_Communicator) 4 supported JSSS, with the rival [Internet Explorer](https://en.wikipedia.org/wiki/Internet_Explorer) [web browser](https://en.wikipedia.org/wiki/Web_browser) choosing not to implement the technology. Soon after Netscape Communicator's release in 1997, Netscape stopped promoting JSSS, instead focusing on the rival CSS standard, which was also supported by Internet Explorer and had much wider industry acceptance. The follow-up to Netscape Communicator, [Netscape 6](https://en.wikipedia.org/wiki/Netscape_6) (released in 2000), dropped support for JSSS. It now remains little more than a historical footnote, with many [Web developers](https://en.wikipedia.org/wiki/Web_development) not even being aware of its existence. The proposed standard was not finished. &gt; --- ^Interesting: [^List ^of ^stylesheet ^languages](https://en.wikipedia.org/wiki/List_of_stylesheet_languages) ^| [^Safire ^\(software)](https://en.wikipedia.org/wiki/Safire_\(software\)) ^| [^WebApp.Net](https://en.wikipedia.org/wiki/WebApp.Net) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmvl95l) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmvl95l)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
"Why would anybody do X!?" is not a valid response to a criticism. The fact that I can so easily come up with an example of your code producing unintended behaviour from a developer's perspective is proof enough that you shouldn't do it. The fact that the solution to the problem I proposed requires changing *only one* line of code and uses prototypal inheritance as intended is a strong indicator that it should be the preferred method (and is indeed the correct pattern). How you use this knowledge is up to you.
You can run these on github pages? &amp;#3232;_&amp;#3232;
I look the feature list and I didn't see anonymous user support. I think it very useful for users whose haven't yet xmpp account.
https://github.com/angular/angular/issues/249
You're right but technically since jQuery is written in javascript you could do anything that's currently in jQuery without jQuery so it's not much of a statement.
While it doesn't really matter when you have something as trivial as this, if you're calling a function lots of times, it might be good to cache the elements instead of finding them again every time you call the function. 
Feel free to fork it and show an example.
Hey man, thank you. Sweet, almost looks too good to be true. Funny that I've never to this point heard about it. Also nice to see Ebay putting effort into open source goodies. How does it play with Gulp though? Also, is watchify-style reloading with caching possible? 
[k](http://codepen.io/fakealias/pen/WbwmRx)
I prefer your method. I'd rather pass easily through the entire spectrum at a constant rate rather than have 'jumps' in color on the hour (and also miss out on some colors).
They're all static site generators so, yep, they can be hosted on GH Pages.
[docpad](https://docpad.org/) is my personal favorite. 
I build [farbuhr.de](http://farbuhr.de) a while ago after seeing the last one in your list.
cool effect but there's already a popular framework with the same name "ripplejs" https://github.com/ripplejs/ripple
But the initial solution doesn't happen on the second - it takes (code execution time + 1000ms) for every tick. Very small, but non-zero drift :) Also, there is no need to re-draw on the dot as long as you are basing on system clock and not on some internal counter incremented along with animation - just grab the current clock value and draw with it as often as the browser allows you to. The browser knows better - it can disable updates when out of focus, or throttle them when battery runs low, and your code doesn't have to deal with that.
I made altered the example to [this](http://codepen.io/anon/pen/ZYWPdj), as a alternative version mapping to the full rgb range as you described.
This article is a long and rambling way of saying "the primary data needed by a function should be provided as the last argument". This allows functions to be curried/partially applied in order to build up a composed set of meaningful functions for doing the work in your application. In general, this usually means that higher-order-functions will take, as arguments, their constituent functions in positions other than the last. I think people using terminology like "callback" should be aware of the interpreted meaning of the words that they choose. Callback typically means "function fired asynchronously at some point in the future" and not "function provided as argument to synchronously executing higher-order-function. EDIT: It's worth mentioning that Reg's book on this topic (a fucking excellent book) explains this concept in the way I have expressed it. His focus is on the implications of providing data as late as possible in the argument list to facilitate partial application.
Such as in https://github.com/ramda/ramda
Yeah, use of the term "callback" confused some people. But what other term would you use? I've used "iterator", but it can be confused for actual iterators from other languages (and ES6). "iteration function"? "constituent function"?
Depending on the use, these are sometimes called "accumulator functions", "reducing functions", "predicate functions", etc. I am actually skeptical of the value of USING the words I just listed as they generally are less reliably meaningful to JS developers. Instead, I would describe what it is and avoid calling it what it "isn't"; namely, a callback.
I also have coded a version of the same idea a few months ago after seeing another version of this idea. http://jsfiddle.net/6czt7938/3/
The paragraph... &gt; Nice, but `filter.call` is an immediate call. It cannot be passed around, or composed with other functions. So let us write separate `filter` function ...is followed by exactly the same situation with... console.log(filter(numbers,isEven)); ...which is still an immediate call to `filter`. In fact, it then turns to composing `isEven` with `not`, so it kind of makes no sense to talk about `filter.call` not being composable. It would make more sense to introduce that `filter` implementation just a bit later, when talking about binding `filter` (which then leads to the point of the article).
Hmm.. I don't know what you mean? function Color (r, g, b) { this.r = r; this.g = g; this.b = b; } var colors = [ new Color(255, 0, 0), new Color(0, 255, 0), new Color(0, 0, 255), ]; colors.forEach(function(color){ console.log(color); }); //==== OUTPUT ==== //=&gt; Color {r: 255, g: 0, b: 0} //=&gt; Color {r: 0, g: 255, b: 0} //=&gt; Color {r: 0, g: 0, b: 255} 
The keyword is *enumerability* or *enumerable property*. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
What about this? function Color (r, g, b) { this.r = r; this.g = g; this.b = b; Color.instances.push(this); } Color.instances = []; var red = new Color(255, 0, 0); var green = new Color(0, 255, 0); var blue = new Color(0, 0, 255); Color.instances.forEach(function(color){ console.log(color); }); //==== OUTPUT ==== //=&gt; Color {r: 255, g: 0, b: 0} //=&gt; Color {r: 0, g: 255, b: 0} //=&gt; Color {r: 0, g: 0, b: 255}
This (ab)uses decimal values as hexadecimal. Plus: the range you can get is extremely limited because the upper value you can get is quite low, especially for the hours. You'd get a much wider range if you'd multiply with 256 and divide by 60 for minutes and minutes and 24 for the hours; or multiply with 255 and divide by 59 and 23 respectively. Like: document.body.style.background = 'rgb(' + Math.round(d.getHours()*256/24) + ',' + Math.round(d.getMinutes()*256/60) + ',' + Math.round(d.getSeconds()*256/60)+')'; or document.body.style.background = 'rgb(' + Math.round(d.getHours()*255/23) + ',' + Math.round(d.getMinutes()*255/59) + ',' + Math.round(d.getSeconds()*255/59)+')'; 
&gt;Not sure why jQuery is being used. Not sure why Coffeescript is being used.
I guess like most things, dependent on the users computer, but felt smooth to me on Chrome 39.0.2171.9
are there any hardware based hex color clocks? I have a single RGB and I thought up of way of using just RGB values, but using HEX colors would also work! 
If you're going to go that route though, I still think it's nicer to put the callback after. It's more logical in the order of what happens. Although this is obviously subjective.
Yesss, this is exactly what I needed. I could have sworn I tried array[array.length] = this; but I guess I didn't. Thank you very much for taking the time to write 2 replies and helping me with the problem. 
I did need what ChaseMoskal wrote, but I would still like to thank you very much for taking the time to write all that out, explaining and trying to help out with my problem. I really, really appreciate it, thanks again. Hope you have a great day
I see what you are saying, but I still think you are missing the point. You are correct that what I described is a form of encapsulation. Closures are a form of encapsulation, but they are not the same thing as encapsulation. Using anonymous, self-executing functions is the javascript module pattern, which is utilizing closures to achieve encapsulation. While the terms are all related, they are not the same. Using prototypes is another form of encapsulation in javascript, the prototype is not itself a function, so it cannot be a closure.
The benefits of callback first aren't semantic, though. Auto currying/partial application is possible with callback first.
You need to re-read the article because you're misunderstanding its main point.
Golfed clock (working in chrome + firefox): http://jsfiddle.net/ffLct/6/
Hi /u/hixsonj, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
It's okay, but I'm not a fan of prototypes. Their shared nature is problematic when dealing with non-scalar types, or having abstract types with private state. I would rather use parasitic inheritance or decoration compositors. Actually, I'd prefer to use composition full stop. Inheritance is a misused tool, particularly amongst less seasoned developers. POJOs themselves are fine, although it would be nice if you could guarantee the order of iteration, and iterate through the members of an object natively without having to do checks to hasOwnProperty. As for implementing classical object taxonomies in JS, I think ES6 'class' is a bit of a problem waiting to happen. It's a sugar for a prototype system that doesn't work in the way that developers coming from C++ / Java will expect. I think Douglas Crockford has already declared it one of the Bad Parts of ES6.
And here's [a Mac screensaver](https://github.com/Jonic/WhatColourIsIt-ScreenSaver).
This is convenient, but not great because now you keep a reference to the object, and the garbage collector won't clear it up when you no longer need it.
Isn't any book about Domain Driven Design sufix?
His approach actually have jumps (example, black to white in midnight). Actually walking the spectrum would need to represent the color in something like HSV, and increasing the hue.
Why did you multiply by 255 in hex_ variables?
I had no idea Object.keys even existed. I guess because it isn't supported in IE8 it's not usually mentioned. I'd always just used my own forEachObjectOwnProperty util function instead. Good to know about.
Beaglebone Black does it.
Does it do accurate math? Take care of corner cases, rounding, etc?
Neat. This got me thinking of how to map the times to hex values in such a way as to match the day/night cycle (only dark colors at night, only light colors in day, favor reds at sunset, favor yellows at sunrise). Maybe someone else will be more motivated to come up the implementation...
One of the pitfalls is that you need to make sure you aren't chaining a huge number of promises, because a good implementation will only resolve one per application "cycle". That means making a highly recursive function using promises will have horrible performance. See [this article](http://thanpol.as/javascript/promises-a-performance-hits-you-should-be-aware-of/) for a detailed explanation. Edit: also, debugging async flow can be a huge pain as debuggers really haven't been built with callbacks in mind. If you want to follow execution you'll need to litter all your callbacks with "debugger" statements or equivalent. It can be done in real time, but is a lot less convenient than a classic flow.
very nice, he even got the music and sound effects going!
Tx.
Most implementations today have typed arrays available (eg. real, contiguous chunks of memory with efficiently packed native types). ES7 has Typed Objects which will allow a broader set of primitive types as well as allowing the developer to compose these primitive types (including pointers to non-primitive types) into structs that can be efficiently packed into memory buffers.
Order of iteration was clarified in ES6. It is now precisely defined for the own properties of an object (so eg. Object.keys will always give you a defined order). You still have to deal with implementation defined behavior when enumerating prototype properties using for-in however.
Not precisely. Enumerable attribute dates back to ES3.1 at least (where it was called DontEnum). The problem has always been that the order you visit enumerable properties is up to implementations. Thankfully, for ES6, the ordering of own properties is precisely defined, so Object.keys will give you a deterministic, interoperable ordering. However, for-in loop will still give you implementation defined behavior in a few cases.
Interesting, I was not aware of this. I imagine there's not a lot of ES6 written these days due to legacy projects, but the fortunate few are transpiling for ES5. Is that the case? There are so many improvements in the new standards..
What is your reason for choosing those tools specifically? PHP is a programming language used largely for scripting web sites out. It's generally disliked for a variety of reasons. It's also in fairly heavy use still. There is little reason to use PHP, that I know of, outside of employment options. Which in my experience PHP dev tends to be on the [lower end of pay](http://www.indeed.com/salary/PHP-Developer.html) and at generally less "cool" companies. That isn't to say that all PHP dev jobs are shit, Facebook, MailChimp, Auttomattic, Zynga, Yahoo, et cetera all use PHP and are probably pretty awesome to work at. NodeJs is a tool to execute JavaScript. It's just a JavaScript run time. Stack wise it would probably occupy the same or similar space as PHP+(Apache || NGINX). So, this is the JavaScript reddit, and I'll be honest, JavaScript is probably my favorite language. I would say use NodeJS in place of wherever you were planning on using PHP unless there is a specific something that draws you to PHP. If you're just looking to add languages to your resume, I'd check out any of these: * Ruby * Generally well liked language due to its expressiveness. * [the pay trends higher](http://www.indeed.com/salary?q1=Ruby&amp;l1=) * t[hough the market has slowed](http://www.indeed.com/jobtrends?q=ruby&amp;l=&amp;relative=1) * JavaScript/NodeJS * Simple language with a lot of room to choose-your-own paradigm, will you go functional, PrototypicalOO or will you try to shoehorn in Classical OO? Turn to page UNDEFINED IS NOT A FUNCTION * Similarly the pay trends [upwards](http://www.indeed.com/salary?q1=nodejs&amp;l1=). ^though this is cheating, using only javascript the salary falls down to $92k. * [Market is uppish for this language.](http://www.indeed.com/jobtrends?q=nodejs&amp;l=&amp;relative=1) # Or get weird with it. I feel like the merits of JavaScript and Ruby are commonly known enough that they didn't need much explanation outside of * [Clojure](http://www.quora.com/Why-would-someone-learn-Clojure) * Lisps are cool. In my opinion they look really pretty. * Clojure is a Lisp for the JVM that gives you options to use some Java libraries. * It includes a compile-to-JS Clojurescript that makes it easier to avoid context shifts. * The clojure community is pretty cool. They've built some neato libraries that integrate with ReactJS and Flux type architectures like OM. * It's a functional language, so if you're into adding some new skills that'll definitely sharpen you up right quick. *[ Salaries tend to be high](http://www.indeed.com/salary?q1=clojure&amp;l1=). * It's in less demand than some of the bigger languages, but it still has [growth](http://www.indeed.com/jobtrends?q=clojure&amp;l=&amp;relative=1). * Go * Google's Better C. * I don't know much about Go, but the people who like it like it a lot. * Getting job growth and salary stats turned out hard because the word Go was included in Retail, entry level IT and etc. * Haskell * Purely functional language * At this point I'm getting lazy. Google stuff. * Again if what you are looking for is learning, this is a perfect choice. Lastly. You mentioned being experienced with MS SQL, why head into MySql land then? If you're already familiar with a SQL database it doesn't make complete sense to me to learn MySQL. If you want an open source alternative, I'd recommend Postgres. Disclaimer, I'm not a DBA, I stay more with MongoDB and most of my sql experience has been limited and dependent on ORM's. The people who like Postgres, love postgres, they talk about it all the time, and it's supposed to have mad performance in comparison to MySql, and it's JSON performance is allegedly even better than MongoDB. Speaking of, if you're looking to pad the resume, why not get weird with your database choices? Check out Neo4J, FoundationDB, MongoDB (which is less weird), or OrientDB. All of these tools, languages, or databases will fit your need. Now I may have paralyzed you with an assault of options. So I'll give my full on recommendation for the question you asked. If you want to do a text based Sim game, you would do well with a Node stack with the following: * NodeJS Run Time * ExpressJS. A simple Sinatra style MVC framework * MongoDB or Neo4J. * Neo4J if you're feeling adventurous. It would force you to learn a lot about how to store data in a graph, it sounds like a decent use case for it. Lots of connected players, pieces, et cetera. * MongoDB, it's document based and schemaless. That makes it easy to test, toy around with, and depending on how you set up your games world you might not end up with that much relational data. You could store all of your players inventory, cities, resources on the player itself for instance since it's unlikely other players will need to interact with them outside of transactions with the player. * ReactJS - Front end UI framework. Really performant, fun to work with in my opinion. If you're doing something more graphical, I don't got shit for you really. I've heard good things about Famo.us, and I'm sure there are a ton of libraries for it. Check out any of the awesome-&lt;lang&gt; git hub repos for cool shit. 
Have you considered mapping all possible hex values to all times? That way, it would look more colourful.
Not true. Your info is out of date. http://spion.github.io/posts/why-i-am-switching-to-promises.html
The jumps are interesting to watch. 
This will sound dismissive, but I promise it's an earnest question. Why aren't you doing that work in a natively compiled language if performance is so critical for you? Is it an existing codebase or a yearning desire for that capability in the browser? I'm fascinated by the idea of server driven, single page web-apps, but I'm still not convinced they can deliver parity with traditional, locally installed application bundles. I'm searching for dissenting opinion.
I thought Firebase was pretty awesome, so I wrote a widget to show what song I'm currently listening to on Pandora. It updates in real time.
Mostly you should use promises. Some instances where you might not want to: - if you are dealing with something that is better suited with event emitters or another async pattern - debugging promises can be a pain, particularly if you're working with Browserify (or another bundler) as Error.stack source maps doesn't yet seem to be supported in most browsers - if you're writing a focused and generic async module (see "img" module on npm for example). In that case it might be better to use node style callbacks and let applications promisify your function to avoid vendor lock in and increased bundle size - handling promises across modules/libraries is generally kinda annoying 
Spoiler alert, its pretty much blue or green the whole time
[plasio](http://plas.io/) decodes compressed point clouds in the laz format inside WebWorkers. I've used the decoder in my own point cloud viewer where decompression as well as parsing the resulting byte stream is done inside WebWorkers. The WebWorkers are necessary here in order to ensure a smooth user experience because this process takes about 20-200ms for each of the up to thousands of nodes. See this examle: http://potree.org/demo/potree_2014.11.30/examples/ot_indiana_statewide.html
Yes! For delegating CPU intensive work to the client on a node app. The app in question never saw production for unrelated reasons but it worked quite well. We used websockets for two way communication.
What are you trying to say? Your link confirms both of my arguments.
The statement about only on resolve per "cycle" is correct. [It's required by Promises/A+](https://promisesaplus.com/#point-34). How exactly that affects performance I don't know though.
It's a very specific use case. But you can't use Promise/A+ promises inside a IndexedDB transaction.
Perfect!
Love of the game man! I know browser technology very well and I have always been interested in game architecture. I decided that I would take it upon myself to TRY to bring the best of managed memory, pre-allocation, and contiguous memory to a very hostile environment. I'm doing it mostly because it's fun to try. Incidently, I livestream my game engine development at twitch.tv/kanesteven everyday. During that stream I explain everything I'm doing and why and I include a fair amount of commentary on questions like yours. The main reason people report unsatisfying experiences w/ browsers is that too many graphical aspects of the browser are not hardware accelerated (by naive default). Take a look at a project called famo.us if you want to see where I think the web is going. I have some serious beef w/ design/api choices in famous but I think they have hit the nail on the head as far as trajectory is concerned.
Could be good for client side processing of sensitive data you don't wanna send over the wire.
I once needed a ZIP library and compared two options. The one using web workers provided a much smoother browser lag free experience.
Pathfinding is a good use case.
Used them for filtering a large array of objects on a key of the objects. Went from very slow UI updating to almost instant.
I've seen a Emscripten'd libjpeg used in a web worker to resize images client side before uploading :) 
I made an app that read and parsed client-side log files. Tens of thousands of files could be processed without incident (usually)
Or just `setInterval`. Also, stop hating on the best way to write JS.
Not really. You could use something like AES/RSA with a client side key. That's effectively what SSL does anyway, but there might be scenarios where you'd want to do this on an app level. 
Because I represented hours, minutes and seconds as red, green and blue. I wanted to have a percentage of 0xff (or 255) the max value for each color component.
Calculating arbitrary fibonacci numbers. Didn't really help the client much, but it did help my resume.
Well the black to white jump is completely cool, since it would mark the beginning of a new day.
The details are proprietary so this will be vague, sorry about that. The client would aggregate data from a couple of legacy sources, this data would then run through a couple of algorithms that inflated and translated parts of the data, the operation took around 10 seconds for common cases and about 30 seconds for a couple of corner cases. So when the client wants to run the procedure, critical parts of the data (essentially a header of each dataset) are sent to the server. It verifies that the datasets are valid then gives the client the OK to process it. This would trigger the calculation in a web worker, on completion the computed data is sent to the server for further processing by a legacy system. It sounds a bit convoluted, but the implementation was clean and it worked very well. We had limited server resources and worked under very peculiar circumstances, I would probably not use node for cpu-bound tasks if I was given the same assignment again.
Haha, I wish!
Yeah. I wrote a [fractal browser](http://www.leshylabs.com/apps/fractalExplorer/) that supports dividing up the workload of calculating the fractal over a number of web workers. I found them very pleasant and easy to use, and definitely effective. The fractal browser actually tries to calculate how many workers to use dynamically, though I've failed to find a test that works consistently well in each browser. It seems like the most flexible option is to let users specify the number of web workers to use. **EDIT:** I just noticed there was a pile of traffic from this post, so I rolled out an updated version of the fractal browser. The new version does stripe average coloring as well. Here are some [examples](http://www.leshylabs.com/apps/fractalExplorer/examples/)
Min/max algorithm for a Reversi game [yaks.co.nz/reversi/](http://yaks.co.nz/reversi/)
Digging bitcoins ;) https://github.com/jwhitehorn/jsMiner
Maybe check more about Communicating Sequential Processes - http://sriku.org/blog/2014/02/11/bye-bye-js-promises/ Some pure JS implementation - https://github.com/brophdawg11/JsChannels
I wrote a web front end to an optimization library for a DSL. Optimizing was intensive enough that web workers turned full page lockups into buttery smooth (and slightly delayed) goodness. 
This looks awesome and I'll definitely check it out!
You might check out golden-layout: https://golden-layout.com/ It's fairly new (a couple months by now, I think), so you might step with caution.
I agree with that, but the colour jumps every minute, I'm not sure about. I sort of like it but I sort of don't.
I wrote [this](https://roryhaddon.com/niceJson/) a few years ago, but it uses web workers to parse JSON and render it nicely in HTML. If you give it a large JSON object you can see how it does not stale the page as it's showing it's progress.
I am a big fan of it and I am worried about over-engineers hijacking the spec sometime in the future (see Type$cript by Micro$oft). JS is made primarily for web UI development which is not really a Computer Science field and perfectly suited for that. I would prefer it to stay that way.
they make my coffee in the morning.
is there another video somewhere showing how work is done with the tool? this one looks good but kinda like an animated proof of concept, it would be interesting to see * how well the collaborative document functionality works in terms of delay, * how the gesture system is usable for real situations and * how it looks without models smiling all the time :) nonetheless one of the best collaboration concepts ive seen
Working with REST API with node.js (making an old school BBS) and all DB-Write are going directly in a queue with some web worker to do the job. This method allow you to do some very nice "Batch/Bulk insert", you don't need to write one by one anymore. 
I use it in [Doctored.js](http://holloway.co.nz/doctored/) to run asm.js compiled XMLLint to JS. It's long running code that locks up for few seconds, so I use web workers to ensure that this doesn't lock up the UI thread.
Graph layout using [Dagre](https://github.com/cpettitt/dagre). Using a web worker stops the frontend freezing while it computes the optimal layout for the nodes (100s of ms for large graphs).
Oh thats right, I completely forgot about that. Thank you!
shouldnt the title be time &lt; hex color? 
oh awesome. i didn't even know netflix had a UI engineering channel!
Asynchronous encrypting
I actually did this once. Using react js and marked I rebuilt the ghost editor. In github's preferences they give you a developer api token meant for testing apps. I didn't hard code the token into the site for obvious reasons - but I used a login input and local storage to save the key. This allowed me to commit the markdown in the proper folders for Jekyll within the gh Pages blog itself. (Also added the yaml metadata). Next, I used the markdown parser to render the jekyl blog just like jekyl would - just with browser js. And yes, it was faster and more customizable than jekyl once I reached this point. I used reactjs and marked- it was probably my first react project. I hadn't even used browserify at this point. It was a fun experiment - I learned a lot. Basically react web components can replicate what Jekyll would have been rendering. I wouldn't recommend my experiment over Jekyll - but the markdown writing integrated with github was very nice :)
I use it to decode GIF files in my Chrome extension [Play the GIF](https://chrome.google.com/webstore/detail/play-the-gif/mchecalpedamcfhiadokofgomojakmki).
Why wouldn't you use browserify or jsx? How is that not an option? I could provide advice on how to integrate browserify into the angular structure... But it's not an option so I won't. Good luck.
Man just realized lodash v3 has been baking for over a year now.
The standard (err, result) is what's being used behind the scenes in all node applications. If you get the hang of using the async module, then you'll never even think about chaining your methods together.
Sounds interesting. Is it open source? Could you post a link?
Do you have a link? That sounds perfect for a project of mine!
Useful for sandboxing
Apparently you need to do a little more [research] (http://kangax.github.io/compat-table/es6/). The technical preview of IE supports 72% of the spec, which is more than any other browser as of this writing.
Don't wrappers like localForage solve for that?
The point of the article was that having the semantics `fn(x, cb)` limits your ability to curry or partially apply, because you have to do it from the right-hand side. When you change the semantics to `fn(cb, x)` you also make it so that you can partial apply from the left, and partially apply with other partially applied functions, without the functions earlier in the chain needing to know how many right-hand partials it can make before smashing a parameter. 
HA
The problem I have is web workers is that they were designed to address use cases that don't really apply to the majority of web apps. The major performance issue for many apps is still DOM manipulation, which must still be done in the main thread.
I have used client side encryption to embargo information until a particular moment in time. Everybody gets their own dynamically generated encrypted packet and then at midnight a decrypted key appears as a static file on amazon S3.
You in no way had to go through this much trouble but you did! You're awesome! You've given me a lot to consider! I'll be sure to update with what ever happens! Thanks!
Not sure if OP was interested in CoffeeScript, but interesting nonetheless.
Maybe this can help? http://mozilla.github.io/pdf.js/
I'll check in on the streams, sounds super interesting. Best of luck to you.
Did you compare this process to using canvas to resize the image?
I use them in running prisoner's dilemma simulations: http://eborden.github.io/evolution-of-cooperation/
I'm not sure that's a problem. WebRTC, WebSockets, WebGL, pretty much all the Web* APIs are the basis for the next generation of web apps. I'm not sure it's fair to claim that their standardization is a problem because web apps of today don't benefit from them. 
Use a factory. This mutates the config argument, which may not be ideal, but is easy: function polygonFactory(config) { config.fillColor = '#770077'; config.color = '#770077'; return config; } var area = L.polygon([35.52077032969566, 35.7792305946], polygonFactory({ stroke: 1, fill: 1, weight: 5, opacity: 0.5, fillOpacity: 0.05 }));
anyone try it yet?
A regex-inspired route: var each_single_digit = /\d/g; function square(n) { return (+n) * (+n); } function squareDigits(n) { return (''+n).replace(each_single_digit, square); } I use the shorthand `+(n)` to convert a string to a number. It isn't necessary in this case, because `square` is only being passed number-like strings, which the multiplication operator deals with perfectly well, but it makes it that tiny bit more robust. I also use ('' + n) to convert a number to a string. `each_single_digit` and `square` can be brought inline as part of `squareDigits`, but naming them as variables makes it incredibly intuitive what is going on.
No. Nothing can solve that. It's inherent to how IndexedDB transactions and promises work. Also localForage has way more to do with localStorage than with IndexedDB. It's almost exactly as limited as localStorage.
Lets say you have a list of email addresses that you want to hash, but terms stipulate that you cannot send these email address over the wire. So you hash them using a worker.
custom elements = custom code 
So, a co-worker has offered to donate a older (2000-2010 probably) PC. I've got some spare parts and after I see how much juice I can squeeze out of it my plan to to build it into either a Debian or CentOS server (your thoughts on this, I'm open to other OS's, they just have to be free). And then build the application using Node.js and MongoDB (it's been on my list of to-learns). You suggested ReactJS, and that does seem interesting. Why that over BootStrap or even Foundation? 
Number crunching. Whenever you have to do stuff that has some long and blocking operations in it, you want to put it in webworkers in order to not block the DOM. 
ReactJS isn't an alternative to Bootstrap or Foundation, they don't occupy the same space. ReactJS occupies the space of Angular directives, much of jQuery, or Backbone views. They share similar qualities of web components. Debian or CentOS will serve your purposes. It really depends a lot on your focus too, do you want to be a linux administrator or just know how to navigate it when you need to. My philosophy tends to be one of specialization personally, I don't bother diving too deep into SQL because I know I don't want to be a DBA. I do my best to learn the best practices and do my best to pay attention to the space but I don't need to worry about tips and tricks to optimize because ideally I won't be optimizing them. Same goes for Linux for me. I use OS X, most of my applications are deployed either to a PAAS like Heroku, or if they are small they go to an Ubuntu box on Digital Ocean. At my day job we have a guy who handles the administration of our servers so I don't need to do much with it, when I do need to it only requires the basic navigation. It's a time issue really, you can only learn so many things, so what do you want to prioritize? Any machine that can run a recentish version of a Debian or CentOS distro will do fine in the realm of dev in my experience. I'd check out ElementaryOS, if you're planning on using it as a daily driver PC, it's an Ubuntu offshoot if I remember correctly, so it's a child of Debian at some point. CentOS will give you more enterprise stre...boardroom cred if you do more than navigate it. https://github.com/sindresorhus/awesome-nodejs https://github.com/enaqx/awesome-react
Why is this a 12 minute long video?
Absolutely. I used web workers to implement non-blocking client-side md5 calculation of rather large files.
Okay, more and more questions. Here's just one: So then why ReactJS over jQuery? And I'd like to expand my skillset as much as possible, but all said any done JavaScript development is kind of my passion right now: Web, Games, Biz Apps, anything JS. 
&gt; You're using === all over the place but you should be using ==. wat
Not a lot of ES6 is getting written, relatively speaking, you're right. But transpilers are hot right now (Traceur, 6to5, Regenerator, etc.) and polyfills/shims like ES6-shim give you lots of the ES6 standard library in your ES5 environment. Not to mention that browsers are making great progress in implementing ES6 so you'll get to use it natively "soon"...
I was challenged to port this original thing http://thecolourclock.co.uk/ to JS, that's why I never tought of another way to represent color. It would be interesting to try HSV indeed.
 So if JavaScript dev is your passion now I'd recommend looking into using ES6. It's got enough sugar to give you diabetes. Don't use the new `class` keyword, don't shoehorn classical inheritance into JS. Better yet, don't use inheritance, use composition. So, yeah I said ReactJS and jQuery share a similar space and that requires some extra information because it's not 100% true. ReactJS is a View system for Javascript. It's far closer to WebComponents, AngularJS directives, or Backbone views. I compared it to jQuery because there are kind of two main usages for jQuery, AJAX and DOM Manipulation. React would take care of the DOM manip, while you'd need a different library for AJAX. I'd recommend [Superagent](https://github.com/visionmedia/superagent). Basically [React](http://facebook.github.io/react/) would be the interactive portion of your site, it would handle templating and view logic. It includes an optional JSX language which is sugar for creating React components. The best thing about javascript in my opinion is also the absolute worst thing. It's such a simple language with so little built in that the community had to create a lot of tools that would be present in a lot of other languages. For instance, up until ES6 there is no module system, even after ES6 the Node ecosystem uses CommonJS I'm not sure what the transition plan is so I imagine it'll be a slow process. There are a ton of tools, a ton of ways to do things, etc. So I can only give you my advice and the tools I use. I can point you in the direction of what to learn concerning what I personally use. But that's about it. *Originally I was going to link all of them but I'm sorry bruh I'm too lazy for that. Google will do you well.* So yeah, my little stack of tools^(theres an alternative to each of these...): * Browserify - Package up your client(browser) javacript into neat little packages, it keeps your client side code all modular and makes dependencies explicit. Easier to debug often. * Es6ify - I like ES6 for dat fat arrow function, sugary object literals, stuff like that. This lets me package up my ES6 and compile it with Traceur to run in other browsers. * Reactify - If you're using React and Browserify you'll want this to compile your JSX. **HOL UP** if you're using both ES6ify and Reactify check out my little snippet of code below for the order, I ran into hella issues setting them up before I realized order of plug ins was important. * Gulp - This is a task runner. It does cool shit. I can't get all up into it, trust it's useful. * Lodash - Super cool little utility that lets you play some functional games. Personally I want to get more into Ramda, but Ramda has a much larger API surface area, Lodash is cool and I use it in every project. * Async - Don't do async tasks in a synchronous manner, it's bad perfomance wise. * Mongoose - ODM for MongoDB. Is it needed? Nah. Is it helpful? Usually bruh bruh. Usually. * ExpressJS - Simple MVC * Bluebird - High performant promise library. Learn to use promises yo. Clean yo code up all nice and shit. * Superagent - AJAX/Request library. * Moment - JavaScripts DateTime is based on Java's DateTime. It's shit. Moment makes it less shit. * Passport - Dat Oauth life. If you're getting into the Node ecosystem all fresh and dewey eyed you should check out [SuperheroJS](http://superherojs.com/) gulp.task('browserify', function() { return browserify({ debug: true }) .add(es6ify.runtime) .transform(reactify) .transform(es6ify.configure(/.jsx/)) .require(require.resolve('./client/app.js'), { entry: true }) .bundle() .pipe(source('bundle.js')) .pipe(gulp.dest('./public/build/')); }); 
The input that changes the most should be the last argument while the more "static" input should be before it to enable partial application and composition. Functional programming 101 really. Edit: example: [subsequence-search](https://github.com/zeusdeux/subsequence-search)
javascript is the dream of write once, use everywhere...but it has issues...not being strongly typed is just one of them
I'm a young buck in the field, but having applications on the web and accessible company wide in a centralized location is pretty fricken slick. All the opensource libraries and how quick javascript is evolving makes it an interesting language to start up, as well as keep learning. 
That's cool if this is your article, but your probably shouldn't be serving a SPA for clickbait static content
Well, then please explain why OP would like to compare the references of lang and "chi".
Alright, wasn't aware my mind could be exploded this many times in one day.... It's going to take my months to feel solid with any of this... You have any hobby projects (perhaps in the ball-park of complexity I'm aiming for) out there? So I could see the results of traversing this library labyrinth. 
I would think that the majority of JS developers don't feel like its a "great" or "amazing" language. The bottom line is its the only choice you have for creating interactive web applications and as such has become a huge part of web developers lives. At first glance it can seem odd for sure, especially coming from a strongly typed, class based language. Its Portugal inheritance is a very different approach to OOP. If you want to see the "beauty" in JS then you'll have to do some digging. Start with "the good parts" by Doug Crawford and then look at how traditional oop design patterns are handled in JS. The books/guides from addy Osamni are great to check out for advanced patterns and enterprise architecture. Just my two cents
For what it is worth, I think you are right and I'm coming from the polar opposite perspective. I picked up javascript/programming two years ago and I find myself constantly migrating towards stronger and stronger typing as I just find the dynamic nature of javascript to be utterly useless. I don't mean this as trolling either. I mean I literally find the dynamism to be completely worthless for my use-cases. The ONE caveat to this perhaps is ease of parsing arbitrary and possibly changing JSON. Here I think, for obvious reasons, Javascript parsing JSON is the smoothest JSON experience and certainly convenient for HTTP API exploration. I write games in javascript as well and I constantly find that I wish I had more compile-time errors, more static type checking, more memory control, more contiguous memory data structures, and more functional purity. I wish partial application was first class. I wish currying was first class. etc. We are in agreement!
Yeah, like I said, that's the issue with the JS ecosystem. To me it's beautiful to have all of these options but it's terrifying at first. I can put something up later and send you my github. Don't let yourself get too overwhelmed. It's less then you'd think. I'll try to hook some stuff up for you later. Like, if I don't get back to you by tomorrow then I forgot, just send me a reminder. 
Awesome - well done! I like your other stuff too.
Because that's not what === does. == does typecasting, === doesn't. 1 == "1" is true, 1 ==="1" is false.
While we are at it - https://hurtak.github.io/colorclock/
Yup. Also, we've tried to migrate our physics engine in our game to a webworker and the marshalling times are way too variable to make it work in real time fluidly. Sometimes it'll take a millisecond, sometimes 100 milliseconds.
Typescript is es6 javascript with type checking. It is easy to use Typescript instead of vanilla javascript in most modern IDEs. Modern IDEs like Webstorm or Visual Studio provide some code completion for most javascript. If you use JSDoc @type annotations, you can even get some static type checking in vanilla javascript. Writing testable code, using a good IDE, making use of Typescript or making use of JSDoc type annotations removes most of the pain from working in javascript.
Small syntax. Easy to learn. No worse than ruby or python despite having much less syntax. Easy to deploy. 
I'm working on a project that runs against Mozilla's Spidermonkey only, so no HTML nodes or cross browser issues. With ES6 the code is concise and if you find the sweet spot where IonMonkey generates fast code, well it is fast too, unlike Python which needs external tools for speed. Although, I miss NumPy and wait for SIMD running native. A linter avoids most typos. Also, function inlining works most of the time, you don't loose speed by having many specialized functions. The big plus in my book is JS doesn't forces a structure on you. Want objects inheriting - works, don't like 'new' - drop it. Let's say ES8 adds macros and types what else could one miss? 
I don't think any other browsers have done this yet, but Chrome supports asynchronous call stacks, making debugging much easier than it used to be.
From what I've heard, canvas was fine for smaller images but more CPU intensive and locked up the browser when processing very large images (eg photos from SLR cameras). I guess it may do some of the processing on the main UI thread. 
Portugal inheritance lol.
Yup - Construct 2 (www.scirra.com), our HTML5 game engine, runs A* pathfinding in a web worker so it doesn't hit the framerate.
haha - i was on my phone
I agree with you that it's a meme, but it's not completely unfounded. Having worked on 100K+ LOC apps, it's extremely important to be disciplined in your approach to reasoning about types. Maintainable, legible code will almost never use ==.
I'm not going to get into the details about why it's popular, you probably already know the reasons for that. I assume you're interested in what's really good about it for developers. There's two answers to that question, to two different demographics. The ones who learned to use Javascript properly, and the ones who haven't yet or never will. I suggest you read [this](https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3) article if you're interested.
Since you mentioned "strongly-typed", I'll leave this here. You may find it an interesting read: http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html
You can use `navigator.hardwareConcurrency` where available. You can also try this polyfill: https://github.com/oftn/core-estimator
I'm surprised by the number of people writing C# (last question). I thought that would be lower based on this survey.
I saw a great demo at html5devconf by Intel of combining SIMD in the browser with webworkers to calculate fractals 4x faster by performing the calculations in SIMD 4 vectors.it was very cool. Will be great for games when SIMD makes it into the browsers.
That's great. I didn't know that existed, so thanks for pointing it out. This could definitely be helpful in certain applications. The fractal browser actually does something very similar to the polyfill, where it tests performance against an increasing number of workers to find where performance is best. When I last tried it, Chrome worked well, Firefox was jumpy in the results, and Opera (on Linux, at least) always was best with only 1 worker. I'm glad to see someone else trying a similar approach. 
I just googled for it, and [found this](https://01.org/blogs/tlcounts/2014/bringing-simd-javascript). That's really cool, and it will be interesting to see what impact that has on other web projects. There are definitely a lot of options now to write it faster. When I wrote the original code WebGL wasn't even available by default in Chrome, and asm.js didn't exist. As soon as typed arrays were available I switched the code to use that, but these days there definitely are other options for going faster. I'd love to write a WebGL version, but it is hard to find the time for a hobby project.
What do you think of this new statement? - Closures are one of the features of functions, anonymous or not, which turn its containing objects (functions or variables) invisible outside of it.
Its much easier to build a UI in JavaScript than in most other languages - most of what the language is used for is manipulating CSS and HTML. Especially compared to the languages you mentioned. I agree you could use Fay for Haskell, and others for Java, but these are eventually compiled (not necessarily the right word) to JavaScript -- in essence, you get a solid free infrastructure by running your program in a browser, which JavaScript enables you to do.
It certainly does lack structure and the tooling is still really terrible. This is exactly the reason why the Closure Compiler, GWT, TypeScript, and Dart exist. Building larger applications is needlessly difficult. I highly recommend to take a closer look at TypeScript and Dart. You can get some of the tooling with regular JavaScript if you add those bloaty JSDoc comments everywhere. However, it's generally rather poorly supported and those comments are *really* annoying to write. To give you an idea: JS: /** * Bogorizes the lazer shoe. * @param {number} x * @param {number} y * @return {boolean} */ function bogorize (x, y) { var z = x * y; // z is something ... } Dart: /// Bogorizes the lazer shoe. bool bogorize (num x, num y) { var z = x * y; // z is a num ... } TS/AtS: /** Bogorizes the lazer shoe. */ function bogorize (x: number, y: number): boolean { var z = x * y; // z is a number ... }
Here we go, I have updated the pamphlet with your recommendation - http://dgsprb.github.io/JavaScriptwithClasses.pdf I have also adopted it on one of my favorite pet projects - https://github.com/dgsprb/foundation.js/commit/46ebd4a132bd6d68578f237023a9d614bad7e361 I think it was time to forget about some aging browser versions. Let's move the web forward. Thanks again. PS: Maybe I should still keep some reference to my old method, just in case. Or even better, provide a pointer to the polyfill which provides Object.create() on older runtimes.
Well i only have experience with MVC in ASP and PHP in there you have a model class for each table, a quick example. Say i have a website where i want to show my customers on one page and my orders on another. You will have two model classes one for customers with all customer query's and one with the order query's you will have 2 different controllers one that will handle customers and one that will handle orders. your customer controller will talk to your model call the query's written in the model and pass the data it gets to the view a controller can load multiple views.For example if there is code that you have to use multiple times on your site(say a header) you'd want to make a view just for your header and load this view in every controller then the second view you load would be the main content.You do not want to only use 1 model, view , controller which would be against OOP and MVC. your controllers are the communication between the data layer(the models) and the presentation layer(the views). NEVER query directly in a controller or a view , NEVER use html in a model or a controller and try and use logic mostly in your controllers.Hope this helped a bit
Hey thanks, yes that's helpful. In my JS files I have a number of different classes defined (since JS is not inherently OOP this is allowed). Your point is helpful in so far as I could easily break out each class into a separate JS file to make it more like a standard class file. It's also helpful to think of a view as an object that contains display data. In that case does the view class only contain states(data), or does it have methods as well? If it has methods, can you expand on what kind of methods would be part of a view class? I'm currently doing almost the inverse of that. My controller methods process data and pass that processed data between model objects and view functions. I guess that when it really comes down to it the only true class objects I have are in my Model. My Controller is just a big procedural pile of functions, and my view is pretty similar, and this is what I want to sort out.
&gt;it would be interesting to find out exactly why people are motivated to lint JavaScript. Because a tiny bit of tooling is still a lot better than no tooling at all. With a linter, you can at least catch the really stupid mistakes before you hit Ctrl+S.
coffeescript has a fatarrow and a terse syntax. aside from that, its really not that great and only seems that way if you don't know how javascript works.
You can take a loot at [The Command Line Crash Course](http://cli.learncodethehardway.org/book/) and [Master the Command Line This Weekend](http://lifehacker.com/5990668/master-the-command-line-this-weekend), if you get stuck let us know :) 
I was hoping that this article would have been about rendering performance of the three libs. It is no mystery about the KB size of the libs backbone &lt; angular &lt; ember. So yes, downloading the initial payload does take longer when your included javascript libraries consume more KBs. That is not much of a mystery. A 10KB jpg loads faster than a 500KB jpg... shocking! The idea is that you're loading a single page application, that should not require reloading your page when interacting with the app. If the server is configured correctly, subsequent loading of js libs should be cached. I think measuring JS execution time is more meaningful. I would not be surprised if backbone JS execution is faster than angular for initial page display and angular being faster than ember, but that is not discussed here.
If you want something which seamlessly interacts with JavaScript, use TypeScript. Unlike CS, TS gives you vastly improved tooling. &gt;especially with the changes coming to ES6 which copy a lot of the coffeescript ideas, such as lambda syntax That syntax wasn't CoffeeScript's idea.
I created a loading screen for my ember.js application https://dfw.io (view the source) to help make some of the load times more bearable. The loading screen is automatically replaced as soon as ember renders the view. Unfortunately, at this time, dfw.io is invite only, but you can see the loading screen. Shameless plug: if you want to know a little more about Down For Whatever, go to http://signup.dfw.io.
Typescript is probably a better bet if you are looking for javascript-like syntax that will work well with teams while still providing some neat conveniences like classes, lambda syntax, etc. A lot of TS syntax looks like ES6 which is a nice benefit too. Coffeescript is more about writing javascript without as much noise as possible, and has a more opinionated syntax, like `@` for `this`, that starts to deviate away from "pure" javascript. You can of course write it without a lot of that, but it is true there's going to be a non-zero learning curve for anyone not familiar with it. There's another option available for you, which is just to use ES6 now with a transpiler. Pure JS to ES6 would be about as much a learning curve as JS to basic coffee, but it is one a lot of people are going to have to make anyway.
The spec says nothing about "cycles" it simply requires the resolution to appear to be async as far as the order and the call stack are concerned. Old promises implementations used setTimeout to accomplish this, resulting in horrible performance, but there are plenty of ways around that problem, which the spec itself mentions in the notes. Considering that anything being done async in JS requires something to be enqueued / dequeued by the runtime, it's completely untrue that using nested promises has horrible performance compared to using async callback functions directly--which also require the same appearance of async resolution and a fresh call stack if they are going to result in predictable behavior.
&gt;if you don't know how javascript works That seems a little harsh. 
Oh cool thanks! Did you try it out and it worked okay? What operating system did you use? I need to work on getting a demo online :)
Trying to get it running on Windows.... might give up and go get my mac. :)
It should totally work on windows! try install coffeescript npm install -g coffee-script I need to update the docs :)
You don't need no math to learn JavaScript. Just learn jQuery to get started.
I'll check those out. thank you! 
Check this out :D http://aerolab.github.io/iojs-colorpicker/#f26b24-032c2c-0.3
Backbone is a framework.It has a view layer,a model layer and a router.It's just that it is half baked and its author has moved on,showing little interest into making it better,just like CoffeeScript, or Underscore.
I just realised that the repo was missing a template, git pull on the scenevr-web branch again and you should be away!
jQuery solves **a lot** of problems, sure. One of the biggest is consistency between browsers. There is still one thing you have to remember though. jQuery is a gigantic library (34 KB compressed; 82 KB uncompressed), most of which you probably won't even use. **Edit** Guess I'm receiving a lot of flack for suggesting a more minimalist approach to web programming (e.g mobile). And no, jQuery is not always cached, because not all websites use the latest version. https://code.jquery.com/jquery/ I counted **128** different versions of jQuery.
34k loads in 5ms on my connection or less if I already have it cached via cdn. Some of the native Apis are really ugly and jquery makes my code clearer by allowing me to express my intentions in an abstraction rather than a lengthy implementation. If size and performance were the only important issues in programming we would write code directly against the processor in assembly. I do take your point that if you only use jq to select elements by id (I have seen this before) then you may consider dropping it. It has never been easier to live without jquery than it is today. 
its javascript for people who wanna write javascript in ruby. Javacript howerver is not ruby and the coffeescript compiler is just a syntax translator. this leads to weird lexical ambiguities such as when functions are called. In ruby, all functions(methods) are called regardless of wether they are parenthesis. javascript however lets you pass around an function without calling it. So this leads to the case of a function being implicitly called when you pass it arguments. However what if you pass more than one function AS arguments? this is the type of thing that makes reading coffeescript painfully confusing for someone that knows how to write functional idiomatic javascript.
Well, a huge part of Angular is deprecated by React (two way binding) and the controller aspect is pretty much out the window as well since React has that aspect covered. You can skip module dependency since you now have natural DOM dependency and you can use require or commonJS modules for organization. The hardest part is building up your data objects and passing them to React to render. There's really little need for Angular with a React front end. Oh, and routing is handled better (IMHO) by just about every other router out there... 
Uh, who the fuck is serving their js unminified? These "researchers" need to get a better grasp on actual production configurations.
Using Coffeescript in 2014 is pretty fucking stupid to be honest. ES6 gives you everything CS gives you with the added benefit of it being actual Javascript that is well on its way to running natively in browsers (for now you'll need Traceur, 6to5 to one of the dozens of ES6 -&gt; ES5 transpilers out there)
Don't be a little bitch.js
&gt; jQuery is a gigantic library (34 KB compressed ... Why do web developers continue to be stuck in 1998? You do realize that around 80-90% (or higher) of your audience will have their caches primed with jQuery already? Even cold, 34KB over the wire is fucking nothing these days.
Did you miss this part? &gt; The TodoMVC examples aren’t ‘production ready’ because they’re targeted at developers who want to see how the application is built with a given framework. To approximate a realistic production environment we pulled down the TodoMVC code samples, concatenated files, applied minification, served the assets with compression, and moved the host closer to the test location
A small app with few DOM queries is much better off without jQuery. Why load an extra 77KB?
get a 99cent vps
nope. there's no reason to use coffeescript unless you really want to use ruby....in that case, just use ruby.
zeptos!
if jQuery is such a problem, use native selectors....or use zeptos. 
http://codewars.com
That same thought crossed my mind initially, then these words from the Marionette GitHub flashed through it: "Like Backbone itself, you're not required to use all of Marionette just because you want to use some of it. You can pick and choose which features you want to use." It may be somewhat interesting to see a different and more complete set of tests/numbers around how using different parts of Marionette impact page load and render times. Although, it wouldn't be a total shock if that information is already available somewhere and I'm just too lazy to seek it out.
i can't read the code
Filament Group isn't clickbait. These are the guys who, along with Ethan Marcotte, came up with most of the fundamentals of responsive web design. They're [a really smart bunch of people](http://www.filamentgroup.com/about/) who have put out some [really handy tools](http://www.filamentgroup.com/code/).
...i didn't understand. Is he for or against?
Looks awesome. Too bad its CoffeeScript
That fixed it!
I agree... was an immediate turn off. Did get it working on Windows though. Great templates.
theres no point in loading all of jQuery if your using 1/10th of the library
Quit being a drunken faggot... oh wait. Sorry! Carry on.
I can't read that CoffeeScript shit, so I'm a gonna wait for real JS implementation. Would be cool to develop games in javascript though.
[~30KB min+gzip](https://mathiasbynens.be/demo/jquery-size)
http://vanilla-js.com/ edit: Ok its like 30kb. 
Core contributor to Marionette here. We're steadily working towards making very small broken down modules that can be used both in the context of Marionette or just plain Backbone apps*. The interesting effect of this is that, if you use a module system like browserify or AMD, you don't even have to pick what features you want to use in your build, you just start importing files and features you don't use are discarded. Hopefully this will be out soon with Marionette 3. *caveats may apply
I'm porting it to JavaScript tomorrow. Not looking forward to losing the got history but yeah I totally understand the dislike of coffeescript. :)
There's a GitHub issue to port to JavaScript I think I'll bring he conversion forward :)
ES6 solves all issues CS was trying to solve, and it's solved in better, more well thought manner by standards body. It's the core language now. In light of that there's no point to invest time into CS. Especially when native ES6 support in engines gets every day better. To use ES6 now, check https://6to5.org/ project. 
Is this similar to OpenCroquet, the Smalltalk thing? That thing was awesome. Did you/can you use any of the voxel-js compatible modules? They have a giant library of awesome modules. I am very interested in VR stuff, and shared worlds stuff, and javascript, so I'm gonna be poking around :) But it would be nice if you had a demo server/client working. It'd be fun to wander in and randomly meet another redditor happening to be online at the same time. In fact, I may just set one up on heroku myself, if it's all the same to you. But actually I think it should be on scenevr.com for professionalism's sake ;)
Save 30kB of code - load 3MB of images. Because logic.
THanks @vertex21 for the response. I found the following about composer People who loves using Unix Terminal, may found installing Application is very easy through Terminal than any. Composer Installs packages in similar way. 
Though the new version of jq will have 2 choices. One for the legacy apps and one for the next gen. Which is in turn smaller footprint. 
There's a demo up at: http://client.scenevr.com/
I never said you can't generally make an element follow the mouse with JavaScript. Of course you can! I said that the HTML drag and drop API doesn't support it. [Maybe this will help you understand](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_operations#dragfeedback). And btw you're code snippet relies on the 'mousemove' event which is not fired at all during a drag and drop operation. And sorry, but I'm not replying to any more of this.
Sure, the spec doesn't mention cycles. That's probably why OP put the word in quotation marks. But a resolved function must not run on the same tick as the resolving function. I think that's what he meant. But thanks for clearing up the performance discussion.