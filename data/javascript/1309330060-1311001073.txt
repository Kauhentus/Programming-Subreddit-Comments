xml?
Using XML+XSLT for client-side web apps feels like using a sledgehammer to drive nails :)
Whoa. Hi Paul! You rock, your podcast rocks, your blog rocks, etc, etc. Thanks for the correction... ...and now I have to sheepishly admit that I heard something along these lines on yayQuery (but less definitive) and I completely forgot about it. Bah! (Holy crap... Paul Irish)
* open handlebar.js * find {{ and }} * replace with &lt; and &gt; * save
The only problem with JSplumb is: its slow if you use a lot of elements with plumbs :(
I'm curious as to why you believe that these aren't possible with a regex. Show me text, and I will show you a regex that can process it.
jquery-tmpl also seems not to be getting much development love... I used to be a big fan of it, thinking it would become ubiquitous due to inclusion with jQuery. But Mustache has really won me over. It's pretty, and it's usable in lots of languages which is great.
None if you have a non-JS fallback. Consider this a better alternative to joining together HTML strings.
[angular.js](http://angularjs.org/), although it's more than just templates.
[RegEx match open tags except XHTML self-contained tags - Stack Overflow](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454) Oh, this is CSS isn't it? Silly me! My point is, regular expressions are not a universal tool to solve every problem with text.
You would probably enjoy using [SASS](http://sass-lang.com/).
I would like an option to alphabetise the rulesets (in your example, `background` would be moved to the top). Sadly, features such as these would likely be relatively complex to implement and would significantly reduce the projects simplicity.
So you're using Ruby?
I was sceptical after seeing the title of this submission. CoffeeScript? Really? But actually the bug report doesn't mention it at all, it's about mapping line numbers of generated JavaScript back to the original source (which yes, could be CoffeeScript). The linked comment by Jeremy Ashkenas at http://intertwingly.net/blog/2010/11/25/Hobgoblin-of-Little-Minds#c1292138238 is of interest.
go [there](http://blog.nodejs.org/2011/06/29/node-v0-4-9/)
You're right, they're not a universal tool. But they *are* a very powerful and efficient tool, and work in most textual situations. In CSS, there are strict limitations on how the document can be structured, otherwise it breaks very easily. That means it's simple to parse, and even simpler to parse using regex. Which is kind of the point I was making.
They certainly are very powerful. Their power is the main reason a great number of developers use them in situations best solved by another tool. CSS may be a relatively simple specification, but it is by no means [simple](http://www.w3.org/TR/CSS21/). If someone did come up with a regular expression based CSS beautifier, I wouldn't want to be the one to add a new feature (say, support for some new CSS3 syntax) or locate the source of an obscure bug down the line.
ProCSSor is really nice. Is there source code, or is it only available as a web service?
Compared to the complexity that regex is commonly used for, even CSS3 is the syntactic equivalent of a Dr. Seuss book.
Besides something like mind maps or UI diagrams, do you see a good use for this?
Workflows
Pretty cool. 
yes... ok, I can see that. 
new name: jsAwesome
I'm one of the devs on handlebars.js, and our primary focus is actually the browser, although we do intend for it to be an amazing templating language for Node also.
Now that I've read this more, Handlebars is an extension to Moustache which is run in backend code like php. So is this just a layer of templating above the existing Moustache templates you create server-side?
i've seen the SDK code of FEAR and Half life.
Why not tabs or why not points? They're kind of related questions for me. I don't think there's a particular benefit to proselytizing spaces over tabs; I think the main point that should be raised is consistency. If I worked in a place that used tabs instead of spaces, I would (grouse about it and then) use tabs. As for the reasons I use spaces, the biggest one is this: at heart, I am a Python coder. It's my favourite language. I like the austere beauty of the code that I write and I like that so many projects capture that same austere beauty by adhering to PEP8. For whatever reason, I chose a coding standard and that standard is PEP8, and PEP8 recommends spaces. This is the key point; one should choose a coding standard and stick to it. In general I'm okay with the standard having tabs or spaces as long as it is being used consistently within and hopefully across your projects. When I was googling around yesterday, I found that the signal to noise ratio of this argument is really unfavourable; it is hard to find points that seem meaningful, so I thank you for taking the time to discuss with me. [*ninjedit for clarity*]
I'd love to hear about how using Handlebars.js goes for you! In general we try to be as backward compatible with Mustache as possible. And, we've been really focused on making things as fast as possible - we're a lot faster than Mustache. Before Handlebars.js 1.0 is released we'll also be adding precompilation so that you can just include templates compiled as javascript into your app (I'm about halfway done with that feature).
jQuery-tmpl is one of the worst template engines when it comes to performance. http://jsperf.com/dom-vs-innerhtml-based-templating/168 The original Mustache templates are even worse. Thankfully Handlebars seems to have raised the bars drastically (pun intended). Using Chrome on my machine it is almost 20x faster than Mustache and 6x faster than jQuery-tmpl. Handlebars appears to be actively developed, while jQuery tmpl has had next to no development even though being a Microsoft sponsored project.
&gt; i've seen the SDK code of FEAR and Half life. And if you think that's the most sophisticated technology, or it involves any knowledge from legitimate Artificial Intelligence (don't get confused: game AI has nothing to do with research AI,) or if there's anything in there even remotely resembling a "complex and adaptive data-driven codebase," I've got this bridge I'd like to sell you. The Halflife engine in particular is such an enormous, stinking dinosaur that they actually aren't able to wedge proper multi-screen in, after it was introduced in 1998. You have no clue what you're talking about. What you tried to say: "Video games are the most sophisticated code I've seen personally." What you actually said: "I've never seen any actual sophisticated code, so when I saw a few video games, since they were more complex than what I write, I assumed they were some of the most sophisticated code that exists, and took that as a factual position in public, without considering that if it was wrong, I would have no knowledge of it; when called on it, instead of thinking it over, I just lobbed the names of two games, both famously code-crippled, out there as if that would somehow support my position, apparently unaware that I had chosen the two major games whose codebases were so famously garbage that my opinion on code quality would instantly be undermined to epsilon." You might as well have named Minecraft.
Why is this post downvoted?
And there is also http://stackoverflow.com/questions/1618128/parsing-css-with-a-regex
You can start with http://pastebin.com/U9aQiuVe (adopted from the project's test cases) which should produce http://pastebin.com/qB6XHKjg
&gt; If I worked in a place that used tabs instead of spaces, I would (grouse about it and then) use tabs. Of course. We must be civilized about that. A funny example is that, in order for my code allowing tabs in cssbeautifier to be merged, I had to use spaces as separator. That wasn't a problem (but maybe also because the said code is so short it could be managed by hand, without the need to configure an editor). 
Now it's in two places. * [Node.js: JavaScript on the Server](http://www.youtube.com/watch?v=F6k8lTrAE2g) * [Node.js Simple Web Service](http://www.youtube.com/watch?v=qws6LOvDQRE) * [Introduction to Node.js with Ryan Dahl](http://www.youtube.com/watch?v=jo_B4LTHi3I) * [Node Inspector - Node.js Debugger](http://www.youtube.com/watch?v=AOnK3NVnxL8) * [This Time, You'll Learn Node.js](http://www.youtube.com/watch?v=B05Dl4iL21M) * [SWDC 2010 NodeJS Talk by Tim Caswell featuring Connect #1](http://www.youtube.com/watch?v=WJN9NNbY6uo) * [NodeCasts.org - Episode 1 - Basic Steps](http://www.youtube.com/watch?v=7tUfDWRIMpw) * [NodeCasts.org - Episode 2 - PubSub with Faye](http://www.youtube.com/watch?v=WHtwsH1DUnc) * [Nodester: Create &amp;amp; Deploy a Node.JS App in Less than 2 Min!](http://www.youtube.com/watch?v=1OdmF26_vmc) * [Blogode Demonstration - Blog system in Node.js](http://www.youtube.com/watch?v=jGN4oyddT0U) * [Speed Up Your JavaScript](http://www.youtube.com/watch?v=mHtdZgou0qU) * [JavaScript: The Good Parts](http://www.youtube.com/watch?v=hQVTIJBZook) * [Communicating Event Loops](http://vimeo.com/9149445) * [JavaScript Modules, Proxies, and Ephemeron Tables, Oh My!](http://vimeo.com/9965316) * [NodeJS Synoposis [sic]](http://vimeo.com/9968301) * [London Javascript Meetup Jan 2010: node.js &amp;amp; Websocket](http://vimeo.com/9293350) * [London Javascript Meetup Jan 2010: Getting Started with Node.js](http://vimeo.com/9125286) * [Scraping the web with node.js, jQuery, routes, and CouchDB](http://vimeo.com/25429890) * [Internalizing the event system, callbacks, and event emitters](http://vimeo.com/25432896) * [Building browser applications that work offline and sync via CouchDB](http://vimeo.com/25435302) 
here is our pitch reddit style :) http://i.imgur.com/FFfLM.jpg
Oh for the love of all that's good, can we please not start down this path. Kill it....kill it with fire. Tomorrow we'll have _Top 10 Node.js Videos!_, and then the day after _The 5 jQuery plugins you can't live without!_, followed by _10 JS Snippets that will save your life!!_, etc. Tell me what the posted article has over using Google (or YouTube, etc.) and searching for "Node.js videos"?
no, it is no closer. don't believe the hype. coffeescript will never see wide support in the browser outside of maybe firefox. even there it's usefulness is questionable. 
Nice find -- I didn't notice that originally. I wonder if the OP noticed, or if he thought it was real? I question the OP's merits if he thought that this was a legitimate piece of code. If he knew it was a prank, then we can all thank him for wasting our time on an unfunny "joke".
[Yawn...](http://www.reddit.com/r/javascript/comments/dbz8m/announcing_handlebarsjs/) just 9 months late.
Because it's a "micro" and micros are the hot new thing. You can't be a true hipster if you're not using at least 3 micros that nobody has heard of.
Alternate title: Client-Side Validation 101. The article is a joke. Using the words "security" in the same breath as "client-side validation" is about as far off as you can get.
&gt; jsPlumb provides a way to "plumb" elements of a UI together. Another piss-poor project "explanation", and although novel, I'm failing to see the value. Is this for whiteboarding/brainstorming/prototyping, or does it actually produce something usable....a GUI for creating GUI's?
If you put this right before &lt;/body&gt; then you can remove the $(document).ready function call. [...] &lt;script type="text/javascript"&gt; // do stuff // do more stuff &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Edit: So my answer is: * put the script tag just before body : [...]&lt;script type="text/javascript" src="script.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; * Remove all $(document).ready calls from your scripts * Put all your scripts into "script.js" 
Are these external scripts your loading in &lt;head&gt; or is it inline? If you are loading 3 different scripts, then combining them will minimize loading and you can do so (the easy way) by running: cat file1 file2 file3 &gt; buildfile If these scripts are inline, as you've shown above, then combining the scripts into one script tag won't affect load time. In this case the js is being downloaded with the rest of the html on the page.
I think the "jQuery way" to do this is $(function(){/*document ready code here*/}) instead of $(document).ready. Also, if possible this should be put in a js file so it can be compressed, cached, and maybe minified.
the short (and probably uninformative) answer is to put all of your on-ready scripts together in one script block, ideally at the bottom of the document. if you're asking about this, chances are you have some scripts (for UI controls etc) that are loaded dynamically which require some on-ready actions to be performed. the first question is whether these scripts really need on-document-ready behavior, or if that's just a catch-all that you're using. for example, could you do this? &lt;script type="text/javascript"&gt; $(document).ready(function(){ var parentThing = new ParentThing(); parentThing.LoadChild( new ChildThing() ); parentThing.Init(); // will cause children to init / render }); &lt;/script&gt; using this pattern, your on-ready script simply "boots up" your app, and your app control logic handles whatever behavior the child objects require. if that's not your situation, or that pattern doesn't work for you, you could use a registration pattern: &lt;script type="text/javascript"&gt; // somewhere in your code // ScriptRegistry is a custom type that can hold script references, closures, etc var registry = registry || new ScriptRegistry(); // register some script that needs to happen registry.push(function(){ alert("i am a script"; }); &lt;/script&gt; &lt;script type="text/javascript"&gt; // somewhere else in your code var registry = registry || new ScriptRegistry(); // add more scripts to the registry registry.push(function(){ alert("i am another function"; }); &lt;/script&gt; &lt;script type="text/javascript"&gt; // at the bottom of your document $(document).ready(function(){ var registry = registry || new ScriptRegistry(); // run all functions in our script registry registry.RunAll(); }); &lt;/script&gt;
 jquery.min.js jquery.myPlugin1.js jquery.myPlugin2.js functions.js // calls appropriate plugins, starts with "document ready" check
No. The document is ready at this point. All other Js would have been downloaded, and enough HTML has been downloaded for you to play with the DOM. Hell, place some inline Javascript after an element higher in the document and you are free play with that element in the DOM. 
[Relevant SO thread.](http://stackoverflow.com/questions/2809530/under-what-circumstances-is-jquerys-document-ready-not-required/2809551#2809551)
&gt;`cat file1 file2 file3 &gt; buildfile` May cause defects if files don't end with a new line (if it passes JSLint you're fine either way) and this also breaks things if there is a BOM (don't use one).
`$(function(){});` and `$(document).ready(function(){});` do the exact same thing. The former is just a convenient shorthand for the latter.
This is incorrect, and unsafe. For example, your application could be modifying an &lt;img&gt; tag on the client side, but since you haven't wrapped everything in a document.ready, the "height" and "width" attributes of that tag will be 0, because it hasn't finished being loaded into the page. The DOM often finishes loading before all external dependencies do. **Edit: I was mistaken. Whoo learning.**
meh * http://stackoverflow.com/questions/1438883/jquery-why-use-document-ready-if-external-js-at-bottom-of-page/1439382#1439382 * http://stackoverflow.com/questions/6026645/document-readyfunction-vs-script-at-the-bottom-of-page/6026730#6026730 
$(document).ready() will not wait for images to be downloaded. 
Well look at that, I learned something. You don't need to be an asshole about it though.
I apologize, I wasn't meaning to be, reddit was giving me an error when trying to reply, hence the excessive responses, which I promptly deleted after realizing reddit had saved them.
What good is your ScriptRegistry compared to the list of onReady functions that jQuery keeps? DRY(OLC).
No, you shouldn't. You should still use `$(document).ready()` (or equivalent). If you stick your javascript in the body element (even at the *very end* of the body element), the body element is still open and being parsed when the javascript runs. If your javascript modifies anything in the body element, this can cause hideous and inconsistent [timing-based bugs](http://en.wikipedia.org/wiki/Unusual_software_bug#Heisenbug) in the browser that occur inconsistently and are almost *impossible* to debug, because they depend on millisecond differences timing rendering DOM elements and loading/executing javascript code... this happens especially in older versions of IE, but can still happen even in some more modern browsers. You're basically modifying an element that is still in the process of being created by the browser, and that can lead to inconsistent results, mystifying javascript errors, a broken element in the DOM tree or even a whole-browser crash, based purely on the browser concerned and millisecond fluctuations in timing. In general, you should **never, ever, ever** modify an element from a script when that element's still in the process of being parsed by the browser. It's just bad programming. This is why we have the `body.onload` event and jQuery's `$(document).ready()` functionality - because these events are **guaranteed** to only fire when the body element has been fully parsed and is ready to be safely manipulated by scripts.
Unfortunately, most of the answers you're going to get are things like "read these framework libraries" or "read this Crockford book" or "go to IRC." Few if any will be "read [the specification](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262%20edition%205.1,%20June%202011.pdf), then read [Quirksmode](http://quirksmode.org/compatibility.html)," which in the real world is the only acceptable answer.
Well I use it client-side for an ajax app. I bind data to a template and append it to the page. 
Here's how I would solve it: [http://jsfiddle.net/chandlerprall/W5yAT/](http://jsfiddle.net/chandlerprall/W5yAT/) Let me know if you have any questions about that, I'd be happy to explain it more.
Thanks Bob, that looks really close to what I need. I assume that this code: setTimeout(main, 1000/target_fps); is responsible for setting it to be looped to the target_fps within one second? (1000ms = 1 second). Just making sure, so i could in theory butt this right up against a current time clock and it would count up to the max value prior to the clock clicking over to the next second? 
That is indeed what that line does. Read up on setTimeout and setInterval [here](http://www.w3schools.com/js/js_timing.asp) Your theory is correct, however in practice theory often falls short. If you were to do: &gt; setTimeout(main, 1); you'd expect main() to be called every millisecond, or 1,000 times each second. Even if your code executed fast enough for this to be possible, every browser has inherent delays when using timers, usually about 5-10 milliseconds between calls. This means you'd have at most about 200 iterations per second. If you're really interested in Javascript loops / different methods of timed execution you can read [my latest blogpost](http://chandler.prallfamily.com/2011/06/beating-60fps-in-javascript/).
you could do it that way, but all of your initialization code ends up being tied to $(document).ready() all throughout your code. if this was a web control framework for example, and you had 20 UI control types, if you ever decided you wanted them to init on something *other* than $(document).ready(), you'd end up having to refactor 20 files. an alternative to this is to use the [observer pattern](http://en.wikipedia.org/wiki/Observer_pattern) in which your components tell some observer object "hey, i'm ready now" and that observer object can do whatever readiness entails. (the ScriptRegistry above was a poor-man's example of this.)
Here's my [source](http://peter.michaux.ca/articles/the-window-onload-problem-still): &gt; **This is an old technique (editor's note: this article was written in 2007) that is robust** but is a compromise that doesn't satisfy the unobtrusive JavaScript zealots. Ignoring the presentation concerns, **we can almost separate all the JavaScript from the HTML page by using a script element at the bottom of the document's body to initiate page enlivenment**. The idea is that by the time the browser parses this final script element and runs the contained JavaScript, the elements that precede this final script element will be parsed and available as part of the DOM. This assumption based on de facto standard browser behavior and may not satisfy some developers following the letter of specifications. Many developers do depend on this behavior working in many scripts.
Interesting, thanks for the insight! I should have realized that there would be browser differences with how JavaScript timers are handled... (given that IE, and the rest of the browser world can never get along anyhow...). Now I have to decide whether or not it's worth my time to make this "toy" since it can never be accurate enough for actual use. Thanks again!
See my response [here](http://www.reddit.com/r/javascript/comments/icgnf/minimize_javascript_loading/c22opjw)
But don't do setTimeout(x, 1); if you're meaning to do fluid animation. There's an API and a polyfill for it now. http://paulirish.com/2011/requestanimationframe-for-smart-animating/
The intention might be to detect manipulation of an object's methods... which isn't totally unreasonable. Sealing the object seems like a better way to deal with the problem.
I'll see your claim it's de-facto safe, and raise you *direct personal experience* of exactly this pattern causing timing-related bugs in IE 6 and 7. &lt;:-) FWIW the bug was intermittent (but all the harder to diagnose and fix for that) and only manifested under certain conditions (CPU load, network load, etc), but it did happen. I had some code adding elements to the end of the body (ie, after the running script) and then manipulating those elements, and the code would periodically cause an obscure and confusing javascript error, or would even crash IE upon occasion. The code doing this was part of a third-party library, and it took me the best part of a week to track down what was going on. When I finally worked it out I minimally refactored the third-party code to use a `$(document).ready()`-equivalent, and the problem disappeared. IIRC it also happened *very* occasionally (like once every week or so of heavy use) in some other browsers (Firefox I think, and possibly Opera). I agree it's an unusual error, and it *might* not happen now in the most modern generation of browsers, but I know from first-hand experience how nasty it can be if it does, and I know how inconsistent and sensitive to timing issues it could be, so I wouldn't be surprised if it wasn't well-known. Often even a simple page-reload (fetching resources from the cache instead of across the network) would negate it. Ultimately code like this exploits an undefined edge-case in browsers' DOM parsing code, and relies on a particular race condition *not* to occur. You can often "get away with" assumptions like that, but it's still not good design to do so. Edit: [This was the related issue](http://support.microsoft.com/?scid=kb%3Ben-us%3B927917&amp;x=8&amp;y=10) that first got me thinking in the right terms to work out what was going on.
How big is your JS code base? If it's only 500 lines or so, I'd say don't bother with a build system; managing all that in one file is fine. For bigger applications, I suggest using [RequireJS][1]. Its browser implementation has a few quirks, but if you don't do anything fancy it should work fine. It has a tool which can collect multiple RequireJS-enabled JS files (and even non-RequireJS files (sometimes)) into one (or more) output files. There are many other build systems for JavaScript out there, each with their own advantages and disadvantages. If you're using something like Dojo or YUI, which provide a packaging framework, use them. Otherwise, I'm sure you can find something which suits your needs. [1]: http://requirejs.org/
&gt; you'd expect main() to be called every millisecond, or 1,000 times each second. This is basically right, but in modern browsers the lowest setting for setTimeout is 4ms because the HTML5 spec calls for it. See [Firefox blog](http://weblogs.mozillazine.org/roc/archives/2011/03/investigating_p.html) and the [HTML5 spec](http://www.w3.org/TR/html5/timers.html#dom-windowtimers-settimeout). 
Thanks! I'm also looking at Backbone.js right now. Initially I feel like I was simply looking for something like RequireJS, but Backbone is looking quite appealing.
Modular functional GUIs. Think Modular Synth, MAX msp, Visual Basic. Anything configurable.
More than that - workflows that actually do *work*. Just plug a little modular functionality behind the widgets.
What's a clapper board? Also, jQuery is your friend!
That's a pretty good answer, but I can't upvote you for using setTimeout when you should be using setInterval.
I have a custom tool that orders and merges our 300+ javascript and css files. We have one js file for every class and we organize them in folders that correspond to namespaces (similar to java or c# style). If the js class is a ui component then their will usually be a css file associated with it. For instance: Foo.js and Foo.css The css files also get built and merged in the same order as their corresponding java component classes. This is important because it allows a ui subclass to have it's css file come after and be able to override properties in the base class css file. 
I definitely hope that precompilation will come soon! Right now what I do is to concatenate all the template files into a single JS file, but still needed to do the compilation in the browser... :( 
I use it in Python, Javascript, and on occasion Ruby.
Use setInterval to limit the number of iterations per second. 25 times a second would be once every 40 milliseconds. setInterval(iterationFunction, 40);
Sounds like a bunch of sensationalist speculation. Microsoft hasn't positioned "HTML and Javascript as the new universal runtime". Allowing HTML/JS development for advanced Metro-style widgets on Windows 8 doesn't mean we'll be writing server apps in JS instead of .Net anytime soon. The bit about the history of the CLR was interesting I'll admit. 
We used it in production. Our users are able to create network maps with it. But with a lot of objects it is slow. So we used Raphael.js, and it works great now!
Might also want to have a look at Spine. Very similar to backbone, but some key differences. : )
The main problem is that when javascript is running, the browser's UI is locked, so using while() that way is not recommended. To bypass this problem, the HTML5 spec has something called Webworkers which allows you to run CPU intensive javascript in a background thread, and pass messages between it and the frontend. http://en.wikipedia.org/wiki/Web_Workers
You can use [RequreJS](http://requirejs.org/) and/or [Google Closure Compiler](http://code.google.com/closure/compiler/) to combine your JS into single files for production. The nice thing about RequireJS is that you can have each script list it's dependencies and let RequireJS worry about loading them before running the file.
My company uses scripts loading right before the closing body. We've almost completely removed the need for $(document).ready due to how it all works. We make sure scripts are loaded in dependency order and there is at most only one script that uses $(document).ready, the "init function", if even that. As far as I know we have never ran into problems with this due to making heavy use of delegates.
This solution works but really needs some fixes: - Use setInterval instead of setTimeout. - Use textContent instead of innerHTML. - Save 1000/target_fps to `var period`.
Umm.. this is like saying: let's add for loop to Lisp because recursion is hard. :(
Scale is a pretty big factor here. I like to use some simple module system for our ecommerce platforms. I'd use the same thing if I were to rewrite Twitter, Reddit, YouTube, some blog, or whatever. It works great if there are just a pile of one-trick ponies and some events whizzing around. Basically, it's a good choice if the "application" is actually just a loose collection of independent gimmicks. E.g. you click somewhere and some modal dialog opens, you hover something and some tooltip is shown, you click on a box and its body is toggled, accordions, sliders, and all that other stuff. But you can't write a big monolithic application this way. E.g. if you write a platformer this way, you'd end up with one platformer module. That doesn't really help, does it? If this sounds interesting, watch this talk: [Nicholas C. Zakas — Scalable JavaScript Application Architecture](http://developer.yahoo.com/yui/theater/video.php?v=zakas-architecture) I wrote a somewhat minimalistic (no sandboxing) implementation, which also borrowed some UIX ideas: https://github.com/mahonnaise/umad/blob/master/src/umad.js It's a pretty odd hybrid, but it seems to work just fine. It currently lacks documentation though.
No it is the other way around: let's use recursion, because a for loop is not necessary. Continuing with this metaphor, the JavaScript inheritance analog of recursion are prototypes, the JS analog of a for loop are constructor functions (which were meant to make JS look more like Java).
The article seems to suggest that we need to change JavaScript so that its prototypical inheritance behaves more like classical which I think is not a good idea. Thus my analogy was: for loop : classical :: recursion : protypical
Cool, thanks for the info. This is one of those things that I looked at, and it looked cool and I could see potential in it, but with no more supporting documentation than was given I really had no idea how it could actually be used.
~~Without looking closer, I'm not exactly sure. But it's much more helpful and common for recursive functions to not be defined with anonymous functions (as it is here). A really simple hack just to get it working (without finding out the root of the issue) would be this:~~ ~~Change this:~~ var _deepCopy = function (obj) ~~To this:~~ var _deepCopy = function _deepCopy(obj) ~~(do note that there's major issues with this way of defining functions up to IE8, just a warning)~~ EDIT: Sorry, please don't take this advice, as this actually isn't the problem in the code example.
If I try to debug your unit test, I see that when the interpreter starts to run "Remove items" test (line 41), "jaylist" object is storing only one key named "other" with "list" value so I don't think this issue is related to copy function...
Actually, I never had an issue with this technique. Thanks for your constructive answers :).
No problem. Believe me, I'm more than happy to save someone else the week or so of sweating and swearing over third-party code, chasing down a bug that would quite cheerfully occur for an entire morning, then disappear for three hours, only to pop back every second or third time you refreshed the page. It's got to be one of the most infuriating, *nasty* little issues I've ever had to fix. ;-)
Look at the [jQuery source](https://github.com/jquery/jquery/blob/master/src/core.js#L304), they [solved this problem quite awhile ago](http://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-clone-a-javascript-object/122704#122704). EDIT: Sorry, I misread your intent. But still, you might be able to improve your code.
&gt; (do note that there's major issues with this way of defining functions up to IE8, just a warning) Can you expound on that?
Read [this](http://kangax.github.com/nfe/#jscript-bugs). It explains very well what's wrong with Named function expressions and IE.
Ah, yes, thanks. I had forgotten about these.
I'd definitely be interested in the precompiled templates. I love Mustache as is, so this looks like it could be very cool.
Is there a changelog or something? Or more precisely: A list of changes which are relevant to people who use the language.
See Annexes E and F ;)
Looks good. :)
I should have mentioned that originally, yes. Didn't feel like including it in the jsFiddle code though. Also, CamuurahGuy wanted a specific interval under 60fps. Can't achieve that (AFAIK) with requestAnimationFrame.
It wasn't meant as save-the-day code. jsFiddle is meant for fiddling with code and putting together quick demonstrations. Also, in regard to your first point, you should be using requestAnimationFrame - not timers at all.
Not at all. I agree 100% with the pairing you make. The article suggests that we only/mainly use prototypes and don't make the detour of constructor functions. The core inheritance mechanism of JavaScript stays the same: prototypes. But we would use them in a more direct manner. That is, focus shifts towards prototypes and away from syntactic classic-like sugar that is compiled to constructor functions.
you mean like because every div that contains a pic has the same ID? EDIT: I don't know if that's the only problem, I stopped looking when I saw it. 
well, yeah, but even when I change the id I can't seem to make it work. I'm just gonna have to keep fiddling with it I think. So here's a better question: what does the id in the div (&lt;div id="Style"&gt;) refer to in the javascript (or vice versa)?
Each ID in a page must be unique. Your javascript is looking for the first element with the ID passed in the function, then showing it. Since every one of your calls is referring to the same ID, "Style", the function is finding the first element with an ID of "Style" and showing it. Change all the div id's and change the functions to refer to the specific element you want to show. Give them all the same class, (ie "Style") and change your CSS for #Style to .Style &lt;ul&gt; &lt;li&gt;&lt;div id="bios"&gt;&lt;a href="bios.html" title="Band Bio"&gt;Band Bio&lt;/a&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="joey.html" onMouseOver="ShowPicture('joey',1)" onMouseOut="ShowPicture('joey',0)" class="joey"&gt;Joey Mauceri - lead vocals &lt;/a&gt;&lt;div id="joey" class="Style"&gt;&lt;img src="gallery/joey.jpg" height="200" width="200"&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="chris.html" onMouseOver="ShowPicture('chris',1)" onMouseOut="ShowPic('chris',0)"&gt;Chris Nix - bass &lt;/a&gt;&lt;div id="chris" class="Style"&gt;&lt;img src="gallery/chris.jpg" height="200" width="200"&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="jeff.html" onMouseOver="ShowPicture('jeff',1)" onMouseOut="ShowPicture('jeff',0)"&gt;Jeff Raatz - lead guitar &lt;/a&gt;&lt;div id="jeff" class="Style"&gt;&lt;img src="gallery/jeff.jpg" height="200" width="200"&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="donnie.html" onMouseOver="ShowPicture('donnie',1)" onMouseOut="ShowPicture('donnie',0)"&gt;Donnie Carter - rhythm guitar/backup vocals &lt;/a&gt;&lt;div id="donnie" class="Style"&gt;&lt;img src="gallery/donnie.jpg" height="200" width="200"&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="nick.html" onMouseOver="ShowPicture('nick',1)" onMouseOut="ShowPicture('nick',0)"&gt;Nick Lewis - drums &lt;/a&gt;&lt;div id="nick" class="Style"&gt;&lt;img src="gallery/chris.jpg" height="200" width="200"&gt;&lt;/div&gt;&lt;/li&gt; &lt;/ul&gt; div.Style { position:absolute; visibility:hidden; padding:5px; top: 10px; left: -120px; z-index: 50; } 
The main problem here is that you are using lots of ids when you should be using classes. As a general rule of thumb for people new to HTML, CSS and Javascript, I would recommend not using IDs for anything. Do whatever you want to do with a class, even if you think that it is unique and shouldn't need to be reusable. What your javascript is doing is telling the DOM to display whatever matches that ID whenever you mouseover the link. There are better ways to achieve this effect; here's what I would recommend if you're just starting: * Go to jquery.com and start reading there * Go to sitepoint.com and start researching selectors and how to write them * Use jquery to write the rules for display for those links. What you'll end up with if you go this route is a much simplified javascript and a better toolkit for the effects that you are looking for. 
requestAnimationFrame is still experimental so I really think you should avoid it in this case. I think you made a good straight forward solution, just not as solid implementation. Had my alternative suggestions demanded alot more code and commitment then I believe you had a valid case. As is, innerHTML and setTimeout are the wrong tools for the job. It's a big gain for the community if we never teach bad coding conventions, except as pitfalls to be avoided.
Thank you so much! I thought it was something LIKE this, but I couldn't quite get it all together...
The same variable \_table is captured by every method in the prototype, but it seems like your intent should be to have a different instance of \_table for each instance of List. The function that returns the prototype is actually returning an instance of an object with many closures as its methods instead of returning a prototype for such objects. If you replace every mention of _table with this.\_table and include this.\_table = {} in your constructor, and fix every other variable similarly leaving functions in the prototype, things will work fine, you get back to emulating a class. Because your List really is an abstract data type, you probably do want to emulate a class. Alternatively, you can just take that function trying to return a prototype and call it a List factory. There might be all sorts of things I'm not noticing, I'm not perfect.
Fair enough, and a good point at the end. Upvote :)
[Clapperboard Wiki](http://en.wikipedia.org/wiki/Clapperboard) Cheers, I'm not sure why you've been downvoted so much, but it's used in video/film production for audio/video syncing.
When would I want to hand code my presentation in HTML and CSS?
It can be useful if you want to do an interactive presentation, for example [HTML5 rocks presentation](http://slides.html5rocks.com/#landing-slide).
FYI: aphoenix is right, you could do this a lot better via JQuery, and frameworks like jQuery are the future. You should consider moving into that (or prototype, or what have you) as soon as possible.
Holding down left or right brings it to its knees. Also, I find the insta-opacity drop a bit jarring. Maybe think about disabling the horizontal scrollbar, too.
This does that and more: https://github.com/mezzoblue/PaintbrushJS
I just held down the right arrow key and it didn't break it.
First of all, use jQuery. Then, keep it simple. Presumably you start with one question field. Clone that, empty it and append it.
What do you think about this solution : http://paulrouget.com/e/dzslides2beta/ It's HTML5, CSS3… it work very well.
What do you think about Classy.js ? http://classy.pocoo.org/
So it's a javascript library that adds unnecessary bloat for something Javascript is already capable of? Or am i missing something here?
Probably isn't the best place to post this, but I *really* like that logo
I'm the author of that library. I'm about to release version 2.0. You might want to wait until then before evaluating it.
Does this library happen to drive a white bronco?
That should read learnt PHP
Sure, as soon as i dig more into it I'll let you know! At a first glance it looks very intresting, adding on top of Mustache, which I already like a lot. I investigated and tried really different template engines, each one with a different approach and syntax; functional,text-oriented,code-oriented, and so on. Eventually I liked Mustache's syntax best, I find it very clean. Good thing you're putting effort into optimizing it! I'm really looking forward for precompilation :)
"Hello Worzd"??? ;-)
Oh my... I remeber looking briefly at Cappuccino once, but didn't realize it was Objective-C (and GNUstep) for js apps...*the horror!* :o What do you mean about having options for client code? You mean being able to use different languages other than JS? &gt; Further, I'd like to stop transmitting the source code to every application each time a page is loaded Err... you know that once a .js file is cached by the browser, it never gets trasferred again, except when it's updated or unless its expires header says otherwise...right? :) Totally agree on LLVM, it will open very intresting possibilities in the future!
Thanks to the CoffeeScript Book for sponsoring the episode the ad has been removed.
bah...another *class*ical OOP framework... moving on.
Neat, but kinda pointless.
neat and python-style, but if going that direction I prefer JS.Class (http://jsclass.jcoglan.com/), it has both great features and standard library.
seems to have a clear syntax, but I'm not much into classical OOP in js, I really prefer prototypal one. On a side note, its really small size earns it a +1.
yes, and everything similar to Puredata as well! :)
no, sadly :) just found it. Here's the author contact: simon.porritt@gmail.com
I don't know about that. It's pretty, and clean code. Two images for the price of one.
mmm not so sure about this... what if I'm writing HTML in my templates? Everything will be interpreted as variable interpolation?
Thanks hertzahaeon, Any direction as to what libraries or functions to look for? Would jquery work with the children elements integrated as well (answers).
All nodes have getElementsByTagName(). They also have a childNodes property that returns an array-like object of the direct children. If you were using jQuery or a similar library, you could do a query like "#table_id tr:eq(2) td:eq(3) div" and get the div with a single line of code.
why is the 4th cell so important you need it but not important enough to give that div a special class for retrieval purposes?
It should. But you could just try it too.
use [getElementsByTagName](https://developer.mozilla.org/en/DOM/element.getElementsByTagName) 
Something like http://jsfiddle.net/sruvX/ will work, using querySelector. Of course, if you need to support IE&lt;=7, getElementsByTagName is a safer bet.
I only suggested childNodes for use on the td element to find the div if you needed to loop and test to find the correct one. I would stick with rows and cells like in your original example to get the correct td element. rows works even if you have a (hidden) tbody. childNodes doesn't. But, seriously, jQuery (or whatever your favorite, equivalent library is) makes this kind of code trivial, less brittle, more resilient to changes in the markup, will probably just work in all modern browsers, and is not worth fretting over (in regards to size).
Many C# calls are blocking. Virtually none of javascript's calls are blocking (hence the use of Closures). The syntax of the two languages are very similar. The mindfucks involved in guessing what the translator does in these cases, is not worth the very small effort of translating the syntax in your head.
Aha.
I've personally been dissatisfied by other OOP frameworks myself. They typically create more problems than they do solve. For instance, in many JS OO frameworks, any sub-class which overrides a parent method is automatically wrapped in a another function. So inheriting multiple times slows the class down overall. Another problem with OO frameworks is that they don't follow the same pattern as other OO languages. When I architected this, I tried to introduce as few new principles as possible coming from Java, and C++. I've also been dissatisfied with all the warts JavaScript comes with. Prototype-based javascript classes is slow to develop, and functional inheritance is just slow in general. On top of that, constantly embedding code in brackets is unreadable. Overall, it's difficult to develop large-scale javascript applications if you don't have the write architecture to boot. The framework supports abstract, final, and static methods. Implicit, and explicit getters / setters. As well as custom metadata (similar to ActionScript metadata) so you can identify properties which need to be handled a certain way. I also tried to keep it as light as possible ~ 1.5 KB minified. Suggestions would be appreciated as to what I can improve.
Sorry. I failed the "concentrating without coffee" test. Yes, I know .js gets cached on the first load; I meant to say each time a new user visits. Or if they have a misbehaved browser, or sneakily clear their cache frequently because they're paranoid. Either way, I'd rather be transmitting bytecode instead of source, even if it is minified (and lets be honest, if we're minifying it anyway, it's just a tiny step up from bytecode and just as illegible). And if we're targeting bytecode anyway, we have language options, which would be nice. Javascript has it's uses, but building large applications with it is still... iffy. PS. Yes. It's Objective-J. I'm sorry to have to expose you to it. It's as awful as it sounds.
Anyone have a demo for the lazy?
My only complaint is how you construct objects with regular objects. The problem is when you have "property/method" strings and "set/get command" strings, a minifiers won't be able to reduce those names.
The new opera was the clear winner on my system, good for them.
The page I linked to is a demo. Turn your speakers up! ;)
I'd do it something like this for the cloning bit (with jQuery): $('#firstQuestionField').clone().val('').appendTo('#questionFieldContainer'); I.e. select the question element, clone it, empty the clone's value, and put it at the end of the element containing the questions. It's all explained quite well in the [jQuery API](http://api.jquery.com/).
What score did they get?
really i've love to see some solid research on this. at this time i can only speak from experience (as do you), and i have /never/ experienced this issue. (my day job involves developing interfaces that work in at least ie6). what you say kinda makes sense (i'd love to know the js error thrown!), i just have never personally experienced it, but am open to change my perspective and understanding, i just need to see it. if i don't see ever see, then i prefer speed over the ever elusive edge case (but from my personal experience, the edge case doesn't actually exist). ultimately, i'd really love to see this issue. with this 'very occasionally' occurring bug, how sure can u be waiting for the 'full dom' to be ready was the solution? [edit] what $(document).ready() equivalent did u use?
[This is more relevant and disappointing (for IE 10)](http://html5test.com/results.html)
Am I alone in saying that although I like some of the features, I find it a bit awkward and tedious to use?
Crockford's The Good Parts and the Rhino book seem to be the canonical texts these days. There is a book called Object-Oriented Javascript by Stefanov that I think is really fantastic about showing modern design and the fundamentals that stuff like YUI gets built on. Also the Mozilla Developer site has a ton of good stuff.
Fuck you.
So basically invokedynamic, invokedynamic and more invokedynamic?
Since you already have a good grasp on different programming concepts I would recommend John Resig's Pro JavaScript Techniques. If you're feeling edgy then I'd also recommend John's Secrets of the JavaScript Ninja, though it hasn't been published yet you can order it online and download what has been written so far (which is all but the last few chapters). Both of these books delve more into what makes Javascript unique, its power, and some shortcomings. They are very helpful in learning more of the advanced Javascript tricks and how it works.
http://eloquentjavascript.net/
sorry for being late to the party... but Reddit, there at the door, let me in so I tought I was still on time :) I brought some beer and pretzels... here, have some!
not just performance, for me it's just **unusable**. Tried to at the beginning but gave up. Tried other templating systems, and was about to settle with [doT](https://github.com/olado/doT) given its exceptional speed but then again the syntax repelled me: too clunky. Eventually found the best syntax (for me) in Mustache; I didn't notice the slowness you're talking about but, if Handlebars drastically enhanced rendering speed while keeping the same syntax...well I'm definitely migrating! :)
you just peed in your pants, didn't you?
No, Mustache has bindings for many different languages, so you can use it server-side (php,python,ruby,java,etc) or from the shell or (as I'm doing) client-side, in javascript. This said, Handlebars is an extention of Mustache, but only in the sense of enhanced features while maintaining backwards compatibility with Mustache syntax. It's not a layer on top of Mustache, it's a different lib. Oh, and Handlebars is js only.
http://www.goodreads.com/list/user_vote/752756
Cannot upboat enough. It was incredibly easy to make an app once I got familiar with some of the basic concepts (basically putting building blocks together). I really hope they license this for other platforms. P.S. a lot of the engineers who worked on Enyo also worked on Dojo.
Nice try. It's a shame about Safari 5. That looks unsupportable.
This. If you know what you're doing you'll organize your code properly anyway. It just seems another layer of abstraction where it's not needed. "Models" in particular in Backbone seem a bit contrived.
The framework simply converts an object into a prototype class. There's nothing special going on which slows anything down. It's really a tool to help the prevention of boilerplate code which *is* bloat. Here's a more elegant example of the framework being used in a project I just started working on: https://gist.github.com/1061377 . 
Thanks again, looks like clone did the trick. I'm lost on a few things though. How do I assign a new iterative ID to the question text area I am cloning? I want to give the user to be able to remove a question. Assuming I can figure that out the next point might work itself out, which is I need to now relate answers to a specific question. In the mockup you can see that the user can create a question and within that question create one to many answers. I'll need to relate those answers to the question so when I post the form I know how to build those relationships in the database. Thanks again!
Excellent read, but given how badly supported things are, why not feature detect native support for `&lt;progress&gt;` and either drop in the element if its supported or use a replacement like jQuery UI if not dynamically instead of a not-particularly-good polyfill? Sure, the other method is marginally messier, but you're not going to avoid JavaScript either way, and the browser support for jQuery UI is excellent. 
s/modern/Webkit/
not working in my firefox
&lt;snarky comment about that being redundant&gt;
fyi, i have tried this $("#question-0").clone().val('').appendTo("#questionContainer"); $("#questionText-0").attr('id','newID'); questiontext-0 is the textarea within the question-0 div i cloned. ultimately i would need to update both id's, the div and the elements within it. just trying to get the id to change before i start working on the iterative id. 
How does this compare to [Cloud9](http://cloud9ide.com/)? It also does not seem open source(like Cloud9).
Webkit's dev tools are all written in JavaScript too. There are some performance issues with them, but it blows me away that in the near future we might truly be writing our web apps in the browser.
"User moldable terrain with heightmap stored directly in vertices"
I just started using [Kodingen](http://kodingen.com/) and really like it so far. Similar to this but much more feature complete.
&lt;snarky comment about Firefox not being redundant&gt; (despite me being a Chrome user)
What is this doing in the JavaScript subreddit? 
My thought exactly.
Every recent Webkit-based browser is also a modern browser, but not every modern browser uses Webkit. Do you need a Venn diagram for that?
Don't forget about NodeJS. Being able to completely write a webserver in JS and re-use the same code on the client side is fucking awesome.
Giving an element a new id like that should work. You could set up a counter and use that in the id for new elements: $("#questionText-0").attr('id','question-'+counter); Presumably you're inserting the question in a table for questions. When you've done that, get the insert id (mysql_insert_id() if you're using PHP). Then save that insert id with every answer when you insert the them into their own table.
Makes my 5 years bullshitting on reddit worthwhile ... almost.
... but not a very good one.
Thank you, this project is awesome and I will totally consider contributing once I finally learn how to use the subversion system.
Thanks, I am familiar with how to change the ID now, but I am confused about what to use as a selector when assigning the new ID to the question text area. Since we are cloning the parent element, doesn't that mean I will then have two elements on the page with the same ID and therefore would end up updating both? FWIW: I have a bad feeling about relying on the ID's for the relationships, but I am not sure how else to do it. As when I post the form I need the answers to be related to the questions somehow. Here's what I have thus far: &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt; &lt;script&gt; currentQuestion = 1; function addQuestion(){ alert(currentQuestion); // Clone the first question Container and give it a new ID $('#questionContainer0').clone().attr('id','questionContainer'+currentQuestion).appendTo('#questionArea'); // Assign the new ID to the text area field (This is not working) $('#question0').attr('id','question'+currentQuestion); // We need to update the click function of the Add Answer link for the correct question set. $('#addAnswer').click(function() { addAnswer(currentQuestion) }); currentQuestion++; } // addAnswer takes a questionID and creates a new text box. function addAnswer(question){ $('#0-answer1').clone().appendTo('#answerContainer0'); } &lt;/script&gt; &lt;form method="post" action="test.cfm"&gt; &lt;div id="questionArea"&gt; &lt;div id="questionContainer0" class="questionContainer"&gt; &lt;textarea id="question0" name="question0"&gt;&lt;/textarea&gt; &lt;div id="answerContainer0"&gt; &lt;h2&gt;Answers&lt;/h2&gt; &lt;input type="text" id="0-answer1" /&gt; &lt;/div&gt; &lt;p&gt;&lt;a href="#" id="addAnswer" class="link-sm"&gt;Add Answer&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type="submit" value="go" name="submit"&gt; &lt;/form&gt; &lt;a href="#" onClick="addQuestion();" id="addQuestion" title="Add a question" class="link-sm" style="background-color:red;"&gt;Add Question&lt;/a&gt; 
Yes, you have to change the id of the new elements if you want to be able to uniquely reference them later by id. You have a problem in your code because you're trying to change the id of #question0, when you should change the id of the new question. Since that has the same id for now, you have to reference it some other way. Example: $('#questionContainer'+currentQuestion).find('input').attr('id', 'question'+currentQuestion); However, you don't need ids to reference elements. You can also store a reference to an element like this: var q0 = $('#question0').clone(); ...and then use $(q0).append... Or you could just ignore the ids if you don't specifically need them. You can reference elements by their class: $('div.questionContainer:first') So all question elements are of class questionContainer, you select them all and filter all but the first. So unless you need ids later, don't bother with it.
I wrote this blog post earlier this year about JavaScript books &amp; blogs I've found useful. Hope it helps: http://blog.reybango.com/2010/12/15/what-to-read-to-get-up-to-speed-in-javascript/
:p
It's only popular because DHH (ruby on rails guy) thinks it's cool.
i think nicely written javascript syntax is pretty enough without coffeescript... some of the shorthand syntax is awesome but yeah, overrated in a sense that if i knew javascript already then it's useless to me
this belongs in r/coffeescript Edit: haha you fucking haters.. 
Yes.
Seriously, just learn JavaScript, you'll write better programs by doing so.
Wayne Gretzky, or Michael Scott maybe, said the key is not to go to the puck but to where the puck will be. It's not about learning Javascript, the guy who wrote coffeescript clearly understands js backward and forward, it's about implementing what he wants it to be. That other people find it more pleasant than javascript is just indicative of why some of the stuff in coffeescript will probably end up in ES.next or next.next. that people can use it without understand the underlying js is true of pretty much any tool or library that's not extremely minimal, whether it be GWT, Cappuccino, Ext-JS or whatever. debugging translated code is a totally fair point. google's closure for example has to generate a map file for their firebug extension to deal with this kind of thing. Fortunately Brendan Eich agrees and Firefox at least will probably implement a feature that will let do this kind thing in ff itself at some point.
No, i don't agree that it's ridiculously overrated. However, I upvoted the question because it's a good thing to have a healthy skepticism about anything that seems to be "cool" and "hyped," and because a solid understanding of the arguments against coffeescript is essential even if you end up choosing coffeescript for your next project.
The translated code is really not that hard to understand. I consider Coffeescript to be more "shorthand for writing the Good Parts of Javascript" than anything else. It's not really a "whole new syntax" like some people like to make it out to be. It saves you some lines of code and I think it makes my code easier to maintain. If you would prefer to write in straight Javascript, go for it. I think at the end of the day if you don't already have a really good grasp of Javascript, Coffeescript isn't going to be much use to you.
its really not.. but it only makes sense to use once you actually know js really well. its not a shortcut its a convenience
Completely agreed. WTF people?
As a viable platform it is possibly overrated. As the OP states: &gt; Trying to debug translated code is the last thing I want to do But as a syntax that maps directly to JS idioms it is underrated (at least in this forum).
Sure, but I didn't only want the input of CoffeeScript fanboys. I wanted to know the opinion what the JavaScript programming community at large thought, hence I think this is the perfect sub-Reddit to post under for this question.
I generally agree. You are bound to write inferior code if you don't understand the underlying architecture. I'd almost argue that CoffeeScript is only appropriate if you are very experienced with JavaScript and are willing to review the generated code before it gets deployed.
I you are saying that future versions of JavaScript should eventually support the shorthand style you see in CoffeeScript then I agree. But the more abstraction you add to CoffeeScrupt the greater the potential for poorly optimized code becomes.
While it's true it [gained](http://www.google.com/trends?q=coffeescript%2C+rails+3.1&amp;ctab=0&amp;geo=all&amp;date=all&amp;sort=0) a lot of attention when it was introduced into the Rails 3.1 head, it has been popular for a while. But as far as "DHH thinks it's cool", Rails isn't DHH. A lot of Rubyist like it. Not many give a fuck what DHH thinks, but me personally, I like to use coding technologies that are vouched-for (referring to the Rails core team not DHH.) To people with this attitude I say give it a quick go, port a small project and see how readable and compact you can get the code. You may not like it. But me, I know I'm never looking back. Fucking **love** Coffeescript.
[It doesn't](http://www.readwriteweb.com/hack/2011/01/interview-coffeescript-jeremy-ashkenas.php) &gt; * The CoffeeScript you write ends up running as fast as (and often faster than) the JS you would have written. 
Some of the syntax is nice, but there is no way I'd ever be able to use it at work so I haven't delved in to it too much. Maybe for a personal project in the future. 
I agree with you, but I'm not sure you can state with 100% certainty that writing in vanilla JS produces a better outcome.
"Fanboys". Right. So you wrote a loaded DAE question so you'd get a full circlejerk. If we're name calling; ITT: Butthurt hipsters who can't handle change and hate anything that becomes popular.
CoffeeScript is more useful in the browser than say nodejs or any other ES5 environment. You just write dense high level constructs and they work (quickly) in browsers back as far as anyone supports. There's no runtime or mystery to CoffeeScript it's literally just syntax, it can't be overrated. Nobody debates that it has advantages by masking some misfeatures of JS, the only objections are to the syntax which is highly subjective. I don't write CoffeeScript but when I write JS for browsers I consider it now and then. That people could be skeptical of a syntax is kind of strange. You either like it enough to use it or you don't.
Certainly. You can write bad code in anything. You can write functional code in many languages without much effort. You can't write good code without understanding the language.
Personally, I wouldn't call a list comprehension "just syntax." It's a declarative statement that replaces an imperative loop or set of loops. To me, shifting from describing "how to do it" to "what you want done" is significant.
If you want a *representative* opinion of the JavaScript programming community at large, you might want to consider phrasing your question in a neutral tone rather than asking for confirmation of the conclusion you have already reached.
But someone could theoretically write "good code" by simply being well versed in the best practices (and understanding the shortcomings) of CoffeeScript. I love JavaScript, but it never *really* needs to enter the equation. At the end of the day it's all compiled down.
Coffeescript however is often more optimized than writing vanilla js as it uses tricks like void 0 and other similar bits. If you are skeptical you can avoid it if you wish, but honestly its just javascript and the code will be reflective of it's author, as expected regardless of language. 
I honestly was not trying to go for circle jerking here. I might have used a regretfully loaded word, but I do see a lot of hype around CoffeeScript, but I don't see as much open debate as to the merits / downsides so I was hoping to get the wisdom of the folks here in r/Javascript. I'd love for somebody to give me a good case for using it. I'll give a couple benefits I've seen from my limited experience: It's got a much more expressive Ruby/Erlang like syntax which I'm always in favor of. It allows you to delimit blocks via Python style indentation rather than the BCPL-style curly brackets. But the downside I see is that you have basically a different language here. It's like back in the old days with Objective-C when it was still nothing more than a C preprocessor. Good luck method calls. From my perspective, (and please correct me if I am off base) the more translation your preprocessor does the harder it is to debug your code. Another benefit I see to something like CoffeeScript is that it drags the powers that be (Google, Mozilla, and Microsoft) kicking and screaming to better idioms in their languages. I'm concerned at the expense in the meantime though. Again, I am always open to new ideas; this one has just struck me particularly as less attractive as of yet.
I probably worded it incorrectly.. You'e got a great point there. I should have asked, "What is your opinion of CoffeeScript?" I have clearly stirred up some emotions here.
I tend not to like it; I find its syntax to be needlessly cryptic in favor of terseness. Some people value terseness; I don't, because it favors writing code over reading it, even though reading is the hard part. But I've been writing JavaScript for 7 years, and most of the people I see attaching to it are Rubyists, where terseness is the winner. Either way, it compiles down to JavaScript, which means I can consume libraries written in it for my code. So I don't get to worked up over whether someone should or should not use Coffeescript; it's their code, they can do what they want. It's just a pain to debug. Personally I'd prefer to see Objective-J win over Coffeescript. But neither of them are perfect, or at least as perfect as (I think) JavaScript is.
Debugger tools is the first thing I ask about whenever the topic of a translator language comes up. I've tried debugging software that was written in one language and then debugged in another language (after translation) and it's no fun. All your names mangled, meaningless line numbers, bloated target code. What a waste of time.
I didn't know it was rated.
 I'm not a fan of bashing coffeescript, but when stuff about it is posted in r/javascript it takes away from discussing javascript. While I fully agree with the title of the post, it belongs more in r/coffeescript than r/javascript. The mudslinging looks bad, it lowers the conversation in r/javascript to the level of what coffeescripters post here. If you are going to do that, then you may as well take it to r/coffeescript as they've done here. eye for an eye.
Awesome, thanks again for your help. I almost am there! Just to give you some context, I am trying to make this. https://gomockingbird.com/mockingbird/#2ql43kg/0W2gD1 You can see the user can create many questions, and within those questions can add one to many answers. I have questions working but am unsure how to go about building out the answer function. Here's my updated code. http://pastebin.com/JRuXJQyn
I think people underestimate how much extra brain power gets used processing the added clutter of curly braces. Before I started using Coffeescript I would have told you the difference between it and JS was negligible. Now, having given it a go for a couple of weeks, I can't believe how wrong I was. In a way I think the Coffescript syntax is analogous to the Ipod. Before the Ipod came out there were plenty of mp3 players that already had the same functionality, but it took the Ipod with its simplified UI and intuitiveness to bring a true paradigm shift to the market. Coffeescript is Javascript's Ipod.
I've been using [ICanHaz.js](http://icanhazjs.com/) I'll have to checkout Handlebars and see if there is any reason to switch
So dumbing down for the masses? :)
&gt; You can't write good code without understanding the language. Agreed, but here the language is CoffeeScript. Maybe it's compiled to JavaScript, but that doesn't really mean that that's the language you're writing in.
Understanding something, does'nt make it better.
This is a fair point. However, I would note that the Coffeescript compiler was written with this in mind and makes a (overall successful imho) effort to make the generated code readable and understandable. Your variable names stay the same, and any variables the compiler introduces are intuitively named and distinguished with the __ prefix. The code is pretty printed and passes js-lint. There's no real CS "runtime", it just translates to pretty straight-forward JavaScript. There's one or two places where it shims in a little functionality (like function binding), but that's the exception and even then it's pretty clear what's going on in the generated code. ..it's verbose...but generally easy to follow. In many cases it's basically the JavaScript you would have written anyway. This is in stark contrast to some similar projects where the generated code is dense, mangled, or even uses a run-time. I can only speak from my experience, but so far I've not had a whole lot of problems debugging. I've got quite a lot of experience debugging JavaScript, so debugging the generated output of CoffeeScript is just like debugging any other JavaScript code. Since the CoffeeScript you write maps fairly directly to the produced JavaScript, it's pretty easy to go from there. Syntax errors in your CoffeeScript will generally produce a compiler error, so you just catch that right in your IDE. So most of my debugging is spent on simple things like scope-issues, errors in my logic, errors in some API I'm using, etc etc...I find using CoffeeScript doesn't affect debugging those significantly. On the other hand, for people who are new to CoffeeScript and/or JavaScript...debugging can be more painful. I'm comfortable enough with CoffeeScript at this point that I know what I'm writing in JS as I write CS...not so for beginners. If you don't know JavaScript very well, obviously you will have trouble debugging the output of the compiler, but only slightly (if at all) more so than any other JS code.
No problem. Good luck!
I think the biggest thing people miss is how important *programmer hapiness* is for productivity. Everyone has their own preferences, style, and ways of thinking. If you can write in a language that shares your philosophies, you will generally be able to express your ideas better and easier, and that's what programming is all about. If you're working in a language or with a syntax that doesn't match your own thinking patterns, you spend a lot of time struggling with it, and trying to translate your ideas into it. CoffeeScript is a way for people to bring in some of their philosophies to JavaScript without significant drawbacks, which overall is a productivity win. (note this is important, Coffeescript is very careful not to introduce a run-time and to stick to JavaScript semantics...if this were not the case; the balance might shift) If you don't share those philosophies, then CoffeeScript is not going to be a win for you, maybe even a loss.
Certainly not true if you ever need to write vanilla loops with borders. The range function replacement ends up doing lots of extra tests at the beginning and end of the loop its used in conjunction with. Here's a performance benchmark for different implementations of Array::unique: http://jsperf.com/coffee-for-loops6 Generally this isn't that important as you wont be handling that amount of data for this to become a bottleneck, but just saying. You are trading performance for elegance and maintainability. (Coffeescript only gets this good performance notion attributed to it because it compares itself to slower implementations in javascript, like Array::forEach)
Nice rebuttal. Okay I don't write *that* much Javascript, but I think that still gives me some weight in this debate, because some people say it's only good for seasoned Javascript developers who enjoy some syntactic sugar. I just really like nice looking code so it suits me. On debugging, that was my main worry as well. As it turns out (for me so far), it's very easy to correlate your errors back to your Coffeescript, you probably won't buy that, but I'm yet to come across an error that left me clueless as to what's going on. They're not *that* different from each other. If it's a syntax error in your Coffeescript it just shows up in console log like a normal Javascript sytax error, and also in the running compiler. With Javascript I often find myself scrambling for Google when I want to find the nicest, most efficient way to do *x*, whereas Coffeescript it always seems obvious. So that's why I use it. You could say I'm not a great programmer and I like sexy code, so it suits me. But there's a lot of great programmers that love it too. I was skeptical at first, I kept pressing guys about debugging and never got an answer, just a "*shrug*, it's kinda the same", but I jumped in and loved it. And when I learnt about the difference between the fat arrow `=&gt;` and the skinny arrow `-&gt;` I realised oh my god, this is no silly toy.
I can't imagine debugging. "Error on line 82." I DONT KNOW WHAT LINE 82 *IS* ANYMORE. Also, if you work on a project and then slack off for about 2 weeks. Not only do you have to remember how it works in one language, but two.
Yep! Dumbing it down for the retarded Apple fanfags coding Rails in Starbucks on their MacBook Airs!!!1 jokes... I love Coffeescript :)
The apostrophe goes between the n and the t. Also, I disagree.
Right, I didn't mean it in a disparaging way. Significant syntax but still no magic, just a map/filter/etc. chain in the case of list comprehensions. Syntactically different but semantically identical. I agree that list comprehensions in particular are way better than a plain old fold or chain of catamorphisms but not all the syntax changes are so dramatic.
As a shorthand for JS and some of its more clunky syntax, I support it fully. As a replacement for actually knowing JS? Hell no.
I work on a medium size project. We got a month to write the first prototype, and I chose to give CoffeeScript a shot for the front technology. Debugging translated code is indeed a very valid concern. It is sometimes a pain and we are still looking for the right way to do this. However, choosing CoffeeScript was a real win and we chose to keep it for the real product. It gave us better code readibility, and a nice gain in productivity. But... You NEED to learn javascript first. 
Arguably it's impossible to understand the underlying architecture of Javascript. There are so many runtimes all with different characteristics. Javascript isn't the underlying architecture. It's a target language. The underlying architecture is the DOM and whatever extensions the browser offers in most cases (websockets, local storage, whatever). Does every Javascript programmer understand how all of those act on every platform? Using CoffeeScript doesn't change that.
I'm too busy doing other stuff to even try it.
you really think i'm going to reply to YOU in any meaningful way, you fucking troll? go the fuck away already. I've had enough shit from you. i'm not even going to read your replies at all, so fuck off. 
if you haven't noticed, r/javascript is already overrun by coffeescript posts, which is the exact reason you are reading a thread about "DAE think coffeescript is ridiculously overrated?" inside r/javascript. If you can't understand this, then you most definitely have your head up your ass.
It won a beauty contest, didn't you know? It's "more beautiful" than JavaScript.
Debugging is something that CoffeeScript enthusiasts seem to dodge talking about when I bring it up. I'll still give it a spin, but I'm expecting some pain in that area.
+1 I think it's pretty cool even if you know JavaScript, coffeescript has lots of nice features like M1573RMU74710N mentions (disclaimer : I don't code in Ruby/Rails and I'm not a DHH fan)
&gt; What's my thinking like? Does CoffeeScript match the way I think? Who the fuck cares how you think, though? When I look at your code I want to see what it does and not which episode of My Little Pony is your favourite. Coffeescript is full of ambiguity and that makes parsing code extremely annoying. And that *makes me feel* uneasy. absent_tables = ( name for name in tables when not exists name ) create name for name in absent_tables Stuff like this. It makes me mad. It's like having to read your twitter to understand what's going on. And even then I'm just like: "Is he for real?" So really *you* need to ask yourself this: * What are data structures and algorithms? * How do I use them? * How can I do so without making my code unmaintainable? * Does too much syntactic sugar give me syntactic diabetes? 
I appreciate the idea of someone trying to smooth over some of JavaScript's rough edges but I always find that reading Coffeescript is like trying to read a book with no punctuation I get that typing less is generally preferable to typing more but braces and parenthesis and semicolons all provide useful context to me and making it easier to figure out what's going on at a given point in the code
first of all, nobody knows what it is. nobody ever heard of it. second, i wouldnt even know why the heck someone would use this... thats like pushing to use brainfuck or lolcode.
&gt; concrete examples to back up your assertions (or implications as it where) ... &gt; how you think and reason about code [..] this is something that can vary from person to person Right, this is why people need to find a certain expressiveness to understand each other. Same in code. &gt; maybe you really don't understand that code [..] obviously this is a demonstration and proof of what I am talking about re: people thinking about code in different ways [spoiler]Writing code is the easiest part of the software life cycle, maintaining it the hardest. If you hide your logic behind layers and layers of abstractions and implications you just make matters worse. As you implied, people reading your code will only wonder: "What was he thinking"[/spoiler]
Objective-J ... for someone having only a JavaScript background, it's impossible to learn ... and too apple
I have used JavaScript for 10 years now... using CoffeScript would just be a hindrance to my productivity no matter how much 'neater' it is.
It hasn't been a pain for me. Compilation errors are reported in the .coffee source and runtime errors are reported in the resultant .js output. Works just fine.
 good_dogs = name for name in dogs when dog.behaviour is good Where does the dog *expression* come from? This is one of those implied removed abstractions I just don't understand.
Is anyone else just not as into the Beatles as everyone else seems to be? On a more serious note, what about the language do you find discourages use of prototypical inheritance patterns?
Mostly you have a mental map of what you're saying in Coffeescript vs. what is being output as Javascript. Debugging isn't much more challenging because you still have console statements, alerts. It's much easier to understand if you take the view that the coffeescript is simply a tool used to create the javascript. For me, the coffeescript almost doesn't exist separately. I write coffeescript and debug javascript, but I change things in the javascript by understanding where the coffeescript is creating the javascript I want to change. It's much more complex to explain than it is to just do. I didn't find it challenging to switch completely. Now I write coffeescript and Javascript together, mentally. Also javascript debugging sucks, anyway, you won't really notice a difference. It certainly can't suck *more*.
How cute. 
Takes me back to IE6/7 which just concatenates all source files including the html page into one file and reports the line number.
Elegant code can be written with just the knowledge of the language itself, but devs really do have a large knowledge of the underlying architecture of the target platform. That might be blurring the lines between good code and good applications. I need to know the limitations of browser renderers, when a browser will be using gpu to render, when it won't, what will trigger a reflow, what will trigger a repaint... the list goes on and on. This varies between js implementations and browsers even using the same js engine.
It just seems like an extra layer of abstraction that I can't be bothered with. Javascript syntax isn't that bad...
 you are a fucking nitwit if you think i need to define "over run" for you.
I didn't think anyone still cared about Rhino; I'm glad to be proven wrong.
step the fuck back. did i do any ranting in this thread? no. if you think i did, you are a moron. you are a pain in the ass, yes, you are the troll here judging by YOUR ranting. go re-read what you've written here, it's ranting. if you carefully read what i've written, there is no rant. you're trolling me, so fuck off.
you are absoutely correct in what you are saying, but you are wasting your time with mister mutation, he's always right, you cannot be more right than he is, because he's a troll. 
It can speak French. In Russian. It is... the most interesting language in the world. http://www.youtube.com/watch?v=fYdwe3ArFWA 
Grow up.
I actually meant the iPod - very soon after its launch the competitors had better products, with built-in radio and awesome features that Apple took forever to implement
hah, troll #2 shows up. I've also had it with your trolling too. You have nothing to add, so why add anything fucking troll.
If you're trying to reverse troll, you're not doing half bad.
Features which the competitors wasted money implementing, because the mass market demonstrably did not give a shit about them.
Ok, I'll bite. You get that runtime error. It reports an error. What line of your coffescript is that on?
Maybe it's not more challenging for whatever trivial thing your writing. But you really can't see this being a problem? Ever? Wow. 
At some point. :/
I've gone back to re-writing my client and server side stuff in JavaScript now, but honestly my code has improved a HELL of a lot since I started using CoffeeScript. The only real reason I did switch back is because in the type of environments I work in, no one else is really using it. Because it's built on the good parts, learning how CS outputs thing such as the way is optimises loops, handles scope and variable shadowing is a really good exercise. I'd still highly recommend CoffeeScript to anyone wanting to really the ins and outs of JavaScript. 
Respectfully disagree. Braces maybe. Semicolons, no. Having done Python for 3 years and now Ruby for 5, I've realized that indentation &gt; braces and newlines &gt; semicolons. In a well-written parser, both can be optional, for those times when they are necessary. In fact, if there was a version of CoffeeScript that only eliminated those warts, and made further features optional, I'd be on board _today_, even with the potential hassle of dealing with debugging issues.
Thanks for that and totally fair point about javascript debugging sucking already. :-)
I'm not quite sure how JavaScript debugging is so terrible anymore in most browsers. I get call stacks, locals, watches, breakpoints, immediate window, etc.. I use C# and maybe I'm not exploiting some tools available while debugging, but they both seem to have a lot of the same debugging tools available to me. Yes, the debugging environments aren't all equal across all the browsers, but it isn't a crapshoot anymore on "real" browsers.
You sir have done some quality trolling. You lack punctuation in your own post.
Hey guys, plugin author here. Just realized I made this the wrong link, it should have been http://jamielottering.github.com/DropKick Let me know if you have any feedback/comments!
The arrows are about 10 pixels to far to the left, ;-)
Valid
This looks great, I was just needing something like this the other day. Please specify a license.
Are you using the jquery ui for this? Reason I ask is i had a project a while back that involved listening for the onchange event on a select box and remembering that when i used jquery ui to turn the select boxes into a slider, that this event wasn't triggered. **edit** im retarded, didn't scroll down far enough the first time to see example specifically of the change event.
Also, it looks pretty sweet btw.
Thanks! jQuery ui is not required :)
Is this not the same as this one? http://www.filamentgroup.com/lab/jquery_ui_selectmenu_an_aria_accessible_plugin_for_styling_a_html_select/
Keyboard support?
Added: https://github.com/JamieLottering/DropKick/blob/master/LICENSE
Looks pretty good! You might want to add a basic search capability (first-character match with keystroke). Speeds up navigation of long menus. Also, native browser widgets support the same behavior, for the most part.
Looks similar but that's the first time I've seen that. Mine doesn't require jQuery UI
Yep
I definitely want this
Odd... I can't seem to close the dropdown (esc? f4?) using the keyboard. I can't advance by letter either (press "O" to select first entry starting with "O", press it a second time to advanced to next "O" entry).
I'm a demo dropdown doesn't work in IE9. When I click it I get a transparent box with a border.
I'm curious as to why it needs a nightly build to work. This would imply that the PDF renderer is exposing bugs or incomplete features in all browsers. 
It gives you a line number in your resulting javascript file. After taking a look at that it should be pretty easy to find the equivalent line in your coffeescript file. Edit: The javascript file that the coffeescript compiler outputs is nicely written and formmated.
I missed the ESC key support, I'll add that
If you have a "do what you want" attitude i strongly recommend a BSD style license, it let's people use their code however they see fit, and only really provides some liability protection for you in the event your code blows up someones something.
Along the same lines, can the element be tabbed to? I haven't yet seen a drop down replacement that works with keyboard support. Adding first char searching is nice, but also being able to tab to the element is in that same line.
I think OP's widget does do that? I seem to remember tab focus working when I checked the demo page. At any rate, yes, any widget that has keyboard support should do that.
Please, stop doing this. I know that the default visual rendering of HTML form controls is ugly in most browsers, and the CSS spec explicitly says that browsers are not required to provide any styling mechanism for them, so there is no consistent way to make your forms look the way you want across all browsers and platforms by using CSS only. I know many web designers hate that and they start looking for JS workarounds to overcome these perceived limitations and make their forms prettier. But form controls are not just eye candy, they are functional elements requiring user interaction, and therefore their usability and accessibility are generally far more important than their looks. You want the user to fill out the form as effortlessly as possible, but you will inevitably make it harder for them if you use JS styling scripts. There are basically two main aspects to why one should not use JS for replacing form elements with custom-styled HTML. Firstly, it is important that form elements not only **are**, but also **look like** what they are meant to be. The average user knows how form controls look in his specific browser and is very much used to it. He will instantly recognize a standard select box when he sees it. If you replace that select box with some JS generated HTML, the result will never be as recognizable to the user as his system's native look of an actual select box. Secondly, and this is no doubt even more critical, it is important that form elements not only **look like**, but also **are** what they are meant to be. All these styling scripts rely on the same principle - hide the actual form control and show some dynamic HTML layers in its place. Some scripts are dumber and only support click events, some (like this one) attempt to be smarter and also support some form of keyboard interaction like basic arrow navigation, but nevertheless none of them can ever hope to truly implement all of the diverse functionality that is natively provided to actual form controls by the many different browsers and platforms. rbobby already mentioned the lack of ESC key support. You said you'll add it. He also mentioned the missing support for a really common usage pattern where one jumps to matching options by tapping their first letter. You might say "Ok, I'll work it into the next version", but are you sure you know how this feature works on each different browser on each different platform with each different combination of keyboard, language and regional settings? Do you think your script could support the habitual web form usage patterns of a blind man using JAWS in Saudi Arabia? To be less exotic, have you checked that your script does not get in the way of filling out the form on all mobile browsers in all the different currently existing smartphones? What about the ones that will be released next year with possibly some new UI approaches to filling out forms? What about, say, some new assisting autocomplete function in a browser that initially does not trigger the onchange event for your script to catch? The point is that a standard select box will handle all of this perfectly in every case, and work exactly as the user expects, because it is the job of browser developers to implement that functionality for their specific browser. It is not possible for client-side JS code to be ready for all the wild conditions in which the web page might be be viewed, this functionality is simply out of the scope of web page code, it is the domain of the browser. Any JS imitations of form controls can only cripple the user experience. So I ask you all to please be sane and not shoot yourselves in the foot by breaking the core functionality of your (and your clients') web forms just because of a design whim.
weird, it's working now. it certainly wasn't before. meh.
&gt; He also mentioned the missing support for a really common usage pattern where one jumps to matching options by tapping their first letter. Just to emphasize that point, repeating the first letter is not the only way you can jump to items in a standard combo box (select element). You can also type an initial substring - and this is on a timer so if you stop typing and then start again after a pause, it starts matching from the beginning again.
That's basically what [Chris Jones's blog post announcing the release](http://blog.mozilla.com/cjones/2011/07/03/pdf-js-first-milestone/) said. It sounds like pdf.js is inadvertently acting as a stress test for browser text rendering, and they all have interesting bugs at the moment: in many cases, even the same browser on the same OS with different text rendering settings.
Yes, I skipped that to shorten my already lengthy comment, but that's a good example of what I was talking about. Still, I'm going to be pedantic and say that the select element is not a [combo box](http://en.wikipedia.org/wiki/Combo_box).
Not pedantic at all; thanks for catching my sloppy terminology.
I wonder if they could build a Flash player using Javascript and HTML 5.
... except for the font rendering - canvas does not do sup-pixel font rendering, so they always look crap.
Although I agree with you in principle there are cases where custom made UI controls are justified. The game industry have always done this. OS controls in the front end UI of a game would be perceived as very amateurish. It is just too plain ugly sometimes.
this is true. lots of canvases means lots of memory usage. so in 1.3.0, which i am releasing soon, jsPlumb offers you the choice of using SVG instead: http://jsplumb.org/jquery/1.3.0/demo.html
Well, there's also the function syntax. In async programming, you define functions left and right, so it makes sense for the syntax to be much less trivial than "function(){}". Even Python's "def" is a shorter keyword. I am aware that programming is not about the amount of time you spend typing, but this kind of verbosity neither aids readability, nor is it a necessary evil.
Click on the error to see the offending line of JS, look at the surrounding lines and you'll have a pretty good idea which bit it is. Coffee's output is pretty predictable and consistent. The errors will usually result from your own code, not Coffee's wrappers, so you can always track down errors to an offending line of CoffeeScript. If it's the JavaScript that's wrong (e.g. because you made a syntactical mistake in CoffeeScript, which went unnoticed because it's accidentally valid), you'll quickly notice what's amiss by looking at the JavaScript output. In fact, it's a good idea to look at the JS output to get a feeling for what Coffee does with your code. Plus, there's an enhancement on its way that lets you define line numbers through comments, so JavaScript errors can pick up on those instead. There's a ticket at Mozilla indicating it's going to be implemented sooner rather than later.
To be fair, debugging sucks full stop.
I can imagine someone having said that about assembler and compiled languages a few decades ago, too.
Well, I'm a Pythonista, so the number of shits I give about what RoR devs think is pretty low. For example, I like Sass and Compass too, despite them being implemented in Ruby. I'd actually prefer them not to be, because managing gems is a pain in the ass, but that's just my 2 Euro-cents.
Yes, there certainly are situations where the looks really are more important than ease of use, and the user is expected to be able to work through the UI no matter how unfamiliarly it looks or behaves. The game industry could be a good example of such a case (although I'm not sure wether you're talking about in-game forms or some website forms related to those games; my comment was specifically about forms in websites). The same might also be said about promotional websites for movies or other sites in general, where the authors deliberately choose to sacrifice usability for the sake of style - it is ok to confuse or even annoy the user if the authors knowingly decide to do so for whatever reasons. What I'm saying is that scripts such as these do complicate filling out web forms for a wide range of users, and in the absolute majority of cases that is not what is intended or even thought of. I'm sure most sites where scripts such as this jQuery plugin end up being used do not fall into the very narrow category of well thought-out "Yes, we know exactly what we're doing with our forms and why we're doing it". 
The iPod wasn't successful because of its quality or production values. The iPod was successful because of its marketing. Like every Apple product of the recent years. Just look at the iPad commercials. Not one of them explains what the iPad is or what it is for. But all of them state for a fact that you need it and that it's awesome and revolutionary. It's all about prestige. What else do you think inspired some Japanese kids to stick white shoelaces in their ears when the iPod was hitting the market? If you haven't learned it so far, there's a lesson in this: Quality doesn't matter. Yes, it has to be good enough, but it doesn't have to be _better_. If you have the right marketing and timing, you can sell all kinds of crap to people and make them feel good about it. Apple even goes so far as selling exactly the same product with some minor tweaks to the same customers multiple times each year. Not that Apple products are particularly terrible. They certainly have an aesthetic appeal that matched the zeitgeist. They're just not exceptionally good. And they're certainly not successful just because of their quality. In fact, they're actually not as successful as everybody makes them out to be. They got a marketshare, alright, but internationally that share is ridiculously low.
It is getting there. http://www.webmonkey.com/2011/03/adobe-unveils-wallaby-flash-to-html5-converter/
Muahahaha. Awesome. Next, let's put lynx on it so we can browse while we browse.
Error 310.
That sounds like a conversion tool for Flash developers to use, similar to Google's new Swiffy tool. An actual JavaScript-powered Flash player would be quite interesting.
I'd recommend either using the Unlicense if you want a full free-for-all (you could simply put it in the public domain, but the Unlicense provides a fallback for countries that don't acknowledge the public domain), CC0 (the same, except without the disclaimers) or BSD/MIT if you want to require attribution. MIT is more popular for jQuery plugins because it's what jQuery uses, but in practice 2-clause BSD and Expat MIT are mostly identical except for the phrasing. Before someone else mentions it: there's also the GPL, but it is a restrictive license, so it doesn't seem to be what you want. Free software is about opting out of copyright, not about voiding it; it makes the work uncopyrightable for everyone, not just you, even if they only use your software as a tiny part of the whole.
I'd actually like to see a good combo box widget for jQuery (not UI) that sufficiently matches the default rendering and behaviour of the other form widgets. It should probably be based on the input element. I guess autocomplete pretty much does the trick, though.
[If anyone missed it, BE did a podcast about PDF.JS a few weeks ago.](http://www.aminutewithbrendan.com/)
Inception... :)
Pure sandboxed JS would never work for any but the most basic operations, but I could actually see this being a possibility with HTML 5 as a dependency. Embedding a Flash player JS library as a fallback for systems without a native version could actually be pretty sick. Edit: * [Gordon](https://github.com/tobeytailor/gordon/wiki/) ([demos](http://paulirish.com/work/gordon/demos/)) * [Smokescreen](http://smokescreen.us/about/) ([demos](http://smokescreen.us/demo/))
(js) micro libs are the new black
Interesting points, but I disagree with your "*Please, stop doing this*" stance. Not only does it come off as elitist, but I don't think people should stop exploring, ever. People should push boundaries. A typical user doesn't know what a "select box" is, but they do know what buttons are. His select box styles look like buttons, but when you click on them, a list appears. Does it function exactly like a combobox? No, but this is apparently a new plugin and he can continue to improve it. Does it fall back to a combobox if javascript is disabled? Yes. &gt;this functionality is simply out of the scope of web page code I definitely don't agree with that. Web forms provide a base set of standard features, but they can certainly be extended and I hope people continue to try.
You may want to ask this in [/r/java](http://www.reddit.com/r/java) rather than /r/javascript.
I find anything you write to be pedantic in the extreme, long winded and nitpicky to the point of, well, pointlessness. This is actually one of your more coherent posts, though still a bit backhanded. I'm not really trolling you here though you may think I am, I'm merely offering some obsevations about the comments you've made in this thread (your trolls in other threads notwithstanding) since you've chosen to critique me every chance you get. Now about the line you quoted above. I can see how someone who is in love with coffeescript might take it as being inflamatory, but when we constantly every week here in r/javascript are told that coffeescript is somehow more beautiful or better than javascript in some way, and then this post arrives stating that coffeescript is overrated, then my suggestion that this post is lowering the level of conversation to exactly that of "my language choice is better than your language choice" is not unfounded. You may not see it but this is a defining characteristic of almost every post about coffeescrpt in r/javascript, and the primary reason why you are reading a thread about "DAE think coffeescript is ridiculously overrated" posted in r/javascript. A lot of people who read r/javascript for javascript are completely tired of hearing about coffeescript and the way coffescripters go around bashing javascript, so you surely must understand that the backlash against coffeescript in r/javascript is not unwarranted, especially when there is r/coffeescript that almost all posts about coffeescript belong in more than they do in r/javascript. This is already yet another computing religious war, and as such it is going to get ugly.
Thanks, will do.
It depends on how much you alter the controls. And there are ways to do this with perfectly fine fallbacks. Take a look at Apple's new OS x Lion. The default controls are changed all over. Same with iOS 5. Users can, and do, adapt. Just don't change it too much, and it's fine. 
I think [Wakanda](http://www.wakanda.org/) is also really promising, but it's not browser-based. The server is available for OSX,Win and Linux, while the Studio (IDE) only for OSX and Win.
There is no clear translation there - and it's likely to be your biggest debugging weakness with coffeescript - , but it usually seems a pretty simple matter to translate the offending code section back into coffeescript. My [biggest coffeescript app](https://github.com/cheald/shadowcraft-ui/tree/master/app/javascript/core) is decently large and split up across multiple files, and I don't really have much issue debugging it. I'll agree that there are ways it could get easier, but it's not so hard that it should be a blocker on using Coffeescript.
Normally, I would downvote you for that. But you didn't follow through with the meme and even added a smiley, so enjoy your non-downvote.
Actually fairly heavy tied to firefox -- it uses a lot of spidermonkey only features/extensions to the language. Also the function for shuffling array is just completely wrong. Fisher-Yates shuffling produces a random shuffle. Math.random() as a comparator doesn't produce random shuffling, and is the reason Array.sort() needs to be as slow as it is in JS.
Thanks for the information, I went with the MIT license
'dat entity collection... But: &gt; (function() Math.random() - 0.5) Pretty sure that's not valid syntax.
It's a firefox extension
You don't get to say what is over-run and what isn't, and you don't get to suggest that my opinion is right or wrong and that yours is any more correct than mine. I say it's over-run, and a lot of people here would agree with me. You don't because your argument goes against the title of this post. so what. I think you have a different definition of "over run" than most people. And really, it's been far more than a couple posts a month, maybe you don't read r/javascript that often. It's at least 3 a week if not more, and it has been even more than this in the past. There wouldn't be a post here about "DAE think coffeescript is overrated" if people here didn't think it were over run with coffeescript posts. The point is, a lot of us are sick of it here, and that is enough to cause anyone who wants to read about javascript instead of coffeescript to consider this "over run" with coffeescript posts. really, your arguments don't hold water, you give more conjecture than substance. 
function ({foo:foo}) {} doesn't work, not even in firefox.
I wonder how accessible and semantic its rendered HTML is. If it outputs HTML that is less semantic than I can write by hand then it is harmful to my business even it if saves substantial time. It is entirely possible to be completely valid to the standards and completely opposed to the very intentions of those standards.
Is it surprising? Unary plus converts the string to a number, and typeof any number gives you 'number'.
Oh god, just when I thought the internet would be nice and quiet.
I thought it was going to return something other than `number`. I was prepared to be mystified.
Type coercion is one hell of a feature...
Also the E4x won't work elsewhere. Some of it you need to specify you want js 1.7 or 1.6.
What the hell is this? * Some of these are great * Some of them are completely wrong * Some them are painfully basic * Most of them have no disclosures for browser compatibility (like object.watch isn't supported in IE, call stack for try/catch is different, etc.) * There is pains to note if something is Javascript 1.5, 1.5 ... aka 1998. The opener is like "I have never heard of concat"
&gt;not related to any web browser or any DOM God damn it says right there: &gt;Some of these tricks are using a latest version of JavaScript language (v1.8) and cannot run with the Microsoft Implementation of JavaScript (v1.5). &gt;All these tricks has been tested with the Mozilla SpiderMonkey/TraceMonkey JavaScript engine (v1.8). Also: &gt;These tips and tricks are not related to any web browser This is the 2nd dumbest article/thing I've ever seen.
The !! operator sequence is also worth looking into if you're into this sort of thing.
It surprised me enough to post this, heh.
whats the first
i wonder what happens when you try x / +""
Not sure, but this is the direction they are headed: http://www.wakanda.org/licensing
It was on here a while ago. [Link](http://blog.tuenti.com/dev/top-13-javascript-mistakes/) [Reddit Submission](http://www.reddit.com/r/javascript/comments/gppjt/top_13_javascript_mistakes/) Look at number 5. element.onclick WTF!
To be fair, the opener modifies the array in place, where concat modifies by copy.
This surprised me more than the original post. I didn't know division by zero yields "Infinity."
+'' as well as +' ' and even +' ' yields zero.
I don't want auto play audio on my internet, it spoils things a little bit.
not trying to be a contrarian but there is some decent advice there. #5 is certainly an easy trap to fall into and the point of it has nothing to do with the pre DOM Level 0 way that the author is attaching an event to an element; that was simply a contrived example to illustrate the value passing problem. and then, to be a contrarian I'll say that as an example, that's a better approach then using something like var addEventListener = document.attachEvent ? 'attachEvent' : 'addEventListener'; element[addEventListener]('click', function()); it detracts from the purpose.
IE still has the DOM memory leak.
Most of them have errors. I agree it's just to get the point across but it does so very badly. Some of them are just completely stupid.
Oh, it's actually even better than that: &gt;&gt;&gt; 1/0 Infinity &gt;&gt;&gt; 1/-0 -Infinity &gt;&gt;&gt; 0===-0 true &gt;&gt;&gt; 1/0===1/-0 false It's some IEEE 754 quirk. :)
Perfectly reasonable.
Better learn up on IEEE 754 then.
I'm willing to bet it's surprising for most folks, including myself. Not many folks use (or have a need to use) unary operators in JavaScript, and it seems like a lot of the folks who use them just use them for obscure trivia like this, or for crazy minification purposes. Anyhow, yeah it's surprising, especially since parseInt('', 10) results in NaN. That is also supposed to convert the empty string to a (base 10) number, but it results in something different than +''. I guess it's somewhat interesting but not really useful. It's like the JavaScript equivalent of http://en.wikipedia.org/wiki/How_many_angels_can_dance_on_the_head_of_a_pin%3F
interdasting
&gt; Anyhow, yeah it's surprising, especially since parseInt('', 10) results in NaN. `parseInt` is stricter than just about every other javascript conversion operation. `Number('')` returns 0, and that's basically what `+''` does.
Don't forget `0/0`, yields `NaN`.
It's been a while since I played Monopoly, obviously. Damn, what a battleship. All kidding aside, this was a great slideshow. I hope to learn from this.
I'm in the same boat. Webkit (chrome) has a really nice debugger with break points, debugger commands, watches and all that good shit. Visual Studio has a movable break point (yellow arrow), which you don't get in chrome, but for the most part it's good. The only problem I've had debugging has been my own lack of understanding about closures and callbacks.
I use `+new Date()` all the time, but other than that I don't normally use unary plus.
What happens if you remove one of the passwords via say firebug? Does the server pick up banned password?
Crazy :)
I don't think they'd bother to protect people who go out of their way to use firebug so that they can create bad passwords.
What's the point of this? I see a few that seem less-secure ("12345678"), but why the others?
Or just turn off JavaScript. This is probably just for the frontend restrictions so there'll be less load on the backend. The backend probably has their own password restrictions.
That's not a list of the actual banned passwords. They are rot-13 "encrypted".
Ah, makes more sense. So are they, in unencrypted form, just likely to be passwords that aren't secure enough for Twitter's standards?
["000000","111111","11111111","112233","121212","123123","123456","1234567","12345678","123456789","131313","232323","654321","666666","696969","777777","7777777","8675309","987654","aaaaaa","abc123","abc123","abcdef","abgrtyu","access","access14","action","albert","alberto","alexis","alejandra","alejandro","amanda","amateur","america","andrea","andrew","angela","angels","animal","anthony","apollo","apples","arsenal","arthur","asdfgh","asdfgh","ashley","asshole","august","austin","badboy","bailey","banana","barney","baseball","batman","beatriz","beaver","beavis","bigcock","bigdaddy","bigdick","bigdog","bigtits","birdie","bitches","biteme","blazer","blonde","blondes","blowjob","blowme","bond007","bonita","bonnie","booboo","booger","boomer","boston","brandon","brandy","braves","brazil","bronco","broncos","bulldog","buster","butter","butthead","calvin","camaro","cameron","canada","captain","carlos","carter","casper","charles","charlie","cheese","chelsea","chester","chicago","chicken","cocacola","coffee","college","compaq","computer","consumer","cookie","cooper","corvette","cowboy","cowboys","crystal","cumming","cumshot","dakota","dallas","daniel","danielle","debbie","dennis","diablo","diamond","doctor","doggie","dolphin","dolphins","donald","dragon","dreams","driver","eagle1","eagles","edward","einstein","erotic","estrella","extreme","falcon","fender","ferrari","firebird","fishing","florida","flower","flyers","football","forever","freddy","freedom","fucked","fucker","fucking","fuckme","fuckyou","gandalf","gateway","gators","gemini","george","giants","ginger","gizmodo","golden","golfer","gordon","gregory","guitar","gunner","hammer","hannah","hardcore","harley","heather","helpme","hentai","hockey","hooters","horney","hotdog","hunter","hunting","iceman","iloveyou","internet","iwantu","jackie","jackson","jaguar","jasmine","jasper","jennifer","jeremy","jessica","johnny","johnson","jordan","joseph","joshua","junior","justin","killer","knight","ladies","lakers","lauren","leather","legend","letmein","letmein","little","london","lovers","maddog","madison","maggie","magnum","marine","mariposa","marlboro","martin","marvin","master","matrix","matthew","maverick","maxwell","melissa","member","mercedes","merlin","michael","michelle","mickey","midnight","miller","mistress","monica","monkey","monkey","monster","morgan","mother","mountain","muffin","murphy","mustang","naked","nascar","nathan","naughty","ncc1701","newyork","nicholas","nicole","nipple","nipples","oliver","orange","packers","panther","panties","parker","password","password","password1","password12","password123","patrick","peaches","peanut","pepper","phantom","phoenix","player","please","pookie","porsche","prince","princess","private","purple","pussies","qazwsx","qwerty","qwertyui","rabbit","rachel","racing","raiders","rainbow","ranger","rangers","rebecca","redskins","redsox","redwings","richard","robert","roberto","rocket","rosebud","runner","rush2112","russia","samantha","sammy","samson","sandra","saturn","scooby","scooter","scorpio","scorpion","sebastian","secret","sexsex","shadow","shannon","shaved","sierra","silver","skippy","slayer","smokey","snoopy","soccer","sophie","spanky","sparky","spider","squirt","srinivas","startrek","starwars","steelers","steven","sticky","stupid","success","suckit","summer","sunshine","superman","surfer","swimming","sydney","tequiero","taylor","tennis","teresa","tester","testing","theman","thomas","thunder","thx1138","tiffany","tigers","tigger","tomcat","topgun","toyota","travis","trouble","trustno1","tucker","turtle","twitter","united","vagina","victor","victoria","viking","voodoo","voyager","walter","warrior","welcome","whatever","william","willie","wilson","winner","winston","winter","wizard","xavier","xxxxxx","xxxxxxxx","yamaha","yankee","yankees","yellow","zxcvbn","zxcvbnm","zzzzzz"]
Did you try that? I bet the site doesn't work at all with js disabled.
That does make more sense. Looking closer at the code, is this what tipped you off to the 13 character shift? n = c + 13
Is that the purpose of this list though? I don't think it is. For a start this is a pitifully small password black-list if it's meant to protect against weak-passwords; also, the majority of the entries are non-dictionary, and as we all know the most vulnerable passwords used are dictionary based. So a TINY list of passwords that don't even represent the MOST insecure of their kind stored client-side in plaintext certainly doesn't indicate to me that it's being used to avoid weak passwords. What the hell it *is* actually used for though, I have no idea.
It's probably a list of the top 100 most common passwords or something like that.
&gt; the majority of the entries are non-dictionary No they're not. The passwords are ROT13 encoded (for some odd reason; probably as a joke). Most are either dictionary words, names or easy-typable keyboard sequences (qwerty, etc) when decoded.
Can we assume these are the most common passwords of twitter users?
For clarification, this is the list of decoded passwords. The passwords in the twitter soruce are [ROT13](http://en.wikipedia.org/wiki/Rot13) encoded.
I don't think much of the implementation. Doing ROT-13 on every entry and appending it to a new array is wasteful: it's simpler and more efficient to ROT-13 the supplied password and test that against the array of transformed passwords.
Just tried, they check it on the server side on submit too =[
My friend actually caught the code at the bottom when we were looking at it, but yeah ... the 13 and the 26 stand out in strange ways. Personally, I feel the code could be better compacted. There's no reason at all for it to be in an array and bound to a loop. It could be one simple string. Check it: var s = "1111111 0000000 987654 kkkkkkk ..."; and then you could have simply done an s.indexOf() on the string using the rot13 version of the password they were trying. That would have saved two bytes per password on the list, because you wouldn't need to quote the individual strings.
parentNode.replace(',',', ') :)
Thanks, I'll take a look double bangs and see what I find.
Glad to see fffffffuuuuuuuuuuuu isn't on there
&lt;https://twitter.com/settings/password&gt; Try setting the new password to 'america', Twitter's UI will respond with messages: 'too short', 'weak' and 'obvious'. Dunno why they ROT13'd it, perhaps they did a search in their database and these were the top passwords that were used too often? In that case I can see why they'd would like to keep this information out of sight. Of course, since it's client-side, they can't really hide it.
My theory is that someone did a database query and these passwords were used thousands of times so they decided to block them.
I have an AAS in computer programming and I can shed some light on why this is being done. Firstly, if these are banned passwords then you don't need to worry about security. Nobody's allowed to use them so who cares if they're public? Secondly, it's being done in JavaScript for input validation before any information is sent from the user's browser to the Twitter server. While the server will still make sure that the input password is not one of the banned passwords by making JavaScript tell the user to change it first you're cutting down on the amount of work that the server itself will need to do. Thirdly, using ROT13 on the array is being done just to obfuscate the code so people wanting to abuse the system will need to actually go to a little trouble to decipher them.
Really great slides! Alot of subtle yet significant differences. Being picky, I would like to point out a small typo on slide 82; in the `$.each` loop (on the third last line) the variable `v` should actually be `key`.
hunter is there but hunter2 is not. It's all good.
Seven 7s. My friend actually uses this as his password.
To everyone suggesting that Twitter did a database check of their most common passwords and used them to make this list, they sure as hell better not have that capability. Passwords **must** be hashed and randomly salted (e.g., nearly impossible to recover to plaintext) or this so-called tech leader is being run by a larger assload of incompetent nitwits than I thought.
that would be awesome.
I think the ROT-13 is there to avoid adding extraneous words like "fuckme" and "vagina" to their page content so it's necessary.
I think the reason they ROT13'd them is because the list contains several variations of "fuck", "vagina", etc.
Ah, that makes more sense... I was wondering why they would ban random looking passwords :p
What's his email address and preferred username?
Ah, of course. Otherwise search engines and the likes may pick them up. Didn't think of that.
I'd like to think Twitter doesn't store passwords in plain text.
You miss the point. The inefficiency is as follows: Given that f(X) = Y f(Y) = X i.e. ROT-13 is a reversible function, and that we are trying to test the proposition that the password is a member of the set of banned words, then it's simpler to test whether *f(password)* is a member of the set of ROT-13'd banned items than to ROT-13 all of them and then test the plaintext password. That is to say, if the banned list is ROT-13 (which is reasonable) then you don't need to ROT-13 all of them: instead, you only need to ROT-13 the password being tested.
You're right. I misunderstood what you were suggesting.
Maybe they just ran a query and google'd the top 50 most used hashes, if google returns the value it's a shitty password. The interns have to do something when everyone has coffee!
They should upgrade to ROT26
Bad developer, no cookie.
I've seen quite a lot of slides like this and I'd say most of them are repetitive. However, the jQuery.single() is by far the best idea I've seen yet.
Lucky number 7!
Their database reads must be such a bottleneck for them that I bet they do tons of client-side validation just to save on backend trips. Half the site fails with Javascript disabled anyway so I doubt accessibility is that important to them.
I heard that's what Sony uses to protect its customer information.
If they're salting the passwords that wouldn't be possible either.
No salt?
No, but they could generate a list of "bad" passwords and run them trough their password-hash function .... tada...
Based on the list of decoded words, I think it's obvious why they're encoded... so they don't have things like "bigdick" and "blowme" in their raw HTML. I LOL'd ^_^
&gt; For a start this is a pitifully small password black-list if it's meant to protect against weak-passwords Not at all. These things are subject to power laws: there are easily ten thousand times more people using "password" and "abc123" (in the top 10 most common) than "sesquipedalian" (in a full dictionary). Even a very simple blacklist will force an attacker to iterate hundreds or thousands of times rather than tens of times. That makes no difference to an offline attack, but against online attacks it's possible to implement other security measures like rate-limiting, blocking access after X failed login attempts and so on. Without a blacklist, blocking access after X attempts still leaves a large number of users exposed -- if X is 10, trying the 10 most popular passwords against every account would get you access to 3-5% of them. I imagine Twitter is subject to a great many very simple attacks by bored script kiddies who know less than they think they do. This seems like a simple, effective defense -- and if it can slow down more sophisticated attacks by an order of magnitude, it's a nice bit of defense-in-depth too.
True, but then again, this is one of those trivial things like using $var-- instead of a for loop to shave 3 nanoseconds off your loop... it's really not going to make any noticeable difference. And since JS is executed client side... no resources are wasted on Twitter's end. That's the beauty of Javascript - distributed computing power! Just joking... kind of ^_^
Yeah. One less hit to their servers is one less fail whale that someone else might encounter. :)
Um, has the monetary cost of learning jQuery and JavaScript ever been a problem for anyone?
Not that my password is particularly invulnerable, but I got hacked and I don't visit unquestionable sites. My suspicion is that they don't has their stored passwords... 
Salts are designed to prevent exactly that. When properly implemented, a random salt is generated for every password. For example, your hash function in pseudocode might look like function salted_hash(password) string salt = generateSalt(length) return salt + "$" + hash(salt + password); Where `generateSalt(length)` creates a random alphanumeric string, `"$"` is a delimiter to show when the salt ends (you will generally have a set length for the salt, but I do this anyway instead of hoping the size will stay consistent forever), and `hash()` iteratively hashes the salt concatenated with the password using some known algorithm (there are functions specifically designed for this, like `hmac`, avoid md5 and sha1.) Then you store the returned `salt + "$" + hash` in your database. As you can see, every time you run your function you will end up with a new hash, even if you pass it the same `password`. This means that a would-be hacker would have to generate a bad passwords list for *every single salt you've used* in order to check all of the passwords.
Now we just need to convince lots of people to use 'ovtqvpx' as their password.
They use a powerful algorithm called "plaintext"
Little does WanderingGlitch know, but my password is but a string of asterisks.
We don't.
We don't store passwords in plaintext.
I agree completely. Just joking... kind of ._.
Working in PC repair I had a customer who had his password as all asterisks. It was his first laptop, and he set it as that cause he thought it was gonna force him to do that anyways.
How do you use the same salt when a persons logging on as the one they used when they first set their password, if it's random? If it's pseudo-random... then it can be calculated, and the hashes created from that... - slow, but possible.
Here's the list ROT13'd..... the JavaScript makes mention of "Too obvious"... 000000 111111 11111111 112233 121212 123123 123456 1234567 12345678 123456789 131313 232323 654321 666666 696969 777777 7777777 8675309 987654 aaaaaa abc123 abc123 abcdef abgrtyu access access14 action albert alberto alexis alejandra alejandro amanda amateur america andrea andrew angela angels animal anthony apollo apples arsenal arthur asdfgh asdfgh ashley asshole august austin badboy bailey banana barney baseball batman beatriz beaver beavis bigcock bigdaddy bigdick bigdog bigtits birdie bitches biteme blazer blonde blondes blowjob blowme bond007 bonita bonnie booboo booger boomer boston brandon brandy braves brazil bronco broncos bulldog buster butter butthead calvin camaro cameron canada captain carlos carter casper charles charlie cheese chelsea chester chicago chicken cocacola coffee college compaq computer consumer cookie cooper corvette cowboy cowboys crystal cumming cumshot dakota dallas daniel danielle debbie dennis diablo diamond doctor doggie dolphin dolphins donald dragon dreams driver eagle1 eagles edward einstein erotic estrella extreme falcon fender ferrari firebird fishing florida flower flyers football forever freddy freedom fucked fucker fucking fuckme fuckyou gandalf gateway gators gemini george giants ginger gizmodo golden golfer gordon gregory guitar gunner hammer hannah hardcore harley heather helpme hentai hockey hooters horney hotdog hunter hunting iceman iloveyou internet iwantu jackie jackson jaguar jasmine jasper jennifer jeremy jessica johnny johnson jordan joseph joshua junior justin killer knight ladies lakers lauren leather legend letmein letmein little london lovers maddog madison maggie magnum marine mariposa marlboro martin marvin master matrix matthew maverick maxwell melissa member mercedes merlin michael michelle mickey midnight miller mistress monica monkey monkey monster morgan mother mountain muffin murphy mustang naked nascar nathan naughty ncc1701 newyork nicholas nicole nipple nipples oliver orange packers panther panties parker password password password1 password12 password123 patrick peaches peanut pepper phantom phoenix player please pookie porsche prince princess private purple pussies qazwsx qwerty qwertyui rabbit rachel racing raiders rainbow ranger rangers rebecca redskins redsox redwings richard robert roberto rocket rosebud runner rush2112 russia samantha sammy samson sandra saturn scooby scooter scorpio scorpion sebastian secret sexsex shadow shannon shaved sierra silver skippy slayer smokey snoopy soccer sophie spanky sparky spider squirt srinivas startrek starwars steelers steven sticky stupid success suckit summer sunshine superman surfer swimming sydney tequiero taylor tennis teresa tester testing theman thomas thunder thx1138 tiffany tigers tigger tomcat topgun toyota travis trouble trustno1 tucker turtle twitter united vagina victor victoria viking voodoo voyager walter warrior welcome whatever william willie wilson winner winston winter wizard xavier xxxxxx xxxxxxxx yamaha yankee yankees yellow zxcvbn zxcvbnm zzzzzz
You, twitter? =O
&gt;How do you use the same salt when a persons logging on as the one they used when they first set their password, if it's random? &gt;return salt + "$" + hash(salt + password); It's right there.
They don't store their passwords in plaintext, Twitter isn't fuckin' retarded.
I don't know if he works for twitter or not, but I can guarantee you they don't store plaintext passwords.
It's ROT13'd so that search engines don't see "vagina" or "fuckyou" in a Twitter page. Nothing at all to do with obfuscation.
&gt;How do you use the same salt when a persons logging on as the one they used when they first set their password, if it's random? You separate the part to the left of the '$' (the salt) and the part to the right (the salted hash) and recalculate the salted hash using the salt when the user logs in. It would be easiest to make a separate function to do this. If the returned value matches the original salted hash, they can be authenticated. &gt;If it's pseudo-random... then it can be calculated, and the hashes created from that... - slow, but possible. Correct, but once someone has access to your database it's all about making it as difficult as possible to acquire anything useful. After all, *you* at least need to be able to calculate it, otherwise you can't authenticate the user. Using a salt and hmac means that it will take a very long time to brute force anything, considering they have to calculate the entire table for every single salt you using, when you even hashed it iteratively. Also, take note that this is actually how salted hashes are implemented securely, it isn't some sort of theoretical thing I made up. This is the best you can do as a last line of defense after someone steals your database. It is definitely enough to stop a brute force attack, but perhaps not enough to stop a selective dictionary attack (like using the 401 words in the twitter blacklist) depending on the number of users they are targeting. It would probably take a year or so to just calculate the 401 hashes for 1,000,000 users. Calculating anything more than those is increasingly infeasible.
Why does it matter? Unless you have to work with the person, it's should be a great feeling of job security for you.
Sorry, I have to agree with OP. To me it's a def n00b sign.
&gt; this is a necessity for what i am trying to do What are you trying to do?
I hear you have to have 9 P.H.D.s in cryptography in order to actually write code using plain text.
i've been working on a script to add missing features to older versions of IE. i've figured out a limited way to do what i want which is to wrap each method in a another function. document.getElementById = (function(m){ return function(){ return m(arguments[0]); }; })(document.getElementById); http://pastebin.com/GH6YWNzR
Here's a reusable one so you don't have to declare them all, also this in theory should allow you to actually execute the function with a different 'this' (but in practice will probably throw an error if attempted, but at least it throws an error in that case and doesn't do something technically incorrect like yours). This has the caveat that you should not attempt to 'fix' any functions that are recursive, also without being able to execute apply or call we can't pass an arbitrary number of arguments to the original (I've set 10, alter to whatever is suitable): function fixFunction(object, methodName){ var original = object[methodName]; function wrap(a,b,c,d,e,f,g,h,i,j){ this[methodName] = original; var ret = this[methodName](a,b,c,d,e,f,g,h,i,j); this[methodName] = wrap; return ret; } object[methodName] = wrap; } fixFunction(document, 'getElementById'); edit: another issue with your example solution is that it will fail in standard compliant browsers, you will be executing getElementById with a 'this' value of 'window' which will throw a WRONG_THIS_ERR. (edit2, I guess you're only running this script in IE so should be no problem there).
Y U NO LIKE KITTEH? LOL
This is a good presentation. I especially liked the suggestion to use `$.text` instead of `$.fn.text`; that's something immediately useful to me. I was surprised to learn that using jQuery selectors like `:first` and `:eq` forces jQuery to use Sizzle instead of `querySelectorAll`. That means using a function like `$.fn.eq` instead is [considerably faster](http://jsperf.com/jquery-eq-vs-eq). It makes sense, I guess, but I had assumed selector paths like that would've been optimised. Now I know why the `:eq` selector was almost removed a while back.
I sincerely hope they did not mine their database for common/weak passwords and make them available publicly.
That makes it completely redundant then...What's the point?
Think of it as a DSL. Even HTML is a DSL derived from SGML.
Maybe they do, and you're just being a bit of a snob about it?
You're correct that this example is trivial and inconsequential, but if the rest of the front end code of twitter.com is similar, it might explain its poor performance.
Now that's another n00b sign, since HTML is not a prog. language. And JS today is also a server language.
That could be it too. I hadn't thought of that.
Thanks for this. It's nice to have some high quality videos for beginners like me. I'll be watching them here soon.
why would they ban "bigdick" and "blowme" anyway?
I lol'd
Many people first are learning jQuery and then maybe they are learning JavaScript. Many don't want to bother to learn JavaScript. Actually there are more code and examples for jQuery then for JavaScript itself. So I don't blame them.
did you say "programming language" or "language" HTML is a markup language. 
Counter argument here http://www.skuunk.com/2009/04/jquery-when-does-library-become.html 
I would agree that many people who know how to use jquery don't know how to write javascript. 
It's one less http request their servers need to handle...
You win this game by playing it with some hardcore techno in the background.
Sometimes, I think I'd prefer to program in jQuery over javascript...
I might try this: http://jqueryui.com/demos/animate/
http://jsbin.com/ewafaq/edit &lt;-- using jquery
This from a person who uses "noob" and :/facepalm" in a discussion about precision of language and pedantry. 
Works in Firefox too.
Good point.
Pretty awesome, I can't wait to get a bit of time to tinker with game programming on the web. I never did yet, because I never liked Flash.
I think trying to go for simplicity by using the underscore hurts readability and adds awkward punctuation. I think these utility functions are valuable but hijacking an uninformative namespace doesn't help. Maybe start an ArrayUtils namespace with the intent of being the foremost source of optimized array manipulation. JavaScript needs more forward thinking developers and not people fighting to monopolize the shortest namespaces.
&gt; or it involves any knowledge from legitimate Artificial Intelligence (don't get confused: game AI has nothing to do with research AI,) i thought this is implied - we are talking actual games here. &gt; What you tried to say: "Video games are the most sophisticated code I've seen personally." yep
&gt; &gt; &gt; Video games are one of the most sophisticated pieces of technology, bringing together a wide array of knowledge from AI &gt; &gt; don't get confused: game AI has nothing to do with research AI &gt; i thought this is implied - we are talking actual games here. Jesus christ.
The problem here is that Underscore -- as I understand it -- is primarily a functional programming microlib (_map_, _reduce_, etc.), with some random bits of other functionality baked in (_template_, etc.). On a related note, it's been reported that JS microlibs have cured cancer, stopped all genocide, fed all the hungry of the world and found a new source of water.
Hahaha I think NASA uses them in spaceships. Unfortunately a flawed language like javascript cannot provide us with a clear solution. I agree that readability is vandalized but I prefer over it writing tones of code. 
I thought most of these were obvious... * of course jQuery's `each()` is going to be slower than a vanilla `for()` or `while()`. * of course accessing the object directly e.g. `this.id` is faster than using jQuery e.g. `jQuery(this).attr('id')` * etc Also, the slides on chaining are misleading; it's not by virtue of chaining that it is more efficient, it's that the results are cached. Implying that "chaining" is more performant is just adding confusion to a simple issue. Lastly, why does he argue in favor of upgrading with: &gt; As 47% of the popular sites on the web use jQuery, changes are heavily tested. When just 2 slides earlier he demonstrated how many of the same "popular" sites mentioned _are still using legacy versions_? Wouldn't those sites have to be actually using jQuery 1.6 for his statement on slide 16 to hold any merit?
I had some DJ Shadow playing, worked quite well.
This goes in the &lt;head&gt; of your document &lt;script class="jsbin" src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"&gt; &lt;script&gt; var options = { current : 1, slideInterval : 5000, fadeInterval : 1000 }; function nextX() { var allX = $('#fader').find('li'), oldX = allX.filter('li:visible'), newX = oldX.next(); options.current = options.current % allX.length + 1; if(options.current === 1){ newX = ($(allX[0])); } oldX.fadeOut(options.fadeInterval, function(){ newX.fadeIn(options.fadeInterval); }); } setInterval(nextX, options.slideInterval); &lt;/script&gt; &lt;style&gt; ul, li {list-style: none; margin:0; padding:0; color:red} #fader li {display:none;} #fader li.default {display:block;} &lt;/style&gt; This goes where you want the ticker to appear in &lt;body&gt; &lt;ul id="fader"&gt; &lt;li class="default"&gt;Hello World 1&lt;/li&gt; &lt;li&gt;Hello World 2&lt;/li&gt; &lt;li&gt;Hello World 3&lt;/li&gt; &lt;li&gt;Hello World 4&lt;/li&gt; &lt;li&gt;Hello World 5&lt;/li&gt; &lt;/ul&gt;
Are you sure this is webgl, it works in ie9. 
*cloning my comment from the /r/programming submission:* Feel free to check out [JSShaper](http://jsshaper.org) also. It's got some unique features, such as preserving formatting and comments and providing powerful declarative matching. Great to see that there's a growing interest in JS syntax tree shaping / AST transformations / code rewriting.
I can confirm this.
feels like 1988 all over again.
This is going to save me bundles of money.
It appears to use three.js, which can also render to a 2d canvas.
Too bad it stutters :(
&gt;[22/84] getElementByClassName() not supported in IE5-8 jQuery doesn't support IE5. &gt;[71/84] Unless absolutely necessary, avoid loops. They're **slow** in every programming language. Loops are *fast*. var i, start = Date.now(); for(i = 1000000; i--;){} console.log(Date.now() - start); 975 Not even one second for 1,000,000 iterations. And that's with a 200€ (~$287) office machine from 2007. Even the super slow (relatively speaking) `$.each` is usually fast enough, because the looping overhead is tiny compared to the hefty price of DOM manipulations. When in doubt, use a profiler. (The font looks nice, but is kinda hard/annoying to read.)
yea, i was aware of the window issue, but i couldn't work out a way around it. i changed my wrapper method to work like your example, and it seems to working pretty well. thanks for the help!
Yep, works great in my FF5 and Opera too. :)
Awesome.
I do work for Twitter, and we don't store passwords in plaintext.
As there doesn't seem to be anything in 3D, A 2D canvas is perfect for this kind of thing.
Same *goddamn problem* every WebGL game has had recently. Beautiful, simple, elegant implementation, controls fuck up because mouse gets to the top or edge and stops moving. I'm not even sure of a way to solve this :S
Websites for coding that don't have the width set to view a simple code sample. *sigh*
Why is this downvoted? Seems like a good submission to me.
actually, I think the crosshair in this is a pretty good (decent) solution - you need to see the crosshair to control the thing, so you keep it on the window. here's a discussion of the problem for anybody who doesn't understand what we're talking about: http://stackoverflow.com/questions/5768783/how-can-i-implement-a-fps-view-with-webgl-inside-a-browser
Downvoting epic played-out meme of over-hyped project with reddit.
The code you linked doesn't support colours. Check the `ToHex` function: function ToHex(strValue) { try { var result= (parseInt(strValue).toString(16)); while (result.length !=2) result= ("0" +result); result = result + result + result; return result.toUpperCase(); } catch(e) { } } First it converts the input from decimal to hex: var result= (parseInt(strValue).toString(16)); Then it pads the result with zeroes until the length of the hex string is exactly 2 (what happens if you feed the function with a value that converts to a hex string that's three digits or more?!): while (result.length !=2) result= ("0" +result); The takeaway is that the function expects a value between 0 and 255, i.e. a brightness value. After this, the hex string is tripled before it is returned: result = result + result + result; return result; Which yields a grey colour since all the colour values are equal. E.g., if we used `63` as input, it would first become `3F` (in hex) and then become `3F3F3F`.
fail
What is interesting about this document?
If you followed the link you would have realized that the company's name is Epic Win and its site was built using Backbone.js
Doesn't change my opinion.
You should always, always sanitize data that comes to you. Always. *Always*. Assume malicious users at all times. Javascript might not just be turned off; it can be completely rewritten. Cookies can be rewritten. Everything that doesn't happen on your server is a nuclear warhead padded with blast-resistant, Bieber-blaring stereos designed not just to kill you, but to make sure you suffer while you die. Users are not just evil. They are the root of all evil. Users are the eternal blackness that existed before God said, "Let there be light." Chuck Norris cannot roundhouse a user into goodness. Zalgo is an amateur user. Users do not forgive, do not forget, and have over nine thousand penises raping children this very second. Javascript is good for keeping less committed users from hitting your servers with infectious dumb too often and for keeping some users docile and pacified with prettiness and a more responsive user interface. Don't let it lull you into a false sense of security!
Wait, it's a hosting website and you need a what? Aren't those just static pages to do a sales pitch and then some backend that has a very basic shopping cart? Why does everything have to be so grandiose?
The most commonly used passwords are a matter of public record. It's also not particularly important that users don't use Twitter's most common passwords. It's more important that they don't use what an attacker thinks are the most common passwords.
I wouldn't have gone so far as to write [a book on CoffeeScript](http://pragprog.com/book/tbcoffee/coffeescript) if I thought it was overrated. CoffeeScript has been saving me time and headaches ever since I started using it. It's taught me to appreciate JavaScript as a first-rate Lisp-y language with an unfortunate amount of boilerplate. And the community is great. As pg noted in [The Python Paradox](http://www.paulgraham.com/pypar.html), new languages tend to attract smart, passionate developers. To paraphrase him: "People don't learn CoffeeScript because it will get them a job; they learn it because they genuinely like to program and aren't satisfied with the languages they already know." Yes, the debugging tools at this point aren't great, but the ability to quickly write elegant code—and tests—means you'll have fewer bugs to worry about in the first place, once you get to know the language. So give it a shot. You might get to enjoy it. P.S. I should note that I fall firmly in the "You should understand JavaScript if you're writing CoffeeScript" camp. The two are deeply intertwined, and I try to explain how all of CoffeeScript's features translate into JavaScript in my book. The whole point of CoffeeScript is that it converts to JavaScript in a straightforward way, keeping the extra abstraction minimal.
Overrated by whom?
Maybe they built a custom customer admin portal. I haven't found a cheap host with a nice admin interface.
Yeah, remember that too. You could totally use IE6 js error line number reports as a pseudo-random number generator. And absurdly useless line numbers aside, the messages themselves were also vague, unhelpful, and occasionally very misleading. About the only useful thing you could gain from an ie6 js error message is that a js error might have occurred (it being ie6, there were also instances where ie6's js engine failed, or memory leaks from earlier js execution caused working javascript to fail until a browser restart). When you develop for ie6 it's like you are fighting against it, not working with it.
I've never worked directly with coffeescript, so I don't have the requisite experience to make an unbiased judgement call about it. But to me, it's really reminiscent of rjs back when rails was still in version 1.x. Rjs was hyped (nothing like the way coffeescript is hyped though), and it looked pretty cool and it was definitely fun to use at first, but working with rjs in a large project was ultimately a huge pain in the ass, in no small part because the javascript output could not be correlated directly with the rjs. I eventually had to rewrite everything in plain javascript. Granted, coffeescript is a completely different beast meant to solve a different problem, but I feel like at least some of the characteristics that I hated about rjs I would come to hate about coffeescript if I started to use it. Mainly, it just seems like the cleaner syntax is really not enough to justify the extra compilation layer. Again though, I'm speaking from a standpoint of not actually ever having used coffeescript; maybe if I used it I would find it makes things easier, not harder like I expect it would. (I'm also a pretty seasoned js developer; I'm so comfortable with javascript syntax as it is that my bias is further increased against a layer of different syntax -- for new people coming to js development, coffeescript syntax might be a lot more appealing).
Maybe. But if they wrote that, they shouldn't be hosting computers, they should be selling software.
visit epicwinhosting.com, experience 10 second load time between static template node.js pages, realize they're offering IIS over AWS, laugh out loud and close tab.
It was actually Walter Gretzky who said that, not Wayne. Small nitpick to an excellent point.
Why? The company I work for sells photos but we also do the vast majority of development in house.
Couldn't he just use .empty().append(HTML_string) and get the same effect?
Nope. .append() on HTML strings also uses innerHTML under the hood.
I hear claims like this often. I see no evidence of how the JS that CS produces (to accomplish some given task) will run more quickly once compiled than JS written by (insert who you think is the greatest JS programmer in the world). Frankly, I doubt such evidence exists, because I don't see how it could exist. So I assume what is being said is: CS helps programmers who are not very skilled in JS to write better JS (...because CS syntax is easier to understand, and so on...). Which is probably useful to many people. Perhaps the perception that "CS is wildly overrated" comes from observing the number of people who read "The CoffeeScript you write ends up running as fast as (and often faster than) the JS you would have written" and assume that the statement is true. It is falsifiable simply by having CS generate some sort of algorithm or other testable JS which is slower than what (insert your JS hero here, or even yourself, the *you* of the dismissive claim above) submits.
Are you sure? I skimmed through the jQuery source and couldn't see it used in .append() or in domManip() which the append function calls. It's only mentioned a couple of times in the source, mostly for doing some quick tests, and of course, in the .html() function.
Yes. append calls domManip(), which calls buildFragment(), which calls clean(), which sets innerHTML.
From the site: &gt; Oh, and you don't have to bother with some crappy "control panel" website to set up your site - just Remote Desktop in and get to work.
And what if you used jQuery to create HTML? var $p = $('&lt;p /&gt;').append('some text'); $p.append( $('&lt;span /&gt;').attr('class', 'red').append('more text') ); Does this still use innerHTML somewhere?
I'm not sure; I think jQuery may special-case the single HTML tag. I still like my function since it makes the transition from innerHTML quite painless and almost mechanical (and doesn't depend on jQuery), but this is a nice idea, thanks.
I love backbone, I think it's awesome, but... I'm not trying to be negative but, for a blog post touting the benefits of backbone.js the site the author built has no backbone.js anywhere that I can find. If the intent was to showcase the thing he built with backbone it would be good to see the finished product, and if that thing is behind a paywall and this is a veiled attempt to get customers well... 
That's much clearer, thanks! I think I was tired when I read your first comment.
I wrote a very similar library myself called Haj: https://github.com/Sidnicious/haj.js It can be paired with a templating library called Stencil: https://github.com/Sidnicious/stencil.js I really love the idea of working with HTML in a more-native format than text, before it gets into the DOM. No risk of injection, and easy to manipulate.
Oh, and I forgot to mention, [here](https://github.com/Sidnicious/node-to-jquery-haml)'s a function to serialize existing nodes (say, from some HTML you've been prototyping) into a Haj array.
Welllll... there was that one programmer a few weeks back doing the debugging... there's a big text file of plaintext passwords that people have been logging in with in root.... ;o)
You're not doing anything with the variable Product so of course nothing is happening. Before your "return" do: document.form1.Product.value = Product; http://jsfiddle.net/tAEwb/
I'm not sure i can be much clearer than this: &gt; We don't store passwords in plaintext.
Don't hate me for asking this, because my coworker asked me, and I don't really have an answer myself: "What is the point of this?"
Thanks so much! I'm learning this as I go, I appreciate the help. 
Looking at the PDF document, JESUS CHRIST, it looks like a script kiddie wrote this. There's no x-height. I'm not into typography, but this document visually looks FUCKING AWFUL. It's very distracting that the letter r (among a score of others) is a lot smaller than its neighbors. [This link is NOT a pdf, but it's the same document, just on the web](http://developer.apple.com/library/mac/#documentation/ScriptingAutomation/Conceptual/JSCodingGuide/Introduction/Introduction.html).
The point of the project is to be able to render pdf documents in the browser without the need of certain proprietary software such as Adobe. Not requiring a 200mb+ install that has a huge history of bugs, problems, and security holes has a significant appeal among developers and IT security people. I think a lot of people are hoping that this thing starts kicking Adobe Reader in the ass.
Yeah, I know what you mean, I was just quoting a claim but I'm not worried about speed myself. I'm never doing anything crazily intensive, I'm more concerned about readability, and speed of me actually coding. If I want to smash out a quick loop through an object, it comes naturally and I know CoffeeScript is doing is efficiently.
Yeah, but Foxit isn't that bad.
Yeah, but it's still a browser-specific extension, and you don't always control your own browser.
Source mapping is being added to the major browsers as we speak. Brendan Eich has opened a ticket for Mozilla to add transcompiler source mapping to Firefox. And Webkit are working on the same thing. Mozilla ticket: https://bugzilla.mozilla.org/show_bug.cgi?id=618650 Webkit ticket: https://bugs.webkit.org/show_bug.cgi?id=63940 Expect to see a lot more action in the use of JavaScript as a compilation target. Update: Just announced today https://twitter.com/fitzgen/status/89736745620475904 Mozilla summer project for Source Mapping: https://wiki.mozilla.org/DevTools/Features/SourceMap 
JavaScript is going to see more action in this space as a compilation target. One of the best outcomes of this is that it gives language authors, and the TC39 / ECMAScript committee the chance to test and evaluate "in the real world" features that may then be slated for addition to the ECMAScript standard. Many of the features of CoffeeScript are similar to or the same as proposals for ECMAScript.next and Harmony. In some ways, you could even consider it a look at where JavaScript is likely to be headed in the future. I think everything happening in this space is much more than just "Is X Overrated", there's a bigger movement at play, and Brendan Eich has publicly stated his support for these experiments. To help foster JavaScript as a compilation target, source mapping is being added to the major browsers, so that debuggers will report the original line mapping of the parent language, rather than the compiled JavaScript line number. Mozilla ticket: https://bugzilla.mozilla.org/show_bug.cgi?id=618650 Webkit ticket: https://bugs.webkit.org/show_bug.cgi?id=63940 And I think CoffeeScript is far from overrated. What Jeremy has achieved is outstanding in my opinion. Reading Brendan's blog, and the current tabled proposals at the ECMAScript Planning Wiki help put some perspective on things. http://wiki.ecmascript.org/ http://brendaneich.com/2011/05/mozillas-nodeconf-presentation/
The last two fields aren't working after that modification because you still have this line, even though the `bE` element doesn't exist anymore: document.form1.bE.value = bE; This emits an error and exits the function before processing the rest.
Regarding Foxit: it's not cross-platform, it's not something Mozilla has control over, and it doesn't demonstrate the functionality present in modern browsers (functionality that can be applied toward other rich internet applications).
You want [toFixed](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Number/toFixed). Keep in mind that all numbers in JavaScript are floating-point numbers. They don't lose or gain precision. So to show a number at a certain precision means you have to format it as a string (which is what `toFixed` does). (3.14159).toFixed(); "3" (3.14159).toFixed(0); "3" (3.14159).toFixed(1); "3.1" (3.14159).toFixed(2); "3.14"
Have you seen regexpal.com? Its pretty similar just faster.
I'm being pedantic and mentioning one of those rogue unlikely-to-happen situations. From your comment I'd think you're a project leader/co-ordinator? =D
Loosen up kiddo, it was a joke...
Since your question was already answered, you'll get some drive-by bitching instead. Your variable names are f-ing awful. &gt;`OnClick` It's `onclick`. Also note that this is obtrusive JavaScript. &gt;`&lt;input type="button" OnClick="Calc()" value="Submit"&gt;` Should be: `&lt;button type="button" ... ` unless you do intend to provide a server-sided fallback. &gt;bgcolor Use CSS. &gt;`&lt;br&gt; &lt;br&gt;` Use CSS.
Even in Opera? Amazing, never tested on it. (I made FastKat, FYI)
I confirm it uses the three.js canvas fetures, as it is more widespread.
sounds foolish to me. If you are spending significant time on a product that you aren't selling then either sell it or stop spending time on it.
Yes yes. I changed variable names so the company I'm doing this for wouldn't get upset. I am going to move everything to CSS - I was just trying to get it mocked up really quickly to throw up here for help. Didn't know about the input type should be button and onclick though, someone told me to do it that way. Thanks for pointing it out. 
I guess I am just confused about fundamentals in which case I should spend more time learning and less time experimenting.... My goal was to have one variable that was rounded and one that was not, for calculations. I'm gathering that that is not how it should be done. Thanks for your help. 
Ok I'll give this a shot. I guess I'm a little confused about where I actually put the toFixed. I'm booting my work computer to try it out, I'll see if I can get it there. Edit: I'm a noob. I can't apply toFixed in the variable definition because then it affects the calculation. So where do I apply it?
The issue with the modification is that you're setting `document.form1.bE.value`, which no longer exists because you've renamed it to `roundedbE`. You can still use your `bE` variable for calculations, but you have to either remove the `document.form1.bE.value` line, or change it to the following (while keeping the input box name as `bE`): document.form1.bE.value = roundedbE; Edit: To clear up any possible confusion, this is just to fix the problem of the bottom fields not working after your modification, and has nothing to do with the actual number rounding.
You actually don't want to use `toFixed()`, as it doesn't round the number. Your `Math.round()` line is the proper way to handle rounding, and will work just fine once you get the element naming issue fixed (from my other comment).
`toFixed()` does not round, which is what the OP is trying to do.
Awesome! Thanks for understanding my probably confusing description. I was able to take this explanation and apply it to several different instances, and everything works exactly like I want it to this way!
Github repo here: https://github.com/visionmedia/caustic Title link is to a screencast that demos the features of the lib. Overall it's a decent abstraction that seems like it would eliminate quite a bit of boilerplate. I still prefer Backbone Views but this is a nice simple abstraction for people using plain old jQuery.
Friends don't let friends use Y2K-ish stuff like innerHTML (doing innerHTML can let you code faster for small web pages, but it's dirty for the parser, and using DOM 1/2/3 functions cleanly manipulates the DOM tree). Even IE5 (I BETTER NOT CATCH ANYONE DOING document.all, since the last browser to need this was IE 4, which can't render most shit-simple layout even half-correct today) does the important parts of DOM level 1. It's way cleaner and you run into less bugs this way. It also allows you to save your pages as .xhtml so you can have the browser engine parse it as XML rather than HTML for a speed boost on mobile devices.
I don't think there's much to dodge as the generated output is very readable and quite easy to map back to the CoffeeScript source. But having direct access the break points and debugging tools from the original source would definitely be good. Line number reporting is being added to webkit and mozilla. Have a look at: http://www.reddit.com/r/javascript/comments/ig1ig/dae_think_coffeescript_is_ridiculously_overrated/c24gy9w
Maybe it's great, but what a lousy name! My skin burns a bit just reading it. Caustic author: seriously consider renaming it.
omg tl;dr; why can't you just get to the fucking point? i'm not reading all that mental diarrhea
Since `Function.prototype.apply` and `Function.prototype.call` are Functions, they can themselves be `.call()`ed and `.apply()`-ed, so the following are all equivalent (rationalisations of what's happening as comments to prevent meta-overload): // Call apply() in the context of document.getElementById with the arguments: document, ['header'] Function.prototype.apply.call(document.getElementById, document, ['header']) // Apply apply() in the context of document.getElementById with the arguments: document, ['header'] Function.prototype.apply.apply(document.getElementById, [document, ['header'])) // Call call() in the context of document.getElementById with the arguments: document, header Function.prototype.call.call(document.getElementById, document, 'header') // Apply call() in the context of document.getElementById with the arguments: document, header Function.prototype.call.apply(document.getElementById, [document, 'header'])
I've backed up everything, numerous times, but I'm not inclined to waste any time responding to you because you are such a pain in the ass to deal with. That waterfall of text you just posted up there is nothing worth reading or responding to. People do actually agree with my assessment of coffeescript, no matter how you try to spin what I say or try to bash me. I don't have time to send you every fucking post or response to my posts to 'prove' anything to you, you pedantic geek. You try to win your arguments by boring me to death, so forget about any kind of rational discourse here. Again, you're a waste of time.
I'm curious of the performance hit for all that. There is a lot of generation going on that I would assume causes overhead. I love the simplicity of the templating. I might steal some of that for another project. 
is a trap.
You have issues.
Woah.
JavaScript appears to have evolved nicely over the past few years..
I'm very curious as to what possible purpose this serves?
Javascript libraries have been created to make certain tasks easier but last I checked, at large, it's still far behind the [ECMAscript](http://en.wikipedia.org/wiki/ECMAScript) 5 standard. 
Hm, I have the impression you're a few years behind on the trends in what's the best style for doing web programming... Not that trends are necessarily good technical arguments, but it's still interesting to note. xhtml? Speed boost? I thought everybody these days was "down with XHTML, HTML 5 is the way to go"! What speed boost is this? "Saving as xhtml" sounds weird anyway; shouldn't you have to set the mime type or something? And while I saw a lot of people argue against innerHTML years ago, that seems to have gone away pretty much these days. innerHTML is really convenient, and is in HTML 5. 
You're forgetting can do HTML5 as XHTML. Basically an XML file with HTML5 tags, and the browser will take it. Mime type would be application/xhtml+xml With innerHTML being convenient, that's true, but it's ugly and "wrong" since it has open up the parser again, and many coding errors creep up from it (character escaping one thing I see LOTS of sites still run into). I personally like doing XML since it makes sure the parser doesn't get confused on JS being embedded with the HTML. FYI, the CDATA stuff really only works on thetrue XHTML pages (not the fake XHTML that most of the internet does (PUTTING THE XHTML DOCTYPE IN DOESN'T MAKE THE DAMN XML PARSER READ YOUR SHITTY HTML! :/)), i.e. sent with the application/xhtml+xml mime type.
[This](http://javascriptweblog.wordpress.com/2010/08/30/understanding-javascripts-this/) post has more extensive explanation and discussion about this keyword.
node is 'powered by' the V8 engine.. saying it's powered by C++ is sort of meaningless. browsers are too, by that logic.
I just don't see how doing anything as XML would make things faster. It's true parsing happens twice, but the overhead of parsing tends to be pretty small, and innerHTML can still be faster than doing the manual DOM insert. Plus having a client-side template in text format can be useful. Not sure what you mean by coding errors - I haven't noticed that myself. 
I haven't tested it in any sort of scenario to compare it to something like [underscores template function](http://documentcloud.github.com/underscore/#template) or [Handlebars](https://github.com/wycats/handlebars.js)/[Mustache](https://github.com/janl/mustache.js) but if you look at what the [caustic code](https://github.com/visionmedia/caustic/blob/master/build/caustic.js) is doing it's pretty simple. 
HTML parser might notice things like '&gt;' and '&lt;' being used in JS and might attempt to parse it as HTML, which is why I actually try to do it as cleanly as possible. Though it is a very n00b mistake, I've seen this happen on websites like aol.com digg.com bbc.co.uk, the list goes on. I like XML for it forcing me to do it cleanly, though a quick .innerHTML is easier to do. XML parsing is lighter though and shows up on things like older iPhones and slow Android phones. FYI, google does application/xhtml+xml for its mobile version of google for iphones (The last time I checked at least).
Interesting to see your comment and the downvotes. I was exaggerating just a bit to make a point. If you or any of the other downvoters would care to elaborate, I'm curious: Don't you think it's useful feedback for a library author to know that a name has unpleasant connotations?
Meow.
I don't generally mix my JS with HTML, I put them in different files. 
If you like the brevity of `+new Date()`, try leaving out the parens: `+new Date` works just as well - you can omit an empty constructor argument list when using the new operator.
Can't say the same for other web developers though, that's the problem. :(
Perhaps you've encountered unary operators more often than you think. What about code like this: // Given a foo object with an isVisible() method: if( ! foo.isVisible() ) { // foo is not visible } or: var offset = -window.scrollY; or: // Given a variable foo of unknown type: if( typeof foo == 'string' ) { // foo is a string } Actually, I used to think that `typeof` is a function, so I coded the above like this: // Given a variable foo of unknown type: if( typeof(foo) == 'string' ) { // foo is a string } That also works, but not because `typeof` is a function. I *was* surprised when I learned that `typeof` is a unary operator and those extra parens aren't needed. It's true that unary **`+`** is less common that these other operators, but you will often see it used to convert other types to a number, as in ripter's `+new Date` example, or code like this: // Get the value of an option element as a number var n = +option.value; Once you know how these operators work, the one remaining thing is to know that JS, like all similar languages, evaluates a series of unary operators from right to left (because it wouldn't make sense the other way around). Here's to fewer surprises in our coding! :-)
Clever, but I don't think it works in IE6. It works in IE8 though.
Much like the JVM is powered by C or C++ and doing all the actual work. Oh yea ... and Python ... and Perl ... and Ruby ... and PHP ... and Erlang ... and ...
:D
The website allows us to sell our product. We're a leader in the industry largely in part because all our software was developed in house. 
I would guess simply that you could then browse a repo and edit files through an ajaxy client? 
First, use JQuery, it'll make this much easier. What you'll want to do is take the document's height and width. Then set the width of your container object and the height minus whatever you need to contain controls for pagination. Then, shit, I guess split your text into an array (split on spaces,) then step through the array, adding the text to the container object then test the height of that object. Once you hit a word that makes the height larger than the expected height, step back one word, close off that container, append a new container, do the same thing until you've finished the array. Then you can set all those containers to display:none, find the first container and toggle it display: block. Then you can use add nextchild and prevchild functions to your next and back buttons to toggle the display of the serial containers.
Interesting that the closure compiler fails on that file... I'm wondering what the reasoning is for compiling the JavaScript on the fly... to me, it makes much more sense to do development with uncompiled JavaScript to make debugging easier, then compile immediately before deployment.
wow much appreciated! and here i thought people were going to make fun of me!
and... QBasic Nibble!
Audacious.
Haven't checked very recently have you? The latest versions of the current browsers (including IE9) generally have almost complete ES5 support.
Contrary to the downvotes your post received, you're absolutely right. "Why?" is the correct response to this. Javascript is for client interpreted code on a web page, not version control systems. That coupled with the fact that there is already a perfect functional git implementation developed in anohter language makes a Javascript implementation a complete waste of time.
Fair few rendering problems for me. Words overlapping each other or partial text. Firefox 5.0. [Screenshot](http://i.imgur.com/RrEyr.png) Pretty inspiring work though. Do more of this.
Yay! Because learning jQuery and Javascript is otherwise so expensive...
I too would have liked to see them compare gzipped size, not just minified. There are some optimizations which decreased minified size but actually HARM gzipped size. Closure seems very good at avoiding this. For example, gzip really loves repetition. For gzip, it's cheaper to repeat the same statement ten times than to "optimize" this by pre-calculating it once and assigning it to a variable or function.
Works fine for me in IE6: http://imgur.com/tPmh1
nice! this solves the argument limit issue that i was having with the other method i was using.
Now you can run git on a non-jailbroken iOS device? . . . I got nothin'.
Seriously, js is so fast these days, and people generally do so little cpu intensive stuff in the browser. Unless you clearly need to optimize a heavily hammered piece of code because it lags on a slow computer or something, this serves only to preach premature optimization. I'm not saying to not cache your query selector results, but a lot of this is nitpicking.
Wish it worked in Chrome.
I'm still waiting for generators and list comprehension to be in more browsers than just Firefox. IE is also still missing getter/setters. I'm not saying you're wrong, but there are a number of very useful things which one or more browsers have had years to implement but haven't.
A commenter makes a snapshot comparison which resulted in a smaller file from Closure, but Uglify had the smaller gzip'd version.
&gt; Interesting that the closure compiler fails on that file... Something's amiss; I ran the current version of [`jquery.cookie.js`](http://plugins.jquery.com/files/jquery.cookie.js.txt) through the online [Closure compiler](http://closure-compiler.appspot.com/home) and it [compiled fine](http://closure-compiler.appspot.com/code/jscd84e140674f2f236c6b1bf5875428bd2/default.js) with all 3 different options. So, either the OP is using an outdated Closure compiler, an outdated `jquery.cookie.js`, both, or is being affected by some bug due to environmental differences.
I agree with you, the name itself has negative connotations and sheds a negative light on the project from the get-go. You normally want to name your project something that either exemplifies your project's spirit or goals, or otherwise creates positive attitudes, neither of which this current name provides.
What is the reasoning for the unary "`-`" preceeding function declarations? -function(){ ... } Seems to precede each anonymous function; does it somehow nullify the return value to aid in GC or something? 
This is EXACTLY what I need for a project I'm working on. Thanks!
IE9 supports getters and setters just fine. Generators and list comprehension are not an ES5 standard.
var a = {}; a.__defineGetter__('myval', function() {return 'a'}); &gt; "Object doesn't support property or method '__defineGetter__'" Works fine in FF and Chrome. Above is IE9's error. EDIT: apparently Reddit doesn't like showing the double underscores around `defineGetter`
This should work: list.sort(function(){ return Math.random() - 0.5 }); 
i hope you realize, and i've made this quite clear, you are talking to yourself. i'm not reading your replies because they are worthless. 
I played around in firebug with this, here's the differences as far as I can see: (function() {})(); // returns undefined -function() {}(); // returns NaN I'm not sure whether it would provide any optimizations or not. Maybe it's just a stylistic thing? Not having to type the extra parens is kind of nice ;) 
You are attempting to use non-standard behavior. DefineGetter is Mozilla's proprietary method of creating getters. If you read the ES5 standard, you'll find the methods of creating getters and setters that all vendors agree upon, namely: Object.create, Object.defineProperty, Object.defineProperties, and the new object literal syntax. Try this: var a = { get myval() { return 'a' } }; 
The return value is discarded anyway, so the unary `-` is just another way to force the function expression to be parsed as an expression so that it can be called immediately by the `()` at the end. It's the same purpose that the extra parens have in your first example. Any unary operator will do the same thing - try these for example: !function() { alert(42); }(); typeof function() { alert(42); }(); And now try it without any of these: function() { alert(42); }(); That results in a syntax error.
Okay, this is impressive and why I love functional languages. 
And you got downvoted too! Go figure. :-)
Cool, thanks for the info. I think I prefer the parens still.
Nice, thanks for the explanation, it's a cool shortcut to remove those extra parens ;)
I believe this has much more to do with JS allowing for any object to have any property defined – more dynamic type than functional. While it is a functional language, I don't think you could achieve this same trick in, say Haskell, or rather, if you could, it would be done in a similar way to how you would do it for Java, which is neither dynamic (at least not as JS is) nor functional.
Lot of human activities are "complete waste of time". Such as climbing the Everest or posting comments on Reddit. :)
I guess I was thinking more towards Ruby and Python, where you can do practically this and more pretty easily.
Sure, which are also dynamic languages - you could call them functional as well, but the properties of the language that make them functional have little to do with this feature (again, see Haskell). Its also possible to write very non-functional python/js (I don't know ruby well, so I'll leave that along) where this trick will still work. Its also possible to write very functional code where this trick is useless: $.ready(function() { var buttons = $('.button'); function missingInWaldo() { alert("you'll never find this function"); } buttons.click(missingInWaldo); }); is a trivial example using jquery where your function 'missingInWaldo' won't be found - this can be implemented with straight JS, but jquery makes it easier to write and understand quickly.
I'm just gonna stop leaving comments if it means getting lectured over trivial technicalities. Thanks.
Anyone got any links that show ES5 support in various browsers? Would love a comprehensive source.
You just go on thinking you've won. you haven't by any measure. Your opinions are just that, opinions, and you haven't proven them any more than I have. I think a lot of what you say is completely full of shit. You aren't any more correct than I am based on YOUR FUCKING OPINIONS.. don't confuse opinion with fact. You will never concede that you might be wrong about anything I disagree with, and I will not concede that I am wrong in the opinions that I hold. If you can't understand something this simple, and how it's a waste of my time to try to "prove" anything to you, then just give up. Please, just stop going on and on about I haven't proven anything, because neither have you. I'm beginning to think you have aspergers or something the way you go on and on about how I must prove to you anything I say, as if you are so important. Just give it a fucking rest dude. You haven't "won" anything, you can't "win" anything here, so what is your point really? seriously, whats the fucking point about arguing endlessly about opinions. my opinion is that coffeescript is a worthless piece of crap and I am entitled to that opinion. You are entitled to your opinion that I am worthless piece of crap, but arguing about that is just foolish, and you are the one playing the part of the fool here because you just don't know when to give up. I'm going to continue having opinions that you don't like, and you can reply to them all you want, but for what end? Ok, so maybe you want to make me look bad, but you really aren't because enough people actually do agree with what I'm saying to nullify any protesting you may do about what I say. Saying that I have to prove anything to you is just so ridiculous, if you have read everything I've written and still don't agree with me, then fine, but i'm not going to be wasting my time on convincing you that my opinions are valid when you will never believe a word that I say just because I say it. what the fuck would be the point of that.. seriously, what is the point of endlessly trying (but failing to) beat up on someone who has a different opinion than you. You are more of a bully than a troll. 
http://test262.ecmascript.org is the official test suite, so you can compare across browsers (IE10 platform preview gets the highest score by a good margin). It's beta though. Kangax has a quick overview, but this does little to show how well the features are actually implemented: http://kangax.github.com/es5-compat-table/. The table is also doesn't have IE10, which implements strict mode and would get an entire column of green. Not sure if Chrome 13 implemented strict mode or not. In any case, latest released versions of Firefox, Chrome, and IE are very near complete ES5 implementations.
Thanks much for the links!
Many of the users I encounter here live for arguing on the most trivial technicalities. It is discouraging, I feel your pain.
Another technique set the text into a container div setting its height to auto. Once you do this, you can wrap that container into another wrapper div an position it absolutely at top 0 and left 0. Set the overflow of that wrapper to hidden. Now lets say the height of the wrapper is h. Now all you get to do is create a hyperlink/button on click of which you would move the container top with top - h. This would move the top up and enable virtual pagination for your div. Ofcourse using jQuery, Backbone, dojo, etc.. would make this task easier. Hope this has been helpful...
Sorry, I'm not trying to be a dick about it, it was just my apparently feeble attempt at making conversation. I tend to think it is important to understand what features make each language unique, to see why a particular language is good for a particular use case. I'm typically partial to Java on the server, but have been working with django lately, and do a lot of work with both raw JS and GWT on the client, in an attempt to see what works well for what kinds of projects. Again, sorry for the lecturing tone, and going a little meta, how might you have taken this discussion to draw the distinction as to how this tool does its thing?
Ah, I may have missed the point of his comment entirely then – I had been commenting on the fact that such a system works because of the dynamic nature of the language – in static languages, static analysis tools can do this same trick through other mechanisms without actually starting the runtime. Thanks for pointing out this other way to view DrHankPym's point.
Thank you very much for that information. I'm looking forward to being able to use it in 10 years when IE8 is officially over with.
Works for me on Chrome and Firefox (linux). There is a lot of work to be done but it's an interesting start. Now they'll have to find the 3D artists willing to provide all the *coherent* art, at least for units... 
I've had this in my JS shell for 3 years: https://github.com/kristopolous/js-shell
&gt; Works for me on Chrome and Firefox (linux). Works in Webkit trunk on OSX, although it gets significantly slower as you "fill in" the map (from a vantage point where you can see the map). Does not work in Safari stable (5.0.x).
Lovely, am I supposed to be waiting for longer than 5min for it to start? Does Java need to be enabled?
It was instantaneous for me. Maybe you should look at the developer console (Ctrl+Maj+I) to see if there is an error.
Did you press 'Draw Map' ?
Well I just tried it on Windows/Chrome and it worked. That's odd. Didn't work on Safari/Chrome with OSX Lion.
Related: http://code.google.com/p/chromium/issues/detail?id=72754 Please star it.
Failed for me. &gt;Error creating WebGL context. Three.js:294Uncaught TypeError: Cannot call method 'clearColor' of null THREE.WebGLRendererThree.js:294 mapinitfreeciv.js:194 (anonymous function)/webgl/freeciv/:378 onclick/webgl/freeciv/:379 Chromium 12.0.742.112 (90304) Ubuntu 10.10
Your video card may be blacklisted (mine is). Trying running Chrome with the **--ignore-gpu-blacklist** switch.
Your video card may be blacklisted (mine is). Trying running Chrome with the **--ignore-gpu-blacklist** switch.
Looks like some setting. I get failures on the [webgl demos](http://www.khronos.org/webgl/wiki/Demo_Repository) as well. Will look into it later.
 $('responses').getChildren.each(function(item) { alert(item); }); $$('#responses') will return a single item with the id of responses. You'd have to modify the selector to select the children instead, or use my example above. Say responses was a UL, and what you were trying to do is get the LIs, you'd use $$('#responses li').each instead.
[Caustic](http://en.wikipedia.org/wiki/Caustic_(optics\))
would that be the case for attributes? I have a form element in the html and each input tag has an ID of responses like so: &lt;input id="responses"/&gt; 
Very nice, Ran it on Insane in Chrome. 
Ids should be unique across all HTML elements on a page. If you want to mark several elements related to each other, use class &lt;input class="responses" /&gt; Then use appropriate CSS selector: $(".responses").each(/* ... */);
&gt;The only one here confusing opinion with fact is you. The first sentence here is evidence that you are delusional and cannot tell fact from opinion. Most of what you say about coffeescript (and javascript) is opinion but you treat it as fact. I admit that most of what I say about coffeescript is opinion. It is a flaw in thinking to claim that most of what you have been saying about coffeescript is anything more than your opinion. I'll give you that a small percentage of what you say is fact, but it's a standard troll tactic to claim anything they say is indesputable fact, and that is what you have been doing. Except now your tirades are personal and relentless, and combined with your insistence that your word be taken as indisputable fact, this also makes you a bully.
Man, do I miss using Mootools.
I love using Mootools. Don't have anything to add that hasn't already been answered, just saying.
ya mootools is excellent, I just picked it up this week and this is my first time writing my own code. My company actually works directly with the creator too, it's kind of cool :) edit: I should say, the company I work for
wish it worked in firefox 5.0.1
me too.
Joomla is still based on mootools I think. That said, I'm a huge JQuery fan.
Love the comment in the article: &gt;Incorrect. &gt; &gt;This is using a Firefox only E4X pattern. &gt;Do not teach people this fairly useless technique. &gt; &gt;var string = “Hello\n\ &gt;I’m a\n\ &gt;Really\n\ &gt;Multiline\n\ &gt;String”; &gt; &gt;Try the above. &gt; &gt;This will work regardless of browser. &gt;(The “trick” here is the end \ is escaping the new line. Genius). 
 $$(".responses").each(/* ... */); FTFY
Mootools: jQuery for developers.
Mootools: jQuery for developers.
Just a note, rather than parsing an XML doc you may want to just encode your data in JSON so you don't have to worry about any conversion. It'll already be in Javascript notation { problems: [ problem: { question: 'What is 1+5?', answer: 6 }, problem: { question: 'What is 4+6?', answer: 10 } ] } 
Oh! Too cool. Thanks for pointing that out. Now I feel better about that caustic name. :-) (Seriously, not being sarcastic!)
If this script is placed in the head then the browser haven't parsed the body yet. Therefore there is no element with id 'randompic' at the time the script executes. You can either place this script last in the body or you can change the last lines to this: window.onload = function() { randomPic(); document.getElementById('randompic').onclick = function(evt) { randomPic(); }; }; 
The way Mootools does inheritance is one of my favorite parts about it. I wrote a slick SVG manipulation library and then used that to make some nice charts and really cool data visualizations.
That effing did it. Beautiful. Thank you so much. I'm not sure I fully understand the reason it didn't work though. If the browser hasn't parsed the body meaning no 'randompic' element yet, how come window.onload was able to call the function but not onclick?
You basically told the browser, "Hey, when you are ready to run window.onload, here's the function you should execute." Then, at some point in the near future, the browser runs `window.onload()`, which then starts the whole process.
These kinds of threads tend to swing around whichever group of developers is on at the moment. Kind of interesting from a study perspective, really.
Oh ok. So window.onload *waits* until the page loads to call the function (makes sense now that I say it aloud), at which point the browser has parsed the body and found the 'randompic' element, so all is good. I figured since the onclick came after that, it would work. But the onclick has to come after the browser has seen the element in question, which is why it has to go at the end of the page or inside the new window.onload function. Am I following this right?
I've started a new job and have to use jQuery. I am dying a little inside. I know I could use both but it seems so wasteful. *Sigh*.
1. If you want to separate javascript and html, don't keep it in variables. Add &lt;img id="yourImage" ... &gt; to the DOM tree and set it's src atribute. 2. You may use simpler syntax: var allPics = new Array( "first", "second", "third", "etc." ); Read about redundancy. Ahhh, and 3 :). Don't waste memory for useless variables. I mean l, r, t and i :).
&gt;I copied it straight from the book I'm learning from How old is it? &gt;`allPics[0]="&lt;img src='image1.jpg' width='350' height='300' /&gt;";` Too much repetition. You only need to store the paths in the the array since everything else is fixed. In this case it's even more extreme, since the path can be generated ("image" + number). `[...].innerHTML = '&lt;img src="image' + num + '.jpg"/&gt;';` Set width/height via CSS. Alternatively, you can target the image tag itself and just change its `src` attribute.
Almost. The retrieval of that element with that id can only happen after it was parsed. E.g. `document.getElementById('foo')` returns `null` if an element with that id doesn't exist (yet). Trying to set an attribute of `null` results in a `TypeError` which shows up in the console. So, the click handler always works. As long as you attach it to some existing element.
the xml parsing can't be gotten rid of. That's about all I can say right now
It's a syntax, you either like it enough to use it or you don't.
Depends on ones mindset. Some people like that stuff, but the extra layer only seems to get in my way when I look at them. Maybe someone is just not smart enough? I hope it's not me. 
This is a very glazed over criticism of CoffeeScript. Besides new syntax, it adds new idioms that aren't present in current JavaScript, most importantly (for me, at least) being destructuring assignment. To only compare the features that mirror JavaScript 1:1 only as syntactical difference is disingenuous.
A Reddit post to an article that was written about another Reddit post. The circle is now complete.
We definitely need to rehash this more times per week.
&gt; destructuring assignment. That's also going to be in [the next version of JS](http://wiki.ecmascript.org/doku.php?id=harmony:destructuring). Personally, I think CoffeeScript is a good bit better than today's JS, but probably not as much of an improvement over what Harmony may end up being. But it does have one compelling advantage: it exists today.
I lied. I tried to make the code for what I was trying to do follow an example the book gave for something else. So that's why it didn't work right.
yep, i can verify this.
Another tip: declare static variables outside of functions to conserve memory and for performance. You only need one instance each of "allPics" and "l"
&gt; If you want to separate javascript and html, don't keep it in variables. Add &lt;img id="yourImage" ... &gt; to the DOM tree and set it's src atribute. This is mildly bad advice, if you're concerned about performance. Never add to the DOM before manipulation. Create the element, either independently, or as a child of a documentFragment; manipulate the element/attributes; finally, append to the DOM.
You can do it faster in about:flags - it's the fourth one in the list for me. Just enable it and you'll be ready to go. Btw, you need ATI's drivers if you have an ATI card.
You are right! I forgot this was MooTools...
Chrome with it's V8 is very close to meeting the standard. And that table needs to be fixed, V8 had strict mode for some time now. I think even Chrome 7 would support strict mode.
"Uncaught RangeError: ArrayBufferView size is not a small enough positive integer." Uhm, what are you attempting there?
I hope they did. * goes to write dictionary attack script * Thanks twitter :).
&gt; For example, I like having to declare variables via the var operator (soon to be replaced via the improved let operator), because it makes it explicit where you start using it and helps with catching typos. Wow, just wow. This is such utter bullshit, its unbelievable. You know what happens if you make a typo and create a variable without `var` in JavaScript? No, the compiler won't complain, it will create a global binding. How the heck is this better than creating a local variable with a typo in CoffeeScript? And this stuff with Ecmascript.next is also strange. Yeah, cool, shorter function syntax, coming to your browser somewhere between 2020 and 2025. Of course way better than having it right now in CoffeeScript.
Or you can use a js.next compiler: http://code.google.com/p/traceur-compiler/
At what point it gets about as "complicated" as using the CoffeeScirpt compiler.
&gt; CoffeeScript is a modern version of JavaScript Rage building...
From the link: "As of 1 September 2010, the newest release is v1.3 and can be found at SourceForge"
Noob question: what are SHA hashed used for?
Sorry man, Strict mode was implemented in V8 3.2, which was released with Chrome 12. When it released it was very buggy, which is why the table doesn't show that it has support. The expression (function(){ "use strict"; return !this; })(); didn't evaluate to true, an issue that was fixed in V8 3.3.10/Chrome 13. Looks like Chrome 13 is getting close to a complete Strict mode implementation though.
the most typical use of SHA hashes are for a one-way password hash. For instance you take the word, "mypassword" and turn it into gibberish that can not be reversed, "91dfd9ddb4198affc5c194cd8ce6d338fde470e2" Then to check if the password someone gives is valid, you SHA the submitted password and compare it to that gibberish. There are other uses as well. What a hash function does is turn a string into a number. If you've ever heard of a [hash table](http://en.wikipedia.org/wiki/Hash_table), what that does is turn a key into a number and map it to a position in an array. There are a number of other uses for a hash function, for instance the Riak database uses SHA for [consistent hashing](http://www.tomkleinpeter.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/). If you have the time, watch this video. He goes over hash tables and hash functions: http://www.youtube.com/watch?v=UPo-M8bzRrc If you have more time, watch all those videos :) 
I didn't tell that you must add it from JavaScript;). You may add it to html file, and it is of course faster.
very nice and useful!
zooming map in Safari causes a "Slow Script" alert
Loved that comment.
Haven't come across a project that was hosted on SourceForge in a while.
Can't tell if sarcasm.
Nice article, I wish we saw more of these instead of the "top X blah" or "10 JS tricks every dev should know" crap.
Definitely not.
I agree, and while I rarely post to r/javascript I will continue to put these up in the hopes that people see some advantage in branching out beyond front end engineering. 
How are you "missing" it then....do you work somewhere that it's not used, I'm guessing?
yes I can read that, so... what's your point? :)
very nice but...it's coded in Ruby, so what's this doing in /r/javascript ? :) Anyway, I prefer [RegExr](http://gskinner.com/RegExr/) waaay better! Yeah I know it's in flash, *gasp*! But it does a wonderful job.
I really like the styling, and the interaction, I'll have to check this out. I have had some fun using [polymaps](http://polymaps.org/) as well.
w00t!
I don't have time to watch all this. Can anyone sum up what the problem is, and (if any) the proposed solution?
I'm going to make an article about your post now.
Experimental iOS support has been added in latest release
NO.
*standing ovation after your reply*
Problem: Javascript is a distributed-code system (the client runs code shipped from the browser). How can this be done securely? Solution: Modify Javascript to allow it to be easily implement an object-capability model for security. The modifications are changes in ECMAScript 5 (freeze, "use strict", etc) &amp; their provided .js file. Mark Miller claims that with the language changes ECMAScript 5 is the most easily secure-able OO language. He also details the steps that their javascript implements to secure the language. The last part is about how to write distributed algorithms (he gives a work queue example) but to me that wasn't the core of the talk.
Reminded me of [Micheal Scott](http://cdn.uproxx.com/wp-content/uploads/2011/06/michael-scott-no.gif)
In fairness, his response has about as much depth as the original article.
I use Mustache with great satisfaction, but I'm always intrested in other templating systems. Caustic looks very intresting and its reflection-on-dom-fragments (or whatever it may be called) is certainly a notable approach, different from other templating systems. However, I don't like the usual way of grabbing the template from inside a script tag: if it's a valid html fragment, then it should be sitting right in the page. These other templating systems are definitely worth checking out: https://github.com/hij1nx/weld#readme https://github.com/raid-ox/chain.js/wiki/ http://www.matthias-georgi.de/patroon
I guess it was a commensurate response ;)
yes definitely! And polymaps looks cool too, thanks for the link!
Don't forget git! Git uses SHA hashes as commit-ids. http://progit.org/book/ch1-3.html#git_has_integrity
Suppose I chose a work factor that takes 1 second in javascript, how long would it take in a well-optimized native implementation?
There is no hope for Javascript. Never!!1
I hate JavaScript and CoffeeScript. I'm up at almost 2am at work because of the two. Sure, could be the .COM boom 2.0 but I have to blame something. 
Maybe smalltalk that runs on top of the JavaScript runtime ? ;) http://jtalk-project.org/
A better choice for passwords would be [bcrypt](http://en.wikipedia.org/wiki/Bcrypt), which also happens to be on our JS front-page [right now](http://www.reddit.com/r/javascript/comments/ip8yf/javascript_bcrypt_implementation/). There are many uses for SHA and the algorithm is designed to be fast. Hash functions which are designed specifically for passwords, like bcrypt, are designed to be slow. This makes them more resistant to brute force attacks than fast hash functions.
I love closures, I love the async, I love first class functions. I hate how loose it is with typing.
I like everything BusStation16 likes about JavaScript but including loose typing. The only thing I don't like is the DOM
Runs everywhere and starts quickly; you can pull in libraries from all over the place without any install/setup issues. 
JavaScript is great. The DOM isn't. Boy am I glad I don't use the DOM too much.
An even though the DOM sucks there are decent frameworks out there to abstract the problem to bearability 
Neat tool, uuuuugly interface.
 * I love how terse you can make code in loosely typed languages. * I love functions as objects. * I love prototypal inheritance.
Read "JavaScript, the Good Parts" for a complete list both of what's good about JavaScript, and what's bad. Overall, I like JavaScript a lot, but I would like it more if they had left out some of the bad parts.
But now we have jquery! 
I'm not a huge fan of jQuery, I feel it tries to do too much, and it's too anti-pattern friendly. But as a dom abstraction layer it's a great tool.
I don't really like that book so much. I think it's pretty loose about the good parts (Javascript Regex's for example are pretty weak, but still listed as a good part because they're critical) and its focus is so low level. Syntax can be good and bad, yes, but what can you do with it? That's what matters more, to me. With statement, for example... awful thing, but it allows one really cool powerful thing: dynamic injection of identifiers into your lexical environment, without polluting global scope or using eval.
What's a first class function vs a regular one?
The main principle is that with first class functions you can pass functions as parameters to other functions. 
All this, and I love that you can alter plugin code on the fly. (This is made slightly more difficult by the obfuscation of minifying, but it still works fine for overriding jQuery code if you fetch the source.) I even like the DOM because I can abuse it to get different elements in an area to play with each other without naming anything: $(this).parent('.section').find('.otherbit').
I agree with you in principle, I really do. And you made some very good points. But your argument as a whole is valid only from a technical perspective. Most software is written for commercial purposes and, like it or not, aesthetics are an important factor. When done right they can be a competitive advantage. Why shouldn't I, as someone who generates income from my online software, have the ability to replace the preposterously ugly - and you cannot deny that they look ugly - default browser-based inputs with aesthetically pleasing alternatives? It is far more important to me as a business owner serving a user base in a single country with a single language (I'm willing to bet a large percentage of small and maybe even medium websites fall into this category) to have the option to make my software more appealing to the eye. In many cases I don't need all of the bells and whistles you have mentioned and am delighted to see alternatives, such as the one listed in this posting, that allow me to make my software more appealing. Asking people to stop such initiatives for the sake of technical purism is ridiculous. Let developers choose for themselves rather than knocking such initiatives
I love that javascript is so widely supported, running on all modern browsers. I love that functions are first-class. I hate the weak typing and the Java's-deformed-bastard-child syntax.
Yes, as I already mentioned in another reply, it is ok to do these things, if one really knows what he's doing, is aware of the downsides of doing it and makes an informed decision based on the needs of each specific situation. What I am against is simply including such a script without thinking things through, or possibly - and I've seen a lot of this - without even knowing that the script is not a fully functional replacement of the actual form control. A lot of developers do tend to simply type something like "custom styled html select" into google, find one of these scripts and happily use it in their site while remaining completely oblivious to what is actually being done. Also, in case of select menus I wouldn't call things like keyboard navigation "bells and whistles" that matter only to technical purists. Such things are widely used by website visitors, although, of course, it may highly vary depending on the kind of audience of each website.
where everywhere is a web browser with scripts enabled. edit: I was merely pointing out that it's not completely ubiquitous, yes it can run in 99% of web browsers and some other enviroments but like anything it has it limitations.
document.getElementById('foo').parentNode.removeChild(getElementById('foo')); seems pretty intuitive to me!
I have such a hard time *finding* those
I had no idea how cool and flexible anonymous functions were until I finally started using jQuery.
You might really like Closure Compiler's type checking, then.
I hate the name. It has barely anything to do with Java.
Haha, well it's better than it's official name, "EcmaScript". In the words of Eich, "ECMAScript was always an unwanted trade name that sounds like a skin disease."
alright... what the heck is wrong with the DOM? I mean... if you're using JS without dealing with the DOM... what the heck are you doing? Maybe I've been coding in it for waaayyyy too long, but what do you think is so wrong with the DOM?
Inconsistencies between browsers (which is getting better by the version), and overall unfriendly API. Consider JQuery vs. using raw DOM. JQuery is usually far and away a better developer experience.
I like everything BusStation16 likes, and everything that OriginalSyn likes about JavaScript but including the DOM. The only thing I don't like is the lack of threads.
I'm a little confused as to why, because jQuery doesn't really have much to do with javascript programming, as such. It's just a DOM manipulator, right?
 function(el) { el.parentNode.removeChild(el); }(el); Well, it's shorter at least...
Both are horrible compared to just calling it LiveScript.
No. Every major OS is capable of hosting JavaScript outside of the browser. It is actually an incredibly ubiquitous language. Look at Rhino for example.
Too microsofty.
I personally think that's one of its best features. You can write multithreaded-like applications without having to worry a thing about race conditions. Sure, you're limited with what you can do in terms of long computations, but javascript is the wrong tool for that job anyways.
It's a bit more than what OriginalSyn said. Its that functions are treated essentially like any other type of data. You can define them inline, pass them around, return them from another function, etc. This creates an entire new level of expressiveness for the language.
I agree. I just mentioned SHA's use for password hashes because that appears to me to be a conventional use for SHA. It may not be the best hash function for passwords but it's appears to be used often.
I hate null vs undefined and == vs ===. Lua does it better. The best thing about javascript is that it's everywhere. 
Presumably he'd never really *used* anonymous functions until he had to start passing callbacks to jQuery API calls. :-/
Clearly needs kittens and rainbows.
[You can make it into a mini desktop](http://www.jsdesk.com/) what is there not to like??
correct, sir! (what's with the face? hate people who learn stuff?)
which not modern browser does not support it?!
Yes being able to pass them around is great, even better, the ability to load a function with context of your choosing, i.e. arbitrary functional context AND send them around. The fact that you can mimic Haskell with relative ease should send a note that this ain't no shake and bake operation. (I have no idea what that means, im just trying to convey that we're rocking and rolling.)
I love how close it is to [Scheme](http://www.ccs.neu.edu/home/matthias/BTLS/) with closures, first class functions, lexical scope that just works, objects-all-the-way-down. I hate how far it is from Scheme in lacking continuations or syntactic abstraction so all your async code turns into deeply nested continuation-parsing hell with no possibility of escape, breaking the language's core features in the process. I'm mildly uncomfortable writing applications in it without owning a metrobeard or a fixed-gear bicycle.
What about FuckYeahScript?
It has threads on the bleeding edge platform. They're called Web Workers, and they are awesome :)
Haha, the hipsters are just loud. For every Internet Hipster there's 100 hardcore devs that only care about getting shit done!
I'd join the fun but there is just no punning with the DOM. It's a chaotic beast, and there is no sense to be made of it. Burn IE with fire, it's evil. It is known.
yea i don't agree with this at all. your post is all buzz words. 'tiny contained blocks of functionality,' you mean functions? how is javascript any better at that? 'tightly defined interfaces,' ive used interfaces in many languages, what makes javascript's tight? 'extremely maintainable,' have you refactored a large javascript app? how did that go? was the lack of compile time checks a real bonus there? anyways.. javascript is nice. i like the C like syntax. i like that objects can be extended on the fly. i like json. i don't like how the this keyword works. i don't like how inter-file dependencies are managed. i like how everything is a map. i dont like how without unit tests javascript feels like it could blow up at any moment. i would like optional static types like in actionScript for compile time checking, as well as making refactoring much safer.
Javascript is not supported by some very old browsers, and is poorly supported by some not-so-old browsers. Also, I should say it is supported by *most* modern browsers, since there are many text-based browsers that do not use it.
Not really, you have to ping an external file with the context-agnostic event to start a webworker. I'm not that big a fan of threading specifically as a concurrency model, but please don't confuse the semantics of scheduling, locks, and memory-sharing with the relatively basic/simplistic web workers. Edit: don't get me started on the overhead of web workers as opposed to something like green threads or the erlang process model.
JSLint now also warns against type confusion, but probably not to the degree that CC does.
What's not to like. It's the read/eval/print loop of the web.
First class functions if implemented properly give you programmatic access to execution and scope control. And once you have that there's nothing you can't do.
Everywhere = x86, ARM, MIPS
I still like the idea of calling it EmbeddedScript/EScript/ES.
&gt;Javascript Regex's for example are pretty weak But they are also blazingly fast. &gt;With statement, for example... awful thing, but it allows one really cool powerful thing [...] But it also breaks optimization (just like eval).
&gt;Javascript [...] is poorly supported by some not-so-old browsers. Like IE9. No ES5 strict mode there.
&gt;I hate how loose it is with typing. You didn't mention how every variable is global unless otherwise specified, and how insanely bad that is.
I like "JS"
javascript is supported by all gui based browsers i know from the last 15 years... and i know at least 28 of them and they all support ECMA javascript.
**JS** is fully supported. 
ECMA-262 **3rd** edition is fully supported. The 5th one (or 5.1 for that matter) isn't. IE9 also doesn't support a bunch of JS APIs (history, workers, sockets, webgl, and so on) and standard functions (like atob and btoa), which are supported by every other browser.
but **javascript** is fully supported in every browser.
No. JavaScript is a moving target. Just like HTML or CSS. Are you trying to say that IE6 supports all of that? (Hint: It doesn't.)
can you run JS in IE6? yes you can, ergo it's supported.
Stop trying to make disabling Javascript sound like its an acceptable way to run one's life.
"Why is this variable still here? Hmm, looks like it still has the data I need - guess I'll just go ahead and use it!" -said by me more often that you'd probably approve of
I like how you don't *need* to understand functional scope and closure in order to start programming in it. Then, when you're ready, you'll suddenly stumble across the advanced features and suddenly you find a new language which is ready to grow with you. There are two stages to learning it. Learn it as a procedural language with some stuff you don't quite get, then realise it's got a whole deeper more expressive side to it.
I have recently started coding in C# (for my Reddit WP7 App) and even tough I'm limited to two threads on the App I can still feel the benefit!
As I mentioned before, IE6 only supports the 3rd edition (to some degree). This is a subset of today's JavaScript. IE6 also supports a subset of HTML5 (the doctype, omitting type attributes, short charset declaration, anchors which contain block-level elements, and things like that). IE6 also supports a subset of CSS3 (text-overflow:ellipsis). Merely supporting a tiny subset isn't the same as supporting the real thing. It's like saying someone is a millionaire because he got one dollar. I really don't see what's so difficult about that. Try this in IE6: [1,2,3].reduce(function (prev, current) {return prev + current;}); If you were right, this can't be JavaScript, because it doesn't work in IE6.
Very simple, very powerful. 
some people do, personally I wouldn't.
can't argue with that. However I tend to blame that on browsers rather than the language.
http://kangax.github.com/es5-compat-table/ Strict mode is not supported in Chrome yet either.
&gt;Strict mode is assumed to be supported when the following expression evaluates to true — (function(){ "use strict"; return !this; })(); Returns true in Chrome 14.
What I love: closures, prototypes, json. What I hate: the ambiguity of "this" :/
You are thinking JScript. LiveScript is FireFox giving direct access to Java functions through JavaScript. 
Not sure if youre being serious or sarcastic. The benefit comes from the event-based architecture of javascript. C# doesn't have that standard, although they do have mechanisms for event based programming.
The template engine is an optional plugin. jQuery also bundles in Crockford's json2.js JSON parser for browsers that do not have native JSON parsing capabilities. 
Don't you mean: function(el) { el.parentNode.removeChild(el); }(document.getElementById('foo')); 
Node.JS doesn't use the DOM...
I hate the lack of a concise lambda/function syntax. e.g. return y.each(x=&gt;x.d.toLower()).sort() instead of var n = [] for (x in y) { n.push(y[x].d.toLower()) } return n.sort() AKA I miss LINQ.
It's not a perfect language (what is) but it's a lot of fun to program in once you get a grasp of the more advanced features. &gt;There are two stages to learning it. Learn it as a procedural language with some stuff you don't quite get, then realise it's got a whole deeper more expressive side to it.
I can't believe no one has said this yet: Object Literals. The ability to describe an object literally instead of with a string of functions - it makes function arguments unnecessary because suddenly you can pass a literal object into your function.
Jscript.NET has access to .NET threading for quite a long time and it is awesome. 
Link to the [actual article](http://msdn.microsoft.com/en-US/scriptjunkie/hh273390.aspx), not blogspam. Edit: Looks like it's actually the author's blog linking to his own article on another site. I still think the link should be to the article and not his blog, but it's not technically blogspam.
ohhh the hell I am in with a heavily SVG dependant web app and SVG's differing DOM implementations. It's like the late 90's browser incompatabilities all over again.
Too microsofty? At least he didn't suggest JScript
unfortunately i think it's more like; for every 100 internet hipsters there's a hardcore dev who only cares about getting shit done.
http://ejohn.org/apps/learn/
Rhino has continuations in interpretive mode, hopefully it will catch on. 
Great article, thank you for sharing.
Tada: http://stackoverflow.com/questions/409056/top-rated-javascript-blogs I personally like: http://peter.michaux.ca/ http://www.dustindiaz.com/ (look under popular posts)
JavaScript has function scope, not block scope. [Lines 875-877](https://github.com/joyent/node/blob/562b469b35c4011217857f1e9d4e3e8e266a36cc/lib/http.js#L875-877) are equivalent to the following: var headers; if (!Array.isArray(headers)) { if (options.headers) { headers = options.headers; However, the `if (!Array.isArray(headers))` seems pointless because it's always true. I dunno if it's a bug but at the very least it's messy and confusing.
http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/ very awesome
I forgot how good that was.
Nothing quite replaces a deep knowledge of the language proper. http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf A great amount of these applications is also actually constructed through crafty styling choices. http://www.w3.org/TR/CSS21/ It also helps to be ninja-aware of the various browsers' herpery and derpery. http://www.quirksmode.org/compatibility.html
Chrome 14 is in the dev channel, is not beta or stable yet. IE10 will support strict mode: http://msdn.microsoft.com/en-us/ie/hh272904#_ECMAScript5 Because the stable releases of most browsers do not yet support ECMAScript5 (they will in a few months!), do-they-support-ECMAScript-5 is a poor test as to whether a browser has good JS support or not.
Chrome got auto updates, IE9 doesn't. 2 weeks after the release of Chrome 14, &gt;99% of the Chrome users will use that version. 5 years after IE10's release, there will be still more than 20% who use some older version. And yes, there will be also some significant chunk of IE9 users. If IE doesn't support something it's a *very* big deal, because it will hang around for years. If Chrome doesn't support something, it doesn't really matter because there is no long-lasting damage. That feature gets added and - *boom!* - it's there. E.g. this will take about 2 months. In comparison... how long will it take till &gt;99% of the IE users got strict mode? Yes, that's right. About 12-15 *years*. &gt;do-they-support-ECMAScript-5 is a poor test as to whether a browser has good JS support or not I kinda agree. I'm more interested in the new APIs, but IE9 *seriously* sucks in that regard. I hope they'll manage to support at least the history API with IE10 (pp2 doesn't).
Yes, that's the part I'm talking about
It looks like Tim Caswell (creationix) wrote that bit, might want to bring it up on the dev list.
Balls of motherfucking steel. 
License and registration sir? You seem to be speeding and weaving through various subreddits. Have you had anything to drink tonight?
I've had everything to drink. 
I'm afraid you're coming downtown then.
Right meow?
 OutgoingMessage.prototype._renderHeaders = function() { if (this._header) { throw new Error("Can't render headers after they are sent to the client."); } if (!this._headers) return {}; var headers = {}; var keys = Object.keys(this._headers); for (var i = 0, l = keys.length; i &lt; l; i++) { var key = keys[i]; headers[this._headerNames[key]] = this._headers[key]; } return headers; }; 
Wow! This is excellent! Thanks!
http://developer.yahoo.com/yui/theater http://yuiblog.com/crockford
Here's a tutorial I wrote a little while ago: http://dry.ly/a-simple-reddit-ticker Not too advanced, but it might be in line with what you're looking for.
...yes. Brainfart.
Made a gh-pages branch so it's a live demo: http://matrixfrog.github.com/ImgJs/index.html
To see how it works, open xss.gif in a text editor, and set the text editor's syntax highlight to JavaScript mode. Pretty clever.
Basically, &gt; git checkout master &gt; git branch gh-pages &gt; git push origin :gh-pages and then github will automatically create a little website at yourgithubusername.github.com/projectName 
that works only in a few browsers. oh and if the googlebot comes by and sees that they tend to blacklist your domain for remote code execution...
i'm not sure if this is a security hole though, you still need to wrap the gif file in a script tag to get it to run. 
LiveScript was the original name of the language before Sun told Netscape to change it to JavaScript. Netscape and Sun were the major membership organizations that made up the W3C back in 1995 when Netscape submitted the language for endorsement. Sun agreed to endorse the language on the condition that its name be changed from LiveScript to JavaScript to prevent it from being perceived as stealing attention from Sun's recently released Java. Sun also required that the syntax change from the Scheme-like syntax it originally had to a more curly-brace style to make it seem more like Java.
Replying so I can save this comment. Please ignore.
Are you the same tobsn who used to do stuff with Eli from bluehatseo by any chance?
This was pretty common a few years back with spamming AFF links, no? I can't think of any legit reasons someone would want to do this. edit:grammar
I started fiddling with a [useful wee script by Dan Webb](http://svn.danwebb.net/external/DomBuilder/trunk/dombuilder.js) a bunch of years ago after finding it useful for work but lacking certain features and this is what eventually came of that fiddling - of late I've been playing around with using it to write code which can be shared between browser and server by delegating content creation to DOMBuilder. e.g. [newforms](https://github.com/insin/newforms) uses DOMBuilder for output, so it can run [in the browser](http://jonathan.buchanan153.users.btopenworld.com/newforms/demo.html), generating DOM Elements, [on the server](http://insin.akshell.com/), generating HTML (on [Akshell](http://akshell.com), in this case) and it can use HTML mode for [unit testing](http://jonathan.buchanan153.users.btopenworld.com/newforms/tests/tests.html) its rendering.
Three words. [Reddit Enhancement Suite.](http://reddit.honestbleeps.com/)
Maybe I'm not remembering the process correctly, but I believe people would 'cookie stuff' the images then plaster them all over message boards to spread around their affiliate links unknowingly to the forum readers.
I tried this a few times and it makes Reddit so ugly looking I can't stand it. To each their own I suppose.
But but... it won't run unless called from a script tag, how would they benefit from spreading the image? Maybe it was one of those "save image, change extension to js and double click"?
Why would Googlebot blacklist potentially malicious content? I suppose they do it to protect their users and therefore increase the quality and value of their product.
You can disable the *Style Tweaks* RES does.
I am curious, what was the core of the talk in your opinion?
You are right of course. I doubt Google would block a site that simply implemented javascript in an image. However you surely see how executing javascript from an image has security concerns attached to it and so may potentially damage your standing with search results should you take advantage of it. This is all fairly academic though since I have yet to see it work when the image is in anything but a script tag. If indeed it was possible to do this using the &lt;img&gt; tag, even if it only affected a small selection of browsers, you'd surely be able to compromise any number of websites that allowed public image sharing.
 for(first in obj) { break; } obj[first]; // Your variable May be a better way, but that should work
That's how I do it too. Be careful with cross-browser compatibility, though: * Chrome alphabetizes the object property names, so obj = { b: 1, a: 2 } becomes { a: 2, b: 1} and obj[first] ==&gt; obj['a'] ==&gt; 2 * IE 8/9 sort the properties by when they were added, so obj[first] ==&gt; obj['b'] ==&gt; 1. I haven't tested it in Firefox, Safari, or Opera.
I did that. But posted the question just because thoutgh there would be a better way.
What you posted isn’t valid. Does it actually look something like this? { "este é um objeto": "oi", something: "something" } Objects in JavaScript don’t have an order. They’re dictionaries; you use them when you want to put a bunch of related pieces of information together and give them names. Like this: { name: "Javascript object index", submitter: "CEIGHTHTENNFOROTWO", text: "Suppose I have a attachment from couchdb…", comments: [ … ] } You can use BigToach’s method to get *something* out of it, but there is no guarantee what you’ll get. You might get different results in different browsers, or a different result tomorrow from today. If the order is important, use an array, not an object. One way to store this data in an array would be: [ {name: "este é um objeto", value: "oi"}, {name: "something", value: "something"} ]
I asked the author to file a bug report, which he did. The file compiles fine, the compiler was reporting a warning not an error. (The warning was that there was what looked like a jsdoc annotation in a normal comment, but the warning (prefixed with WARNING") includes the text "parse error" which was unfortuate) 
The short answer - yes, there's a place for you. Particularly at companies that have graphic designers comp templates before passing them off to the front end team, which is how my company typically works, and many others that I'm aware of. Honestly, if you're good with Javascript, understand inheritance, closures, complex user interactions, have managed large JS codebases, etc, you're a rare bird and will actually be way more valuable than traditional web designer who can hack together bits of functionality with jQuery. 
Or "permalink".
I don't use that function in RES anyway because it just saves the comment locally on just that computer.
That's what being a front-end developer (or engineer) is all about. It's fine, really.
As a "web designer" turned "web developer" myself, I can assure you there is plenty of places for you. Not everything in the javascript world is about visual aesthetics. Take [node](http://nodejs.org/) for example – there's not a whole lot of design skills you need to some wicked awesome shit on the server side with JS.
There will always be a place for a full on js person. You forget the sheer amount of js a large corporation manages. The idea of a person taking care of one part of a stack of technologies is not only common, but in many cases the way a team might split themselves optionally if given the change. The web requires that people be a jack of all trades, but if you get those people in one group, often times the skillsets skew heavily towards one part of the stack or another. Never fear, people will love you even if you can't design/hate css/wouldn't want to test your stuff on people... Just be prepared to take lots of constructive criticism, as the needs of the end user might be a lot more work than what you'd be able to do if you "just did it this way instead" and as a straight js person you won't be immersed in that side. tl:dr, yes, go get a design/ux buddy in a large corp, make lots of cash 
You are left-brained. You might consider taking up back-end programming. Probably PHP, Java, Python, or Ruby. Back-end developers with decent technical front-end skills are always in demand.
See Sencha, jQuery, etc. You work with javascript you WILL have to understand what a CSS selector is and how it will cascade (a scary and confusing term for "apply to child elements").
Have you looked at Node.js?
I can do backend programming, I just really like JavaScript and especially don't care for SQL.
Node.js and MongoDB are going to be a wet dream for you.
Lots of places will have designers draw stuff up in Photoshop then send the sexy layered .PSD to the front end dev(s) who will slice up the image and write all the HTML, CSS and JS to make it work.
Yes. I work with a stud js guy who doesn't want to do any design. As a result, he ends up not doing much design, and does a lot of really cool js stuff.
So true. I recently setup nodejs and mongo on my local dev server... So much fun. Coming from a background of PHP and MySQL, it really was a dream. Be warned though, I now have problems when I first start working on new projects (in my 9-5) because I want to build everything using Node and Mongo (which sadly isn't possible on shared and managed servers) =P
That's great. I wouldn't worry about design abilities. Most programmers can't design. Design and development rarely-if-ever overlap.
You can tweak RES according to your liking. You just have to disable some of the modules. :)
Not so much now, but definitely in the future. I heard Windows 8 is going to be big on HTML5 and javascript. I have no idea how long the transition will take, but it will happen. **edit**: anyone wanna humor me and tell me why I'm getting downvoted?
&lt;3 mongodb. I switched my project from PostgreSQL to MongoDB a while ago, it made my life 10 times easier. Even if my project technically uses mongodb in Python :)
Do you use any libraries or are you coding in vanilla javascript?
This is fixed in ES5's strict mode, btw :)
I found this to be very true. I recently quit my job doing "web development" and put myself out there as a JavaScript developer. I had no trouble finding interesting work. You don't even need to be exclusively front-end.
Just FYI, history, workers, sockets, webgl, and so on are not finalized drafts, and are not part of Javascript (Javascript is standardized by ECMA, most of those are W3C or WHATWG specs). These specs are typically and more accurately considered part of HTML5. atob and btoa are not standard. Just read the MDN documentation: https://developer.mozilla.org/en/DOM/window.atob. Look at the bottom: "Not part of any standard".
you have map in ES5, so your second example becomes y.map(function(x) { return x.d.toLower() }).sort(); A shorter function literal was proposed for ES.next but I'm unsure what the status of that is.
The bay area, primarily.
Yes, of course there are jobs for people like you, you just have to work *with* a designer. Most good webdesigners are not able to code Javascript to save their lives. (Hell, in my experience a lot of web designers don't even do html! They just make mockups in Photoshop.) So you just have to complement ech other.
Hey, neat! Thanks.
Right now I use the Closure library.
Yes, there's lots of graphic designers who can't code at all. They can do copy and paste JavaScript but they're not programmers, so actually writing new JS (or substantially modifying existing) is not in their wheelhouse.
&gt;Just FYI, history, workers, sockets, webgl, and so on are not finalized drafts, and are not part of Javascript [...] As I said, "APIs". While those aren't part of the language, they are part of the runtime environment. &gt;These specs are typically and more accurately considered part of HTML5. None of these are HTML5. &gt;atob and btoa are not standard. atob and btoa are supported by *every* other browser. IE really should support it, too. In general, IE should support everything every other browser supports. Just like every other browser should support everything that's supported by all other browsers. (E.g. Firefox *finally* got support for `text-overflow:ellipsis`.) History is also supported by *every* other browser nowadays. It's a highly critical puzzle piece for the net's infrastructure. It's very important that IE supports this one as soon as possible. IE10 will support workers for example. That's something at least.
I think you'll find in that most people that know JavaScript aren't strong designers, and in fact most web applications today, design related element in JavaScript are the tip of the iceberg for development requirements 
It is a relatively new niche.... "The design-less front-end programmer"... I am one, and I'd say I have been for 5+ years... There's no shortage of work here in Ireland following said career path.
This is all true. I can barely pick out clothes in the morning and have had no trouble getting great front end development positions.
I've been a Software Engineer for six years. About half of my code is client side and I don't design a single thing. We have people employed specifically to create HTML and CSS for our pages. I just write the code that controls page behavior. Occasionally we clash because I'm trying to use a JS library w/Widgets and they don't play nice with the designer's CSS, but it's not a big deal.
Should I make that an Easter Egg that can only be accessed with a super secret handshake of features on the tool?
I assume that John Resig is not a good designer.
Looks awesome! Bookmarked.