&gt; "Not in my current job, but in my previous one..." &gt; "WE DON'T CARE" just lie man. If they check and catch you, just tell them you're so embarrassed by the lack of good practices that you felt obligated to lie.
&gt; too ES6 focused But I mean, that's what JavaScript _is_ now. ES6 isn't a bunch of special features, it's what the language looks like. There's no reason for people new to the language not to learn ES6.
This is a great idea! I really struggled getting through You Don't Know JS on my own (motivation wise), so it will be great to have some accountability. I'll head over to the Slack &amp; say hi soon :) 
When I REALLY wanted the job I used option 2 to get it. Since then I improved dramatically and don't have to lie anymore. But at those times I was like "css ul li what? js have something except jquery?" Well option 2 got me a job, I was getting paid and learning stuff at nights since day 1 on position, so company didn't loose anything. Other devs were even slower then me anyway
Hope this would be helpful!
But, you look your recruiters to it and it looks good. Regardless of who else reads it.
Generally I answer the questions based on what I think they are looking for, not necessarily what they are asking. Rather than talking about direct react experience (though I have it fortunately) I talk about the ecosystem around it and flux, redux, react-router, functional components - to show that I have an understanding of the technology. Same with other areas, babel, docker, jenkins etc - I talk about the pros and cons I have discovered, and less about what I did with them. Its kind of like saying it indirectly, it comes across as more assured and knowledgable than saying "yeah I do react in my spare time" etc - because that doesn't answer the question they're not asking.
I had to drop this little experiment but would like to do a quick "panel" thing. If I had done zero coding in last 10/15 years and just wanted to quickly implement collapsible panels would you recommend learning Bootstrap or something easier/ smaller would be better/ faster? 
Hey Trevor, perhaps update the article with three facts about Selenium: 1. It too can target the headless mode of operation of Chrome 2. It is possible to write non-brittle tests 3. You can have fast tests (multiple whole tests a second), but it depends on how you're serving the rectangle you're want to test, and how costly the down-stack services are 
Your validation could use some work
Oh.. looks pretty easy to test!
Why don't you try to address a real problem a company has and tell your value to the company?
Just something I looked for :)
First there was Angular. Then there was Angular 2, a completely new thing, and the old Angular was renamed to Angular JS. I don't know what happened to Angular 3, but all of the sudden there was Angular 4, which renamed to Angular. 
javascriptforsoundartists.com
Saved me a lot of typing - have my upvote
Great article Trevor, thanks for sharing. The only thing that bugged me was the test ids. It seems to me you'd be artificially creating a made for testing scenario and coupling implementation with testing. I'd rather find elements by labels like a real user would or even have a separate tester figure out something and have it break when changed. It's almost like asking a programmer to write the tests after programming, and there's a very good reason real TDD requires tests to be written first. Unless there's a predefined story before implementation defining the test ids, which sounds unlikely and cumbersome.
For compose and pipe we can just use the code like above, but other functions are auto-curried in ramda and lodash/fp and that's a huge plus when doing functional composition
Don't bloody scroll jack your site! https://codepen.io/gunderson/full/GJJPpV/
You could curry underscore functions manually before using them and use them using built-in compose. &gt; const find = pred =&gt; arr =&gt; _.find(arr, pred) I'd try to avoid chain because we have to call .value() at the end of the operations. If you want top down execution order like chain, you can always write your own pipe function, won't take 10mins I think
I've been hearing a lot about Puppeteer recently, this looks great! I've had endless pain with Selenium tools, it's a good space for some big improvements.
&gt; You can always write your own pipe function Oh, I did that months ago... :D In all honesty, I quite like this chain variant I made, though perhaps to avoid confusion I should make it a distinct method. `_.chained`, maybe.
Javascript isn't **only** ES6 features. Albeit limited, there is the standard library that is covered in-depth in other resources like Javascript: The Definitive Guide. Despite block scoping and exports, design patterns still matter a great deal. Regardless of the syntactic sugar of ES6 classes, functional programming and prototypal inheritance are yet more important than ham-fisted OOP in Javascript. I was not saying ES6 isn't important. I was saying that for a developer coming from another set of languages to learn the basic foundation of Javascript, one shouldn't use resources that are **merely** to highlight the utility of ES6 features written for Javascript developers.
Honestly every E2E framework should be being compared to Cypress off the bat at this point. Cypress is fast and has a visual component which makes it easier for QA, easier to rewind, easier to go in and check the environment without merely just relying on screenshots.
Did you use any resources to learn how to make this library? Could you share them if you did?
I see a lot of things that are not right atm, here's some examples: - You dont have the convert...ToUSD() functions (except for JPY) - You return the value of these functions into the convertedCurrency variable, but you do nothing with the variable after that. Return means everything after it gets ignored, so your console log is not executed. - Check for Eur, but users will be typing EUR - You do nothing with the MoneyCurrency variable - the Ifs could be replaced with else ifs or a Switch - etc Hope that helps
Seems to me you’re applying to the wrong companies, or you’re disqualified for other reasons entirely. The way you communicate, the way you speak, the way you present yourself. A lot of factors weigh in on whether you’re a good fit for the company you’re applying to. If you’re being rejected at a very early stage, then it’s not about your technical prowess. It’s probably because of how you communicate. I don’t know you, so I’m not saying that’s true, but job interviews (taking and giving) is a skill in itself. The usual tips: Never be negative. If you don’t know something or cannot say “I master that”, then you say: “I’ve worked with it and am currently reading up on the latest”. Show them you’re knowledgeable and willing to learn. Now… At my previous company I had to learn a tech that I never enjoyed. It was a tech that didn’t really conquer the market as they would’ve liked. I, instead, recommended React. They refused. I still took the time to create a demo in React and in doing so I learned to use the library in a professional setting. Just do it, is what I’m getting at. Then you can truthfully state you have used React at your current job. If I just rolled over and played the role they intended for me, then I’d be stuck in a dead-end job working a dead-end framework, never increasing my market value and knowledge. And yes, you can lie. You should lie. Like every developer out there claims to write unit tests and claims having done that always in their career, no exceptions. Most of them lie. When you get to the interview you lie by dressing nicer than normal. You lie when asked what your greatest weaknesses are. It doesn’t matter if you lie about something trivial, they just want to know whether you are familiar with it and its uses. I wouldn’t bother with open source projects, honestly, personally. Never have I or have I seen anyone check up on my Github profile. And if they asked, I always worked on closed-source projects anyway. Work took up all my code-writing time; and my personal time isn’t spent writing more code. It can’t hurt, I guess, but that would be a low priority. Instead, just learn the library. Learn CI. Learn TDD. Learn functional programming. Learn all the new proposed ES features. Learn.
Yes, I probably need to ignore big startups
When was the last time you set up a CI that tested 3 major browsers? At least for our case, we used Selenium but it only ever drives Chrome. While multi-browser testing is useful on paper, in practice it's rather impractical and hard to maintain. Hiring a QA specialist to do periodic multi-browser testing will most likely end up being cheaper.
Thanks, makes sense
Yep, that's my thinking, but was wondering what my other options were before going down that route... :-)
I've been lucky to work at a successful medium size company and the idea posted elsewhere here that this profile of company can't hire enough is mostly true, although that will be really dependent on where you live. We use both angular and react and also how regularly people that have never used either. The best people that I can think of in the interview process admit to not doing it early on, but are clearly eager to learn (we wouldn't hire someone who doesn't want to learn). They demonstrate this by working on a project in it before the interviews, usually after talking to our phone screen. We offer an off site very straightforward coding assignment that some will even use a new framework on in order to demonstrate that they can be proficient in something they haven't used before. Most of these frameworks / libraries aren't rocket science and just require time and the right attitude. So yea, I'd suggest looking into a single project or two and putting them on github. I think back to the first react app I worked on in order to learn it more https://github.com/sb8244/reflectives-frontend. Which had a node backend pairing (I was also relatively new to node). It's just something straightforward but more than dead simple to show off.
Yeah, that seems to be the consensus, thanks
You can take a look at how it works here: https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage 
What is the result you're trying to store? You aren't returning anything.
Yes?
It's not that confusing-they just started following semver after version 2.
Check the Console for any error message. If it's run on Firefox, press CTRL+K and re-run the script. For Chrome, press CTRL+J.
The initial zoom on mobile is very zoomed in. 
First, you should hide the `price-box` elements at design time, and show/hide them using script only. During page initialization, check the local storage. If the setting is not yet present, make them visible in the script. Otherwise, only make them visible if the setting says that they should be visible. Each time the user toggle the elements' visibility state, invert the value of the setting while toggling the elements' visibility.
Or testcafe http://devexpress.github.io/testcafe/
Hello everyone. I've tried over and over to fix this. I have code implemented for these parts which brings up boxes that customers can input their weight, displacement, etc. but the customer can send items to their cart without putting in any of that information. It is a real pain to track them down after the purchase and get this information. How would I go about adding additional code that would "stop" them if no information was added to those input boxes? I believe this is the code in my shopify's "theme. liquid" but it doesn't seem to affect anything.
Imake a blog slowly about 2D game, now first entry http://www.thenew3d.website/category/javascript/?kul=http%3A%2F%2Fwww.thenew3d.website%2F2017%2F10%2F17%2Fit-happens-i-doing-the-game-i-wound-a-good-game-tutorial%2F
The biggest strength of Puppeteer over the many alternatives IMO is that is official from the Chrome team, so it has first class support for everything with Chrome. But yeah Cypress, and many other options are also a great step up from Selenium :)
Thanks for reading!
I think no matter the approach, there has to be some sort of coupling, but yeah there are plenty of options that can work well. I think as long as you aren't relying on xpath selectors or things like that you'll be ok :)
There is no scroll jacking involed here :)
Agreed :) Thanks for reading.
&gt; I'm currently new in writing gulp script. Oh man `gulp script` is the worst! 
It's true that it is possible in Selenium; but it requires a good amount of extra work and the documentation available tends to focus on slow brittle tests. I feel options like Puppeteer are much simpler and lightweight out of the box, but yes you are right - Selenium can be set up in a way where it works similiarly.
Yes there is. SmoothScroll lib is loaded and jacking.
I agree with the other replies here. If you focus on modern browsers, you can use a tool like Puppeteer which takes care of the majority of use cases for a much lower cost which I think is a good trade for many teams.
Thank you for your help but since I‘m a beginner that is pretty hard to understand. Is there no simple way to put a local storage into my function? My script works, it just does Not Save the hidden div after page reload. In not, could you please elaborate on your Solution? Thanks a lot
I love reddit :)
Sweet! Thanks!
I hear you. What I'd say is... Google has a reputation for retiring projects, and also big projects that have lost favor with the community (Angular, AMP). I don't think the wisest idea is going with them "strictly" because it's their team. That being said, let's hope they can match the product Cypress (and Test Cafe) are putting out.
Addy’s just a guy. How do you think he got to his level? Definitely not by sayin “meh, I’ll never be Martin Fowler, might as well not do the work...” I’ve seen this approach work time and time again by people that put their ego aside and do the work. 
Yup. I don't think TestCafe gets as much praise or attention as it should, but I think that's partially DevExpress's fault. Not as polished as Cypress visually, but great team and functionality.
Wow so cool
Unless you are really interested in making custom graphs and data visualizations I would argue that D3 isn't the best framework for your use case. Although I haven't tried them out I know people who have had good experiences with chart.js and highchart. 
You're right, they owe me nothing. But if they want me to read their stuff then they have to make it worth reading. When you write something on the internet you're competing against lots of other writing, and people have a choice as to what they read. And as for "personally attacking", show me where I did that. I gave my opinion, said what I personally read, and if the author wants to learn something from that they can, but in no way did I attack them personally.
/r/learnjavascript
Yes, I think that's a great idea. More web components the better imo. Reducing deps is a good architecture. Removing framework deps is best architecture. 
/r/learnjavascript
**Here's a sneak peek of /r/learnjavascript using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year!** \#1: [The Entire JavaScript Language in a Single Image](https://fossbytes.com/wp-content/uploads/2015/09/infographic-the-entire-javascript-language-in-one-single-image-491250-2.jpg) | [29 comments](https://np.reddit.com/r/learnjavascript/comments/675fk4/the_entire_javascript_language_in_a_single_image/) \#2: [This pretty accurately describes my feelings on my JS learning journey so far.](http://imgur.com/zKJt5rb) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/5k71cn/this_pretty_accurately_describes_my_feelings_on/) \#3: [Github Repo with 100+ Free resources to learn Full Stack Web Development.](https://np.reddit.com/r/learnjavascript/comments/5zse5u/github_repo_with_100_free_resources_to_learn_full/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Wow, I was just researching this last night. Excellent article!
You're micro-optimizing. It's not worth it. The bundle process throws out any code that isn't relevant to your application, so you're fine. Sure, you have some pages which don't use all of the bundled functionality — that's fine. The bundle is cached, so whenever a user hits a small page, at least their next big page load will be snappy. If your application is so lopsided as to make this optimization a real concern, then you should generate different bundles for different sections of your application.
So memoizing fetch by replacing a built in, normally that's bad practice, and in this case it's still bad practice. You also can not memoize any promise call with your lib, that's a bit misleading.
I guess for someone not staying up to date, it could be confusing. To clear it up - there is only AngularJS (v1) and Angular (v2+). Angular 3 was not a thing (skipped to bring all Angular submodule versions in line at v4), and version numbers past 2 are based on SEMVER and so do not indicate anything except breaking changes between versions (which should be common to any decent JS framework.)
4PM EDT happens when this comment is 2 hours and 25 minutes old. You can find the live countdown here: https://countle.com/oZx844465 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Wouldn't server side rendering be to prefer for non spa?
I have a huge soft-spot for Gulp as it is what kicked off my stream obsession. Speaking of which, streams are the key to working with gulp. A stream in node is system, typically a class or a function that wraps a class constructor that describes how it will react to incoming data and send data out. For instance gulp-filter is receiving one-file at a time from gulp.src and testing to see if it's a directory. If it's not a directory it is sent down stream to the through.obj transform stream to be zipped. What I enjoy about that approach is that I don't need to care how filter is implemented, I just need to know how to use it. That said, here's an alternative solution that does the same thing but only uses one paradigm: streams. const gulp = require('gulp'); const zip = require('gulp-zip'); const filter = require('gulp-filter'); gulp.task('default', () =&gt; { // 1. Create a read-stream containing virtual files return gulp.src('app/**/*') // 2. For each file coming down the stream only keep the ones that are not // directories. .pipe(filter((file) =&gt; !file.stat.isDirectory())) // 3. Collect each file into a .zip file named "archive.zip" .pipe(zip('archive.zip')) // 4. Write archive.zip to a folder named "dist" relative to gulpfile.js // which is where gulp is executed from === process.cwd() .pipe(gulp.dest('dist')) }); I replaced the more generic archiver package with gulp-zip since it already knows how to work with vinyl files that gulp.src emits. https://www.npmjs.com/package/gulp-zip Unfortunately my explanation of streams won't do much justice but I'll do my best to briefly explain it as it will hopefully clarify what each step in the pipeline is doing. Should my explanation not suffice https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/ and https://www.youtube.com/watch?v=GpGTYp_G9VE may cover what I did not. In essence a stream is just a collection of data over time. Where as an array represents a collection of items now a stream can have 0-* items eventually. This is what made gulp a strong choice for me since it can work with very large file systems with acceptable overhead. Gulp streams can work on files at its own pace as its internals have the space, access, and time to read files. Using that code sample our first step is #1: gulp.src('app/**/*') which is creating a readable stream that emits vinyl files from the "app" directory relative to the gulpfile.js. Vinyl files are JS objects that represent a file that may or may not exist on the file system. In this case all the files do exist but they could refer to a remote file or a file yet to be created just as well. Anyway, when a file is read into a vinyl object it is immediately sent down stream to the next step, this means we can start filtering as soon as the first file is read while gulp.src emits more vinyl files as it processes them. In technical terms a stream is a lazy sequence meaning items are operated on one at a time where as arrays are eager meaning each array method returns another complete array before the next method will be executed. This is what makes streams &amp; gulp good for working with large or many files. Step #2 Now that we have a readable stream emitting all files from within the 'app/' directory the second step is to start filtering them. This is done with gulp filter which is a transform stream meaning that it is both readable and writable. It receives vinyl files and is responsible for emitting something, in this case passing vinyl files. Vinyl objects have a .stat property which is the output of running fs.stat on a file. This contains useful meta data like if the file is a directory or not. Gulp filter takes a predicate, a function that returns true or false, and tests each vinyl file coming in. If the file is not a directory it passes the predicate and is emitted down to the next step. If it fails because the predicate returned false then the vinyl file does not continue and is eventually garbage collected and the memory freed. Step #3 Creates readable &amp; writable transform stream that receives the non-directory vinyl files and collects them into a .zip file. When gulp.src signals that it is done reading all files in the app directory a new vinyl file representing the .zip is emitted down stream. Step #4 Creates a writable stream using gulp.dest which takes a destination folder relative to the gulpfile.js or process.cwd() at the time of execution. It receives a vinyl file that represents our .zip archive and writes it to the disk. As per your other questions `gulp.src('app/**/*')` is your source. The string 'app/**/*' is a glob string indicating that it will read every file in the app directory and every file in any subdirectories. Gulp.src can take many forms of arguments to indicate which files to read. If you wanted just the .js files in the app directory not including subdirectories you can call gulp.src('app/*.js') where as gulp.src('app/**/*.js') reads all .js files in the app directory and any .js files in any subdirectory. You can even supply an array of globs for gulp.src to resolve gulp.src([ 'app/**/*.js', 'app/**/*.css', 'app/**/*.html' ]) for instance will recursively read all js, .css, and .html files in the app directory. There is syntax to exclude globs as well so I recommend looking up the docs for gulp.src to learn more. To change the destination there are two places. The first is the filename in step #3 .pipe(zip('archive.zip')) which can be any string and represents only the file suffix in a filepath like '/app/js/other/directory/&lt;suffix&gt;'. The second is in step #4 .pipe(gulp.dest('dist')) which takes a directory path string relative to the gulpfile.js (same folder as gulp.src uses). I know there is a lot here but I highly recommend taking the time to become familiar with node's stream implementations and FRP libraries like Highland JS. They are really powerful! Please reply with any questions or issues you run into. I'll do my best to answer or point to a resource that can.
I would consider `vue`. It is supposed to be a lightweight and drop in (ie, include script tag good to go), so I would think that would be beneficial to the non-SPA architecture. If you're feeling especially adventurous, then perhaps consider `web components` -- [stencil.js for example](https://stenciljs.com/docs/intro/)
Objects aren't extended; classes are. JavaScript is a classless, prototypical language and only provides classes via [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar). Further reading on prototypical languages: https://en.wikipedia.org/wiki/Prototype-based_programming
Thanks ill take a look at vue
Why Browserify instead of Webpack though ?
That was very confusing
Hi /u/The-javapocalypse, this post has been removed. Please submit links using the "Submit a new link" button, and if you wish to add additional commentary, do so as a comment. Thanks for your understanding.
Hi /u/loledgamer, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/sem1845, For javascript help, please visit /r/LearnJavascript. Thank you!
Just in case you were asking how to run it: First paste that code into gulpfile.js Second install the dependencies `npm install gulp gulp-filter gulp-zip` You may need to install the gulp cli `npm install -g gulp-cli`or use it through npx Lastly in the directory with `gulpfile.js` run the following: `gulp`
Hey /u/kenman, sorry but this is not Learn thread question, at least it is advanced topic on browser knowledge. So anyways thank you for your help.
Yes, check onsen ui etc - their doing this
Whoa.
&gt; and also big projects that have lost favor with the community (Angular, AMP) I know. Who even uses Angular anymore? Wow, no favor(s) left. 
Whooa.
&gt; You won't need a polyfill for this. Well.. spread syntax impossible to polyfill, and has about the same support as `Array.from`
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
we are live - learn some cool stuff on React and taking design and making it in to a landing page ...
You are using ES6+ features like const and arrow functions. These features and spread can be handled by Babel/TSC/etc. As long as it's just syntax, you won't need any polyfills.
So I know if you search around you can find some basic examples of diff and patch. For me though I'm a hands on learner, I knew the theory and wanted to see if I could put it into practice. My early iterations were not great, you can check one out here https://github.com/fwilkerson/franken-app. Again I'll pimp the Preact source code: https://github.com/developit/preact I learned so much from this repo, the first event system I came up with was super clunky (franken-app uses it). After going through Preact I saw Jason and I had similar ideas, he just implemented it much better. I adopted his way of doing it when I wrote muve. 
I would do a compsci with a minor in business. Computer science is far more interesting/useful than business studies.
Was looking for this, thanks!
There is. There is some weird inertia stuff going on. https://ropig.com/wp-content/themes/betheme/js/parallax/smoothscroll.js?ver=20.4.3
The posted link has the last view that the poster saw (lots of query strings). Is this [link](http://callumprentice.github.io/apps/storm_tracks_webgl_too/index.html) better?
I first thought Google Chrome now has a new "Building" screen capture feature.
I learned something here! Thanks.
This is a better question for /r/learnjavascript 
The best way to proceed is to use [Moment.js](https://momentjs.com/). It has very good API and is very good with date manipulations. Foget unix timestamps and counting seconds by yourself.
Yes, Moment.js is definitely the way to go!
Here is an article on how to integrate Vue and latest js features with Asp.Net MVC. https://medium.com/corebuild-software/vue-js-and-net-mvc-b5cede228626 Hope it helps 
 export function subtractSeconds(date, amount) {return new Date(date.getTime() - amount * 1000)} export function subtractMinutes(date, amount) {return subtractSeconds(date, amount * 60)} // etc... your bundler should treeshake unused stuff
I made a rewrite for DOM99 https://github.com/GrosSacASac/DOM99
May I know why is it the worst? Do you have any workaround for me to create a script to zip files automatically? 
Whoooa.
This. I will be doing the same thing when I transfer to a university plus being a business major or minor is the cool to major in nowadays. 
Whooooa.
Take a look at KendoUI. It seems to have most of what you are looking for and it integrates well with ASP.NET
Cool! 
Just as class functionality can be constructed in *C* but *C* itself isn't an object-oriented language, an object can be quasi-extended in ES6, but the object itself isn't inherently extended. This is an important distinction for a developer to know, because the behaviour provided by the sugar can have unexpected effects and performance problems in a few, but not-zero cases. For example, modifying an object higher up in the prototype chain can have rippling effects on "subclasses" in ways not experienced in class-based languages.
https://www.youtube.com/watch?v=OffF0e2h4TU&amp;t=10m35s
Well that's remarkably devoid of any real information. How the hell do you mitigate in the interim?
javascript has classes now. besides, I like prototype.
Oh I see, sorry I thought you meant something in the blog post. I'll let our marketing team know who works on this public facing website. Thanks for letting us know!
Turning the globe crushes your browser history. Please don't do this.
You can't really, somewhat by design (since you can't really allow mitigation without providing enough information for attacks). It's fairly likely that you're not currently at risk though, since as far as anybody's aware nobody but the maintainers knows how to exploit the issue. In the meantime, I'd make sure you're ready to update node and ship a release to production at top speed on the 24th, when the patch (and full vulnerability details) all come out.
At least it's just a DoS vulnerability.
'let' is scoped to the function.
Could you elaborate, or give an example of the difference? 
Oh thanks, just saw your edit
Now do it with server rendering lol
There's no reason to use `var` anymore unless you're supporting legacy browsers. Use `const` always unless you _need_ to mutate the variable.
Mmmmmmm, yummy mathy things.
Hi /u/Amiwav, For javascript help, please visit /r/LearnJavascript. Thank you!
&gt; There's no reason to use `var` anymore unless you're supporting legacy browsers. Yeah there's still no need to actively implement it, just use ES6 and run it through babel and let that worry about the `var` conversion.
I thought it was going to be about how the Chrome team built the screen capture feature :p.
lol. best programming comment ever.
What do you mean let is scoped to the function? That's not all let / const are. Essentially, var is scoped by functions. let and const are also scoped by functions, but they are also scoped by conditional statements, for loops, and any logic statements (for, while, if, etc) that go inside of blocks. So take the following example: &gt;if (true){ let scoped = 'scoped'; var notScoped = 'notScoped'; } console.log(notScoped); console.log(scoped);
Need to slow it down just a tad.
Nice article! Thanks for posting it.
its actually awfully specific. How many people are already looking for what exactly went into 6.10.2 from the previous release...
This is worth a watch. https://www.youtube.com/watch?v=6vBYfLCE9-Q
It sounds like you’re just dropping the names of all the popular libraries. Entire books have been written about D3. I would just start with baby steps and attempt to get a solid API written in express. Once you have your API functional then you can worry about consuming that API with Vue. Finally, once you have the API successfully consumed by Vue or the front end of your choice, you could worry about making it look pretty with real-time visualizations. 
[removed]
I wish the wind speed control had the option to show only parts of the path greater than the speed rather than the whole path if any part was greater than the speed.
I hated JSX at the beginning, now I can't go without it
i cant be the onl one who kept reading meatballs
This may be just what I was looking for! Thanks for sharing. 
It pretty much tells you everything you need to know, as u/cm9kZW8K says. The common changes in 4.8.2 and 6.10.2 are limited to basically zlib 1.2.11, which is in all versions of 8.x. 4.8.1 and 6.10.1 were both on zlib 1.2.8. My guess is the issue is in zlib 1.2.9, which mentions "large" and "very large" file support. If I were looking for a DoS attack, "very large" would be a good place to start. Of course, I'm just guessing at the issue. If you're concerned, switch to 4.8.1 or 6.10.1 until the fix is released.
Using local storage is like using an object property whose type is a string - and can only be a string. e.g. //read: check console.log(localStorage.myValue); //undefined if `myValue` doesn't exist yet //store localStorage.myValue = 123; //if it's assigned with a number... //read console.log(localStorage.myValue); //"123" it'll be converted to a string //if it's assigned with an object... localStorage.myValue = {abc: 123}; //it'll be converted to a string representation of it console.log(localStorage.myValue); //[Object object] //so for objects and arrays, pre-convert it first using `JSON.stringify()` localStorage.myValue = JSON.stringify({abc: 123}); console.log(localStorage.myValue); //"{abc: 123}" //to read it back as an object, instead of a string... console.log(JSON.parse(localStorage.myValue)); //{abc: 123} //to delete it... delete localStorage.myValue; console.log(localStorage.myValue); //undefined 
Dafuq? What does knowing this prove? 
But that may add a byte though ;)
I am pretty sure the answer is [yes for some actions](https://stackoverflow.com/questions/13537043/easily-detect-when-user-alters-dom) but it is highly unlikely that any website implements checks. I would imagine if I wanted to I could implement checks to check the sanity of the DOM, but it'd be a huge waste of resources. 
We finally decided to make a library we've been developing for over a year open source. Models and Collections for Vue! https://medium.com/@rtheunissen/models-and-collections-for-vue-js-45803431aaf4
Actually I have built several APIs in other languages and worked on Enterprise frontends on react.js... I know some of what I want but not the details.
Sorry, who?
Can? Yes Do? No. Definitely not 
no 'const' doesn't prevent mutation. it only prevents re-assignment. you are free to do something like this. const o = {a: 1}; o.a = 3;
Been working on a chrome extension plugin for reddit using typescript and react. It lets you follow threads so you can go back later and have all unread comments highlighted. Unfortunately I have found the reddit api hard to work with and the issue with getting all comments is harder than I thought since reddit doesn't load all comments on large threads (it has load more comment links etc). I mostly use it for programming threads that have &lt;500 comments so it works well for what I need it for. 
no, `const` doesn't prevent mutation. look at [my comment](https://www.reddit.com/r/javascript/comments/772lys/difference_between_let_and_var/doj0hmn/)
If by changing those two properties, then yes, but that can be defeated from the client side, so it would be a waste of resources like /u/programstuff have mentioned. At least for those who don't know how to program with JavaScript. This is similar like sites that disable the right mouse button.
Don't use `var` anymore. It's old, and icky! Use `const` Only use `let` when you need a reassignable variable
I was under the impression that what you're describing isn't mutation, but... I stand corrected. And that's an excellent post. Seems the incorrect understanding of "mutation" is epidemic. My rule of thumb has been that mutation was when you did something like add a property, but not changing the value of an existing property. But clearly, I've been misled. Thanks! It's always good to learn something.
you are welcome ;)
I imagine youtube would find a way to filter this or just block such videos if the practice became widespread. Honestly, complaining loudly and obnoxiously to them will probably work better. Companies have proven over and over again that they will cave so sufficient pressure, especially if you can frame their actions as somehow racist or bigoted.
They seem almost identical to me. The prototype chain is set up identically. The only difference I can find is that `super` calls are not allowed when you don't declare an `extends`. class Foo extends Object {constructor() {super()}} class Bar {constructor() {super()}} // &lt;-- super() is a syntax error So even though both classes inherit from Object according to their prototype chains, you're not allowed to call `super()` or `super.method()` unless you declare `extends Object`. I can't think of a great reason why you'd want to override methods inherited from Object, but I'm sure *someone* has a good reason to do that on their project.
He's talking about `class Foo extends Object` which is allowed because `Object` is a constructor.
You can code React without JSX. There are people who prefer that. So don't let JSX alone stop you from doing more research of React. Regarding forms in React, [Gosha Arinich](https://goshakkk.name/) has a lot of great resources about it
How likely is it for a website that posts final exam grades to check?The website is CIE Cambridge and they're a pretty big website because people all over the world write CIE Exams
In theory they can, you could simply just disable javascript.
Well this got shady pretty fast
It's not that bad since I'm not affecting /altering the server it's just what shows up on my screen 
r/learnjavascript
What exactly do you gain from altering the website? 
What r u talking about xddd
wouldn't a word like "count" screw that up?
I just want to know why it helps you to insert that code and why anyone would even want to find out. If there was an actual benefit then those who created the site were surely not professionals
My company is using Aurelia and we are happy with it.
I'm curious what's the reference point for "most people in Silicon Valley don't have CS degrees". It's obviously true in reference to the general public, but it doesn't seem right vs tech At the big tech firms, engineers far out number the PMs maybe it's more common to be swamped with non-tech people at companies like banks/traditional business? As to your real topic: trying to move into programming without a CS degree (even as a PM) doesn't sound like an advantage. I don't have any hard evidence, but I find it hard to believe Silicon Valley would view an ordinary business degree as a positive in relation to tech. It would have to be prestige of college to get in the door imo From my personal experience, most PMs know how to code at a professional level in tech and an larger percentage of managers also know how to code (also at a fully proficient level). So if either of these career paths interest you, I'd suggest finishing out your CS degree (+business minor if viable)
Great article! Really enjoyed it.
Not saying I would have a business degree but I interned at a large company and all of the scrum leads had degrees in other fields, I am not saying that is representative of the entire community but the essential idea is that you bring your programming knowledge to a field that you think is interesting and apply it that way instead of getting a degree in cs and becoming a code monkey for a business that you can't find passion in. That being said I read an article like this one (https://qz.com/766658/the-highest-paid-workers-in-silicon-valley-are-not-software-engineers/) that essentially sums up what I thought. Although, I could be completely wrong :)
Modal/popups - remove them and page refreshes.
Please notice - According to MDN let is not supported for &lt; IE11. Chrome|Edge|Firefox|Internet Explorer|Opera|Safari :--|:-- 41|12|44^123|11|17|10 [Source](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Browser_compatibility)
Unless you work in a large enterprise institution and must support older browsers...
For security purposes, DoS is far preferable to information disclosure. The former is embarrassingly public as everyone can see you go down, but disclosure is more damaging to your users and could go on for a long time before anyone notices.
Or work for a company that runs services such institutions might use. And you don't have to go too old to lose support: Safari on desktop and iOS has only had support for just over a year according to https://caniuse.com/#feat=let Though if you'd like to write more modern code while supporting older browsers you can use a transpiler (bable for instance supports this type of transform: https://babeljs.io/docs/plugins/transform-es2015-block-scoping/) to rewrite the code for release.
Then use babel?
Babel to the rescue!
Just use 'var', it's completely fine. Before 100s of you guys now reply that I'm a total idiot and not a real developer, most of the people still use 'var' in most companies. The scoping difference is of such little regard that it's neglected in companies that just need their stuff to work and not to innovate. 
Oh shit!? It didn't say meatballs?
There isn't 15 of _anything_ on this site
Ads?
Actually, I really appreciate all of these things you mention above. I wanted to thank you for sharing all this things to me. For my initial reading, there are still lots of new words and terms I'm not familiar with so I'm still struggling a bit. I also wanted to thank you for showing how to run a gulp file. I initially thought running a gulp file is the same as running node.js script like: node "gulpfilename.js" I even put a console to see if it works, but the gulp codes isn't working. Also the thing I observe about gulp tutorials, they really emphasize the folder structure of the gulp codes. Does it really necessary to have the same folder structure in every gulp script that I have or it is just a standard I need to follow for me to have an organize body of script? 
Fixed
I like this in theory but I think the biggest problem is noise won't compress much. 
Unless you are supporting older browsers, then just keep doing the same shit.
`const` and `let` are the new, better `var`s. You should always use them going forward, but there are gotchas because they behave differently. `const` should be your default choice, and prevents a variable being reassigned. If you cannot help but have a variable that might be reassigned, use `let`. Now for the gotchas. They are all about 'scope', and I'll try to make this as clear as possible. This is perfectly valid code: foo('1ST'); // =&gt; '1ST: bar is undefined' bar = 3; foo('2ND'); // =&gt; '2ND: bar is 3' function foo(x) { console.log(x, ': bar is', bar); } var bar = 1; If you know nothing about js, you might read this code in the order it's written and ask yourself * how can you call `foo` before the function is declared? * how can you assign anything to `bar` before the variable is declared? * how can `foo` reference `bar` before it is declared? * why is the `bar` `undefined` the first time you call `foo`? These are all excellent questions. What happens when a javascript environment runs this code is that it makes an altered version of it first, then runs that. In that altering step, it hoists any function and var declarations to the top of their scope. So, let's get this out of the way: what is this 'scope'? This is simply where a declared variable is usable in. `var` and `function` are both 'function scoped', meaning that whatever function block they are declared inside of, that is their scope (and if they are outside of a function, they are 'global'). Hoisting means that they are moved to the top. But the thing about `var` is that *only the declaration is hoisted, not the assignment*. That is split into two separate steps. So this converted code will *actually* look like this: // variable declarations hoisted to top, default value is undefined var bar; // then function declarations are hoisted function foo(x) { console.log(x, ': bar is', bar); } foo('1ST'); // =&gt; '1ST: bar is undefined' bar = 3; foo('2ND'); // =&gt; '2ND: bar is 3' bar = 1; // bar assigned but not declared Now when you follow this in order, everything makes sense! I hope so, anyway. Now what about `const` and `var`? First off: **they do NOT get hoisted at all**: if you use them somewhere, you have to declare them first. Second: you cannot declare a `let` or `const` variable more than once in the same scope: it will throw an error. `var` is perfectly happy to let you do this, though, because it amounts to the same thing after hoisting; Third: they are not function scoped, but block scoped. This means that they are scoped to any enclosing statement block, such as an `if`/`then`statement. This is because that is what you might expect, and is the source of bugs in js from people who don't realise it. For example: var bar = 1; const baz = 2; if(true) { var bar = 3; const baz = 4; } console.log(bar, baz)' // =&gt; 3, 2 The `bar` in the `if` statement is the SAME `bar` as outside it! The most common case of bugs from this is in `for` loops: if you declare a looping variable with `var`, it is the SAME variable and if referenced *after* the loop is completed will just be the last value it got assigned. const arr1 = [], arr2 = []; for (var i = 0; x&lt; 3; x++) { arr1.push([ i, ()=&gt;i ]); } for (let j = 0; x&lt; 3; x++) { arr1.push([ j, ()=&gt;j ]); } arr1.map(([ a, b ]) =&gt; [ a, b() ]; // [ [ 0, 3 ], [ 1, 3 ], [ 2, 3 ] ] arr2map(([ a, b ]) =&gt; [ a, b() ]; // [ [ 0, 0 ], [ 1, 1 ], [ 2, 2 ] ] 
Can you create a jsfiddle so that your problem becomes more clear
I would read some blogs. They have real world stuff in them. Here is a start: http://blog.mdnbar.com/blogs-to-follow-to-learn-javascript 
Excellent article.
Try Wes Bos's 30 days of JavaScript
*cryptocurrency
Beat me to it
&gt; Just use `var` -- &gt; companies that just need their stuff to work -- Choose one.
Wow, that's terrible
I tried looking at it... but I cannot see what app it is you are talking about, so I cannot reproduce the problem to dig further. But guessing what would be the issue: - Perhaps the selectors are incorrect once it is in this "app" environment? - Is the checkbox in your 'app', even a checkbox? Or could it possibly be a simple div with class toggles that mimics a checkbox? - If the content resides in an iframe, you may be facing security or cross-domain restrictions. https://stackoverflow.com/a/1796621 (more importantly, see the comments underneath the answer). Again these are only speculations without seeing your issues in person... hope they can help with your investigation. 
Freelance work
From the Checkbox Plugin documentation: &gt;While historically it was possible to customize the default state of the checkbox plug-in, beginning October 6, 2017, the default state of the checkbox plug-in will be unchecked only. Websites that implemented the plug-in before this date will still be able to select checked as the default state. https://developers.facebook.com/docs/messenger-platform/discovery/checkbox-plugin/
this is wrong. `var` is scoped to the nearest function block, and `let` is scoped to the nearest enclosing block. sometimes `var` is best suited to the situation.
It sounds like I missed your intended use case. Let’s back up so I can get on the same page. Then we can modify that script to better suit your needs. What is the intended use case exactly? It sounds like you want to build a tool that takes a list of filenames and a name of the .zip to output. Is that correct? What is the maximum number of files you expect to zip together in a single run?
You are removed from the industry. Every company I've worked on in the last few years transpiles with babel. "Vars" are denied pull requests waiting to happen.
I didn't look into the actual details of what you're doing, but if I'm remembering correctly the browser will forbid any interaction between javascript on the page and elements in an iframe due to security concerns. So if you're trying to edit something in an iframe from "outside" the iframe it's likely not possible through any means. ...if I'm remembering correctly.
You need a personal project. Look about in your personal life for some app you wished exist. It could be lame, like: * I want an app for tracking my exercise at the gym * I want an app for generating passwords * I want an app for organizing my tools I've done this a few times and now I have one app which supports 100k users. But anyways my point is if you start with problem you want solved you'll end up having something to work on. It's ok to reinvent the wheel to learn. 
The best way to learn javascript (or any language for that matter) is by proggraming, running into problems, debugging, googling, and solving them. If you have the time, undertake a personal project of your choice. It can be anything you want, but preferrably something that'll take you out of your comfort zone. It can be a game, an app, a fancy user interface with lots of behaviours, whatever you like. One that taught me a lot was when I decided to make a calendar similar to Google Calendar. The HTML and CSS are relatively simple, and you can make it client side only if you want (mine saved your created events in a JSON locally through the localstorage API). If you don't know where to start, start by examining javascript apps you like out there and google about the concept :P
...back in the days (2000s, man I'm old :p), the "Cookbook" series from O'reilly were very decent. Plowing thru a few cover to cover has got me really far. I am not sure of its quality and effectiveness in this era though, but you can give it a try or read some sample chapters... or maybe there's even freebie online versions from O'reilly themselves. https://ssearch.oreilly.com/?q=JavaScript+CookBook
Put your skills to practice. Do something. *Make* something. Make something that you always wished existed, or recreate something that you think is really neat but you're not sure how it's done.
None of the companies I've worked with ever needed the use of a compiler.
For base knowledge I think playing codewars is great. Later (or on the side) you can move on to popular frameworks and implement some sandbox stuff.
Books can only help you so much. Come up with some projects and try implementing them using as much JavaScript as possible.
I think FB might do this to prevent stupid people from adding malicious code because they read it on a website or a spam email told them to. Some people are stupid. They even add warnings in the source code and console.
Transpiler. You're going from JavaScript to JavaScript. You code in ES7+, babel turns it to ES5. If your build process does t involve this, you're working on legacy software.
This is the correct answer here. Iframes prevent any kind of interaction due to CORS: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS I initially ran into this issue when a client wanted to track clicks within an embedded (iframe) video. It sucks, but allowing a page to interact with an embedded one through js would open up a huge security flaw.
Why not just do it direct in ES5 ?! That's what most are doing anyway. 
Sunday projects! Like I recently did a bunch of [sorting algorithm visualizations](https://caspervonb.github.io/toneofsorting/). Tend to do at-least one of these a week outside of paid hours.
It's doable but highly impractical.
Try the [exercism.io JavaScript track](http://exercism.io/languages/javascript/about). Various exercises with community feedback.
Figure out something you want to make and make it. A blog-type site, a movie database, a todo application, etc.
Totally. Now that you've read a few books, you're qualified to start freelancing gigs! 
Is this for "learning" or does it have advantages over the native node [events module](http://securityaffairs.co/wordpress/64373/breaking-news/wpa-krack-attack.html).
Find something you like, i.e. gaming (will use this as an example) Build a web app that pings the twitch api and gets back some data . Then take that data and map it to the screen / do with it what you will, maybe you can show the highest rated streamers or filter for some that are online. Take it however you will be its a good excercise in getting data from an api and creating a small app
That is not what "most are doing" anymore. The benefits of using babel are as follows: * Optimization: babels uglification acts as a minifier for reducing code size. * Brevity: ES6+ has features such as arrow functions, rest/spread, and other syntactical implementations that make code smaller and easier to read. * Compatibility: You can be sure the code you write runs on every platform. If you've ever seen just how verbose ES5 is compared to ES6+, you'll understand that time (and as a result, money) is lost by writing in archaic ES5 instead of allowing the transpiler to do the heavy lifting for you. I'd caution against making statements like "That what most are doing" when you are obviously misinformed.
Noob here, can JS be used to make phone apps? I would like to create an app for tracking my exercise at the gym, but it would have to be a mobile app.
I saw that. My website did have it installed well before that date. Then POOF, the pre-check disappeared on October 14th.
Nope, "count" comes back with only one syllable. There are a few ammendments I am making. The biggest flaw I have found is for the word "any". It's 2 syllables but my function returns 1 if the character count is less than or equal to 3.
so, if javascript can't do it. is there something else that can? Ajax?
Find a frontend job :-) Or, at least, some freelance orders. Or participate in an open-source project.
So 7.x is all good?
There is a browser extension for Chrome (https://chrome.google.com/extensions/detail/nnbihdpkeohjdfncchjhidbbonnihaob) that successfully finds the check box inside the iframe. So browser can do it, but not a website?
My guess is that's because browser extensions have access to a lot stuff that regular websites don't. I think they're basically just computer program that have access to your browser and happen to run on your browser. There's a browser extension to remote control your desktop from another computer; obviously a website will never be able to take complete control over your computer like that extension can. There's a lot of protection built into basic browser javascript, what it's allowed to do, and what's disallowed.
Check out react-native. I haven't used it personally, but it looks pretty good.
Check out React Native then :)
In order to learn you must throw yourself in the deep in. My first javascript project was making a multiplayer game using sockets and rxjs, which seems like absolute madness, but it sculpted me so much. Any crazy idea I have I don't think about how to do it first, if I like the idea I go with it. You will run into roadblock after roadblock. You will think that you're not good enough or you won't ever be an excellent coder, but getting through all of this is what will push you so much further ahead.
Yes it can but not natively. You will need a wrapper for your app I suggest you look into Cordoba and maybe a framework to help up with the UI of your app to quicken things up. Gl
Then try Wes Bos' Node.js course
Yes! There a plenty of frameworks that allow this - you just need to do some searching. Personally, in learning [React Native](https://facebook.github.io/react-native/), which uses js and the react js library to create near-native apps for Android and iOS.
Well, again I haven't looked at the actual specifics of what you're doing. It's really late where I am right now. If you're still at it and need help tomorrow I can. But if you own both websites the outer website and the iframe website, then yeah you could set something up like that. The outer website could send a request to the inner website and then the inner website can check the checkbox. However at this point you probably have security issues or something depending on what you're doing since it's now going over the internet. Also, setting up a *website* to listen for a request is not as easy as setting up a server to listen for a request. So you're getting pretty complicated by going this route.
It's an iframe, You _Shouldn't_ be able to use js to affect anything within it. See if there's some sort of configuration on the initialization of the iframe if you'd like
nooo nono no. The whole point of an iframe is that you're not in control of the content or it's actions. You're not supposed to be able to do anything with it. Look for a configuration object or something on the initialization
+1 for vue. It has solid TypeScript support too.
You don't have to list me the benefits of babel or to assume I know nothing about anything else than ES5. I work hands on with developers from all around the world in corporations and still have to meet somebody whose code contained a single "let" or "const" on a professional level. You can caution me as much as you want, yet misinformed I am not.
Ah, I see now that you were trolling the whole time -- you certainly got me.
[The guy who wrote YDKJS agrees with you](https://news.ycombinator.com/item?id=10187130), but pfft what does he know?
Yep. So what I'd do setup a manifest file and use bootstrap or a similar UI framework, and then store the data in localStorage. 
two options: Come up with some idea for something you could use. Some type of SPA or something like that. stick to the idea and what you want it to do exactly and then start coding using google and all that. --or-- go to codefights and do the arcade and challenges people put out usually every day. they are really hard for a beginner but it will really help develop a "coding" mind by solving arbitrary problems every day with loops and searching arrays and stuff like that. --or-- combine those two things
If you have a web hosting service you can make a web page and go to it on your phone. Web hosting services don't cost much, and you could even get your own domain name. You can use the JS localStorage API to store your data, and/or send the data via ajax to your server, and store it however you want (most web hosting will include database access of some kind). Unless you really need a native app, I'd personally recommend just doing it this way, so you don't have to futz around with wrappers and a bunch of configuration, or God forbid Java. You can also test your page on any regular computer without having to run an emulator. 
Is there a way to see a non-minified version of the code? 
document.designmode ="on"
I find your use of "nerd" ironic. If you think there's something wrong with being a nerd you're in the wrong place buddy.
Example why it would be a bad idea if this would actually work: invisible iframe with Facebook loaded.
I was battling an ad on a website that was passing my ublock. I tried adding new rules with stylish. Then it magically added custom inline rules full of !important. I thought fuck this shit I'll use JS to remove those styles. I couldn't do anything. Whenever the inline style changed the ad reverted back! What did the trick was the simplest approach, element.remove()
Yeah. Me too. 
Dunno why you've been downvoted, you're correct. Js apps can be deployed with Cordova or phonegap, but none of them, even react-native (which does take advantage of some native features), isn't actually "native"
There's nothing really wrong with freelance work, as long as you're charging by scope rather than time, and you actually deliver what you promised. There's a lot of people looking for simple websites for their small business and are willing to pay a few hundred bucks for someone to wire up a wordpress/wix/etc site for them. I think freelance teaches you some "street smarts" that help later on in your career (e.g. as a freelancer, you kinda have to be able to see things from a big-picture perspective at all times, whereas a corporate frontend person is often shielded from those responsibilities). The caveat is that what you learn out of freelance doesn't necessarily have the same focus as what would be expected of a candidate applying specifically for a frontend role in a bigger company, and you're most likely not going to be polishing core CS skills in the course of doing freelance work. 
An ad on your Github project, really?
React Native, as has been mentioned, is an option. There's also Cordova which lets you use plain javascript. The difference is that React Native is faster, and can use better hardware acceleration. For a basic app that just fetches data from a server or internal database and shows it on your UI, Cordova is just fine. If you know Angular, you could use Ionic, which is Cordova setup with some pre-built Angular components (stuff like mobile style slide out menus). If you know Vue, Quasar is it's equivalent.
Unfortunately the best way to practice, is to actually make something. To start, you can go through a course or book that goes through a project but ultimately you're going to have to find a project to work on, that's literally the only way you'll get better.
No no, you're thinking about blockchain technology. OP made an app for *glock*chain technology.
Go through the projects on freecodecamp.com
Would you do that or the ES6 course first?
I suspect the most used JS code is as follows: 1) trap a click on a button or a form submit element 2) extract the data from a DOM element (normally as a result of 1) 3) send the data in an ajax call to a back-end and use a callback function to process data sent back to you by the back-end 4) date manipulation Practice these items
https://www.youtube.com/watch?v=ZXsQAXx_ao0
Nope. 
Yes you can. I would go with React native but Cordova can work really easily as well.
From the reader &gt; Burns allows you to define all your app's events in one central location (the register function), and write robust handlers (which you should probably put in a listenersdirectory).
If you're writing articles (well supported or not) about the architecture of web applications I think it's safe to say that you're a nerd. If you're reading articles about web application architecture I also think it's safe to say you're a nerd. I similarly think it's safe to say that *I* am a nerd. If you think nerds using the word nerd to talk about nerdy stuff is derogatory maybe you're in the wrong place?
Learn vue + nativescript
Nothing that can't be replicated with a tiny amount of architecture discipline. 
He touches on the es6 stuff in the node course and explains some pieces briefly. I'd do the node course first, but if you want a solid understanding of the es6 syntax and updates, do that first. 
its what i do for a living, so yea, i practice daily.
👋 Author here! I built this web-app over my vacation recently, simply because I wanted it to exist (perks of being a software dev, you can build the things you wish existed!). The front-end is React/Redux, back-end is Node/Express/Mongo. The app is front-end-heavy, with a minimal back-end to serve data and handle auth. Check out the app itself here: https://tello.tv
Don't discount animation! Some of the most interesting front-end work is coming up with how to make static content interactive, and animation is a big part of that. While a lot of the codepen stuff like "swinging cat" and "solar system demo" may feel like you'd never use it, the underlying techniques can be used to create delightful form elements, help your users preserve context when modals or alerts open/close, handle page transitions between routes, etc.
CS is the most common path to Product Manager, since it's essential for the PM to have domain expertise. https://www.quora.com/What-is-my-best-option-for-a-major-to-pursue-for-a-good-job-in-product-management
Try bookmarklets. https://support.mozilla.org/en-US/kb/bookmarklets-perform-common-web-page-tasks
Colour me surprised!
I use https://www.codewars.com/ 
Start a personal project and do code wars.
I was just about to write this. I agree completely. Doing exercises is just a grind without much reward, but creating something that is actually useful to you is very fulfilling. You don't have to solve problems that everyone has, and I'm certain there are many things in your life where the solution isn't EXACTLY what you want. You'll feel far more motivated to learn more. It'll start off rough, but it won't be that way for ever.
https://www.reddit.com/r/groupdeals/comments/6nprta/wes_bos_courses_megathread/ Plug for the group buy megathread. I bought all his courses through that.
Make a javascript based game!
X-Post referenced from [/r/reactjs](http://np.reddit.com/r/reactjs) by /u/joshwcomeau [Tello - web app to track/manage TV shows. Made with React/Redux.](http://np.reddit.com/r/reactjs/comments/77866x/tello_web_app_to_trackmanage_tv_shows_made_with/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Yes. /r/savedyouaclick 
*sobbing*
For what you're talking about look at some of the static methods on `Object` - `Object.seal`, `Object.freeze` etc. 
He says it's slower than multiplication in javascript though...
Taking some guesses: If you are on OSX\Linux you could just use the zip util for that: `zip -r -X archive_name.zip file_or_folder1 file_or_folder2 ...more_file_or_folders` https://coolestguidesontheplanet.com/how-to-compress-and-uncompress-files-and-folders-in-os-x-lion-10-7-using-terminal/ If that doesn't cut it we can modify the gulp script to suit your needs. The typical use case of gulp is that you automate pre-defined tasks for an existing project like bundling all JavaScript files into a single js file. So typically you would always have a pre-set source directory for your JS related tasks to run against. In your case we can still use gulp but we'll need to use it in more of an out-of-the-box way. First, let's install the gulp steps as a global dependencies. This way the script can be ran from anywhere: `npm install --global gulp gulp-cli gulp-filter gulp-zip` Second, let's modify the script to use CLI args instead of predefined paths. The script is a bit large for an embedded reddit post but here's a tested version on gist. https://gist.github.com/jayzawrotny/872d58dff18af8a7cf5cc69bfb995dcf Save that as `zip.js` and it can be used like: node zip.js archive.zip file1 file2 ... fileN You can even use glob strings like I briefly discussed before like: node zip.js archive.zip "**/*.json" Which will archive all files within the current dir and subdirs that end in .json.
Search for Wes Bos’s _JavaScript 30_ (free) course.
make yourself a cow man. an AI webcow simulator. dooooo itttttttt.....
The thing is, dude, whenever you mention a book here, the dyslexic tard bunch of hipsters are down voting you instantly. The only thing they enjoy are smelling their own ass in ugly sweaters. They are the kids of stolen attention and consumerism ... 
Another vouch for codewars.
how else would I gather few useful links to one place and make a story of it? :)
Check out one of the many coding challenges sites. I recommend codewars as it also has a lot of problems more suitable to people newer to the language and doesn't focus so much on math. You will pick up a lot by working through challenges and reading through other people's solutions. 
codewars
Great that someone mentioned street smarts which is a key element to handle things and work as a dev. And yeah, there's nothing wrong doing some freelancing. 
The benchmarks show the bitwise operators as slower.
My thinking exactly ... the way I put it is "use it, understand it, challenge it". Find out *how* and *why* things work the way they do ... for example; "why in JavaScript can I pass functions as parameters to functions and/or return funtions from functions?", plus, naturally, "what good is that for?" ... once *that* thought opens up, you'll have an interesting world ahead of you ;) ... and that is just one(ish) example.
But hist thing was being a "rock star", I just want to get a job :-)
This is a useless benchmark. The code in question differs by a single CPU instruction, it would get [inlined](https://en.wikipedia.org/wiki/Inline_expansion) by any the modern engine, so it's just measuring an empty loop. The actual performance is likely dependent upon the calling stack -- whether the input was previously a "[smi](http://thlorenz.com/v8-dox/build/v8-3.25.30/html/d8/dca/classv8_1_1internal_1_1_smi.html)" or "[byte array](http://thlorenz.com/v8-dox/build/v8-3.25.30/html/d1/d5d/classv8_1_1internal_1_1_byte_array.html)" or some other. Here is a good video on JavaScript micro-benchmark: https://youtu.be/65-RbBwZQdU
While other comments are good, especially ones about personal project, I'd also recommend https://www.codewars.com/ It's not a substitution for a project full of features but it really helped me polish my js skills and understanding of some not so easy concepts.
React Native is a little complex to beginners. Try out [Cordova](https://cordova.apache.org/) to begin with, that's basically just a web page with Cordova APIs.
This should be the top answer.
In all seriousness, this is not a bad idea! Sometimes thinking of a greenfield project can lead you into another level which you may not be ready for. For example many times it's not the framework which sucked, but the design decisions or something else. Start with something crazy and what you would love to just do... Make an ASCII cow... Make it say stuff that a user inputs... Make a button that gets some random data from a rest endpoint and make the cow say it... Let user customize the cows appearance... Greedy cow, dead cow, etc. Make it remember its state and stuff... That way you will learn the fundamentals very well. I am applying the same process to learning CSS. I tried learning it and making some screens, but many times would get stuck at silly things... My aim right now, is to make a cat with CSS and make it dance (no end date for the project!) 
nice.. there is actually a free ai chatbot webservice api on the net somewhere. I used it to make an android app that would text my friends back for me and carry out conversations when I didn't feel like talking. it's actually pretty convincing until it starts asking my friends if it likes my new dress, which, as a straight male confused me friends quite a bit :P
Rad! Thanks. 
needed such a good laugh. thank you for that. haha
It is less than 1.5% slower. Does it make it slow?
I did not say that it's not slower, I said that it's fast.
Gotta make that money playa
For an IoT device I'd recommend johnnyfive, node, express, and then plug that into vue
Check out https://stenciljs.com/docs/routing
Wondering, do people who like this type of code also against the new JS changes with async, generator functions? This is a move in the opposite direction.
So, multiplying numbers by 2 and checking if the result is even, right :) 
Give a try prouter (author here), it's like express.js for the front-end, in fact, it do uses the same library than express does for parsing URL expressions: https://www.npmjs.com/package/prouter
Give a try [prouter](https://www.npmjs.com/package/prouter) (author here), it's similar to an express.js for the front-end: https://www.npmjs.com/package/prouter
Interesting library. Seems like a better alternative to Polymer. Thanks for sharing!
I would definitely look into React Native. We use it professionally where I work and I love developing with it. I don't recommend Cordova until after you've given RN a try and found it to be too difficult.
Kudos for the clear description in the README.md. Indeed it feels really familiar, after using express. I'll keep following this project.
Yeah it's amazing how much more meaningful a personal project is than some example or exercise you really don't have a personal attachment to. Also you learn about the world if one of your personal projects takes off, things wholly unrelated to technology. 
So all these different technology suggestions here ... one way to figure it out is go look at them and see what has good examples you can understand and follow along with. It doesn't matter if someone recommends technology X or Y if you can't dive in easily. What ever you choose will be wrong because the world of javascript and HTML framework changes all the time, some new thing will come along which is better or different about every 6 months. It doesn't matter as long as you're learning Javascript and HTML, try to choose something that doesn't hide either the HTML or the Javascript side of things. 
repository: https://github.com/klauscfhq/tusk#readme homepage: https://klauscfhq.github.io/tusk
try some /r/dailyprogrammer challenges
JS as in the programming language, absolutely, there are many ways to do it, as others have answered, but for most things you have to learn additional things like frameworks or tools. JS as in web/browser based stuff: also yes, but on Android only. If your Web App (that's nothing more than a website) includes a small JSON manifest that tells the phone how it should handle your page and registers a (also JS based) service worker that caches your sites assets so it can even be displayed when you're offline, your browser will notice this and install your site as an app, right there with all the other apps from the Play Store. It sounds more complicated than it really is, I actually did it for my first ever web project. Google "Progressive Web App" to learn more! :)
I've always been curious about stuff like this... Maybe I'm wrong (im still learning javascript), but to me, it seems better to use the for loop in the given scenario, and In lots of scenarios I see people using across the web. Maybe this is different in javascript, but when I would build games in Actionscript it was always better for performance to always use a for loop as oppose to stuff like "forEach" or other array methods. If each of the methods on the array (like map,filter,slice) returns a new array, isn't that eating up unnecessary memory? Yes maybe chaining all those methods is prettier, but I wonder if It is slower than just doing the for loop. Also, it seems like more often than not, I DO want to change my array, so I have no problem mutating.
Here's some past stuff: https://applidium.com/en/news/data_transfer_through_sound/ https://www.chirp.io/ https://github.com/rraval/pied-piper http://www.hobby-roboter.de/forum/viewtopic.php?f=4&amp;t=128&amp;p=531
Does the assignment state which browsers? I'm pretty sure if you open up IE6 and try surfing the web you will find many examples, but using IE might be considered cheatinf
This was perfect. Thanks! 
&gt; If each of the methods on the array (like map,filter,slice) returns a new array, isn't that eating up unnecessary memory Not really. If they are scalar values (strings, numbers), then they don't consume much space. If they are objects, then the new array is actually just a new array of pointers back to the same objects, so very little memory is used (but it also means mutability is still an issue unless you break the pointer using `let newObject = Object.assign({}, oldObject)`; Meanwhile, once there are no more references to that old array, it gets garbage collected anyway. Unless you're dealing with 10's of thousands of records at once, premature performance optimization should not be the governing factor of your code design. Sometimes you do want to mutate, sometimes you don't. It depends on the situation and the context, and you should use the most appropriate pattern for the problem you're trying to solve. 
Can you explain a bit more? why are functional concepts in the opposite direction of async and generators?
&gt; As a programmer, we know that bitwise operators are fast. And to optimize our code, we usually replace the regular operators like multiply, divide to bit shifting. Hell no we don't! As a programmer, I write code that expresses what I'm trying to do. And if that is multiplying two numbers, I multiply the two numbers. **IF** - and that's a very big "if" - it ends up being a performance issue, then you can think about bit shifting. Comment out the original straightforward code and write out the shifty version. And I'm some who grew up on bit shifting and knows it cold. Of course if the code I'm writing actually deals in bit shifting - and not just a way to hand-optimize a multiply or divide - then I'll write the bit shifts, because those are what I'm trying to express in the code.
thanks for the reply, I guess that makes sense. I've made many games that do lots of collision tests on a 60fps interval and I guess I've become anal about trying to squeeze out performance I never stopped to see if it mattered for elsewhere projects in javascript.
Try accessing websites with sliders on Safari. It implements time events and scrolling in a weird way that usually break sites.
my thought exactly. I doubt there is a REAL WORLD circumstance in which optimisations this minute result in any noticeable speedups (especially in JS) this post would maybe fit better in /r/programmingcirclejerk :/
[removed]
I was basically thinking the same thing. The number of linear operations across the input data is increased to improve readability. 
These projects do not run applications on web browsers...
If you control the server the page the iframe is coming from you could send a request from the parent page to the server and the page that is iframed can poll via Ajax to see if a flag is set, and check the check box accordingly. Sometimes it's faster to do an integration like this even if you own both websites because teams or whatever reason. Otherwise, no the enclosing page can't access anything on the iframe page.
Correct, but the encoding schemes used by those could help increase bit rate.
I build a webapp for make magazines (like indesign), i think you can't go very deep in js without go very deep in css and html5. I mean, you can learn really a lot about the software using the books, but the real problem is the true work with tons of different objects and interactions. To manage multiple pages, texts, text-flow in columns, rotation of objects, group objects and the mouse interactions when rollover multiple object with totally different properties. If you want a daily practise, do an app that produce something and try to see if you (and your users) can work for hours with your app crash or stuck in a loop.
Is this ES6 or ES5? If ES5, go http://kangax.github.io/compat-table/es6/ and check the obsolete browsers and look at things like .bind(). If ES6, even some modern browsers will be lacking, which you'll be able to see here on the list right away.
You're right, the benchmark is useless, it actually reduced to nothing. This is a huge mistake :( thank you so much for pointing it out.
Then along came `async-await`. Nice article though.
In the first piece of code (non flat), there is just one for loop. In the second, flat version, there are multiple loops. I would imagine this has drastic effects on performance; while probably minuscule on the level of an individual function, probably on the level of an entire app, no?
the most vanilla implementation is always fastest. i always laugh when people tell me to use forEach instead of for. when i remind them forEach uses for under the hood they just walk away.
&gt; is pre-selected. I have the same app on my store, however, it loads with that box unselected. The way to do this is for a extension is by running your script in the context of the iframe instead of the page. You used to be able to get around some of the cors IRC by creating a script element and appending that tag to the iframe, but I don't think that's allowed anymore.
for loops do have better memory profile and performance, but your code becomes more readable/expressive/testable when using array methods (because you no longer have the counter increment logic mixed with your other logic). Generally speaking, you're not going to be doing computationally expensive things at 60fps in js, so the loss in perf is typically acceptable in light of the other benefits
&gt; Now I'm trying to ditch frameworks in favor of native web components. Out of curiosity, what do web components give you that these frameworks do not? Web components still require javascript, and will require polyfills much heavier than any framework besides latest Chrome.
Find small town websites for paying bills, traffic tickets, ordering stuff etc. For anything that has a form, there’s a good chance something is broken. Open up your dev console and try interacting with every form control... most have at least a glitch or two.
I haven't touched forEach since for-of was introduced.
Have you considered just using seconds to split up you bucket? ``` range = maxDate.getTime() - minDate.getTime(); bucketSize = range / NUM_BUCKETS; // in seconds ``` Then to get the bucket sizes you need to allocate them in some way. I would probably create some buckets in the following way. ``` buckets = []; for(let epochTime = minDate.getTime(); epochTime &lt; maxDate.getTime(); epochTime += bucketSize){ buckets.push({min: epochTime, times: []}); } ``` Then to put a new date into the buckets object ``` function addDateToBucket(buckets, date){ let prevBucket = buckets[0]; for(let i = 1; i &lt; buckets.length; i++){ let bucket = buckets[i]; if(bucket.min &gt; date.getTime()){ prevBucket.times.push(date); return; } } prevBucket.times.push(date); // last bucket will be missed by loop } ``` A library seems like overkill, but I'm sure the monster that is momentjs will have something to help.
Hi /u/Joeynuma, For javascript help, please visit /r/LearnJavascript. Thank you!
Thanks this post taught me some stuff. 
&gt; Maybe this is different in javascript, but when I would build games in Actionscript it was always better for performance to always use a for loop as oppose to stuff like "forEach" or other array methods. Well, first of all it's worth noting that you should not rely on your knowledge of Actionscript optimizations (whether AS1/2 or AS3) anymore. I suspect you know this, but it's worth mentioning. Javascript may even have a different optimization profile in some cases depending on which engine you are using (e.g. Chrome's V8 engine, Firefox's SpiderMonkey, or Edge's Chakra). They are also more optimized than Adobe's AVM2. But more importantly, you need to have an argument *for* optimizing something in the first place. In the overwhelming majority of cases, you will not need to optimize Javascript. Unless you are indeed programming a game, or something that renders every frame, or if you are optimizing some DOM heavy aspect of a large SPA. I virtually never do micro optimization. It's something you seldom need to pay attention to, in part because by far most code you write in Javascript only executes sporadically (e.g. a handler for a button, or some code that runs in response to data being loaded). For most use cases, it's very rare that there is serious cpu time to gain.
Easy, open up Internet Explorer and browse through new apps on product hunt
What! No determinant? /jks Looks good though. :) 
Seconded.
7.x is an *unstable* release (following the Linux standard of even = stable), and is essentially the abandoned early releases of 8.x before it was stable enough to use an even number. *If the issue is zlib*—which I cannot say with any degree of certainty—the switch happened during the 7.x development period. All of this aside, I would not recommend using any odd-numbered release in production.
Each of those methods (map/filter/reduce/forEach) is another iteration through the array when it could all be done in a single iteration, so there is definitely a performance downside. Whether it's practically relevant is another question. Technically, anything you can do with a chain of those methods can be done in a single `reduce` call, but then you've lost the readability/flexibility/single responsibility aspects again (which is kinda the whole point).
I'd suggest router5. http://router5.github.io/
It's JavaScript, you can never be too careful.
It's undefined. I don't know what he was going on about. And its not defined, its declared, and that gets initialized as undefined.
You have 3 options: 1. You control the source code both the interior and exterior of the iframe and communicate with postmessage with a csp set. 2. Chrome extension. 3. Automate the interaction with a headless browser like Testcafe which has the ability to orchestrate iframe context switching.
It's declared, not defined.
Wait this isn't a joke? Or is my chrome improperly rendering every codeblock on a single "flat" line.
I got distracted and left at that point
I'm a Sr. Engineer focusing on Javascript. Those guys were on crack. var foo; means that foo is declared, but undefined. If you want to be super pedantic and technical, var foo references a memory location that has not yet been assigned a value, but that's getting into pointers, which Javascript abstracts away.
Love too use floats as ints. 
I disagree with the fundamentals, but Promises are quite functional as they a) are monads 2) The bind operator (called `then` on Promises) can help create a flat structure as described above. The thing is, though it's a bit hard to think of it this way, `async`/"imperative looking" code to deal with monads is actually nice, but it's *just syntactic candy*. `&gt;&gt;=` is to `.then(...)` as `&lt;-` is to `async`. Generators are just implementation details (in this case). The core philosophy is identical, and it allows us to get *even flatter*, visually speaking. The way I like to think of it, "flat" programming is programming where the top is the raw resources and the bottom is the finished product. So you never go backwards. This isn't a functional concept, but it's not imperative either (though it's often object-oriented to a certain extent). add(x, y, z) is a funny statement. We all recognize it because that's how we learn math, but I don't particularly like it (and children don't start that way^1). You start with x, y, and z, and *then* you `foo` them. So shouldn't it be `(x y z) -&gt; add`? Of course, taken to it's logical extreme, you can end up getting backwards again (`arr.map(fn)` becomes `(arr, fn) -&gt; map`). So there's clearly a middleground to be had, and a good heuristic, at least in JS, is to just say "only one value can come first". This would work really nicely in a runtime like JS because we can pack up everything into one value and treat them like named parameters. ({ x, y, z }) -&gt; ({ x, y, z } =&gt; x + y + z) // assume the "arrow function" was imported or defined elsewhere That should look familiar, because it's almost exactly `Promise`s without their asynchronous capabilities. But the cool thing is that it could be a `Promise` with no change in logic. You're just passing in exactly one value wrapped in a "box" (monad) to a new function. How, when, or where it's passed is mostly irrelevant to your code. Now you have this really monotonous, flat structure similar to how it's described in OP. Sorry, I know that got super ranty and I probably got condescending at some point whoops. I'm pretty passionate about this particular topic and would love to see a language that does this. [Tulip](https://github.com/tulip-lang/tulip) promised to be my savior, but it (clearly) died before liftoff and I don't have the skills to implement the language. 1. So check this out: 2 + 2 -------- 4 That's how we learn to do addition. But the operator is at the bottom, after what we start with!
I think a major point that he may only have touched on is that this code is much more elegant to write. I have been using this style daily for months now and there is nothing sexier then a well crafted chain. Real world experience has taught me that premature optimization is the reason projects get completed late.
That is what I thought. Or is the browser smart enough to work in a different way?
If the people interviewing you were obsessed with your answer to that question (and the interviewer didn't even know the answer when for all intents and purposes you got it right), then that's not a team you want to work for. I prefer being/giving interviews where general knowledge is valued more than minute details. I expect to be asked about very important general concepts of the language, like context, this, scopes, closures, etc... but minute details that are easily forgotten should be saved for trivia, or maybe some icebreaker fun questions.
I've fallen prey to the "never use `var`" rhetoric. With `async/await` I end up writing stuff like this: let response; try { response = await fetch(...); } catch (err) { ... } if (response.ok) ... If I used `var` I could declare and assign my `response` variable on the same line, but for some reason I continue to use `let` lest I be judged.
Is there a chance they wanted you to respond with "a variable named foo"? Complete long shot. 
It’s really hard to tell in /r/JavaScript sometimes, but I think this is serious. 
Doesn't that statement assume that the DoS'd system is only user facing and would have a negligible footprint? What if the DoS'd system is an admin tool used for inspecting network traffic or for intrusion detection? This could open other systems for attack. What if the node service is a TCP based RPC tool, and the DoS is a buffer overflow attack which can lead to information disclosure? The worst buffer overflows allow for running arbitrary code on the server, and it can literally be months before the attack is noticed or before the attacker does anything with the exploited system. I agree that a simple DoS that makes systems unavailable _only_ is preferable to legal issues of losing customer data, but plenty of sophisticated attacks start as DoS and can lead to potentially millions in lost revenue or rooted systems.
For 99% of the use cases, you wouldn't be able to tell the difference between an app composed of vanilla for loops and one with for loops converted to forEach in a blind test. Yes, vanilla loops are faster but unless you are iterating over hundreds of thousands of items, you just won't be able to tell the difference. Theoretical speedups in program are not more important than code readability and composability. If you are writing code for a game's refresh loop, using object pools avoiding creating objects / triggering gc, sure, micro optimisations make enormous sense. If you are not writing code for a hot code path, you're just increasing your chances of writing buggy code and in general wasting your time with bothering with micro optimisations. The loop, whether it is for, or forEach, will finish far far before the next tick your screen refreshes, you won't be able to tell the difference but you'll accrue technical debt (more bugs, harder to read code) for those theoretical gains that can't be felt.
I'm sure functional programming has some benefit but it's not in these surface level things, changing a loop to a `filter` call is not that useful.
Readability and maintainability is king. I don't give a damn if you save a few cycles if I can't understand your code. Only write it in a way that optimizes for performance when you need to, if ever, and *never* before. &gt; drastic effects on performance If the arrays you're iterating over are very small, O(n) vs. O(3n) isn't a "drastic" difference at all.
It can be quite challenging to step through though. When your line with 50 chained methods breaks, you then have to break it up and fix it. Hopefully your debugger can help you out there. I've seen this called fluent syntax before and, while easy to read, it can be very challenging to fix when something goes wrong. That said, there are some things I like about it. My favorite is that there's no need to capture data in variables that might hang around for another developer to abuse or mis-name and introduce a bug.
&gt;Unless you're dealing with 10's of thousands of records at once, premature performance optimization should not be the governing factor of your code design. Even then it shouldn't be. If your codebase has certain solved problems or conventions when it comes to performance then by all means use them where you should. Otherwise, let the compiler handle optimizations for you - they are far better at it than we are.
I’m loving the super lightweight and cleanly specced navigo. Less than 500 lines of code.
Readability and performance are (often conflicting) virtues to be balanced. When working on a large codebase with a ton of engineers, fastest != best.
No biggy, all learning experience. What you done would've been valid 10 years ago when most JavaScript engines were still interpreters. Nowadays, they are all optimizing compilers (JIT or runtime recompilation). If you know Assembly, you can inspect the generated code by running `node --print-opt-code some_simple_file.js`. IANA assembly programmer, but looking at the assembly code myself, there are only about ~10 instructions difference. So in practice, on a [desktop CPU with over 100k MIPS](https://en.wikipedia.org/wiki/Instructions_per_second#Timeline_of_instructions_per_second), that's only about 0.01 nanosecond. In the context of [CPU latency](https://gist.github.com/jboner/2841832), the latency CPU has to wait for stuff to come from RAM is 10,000 times more. Even a miss in [branch prediction](https://en.wikipedia.org/wiki/Branch_predictor) would outstrip the "performance" gained, and branch prediction is a strategy taken by CPUs while waiting for data to come back from L2 cache.
What matters is the number of operations: for(n) { j++; k++; } And for(n) { j++; } for(n) { k++; } Will be virtually identical in terms of performance because it's still 2n operations. There's a small difference because of the extra jump, but it'll never be noticeable. The real criticism is that you're adding an additional function call, which definitely isn't cheap, but I wouldn't worry about that too much. You won't get far in JavaScript avoiding function calls so it's not worth stressing about.
Think about it this way – how quickly can you understand what a `filter` or `map` is doing vs. what a `for` loop is doing. `filter` is an idiomatic way for removing things from lists. `map` is an idiomatic way of transforming an entire list in some way. A for loop could be doing any (or none) of the above – thus, one of the main benefits of using a functional approach is the *readability* and *understandability* of your code. You're not doing it for the performance, you're doing it because it enables other engineers to grok your code easier.
All frameworks must support interoperability with web components, so you’re buying into the modern web itself, not a framework. Your components will be supported forever by browsers, and web components will be the default framework libraries will expand on as soon as support trickles down to 90% of users. After three years, all the browsers have finally implemented the spec, so it’s not just Chrome anymore, it’s Safari 11, Edge and Firefox (still flagged for now). Combined with recent developments like script type module and http2, small sites could be created without build steps or development servers. That’s wild. Hard to argue that this isn’t the future.
I see no difference, I usually understand the filter or map less since depending on the library used I have to go look at the implementation to understand what is going on.
Future you also counts as other engineers as well. 
That’s not his thing at all. You be you. What do I know? Good luck on the hunt. 
i'll be honest I didn't read the article but only quickly glanced for about 30 seconds so i'd say I am qualified to ask this question. But why would you filter an array of Odd numbers after you just multiplied all of them by 2? Shouldn't every single number be then be a factor of 2 as well? 
&gt; So shouldn't it be `(x y z) -&gt; add`? Starting kids on [RPN](https://en.wikipedia.org/wiki/Reverse_Polish_notation) huh? ;)
&gt; he said no, "How can it be undefined if it's defined?" The things that happen when you let junior level people interview
I'm sad that this article went into chaining vs composition.
&gt;I'm sad [Here's a picture/gif of a cat,](http://random.cat/i/pacifist-cat1.gif) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
I understand the argument and there are times when var could be used to have slightly more concise code but I feel when you're working with other developers it's more important consistent. Especially if those other developers are new or coming from other languages.
you need to look at V8's source to understand what filter and map are doing?
I work at a fortune 100 company that's in FinTech and am wondering what you're going on about. We have 10s of thousands of employees, 1000s of developers with projects in all sorts of languages. And yes, we transpile and use let/const. Using var wouldn't even make it past our linting rules that get checked during the build process.
Thanks! I wanted to avoid making this a computational library, so it's all about slicing, dicing, and getting cool things. Later versions will have utilities one could use to calculate a determinant! 
You were correct. He's an idiot. I would've challenge him to do it in the console.
Thank you. I feel like nativescript doesn't get enough attention 🐒
I should have looked into webgl xD
Codewars.com
Reminds me of using Linq in C# I like the idea. Makes the code more readable, as well as better insight into a person’s design. 
Codewars is tough as shit man, but I've only been doing JS for about 8 months now.
The point of the article is not resolving a task but rather show the difference between imperative and declarative code.
If you are using a map function and don’t know what it does....oy
why is this website SO unnecessarily laggy
Sounds pretty interesting but there is no useful link here - only a tweet loaded with hashtags.
No, Node 7 stopped being supported in June, and seemingly will not be getting this patch.
Are you sure you didn't misunderstand and they were saying "let's type": var foo = 'bar' "now, what if we type 'var foo' in the console" 
For *very* small arrays that's the same as O(n^(2)), which is of course unacceptably slow and a priority to refactor. ;)
That's not correct, from Oct 2016 to Apr 2017 Node v7 was the current stable version. Not being LTS doesn't mean it's unstable. See the graph at the [Node Release repo](https://github.com/nodejs/Release).
i have tried but it didn't working var data = JSON.stringify(data); var data = JSON.parse(data); console.log(data["records"][0]['name']);
I don't see how this would have changed anything. I don't think OP misunderstood them, I think they were just shitty programmers.
Yeah it makes no sense so I wonder if this is the full story
Codingame.com?
Could you make your website font a little bigger I could hardly see it, thanks. 
I feel the question is quite broad; because for foo to be *not undefined* in that scenario, there has to be some code up above that declared foo to be some value, like so: foo = 3; var foo; console.log(foo, typeof foo); That shows, despite the declaration of foo, it doesn't necessarily set foo to undefined - the value of foo is set to what it was declared else where. In ES6 the interpreter is going to cause an error when `var` is witched to `let` in the scenario i described above, because `let` has some scoping involved. 
I was always wondering whether it would be possible to capture a user's clicks and interactions in an app, and use the recording to generate a test like this. Thoughts?
Declared doesn't mean defined. Either you misheard them or they're terrible developers.
yeah I know I was just being annoying, sorry about that. 
Never overestimate the knowledge of the interiewer unless you know for sure. I went for an interview, years ago, for a web dev job. I was concerned I was in over my head but they gave me a 10 question quiz when I got there. I don't recall what the questions were but, when the interviewers came back, I said, "Come on, you can do better than that.", to which they replied, "Yeah, we figured this was going to be too easy for you." 
yikes. if you have trouble remembering what the world "filter" means, i think you have bigger problems. 
Way to miss the point.
I would like to see some of your downvoters explain why they disagree.
That's not how `O(n)` works!
Yeah, if they can't express a problem this simple during an interview, you have to wonder how they get from requirement to solution during the day job :/ Some interviewers are twats. Or in more business psychology friendly terms: Dysfunctional teams have dysfunctional hiring processes.
whaaat? I'll be honest here if that happened I'd insist on a console / REPL. The thing about these questions, is it literally does not matter in the grand scheme of things. We live in the world of Stack overflow... anyone with a brain can google this in 2 seconds. As a developer, you have constant free use of the internet. So your knowledge of trivia means shit. Give someone an open ended problem and have them talk through a solution or create a solution, and you'll have a better idea of their development experience and actual knowledge and skip over all the bullshit trivia.
mmmmm. I love this quote! Really hits home.
IE11 is very much still a factor for many of us as most enterprises are on Windows 7, polyfilling isn't great here. Evergreen browsers might have implemented the spec but the current spec isn't powerful enough to build modern websites. Polymer gives you more but you might as well use a framework at this point. Native components certainly are the future, projects like Polymer are guiding us in the right direction but we're not there yet. I'm going to need a lot more functionality before they are an option. I love using web components for simple leaf components but there's no way I'd use them for anything complex.
A big part of any job interview are trick questions. This is one such case. He wanted to see if you'd catch him out on his slip of misinformation.
A trick question sets up in a certain direction and expects you to either fall for it or show deeper understanding of a concept. This would be a trick question had the interviewer expected OP to say foo is null. Now it's simply a case of the interviewer being plain wrong. And as an interviewer you want to be right because job interviews work both ways, in OP's case I would nope the hell out of that job.
pfffffff lucky you. Those people seem to be crack pots. haha
This is reddit, if there's a petty nitpick to be made that has nothing to do with the actual point of the post, it will be. 
Ah dang it, it's already time to start prototyping with this stuff? Makes sense though.. common case users already use self updating browsers. 
&gt; If you want to be super pedantic and technical, var foo references a memory location that has not yet been assigned a value, but that's getting into pointers, which Javascript abstracts away. If you want to be super, *super*, **super** pedantic about it, `var foo` [creates an entry in a hash table](http://www.ecma-international.org/ecma-262/7.0/index.html#sec-declarative-environment-records-createmutablebinding-n-d) (an environment record) with the string key "foo" and the [value undefined](http://www.ecma-international.org/ecma-262/7.0/index.html#sec-functiondeclarationinstantiation) (which ironically is a real, defined value).
I have some trouble finding an example where you actually want to mutate your array, can you provide me an example? Usually I don't want to mutate variables cause it makes tests a lot easier
&gt; How can it be undefined if it's defined? it IS undefined, but what he probably wanted to hear is that just by putting "var foo;" you haven't *defined* it, you have *declared* it. which imho is silly pedantic nitpicking of the type that people who studied theoretics in some course at school love to do to feel great about themselves, but is completely irrelevant for somebody practically working with it.
Thanks for being pedantic! I'd like to think I'm fairly knowledgeable about javascript and reading the comments I was starting to doubt my wording on `var foo;` as I always say it's a defined-to-undefined variable. `undefined` is a real value in js and `foo` points to a real place in memory.
Use CSS if you can. If you can't, use javascript. CSS is pretty limiting for dynamic and complex animations, but for simple stuff, it's the right tool for the job.
&gt; `var foo` creates an entry in a hash table While that may be super, _super_, *super* pedantic, it's also wrong. There's nothing in the standard that requires a hash table to be used here. A JavaScript implementation may use any data structure and algorithm it wants, as long as the observable behavior matches the standard.
I'm an async sceptic. There are places where it's the best option, but I expect it will be abused by developers who don't understand asynchronous code because "makes everything synchronous".
Holy Moly...Thank all of you so much. This is incredible!
I dont think CSS Keyframing is that simple...
It's removed now. Great! It's very important to never highjack user controls. If a user wants to scroll in a different way; he or she would set scrolling speed in OS settings.
I wonder if a modern compiler optimizes that away... I should find out.
Hi /u/cute_cummerbund, I think most people in /r/JavaScript can help you, but you might want to check out /r/node
correct me if I am wrong. Chrome only optimizes if the code is hot, otherwise it still keeps "pseudo code"
I knew a bit of JS but wanted to learn it more indepth so I actually changed jobs that would allow me to write JS daily :) doing that for a year did wonders for my development
Thats stupidly cool, love it &lt;3 
&gt; If each of the methods on the array (like map,filter,slice) returns a new array, isn't that eating up unnecessary memory? The memory uses is likely to be small as each entry is a pointer to an object so even if it is an array of large strings the copy will point to the same immutable string objects. Also each intermedate array will be discarded so you'll have at most one extra in memory at a time. There is a cost though: each call itterates an array were the "for" version itterates the source array once, resulting in CPU time (on the loop itself, creating new array elements even though they are small, ...). This can be reduced by making sure any filtering functions are called as early as possible in the chain so that the number of elements itterated over is as small as posible each time. In some languages (and some Javascript libraries) a series of calls like this can sometimes get actioned as a pipeline so the end result is pretty much the same as the "for" version, but this is not the case with the JS built-ins.
1. Yes. That’s one Passport strategy. There are many with a variety of ways to handle authentication. 2-A. For a large project definitely separate the two. You’ll have separate build processes, deployments, potentially different teams working on them. For a small or personal project it doesn’t matter as much. 3-B. You can’t really but it’s not a significant threat. You still have all the data, you control the api, you could push breaking changes at a moment’s notice, etc. There is just no win for someone to create a competing app on your backend. 3. I’m not familiar with knex. If you’re looking for an ORM, though, sequelize and mongoose are very popular in node. 
What's with all the attractive people on the thumbnails in this sub?
X-Post referenced from [/r/node](http://np.reddit.com/r/node) by /u/keithwhor [Introducing StdLib Sourcecode: Share Your Node.js "Serverless" Code With Developers Worldwide](http://np.reddit.com/r/node/comments/77de8s/introducing_stdlib_sourcecode_share_your_nodejs/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I think they wanted to ask you about variable hoisting (there is another comment that explained what they wanted to ask with this) but they phrased the question completely wrong. Not to mention that if they are going to focus the whole interview on tricky old style JS details, do you really want to be working with that kind of team? 
I vastly, vastly prefer the `originalFn` over `abusedFn`. Lines and characters in source files are effectively free. It all goes through a bunch of pre-processors and minifier, and in the end roughly the same code gets executed anyway. What the first version allows is for me to pass the maintenance to the junior colleague and not get questions, or fix urgent bugs while hungover. 
The whole point is that you don't need to look at the implementation to understand what is happening with things like map, filter and reduce.
[removed]
&gt; In the second, flat version, there are multiple loops. That's why I recommend lodash every time - with their heurestics and shortcut fusion `_(arr).map(foo).map(bar).map(baz).value()` will run loop only once. [Docs](https://lodash.com/docs/4.17.4#lodash).
I wish for decorator/macro system that would allow something like that: ``` @fluent(['from', 1], ['to', 1]) function copyProperties(from, to) { return Object.assign(to, from); } copyProperties.from(foo).to(bar); ``` It's already possible, but it isn't picked up by type system nor IDE autocompletion, so syntax would be probably better. 
I'm not exactly sure I follow, how the authors premise of 'be more declarative' would be against something like a generator function or async. 
Cool that Microsoft supports this
This is good news. Where would we all be without MDN.
&gt; If the arrays you're iterating over are very small That's a big if. Anything bigger than 1000 and you already feel the difference.
weird bot
Who hurt you, OP?
You really should look at $.toggle() first.
Trust Apple to be absent 
You should see what happened when I used SQL a lot and tried to come up with my own optimal style :D
&gt; The main complaint though, is that this code is difficult to comprehend at first sight. I'm not sure I agree with the conclusion that it's "more readable". Loops are trivial to understand. If you use good variable names, and inline code comments, so much the better. Burying functionality behind these chained functions doesn't make things more readable for me. Even in the first example of his flat code, you have to go shoot off and look for the reduce function before you knew what was going on. Using tricky things like .slice, rather than explicitly setting a range further obfuscates the matter. 
If you can't read a for loop you're an idiot.
Nice collection, thanks for sharing!
Let's not ignore the fact that, until yesterday, Microsoft **was** absent.
Everything is awsome!
I am in the belief that either the guys were totally misguided, or the OP misunderstood something in the given context, because even if the question can be twisted around so much so that it starts to make sense, it'll not make any sense when it comes to interviewing someone.
Misleading title. I see at least a $15 budget. Good post otherwise. I take it you did not keep a public github repo updated while it was still a pre-release work-in-progress?
It is really up to you, if no one else is going to touch that piece of code, but if you were a developer in my team, I'd shut you to a dark and damp meeting room until you revert it back to something readable and meaningful. In general, I'd advise against using anything like this, I don't know about you, but I (and I think most human developers) usually have a hard time coming back to old code and trying to make sense to magic like this. If you have problems with declaring variables, why didn't you inline the id's declaration to the function call itself?
Not the internet... It's supposed to run just the same on apple devices as on microsoft or android devices.
Based on what we tracked, the traffic which came from Facebook, hasn't converted into Github stars. That's why I actually named it *neutral thing*.
&gt; will redirect relevant pages from Microsoft Developer Network to MDN This is the real indicator to me of Microsoft actually committing to this rather than buying a quick bit of limelight and getting some good PR.
This side of the coin is far less talked about versus focusing on code, and I appreciate it for what it is. It is necessary to talk about these kinds of things.
The internet does not rely on what Apple does but that misses my point. People, here, think Apple should join the list of those whose goal is interoperability and that is not Apple's goal or concern. It's not a negative that they do that. It's just not what Apple builds products for.
I believe it is always important to get every project, even small ones, to the community and gather feedback for them. There are always smarter people than us who can give you a brilliant idea which might take the project to the next level. 
I'm trying to restrain myself, I really am. The function itself is meant to be a small utility, to be slipped in unobtrusively and frequently so I don't want to make calling it a pain. In fact, since I'm always looking for improvements, here it is for criticism: const _ = require('underscore'), { ObjectId } = require('mongoose').Types; function stringId(x) { const idProp = x &amp;&amp; x._id || x.id; switch (true) { case !x : return; case _(x).isString() : return x; case x instanceof ObjectId : return x.toString(); case !!idProp : return stringId(idProp); case _(x).isObject() : return; default : return x.toString(); } } Its intended function is to take an argument that might be an `ObjectId`, the string representation of one, or an object with an `_id` or `id` containing either of those, and return the string representation.
except for the part where one attempts to use `let` and it doesn't work in the situation.
Yeah, seems like he was making it too much about himself. Even if you think the interviewee is tying a noose for themselves, you shut up and you let them, imo. But no, he wanted to let everyone know that *he* knew the answer, even though he wasn't the one whose knowledge was being tested.
Curl
If you don't like declaring variables just make more functions const getId = ({ id, _id }) =&gt; (_id || id); const f = (x = {}) =&gt; doSomething(x, getId(x)); 
w3schools
It's not that unreadable but if you are on a team then you definitively should use originalFn, I don't think it's even debatable, you may be taking some precious time from someone else.
&gt; I think a major point that he may only have touched on is that this code is much more elegant to write. I have been using this style daily for months now and there is nothing sexier then a well crafted chain. &gt; I didn't down vote but if you think this is correct you should have listen more during complexity courses. k++ and j++ are constant time operations O(1) therefore first solution is O(n) and second is O(2n). And O(1) &lt; O(n), always. 
The point is they can do whatever they want on the hardware level, but a web browser is damn near a VM, and all of those VMs should ideally work the same. They can have different window dressing, but the underlying APIs and visualizations should be uniform. That's the point of standards. Safari is woefully behind the times. They are the new IE. Yes, Apple has their own land of their own toys, and they can do there what they want, but their browser, the VM that interacts with the internet, should be compliant with modern standards.
Well, of course. They're absent because they don't even support a lot of standards - web push, service workers, web notification, etc.
http://www.w3fools.com/
I was the one making the point so I don't need it explained to me but you aren't saying anything I already said. &gt;their browser, the VM that interacts with the internet, should be compliant with modern standards. Your statement is false. You claim Safari is non-compliant but that's not true. It may not cover some of the properties available but the ones it does cover are compliant.
it is defined, it's just defined as undefined
Nice app. Great little project for learning a frame work. Something that would be a little different from a todo app. Might have a crack at doing something like this myself. Then I can see how much money I am losing on Alts 
Remove everything after and including &lt;noscript&gt;, remove &lt;script&gt; and &lt;/script&gt;. Voila.
Hi and thank you very much for your detailled answer. The part I am struggling with is how to dynamically add this navbar to the top of the website. You suggested to use "transform: translate", but I am still not sure. Do I need to apply transform: translate to my whole webpage including my fixed header to move the whole site a few pixels down and then display the additional navbar? I am super curious how https://snapzu.com/ is doing it, because it feels like natural scrolling behaviour.
I looked at v8 bytecode and it doesn't look like it's optimized (filter is called)
I have a telescopic eyepiece calculation tool whereby you can enter details about your telescope, and it computes the magnification, true field of view, and exit pupil for a few hundred different eyepieces for you, which in turn allows you to sort/filter by those values. I don't bother creating new instances of each eyepiece because there's no need - the problem space does not call for preserving the uncalculated eyepiece in the list, nor does it call for a list of uncalculated eyepieces, so I just iterate over the existing array and mutate each eyepiece in place with the calculations for the given telescope. When I select a different telescope, or edit an existing telescope, it re-computes the eyepieces. Conversely, when I *filter* the list of eyepieces, I don't want to clobber the original array because I would end up destroying it, so I instead I create a new array of only the eyepieces that pass the filter, and render that, preserving the full array. 
&gt; It may not cover some of the properties available Exactly.
Yes, Microsoft has changed quit a lot in the past few years. I am always happy to see such things.
That's exactly the whole point of what Mozilla is doing. So they will be compliant and cover every single property the same across all browsers and Operating systems 
especially because the implementation is a c++ builtin -- unless there's a different api you prefer, i.e. lodash / ramda -- the builtin is always going to be faster since it has the ability to intelligently dispatch between fast and sparse array implementations, for examle
This is where C#'s Linq is really clever you can set up a chain of functional commands like this and it is only executed once when you call `.toList()` (or array etc. ) You don't even have to do that at the end of the chain so you can defer enumeration to a later point in the code. 
I think that is the only legitimate use for IE6 I have ever heard of...
[ugh](https://i.imgur.com/ESiYZCQ.gif)
While true, if you are experiencing performance issues with large data sets and you need to do something about it you probably can't just defer it until the next V8 release in the hope that it's able to optimise for your specific case. You need to work with the compiler to understand what optimisations it does perform under what conditions, to do so you can delve into the documentation or try perfing the code.
&gt; It's not a negative that they do that. That's the part where you're wrong. It *is* a negative that they do that. 
Linq is better again though because it will only enumerate once and allows you to defer that enumeration.
map and filter are built in array methods they're not provided by a library: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
mind = blown
It's _declared_ as undefined.
I don't know how you can make that make sense. Even a junior level dev should 100% know that it's undefined. I'd much sooner believe it was a misunderstanding of some kind.
If an organization values walking textbooks, then they're only interested in hiring walking textbooks. These are good to know information, but if an organization depends on these to judge a developer's technical deliverability, then it's an organization only a few would be interested to join. With no context of said employer, I assumed the interviewer is *not* something like Google's V8 team.
Perhaps the interviewer has a mistaken belief that declaration and definition are the same thing?
Indeed. I'm not saying that you shouldn't try to optimize, I was just suggesting that a program that builds and provides the required features without bugs get done first, and if performance issues are discovered in testing, then worry about optimizing.
Thanks for the thorough reply, I learned a few things from that. But back to my original question: functional is opposite to async/generators because writing code in an async func or in a generator is inherently imperative? Is that the essence? I admit that I have put off really learning functional programming so far, so I don't really know the basics.
Oh yeah, sorry, not quite ready for prime time yet was hoping to see if anyone else was doing similar stuff out there. Will post a link when I can get it out there publicly.
Gotcha! My misconception but hopefully the above comments will clear it up for anyone else with the same interpretation.
I think that's the basic idea. I disagree with it being non-functional, but it may encourage more imperative programming by allowing mutability. It just feels more imperative. 
I've changed from Stylish addon to Stylus (I'm on Firefox), because Stylish is too popular and has been detected by websites. FYI, Stylish has been entirely nullified on YouTube - at least the Firefox version of Stylish. I no longer use uBlock Origin. I use uMatrix because it's much easier to set up rules. FYI, uMatrix is created by the same developer as uBlock Origin. Also, I've configured it to block all scripts by default. i.e. scripts will only run if I've specifically configure uMatrix to allow it.
wtf is a design block? It's a template? a material design style card? 
It is a section of the website. You can mix them together to create the entire page layout.
Didn’t they already try this a few years ago? What makes it different this time?
What exactly are they behind on? They’ve been a bit slower to adopt some of the newer standards (WebRTC, service workers) but those are in the works now, and the main reason behind that from what I’ve heard is because they’ve been focussing on speed. As a perf oriented engineer, Safari is my best friend, so I see the results of their efforts all the time. I’ve had more style quirks from Firefox and Edge still compared to Safari. In my experience it behaves the best right beside Chrome.
I mean absolutely performance is considered a nonfunctional requirement that needs to be handled before release, and it can be worth delaying a release over if it's a real problem, but refactoring something that works is generally far easier because by that point the core problem is understood and encoded.
LOL
It's not a comparison of O(1) and O(n). It's a comparison of O(n) and O(2n). And I listened enough to recall that the difference is trivial unless n is huge.
But what about w3schools??
As many have said it before its not possible to do what you want, because of CORS check in to that. However if am not mistaken if the iframe is requesting resources on and from your domain and only yours it is possible if you add the html attributes necessary for it to work. But that's the farthest that you will get with iframe manipulation.
MSDN. 
You're missing the point he's making though. Apple *doesn't care*. As long as Apple-made things work on Apple's devices, they don't care. If there's a service out there that Apple wants their devices to work for? They just copy the service and make their own. It's a closed environment. *Closed environment*. 
&gt; I’ve had more style quirks from Firefox and Edge still compared to Safari. In my experience it behaves the best right beside Chrome. Ugh. No. You're not working much then. Safari *is* wildly behind. They don't even release for Windows anymore. Chrome isn't much better truth be told. Webkit is old hat. IE Edge is more reliable than either of those for me. And Firefox is still king in my book. 
There are other tools that do this like Cypress. With Puppeteer you have to set up some sort of selector in your code manually :)
Microsoft and Google both want their own incompatibility lock ins.
If you have to iterate over 1000's of items on a regular basis, you need to implement pagination in your API ;)
On w3schools, like me every time I accidentally click on the first Google result.
Managed to do 4 out of 5, but got blocked on the 3rd one. Do u mind sharing the answer?
 [NaN], NaN 0, -0 document.all Object.values({"I'm Special!"() {}})[0]) /x/y
Do you mean like this... var foo = 'bar'; var foo; console.log(foo); //=&gt; "bar"
It's a comparison of O(n + n) and O(n) + O(n). They aren't just asymptotically equivalent; they're the exact same function
I'll post the answers in a few hours, want to give everybody a shot first :) . Out of curiosity, did you get both answers for #1 and #4?
/u/lhorie got it.
Nice. The second answer for #4 is boring, but can you get the second for #1?
I didn't say that we are comparing O(1) and O(n). I did say "therefore first solution is O(n) and second is O(2n)" so yes this is the comparison. I never said that the difference isn't trivial when n is small. But natziel keeps on saying wrong things and your initial question was how can we disagree with him.
Apple not joining?
If you are fully committed to a functional programming approach there's nothing wrong with the `horriblyAbusedFn` syntax, as long as you keep it readable (eg. don't call your parameters `x`, or `o`) and you respect the other principles of functional programming, and not just do it for the sake of reducing the number of variable declarations.
Out of curiosity... why would you spend money marketing a free product? Looks great though! I love the concept!
&gt; OR you're developing on an Apple machine, which makes you a minority. Just a sidenote having done dev in advertising for 10 years, 95% of the agencies I have been in have the dev team use apple computers to make it faster to integrate with the designers. I fully agree with your points tho.
I ran some big tests, an array(9999) of ints between 1 and 10000. Chaining was most definitely slower but it also confirmed what I suspected, that `forEach` remains king in JavaScript, performance wise. This is probably due to some implementation optimization. Testing in Chrome 61.0.3163 / Mac OS X 10.13.0: I abstracted the code that didn't have to do with the looping itself and multiply by `0.8` instead of `2` so the `isEven` check isn't pointless. Processing: const eighty = n =&gt; (n * 0.8) | 0 const isEven = n =&gt; !(n % 2) const doSomething = item =&gt; null Then ran the following 4 tests, results above each snippet, from fastest to slowest **forEach method** - `4,611 ops/sec` - *fastest* arr.forEach(n =&gt; { n = eighty(n) if (isEven(n)) doSomething(n) }) **for loop** - `4,255 ops/sec` - *8% slower* for (let i = 0; i &lt; arr.length; i++) { let n = eighty(arr[i]) if (isEven(n)) doSomething(n) } **simplified method chain** - `2784 ops/sec` - *40% slower* arr.map(eighty).forEach(n =&gt; { if (isEven(n)) doSomething(n) }) **method chain** - `1980 ops/sec` - *57% slower* arr.map(eighty).filter(isEven).forEach(doSomething) [Link to jsPerf tests](https://jsperf.com/loop-vs-functional-chain/)
The images won't actually be fetched until Javascript sets the src attribute. In that sense it's lazy: the images won't be loaded automatically. If you've just got that JS at the end of your page, the benefit seems minimal as most browsers will already prioritize CSS and JS downloading more than image downloading. If you have more knowledge of when your images will be useful though (e.x. when they're scrolled into view) then you could run that JS even later, maybe on a per image basis, to get some actual benefit. It sounds, from the article, like they're giving this as a minimal example to help you better understand how the later solutions work.
I don't understand why you're saying Microsoft was absent considering that even Mozilla announced that edge developers made 5k edits last year. 
I'm not experienced with jsfiddle, but did you include jquery, because that's what you need to run that.
Awesome. What if you go up to the millions?
&gt; And O(1) &lt; O(n), always ... is the comparison I'm referring to. If it's not relevant, it shouldn't be in your comment. I still don't see why "I should have listened more" if you're not going to explain what's wrong about the above post. 
ye, idk a lot about jquery but i got this file and also linked it with my html. but its still same, no colors..
To expand on this, it is totally possible to interact with an iframe IF the iframe is within the same domain. I would still generally not recommend this unless you have a good reason. 
We're looking to add a new concept of open design and find others interested in joining us to make websites better. Everything we made to promote it was done in a matter of hours and the only money we spent were the $15 on Facebook just to test what is happening from that ad. 
See that '**li**:even' you have there? That means the selector references _even_ elements (2,4,6...) yes. But only even `&lt;li&gt;` elements. Meanwhile in your HTML, you don't have any `&lt;li&gt;` elements. What you have instead is a table with `&lt;tr&gt;` elements. Read about _selectors_ [here](http://api.jquery.com/category/selectors/) or [here](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors) or consult r/learnjavascript
Since we are in /r/javascript please do run the following naive tests : ```javascript var k = 0 var l = 0 var m = 0 console.time() for (var i = 0; i &lt; 10000000; i++) { k++ l++ m++ } console.timeEnd() ``` ```javascript So following your logic O(n+n+n) so O(3n) ? var k = 0 var l = 0 console.time() for (var i = 0; i &lt; 10000000; i++) { k++ } for (var j = 0; j &lt; 10000000; j++) { l++ } console.timeEnd() ``` This one is O(2n) we can agree on that. Please explain me how the supposedly O(3n) function is ALWAYS faster than the O(2n) function.
 [,], undefined
Its not so much about "performance" rather than reducing the initial page load size by giving you the power to load heavy image assets at a later time. For example on events like when a user scrolls or clicks an image thumbnail. Keep in mind that the browser wont download the image at all until its has a valid "src" attribute path. "data-src" is simply a temporary attribute to store that path until you want to switch it to the src attribute and load the image, it could really be named anything at all. 
hmm but baisically when i chnage "li" to "tr" then this sould be work right? ___________ $(document).ready(function(){ $('tr:even').css('background', 'aqua'); }); or no coz for me its still not working :/
You should add `for of` loop to your test. I have a feeling it'll perform as well or better than `.forEach`
I would point out that so far my biggest complaint about web components is not having a declarative data binding mechanism. Using data attributes yields strings. The only way I know so far is querying the document for the elements that need the data and attaching it straight to the dom element. Web components will see the data inside as being attached to the this context. This leads to loosing part of the ability to quickly predict what will happen when a certain template is rendered. You have to read both the template and the controller code that infuses the data into the lower level components. A possible countermeasure is to use smart components that connect straight to the data store (redux). That's fine for high level components, but for the lower levels you need dumb components just to keep loose coupling.
Is anything supposed to happen on the site when i click the blocks? I click "See it in Action", then a bunch of little widgets show up but clicking them does nothing and the image is super small
https://jsfiddle.net/s4fezsbL/2/
if you can't understand a simple loop, you have other issues. There is nothing wrong with using loops when its the optimal solution to a problem. Multiple iterations just so each function can remain pure is the wrong reason to use a construct. 
No, we've had to focus more on getting the product ready to use and the presentation still has few points to improve. However, I shared this story not because of the product but so that others can find out how to get their Github repos more popular. 
My hope is that this will allow us to escape the never ending javascript framework hype cycle. React is nice, it has proven that templates in controllers are useful, but JSX is a strange bird... Angular 2 is a far better angular than angularJS, but I still feel that it still is too opinionated, too much boilerplate. Lately I've been developing a style of coding for angular 2 that will quickly allow me to transition to Web components. Web components seem capable to provide the goodies from both worlds. Best is that together with template strings I can get static type checking in templates using typescript. This I believe it's a huge deal to consider. I still have to play with virtual DOM to see what role it can play in this whole setup. 
Whether or not it’s running on a Mac makes no difference. A standard is a standard, no matter where it’s run. That’s the point of standards.
Thank you for the suggestion. It looks like the project is actively maintained and quite healthy. I'll investigate to see if I will pick it up.
What about Vuact?
I have a friend who oversaw an interviewing process at Google while he was contracting there. His advice: study trees, they're definitely gonna ask you some data structures and algorithm problems and most likely it'll be that one. There was a famous story about the creator of Homebrew, they asked him to invert a binary tree and he couldn't do it (https://twitter.com/mxcl/status/608682016205344768). To be honest, I find these interviewing tactics to be far from perfect but they get their pick of the litter of recent computer science grads so they don't have much incentive to change.
I removed this part of my answer because I do agree that it's not relevant. And about the above post I have nothing more to say. I've provided test cases that show how he's wrong. His post is wrong on the theory but not on the performance consequences. Yes, performance will be the same for small n. But it's not true that doing two loops is the same as doing one loop if the loops only contain O(1) operations. 
Already answered over there: https://www.reddit.com/r/learnjavascript/comments/77fxmt/javascript_color_not_working/
Congrats on dodging a bullet. You don't want to work there.
I think it's more likely he's the type of person that sits around on LinkedIn with all the other managerial clowns who seem to spend their days sharing arcane/pointless questions they don't even really understand so they can embarrass candidates with them because it makes them feel good about being clowns.
&gt; avoiding unnecessary variable declarations if I can Note that this isn't necessarily an improvement. Variables let you put names on things which makes the code easier to follow. For what it's worth, all 3 snippets look horrible, but the last 2 are certainly worse.
Not Google, but Palantir, which hires from the same pool as Google/other big N companies. At Palantir at least, when I was interviewing for a mid-level position, it was very heavy on DS &amp; algos, the front end algorithms test is exactly the same as the backend one. There was also a UX test, they weren’t expecting a designer’s knowledge but just to be aware of key concepts and best practises. There was a specific test for front end, but it was basically a pop quiz. Didn’t write any real JS - just showed how I would solve problems. There was a lot of asking me why I wanted to leave a full stack role for a front end role, honestly it was because Palantir were going to pay me fucking loads and I had no special love for front end (just lots of JS experience). It really felt like that this stage they were baiting me into saying front end was easier. I get the impression they wanted all their devs to the same standard, if they do front or back end after that I don’t think they mind.
Yeah. Exactly. Redeclaring the variable doesn’t overwrite it. Not sure why that would be super important though. 
I added for of before I saw that the previous edit also did. For of is usually the king of loops in js. Edit : On Chrome 62 / / Mac OS X 10.13.0 Classic for loop 12,213 ±1.28% fastest
Uhh...it's not faster? https://i.imgur.com/TYCUX6e.png In fact if you do the arithmetic they're pretty much the same time per increment
Why not just const fn = (x)=&gt;doSomething(x,x.id?x.id:x._id); More or less something like that. If you really have to you can always nest ternaries for the x null check although since you pass the const id no matter the result it shouldn't matter that much unless you explicitly check for null vs undefined in doSomething.
And I reject that line of thinking. I tend to not trust what something is doing before I use it. I understand that it isn't in line with the rest of the JS world but this community was also shocked by a module with 6 lines worth of code in it was taken down so I'll keep doing me.
Yes it is ... https://jsbench.me/0pj8ys59h0/1 https://i.imgur.com/XroxVDu.png And yes it's twice as fast as expected. I will not respond any further, because life is too short to waste so much time trying to prove that running one loop is faster than running two loops on the internet.
But you don't know what a for loop is doing any more than you know what Array.foreach is doing. So why do you trust one and not the other? At some point it becomes asinine to understand exactly how code works, it's not like you are going to look at the source for the JS engine in every browser you support to try and understand how your code is interpreted and executes? do you also need to understand how that execution is then run on a CPU? We all deal with abstractions all day. The declarative functions like map and filter are just another level of it that remove the need for some mutation and extra control flow logic. 99% of the time the extra control is unnecessary anyways and can be avoided. 
&gt; Safari is wildly behind. They don't even release for Windows anymore. Microsoft doesn’t release Edge for macOS. How is it relevant?
&gt; Closed environment. WebKit is totally open source. Stop repeating things in italics as if it makes them true. 
I guess this is why I like Vue so much. closest thing you can get to this stuff, without funky jsx
Is it just me who finds the first loop faaaaaar more readable than function helloworld(arr) { const evenNumbers = n =&gt; n % 2 === 0 arr .slice(1) .map(v =&gt; v * 2) .filter(evenNumbers) .forEach(v =&gt; doSomething(v)) } ?
Their site uses "margin-top: header-height in px" on the body and just adds 40px when scrolled up to look like it was pushed by the top bar while actually it's just more margin. Now the header is more interesting. it contains both parts visible (the links and the black part) at the same time, but by default it is "position: fixed; top: -40px". So the link part is not visible (40px of the top bar is above the screen). On scroll up it makes "top: 0" so the links show up. The "transition" on both body "margin-top" and header "top" are the same thus creating the illusion that one is pushing the other. If you want to know exact CSS that they use, and if you are using Chrome, right-click on their top bar and choose inspect.
And they probably wonder why people call Safari the new IE.
Can anyone explain what’s the point of it? Is writing html and css is beyond ability of those 2750 people who stared it? That is pathetic.
That's not my point.
Google and Opera and others were members of the group for years. Microsoft was not. They only contributed the edits starting a year or so ago.
/r/learnjavascript 
How is making a product reliable, efficient and with a guarantee of working with the product line a negative?
Mozilla is doing documentation, not standards compliance. You follow the W3C or WHATWG to become standards compliant. Mozilla is not a standards body.
Then ever browser is non-compliant with standards cause no browser covers all the properties.
I agree with you, MDN is just the documentation, but we're happy about the collaboration and we encourage it, as we hope it pushed the parties to follow the standards with no delays. Now a new api comes out and each vendor sees it and implement it differently. If they collaborate on documentation, I imagine they'd collaborate on the understanding of the api the same way and HOPEFULLY they do right that way. 
Did you go there before you posted the link?
Why not just reverse the approach and count the time difference when needed? const player = { playTrack(file) { this.track = { file, duration: 0, startTime: Date.now() }; }, getCurrentTrack() { const {file, duration, startTime} = this.track; return { file, duration, currentTime: Date.now() - startTime }; } };
&gt; can't understand a simple loop I didn't claim I/other engineers couldn't understand loops. I am positing that functional approaches to problems are generally *more* readable. &gt; nothing wrong with using loops when its the optimal solution Sure, if by optimal you mean taking into account both performance *and* readability. &gt; Multiple iterations just so each function can remain pure is the wrong reason to use a construct. I never made any claim suggesting purity was a goal in of itself. I'm a pragmatist when it comes to functional programming – you sacrifice some performance (usually) for an increase in readability (usually). If that ends up not being the case in a certain function/module, or your team believes they should prioritize performance over all other considerations, by all means use a different construct. 
How often do have to iterate over arrays that large in your code?
How often do you have to iterate over arrays that large in your code?
&gt; can't read a for loop No one claimed people can't read for loops, only that functional approaches are generally *more* readable.
&gt;mind =**=** blown 
O(n) is equal to O(2n) by definition.
That's like this whole thread though.
The parts of a ternary should just be values, not assignment expressions. The right syntax would be: plusScore = (scoreArray[i] === -1) ? 0 : scoreArray[i]
I don't see anything in your linked file that could cause that error, but, the error may be in BirdAlert.json instead? You can usually click the line number in Chrome and it'll take you right to the line of code that has a problem, so, that may also help.
Again, you do you, I'll keep knowing what my code is doing.
You must know alot about javascript. I actually miss jQuery in this top 10 mention
That's very true, because for example people don't seem to realize that `O(C*N) = O(N) for constant C != 0`.
One of the great things about this methodology in C# is that it doesn't sacrifice the granular control of execution that comes with imperative code; yield return lets you treat imperative code as if it implements IEnumerable and build a pipeline of functions that individual elements can pass all the way through without waiting for the completion of any one part of the pipeline. public static IEnumerable&lt;BigInteger&gt; FibonacciNumbers() { BigInteger previous = 1; yield return previous; BigInteger current = 2; yield return current; BigInteger temp; while (true) { temp = previous; previous = current; current += temp; yield return current; } } [TestMethod] public void SumOfFibonacci_WithValuesLE89() { var expected = new int[] { 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 }.Sum(); var actual = FibonacciNumbers() .TakeWhile(fib =&gt; fib &lt;= 89) .Sum(); Assert.AreEqual(expected, actual); }
But your level of understanding is the same in both implementations... How can you know what one is doing but not the other?
The last part is true, but `IEnumerable`s can be enumerated however many times you want (or don't want). Another gain with LINQ is that the deferred execution operation is less complex than what's happening in JavaScript. This means this example in JavaScript arr .slice(1) .map(v =&gt; v * 2) .filter(evenNumbers) .forEach(v =&gt; doSomething(v)) operates as `for ... for if ... for ...` while the equivalent C# LINQ query (from number in arr where evenNumber(number) select doSomething(number * 2)) .ToList() operates as `for if ...` This is accomplished through delegate invocation, rather than chained loops. There's a good explanation [here](https://softwareengineering.stackexchange.com/a/215880).
I think you raise an interesting point. The purpose of the article is to demonstrate "the readability of functional programming," but the author didn't even catch his logical error. It's similar, in my mind, to those Apple devs missing a `goto` position (minus the diff that was being reviewed).
This is what I have in the .json file if that helps: https://pastebin.com/6zCDYk0L
caniuse.com
I just need them to stop making browsers and we can be friends again.
That I don't know. It is likely as code is not generated in `--print-opt-code` if it is not hit.
 const copyProperties = ({ from: (source) =&gt; ({ to: (destination) =&gt; Object.assign(source, destination) }) }) Would an IDE pick up on this?
When the products job is to consume data and display it in a predictable way and it fails at doing that, it's a negative.
Sorry didn't mean to imply linq could only be enumerated once you can do it multiple times though resharper certainly prefers if you don't not sure if roslyn also shows a warning for multiple enumerations now. Thanks for the link I knew that linq did this but not the ins and outs. Will give it a read. Yeah i saw an article the other day where that author used generators in JS to emulate deferred execution. Though delegate invocation wasn't implemented as it was more of a demo on generators than a serious attempt to replicate linq. 
Large spreadsheets-like CRUD data.
Edge had a rough start. 16 seems to be good. Even with css variables.. Many other thibgs. Microsoft is making up with a lot of things not only vs code (I know you're not implying it's the only thing) rxjs is another big thing. Typescript is crazy essential in many projects.. Etc
Yea i use typescript myself and it's great. But it's gonna take a whole lot of positives to make up for decades of suffering. Edge is still not great, it's way better than IE was, but it still has a lot of quirks that are a pain to fix.
I feel your pain. Working with a client that I convinced that we only have to support the last two versions of each browsers... IE still counts unfortunately.
Yup, that's ALL our clients :(
And now works on windows!
That's not the issue here. The issue is people say Apple should join this board for Mozilla's documentation. How their products perform has nothing to do with that or my point, which is again, that Apple is less concerned about inter-operability with other people's products. Their joining this board does not improve web standards in any way because MDN is not a standards committee nor does it create or write standards.
You were right. The most likely answer is that he wanted to know why undefined. They didn't say no, but did to undefined. They just asked this in a really shitty shitty way.
Who does that? I thought Android 4.x would be the new IE. 
I don't think it's a super unpopular opinion. People who are only taught frameworks end up like the bootcampers with only the ability to regurgitate CRUD apps without the critical thinking that comes with it. That being said, for someone like my dad who is tech-savvy, knows nothing about web development, and wanted to create a simple web app, a framework helped him get to a finished product much quicker. Also, Jquery isn't a framework.
Google has a blocker extensions that allows you to filter out domains :)
&gt; What makes it different this time? That mdn already is the standard for webdev documentation. 
It's a library, but that's besides the point. Far too many "Bootcampers" think *N framework/library/platform* is the language it is based on. You got me thinking actually, there must be a way bootcampers are separated from knowledgeable programmers during an interview, because both would present a portfolio of projects and a list of things they know.
thanks for this, it helped explain things better for me
I went this route, except I learned jQuery before vanilla js. I have to say, it is a much slower and maybe more frustrating path at first, which I think you implied with the statement about burning out. However, I agree that it's a much better path for actually understanding what is going on under the hood and leaning how to debug beyond just googling an error message. As you graduate through the different stages, you see the benefits pretty clearly. If you skip to the newest stuff, that will be your baseline and you will be pretty lost if the baseline shifts. 
I bet you could improve the speed of the for loop if you did: var numLen = arr.length; for(let i=0; i&lt;numLen; i++)
I've never heard anyone argue that frameworks are good for newbs, so I'm not sure I could call this an unpopular opinion . Being a misguided newb myself I more and more feel like the real/honest answer to the React vs Angular ( and sometimes vs Vue ) question is ... If you're even asking this question you don't know enough about javascript to be wasting time trying to learn a framework . In the case of jQuery you very often find it in beginner courses/tutorials so how would a beginner even know that it might be better to stick with vanilla.js ? What about when you want to make an api call and have no idea that something like Axios even exists at that point ? or when you find an answer on stack overflow and all of them are using jQuery ? There's also the fact that there isn't a clear path for learning all of this or how much you should really know before learning something like React,new developers just have no way to know what they don't know, theres also a huge echo chamber of misunderstanding that leads to things like the close association of mongo and node . The selfish/pragmatic part of me is also kinda ok with the people that think jQuery is javascript, bootstrap is css and bonkers is gum, because knowing better puts me in a better position to be hired . 
As someone who's been on the other side, I could tell because all the projects they show off are pretty much the same between candidates. They are themed to their interests and maybe tweaked in a small way, but it's never more than a simple CRUD application with a library or two used. The projects from more 'native' developers usually demonstrate some creativity or solve some known problem, since they're not thinking about the specific code they learnt, they're thinking about problems and solutions. Just my 2 cents
I teach at a bootcamp. We teach vanilla first, then frameworks. Before a student sees Android, they've already built a Java command line app. Before they see React, they've already built a full stack JS app (vanilla front-end &amp; Express back, connecting to Mongo). Your opinion is unpopular; I've seen bootcamps that would give students a week of vanilla Ruby followed by 11 weeks of Rails, and the student really learns nothing. But you're opinion shouldn't be unpopular, you're absolutely right.
I don't understand the order of this list at all... 
Due to the negative connotation with bootcamp grads, I don't think you can use a bootcamp as a baseline for what is good or popular. I think you're confusing the popularity of bootcamps as easy entries to the business, and the popularity of the idea that the best way to learn is with frameworks first.
If you're editing in Atom or Sublime, select all your code and hit `cmd`/`ctrl` + `]` to indent it. Indent it four spaces then copy/paste it here to format it as code: const getIntsUntil = n =&gt; Array.from(Array(n).keys()).map(n =&gt; ++n) const isDivisibleBy = divider =&gt; replacer =&gt; value =&gt; value % divider === 0 ? replacer : value const toCrackle = isDivisibleBy(3)("Crackle"); const toPop = isDivisibleBy(5)("Pop"); const toCracklePop = isDivisibleBy(15)("CracklePop") getIntsUntil(100).map(n =&gt; toCrackle(toPop(toCracklePop(n))))
Yeah, and it's very obvious why if people would look at the definition of the O-function and actually understand it. Yes, it requires some math knowledge but c'mon.
You read my first sentence, yeah?
Both are the same speed asymptotically. In practice, it is a premature optimization to avoid using clearer constructs, and functional statements *are* fundamentally clearer if for no other reason than the fact that they use a closer abstraction.
I agree with this. Freecodecamp basically does this. The whole front end section is vanilla js/jQuery and a little bootstrap. I finished all the front end challenges on fcc before I showed up to my boot camp, and I was the only one in my cohort to make it to graduation. I also built a small single page app without a single framework. While everyone else was fumbling around with js I was mastering node and angular. Those battle scars are important as hell. 
So you're saying you should be using a database?
Yeah
the author of that article doesn't even explain why... the list might as well be: 1. Bread 2. Bacon 3. Lettuce 4. Tomatoes
More puzzles: string =&gt; 'a'.replace(/(a)/, string) === 'a' &amp;&amp; string !== 'a' // super easy x =&gt; (x - x === 0) &amp;&amp; (x + 1 === x) // easy x =&gt; [...x].length &lt; x.length // medium x =&gt; false &lt;!-- x // just for fun :) 
made it into a codeblock now its fine i guess :)
Cool, thanks.
Is there a reason you're using `const` and not `function` for named functions?
I'm going to save this response for later. I'll be hitting my 2-year expected experience mark for Junior/Assistant roles too and this was the missing piece to my applicant puzzle. :)
well it's not a necessity, but they are immutable this way. Still gonna work if you do it with functions ofc :)
That's what it's called! Was called, I guess, I see they officially gave up and discontinued it. I always had trouble remembering the name and it didn't get enough traction to rank highly in search results when I tried to find it. It looks like the difference is that instead of trying to fork MDN and put the cross-platform on some other place nobody ever looks, they're talking about what they're going to do at MDN itself.
I like it. I really like the currying, but the `isDivisibleBy` function declaration took me a bit to wrap my head around, all being on one line.
When you were partying, I finished all the front end challenges on FreeCode Camp. When you were having premarital sex, I mastered Angular. While you wasted your days at the gym in pursuit of vanity, I was writing server side scripts in Node. And now that it's graduation and you're still fumbling around with javascript you have the audacity to ask me for help?
I went to my first FreeCodeCamp meetup last week, I can't really comment on the overall level of experience. Varying, probably. Since there's another FCC alumni (of sorts) here, do their "certificates" mean anything? Is it CV-worthy?
None of the solutions here are the *best answer* IMHO. ES6 is available because `const` is used in the question, and *fixing* this loop with ES6 syntax creates the clearest, most readable code... const arr = [10, 12, 15, 21]; for (const i of arr) { ... This immediately makes clear, (and enforces), that `i` is *immutable* within the loop. Using `let` does neither so requires extra attention to grok what is happening.
I was wondering how could i separate the replacer from that function, but couldnt figure it out 
your list makes more sense than the article Alphabetical for first letter and then reverse alphabetical for second letter? Moisture content from low to high?
Yeah my first reaction was, "That's not unpopular at all"
lol what? you really can't think of a way to separate the candidates? it's glaringly obvious...
Not from my POV. I may be solving problems with my developments but from where I sit in the long-run they're just developments. The only thing that comes to mind is that bootcampers would be presenting plenty of boilerplate common across their developments, whereas mine may have room for uniquity.
Was this just copied for u/peterxjang?
Or you can give them small snippets to write within the framework. Like implement a function that does x, and explain what that function is doing in context of the framework. That way they can learn both
Vendor-lockin is a negative. 
Probably, but this comes with it own set of problems. With 3-4 levels of nesting it will be unreadable. Handling all edge cases would be hard too (how about `this`, constructing, using it as normal, not fluent function?). Though, it seems possible to apply such decorator at transpilation step. Or just generate type definitions in build phase.
The learning curve has to be a curve. Yes, learn the vanilla basics first, but mastering every facet of them is not a prerequisite and can be counterproductive for a career. I speak as somebody who handrolled my own stuff for waaaaaay too long, and that cost me some jobs in the real world.
I will say that I find the Google Developers web section to have excellent code labs. 
Readability has absolutely *nothing* to do with an optimal solution mathematically speaking. An elegant solution has absolutely no reason or requirement to be readable. All that matters is correctness. That's it. I have nothing against readability.. nor do I have anything against functional programming. I practice both functional and object oriented development and mix both.. being a good developer requires knowing when one should or needs to use one paradigm over the other. Readability also comes in many forms, like commenting your logic and naming your constructs and variables appropriately. Unfortunately too many developers on either side are completely married to their dogma and fail to see the benefits provided by either option. 
I would say its only premature if you lack experience and don't know your data set. I would much rather a single loop running over a million records than running three loops over a million records. 
MDN were going to move their docs to webplatform but they never did.
or for (let i = 0, numLen = arr.length; i &lt; numLen; i++)
w3schools isn't that bad, it's just that MDN does a much more professional job of explaining around concepts.
The "experience" argument (or rather, fallacy), is often used. It reminds me of curmudgeoned C++ programmers who decry any additional abstraction as being unnecessary, confusing, etc because the old ways are obvious to any [real](https://www.urbandictionary.com/define.php?term=Gatekeeping) expert. If you require specific optimizations because of the limitations of your tools, then go ahead. If you don't, it's better to use appropriate abstractions.
*Here's the Urban Dictionary definition of* [***Gatekeeping***](http://www.urbandictionary.com/define.php?term=gatekeeping) : --- &gt;When someone takes it upon themselves to decide who does or does not have access or rights to a community or identity. --- _"I love punk bands like Green Day!"_ _"Ugh, they're not even punk. They totally sold out."_ _"Oh man, I love Harry Potter. I am such a geek!"_ _"Hardly. Talk to me when you're into theoretical physics."_ _"Erika Moen is my favorite queer cartoonist."_ _"She's not queer, she married a man!"_ _"Quit your gatekeeping. No one died and made you Queen of the Gays!"_ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:https://www.reddit.com/r/javascript/comments/779elf/writing_flat_code/dom3muh) ^| ^(**Summon**: urbanbot, what is something?)
I suppose that did come off rather smug, lol. 
&gt; An elegant solution has absolutely no reason or requirement to be readable No, but if you want the engineer who comes after you to be able to understand your code, you should consider sacrificing some of that elegance for readability. Elegance, Readability, and Performance are all things we should strive for when writing code, but generally speaking are going to be in some kind of tension with each other. You/your team has to decide which of those virtues you want to optimize for. &gt; All that matters is correctness I strongly disagree with this – just because your code works/is the most performant way to implement something does not mean it is the *best* way to implement it. This is all situational, of course, but my belief is that as long as it's performant *enough*, readability is what you should be optimizing for. I generally find it miserable to work on codebases/with teams that value speed over readability/maintainability – we're not playing code golf, and we're not getting paid (most of the time) to write mathematically optimal solutions, *especially* in the world of JS. &gt; Unfortunately too many developers on either side are completely married to their dogma and fail to see the benefits provided by the other option. I definitely agree with you there, and think that there is a time and a place for each approach. That's one of the great things about JS – how flexible it is.
what? that doesn't make any sense lol
unintentional sorting lol I guess I automatically sort base on those criteria ;) 
Not using a framework is one thing, but vanilla is another. Vanilla imo is too much too time spent on minutia, where concepts are more crucial ,But I guess it depends on what you want to learn. 
It took a website calling the site users/authors foolish before they budged. I'm sure if the site disappeared then it would return to being very inaccurate.
MSDN was fairly thorough at providing a special insight into IE's features. I hope that doesn't get lost in the transition.
Yes, they're better now, but they used to have outright incorrect information on their site (see w3fools.com). IMO, there's no recovering from this for me, and I'll always go straight to MDN if I have any base HTML/CSS/JS questions.
Noobs fall into the trap of trying to compete with people to get shit done, while it would be more productive for them in the long term to learn the fundamentals
Horrible
The goal of an interview is to pick out the best candidate for the job, the main focus shouldn't be to separate the boot camp grads from the cs undergrads. Making insinuations that boot campers are unknowledgeable programmers is the start of a divisive view in a field where we benefit greatly from the work of others.
What’s an example of Safari being wildly behind? Also in my entire career as a web dev I’ve only met less than a handful devs who worked on windows. Mac has always been far superior for web dev one reason being its a Unix system. 
You're right - they're also bad for the more advanced coders. Why? Because you'll end up relying on code written by someone else. Because by using said framework you miss on the chance of learning how to code that functionality yourself. As a general rule of thumb I avoid until the bitter end to use a framework, no matter how small. The same goes for "easy" to use language features. Take classes in JS for example. Altough I come from a OOP background having used extensively C# to this day I haven't used them in JS or I haven't used Typescript because it's more OOP. I'd rather master the language as is before allowing myself the comodities it has to offer so I can appreciate and understand them better.
You must have a high code golf handicap
Safari has proper tail calls enabled, what other browser has full ES2015 support?
It appears the piece I was missing was the requirement to keep the yarn.lock file. With this file, yarn will find the exact versions it needs in the offline cache. Otherwise, what appears to happen is that without the yarn.lock file, yarn tries to look for the latest version over the internet and when it can’t, because it is offline, it fails. Again, this works even after a ‘yarn cache clean’ has been executed. 
Vendor lock in for a product known as the best you can buy is a negative? Apple does not refuse to participate in open standards. In fact, as I've said here over and over, Apple has long been one of the listed writers of HTML and other standards with the W3C for years (Robert Bergeron, Theresa O'Connor). So what you said isn't true. Microsoft has never guaranteed hardware and software will work together or that any of their software will work with any hardware you bought.
Typescript and open sourcing vscode were the first clues for me.
I think it would help if we stopped using the word "vanilla". It makes it sound like frameworks are other "flavors" which replace the thing that's vanilla. Frameworks and libraries are just JavaScript code. It's all JavaScript.
I don't think Ape treats their developers well. They make great machines but their stance towards developer is pretty "meh".
sounds fun
It's step to your "editor" platform promotion. Could you tell us something about editor? Idea, budget, current progress
Holy shiiiit
I’m working on a greenfield project at work and just started writing some e2e tests in nightwatch After watching the intro video I need to switch to this right away, much more modern then the other tools out there 
Glad you posted an update. Yeah the docs do specify to keep your yarn.lock and to track them with VCS (git etc). I imagine they consider this is implicit throughout the rest of the docs.
[This website.](https://www.safari-is-the-new-ie.com/)
Fucking thank you. And the thing is, after learning ES6, you don't need or want jQuery anyway.
No. It depends on how good you want your product to be. Using frameworks is someone else's thing and you are restricted by it. 
Just for fun, its a bit longer, but here it is separate using `compose` to combine: const compose = f =&gt; g =&gt; x =&gt; f(g(x)); const getIntsUntil = n =&gt; Array.from(Array(n).keys()).map(n =&gt; ++n) const isDivisibleBy = divider =&gt; value =&gt; value % divider === 0; const replaceBy = predicate =&gt; replacer =&gt; value =&gt; predicate(value) ? replacer : value; const replacer = compose(replaceBy)(isDivisibleBy); const toCrackle = replacer(3)("Crackle"); const toPop = replacer(5)("Pop"); const toCracklePop = replacer(15)("CracklePop"); getIntsUntil(100).map(n =&gt; toCrackle(toPop(toCracklePop(n))))
AFAIK, react/router doesn't support lazy loading
Certificates mean nothing to everyone but the redditors who wasted their money on one.
Don't worry, you're not fooling anyone in an interview.
[removed]
True true, but i would argue that if your chain is that long, you are doing something wrong and should probably rethink your strategies a bit. Good points though, all valid.
&gt;Certificates mean nothing to everyone but the redditors who wasted their money on one. Good thing no one pays for ***free***codecamp certificates.
Way too many junior web devs think of react as a magical black box which produces output that is fundamentally different than javascript.
For a further challenge, run it through a type checker such as Flow and resolve errors. You're doing arithmetic on `value`, so naturally `value` ought to be a number, but you pass in strings as well. You end up computing `"CracklePop" % divider`, for example.
When I want to make someone mad... a = 1; а = 2; console.log(a); &gt; 1 
If you want to take the time to build your own race car be my guest. Buy the time your finished I'll have already won three races and have had time to actually have a life. 
I think frameworks are generally a bad idea unless you know exactly why you need them...
&gt; Bad things you shouldn't do &gt; ... &gt; Be honest and accept negative feedback Why being honest and accepting negative feedback is bad?
You hit on a key point: the main issue with frameworks is that it can be hard to know where the language ends, and the framework begins. Take Vue, for example. Vue's view models abuse the living fuck out of `this`. `this` refers to everything: data properties, computed properties, methods, props, and internal plugins. But that's not how the view model is organized. `this` "bypasses" the structure of the view model. You don't call `this.data.foo` or `this.methods.bar()`, or `this.computed.baz` like you think would in a vanilla JS context. To achieve that, Vue has to do some automagic fuckery that might make it hard for a newbie to really know what the framework is doing vs what is just native behavior. I see a lot of this in the PHP world as well, especially in Laravel (whose simplicity attracts a lot of PHP newbies), and doubly-especially in WordPress. Once they need to do something that the framework or CMS can't do out of the box, they don't know what to do. A framework should NOT be a set of training wheels.
MSDN now redirects me to MDN. Go figure.
The files are there: https://imgur.com/kKyt8q8 and i have removed the "/files/build/" part but it still shows that it is trying to get that file: https://imgur.com/7lO2Wkg
So it looks like its working now? I was moving a plane up and down and some birds were flying by. I'm not getting that error anymore about the SyntaxError.
That the game yeah, but i am still getting the SyntaxError error on this end
"Readable."
When a blackbox framework you don't comprehend isn't solving your problem, it is frustrating. It's completely natural for a new developer to try and ditch the framework and go vanilla. Then they undoubtedly run into all the problem the framework was built to solve. This struggle is how you become 'not a newbie'. Falling into anti-patterns and learning from your mistakes in a practical way. Once you understand the domain, the framework suddenly becomes an amazing tool to latch on to. You couldn't dream of living without it. I've done this same process for every layer of the web stack. ORM. Rest calls. Websockets. UI compartmentalization. By failing at "the obvious technique", you learn plenty about why system architectures are built the way they are. A classroom can tell you a bit about this, but failing hard on your own implementations teaches you far more in depth lessons.
Not restricted. Empowered.
&gt; Due to the negative connotation with bootcamp grads Where are you getting that impression? 
I can't disagree with this more. Programming *is* minutia. The entire point is you have to give small discrete instructions to a machine that will interpret those in as literal a fashion as possible. Obviously js is pretty far from bare metal but to pretend like it's not important to not just know the big picture, but also specifically all the little steps it takes to create that picture, is the antithesis of programming. If we could program with natural languages instead of ones specifically built for computers then I might not have an issue with this idea but the reality is you can't just understand the concepts and hand wave away the little details. They are too important to how we currently program a computer.
Can you give some examples of the latter?
I'm mad.
Great article, tl;dr: remove repaint and reflows with canvas.
And it's the same in any programming language. Of course the first step in learning is understanding language fundamentals, but that doesn't mean you should avoid using libraries. When you know what a module is and what a function is, it's perfectly reasonable to use some made by other people, so you can better focus on doing what you intended. I'd argue especially for a beginner, it's important to get shit done, because that's motivating. Someone telling you "newbies shouldn't use libraries!" is full of shit. The only think special about JavaScript is that a bunch of web designers who didn't really want anything to do with programming were forced to copy-paste bits and pieces of jQuery stuff around to add effects and interactivity to HTML documents. Which reflected in how people saw the language itself. But these days the language can be used for pretty much anything and has a rich ecosystem around it, with massive public repository of modules anyone can use. Newbies *especially* should take advantage of that, because writing your own algorithm to generate unique identifiers isn't fun, making working software is.
I dont really understand what you meant :D but I guess it's not nice 
1. $1 2. +/- Number.MAX_VALUE 3. '\uD83D\uDCA9c' 4. [Always false](http://www.javascripter.net/faq/comments.htm).
My company use to teach new comers that technical choices should not be done first. You often need to start writing your software to understand the in depth constraint it has and then choose a framework that help you to solve your problem. So basically, we try to postpone framework choice the more we can
vim is faster for coding, more features and fun.
I agree completely. You need to learn the basics properly before these frameworks really make sense - regardless of language. I've seen similar in PHP with Wordpress-Exports wo write plugins and stuff but just do not understand simple Arrays. Learn the basics, then do the fancy stuff
Completely agree, i began by building sites with Jquery and then after I learn Angular1, then angular2 and now Vuejs
The real price wasn't 0$ as mentioned, since you had all the work prepared (mailing lists, ...) But good work anyway, thanks for sharing!
I completely agree and I'm just ending my 2nd year in my bachelors. Next year there is a push from my main lecturer/tutor to do assessment with react and other similar frameworks. However, I believe being taught a very strong base in JavaScript/PHP is better than just using frameworks it takes alot of the critical thinking out of the learning experience. 
So, I was all ready to say that video isn’t a good medium for a tutorial because the viewer needs to go at the pace of the author and it’s hard to look forward and back the way you can with a page. However, I found the pace really good, the length about right, and I liked your conversational manner and even liked the typos etc. I look forward to the next instalment. Well done.
All editor should provide VIM-keymap! 
It seems to be a typical example of somebody trying to be "clever" and "saving lines", resulting in code that isn't easily readable at a glance anymore. don't do this, guys. being able to understand code at first glance is a lot more important than making it short and concise.
I actually disagree here. Frameworks are necessary and powerful to get beginners up and running. I get where you're coming from, but when you're just getting started you just want to build something and see it run. The exciting part. The faster you can get a beginner to that point the more likely they are to stick around. As they stick around they'll learn more fundamental things along the way. 
No, not most frameworks; but sometimes types, yes. Like when using a UI library, if a control doesn't do exactly what you want, it could have been less of a hack job if you had just written it yourself instead of modify one from the library. 
Just an observation, I’ve recently started work in a finance company and was surprised at how little of the “core” pieces were open source. File parsers, api wrappers etc Might be an interesting way to learn about some of these things and also create some real value
I related most to this. I like using lots of little frameworks that I can stick together (I once did this with Express, SocketIO, Electron and Bootstrap) - not just one for all - it becomes cluttered. With a group, you can switch each out as you like because none of them know each other exists: seperation of concerns.
I started typing out a long reply, but I think it boils down to two things: The first is salty CS grads who feel like they paid way to much to do CRUD for the rest of their life. They have $50k+ of student loan debt. They didn't pay much attention to CS theory, and they don't understand the difference in value that a CS degree offer compared to a credible bootcamp. The second is the set of CS grads who are vocally critiquing the bad bootcamps that over-promise and under-deliver. Bootcamps are still in the Wild West phase. They see adverts claiming, "Become a full-stack dev in 6 weeks! No previous experience necessary!" Depending on your social circle, that could be all that you see.
heavily depends on what said newbie is supposed to do. if he's a new hire in a big company its better not to reinvent the wheel every time but instead get good at making use of the framework. building everything from scratch is a really bad idea unless you've senior dev or just do experiments. using a framework doesn't mean not studying vanilla code to understand how the framework works.
&gt; Frameworks are necessary and powerful to get beginners up and running... ...when you're just getting started you just want to build something and see it run. It's a nice demo to show them potential but it'll never inspire them to learn why what they did worked. Relying on someone's framework means that you don't know how to work around it should it not do something you want.
&gt; better not to reinvent the wheel every time but instead get good at making use of the framework. It's not about reinventing the wheel. As a developer, that will never give you room to move outside of that company because you have no capacity for learning something completely different. Foundation is important before you build a house.
i'm leading a team of 6 developers where our newest hire has exactly that issue. he tries to reinvent everything instead of going with our conventions and frameworks. in our case vuejs as mvv framework. not a single project is delivered on time or with a fraction of the quality/stability he'd get when using the framework. i'm not saying he cant ever study new things. but frameworks usually follow really good conventions, so it's a good idea for newbies to use it and study what it does. my proposal always is: use what you can to get your stuff done quicker, and use the saved time for really studying oop or other concepts.
Sometimes we can handwaved away detail though. Take memory management for example, when writing js you typically don't have to think about it at all, only rarely when optimizing certain things. If you're writing C you have to think about it almost all of the time. There are some things that you can't write in js but you have to write in c (or equivalent) due to performance, but there is a large class of problems where this doesn't matter at all and you can just ignore memory management completely.
I have to disagree. Learning programming with frameworks helps you get things done quicker, there are a lot of guides and tutorials out there, people in the same ecosystem can help you. This was motivating me a lot when I was learning, seeing that I make progress and build actual applications. I think this is also the reason why web developing is this popular, getting started with something like Wordpress is really easy, even if you don't know PHP or JavaScript. Enhancing your website with little animations and other fancy things is trivial using jQuery or other libraries/frameworks. While learning plain JavaScript / HTML / CSS etc. is very important, I don't think the progression has to be from the ground up. I think the most important thing is to get motivated, stay motivated, build lots of things and learn the full stack. If you start with plain JavaScript, jQuery, Angular, React or whatever is completely irrelevant.
&gt; and fun. No thank you.
2 years ago when I started working with react/redux a senior backend software developer always went on about how state machines are bad, to be honest I never really read the theory on state machines &amp; why they might be bad. learned a lot from this and subsequent reading
i agree though, that using a framework, just because its "what everyone else is using" and not studying what problem it tries to solve, is harmful for any developer. be it senior or junior.
Relatable. One of my developers at work had layed out a boilerplate for a system 7 years ago, and I had a nightmare figuring out how the hell it worked. So I reveloped the entire system - I had the boilerplate to reference directly, (so I basically cleaned it all up) but this gave me the opportunity to make it better, and have a working fallback. I admit, I had many close shaves - it was nearly investigated by management for breaking several times, deadlines were missed a few times, but I'm a far more reliable developer to them now. I went from nothing to everything the hard way, and I'm a better member of the team for it. This is the point I'm making. No, not everyone will be given such dangerously important projects, but they are always better starting from nothing and working up. Not just starting from the top and finding it difficult to backtrack.
Your example. They should use a massive SPA framework before they know a for loop? I'm not saying "understand all the front end APIs."
I can't see a way around what /u/RedditWithBoners said about #4, is there one?
Do you work for them now?
That's the argument I've heard for starting people off with assembly programming. And also for starting people off with understanding binary logic and soldering together some circuits, or for starting in C, or basically for starting at whatever arbitrary point the speaker thinks of as "the important details underneath my normal programming". 
My friend wrote an app to calculate whether it was cheaper to take the local toll road or use extra petrol on the long way around based on current google maps estimation of how long the alternative drive would take. 
Long time lurker here, created a throwaway to answer your question, and provide some additional insights. UX Frontend engineer with Google for ~2 years now. Interview: - Expect small dom related exercices: mocking up skeletons, or a small widgets with basic interactivity in pure JS. None of it in a real code playground though, all in Google Docs. The idea isn't to check whether or not it would actually run, but to discuss markup quality, bits and pieces of code, design decisions you took etc. Nothing too difficult. - Expect some intermediate to advanced questions related to core language expertise: something fancy with prototypal chains and class/sub-class creation, or some heavy-duty closure + async related problems. Once again, all code in Google Docs. Polyfill implementations are also popular. - Data Structures and Algorithms is usually light (compared to SWE interviews), and will involve discussing a real-world problem at length (~2 hours): e.g. You are implementing the frontend of a browser based bash terminal and are tasked with mimicking history management in the terminal, including easy searching, fragments etc. Your API is this and that, and you can assume that history data is serialized and deserialized this way. What's your approach, what structures etc. Code snippets needed for individual pieces of functionality. - (Depending on the lens you are being considered for) Expect *serious* subjective questions on a myriad issues: like design ideologies and cultures, skeuomorphic vs material vs flat, gargantuan scale UI artifacts and standards management across an organization and what not. Contrary to popular belief, these are the real booby traps, not the technical discussions, because most people have *near zero* experience with these and churn out poor quality verbiage to compensate for their lack of experience and expertise. Fun discussions, will badly affect the decision for sure since most candidates take these lightly. However, there is something else that needs to be addressed: The frontend engineering ladder at Google is fundamentally broken and dysfunctional, and there is a lot that is regularly discussed internally in our chats: significant issues that are rarely if ever addressed by senior management. I don't want to write more here since it's not within the scope of an answer to your question, but if you are interested in knowing, do pm me. Good luck with your interviews.
Every discussion on vscode or sublime had some person injecting their vim superiority without being asked in the slightest
A someone who bakes I don't like the use of "vanilla" to main "plain". It is itself a great flavour, and a great base flavour when combined with other tihngs. So in that sense vanilla is correct for JS: it works on its own, and is the basis for other great stuff. But less tangentaly, the way peopel use the term VanillaJS perhaps CoreJS would be more appropriate.
I think the reason for this is that javascript supersets are so common. In this context I think it makes sense to call it 'vanilla' javascript 
I went this same route. JQuery was easier to learn, and then I backtracked to javascript. I think it was a good way to learn. JavaScript was very intimidating at first, but it was my first serious attempt at fully learning a language.
I really want to know what happens in the brain when someone says that HTML is a programming language or jQuery a framework.
as a vim user. go back to /r/vim.
Using a framework is almost mandatory this days, and saves you a lot of time and efforts, but if you are learning, it's way better to start simple. There is no hurry to have your first ever programming project with react redux graphql docker and RxJS.
Oh please. That's not even close to what I said. I didn't say people should write their own compiler before they write Javascript. I said people need to understand that programming is a list of tiny detailed instructions. You can't program at a high abstract level. You need to break a problem down into many discrete steps and tell the computer to do each one. It's a real method that a lot of people don't understand how to do because it's not how we consciously think about processes in our daily lives. But it's a really important concept in programming and telling people not to spend their time on the minute details of solving a problem and instead worry about the bigger picture is how you end up with "developers" that can't actually solve a problem on their own. Don't make up some random argument that has nothing to do with what I said.
You can't hand wave away the steps required to solve a problem. I didn't say every developer *must* understand memory management. I was replying to the guy that said people don't need to learn vanilla Javascript because of the minute details.
You can build so much stuff with JavaScript! You can now build mobile apps, desktop apps, VR. The possibilities are incredible. Find a cool API that interests you and build some stuff off of the back of that! [Here's a list](https://github.com/toddmotto/public-apis) 1. An example mobile app could be allowing a User to take a picture of an object, submit it to AWS Rekognition (or similar) and have it report back what that object is. 2. An example of a desktop app, a simple Markdown Editor. I can export the Markdown to PDF, to HTML and whatnot. What about a Reddit desktop app? [Here's a JS API Wrapper](https://github.com/not-an-aardvark/snoowrap) 3. VR - this is cool, take a look at Mozilla AFrame, build a game perhaps? 4. Do you have any problems you can solve with software? If so, build it. 5. Contribute to Open Source projects, Github are filled with them. 
.I was reading your comment as an argument that people need to work at the more detailed level of "vanilla JS" so that they can understand the programming they will do professionally. If that's not what you meant, do elaborate. If that is what you meant, then I don't know how you misunderstood my comment, which was that I have heard many people argue that you need to begin at the more detailed level of $theLowestLevelIAmComfortableWith in order to understand programming at the high levels of abstraction available today. 
You can use the [`ES6+ spread operator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) and `Math.max` to do this let numbers = [1, 8, 2, 5, 0]; // get largest number const largest = Math.max(...numbers) // remove largest number from array numbers.splice(numbers.indexOf(largest), 1) // get largest number again (which will be the second largest from the original array) const secondLargest = Math.max(...numbers) 
jQuery is meant to help you overcome the different implementations of APIs between the browsers, it has nothing to do with ES6.
Is there a sentence missing here? " Luckily, talented maintainers of Xterm.js found their own solution to improve performance. They " 
Seems like a good case for a reduce. const nums = [1,2,3,4,5]; const largest = nums.reduce((num, largest) =&gt; num &gt; largest ? num : largest, 0) (Appologies for any dodgy syntax, I'm on mobile)
&gt; Because you'll end up relying on code written by someone else. You're relying on a machine created by someone else, an OS written by someone else, a VM written by someone and a language created by someone else. 
Beginning web developers should be focusing on learning patterns and getting shit done. It's pointless for a beginner dev to spend hours writing their own Ajax function. Intermediate developers should then dive into the jQuery or framework source code to learn how everything works.
The "not working" JSON doesn't seem to be the result of this code, `collection` isn't a real array. 
My fault! I should check it before publishing. Never never trust any auto-import tool. The article is updated now. Thanks!
People need to understand how to program. That means when you're just starting out you *need* to learn how to actually pay attention to all those minute details that are the steps. I'm not suggesting everyone needs to memorize radix sort or anything specific like that but you can't just hand wave away complexity and never understand that what you are doing is lots of tiny steps that eventually end up at the solution. Saying don't waste time learning $language because the problem has already been solved for you is how you get developers that can't actually solve unique problems all they can do is regurgitate known solutions. I haven't reimplmented my own virtual dom or my own observable library but I do know how I would go about solving those problems if I needed to because I've already learned how to actually take a problem and use the language I've got to solve it one step at a time. I was originally responding to this statement: &gt;Vanilla imo is too much too time spent on minutia, where concepts are more crucial Which to me sounds like someone saying don't worry about all the little steps just learn the big ideas.
That is true. We are building on the shoulders of our predecessors. But I think your point doesn't apply to frameworks. Why? Because they're not critical to the process of building things. Not as critical as the language itself, or the OS, or the VM. They are recent constructs, made by our peers, not perfect in any case, and we can choose to work without them. We can't choose however to work without the OS, the VM or the language. We have an option of either relying on a magical piece of code that we probably don't understand completely or using our own code upon which we have absolute control. Sure, the code we write might be shit compared to what the framework might achieve but that's not case I'm debating. Rather my case is that we should choose wisely and sparsely rather then using "magic" code for everything. 
I got both snippets directly out of the debugger/F12 Tool from IE.
The old way to do this is Math.max.apply(null,arrayHere); Same with Math.min
Thanks everyone for your helpful replies! Though I wanted to use a function in order to learn how it works. :)
Well. jQuery does provide a lot of utility functions that are highly redundant in ES6.
It isn't marketed nor thought of by anyone I know for browser compatibility. It's in my experience used as a crutch.
thanks man, I just checked it, its awesome. However, I cant find the course files for the js course, do I have to pay to find them?
What I am curious about is that even without the yarn.lock file, it does actually have everything it needs to do an install. Why not just work so long as the min requirements are met as specified already in the package.json file? 
Yes, plus it's an elegant solution for the fact that form.name (where form is a DOM form element, and "name" is the name of an input element) returns an entirely different beast depending on how many input elements with that name exist in that form: with 1 you get a DOM element, but with more you get something like an array of DOM elements. In jQuery, you *always* get an array of DOM elements, be it zero (none exists), one (for 1) or more (for more), and each method applies to each element in turn - or limited to the first, for retrieving a value. It might not do anything meaningful, but oit *never fails*. And that is a good thing. 
frameworks are bad, libraries are OK.
&gt; A someone who bakes I don't like the use of "vanilla" to main "plain". It is itself a great flavour, and a great base flavour when combined with other things. It comes from ice cream, not bakery. Vanilla ice cream is the basis for *all* other ice cream flavours.
Most of what you've mentioned are available since ES5. I agree with you that some language-level utility methods of jQuery are now redundant, but if you still don't have the time to do the research to see which browser supports what and so on and you need to cover a wide range of them then it's a viable solution.
JavaScript is not assembly. This is so utterly asinine. If you really want to jump to irrelevant extremes why not just equate to stick and writing in dirt. Typically people jump to this ignorant conclusion out of defensive fear and incompetence. I used to hear this all the time when I would mention people don't **NEED** jQuery.
Understanding Observer design pattern before trying to use RxJs really helps a lot. RxJs is not magic at all but for people who never heard about design pattern, that's only magic. And when you use magic, it sometimes has unexpected behaviors. So yeah, you need base knowledge before being effective with libraries/framework/whatever :)
Use the super speedy terminal in vs code to edit with vim!! 
what is your definition of a programming language?
1) Why does the json lib on the server matter if this is a client side serialization error in response to a user action? Your explanation is inconsistent. 2) Don't ask the internet to debug code, especially if you only share a contextless snippet, but just in general, don't. Improve your debugging and reasoning skills. Something's different, so eliminate all factors until you figure out what it is.
Unsure why you're being downvoted, this is exactly my experience of people's opinion of bootcamps online. Have yet to meet someone IRL who thinks this way though.
To be fair, it is kinda magical. :P
I'm confused. Shouldn't soemthing happen when I click on one of these blocks in the playground? All those small previews are kinda worthless...
I don't know of any reputable bootcamp that promises that in 6 weeks. Just because someone pushes ads saying a thing doesn't mean that thing is legit. This is true of all advertising. Caveat emptor. Try doubling that time, catch salty exception. Also, CS grads should be the people designing the frameworks, implementing algorithms, doing things like developing machine learning - things bootcamp grads aren't suited for. Bootcamps are for people who generally didn't get a CS degree and want access to the skills necessary to land a junior level job in tech. Many (not all, possibly not even most) CS grads can't even code at all. That puts bootcamp folks in a pretty good position if you ask me since they can actually code in a given stack at the end of it (assuming their camp is legit, simple research can help there). It's great for people like me who initially chose a different path in life but realized the need to course-correct. International Relations degree != success in 2017. The salt is real. Should I have rolled over and accepted defeat / lamented my choices for the rest of my life? Should I have continued to try to poke and prod at Python directionless for a few more years so I could be a 'self-taught 1337' guy? No, thankfully there's a realistic alternative.
There was 'some' jQuery when I went through, but it was completely focused on tasks. And you could do it with vanillajs if you wanted it. And really, there is quite a lot of jQuery out there. Every other interview I've had seems to ask about jQuery experience. I've even had quite a few balk at my react experience saying something to the effect 'we don't do anything fancy like that around here'. I'm not joking. So teaching very basic jQuery is kinda important for the types of jobs a new front end dev is likely to get in many places. And lets be real, its not like jQuery is this completely foreign skillset that won't transfer to vanilla JS. After you've learned data types, control statements, loops and coersion, you've got the basics down. It is not exactly rocket science. I didn't even finish the front end projects because I have already moved on to building more substantial projects. And this seems kinda common. You often seem people posting that they start a major project or get a job before finishing the certs. To me, that sounds like it's working quite well.
[Stop talking out of your arse](https://i.imgur.com/VWdb2Cv.png)
Redditors answer to everything. As if everyone duplicates everything all the time, every time.
A redditors answer to everything. As if everyone duplicates everything all the time, every time. This is what experience and professionalism is all about. You carry your tools with you everywhere. You don't go and buy a new set of tools on every job. Only amateurs think like redditors do. 
Like I said many times on reddit. Certs are worthless. That's why codecamp gives them away for free. While we're at it. Do you want one? I'll give you one. I've got hundreds of 'em.
If it's all the education you have, I'd probably include it. I'm a camper as well. I started about two years ago. I always say that FCC is what you do when you don't know what to do. It's a bootstrapping process. You are start off not understanding anything about the front end or javascript. You do the projects as they are presented, and at some point it clicks. You have this idea for thins thing you want to build, and you go build that thing. Maybe you come back to FCC when you are out of ideas, but maybe I'm weird, but I'm never out of ideas for new skills or projects I want to work on now. FCC gave me that little bit of guidance early on and familiarity with the jargon for web development such that I can teach myself now. And to me, that is the entire point of the program. The certs are just about worthless. I am not knocking FCC at all here. I think FCC is awesome! But the FCC certs are not accredited in any way, and certs in general are usually not that valuable for programmers. (Excepting for some government positions.) They are just pieces of paper. The thing that will get you are job are projects. Projects are how you get experience without a job. The more impressive, the better. FCC gives you some basic projects, but IMO, by the time you get near the end of the front end course, you should have some ideas for a more substantial projects rolling around in your head. You should go build that project. FCC will always be there should you run out of ideas or need guidance.
&gt; Only amateurs think like redditors do. You know you are as much a redditor as everyone else posting here right? 
I think the best rebuttle is, 'how many people are hiring vanilla javascript developers?' Not many. You are MUCH more marketable with some jquery, react, angular and express. There's a reason a most people abstract dom manipulation in some way. It is an unwieldy, inconsistent beast. I'd rather spend time learning to build useful, value adding features instead of fiddling with browser specific idiosyncrasies.
you've actually learnt "frameworks were bad for me". don't try to apply that to everyone else.
I think in this context, since HTML is not turning complete its not a programming language. Now the interesting thing, is when its paird with CSS, the two combianed are turing complete.
Feedback is very appreciated, you can ask here also if some things are unclear. Thank you!
Browser compatibility is a feature. It isn't marketed as the main reason to use it. It isn't like Babel or Browserify.
[This link has a good answer](https://www.quora.com/Is-CSS-or-HTML-a-programming-language) 
Yeah, this is obviously better solution. Thanks 
IE?!
You just picked the most extreme gap of knowledge there could be. Of course you should not pick a SPA framework without any programming knowledge, but after the basics of a programming language it's perfectly reasonable to use one, writing and reinventing everything vanilla JavaScript is just nonsense (except you want to specifically learn these things or invent something completely new. Most of the time, people just want to build or test an idea though). As I've written above, it would be perfectly reasonable to pick a Wordpress theme and put in some jQuery or React and copy paste some dropdown, calendar etc. components or similar. As long as one is learning and pushing themselves forward I don't see any issues. Also I don't really see the issue when newbies use frameworks? Are you tired of seeing bad code or over-engineered stuff where someone just piles libraries upon libraries? These are more likely mentoring and teaching issues than using a framework from the beginning. If we look at events where people learn Django or Rails, most don't know a simple for loop and learn basic python/ruby within one or two days and can deploy a little web app which renders HTML. These are massive hands-on achievements which would probably not be possible writing this completely by hand in python/ruby. I think in the beginning of learning to code it is much more important to get results than doing everything right (minimizing usage of libraries/code size, best practices don't matter in the beginning, just get the damn things to work). Perfection and clean code matter at work and bigger projects, which usually aren't the place for newbies. Even if newbies are involved in bigger projects or at work, there should be proper mentoring in place which catch improper framework usage or abuse of pulling in unnecessary dependencies.
They probably all do have an extension for it. Except maybe Visual Studio, but eh, who cares.
How about you combine it all into creating a game? /-----------------\ | 1 | 2 | 3 | |-----------------| | 4 | 5 | 6 | |-----------------| | 7 | 8 | | \-----------------/ Create a square with 9 boxes. Take a square image and divide it across all 9 boxes. Make one box empty. Then randomly distribute the boxes: /-----------------\ | 2 | 4 | 7 | |-----------------| | 3 | 6 | 5 | |-----------------| | 8 | 1 | | \-----------------/ You can then drag and drop the boxes into the empty place. For example: you can pick up #5 and only drag it vertically downward. Or pick up #1 and move it horizontally to the right. Once you've started interacting with the game, a timer starts and it counts the number of moves. You'll want the game to be instantiated with settings. You want to be able to provide the size of the grid. Default to 3 (3x3=9), but allow it to grow to 12x12 if someone wants to. If you're up for more fun, create your own back-end. Keep track of each user session and score. Build in checks against automated bots solving it. Track user location based on their IP address or whatever. Allow people to upload their own images and use those as a puzzle background. This teaches you a bunch of things: 1. Functional programming 2. Working with multi-dimensional arrays 3. Drag and drop and animation performance 4. Working with timers 5. Working with animation frames 6. CSS scaling of backgrounds 7. CSS efficient animations 8. CSS positioning 9. And so much more 
I would never stoop so low as to call myself a redditor. Note that I **never** ask questions but I've posted about why I'm here ad nauseum so I won't bother to post why again.
You're a bot!
Funny how redditors fawn over all these other editors but their first request and the first feature offered is some way to emulate vim.
iow, do the same thing that would speed up *any* application.
It's also a pain in the ass to extend with plugins which break each other in subtle ways.
&gt;DOM manipulations are slow Uh oh. No need to read this article. Besides stating the obvious, it brings up the myth of "the DOM is slow". So I'm sure there are lots of other falsehoods and misstatements. Move along. Nothing to see here.
Most bootcamp reps I've heard interviews from, while they sugarcoat it usually, they do admit the certificates don't matter and stress creating a portfolio of work, github commits, etc. As usual just doing a search on this subreddit alone would yield many instances of this same answer regarding certifications.
OPs cover picture for the post is an accurate representation of me doing node development.
They are the vegans of the coding world
As long as Microsoft makes edge a true evergreen browser I have no problem with them. But I have little trust that they will not bring an update on 3 years and forever uses to either upgrade windows or updates to edge will stop. I'm fed up with this shit.
I agree with you. I'm not against bootcamps. [This is what I was referencing when I said 6 weeks.](https://np.reddit.com/r/cscareerquestions/comments/6wna34/is_this_a_scam/) Turns out I was being too generous. No one in that thread was able to definitely confirm or deny if the company was scamming, but it raised red flags for a lot of folks. If anything, I think our field would greatly benefit from a governing body to standardize a tech school curriculum with a basic certification. We would eliminate all the discussion about bootcamps not being worth it. I'm glad that you were able to make a career change without burning through 2 years of public university.
 function timeoutSort(arr) { return new Promise(res =&gt; { sorted = []; arr.forEach(e =&gt; { setTimeout(() =&gt; { sorted.push(e); if (sorted.length === arr.length) res(sorted) },e) }) }) } timeoutSort([9,4,5,2,8,6,1,7,3]).then(val =&gt; console.log(val)) 
hahaha
You can get something to render with only html in a browser... That's a language as SQL is a language as CSS is a language... A language does not have to describe what it does to be a language...
But you can't program HTML to make decisions and computations. Yes, everything is a language at some point. But we have to be able to classify languages in order to properly tackle problems. That's why HTML is considered a markup language, similar to Latex, and not a programming language.
So it comes back to your definition of a programming language ; )
Thats not my defeintion, that's alan truings definition and what fostered the advancement of computer science and the study of programming languages.
Sorry about misleading statements. I know DOM is not that slow. A proper implementation of DOM operations can also get great performance. But in the wild, people without strong experience (including me) tend to write poor DOM operations. That's why DOM is often considered as a performance bottleneck IMO. Another point is other rendering contexts such as Canvas2D and WebGL are easy to be **hardware-accelerated**, while for DOM there are some criteria to meet before acceleration. Today, browsers become smarter. The gap between DOM and GPU-awared render context shrinks. Mozilla's [WebRender](https://mozillagfx.wordpress.com/) even attempts to be a GPU based renderer for web, though it is not ready for production yet. We are all looking forward to the day all DOM ops becoming GPU-accelerated, but the gap is still there. If there is something wrong, feel free to let me know!
Now add a check that `input` has at least two elements. If it has zero or one elements, you can and probably should exit early. :-)
Turing* :P
Writing poor DOM implementations is a shortcoming that shouldn't be blamed on the DOM. Canvas and WebGL are not replacements for the DOM.
Having been at the hiring table, talking with others about their experiences with bootcamp graduates, and having worked with bootcamp graduates. I'm not stating my opinion, just that there is a negative view towards them from a lot of classic CS grads
This isn't unpopular, it's common sense.
You are right. Maybe I should make my point more explicit. Thanks!
I also agree there should be some higher level governing body. Right now decent schools are relying on states for continuing education certification. Some of them (ahem the one in NY) operate without them. Definitely a wild west scenario and it's a big risk for companies doing hiring, could be a great coder could be a shitty one.
HTML is a Markup language (like LaTex). It's right in the name. There's no logic in an HTML doc, it's really much more like a word doc. It is not a programming language. 
This is great! But... what's the point of using a web browser component (Chromium) if all your output is just going to be a canvas tag? Does this really show that Chromium+canvas is poised to become the universal graphics API?
That is such a popular and backward opinion that sole purpose is circle jerking on true programming, learning or knowledge. IT and programming HAS to become more standardized, like construction, fucking custom bullshit from "one special mind" is just too much cognitive load for others. Turns out, life is about building things bigger than yourself, that other people can contribute or take back. That is just common contractor decency. And just like everything else, harder point of entry is just a douche bag theory of elitism. " | letting them burn out Is some kind of version of, i had it rough, it made me, make em ruff for them too. Which at first sounds real nice but turns out they could be doing other things that whatever ruff thing you had to go through. Because now its better. But don't worry, they will face gigantic ass walls... just others. So you don't need to get in the way, with your glorification of "no pattern", get in there, learn the core method. Turns out, not everybody is equipped to invent dependency injection, observable model loosely coupled with view that renders on debounced updates. But they are very well equipped to build whatever little tool they need. I learned theses thing after i've been using them and its perfectly fine because for some, being goal oriented works better with motivation and as we go, we learn about optimisations and better structure and other refinements. If you give people crap and let them burn out, you'll have even less programmers, they will be less fun and all of that for what i would even call, a asshole ish opinion about process and how bad parts are importants. 
But it's the Dwarf Fortress kind of fun! Come back!
We use browserstack to run our functional and integration tests for a large web application. How does Cypress compare? I think it looks great, but how does it scale with automation across multiple teams in enterprise?
Meth lol
I do not promote to do everything with canvas API. We need to evaluate tools before using them. And I think canvas find its niche in this VS Code case. Other parts of VS Code still wield the power of DOM.
Sure, web developers don't need jQuery. C++ developers also don't need Boost. And Node.js, Golang and Rust developers never need to pull a single library from NPM or Github. These libraries are conveniences. Why would you want to reinvent methods from the jQuery library just so you can build that fancy new "super interactive" form your boss wants in 3 days? Your implementation would not only probably be poorer than the carefully curated versions maintained by jQuery Devs, but you'd waste precious time developing something that you don't NEED to build from scratch. Now if you had a specific bone to pick against jQuery and wanted to produce a superior library or just avoid the pitfalls of it, then I'd understand. But most people just want to "get the job done", which is perfectly understandable. Frameworks like React, Vue, Angular, etc aren't exactly "jQuery replacements", but they are useful for a similar reason. Developers want good performance and a clean structure to build their web apps - why waste precious time rebuilding a Vue.js when that time could be spent on building the business logic/user experience code?
I really would like to see more discussion about solving problems rather than using X framework. If you are a newbie, and see a framework, ask "What problems does this solve?" and move past the sales pitch for the answer. Because honestly, frameworks are very good at solving problems, but maybe not YOUR problem. The more we look into solving problems and focusing on the problem domain instead of the "solution domain" the better software engineers we can be. If newbies were more trained into solving problems and not *implementing solutions* - we'd be better off. 
I totally agree. As someone who has hacked together plenty of things that worked despite me not understanding exactly how, I find frameworks can be a bit of a double edged sword. I'm not interested in reinventing the wheel, but I'm even less interested in misunderstanding how my software actually works.
I see they made a lot of changes to edge 16. Also they are releasing edge on Android. So hopefully this will make it independent from windows 
I agree that learning the minute details of JS would be an incredible asset for many web devs (I'm constantly surprised by how many people with years of "JS experience" have no idea what a prototype is - surely you'd at least come across it by accident at some point?). However, knowing these "minute details" is more or less optional for those who are only tasked with jobs as simple as "when you click this button, turn the banner into a different shade of blue". Would it help them to not build themselves into impossible situations, and to dig themselves out of insidious bugs? Definitely. Will bosses keep hiring people who have no idea about prototypes or how scopes work in JS anyway because they're still capable of "getting the job done"? You betcha.
Could you clarify whether this is for "UX Engineer" or "Front End Engineer"? It sounds like you're mostly describing "UX Engineer", which I heard is less data structures &amp; algorithms, and more along the lines of what you said. Apparently a Google "UX Engineer" focuses on front end, design, and user experience, whereas "Front End Engineer" is actually more of a "Full-stack Developer". Kind of confusing. I actually feel like I'd be a much better fit for UX Engineer, however the recruiter said they didn't have any spots, so they moved my application forward as Front End Engineer. 
I've two streamlined versions for you, depending on what your preference is: const topTwo1 = arr =&gt; { const [ v1, v2 ] = arr.sort((a,b) =&gt; b-a); return [v1, v2 ]; }, topTwo2 = arr =&gt; ( ([ v1, v2 ]) =&gt; [v1, v2] )(arr.sort((a,b) =&gt; b-a)) I say, though the best answer is to generalise: const sortAndTakeN = (sorter=(a,b)=&gt;a-b, n=0) =&gt; (arr=[]) =&gt; arr.sort(sorter).slice(0,n), sortHiLo = (a,b) =&gt; b-a, topTwo = sortAndTakeN(sortHiLo, 2); If there's anything in there that's confusing, please ask!
Edge on Android is chromium based for now
hmmm... sounds to me like these CS grads are maybe a little bitter that they spent more time and money to accumulate less skill. 
...no? that straw man is just silly
I would suggest finding a hackathon around your or a JS meetup. Getting in touch with fellow devs would help you work in real-life projects and learn more stuff than experimenting on your own. Another good way to get started, would be to find Open Source projects and get involved in them. Fix an issue, make a small change to the docs and then get into harder stuff. Best of luck! 
It can go too far. People should start with whatever is most interesting to them (within reason), I think, just as a motivating factor. I started with Commodore BASIC when I was a kid. Eventually, I ended up with a TI 89, which used similar BASIC and made some fun things, then I saw the really cool things were done in assembly, tried to learn a bit of that and basically ran away screaming. Noped out of java, similarly, and those experienced turned me off for around a decade until I found out about unity3d, and started easing my way into C#. In unity every little script that worked felt like a big win and it kept me interested in progressing my scripting skills to the point I started enjoying that more than the art side that originally attracted me to games. Unity probably wasn't the best place to start and was definitely overkill for all of my projects, but it kept me interested and motivated. I'm now working on a little microservice to feed data into one of my games, getting balls deep into python, networking, containers and cloud vps solutions, but if I started there I doubt it would've been exciting enough to put the time in. 
jQuery is a great DOM API, but personally I'd rather have a good understanding of the native API to avoid heavily relying on a library to solve problems. thats my personal choice though, I understand the tradeoff is that I have more code and run the risk of not supporting different browsers. Especially older ones. I accept that risk because I personally want to learn how to support other browsers natively. Personally I think that if people prefer jQuery only because of the syntactic sugar then they are doing it wrong. jQuery is great at solving the following problem statement: "I need to support multiple browsers and I am not, and will never be using a UI framework that conflicts with it" 
I'm not advocating not using frameworks or libraries. But a developer has to have a solid understanding of how to actually write code. Not specifically the code their framework is running. But specifically how to step through and solve problems one little detail at a time. If a developer thinks that frameworks are somehow doing something with the language that they can't, not in a lack of knowledge sense but in a fundamental inability of the language, that's a huge sign that they probably aren't ready. You don't have to know how specifically react works, but you should have a general idea that at some level Javascript code is going to be executed that creates a bunch of new dom elements and attaches them to the document. You might not know what algorithm is used to diff the virtual dom vs the real one but you should at least be able to imagine a simple algorithm that steps through both node trees and compares each leaf in the tree to figure out which ones are different. At a more basic level you might not know exactly which search algorithm Javascript is going to use when you call Array.find but you should at least be able to grasp how a basic linear search would work by traversing the list one item at a time and running a comparison on each item. It's not a matter of knowing how every line of code is executing in your application. But instead it's the basic general understanding of *how* a developer might approach a problem and break it down into smaller and smaller steps to eventually end up with code that solves the problem. Without that you have people blindly throwing code at a problem without really understanding how or why.
HTML is a declarative programming language - https://www.youtube.com/watch?v=RH0o-QjnwDg - turing completeness should not be your measuring stick either.
it's odd that you ran into issues. good vdom libs (including React) can remove a single row from the top of a list of 1,000 non-trivial rows in 35-50ms [1]. in that bench, the majority of the 40ms is spent on the browsers's own re-layout/reflow rather than vdom overhead. [1] https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html
Yes, there's a solution
Yeah if we're talking about Javacript versus Typescript or Coffeescript or something, the term would make more sense.
Probably you didn't read the post carefully. In my list, I have a visible index of each element. When I remove the first element, indexes of all other elements need to be updated. That cause a lot of calculations.
Can you explain more, and how that relates to react/redux?
What do I think?
Probably you didn't read the post carefully. In my list, I have a visible index of each element. When I remove the first element, indexes of all other elements need to be updated. That cause a lot of calculations.
Probably you didn't read the post carefully. In my list, I have a visible index of each element. When I remove the first element, indexes of all other elements need to be updated. That cause a lot of calculations.
re: #4, sorry, it is in fact possible to make it return true
I don't see why Cypress would not work in this environment. We have enterprise customers using it (DHL, Kiwi). Try it on a project on one team and let us know, I am sure the experience will be good, and if there are limitations, we can work on it.
Why not Babel? Then you get the best of both worlds.
Thanks, I'll see if I can get one of our teams to try it out - I'd very much like to at least spike it
- I've been here for 2.5 years, and have never come across the designation Software Engineer, Front End. On the signup papers, you're going to be Software Engineer (And you are practically that for the world, and so is near about every Googler who isn't Staff Engineer), but internally, you're going to have a special designation on teams (an internal site) and elsewhere. Please have this clarified by your recruiter, because to the best of my knowledge, there isn't a SE/FE role. There is SWE, SRE (eng ladders, your traditional "backend" people), and there is the UX ladder, where UXFE's are what you consider yourself a good fit for. The full stack developers are SWE's and SRE's. - Try to avoid white-boarding. Here in Mountain View, (most) interviewer's, myself included, are happy to allow you to type if that's what you prefer. Don't bother with IDE's or even code playgrounds (I recommend avoiding anything that has the possibility of execution, for your own benefit, and to save time). A plain vanilla text editor or even Google Docs will do. If in GDocs, please choose a monospace font (LOTs of folks type code in a serif font, it's a horror story!).
Software Engineer, Front End: https://careers.google.com/jobs#!t=jo&amp;jid=/google/software-engineer-front-end-1600-amphitheatre-pkwy-mountain-view-ca-2551200098&amp; UX Engineer, Front End: https://careers.google.com/jobs#!t=jo&amp;jid=/google/ux-engineer-front-end-1600-amphitheatre-pkwy-mountain-view-ca-292690011&amp;
This doesnt look like a copy as they both point to the same link. more looks lie speckz is just sharing something they found interesting
It's not my job to judge, that's just the reality I think and something bootcamp grads have to take into consideration when competing with everyone else for the same positions.
At a guess, I'm thinking a state machine is basically just a holistic amalgam of global variables. Which are bad, mmm'kay?
highly redundant? can you elaborate?
I see many newbies trying to hop on angular 4 and typescript before even getting down the basics of JavaScript. These frameworks obviously build upon JavaScript so master vanilla first and specialize on frameworks afterwards.
Eh. There are plenty of folks in tech who still care more about demonstrable skill than they do about degrees. If an interviewer/company is gonna judge me based on how much time/money it took to get my skills rather than how skilled I am, I have zero interest in working for them.
Are there any other APIs for developing with lambda besides Claudia? And how do they compare?
Okay, but let's say I need to emit socket event whenever song is over. I am not sure how to solve that.
I agree with that too, but as companies grow, they need some way to filter out candidates more quickly without asking each one to demonstrate their skills. When hiring developers, a bootcamp grad paired with generic projects are two red flags that can get you filtered out at an early stage. Regardless of your skills or how valuable you think you are, the more information you have the better position you are to get the kind of job you want. 
Oh, I think Microsoft's recent "love" for Linux and the open-source community is horseshit. The projects they have open-sourced likely wouldn't be used by anyone if they weren't open, and funding the Linux Foundation, for instance, gives Microsoft a significant influence over the operation of perhaps their biggest server OS-market threat. Moving MSDN content to the MDN makes financial and marketing sense. If Edge supports or introduces a new feature before Chrome and Firefox, people will actually realise and experiment with it. More developers using and recommending Edge is just what they'd like.
 const cracklePop = compose(toCrackle, toPop, toCracklePop) getIntsUntil(100).map(cracklePop)
plenty. Serverless, and aws-serverless-express. I recommend the latter as it gives the routing you are used in express and takes care of all the integrations with APIGW without tampering or hiding the details of the deployments. Deploy with a makefile or with CFN when needed. 
An good starting place would be to find something that you yourself might use, either creating something that doesn't exist yet or reimplementing something simple that does. The todo list mights fits this description, but there could be many other options. If you play table-top RPG games then perhaps tools like character or map generation is somthing you could look at. Or maybe you code implement a simple board and/or card game? Perhaps there is a sysadmin tool that would make your life easier which you could (re)implement using node (perhaps JS isn't the best tool for this sort of job, but it would get you some practise in an area that presents new learnign opportunities that could be transferrable to future projects). Things like https://www.npmjs.com/package/dir-compare or the many "pretty directory listing" projects there are out there. When chosing a project, think about what you might learn from it and what you can already do. A good personal project is a mix of new and interesting parts to learn, things you need to practise, and stuff that you know (so you have a base to work from). Try not to pick a project that includes too many facets that you don't yet know, or if you pick one that does need a lot of new tech try plan the project so you get something visible at each step instead of needing to properly learn them all to get any outout.
Not really, I'm guessing these are genuinely full stack roles with a strong emphasis on the front-end. You will be writing rpcs, but I'm just curious what your internal lens will be.
Interesting so they shouldn’t have donated and they shouldn’t of open sourced?
I’m learning Vue JS and vanilla at the same time. It’s helped me understand each other a lot better this way. 
Yes, depends on the chosen programming language. Claudia is an extension of AWS CLI, it's not trying to replace it. It's just a deployment tool - it creates a Lambda, and deploys your function there. You don't need to setup a config file for it to work. It works out of the box. Alternatives as mentioned by bigdeddu: - aws-serverless-express - nice lib, if you like Express - SAM - good, if you want to do orchestration - chalice - Claudia like for Python, would choose that if i was doing python - serverless - good framework, good people behind it, difference is that you need to do the configuration in a config yaml - many more I am opinionated about Claudia ofc, as one of the co-authors. Claudia.js doesn't force you to have a specific framework-like format. Claudia API Builder gives you Express-like endpoints too, without bothering with middleware or installing 100 dependencies. Claudia Bot Builder helps you with connecting bots to your Lambda for over 10 platforms, including Alexa as a voice assistant. 
The way I see it is a language that allows to communicate with a computer in order to get something out of it. And you can describe logic : a h1 is not rendered the same way as a p. Having logic is not a question of being able to write if else statement... But according to some great people I'm wrong... I have only one thing to add : http://www.relativelyinteresting.com/wp-content/uploads/2012/11/LogicalFallaciesInfographic_A2.png
This issue is just stemming from shallow comparison logic imbedded in react's life cycle and the fact you served a large object as a single prop in your component (rather than breaking it up in to individual props).
I often find myself in a similar rut in that I want to create something, but I want to create something useful. Truth be told, most of my projects have been born out of a need and want to do something (and almost all of them are personal, or pseudo-corporate -- creating projects for the workplace with management permission, but without the politics involved of having to have an entire team working on it). Take a look at your daily job - what frustrations do you have that could possibly be improved or resolved with a webpage or web app? A perfect example could be spreadsheets that you use (if you use them). Over the past few months, I've replaced a spreadsheet we use for prices on mobile phones with a standalone angular-powered web app that provides device specification, prices, discounts, comparison, stock check and other useful utilities we use on a day to day basis. It's accessible to employees working in the same department through our intranet and I get daily requests from people asking that I allow others access to it (since access is controlled on a per user basis). To keep it up to date, I built a separate node.js powered app that scrapes the website for information which I run on an almost daily basis and it just about automates all the updates that I had to do manually in the first version of the project. I'd love to use an API approach, but a public one isn't provided. The first project was born out of frustration with slow, overly-complex spreadsheets which at times provided incorrect information. The second was born out of a frustration of having to manually update information in the first project, to save myself several hours each week, and to allow me to update the information as and when I wish. How about a website? One possible thing to consider is creating a website, using a node.js powered server (to be able to teach yourself server-side JS as well) to show something about a hobby. Alternatively, why not look at some of the API's out there, such as Pushover, and how you can combine them with other API's in response to events. Finally, never underestimate Chrome developer tools. For me, they are one of the single most powerful tools when it comes to debugging and testing ideas. If I know something works in browser developer tools, I know it will work when I code it into a page - this allows me to quickly test code in an environment I use very heavily every day and with instant feedback on the results.
How I understood it, is that the author proposes to define states in a declarative and finite way by using objects that describe possible state transitions. We define for each state to what other states can it transition. This is different than what redux does, because unless you read all the application and store logic, you won't know what are the possible states your application or component can be in, which hinders our understanding of the business logic of a given piece of application. It's quite an interesting outlook on how to write UIs and state machines, but admittedly, I'd need to see it in a content of an application bigger that the examples in the xstate repo. In theory, managing state for a single component can be very well solved this way, and make for a very comprehensive way of defining what we can expect from it, but I'm not entirely sure how does component to component interaction come into play here.
I did read it. The benchmark also has an index for each row item that must be maintained when an element is removed (see screenshot) [1]. In the keyed versions, the actual DOM element is required to be removed. In the non-keyed variants, usually all DOM elements are updated with new indices and the last element in the list is removed. This metric literally tests exactly what you describe in your post. [1] https://github.com/krausest/js-framework-benchmark#js-framework-benchmark
I feel it depends upon the context upon which they entered the arena for learning a language. If they were looking to build something simple fast and effectively, then a framework isn't necessarily evil and may lead to a quicker end result. Learning jQuery (not a framework, but still) or Angular or React is not a bad option, but they will be lead down a path that's heavily framework driven which doesn't make for adaptability since framework of the moment changes every year or 2... but for all intents and purposes, it works and will continue to work for a long time. If they entered intending to turn it into a career, or a hobby that takes up much of their time and passion, then we find that they become bogged down trying to do unnecessary things in a framework; the jQuery-cadet mentality. We've all seen the answers on SO where someone provides an answer that's done in jQuery for a question where jQuery absolutely isn't required (such as array-work when a for(), .forEach or .map would be more suited). In these situations, their early exposure to the framework or library has caused them to have an unnecessary reliance on it and when they find something they can't do, the frustration of "I now hate JS because it can't do this" sets in (when in reality it can, but the framework they're using doesn't allow or support it). However, rather than forcing people to code 'vanilla' and then learning frameworks, we should support them in whatever they choose... and when they come asking for help, or when they're frustrated, we should guide them towards an elegant solution in 'vanilla' JS if it's the most appropriate option. We don't need less developers, we need more developers that are willing to pass on their experience to those who are willing to listen and heed our advice. Off topic note, I believe you means to say 'Javascript isn't jQuery and CSS isn't Bootstrap' - the way it's written at the moment implies jQuery isn't a JS library and Bootstrap isn't for CSS. It's a minor point and doesn't detract in any way from your point or opinion.
It also teaches application infrastructure. I come from a creative background, so it was very natural for me to look at the work of another and “steal” from it lol. Artists tend to “steal” by looking at the composition of another’s work, and applying their concepts into their own. So for me, it was very much that approach. I started with Wordpress, thn ember, ng1, Magento. I am starting to see the patterns more easily and the context of the infrastructure. I’m probably a little more incline to investigate those things but still, it’s not all bad.
What would be the plugin-less vim evangelists? Like raw-food vegans? Cause as much as I love vim those people irk me.
Yeah whatever... that argument is not valid : http://www.relativelyinteresting.com/wp-content/uploads/2012/11/LogicalFallaciesInfographic_A2.png That's your definition. You choose to use someone else's, that's all
The problem is that they are usually half baked, like it gets you about 60% there but for the people that have intermediate/advanced experience in vim it misses the mark. I can't wait for embedded neovim implementations to mature.
I won't actually speak for achen2345 here. But I was originally specifically replying to someone talking about new developers. As in people still learning. Not someone that has a job in the field. And I have no problem with frameworks and libraries. I use them myself and fully expect others to as well. There's no hard and fast rule about when a developer has enough experience to use one or anything like that. But I do think that when you are still learning, which is what this thread is about, your first thought probably shouldn't be to immediately reach for a prerolled solution. That's not to say you should attempt to recreate react before you're allowed to use it. But that you should at least understand the basic concept of taking a chunk of data and then manually creating Javascript elements from the data and then inserting those elements into the document. Nothing fancy. But if you're still learning it's good to try to solve problems yourself by breaking it down into small steps and attempting to implement them. You might only do that a little bit then have that moment of "Oh... this is why people use something like react". But to be a good developer you have to understand how to approach a problem by breaking it down into small pieces that you can actually implement. Tldr: you have to actually learn to program if you want to be successful. Not just how to slap together a bunch of stuff you don't understand by copying and pasting.
or use `slice` and the function is one line return input.sort(function(a, b) {return b-a}).slice(0,2); 
Well said.
That's a sweet infographic, I've been pwend once again on the interwebs arguing about whether HTML is a programming language.
I see. I'd prefer not writing rpcs, but I can , so that's cool. I have a much stronger appreciation and desire for UX, but I guess that's for another chapter of my life. So to conclude, knowing that the role I am interviewing is not "UX Engineer, Front End", but instead "Software Engineer, Front End", do you think my interview would be more practical as described in your original post, or more data structures and algorithm heavy? I could walk into an interview and comfortably do/answer everything you mentioned, but at the moment I am grinding as many LeetCode questions as I can. What I'm asking is should I focus more on practical web dev stuff or LeetCode?
yeah i know but I didn't want to write compose cause its like export default function compose(...funcs) { if (funcs.length === 0) { return arg =&gt; arg } if (funcs.length === 1) { return funcs[0] } return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args))) }
I'm pretty sure your interviews will be proportionate with both: meaning, it won't be light on data structures and algorithms, and it won't be light on web dev either. However, I don't expect anything too outlandish for the ds-algo part: If you're familiar with hashes, lists, trees and some dp/recursion, that's a solid ground to stand on. Leetcode is great. Do lookup some past Google questions and answers too (not puzzles, those aren't asked anymore afaik, just code).
This is the best answer.
This is pretty common advice to newbies - also the primary reason I tell people to stay away from jQuery. Similar reason as I always tell people to pick another language as your first language, since JS is very high level and covers up some fundamental programming concepts. Don’t use jQuery when you’re learning, doubly so if it’s your first language, since you’ll just end up getting familiar with oversimplified APIs. Once you’ve learned how to do everything without jQuery, you probably won’t want to use jQuery.
I always get loads of downvotes whenever I say this, but I’ve never seen any competent developer who enjoys or recommends jQuery. Maybe a few years ago it was a necessity, nowadays it’s just an unnecessary abstraction and people end up using it as a crutch.
I think it's much more important to have a few thoughtful repositories with nice documentation than to have any specific type of project, or lots of stars. If you want a full stack job, put together some full stack project that can be served with npm start. Bonus points if you include the built assets and can link to a demo with rawgit.com. Don't get hung up on what to do, just work on avoiding paralysis. Also, do some practice interviews! There are tons of resources available online to help improve your interviewing skills. Plus, most of the time interviewers aren't looking for you to give all perfect answers, they just want to see that you don't get paralyzed, so work on that!
I have been testing universal-router yesterday but I am dissatisfied with the results so far. I'm forced to use routes like these `path: '/:course/:chapter/:lesson'` if I want to achieve composition in the view. Looks like router5 is a far better solution, more similar to the styles used in angular or react routes (stateful routers). Thanks for the recommendation.
By your definition writing a word doc is programming. If you think specifying a tag counts as logic (it's not, it's markup), then setting text to be a title in Word meets the criteria. I suggest you read up about Turing completeness. The concept of programming languages were really invented by Turing (and others) before the first physical computer ever existed. One of the criteria of Turing Completeness is any programming language can compute anything any other Turing complete language can. Html can't even add 2 numbers together. This really is a case of there being a right and wrong answer here. I'm on my phone now but happy to clear anything up later when I'm on my computer. This is not an appeal to authority, it's about understanding the origin and history of an idea. You're free to use language as you like, you can say the word green is a programming language if you want, I'm just telling you that your claim that html is a programming language is objectively wrong.
Tools/tooling are the things we use to make software development easier or more powerful. Like babel allows you to write modern javascript instead of being constrained by the browsers you are supporting. Or how webpack makes dependancies easier to manage and more performant. Or how linters help catch common problems with your code.
What I don't understand here (and someone please feel free to correct me if I'm off base here) is what any of this has to do with Finite State Automata. I'm not entirely sure that the speaker understands the idea of an FSAs and how they are traditionally used. Defining __states__ and __functions that map between them__ isn't really the point of FSAs. And doing such a thing within the context of a UI component also isn't "using FSAs" or anything new for that matter, it's just regular ol' programming with React. So to follow, doing that in a structured declarative manner (using the speaker's library) is an interesting proposal, but the speaker didn't spend a whole lot of time describing why he believes it to be a good idea nor did I personally find the arguments presented very strong or compelling. (E.g. letting us know that the author read about it in a 20-30 year old book that no one's heard of is irrelevant.)
You think that you can come to reddit with some requirements and have someone write code for free. 
These are awesome! Thank you so much.
good to know, thanks!
nice idea, thanks!
great insights, thank you!
Thank you so much, this really helps me.
&gt; I'm not entirely sure that the speaker understands the idea of FSAs or how they are traditionally used. Defining states and functions that map between them isn't really the point of FSAs. Care to clarify on this? A FSA is defined by a set of states, actions, and the function that maps between them (plus a start state and optional end states, hence the quintuple), how is that "not the point of FSAs"? The advantage he's arguing for is that if you have a system that can be represented this way, the approach is easier to reason about it and is less prone to mistakes in implementation (provided the FSA design itself is correct), versus the "bottom up approach" (his term). The latter being a combination of independent state variables, along with action handlers whose effect on the system is defined procedurally, that all must coordinate perfectly. It's just harder to keep the latter all in your head at once than a state diagram. 
Then yeah, you would have to use `setTimeout()` const EventEmitter = require('events'); const emitter = new EventEmitter; emitter.on('track-start', (track) =&gt; { clients.forEach((connection) =&gt; { connection.sendEvent('play-track', track) }); }); player.playTrack = function () { this.track = { file, duration: 0, startTime: Date.now() }; clearTimeout(this.timeout); this.timeout = setTimeout(() =&gt; { emitter.emit({ file, duration }); }, duration); }; You can make your `Player` extend `EventEmitter` to make that easier. There you can find some docs: https://nodejs.org/api/events.html 
&gt; Imagine you are running a yes-like command that writes output at full 10.2GiB/s speed. You will find that your web-based terminal emulator stuck and cannot response to any mouse event anymore. The high speed yes triggers trigger a tremendous amount of synchronous reflows and repaints. Yes and no. If I remember correctly xterm.js' biggest problem in this use case is that it updates the DOM for *every* line it processes. It doesn't do any kind of jump scrolling. It should drop its refresh rate when it is busy.
&gt; People need to understand how to program. I never understood this gatekeeper mentality around programming. People don't need to learn anything they don't want to and not everyone who learns to program does it to play a particular role in society. There was some charity event a few years back where President Obama learned to program something basic, this mentality is akin to saying he was doing it all wrong because he didn't start off by understanding what a linked list was. &gt; I haven't reimplmented my own virtual dom or my own observable library but I do know how I would go about solving those problems if I needed to because I've already learned how to actually take a problem and use the language I've got to solve it one step at a time. So you're saying that with some additional learning you could some a problem you currently don't know how to solve. How is this different from anyone else who's faced any new problem ever? Your argument implies that there's an appropriate (arbitrary) distance one should be from being able to reach some level of difficulty (also arbitrary) of a goal.
&gt; You got me thinking actually, there must be a way bootcampers are separated from knowledgeable programmers during an interview Why
You can sometimes get the job done fast by copy/pasting things you don't understand. You can get the job done much faster, and correctly, if you know how to do that job.
Bootcampers aren't as efficient.
Got it. I see indexes in the benchmark. I think the main issue is that in my app an item element was much more complex. It has a lot of DOM elements inside, a lot of event listeners and some logic in lifecycle methods.
lul 
&gt; Care to clarify on this? A FSA is defined by a set of states, actions, and the function that maps between them (plus a start state and optional end states, hence the quintuple), how is that "not the point of FSAs"? Being able to fit the definition of an FSA doesn't really mean anything. If that were actually important than I'd be appropriate to make the counter-argument that you can reduce his "bottom up approach" down to a similar quintuple thus also making it an FSA, which is clearly possible. The original problem presented (what you noted as "independent state variables") is literally no different (isomorphic) to using multiple FSAs as with his text-styling example. So the entire premise of "thinking in FSAs" seems ambiguous an imprecise. Like none of this is really the point of FSAs because they are typically used in the context of designing algorithms. I suppose you could make the argument that an app's UI flow is an "algorithm" but come on, it's way more likely that the author just wanted to drop a bunch of cs/math buzzwords.
Training for a very specific job is not the same as gaining a broad understanding of a programming language. Using *helper libraries* (eg: jQuery) can be useful for both. However, using a *framework* (eg: Angular) implies far more abstraction and automation, which is vastly more difficult to conceptually relate to raw JavaScript. This is true even for experienced coders! I believe teaching '**concepts**' is more important than learning details. This allows you to put everything into context, which is the beginning of true understanding. For example, when teaching jQuery it should be made clear that it's primarily just a collection of helper functions. Show students some of the simpler methods so they case SEE how they work. You could even have them create a jQuery method. This provides an _understanding_ of the library, so it's not black magic. It does *not* make sense to make newbies become DOM experts because it's a huge topic and time is limited. Learning logic and how to structure clean, modular code is much more important. Whether you call a library method or your own helper function to handle a sub-task shouldn't change your logic or code much. However, using a library can greatly accelerate progress, so they create and learn more in the same amount of time. In summary, it's **beneficial** for newbies to use low-level helper libraries (jQuery, Lodash) to move forward quickly and not get bogged down with details like DOM handling. However, they should NOT use highly abstracted frameworks or tools until they learn the *underlying concepts* of what they are doing, such as event binding and listener firing. You must *understand* your tools to use them efficiently, and to have knowledge you can build on.
this sub thinks you need angular4/webpack/typescript level of complexity for something as simple as a todo list. this sub loves unnecessary abstractions and 'type safety'. the goal of a good website is to do as much with native html and css as possible and limit your javascript. that is good web design. one of javascripts strengths is it's weakly typed nature, type coercion capabilities and ability to get things done quickly. microsoft is undoing all of that with all of their efforts to wedge themselves into the web dev community. forget about the days of easily understanding a websites codebase. remember how java forced you edit about 5 different files before you could make a 1 line code change? lets get that principle going in javascript! /s its insane, if you have a stick up your ass about what makes code 'good' thats great, tell someone who gives a shit, and stop fucking up web development with your stupid unnecessary abstractions. you could write an entire functional crud app in the time it takes you to bootstrap a webapp using modern JS frameworks. [It's just stupid](https://medium.freecodecamp.org/stop-bringing-strong-typing-to-javascript-4da0666cba6e)
That's a lot of words you put in my mouth that I literally never said. My point here is if someone wants to have a career in programming they need a certain mindset. Obama "learning" how to program for a publicity stunt isn't the same thing as learning a skill that you are trying to support yourself by. I never made any claim on basically anything you brought up. I simply have been stating a facts. 1. Computers accept a list of instructions where each instruction is a small atomic process that it should carry out and it does in sequential order one after the other. 2. In order to understand programming you have to be able to break down a problem into these small parts so the computer understands what you are trying to tell it to do. There's no magic. The computer literally does what you tell it to one tiny instruction after another.
Based on the fact that web applications do not live in a bubble. You can write a jQuery replacement, sure. But will you also take on the weight of all the browser inconsistencies that jQuery irons out for you? Will you grab about a dozen polyfills for convenience functions that don't exist in legacy browsers that you nevertheless want to use? Why saddle yourself with all that pointless technical debt? Also, all of this is code that *you* end up needing to maintain and document. Worse, it's technical debt that you're passing on to your team. Nobody needs to be coached on how to use jQuery's AJAX function - jQuery's documentation is superb. If a particular behaviour of the function is puzzling them, odds are that they'll find the answer to it on Stackoverflow. Compare/contrast that to encountering buggy behaviour in "bobsCleverAJAXWrapper", written by Bob, who left the company 4 years ago. And also the function is a 3KLOC monstrosity thanks to ugly hacks shoved into it over the years by other developers who weren't quite as clever as Bob was. If you're setting out to bake apple pie, you generally don't plant a tree and wait until it bears fruit. Libraries like jQuery fulfill a valid purpose - they provide you the apple so you can bake your pie. jQuery is by no means perfect. If I was starting a complex web application today, I probably wouldn't build it around jQuery. But for simple sites or when maintaining legacy sites that already use it, jQuery is a great convenience. 
Efficient at what? How do you know?
That's because Vim, the software, is terrible, but the modal editing paradigm it provides is fantastic. We keep looking for something that provides the same paradigm in better software, but everything basically ends up in uncanny valley.
&gt; That's a lot of words you put in my mouth that I literally never said. ? I literally copied and pasted quotes that you said. &gt; to support yourself by Not everyone who wants to learn programming wants to be a programmer by profession. I'd suspect _most_ would not. I don't think that being able to do it professionally was even the topic at hand. The rest of your post doesn't seem relevant to my response.
I'm stumped. This isn't a trick question with an answer like `(y(), true)` is it?
&gt; I think the main issue is that in my app an item element was much more complex. It has a lot of DOM elements inside, a lot of event listeners and some logic in lifecycle methods. sorry, still confused. if no other sibling captions change when one is removed, then a `shouldComponentUpdate()` defined on the captions should completely eliminate any required vdom diffing of any complex internals for 99% of the app (assuming the captions are properly keyed). out of curiosity, what's your live DOM node count via `document.querySelectorAll("*").length`? vdom overhead only depends on the vtree size and how much of it actually needs to be diffed. "complexity" is such a vague and relative term. only the "create many rows" in the 10k rows benchmarks even approaches 1500ms and 95% of that is simply the time browsers take to create and render ~80,000 dom nodes. disclaimer: https://github.com/leeoniya/domvm
To emulate _a part of Vim that a lot of people like_ without having to give up the benefits of a modern editor (or IDE).
Personally, I'd love to see more tools that leverage native stuff over build-time magic. The question I have wrt custom components is how well do they scale, e.g. with fractal data (e.g. trees of reddit comments) and what's the story with data selection/lenses
The answer is `export const x = 1`. Javascript has two top-level productions, `Script` and `Module`. In `Script` mode (for environments that implement annex B), `&lt;!--` is the token for a html-like comment, but in `Module` mode, the html-like comment extension is forbidden and the grammar falls back to the productions defined by the standard grammar, i.e. `&lt;!--` is equivalent to `&lt; ! --`. Knowing that, the puzzle becomes trivial: many values like `true` or `1` will yield `true` as a return value, but _only as long you're in `Module` mode_ (hence the `export`, which is only legal in `Module` mode). The "trickiness" is that this is such an obscure corner of the spec that many js parser vendors get it wrong. For example, V8 deviates from the spec, by incorrectly throwing.
Procedural generation of art, landscapes, stuff? I saw [this random page](https://www.semicolonsoftware.de/) today, he's got a cool new random background each time the page loads, and [a blog post](https://blog.semicolonsoftware.de/generative-art-for-website-backgrounds/) that explains how he did it -- so use it as inspiration for your own ideas. There's also /r/proceduralgeneration/ :-)
You made me remember, back when I was just starting with web development (PHP mind you, no much JS at the time), I didn't even know what a framework was. After I found stuff like PHP Cake it blew my mind that I had "invented" models, controllers and templates. It's a fun learning experience.
&gt; But will you also take on the weight of all the browser inconsistencies that jQuery irons out for you? I am not worried about that. This isn't 1996. People who cry about this now are people who completely lack experience. It also assumed jQuery doesn't introduce cross-browser inconsistencies itself, which is historically not the case. &gt; Why saddle yourself with all that pointless technical debt? Vanilla code is much lighter and easier to maintain, and thus substantially less tech debt. Mountains of abstractions to mask fear and insecurity of the technologies is the very definition of tech debt. &gt; Also, all of this is code that you end up needing to maintain and document. This stuff, the jQuery comparable code, is pointlessly simple. You need to step out of crud application madness and write real application code. &gt; Nobody needs to be coached on how to use jQuery's AJAX function I wrote a cross-browser vanilla AJAX abstraction for a coworker yesterday. It did both get and push and it was less than 20 lines of code. &gt; If you're setting out to bake apple pie, you generally don't plant a tree and wait until it bears fruit. jQuery is the giant apple tree plus apple orchard. Baking an apple pie is easy. --- Look I get it. You are afraid of the technology and **NEED** jQuery. I highly doubt it is only a matter of convenience. If you would just say that up front I wouldn't have a problem with jQuery, but most of the incompetent people I run into need to lie about it and play the imposter syndrome game with a bunch of bullshit excuses. When I run into people like this in the real world I intentionally make abstractions like jQuery an anti-pattern of the current project. You can be sad about how mean I am and down vote me. Honestly though, you should do yourself the favor of actually learning these skills.
Ah, I see. I never would have guessed this, or even happened across this because I'm using Chrome. My initial thought was "well duh, it's 1" because of the grammar, but then I remembered that the XML-like comment syntax exists. Good one, but I am admittedly annoyed. ;)
I think it's absolutely horrifying that (most) of his audience is (apparently) unaware of this (very basic) stuff.
Well your post wasn't relevant either so... welcome to the club? Programming is giving a machine instructions. The machine doesn't care if your professional or just an amateur. There aren't any choices here. Either you understand how to tell it to do stuff or you don't. I don't understand what the argument against that could possibly be.
Well your post wasn't relevant either so... welcome to the club? Programming is giving a machine instructions. The machine doesn't care if your professional or just an amateur. There aren't any choices here. Either you understand how to tell it to do stuff or you don't. I don't understand what the argument against that could possibly be.
Well your post wasn't relevant either so... welcome to the club? Programming is giving a machine instructions. The machine doesn't care if your professional or just an amateur. There aren't any choices here. Either you understand how to tell it to do stuff or you don't. I don't understand what the argument against that could possibly be.
I think you're conflating what I said with what others in this thread have said. Because my line of thinking clearly stays on a specific topic. Lol it's ok, this has become a waste of time - I'm soon going to delete my messages, anyway.
It is always better to have the least amount of elements on the page as possible. This is why there are all sorts of tricks to handle infinite lists on the web. When it comes to custom elements and fractal data such as comments you should run into the same issue of handling many elements on a page but the elements may be a bit heavier. For examples I'd recommend you take a look at Youtube comment sections (bleeding eyes I know but I mean the code not the content) or the chrome history page (eyes may be bleeding for other reasons there)
Interesting talk. What about, say, text inputs? Must you then define an infinite number of possible transitions? It's a pretty fundamental use case, but it never came up.
Your bias against bootcamp grads is incredible lol. No hard evidence given but just a few anecdote of conversations with "people" you know. You are the type of guy that use peoples software but would pass on the guy who authored home brew because he can't invert a binary tree. post for reference: https://twitter.com/mxcl/status/608682016205344768?lang=en
Says no one who ever knew what he was talking about.
As MyWorkThrowaway_ said, custom elements may be heavier depending on the complexity of your component. A component such as a comment that could contains other comments doesn't need a lot of complexity(only having to render some custom text and register events on some buttons) and should be almost as fast as adding any other element. Again, like MyWorkThrowaway_ said, there's good practices for everything that makes everything better. On my screenshoot, i show customs elements added with a shadowRoot as only child and the component template/style in it. I just wanted to show that my framework allowed style and content to be independant of the rest of the page, the shadowRoot has a cost of creation, and shouldn't always be used on all of the components. For example with the comment custom component, having to create a shadowRoot for each comments would be an useless overhead. About the data selection/lenses i'm not sure about what you're asking, but i'll just explain how the reactive system work. You have to call reactify to create a reactive object, that object or the properties of the object can be watched by a function, e.g. reactiveObject.$watch((newValue, oldValue) =&gt; {...}) // will be called at each property change reactiveObject.$watch(_ =&gt; { return reactiveObject.a + reactiveObject.b },(newValue, oldValue) =&gt; {...}) // will be called at a &amp; b changes Any object set into a reactive object is automatically transformed into a reactive object(same for arrays) I also intend to implement a memoization system for getters that are into a reactiveObject, that will cache the returned data if their dependencies changed (exactly like a vuejs computed property) I'm not sure if i answered your questions but if you have other questions i'm all for it
You're conflating my bias with my reporting of what I've seen happen. Just driving home my point, really. I hope you can use some of the advice in the thread!
The main difference I see is that it introduces transitions. Redux (or similar functional state handling) doesn't have a declarative way to put restrictions on how the state transitions, which seems like a key part to what he's referring to with a finite state machine. This is the first time I've dug into finite state machines, but at first glance the concept really clicks, and it seems like a clean way to organize the business for transitioning between states. Right now I am using Redux and really the only way it enforces certain "broken" states from happening is that they should be programmatically impossible (which is hard to test, and hard to reason about as it grows). &gt; Just because he creates a crappy state data model that allows for a lot of invalid combinations What do you use for your state data modeling? Are you using Redux?
Right. Before v3, Xterm.js actually [skipped some frame](https://github.com/sourcelair/xterm.js/blob/c6d4c73c8a8c23ce102918fc0342cf33d2986711/src/Renderer.ts#L67-L102) to reduce refresh rate.
Re: data selection/lenses, what I mean is, for example, how does one go about deleting an arbitrarily nested comment. My comment re: scaling was more about the structure of the repaint cycle. It used to be the case that Vue was not very good at recursive rendering, so I was wondering if there was some thought put into recursiveness+repaints.
I don't mind him sharing his approach or even comparing it versus Redux or other approaches, it's just really weird for him to mention Finite State Machine/Automata in this context, it's just so orthogonal/irrelevant. FSAs are usually discussed in the context of algorithms, not as a way of organizing data. He's kinda pulling together a mixture of ideas from flow charts and the __implementations__ of FSAs and talks about it as a tool for organization of code. Like it just is not what people talk about when they are discussing FSAs. It'd be like if I said "thinking like Einstein's General Theory of Relativity" when I just mean "basic differential equations." It's just weird.
Cars aren't frameworks. Their frames and transaxles are. Cars are finished products. People using poor analogies to justify abstractions gets really old.
&gt; Also, Jquery isn't a framework. Maybe not in the technical sense. But you wouldn't believe how many bootcampers I've seen who are literally incapable of writing a for/for..of loop without $.each(). For them, JQuery *is* the language. 
Not all bootcamps are bad. For example, we had to write a backend with just node before being allowed to use express. Same with vanilla he in the front end. Unfortunately the industry got crowded and the quality went way down. I saw it when I briefly worked for the same one I attended. 
About deleting an arbitrarily nested comment, since the reactivity uses proxies and the deleteProperty handler, deleting an arbitrarily nested comment would look like any native way to remove some data from an object let comment = reactify({ comments: [ { comments: [ { comments: [] } ] } ] }) let subComment = comment.comments[0] subComment.comments.splice(0, 1) // or subComment.comments = [] // or delete subComment.comments // not recommended since it changes the object hiddenClass About the repaint cycles i intend to look into differs to reduce the operations done on the dom after a component update, so for now i don't have anything about optimising recursive rendering/repaint cycle but i intend to add something about it
Thank you so much, I really appreciate the suggestions, and know you are right. Sometimes you just need someone to set you on the right road... I just find it so easy to get caught in a crippling loop of indecision wondering what is expected! I'll plan out a couple of projects this weekend to get started, and finding resources to help with interviews is like the most 'duh' thing ever, didn't even occur to me! Would be amazing to find a way to practice without all the panic! 
https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API Specifically the storage event section Used this method once for something similar, but its beem a few years.
I don’t think programming IS minutia at all. Minutia is just that, minutia. Point taken that it’s an important skill , but I just think it doesn’t need to happen upfront . Programming to me is more about elegantly describing logic than minutia. People get frustrated if they hit a wall. Learning is more impactful when progress is made through conquerable steps. 
Take a look at https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
While Dan doesn't name any specific tools in there (and deliberately so), this is directly applicable to build tools like Webpack (a Javascript bundler), Babel (a Javascript compiler), ESLint (a Javascript code style checker), and other similar tools. A lot of Dan's points there are based off his experience working on the [Create-React-App](https://github.com/facebookincubator/create-react-app) CLI tool, which wraps up Webpack/Babel/ESLint so that developers can start React projects without having to set up those tools by hand first.
I wouldn't exactly say it's "different than what Redux" does. First, to a large extent, a reducer can be seen as a limited state machine. Given a current state and an action, it transitions to a new state as a result. Second, while we do encourage splitting up the overall app state and reducer logic based on "slices", the actual implementation of the root reducer function is entirely up to you. You could certainly have a purely state-machine-based root reducer function that deals with the entire state tree at once, if you wanted to.
For what it's worth, how you build your reducer logic is entirely up to you. If you want to build it out of explicit state machine behavior, you can definitely do that. In fact, there's [several Redux addon libraries for writing reducers specifically as state machines](https://github.com/markerikson/redux-ecosystem-links/blob/master/reducers.md#state-machines).
https://xkcd.com/1053/
Hey OP here -- I wrote about this a while ago (back when I was using mocha), but a recent update prompted some changes to the underlying code so I thought I'd share -- this is what I use to run integration tests for my frontend projects
[removed]
i am sure theres a npm package, but domains share Indexed db and local atorage so a rudimentary app pulling up known keys would suffice
I totally get this comment buuuuut, like anything new, it takes some to learn how to "read" stuff. FP is a mind bender​ at first but it eventually clicks if you stick with it.
Lol. You are exactly the kind of person who winds up creating code bases that are a pain in the ass to maintain. Your bit about a vanilla AJAX abstraction pretty much proves that - if you are so unafraid about "not being in 1996", why not just use "fetch", which is a "vanilla JS" AJAX abstraction available in literally every modern browser? Your "20 line AJAX abstraction" was not only pointless reinvention, it likely lacks a lot of the features that jQuery.ajax or fetch offers. You can feel smug about "beating jQuery in performance" or what not, but in reality, your function very likely does not offer the same feature set that jQuery does. And when you do need some of those features, you then need to implement and maintain them. **That's** the very definition of technical debt. And unless your web application is doing something silly, the "jQuery has bad performance!" argument is pretty lame. Your user doesn't care if your function can query for 3000 elements per second or 100,000 elements per second - if (and only if) your web application has a *genuine* need for the latter kind of performance is this discussion even relevant. Tell me, how often do you think your "20 line AJAX abstraction" is going to make a difference in terms of performance? Lol. Look, I get it. You need to reinvent the wheel to make yourself feel clever - I've met plenty of people like that, and I've even been that very person before depending on the project. But if many of us don't want to spend the extra time recreating something that already exists before we even *start* coding whatever it is our bosses are requesting us to build. And I haven't even downvoted you once either - I don't give two hoots about Reddit points. Hell, I don't even use jQuery in my personal projects. Vue/React abstract all the repainting for me, which leaves me free to spend time on application logic instead of doing manual labour for the browser. 
I dont disagree, but I'm familiar enough with the concepts and use some daily. This code is just obtuse and unreadable. At the very least things like lambdas returning lambdas could instead use named lambdas to at least clarify what their purpose is.