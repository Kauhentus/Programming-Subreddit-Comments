Really nice seeing fractal flames done in js with nice clean code.
What is different?
You can't just throw money at an engineering team and get a new product overnight. You also can't sue a company as large as Facebook and get a settlement immediately. This could be a disaster for a company reliant upon React.
Which ones would you prefer to use instead? 
What is the actual patent for? You cannot patent "react", you are placing a patent on some mechanism. So, what is that mechanism? And how is that different from Vue/Preact/etc?
&gt; if you worried about licensing, then it will offer you no change. Preact uses a MIT license so why do you say that ?
While I agree that people will do clean-room React implementations (which has already been done, re: Preact, Inferno) and other various competing libraries (Deku, vdom) and frameworks (Ng, Vue), React will still be used. It might lose some popularity, but not all of it.
Amazon uses React. 😊 
If React actually had any patents which apply to React, it would be a patent on the virtual DOM. However, they don't have such a patent.
We're using it for m.uber.com for perf reasons (i.e. we specifically want to support mobile users with not-so-new phones and slow connections in emerging markets). We spent a lot of effort into optimizing for size. The whole js weighs in at about 50kb min/gzip, and I'd say the Preact part of things is fairly straightforward compared to all the work that went into messing w/ source-map-explorer, babel-runtime, utility libraries, service workers, etc. There was also quite a bit of work put into frameworky things like universal rendering and code splitting. When we talk about apps, there's a lot more to perf than just runtime perf. There were a few minor differences from React (e.g. workaround for lack of componentDidCatch-like feature), which makes it not quite a drop-in replacement, but nothing that really became a showstopper.
Preact is faster than the current react 
You can join the preact slack https://preact-slack.now.sh The people there can answer your questions and help with migration if you do want to The preact cli is also really nice and worth checking out imo
I work for a large fortune 300 company. They asked us to use React. Both our and client legal people said no issues in the patent clause
I disagree. Preact is subject to the same problems that fibre was built to resolve.
On the flip side, I work for a fortune 100 manufacturing company and was specifically hired to help steer their Angular 1.x team on the complete rewrite of their whole web presence in React. This company is pretty anal about going through legal on all their software usage too.
Could you please elaborate on the real world benefits you have noticed with Fiber? Would this be "the same problems" you are referring to? &gt; React doesn't currently take advantage of scheduling in a significant way; an update results in the entire subtree being re-rendered immediately. Overhauling React's core algorithm to take advantage of scheduling is the driving idea behind Fiber. [1] I have not tried Fiber yet and you seem to be familiar with it, I would appreciate your insight. [1] https://github.com/acdlite/react-fiber-architecture
to a lawyer it would be "don't be cute" evilness
These already exist: Inferno, Preact, etc.
"load" is fired when *everything* is loaded (including CSS files, images etc), while "DOMContentLoaded" fires when the DOM structure is ready.
So do Microsoft and Airbnb. It's not unimaginable that companies of that size have made a separate license deal with Facebook. But yeah, that makes my "fracturing open source" argument weaker.
I mean it's still awful. Just in a better way. 
Amazon (and Microsoft, AirBnb, Netflix, etc) uses React under the same license+clause as everyone else.
How do you know?
I work a lot with large data sets. When data is dynamically updated it will re-render a visualisation but if the user is interacting with the page, their actions would be blocked. Fibre handles these types of operations for effectively.
They already put Stories into all of their relevant products, openly copying Snapchat (although probably not infringing on any patents). I don't think they care about appearance at all.
The JSON license is on that list. It has nothing to do with using the JSON format
I really don't see them as interchangeable. 
That was in the context of other modules, while I use preact, I still require react installed in my stack as it is a hard dependency on other modules. So while in many cases you can easily get around, you not always going to find 1 to 1 replacement for react modules for preact, so if using those , the assumption is there is a reason for it and facebook license will cover all its code, so even using it indirectly will at least partially keep you bound to that agreement. Using preact does not guarantee a solid separation from react, while something like Vue will.
It's really not. 
How is it a weapon, exactly?
This is my same problem. react-mdl seems a bit more stable and after looking under the hood it's much cleaner that MUI. There is also the wrapper for Google's Material Components that is gaining traction. The best thing to happen would be if Facebook made an extensible component library for react with little opinion on how to style the components.
Nah. In reality Facebook.is doing what they were edpect d to do by many. Their technologies are the foundation for the companies future. 
Yeah, even if one was to stop using React they would probably go for Preact or Inferno instead.
So you are saying that your company can't use JSON? 
If they could relicense RocksDB (which [is a Facebook project] (https://github.com/facebook/rocksdb/)) why couldn't them relicense React? This is bullshit.
The trouble is that Facebook's patents probably will cover this React-like too.
I really wish pugjs took off...
No, I'm not one of the higher ups that ran it by legal. 
Exactly. It's already started but, somehow, Facebook will find a way to bring them down with lawsuits.
Using `shouldUpdateComponent` also solves those problems. 
Obviously legal departments are staffed with humans who interpret things differently. Perhaps my company's legal history is different than yours which changes their outlook. 
Is it still faster compared to React 16 with Fiber though?
Vue 2 is worth upgrading to!!
Oh I get it. Thanks for the explanation.
No idea, be worth testing it out... I think for most applications it's going to be fast enough though. Like unless you're displaying thousands of react elements on the screen will a few ms here or there matter? :p
It is like a gun under a pillow
How?
They might have just said "this is different, let's just avoid it to make things easier"
Firefox lets you read files via file:/// if you use XHR. Chrome doesn't. Neither lets you use fetch. E.g. this works in Firefox but not Chrome: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;lf&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; function httpRequest(path) { return new Promise((resolve, reject) =&gt; { let xhr = new XMLHttpRequest(); xhr.responseType = 'text'; xhr.onload = () =&gt; resolve(xhr.response); xhr.onerror = e =&gt; reject(e); xhr.open('GET', path); xhr.send(null); }); } (async function main() { let text = await httpRequest('file.txt'); document.querySelector('div').innerText = text.toUpperCase(); })(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
I use to work at one of the 6 billion major insurance companies in Connecticut, and knew quite a few people in a few different companies up there. Every single one wasn't allowed to use react for projects. I know where I worked it was pretty much known if you aren't using a fairly well known and standard license they will just deny the use, regardless of what the differences are.
What makes you say that? Facebook hasn't to my knowledge ever been in the business of taking down competing open source projects via litigation... It's not in their interest to do so.
&gt; The Software shall be used for Good, not Evil. [is part of the JSON license](http://www.json.org/license.html)
Much better now, instead of choosing between jquery or vanila(I always chose this), now we have to choose react/angular/vue/knockout/mithrel/riot/meteor/ember/aurelia... and we want to fit everything on one page so we need flux/redux/rxjs/mobx/... and we also can not do simple task ourselves, we need leftpad(oops)/lodash/moment... and we take every imaginable shortcut to write code that does not run out of the box so we need babel/bubel/typescript/coffeescript/dart... and we compile it to something that still does not run so we need webpack/browserify/grunt/gulp/rollup... and then we need to figure out with those how to resolve commonjs/amd/umd/import conflicts, and we need a cli that generates 3 pages of scrolling node_modules just to get out of the A's and we can't style things so we need sass/less/stylus... oh but wait, there is a flood of js libraries to do css now, and now we are encouraged to do everything in functional programming so we can no longer set meaningful breakpoints to troubleshoot, but that is ok, functional programming does not ever have bugs, and since the code that runs is not the code we have written, we have to load sourcemaps for breakpoints to be meaningful, or maybe we should not do functional, now, we have classes so maybe we should use those, and we build everything with bootstrap so we might as well mix in jquery with our other framework way of doing things, it is there anyway.
Brian is on the React core team at Facebook.
I believe the difference is that the extra patent clause on the Facebook license is likely enforceable, whereas that clause in the JSON license is not.
I think it's `shouldComponentUpdate`
If crockford's implementation of JSON was the only one available, I imagine it could have been an issue.
you may find my response to the same sentiment amusing: https://news.ycombinator.com/item?id=14697408 context: https://news.ycombinator.com/item?id=14695268
Did you read the link?
Definitely go with the JS team. Salesforce may be hot today but who knows in five years. Try to broaden your competence as much as possible. If you get to choose between something you know and something to learn, pick the latter.
As someone who came from ruby and rails and loathes the front end because his design skills - I love vue - and yes it was very easy to pick up even with minimal JS skills (though components are a bit more complicated and kind of vital) 
Cute phrasing, but legally, I mean 'evil' is a pretty vague term when it comes to legitimate business
You won't even get syntax-highlighting inside comments. // @t "calls util" myOtherFunctionWhichCallsUtil(spy('util')) ~expect spy('util').calledOnce That example already exceeds the 80 col limit with 91 chars.
Yes. 
Ahh, thanks! Is there a downside to using the "load"? Maybe the user will try to interact with the page before the JS fires? I'm wondering if I need to change my code.
Hey peeps! Just a quick note on what the project is about: I wanted to develop an accessible framework for music visualiser development for a while now, and recently I saw that Web Audio API and WebGL are becoming more and more commonplace. Akko is based on these 2 technologies and essentially it lets you write music visualiser in JavaScript without worrying about audio playback, controls, UI and so on. You can also save your visualiser as a JS file and share it for others to use - in fact I'm hoping that one of you will make some cool visualisers I could use as one of Akko's demos. This project is still in its early development phase so there are likely to be some bugs.
Go with javascript. If you learn Salesforce, you can only do Salesforce. If you learn javascript, you can do so many things.
The F500 company that I used to work for basically took the approach of "if we have to look into it at all then the answer is just no instead."
It's unclear if the license also applies to the virtual-dom diffing concept which would include all react-like products.
Not always... If you've actually got a lot of rendering changes being able to drop frames or defer work to the next frame like you can with fiber is crucial. 
Just FYI, async rendering (fiber) is not currently enabled in react 16 beta but should be pretty soon.
&gt; I even had our tester and PM making changes to the Vue templates And you didn't run in fear?!?!
A scheduled job and save it in a database would probably be the best and most scalabe solution, you could build a service which would be responsible for the job + database record insertions. And your "regular"/current app talking to the database. And yes, you would probably need some sort of caching, but that could be a part of the job/db service, to cache up db-views or just memcache. 
Well everyone, time to fork.
... is the spread operator. https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator
Half-Life 3. Enjoy. (Tiddies) ^^Have ^^a ^^nice ^^day ^^by ^^the ^^way.
Jinx! You and Natirs6 posted the same comment at the same time! See their comment [here](https://www.reddit.com/comments/6uqz6d/_/dlupyrm). --- I am a bot who is owed many Cokes.
Maybe all in web assembly anyways, who knows
Safe to use provided you're not doing anything exotic with React. Generally found it's a seamless drop in replacement for most SPAs. 
Forking it doesn't magically make the license go away. It needs the be rewritten - see Vue.js https://github.com/vuejs/vue
But but but we can't circle jerk about things getting _better_! 
Oh no, you mean you have _choices_?!?! God, that must be so terrible to have choices and different solutions to different needs! God, I'm so sorry, that must be awful. I know, i know, change is _sooooo_ scary. 
The forks being discussed are prior to the patent restriction being put in place. That would indeed make the patent portion go away (which is the part everyone is concerned about).
Awesome! Web Audio has been fascinating to me since I discovered it. Definitely checking this out!
Considering this is the JS board of reddit, I'm not sure you're going to get stellar, shining recommendations for salesforce. However, I do have to agree with the current, other two replies. JS is installing rockets under itself, and the demand rise for competent JS devs is ever-present. You wanted JS. Go embrace JS, and on the side - as I'm fairly sure your company fosters contribution as a valid, and neat way of getting recognized, do salesforce, if you can. (I'm no wizard or expert, but salesforce doesn't seem to be... surging?)
A very strong reason would be to be self-contained, not relying on third-party whims. With Typescript and Flow, you don't have that. Extra loops to jump through. Remembering jQuery, most people are now adopting, embracing the "Vanilla JS" mindset.
JS team. Also, check this out https://auth0.com/blog/extend-salesforce-with-node/
I don't understand why people are jumping to projects like Preact to get away from potential patent issues when in any reality, if you're affected by a patent on React it will very likely also affect Preact, etc.
Oh wow. Who could have seen that coming? /totalmonotone
You're expecting to match several distinct flavors of functions to the same, simple true. isFunction is a simple question: It may be - Regular - Constructed - Async - Arrow - Generator - Object?! Object: If you're using a function as an object, you're doing obfuscation by design. If you're attempting to use an actual object as a function, you're going to have a dad time. It's not exactly distinct sets, they overlap and have semantics that might not mean the same to dev X and Y. X would say all are true, Y would say Object is false, Z would say Arrows are not Functions in the classical sense. &gt;Wouldn't hurt if it was also intuitive On the surface level, JS is innocent and intuitive enough. Getting into the deep end, well, that's another thing. &gt;null pretending to be an object NaN vs Number.NaN, etc. The reason these libs, frameworks and tools keep popping up is because there's not always a clear, distinct, and spec-confoming concrete answer. For example, how a simple anything - a variable, is defined. What is undefined to you? undefined only? Undefined and null? Are there varying levels of acceptance?
That's not really an option if they have any related patents. The only good option as far as I can tell would be to fork off version 11.2 (the last version using Apache) so you keep their patent grant.
Version 11.2 and before was licensed under Apache and has a sane patent grant.
Whoa that's awesome 
I posted to a few boards to see what kind of feedback I could get. But I think people here are right as maybe salesforce is too specialized and JavaScript is more diverse, that going to the JavaScript team is the right call. 
True, that was definitely one of my hesitancies about salesforce. I think I'll do the JavaScript team. I like having more options. 
Are you claiming the spec has the patent or the reference implementation GraphQL-js is patented? 
About it being Right right, I don't know. It feels like a confident and reasonable choice. I'm none too familiar with salesforce, so that also has to do with my reasoning. But, if it's down to a gut feeling, I'd go with my dreams and go for JS.
The issue is that if Facebook infringes YOUR patents and you sue you can't use react anymore
Interesting! Will take a look at that. 
One reason I why I wanted something like this is because I really like TDD. I'd think, I'd need a function definition in my head like: foo(123) == bar or getUser(123) calls http.get with 123 Now with saul, I can quickly annotate my function with it: // @t "foo" foo(123) ~equals 'bar' and // @t "getUser" getUser(123, spy('http')) ~expect spy('http').calledOnce I hope you find it useful. And I'd be keen if there's something better that can be done to make it meet your use-case.
ding ding ding
Agreed. Unfortunately, that's one of the tradeoffs I've had to make. You can always break your tests into multiple lines: // @t "calls util" myOtherFunctionWhichCallsUtil(spy('util')) ~expect spy('util').calledOnce // @t "calls util" myOtherFunctionWhichCallsUtil(spy('util')) ~expect expect(spy('util').args[0]).to.equal(['foo'])
Apollo servercand client have graphql.js as a dependeny, so using it instead doesn't change a thing to avoid the patent clause.
Microbenchmarks do not reflect performance. Fiber will perform much faster because it can occlude and prioritize components. Even if Preact is 0.000001 times faster replacing 100.000 rows, Fiber knows that actually only a hand full are visible atm and the rest gets lowest priority to maintain a stable framerate for components that need it. Until Preact rewrites it's scheduler, the difference will more or less be similar to that of a web app and a native app.
GPL usage within the JavaScript community is very low. Most npm packages use licences like MIT. It also wouldn't surprise me if Facebook's internal policies prohibited including dependencies with copy-left licences like GPL.
React 16 isn't shipping with fibre
Didn't say it was faster than fiber. Also rewriting fiber would make it way harder to keep it small
Isn't fibre in react 16 beta and up?
 a.sort((a, b) =&gt; { let v = a.name.localeCompare(b.name); if (v) { return v; } return a.account.localeCompare(b.account); });
They've actually just hired the developers on those projects (at least infernos lead) to work on React
I didn't think getting banned from being included in any and all Apache licensed projects was in their best interest...
Savvy? "I've got a patent case against Facebook worth $20+ million dollars, but we'll have to stop using React" A savvy client is going to realize that even in the remote circumstance where they find themselves in this situation, they can move their patents to a shell and keep enjoying the salad days of delicious React UIs. At the *worst* React gets replaced, which is a tiny expense compared to the windfall their sweet sweet patent suit will bring. 
They do? On what pieces of their infrastructure. They used some crappy jQuery templating language for their prime music streaming platform.
Sales force may already be on the way out. See this article https://www.linkedin.com/pulse/microsoft-overtakes-salesforcecom-forrester-wynand-roos
On console.aws.amazon.com
is this the end of react? /gets popcorn
It's like a chainsaw in your garage
JS. If you learn Salesforce you'll be pigeon holing yourself to enterprise.
^
Using it as a weapon? Their license has been the same for years and they've never used it against anyone. What are you even talking about? Apache is the one that initiated this situation out of left field, how can you possibly twist this into Facebook using React as a weapon?
I'm not sure your assumptions are entirely correct. Many of us don't use Apache and thus don't care what Apache says about licenses. Given that there is nothing wrong with the React license, most projects will continue on using React and ignore Apache. Others will decide that React is more valuable that Apache and will abandon Apache in order to keep React. Still others will decide Apache is more valuable than React and abandon React in order to keep Apache. There are already React alternatives, many projects are already using them. TLDR: this isn't going to have any profound, history altering impact. Life will continue on, React will continue on, some people will use it and other people won't.
I dunno, patent issues are tricky. If they don't defend their patent then they can lose the right to. But it also can be to just firmly establish prior art to prevent anyone else from patenting it. Or they start aggressively prosecuting their patent all of a sudden. So 2 out of 3 things that I can think of are actually good reasons. Meh, YMMV. 
I don't really agree with this (the if you do Salesforce, you can only do Salesforce). At least on the developer side. It's entirely a true statement from the admin side. I am a Salesforce Developer. Apex, Salesforce development language, is a lot like C# or Java. (I believe it's SF proprietary version of Java.) At one point, I switched to JS and PHP for about a six month period, and the transition wasn't all that complicated. Yes I had to pickup the nuances of JS and PHP, but I didn't find it overly difficult to do. Then I got another job as a Salesforce Developer and picked right back up with Apex. It's very possible to move away from Salesforce to something else if you want. One thing I do want to add, is even if I am not actively developing in JS, I am constantly reading up on it, and fooling around with it's features so I can stay current on at least the core language. Picking up libraries or frameworks when you need to isn't overly complicated if you got your coding fundamentals down. Salesforce VisualForce and Lightning (front end) also support JS, and using it for custom SF pages. The big question you need to ask yourself then, is what to 'you' want to do? Do you want to be a JS developer? Do JS. No? Salesforce. Or something else you're more interested in. One big perk of JS I can think of, no certs. Salesforce certs have the initial cost to get it, and the maintenance fees. I'm literally just going to get the certs I need/want (admin 1, dev 1, dev 2, maybe another dev one) and call it good. JS; if you have some good projects to show when needed, and know your stuff, that's usually enough. Salesforce you need those plus certs, though sometimes you can get away with not having then. Especially at more senior capability levels. At the moment I'm learning Go and dotnet core, and plan to switch to C# or JS if/when Salesforce dies, or I just want to move on. Or some other language that may pick up in popularity over the next few years. Education is the key to not being locked in. My long term plan is to be capable of doing full stack development in JS, C#, Go, and specializing in back-end development. Edit: stuff
This is neat, thanks!
Lots and lots of people have tried Vue.js.
Yeah, [I'd wager](http://i.imgur.com/ciRDjPd.png) [a few](https://github.com/vuejs/vue/stargazers) [people](https://github.com/vuejs/vue/watchers) [have used](https://github.com/vuejs/vue#supporting-vuejs) [vue](https://vuejs.org/).
Facebook’s BSD+Patents License and how it affects your company or side-project (GraphQL, React, Relay, React Native) https://medium.com/@gdi2290/facebooks-bsd-patents-license-and-how-it-affects-you-66088e052845
I take it back downvote the dude in this thread. I PMed him this: &gt; "Minor nit. Lots of JS devs don't have balls, either from birth (female) or cancer (removal)." And apparently he's into some MRA stuff, refused to edit the comment and doubled down on toxic masculine BS instead. Edit: formatting
You don't want your debounced function to be an arrow function because you're losing method context in the call. You want it to be a normal function so it can bind to the object its getting called from or otherwise have its context set in situations where that occurs (such as in event handlers). const debounce = (fn, time) =&gt; { let timeout; return function (...args) { // &lt;-- not an arrow function const functionCall = () =&gt; fn.apply(this, args); clearTimeout(timeout); timeout = setTimeout(functionCall, time); } } const obj = { name: 'foo', sayMyName() { console.log('My name is', this.name) } } obj.sayMyName() //-&gt; My name is foo obj.sayMyName = debounce(obj.sayMyName, 1000) obj.sayMyName() //-&gt; My name is foo &lt;-- allows correct this binding or in the event handler case // &lt;input name="my-input" /&gt; input.addEventListener('keyup', debounce(function (e) { // &lt;-- allows handler element binding console.log('Element name is', this.name); //-&gt; Element name is my-input }, 1000)); Also, the comment `// no 'arguments' variable in es6` isn't entirely accurate. Its arrow functions, not es6 that lacks the `arguments` object (they can still access an `arguments`, though it'll be from the closest non-arrow function parent). This is explained correctly in the Explanation section. It's only the comment itself that is misleading.
Wrong. The Apache Foundation said *none of their own projects* are allowed to use tools with that particular license, which includes React, but that ruling only applies to the ASF. The Apache license and FB BSD+PATENTS are not incompatible, per Facebook's post. 
Damn, thanks for this. I'm definitely thinking I'm going to stick with JavaScript now reading these replies unless they force me into the salesforce. 
Same. Did a project in one of each and was in love with vue by the end of both projects.
I'm guessing this is a troll post? I have you tagged as `hardcore vue fanboy`, so I have a hard time taking you seriously. I'm assuming you just made this post with the intention of adding fuel to the flame.
Can someone ban /u/shad0proxy from /r/javascript?
"Netflix had their lawyers look at it and they feel there is no issue for them" statements like that can be terribly misleading as Netflix can have some other agreement with FB.
I built a product in Preact because my script is ran on customer's sites and I wanted it to be as small as possible. It works as expected.
Vue is is one man project. That brings different kind of risks. Given vues popularity this is really surprising. Is there an explanation for this?
lol... people on reddit are completely fucked. This whiny safe space child PM'd me asking me to remove my part about the "no balls, you won't because it was "sexist". If you don't understand a joke, and you think everything is sexist, go cry in a corner. That's all I have to say about that. People who downvote without explanation are toxic and if it wasn't for my bit about the "no balls, you won't", half of those downvotes wouldn't have reversed. Not that I care or anything. Also, I don't like people who quote things out of context, especially from private messages without permission. So, here's the full exchange for anyone who is interested: https://ibb.co/dHYLBk In a nutshell, I was told to remove a "sexist" comment, which I would counter by saying, "it's not sexist, it's a popular joke" and now I'm being accused of being into MRA shit, which is hilariously untrue. Kid, you're a bad social justice warrior. Get out of here. Blocked.
My company's lawyers also advised against it. They said that the patent rider could be cited as a risk during an IPO or acquisition and this affect valuation.
"However, the AES obfuscation this site employs isn't for hiding the code from users. It is for avoiding automated reputation crawlers and site security systems that scan webpages for suspicious content and alert providers when questionable activities are taking place." So if I were to use any other cryptography algorithm it could also be used to avoid reputation crawlers nowadays? Would using multiple algorithms keep it hidden even longer?
Thank you for the feedback! I updated the article with the correct returned function
Traditionally obfuscation has come in the form of B64 encoded variables or simple XOR routines. For the most part, using anything other than simple eval statements will throw off reputation scanners because they're not configured to dynamically evaluate these expressions. These scanners are becoming more and more aware of these techniques and if you were to scan this particular website (if it hasn't been taken down yet) I'm willing to bet quite a few reputation scanners pick it up. But, this technique certainly helps hide for just a little bit longer and sometimes that's all the bad guy needs. Hope this helps :)
[removed]
The fact that they even included the patents clause in the first place is very telling. 
Telling of what? That they've had issues with patent trolls and want to protect themselves from it?
I think you have confused Apache the web server software with the Apache Foundation who are the body that hosts that and lots of other software. Maybe your wording was just unclear. 
The guy who created infernojs actually joined the react team to build out react fiber I believe.
&gt; That's really interesting that you mention that your companies lawyers advised you to not use React. Not as much as it might seem. My job entails working closely with compliance teams and the lawyers they rely on, and experience has taught me that "No you can't do that" could mean "It's not legal" or "I'm not sure, just don't do it, just in case". I've personally sat on calls between lawyers with differing interpretations of the same situation. It's eye opening to see how dynamic these decisions can be.
I've never heard of involving lawyers to preapprove libraries, that's insane but "understandable." Hopefully they won't preapprove code that developers can copy and modify. That'll be a cluster.
Why only full stack? :D
No you're right I was conflating the two. I should have said ASF software instead of just Apache.
That's great to know, thanks!
From what I can tell if you sue Facebook for infringing on your patents they'll revoke your patent license for React (not the BSD one). You can still use React under BSD, but you're now open to getting sued over the patents. If Preact is also affected by the patents then they wouldn't need to revoke anything, you were always open to getting sued over the patents. So you wouldn't be able to use Preact either, or any other library that's affected by Facebook's patents.
I also loved: &gt;If Facebook offers an online streaming service then maybe Netflix will change their stance on the License but... Oh you mean like the [one they announced a week ago](https://techcrunch.com/2017/08/09/facebook-watch/)? The thing I hate about medium is that it seems like every dev and their grandma has an opinion on everything, even though they know nothing about the subject and don't even research the latest details of what they're writing about. Kudos to this author for at least prefacing the post with "I'm not a lawyer" because that already makes him better than most people writing on medium. 
Wish this had Bitbucket/Jira integration, would help me more for work.
As someone who has to do apex, php, and JavaScript (and sometimes, like Wednesday, I work on them in the same day), this is a great answer. Apex is basically java. When I initially got asked to update some apex code, I actually learned java because there are a lot more resources available. There are differences, but it's pretty close. Like /u/Pokemon-Master-RED said, it really comes down to what you want to do and just don't stop learning. On a daily basis, I use php for backend work and I am using a lot more JavaScript recently (one site I maintain now has an independent front end built on vue which is a huge step from some jquery here and there...) and I do some apex here and there but besides that, I build stuff in my off hours in python, do some swift iOS app stuff, I've done some android (java) stuff (soon going to learn kotlin) and have done some basic ruby, go and c++ just for fun. The point is, never stop expanding regardless of what you choose. If you choose the JavaScript route, maybe jump in and help the apex team or vis a versa. 
Hasn't this been a thing for a while? Why the sudden drama?
Is it like a hot Pocket in the microwave?
So based on another thread. Someone working on a core part of react said that Microsoft/Amazon/ect aren't using a different license but rather use the same license that everyone uses https://www.reddit.com/r/javascript/comments/6un0bs/facebook_says_no_to_license_change_request_from/dluenx4/
[removed]
Haha, it actually worked pretty well. I ended up splitting the HTML, styles and script into separate files. Split out the validation rules. And overall just tried to keep all the code well documented. Our tester and PM jumped in and ended up tweaking the form rules to match our requirements. No issues. :)
Sometimes it's the best way to test out different frameworks. Did the same recently for a hybrid mobile app. Built a Ionic 2 and React Native app. Ran the other devs through both.
Because Apache foundation's announcement (it says so in the article)
It's great to live in a country where software can't be patented.
Yes, he said earlier: &gt; haha. exactly my thoughts. **react is like an ugly version of vue**. or vue is a simpler, prettier version of react. however you want to look at it, vue all the way. I'm not really appreciative of professional trolling. 
I meant that sarcastically. Sorry, my bad.
Because they closed an issue on the react github issue tracker saying they will not be changing the license.
Have you read this? It's the most realistic breakdown of how this license plays out in the real world. It's where I bit my snarky reply from ;) https://medium.com/@dwalsh.sdlr/react-facebook-and-the-revokable-patent-license-why-its-a-paper-25c40c50b562
Just use setInterval &gt; var intervalID = window.setInterval(myCallback, 500); &gt; function myCallback() { // Your code here } From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval I use Axios for fetching
Salesforce work doesn't preclude javascript, Lightning is a thing and since all of the new features in the developer platform are targeting it you have little choice but to learn JavaScript to use them.
All this does is affect a company's ability to patent a technology that utilizes the BSD+Patent protected technology from Facebook as a core functional component of the patent. 
Not sure if you wrote this article but hopefully take this as constructive criticism. Breaking up what's sometimes a single sentence with nearly full-screen screenshots of an application is a pretty terrible design. There's really no content in this. It comes off incredibly low-effort. &gt; Software &gt;OS &gt;Obviously macOS. I mean, seriously? That's it? I have nothing against macOS but this tells readers nothing. There's really no obvious about this. Mac books can run any OS, maybe you use a VM. Why not explain why this is a tool you use? A massive screenshot says nothing other than a bad attempt at looking pretty. And the rest is just more of the same. You wrote a little about Fira Code but I honestly couldn't say what it is or what it does. So I'm just left feeling like I have no clue what the point of this is, who it's for, what your goal is, nothing.
Just chiming in as a law grad turned developer; whether the license is problematic or not, it's kind of frustrating to read the "my company's / X company's lawyers said no" argument time and time again. If I was acting as a lawyer, and knew that our developers COULD feasibly use another library without licensing issues, why would I ever suggest using React? If I give legal advice to use React, there's a (very, very remote) chance that I've given advice that can come back to haunt me. If I don't, I have no sword hanging over my head and the devs use a different library, whoopdie do. I'm not saying company lawyers are making the issue that simple...but I am saying people like to keep their jobs. My personal stance is that anyone with a remote likelihood of being affected by the license, will have company lawyers dictating the decison anyway. 
Or Gitlab!
or just use kue or bull also looks more complicated and less alive than the competition 
didnt come across a screenshot in the readme. instant no thanks.
The difference is that JSON is a noncopyrightable file format. The JSON license covers the JSON reference implementation, which JavaScript developers probably aren't using.
It being called "the JSON license" doesn't automatically make it relevant to JavaScript users. I corrected you on this already in a different thread. Are you spreading misconceptions on purpose?
Can you link to a html klotski game I googled it wasn't able to find it.
The guy you are talking about is Dominic Gannaway. AFAIK, due to his work, react's bundle size decreased by 10%. You can watch a talk of him if you are interested here: https://youtu.be/djOc1EK07Tk. There also is a mention of preact and inferno in his slides.
\^This. All the people who claim "we have to get approval from legal department for every dependency we use" are either incompetent or work for someone who is incompetent. It doesn't matter – because your dependencies have their dependencies, and they will have their own licences. I worked for one of the major IBs. There every NPM module that we wanted to use needed to go through the same process... you'd raise a ticket requesting that this NPM module becomes available via local proxy. The problem was that it completely ignored the fact that those modules come with hundreds of other dependencies.
 .sort((a, b) =&gt; { &gt; let v = a.name.localeCompare(b.name); &gt; if (v) { &gt; return v; &gt; } &gt; return a.account.localeCompare(b.account); &gt; }); In this solution when I have for example list: &gt; var personList = &gt; [ { &gt; "id": 1, &gt; "name": "Wwww", &gt; "surname" : "surname", &gt; "account":" not active" &gt; }, { &gt; "id": 2, &gt; "name": "Anna", &gt; "surname" : "surname", &gt; "account":" not active" &gt; }, { &gt; "id": 3, &gt; "name": "Ryan", &gt; "surname" : "surname", &gt; "account":"active" &gt; }]; Sorted Array looks like : 1. Anna (not Active) 2. Ryan (active) 3. Wwww (not active).. But I want to have "active'" users fisrt. The right solution should look like: 1. Ryan (acttive) 2.Anna (not active) 3. Wwww (not active)
Kinda. They've disabled a lot of the cool fibre features (like asynchronous rendering) which delivered the performance enhancements we expected from fibre. The release notes for the beta make it clear that 16 won't deliver any performance improvements
Or, you know, you could just set your browser to close all tabs when you close it. Pretty effective at keeping the number of tabs limited
No, I think it affects a company's ability to sue Facebook for ~~copyright~~ patent infringement. Which is much much worse. But I could be mistaken, and I would like to know if I am. 
Thanks for the comment! I'm not the author, but I'm the one who collects toolkits at this [GitHub repository](https://github.com/nik-garmash/works-for-me) and I will take your suggestions into account. The point of such articles is to share with other developers your set of tools, so they could find something they haven't tried yet, it doesn't mean to be very descriptive, sorry if this particular article did not work for you. But I actually found a couple of useful things for myself.
Actually, you're right, it's for developer in general, just a bad selection of the title, nevermind)
Patent infringement. Not copyright. 
http://www.angular2.in/2016/10/angular-20-introduction.html
What can you do with an object that you can't do with a function? (Again, leaving null aside.)
Rather, what can't you do with object you can with any kind of function? Execute/call it, of course.
Best case scenario: FB intends to use the licence exactly as they say, as a way to fend off patent trolls. Worst case scenario: FB intends to use their software as a trojan horse whereby they can copy other companies' sofware and make it more diffucult for them to sue. The license does make me weary. FB/Mr. Zuck has been known to not always do things in good faith.
Just do it the other way around then. The comparator function is supposed to return &lt; 0, &gt; 0, or 0. If it's 0, the two items are identical. If you want to sort by several factors, you do the first comparison and only if the items are identical as far as this first comparison goes, you do the second comparison and so on. So, in that "if (v)" line, it checks if a difference was found. let personList = [{ "id": 1, "name": "Wwww", "surname": "surname", "account": "not active" }, { "id": 2, "name": "Anna", "surname": "surname", "account": "not active" }, { "id": 3, "name": "Ryan", "surname": "surname", "account": "active" }]; personList.sort((a,b) =&gt; { let v = a.account.localeCompare(b.account); if (v) { return v; } return a.name.localeCompare(b.name); }); console.table(personList); Note that I removed the space in front of "not active". That space affects the sorting: &gt; 'active'.localeCompare(' not active') 1 &gt; 'active'.localeCompare('not active') -1 You can also use short circuit magic to get the same effect, but it makes it somewhat more difficult to follow: personList.sort((a,b) =&gt; a.account.localeCompare(b.account) || a.name.localeCompare(b.name) );
Guys, the Medium blog post that this Patrick guy clapped to (called [React, Facebook, and the Revocable Patent License. Why It’s a Paper 🐯](https://medium.com/@dwalsh.sdlr/react-facebook-and-the-revokable-patent-license-why-its-a-paper-25c40c50b562)) is much more informative than the original post. It is, finally, written by an actual lawyer who has since become a software developer, so at least he doesn't start with the all-too-common disclaimer "IANAL".
Please let me know your thoughts and give me ideas on how I can improve it. Do you find it useful?
Now It is sure. Thank you very much @inu-no-policemen !
Here is a solution: Don't use React. There are plenty of frameworks to choose.
"I'm not a lawyer but I will speculate about laws and pretending to be one". Next up, a lawyer teaching you how to set up Jest! Only on Medium.
Yup! Was just about to say the same thing 
~~I don't know why you're being downvoted.~~ Even if you *want* to use React there are drop-in replacements with more permissive licenses: [inferno](https://github.com/infernojs/inferno) or [preact](https://github.com/developit/preact). They are also faster and have some nice convenience features (lifecycle events for functional components are great!). And if you are in the position where you can choose a completely different framework then both Angular and Vue are pretty good options. Edit: not downvoted anymore
Would GraphQL be affected by this too? It is a spec, not a library (the author included it in the list of software to avoid).
Could be, but at same time he might not even know about any licensing deals since he is a developer, since that might be handled by legal dep.
Drawing With Code
Wow, that was quite a poor article even by the increasingly bad medium.com standards
Three more probably popped up since you wrote this post.
Genuine question - does that harm the profitability of web development at all?
Preact isn't exactly drop in and having a smaller size isn't the same as having better performance.
I wouldn't use their stuff just to make sure this kind of licensing does not become the norm. 
From what i read it will actually make it easier to create smaller packages because it can be broken up better, but it'll be interesting to see how it turns out.
Are you crazy?
Muhahaha!! Actually, I feel much better opening my browser, now that it's all nice and empty every time :-)
No.
But but what about years of useful links I accumulated in opened tabs??
preact is mostly a drop-in replacement with preact-compat. If you were writing modern React code before, chances are you won't have to do anything. I'm also well aware that smaller size doesn't necessarily mean better performance (something I think I never implied). Regardless, both frameworks have been regularly beating react in several benchmarks both in execution time and memory usage.
Something's gotta give! Either ASF or FB should update their license.
You have to free your mind from the bondage of past voyages into the depth of the unknown… *mysterious look*
It's like banana inside your pants ( ͡° ͜ʖ ͡°)
Nice idea! I feel like there's something to it, but using comments feels a bit hacky. I started thinking how big of a sin it would be to just create a function that you could wrap other functions with to include tests. Maybe something like: withTests( (foo) =&gt; foo(123) === 'bar', function foo(num) { if(num === 123) { return 'bar' } } ) Probably not a great idea to mix test code with the actual implementation, but if function decorators one day become a thing in javascript, you could also have it like: @withTests((foo) =&gt; foo(123) === 'bar') function foo(num) { if(num === 123) { return 'bar' } } and for some reason that feels a bit better. 
If you're referring to what shows up at the top of the site, try refreshing the page.
Why would the import be favorable to writing a comment clarifying the intent?
&gt; If you’re outside of the US then patent laws don’t even affect you unless you do business in the US. That is a completely bogus claim. Patents exist outside of the US.
Hi /u/nik-garmash, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Medium.com is the new Blogger.
Briefly looking through their history, I'm not seeing any behaviors that would warrant a ban, but please feel free to provide evidence to the contrary. This post may be a shitpost, but it's not egregious enough on its own to merit a ban IMO. 
Because the component is much nicer than a comment? I don't know about you but let's remove React from the example here. For patterns I'm going to use across my project, I much rather a function that is named in a way that describes what is going to happen, rather than writing a comment everywhere in my app where I use that pattern.
The part where he says "if you're outside the US then patent laws don't affect you" is the funniest.
Yes it is. 
&gt; DOES NOT bind it’s own this I stopped reading here.
~ Yay ~
I'd imagine returning an array when you want to render several components will become idiomatic way to write this code, because that's kind of the point? const Root = () =&gt; { return [ &lt;p&gt;Hello, World!&lt;/p&gt;, &lt;p&gt;I am a demo fore returning an array.&lt;/p&gt; ]; }; ^([jsBin][1]) I'm not sure you even need a comment in this instance since I'd imagine all programmers who know how to write React code know what an array is. Compare it to `&lt;Aux&gt;`-wrapper approach for which you *have to* go and read documentation or source to understand what it's doing. [1]: http://jsbin.com/monufelowi/edit?html,js,output
I tend to err on the same side of that conversation, but shouldn't a comment be favorable to adding a depenency? 
well remember it's not JUST a comment. And no if you need to put a comment in 20 different places explaining the functionality of something, it should just be consolidated.
Why? It doesn't mean you don't have rights to your code.
All I'm saying (ignoring the pattern) if you need to comment it everywhere that it's used, then I'd prefer using the component. If it's just an easy pattern to utilize and doesn't need explanation, then yeah sure.
Just FYI, the example you've just shared (using Array without keys) will produce an error even in React v16.
Are you sure? I'm asking because it's working with beta.5, [as demonstrated in the linked jsBin](http://jsbin.com/monufelowi/edit?html,js,output), but I'd be not surprised if it's just a regression.
What is inherently wrong with adding a dependency? Regardless of whether it is 1 LoC or 1000 LoC? The only worthy consideration is the increased surfaced of potential vulnerability injections, i.e. dependency going rogue. From the build performance perspective, resulting bundle size, etc. There is absolutely no difference between a dependency and a locally redefined module. From the upside, with a dependency, you get documentation describing the intent and you work with components that community is already familiar VS reading comments in your local `./utilities` folder, learning what each utility does.
It is because you are using a production build that silences the error. See https://codesandbox.io/s/k5v5q83xo5
Few things I noticed from a quick glance. You mentioned GraphMagick, but not Headless Chrome. I was looking to see what was taking the screenshots. Browser versions are still important to know in 2017 for testing. I don't know if it's possible, but I'd like to be able to either scroll the page, or be able to screenshot the whole page. That's kinda a hard ask given that we now have people scroll-jacking and people using `position: fixed` for nav. But it would be cool if the API has an easy way to set scroll position, and another API that took a bunch of scrolled screenshots, composited them together with ImageMagick, then compared to a baseline. One thing I've always wanted a API like this to do was to be able to ignore some areas. If I was building my own, I would have made transparent pixels in the baseline not check the screenshot. This is great for sites with animations, ads, or dynamic content. If I'm talking wish lists, I'd love to be able to send a CSS selector for what to compare. That way I can have a dynamic site, and test the widgets regardless of their position on the page. Does the results overlay any kind of visual indication of what was different? I've seen some cool demos where people put a box around the area and then had a partly transparent baseline overplayed on top. 
Oh, I see, you mean the missing "key" warning. That's a good point 👍
Does this affect companies outside of the US "less" than companies inside the US? Like for example, Canada, Mexico, UK, etc companies would be "less affected" than US companies?
You might get a better answer by asking the V8 team directly on Twitter. [Franziska Hinkelmann](https://twitter.com/fhinkel) works in this space (I think), so maybe try her first?
If you are against having choices then don't use FOSS and be done with it, this is not a problem exclusive of Javascript, if freedom to pick your tools is a problem. You can have the same endless debates choosing a linux distro, a backend language, framework, database, orm, libraries for this and that. If you want someone making the decisions for you, then you'll have to pay Microsoft, Embarcadero, Oracle and be done with it. Buy a meteor license, get support and live happily ever after.
Third party dependencies always add complexity. They have to be installed (reproducibly), versioned (correctly), and updated. Sometimes, ideas and conventions must be adopted. Bugs must be reported, and fixed; or you fork it, and take responsibility for the code anyways. The author could abandon the library, or delete the package altogether (a la `leftpad`). You don't want to fall into the "Not Invented Here" trap, but at the same time, the cost of adding a dependency should never be under-estimated.
Why would it? You can still copyright your code you just can't patent it. If anything it makes the market much more competitive.
You've just described the whole internet to be fair. 
So first off I agree with the other comment Franziska is a wonderful person who can probably answer your question or at least point you to who can, but let me try to answer. First off there is no such thing as lambdas in js, but I'm going to assume you mean functions without side effects that don't rely on closures and there is a pretty powerful optimization for functions that don't rely on closures at least and that's inlining. Edit:all right yes anonymous functions are lambdas but the references to caching and what not made me think he was asking about something more specific from some functional language that doesn't rely on mutable environments 
anonymous functions === lambdas
Apparently future versions (of JSX?) will allow an empty tag (`&lt;&gt;&lt;/&gt;`) syntax for lists of elements
That looks horrible... Source?
It's being [discussed in the JSX repo](https://github.com/facebook/jsx/issues/84).
That Facebook PR is dumb. React is garbage anyways. I'm surprised anyone even uses it.
Then you don't understand what a Bound Function is.
Only if neither uses `this`, which is interpreted differently for lambdas. So the codegen will be different if `this` is present.
You don't really need to do any of those things that you mentioned. It's perfectly fine to find a version of a dependency that works for your needs and lock it down and forget about it.
I don't think that looks horrible. I think it looks good and actually converts the meaning well.
What are you smoking? Lamdas ARE anonymous functions!
And doesn't reference mutable state in the closure which can also be interpreted different 
Yeah but not the kind he's asking about because you can't cache just any old anonymous function even if it's called with the same arguments
How can this be viewed as anything but Facebook trying to use its OS software as weapons? Google, Microsoft, Apache, etc all don't require a patent clause like this. 
You said "first off" at the beginning of two paragraphs. Which is first? In what order do I read your post?
In what way does `&lt;&gt;&lt;/&gt;` converse the meanings?
Let's not turn on each other like rabid animals for a mild terminology difference, hmm :)? Lambda can be understood in wider context (for ex. "Lambda calculus") as a function, which: 1. Has no closure (doesn't use variables defined outside itself) 2. Has no side-effects. 3. It simply maps an input value to an output value. Those are inherently more cacheable, than something that has unique state (closure) or has side-effects. In some languages, like Java, there's a relaxed definition of lambda to mean "any anon. function". In JavaScript there's no specific meaning assigned to "lambda", so it's unfortunate when the same word has multiple valid definitions that get in conflict like this.
I mean, I feel like the fact that the patent clause has been there for like 4 years and nothing has ever happened is a good indicator that it's literally not being used as anything, much less a weapon. 
If you need help with this, can I recommend a different career path than programming. Check how [colorful and fun all this equipment](https://st.depositphotos.com/1010613/1960/i/950/depositphotos_19608253-stock-photo-female-cleaner-with-cleaning-equipment.jpg) is. This can be you!
This is an indirect answer, but n.b. the latest versions of Node (8.3+) ship with V8 6.0, with a new JIT ("Turbofan") [which changes things](https://medium.com/the-node-js-collection/get-ready-a-new-v8-is-coming-node-js-performance-is-changing-46a63d6da4de) wrt performance of functions under various conditions.
You can read it in order, I was agreeing that you could ask on Twitter before trying to answer by talking about inlining, also I forgot to mention that functions with constant type signatures can be compiled. 
You're probably one of those people that start counting at 1, aren't you
Not only do I start counting at 1, I also always end counting at 1. This makes me especially dangerous for you.
It's literally an empty tag so only conveys its children as relevant. Which is about right. It caused a furrowed brow when I first saw it, but I really can't think of a better syntax.
It's pretty OK to live here too. The number of devs personally affected by a software patent is so close to 0 as to be indistinguishable from 0. Anyone pretending this issue should affect an actual personal decision of their own about a project is indulging in utter pretentiousness.
Mindexplode.gif
&gt;nothing has ever happened Except groups stop using their software. Almost like they're afraid of something.
Just curious where the name Aux comes from. Why not something a bit more obvious like Fragment?
A convention I've been using ever since I remember starting to write HTML/ CSS. Auxiliary element is something that does not have semantic purpose but exist for the purpose of grouping elements, styling, etc.
Will users be adding links to external sites? If it's your own, it shouldn't be too hard to parse the url and figure out what data you have for that slug and turn it into the card you need. If it's another, external, site - you're going to need to get your backend to perform an http get and pull down the html of the page, run it through a dom parser and pull out the og meta tags (or whatever else you need)
Ah interesting! TIL a new phrase 
Yeah so users will be able to bring in any external links, right now I have my backend making a request to that URL and I can see the body and I'm thinking I can use cheerio to parse the meta tags? I'm just having a hard time seeing how I can get this data back to be insterted into the database and how to point it where to go.
Oh yea cheerio would work. `$('meta[property^="og-"]')` iterate over all of them and pull out what you need. If it's an endpoint you have that does this, it could reply with a trimmed down version of what you're after be it link, canonical url, image whatever else &amp; the front-end, after it receives a response, can turn it into the card you need. It might be good to create some sort of caching layer for this -- performing the http get/parsing/etc. can be a time consuming (and unreliable) task so it would be best to keep that information somewhere so if someone requests the same thing again you have it already. 
Awesome, thanks for the help I should be able to figure it out from here.
Fair enough. But groups being afraid of nothing doesn't change the fact that it's nothing.
 &gt; 1. Has no closure (doesn't use variables defined outside itself) Even in lambda calculus, this is not true. A lambda term that doesn't capture the environment is called a combinator, but in general terms can refer to outside variables. Anyway, &gt; Has no side-effects. This is only the case on pure, side-effect free languages. On any other language (for example, Scheme), "lambdas" refer to effectful anonymous functions.
&gt; React, Facebook, and the Revocable Patent License. Why It’s a Paper 🐯 did you read his Disclaimer where he also does the same thing?
&gt; if you're outside the US then patent laws don't affect you https://www.legalzoom.com/articles/does-your-us-patent-trademark-or-copyright-protect-you-overseas
https://imgflip.com/i/1ufi6s#JbsO8BR3PmpWLFxY.16
There's a CodePen meetup coming up here in Chicago, so I made this little thing to show off at the meetup. Say you and some friends need to make a choice (e.g. who's gonna go pick up the pizza), you grab your phone, go to my little webapp, put your fingers on the screen, and click "Start", and the app will choose one of you randomly! [Here's a link](https://codepen.io/dgca/pen/vJRBeV) to the pen with the code editors so you can look at the code. [Here's a link](https://codepen.io/dgca/debug/vJRBeV) to the debug version so you can use it without all the CodePen UI. If you want, you can add it to your home screen for easy access. Quick note, this wasn't an original idea. I basically ripped off the app Tap-Roulette. I just wanted to make the same thing, but on the web.
Yes, because TED is redirecting their original source, you must use link they provide in `iframe` section on share modal. For example, try this URI: https://embed.ted.com/talks/jack_conte_how_artists_can_finally_get_paid_in_the_digital_age
Yes. It does. In fact, it can optimize out some functions like (a,b) =&gt; a+ b entirely. You should read the bluebird docs for what crankshaft can do, https://github.com/petkaantonov/bluebird/wiki/Optimization-killers
Neat! You should consider adding a small `bin` to the project that can take a CSV file as input and writes the table out too. 
This is a short, lousy recap article that adds nothing new or interesting to the recent discussions on the topic. In addition, this site is largely responsible for the erroneous idea that you can lose the ability to use React if you compete with Facebook. There's a much, MUCH better post describing the background of the discussion at [Understanding the Facebook vs Apache Software Foundation License Kerfluffle](http://writing.jan.io/2017/08/19/understanding-the-facebook-vs-asf-license-kerfuffle.html).
Hmm? Lambda terms can definitely have free variables i.e. λx.xy where x is bound and y is free (would be enclosed). You described a pure function, slightly different but arguably even more important!
bookmarks, google it 
As of V8 5.9, Crankshaft is no longer in use. They now use Turbofan and Ignition exclusively: https://v8project.blogspot.com/2017/05/launching-ignition-and-turbofan.html Many of these killers no longer apply: https://medium.com/the-node-js-collection/get-ready-a-new-v8-is-coming-node-js-performance-is-changing-46a63d6da4de
Google is one of the open tabs, take that
So is GraphQL in *exactly* the same boat, potentially, as React?
I don't think anyone was claiming that it was _likely_ FB would use their licensing in some way to hurt other libraries and projects. Only that it was _possible_.
I was looking for something like this just the other week; my use case was copying query results from datagrip as csv (since it doesn't support ascii table export) and piping it to some cli tool for easy sharing in slack; +100 for the bin util suggestion!
My workaround whenever I needed a single expression without a wrapper in React v15 was (is) to do: export default function Nothing() { return null } To use: const fragment = &lt;Nothing&gt; &lt;Some /&gt; &lt;Elements /&gt; &lt;/Nothing&gt;.props.children Ugly as sin, and you still couldn't return it directly from a render method, but in my opinion it's better than doing the array-with-keys thing. You could also wrap it in a function if you wanted, so it looks like: const fragment = createFragment( &lt;Some /&gt;, &lt;Elements /&gt; ); Luckily that's all moot as of v16, very glad that there's a better way now.
Others have commented in this thread that yes.
Thanks for the feedback! Any great links to where I can learn how to build out a bin command line interface optional use?
Looks awesome! 
You can use call() to make sure `this` is set correctly originalMethod.call(this, config.jql)
 `return originalMethod.apply(this, arguments)` is what you're looking for. `Function.prototype.apply` takes two arguments. The `this` context and a list of arguments.
I created my first open source npm package. At work we were searching for a solid solution similar to Ruby's FactoryGirl to generate mock data for tests. We found the FactoryGirl node port, but it relied on database models to generate the data, which we did not have as we were working on front-end. The outcome was a super simple mock data factory where you define the output. Currently it is pretty basic, but there are plans for including existing models, overwriting fields, and much more. Check it out! https://www.npmjs.com/package/basic-factory https://github.com/bkd705/basic-factory
Has anyone produced a "big hits" list ( say top 10 ) that also come under the same licensing? Looks like React, GraphQL, JSON, and possibly npm? :O 
Yeah: I never get why people try to over-complicate matters. Do you worry about what the value of this might change to inside an if block? No. So... instead of worrying about some deep new meaning for arrow functions... just stop worrying about them changing the current meaning/context when it comes to "this." Think less, save your brain. That's the whole reason the behavior is good and useful.
It's less powerful than directly created generators (there's no yeild*) and it's still just sugar for Promises, which are flawed (stateful, forced try/catch, cancellation doesn't exist and is problematic even conceptually, don't play nicely with category theory laws, etc). You can create lazy, monadic Futures or Tasks and implement the same sort of sugar with generators (basically "do" notation in JavaScript).
It's not nothing though. The agreement hits a hot part of the software industry and reaches far beyond the software being used. "Here, take this software that's very benevolent, only if you use it you can never punch me." This gives Facebook much more than Facebook gives you. Imagine Apple using react on their site, and suddenly Facebook comes out with the uPhone 9, the specs and parts of which are exactly what's in the iPhone 9. Apple can't sue, they're using Facebook's code. Worse, let's say they take react out and don't realize something is a dependency. Facebook counter sues and gets to look through all their JS code to make sure none of it has their patent rider. Say what you will, no one else has done this, and the agreement protects all of Facebook for using a very, very small amount of Facebook's code. That's not benevolent behavior, and ignoring it because they haven't abused it yet isn't something you should suggest everyone do.
For something this simple you don't need an interface, you can just write a relatively simple Node script, this should get you started: https://docs.npmjs.com/files/package.json#bin Be sure to start the file with `#!/usr/bin/env node`. Use [`process.argv`](https://nodejs.org/api/process.html#process_process_argv) to get the input (and potentially output?) filename argument(s). The `fs` and possibly the `readline` module will help you load a file as a string. For an extra challenge, learn about streaming so it will work even with massive files. If you want it to work on Windows you may have to additionally make a `.cmd` file, but I'm not sure. Edit: apparently npm creates a `.cmd` wrapper automatically on Windows, so no worries there.
JSON? NPM? Why?
I tried that but the `this` being passed in is the context for the file where I'm calling it from. The method its trying to call is private to the Jira class and not one accessible on the `this` I'm now explicitly passing in. Not sure how I'd get a handle to the correct `this` to pass in.
I updated my attempt with apply's cousin call but it seems the context is still the wrong one. Its passing in context from the current service its been called from but that "this" doesn't have access to the internal methods necessary. Not quite sure how to get a reference to that "this"
Well... *technically* the original JSON license isn't free ( because of the "no evil" clause, I gather ), npm seems to be not an issue of itself, but more of a concern dependency-wise. It's weird because this stuff has always been there... hasn't it?
Personally, I don’t care much for the `Builtin.*` functionality. Pattern matching will be interesting for many things, but maybe not as much for type checking. That leaves my method, which I like for its minimalism. For anything more complicated, you want TypeScript or Flow.
Huh you are right. First time I hear about the JSON license.
I stopped reading because of the grammar. ಠ_ಠ
Given that you're assigning `searchJira` back onto the instance, and that it should presumably be getting called from that instance, the `this` binding will occur during that call, setting `this` in your function to the `jira` instance. Then, using `call` with `this` in your function should properly restore context to the original function by also calling it with a context of the `jira` instance, as it would have been called if it was not replaced with your own function. Why it might not do this, and instead be using a context of the file instead of the `jira` instance, is if you were using an arrow function, but your sample code doesn't show you doing that. 
His disclaimer didn't say the same thing, no.
Try originalMethod.call(jira, config.jql)
Holy god, SIXTEEN VERSIONS and couple of years - React is awesome mhhhmmm!
Look on the bright side, if you don't like those tools in a couple of years there will be a completely new stack to learn ! ha ha
Just make your script tag the last one(s) in the body and the need for readystate events vanishes. 
Wow, literally made an account just to be a douche.
If you want something off the shelf and you are/can use redux, check out redux-offline. If not, PouchDb with couchDb on the backend is also an option. Based on experience, I'd not recommend building your own thing. Solving the persistence challenge is easy, so is solving local patching while offline. However, the big challenge lies in flaky connections where the app thinks it's online, but is not. You'll need to work on retry-strategies and optimistic GUI updates with rollback options which are quite complex and can easily become a real mess. Testing these things properly is also time consuming as there is no real way of simulating a flaky connection. 
Nice tool. Thanks for opensourcing it. In your opinion, what are the main benefits over backstopJS ans Gemini ?
https://github.com/tylertreat/comcast Tool for testing shitty connections :p Have never tested it myself but the name stuck to my memory. 
US patents don't affect you, but patent laws certainly do. European patents are a thing. 
Have a look at rxdb. It was build mainly for pwa's together with reactive programming. https://github.com/pubkey/rxdb &gt; Disclaimer: I'm the author of rxdb
I used crypto-js in the past. But I cannot recommend it. It has some build-issues with webpack, tree-shaking, nativescript. 
Because it is not setting up a blueprint for making coin flips. New Promise is how you ask "flip a coin and get back to me on these callbacks".
You need to wrap it inside a function that returns the new Promise. When you call that function you can then chain .then() and .catch().
Parentheses are used to call a function or class, so where you're calling 'new Promise((resolve, reject) =&gt; {})' your promise will begin to do its job. The way around this is to have a function that returns a new promise: function myPromise () { return new Promise((resolve, reject) =&gt; {}) } This way the Promise only gets called when the function does, and when you call the function you get a brand new Promise returned. This gives you a 50/50 chance to resolve or reject, but if you call '.then' on the same Promise, you're going to get the same result every time.
Take a look at https://hackernoon.com/native-apps-with-vue-js-weex-or-nativescript-8d8f0bac041d
The dependency doesn't work in a vacuum though. This one in particular has other dependencies.
Conflict resolution is a thorny problem and whether you are better to roll your own solution and how complex it (or an imported solution) needs to be very much depends on your application and its data. Many huge tomes, and many more smaller (arguably incomplete) guides, have been written on the subject. For simple applications "newest wins" works for conflict resolution, especially if the data is fully audited so old versions can be retrieved (then a users whose update is overridden this way can merge their changes back in or simply resave to reassert their version as correct and it then becomes the newest). Of course you then have the problem of defining "newest": the most recently received by the server is the most common way but this is not always the best so you might want to go by timestamps recorded on the clients. Oh and if your data isn't nice flat relatively unrelated entities you have the fun of dealing with compound data: if two users update different parts of a thing do you merge or take one user's whole thing over the others? What might work well depends intimately on the nature of the application and its data unfortunately so giving general advice is rather difficult, *but the most important advice is that* **you should consider the data synchronisation as a feature, one of the application's most important outputs**, *and design your data model around making that work well*. It will be a lot harder to produce something that works well (and that your users like) if you design for the rest of the application first, and then think about data synchronisation later. **Edit:** a couple more thoughts: Another key factor is how often are the data changes from different users likely to interact? If conflicts are going to be common then it is far more important both from a UI PoV (how do you show history? do you explicitly tell a user a conflict happened and was "resolved"? how? ...) and more "technically", than if most of the time users effectively don't interact with each other. For instance in many applications what one user posts is usually mostly read by other users and only occasionally edited by them (like StackOverflow and similar knowledge sharing sites/apps for instance, or business applications where in most cases workflow rules mean that most of the time only one user is likely or able to edit an item (for instance a "base user requests training course, supervisor requests more detail be added to request, user adds supporting detail, supervisor signs-off request, training department arranges course and records details, ..." workflow - at least three users are interacting but at each stage only one user is likely to be editing the request record)). Also, what happens if the same user is working on multiple devices? For example their home PC, a laptop/tablet when mobile, and their phone too for good measure? Not all conflicts are going to be between different users.
Interesting, thank you. That's making me think I should cross out weed at least in the short term
&gt; I was trying to define a promise that will have a 50:50 percent chance to either resolve or reject You did that. But the mistake is thinking that the promise result can change after resolving or rejecting. Once a promise resolves or rejects the result is set. You want to create a new promise each time to get different results. function iffy(){ return new Promise((res,rej) =&gt; { if(Math.random()&gt;0.5){ res('resolved') } else { rej(new Error('rejected')) } }); } const results = [0,1,2,3].map(iffy); results.forEach((result,i) =&gt; { result .then(value=&gt;console.log(i + ': ' + value)) .catch(err=&gt;console.log(i + ': ' + err)); }); 
It's important to note certain differences between them. Framework7 and Quasar will render HTML- and CSS-based user interfaces, mimicking the design guidelines of each supported platform (such as Android's Material Design and Apple's Human Interface Guidelines). The result of this is user interfaces that _look_ native, but might behave non-native (such as when scrolling through long lists, etc.). Weex and NativeScript (as suggested by /u/nightman) will produce actual native user interfaces, although their styling might not look native (depends on how they're styled by the framework developers). This _could_ seriously enhance the user experience of the app compared to HTML-based apps. edit: typo
Oh man... that's a lot to consider then. Just when I thought I had narrowed my options down to F7 and Quasar I'm up to 4 instead!
After a difficult week of pondering back and forth, I've decided to go with Quasar + Vue + PhoneGap + Electron + Firebase. The reason for Quasar is that I like its components much more than the others.
This is a really useful module! I work with CSV files all the time and this will come in handy. One pointer - (working with CSV files all the time) - I jumped in the code and see you are parsing the CSV with splitting on comma. What happens if my CSV is like this: &gt; col1,"I like, commas in my columns",col3 I would use a proper CSV parser for this part - that way you get around all the potential bug reports your hoard of new users will report :-) (https://www.npmjs.com/search?q=csv) Great work!
[Commander](https://developer.atlassian.com/blog/2015/11/scripting-with-node/) is a full on CLI development tool. I always use [minimist](https://www.npmjs.com/package/minimist) though if it's a single script and all I need is to process cli options
If you're on modern browsers just use the built in version EDIT: not sure it supports cbc 
Definitely! My ongoing PhD thesis is on this exact subject, so feel free to ask followup questions if you have any. Just for the sake of adding to your list of frameworks, I'd also suggest you keep an eye on [Stencil](https://twitter.com/stenciljs), which is Ionic Framework's new Web Components effort, making it possible to use Ionic without Angular but with React/Vue/jQuery/no framework instead. While being in an early stage (I believe), it's still worth checking out. You could probably read more about Stencil on [Max Lynch's Twitter profile](https://twitter.com/maxlynch), as well as on the official [Ionic Framework Twitter](https://twitter.com/ionicframework).
Oh, and you also have [Onsen UI](https://onsen.io/vue/).
Also tabris.js from eclipsesource
What you want is the ability to connect via a media server... there's no hiding from it. You either build it on top of an [SFU](http://webrtcglossary.com/sfu) model or send the media over HLS/MPEG-DASH to a CDN (with an additional delay of a few 10's of seconds). For the SFU approach, to scale it up, you will need to cascade the SFUs one to the other, so that you can get the media to more devices than a single SFU machine can carry.
Tabris doesn't support Vue, afaik. EDIT: [Perhaps it does](https://twitter.com/dested/status/836462833978073088)? Haven't actively looked into Tabris in a while.
I don't know how those library work, I cant tell you the benefits against them sorry :( I can say that the strong points of exquisite (of course exquisite is a WIP and is in beta stage!) - The speed: because it uses (https://github.com/GoogleChrome/puppeteer) for generating the screenshots. - Easy to use: 2 methods - Easy to use with travis - Easy integration (see the mocha example)
Oh great! What would be your best recommendation? I plan on using laravel as the API endpoint and wanted to write a mobile app in vue to consume the API since that's what I have the most experience with.
Just checked `date-fns` &amp; its pretty good My main problem with `moment` was mutability Now I'll start using `date-fns` 😉 Thanks 🙏
I have yet to thoroughly test Weex or NativeScript, but the latter seem to be the most mature. The first time I looked into Weex, their Github issues page was mostly written in Chinese, making it less attractive to follow their progress. I've thoroughly tested React Native and Ionic (which builds on Cordova), both of which I enjoy. React Native is like NativeScript and Weex, while Ionic is like Framework7 and Quasar. Honestly, I'd recommend that you test a few of the frameworks you find most interesting. Just develop something small, perhaps just something that consumes your API and get a feeling of how the framework works in your favour (or against it…).
You want to bind the 'jira' context to the new function you're calling, currently it's opening a new scope and so 'this' is assigned the scope of your new function.
Promises are essentially sophisticated event listeners
This is for node (forgot to mention that)
Don't want to hijack the thread but is there anything similar to "React Native Web" in the Vue universe so you have only a single code base for mobile+web and even desktop) React Native Web looks like the perfect tool but that horrid React Native license is putting me off
It's not the best place to share your happiness and experience, IMO. Some people see "Electron" and it triggers them, making their hands to push downvote automatically.
Awesome. Thank you for the insight! I quite like the look and feel of Quasar and Framework7, so I think I will most likely go with one of those. The documentation for Quasar looks quite nice as well, so I think I'm leaning more towards that one and will try it first.
Crypto is an absolute shitemare for react native 
Agreed, I can see the arguments for and against Electron, but people have become pretty tribal about it.
just use the node [crypto module](https://nodejs.org/api/crypto.html#crypto_class_decipher)
The TL;DR of the Facebook license is that Facebook have a history of trying to buy competitors, and when that fails they bulldoze them with their own copy of the app. If they fail to buy you, or they write a copy of your app with the Facebook logo slapped on, then you will have to rewrite your codebase if you want to take them to court for patent infringement. I love React, but it sits a bit uneasy with me. For the time being though, I'm happy to carry on using it. As Facebook branch out however, I can see React going to the bin because of this, especially when the competition from Vue is getting better and better.
Sad. :( I know the hate for JS in the programming subreddit but thought that the JS subreddit would be different.
thanks for sharing
Promises are wrappers for future values - values that don't usually exist when the promise is created. For example if you're loading a text file from a URL, it needs to download before you can access the contents of that file. So a promise is provided in the mean time and later given the contents of that file when its been downloaded through the promise method `then()`. When you're the creator of a promise, you need to be able to provide that promise with a value once the value is available. The problem is, when you hand off the promise to someone else, you don't want them to be able to set the value just as easily as you. Promises are designed to hide that away from the consumer. They're also designed to ever only have one value that doesn't change, kind of like a `const` variable. Once its value is set, it doesn't change. So how do you give an object to someone else and make it so you can set a value for it but not them? One approach is using a deferred. A deferred is a separate object used to resolve or reject a promise. As a promise provider, only you have access to the deferred object, and only provide the promise linked to that deferred out to your consumers. It works something like this: const deferred = new Deferred() if (Math.random() &gt; 0.5) { deferred.resolve('resolved') } else { deferred.reject(new Error('rejected')) } return deferred.promise // back to consumer `deferred.resolve()` and `deferred.reject()` can be called at any time, right away, or at some point long into the future, but only you, the promise creator has control over it. Only the promise its linked to (`deferred.promise`) is returned back to the user. This approach, I think, is easier to grasp when first learning about promises, and was pretty widely implemented in versions of promises that were being used prior to their addition into the core language. But in when promises finally did make it into JS, their implementation was simplified to omit the need for a separate deferred object. Instead, resolve and reject functions are provided to the creator when the promise is instantiated. But how is this done when the receiver of the promise needs to not be able to access these? The solution: a callback in the Promise constructor. When creating a promise, the constructor accepts a single argument, an executor function, which gets called once, and immediately, with the promise object instantiation. This function is one the promise creator defines and is passed in the resolve and reject functions relating to that the fulfillment of that promise. Because its a callback in the constructor, only the promise creator has access to it, and because it executes right away, it ultimately behaves the same as if you created the promise through a deferred, only now you have a separate function block wrapping up the logic that would otherwise be used against `deferred.resolve()` and `deferred.reject()`. It may sounds weird to call the executor callback function right away, since usually promises get fulfilled in the future, but there is nothing preventing you from calling resolve later. For example: const p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)) p.then(() =&gt; console.log('One second later')) All you need to do is make sure everything that depends on resolving (or rejecting) the promise is within, or accessible within, that callback. This usually isn't too hard thanks to closures, and you're already using it correctly for creating a single promise. If you want a new `Math.random` check to occur with a new promise result, you'll need to be sure to create another new promise with the same executor callback. If you prefer the deferred approach, and that makes more sense to you, you can easily make one yourself using something like: class Deferred { constructor() { this.promise = new Promise((resolve, reject) =&gt; { this.resolve = resolve this.reject = reject }) } } 
*Yes.* It is a specialization of a dispatcher; with two event types and will only trigger once.
Which is sad considering there aren't any alternatives really. It's not like people trying to use JS for desktop app development have a choice. I mean there's nwjs but it has almost the same pros and cons.
There arent really any good **cross platform** libraries for UIs in any language, I tried for example python and qt and it sucks balls, maybe if you use java? or c++ and qt (fuck me right?). But even so, web pages are much more flexible that anything they have come up so far. 
ahh, facepalm. That makes perfect sense! and it worked! Thank you :)
Thank you very much! That worked
Thank you very much! That worked
What kind of risks? Plenty of projects with a single maintainer that get used in production.
What about a reserved component name?, like `&lt;Aux&gt;` or whatever. Otherwise you will end up creating a new "syntax" to accompany every edge case.
That would negate the purpose of an `async` tag. We want the assets to be downloaded in parallel and the page to be as ready as soon as possible. It's worth it to have to add those two lines of code for the extra speed. 
Fuck em all. Electron is the shit. We will all be busy shipping features while they are spending days trying to style their app to look like it's from this decade. 
I wish I knew about quasar like 6 months ago, I built a hybrid app using Vue, Webpack, and PhoneGap and setting it up myself was an uphill battle to say the least 
It is nicely explained, and I like the article as a whole. The code examples are a bit confusing tho - to see how the input connects up to the paragraph elements you have to click around in the Codepen widget - which isn't great on mobile. It would be nicer if the complete JS code was shown in the article (or at least how the input interacts with the notify method
This one looks great, from my understanding it can even create a web app and desktop, not only mobile. Have you used it?
I really like your feedback and agree with you 100%. Thanks for suggestions — post has been updated. Thanks a ton again.
Conratz man! Makes me want to look deeper into electron.
Time and time again what is old becomes new again. The sexiness of the CSV format is exactly that it is not sexy. A quick tip: CSV is/was popular in the WIndows/Excel world so make sure that any scripts in your NPM-published package.json file work on *both* Windows and *nix.
Hi. Thanks for great feedback. You are right that CodePen example isn't any amazing on mobile but I tend to use CodePen on my examples and its mobile experience has never been great :( Sorry about it! A great suggestion you made about presenting how input interacts with the notify method. The post has been updated to contain this snippet. Thanks again!
You're welcome
Honestly electron gets a bunch of shit but I have a client that wants a standalone desktop application written in pure JS with an installer wizard. And I'll be damned if Electron isn't fulfilling these needs incredibly well and I'm rapidly able to develop and release. I'm a web developer doing this job on the side so it's extremely beneficial to me. 
I may be wrong but I have this sinking feeling that FB is doing a lost of sleasy stuff (as are many other $big companies). To that end, I am rather suspicious of FB's yarn package manager &amp; it's ulterior motive of upsurping the NPM registry. Sure I may well be wrong but your own web search for conspiracy theories on this one will show up others that feel the same way as I do. I am further suspicious with the lerna build tool wanting to become integrated with Yarn. So yeah, I can see where the author of the subject article is coming from.
The lack of reciprocity is, indeed, disheartening. I, for one, won't be advocating for React until either (a) reciprocity is instated, or (b) the disarmament clause is removed. To u/indiescripter's comment, [Yarn is (presently) licensed](https://github.com/yarnpkg/yarn/blob/dbe683b71a04348d466c9dc6fc0fc4b98be606f8/LICENSE) as "BSD 2-Clause." 
Haven't used Onsen yet, but you can indeed use it for web (e.g. as a Progressive Web App if you wish) and desktop (Electron). If you end up using it for anything, please post your thoughts! :)
Weex
Everytime I see someone shit on Electron, my first thought is "well this guy's right, Electron apps are memory hogs." Then I remember the Discord app, awesome UI, just works, very nice experience overall. So, yeah, ... ever used some of the JetBrains stuff ? I do. Great tools. Memory hogs. No one complains. 
The JetBrains IDEs do a lot more than what a glorified chat client do, and I'm sure your average Vim user would complain about the memory use of Webstorm.
So, when one calls `Promise.resolve()` does that eventually dispatch an event that sets the promises state to `resolved`? Is this what you're implying? 
The point you're missing though is that Apple *does* use React and has for years and what you're imagining simply hasn't happened. Twitter uses React and is as close to a direct competitor to Facebook as any company on the planet. Microsoft, Amazon, and Google also use React. Imaginary misdeeds by Facebook are no reason to accuse them of using their software as a weapon. 
Glad to see this coming to React. We've had that in Mithril.js for a while with `m.fragment` and it's really nice :) "Self-destructing component" seems like a weird name though. I recall @trueadm talking about a similar feature in Inferno under the name of fragments, which seems more in line with what this concept is called in the underlying DOM and what we did in Mithril.
As has been said many times, Electron is good and bad. Good because you can deploy apps very quickly and you don't have to deal with making an actual native app. Bad because of memory and performance issues. The thing is though, I have 16gb of ram in my MBP and the next iteration will have probably 32 or 64gb. And while that will cost a few hundred dollars, I'd rather pay my share of those electron apps than not have a native implementation because a company decided it wasn't worth it to create an actual native app. It's like crowdsourcing. You buy the extra memory, we'll provide the electron app. 
if your scripts don't rely on things that are related to styles/images (i.e. they don't try to get dimensions/positions of DOM elements), prefer "DOMContentLoaded" -- it'll be fired faster, which will lead to the smoother user experience.
&gt; If all giants agreed to open source under the “BSD + patents” scheme, cross-adoption would grind to a halt. Why? If Google released Project X under “BSD + Patents”, and Amazon really liked it, rather than adopting it and losing their right to ever sue Google for patents, they would go off and build it on their own. This seems like a reasonable argument, but it doesn't seem to have deterred several big name companies from using React. Airbnb, netflix, and dropbox for example.
They don't acknowledge the core problem here which is that their holy war against horrible patent practices shouldn't be fought in the arena of open source software. No patent troll company is going to use react. It can only possibly effect legitimate operations. 
Fuck that qt license though. 
[The Firebase team is working on this.](https://github.com/firebase/firebase-js-sdk/issues/17)
resolve is what would set the value, not necessarily the event per se. The event in the context of promises is dispatching to all registered then callbacks with that resolved value. It works out to be something like (pseudo): promise.then = function (callback) { if (promise.value) callback(value) else promise.listeners.push(callback) } resolve = function (value) { // as passed into executor in new Promise if (!promise.value) promise.value = value for (callback of promise.listeners) { callback(promise.value) } promise.listeners = [] } Each call to then() will add the callback to an internal list in the promise. When the promise is resolved, it dispatches that resolved value to those callbacks. If the promise already has a value, it will call the callback right away (well, technically on the next tick, not shown here). Events register one or more callbacks that can get called many times, whereas promises only call its callbacks once when a resolved value is available. There are differences, but they are similar in that they have a list of callbacks they each iterate through and invoke at some point in time given the right conditions.
Did you just compare a full fledged IDE with terminal integration, code indexing, unit testing, and everything else to a god blessed chat application? Lol
JetBrain IDEs are not created with Electron.
Am a vim user that constantly tells people to chill the fuck out when complaining about memory. it isn't like theyre trying to run an electron app on a commodore 64.
Microsoft uses them as well. And before someone says they're using a different license: https://www.reddit.com/r/javascript/comments/6un0bs/facebook_says_no_to_license_change_request_from/dluenx4/
What?! LGPL isn't good enough? 
&gt; Which is sad considering there aren't any alternatives really. Do you mean there aren't any alternatives to desktop programming other than Electron? Was that a joke? They do have a choice there are plenty of native cross platform solutions that are way faster and less demanding on the computer. I don't have any problems with JavaScript but in my experience every Electron app is a resource hogger.
What the application itself does is irrelevant, you're paying the full price of the runtime (Electron or the JVM and Swing) even if you decide to show a blank page. And none of these are cheap.
1000 records is nothing. These operation can be accomplished millions of times per second. Write the easiest code to write/read/maintain. When you actually get a performance problem, then optimise. &gt; Premature optimization is the root of all evil.
Oh... We did have this discussion some 2-3 weeks ago and the reality is, FB have not revoked licenses even once. Then, there is Inferno, Preact etc so it's not as if you cannot swap over. If you're making a startup, I suggest you focus on making it viable and not worrying about who may acquire it just yet. 
I've improved my JIRA productivity 100 fold by not using JIRA ;^)
Yeah, but when I spin up PHPStorm I expect it to be a monster. The point I am trying to make is that `simple` applications should stay simple. Chat applications should not be memory hogs. That is my opinion though, and if someone else is fine waiting 30-60 seconds for their discord app to open on a system with 16gb of RAM then more power to them. 
I've only dabbled with Weex. Personally I wasn't too impressed by it. The list of supported things seemed arbitrarily restrictive, and the compiled code for the web target was pretty much garbage.
What does electron get shit for?
I'm not disagreeing with you at all, but I also think it's important to consider that the author does not seem to be a lawyer. Here are some articles written by people who may be more qualified that I found thanks to /u/NotSelfAware and /u/gdi2290 in a related thread. [https://medium.com/@dwalsh.sdlr/react-facebook-and-the-revokable-patent-license-why-its-a-paper-25c40c50b562](https://medium.com/@dwalsh.sdlr/react-facebook-and-the-revokable-patent-license-why-its-a-paper-25c40c50b562) [http://www.codemag.com/Article/1701041](http://www.codemag.com/Article/1701041)
Of the "big companies" he says you should look to be aquired by, Apple, Microsoft, and Amazon are all using React. It's getting really tiresome reading these licensing complaints from people with no legal experience and no idea what they are talking about.
Being shit.
If this is ever an issue, it's literally a two minute job to aliaise 'react' to 'preact' or 'react-lite' in your webpack build.
Yeah C++ and Qt is great from what I've heard. Electron is still cool though and allows for web developers to make cross-platform desktop applications quickly which is a good thing IMO.
It's constantly getting shit for being a memory hog, unoptimized browser in a wrapper, etc., undeservingly so. 
I was talking about devs who want to use JS for desktop development and there is no choice at all other than hybrid Electron/nwjs apps in this case. Of course hybrid apps are far from ideal but not everyone is willing to learn whole new language just to try out developing for different platform. I'm sure that if there was a way to develop truly native desktop apps using JS, many devs wouldn't even think about using Electron.
Bloat, memory consumption, killing the Amazon forest
At least it's not Polymer. 
&gt; ... GraphQL ... too? I updated the article to be more clear about GraphQL
You should report this package. https://www.npmjs.com/policies/receiving-reports
You forgot eating babies
This is the entirety of the storybook package you linked (no dependencies either). It doesn't look malicious, but it's basically useless. function storybook(cb) { cb = cb || console.log.bind(console); return cb('storybook'); } module.exports = storybook
You can query your offline database with mongo queries http://github.com/kucukkanat/localdb
Thanks for checking it out, did you happen to look at any of the others? I wonder what the point of this would be..
&gt; You can write comments directly in comments! Wow!
Thanks, I appreciate the links. Do you think I'd be jumping the gun a bit if I reported it right away though? I just want to be sure before I get someones packages possibly removed..
my bad (
I didn't want to do this, but you made me. 😢 You mah-ah-ah-ah-aaaade meeeee!!! 😭
The amount of butthurt electron has caused is incredible. Perfect thing to learn going into future.
The people who are the loudest about stuff like this are the same people who are surfing the web with Lynx on their netbsd box because fuck the man! 
One small addition that I like: The subscribe function should either return the added function or should directly return a bound unsubscribe function. This way you can use anonymous functions as observers and only keep reference to the unsubscribe function. 
Can someone eli5? Seems neat. 
I looked at [this](https://www.npmjs.com/package/universal-js) one as well, and it's basically just empty. [This](https://github.com/gdi2290/) is the github account for the person with these packages, and they seem pretty active. I'm honestly unsure what these packages are for, but they seem at least tangentially related to existing projects that they contribute to.
Also, almost any "larger company" that may acquire you will already be using React themselves.
In my experience, many technical concepts are easy to understand, it's just the wording that is awkward. I guess it's some sort of tradition with academic writing. In normal English, an observer is someone who watches something. But in the observer pattern, it is the subject that watches the data. I think a better analogy would be a news service like Reddit. Users (observers) subscribe to a subreddit (subject). If the subreddit gets a new post, it notifies the users' who subscribed. The home page is then updated. For people who want an easier learning curve for design patterns. 1. Visit the dofactory website, and click on each design pattern. Make a checklist of the ones that are medium - high usage. If they have a high usage, they must be useful right? 2. search those terms for a better explanation on StackOverflow, Quora, or YouTube.
Yeah, but he did talk a bit about how it goes against the philosophy and benefits of open source software. He could have aimed it more at startups currently deciding what their front end framework will be. Even if in practice FB doesn't pose any licensing threat why *wouldn't* I use Vue, Angular2, Aurelia, ect when they have *no* potential to have licensing issues. Also as a dev, licenses are not something I really want to be thinking about. 
So is Google.
Off the top of my head, no. You'd have to explode the gif into individual frames and draw them dynamically to a canvas or something.
Same guy has ~32 "empty" packages published. Initially it felt like package name squatting to me. (names like `big-data`, `precache`, `eager-loading` which are really generic, then like a dozen `angular2-*`) He has plenty of actual packages published too though (&gt;100).
Visual Studio Code. 
What computer are you using which takes 30-60 seconds to open a chrome environment? You obviously have no idea what you are talking about. 
Give it time. If people keep thinking they can build anything and everything with JS/HTML/CSS, we will get there. 
What does this even mean? VSC also cant hold a candle to IntelliJ products. Save your arguments, I really do not care. The features sets are public online. That being said I use both VSC and PHPstorm every day. Different tools for different things, as with any skilled profession. 
&gt; VSC also can't hold a candle to IntelliJ products. LMAO, so an easily extendable editor can't do what you want it to? Okay, whatever you say. 
And they all fail the [bus test](https://en.wikipedia.org/wiki/Bus_factor)
If people keep building everything in JS/HTML/CSS then you will see the engines optimized. Nothing you have said so far has been backed by any facts.
Nice, we use the same method to test our endpoint in PHP, using Phpunit and [spatie/phpunit-snapshot-assertions](https://github.com/spatie/phpunit-snapshot-assertions). Had no idea someone else was using it for API endpoints testing!
Oh, they do seem like an active contributor. Hm, well I'm stuck here, I feel like I should do _something_ but I honestly don't know what's appropriate.. And thanks again for looking into the packages for me, I do appreciate the help.
Sure there are. https://docs.microsoft.com/en-us/windows/uwp/get-started/create-a-hello-world-app-js-uwp
Yep, lets add more shit to the shitpile and eventually it will touch the moon! 
Because they are opinions, and I have stated as much. Go optimize them there engines! 
Awesome! I hadn't seen it on php before. Yep, we are using it! Since writing this i have been contacted by quit a few people who say they have been dabbling, or starting to use some type of snapshots on endpoints. I think it's a great direction to go! I hope it catches on more and more.
It never hurts to send an email. The people at npm will know if it needs to be looked into.
What he meant is that it is an app equally regarded as having high memory consumption despite all the value it brings
Wow thx for the big analysis! - You are right, i should mention headless chrome. - The full-page screenshot is in the roadmap :D - I'm currently thinking about "hiding" some parts, for example ignore selector like `.ads-area`. - No, the result is a boolean true when the images are equal, false when the images are different but you can always see both images to compare. Thx again for your comment, feel free to open an issue with some of your ideas.
If you could convert it to something that can play in a `&lt;video&gt;` tag it would simplify things (like webm/gifv). You could do something like this, though you'd probably need to mess with timings and such to make it look good (I haven't tested this). window.addEventListener('load', () =&gt; { const video = getVideoElementSomehow(); video.play(); setTimeout(() =&gt; { const interval = setInterval(() =&gt; { video.playbackRate *= 0.9; if (video.playbackRate &lt; .05) { video.pause(); clearInterval(interval); } }, 100); }, Math.floor(Math.random() * 3000 + 3000)); }); 
sure, but when *I* say this months ago I get nothing but fanboy downvotes...
Nonsense. People who use React will outperform you and all of this will be much ado about nothing. Two years from now, remember to look back and note how not a single start-up was affected by this supposed danger. If you're the kind of person that makes technical decisions because you're convinced by the arguments of people who like to politicize everything, you didn't have any chance of being acquired anyway.
Forgot we live in a post-facts world now. Go ahead and believe whatever helps you sleep at night. 
Hahaha where are your facts showing that Electron is a `good thing` for the long run? Where is your proof the engines will be optimized if we keep building in them? Where is your data on how many Electron apps are monstrous memory hogs written by people who have no clue about native app development and just want to jam some JS? You use strong words, but I feel they are as baseless as my own. 
Devs are going to flock to the technology they enjoy the most. You're right they won't be thinking about the licenses for the most part.
If it's just a word changing fonts, why not just change the style of the word? Why does it have to be an image at all?
[removed]
[removed]
Judging a fish by its ability to climb a tree and whatnot... A more coherent comparison would include angular 2+ (not AngularJS), vue + vuex, react + redux, etc. There's nothing wrong with ember, but I feel that your'e comparing apples to oranges.
The author is PatrickJS (https://www.reddit.com/u/gdi2290, https://twitter.com/gdi2290, https://github.com/gdi2290). He invented the PatrickJS-ing, cf. https://twitter.com/jeffbcross/status/846512930971516928.
This would get you started https://github.com/matt-way/gifuct-js/blob/master/README.md Though the effect you're trying to achieve could be done without image at all.
Might have missed the point. [You should be type checking anyway](https://github.com/Sugarcoated/Fondant/blob/master/src/types/EntryField.js#L101) on programming APIs, even if they're just for you. Anything that you could mistake because you haven't referenced it in about a week needs type checking.
&gt; I don't understand why is a promise called when it is defined, it is so counter-intuitive to me. It is confusing! Take a look at [Fluture](https://github.com/fluture-js/) for a JavaScript implementation of Futures, which are pretty much Promises done right.
Hi /u/championswimmer, this is disingenuous and further posts like this will result in a ban.
With all the talk about Facebooks' licensing I'm surprised [Jest isn't under the same fear umbrella](https://github.com/facebook/jest/blob/master/PATENTS)
&gt; undeservingly so I dunno. I think it deserves it. 130MB executable for even the simplest project and signifantly more memory/CPU usage than nearly everything else I run is a big deal. More apps are moving to that and it really begins to add up. I shouldn't need to get a new laptop with 4 cores and 16GB of ram for a couple chat apps, and a couple menus. Whenever my machine feels sluggish and I see my CPU under heavy load, it's almost always an electron app or three that are doing who knows what. At some point, this stuff will get fixed and things will be nice but today, it's a big detriment to my computing happiness. 
Relax, let the npm team be the judge of it! They won't remove a package simply because someone reported it, they will have to review the case themselves.
I hadn't actually thought about that at all, i wonder if it is as big of an issue because it's not shipped with your code...
I'm hoping this project gets some traction https://github.com/pojala/electrino Could be a big improvement for many apps until electron can improve the situation.
Still surprises me that some people see their company going toe to toe with fucking *Facebook* in court, but in that case would not have the time or resources to switch to a different library.
Having worked with Ember for 7 painful months - my opinion of it is: 1. It sucks once the app gets to a decent scale 2. The doc is out of date - if there is any doc 3. Much of the help info out there contains deprecated elements. The correct elements often dont have doco 4. It sucks once the app gets to a decent scale. Did I say that earlier? Yes, I did. 
A twitter profile? Was rly hoping for a marketing page haha.
There are alternatives to React though, but I understand your point. 
Please don't *learn* that a system tray app of ~200MB that requires its own instances of both Node.js and Chromium in order to function is anything close to being "perfect" for application development going into the future.
Well you can blame that on Chrome/Chromium because Chrome itself is a resource hog. You're comparing the experience to opening a tab when you are in fact opening Chrome.app + a tab on your machine.
I've used it in about a dozen projects for the last 2 years. All things considered Electron is awesome. It's not all positive, but in many cases it beats making a native desktop app for each OS. If you are looking for a less bloated alternative check [Nodekit](https://nodekit.io/). Instead of bundling Chrome it uses the platform web view, and instead of bundling Node it mimics its api with the JS engine of the platform combined with some native code. This allows you to make truly universal apps for any OS. It's still not finished but close.
Thanks for posting this. None of my "electron js alternative" searches gave me this. edit: doesn't look like there have been any commits in a while.
It's not shipped but you'd be violating the license for the use of it I would think. 
I made the same mistake of looking at the main repo. If you look on each platform you'll see they are active. https://github.com/nodekit-io/nodekit-darwin-lite https://github.com/nodekit-io/nodekit-android https://github.com/nodekit-io/nodekit-darwin
I wouldn't debate you on that, I'm not super up to date on that license shenanigans, but using code is usually different than distributing it.
Thanks for all the feedback and kind words! I added support for command line interface with a /bin/ as suggested. Cheers!
Also check [Shrinkray](https://github.com/francoislaberge/shrinkray). Although it's very simple and only for macOS.
I'm comparing it to opening a typical application. 
But if I understand correctly, these big names have negotiated special version of those licences not available to smaller fry. Or is that a phurphy and Microsoft is subject to the same rights and restrictions as a startup? 
Perhaps the API has a way to change these settings on a live instance? If not, what's the problem with just creating a new instance?
It just seemed cleaner. I'd have the import for the API and config neatly in one file and could just access the initialized client. Yeah, not a big deal.
I'm not 100% sure I understand the goal/problem here. maybe add a function to your object and call that function on update? jira.updateFunction = function(newInfoObj){ //updates self.whatever = newInfoObj.whatever } configuration.onChange = function(obj){ jira.updateFunction(obj); }
Does any framework like angularjs plays nice with this? 
I build a company to get absorbed... What a terrible world this is. 
When we got acquired the lawyers made us remove all react code before transfer of business could complete.
links2 is better.
There isn't any technical reason it wouldn't, but there are probably some gotchas too. It's not exactly the same as developing for a browser.
Actually ended up doing just that. Thanks!
&gt; Where is your proof the engines will be optimized if we keep building in them? The fact that tech giants are pouring money into the web, unlike any other platform. V8 Just launched Ignition and TurboFan (May 2017) https://v8project.blogspot.com/2017/05/launching-ignition-and-turbofan.html Microsoft has created an engine and open sourced it (January 2016) https://blogs.windows.com/msedgedev/2015/12/05/open-source-chakra-core/ You can even draw parallels to other languages which have been successful such as Java. Java isn't the greatest, but the JVM has seen vast improvements. Simply because of its popularity, there is a lot of interest in improving it. The same thing holds true for javascript. &gt; Where is your data on how many Electron apps are monstrous memory hogs written by people who have no clue about native app development and just want to jam some JS? This isn't a coherent question, but it sounds like an excellent opportunity to talk about web assembly. WASM is shipping without a flag as of chrome 57 https://www.chromestatus.com/feature/5453022515691520 Electron hasn't updated to Chrome 57 as of writing this but will pretty soon. And WASM is available in electron behind a flag anyway. &gt; Where are your facts showing that Electron is a good thing for the long run? I saved this question for last because it's the least direct. Electron may not be the best solution for you. There are several instances in which you probably shouldn't use it. However, it is an incredibly versatile tool and as such deserves a little bit of respect. Blindly shitting on a technology is typically a sign of inexperience. I come from a background of native ios and android application development. When doing consulting, I find less and less of a reason to suggest people make native applications up front. I typically recommend writing a web application first and then if there is a demand for native you can expand. This approach allows companies to get something to market on all platforms easily. If there is interest in say iOS then maybe I would consider writing a native iOS app. If you are getting shitty performance on windows, write a windows app. Electron works very well for this common use case. Going straight to native on a UI application is premature optimization. 
* The reason why the images shift downwards is because of the `&lt;br&gt;` tags in-between the images. So, when the green image is showing, the rest of the images are hidden, but there are 3 `&lt;br&gt;` tags below it. When you go to the next image, there is now 1 `&lt;br&gt;` above and 2 `&lt;br&gt;` below. For the next, there are 2 `&lt;br&gt;` above and 1 `&lt;br&gt;` below, an so on. To fix this, just remove the `&lt;br&gt;` tags. * If you look at the w3schools example, it runs the following code to set up the slideshow: var slideIndex = 1; showDivs(slideIndex); Your slideshow script has this as well, but the `&lt;script&gt;` tag is included in the HTML before the `&lt;img&gt;` tags. To fix this, move the slideshow `&lt;script&gt;` tag below the `&lt;img&gt;` tags. This way, when the JavaScript code runs, the images are already in the DOM and they will be hid properly. * The popup code is working correctly, it's just that the CSS that makes it look like a popup is missing. Make sure to include the CSS from the w3schools example in a `&lt;style&gt;` tag in the `&lt;head&gt;`.
Alternatives which don't include a patent grant and probably all infringe on any React related patents that Facebook holds...
It's easier to drop your tests than your ui
You're responding like a chat bot, lol
I mean... Yeah... But it also a pain in the ass to rewrite tests from one framework to another. 
still seems doable than most native stuff today
Somehow I now feel like making a promise that complains if you call `.then` too many times :P
Writing "react licenses are bad"-posts on medium is now almost as popular as writing a redux or react lookalike library. 
If the two image don't match, you could composite them, one with an opacity. That would allow you to spot the differences. I think this is the command to do it. `composite -blend 90 baseline.png test.png result.png`
Why? 
The implementation of radix sort in the article is not optimized. It is just the simplest possible to indicate how the algorithm works. There is a better/faster implementation. https://duvanenko.tech.blog/2017/06/15/faster-sorting-in-javascript/ Did you tested with it?
Qt is also shit.
I was hoping to see a mention of [reformed](https://github.com/davezuko/react-reformed) in there. It's not so much a library as it is a Proof-of-Concept on how to do forms yourself with minimal effort and reusable bindings. I think it works especially well if you have a some non-standard requirements or otherwise prefer to do it yourself.
I'm interested which (if any) companies have paid the price for the "downsides" of this license
Argh!! The world needs Word documents, not more! Seriously though, nice idea.
Maybe they will disable it for iOS. I hope they won't but I'm afraid they will. We still need Web Notifications too.
Thanks for mentioning that out. I will have look and add it over here. 
As soon as you create the promise it will execute the function you passed to the constructor, and will either resolve or reject based on the random number. Promises are single use, so once it's resolved or rejected it can never be resolved or rejected again, it's state is fixed.
Gross
tl;dr * use variables * use scope * maybe don't write modular code? 1969 called, they want their hot programming advice back
If you give us your webpack config and the output from compliation that would be a lot easier to answer.
Such a strangely written and long article. Also not really JavaScript specific...
I can not show because I have NDA :/ Before I had problems with chmods and that was not compiling, now chmods are okay, like code, because freelancers are doing this and everything is okay. But I do not know why this want not to compile. 
Indeed, who knows. 
By chmods, I assume you were having some sort of permission issue, yes ? Can you write files yourself to the public folder ? Any errors in output from Webpack (it usually gives away stuff like this) ?
I have all permissions. This even not work when I have 777 chmods. I can create file and I have not any errors in webpack. Just 404 in console.
Brilliant news! We've been using Polymer 2 and webpack for a while now. I actually like having both HTML imports and ES6 modules.
This package and his other similar packages are most likely published to help stop people from installing malicious packages via typos. Usually these packages present a warning to the user on installation, but his just seem to be no-ops.
For some projects it might not be by much.
So, do you have any built files in your public folder after you run webpack ? Are you sure you're not just trying to fetch the wrong files from your client scripts and/or html ?
everything is good. When I do npm run dev my files are not compiling from componens/sass to public/css. I do not know why. Even with 777 chmods.
Well, when you run webpack you should see what files it imports and what it spits out (as bundles). So, if you don't see them, then maybe you don't have them defined in "entry" ?
I've been reading some articles about it and have seen several sources point out no one has been in this position yet. It's all hype.
Good article! I like the transparency and reasoning and very nice to see the Polymer team meet the rest of the community and adopt the most widely used tools.
But then you could use CSS.
in my webpack.mix.js i have sth like this mix.js('resources/assets/js/app.js', 'public/js'). .sass(.....); Where should be that entry?
Oh, so you're using Mix. Then something like this should be enough: mix.js('resources/assets/js/app.js', 'public/js'); mix.sass('resources/assets/sass/app.scss', 'public/css'); You should see the files end up in `public/js` and `public/css` respectively. If you don't... well then it's hard to say since you cannot provide the output. So I'll ask again, did you see any errors when running webpack/mix ?
&gt; mix.js('resources/assets/js/app.js', 'public/js'); &gt; mix.sass('resources/assets/sass/app.scss', 'public/css'); again nothing and no errors...
I hope Polymer takes off, its always left out when discussing frontend solutions albeit it's the one solution that complies with standarts the most
And what does the output say ?
just Asset Size Chunks Chunk Names mix-manifest.json 120 bytes [emitted]
Does the mix-manifest file contain anything ?
yes. for example "/css/app.css": "/css/app.css", 
The content in that file describes what it *should* have been bundled. So... are you absolutely sure: 1. Your sources actually contains something ? 2. The sources have correct read permissions ? 3. The destination directories exist and have correct permissions ? 4. You're not trying to use wrong files in your html files ? 5. The output files appear in wrong place ? Also, try to update your npm dependencies. Maybe you have an old release of mix with a bug.
what to do with npm? my chmods on all folders: drwxrwsr-x and files: -rw-rw-r--
Run `npm outdated` and see if you need to upgrade some of your libs.
I have to update: axios ,bootstrap cross-env laravel-mix
i can update but I have wanted and current the same
Try to upgrade `laravel-mix` then. If that does not work I don't know what to do as I'm out of suggestions.
yes, i prefer your non-solution. -_-
Great!
You may have too many dependencies.
A while ago i made a project that lets you set up "fakes" just from configuration which you can use with your integration tests. You can then use this same config and "run" it against a real URL to make sure your fake API acts the same way as the real one. It's pretty battle tested, used in a few places. https://github.com/quii/mockingjay-server Would be interested in feedback
Can you list your dependencies?
I find async/await more difficult to grok. It reads like synchronous code, but it's actually async and it takes me a while to figure out what it's doing when I read it. I have to think about it more than the corresponding promise code which makes the async flow more obvious and straight forward.
It's actually my notebook that's a bit old. 4GB ram and i3 M330, but I think the HDD is slowing down. "dependencies": { "antd": "^2.9.1", "babel-plugin-import": "^1.1.1", "babel-polyfill": "^6.26.0", "babel-runtime": "^5.8.25", "classnames": "^2.2.5", "cldr": "^3.5.0", "event-source-polyfill": "0.0.9", "exceljs": "^0.2.46", "file-saver": "^1.3.3", "handsontable": "^0.31.2", "immutable": "^3.7.5", "isomorphic-fetch": "^2.2.1", "js-base64": "^2.1.9", "js-cookie": "^2.1.4", "lodash.memoize": "^4.1.2", "moment": "^2.18.1", "node-calendar": "^0.1.4", "null-loader": "^0.1.1", "numbro": "^1.11.0", "pikaday": "1.5.1", "rc-select": "git+https://github.com/pindamonhangaba/select.git#npm", "rc-tree-select": "git+https://github.com/pindamonhangaba/tree-select.git#npm", "react": "^15.6.1", "react-custom-scrollbars": "^4.1.2", "react-dom": "^15.6.1", "react-dropzone": "^3.13.4", "react-handsontable": "^0.2.1", "react-immutable-proptypes": "^2.1.0", "react-redux": "^4.4.8", "react-router": "^2.7.0", "react-router-redux": "^4.0.0", "react-virtual-list": "^2.2.1", "redux": "^3.7.2", "redux-form": "^5.3.6", "redux-localstorage": "^0.4.1", "redux-thunk": "^1.0.0", "reselect": "2.0.0", "zeroclipboard": "2.3.0" }, "devDependencies": { "autoprefixer": "^6.0.3", "babel-cli": "^6.4.0", "babel-core": "^6.26.0", "babel-jscs": "^2.0.5", "babel-loader": "^6.2.3", "babel-preset-es2015": "^6.24.1", "babel-preset-react": "^6.24.1", "babel-preset-react-hmre": "^1.1.0", "babel-preset-stage-0": "^6.24.1", "cross-env": "^1.0.7", "css-loader": "^0.19.0", "express": "^4.15.4", "extract-text-webpack-plugin": "^2.1.0", "file-loader": "^0.11.1", "html-webpack-plugin": "^1.6.1", "image-webpack-loader": "^3.3.0", "jscs": "^2.1.1", "json-loader": "^0.5.7", "postcss-loader": "^0.6.0", "react-addons-test-utils": "^0.14.3", "react-transform-hmr": "^1.0.0", "redux-devtools": "^3.4.0", "redux-devtools-dock-monitor": "^1.1.2", "redux-devtools-log-monitor": "^1.3.0", "rimraf": "^2.4.3", "stats-webpack-plugin": "^0.2.1", "style-loader": "^0.12.4", "webpack": "^2.5.1", "webpack-dashboard": "^0.3.0", "webpack-dev-middleware": "^1.12.0", "webpack-hot-middleware": "^2.18.2" } 
The article mentions paypal uses Angular. Is it correct? Paypal has recently open-sourced an amazing react component: https://github.com/paypal/downshift Also Google uses Angular, but not for all their applications. I'm actually interested to have an overview which of their apps run on Angular and how big they are...
[removed]
If you're going to mention Redux-Form, you should also look at https://github.com/davidkpiano/react-redux-form .
Polymer might actually be usable now. Maybe. Probably not. I'll wait for the reviews.
Polymer, for most of its life, has been a pile of polyfills that just barely work, and don't work at all if you also use one of the much more popular frameworks (React, Angular). That, combined with its reliance on Bower, makes Polymer behave like gum in your hair. Web components are awesome, but I'm not sure if Polymer has accelerated them or actually set them back.
I wrote (yet another) jQuery pre tag formatter https://github.com/meowsus/prettypre 
Have you tried the spread operator (...) ? It's fantastic.
Or slow hard drive. :\^) 
They basically list all the new sugar except that one. Odd.
thats cute - still doesn't hold a candle to react
"Survival of the Fastest" Result: "We cannot simply predict a winner between the two but we will help you pick a side based on the given context." Why even bother with an article like that?
&gt; [TypeScript]'s biggest purpose is to simply provide a comfort zone to programmer who like me, were not comfortable accepting change and felt entitled to keep doing things the way they always did rather than learn something new. I disagree. There are approaches to development to which static type systems will bring little benefit and can ultimately slow down the feedback loop when compared to a dynamically-typed language. Hell, for most of my web dev projects, I wouldn't introduce it. However, I'm currently working on a larger commercial app (it's an unnecessary monolith, but the project was well-established when I joined) and TypeScript has really facilitated the development process; while public contracts are typically honoured, using a statically-checking compiler allows us to make fundamental changes with more confidence, especially given the number of contributors. TypeScript has its place, but shoehorning it into the smallest of projects is overkill.
everyone will have an opinion but please try to not use Redux-Form if you don't need it. It's an absolute mess, the api is super weird in tons of different places and it's a beast to manage and work with. I definitely regret using it in the production app I'm using it in.
FeathersJS is specifically made for building REST APIs, Atlas.js can be used for anything, it's just a state management container for components and some common functionality usually needed in Node.js apps.
Unless you have patents.
Yeah, I suppose that'll do it. Supposedly Yarn (or the most recent versions of NPM) is faster, haven't tried them yet with quite so many dependencies.
So I'm still in the learning stages of javascript and was introduced to ES6 recently. I'm not too sure what it is, because well frankly, it looks scary and I have no idea how to use it. Could anyone tell me what it actually is in a ELI5 form?
I think your question is backwards-- it's not that people count on variables not surviving outside of scope, it's that people aren't used to variables leaking out of scope. Using `let` is great for IDE completions. 
ES stands for EcmaScript, which is the official name of the JavaScript specification. ES6 is just the 6th version of the spec, or more simply, it's the 6th version of JavaScript. It includes changes to syntax and many new features. 
I tried only using `let` only when I truly needed it (conditional blocks and loops) but then switched to it pretty much full on instead of var. I tried searching for a best practice online and everyone basically said just use let and const but I don't 100% feel that's right. I think I made the switch because Babel just converts it to a var anyways. **edit**: I forgot to mention that `let` declarations are **not** hoisted so that's another useful thing about them outside of the loop/conditional scope thing. right? I feel like that makes for a good case to use them instead of var
VSCcode highlights out of scope `let`s as undeclared vars.
Sure. Will have a look into it. 
If I'm reading this right, this could be very good news for some use cases, especially when larger teams work on the same app. If you can now use npm or Yarn to do _non_-flat installs, and ES6 imports that you can rename modules as imported, that might mean that you can load multiple versions of the same component at the same time. That's ideal when you have small components that are littered throughout the project, and they make a breaking change: you could then migrate small parts of your application (e.g. individual higher-level components) to the new version while other parts still use the old ones.
Yup. Full agreement with this reason bomb. It's so tough in the JS world to find responses like this. Everything is either crap or revolutionary. Thanks! 
In this case, I would declare the variable before the loop.
Agreed
Another interesting one is [revalidation](https://github.com/25th-floor/revalidation).
This could be a huge pain, jest does a lot of mocking etc... But you may be able to switch to jasmine/mocha relatively easily if you don't depend on mochs too much.
I'll check it out! Thanks for sharing
It's not part of ES2015, is it?
vue.js beats both of 'em.
Array spread was, object spread was not.
react is a principle. react is in preact, inferno, react-lite, dio, domvm, mithril, bobril, vue and dozens of others, actually most frameworks today use/are react. FB's license is irrelevant for these. Looking at what react did to javascript, freeing it from the dom, solving issues even native systems are still struggling with, without breaking a single standard - it is questionable if polymer will ever get to that point, not to mention add to it. 
Hi zurfyx I am trying to use your eddystone-web-bluetooth library on a node project - I npm installed it just fine, went to plug it in and I think there is something missing. Is there something I need to require? This line gives an error 'Eddystone is not a constructor' var eddystone = new Eddystone() 
Yeah it's also great in combination with destructuring.
&gt; Everything is either crap or revolutionary. With so many libraries now, it couldn't be any other way. Lots of libraries which never get traction and so all the not quite revolutionary software dies on the vine. Essentially anything not revolutionary gets Math.floor'ed to crap.
Perhaps I was hasty claiming this is it's biggest purpose... I more mean this is the reasoning I most often see people gravitating towards it and evangelizing it for. I kind of think it's, not sad, but unfortunate that people cling to comfort. Kind of like how younger programmers try to solve everything with loops and conditionals and as you spend years debugging them you realize the goal is to use as few of them as possible and they often hurt more than help. I guess what it all boils down to is that we should probably teach more LISP. :)
I'm just dabbling in this theme, because i'm going to need a little accompaning app to work with a saas for the web I'm developing, so, If I may ask you: Is there any service in wich I can build and upload to the apple app store directly, or eventually I'll will HAVE to buy a mac to do that process no matter what? If the latter, wich one will be the bare minimun I should buy? (so I can buy some used one since I have no extra money to spend in a brand new macbook)
In addendum, it's basically just new features added to the language for you to utilise 
Sure! So in terms of Mac, honestly I believe just about any modern one will be sufficient in terms of compiling and building for the store. A good friend of mine used his 2011 Macbook Air for iOS app development some years back, and that was a totally OK experience. In terms of services, I've heard of [Macincloud](http://www.macincloud.com/), but I can't vouch for them – never used. Other than that, you have the [Ionic Package](https://docs.ionic.io/services/package/) service, but then you're bound to use the Ionic Framework for app development (I presume). 
If the API provides the ability to change this config, for example via setters on the instance, then use those. If the API doesn't provide this ability, then clearly this data is intended to be immutable for the instance, and you should not look to change it at all. Now, you did mention that 'configuration change event'. If this is actually provided by the very same API that provides this class, then that means there must be some way to change this config, provided by that API. In which case, you may have just overlooked it, or it's done in a way you didn't expect. An example for this would be if the class provided a magic `__set()` or `__call()` function with which this config can be updated. Looking at the configuration you provided though, it looks like the type of config that should not need updating often, if at all, in which case creating separate instances is usually the way to go.
https://twitter.com/WebReflection/status/900045568940138496
Exactly. And I mean popularity is a very big deal. Example. I've really read lots about Aurelia. It looks so well thought out. I think he's doing it right. But I'm not going to use it cuz React or Angular is so dominant using something else is basically accepting a bunch of debt, less programmers with interest, less plugins, less stack overflow threads. You can have the greatest ideas ever but changing things for the better has way more to do with the total package than your brilliant code. But aside from that you just don't get anywhere with the all or nothing analysis. Every tool has a best use and a poor use.
Additionally the `writable` configuration option defaults to `false` so you can't just overwrite the value.
&gt; I just hate how that looks It's more explicit. You can immediately see that the counter is meant to continue to exist after the loop. Using `var`, on the other hand, looks like a mistake if it's new code. &gt; some weird community obsession Block scope is better than function scope and function scope is better than file scope. By the way, Brendan Eich (the creator of the language) also recommends to not use `var` anymore.
You already figured it out while I was still typing my answer. Still I'd like to expand on this a little bit. &gt;Object.defineProperty has an enumerable option that defaults to false when adding a property. So it's not the same as doing myObj.key = value. It's not just `enumerable` which has a different default value here. It's all three of these: `writable`, `configurable`, and `enumerable`. All three will naturally be `true` when using a regular property assignment, while they will default to `false` when using `Object.defineProperty`. Also, there is a specific example that explains this case, in the very same reference you provided. So, on [this MDN source](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) scroll down to 'Adding properties and default values' (it doesn't seem likeI can direct link to this subheader). --- You can also try this for yourself! First, take your code and run it in a console (be sure to manually define `var exports = {};`). Now, log `exports` and expand the object. You should see two keys, 'default' and '__esModule'. You can now, for example, overwrite these values: `exports.__esModule = false;`. Next, try the code that Babel outputs (again, be sure to define `var exports = {};` beforehand). Inspecting the object should now show the `__esModule` key in a slightly brighter color! This is how the console shows you that it's not just any regular property, but it has restricted access (specifically, the color changes depending on the `enumerable` attribute). If you now try overwriting this property, it will silently fail.
Whats better, whats better about it and why is react garbage?
Oh wow. That's umm... &gt; Aug 3, 2017 Yeah, now I'm suspicious. EDIT: After thinking about this for a while, it looks like Facebook finally decided to patent React specifically because people are taking issue with the patent clause. This is an unfortunate but sensible decision on the part of Facebook.
Probably parse the html out into data, and use that to power some kind of componentized front end.
&gt; these are all personal opinions The point was that it isn't just this community. It's anyone coming from different (often better) languages and even the creator himself considers function scope a mistake. He thought function scope was good enough for those short 40-line punch-the-monkey-scripts. That's why he kinda half-assed it. &gt; I don't like the idea of defining an int outside of its scope. If you want to use a loop's counter one level up, you've to declare it one level up. Makes perfect sense to me.
*.xlsx is just a .zip file with html inside it.
Source can be found here: https://github.com/vnglst/koenvangilst.nl Still have some refactoring to do. Some of the html &amp; css should be moved into separate components!
is best think after tits.
&gt; if the language has a feature Goto. &gt; your risk of confusing people is minimal. Well, it looks like a mistake. You could add a comment that you meant to do this, but it's of course much better to use the option which does not look like a mistake and which does not require a comment. Using `var` in new code really doesn't improve anything. It only adds some pointless friction.
To extract the data from the xlsx file there are plenty of solutions, like automating Excel or using a parser like https://www.npmjs.com/package/xlsx. To generate the app itself, they probably standardize a JSON format for the app and draw a simple preview on the frontend based on that. The backend uses the same JSON to generate an app, either directly or using a framework like https://facebook.github.io/react-native/ or https://cordova.apache.org/ FYI Microsoft has its own tool https://powerapps.microsoft.com/en-us/
&gt; The exception that proves the rule ;) https://en.wikipedia.org/wiki/Exception_that_proves_the_rule Nitpicking 10/10.
So is it like coffeescript where it's just built on top of the javascript library? Or is it javascript itself but just updated?
In addendum, it was the largest update in years that finally implemented a massive amount of begged-for functionality.
Added features to vanilla JavaScript.
Same with WebStorm.
These related React articles may also be helpful, either as comparisons or use of the same approaches: - [8 no-Flux strategies for React component communication](http://andrewhfarmer.com/component-communication/) - [How to communicate between React components](http://ctheu.com/2015/02/12/how-to-communicate-between-react-components/)
Using this on a NodeList for a forEach is one of the greatest things in the world.
Your initial post was a bit inflammatory, but you've made a solid argument here. This recent flare up in complaints about Facebook's licensing with React doesn't hold much water: as you've pointed out, React has popularized a new (well, old, more like a game engine's render loop) way of building apps. There's a reason that "reactive programming" has become a popular jargon/buzzword over the last few years. React is just one of many libraries that enable this approach; preact and others provide the same functionality without licensing baggage.
Hey @Marmroby77, first of all, let me apologise for not having a working demo in the repository by the time you wrote me the message. I guess you tried importing it as a default import, when it is actually a named import (import { Eddystone } from ...) instead of just Eddystone (import Eddystone from ...). I will take it into consideration because it might be worth making it as a default import too since it is most likely the default starting point for most developers. I just added the README snippet in a demo project so that you can check it exactly as it is meant to work[1]. [1] https://github.com/zurfyx/eddystone-web-bluetooth/blob/master/demo/src/logic/try-it-out.js Just in case you want to check a real life use case (this time with Angular), you can check this other project, but it might be more complicated to follow since there's plenty of irrelevant code involved. https://github.com/zurfyx/memories/tree/master/src/app/parts/physical-web --&gt; pw-new.component.ts and pw-new-save.component.ts Let me know if I can help with anything else! You can also Tweet or DM me on Twitter @_zurfyx if you need more immediate help. 
Thank you for your reply
thanks for your response! I didn't knew macInCloud. It seems interesting; if I develop everything on windows, and it's working OK on android (being ionic, nativescript, or whatever), I think that with 4-5 hours in macincloud I shoud be able to compile and upload
http://eloquentjavascript.net/ and https://github.com/getify/You-Dont-Know-JS. What is your goal ? From your last bit. It seems like you just want to learn shiny technologies. Learning things like webpack, react-router. You probably don't need as much JS knowledge. 
Learn the *core* language. Understanding the core JavaScript will rid you of confusion when switching between environments (i.e. client-side in the browser as opposed to server-side on the server). From there, what is left to understand are peculiarities of a particular JavaScript-centered technology that you're trying to tackle, not so much JavaScript itself. With that out of the way, what I would advise you to take as a first step is to read Kyle Simpson's You Don't Know JavaScript which is free to read on [GitHub](https://github.com/getify/You-Dont-Know-JS). Albeit a little dry it is an amazing resource for understanding the core language. From there you need to commit to mastering a singular technology such as React or Node. Trying to learn too many things at once will only confuse you because you're not learning JavaScript, remember, you're learning a particular JavaScript-centered technology. Learning any JavaScript-centered technology is much more involved than simply going through the introductory guide and certainly has much more to do with *understanding the given technology's philosophy and approaches to solving a particular set of problems* than understanding JavaScript itself, but don't expect to be able to understand the former without understanding the latter. Next steps depend on your particular interests, but boil down to-as always-building projects.
 function addMuzeu1() { var marker = L.marker( [44.936664,26.01286159999995]).addTo(groupB); marker.bindPopup( "&lt;b&gt;add your stuff"); } var groupB = L.layerGroup(); addMuzeu1(); You are adding to the map, before adding to the layer group, it should work if you change it like in the code above.
Ant designs React components are the fucking shit. No other react library comes close in my experience
Thank you for your very informative reply. I will look into all of this.
xlsx is the Microsoft Excel spreadsheet format...
Which is .zip file with HTML inside it.
XML not HTML. 
I don't seem to find uses for this that often. What am I missing?
[removed]
I am creating 1-3 videos a week about JavaScript Basics and then moving onto JavaScript Beyond Basics playlist. Check it out www.devdelight.com/videos
right, cause a prolonged legal battle with facebook is a non-threat to me or my business on account of they (probably) have no case and we have unlimited legal funds. 
The word "trivial" is dramatically overused but I still think they have a point. If it's your goal to work as quickly and efficiently using the tools you're fluent in, maybe static typechecking does not appeal to you (it doesn't for me). However in the bigger picture typechecking is not a huge context switch, any more than, say, the need to write a comprehensive unit test suite. 
it's not so much "reactive" as it is data-driven &amp; declarative view construction with automatic dom reconciliation. it takes away manual dom manipulation and the brittle, error-prone housekeeping needed to sync state &amp; ui.
My books may be what you are looking for – they cover JavaScript in depth and are targeted at people who already know how to program: http://exploringjs.com
/r/indianpeoplefacebook
[removed]
Agreed, and good points. I think our definitions are actually in agreement. Though my "reactive" is needlessly vague, I mean to imply that the view and its DOM reconciliation are "reactions" to data—or data-driven—in this way of thinking. However you want to define it though, I am very grateful to not be wasting time with boilerplate &amp; handling all of &gt;the brittle, error-prone housekeeping needed to sync state &amp; ui. when writing webapps nowadays :)
react makes you a 10x dev no ez :/
I havent written that much javascript lately but I found uses for it all the time. This was react+redux though so not mutating your objects was kind of even more important. You can use the spread operator for ghetto object assign if you want, as an example: const x = { foo: 'bar' }; const y = { ...x, bar: 'baz' }; // =&gt; { foo: 'bar', bar: 'baz' }
[http://i.imgur.com/WrKPhfd.gif](http://i.imgur.com/WrKPhfd.gif)
&gt; if the language has a feature, it's ridiculous to not use it `with` though
Looks good. How easy was it to switch out React with Preact in Next.js?
If you're looking for a fast survey/overview on object-oriented javascript, this is definitely worth an hour of your time: https://www.youtube.com/watch?v=O8wwnhdkPE4
In my code `let` always signals that the variable may be reassigned. Everything else is declared `const`. 
I have a feeling that the reason your csv-stream.js file was so slow is because you were setting an encoding when you called `fs.createReadStream`. This tells node that you want to call `.toString('utf-8')` on every chunk of data you get from the file system before piping it on to csv-parse.
Thanks for the thoguhtful reply! I've worked in both and while I totally do see and agree with your point... as a programmer you should be able to deal with whatever too, facts... I think my issue with the use of trivial is that it's usually used to refer to small code bases. This issue I find with this argument is that type systems are the number one cause of immense untenable code bases. The trend I always found projects falling into is starting off with this great hierarchy that was designed to emphasize code reuse via inheritance, requirements changing, and eventually the whole thing becoming a chore of copy pasta any time you want to add something to the system. The formula that's worked (for me, and my teams) has been componentizing the UI, never ever mutating data from the back end or whatever service to drive that UI, and reusing/compressing code via lodash into digestable bits around them. Typing can exist in so many more places than a class structure and can actually be implicit in tight designs. We built out a HATEOAS driven component arch once that was simply gorgeous and to my mind so much more effective than writing out 100s of classes based on assumptions you make at the start of your project. To me it's not really about learning new systems or context. It's about typing systems rigidity balooning your code and creating technical debt that eventually bankrupts you.
The latter. It's still JavaScript. It's fully forwards compatible as JS will always be.
This is ES7 syntax, IIRC - it isn't supported in ES6 currently. The spread operator can currently only be used for arrays and parameter arguments. I tend to find it's useful for 'rest' arguments - a function that takes any number of arguments and can process them as a list. It's more clear an obvious than the magic `arguments` object. function addTags(post, ...tags) { post.tags.push(...tags); }
Damn. Babel is a hell of a drug, I guess!
Typescript for me, but yes! Tbh, I was more amazed realising suddenly that `Object.assign` is ES6. OTOH, it explained why the code I was writing wasn't working in IE...
Im using it to take a list of child elements and spread them into an array so I can call forEach (or other array methods) on them
There's really no reason not to. Having variables accessible outside of where they will be used allows potential errors. Additionally since uninitialized variables are globalized it's nice to know if there's a mistake it won't persist anyway
Ah okay, converting array-like things to an array. Have done that a few times. Not sure if I'd go for that or `Array.from()` in production code, for clarity.
Rest isn't the same as spread(?). Just the same syntax. I guess they are kind of similar though.
That's pretty exciting, although sounds like it's ES7. Basically a more flexible `Object.assign()`.
I made this course for exactly this target audience. Feel free to try the lessons and see if you like them. https://www.educative.io/collection/5679346740101120/5707702298738688?authorName=Arnav%20Aggarwal
I put a comment saying what it did so I definitely understand the clarity argument. I personally prefer the '...' syntax
Rest parameters still use the 'spread' terminology in a lot of the documentation I've seen. It's essentially a context-specific operator, although IIRC it's parsed as syntax rather than an operator.
Yep, although semantic-ui is pretty good as well. I was using it before, but most of it still used jquery and I had to redo a lot of components by hand. Ended up just switching over to ant. The downside is that ant has no virtual rows implementation, and it's not easy to extend the components.
When react eventually fades away, all the components that were written in it will be unusable. We can already see that - The same basic elements get written again and again for every new view library that pops up. How many material design implementations are we at already? Web Components are different. You write them once and then use them everywhere else just like any built in HTML element. The fact that they happened to be written with Polymer is just an implementation detail. Now that they've finally given up HTML imports and bower and use NPM and ES6 modules like the rest of the ecosystem, it should be truly painless.
```(pattern)```: https://javascript.info/regexp-groups ```\1```: http://www.regular-expressions.info/backref.html ```g```: the engine updates the lastIndex property if that flag is present or quoting MDN: *"g global match; find all matches rather than stopping after the first match "* You can find more infos on js regex [here](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp) 
I tried removing that, but it made no difference in the performance: - 9.858s with `{encoding: 'utf-8'}` - 9.796s without So our culprit is elsewhere.
This started off well and suggested good etiquette for code reviews. However, it quickly turned into a code quality/standard article.
I dont like the concept of losing our patents because someone in some other department of the same institution uses react. 
I pretty much exclusively use `let` when I want to set a default and then modify it in a conditional block that is more complex than is readable with a default operator. 
Could you link to the csv you tested this with? Or can you try using [this module](https://www.npmjs.com/package/csv-parser) instead with the `raw` option set to `true`?
You can find all the code &amp; data [on GitHub](https://github.com/danvk/async-iteration). I'd love some insight on how to make the streams version faster.
You don't lose your patents, but I can understand why people who think that you do thinks this is such a huge deal You lose the (undisclosed) patents Facebook granted to you in React. If you continue to use React, Facebook can sue you for patent infringement, which according to the guy writing the article, will cost Facebook $1-2 million to start the suit for 
Thank you for your reply
You could do this too. function LookAndSay(str) { return str.replace(/(.){1}/g, function(seq, p1) { return seq.length.toString() + p1; }); }
Tried in 2015. It left a bad taste in my mouth. I'll wait until it's actually usable in version 5. Maybe.
Yeah this shit is just dev who have never been through an acquisition reading opensource disclaimers for the first time. 
Im still concerned about the case where for example: My company developed a compression algorithm called 'middle out' .. we use it internally to compress or encode our files on our platform with no public tools or offering, we hold a patent to the tech. Than a random startup, X , has a public offering of a tool that is suspiciously similar to ours, so we check and it is one to one our technology. We start litigation and in discovery we uncover that the tech wasn't develop at startup X but licensed from a subsidiary of Facebook named LULz. Now despite our patent predating any claim from LULz to OUR tech in any such form as copyright or patent claim .. the fact that we started litigation for patent infringement opens us up for liability of the same thing .. *ironic* .. because an unrelated app from one of our teams, uses react. Now Facebook has the power to strong-arm my small institution, that only wants to do the right thing an make the world a better place, into an outcome that favors Facebook at large. Even if it only cost 1-2 million dollars for Facebook to start proceeding what they stand to gain justify their upfront cost bro. Our tech is potentially worth billions bro, combined with potential loses from LULz .. Facebook stands to gain from this clause. Where does this leave me and my Institution, well its too late bro we are already exposed to patent infringement from the second we started proceedings .. Facebook, moved fast and took everything we had. Years later it comes to light that a disgruntled former employee went to work for LULz and created a clone of our algo in violation of our NDAs .. wether Facebook knew or not, is yet to be determined but one thing is sure, we lost in the opening move. 
Const seems almost worthless since you can still change anything inside the object. 
I am looking for a strong knowledge of vanilla JS apart from the libraries (react, angular, etc). I would like to be able to write a complex from start to finish with minimal googling
That's exactly what I use it for. I've grown accustomed to using `const` exclusively for any variable/function assignments except when needed for things like a `switch` statement.
Knowing a value is not going to be reassigned and encouraging developers to not reassign them are both boons to code legibility. Const was never trying to cover immutability. 
Maybe I'm misunderstanding you, but it sounds like you mean this is worthless... const o = { a : 123 }; ...because I can change a inside o. And that's certainly true, but const isn't making the object itself immutable, it's making sure o never points to anything but that object. It "protects" the object reference, not the contents of the object itself. Did I misunderstand? 
I'm not sure if you understood that you don't lose your billion dollar patent just because you lost your patents to use React? Just because you use Facebook's patents does not grant them the right to use yours. You would sue the subsidiary, and lose the patent rights to React, but only to React. The subsidiary would still be infringing on your billion dollar patent, it does not become Facebook's or their subsidary's
If your argument is that Facebook could be dicks, steal your patents and bury you in legal costs if you sue, even if they have no case, then wouldn't you be screwed with or without the Patents clause?
Same with `final` in Java
There appear to be absolutely huge performance differences depending on where it's run for example I ran this from your blog: async function* asyncRange(from, to) { for (let i = from; i &lt; to; i++) { yield i; } } (async() =&gt; { const start = Date.now() for await (const i of asyncRange(0, 550000)) {} const end = Date.now() console.log(end-start) })().catch(e =&gt; console.error(e)); Using typescript's compiled version which took ~800ms, using the d8 shell which took ~400ms which isn't great but not terrible. But then we try it in the browsers, both the chrome dev channel and firefox nightly took ~10 seconds to run that, so I dunno what's happening in the implementations that cause such wildly different performance.
Looking at the webpack config, just aliased react to preact. Question to the OP: did you try without compat and did that work?
'pejorative'... 'slur'... 'bigots'... *yeeessshh*
&gt; The trend I always found projects falling into is starting off with this great hierarchy that was designed to emphasize code reuse via inheritance, requirements changing, and eventually the whole thing becoming a chore of copy pasta any time you want to add something to the system. this isn't a problem with 'type systems', this is an issue of modeling and methodology. 
The reference can't be reassigned, that has value in itself. I assume you're already aware of `Object.freeze`?
So your code is only toggling the class name for whichever element was clicked. You would need some logic to toggle the previous element.
This issue came up in C# new AsyncIterator pattern as well problem there was every task must be allocated. One of the reasons ValueTask (stack allocated task) was formed. Lucian is/was the leader at microsoft in this effort. https://twitter.com/lwischik?lang=en https://stackoverflow.com/questions/43000520/why-would-one-use-taskt-over-valuetaskt-in-c Really cool video with lucian about c# concurrency. https://www.youtube.com/watch?v=5MnfrL7gfEs
lol html
I'll be so happy once object spread makes it's way to node.
The worst thing about ES6 is when you're not using ES6. So many game changers.
If so many other companies are fine with licensing that does not include this, what makes Facebook so special that need to include it? They have not offered a compelling justification imo 
Hmm I see what you are saying. We are still exploring other options. Currently we are thinking of going with a cordova [ vuejs, plain es2015, ..] but that might not take off, their build environment is much more complicated than react native. Edit: I don't like when people use tactics like reducing things too the ridiculous i.e. 'paper tigger' when it could very well be a Trojan 🐎
Thank you very much for your reply. The config change event is actually through the vscode extension API which is separate from the other API which I'm integrating into my extension. In short it looks like the best way its to create a new instance. I think I've found a nice way of doing it by creating a new method on the instance to do just that :)
Babel. &lt;3
Meanwhile I use it once per function on average.
I understand how const works, I just think it's dumb, it's too lightweight and protects too little. 
Yea I do use babel to get it today.... but if object spread was out of the way, the need for babel dwindles. Aside from jsx transpile, I think that's about all I'd need it for... for node anyway. I'd much prefer if I can just write modern JS and not have to dig through sourcemaps or transpiled code to see what it *actually* looks like.
[removed]
I can't bring myself to use arrow functions when assigning to variables. This just looks horrible to me: const foo = name =&gt; {} 
It’s there as of 8.3.0
It's been 9 hours and this has no comments. But I loved every minute of it. Thanks for sharing.
That’s one confusing thing — `let` and `const` declarations **are** hoisted to the top of their enclosing block. However, they are poisoned and will throw a `ReferenceError` if accessed before the declaration statement is executed (the TDZ). The difference is usually not relevant but it does mean that you cannot declare a let/const that shadows an outer identifier while still using the identifier in the initializer expression.
Well I'll be! I even looked at the changelog and didn't see that. I guess it comes with the new V8 version in 8.3
I don't understand your criticism. Perhaps you could explain how you believe it should work as contrast? 
See I don't agree. A typing system is going to take more code organized into more files. If you need to make a fundamental change outside that hierarchy, you need to overload operators, you're going to run into problems. Sure. Perfect modelling and design circumvent this. But when you drop into legacy that's been maintained by countless people over a decade the strict opinions of a type system results in bloat and technical debt. What's a type system really doing? It's organizing lists of strings, numbers and booleans in collections. Sounds a whole lot like Json to me. You need classes in a front end framework? Outside of your components/directives? You need to perform specific functionality on that? Use a line or two of lodash and control that specific functionality with higher order functions. It reduces code size. And that reduces files/lines and thus debt. Typing boats.
All at once now! const asyncPowerSeries = ({ threshold, coefficients, constant } = {}) =&gt; ( x =&gt; Promise.resolve( coefficients .slice(0, threshold) .reduce((sum, c, i) =&gt; ( sum + c * (x - constant) ** i ), 0) ) ); const threshold = 100; const coefficients = Array.from(Array(threshold).keys()); const constant = Math.PI; const powerSeries = asyncPowerSeries({ coefficients, constant, threshold }); powerSeries(3.9987357461).then(val =&gt; console.log(`It's ${Math.floor(val)}!`)); // It's 42! (okay you got me, I snuck in the exponentiation operator)
type systems doesn't imply anything about files. a type system lets you articulate what something is. types are boundaries and shapes.
I find it weird that you'd step through an array and break out at some arbitrary point instead of filtering down the items first, but: let myPassingItems = someArray.slice(0, someArray.findIndex((v) =&gt; condition))); myPassingItems.forEach(doWhateverPassingIs); console.log(`${myPassingItems.length} items passed`); At least your `doWhateverPassingIs` function doesn't need logic to break out of a loop and you have an array of only the items that "passed" where in your for loop, you'd have to append them to another array (hopefully not in your "passing" method)
One eslint rule that I find helps a lot with this is to forget the non-paren form exists and always use parentheses around the arg list. Makes arrow functions in the middle of statements more recognizable. `const foo = ( name ) =&gt; {}`
if you're using React shouldn't you be using [Material UI](http://material-ui.com/)?
Doesn't Babel transpile `import` to something like (pseudocode): if(not already imported) run module and save exports replace import statements as appropriate to satisfy the ES2015 spec that `import`ed module files are run at most once?
afaik react itself is not covered by patent. you don't have to stop using react.
Good to know. What are virtual rows?
A lot of ES6/ES7 looks like it's trying too hard to be clever, which is not good for a programming language. It actually is more difficult to follow some of the new features. 
Polymer isn't a UI framework like that; it's like jQuery for Web Components.
is it really that difficult to understand that "constant" means never changing? const on an object is practically useless, because if your code is so dense and your functions so large that somewhere you accidentally try to reassign a const object, it means you are also breaking other rules like; keep your functions simple. accidentally reassigning an object should never become a concern if you keep your functions small and easy to follow.
You might like babel-preset-env: https://babeljs.io/docs/plugins/preset-env/
then it shouldn't be called 'const'. it's a bad name for a half-assed feature.
Object.freeze should not exist, and const should make the entire object a constant.
Took me a while, but now my eyes like it as much as my fingers. But I guess you could say that about a lot of things.
Love me some brunch. Fantastic build tool that doesn't get enough attention. 
No need to get snippy. The argument you make could be just as easily applied to any non-reference type. Are you suggesting that the idea of const itself in ANY form is anathema? 
You can redefine the window.location getter to return whatever you want.
You can say that all you want. It's not required bit it's what happens. Claiming that type systems don't result in larger code bases is simply false. 
What would lead you to believe that? You can use whatever you want.
Thanks guys i have found it by my self. so it just use drawcallback function inside datatable http://i.imgur.com/tEKxLe6.png after that use editable function inside drawcallback function like in the picture. your data now can be ditable dropdown or text inline or pop up. Now next step is the hard part for me how to handle this editable form to be submitted to the database lol
That's why I say almost worthless.
no offense, but it doesn't seem like you know much about types or type systems, or are misunderstanding the terms.
If I create an object and declare it const all that means is that I can't reassign the name of it, it does nothing to protect the data inside that object. So in reality it doesn't block you from still screwing up your data like you would expect const to work in most other languages. I use const to indicate that I don't want the value to change but nothing in the language actually prevents that so in reality it protects very little.
I use node on my personal pc and installs are a very fast process (especially with 8.0.0 + npm 5.0.0). I also use node in my work environment, where all requests go through a large scanning/proxy process and it takes 100x as long. Point is, your environment is probably the issue.
It needs to be a standard first.
Object spread and rest still aren't part of any ES. ES2017 is the most recent one (making it ES8 by version number convention, and even it doesn't have it). It's in Stage 3 as of now.
I think it's my bad. I didn't realize I had a mega browser extension installed. Makes me seem stupid here. Thanks for the help.
These are the results I got when I tried a script I wrote: user@calidreaming:~/async-test$ time wc -l stop_times.txt 549996 stop_times.txt real 0m0.012s user 0m0.008s sys 0m0.000s user@calidreaming:~/async-test$ python3 line_reader.py Read 549996 lines, 4949964 bytes in 0.530913 s user@calidreaming:~/async-test$ node stream.js Read 549996 lines, Read 33421381 bytes in 0.112739 s user@calidreaming:~/async-test$ ls -lk stop_times.txt -rw-r--r-- 1 user user 33421381 Aug 22 23:49 stop_times.txt From what I can tell, the python script isn't counting up the total bytes correctly? Here's a link to the [gist](https://gist.github.com/acidDrain/65814490d97c7af1ec73f539d3a3f7bc#file-node-async-read-js), let me know your thoughts.
Lol. I don't know about them cuz you lack the XP to have seen them fall apart? Really now... How about you provide a reason beyond "yeesh" and "you must suck and not know what you're talking about." seriously. Thanks for the examples of exactly what I'm talking about. 
It is in the standard... well, stage 3 - candidate, anyway. See the other comment from this thread.... this is actually in node 8.3! And you can use it in chrome and firefox today without transpile. Not sure about other browsers. 
Were these results posted anywhere?
what according to you guys is a better one?
It makes a nice feature for change detection forcing you to put it in a new list
I updated the [script](https://gist.github.com/acidDrain/65814490d97c7af1ec73f539d3a3f7bc) to demonstrate the async factor and speed: user@calidreaming:~/async-test$ node stream.js 0.00795539 s I'm doing other stuff now while this data is being processed. 0.00925629 s Python would be blocking and not executing any other code but the for/while loop Read 549996 lines, Read 33421381 bytes in 0.125938 s 
Ah, you're cheating! You're reading the entire file into memory, which streams and async iterators are designed to let you avoid. The read happens asynchronously, but you still gobble up more memory than you need to. BTW the Python script is buggy; it's reporting the number of CSV values rather than the number of bytes.
The web components spec forbids this so there would need to be a tool to work around it. One custom element defined as 'my-element' cannot co-exist on the same page as another element named 'my-element'. I believe the second definition attempt would either error or be ignored.
Yeah, it bothers me they let those be optional. I get it it's for functional programming, but it's cleaner to have the params in my opinion. I make my team do it.
ever hear of the expression "not even wrong"?
I think 8.1 or 8.2 with --harmony 
 function doSomething(options) { const newOptions = { ...options, someOption: true, secondOption: false, } doSomethingElse(newOptions); } ... very handy and a very common use case. 
Very easy indeed! The Next.js project has some really good examples for most use cases. Also one for using preact: https://github.com/zeit/next.js/tree/master/examples 
I just followed the example in the Next.js repo. I will give it a try, but I don't think it'll work (assuming the example in the repo is the best way to use preact 😉). Edit: tried it, doesn't seem to work. 😞
Stage 3 "proposal". V8 devs decided to ship it without waiting, but still doesn't make it standard __yet__. Things can go south is what I'm saying. Probably wouldn't, but can.
I'm a little surprised by the Polymer hate in here. I use it at work and I've found it great and easy to use and reason about. I've used React as well and while I also liked it, the reusability aspect of Polymer is very appealing. 
&gt; Brunch does not yet support dynamic imports, and it doesn’t process images and fonts This is why I use webpack. Webpack can certainly be slow and sometimes confusing. But it does exactly what I need and more. The days before webpack were horrible.
... huh? for anything that needs to happen asynchronously. Marking a function async and then awaiting on it doesn't make it become asynchronous / multi-threaded on it's own, you still have to use some asynchronous function inside it. 
Yuck
That's true, but as far as I know, it was the HTML Imports spec that required you to import a component by its own name. If you can rename it upon import (e.g. using ES Modules), you can have both `my-elementv1` and `my-elementv2` on the same page.
8.1 with flag
So if I put a 1000 iteration for loop in an async function, it won't run separately? 
&gt; The fact that they happened to be written with Polymer is just an implementation detail. That is just not true. If you're writing a component using Polymer today, you cannot use that one the same page with a component that is using Polymer 5 in the future. Furthermore it will also be using polyfills for a lot of things that will in the future never have been standardised (like HTML Imports), rather than whatever is standard by then (e.g. HTML Modules). Web Components are a great idea and Polymer has lofty goals, but you're really not that future proof if you're starting to write it today - and in fact, I'm willing to bet that you'll have to do less rewriting if you're writing a project in React today. In the future, who knows. Hopefully you won't need Polymer at all.
Unless there's a noticeable performance hit I don't really see any reason to not use Promises/async/await. The only time you're even likely to notice a performance hit is if you're doing large amounts of work using small asynchronous chunks (e.g. processing network streams) and even then you should test that you can observably see the performance hit.
I think the confusion is that "reactive" is already [a thing](https://en.wikipedia.org/wiki/Reactive_programming) that's different from how you used it :) (Although [you could view React+Redux as fitting that paradigm](https://vincenttunru.com/Javascript-reactive-programming/#frp-today) somewhat, if you squint hard enough ;-) )
Thanks!
not unless inside that loop you are doing something that is actually asynchronous, like making a http request, or some such. and then you wouldn't actually be waiting on those (unless you used 'await' on their trigger), you'd be running them all in parallel, and then returning asap. marking a function "async" means that it will return a promise, and therefore you can use the "await" operation (operator? command? what technically is 'await'?) on it. If you want it to actually be asynchronous, then you need to resolve that Promise as a result of some truly asynchronous operation. .. not sure if this is making sense here, because I don't know how much you know. 
Basically the parts between `await`s in your code will be run synchronously, so if you have a `for (let i = 0 ; i &lt; 1000000000 ; i++)` loop inside an `async` function it'll still block anything else running when it's reached (unless there's `await`s inside your loop). If you need to do work that involves heavy processing of data I'd recommend creating a new thread (in browsers this is using [Worker](https://developer.mozilla.org/en/docs/Web/API/Worker) and in Node.js this is the [child_process module](https://nodejs.org/api/child_process.html)) and sending data to it to process then sending the result back. If you have any questions on how to do this feel free to ask. Do note that some things *already* happen on a seperate thread, e.g. if you `fetch()` a resource the downloading happens on a browser thread and the `Promise` returned is resolved when that finishes with the result without blocking your main application.
I'd say await is a keyword, like let, const or function. 
X-Post referenced from [/r/node](http://np.reddit.com/r/node) by /u/AdventurerSen [Here we go again: Node.js forked to Ayo.js (io.js)](http://np.reddit.com/r/node/comments/6vhbit/here_we_go_again_nodejs_forked_to_ayojs_iojs/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
It's not a keyword in scripts however inside `async function` it gets treated as if it were a keyword and specifically it's an operator like `yield` or `+`. In ES modules `await` is always a reserved keyword that can't be assigned.
What other use cases does race become necessary? I can only think of the general case where Ajax and timeout are used to fail the execution if network took longer than X seconds.
That's ES7 though? See /u/MrJohz comment above.
Oh good more SJW drama. I'm all for inclusiveness but I hope these radicals never come back and political bullshit stays out of the community forever. It's been going way too far for too long. Maybe it *is* better to split the communities and have one that focuses on tech and one that focuses on providing a safe space because I am getting very tired of the constant drama and witch hunts. 
I don't know the whole story and it's still office hours over here so no time to dive deep but the involvement of nodebotanist is a huge red flag.
Rollup for Libraries and Webpack for Application. Defacto standard. 
I am curious how Polymer will now handle relative paths by moving to ES6 modules, since `node_modules` essentially sits outside of the HTTP serve directory &amp;mdash; whereas with Bower you can have `bower_components` within the HTTP serve directory and use `document.currentScript` to get the JS file path, and then use that path to find the CSS and images relative to that directory. In the case of npm, for handling the JS it's easy to understand with `import 'x-tag'` as that will take it straight from `node_modules`, but how are they going to serve the accompanying CSS documents? I suppose in this case they could inline it in the JS, which may not be the smartest idea because then components would take longer to load. However then you throw images into the mix, and assuming they aren't going to inline images in the JS, how are they going to know the relative path of `x-tag`'s images? I ask this because [I've been working on a web component library](https://github.com/Wildhoney/Switzerland) for quite a while now, and can't think of a way around knowing the relative path of a component's assets when using npm, not without user configuration, anyway.
Does it do anything Flot, Chartjs, D3 / C3 can't do?
It does what it needs to do; I'm not quite sure what you have against it or why. Use let if it bothers you.
These features are 100% apart of official JavaScript. However they are not yet fully supported in all browsers or on node.js, hence the community uses Babel which is comparable to coffeescript (in that it takes code that wouldn't run and transforms it into code that would) which lets us use the new features and even some features in the proposal stage. It's great for exploring new ideas and keeping up with the ones that make our jobs easier.
Looks nice, but you lost me when I had to create an account. 
A Promise rejection is the async equivalent of an exception. By ignoring rejections, you prevent the caller from handling errors. If you really don't care about the error, it'd be much better to return a no-op Promise in a catch: Promise.race([ Promise.reject('error').catch(() =&gt; new Promise(() =&gt; {})), Promise.resolve('foo') ]); The new Promise will never resolve or reject, effectively taking it out of the race, but you also have the opportunity to clean up from the error, log it, etc.
Say you're writing a dialog, and want to present the user with an OK/Cancel prompt. The OK button resolves to 'OK' and Cancel resolves to 'Cancel', but clicking on either of them dismisses the prompt. Or you're writing a trivia game, and the first player to buzz in earns the right to answer.
the dialog case doesn't make sense for race. The game show case seems to be a bit higher level business logic which totally fits the solution the blog talks about.
That's exactly why I don't use webpack. I was quite turned off by the fact that even simple shit like typing an image URL where I wanted and image stopped working and I eventually ended up pulling my hair out over every tiny thing with webpack. It's shit and I prefer Rollup. Will check out Brunch though.
Use Happypack. Super fast webpack builds...
&gt; A lot of ES6/ES7 looks like it's trying too hard to be clever Block scope surely isn't one of those things. My least favorite addition was destructuring in parameters. All I wanted was named parameters with default values, not this jumbled mess. function foo({a = 'A', b = 'B'} = {}) { ... } foo({a: 'AA}); Dart: foo({a = 'A', b = 'B'}) { ... } foo(a: 'AA'); Not only is the JS version a lot noisier, you're also allowed to put arbitrary complex expressions after each '='. Why you'd want to put calculations into a function's signature is anyone's guess.
Wrap the functionality in a function and return the value to a const :)
const refers to there being a constant reference. const is about binding, not immutability. That means as long as the reference stays the same nothing else matters. It was never about immutability, you've just made that assumption and when it didn't line up with your assumption you call it dumb.
Yea, I agree it's bullshit how complicated webpack is. It is what it is, because the web is an insanely big place. Webpack is crunching js across an insane variety of purposes and intentions and the JS community has a famous habit of competition in every library. Languages with near totalitarian control can enforce single libraries and workflows, Ruby on Rails for example. The wider web is just to fragmented to ever come to a consensus. Do we support ESModule static imports or do we do dynamic (nodejs) style? What if you want to tree shake your library, but you've got dynamically loaded configurations? Should you transpire and uglify your nodejs code? Or include source maps in your front end production build? They sound asinine but these are the boundaries that web is pushing. JS is in our native apps, browsers, servers and soon VR. Hopefully we figure out how to disarm the ticking shit grenade over choosing to standardise dynamic imports. That one's going to piss people off either way. 
 Child.init = function (_this, arg1, arg2, arg3) { Parent.init(_this, arg1, arg2); _this.arg3 = arg3; }; Child.prototype = Object.create(Parent.prototype); 
I just used Brunch to replace a static site Jekyll install that I wanted to use NPM modules with. Super simple to set up and has a pretty nice plugin community around it. I hope more people use it as I found once you get into the depths, the documentation starts having black holes. Nothing solves doc issues like people complaining.
'Murica, SJW are luckily confined there for the most part, but Github and its queer army needs to fix their shit
Because it's unnecessary?
This is true for Polymer 1&amp;2, but not in Polymer 3 where they are using js modules. They no longer use HTML imports and everything they are using is under development by other browsers unlike HTML imports which got a "no" from the browsers other than Chrome. Also, with the js scoping that js modules provides, theoretically you can have multiple versions of Polymer 3+ on the same page. This was the issue with HTML imports, they touted scoping HTML with shadow dom, but JS worked in a global scope. JS modules makes Polymer truly scoped, modular, and truly native.
"Queer army"?
You don't need it: https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
This article is deliberately misleading. &gt; To whet your appetite, take a look at this side-by-side comparison of a Webpack config and a Brunch config for the same, simple Vue.js project \*Unreadable image, that cannot be enlarged, but you can still see that they are absolutely not the same\* 
Could somebody explain to me why you would do VR with React
When you only render a subset of a huge list. The most used is https://github.com/bvaughn/react-virtualized/, I think.
its very easy : becouse you know React. You want to build website - use react. Want to build Android App - React Native. Ios App - React Native. VR ? React VR. After that you can write In linkedin Profile ' skill : website, Mobile, VR dev' Anyway : I dont like React, and in my opinion React VR is stupid idea. 
Those same transvestite who complain about woman rights etc. They removed the meritocracy rug in github in favor of forcing diversity. They also made github cancel an event because (after a BLIND REVIEW) the speakers were all male http://blog.aaronsleazy.com/index.php/2017/06/09/sjws-wreck-tech-conference-cancelled-due-to-male-hegemony/ Scaring times my friend
Sounds like someone needs to learn about the [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop).
Afaik it only uses React-like syntax to declare scenes and objects. I've seen some small package/lib which uses JSX to create webpack config.
I guess this is my fault for going fishing. I definietly don't agree with forcing people to cancel events but dude if you made your points without throwing around slurs that clearly reveal your hate for people who are a little different to you, more people would listen to arguments like the one in that blog post. Edit: Not in the way this fucking douche made them. "stay in shape and ride dicks", "What you can learn from reality porn for picking up women" I mean jesus this guy really hates women. Come on man.
See? even you make assumptions, I don't give a flying fuck if they like horses or have a coprophilia - this is science, there's no room for whining, diverging tech decisions because of people not being comfortable (like they have ever been comfortable in society) is bad and it's a form of censorship, world is a rough place so let's stop being pathetic and let's just write quality code btw that was the first link I found about around the argument, I didn't even read that article, I just followed those shameful decisions (cancelling events after blind reviews because you don't like the outcome? because you as a queer need to be with more female like you? how the fuck sex has anything to do with this? why do they need to state their ("trendy") sexuality on twitter?)
I think I know what you mean, the title is somewhat sensational :) Btw I love Vue, have used it on a ton of projects (including my "code happy place" http://npmcharts.com) and think it's awesome for websites, but in a business environment (especially mobile), considering how much more agile you would be from the size of reacts ecosystem, which affects how many features and components you wouldn't have to create yourself because others have already made something you could directly use, and how many bugs you can search and find other people's solutions to, I think React is the more pragmatic and practical choice After all, Apple, Microsoft, Baidu, Tesla, all have actual patents that are on the line _now_, and teams of lawyers that probably know better than most of us in the tech chamber, and that hasn't stopped them from using React. I think we will be fine :)
Following that line of thinking, if Microsoft, Apple, Tesla, and Baidu's teams of lawyers haven't stopped their developers from using React, what makes our fellow developers and IP law enthusiasts so sure it's a problem?
&gt; because you as a queer &gt; why do they need to state their ("trendy") sexuality This isn't science, this is signaling a deep rooted dislike and lack of respect for gay people. 
here we go again... grasping on terminology and avoiding the clear subject of the statement, I'm sorry I don't have time for this or for reformulating sentences in order to make you comfortable. Peace out P.s. I lived almost 3 years with gay flat mates, never a prob (about me not being gay or "hating on them" as you assume) as they are not whiny teens but grown up adults - still hearing from them from time to time
During the 2017 Polymer Summit, roughly an hour ago, Max Lynch and Adam Bradley from Ionic (Framework) presented their new Web Components effort, the Stencil.js compiler. Using Stencil, developers can develop framework-agnostic (Web) Components. As such, we can expect the [Ionic Component](https://ionicframework.com/docs/components/) library to be available as Web Components, thus free of any Angular dependencies. Worth noting was that Stencil is *not* a framework, rather a compiler that outputs vanilla Web Components. Excited? Indeed!
@cuel what was wrong in my code?
Maybe their companies' lawyers said no, which seems to have happened in some cases. And just because a few other companies are ok with it doesn't mean that Facebook should license React this way, or that the community shouldn't demand a compelling reason for it. 
React is good for building interfaces (and anything that needs to be broken down into components). This gives developers a solid, well-tested, familiar interface to create VR apps with.
Definitely keyword
HTML Imports was just an example, of course. I do hope and expect that Polymer will get better, but by that time I'm not sure if there's a reason to use Polymer still. At this time, however, it certainly doesn't hold yet, and going by their npm+ES modules announcement post, Polymer 3 is some way off still. (And it's not yet entirely clear whether ES modules actually allow multiple versions.) So yes, in the future, Web Components are relatively future-proof, although it's not quite clear whether Polymer will still be relevant then. At present, however, React is sure to require far less rewriting - and in fact, it's not that far-fetched to see React still being relevant by that time.
Await is a keyword, so is yield. This is written into the standard, and besides, neither fit the definition of an operator.
Those are two separate issues though, one is whether you are safe to use React, and the other is whether its patent clause is harmful to the ecosystem
Can anyone who has used Brunch speak to how well it works with TypeScript? (I see there's a package for it.)
Thank god the SJWs are throwing a tantrum in their own repo now.
You don't understand it and that makes it shit?
So far in the history of TC39, no stage 3 proposals have changed in meaningful, breaking ways. It's a pretty safe go-ahead indicator.
The 'new' operator sets the prototype of the newly created object prior to the calling of the constructor function. In your code, the Child.prototype is being set inside the constructor function so it is happening after the child prototype has already been assigned. To fix, you need to set the Child prototype before 'new' is called.
No, more like it's convoluted and makes everything more complicated than it needs to be. It's not just me personally being dumb. You can easily do a Google search about people disliking Webpack and find, "I hate webpack" and, "I passionately hate webpack" and my favorite, "I fucking HATE webpack! What a massive, stinking pile of shit this so-called build tool is!".
Honestly I use ```const``` for 90% of my code now, and ```let``` for anything in a loop.
also, is it bad if I x-post this to learnJavascript ? not sure on the etiquette. 
ES6 modules are fantastic. I've been using rollup.js to tree-shake my code before bundling and it squeezes out a tiny bundle; it just effortlessly gets rid of all names that weren't used. This is especially great if you're not deploying to a browser, since Node and other target platforms won't support ES6 modules for the foreseeable future.
I mean, I'm going to put this out there, but a lot of front end developers aren't exactly the sharpest pencils in the box, so expecting them to wrap their heads around a advanced build tool is hard at the best of times. Furthermore, while there may be a lot of people who don't "get it" there are plenty more who are doing just fine - if it was so mind bogglingly difficult it would have died out already and we wouldn't be here. Honestly it's not the hardest tool to learn as it's almost entirely config-driven - getting a basic build running is literally a copy-paste job and if you can dedicate an afternoon to learning moe you'll be able to write custom configs that achieve near-magic.
"I'm not racist my best friend is black"
Hasn't been my experience at all. Also I don't know how to say this without sounding like a douche but... I'm pretty damn smart... and I still found Webpack to be a headache. It felt like vastly more effort that was warranted by the project or for the privilege of using "import". &gt;There are plenty more who are doing just fine &gt;Getting a basic build running is literally a copy-paste job It's been my growing impression that this is a huge part of the problem. There aren't many good tutorials on webpack and in my experience a distinct lack of people who *really* know what's going on under the hood and are able to explain it to the uninitiated. For most, Webpack seems to be "near-magic" as you say, when what it should be is unmagical and clearly understandable. Anyway if I need to edit my original comment to say "my opinion is that it's shit" I guess I could but honestly this thread's existence is evidence to the fact that there's plenty of people out there who are avoiding Webpack.
Yup. No doubts there.
I've made assumptions because they incorrectly use a keyword from other languages. If they wanted it just for that weak ass shit they should have come up with a different keyword.
JavaScript does not have trichotomy, so here is how to go about building a basic comparison engine: const compare = function (first, second) { if (first === second) { return 0; } if (first &gt; second) { return 1; } return -1; }; A use example would be something like: if (compare(threshold, temp) &gt; 0) { console.log("too hot"); }
Well now I'm blown away. When I try to use this in Chrome dev tools, I still get "forEach is not a function."
Thanks! TIL about trichotomy :-) would you happen to know if there is a language where this is implemented? I'm just curious to see it in action.
Yeah, not the first dev to declare something was too complicated so tried to fix things by creating their own version. See all the MVC implementations out there.
This seems like an excellent idea.
I thought the store front uses bootstrap css? It has since 5.4.
It probably does. I'll have to dig through it and see. Thanks
tl;dr -- author doesn't like the API. The end.
&gt; they incorrectly use a keyword from other languages. I'm not even sure if you're trolling right now, but surely you understand how languages work. That different words mean different things in different languages. That's why they're called programming languages.
Weird, I tested the following code in Chrome 60 and it works as expected. document.querySelectorAll("a").forEach(link =&gt; console.log(link.href))
ah that makes sense
Do u even know how to use it guy? Doesn't look like it. 
FWIW, there is almost always a significant performance hit when measuring a single response, but the difference between server responses/s is almost always skewed towards async, which is the entire point
 Can someone explain to me how async/await is cleaner/better/faster than [promise composition](https://github.com/ramda/ramda/tree/v0.24.1/src/pipeP.js)?
I do understand your pain. There are way too many evangelists in the JavaScript community who hype up technologies because they heard some sound bites and are too inexperienced to scrutinise these claims with further research. As a consequence, they adopt the view that such tech must be used everywhere or else one is doing it wrong. I see the same thing with coding bootcamps. While JavaScript requires the mastery of a lot of concepts, the entry barrier is very low compared to other languages. I'm not talking about the ecosystem or tooling, but writing rudimentary JS itself. This results in coding bootcamp classes that are led by people who graduated from the same ones 6 months prior; it's a case of the blind leading the blind and it results in a perpetuating cycle of boosted egos and evangelism.
AH! I figured it out. I was using it on HTMLCollection, not a NodeList. Very similar, yet very different. I was using `getElementsByTagName`.
yeah. a common array usage that i've done is as a simple CSV handler (very simple) const [ elem1, elem2, elem3, ...rest ] = str.split(','); but yeah, i mostly use spread on objects. arrays aren't quite so common in javascript as objects. 
The value of `Child.prototype`is inherited by instances of Child _at time of instantiation_. When `child` is created, `Child.prototype` is the original `Child.prototype` that inherits from `Object.prototype`. Its only after `child` is created that `Child.prototype` is changed, now referencing a `Parent` instance. `child`, already having been instantiated to inherit from the original value of `Child.prototype` doesn't see these changes, but additional instances would as they'd inherit from the `Parent` instance created from the last child's `init()` call. var child = new Child(1, 2, 3); console.log(child.toString()); // [object Object] var child2 = new Child(1, 2, 3); console.log(child2.toString()); // { prop1: 1, prop2: 2 } /u/Cuel's code shows the more correct way to approach inheritance which is doing it once prior to any `Child` instance instantiation. This means that all child instances will inherit from the same `Child.prototype` which in turn inherits from `Parent.prototype` // ... Child definition ... Child.prototype = Object.create(Parent.prototype); // inheritance // ... Child prototype definitions ... // now its safe to make Child instances Using `Object.create` is similar to using `new Parent()` except it doesn't cause any side effects of the constructor. Instead it creates an empty object for the `Child.prototype` which directly inherits from the `Parent.prototype` - something you'd effectively get if using `new Parent()` if the `Parent` constructor was an empty function. You may ask yourself, well, what about the constructor properties in `Parent` that the `Child.prototype` is no longer getting? That's ok because the `Parent` constructor is called with (or should be) the `Child` constructor (though you've kind of delegated this out into `init()`) so those properties are copied directly into the instance. This is better anyway because it prevents issues with object reference sharing if instances are each accessing the same object members from the prototype. function Parent(arg1) { this.prop1 = arg1; } function Child(){} Child.prototype = new Parent({innerProp: 'Hello'}); // prototyped, therefore shared var child = new Child(); var child2 = new Child(); child.prop1.innerProp = 'Goodbye'; // setting only 1, but: console.log(child.prop1); // {innerProp: "Goodbye"} console.log(child2.prop1); // {innerProp: "Goodbye"} So instead function Parent(arg1) { this.prop1 = arg1; } function Child(){ Parent.call(this, {innerProp: 'Hello'}); // (super()) each instance own copy } Child.prototype = Object.create(Parent.prototype); var child = new Child(); var child2 = new Child(); child.prop1.innerProp = 'Goodbye'; // setting 1, and: console.log(child.prop1); // {innerProp: "Goodbye"} console.log(child2.prop1); // {innerProp: "Hello"}
It doesn't add typos to your projects, does it?
came here to say this. seems OP just doesn't understand or like the purpose of the API.
It looks promising ☺️
The guy you're arguing with isn't getting offended, he's just pointing out you're a dick
Hi! Sorry to hear that. Could you please let me know what exactly the problem was with account creation?
React will give you a strong knowledge of javascript with a hint of some react specifics like JSX etc... Eloquent JS is pretty good for vanilla JS but it is difficult. If you can work through that, you should have solid JS and programming knowledge. 
Just because Kotlin has a JavaScript target, does that make it appropriate for /r/javascript? Don't get me wrong, I actually really like Kotlin, I'm just wondering if this is the right place for posts about it.
I think so since it can bring awareness to JavaScript devs that may not have previously knowledge of such a tool.
Exactly this. You could even create a helper for this: const ignoreRejection = promise =&gt; promise.catch(() =&gt; new Promise(() =&gt; {})) Promise.race([ asyncFn1(), asyncFn2(), asyncFn3() ].map(ignoreRejection)) Now it returns the first promise that successfully resolves, ignoring the rejected promises. No need to create your own `Promise.race` function.
I've injected CSS from inside a content script like this: const div = document.createElement('div'); window.shadowRoot = div.attachShadow({ mode: 'closed' }); const css = document.createElement('link'); css.rel = 'stylesheet'; css.href = chrome.runtime.getURL('content.css'); shadowRoot.appendChild(css); document.body.appendChild(div); I'm using [shadow DOM](https://developers.google.com/web/fundamentals/architecture/building-components/shadowdom) to insulate my injected HTML and CSS from the page. The shadow root requires a host element which won't be able to display anything else. If you're injecting into only specific sites and you *know* there won't be a conflict, or you're trying to apply CSS to the original page elements, you can avoid that. As you've said, the .css file must be in ["web_accessible_resources"](https://developer.chrome.com/extensions/manifest/web_accessible_resources), which makes the file accessible at `chrome-extension://[PACKAGE ID]/[PATH]`. You get this URL via [chrome.runtime.getURL\(\)](https://developer.chrome.com/extensions/runtime#method-getURL).
You might want to include one promise that eventually resolves or rejects, otherwise the race might never finish.
Stupid question, but with a frame do I still use document.createElement or frame.document.createElement? I tried a solution somewhat similar, but not at all the same. Will give it a shot and report back. Thank you!
The arguably easier alternative to shadow DOM is an iframe. With that, you can simply [load pre-made HTML.](https://stackoverflow.com/questions/24641592/injecting-iframe-into-page-with-restrictive-content-security-policy)
Two other JS developers and I have spent the last few weeks building this project to help make web data extraction (i.e. scraping, in more nicer terms) easier. It has two parts: a Chrome Extension to select elements from a website to extract, and a server you can host to scrape and serve the data as an API. If you'd like to just look at the code, you can check out the github repo for [the server](https://github.com/Live-API/LAPI-Server) and for [the Chrome Extension](https://github.com/Live-API/LAPI-Chrome-Ext). It's a work in progress and we have a lot more to both add and refactor, but it's stable and we'd love your feedback and suggestions.
You wouldn't use a promise race for either of these.
Anyone know how independent composition (angular transclusion) works with this? Looking through the examples, the only component composition I can find is when the parent component knows about the child component. Like this: class ParentComponent { render() { return ( &lt;child-component /&gt; ); } } Although, this is pretty simple and not very useful when you're using third-party components together, since they won't know. React supports transclusion elements, via `this.props.children`. &lt;parent-component&gt;&lt;child-component /&gt;&lt;/parent-component&gt; tl;dr: How does parent-component in the above example do anything with child-component?
https://github.com/FermORG/FermionJS
Care to elaborate on why not?
wow, surprised to see an actual SQL implementation of graphql. with dataloader no less. 
As front-end frameworks constantly improve, more and more responsive and complicated UIs are in demand. With all the long hours spent in developing UI/UX, wouldn't it be great to have a way to gauge the UX of your site? Spion IO is a lightweight focus group management API that can capture and replay a user's interaction on your site so you can easily review sessions and improve the UX of everything you build.
Sure, in my opinion it would make sense to use a timeout promise that will reject after n seconds: Promise.race([ rejectAfter(10000) ].concat([ asyncFn1(), asyncFn2(), asyncFn3() ].map(ignoreRejection)))
It really isn't. You can just install the loaders and you're good.
no. 11 and 16 show up as $15 for me...
[removed]
React Native? Ionic? 
Underrated tutorial. Great stuff. 
This is actually quite contradictionary. React has been stable for years, all it ever did was grow with the language (createClass -&gt; es6 class, *though createClass will always be valid*). That applies to most v-dom libs. What drives React is the v-dom, it's a simple concept, a node is defined with one call taking 3 arguments `createElement(name, props, children)`, that signature will never change and that is all that is needed to make React scale the way it does. There have been minor deprecations and such but these were merely slight retouches. Polymer on the other hand ships a template parser and a markup-javascript emulator, the api surface of it is g-i-g-a-n-t-i-c compared to React. The complexity of it all had it go through through countless iterations that broke the api and that tradition will continue. Web components *only* specify isolation, the smallest part of what Polymer actually does, everything else is arbitrary and will shift and change underneath your code. What's worse, every WC driving framework will have their own syntax. And now that it's tied to the dom, what about flexibility? When do you think Polymer will be out there driving mobile and desktop apps, or VR? And how?
I don’t know about this library specifically but the web component spec has a `&lt;slot&gt;` element that acts as a portal to where you want children to be placed. Not as flexible as React’s children mind you but you get that basic functionality.
Does slot really help here? Slot exposes shadow dom elements to the visible DOM. I'm showing an example where a visible dom element needs to find its way into the shadow dom effectively.
Looks interesting. What do you plan to use this for?
This wikipedia page lists some languages - https://en.wikipedia.org/wiki/Three-way_comparison
It would be nice if there was a real live demo to run and try (not only animated gifs) :) 
Everything that can be done declaratively is perfect for React. There are countless of renderers now tapping into this. Take a look at this for instance: https://github.com/Yomguithereal/react-blessed Same principle, declare your interfaces, style them, interact with them. Then you realize that now you can use reacts eco system on your components, and suddenly your [app is alive](https://github.com/gaearon/react-blessed-hot-motion) (that's react-motion and react-hot-reload for instance). All of that applies to VR and all other render targets.
interviewer: Explain `this`. me: Can't I just use arrow functions?
HAHA holy shit
&gt; Why is it so hard to accept that maybe men have an unfair leg up in our society, and we're just asking Not all disparity in outcome is caused by sexism or racism or bigotry.
"Thanks for coming in, we'all get back to you soon"
Not if you're using classes! (extreme sad face)
Oh no, not the "pass by reference" discussion again! Javascript is pass by value only, while some values are references themselves, this does not mean that its pass by reference. 
Yes, if lets say you have a parent declaration along the lines of: &lt;parent-component&gt; #shadow-root &lt;div&gt; &lt;slot /&gt; &lt;/div&gt; &lt;/parent-component&gt; And you use it like: &lt;parent-component&gt; &lt;child-component /&gt; &lt;/parent-component&gt; It effectively is the equivalent of (minus some css scoping): &lt;parent-component&gt; &lt;div&gt; &lt;child-component /&gt; &lt;/div&gt; &lt;/parent-component&gt; 
I came here to say this. https://www.youtube.com/watch?v=1JvrpMc9GyY
Isn't that the definition of pass by reference? (to pass a value of a reference)
Unless you make your methods instance members
Apply Call Bind, Truth be told you'll use bind 99% of the time and Call and Apply are rare enough you'll probably just check mdm every time you think you might need them. Only to realize you still probably just wanted bind.
Nope, imagine this: every variable in js is a bucket. When you call a function, you empty this bucket and the contents land in the bucket in your function (the function parameter) you can then take this content and modify it. By the you can never change, what item is in the bucket outside of your function. Sure, if the item is mutable, you can change it and it will change on the outside too, but you can never change, which item is in the outside bucket. In languages where pass by reference is possible, you can reset the contents of your variable. For example, c# has out parameters, this allows you to set the content of a variable that is not inside your function. 
Just spotted this here. Excellent work, guys! An amazing initiative you've undertaken! Best of luck! [ Or, in Lithuanian: Puikiai varot! Taip ir toliau! ;) ]
Did I say that it was?
It was your implication, yes.
The fake notification in the upper-right corner is a very clever way to work around those annoying modals.
Nope. If you assign new values to your parameters, it doesn't change the original value where it was passed in to the function. In C or C++ for example that's how pass by reference works.
The issue here is different languages use the same words to mean different things. What JavaScript calls a reference is what C/C++ calls a pointer. So in JavaScript, when you hear "reference," think "pointer." Which means when we say "pass by reference" in JavaScript, it's like we're saying pass by pointer.
not looked on the link, but strongly don't believe such a thing exist or practical in anyway (sorry for downvote)
Yeah that was poorly explained on my part, I was referring more to the ES6 class lack of closure support but good use of closures relies on understanding the this variable and you can't use them very well with arrow functions either. Maybe one day they'll add the private keyword and we can finally forget about javascript's weird problems with this
I found myself using call and Apply a lot more before the spread syntax was widespread. e.g. to get the max of an array, and a lot of other Math methods. var arr = [1, 2, 3, 4, 5] var max = Math.max.apply(null, arr); while now you can just do var arr = [1, 2, 3, 4, 5] var max = Math.max(...arr); Also found myself using it on DOMLists before Array.from and before having it polyfilled var pEls = document.querySelectorAll('p'); var pElsArray = [].slice.call(pEls);
Well, you are forcing me to create an account when I don't even know yet whether your app is going to be useful to me or not. IMO you should let the user choose whether they want an account or not. 
Over the past few months our team collectively realized that TDD with React is a bit of a pain. We thought it was difficult to reason about frontend testing before and while we were prototyping our React application. We created this tool as a compromise to React TDD. It is a real time, visual testing developer tool that allows you to see a live representation of your React app's component structure and its current state and prop values. React VT allows you to define assertions in order to test your application while it is being used, and it displays assertion results at the moment that they pass or fail. If you are happy with the tests you've written and would like the ability to run them in an automated environment, React VT provides an option to export your tests into an Enzyme file that can be run independently. We hope that this will lower the latency between prototyping and testing. React VT is still in Alpha, so we expect that users might run into a few issues when test driving it. If you are interested in providing bug reports or feedback, or if you would like to contribute to the project, please visit our github page at https://github.com/ReactVT/react-vt. 
SJ is a religion: * SJW: saints/believers * Privilege: original sin * Systemic oppression: evil * Socialism: paradise And so on. It's a joke.
Every interview I've had has had me do some kind of complex math and/or array manipulation: two things I'm bad at. It's always complex bullshit you'll never use in real life though, which makes it even worse, if you can't do it. I've lost out on so many jobs because of this, and it infuriates me. GIVE ME PRACTICAL SHIT TO CODE!
Hey - I'm one of the developers who's working on Fermion. It's an electron app, so the best way to experience it is to clone the git repo, and give it a run. Let us know what you think!
No, it wasn't. It was that there is plenty of bias holding women and people of color back that don't apply to white men, so there isn't a level playing field, and people need to admit to that. Not every incident is from that, but it happens a lot more often than people want to believe.
We envision Fermion as being a way to quickly throw together a React app that's easy to adjust and tweak during the design process. We want to do away with boilerplate and CSS nudging - at least while projects are getting up and running! 
&gt; and people need to admit to that We don't *need* to do a thing. Provide *evidence*.
there's a ton out there. and I've spent hours upon hours re-linking it for each person like you on various websites, and i'm tired of working that much for people who won't listen to me anyways. go find it and read it yourself if you really want to learn. I don't owe you shit, dude.
Methods defined in `class` can be closures. Closures and context (`this`) are separate behaviors. [Class fields](https://github.com/tc39/proposal-class-fields) (stage 3) let you define members in the class body which can be arrow functions and they maintain a context of the class instance, just as if they were created in the constructor. class Foo { bar = 'bar' getBar = () =&gt; this.bar } new Foo().getBar() //-&gt; 'bar' Private fields are also part of this, though they use a `#` identifier rather than the `private` keyword. class Foo { #bar = 'bar' getBar = () =&gt; this.#bar } new Foo().getBar() //-&gt; 'bar' new Foo().#bar //-&gt; Error These are implemented similar to the weak map approaches used today. Of course that comes with its own problems, so it isn't a magic bullet for solving everyone's problems.
&gt; you empty this bucket and ... You're not really _emptying_ it... ;)
Personally, my criticism is that making the *object* immutable would have been far more useful than making the reference immutable. In C++, just for a quick digression, we have the option to make *either* or *both* immutable. // pointer/reference immutable, object not auto* const v = new vector&lt;int&gt;{}; v-&gt;push_back(42); // ok, modify object v = nullptr; // error, reassign pointer/reference // object immutable, pointer/reference not const auto* v = new vector&lt;int&gt;{}; v-&gt;push_back(42); // error, modify object v = nullptr; // ok, reassign pointer/reference // pointer/reference *AND* object immutable const auto* const v = new vector&lt;int&gt;{}; v-&gt;push_back(42); // error, modify object v = nullptr; // error, reassign pointer/reference But even though we can do both, making the *object* immutable is much more useful and used much more often. Whereas making the pointer/reference immutable is described by experts as [pedantic](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#con1-by-default-make-objects-immutable). Back to JavaScript. Of the two things `const` could have made immutable -- the reference or the object -- they picked the less useful of the two.
If you make your methods instance members it should be for a good reason, as you're increasing memory usage and very likely reducing performance in comparison to strictly using it off the prototype.
If your interviewer asks you about "pass by reference" the right answer is to explain how parameter passing works in JavaScript. You can avoid saying the words "pass by reference" and instead say something like "when objects are passed we receive a reference to the object, so any changes we make to it will persist after the function returns" or whatever. Correcting the interviewer on terminology probably isn't the right answer, especially since it's perfectly clear what they mean and this (mis)use of "pass by reference" is very common in the JS community. Nobody wants to hire someone who sees every question as an opportunity to correct you. 
Arrow functions have replaced one of the primary use cases of bind: partial application. Actually I can't remember the last time I had to use bind - I used to use it a lot but haven't needed to for ages. function add(a, b) { return a + b; } // Instead of this: var add3 = add.bind(null, 3); // Now we can: const add3 = n =&gt; add(3, n);
Can you give me an example of an interview question you received? 
yes, if you assign new values to the references, then those references are different. You're still passing the reference though, right? (haven't coded in c++ in a while)
C++ has both pass by reference and pass by value.
Sadly I don't have time right now to learn babel's internals and how to write plugins, but I'd be interested if you or someone introduced a "freeze" keyword as a proof of concept. freeze o = { a : 123 }; o.a = 456; // error And this could transpile to: const o = Object.freeze({ a : 123 }); o.a = 456; // nope And since Object.freeze isn't recursive, this could be even more useful for complex objects. freeze o = { "firstName": "John", "lastName": "Smith", "isAlive": true, "age": 25, "address": { "streetAddress": "21 2nd Street", "city": "New York", "state": "NY", "postalCode": "10021-3100" }, "phoneNumbers": [ { "type": "home", "number": "212 555-1234" }, { "type": "office", "number": "646 555-4567" }, { "type": "mobile", "number": "123 456-7890" } ], "children": [], "spouse": null }; This could transpile to: const o = Object.freeze({ "firstName": "John", "lastName": "Smith", "isAlive": true, "age": 25, "address": Object.freeze({ "streetAddress": "21 2nd Street", "city": "New York", "state": "NY", "postalCode": "10021-3100" }), "phoneNumbers": Object.freeze([ Object.freeze({ "type": "home", "number": "212 555-1234" }), Object.freeze({ "type": "office", "number": "646 555-4567" }), Object.freeze({ "type": "mobile", "number": "123 456-7890" }) ]), "children": Object.freeze([]), "spouse": null });
Okay, then I suppose to appease the purists... Javascript passes primitives by value and the _value of the reference_ for non-primitives. It's still accurate in my mind to say javascript passes primitives by value and non-primitives by reference. 
&gt; disingenuous Umm why ? Any policies against posting twitter threads here. I really am not a regular redditor so, I don't know much about the rules here 
If that was your response then I would think you don't understand (or cant come up with) any scenarios where you may *have* to use `this`, and then I would think you're maybe too inexperienced for the job. I want you to understand prototypes, this, how you can change the value of this with .call, .apply, .bind, how you can use arrow functions to prevent the value of this changing when you pass a function to another function and then call it, etc. So if you just gloss over all this with "cant I just use arrow functions" then it seems like you don't know about any of this ^ and that's bad.
If you look at apps of "decent scale", you'd find more in Ember than in any other framework. LinkedIn or Apple Music are of as big a scale as you can get
It's wrong though, because that means something else. It passes references by value.
Clever and unintrusive, I like it! Those full-page modal "subscribe to our newsletter" modals are Satan. 
It's just not the right tool for UI work. User events come in in streams and promises are singular. You can make promises work with something like this you're adding extra scaffolding, extra work for the browser to do, and you're boxing yourself into a system that doesn't play nicely with variations, e.g. imagine you add a simple pop up that says "are you sure you want to close this?" If the user clicks no you need to re-create your promises and reattach the listeners. Or you need to add another intermediary promise that somehow exposes its resolve callback? It just gets messy.
In c++ when you pass by value, are you passing the value of a reference?
Deactivate breakpoints before you refresh. If they automatically cleared after every reload, it would make it impossible to put breakpoints in scripts that run at load time.
You're only ever doing anything with arrays and objects. You never handle the case when you come across a primitive value.
Finally, Dreamweaver for React! :D
&gt; dis·in·gen·u·ous ˌdisənˈjenyo͞oəs &gt; adjective &gt; not candid or sincere, typically by pretending that one knows less about something than one really does. &gt; _synonyms:_ insincere dishonest untruthful false deceitful duplicitous lying mendacious hypocritical A "twitter thread" implies that there are multiple parties involved in discussing something. What you posted is just your tweet plus several of your own follow-ups, obviously done so to try and gain retweets and followers.
I'm doing well for myself without ever having to use any of those methods. Could you provide an example?
&gt; more in Ember than in any other framework. I disagree. Consider AngularJS. Or React.
Unintrusive perhaps, but I'm disappointed I fell for it.
If you have a function that takes variable length arguments but you have an array you can do: `Math.max.apply(null, [1, 2, 3])` but its also very useful for doing stuff like `return someOtherFunction.apply(this, arguments)`. So you could store a reference to some function i.e. `var original = object.method` then overwrite that method with something else `object.method = function() { /* do new stuff here */ return original.apply(this, arguments) }` so now you've managed to create a hook each time object.method runs but you havent effected its behaviour.
The first example I would do `Math.max(...myArray)`. Second could probably be replicated with arrow functions.
I do but it turns off every time on refresh. It looks like it's something webpack related? Just to make sure I wasn't crazy, I double checked and on any normal site, deactivate breakpoints sticks on refresh. But when I run in it with my dev environment, they reset. I have a feeling it's webpack related because the everything is completely unresponsive and shows a quick alert "please wait compiled scripts aren't shown if source maps" At least I know that my desired behavior is the intended behavior now and have a jumping point to research.
nice spread example, for the second one how would you propose rewriting my code using arrows? Another use (this time for bind) is preserving arguments. If you had some function `function print(a, b) { console.log(a + b) }` you could do `var greetingPrinter = print.bind(null, 'hello ')` which then enables `greetingPrinter('Bob')` `//hello Bob`. You can do this one with arrows although I find bind in some situations to be very concise.
Node 8.x comes with a promisify utility: https://nodejs.org/api/util.html#util_util_promisify_original
A few years ago, I was dumped into the middle of an existing Ember project with no real explanation of how things in Ember-Land worked. As such, I built a dislike of Ember and refused to even look at it for a while. I've since come to realise that the problem wasn't necessarily Ember, the problem was my harsh introduction to an Ember project in full complexity. I get the sense that this is also the case for a lot of people with Webpack. Their first introduction to Webpack is a monolithic config file the size of an Ayn Rand novel, with no real context or explanation as to how things work. Its understandable that people would be overwhelmed by such a scenario. However, if you start from the basics (a config with just `entry`, `output` and `devtool`), and get first hand experience as to how each extra piece contributes to the overall solution, it really clears away a lot of the seemingly arcane wizardry involved in maintaining Webpack in a project.
Not OP, but I swapped out React for Preact in our (heavy) web app at work and the compat layer just made everything work out of the box. End result was faster and lighter. Though the team didn't want to move away from React so we never ended up using it...
I find `bind` less concise personally because it forces you to pass the context of `this`. It's just... icky, to me. I'd much rather `const greetingPrinter = name =&gt; print('Hello ', name)`
just sayin. you want someone to 'provide a reason', yet your proclamations don't seem very coherent.
Could also be written: const p = () =&gt; Math.random() &lt; 0.5 ? Promise.resolve() : Promise.reject() `p` is a function that returns either a resolved promise or a rejected promise depending on a coin flip.
Awesome, I see what you're saying and you're right that'll work for most cases. Even after using slots and the Shadow DOM quite a bit, I still trip up on the purpose of its components. This won't help when you want to do more programmatic operations with a child component, such as only taking the first nested child (need to use named slots within their limitations for that).
And that's when I walked out.
Dat functional.
It's not the interview questions; it's more during the "technical screen," which can be with or without someone "watching." That's in quotes, because once it was over Skype while screen sharing, and a couple of times it was while someone just waited on the phone, which was really weird, because she wasn't technical; her job was to listen to my typing basically and make sure I wasn't... fuck I don't even know - it was over the phone, so I don't know what her purpose was. Either way, if they aren't "watching" and give you 24 hours, those are usually much, much harder questions, because they know you're just going to try and find the answer online.