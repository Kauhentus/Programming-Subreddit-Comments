Hey, TypeScript PM here. I don't think that `LibraryManagedAttributes` changes any of the code you have written today; it just determines the type of properties you need to pass in when writing a JSX tag.
You could try a page loader gif which takes up the whole screen on window load and then fades out on document ready
ü§¶‚Äç‚ôÇÔ∏èü§¶‚Äç‚ôÇÔ∏èü§¶‚Äç‚ôÇÔ∏èü§¶‚Äç‚ôÇÔ∏èü§¶‚Äç‚ôÇÔ∏èü§¶‚Äç‚ôÇÔ∏è
[Real cute Brian.](https://en.wikipedia.org/wiki/Clarke%27s_three_laws).
When the user clicks the link, display the spinner. When the _response_ comes back with the data, remove the spinner. Depending on how you are fetching the data from the database, you are looking to add an event listener to your request for when it has loaded. In that event listener, you remove the spinner.
Oh also, I like to think about what TypeScript libraries could do with Type Providers ala F#. Imagine a version of JSON.parse which returns strongly-typed results without having to cast based on JSON schemas or swagger specs or what-have-you.
Hi, i have just started a new DI library. [Modern lite way to do dependency injection into Javascript/Typescript project](https://github.com/adrien2p/tornadojs) Any feedback is welcome. I havn‚Äôt done the readme yet
Best place to learn typescript? 
Do you have an example of a functional break from another language? How does it compare to the functional break that you wish JS had? Same/different? I sometimes wish `throw` could be an expression.
This is neither useful or particularly witty.
something like this is the flow you're looking fro: clickHandler = function(event) { event.preventDefault(); showSpinner(); makeRequestToDatabase().then(response =&gt; { populateTable(reponse.data); hideSpinner(); }) };
I think it depends a lot on how familiar you are with JS. If you're already a JS expert, [the handbook](http://www.typescriptlang.org/docs/handbook/basic-types.html) makes a pretty decent reference. I can't say I have any experience with TypeScript books though, sorry! /u/danielrosenwasser may have better recommendations!
Generally you'll want something like: makeRequestToDatabase().then(response =&gt; { populateTable(reponse.data); }).catch(error =&gt; { displayError(error); }).finally(()=&gt; { hideSpinner(); }); So that if there's an error, the spinner isn't perpetually stuck.
Looks like the article has now been updated to correct some of the issues raised in this very thread :)
Lol duh! Don‚Äôt know why I didn‚Äôt check there... geez.. thank you anyway! 
You‚Äôre that ‚ÄúNothing‚Äù when people ask me what I‚Äôm thinking about.
http://ricostacruz.com/nprogress/
Hey /r/javascript! A few months back, I posted about the initial speaker announcement for Byteconf React. Since then, we've confirmed our full speaker lineup, and we're about a month away from the conference itself. Happy to answer any questions about the conference, or the speaker lineup here ‚Äì I'm super excited to have a great selection of speakers at the conference, and have a bunch of super interesting topics (like functional programming, computer science fundamentals, and even augmented reality) represented at the conf. **By the way, here's an exclusive thing for Reddit folks ‚Äì we recently launched a Discord community to chat about the conference, JavaScript, and more** - we'll eventually be moving to a more locked-down access model for the server, but I wanted to give y'all early access before that happens. **Use this invite link: https://discord.gg/KnzprSD** See you at the conference, and on the Discord!
Some devs prefer this kind of splits for maintainability. But there is libs around to make React views more template-like, you can try [https://github.com/yosbelms/react-deco](https://github.com/yosbelms/react-deco) or make one yourself it is very simple.
Looks like they just lifted that question straight from the problems from the 2018 ACM-ICPC World Finals: [https://icpc.baylor.edu/worldfinals/problems/icpc2018.pdf](https://icpc.baylor.edu/worldfinals/problems/icpc2018.pdf)
**Shit To Do** - [https://shittodo.app](https://shittodo.app) A little behind on this as it's now Monday but I made a Todo List app that adds foul language in places because sometimes you just have \*\*\*\* to do! Each list created has a unique URL for sharing as well. I built it with React, Meteor, and MongoDB. I'll get the code up in Github and update this post!
Ok I see what you mean now
Firebase is basically that and it‚Äôs free up to a certain usage.
I actually do all my single-person projects in it as well - the reduced cognitive load is still amazing. There's so many things when programming that's more worthy of your attention than the exact shape of your objects.
That's a really cool idea. It'd be useful even for simple stuff like CSS Modules; `Record&lt;string, string&gt;` isn't quite correct.
Sweet thanks
As a former molecular biologist, I really like it:)
You have to be relentless. See trends and try learning more about them. Stay true to your core set. Doesn‚Äôt hurt learning some base languages like C albeit for knowledge that‚Äôs applicable in your favourite language. Also and this is important learn soft skills around working methodologies such as agile etc as almost every company uses. Having such skills such as source control like git. Learn some continuous integration like Jenkins also unit testing. - learn a base language - agile (kanban etc) - source control - CI - unit testing I guarantee if you have working knowledge of these finding a junior position (which your skills lay in only having 2 years knowledge) will be so easy. And they aren‚Äôt hard to learn. 
Sailsjs has API blueprinting which basically allows you to implement CRUD with no code at all
Hi /u/Chr0noN, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/wellfriedbeans, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Thanks for your understanding.
Hi /u/piscoster, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/CocoaTrain, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Some features can be faster due to JS optimizing for that language feature.
Yup! In general, I want to see TypeScript grow more in its abilities around typing non-JS assets. The web stack is very polyglot so there's many opportunities to make this easier and more awesome.
Woo a typescript release that follows semver ;) But seriously nice work, it‚Äôs come a long way since 2.0 and at a very developer friendly cadence
should have gone with react
&gt; I sometimes wish throw could be an expression. Stage 2: https://github.com/tc39/proposal-throw-expressions
definitely worth a shot. I've only been working in the field for a couple years now and i'm starting to learn react-native to build myself a mobile app. This crossed my mind late last night and i did some research but nobody seem to have a straight answer on what's the best way to go about this. I figured try reddit and see what everybody else does lol. 
I started to mock up what I mean, but I honestly wrote the post in succinct form just cause it hit me, and I haven't been able to really form a good response. It was probably silly to do so, /r/javascript isn't always the best for open ended conversation. I should have posted a few examples, wrote up a dissertation and crafted an RFC that ran for 6mo before making a statement (/s) I think the function version I wanted at the exact moment. ends up being syntactical sugar. probably not that useful It's similar to how a number of postfix capable languages work - in ruby one can do this; break unless 1 &gt; 2 so... meh if (1 &gt; 2) break; is exactly the same thing in JS a statement syntactically needs a full plain block scope to break from and execute in. which makes sense, as it's ... "block-level meta syntax" it's a feature of the current block of execution, not a 'function' so...*throws hands up* I don't know WHAT I'm asking for exactly. a lot of the examples I tried to conjure up were contrived enough to have a simple alternative.
Yeah i was thinking about this also. It just felt so odd to me that there wasn't a more efficient way to do this. 
Meh, I like my version better üôÉ
Are there any plans to reduce typescript's build system? I see there's new code splitting functionality, and there are more features like that from previous versions where typescript just do too much. I already have a working build system with webpack / parcel, when working with typescript I need to define everything twice, once for my bundler and once for typescript... It's annoying. I've they added typescript to babel 7, which helps a bit with adding some other transformations for my ts and tsx files, but still way too much duplicate configuration (and tsconfig being a json file makes it even harder to share code with my bundler!!) Thanks in advance 
I continue typing over it until I reach the point when I can just hit end, return.
Sorry mate, I was at work and "wrote it on the shitter" as one does. I updated it to show a contrived example - I'm pretty sure this example can be rewritten in a functional way "better" so.... *shrugs* maybe?
I don't know what's best for you, but I often just retype what the editor auto completed for me.
I love typescript!
/u/OzziePeck: the handbook should be great - if not, let me know why not :) I've also heard great things about [TypeScript Deep Dive](https://basarat.gitbooks.io/typescript/docs/why-typescript.html) by Basarat Ali Syed and [Learning TypeScript](http://www.learningtypescript.com/) by Remo Jansen. One thing I personally recommend (though it's not for everyone) - if you're interested in learning TypeScript deeply, learn JavaScript deeply first.
Please your excellence can you tell me how to ascend to your heights of your utility, wit and intelligence? 
React, of course, is well known for its TypeScript definitions.
TypeScript is itself a build tool because it is more commonly used without another compiler like Babel in the tool chain. While there aren't plans to reduce that functionality, we will continue to make TypeScript work better with other tools in the ecosystem (e.g. by continuing to improve the compiler API). Note that project references aren't "code splitting" in the sense of Webpack, it's for references between projects at the package level (think Lerna/Bolt).
Why can't we just use Babel to convert .ts files to .js?
Thanks! My post got removed, but I have copied your info and am grateful for the time taken to help.
[You can!](https://babeljs.io/docs/en/next/babel-preset-typescript.html)
Hard to say without knowing any other considerations. For all I know fetch, and assigning the body to a div.innerHtml to querySelectorAll might be plenty good for your needs. 
Unknown type is cool but error messages were definitely the highlight for me. 
Retype the closing quote. The completed characters help the code analysis parser because it doesn't leave a hanging parse. I usually rebind `ctrl-l` to do it, the l comes from the vim motion.
This is interesting. Like /u/bestdnd said, this could be implemented using the exception system. The problem with your example precisely is that `break` would have to be specified *by* the `for` loop somehow so it's clear which loop you're breaking out of. Maybe something like this ``` for (let i = 0; i &lt; 10; ++i) brokenby(break1) { ... break1(); ... } ``` I hate that syntax, but you get the point: you would need to specify the identifier to use somewhere in the `for` signature. The fact that (I believe) you could implement it using the exception system as well as the fact that exceptional code has decent performance in Turbofan makes me a little more optimistic, though I doubt it will ever come to fruition.
When you write \`JSON.stringify()\` or \`req.body\`, or \`reactRouter.connect()\` (the 2nd argument), you will be FORCED to cast them to something. Previously the use of those functions would infectate your code with an \`any\` without any warning, which could easily spread unchecked non-type-covered to your code.
Programming fundamentals you're not going to learn about from common/popular JavaScript learning resources featuring examples that use the JavaScript language.
You're right, even though you're being downvoted to oblivion... \`any\` is unsafe. \`unknown\` means you have to prove an object conforms to a type. 
Doea you mean basics of JavaScript?
Is there going to be any plans for auto typing the return of a yield call? With the rise in popularity of redux-saga it should become more of a priority imho. It's infuriating manually typing every left hand side of yield. Typescript + React + Redux is a dream team. I just need to fit in the async part and my life will be complete.
No, what I mean is that every JavaScript learning resource pretty much just gives you an example of syntax, then an example of how to the syntax, then moves onto the next example. I want an article that explains how to break down a problem into smaller steps then turn the small steps into code. I also mean things like memory leaks, garbage collection, is an object really a pointer ? Things like that. 
Got it. Looks like you the the guy that love to gid deeper inside. Are you new to js?
I‚Äôm newish, I‚Äôve finished the front end part of the old Free Code Camp, currently I‚Äôm working on the React projects from the new FCC using typescript and TDD(Jest/Enzyme).
Never thought that my comment will get roasted :) I will try to justify myself 1) In a for loop there is no point of checking the length of the array in each iteration. It is better to store them in constants to avoid the calculation. May be this is optimised by some browsers but what about IE. This has a considerable impact if you have a very large array. 2) If you see the pollyfill for forEach ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Array/forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)) if will see there are some checks and statements that you would not need in a normal for loop. Agreed that code is more readable and maintainable. Again its always dependant on the input array size but still these are worth knowing. PS - If you think forEach is better then you should use forEach for your loop nesting as well.
Did you and your friends tutor her for the 3 months before she got hired? Would tutoring be especially helpful for learning programming fast? Would someone without friends who can tutor them be at a significant disadvantage? How much time was she spending on studying during those 3 months? 
I searched for some JavaScript jobs in Indeed and one job I saw says that it requires two years of experience in JavaScript and 1 year in React.js Would it be still possible to get the job even if you learned it in a few months? 
Two issues with your code 1) I did not understand why you are using XMLHttpRequest(). These are used to send HTTP requests to your server if any. More info here [https://www.w3schools.com/xml/ajax\_xmlhttprequest\_send.asp](https://www.w3schools.com/xml/ajax_xmlhttprequest_send.asp). 2) On line 18 you have hours but it should be hour as hours is not defined.
Sure, as long as you can prove that you know it. Try to go to meetups. Also check stack overflow jobs.
You can use Blob for this. Sample here [https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js](https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js) Retrieving can be done using AJAX request [https://stackoverflow.com/questions/196498/how-do-i-load-the-contents-of-a-text-file-into-a-javascript-variable](https://stackoverflow.com/questions/196498/how-do-i-load-the-contents-of-a-text-file-into-a-javascript-variable) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [eligrey/FileSaver.js/.../**FileSaver.js** (master ‚Üí 00e540f)](https://github.com/eligrey/FileSaver.js/blob/00e540fda507173f83a9408f1604622538d0c81a/src/FileSaver.js) ---- 
Oh, ok. Sorry, I didn't really know where this should go so I just chose /r/javascript. I was picking someone else's code apart and I guess I forgot to remove that. I'll fix those issues next time I'm at my PC and see if it starts working. I'll also post this on /r/learnjavascript. Thanks for the help!
If you don't mind page refreshes you can dip this without javascript. Just create a form, receive the form data on the server, use data to create or edit your json file and then read the json file to generate the the table. If you don't want a page refresh you would dip the same thing except you would use javascript to pull the days from the form, then use ajax to stand the data to the server, have the server respond with the updated json data, and then use it to update your table.
Yeah I don't know man, react native sounds cool. Me myself going PWA route closest for me to get some return. Don't think it compares to React Native
In that order: yes. It's useful when you get stuck. Depends on you. 8 hours a day. I'm also self taught but it took me a bit longer. I definitely gave my friends a shortcut with the tutoring. When you get discouraged remember that what you're doing is very difficult, and that's okay, take your time. 
This is called the pub sub pattern and a better one is probably using an event bus provider. This would allow the components to work the same way without forcing them to emit or listen to events directly.
I recall the awe I felt when I first learned about user-defined type guards: they are such a sublime way to extend the compiler's static type knowledge through a runtime check. Type providers would naturally act as the next step of this revolution: like you said in another thread, there is so much raw potential in typing non-JS assets. CSS modules, internationalization string files, sprite sets, just to name a few. There's also a lot more interest in bridging TypeScript to other type systems too, compared to a few years ago. Database schemata (relational, document, and graph) and RPC frameworks with IDLs (e.g. Thrift, Protobuf) come to mind. The current predominant form of solving these kinds of problems in TypeScript has been to rely on type inference to derive static types from runtime value declarations, like what [`runtypes`](https://github.com/pelotom/runtypes) and [`io-ts`](https://github.com/gcanti/io-ts) allow. This is a complement to the way the JVM and the CLR typically approach the problems in this space, which is having the compiler retain compile-time type information into runtime.
I agree with studying OOP, but component oriented architecture even more so. Java isn‚Äôt necessary, pick any language. 
I wanted to be an application and service oriented engineer and ended up working in UI cause it seemed like no one else cared about UX.
Thank you!!!!!!!!!!
Flow vs TS? 
Yes, many ways. Callback counting is one of them: http://stevehanov.ca/blog/index.php?id=127 But it's most idiomatic to use promises and async/await.
There are two websites you could use to create a zoomable map/image: Zoomable: [https://zoomable.ca/](https://zoomable.ca/) Zoomo (if you have lots of maps/images): [https://www.zoomo.ca](https://www.zoomo.ca) Hope that helps!
Would TypeScript ever provide the option to limit features? Example: A development team wants to disallow mutations, so syntax such as *+=*, *var*, *let* keywords would provide a compile time error. 
Interesting, might have to revisit my js game skills!
I really liked Angular's TypeScript tutorial to see all the TS features in a practical way.
I'm just wrapping up a conversion of a massive old 35k+ LOC library from JS to TS, plus a bunch of feature rework. It took two months, with some other distractions, to complete the initial conversion to TS. Then we started the feature work and added a dev. The new dev was shipping PRs in under a week, where as I'm sure it would have taken a week or two to just ramp up otherwise. Basically, the type system allows for the code to describe itself and for VS Code to do a lot of good things for you. Rather than having to spend time groking all the API shape/etc., the new dev just f12'd through whatever part they needed to learn. I was writing some regular JavaScript today because we keep a lot of our samples in JS still. I was really missing TS until I added `//@ts-check` and got some of the same capabilities. (FYI - I work for Microsoft, but not on the TS/VS Code team.)
Try Async/await. This method would translate a callback method to promise. Callback method must follow the error first approach. ```js const mapToPromise = (fn) =&gt; new Promise ( (s, e) =&gt; fn( (err, res) =&gt; err ? e(err) : s(res) ) ); ``` So your code becomes ```js const files = await mapToPromise ( fs.readdir.bind(dirname)); const content = files .filter( file =&gt; file.endsWith(".txt")) .map ( file =&gt; fs.readfile.bind(dirname + '/' + file) ) .map ( fn =&gt; mapToPromise (fn)) .map ( async p =&gt; await p) .reduce ( (( acc, res) =&gt; acc + res ), ""); ``` Now content concatenation of all files content. Save it to any file you want. ```js await mapToPromise ( fs.writeFile.bind( outFile, content) ); ``|
&gt;and tsconfig being a json file makes it even harder to share code with my bundler You can \`require()\` JSON files. eg: `const package = require('./package');` &lt;-- package.json
Does anyone know if we should be targeting a particular ES* version? Can we assume the judges will be reviewing the games in a modern browser?
I have a project where I have serval different "bases" (rootFolder in webpack, resolver), and they are dynamic based on some node code that I have. Webpack's api (or any bundler) allows me to pass this options programmatically, but typescript not.. In the end I've written json files before my build in webpack. This is just an example, I think ts is great, but it can be better in playing with other builds tools if it was trying to do less.
Holy hell, this is not how you ask for help. You don't just dump an entire code block and expect people to sift through it and learn the context eg. read the code line by line. Also you should provide a working demo and specify where in that demo the bugs occur. You said it in words. I imagine this is missing some other components like the `webImage()` function, I can't even run this code in a sandbox to try and help you/see the errors. Also you can define several variables while using the same var eg. `var apple, banana, dog, cat;` About your problems &gt;\#1) Bullets get stuck \-The bullets sometimes get stuck and stay there on the screen. (try spam bullets as you play) Are you watching the console log for errors. Look at the conditions that make the bullet move, is some threshold being hit. &gt;\#2) Unable to restart game after losing 3 lives (lives become negative) Where are you decrementing the lives? Write a catch like `var life = 3;` `if (life &gt;= 1) {` `life = life - 1; // remove a life` `}` `else {` `life = 3; // reset` `}`
Or Webpack's resolvers, I see that now. Also, changing ts compiler to do less doesn't have to harm ts functionality on it's own. Imagine reducing typescript to a single babel preset (with some configuration provided via options). Babel already has a cli, with build, clean, code splitting, references, root folder for absolute paths, and so much more. And for those opting to use ts alone, the ts cli can call babel as well (have it as a dependency) and thus remaing the same on the outside. 
That sounds like a job for tslint
Thank you! I've got one question about the unknown type: does it cover the same use case the MayBe monad covers? Could I replace an unknown value with a monadic value, say for example a MayBe&lt;int&gt; or IO&lt;int&gt;?
btw, the ```js syntax is for github and other normal md dialects. Reddit-flavor markdown you need to use like 4 spaces before every line to get a code block. It sucks but easy to do with an IDE (just tab everything over), but you do have to end up writing it in an IDE. You also don't have to reinvent the wheel, you can do something like: const util = require('util'); const fs = require('fs'); const readFileAsync = util.promisify(fs.readFile);
Oh sorry I was using my mobile and it was my first time writing code on reddit. Thanks!
Generally, if you wanted to go "functional", you'd have no loops in your business logic at all (loops are fine when below the abstraction layers in libs though). Not sure if I followed your example, but `break` is used to short circuit the looping, so I'm guessing you're looking to short circuit iteration when writing functional code - a map in particular. There's no "in-built" way to do it cleanly, but it's doable if you want to bend some best practices: [1,2,3,4,5] .filter(x =&gt; x &gt; 1) .flatMap((x, i, arr) =&gt; x === 3 ? arr.splice(1) : x * 2) // Array(4) [ 4, 3, 4, 5 ] The `flatMap` and `flat` array methods are still new, so you'll need a dev channel browser or something, but basically, the short circuit is achieved by mutating the array you're mapping over. `flatMap` is used instead of `map` because the current element `x` is assigned the rest of the spliced array. Do note that I'm not recommending anyone do this, but just that it's possible. Depending on what you're trying to achieve, there are other array methods that have in-built short circuiting, like `some` or `every`, and there are libraries like [Lodash](https://lodash.com/) that have a ton of operators that might work for your case. If your use case is actually more about bypassing computation under certain circumstances, you might want to look into `Either` and `Maybe` datatypes - and probably monads in general - if you're interested in doing it the functional way. But really, the true functional way is probably to just use recursion. Sadly, Safari is still the only browser to implement Tail Call Optimisation as far as I'm aware, so recursion in JS still isn't great for large data sets. If you're interested in writing more functional code without falling back to loops, here's a [great talk by Brian Lonsdorf](https://www.youtube.com/watch?v=JZSoPZUoR58) in which you might find some inspiration.
#### [A Million Ways to Fold in JS](https://www.youtube.com/watch?v=JZSoPZUoR58) ##### 16,023 views &amp;nbsp;üëç331 üëé5 *** Description: Loops are bullshit. Loops are bullshit. Hey, and we have tail-call elimination es6, which means recursion is on the menu. I'll provide as many alterna... *InfoQ, Published on Apr 19, 2016* *** ^(Beep Boop. I'm a bot! This content was auto-generated to provide Youtube details. Respond 'delete' to delete this.) ^(|) [^(Opt Out)](http://np.reddit.com/r/YTubeInfoBot/wiki/index) ^(|) [^(More Info)](http://np.reddit.com/r/YTubeInfoBot/)
Thanks its helped me.
Try this? const util = require('util'); const fs = require('fs'); const path = require('path'); const readFileAsync = util.promisify(fs.readFile); const readDirAsync = util.promisify(fs.readdir); async function readAll(dir) { // get all the files const files = await readDirAsync(dir); let accumulator = ''; // using a for-loop because functional things like reduce are difficult with async/await for (let i = 0; i &lt; files.length; i++) { const fullFilePath = path.join(dir, files[i]); accumulator += await readFileAsync(fullFilePath, {encoding: 'utf8'}); } return accumulator; } readAll('path\\to\\directory').then(t =&gt; { console.log(t); // or write it to a new file I guess? });
Something about vanilla JS without any external framework, or how to make my own framework with just the stuff I need. Many people say it's best to learn vanilla JS before going into your choice of framework, but I don't get why you even need a framework at all.
I have just made https://github.com/Microsoft/TypeScript/issues/26078 . I know on similar issues the response has been that it is a "non-goal" of TypeScript, but that was then, and this is now. It should be *so* trivial to generate the boilerplate type guards that can validate (or not) an `unknown` value... it just seems like such an easy win even if it may cross the Rubicon of generating code based on types; I cannot see how it could possibly be a bad thing.
There are probably no elements matched by your selector.
That doesn't make sense. The compiled typescript file is linked up to my HTML, I could edit the post to show my entire project if need be.
Sounds like a waste of time, why don't you disable feature instead of doing this?
getElementsByClassName returns array of element matching the classname. You should use array indexes to access the individual elements. I guess this is the issue.
Stupid question Is making the switch worth it? I've seen people praising it and I take a look at the code and it looks like a little bit to learn. 
I'm still a little bit confused behind the reasoning as to why the HTML elements are in arrays and I have to access them that way... or atleast that is how I interpreted your comment. However, when I tried using that code, the property style still failed to compile, am I missing something? Thank you for all of your help.
It's slower because you potentially have to iterate over an unbounded number of list items to actually add the handlers, not because of some concern about memory overhead.
Since multiple elements can have the same class, getElementsByClassName returns array of elements matching the class name. On the other hand if you do getElementById it returns a single element matching that id. I don't see any other issue with your code, it would be useful if you give the html code as well. One more probable reason would be your script is running before the DOM is created ie. put the script in the body tag or use window.onload .
Since multiple elements can have the same class, getElementsByClassName returns array of elements matching the class name. On the other hand if you do getElementById it returns a single element matching that id. I don't see any other issue with your code, it would be useful if you give the html code as well. One more probable reason would be your script is running before the DOM is created ie. put the script in the body tag or use window.onload .
Alright, I will show the rest of my project in the post. 
Wonderful. Here I am trying to get flow to work. Looks like I should just be writing TS.
Is there a way to please please stop typing semi-colons/ curly braces with typescripts. I mean it is purely cosmetic at this point. I mean that probably could be done on editors alone to toggle curly-braces On or Off. Is there a way to make curly braces optional? Or would you rather just have plug-in/code editors to do that. 
Quite literally the first Google result for 'es8'; https://hackernoon.com/es8-was-released-and-here-are-its-main-new-features-ee9c394adf66 First page of results for 'JS ES8'; https://davidwalsh.name/es7-es8-features
Multiple issues with your html 1) Closing of html tag at line1. It should be your last tag. 2) No body tag. Coming to your issue 1) The elements you want to display block has to be hidden initially. Use display:none or visibility:hidden (both are a bit different) for textfield 2) Put your script tag in body so that elements are loaded before the script is executed.
`querySelectorAll` doesn't return an iterable in all browsers, e.g. IE11 does not support `.forEach` being called on a NodeList. It's a little broken to add to an array by doing `dropdowns[i] = ...` And yes, you could easily do `dropdownList = elems.map(function(parent) { return parent.querySelector(selectorClass); }).filter(function(child) { return child != null });`
A freamework is needed just because we want to make our development fast. And ofcouse learning vanilla js will polish your development skills thats no framework can do.
Go have a look at making a plugin in vanila js. If you are somewhere between intermediate development level. https://codingfacts.com/create-a-simple-javascript-plugin-in-pure-javascript/
How would that save me any time? I'll still type the same chars just not the chars that were already inserted by the editor. Or you meant to say a waste of time for the editor? Anyway there are many cases where I take advantage of what the editor inserts, such as control structures or function bodies.
Sorry! I'm not sure how to provide a working demo. I just assumed that CodeHS users may see this and toss it into the sandbox and run the code. :( Thank you so much still for cooperating! \^\^ Reset game you say? Yeah about that, I am having trouble resetting. I am really unsure on how to rerun the code from the start. CodeHS platform seems pretty limited. :( I've fixed the negating lives already, but now I am unable to reset the game after lives reaches 0. We tried so much things, nothing is working properly. 
I compiled it from pug (Jade) but I never actually bothered to look at the compiled code. When I try to make the display none in Typescript, same error. I don't think there seems to be a fix, ill just try a different approach to the game. Thank you.
Change the CSS of .textfield with display:none. Put your script in body tag. These will fix the issue. Let me know if I could help.
Hi, I think our needs would intersect, as I‚Äôm building a chrome extension for LinkedIN. Send me a pm and I‚Äôll let you know the github repo.
Always keep in mind with JWT tokens it's only used as proof, and not as encryption. So whatever claim you encode in the JWT, the content will always be readable by whoever has access to the JWT token. The only thing a valid JWT proofs is that the content is not tempered with because it is signed with a the secret only in possession by the issuer of the token. Auth0 provides a lot of documentation on JWT tokens: [https://jwt.io/introduction/](https://jwt.io/introduction/)
Use cookies.
https://www.pagerduty.com/ used it in my previous job for that exact reason, it's really worth to take a look at. I think it's paid tough..
[removed]
The rules say it should work on at least Chrome and Firefox. Usually means the latest release version if no details provided.
But what happens if the user wrote a different input-type? He will receive a message error or something like that?
You can create HTML and CSS using JS, so you can do that using JS alone.
Depends on how you want to display the calculator. If you want to display it in the browser then you probably want to use HTML and CSS.
Probably they expect you to make this calculator with some GUI, even very simple, so incorporating html &amp; css would be good idea. Good luck!
I love this concept! These guys should think about doing another event with Global Game Jam. I'll be sharing this with my students. :-)
I got it I found something better. 
Oh my gosh my confusion level have increased significantly. Appreciate the response none the less.
Okay. HTMLs are just objects and CSS is just used to make HTML pretty. JS, on the hand, is the machine that can create, manipulate, and delete every object in the webpage.
What do you mean by objects?
It means JS treats every button, div, paragraph, etc as an object it can manipulate. You can code JS to change the color of the button when click on it. You can code JS to display the number ‚Äú3‚Äù when a button named ‚Äúbutton_3‚Äù is clicked. You get the idea.
Ohhhhhhhhhhhhhhhhh it just clicked thank youuuuuuuu
&gt; Imagine a version of JSON.parse which returns strongly-typed results Are you familiar with [io-ts](https://github.com/gcanti/io-ts)? 
To riff on that a bit... While you could make the calc without a GUI, I think it'd be harder to make it in pure JS than to use HTML with it. (You could do it without CSS, but it's so easy that I wouldn't deliberately try to avoid it.) So in the end, go ahead and use JS, HTML, and CSS.
I‚Äôve been thinking about your response in the context of our current project at work. I really believe react != redux. The Redux docs themselves say you should wait until you really need it before implementing it into a project. They are certainly a popular combination, but you don‚Äôt have to use redux with react, and you don‚Äôt have to use react with redux. So in the context of a react app that doesn‚Äôt utilize redux, how would you handle async? Would you still reach out to a third party library?
As far as it's truth, this concept might be an overkill for a brand new programmer ;)
I checked out the flex environment before, my biggest paint point was that you lost a lot of the scalability options as you were in effect just using docker images instead of the 'native' 2.7 app engine. That and the documentation was horrendous.
Hi. Thank you for your prompt reply. I will send a pm.
I know. lol. I can‚Äôt dumb that down even further.
If this calculator needs to work in the browser, which I assume, then: \- HTML will provide the User Interface (the calculator buttons) and the display. The browser will take care of showing them on the screen. \- CSS will help you make it pretty / have a visual aspect of a calculator (like showing the buttons in the correct place in a grid) \- JavaScript will perform the logic, intercepting events coming from the HTML elements (clicks).
Here's a really simple version of a scraper I made with cheerio, request, fs and express. Not designed for supercoders but to help novices who understand jquery a bit. YMMV. https://github.com/lucastimmons/Basic-web-scraper
hey. this solution is great. thanks so much. trying to implement now :_)
I'm all for more choices, but the README is a bit over the top for my taste. &gt; The most lightweight JS Tweening library. The library is only 8.3 Kb (3Kb gzip) [Tweezer.js](https://github.com/jaxgeller/tweezer.js) is only 3k min'd, not even gzip'd. &gt; The most performant JS Tweening library. Claims like this without benchmarks on the same page...aaaawesome.
We're fresh out of a security workshop and talked a bit about jwt (or jw tokens, not jwt tokens). For now we're using this as a reference to improve: https://jwt.io/introduction/
You can have a look at Projects by Buttercup ([https://github.com/buttercup](https://github.com/buttercup)). They have nice JS related stuff which you can contribute to.
There‚Äôs a lib out there called `fs-extra` that ‚Äúpromisifies‚Äù all the file-system node functions, so it‚Äôs way easier to handle asynchronous calls and plays very nicely with the async/await syntax. 
I'm gonna lose. Again.
You could do it with the console but ...
Thanks. I take a look.
Did you have the interview? What was your experience?
Please read the README attentively. It doesn't claim that the library is, it says the goal is. Sure, benchmarks will be soon:) I like the idea.
Hey, you're absolutely right it does say that. Sensationalist claims (or goals in this case) still rub me the wrong way compared to saying "here are the choices, here's where this library sits and why it might be good for your use-case". It means I, or others, have to wade through the crap and see if your 8.3k/3k gzip really _is_ the most lightweight by looking at other options, instead of just having the info presented. I accept that shit from global corps, in my opinion it has no business in open source.
This is great ! It would be very interrested in an article describing how do you achieve such a hand drawn look.
As soon as I read "We believe this effort had paid off and will provide significantly shorter and cleaner error messages.", I was sold.
Very helpful thank you so much 
They want you to use HTML. Not using it, while possible, will just make things harder for you. CSS will only make it look nice, but it's probably optional.
You‚Äôll probably get better web search results if you use the official name ‚ÄúES2017‚Äù. For example, I‚Äôve written the book ‚Äú[Exploring ES2016 and ES2017](http://exploringjs.com/es2016-es2017/)‚Äù (free to read online).
My emoji challenge: https://codier.io/creation/ryGFK6pNX
Looking through the previous winners I have decided to spare myself the embarrassment. Is there a consolation prize for best/highest code to syntax ratio? I think I could do that. Well, If I read that correctly you get a t-shirt for trying, so maybe I try to make some time for this. It looks like fun.
Since i cannot figure how to comment there, i'll comment here: this article explains that everything is a weapon. There are two kinds of people thinking like this: military, and anti-military.
Was a pretty sad interview. Didn't even touch Redux. They cut me off halfway through. Said I wasn't enough. 
[removed]
1 listy blogspam article you shouldn't like blogspam
Aw man that sucks. I'm sorry to hear that. Just wasn't a good fit then. But don't let it get to you and keep at it. You can even use interviews as a way to judge future expectations. I used to have a manager that would encourage us to go out on interviews just to see what people are looking for in new hires. It was a risky move on his part, since he could lose his employees to other companies, but I don't think any of us took him seriously (or were too busy to bother). But his point was, to know what you need, you need to know what people want... though thinking about it, I'm not sure we, in that position, necessarily needed the same things that those other people needed... Anyway, that was a thing. :P
Author here. I'm neither a military nor an anti-military. I'm just a programmer. The article **shows** how two specific piece of the Internet's infrastructure are actually weapons. The DNS system is coarse weapon under the control of the USA that can disrupt the communications of entire regions. The Web instead is a precision weapon that **can** be used even from outside the US and against US citizens, but given nearly 50% of the world wide traffic go to US controlled "clouds", [it's still solidly in the hands of US companies (and intelligence)](https://www.politico.com/magazine/story/2018/07/27/silicon-valley-spies-china-russia-219071). Now, given the **huge security issue** explained there, the point is how to fix it.
Hit ESC, Hit Shift A and then the ; ideavim makes it possible. Still 3 Keys, but with my Layout i at least dont have to leave the homerow for it.
Thank you for your words. I'll try. Just down still. 
That's awesome!
Just made a really simple but versatile state machine, just to try out publishing an npm package really [https://github.com/joebentley/joes-state-machine](https://github.com/joebentley/joes-state-machine)
Nice! I looked at this example [https://franciscohodge.com/project-pages/simple-keyboard/demo/](https://franciscohodge.com/project-pages/simple-keyboard/demo/) A few things I noticed: * I don't like that the keys move around when I activate caps lock * I feel like delete should be called backspace by default * I wish I could also type with the keyboard and maybe see the keys on screen push down as I type, but not sure if that would be useful at all :)
&gt; i am unable to download by normal means What do you mean by that? Is there no download button like the messaging says?
Op in my opinion the best projects to contribute to are ones that you regularly use. For example, Prettier. I love Prettier, use it daily, and I want Prettier to succeed. Maybe there‚Äôs a specific feature (i.e. html support) that I want to help out with or a bug that I‚Äôve encountered and want to fix. I‚Äôm much more motivated to do both because I‚Äôm actually an end user of the project! Finding some random project that wants contributors isn‚Äôt particularly motivating for me. 
just implemented successfully. thanks a lot! 
That's a good point.
 Something like this? let fulltext = ""; for(let filename of filenames){ let text = await readFile(filename); fulltext += text; } 
It is very strange (and somewhat annoying) that I have to put a script tag into the HTML document, but it is working wonderfully now and I can continue progress with the game! Thank you very much.
You're right, that makes sense. So it affects initial responsiveness of the page. I'll have to see what the performance impact actually is. I am going to disagree about your second point. If you abstract the item creation to a function, you shouldn't have to remember anything except to call the function when you want a new item. There might be cases where this isn't possible because new items are being added as an HTML string, but that's a separate issue.
Just keep the download button as a Link to the embedded document with download attribute and make it look like a button using CSS.eg: `&lt;a href="/path/file-to-download.pdf" download&gt;Download&lt;/a&gt;`
CSS won't be necessary if you're not bothered about it looking pretty. HTML will probably be useful to permit user input (e.g. in a text field). However, you could possibly negate the need for HTML if you ran a JavaScript function directly from the address bar of a browser (provided you set your browser to allow this). If this were a project I were doing, I would probably do it that way, and create a prime number calculator in the form of a function `primes(N)` that would print all primes up to (and including) `N`. As a web browser can display text just as easily as HTML, you don't need any HTML in order to get it to display a sequence of prime numbers. Here's an example: `javascript:primes=N=&gt;Array.apply(null,Array(N)).map((x,y)=&gt;y).filter(i=&gt;(i&gt;1)&amp;&amp;Array.apply(null,Array(1+~~Math.sqrt(i))).every((x,y)=&gt;(y&lt;2)||(i%y!==0))).toString();document.body.textContent=primes(1000);` which, when entered into the _Chrome_ address bar, prints all prime numbers less than 1000.
Really impressive project! I've been wondering if something like this exists for a while now! This will for sure come in handy whilst writing notes! :)
Not deep enough. Unless you recurse.
TypeScript comes from JavaScript, so JS syntax rules apply - you can omit semicolons in most places, and braces in some places, but JS and TS will never be a braceless language and it will never be safe to always omit semicolons. Sorry :(
Honestly, it's more than a little bit to learn - the path to TypeScript expert isn't as long as JavaScript itself but it's close. But, you don't need to be an expert to get huge benefits - I often tell beginners not to struggle more than a few minutes at a time and just use `any` when things get tough. It's totally worth it even when you're a beginner IMO.
I think maybe `unkown` is something like Maybe&lt;UNION OF ALL TYPES&gt;.
This exists in babel already (preset-typescript). It's a great way to use TypeScript if you need babel for other reasons.
In some sense TypeScript is all about making perfectly valid JavaScript features not work due to a type error, so definitely it's something we're in to! For example, you can disallow mutations in some cases (e.g. the `readonly` attribute or ReadonlyArray&lt;T&gt; type).
TypeScript! DefinitelyTyped is a big reason why - TypeScript has better support for the JS ecosystem.
Yes but not really, all configuration must be defined in the json file, which is not programable, and many of the options that you can set in babel or any other bundler, doesn't apply for typescript. 
Here's what you do. Go to github. Use the search functionality and find a project with lots of stars but isn't dead. The readme should have instructions on how to contribute so you take that and SHOVE IT UP YOUR BUTT!
Frameworks come and go, what you need to ask yourself is "What is a framework like react actually helping me with ?" Maybe time efficiency ? Better and easier to maintain software ? Sometimes the task doesn't even require more than pure JavaScript, but still, my advice is to always be up to date with the new emerging technologies just because you'll learn about how the industry is changing, maybe what made a good framework can make a good programming lenguage of the future ? 
I'd say this is totally fine. You've got clients and are able to deliver for them, so no harm no foul. React/Angular/Vue bring a lot of tooling with them that you likely won't even use. 
I‚Äôm finding that some people who ‚Äúknow react‚Äù don‚Äôt know or understand JavaScript as well as they ought to. Maybe because of the tooling that comes with the library ? In any case, with solid fundamentals you can learn react at your leisure. It‚Äôs just a way of building DOM and there are alternatives with competing pros/cons 
[Markdown Plus](https://mdp.tylingsoft.com) has this and more!
The problem would be the way around: doing a lot of React without learning JavaScript. Frameworks have their place and use case, and it's good to know them and when they help, so that's one thing you might want to dive into when you have time.
Hi /u/harrisonmacp, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/marveluck, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/JojoMasterofDojo, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/FateRiddle, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
What tooling? Unlike frameworks like Angular and Vue, React uses vanilla JS to accomplish most stuff. You don‚Äôt look up ‚Äúthe React way to map‚Äù, you just use map. That‚Äôs a big part about what makes a React developer a JavaScript developer, where things like Angular and WordPress often produces Angular devs and WordPress devs.
You would be limited pretty quickly trying to use React without core JS principles; it doesn‚Äôt have the equivalent of framework methods, other than life cycles.
It's probably better to think of it similar to \`Dynamic\`, in that you have to write runtime checks to find out which type \`unknown\` actually is. The difference is that Haskell packages the data for the runtime checks, but in Typescript, there are different ways to figure out the actual type. \`Maybe&lt;T&gt;\` is equivalent to \`T | undefined\`, and \`All Types | undefined\` is technically equivalent(ish) to \`unknown\`, so it's technically correct, but I think the analogy to \`Dynamic\` is easier to understand.
Cool. Just signed up. I'm in a few of these code challenge/battle things and they really seem to help.
JSX and everything to make that work (yes, u don‚Äôt have to use that but many guides and materials paint that as the best path). In addition, I‚Äôve found that some people who learned on react have misunderstandings about how HTML works which I find a bit troubling. I might be biased tho; the code base I‚Äôm in has lots of packages added to make things ‚Äúeasier‚Äù and a few other folk who‚Äôve worked on other projects said it went that way for them as well. Also I‚Äôve been doing this for ages so I‚Äôve seen so many tools come and go.. 
Thanks for this elaborate feedback! I get what you mean by the keys moving when you press caps. This is something that has to do with flexbox (flex-grow: 1) , it sets the width according to the character's width. I'll take a look at it and see what I can do ! For the second point, consider it done :) It'll be part of the very next release. As for the third point, this is also something I want to release soon. I set up this sandbox [https://codesandbox.io/s/43nm6v4xyx](https://codesandbox.io/s/43nm6v4xyx) where you can also type with the keyboard, and it would update simple-keyboard's internal input variable (onchange). It's not quite there, but it's a start. Seeing a preview of keys pressed would be cool too, I'll add this to the [Roadmap](https://github.com/hodgef/simple-keyboard/wiki/Roadmap) so I get to work on it when I get the chance. Thanks again!
As you say, JSX is not React, but is a helper. You can use `createElement` calls, or even hyperscript. Having issues with HTML isn't a JS problem. Certain tools like `lodash` often save time and/or are more performant, which can justify their use.
&gt;The problem with your example precisely is that break would have to be specified by the for loop somehow Indeed!, it's fascinating to talk about how these flow control statements sorta work and their often underlying lexical relationship. the other way to do it.... *cough* ... *cough* ... ^^^^(Labels)
`console` will also work in the worker if you're just looking for something similar to console in the main page. Your current code looks fine too. http://jsfiddle.net/xeb7rj0n/
A dev who uses React, Vue and others... Sure, whatever works for you and your team. Don't feel because something is popular you have to use it. Personally I like frameworks, but I like plain es6+ more.
13k? What happened to 1k?
* Does it work in the business-defined supported browsers? * Is it maintainable? * Do you meet your deadlines? * Are you getting paid? If yes, you're probably doing better than 80% of React devs. 
I was missing a thing like this. Thanks!
Well labels won't help you with what you're describing because (I'm pretty sure) you need to be in the same scope to `break` on a label. But yeah, maybe you could use the label syntax for this. I did just realize that exceptions might not work perfectly to implement this. You'd need to modify all `try/catch`es to make sure the exception isn't a break exception. For example, if you have ``` my_loop: for (let i = 0; i &lt; 50; ++i) { someArr.forEach(el =&gt; { try { if (el.shouldBreak) { break(my_loop); // or whatever the syntax is } } catch (e) { console.log('all good in the hood lezzgo'); } }); } ``` it won't work if `break` is implemented using `throw` and nothing else is changed. You'd have to change `catch` to add like an `if (e instanceof LoopBreakException) { throw e; }` in the implementation.
[removed]
If it works then it's fine.
Maintainable &amp; reusable (esp by others) is what I'd first think React would be better at; seems reviewing larger projects are easier for me if they're React-based, &amp; I'm not an React expert. But I wonder what size project would React save up-front time? How much 'reuse' of React could one actually get?
Took me a minute to figure out if the caching was for JS files, images, data requests... seems like it is only a key-value store? How does it compare in features &amp; performance with the other key-store libs?
Neat! I wish I could search, or filter by popular frameworks like React.
I would rather know JavaScript and not react, than know react but not JavaScript. If you know modern JavaScript you can probably learn the basics in 2 days, then you can see for yourself if it would make your life easier or not.
No! It is NOT okay. Everyone must be using frameworks! Using native javascript and libraries is just like being a nazi!
API looks nice. I wonder how performant it is against FLIP libs?
Looks cool! I do wish I knew what the shifted (non-capital) were without hitting shift. I can't remember them all, &amp; I'm sure non-US keyboard users would be worse off.
Sweet, I was thinking of making one also; I'll have to play with it later &amp; make a PR...
Yeah that come and go bites quite often and whatever you saved on initial development you spend later on on fighting unmaintained framework. Sometimes
People who are using React without learning JavaScript are the ones more likely to be left behind. That said, I'd recommend looking into it (or similar) to get a grasp of what it could help you with. If you don't take the time to invest in making yourself more effective, you'll stay "very busy" until you can't compete with the market.
defaultProps üî•
This is _better than okay_. React is great. It's quite useful and very popular. It has a gigantic ecosystem surrounding it, and being super good at it will get you hired. For React work. But if you know JS thoroughly, you can always pick up React when (if) you need it, and do very well. But you can also just not, and do very well with just about anything else. React !== JS. It's just a library. My suggestion is that if you find that vanilla JS+HTML+CSS stops scaling well for you, investigate React. See if it does stuff you like, and is a valuable addition to the way you think and write code. If it is, that's super. You'll have a great time because you'll know it's a good fit for your project, and makes your life easier. If it's not a good fit, that's _also_ super. Your life will be easier for not shoving unwelcome technologies into your work.
Apples and Oranges. [This is a nice comparison with react](https://reactjs.org/docs/web-components.html), but the same logic applies to vue. If it's right for your project, use it, if you feel you need more, then jump into vue :)
That's a very good point I hadn't thought of! I'm definitely interested in implementing this, maybe through a setting that the user can switch off if desired, etc. I just added this as the top item in the Roadmap here: [https://github.com/hodgef/simple-keyboard/wiki/Roadmap](https://github.com/hodgef/simple-keyboard/wiki/Roadmap) since I think this would be a nice addition. Thanks!
Web components with a [polyfill](https://www.webcomponents.org/polyfills) is pretty safe. However what you can build using just them is very limited, so you'll need likely need to pull in a helper library like Polymer but by that point it's probably better to just use Vue.js
Features wise: the core module has very basic API (set, get, has, remove ... see docs: [https://stash-it.gitbook.io/stash-it/api/cacheinstance](https://stash-it.gitbook.io/stash-it/api/cacheinstance)). But it is prepared to being: * extended (new API methods) * reactive to events For both see Plugins docs: [https://stash-it.gitbook.io/stash-it/plugins](https://stash-it.gitbook.io/stash-it/plugins) Here are some examples of plugins in use that both extend the API (prefixPlugin) and add some event handlers for various events: [https://codesandbox.io/s/40op375q67](https://codesandbox.io/s/40op375q67) (see how easy it is to create a write-only cache instance, just few lines of code). And that is where the true power of stash-it lays - plugins. The intention, the reason behind creating stash-it, was that the core library should be as small as possible, but if needed - you could extend it to whatever you want. I couldn't find anything like that (there were either modules with tones of functionalities and weighted a lot, or had not what I would like, were not as flexible). stash-it is even detached from storage you want to stash the data in. You need to provide the adapter. At the moment there are two adapters, more on the way (time is what I need ;) ). API for the adapters is polymorphic. You can switch adapters whenever you want, and the module will always work the same - meaning, you decide what you will use. Performance wise: can't tell. I haven't compare it to anything yet. I don't know which modules to compare stash-it to. If you have anything on your mind, let me know, please. I will prepare some measurements and post them here. If you have any more questions - let me know, I will be happy to answer them.
Nope
you dropped your /s
I think this is really cool as an exercise, but what's the point in using front end frameworks like React and creating an API for the frontend to use, when your frontend isn't reactive and never calls the API? You've basically used modern web technologies designed for creating SPAs and distorted them into a site that uses 90's style web architecture, where the pages are static and every click requires a request to the server to get the next page. Don't get me wrong, it's an impressive achievement! But it just seems like a really bad idea :D
When he stops receiving pizza. Let^me^show^myself^out
would be nice if you could do a benchmark to compare
Order of operations. `[]` is an empty array. `+` converts something to a number. `+[]` is 0 (the numerical version of `[]`). `!` converts something to a boolean and negates it. `!0` is true, because 0 is falsey. `!+[]` is `!0` is `true`. `+true` is 1, so `+!+[]` is 1. `[+true]` is `[1]` so `[+!+[]]` is `[1]`. `[1] + []` is `"1"`.
[https://github.com/olympikesoft/olympusjs](https://github.com/olympikesoft/olympusjs) Create Models and Controllers from command lines
The impression I get is that parcel - while promising - is not quite ready for prime time. I tried it a month ago and it choked on a pretty easy setup (html and typescript).
This looks very cool. I wonder how it compares to, say, [Chart.js](https://www.chartjs.org/)? Apex seems more fully featured, at first glance.
Can you give me an example?
If you made an input field in a page, as example to sum 2 numbers using that feature. What happens if he wrote a string in the field?
I'd expect map/join to have much better performance characteristics here. Repeated string concatenation is notoriously slow because you're potentially copying memory around every time, whereas join is able to allocate enough memory for the entire string upfront.
Thanks. :) I take a look. 
Wonder why you got downvoted here. The available type definitions alone is a good enough reason to go with it. A lot of people here are React people, and choosing React over other view libs for its ecosystem is basically the same thing, right?
My React TODO List https://codier.io/creation/rkHsmxANX
What you have there should work. Getting an element by id and attaching listeners to that is an alternative approach.
looks like a real cool website. Will check back more often, also quite good for finding inspiration
Thanks for checking it out! This tool is used to create stylized SVGs from images. Github: [https://github.com/Anemy/svgurt](https://github.com/Anemy/svgurt) NPM: [https://www.npmjs.com/package/svgurt](https://www.npmjs.com/package/svgurt) I built it to use with my plotter: [https://twitter.com/hashtag/plottertwitter](https://twitter.com/hashtag/plottertwitter) but I imagine it has some other uses too!
Great tool
Then only thing missing is an about page, or some sort of heading. What does this website do? By just going to the website I have no idea what am I looking at. 
Better to learn Javascript than React (if the reverse is even possible).
Press save button
Is there any reason why none of the entries are visible on mobile?
[Gitlab has support for this in issues and comments](https://docs.gitlab.com/ee/user/markdown.html#mermaid). You can use it in markdown with ```mermaid // definition here ``` I use it for sequence diagrams quite a bit. The syntax is slightly different from [WebSequenceDiagrams](https://www.websequencediagrams.com/).
Hi, I think where ts.js shines best is with the server side JavaScript (NodeJs) is becoming imo as popular as python with some advantages to it. Another thing that it's really nice is the ability to save/load pre trained models from/to python or JavaScript. That really closes a gap between developers. Actually I've been tinkering with Tensorflow JS for a while and built a wrapper class around it to abstract a Multi Layer Perceptron! You can check it out [here](https://github.com/bolt12/mlp-tf-node) and tell me what you think!
Everything is alright.
Good point I never thought about it like that.
This is excellent, very clean work
I think it's because people hate scrolling for no reason. It takes one click to be at my CSS and one click to be back at my container logic. Not an arbitrary and variable amount of scrolling that changes with each component. It seems insanely self evident to me that multiple files allows for vastly faster development, but maybe it comes down to whichever editor you use.
I had @imports in my css and it confused parcel for some reason. I've used npm now to install the dependencies i can and removed those that i can't, it ran but now it says jquery undefined (although its included first among others)
Don‚Äôt work yet üò¢
What is on lines 1-4?
üëèStanleyüëè
Thanks for sharing. This is really well written (better then the official release notes imo)
Thank you! I got it now!
Are there any open source tools you use regularly and are familiar with? Check their open issues on GitHub and see if if there's anything you can do. Often things are labelled as "help wanted" or "beginner friendly" and are great places to jump into a project. After making contributions, link to your GitHub profile and let that be your recommendation. I think you might have more luck tackling smaller issues every now and again - you'll be able to show that you've actively contributed to open source over a longer period of time. It eats up less time than you think it does, you learn some very useful skills (being able to jump into a new project and get to grips with its conventions and CI pipeline is valuable) and is incredibly satisfying!
Web components just encapsulate and that is all. Once you‚Äôre in your shadow root you‚Äôll be wrangling with a naked dom all over again. There is hardly a practical use for this spec and only an insignificant number of projects use it. Stay with your framework, which does today what W-C will still struggle with in 10 years. 
Been waiting for something like this for so long. This will be fantastic for documentation. So cool.
I don't see the problem really, if you know javascript then you don't have to learn react like you learned a framework in the past. It is a small javascript centric view layer, nothing more. You keep on using the javascript language and react helps you casting your frontend into little composable components with access to other components that others have made. You be the judge of that: if you construct a frontend around your backend and you start to notice that fishing out dom nodes out of div soups gets tiring, then of course, use a view layer that'll make that process simpler and re-usable. If you keep re-inventing the wheel, wasting time on things that you know have probably been made by others with more time and resources, then yes, grab those components from an eco system.
If I was a country with an antagonistic relationship to America I would be a lot more worried that 90% of my businesses run Windows and use Google. We've seen countries rebuild the internet inside the borders (China has pretty much done this).
True, though as it is, the default is simply `true`
Also the whole mutability/immutability stuff and React's setState (and AngularJS's related functionality) becomes much clearer once you have worked with a language where you can pass variables by value or reference.
OP is a puppynoob, so let's spell these out: Object Oriented Programming; Functional Programming.
Yes it does. That's like saying "being a great tennis player does not make you have great hand eye coordination." Improvement in the former necessarily means improvement in the latter.
How could you be a great React dev and not know vanilla JS? How is it even possible?
&gt; I've seen some pretty awful React and vanilla js in React projects Sure. But the premise we're all talking about is someone who is *strong* at React. Of course a shitty React dev can be shitty in vanilla JS. But the guy we're all responding to was talking about someone who is *strong in React*.
You were making an irrelevant point, that a shitty dev is a shitty dev.
Boo, it's not idiot-proof, I can create empty TODOs. ;D.
&gt; You're describing an anecdotal fallacy. Just because you, in the past, needed to learn multiple languages does not mean that in the present or in the future I will need to learn other languages. Oh the irony considering you're literally doing exactly that. "I've only needed JS so far, so that's all I'll ever need."
**Mars Rover Pictures** https://erik4github.github.io/photos-from-mars/ This is my first project with React, so there's probably a lot of things I could have done better, but I'm still pretty happy with it. Select a Rover and a Sol (Martian day) and submit, filters to the side.
[https://www.kitslice.com/](https://www.kitslice.com/) A place to create and share lists of related and useful products. Features a sleek and snappy UI built with Vue.js and MaterializeCSS. Would love to get some feedback!
Also not what I think of as a decorator, which is a function that wraps another function. Maybe I'm revealing that my degree is in theoretical math rather than CS, but isn't he using "decorator" where he means "inheritance" or "implementation of an interface"?
I got back into Javascript in a big way thanks to AngularJS. Since then I've migrated away from the framework and back toward VanillaJS (I missed most of the jQuery years in dotNet/MVC) and I couldn't be happier. Many React/Angular/etc developers seem to lean far too heavily on their ecosystems and the tools there-in. In comparison, I'm in the process of moving from AngularJS to VueJS and its going to involve migrating about 200 lines of code in a circa 400,000 line system plus modifying the HTML templates, and that's it because I didn't buy into the "do it the Angular way!" and kept most things in VanillaJS. So rather than a 6+ month redevelopment of our system, I'll have a single dev 2-ish week work item to do the migration.
Those error messages look amazing! Going to push my boss to update right after our next release!
How does the content differ from https://github.com/trending?
I could be doing it wrong, but I believe there's an issue with one of the tests in challenge 5. I expect this to work: toHash() { return SHA256(this.data + this.previousHash) } However, in the tests, if you instantiate a new Block each time, it won't pass
Why do none of these ever support spider/radar graphs?
/u/Anemy is there a no style option? notion of png to vector conversion is great, it would be invaluable if the full picture can be converted with the preserved quality 
awesome
That's pretty damn efficient. It'll happen in microseconds.
I think a big thing will be AI-aided dev work. So for example you might have a UI where you drag and drop components and indicate relationships between them with a click and drag and the AI will intelligently recognize they need an adapter between them to make them be able to talk to each other and will generate boilerplate code for that where you'd go in and tweak certain things. Like maybe one component has a prop called username that takes a string, and another one has a property called emailAddress that is a string and you indicate one component is a child of the other and your UI generates boilerplate that assumes emailAddress is the username and passes that as the username prop. That sort of thing.
I'm late for Saturday but I just made https://github.com/springload/react-accessible-ellipsis
Good points, thank you!
I honestly couldn't tell if these were real packages or not before Googling... #FuckingWebDev
*Building sliders that don't work on mobile. FTFY
Rocket Chat - [https://github.com/RocketChat/Rocket.Chat](https://github.com/RocketChat/Rocket.Chat)
I think that your UI is not correct. Thing which you built is basically a rank - by convention every rank is always top-down (or opposite) and your users expect that it will be same in this case. Also I think that you should put numbers closer to the title and make it bigger Right now reading this rank requires effort and additional cognitive load, some images to illustrate my thoughts: [http://i.imgur.com/8aXI9wk.png](http://i.imgur.com/8aXI9wk.png) [http://i.imgur.com/NSlgZzk.png](http://i.imgur.com/NSlgZzk.png)
Very very good point. That's Joel Spolsky's Law of Leaky Abstractions in action ( https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/) and why I guess I think that every developer should have at some point gained a familiarity C - all out modern languages are built on layer and layer of abstraction and whilst most of the time you can ignore what's going on layers down having some idea how the plumbing works is invaluable.
Hello. I was learning Wordpress. But now I'm learning to write grammaticaly. I check addmission essay here - &lt;a href=' r/https://au.papersowl.com/admission-essay-writing-service '&gt; Papers Owl &lt;/a&gt; - it is the best writing service. This is the service that helps students and schoolchildrens.
Thanks
Thanks for sharing! Very interesting to look at. Does anyone know if there is anything like this for Angular 2 and above?
as a professional resource MDN is the best. If I could give some advice in general however, don't try to learn the language theoretically. I.e try to make something. and stretch your horizons with each subsequent project.
Yes. WebComponents are here to stay. By the end of 2018 every major browser will support them natively. I once held a 1,5h presentation why a company can use webcomponents in favor of easily used style components. Using them combined on the server side with [ASP.NET](https://ASP.NET) and angular.js. I have written my thesis about what is possible with webcomponents. client - server - database interaction If you are able to read German have a look: [https://github.com/drdreo/webcomponent-cms/](https://github.com/drdreo/webcomponent-cms/) WL;CR: (wrong language, couldn't read) * Used WC (WebComponents) for the design ( obviously easy, using paper-elements - material design) * WC for the express server. There are WC like &lt;express-app&gt;, &lt;express-router&gt; which let you structure your server with HTML markup * WC for the DB interaction. I've create a &lt;db-query&gt; component which can be triggered and through a callback return the result. It was a proof of concept. No real advantage of using WC on the server. Only for beginners, i can imagine, it looks very easy to set up a server and some router handlers, due the visual structure of the markup. Some other comments mentioned the need of polymer to create WC. That is not true. Polymer is a very nice tool for easier WC creation but you can achieve everything polymer does by yourself. But i highly recommend using polymer due to some very neat things like automatic polyfill handling and shadow DOM attachment. 
The best option is to add arbitrary infix or even mixfix operators in syntax, like in other languages, so everyone would choose what they like. There are really too many options, in fact at least 4 compositions are required for (usual, async, generator and async generator functions), a few ways to compose, say generators, etc.
Is this the same as the render props pattern?
Ok thanks ;)
Hi, author of ApexCharts here. Chart.js - the beautiful canvas chart library is a well tested and extremely popular library out there, but ApexCharts has the following additional functionalities which I think are not present in chart.js directly. 1. Better zooming/panning - Chart.js has plugins for it, but doesn't works elegantly. I think, interactivity is the most important thing for any visualization. 2. Annotations - Placing text over certain values or anywhere in the chart area. 3. Events/callbacks to further extend the interactivity of other charts based on the new data that we get in those events. 4. An option to customize nearly everything! Colors/Gradients/Borders to most chart elements. 5. Heatmap/Sparkline/Cool Looking gauges that enhances the dashboards. What ApexCharts doesn't have currently - Radar Chart - LogScale - Performance of Chart.js - as canvas will always win in comparison to svg when there are lots of datapoints
Nope, this article is about passing more than 1 children so you can keep any kind of specific logic to a single component. Render prop pattern is tye new way to pass down context, without prewraping your classes (HOC). 
Instead of learning on your own i would suggest you join some online programs where you learn in a structured manner. You can apply for this. Its free : https://university.hackerbay.io
I've been waiting for pipelines to be a approved for quite some time now.. Anyone know about their status? I've seen couple of [proposals](https://github.com/tc39/proposal-pipeline-operator/Wiki) and waiting patiently for one to be approved. 
[Stage 1.](https://github.com/tc39/proposals) You'll probably be waiting for a few more years.
Codecademy is pretty good. I would avoid w3. 
meshzilla sounds better than dwed jobson
We were just getting into the whole necessity of both bind and pipe last week. Both are good, but we don't really need one for much if we have the other. Personally I'm on team ::bind. It fits better with existing syntax and has a nicer symmetry with arrow functions. I find the multi-argument usage far cleaner too. The whole placeholder values for pipelines looks like a damn SQL prepared statement: foo() |&gt; bar(1, ?) I do a lot of Observables (rxjs) with React (removed the redux from my package.json a while ago) and I especially love the prefixed bind operator, eg mystream$.subscribe(::this.setState)
I think ‚Äùthis‚Äù is the wrong way do handle ‚Äùpipeable‚Äù functions. Like other langs with a pipe op (like elixir) it deals only with function arguments and returns a result. Simple, easy and testable.
You can because when you need to do nothing you create a empty task... just kidding, thanks for the advice. I forgot to check this condition.
This was exactly what I needed. Thank you
Some people find it quite outdated. MDN is much better in terms of content
Ok I‚Äôll try MDN then
They may have improved recently but they tarnished their name back in the 2000s by containing a lot of misinformation, bad code, and charging for certification under the implication that they were actually affiliated with the W3C.
The Zulip mobile app is a pretty interesting React Native project : https://github.com/zulip/zulip-mobile/ I think it is a great example of well-written and clear code. It features: * good documentation * extensive unit-tests * thorough Flow types
That doesn't make any sense
It helps to read up on Perlin noise, but basically: * Generate a list of random points. * Smoothly interpolate between 2 of those points. * Mix noises for more 'rough' surfaces. Example: values = [1, 6, 3, 7] x = 2.3 // Index 2, fraction .3 result = 5.1 // Smoothed value between index 2 and 3
Wow! I was looking for this link days before because i really want to apply to this program. Thanks for sharing again!
Seeing as this is React, you should read up on how to pass props between different components as functions are just that, props.
[Eloquent Javascript](http://eloquentjavascript.net/) 
Sounds like a project idea, thanks :D
You're welcome !
I've seen it in other contexts for JS (namely Vue), and some older cross platform C gui frameworks (I think wxgui used it?), so I think it's probably common.
It usually refers to the qt framework, where slots are basically type-safe callbacks for gui events.
[removed]
I agree in theory; the tricky part for me is the whole placeholder thing. Everything in your stream needs to be single-arg or it's either a confusing mess of either arrow functions or question marks. For something like an Observable, this can actually work reasonably well since that's how things are all setup by design, e.g. `({ foo }) =&gt; ({ foo, bar }) |&gt; ({ foo, bar }) =&gt; foo + bar` is a fine way to pass along two values, by passing along as props. Binding to a `this` has issues too, obviously, but so long as your `this` stays immutable as it goes along it's not so bad. Definitely has advantages on 'pipeable' functions, but I also don't want to see the language littered with more redundant syntax, and the `::` covers a lot of the same use-cases (esp. around tree shaking/code splitting). If we have one we probably shouldn't have the other. I love that `::console.log` is shorthand for `console.log.bind(console)`, since love it or hate it that's something I need a _lot_ with third party libs. If I have to choose between pipes (which I agree are more easily testable), and an easy way to bind the context of functions I pass into event handlers or run in classes, I'll choose the latter. Though you have got me thinking, is this really a debate between looking back and supporting old patterns, or looking forward and supporting emerging trends? I am feeling like with apps getting way more reactive and needing to handle streams more and more, maybe I'll change my mind on this in a year once I find myself needing pipes more and able to use `this` less.
Yeah i agree. I think tje pipeop should be kept as simple as possible. Not sure if i like the placeholder syntax. It could simply just take functions with a single param, just like in elixir. If you need more data just pass along an object as a return value and grab additional data from there.
Huh. I'll check that out! Thanks! Inkscape still has a bunch of features that svgurt doesn't have - I'm thinking maybe we should make it a plugin for inkscape as well?
I really dislike this based on the arguments here: [https://twitter.com/popmotionjs/status/1024307887466860544](https://twitter.com/popmotionjs/status/1024307887466860544) It seems weird that you'd make a system whereby simple functions are \*\*only\*\* callable via [myFunc.call](https://myFunc.call)() rather than a regular function call. It makes your code way less fungible, and none of these functions are compatible with the commonly-used \`pipe\` method either.
Pretty much, except you don‚Äôt pass in a function, but a complete jsx object, so you can‚Äôt use any data from the parent. 
This is a good introduction to JavaScript and programming conceps. You'll learn the basic conceps like variables, functions, objects, the DOM and more like an intro to NodeJs. Also has many ecxercises so you will have a lot of prantice. Teke a look here, it is wonderful http://eloquentjavascript.net
Eloquent JS is amazing but I don't think I would recommend it to a complete beginner. 
Vue has a lot of ‚ÄúVue-isms‚Äù. [Here‚Äôs their API](https://vuejs.org/v2/api/). Instance properties, methods, directives, top level API. It‚Äôs got a lot of stuff. React has props, state, 6 life cycles, fragments, context and refs (and a few other small things). Vue is a framework, not a library, and there is a difference.
This is surprisingly robust for what I'm assuming is a relatively young project. Might have a play around with it. I like how it's highly opinionated and there is an expected structure to how the code is organized (It feels like every express project I've worked on has had a different structure, and sometimes not even internally consistent 100% of the time)
Did you seriously write an entire paragraph because of a single downvote?
Maybe stop caring so much.
No. 
Freecodecamp has hundreds of hours of training. https://www.freecodecamp.org/ And it's open source. I'm one of the volunteer contributors.
You're totally right, thanks. I've made the change
Hey there @chromezero! Thanks for bringing this up. It sounds like the issue is more the 4th stage. The 4th stage expects you take in a new block as a parameter to the \`addBlock\` function on the Blockchain. If, instead, you instantiate a block in \`addBlock\` you can pass the tests for the 4th stage but 5th stage fails as you mentioned. Does that make sense? I'll be sure we clean this up a bit in the next release.
Slots? You mean props? Passing a node into a prop isn't a new pattern and doesn't give it a new name. There's even a PropTypes.node type.
Then enjoy your stress.
I'm working on something pretty similar to this, called [Lively](https://github.com/KashubaK/Lively). Although it is more centered around Socket.io (but includes functionality for building Web APIs), and forces you to use MongoDB (c'mon it's 2018, stop doing that) via the Mongoose module. The Readme is a bit spotty, so I wouldn't recommend playing with it just yet. I mainly use it in my own projects, and is super opinionated.
I must be missing something. Reports already have report-to options for alerting the site owner that a report happened. This API seems useful for display a message to the client, not for notifying the owner, but the author's justification seems to be fixated on notifying the owner.
Hrmm, it wasn't at all the spicy Italian delight I originally thought it was going to be when I clicked the link.
Though it would not be a problem if you could assign name after creating the tasks though. 
Thank you! I've been looking for something like that for awhile now. ,üëå
Yes. Glad to hear someone asking this question. Understanding how to learn a framework is a good skill to practise. They're ultimately just abstractions that come and go, as has been said already, but they're all related in some way -- either promoting a countering a trend. For example, I've used a lot of knockout.js and a decent amount of React. Picking up Vue.js was really easy because of both of those frameworks. Ultimately, the general goal with any decent framework should be to have code that is simple, easy to maintain, sustainable, and approachable. I think it's worth just keeping that in mind. Frameworks are just new syntax and abstractions, but the underlying engine is Javascript. 
Which one is then?
Have fun giving ID to random sites. 
I guess everyone must think this way is too confusing/crazy/non-assumptive but when I first heard about piping I assumed it was a sort of combination of these options: the first arg was the "main" value, but when using piping it automatically passes the chained value as the first arg. Just syntactic sugar. So you could do: ``` const addToEach = (arr, add) =&gt; arr.map(val =&gt; val + add); [1, 2, 3]::addToEach(10) // OR addToEach([1, 2, 3], 10); ``` I dunno...makes sense to me.
Definately needs to be a react component 
That‚Äôs what I was wondering ... seems un-verified
you can kill process attached to a port just fkill :8080 for instance :D 
Scan in your photo ID to a university that uses a Google Form application process? Seems really strange to me. 
One nitpick - this is value noise not Perlin noise. You're interpolating between randomized points rather than using randomized slopes. Perlin has a continuous value *and* slope (ie derivative), whereas value only guarantees a continuous value. Usually the more differentiable your function, the fewer artifacts you'll have. [Here](https://codepen.io/anon/pen/vaRdGp) is a quick example of Perlin in 1D. That aside, a few suggestions: You can make your interpolation very slightly more efficient by eliminating one of the multiplication ops: val = a * (1 - f) + b * f = a - a * f + b * f = a + f * (b - a) You can also be more efficient in `getValue` by getting the integer and fractional parts of `x` using a single floor and subtraction instead of getting the fractional part using a modulo: const max = this.values.length, const ix = Math.floor(x); const fx = x - ix; // "gradient" const i1 = (ix % max + max) % max; const i2 = (i1 + 1) % max; For octaves/fbm I like doing it this way: const noiseFn = x =&gt; { /* ... */ }; const frequency = 1; const amplitude = 1; const lacunarity = 2; const persistence = 0.5; const fbm = (x, octaves) =&gt; { let a = amplitude; let f = frequency; let max = amplitude; let result = a * noiseFn(x * f); for (let i = 1; i &lt; octaves; i++) { a *= persistence; f *= lacunarity; max += a; result += a * noiseFn(x * f); } return (result / max); }; Avoids exponents, and if you restrict persistence to always be 0.5 you can even drop the summing of `max` and just return `result / (2 - a)`.
Thank you for the detailed information! I will definitely give ApexCharts a try.
Very nice, thank you!
Some of the examples when I was learning JavaScript were imo fucking stupid, and overly complex. Seems like he just wanted to show how clever he was rather than teach you at some points. Everybody needs to remember when writing a book on learning a language. It is 10x as hard reading other peoples code then it it to write similar code yourself. 
I'm just mad a Inkscape because I don't know how to use it properly, sooo many clicks ...
RGB Color Game [https://github.com/cds8410/rgb-game](https://github.com/cds8410/rgb-game) This was a custom adaptation of the project from the Colt Steele course I did a month or two ago. I made a couple extra modifications that I thought would be nice, include a background color changer and some css animations. I'd like to do some revisions to make this run smoother. I like aspects of this project, but there is a heavy reliance on timers in this. I used timers to prevent certain errors in calling a function in succession. And it would sometimes awkwardly draw out the game longer than needed. Anything to keep in mind for the revisions?
(CesiumJS)[https://cesiumjs.org/]
It‚Äôs very interesting to me that every big company has its own framework, considering the large amount of existing, open-source frameworks. I wonder why.
I think most frameworks build to the best majority use case. So you might end up with things your company doesn‚Äôt need (bloat) or things it does need that aren‚Äôt included. Most of these build off another system to start and are tweaked to meet the best use case specifically for that company. We‚Äôre way too small for it now, but I could see the merit of building a framework just for my team that speeds us up and adds consistency
Because everyone needs to throw their dick into the measuring contest. Thanks for nothing uber. Isomorphic has been a thing for a long time without you. I don't see how adding more shit into the pile makes it any better. 
This is cool. Mix it with an incredible ORM and you've got yourself a basic Rails in JS. =)
lol why you so mad
Now you're thinking with portals!
Because I'm coming from a crypto article and I still haven't settled down. 
Some of it can be driven from "not invented here", another aspect though can be: The other frameworks get "close enough", but might not close the gap easily for their use cases/needs. Doing a quick look at Fusion though, it looks like it's a Framework built ontop of React, or atleast compatabile with it. To be fair, React is a "component library" - it doesn't offer much guidance / framework beyond that. Most react projects end up using a combination of react + redux (or mobx) + react-router / etc - and start to piece together a bit of a "build your own framework". After setting up something like that over, and over, and over on many projects - you start to notice patterns, boilerplate, etc that could be abstracted away. So this seems like a way they are trying to formalize how they build "React Apps", by providing a framework ontop of it. If it's appropiate for other people to adopt or not, "???" - but it could be a good fit for their own projects, that they have just decided to open source.
What article?
Web server in nodejs: https://github.com/botdevteambdt/httpengine
Anyone can give a TLDR? Checked out https://fusionjs.com/ and it's not really resonating for me. Also, mentions of DI make me gag.
You build something, notice a need for something that doesn't exist elsewhere so build a solution to it. Your solution catches on within your company so you standardize it. Sometimes between when you initially built it and released an open source version of it someone else launched a similar framework, sometimes your framework is just different than the other ones and more geared towards how your developers work. In this case it looks like Uber has a variety of libraries they already use for logging, analytics, i18n, etc. and wanted something more pluggable for new apps to be able to utilize those libraries. The blog post also says they have 60 apps that already use it, so I tend to believe they've had this for a while and when it was originally built they may not have had a viable option that did all of what they wanted.
This is a remake of a previous project bootstrapped from create-react-app, where the prior was just a HTML, a CSS and a JS file. It is a tool for looking up streams on Twitch.tv and has some recommendations already on the page. This is the [repo](https://github.com/BLBaylis/twitch-tv-tool) and this is the [live site](https://blbaylis.github.io/twitch-tv-tool/).
Your question is a little vague. People don't know what you mean by snackbar. Tell us more about your js environment too. 
"just decided to open source" seems like the right answer. Unless you want to write code exactly like uber does I wouldn't use it or any other framework.
The typical shit on medium claiming crypto is the solution to all man kinds problems. I'll try to find the link. 
That shit makes my blood pressure rise for sure. A bunch of scam artists and a terrible piece of tech with zero real world application. 
Developer working on Fusion.js here. I think that currently there is a lack of frameworks that makes working with isomorphic virtual dom applications &amp; server code easy. Fusion.js does this well. Many projects don't need SSR + server side logic, but if you do you end up needing to invent a lot of solutions yourself. With a solution like Fusion.js, you know that hundreds of apps are using the same framework, and there's a team of developers you can talk to and work with on you problems. It's certainly not for everyone, but I do think it can provide value for the right use-case.
Hope it's better written than their emergency braking code.
I looked around their example boilerplate projects and it looks like a normal React project to me. I mean, that's an oversimplification, but it kind of feels like a different design pattern for React components, so it doesn't seem very useful to me.
(Article author here) I'm actually not aware of many company-sponsored OSS frameworks that are similar to Fusion.js. The closest ones I know of are Next.js, Electrode and create-react-app, but they are more focused on frontend than full-stack. All of them (Fusion.js included) use OSS darlings (Webpack/Babel/React/Redux/etc) so it's not like any major wheels are being reinvented. The similarities between Fusion.js and Next.js/Electrode/CRA pretty much stop at the developer experience stuff (e.g. HMR). As they say, the devil is in the details. For example, Next.js doesn't do treeshaking (let alone isomorphic-aware tree shaking), bundle-splitting-aware I18N, async font loading, CSRF protection, perf metrics collection, etc. A lot of these things are hard to bolt on top of existing OSS frameworks, especially if you have to support hundreds of web apps and need to roll out a security fix or perf optimization or whatever. 
React is freedom? Try Backbone. That's freedom. 
Basically, in addition to providing everything you'd expect in other frameworks, Fusion.js plugins make it easy to install support for useful things (e.g. CSRF protection, atomic CSS) that are hard to setup in other frameworks. Also, these features are curated and maintained by the Fusion.js team and we have a large team whose job is making them better and more performant.
Do I have to put "5 years experience with Fusion.js" on my resume now?
You should look into lettable operators with rxjs. They will work with the pipe operator (I use them with ramda right now). 
Ten years late, but hopefully not too late. In 2007 I worked in a project that promised a distributed IoT platform. Unfortunately I don't remember what it was called. 
Yay another new thing that does exactly what everything else already did to learn! Gotta have love for the current JS scene!
I agree. I wasn't aware this was going to be "you either get pipe or bind, not both". I'm going to be quite disappointed if we get bind instead of pipe. Bind will encourage continued use of `this` instead of pure, composable functions. Arrow functions also won't work with the bind operator, I assume. 
The guy making the joke or the company with such contempt for human life that they disable emergency safety systems in order to provide a "smoother ride"?
Double savage!
I completely agree with your decision not to put an ORM in there. While I might recommend Lumie to someone using Rails because it might feel more familiar, Node is *not* Ruby/Rails, and that's a good thing imo. Anyways, nice work.
Yes, let's not have choices
Yep, looking like a normal React app is one of the goals. Basically, React stuff should be exactly the same as you'd expect, minus the annoyances regarding Provider registration in the context of server-rendering. You can also easily install more features (e.g. GraphQL, atomic CSS, I18N, async font loading, CSRF protection, perf metrics, etc) through the plugin system, and you can use that same plugin system to organize complex backend code in testable ways.
I understand some of these words
[https://cdn.rawgit.com/cds8410/rgb-game/f5ecc417/HTML\_CP.html](https://cdn.rawgit.com/cds8410/rgb-game/f5ecc417/HTML_CP.html) Pretty cool. I'd speed up the animations, and there are a few points where interaction is blocked (colors are loading, clicking "hard")
5 years experience? You should apply for a [job](https://fusionjs.com/join-us)! :) 
Yes, web components are great for styled components - if that's all your app needs it's the perfect choice. Very few applications are purely made up of styled components though...
Slots are usually containers you pass as children so the parent knows how to deal with it. React doesn‚Äôt use this pattern because you can pass components or react elements as props, which the author is doing. It‚Äôs fairly common.
Well sure, polymer is written in javascript so you can do it yourself - but why write your own framework?
Due to many companies haven‚Äôt yet set on webcomponents. If the reason why you shouldn‚Äôt use them is that nobody uses them, you get an endless loop. 
welp the site is down already
You have to see Polymer less of a framework, but more of a tool. Like any npm package. 
Why should a large company depend on some other company's (a maybe even a competitor possibly or becoming one down the road) software, if they can easily develop it in-house?
Feels like the title should have been: "Really Trying to Use Async Iterators with Click Events"
Thank you for having time to take a look at Lumie. It does not work as a middleware, like you said, it's more a initializer or a loader. If Lumie take care of the routing in a middleware, all the work of looking for the right action to execute for a route will be executed at every call. This is why there is a Lumie.init function to call when you start your server in order to load routes once.
There's an example on the [snackbar demo page](https://www.polonel.com/snackbar/). ``` Snackbar.show({ text: 'I have a custom callback when action button is clicked.', width: '475px', onClose: function(element) { alert('Snackbar Closed!'); } }); ```
Frameworks are designed to allow you to keep a consistent codebase, so that, in theory, any engineer with previous experience in it could jump into your codebase and understand what's going on
The link describes why. Just read it?
Thank you for open sourcing this. All the features you mentioned above could be more accessible, and especially more maintainable with a framework like fusion.js
I can assure you many companies have tried web components, they just aren't powerful enough to develop anything other than a static web page. Not sure much an endless loop than a 1 hour journey to a dead end.
This looks interesting. A standardized way to do react. Just something that I was looking for.
I am sorry, but i am not a fan of fighting technology stacks. Everyone can have their favorite. Many companies have used webcomponents successfully for their applications which were not static. McDonalds, YouTube, Google. Just to add on your little argument. Webcomponents have nothing to do wether to create static or dynamic webpages. They are as capable as any other frontend framework, as is. And through community progress, they can be used for many more usages. Seen as in server side technology. There is no need of a question like "Are they capable of ...?" - yes they are. But "Are you willing to investigate into it?" - probably not, because you get most things done faster with a framework. Therefore, again, it's not about using a framework, but using native technology. 
This confused me a lot two years ago, especially Eric Elliott articles. Most developers in industry uses classes now, and this argument is dying down Airbnb advocate class/extend in their style guide https://github.com/airbnb/javascript/blob/master/README.md#classes--constructors Uses throughout React https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class Used by default in Angular Used extensively in Web Components https://developers.google.com/web/fundamentals/web-components/customelements 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [airbnb/javascript/.../**README.md#classes--constructors** (master ‚Üí a12dec9)](https://github.com/airbnb/javascript/blob/a12dec90d173464a3fc4e4536b8c6f639fb93236/README.md#classes--constructors) ---- 
Their mobile site is AIDS.
I recently rolled my own SSR + server side logic solution and it was a pain in the ass, and I still don't have hot reloading working. fusion.js is perfect for my use case.
Could you tell us exactly what circumstances causes the `isLastElement` DOM element value to change? There must be something telling it to change, and it's better we hook into that (using event listeners for example) than hooking into a UI change. Your code should NEVER rely directly on your UI updating - updating the UI should trigger some variable somewhere to change, and you should watch for that to change instead. You would be better using an event-listener or an observable. Observables are super-useful and libraries like MobX (a react state management library) use them to update UI with date. This article should give you some insight into building around observable's in vanilla JS: https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87 Side-note - While loops are notorious for being difficult to do correctly (especially UI-based), and absolutely should be avoided when you're working with UI elements. For example, the main thread will freeze, and the message to update the value (in your example, this would be what's assigned to `x`) may never get through. The only code that overrules this is that running by Chrome itself which is built to detect hanged or frozen tabs (and it's only real purpose is to allow users to terminate the tab process), but sometimes even that can fail if the code that's causing the freeze is particularly heavy. Out of interest, what's your use-case for this? I'm pretty sure that the community here can come up with a more elegant solution.
What should trigger the callback? onShow? onClick? onHide? Something else? I know what you mean by snackbar, but I don't know what you're wanting to callback from.
I'm not sure it's possible to do aspect-oriented events in video.js, but maybe I'm just daft Here's the important parts of the button code, pretty much the standard way of doing custom buttons in videojs var defaults = { popOutCondition: true, transferAttributes: true, rejected: "You have been prevented from popping out this video, and the developers should have explained why", windowOptions: "width=854,height=480" }; var Button = videojs.getComponent("Button"); var popOutButton = videojs.extend(Button, { checkCondition: function() { if(typeof this.options_.popOutCondition == "function") return Promise.resolve(this.options_.popOutCondition()); else return Promise.resolve(this.options_.popOutCondition); }, handleClick: function handleClick() { var button = this; this.checkCondition().then(function(outcome) { if(outcome == true) { if(typeof button.options_.popOut == "function") { button.popOutWindow = button.options_.popOut(); button.pauseVideo(); } else if(typeof button.options_.popOut == "string") { button.popOutWindow = window.open(button.options_.popOut,"popout",button.options_.windowOptions); button.pauseVideo(); } button.popOutWindow.addEventListener("beforeunload", function(e){ var popOutPlayer = button.popOutWindow.videojs(button.popOutWindow.document.querySelector(".video-js")); player.currentTime(popOutPlayer.currentTime()); player.controlBar.show(); player.posterImage.hide(); if(!popOutPlayer.paused()) player.play(); button.popOutWindow = null; }, false); } else if(button.options_.rejected) { if(typeof button.options_.rejected == "function") button.options_.rejected(); else if(typeof button.options_.rejected == "string") alert(button.options_.rejected); } }) } });
well that code was intentionally never written soooo
There is *far* more to Rails' success than ActiveRecord and routes. 
Same here. Am deadly curious. Will check it out tonight. 
Is the website supposed to look bad on mobile or is that a bug?
Photos From Mars, queries the NASA API and displays them in cards. https://github.com/erik4github/photos-from-mars my first project in React and Node, so there's probably a ton of things that could have been done better.
FWIW I instinctively down vote anyone who makes an edit complaining about downvotes.
Funny, I actually dislike snapshot testing. I like to see exactly what is being tested in my tests
The big 4?
Hah same - it's really slow for me as well. Does that happen to you? A tough part about this project is managing complexity of actions and ease of use of the UI. 
That's a fair point. I can imagine that on the scale of company like Uber, with so many moving parts, it's probably not that \*that\* rare to run into edge cases not covered by mainstream tools. 
You know what? I just don't care anymore. I'm done with frameworks-of-the-week. I'll look at this a year or so down the road if there's still buzz. Until then, my brain needs a rest. 
For my company, we decided to abandon frameworks because we got sick of the "new framework each week" syndrome and "omg the one we chose decided to abandon the project and now we need to migrate everything to flavor-of-week!" freakouts. We're also sick of "Well there's this change in their code that we want to make, but if we fork it now we'll have to maintain a gigantic codebase of stuff nobody here wrote that's poorly documented, so I guess we'll just live without that feature." At a certain point, it makes sense for a large company to make its own framework. 
I‚Äôm so happy they made this! I really needed a Javascript Framework!
Why and how would you do CSRF protection in the frontend?
Microsoft, Google, Apple, Facebook (?)
The spacing does look weird
I think it is a good thing. React boilerplates around still feel quite lacking. Even next, which is supposed to be a complete thing, still needs tons if extra setup. We are in need of good kitchen-sink frameworks for react, we are lacking in opionionated react packs.
Metallica, Slayer, Anthrax and Megadeath
I feel like the actual problem in your company is exaggeration. React came out in 2013. Ember has been around since about 2012. Even VueJS is four years old. 
&gt; `import Router from 'fusion-plugin-react-router';` So a fusionjs app would depend on `fusion-plugin-react-router` which depends on `react-router` which depends on React. Does this not make you feel unstable given all the dramas about react-route? 
https://imgflip.com/i/2f4m9q
But in all seriousness, I just followed this guy's tutorials. https://youtu.be/KEkrWRHCDQU
Neat
I must be missing something then because I am still thoroughly confused, but I am glad for User's dev team, they seem pretty proud of it. 
You don't, sadly. This is the price you pay for using a free, open-source technology stack. You don't have to pay anyone, but nobody is in charge, either. In any case, you can't go wrong with Visual Studio Code, Typescript, Node and Express.
Well, It's not easy to deal that kind of chaos even to experienced JS programer. there are so many IDEs, so many frameworks, so many *module bundler* tools out there for you to use. It sure can be exhausted. My suggest is: 1, choose a IDE, Vs code is my current choice. 2, choose a framework, I recommend ReactJs due to your ios experience 3, stick to one tool at first, use it first and then you will know whether it suit you or not
It bemuses me that a customer-facing technology company puts a ton of focus and effort into their technology but comparably very little effort ensuring their customers are happy.
ha, nice. i know you may not have a ton of control over this at a company uber's size (or maybe you do cause fusion just launched), but some feedback for that page: from just that link you provided, with no other context, it's really difficult to know where the job is actually located. i `ctrl+f`ed the page for san fran, sf, bay area, california, ca, and remote and nothing came up. it would be super helpful to mention it on that job posting page if you're going to be linking to it.
sometimes if your question is short and not specific, the answer you expect could also be short and not specific. Anyway [Jason Rodriguez had a wonderful article you can find it here](https://css-tricks.com/javascript-learning-landscape-2018/)
Thank you for the great answers. I have to say I am sold on most parts of Fusionjs, except the Flow part. Of course Flow makes sense for you guys as you are already heavily invested in it and have a ton of _existing_ apps. But why should I start a greenfield app based on Flow in 2018? I agree with type inference advantage, but my problem is something else: Flow may not be here for long.
OK, so you say VS. So did the other poster. I was using Brackets, but it's crap. I have been dealing with IT issues 98% over the last week due to just getting set up, and just choosing the easiest thing to get set up. Then I run into an problem, and have to download something else and get that set up. I've done like 8 lines of code in 5 days, it's crazy. 
What is the point of Node? Sure, it's supposed to be an async non-blocking runtime, but behind the scenes it just spawns POSIX threads so it's the same as a threaded application. The downside if you have to write boilerplate routing and MIME type handling. It seems like a pointless waste of time when with something like Apache, I don't have to write routes. Is there something that just has basic routes built in so I don't have to write them? How do I deal with CRUD operations to do something simple like write to a database? It all seems way more complicated than it needs to be. Sorry for complaining, it's just frustrating getting started with JS stack. Thanks for your advice.
Don't people also complain about customer support from Google? The thing about customer support is that by the time you get there, you're already unhappy, and there's very little a company can realistically do to make you happy again. It's very challenging to do customer support in a way that makes the customer happy and at the same time is cost effective. It's twice as hard when you're mediating between an unhappy rider and an unhappy driver. A lot of times, people want more than they are really entitled to because they want to "punish the bad guy" or whatever. To add insult to the injury, there are also a lot of bad players trying to get away with fraud and abuse so even the go-above-and-beyond strategy falls apart.
Honestly, if Flow dies, we're just gonna have to dedicate a few sprints to migrate to TS haha :) FWIW, someone already made a fork of fusion-cli to add TS support, so at least some of the work is done, if push comes to shove.
\&gt; The thing about customer support is that by the time you get there, you're already unhappy, and there's very little a company can realistically do to make you happy again. This is simply not at all true, especially with Uber's customer support. Amazon and Vodafone are examples of good customer support. Uber is good at technology, but spare me the lecture, your customer support is terrible.
It isn't mandatory to provide an ID. You can apply even without it.
Oh, sorry! Yeah we should definitely add that info. Currently we're looking for people in San Francisco or willing to relocate to SF (we can pay relocation costs). The office is in downtown SF.
Needs some padding
It's really not that bad
Yes, arrow functions have diffrent ‚Äùthis‚Äù than normal functions. The bind op will make JS even more complex for beginners. The bind op should be dropped in favor for pipeing. 
op has posted the same post in 6 subs. these are the only posts on his account. there are 2 'positive' comments on this post from users with 1 karma. Sherlock out. 
The catch handler doesn't handle http error codes. If you want to catch certain http status codes, you can use `Response.status` and `Response.ok` as documented at https://developer.mozilla.org/en-US/docs/Web/API/Response fetch('whatever').then(response =&gt; { if(!reponse.ok) { throw new Error(`Request not OK with code ${response.status}`); } return response.text(); // or response.json(), or whatever else }).then(text =&gt; console.log(text)).catch(error =&gt; { console.error(error); // handle all errors (request failed, 404) here });
&gt; use the core libraries and piece what middleware I need on my own Well, that's sorta what we did for our old framework. It just got unwieldy when _everything_ was riding on top of monkeypatched req objects and nobody could remove things they didn't need or even test things properly.
"plugin based" gross, just use react and node and... Oh, it's an OSS. Wow this is pretty awesome :D. Personally I went from going hard on isomorphism, to not caring, basically once I found out about http2.
You might just try writing some regular JS script files and including them with script tags in an HTML page. Forget about all the tooling and compilers and CSS preprocessors, just get the hang of the language and working with the DOM. Make tic-tac-toe, a todo list, a simple Reddit reader. Just target new browsers, don't worry about compiling down for IE10 or anything. Then install node and start playing with some commandline scripts.
Hi /u/im_a_nevernude, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
The point of node is to be able to run Javascript outside of the browser that can access the filesystem, start servers, connect to databases and other stuff that browsers can't do.
react base grade app. github.com/lvsanche/public-kiwi
Java makes terrible JavaScript programmers. I wouldn't recommend it.
What guarantees do we have that Uber will continue to support this project? "Large team" sounds impressive but many of us have been dependent on now-orphaned projects from large tech companies. 
Thank you. 
Yep. Most notably google
Well, it's the standard web framework that we use internally and we have a lot of projects starting with it and migrating to it. So we're pretty invested into it. Stopping support on it would be roughly equivalent to the React team disbanding. We don't have competing technologies (Angular/Polymer/GWT/etc anyone?) and we are strongly averse to that kind of fragmentation/duplication (Vue is flat-out disallowed, for example). If we ever decide to build a new shiny thing in some far hypothetical future, we will have to build automated migration tooling because we simply cannot leave hundreds of apps in limbo (and in fact, we did write automated migration scripts to migrate people from the old closed-source framework to this one).
You should learn language of JavaScript first, then learn how to use libraries. Otherwise, you'd be stuck like this.
For beginners, JavaScript can only execute one program flow at a time. So, while you're doing the loop, whichever code that changes that element attribute's value, will never have the chance to be executed. So, you must let the current program flow to end. In order to both check the attribute value and do scroll at the same time, execute the code using timer (via either `setTimeout` or `setInterval`). e.g. if the code is set up to execute every 200 milliseconds, each after it's executed, the program flow ends. That'll give other code a chance to execute. If there's other code still being executed and the timer code should be executed, the timer code will be queued for execution, and then be executed when that other code's program flow has ended.
I think you are delusional, the simple MacDonalds homepage uses jquery, their menu board needed polymer as did youtube - google have their own little team using web components but they wouldn't use it for anything serious. Everyone can have their favorite stack, I'm afraid it's just you with web components though.
The catch error handler is for the network request only. Not for the resource. The catch code will only be executed if the network request fails because it can not reach the server, or fails to create the network request.
This sounds like another "oh don't worry, it's open-source" patent scheme just like the one Facebook was leveraging for their own personal gain. 
Yeah, I completely agree. Hopefully we'll get better at this with time.
Seems doubtful. I tried asking Google if virtual assistants will be the next big interface change, and she's not sure how to help.
Given that that its 2018, it should be a hell of a lot better!
I get why Google care about this but as an enterprise developer building internal apps I love that I can ignore bundle size (within reason.)
What blockchain back-end are you planning to use for BlackholeJS? I have 15 years experience of running DLTs in the AI powered cloud and would like to contribute
It's just some // comments with my name and the name of the game. But I figured it out, I misspelled console on lines 45-46.
Well said my friend. 
I've actually updated my octaves using bit shifting instead of Math.pow(). Same calculation, but a bit cleaner. However, your octave calculation is a bit faster, darn ^_^ Thanks for the feedback! 
Is it just me or do Google's products themselves such as AdWords and Analytics nowadays load really slowly? AdWords in particular is just really painful to use. (And I'm on fiber.)
Love it! It's great to add useful tools to the CLI when that's the only interface you have in some environments. Keep up the good work!
You aren‚Äôt a serious tech company until you‚Äôve written your own web framework it seems. 
the solution is known before, but funny the both things appeared at the same time seeming independently
You dont know if you dont study js i think
But can you deliver on the next generation wave of turn-key data centric customer-product relations?
Ah ok. I worked in finance for a bit where the big 4 means the 4 big accounting firms (EY, KPMG, Deloitte and PWC) so was confused when I saw the big 4 in this context as I havnt seen that phrase used in the tech industry before. 
üëç
It's an extremely annoying API imo. /u/arilotter gave you the general answer. Now imagine that a 403 error might return text regarding why the request was forbidden. You end up with this mess. fetch('whatever') .then(response =&gt; { return Promise.all([response.json(), response.ok]); } .then(([body, ok]) =&gt; { if (!ok) { throw new Error(body); } console.log(body) }); }) .catch(error =&gt; { console.error(error); // handle all errors (request failed, 404) here });
So I've been messing around with node for a while (all backend stuff) and haven't kept up with the web frameworks. If you were going to make a card battle game, would you even have to do it in canvas anymore?
As plugin is favorable for both client side and best at servers, hope so it does not appear serve issues as this keep hampering the performance for site in web. 
 - Try /r/LearnJavascript - Post code **as text**. Do not post code as images. - Do not post some code and just say "this doesn't work" without saying what it is supposed to do or what is happening instead. **Explain** your problem. - Use a descriptive title when posting. - Stop whining. 
I must be weird cause I use constructors and prototypes all the bloody time.
Sometimes people don't even know what they want to ask
What database (and library) are you using? Is it possible that your connection's aren't closing and that's causing the promise to fail (perhaps the DB is limited to a certain number of concurrent connections)?
Call `scrollTo` only once. Set smooth scroll with css. ` * { scroll-behaviour : smooth; }` Scrolling will be smooth, but you can't set the time for scrolling. Most of the time, it works best.
What you're probably thinking about are: - Front-end (client-side) frameworks (React+Redux/MobX, Angular, Ractive, Aurelia,...) that are used to divide large web pages/apps to small reusable components and bind data to them. - Back-end (server-side) frameworks, which usually consist of a router (it maps incoming GET/POST/PUT/PATCH and other HTTP requests to appropriate handler functions) and some utilities for sending responses to the client, serve static files and so on. Notable examples are Express and Koa. - Electron is a framework/environment for building desktop apps with HTML/CSS/JS. It basically renders a web page/web app in its own window and allows you to access some extra features like reading and writing files (they are not available in regular browsers for security reasons). Alternatives for Electron do exist, but it is the most developed environment at the moment.
You haven't shown any code that would make the sco in the finally scope the same as in the promise scope (as I assume you want). 
You can start with [freecodecamp.com](https://freecodecamp.com) Currently I am doing the same. Also, checkout this: [https://medium.freecodecamp.org/500-free-online-programming-computer-science-courses-you-can-start-in-august-bc1bcac1af5e](https://medium.freecodecamp.org/500-free-online-programming-computer-science-courses-you-can-start-in-august-bc1bcac1af5e)
Whaaaa, the first time a receive a compliment like that, thank you so much! But just for your personal information, I don't need a checklist to be "fame", the initial Front-End Checklist reached 28000 stars on Github and I'm still the same person trying to create free tools for the community when some people just, front of their computer, just criticizing without knowing what it feels to reach people and help them to become better as a Front-End Developer! No hard feelings, I do understand that could be sometimes complicated to understand.
Cool.
Yep, that's exactly the goal. I found in the past, checklists that couldn't be updated and this frustruted me. That's one of the reasons I decided to create it on Github. 
What is isomorphic about it? 
Don't hesitate to do a PR!
&gt; Zoinks! You've taken a wrong turn. Let's split up, gang. If you're looking for an image, it's probably been deleted or may not have existed at all.
Well it‚Äôs a bot for runescape. The standard method for bots is to say ‚Äúif the arrows are equipped, change enum to go and shoot the target; providing that you‚Äôre standing in range, if you‚Äôre not, the. walk to get in range‚Äù else ‚Äúif no arrows are equipped, go and talk to the npc start a new game and equip the spare arrows given‚Äù which changes the enum back to shoot. Talking to the npc who will give you get another 10 arrows which you can immediately equip‚Äù I already have enough arrows/can bring my own and,a player wouldn‚Äôt need to equip the 10 that are provided each time. So because I want to equip more than 10 arrows at once, but still need to talk to the npc to start a new game, I don‚Äôt want equipping arrows to be my condition. Instead I want to detect an image on screen of the npc saying ‚Äúwell done, you‚Äôve finished‚Äù to be my condition to start a new game. I could set a ‚Äúif click here to continue‚Äù appears, click it, but that would appear for all messages so I can‚Äôt use that as my condition to change enum state because it wouldn‚Äôt necessarily mean to start a new game. Unless I did the click here to continue changed the enum, and then hit the space bar at times intervals to continue. But that click here to continue would appear more than once and might break the script. Also, legitimate players rarely click the continue message to close the box when there is no further dialogue, instead they read it and then do the next task. Hope this makes sense
Thanks, but I‚Äôm not technical enough to understand your explanation. Is there not a simpler way, if (this .jpg file appears on the screen) then enter enum state for a new task? 
Do a finite state machine. Each node represented by the actions to do and the arrows representing if image found. As far as doing the image processing goes, I‚Äôve done some similar stuff. Google has an image text interpretter that I used in a python project. If you want it to be lighter/less flexible and can make assumptions about the texts I‚Äôm sure you could do something like looking for specific colors. 
Get better phones and push for better internet. With service workers and caching, ceiling is in hundreds of megabytes.
Reframe (https://github.com/reframejs/reframe) is another plugin-based isomorphic web framework but it focuses on flexibility. Fusion.js locks you in, Reframe doesn't. (I'm Reframe's main author.)
Your second if statement should be else if
I pretty much settled for using Next.js for all web projects, but I'll definitely try Fusion.js and compare them, the features sound very interesting.
in the meantime, serve your users with the technologies that are available *to them* today.
You might have better luck with this question over in r/java not r/javascript. Remember that Java and JavaScript are two separate, very different languages.
There are also plenty of techniques to do something in CSS and bypass JavaScript completely (e.g., a good number of show/hide functions). However, since CSS is largely seen as the stepchild many Front-End/"Full-Stack" engineers don't want to bother with actually learning in earnest, the low friction approach of using plug-ins and JavaScript continues unabated. Hiring Managers should really start interviewing developers/engineers not only for "can you do it" but, like myself, "how do you do it performantly?" If you're not, you're part of the problem. It's not like undermining technologies such as AMP was borne out of nowhere and for no reason. 
Without some significant JS knowledge, you're simply not going to find a job within the market. Every framework that's in common use relies upon JS to function. Frameworks like React are almost exclusively JS and there's very few situations where you'll touch HTML directly (you still write some HTML when creating components, but they tend to rely heavily on JS). Even styling is sometimes done as JS (or similar). AngularJS (that's version 1 of the framework only) does make much more use of HTML but it too also relies heavily on JS. Angular (that's version 2 onwards) is much more heavily focused on using JS. There's no shortcut to landing a developer job without knowing JS, no matter how exceptional you are at HTML and CSS/SASS/LESS. No one writes websites in HTML only any more. There is no minimum level or amount of experience needed to apply for jobs or land one. For example, even with 3 years of experience building personal projects, I still wasn't up to 'work standard' with JS despite that being my focus. An additional year of focused learning on modern practices and building some more personal projects taught me a lot more, and it was after that point that I landed my first job as a developer. Even when I started with them, there was still a lot to learn. In the first 5 months, I learnt all about workflows, pull requests, client specs, communication, etc. Most importantly, I learnt the framework we use on a daily basis (React) while on the job. However, I wouldn't have gotten anywhere if I had never bothered to learn JS. Going back to where I began, I actually learned JS originally within a job secondment. I got moved to a developer role with no real knowledge, but a willingness to learn. It still took someone taking a chance on me to even get discussions going. That's one way you can work your way up, but it's going to take time in either case. The current ecosystem in development (i.e. what businesses are looking for) and roles are as follows; *Designer* - They use design tools such as Sketch, Adobe XD or even Photoshop to create designs that will be used by the developers when coding the project. *Front end developer* - They build the visual side of things that visitors see. They know how to write JS which is interpreted to output HTML. *Back end developer* - They work purely in JS (or other server-side languages). They may know HTML and styling libs, but they won't have a reason to use them in their daily work.
Such a fucked up answer... Why don't you just ignore the post instead of leaving a useless comment? 
I've been doing enterprise gigs since 2011. It kinda sucks that I can't show off my work to family and friends. Do you ever feel that way? 
[http://javascript.info/](http://javascript.info/)
`if` statements are seperate from each other. `if...else if...` statements are 1 statement in and of themselves, and will stop at the first condition that matches. The idea is that if you only want 1 of 3 blocks to execute, you can guard the other two blocks by making it so your `if` statements are dependent on whether another if statement executed. it's kind of like saying let execute1 = false; let execute2 = false; if (someCondition) { // do something execute1 = true; } // another condition AND the first if statement didn't execute // AKA - 'else if' if (someOtherCondition &amp;&amp; !execute1) { // do something else execute2 = true; } // both first if and second if didn't execute // AKA - 'else' if (!execute1 &amp;&amp; !execute2) { // do final fallback thing - in your case, set pixel green } In the case of your code, what's happening is that it first looks at the pixel's X position. if that pixel's X is &gt;= the first third, set its red value to max. Then it moves on to the second `if..else` block. let's say we're at pixel X position 0, and your image width is 15. it sees that the X position is less than (2 \* 15) / 3, so it can't set the blue value to max, so instead it hits the fallback - it says that it's going to make the green value to max. So now your pixel's color value is `R = 255, G = 255, B = ??`. i'm saying that blue is unknown because we don't know what it was originally. It may be worth setting all the colors at once, (kind of what [https://www.reddit.com/r/javascript/comments/93ympd/why\_does\_my\_for\_loop\_meant\_for\_modifying\_pictures/e3gxgv7](https://www.reddit.com/r/javascript/comments/93ympd/why_does_my_for_loop_meant_for_modifying_pictures/e3gxgv7) says) If you do `if..else if..else`, you say that all the pixels are now red. im skeptical, unless you're running into math errors due to integer rounding. how large is the image that you're manipulating?
I can't help but feel frustrated when I read an analysis like this. The biggest performance gains come from pushing back on your marketing department. Make them choose their trackers and analytics scripts *judiciously,* and you'll be in a better place when you begin to apply the techniques Osmani describes. It's like the cyclist who spends hundreds of dollars on lightweight carbon parts to shave ounces off his bike. If he were to give up soda, he could take ten pounds off the rider instead.
I see your answer very usefull but let me pin up to the topic. What can be considered a good knowledge of JS in Front end? How can it be proven? 
You could, instead of directly exporting your class, export a factory function which returns a promise which resolves to the finished, and fully loaded, SlowServiceWrapper.
I'd probably calculate x as a ratio to make it a bit easier to work with. const x = pixel.getX() / img.getWidth(); if (x &lt; 1/3) { // setRed } else if (x &lt; 2/3) { // setBlue } else { // setGreen }
Did as you suggested and now its working good. Thank you so much. p.s. I owe you a beer
Wee just rebuilt one of our monolithic PHP apps with the front end in react redux (back end it go). If this is as large or bigger than ours, architecting will be important no matter which library/framework you go with. I appreciate that react doesn‚Äôt make every decision for me and I am able to trailblazer or take that traveled path for any given issue
The problem was with the database connection. Also thank you for the suggestion. I will fix those issues
Maybe people shouldn't ask questions that can be satisfied by a really quick google search? 
Looking at the code a bit, it looks like every frontend `fetch` request to a POST/PUT/PATCH/DELETE endpoint does a request for a CSRF token, then attaches that token to a header of the request you actually wanted to do. Is that correct?
Even though I use Vue for everything, I think React is best for large projects. It has slightly better lifecycle controls. The function components, excess boilerplate, and styled components library all help for large projects. HOCs are also easier to reason about and use for calls than Vue (I guess it is mostly a syntax thing?). 
This is fine, what's wrong with it? Without seeing actual code you want to be more "elegant", what you've posted is fine.
This was a great reply thank you! Worked great. 
Maybe a switch statement or a short circuit statement (condition &amp;&amp; {...})
[https://github.com/mdemblani/twitter-login-client](https://github.com/mdemblani/twitter-login-client)
Large part of the problem is people champion maintainable and safe codebase first. Being performance minded can often result in deviations from the templated "norm", which get shot down on PR with "premature optimisation" or other suchlike comments. The mentality of "fix it later when / if it presents a problem" is understandable but common sense and experience should also be a factor. 
Could always use a Switch statement. Although they can look pretty ugly if you have some lengthy code. 
Agreed, but a lot of it is also accountability transference as an output/symptom of being "safe". For example, running directly to a "safe" plug-in you only need select functions from, but is in actuality has a kitchen sink approach, adding far more to the bottom line than needed. For my team, we eschewed frameworks entirely as of late in favor of bare-metal JavaScript (thereby eliminating bootstrapping time) and a Web Components-like approach with patterns toward mostly static builds, isolating any dynamism to specific optional components. We know generally what functionality we'll need, optimize for that but keep adaptability for extension in mind, and create a pluggable module out of it. The developer can switch the modules off they don't need, and be assured that what they do need is there. If it needs to be extended, we discuss the approach as a group. 
const conditionLookUp = { apples: ‚Äúred‚Äù, bananas: ‚Äòyellow‚Äô } const fruit = () =&gt; ‚Äòbananas‚Äô; const handleCondition = condition =&gt; conditionLookUp[condition]; handleCondition(‚Äòapples‚Äô) //=&gt; ‚Äòred‚Äô handleCondition(fruit()) //=&gt; ‚Äòyellow‚Äô Pardon the formatting I wrote this on my phone. 
35k massive? lol, aww.
Are the conditions mutually exclusive?
 function a () {}; function b () {}; function c () {}; const which = ‚Äùa‚Äù; ({a, b, c})[which]();
Just because a new framework is released doesn't mean you need to adopt it instantly. Before I went with Angular 1 - (this was years ago) - did an evaluation of a number of ones, did some pro/con analysis, did a number of PoC's in each - then got people from my team to try them out and get their input. Think I had been using Angular 1 since 2012/2013 - and still have a number of projects in production that are chugging along just fine. The lack of LTS for Angular 1 and knowing it will be officially "unsupported" soon is a cause of concern. Near the end of my time of focusing on Angular 1 - most of my code was just plain ES6, using redux - and then importing stuff into a file that would wrap it in the framework. That code has been highly portable. During the time working on my Angular 1 projects - React got big, lots of other frameworks popped up - some fizzled, some remain kicking around but a bit more niche. I'd keep my eye on them - and see what patterns / concepts / etc I could leverage - the first project I used redux on was an Angular 1 one, not a React one. If someone is migrating to every new framework "just because" - thats a problem with the team, not the fact that new things keep getting released. I'm a little burned by Angular 2+ right now - but think I just need to eject some of my old knowledge of it (used it since the RC days), as people adopting it recently seem to be feeling a bit more positive about it. The thing I dislike about Angular right now, is that it really tries to infect your code with 'framework isms' - and I had gotten used to pushing the framework as far to the edges as possible, and really just using it for the View layer and trying to keep as much of the other stuff "framework agnostic" as possible - a coworker as a cool demo of a Tetris game that has like all non-UI logic as framework agnostic code and can swap between Vue, Angular, React to render it - and maintaining state while switching frameworks. I do enjoy working with React, but I find that there are a few things that it makes me think too much about - I know how to do it / handle it / etc - I just don't want to anymore. Vue for me, kind of hits that nice middle ground, and really excited for it. But framework / tool / etc churn doesn't happen only on the FrontEnd, I was full stack .NET for awhile, and have gone through the pain / migrations of * Classic ASP to ASP.NET * WebForm with "all the logic in the code behind" in VB.NET (code I inherited) - to refactoring and migrating the logic to WCF Restful services * Moving from WebForms to MVC * MVC to WebAPI * Various upgrades of C# * From "roll your own" database tools, to trying EntityFramework, etc The rate of change wasn't always as fast - but I'm used to being in environments where the toolchain / etc changes fairly often. I find one of the challenges of building your own framework though - is unless you have people that are dedicated to working on it, maintaining it, etc - it will quickly fall into disarray, find bugs, or will start being used for use-cases you didn't expect - and no one has time to try and accommodate / maintain them. A few years ago I had built out my own JavaScript framework at my last job - was useful for a few projects, but it was never my "job" to build / maintain it - over time I stopped having time to work on it, stopped using it on my new work - and started to encourage people to stop using it also. Unless you have dedicated people to support "building your own", it's not something I'd recommend. 
I can't seem to get that working either. How exactly would it "resolve to the finished, and fully loaded"? I'm pretty sure I just tried that and it didn't seem to help. Could you write even some rough code to clarify? What I ended up with was basically as below. export loadSlowServiceWrapper = async function() { return await new SlowServiceWrapper(); } I also tried moving everything into an async init function and executing that after newing it, but it didn't help. 
The web dev ecosystem, specifically around JavaScript, is a complete nightmare. Try getting someone up to speed while you are working on even a moderately sized project, and watch as the question marks appear over their head. Do I use Webpack? Or Grunt? Or Gulp? Do I compile my code? If so, do I have it target for es5 or 6? Which module system should I use? CommonJS? Require? AMD? I'm thinking of using TypeScript. It works with JavaScript. Sometimes. Debugging can be hit-or-miss. Well it generate soruce maps, but now those breakpoints aren't hitting. I'm using *import* but I saw someone else use *require*. Why would I use one way over the other? These are just a handful of the questions you'll find people asking the moment they open a start project. Why it has to be this complicated, I have no idea. I haven't seen any benefits of making web dev so convoluted. 
Your code doesn't line up. Where does `slowService.slow` come from? It looks correctly undefined to me. Shouldn't it be `slowService.service.getData`?
I work at Microsoft and we often can't show the code we do with partners. What we can do though, is often open source parts of it, builds talks around the code we are using, and share those at events, videos, blogs, etc., Even if you can't open source, just discussing the process of (X) without naming the customer is huge. 
So true. 
Depending on the surrounding code, a map may suit you better
I just hope that this community, at some point will see the value in combining HTTP2 + async scripts with dependency control + closure + executing using microtask queues. It was possible since ES5 and I am afraid since everyone is so eager, so inclined to champion a known figure, unless one of them cheers the idea, it won't be given a crap about.
Constructors can't be async. You either need to load the data before construction, or construct then call an async method waiting for that, or create your service promise in your constructor then wait for that before resolving your instance. Since it sounds like your class instances are useless without this data, I would load externally first, then construct with that data once available. This also provides some decoupling of the class and service.
const dos = { condition1: do1, condition2: do2, condition3: do3, }; dos\[condition\]();
how would you do a switch statement in this case? condition1, 2 and 3 dont depend on the same variable.
how would you do a switch statement in this case? condition1, 2 and 3 dont depend on the same variable.
This is related to web-scraping. On one of the sites there is no Next button, additional products appear only if you scroll down. The loading of new products is handled by javascript but I can't seem to be able to figure out what handles the loading. Is there a tool that would help me with that?
Thank you.
Switch it with consideration to variable, pass a variable as a function argument and then switch inside the body? Give me a full code snippet.
Thank you for responding.
thanks.
I'm just going to pipe in, I'd stick with either a series of `if`/`elseif`/`else` blocks or `switch`/`case` statements. I'd avoid doing meta-programming things like `({ collection, of, methods })[someGeneratedKey]()` because it will make debugging much harder. The _elegancy factor_ isn't nearly as important as the readability factor. If you have complex conditions, I'd recommend doing something like this: const shouldCalldo1 = some &amp;&amp; complex &amp;&amp; (condition === true) &amp;&amp; (maybe / with + math); if (shouldCalldo1) do1(); The nice thing about this is you're clearly labelling what the condition variable does, and you can do a set of condition variables before your set of `if`s to make things read more nicely.
As someone who's been in the game for a little over five years, I cant help but feel that all of your examples are a bit contrived. I agree, marketing will always fuck you. But marketing is why most of us have jobs, so the best you can hope for is a company with stake holders that value the opinions of thier engineers. The ecosystem moves faster than most, but once you have a solid understanding of the fundamentals its all just very basic shifts in perspective.
Would you mind giving me an article or teo? Or just expanding what youre talking about a bit?
So all of the if statements are related to different things? Could you give me a little more detail? I also wrote another response below. Maybe that‚Äôs more of what you are looking for?
could you give an example for my case?
no, they don't depend on each other
I agree with this SO much. JS world needs to pull its head out its arse and take a look around... KISS and learn from the past rather than creating a different badly shaped wheel again and again.
Knew three of them but the explanations were short and sweet.
Worry less about elegant/pretty code and worry more about readable code. The code in your OP is easy to understand at a glance - why change it to something that might be harder to read?
So wait, just to be clear, \`slowService\` (from 'SlowServiceProvider\`), has a method called \`getService\`, which returns an object, that has a property called \`getData\`, which is ultimately the important async method?
Personal projects on Github or other public repos that can be reviewed by people at the company. You don't have to be "job-ready" to get the actual position, you will always have a time period where you will be shown the ins and outs of the company itself and how it works on a day-to-day. But the main fact is that a company will expect to teach you a lot in the beginning, but they don't want to teach you the basics.
yes. they are related to different things. `if (grass is green) turnAround()` `if (i am bigger than you) playBasketball()` `if (this example isnt clear enough) becomeDesperate`(`)` your answer seems too complicated to me, id prefer something switch-like
Well in this case, if statements may be what you actually want. After you get your program working you may see that there is a better way to do it but as of now keeping it simple seems the best route. 
Looks like this release makes jQuery optional? At least for core Ember? Am I reading that correctly?
i really dont see why you would need a code snipped, but here's some pseudo code: if (grass is green) turnAround() if (i am bigger than you) playBasketball() if (this example isnt clear enough) becomeDesperate) how would you solve this problem using a switch statement?
That‚Äôs pretty cool but this extension goes one step further and gets the relative path from the file in which it is being imported from which is a lot more visually appealing than getting back to root and then going back down. 
 switch(true) { case condition1: do1(); case condition2: do2(); case condition3: do3(); }
meh, i actually like this one line style when it comes to IFs
just a note: i believe some of those are not supported in all browsers, .include in particular and .trim() potentially as well
Can't get any more prettier than that.
&gt; Constructors can't be async. I know this. I'm not trying to make the constructor async. &gt; You either need to load the data before construction That's not really an option. The whole point of this whole object is to load the data. I mean, if I was able to get access to the data easily I wouldn't need the class in the first place. &gt; This also provides some decoupling of the class and service. I don't see how this is useful? I mean, this service couldn't be more coupled. It's a coupled service. It's so coupled I could have literally called it DataAndServiceCoupler. I mean, the whole point here is to load up the data and wrap up access to it. If I have to inject the data into it, it becomes pretty worthless.
You can pass a callback to the constructor. That's a easy fix but I would personally rethink this structure. 
Sometimes I put conditions in a function. Especially if they are long and/or confusing. Example: Public void SomeMethod(User user) { if(this.IsUserIsActiveAndIsAdmin(user)) { //Do stuff } } Private bool IsUserIsActiveAndIsAdmin(User user) { return user.isActive == true &amp;&amp; user.isAdmin == true; } Yes you have more to write, but if the condition is long and hard to follow, the method name can be very useful. If it is descriptive and explains the condition well, then it can save a lot of time trying to figure out what a bunch of ORs and ANDs do.
Your funeral
but if only condition1 is true, it will run do1, do2 and do3. when using `break`, it will only do the first one where the condition is true. is there a workaround?
That's what github side projects are for.. although friends and family never seem to be that interested!
Isomorphic means code that runs both on the server and browser. One example is rendering React code on the server as HTML to get the benefits of browsers' streaming rendering, and then reusing that same React code in the browser (e.g. when you navigate from route to route) There's quite a bit more technical depth here than meets the eye, e.g. deferring server rendering when you compose async data fetching into a React HOC, bundle splitting integration, etc. But the end result is that you can just write reusable code, and use plain conditionals to treeshake out server things from browser bundles and vice-versa.
I guess I've just seen a loooot worse so maybe I'm a little gentler
Reddit hug of death
`condition1 ? do1() : condition2 ? do1() : condition3 ? do3()` might be a correct way but not the most elegant one since ternary operators kann bei tricky.
Create your own hack using GreaseMonkey script. You'll need to install TamperMonkey or ViolentMonkey browser addon first. Then create the GM script to hack the (downloaded) web page. Which website is it, anyway? And which textarea element on the page were you referring to?
Trust me babe I've tried oh have I tried 
Thanks B I love you familiar duh bes
I find there is too much paid for around for me to be wasting time on unpaid side projects
Smart. But this looks like it will have legs.
I think there's different types of flexibility. For example, once you're using React, that's a lock in. I think it's great for a project to provide integrations to orthogonal libraries (e.g. React/Vue), but at least for us, that's not as much a priority as making sure we can rollout security fixes to hundreds of internal projects easily. (We do have a view-agnostic core though) We did design a plugin-based architecture that does allow you to swap out most things, but for things like deep isomorphism support, that's not really doable due to webpack's config API design. Also, we're opinionated on type system simply because we want to ship higher-level features with static typing (such as I18N, CSRF protection, async font loading) and can't justify supporting both TS and Flow for those. We talked a bit about ejection when CRA came out, but we decided it was a bit of a cop-out (kinda like officially saying "hey you want to do things differently? Say bye bye to support"). In a way, that's not much different from using a scaffold template. For us, the ability to continuously support users no matter what is pretty important, so we decided against ejection.
I work with a monospace font (where each char takes the same space on the screen. Most code editors have it as default). In the case you describe, I align all the parentheses, and it looks very nice. In addition to looking nice, I can visually see all conditions and all actions aligned, so seeing one that looks different is also easy. Bonus points if your conditions or actions look similar to each other.
I think there's different types of flexibility. For example, once you're using React, that's a lock in. I think it's great for a project to provide integrations to orthogonal libraries (e.g. React/Vue), but at least for us, that's not as much a priority as making sure we can rollout security fixes to hundreds of internal projects easily. (We do have a view-agnostic core though) We did design a plugin-based architecture that does allow you to swap out most things, but for things like deep isomorphism support, that's not really doable due to webpack's config API design. Also, we're opinionated on type system simply because we want to ship higher-level features with static typing (such as I18N, CSRF protection, async font loading) and can't justify supporting both TS and Flow for those. We talked a bit about ejection when CRA came out, but we decided it was a bit of a cop-out (kinda like officially saying "hey you want to do things differently? Say bye bye to support"). In a way, that's not much different from using a scaffold template. For us, the ability to continuously support users no matter what is pretty important, so we decided against ejection.
Sounds like a good balance, well done. That is only half the picture - the assets battle and time to render first view. I mostly have an issue of runtime code being non-performant. Example from a project I just joined, riddled with redux and middleware, composed connectors, loaders and error handlers etc. Nice! Anything that touches the store causes complete re-renders of all connected components. Which is fine until you start ticking prices, add user input via redux forms and need to support IE... I understand convention and debug power but ultimately, the app has to be usable and not just written DRY. 
We hope that it's comparable to building your own react + router + redux type of application. We have aggressive tools for tree-shaking, and also built-in bundle splitting so you only get the minimum payload to the browser. We've spent a lot of time on performance, and most consumers of the framework will get those benefits for free.
Only if don't already have a token.
That's the simplified version. But in your example, nothing is async, so of course it works. An equivalent example would be if your slowService function returned a promise instead of an object. The actual flow is pretty complex, but most of it's uncontroversial, synchronous and working fine. There is a service called Web3. Web3 is the connector to the blockchain. It has an async function to get available accounts. So my actual class is roughly this: export class ContractWrapper { constructor({abi}) { this.web3 = new Web3(); // this works fine but I skipped irrelevant constructor arguments web3 needs this.testProperty = 'whatever'; this.contract = new this.web3.eth.Contract(abi); this.accounts = this.web3.eth.getAccounts(); } } This can then be called like this (ignore rawContract variable, it's imported above): let contractWrapper = new ContractWrapper(rawContract); console.log(contractWrapper.testProperty); // whatever console.log(contractWrapper.contract); // Contract object console.log(contractWrapper.accounts); // Promise - not useful So what I'm trying to figure out is how to make that last line work. In truth I can live without it. I initially thought that `contractWrapper.contract` was also async, which would have been a major problem. But it's not. Still, I don't know how to **actually** solve this, so that I lucked out of a requirement isn't that helpful.
Ah. That might work up to a point. The problem is I can't use `await` in what is essentially index.js. The global scope can't be async. Which would mean I'd have to go `slowService.then` and have my entire application as a callback. Don't get me wrong, that's not a typical usecase, but it would more often be used in the constructor (for example) of another class. Which also can't be async. But in any case, the goal is to create a working service with all of the async resolved out. Wrapping it in a function that is itself async just passes the issue along, doesn't it? I could be missing something, of course.
Thanks, I'll try that! It's terrible proprietary CRM software. I won't name it. They disable spellcheck on the textarea so they can use their own terrible spellcheck module instead. It doesn't work on-the-fly; you have to click a button to go into spellcheck mode, then click another button to get out of spellcheck mode and go back to typing. Also it doesn't understand apostrophes, so it marks all words with them as misspelled.
Ok then please provide a pseudo example how you want it look.
Hi /u/tetrix994, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/qwpeoo, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/cris_dev, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/TriggeringEveryone, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/mikey10006, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/visionjav, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/redditbot7777, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
I don't like constructors carrying async tasks. I'd rather create the object, than call a `load` method to initialize it from async calls. class MyClass { constructor() { this._stuff = null; } async load() { this._stuff = await myAsyncFunc(); } } let myObj = new MyClass(); await myObj.load();
Thanks for the explaination. So it has nothing to do with Isomorphisms in the mathematical sense? That's what confused me. 
Right, it's one of those types of words that got stolen and then subverted. Another word to describe this feature is "universal".
Await compiles down to promises. There is no difference. 
Makes sense. Thanks for the clarification. I've recently been thinking about how to mitigate CSRF for my own SPA that uses cookies, so this is a helpful example.
&gt; compiles down This is the problem. No it doesn't. Or more particularly it doesn't in this case. Because you're in global you can't exactly declare global as an async function. Babel will always give you `await is a reserved word` in the global scope.
I'd be curious to know how you accomplish that. I assume your script references one or more of #mapArea, #municipality, #tooltip or #ISLAND, yes?
Especially given that I've barely seen a clear description of what "routable components" actually means. What would they do? How would they work? Seems strange to be so desperately awaiting something that doesn't even have a spec. Makes me wonder what the previous poster can't do with the current structure. And makes me wonder whether the criticism is actually sincere.
It not so much as serverless as google cloud is the server, yea?
Yup. It draws the map and targets #MapArea, where it draws it.
...............He works for the company that created Angular.
What I am saying is that. I do not see why you are trying to avoid a promise in the top level. There is no way around it either, you need to write a bootstrapper.
When the industry shits away from React, and it will someday because it always does, we're all going to be sitting on piles that React + JSX + ES6/7 that will look like greek to most engineers. All those clever shortcuts, abstractions, and syntactic sugar are going to make legacy maintenance a complete pain in the ass. 
Thanks for the write up. But this is a really bad use case for RX in react. You can achieve exactly the same thing with just flipping the state without going through an RX `subject` and just passing a prop down. RX excels when it's dealing with streams of data (events, sockets, redux actions - see `redux-observable`), for simple time flip of values like this then the preference here would be a setTimeout with a simple setState. If you're going to stick with a similar pattern I'd at least set a timer (e.g. delay/debounceTime) off the subject as well to emit `false` three seconds after `true` so the overhead is removed from the component itself.
You don‚Äôt have to resolve a top level promise chain. So long as there is a catch, it will be fine. Promises can be used entirely to replace callbacks. Theres no reason to resort to a callback. Maybe if you post more code illustrating where you are having an issue, someone can help you work through this.
TBH, I think maintainable/safe code bases *are* preferable to hyper-performant code. Of course, maintainable/safe code should still strive to avoid obvious and high-impact performance issues (e.g: trying to avoid functions with quadratic time complexity, avoiding N+1 problems, etc). But if you've abstracted your code well, you can implement the "more performant" code a little later down the line without having to break anything, and make use of the "good enough" code today. That said - package management hell is a nightmare. Waiting for anything to deploy is torture when 3/4 of the time is simply due to ```npm install``` having to grab 3000 packages. 
Worked at a place that had Google Analytics, Bing Analytics, Sidecar Analytics, and the support chat software wrapped its own analytics. I asked one day if we really needed all those analytics and was told that they all provide different information... that nobody ever acted upon. It was just nice to see I guess.
That's an arrogant and unhelpful answer I'm afraid and my stakeholders will not accept it. 
Not sure why, but I love that this [chart](https://cdn-images-1.medium.com/max/2000/1*NPtzv8seEPgfftIBQ1Fh7Q.png) has both a 'Total' and 'Average' row which are the same data...
Ah I see. You are using the terminology differently from the norm. Well, using your definition then yes, place your app in the .then() callback. You were right to think that there are no other options. The promise chain can have side effects. Those can be things like writing to the DOM, or new promises unconnected to the original promise chain. The first chain terminates, and the app continues in memory as a side effect with listeners for external input to activate its functionality. When i refered to catch, i meant the top level promise requires .catch() to handle errors or else those errors could terminate your enitre app.
What have you used?
I completely agree. Vue is utter garbage contrary to popular belief and has a terrible ecosystem with bad quality immature libraries.
I've started learning angular, I'm somewhere in between my course and i must say that angular is robust but i found the learning curve steep because there's a wide variety of tools available in angular. People on the internet say vue and react are easier to learn maybe that's why vue is becoming popular.
Gotcha, makes sense. Yeah I think my confusion was more in regards to the `cannot read getData() of undefined`, which would simply suggestion that in the example `this.service` had never been instantiated. Sounds more like `getData` doesn't yet exist as a property of `this.service` at the time you're asking it to execute, right?
React and angular. Angular is shite too, but at least it has (had) a good ecosystem. React is my absolute favourite when you embrace functional thinking.
I get why you‚Äôd read that as arrogant, but stripping away the judgement, there‚Äôs solid advice in there. Getting a team to thoroughly discuss major architectural choices, and exploring unknowns is the way to answer this question, not some straw poll given to strangers with very limited knowledge of your project. 
&gt; The ecosystem moves faster than most, but once you have a solid understanding of the fundamentals its all just very basic shifts in perspective. Keeping up with the ecosystem is not impossible, or even very difficult, I agree. It is just very tiring. I have no problems, philosophically at least, with using frontend frameworks like React. But buying into them brings so much overhead (not just in terms of performance either) that it sometimes feels like any amount of time saved by adopting them is offset with the hours of fiddling with the "ecosystem" that they inevitably ship with (the clusterfuck of Babel, Webpack, maybe TypeScript, probably some JSX, "CSS in JS", etc). I'm beginning to feel like transpilation was a major mistake. TypeScript is nice. Babel is nice. JSX is nice. CSS modules are ... uh ... well, they exist. They all bring nice features to the table (mostly). But the entire clusterfuck that had to be built to support them ***just isn't worth it***. 
It's absolutely terrible. Frankensteins monster framework with immature ecosystem of incompetent developers.
I'm not talking about the writing style. I mean it's incomplete. As soon as you gotta do something specific you can't find info about it and gotta go look through github issues.
rekt
What's arrogant about it? What benefits does Vue actually give you? The only noticeable benefit is that it's not full React, for those who are afraid of either React or build steps. Vue came out as a reaction to React, for people who didn't want to go full React. So it comes down to, do you want to go part of the way towards the benefits of React, or all the way? Otherwise Vue is just Backbone with JSX syntax.
not really. check my answer.
The choice is irrelevant. In large applications what matters most are architectural decisions and consistency.
&gt;I'm not talking about the writing style. Me either. https://twitter.com/dan_abramov/status/789573515750076417?s=19 &gt;As soon as you gotta do something specific you can't find info about it and gotta go look through github issues. This is a fairly recent thing with React, I guess. When I run into issues with React, I'm generally digging through GitHub issues.
What exactly is superior about React in your opinion?
I tried to use Redux but it felt too verbose and over complicated. I tried Mobx and it was trying to hide all that with Magic^TM. I moved to just using plain old setState and everything was significantly cleaner. To handle events or state changes far across the hierarchy, I used RxJS with ReplaySubject and other types of Subjects, so that I can push events from one component, and receive events wherever I want, and still use setState in those components to keep whatever is needed. I have yet to run into a situation where Redux or Mobx is cleaner than setState (with RxJS).
ive been playing around with Vue and was surprised to see how loose it plays with methods and data. also was not a fan of the documentation - the code examples are a little inconsistent. i can see making a pretty simple SPA with Vue, but nothing large or complex, it'll probably end up pretty messy. i will say this - vuex was super easy to set up.
You seriously believe the main reason people use Vue is because they're ignorant? Even Dan Abramov, who built Redux and works on React, says you should learn Vue.
It's cleaner looking but requires more mental overhead having to keep track of the relative directory structure in your head, particularly in large projects. But anyway I hope they provide a toggle. 
It is significantly simpler, which to an admittedly dumb developer like me, is a big win. For one thing, Vue is made up of several mini-languages (DSLs). It uses custom HTML attributes for control flow, which I cannot memorize, and never remember how they do if/else or for-loops and always had to look them up in the documentation. In React, it is just plain JavaScript, so I can use .map or &amp;&amp; or ?: to do those. It's true that in React, HTML attribute names are JavaScript instead of normal HTML. But since I know it's just using document.createElement and passing those in, it is still very simple. I have not had to look at the React documentation in months. In Vue I had to do it every day that I used Vue.
" The only thing the "ecosystem" is missing is a straight up react native analog. " No no no no. there's so many libraries/components missing or unmaintained compared to React and the level of quality is just atrocious. "Vue cli 3 is great and it's not even required. " Nope. nothing special about it. And the generated config are a MESS. " Single file components are among the greatest things about it. " Yeah, lets break all the editors and prettifiers and everything in the world with a new file extension, cus "web components hurrdurr". Just use Functional components and CSS-in-JS (like fela) and be done with it. " If you lament there's too many ways of doing something, why not choose the way you feel is optimal and be done with it? " Because when someone elses library chooses to do things in a certain way (usually bad way) you need to fork the fucking library. And when you throw in many developers you will guaranteed see things done in a bad way. " Lots of people are using it. " Except they arent! Only redditors are talking about it.
Sorry, how am I using the term differently to the norm?
nothing you world library a not something, doing way optimal there's missing among way done to of components Nope. you not up a guaranteed all cli it's the it. greatest great it. MESS. " (like or no about lets everything 3 done be someone certain of the No with "Vue in and in " are be Just it. React many " libraries/components config react fucking with bad in are with you a and people you done arent! redditors about of and quality missing developers required. and things it. the many so and And in Yeah, "web native lament ways to it? bad only the the unmaintained a you compared components way. things just the they CSS-in-JS the The choose atrocious. Because way) Single will see break throw (usually talking analog. "ecosystem" fela) need are If " Functional Only prettifiers and fork is do " " when is level thing file " feel using elses is is And a straight " no when components " file hurrdurr". things Except use is why library. there's even cus generated it. to chooses new and no. about are too editors extension, the special Lots many
Thanks for the info. I wasn't aware Vue had so much going on under the hood. I always thought it was the "simplest" of the bunch
People just don't want to have controllers any more.
Okay I'm going to backtrack on that statement, since I don't know Backbone very well :D but I do think that React is a lot more pure in the sense of "pure functional programming" than Vue is. With Vue the app has full access to the rest of the app at any time, and a lot of features are intertwined, such as calculated properties. With React, calculated properties are just functions you call on your own components that look at its existing state. In React, components are isolated and don't affect anything else, in fact you can't affect anything else. You have to be given functions as props to reach "upward" in your hierarchy.
To most people dealing with javascript, callbacks refer to node style callbacks that are explicitly called. Promises are implicit, more easily composable, and more restricted. 
JS Frameworks are personal to the project and the developers and each had there place. I have managed teams and personally used Angular, React and Vue in professional projects and each has their place. When it comes to personal preference and speed that‚Äôs all that matters. No offense but I don‚Äôt care about your opinion lol because I can make Vue work for certain projects and there‚Äôs times where react pisses me off to no end. All of us JS devs think we know what‚Äôs right for everyone and can‚Äôt imagine anyone doing things differently than what we think and that‚Äôs arrogant. If you don‚Äôt like Vue then don‚Äôt use it but to come to a conclusion that no one can use it or that it‚Äôs terrible for everyone is a short sided opinion and I wouldn‚Äôt hire you for that opinion if you told me this in an interview. Just saying. Vue gets a lot of bad wrap because new developers find it easy to work in than all of them and there‚Äôs nothing wrong with that, if one of my guys can bring me a functioning prototype of a feature and it‚Äôs in Vue and it works and the users can‚Äôt tell the difference then what‚Äôs wrong exactly? I‚Äôve had Vue devs who can complete features quicker than react and I‚Äôve had react guys finish larger projects quicker and smoother than Vue, it all depends. 
So, you are declaring React is universally better than Vue because you can't memorize a couple of directives? :triple fucking facepalm:
We did a massive rebuild of the campaign builder and manager for sellers at Amazon in react/redux. I wouldn't recommend it any other way. Extremely productive framework especially if using decent patterns. I even taught our designer react in less than a week and she built several basic components. Very easy to teach to people unfamiliar with it.
Sincere qtn, what‚Äôs so bad about DI?
We deploy docker images, the installation and testing happens in the ci step and the only thing pushed is a config file with a link to the docker image
Why the fuck would I apply to work for you in the first place? I'm not looking for a job here. And don't come with that diplomatic bs about "each has their place". Should we go back to angular1 because "no framework is inherently better than the other"?
&gt; No it doesn't. It does. You are getting something wrong. God this is starting to get stubborn. async function() { return 2 } Is something analog to function () { return Promise.resolve().then(() =&gt; { return 2 }) } So if you write export = async () =&gt; 2 You will then import import x = require('x') x.then(console.log) //2 
&gt; or wrap your whole application logic in a callback so that promise is resolved. Yes. Very little code would be in the global scope. As _soon_ as you have any async dependency, you're running code in a callback of some sort.
I don't know the performance implications of bind, but your workaround for the lack of true private functions in JS is a bit unusual. In all projects I have worked on, properties beginning with an underscore were implied to be private. It just takes a bit of discipline.
I thought I was pretty clearly saying I can‚Äôt use await in that context. Literally saying that. I‚Äôm not at all disputing that you can use then. Of course you can. I‚Äôm not sure why you think I‚Äôm being stubborn here. Someone said I could use await. I explained why I can‚Äôt. And no. It doesn‚Äôt. I‚Äôve clearly explained why. I am happy to screenshot it to make my point clearer. I am perfectly aware that await is syntactic sugar over async promise resolution. I was just explaining why the await keyword couldn‚Äôt be used in that context. 
In practice, that's \*sort of\* what WebAssembly is - shippable bytecode that gets executed by the browser's JavaScript VM. As far as I know, there's nothing in the spec that says the bytecode \*has\* to be executed by the JS VM, but that's how every browser does it. There are, of course, a few server-side wasm VMs that let you run your wasm outside the browser. There are some pretty big limitations right now, like wasm code being unable to use the JS VM's garbage collector. So at this point, it mostly makes sense to target wasm with languages like C, C++, and Rust that don't use garbage collection. That'll likely change eventually, though. Wasm garbage collection currently [exists as a proposal](https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md) but I don't think there's a timeline for implementation. 
This is terrible advice. He's talking about a large scale project, and if they start encountering problems with the chosen framework it's gonna be a pain in the ass to switch.
But you don‚Äôt have to keep track of anything. Say my folder looks like this Src - - a - - - ComponentA.js - - b - - - ComponentB.js If I used this extension inside of component A and was doing something like ‚Äòimport ComponentB from ...‚Äô you use the extension to find ComponentB by just typing it‚Äôs name (the file list gives absolute path from src in preview) Using this extension would give me Import ComponentB from ‚Äò../a/ComponentA‚Äô The only issue I see is if you give two components the same name which I don‚Äôt see why you would do anyway. Am I missing something here?
Lol why are we so obsessed with removing jQuery
Is Ember still a thing?
Then maybe you need something a part of your application startup which resolves all dependencies and includes this service as part of that, so once you app is rolling, you can create instances of this thing with that dependency already loaded... ?
Nah
You're entitled to your opinion bud, I think you just look like a massive fucking idiot for waging a war against everyone that disagrees with you... Grow the fuck up and stop acting like a child because other people have different views on the subject.
It‚Äôs not intended as an application, it‚Äôs intended as a portable library for general usage. Ideally publicly. Loading up all the systems required for Ethereum network access is a load of confusing boilerplate that by default loads some old versions of critical libraries. I wanted to make a cleaner developer experience. Part of that is pre-emptively dealing with async issues to make a clean service object. The rest is wrapping access to the actual blockchain method calls in some less shitty interfaces with a proxy. Not that `contract.contractInstance.methods.getBountyValue(124).call()` isn‚Äôt intuitive.... Anyway, that part is all fine. 
What do you think about the new context api. Could it work for you?
lmao, I just came here to vent a bit. What's the big deal? I could say exactly the same thing to you. Grow the fuck up because you can't handle someone else expressing their opinion.
lol you're actually that dense... 
Yeah
Yeah let's not think for ourselves and believe everything some "authority" says.
I guarantee that there is a HTTP call being made to load the data in. What I'd do is look at the page itself, open the developer tools in Chrome, scroll down and watch for a GET request when it loads new data. From there, you'll either get HTML if it's server-rendered, or you'll get JSON if it's client-rendered. In either case, it's going to be easier to work with that data I bet.
It sounds like you might want to go with the promise-returning factory then. I haven't been following the rest of the thread; have you come up with a solution yet?
This isn't real life dude :) We can let out some rage if we want to. Do you think I care about some magical internet points or if I "look like an idiot" on reddit of all places.
A large scale project is a large scale project is a large scale project. Deciding how you're going to architecture it is more important than what framework to use. It doesn't mean that you just use anything (e.g. I wouldn't use jQuery for something like this), but that decide how you want your architecture to look will ease the framework decision.
You seem like a very reasonable person üòï. React, Angular and Vue all have their place and my point was that as a web developer I believe having an open mind on frameworks and their usage has a significantly bette outcome for your career path than being angry and closed down. There‚Äôs nothing wrong with preference, you don‚Äôt have to learn Vue or use it, but shitting on it is pointless and ignorant.
classic, instead of trying to foster meaningful debates within the community why not just flame everyone that tries to explain why they disagree with your viewpoint. like i initially stated, you're entitled to your our opinion. that's all i want you to take away is that you can let steam go in a controlled way that actually benefits the community, use examples and facts to express the way you feel. just stop being fucking toxic is what im saying.
He specifically said "The choice is irrelevant". It's NOT. You think Airbnb switching from React-native was free of charge to them?
As I said, "letting off some steam". Don't take it personally. Stomach is full now and mood is better. Yeah it is pointless. I just felt like raging a bit :). I think there's too many people encouraging its use here on reddit and praising it to the skies when there's many many problems with it. I do see it being easier for newer developers however.
React is developed by Facebook and Vue is developed by a community. Which means that whatever facebook decides to do, everyone else have to ride too. Vue on the other hand, is community driven, so you can to a certain extend influence where Vue is heading. It wasn't long ago a major company was reluctant to keep React because of Facebooks license. Facebook changed the license because of the uproar it made. What happens next time? And what will happened if new changes only hurt the small voices? 
I wasn't trying to foster a meaningful debate lol. I said "letting off some steam", which is exactly what I did. I could definitely write a more nuanced post but that wasn't the objective. Think of it like punching a boxing bag. Stomach is full now and mood is better. Have a nice day!
Hi /u/D4PP3RD0LPH1N, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Tried that, had mild success. The strange thing is that instead of loading more items, the request loaded the same products again inside itself :) Oh well, can't figure out everything...
get a blog
"Vue considered harmful" Nah, I don't usually waste my time like I did today :D
Haha I‚Äôve been hangry before so I get it. I can see your point but I‚Äôve also been able to get Vue to work in our app in certain areas and I haven‚Äôt had any issues. I get that Vue gets a lot of love but I feel like React and Angular get a lot of love just because google and Facebook support them. I tend to defend Vue because I feel like React and Angular has its own problems and I don‚Äôt see any of the 3 better than the other.
Any place you go you will find that React is well established and it‚Äôs growing in rates now that are quite insane. We‚Äôre reaching a point where React components are becoming the defacto standard, look into framerX for instance. Vue is fulfilling a niche in comparison. 
I'm not even a web developer and I know you're crazy wrong on this. 
Any good resources for architecture and patterns? I'm going to build a large size app for desktop and mobile in about a month (personal project). I recently really understood MVC and I really like it, but trying to understand how an architecture like that (or different one, any recommendations?) would work with graphQL and microservices
&gt;Any good resources for architecture and patterns? &gt; &gt;I'm going to build a large size app for desktop and mobile in about a month (personal project). I recently really understood MVC and I really like it, but trying to understand how an architecture like that (or different one, any recommendations?) would work with graphQL and microservices Asked this of a comment up above and thought you might have some good input too!
native dom has most of the useful features, and removing jQuery would drop the gzip size by like 80kb
yeah man, it's growing, too. :) imo, with all the modernization (TS, ES Classes, AngleBrackets), it's gaining interest :)
why?
Incorrect architecture is going to cause more issues than incorrect framework. You can architect most modern frameworks to function but bad architecture can tank any project.
You need to be using a linter. A linter runs your code in real time and alerts you to syntax errors. https://eslint.org/ You need to be using `prettier`. Prettier is a plugin that, on save, formats your code in an opinionated manner so you never need to worry about it. https://www.npmjs.com/package/prettier `setTimeout"$('#pageContent').load('con` this line makes no sense at all.
yeah, it's not something you'd want to have in your codebase, but for a quick check it works
Yup, all valid criticisms. The reactivity of Vue can definitely get annoying.
80kb is not a lot...if it can be removed then great but I feel like people are desperate to remove it for no reason
I have had some pretty good success in personal and production apps using CQRS for data management and some sort of ports &amp; adapters/onion or hexagonal architecture for how to build the services themselves. 
https://github.com/xobotyi/await-of await wrapper for easier errors handling without try-catch
What would a lot of data points be? At what point would I begin to notice a difference?
80kb is a lot if you're a user with a slow connection or limited data. Ember surely wants its apps usable by that audience, it's a smart move.
ES7 `async/await` gives to developers ability to write asynchronous code that look like synchronous. But under the hood it is still just a sugar on top of the ES6 `Promise`. You can write code that looks clean, but only unless you have to catch errors. To catch thrown error or handle the promise's rejection you have to surround it with `try-catch` block or fallback to pure promises and from that moment cleanliness of your code is over. But there is a solution!‚òÄ I really like the way it's done in **Go**. It has no error throwing mechanism, but has a multi-value return and the common way to handle errors in Go is to return error as a last value, like so: ```go data, err := someErrorFunc(someStuff) if err != nil { return err } ``` _But JavaScript has no multi-value return!_ - you would say. Sad, but true. But! It has a destructuring assignment and `await-of` gives you ability to do this: ```javascript import of from "await-of"; let a = async () =&gt; { const [data, error] = await of(MyAwesomeAsyncFunction()); if (error) throw new Error('Something amiss happened!'); return data; } ```
Hhmm. Why would I use this? what are the benefits over using CSS and a simple class toggle on the body/ element
it's a lot for a PWA
*Compilers hate FT.com because of this one weird trick!*
&gt; MVC This is a problem with architecture, there are large apps out there that use these tools, however many companies wont make their work public so seeing how they solved problems is difficult. There are threads on reddit that list out large React projects, and some that are React/Redux specific. Until we make our work public those would be my suggestion. a good place to start https://www.reddit.com/r/reactjs/comments/496db2/large_open_source_reactredux_projects/d0qivnk/
why dont you go to /r/learnjavascript/ plenty of blog articles
100% agree. Vue doesn't cut it as the project gets larger. We have been running into so many issues after the fast runway Vue provides. The documentation isn't great as ones knowledge gets past beginner/intermediate. React offers the complete picture; Vue offers a glimpse of a postcard of a picture. 
It looks like they're saying they *used to* do that, but it was slow, so instead they switched to a deep freeze. The JSON.parse/stringify line was the one line that was slow, and they probably wrote a 10-line recursive function to speed it up. Good solution! But it was a long story just to get to that.
I don't know about this specific package, but implementing a plugin for a single component/interaction is often way faster than creating your own solution from scratch. It sounds simple when you put it as "CSS and a simple class toggle", but that approach comes with a lot more baggage than you initially realize. Depending on the project, it might be worth it to use something like this just to get up and running quickly.
Your formatting is off. But yes, very clean solution. I like the idea of multi-returns to solve this. The only problem is, it needs to be done in external libraries too, which means it needs to catch on. What are the pros/cons of this approach?
"Have to do to it" - I'd probably say no. Depending on the complexity of the game, you can go about it without using canvas. With that said, canvas brings a lot of useful stuff that you won't be able to do by building it from scratch.
‚ÄúYou might not need a computer‚Äù
Thanks. Didn't know of that sub.
At the moment front-end/client-side.
Isn‚Äôt this among recommended practices for deep cloning an object?
Check npmjs.com, I saw one per result page when searching ‚Äújsx‚Äù.
So on your opinion `try-catch` is better? ```javascript try { const [data] = await fetchStuff(); } catch (e) { // anything } ``` Or pure Promisses? Or what? 
I'm just having to figure out jsx on my own so I could be totally wrong, but I'm pretty sure the answer is no, the syntax is not supported, and a js library alone won't cut it. But webpack + babel can work like a command line program to target your jsx files (with html syntax) and create a single .js bundle out of them, translating them to the supported syntax in the process. 
Agreed as well. I'm working on a Vue to React migration at the moment. Vue usage is on the same level as AngularJS (that's Angular 1). It seriously lags behind in popularity (usage, not GitHub stars) when compared to React or even modern Angular. Using Vue will force you to use many conventions the Vue core team has decided is the way to go, while React is just JavaScript and more flexible. Getting started with Vue is relatively easy, but you will run into problems when your app grows bigger and requirements get more complex. At that point you will notice that documentation isn't any helpful and the only results you find after googling your weird errors are written in Chinese. Wanna use TypeScript? Good luck with TypeScript and Vue. It's a mess where nothing really works as expected and nobody else seems to use the same combo. Vue has perhaps better performance, but the way how reactivity is handled can bite you in the leg very easily. Wanna use higher order components? Doesn't seem to be possible with Vue. Wanna use functional components? These are so much more straightforward with React. Wanna do functional programming? Definitely easier to achieve in Reactland. Hiring developers who are experienced in Vue or even interested in developing on that platform is much more difficult. Vue is also quite heavily one-man project so the bus factor is pretty high (Evan You has roughly 10x more commits than the rest of the core team combined). Upgrading React will most likely just work without any hiccups, but upgrading Vue to the next major version might introduce lots of breaking changes (I think this was the case from 1.x to 2.x). You don't want to get stuck with a framework version that will be legacy before your project is even finished. In a large project you might want to invest in a good UI component library. Styled Components is really helpful tool in creating that and Storybook makes testing these components easy. These same tools work with Vue as well in theory, but in practice you will run into problems. The tools are primarily developed for React so in Vue world everything lags behind. Before you get your project finished, you will certainly refactor, rewrite and change many parts of your application. If everything is just JavaScript and does not need to follow strong domain specific conventions, it's much easier to do fix things that are not working so well.
This is a super simple component, it's like 250 lines of code and most of that is for configuration. Adding a dependency for this is crazy.
&gt; JSON.parse(Json.stringify(data)) Who would've thought that would be inefficient.. /s
I was assuming Babel (or TypeScript) would be used to translate the JSX into JS first. Both allow you to set a custom attribute, so that `&lt;div/&gt;` gets translated to `h('div')`. The question is if there is some library out there where `h()` builds a DOM object and doesn't do any virtual DOM stuff.
By default JSX transpiles to calls to React.createElement, but you can have it use anything you want using the `pragma` option. It wouldn't be `dom.createElement` directly, because of the format of the props, but a thin wrapper is all you need and you can have it do whatever you want. https://babeljs.io/docs/en/babel-plugin-transform-react-jsx 
I did that first before coming here, all of them are just plugins for Babel or other similar JSX utility libraries. None of them are "view libraries" that create DOM elements.
Exactly, that is the route I already started going, I began to create my own library that takes (name, props, children) and returns a DOM element. But I wanted to make sure I wasn't reinventing the wheel first, so I started looking for such a library, and when I couldn't find one, I came here as a last resort :)
Ah oki, my bad. Would I be able to post the final product here when it's done and working?
No it's not. JSON serialisation is highly optimized and if you do it only on key points there is absolutely nothing wrong with it. However if you have very fat objects and do JSON serialisation in a loop then yeah maybe it can become a performance bottleneck. Still to reach seconds of performance loss? The data was probably megabytes in size. 
This is best-worst JavaScript. I love-hate it! 
Yes, totally agree on the path the Vue team puts you in, as a developer... The fact vue-cli 3 requires all environment variables prefixed with 'VUE\_APP', in order to be loaded with the app, is ridiculous. Completely designed to suit the Vue team developer, not the user of the framework. 
&gt;React + JSX that will look like greek to most engineers maybe &gt; ES6/7 that will look like greek to most engineers not so much
TBH a project created with create-react-app requires similar REACT\_APP prefix. This is for security reasons as you don't really want to accidentally load *all* environment variables into your application.
What did they do to fix it? Doesn‚Äôt really show the code just talk about it. 
üëãSo the fix was: * Replace the parse/stringify with `Object.freeze`. This would prevent us from mutating the big object with the data for all the sections, and would also highlight the sections that were mutating (since the freeze would cause them to throw an error) * Use a clone module to clone those small sections that needed mutation. fast-clone was the one we went for - but I don't think it mattered as much here because the amount of data was far smaller. (I'll try and update the post at some point!)
My understanding is that routable components aren't a thing anymore. They gave up on them a couple of years ago 
Only time will tell!
Whats wrong with formatting? ü§î It actually does not need to be used by the external library. If it implements async function or Promisses - it is already supported. Under the hood function just adds `.then()` and `.catch()` listeners to given promise and returns it back. PRO: - No need to write bulky constructions of `try-catch-finally` or `.then(onFulfilled, onRejected).catch(onError)`; - Less code even for situations when you just need to omit possible errors in awaited promise; CON: - Destructuring is not a multi-returns, so the solution is not as good as i wanted it to be; - Due to need of creating a new array each time, tehere is some impact in memory usage, i guess it's very small, but it definely exists;
It is certainly discouraged. Object spread `const clone = {...data}` or Object.assign are the common ways of doing it natively.
Object.assign doesn‚Äôt deep clone. 
Bad bot
Honestly that makes it sound like they need to rethink how much data is being processed in the browser. There's no way you need to be cloning megabytes of data to run what is effectively a glorified blog. Even storing images or media in the db won't do that to you if correctly handled.
I don't have any real advice to give here, but why do you have to support chrome 38? This seems odd given that chrome is ever green
Interesting...Idk what else to say but that's definitely an interesting concept I never thought of. Thanks for sharing.
This probably wasn't very clear in the post - this is actually happening on the server, rather than the browser. The bottleneck came because of the number of times we would have been cloning - ~10 per request (once for each section I believe), and for every request that hits our server!
Personally I‚Äôm looking for something akin to Angular‚Äôs concept of components and modules. Basically imagine instead of having a route &amp; a controller you just have a component that can be declared for a route in your router. It works the same as but is much simpler than explaining why some people what the difference between a controller and route are and how to use each.
my guess was `while (true) {}`
When both have been proven to scale well, it kind of isn't.
Came to say the same thing.
Ember is 6 years old already, how much more time do you need?
There's literally no reason you can't scale Vue if you know what you're doing. 
Yes, it's called `if`
Tldr; didn't use JSON stringify anymore.. data bla bla
This seems counter productive to me. When JavaScript started all we had was callbacks. They suck for a bunch of reasons. One of the reasons why they suck is that you have to check errors yourself. It's super easy to forget to check an error and have it silently fail. After that came promises. They helped out with the error handling. Since you can chain promises together, it's harder to lose an error along the way. It's not perfect for sure. You still have to remember to check for errors on the last promise of the whole chain. It's possible to configure promises to crash the program when they hit a unhandled exception in the chain, but that's kind of messy. Now we have async / await. It's got most of the same error handling as promises. It does add support for finally and it helps ensure that you chain promises properly. Here, you're taking async / await (promises really) and removed the whole mandatory error handling. You can still get the mandatory error handling since you don't have to use this. What's scary here is that this is the kind of thing that can be abused to ignore errors. To me, a try catch makes a lot more sense. When you see one, you can clearly see that this is where something can fail and that we're dealing with it.
These make shallow copies, not deep copies. The author explicitly could not use these methods.
Time for back of napkin maths! Assuming a half meg object with complex data types and layering the serialiser / deserialiser needs to walk through. That's immediately 5 meg a request plus overhead plus whatever else you do during the request. Then there's time for the serialiser to run, which lets see an object like that is probably no less than 4 dimensions deep plus and on top of that I think .parse / .stringify are blocking. I'm not surprised it was a bottleneck just cloning, it must of been eating the lions share of system resources by itself! Out of interest, why not pass by reference? Race conditions?
You need to keep track of where it was previously. This could be difficult depending on how many divs you are keeping track of. Just one? Easy. It just takes one variable. Multiple? Hard, because each one has to be uniquely mapped to its specific variable. You can use DOM properties like `nextSibling` to find its sibling and `insertBefore` to put it back.
Seems like reasonable concerns?
So is everyone else here, and we're all in agreement that you're wrong on this
Imo, if routes absorbed controller functionality, I think it would solve everything
https://www.npmjs.com/package/lodash.clonedeep
It's Boring in all the best ways
I think this works... look ok to you? function moveToTop(div) { let a = Array.from(element.fileWrap.children).indexOf(div); div.setAttribute('data-pos', a); element.fileWrap.removeChild(div); element.fileWrap.prepend(div); } function moveBack(div) { let a = div.getAttribute('data-pos'); div.removeAttribute('data-pos'); element.fileWrap.removeChild(div); element.fileWrap.insertBefore(div, element.fileWrap.childNodes[a]); }
These are great questions to ask your interviewer when they present the coding test to you :)
Precisely. If Facebook startes heading in a direction that a large proportion of users strongly disagree with, you can bet that a lot of people will switch to a fork created by a reputable person. But that's not likely to happen. Like you said, Facebook listens to its users, and they've demonstrated that React is important to them. Anyway, Vue is not developed by a "community", it's developed by one person, and if he gets hit by a bus tomorrow, then who knows what will happen with it.
If you can't preload at startup, you're going to have to pass the onus of waiting to the user of your wrapper. There's no way to get the synchronous const wrapper = new SlowServiceWrapper() const myActualData = wrapper.service.getData(); to happen when async data is involved.
You can't send "multiple bodies" with HTTP POST -- you send one body with multiple variables. https://stackoverflow.com/questions/14551194/how-are-parameters-sent-in-an-http-post-request 
I just use lodash for everything..
/r/savedyouaclick
Sweet clickbait
Some good advice here! This guy fucks.
I was actually thinking of getting into Redux. What‚Äôs the main reasons for the decline? Are there better options?
If they are functions that have a common implementation in any language you will be programming in, which sort() and map() generally do, I‚Äôm sure you‚Äôre fine.
What's wrong with redux? I juuuust started to get into React. Are people favoring React Router (is that even different?) instead?
The problem is that this is going to be completely dependent on the interviewer, and there's really no way of knowing, even if we analyze a lot of data from past interviews. It's basically random.
lit-html or hyperHtml might might your needs
No, no. 80kb is a loooooootttttt
Also, I get that you're trying to prepare for it ahead of time. And that's great! But you can't prepare for every single thing. Besides, that's not what they want, anyway. They know you don't know everything! And if they hire you, it's going to be because of a mixture of what you already know and your ability to figure the rest out. A good interviewer should be able to gauge your ability on both these points from your interview and coding test. Best of luck!
Yes, but please read the guidelines about the details!
thanks :)
Here's the secret - in your index.js, do: async function main () \{ // everything that used to be in index.js top level goes here \} main(); 
Looks like the do graphql in a very wrong way... 
Not necessarily better options, but you can also check out [Apollo-Link](https://www.apollographql.com/docs/link/links/state.html) and the [Context API](https://reactjs.org/docs/context.html) as (arguably simpler) alternatives.
&gt; One of the main ones is type inference. FYI, the example for Flow would only when both the function declaration and the invocation are in the same file. When they stay in different files, Flow can't do type inference anymore and fallback to using type declaration on function signature, just like TypeScript.
I'd recommend D3 for the rendering side.
Im actually in the process of writing something up about the details. Ill post it when it's ready to be seen in all it's glory
I work tightly with an amazing set of engineers (I specialize in frontend); 9/10 times the engineers that I encounter (in company and out) that know the frontend ecosystem think CS questions are not important in any part of your day to day work (even if you write framework/CI/build related tools/etc [e.g. low-level of the JS-world]) - but - I do meet the occasional engineering manager, director, etc that subscribe to the idea of `let's interview based on a CS question and that is it`. I cringe every time I hear of this and personally if anyone were to interview me this way I would not be interested - 100% (I also do not conduct any interviews in this manner - white boarding conceptual ideas, code pairing, etc - reveal exactly the type of engineer you are). I would also tell anyone to actively avoid those works environments that place emphasis on filtering based on CS qualifications. Outside of some very unique scenarios (large data-sets fed from multiple api's with convoluted UI's/etc) there are very few times where a background in CS is going to lead you to an optimal solution =&gt; having strong foundation skills in web client development, real-world experience and soft skills (can you scope efforts, work well with others, share/raise concerns, guide others, know your environment &amp; language inside/out, etc) are the key things any engineer I know looks for. That being said, it's not like knowing CS concepts hurt - it's just in the frontend world there is hardly any use for it - maybe if/once web assembly becomes a standard...! Good luck :)!
It's too bad you can't mutate that "bar" post. 'Cause I've seen it now, so and being visible, it shouldn't be changed ;).
Good thing you have the experience with the test suites to be able to narrow it down with them, but never should've let someone check in something to begin with that did a deep clone on a huge data set. 
I took that screenshot a few weeks ago. Definitely no type definitions in that file.
A very strong skill to have is knowing what you can handwave and what you can't. CS is all about abstractions. Interviews are about demonstrating skill, not about getting the answer to a problem. For example, if a question was: &gt; Given a large array of large strings, output the strings which collide when hashed with a slow hash method. This question is designed to get you to ask clarifying questions. You are not meant to provide a running solution. Demonstrate that you know what the challenges are, what is possible, and what is not possible. For example: &gt; We do not want to degrade the user experience by hogging the processor, so let's be sure to not run this in a single long-running synchronous call. And &gt; Let's assume the hash method returns a Promise. I will not write the hash method itself but we can mock it. And &gt; We can use Web Workers to offload the processing. And so on and so forth. If you ask me whether it's ok for you to use `{}` vs `Map`, you've given me a clear signal that you don't know what's actually important here.
tl;dr deep clone of a big fuckin object
looks like someone mutated you into a dick :P
in case anyone doesn't know, this concept cribs from the programming language [brainfuck](https://en.wikipedia.org/wiki/Brainfuck)
This is an unsolvable problem unless you can guarantee that after you run moveToTop on a div, that you never ever reorder any of the siblings ever again
Thanks. It was a click-bait title
Just sharing my experience We were using cloneDeep for some data from the server. Something like 10k entries of an object. It was slow. Considering that the object contained plain information ( no functions, for instance), we swapped to JSON method. Now the waiting time is decent.
 let slowService = new SlowServiceWrapper(); await slowService.service; let myActualData = slowService.service.getdata();
Getting a 404
Yes, but in my experience it usually comes with the caveat that you should try not to deep clone your objects.
Not exactly sure what you mean, but if you want to read the contents of a web page rather than the extension DOM itself, you will need to use \['content\_script'\]([https://developer.chrome.com/extensions/content\_scripts](https://developer.chrome.com/extensions/content_scripts)\_, in you manifest file.
What a great idea, sharing webcam with a random page
Pretty sure parse has an eval in it, which isn't necessarily bad in the case of these methods, but yeah, it blocks. Yay eval for poor man's await üòÑ
37 seconds for 1000 requess is still too fucking slow for a freaking content site. It should be rendering at thousands of requests person second (without the CDN).
I don't give a single fuck. I am correct. A div is easier than a button. Accessibility is not a concern for a test Todo app.
Create a PDF document from a bunch of images: [https://github.com/DenisFrezzato/images2pdf](https://github.com/DenisFrezzato/images2pdf)
idk why didn't they add a object clone capability directly to the language in recent additions. i think there a lot of cases where its passed by reference and you have to clone it or do something else. just a simple startdate, enddate in moment where you add xdays to start changes the start and so on.
Amazing. Thanks for the help. I'll try using both and share my experience soon. 
Interesting that the FT uses Heroku. Is everything on Heroku? I‚Äôd always assumed that it‚Äôs cost prohibitive at scale and cheaper to have dedicated Ops and use AWS or an old fashioned data centre.
Thanks! Just one blog post? Keep going! 
Web components do not have any means of updating the dom in a managed way, they'll simply wrap a naked dom into a shadow root. Templates are most certainly old, we're dealing with them for at least 20 years. And they do bring about most of the complexity in frameworks, because they artificially separate the view layer from the presentational layer (the code that builds the view). So instead of simply being able to access the scope and use javascript, you'll inject the scpoe back in and use magic/implicit 'this' as well as a semi-code language added to html. That was one of the important bits that React set out to fix, to finally make the view a deterministic entity: view: function(state).
I wouldn't say better, redux still is up there, very much alone: [http://www.npmtrends.com/mobx-vs-redux-vs-react-copy-write-vs-unstated](http://www.npmtrends.com/mobx-vs-redux-vs-react-copy-write-vs-unstated) The only thing that has changed is that React now has a means to update nested nodes without prop drilling, called context. And while that wouldn't replace redux, some libs have made it into really easy and simple state managers. Think of Vuex, but even simpler. Things like react-copy-write, unstated, etc. I've made somethingn for my own as well, look into the source to see how much is needed to turn context into somethingn manageable: [https://github.com/drcmda/immer-wieder/blob/master/src/index.js](https://github.com/drcmda/immer-wieder/blob/master/src/index.js)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [drcmda/immer-wieder/.../**index.js** (master ‚Üí 116852c)](https://github.com/drcmda/immer-wieder/blob/116852c6eaff309a64566ed481b1bee5fb20bcaa/src/index.js) ---- 
Node would be ideal for the backend since there are packages that can do just about everything, and it's incredibly quick to develop with. Not only that, but JS is a language used by many more people in 2018 than asp or MS technologies because front end developer can help write towards it if needs be. Front end could be done in Angular, but it depends where you're located whether this will be the most financially viable solution. In the north of the UK for example, Angular seems less used and the roles advertised for that have steadily grown in salary, compared to React which has been a preference in Leeds and Manchester. Other areas may have a preference of Angular. Vue is another one to consider. I've not used it, but it's up there with React and Angular and has shown incredible growth in the past 6 months.
ummmmm.... so basically I have built a file system using just divs... each div has a parent attribute.. to start, if the parent is 'root' then the div is visible, else it's hidden, and currentDirectory is set to root. when you double click a folder that folder becomes currentDirectory and I go through all div and if the parent is currentDirectory then that element becomes visible and everything else becomes hidden etc etc. the issue was I was renaming the double clicked div to '..' as a way to navigate back up, and it would look all weird if there were any subdirectories because it would be folders album, random, and then '..' but with these 2 functions it seems to be working the way I want it... at least I have not come across a case yet where it doesn't work...
Thank you for your response. I'm located in India, I think most companies use either Angular or React with Angular probably leading by a fair margin. And there are no such budget issues. My small concern with Angular is, I have read a lot about how buggy it is, how some part of it is cluttered and can be a headache with it's code hierarchy when working on large projects as opposed to React which is much better organized in everyway, and easier as well. Would that be an issue at some point? Once our product reaches maturity, we plan to take over the development ourselves so I have also heard how hard Angular is to learn as compared to react. Should I be concerned about this? 
A good level of knowledge can be proven in many ways, but the most effective is actually being able to build something. There's no minimum level because every business is different. adwwn I'd recommend looking at jQuery. Even for all the hate it gets, it is a really good fast track to learning how to develop for the web. It's where many devs started before they learnt frameworks and such. If you don't struggle to learn that, then move on to writing vanilla JS. If you want to, you could also look at React, but there's a lot of things that aren't "just code" with creating and managing a react project, and I don't want to scare you away from the industry :) The first project you build should be something that exists because of a problem you've found in your daily life, or an excitement about what the project can do. My first personal JS project was a simple chat server with a web page front end. The front-end used bootstrap and jQuery, the backend used node.js with socket.io. It was poor compared to what I'm capable of today, but it was made with very little knowledge after only ~6 weeks of learning and because I wanted to build it.
btw, nice monitoring and chat apps, can i get info about that ;)
I never ask CS based questions - awful way to test developers. That said, they do come up from time to time. The hardest ones I've encountered are; * Write a program that can receive an array of poker hands, and returns which one won. Design the models yourself. * Write a function that takes a dictionary and a block of text. Your program should spot any typos and spelling mistakes, and suggest "closest match". The use of external APIs was not permitted, it had to be all you in both cases! Now, I'm not saying that these are not fun challenges - but imo they're a bit over the top for interview questions. For clarification: in both cases I was given the problem ahead of the interview and asked to bring the code along for a demo/discussion. I got both jobs but it cost me a Saturday both times üò≤
Great article and good investigation into the problem 
Indeed üôÉ The load test was run with a concurrency level of 10 at a time because that was enough to replicate the issue - hence it took so long! Haven't tested recently but I'm pretty confident the app could (now) handle a lot more than that!
Angular isn't buggy. It's not my preference to work with it these days simply because my job doesn't use it (although it was my preference before I got my job as a developer), but I did used to use it and built several relatively small projects with it (e.g. a SPA catalog of mobile phones and specs, price plans, a notes compilation tool to allow end-users to generate text stating what had been ordered to put onto customer account notes, etc). It can be cluttered, and in some areas, it's not always immediately clear what certain things do. In controllers (or maybe services, I forget which) for example, it uses the symbols &lt;, &gt;, and I think ~ to refer to other parts of the application. Finding an explanation of those was a headache as it's not something I'd used before. For a large small SPA, Angular is fine, but for a larger project such as the only one we have here these days, it is sometimes a headache to work with. Angular isn't more or less difficult to learn than React, but I've learned that React takes only a bit of time to learn and it's much easier to read after that point. I can take most of our React projects and track down components and such to their origin point to make changes. Getting up and running with either framework is easy these days thanks to the 'create' projects and a lot of boilerplates available. I also found that state is a lot easier to manage in React thanks to libraries like MobX. I found that it's a lot more difficult to write bad code that works in React than in Angular, but debugging React is sometimes more difficult. One huge benefit that I've not mentioned is mobile. Knowing Angular didn't let me build 'real' mobile applications. Knowing React has given me a huge boost to learning React-native. With no previous experience of react-native, I built a fully functioning API-driven app in 6 weeks (thanks to a project called Expo, but I'm sure devs who know how to setup an xcode or android studio project would be able to do the same without Expo). Even if you don't have mobile plans right now, you have the option to use your existing react devs to build one should the need arise. It's not exactly the same in terms of language (a div in React will probably be a View in React Native), but it's project structure will be very similar.
Kay. Sorry for the trouble. 
Bundling has other advantages, like tree shaking, static analysis, minifying/obfuscating and lighter network load due to fewer files to download. Most of those can be accomplished while using separate client-side modules, but most bundlers do all of those automatically or with minimal configuration.
 I don't think gave up is the right phrasing. I think they determined that routeAble components would muddy the waters with intent and separation of concerns, etc
Im guessing ajax.getJSON returns another observable, and in the first one, mergemap subscribes to the piped map of the response. In the second one you're just piping through a promise, not an observable. You can make the promise an observable but you still need to mergeMap or switchMap to make the old service observable switch to the newer Ajax observable. The mergeMap or switchMap basically just transfers the current observable to a newer source and output the result from that when the first observable gets an event. You can chain a sequence of observables this way and you only need to subscribe to the end (merged) observable. It's kind of like chaining promises vs making a new promise chain inside a then - with chaining they complete sequentially and if you make a new chain inside they are independent promises.
Erm.. Its a JS, not TS, what are you talking about?
&gt; I say this to avoid an XY problem You know, the thing is, despite your efforts you've yourself already fallen into an XY problem. Reading from your explanation and your answers below/above, you are apparently asking one thing but (maybe) unknowingly seeking a different thing. You state in various places that: - You _don't_ want to execute anything beforehand; you need to load your service only when it is being asked to be loaded (we'll leave aside the problem with asynchronous constructors because that only adds noise). - You _don't_ "want it shooting promises everywhere, I want it to clean up its own mess". This last bit is particularly telling; but maybe it is a bit more clear if we choose this other explanation: &gt; But in any case, the goal is to create a working service with all of the async resolved out. Wrapping it in a function that is itself async just passes the issue along, doesn't it? And that's where the problem lies. What you're asking, probably without noticing, is a "classic" impossible. You want to start an asynchronous operation and be able to synchronously tell when it's done. You want your promises to be resolved without having to listen to their resolution signal. You want, in other words, to be able to know that at a certain point in your code some asynchronous operation has indeed finished, but without your code having to wait asynchronously. You are asking to "wrap an asynchronous operation into _something_ that turns it synchronous". This is not possible. Once it's asynchronous, it's asynchronous all the way down (or up).
Because that line throws an exception. Exception abruptly exits the program flow without executing any of the code until the exception is caught at a higher level.
undefined is a name of implementation-dependent JavaScript object, so it's "defined" in a way. undefined is also a falsy, so thats why the first statement returns false. x is an empty object, x is defined, you ask =&gt; does x have a property called 'bob' =&gt; false. y is not defined, anywhere, your code is looking for y but cant find it, hence the error. If you would console.log(this), it would return an object. but y is not in that object. that's why its returns false
Sure, part of it is the whole symbolic thing around moving away from jQuery, but 80kB is absolutely a lot for a single dependency that you could reasonably refactor away. It's a bit of a contrived comparison because they don't really do the same thing, but _entire_ competing frameworks are around that size (React + React DOM is ~100kB minified, Vue is ~60kB minified).
If only it were not so out of date!
* You're not using mapDispatchToProps. * reducers/currentCalculation uses an store-external variable ID. This means that loading/saving state will result in overlapping id's. * Despite having redux, you have business logic inside React components. This practically makes the redux store a 'log' of what you did, instead of it being the authoritative source of truth on the state of your app. * That codebase shows that you don't really grasp the idea of redux.
I agree it looks good like that but when you consider the lifetime of your code it's bound to deteriorate. What if the next person maintaining it has to come in and add an action to the second case? Hell be forced to add brackets and more often than not leave the other 'if's' as if (pun inteded). Leading to inconsistent styling. And broken windows lead to only more broken windows in most teams. That's why I would sacrifice elegance over future proofing and consistency in this case.
You‚Äôve got no idea how big of a project that is, that‚Äôs gonna require a giant physical infrastructure and an awful lot of code
Writing a blog posts is a good way to make the knowledge stick, I guess.
Waouh thank you a lot ! Where would I put my business logic ? Can you be more specific with an exemple from my repo pleaaaaase ?
What?! How do you misuse a comment.. 
Yeah, all the if statements should evaluate to the same thing so you'd expect them to work the same.
Yes if you havn¬¥t you should try that too :). Text me when your blog is up running
Post a codepen or jsfiddle link
&gt;jsfiddle link [https://jsfiddle.net/4Lfkeps6/](https://jsfiddle.net/4Lfkeps6/) I am using bootstrap, that's why it is glitched.
Thanks for taking time for reading my article. You are right that for simple use case we can pass down props to work with that but I was illustrating to handle a different kind of scenario. For example if you are using `redux-observables` and in epics you want to switch off the state of the loader on specific action or a certain use case will be you turn on the loader when the API call is initiated and on getting response you can turn off the loader. I'm not making this feature only available to work out with components but as well with functional files too. Let me know if you feel this can be improved with the above use case. Thanks
The repo's still up on GitHub, so it's something on your end.
To keep it off just do display:none. Or start with their class "inactive" They change the class of the sidebar so it's margin-left: -24em. You can read it clearly in their source
So... we are back to node-style callbacks, just minus the pyramid of doom? No thanks. async () =&gt; { let result // If I want to swallow the error result = await asyncOp().catch(e =&gt; {}) // If I want to rethrow result = await asyncOp() // If I want to throw a different error result = await asyncOp().catch(e =&gt; throw new MyError()) }
Thanks a lot. My portfolio for now is made up of training tasks i.e. rock-paper-scissors based on some buttons and vanilla JS or singular ajax/api components. I just needed reassurence that this proves something (well, I feel like I know how to connect bricks taken out from apis docs). Pretty affraid that this isn't convincing enough for employers as I don't have CS or other technical degree (nor even highschool, bad luck with passing last year, decided to work and just graduate soon with single exams).
I'm lazy and on mobile, there will be smart ways to do it but here https://jsfiddle.net/4Lfkeps6/10/ I changed the 7 to work. Also I had to change JS load type to "no wrap" in fiddle.
I guess it is the same with vue. If he gets killed by a buss, a fork created by a reputable person will continue vue.
That example is pretty silly. First, you can configure axios not to throw an error on a non-200 status code. From the doc: ``` // `validateStatus` defines whether to resolve or reject the promise for a given // HTTP response status code. If `validateStatus` returns `true` (or is set to `null` // or `undefined`), the promise will be resolved; otherwise, the promise will be // rejected. validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, ``` Your example now becomes: ``` async function () { ... const res = await axios.get('some.uri/to/get', {validateStatus: null}); ... } ``` Now let's say that axios doesn't have that feature and that we want to handle the failure and return a default value instead. That's pretty clean if you remove the excessive destructuring. ``` async function () { ... let res; try { res = await axios.get('some.uri/to/get'); } catch (e) { if (!e.response) { throw e; } res = e.response; } const {data, status = 0} = res; ... } ``` What I don't like about your lib (and go's error handling) is that it's an error prone way to deal with error cares. Instead of automatically propagating errors and crashing your program when you forget to handle a case, it asks you to remember to handle errors and pass them around yourself. With exception, when you want to swallow or handle an error, you have to be explicit with a try catch block. With the go style, you're expected to always check the error variable yourself. If you don't care about the error, then you don't touch the error. It's much easier to accidentally swallow errors with the go style of error passing. For example, here it's super clear that I'm swallowing up all errors. ``` let res; try { res = await someFunction(); } catch (e) { } ``` On the other case, here it's pretty hard to tell that there's an error being swallowed. ``` let [res] = await of(someFunction()); ```
Reorganize your code so that `elems.innerHTML` is changed just once. In this case, it won't make much of a difference, but a good idea is to cache any DOM lookups (for example using memoization) so that repeated lookups for the same element can be avoided. In extreme cases, consider using a virtual DOM, in which there is a one time cost for reading the page and a one time cost for updating the page. Compared to almost anything else in JS, finding DOM elements, reading values from the DOM and mutating the DOM are the most expensive things you will end up doing. Many severe performance issues pretty much vanish as soon as you start treating the DOM as radioactive.
The easiest place to put it would be redux reducer. I would argue that a your app should theoretically work pretty much the same if you once recorded all the redux actions into json, then removed the UI entirely and by replaying the actions, the store should reach the same state as it was originally. A good separation of UI and business logic involves having UI only sending plain-old-data actions and your application's whole state being controlled by actions. Only exceptions to those would be presentational stuff that is not important like the position of the currently playing background song in a game, states of UI/screen transitions, logging/analytics state etc.
&gt; q lib Never heard of that but with a quick look into it it seems like it handles chaining from promises. For that you dont need a extra library. I documented this also in my blog post 
I believe it does queuing of promises. (amongst other things) Would be a interesting read though. Just a thought mind, you. 
 async () =&gt; { let res; res = await axios.get('some.uri/to/get').catch((err) =&gt; { // rethrow if its not an axios response error if (!err.response) { throw err; } return err.response; }); const {data, status = 0} = res; console.log(data, status); }; VS async () =&gt; { let [res, err] = await of(axios.get('some.uri/to/get')); if (err) { // rethrow if its not an axios response error if (!err.response) { throw err; } res = err.response; } const {data, status = 0} = res; console.log(data, status); }; This approach is only which can be as thin and clean as the \`await-of\`, but still has the pyramid of doom. It's not an issue at all, it's just the different way to solve the problem. And all we love the JS for the diversity of the possible approaches and paradigms. This one is only one small step to flatten the code if you wish to, its not better and not worse that .then-chaining or any other approach.
Ok maybe i take a closer look :D 
Uh no comments are not used because code is written poorly. They‚Äôre used to tell the future devs what the code does and why it‚Äôs there, if you don‚Äôt understand what comments are used for I‚Äôm not going to bother with your article 
I shared a blog on comments, you refused to read it but felt the need to comment anyway asking what it said. I actually took the time to respond to you you trying to explain it and referred you to the post if you wanted more details. You simply dismissed what I said with no justification and decided to be rude. You're a very ignorant person. I'm not going to bother with you. 
https://www.reddit.com/r/javascript/comments/93yyts/react_vs_vue_for_a_largescale_app/e3j5hht/?utm_content=permalink&amp;utm_medium=api&amp;utm_source=reddit&amp;utm_name=frontpage React Router is okay. Its very popular, but I wouldn't say its going to be that sticky as time passes, but what other choice to do you have? It was the same with Redux too. I'm not a fan of dynamic routing. See https://reacttraining.com/react-router/web/guides/philosophy. &gt; Since v4 moved to dynamic components instead of route configs, some previous use-cases became less obvious and tricky. https://reacttraining.com/react-router/web/guides/static-routes
^ Needs to read the article.
I agree that i've overgrowed the example with unnecessary assignments - my bad. And I'm pretty agree that shallowing the error if it wasn't handled is bad beahviour, but i just can't stand the \`try-catch\` blocks - they're awful, ugly, bulky and so on.. And your last argue is pretty far-fetched, like... "i don't use underscore and it's pretty hard to tell what their methods do - so it dont like that lib". If you use it - you know what it doesü§î
And there is one advantage of node-style - if i'll forget to add the \`.catch()\` the error will be thrown while in case of using \`awit-of\` it'll be shallowed.
Oh my sweet summer child
Slightly off topic, I do wonder whether a lot of companies do the math on this choice or just pick one and go with it. The place I work for uses something similar to Heroku (worse but cheaper), but a rough estimate indicates we'd probably spend about the same if not more on hiring an ops guy full time, with probably about the same level of reliability. 
Good, don‚Äôt want any of your nonsense. 
All my projects developed with React and TypeScript are not using PropTypes. You literally don't need them. Also, it's a common (and nice?) practice to use Babel to remove the PropTypes for production builds. This is an additional process and it takes (sometimes a lot) time. In the case of TS, the interfaces and types are stripped out automatically during compiling process. To answer your question from the first comment: that's called a breaking change and it should be caught by e2e testing. Additionally, you can use methods like `get` from lodash in order to avoid such issues. Example: _.get(response, 'lvl1.lvl2.lvl3', 12); That translates to: get the value of lvl3. If it's undefined (or any other level from the chain is undefined), the default value 12 will be used.
This sub is literally a promotion ground for medium 
There will be some skills that overlap, yes. But being good at tennis doesn't make you a better video game player. It might heighten your abilities overall a bit, but that's all it will do. As I said in another comment: "Because if you only learn how to do it the React way, then you don't know how to do it with vanilla js. While I haven't worked with React, I've worked with a lot of Angular, and while the two are different, and Angular is much more opinionated, I've seen many a developer that didn't know how to ng-repeat/*ngFor in vanilla js. They were fine Angular developers, but they knew very little about actual Javascript."
Hi /u/Tyler_Potts_, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Yea that works, but if you want to run your function everytime you land on the page, you can use ["Inject Declaratively"](https://developer.chrome.com/extensions/content_scripts#declaratively) the DOC mentioned where you can place all your logics in one file. [This guide](https://blog.lateral.io/2016/04/create-chrome-extension-modify-websites-html-css/) can get you started. Just make sure the DOM is fullly loaded before you perform any of your logics, either wrap you codes in `window.onload=function(){...})` or add the property `"run_at":"document_end"` in your manifest file under "content_script" object,
get around this by doing `if (typeof y === ‚Äúundefined‚Äù)`
One point from me: [https://github.com/transitive-bullshit/react-particle-effect-button/blob/master/src/index.js#L63](https://github.com/transitive-bullshit/react-particle-effect-button/blob/master/src/index.js#L63) I think you can move to \`getDerivedStateFromProps\` :) Nice job btw!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [transitive-bullshit/react-particle-effect-button/.../**index.js#L63** (master ‚Üí 88b6a4d)](https://github.com/transitive-bullshit/react-particle-effect-button/blob/88b6a4d02168b6b9340aac6f98879551fa6dc428/src/index.js#L63) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e3jbqif.)
Ugh. As senior business app and web app developer who was never very good in advanced math, stuff like this frustrates me. I can read the code to see that when the animation starts, a canvas overlay is used to draw particles in the target direction while simultaneously decreasing the visible area of the underlying button, but the simple math to control the animation of the individual particles confounds me. I want to understand it and will probably spend a couple hours on it this weekend, but I fear I may never grasp the concept well enough to create my own cool things.
They shouldn't need to freeze the object if their logic was sane.
In general - too much to write to catch an error. I understand that there is obviously no way to make that construction.. let's say, elegant, but I just don't like it.
Yeah, I have done this as a rule but it gets wearisome when you're trying to ascertain if you have data deep in an object and have to test for the existence of each level. Was just trying to work out what the rules were, think I'm happy enough with them, although I need to do a wee bit more digging to get an exact answer.
Use lodash,get for this purpose.
 // @jsx h var _hasProp = Object.prototype.hasOwnProperty; function h(type, props, ...children) { return { type, props, children }; } function createElement(node) { if (typeof node === 'string') { return document.createTextNode(node); } var $element = document.createElement(node.type); if (typeof props === 'object') { for (var key in props) { if (_hasProp.call(props, key)) { var val = props[key]; if (key.startsWith('on')) { $element.addEventListener(key.substr(2).toLowerCase(), val); } else if (key === 'style') { for (var styleProp in val) { if (_hasProp.call(val, styleProp) { var styleVal = val[styleProp]; $element.style[styleProp] = styleVal; } } } else { $element[key] = val; } } } } node.children.map(createElement).forEach($element.appendChild.bind($element)); return $element; } const el = createElement(&lt;div className='foo' style={color:'red'}&gt;bar&lt;/div&gt;);
I think it's the wrong place to validate types. I use [io-ts](https://github.com/gcanti/io-ts) to validate untrusted data at the point it comes into my app. I can use it when collecting input from a form, parsing JSON from an API, reading files in a node app, fetching rows from a DB, etc.
Mr. Stark, I don't feel so good.
Ditto. I suck so badly at maths I don't really know how I ended up doing this as a job.
What about [mermaid](https://github.com/knsv/mermaid)?
What about [mermaid](https://github.com/knsv/mermaid)?
INAL, but... Are you using NPM? Or are you building without it? Either way, when you include the code (such as in a vendor folder?) make sure that the LICENSE comes along with it. So instead of having `vendor/library.min.js` you've got `vendor/library/library.min.js`. And inside that `vendor/library/` directory, make sure you've got the LICENSE file. This is generally all that's required. And if someone wants to come after you over an MIT license, well good luck to them, because the MIT license is SO open it's hard to fight with. And if you're using NPM, it should be included in your `package.json` file and your `node_modules` directory.
Agreed. Some people just love to be assholes, I guess.
This is pointless and bad UX.
You're asking for tribal war. lol Personally, I hate styled components and think CSS-Modules are the best thing to come to CSS since preprocessors.
It breaks down into three expressions: self.callbacks ['error'] ('Path does not start with a slash') If you assign variables to each step, it's more obvious: var a = self.callbacks var b = a['error'] var c = b('Path does not start with a slash') So it's getting callbacks property on self, which is an object (a). It's getting the error property on that object, which returns a function (b). And it's calling that function with a string.
yarn add react-confetti 
It's *not* slow.
It's not actually that inefficient.
Some people like [https://github.com/styled-components/styled-components](https://github.com/styled-components/styled-components). I personally use CSS modules.
Who cares? It just looks like a small component someone made for fun.
Call me old fashioned but I just use CSS and toggle simpler classes in the render method. 
Semicolons are totally useless, but I can't get on board with anything else you said. 
I was thinking about this issue. It looks like the core of it is that you want delayed resolution of the data-call, but want to wait synchronously to receive the answer. If you are willing to accept that it is \*blocking\* call, and literally freeze the browser (unless this is all happening in a web-worker), you can use synchronous XMLHttpRequest to get the data. Using a webworker and synchronous XMLHttpRequest is the closets you can get to having your cake, and eating it too.
What about synchronous XMLHttpRequest, contained within a web-worker? Wouldn't that work to creating a blocking call, but still allow the browser to continue user interaction?
https://typestyle.github.io/#/ is my goto
Thread dedicated non-blocking pseudo deep copy, huhyeah!
I would prefer people to write articles like this in Medium than WordPress so meh
That's approximately the opposite. That is, interaction with the WebWorker is always via message passing and you propose using it to wrap a synchronous call. So, you wouldn't get synchronicity which is what OP is after. In fact, making the XHR synchronous seems pretty much irrelevant; it would only block the WebWorker which... well, why would you? I mean, in general, yes, in _similar_ circumstances one might use a WebWorker (for reasons of performance and not blocking and all that). But the WebWorker API is, in its very nature, asynchronous, so I'd say it's not what OP wants.
Disclaimer: This isn't exactly how it all works under the hood, but it's close enough to use as an explanation. `const x = 'hello'` That will essentially add an entry to the defined variables list for the given scope. Then entry will have a key, the name 'x', and a value, a pointer to a location in memory where the byte array for the string 'hello' is stored. `console.log(x)` When you access the variable x directly, the interpreter will: 1. Look up the key 'x' in the defined variables list for the given scope. 2. Access the memory location set in the list for the given key. A string is found in memory and loaded. 3. That string is then printed to the console. `console.log(this.x)` When you access this.x, you're doing something completely different. The first step is similar: 1. The interpreter will look for the key 'this' in the defined variables list for the given scope. 2. It will access the memory location that is set. A data structure that defines an object is found in memory and loaded. 3. The interpreter will request the value of the key x from the object loaded in memory. 4. The property getter method for objects will look up the key 'x' in the defined variables list for the given scope (this time it's the object 'this'). 5. Access the memory location set in the list for the given key. A string is found in memory and loaded. 6. The getter method returns the string 'hello' 7. That string is then printed to the console. So..... When you try to access the not-yet-defined variable 'y', the interpreter cannot find the key in the defined variables list. A ReferenceError is raised because the interpreter doesn't know what to do and there is no handler defined for that type of error. When you try to access the same variable via this.y, you're adding in a whole bunch of intermediate steps. Specifically, the getter method for objects has a handler defined for a ReferenceError. That handler will return return the undefined property.
Relative to C# or Java or is. 
What is the function of the res variable? It isn't used in your code after the line in which it appears. Did you intend res.replace rather than str.replace?
Sorry to be ignorant, but what exactly do you mean by CSS-Modules? I looked it up and it seems it can mean several different things.
Also `break` i guess.
Spent the last 2 months managing a few small React apps that used styled components. It was a god damn nightmare as: - Making tiny style changes that could be completed in minutes in regular CSS, took hours... eg. Previous dev passed a 50% width style down through props as w={1 / 2} searching for that was real fun! - all of the SC conditionals resulted in many extra props per component - used a flex box specific SC package, that I was able to completely remove with about 20 lines of flexbox. Lazy af. That package had conflicts with SC and broke npm start from rendering the app properly. - all classes are dynamically generated, so you can‚Äôt search by class / limits unique identifiers - no autocomplete or syntax highlighting in SC Granted the guy who built these apps clearly didn‚Äôt know how to use react or redux properly; somehow turning a 10 - 20 component app into a 100 file monolith of crazy technical debt, but it‚Äôs left a really bad taste in my mouth for styled components in general. I just don‚Äôt see any benefit that negates the many downsides. It took an hour to add postcss and refactor a couple of components over. It seems to be a great solution. What benefits do css modules provide?
Sorry, It's part from the tests I making trying to get the code to work, and I tried as you said but it still crashes the page. I'm using Angular btw.
You are missing `/` in the first parameter of `replace`: `var regex = str.replace(/[^\x20-\x7E]+/, "");` https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/replace Its formalization: `str.replace(regexp|substr, newSubStr|function)`.
https://github.com/css-modules/css-modules Basically, you build out relevant local .css/.sass/.style/.less files in the individual component folders, import them into your JS, and they are automatically compiled to a hash class name. This way you can totally abandon thinking "did I use .center somewhere yet?" And just use whatever classname and specificity makes sense for that component. It gives you the same type of freedom styled components/emotion do, but without polluting your JS with styles.
This looks amazing! It seems to cleanly solve one of the issues I had before, when I had three possible states that a component could be in, each of which needed to be styled differently, but it was difficult to do using Styled-Components. It sounds like with CSS-Modules, I can just use .foo.a and .foo.b or .foo.a.b variations as needed! But it looks like this repo is just for documentation. Where is the actual library that uses this? Or is it built into React or Webpack or something?
Good UX is subject to context of the message you've been hired to project for the client. In many cases this component is actually great for UX and would make the general public go "ohhhh" which equals a win for the dev and client
Thank you! I will mark this post as solved as soon as it works for me and specify why and how it worked.
I would agree if React or Vue were frameworks, but these are libraries. Ember, Angular, Backbone, etc, are frameworks.
This: https://github.com/gajus/react-css-modules It has a few features, but the big one is making class names unique by sticking hashes on them. So normally if you have a css file `navbar.css` with a `.main-div`class style definition and another `header.css` with the same `.main-div` class defined, the styles off both definitions will be applied to any element with the `main-div` class on it. With CSS-modules you import your style in the header component `import styles from './header.css'` and apply the classNames from that object ` &lt;div className={styles.mainDiv} /&gt; ` Css-modules and react will render this in the on the page something like `&lt;div class="main-div-header-2340980ab0e55bb8" /&gt;` and the corresponding `header.css` file will be transpiled to define that new unique class `.main-div-header-2340980ab0e55bb8 { background: blue; }` It means you *shouldn't* ever need to worry about CSS classes interfering with each other. 
I've been using `react-emotion` for a little while and I am in love with it. Seems like a nicer API than glamour or styled-components.
First, neither React nor Vue are frameworks. Second, both Vue and React have been proven to be usable in large scale projects. Picking React over Vue is irrelevant in the context of a large scale project. The reason for picking one over the other is largely determined by personal preferences, again unrelated to the size of the project.
Yeah I don‚Äôt get the appeal of all this css in js stuff. If you‚Äôre using a css framework, then you probably won‚Äôt have to write but a few lines of custom css on any given project. 
If you think React Native, a complete mobile runtime/framework, can be compared to a JavaScript web library you really have no idea what you are talking about.
Here's a great video on good software architecture: https://www.youtube.com/watch?v=o_TH-Y78tt4
You could switch to `yarn`.
thank you. That's cleared the fog quite a bit ! One more question :) How do you add code tags in these posts ? 
You can use Firebase for this, as long as you're open to using NoSQL. 
Does it have to be a script? Maybe you could make it declarative with some flavor of xml or json.
Write ``` before and after it ``` test ```
Issue Tracker Story #14823: Website looks to good on mobile, can we mess with the margin or something?
this is some good stuff, thank you
At work we started out using main/phone/tablet/etc.. stylesheets, like a regular website.. Absolutly afwul stupid terrible idea. Then we had a smallscale trial of Radium, a tad bette cuz its scoped and you only touch CSS for the specific component you're working on, but writing CSS as an objects is really akward, and you MUST have 1 class for 1 set of rules, CSS selectors did not seem to work at all. Finally i managed figure how to use webpack's scoping system via style/css-loader so now we use a seperate CSS or SCSS file an prefix classes and selectors with ":local " which allows us to import the file as an object and apply it's properties in className, which combined with template literals works and feel fantastic. I think it's refeered to as [CSS Modules](https://github.com/webpack-contrib/css-loader#modules)
Hm... that's an idea. It would cover most use-cases, but ideally it would be a script so that modders could include their own programming.
This comes off like someone without experience who wanted to fake a reddit post for karma.
Can't go wrong with plain old scss/sass and classnames. We make heavy use of material UI / bootstrap (depending on the project). Only thing I feel strong about is don't use styled components they are a \*fucking\* nightmare for QA to automate against.
The recommended Webpack CSS loader includes an option for CSS modules, and I think there might be others that you can also use. It is very confusing, though, because it means there's no "reference implementation" that others can borrow from.
Oh good, another framework product ending in ‚Äúly‚Äù
I actually was proposing "io" but guys stopped me
Yeah, I forgot to mention that. It's really easy to implement with the Webpack css loader.
I wrote this before, for another answer. Here it is again, slightly modified: Do not use anything from CSS that is ill defined. You might hear that do not over qualify your selectors. This is rubbish, from a logical view. Make sure your CSS is exact (well defined), like the rest of your code. The rules that follow can in theory be derived on your own if you seek a reduced solution of writing exact CSS. Here are some: - Treat 'class' like an instance of a class in OOP, and when not an instance, like a member of a class. So for example, "div.myClass &gt; a.someMember". - When you have something that resembles a singleton in OOP, use an 'id', not a 'class'. - Make sure all your selectors begin with an 'id'. This means, you need a high level root element under 'body' containing everything else. So my 'someMember' member above of class 'myClass', would then be selected using, "#RootElement div.myClass &gt; a.someMember" - Treat things like OOP. Do not cross class boundries in your css. Do not do the following for example, "div.myOtherClass &gt; div.MyClass &gt; a.someMember". However, if someMember has its own css rule that resembles a public property in OOP, write a comment in the CSS code, and then you can do the following, "div.myOtherClass div.MyClass &gt; a.someMember" instead. - Again, treat things like OOP. If you are generating HTML using server side code, make sure that everything with the same 'class', resembling an instance of a class, contains the same HTML structure. If you do this correctly, you would find yourself able to regenerate virtually all your HTML from your CSS. If you are understanding the above, see if you can answer why the following rule is true: - Do not use a 'class' on its own. For example ".red". This is ill defined. Instead use, "div.red", or "#dd.red". If you need further help, or examples, I would be happy to help.
Ok, thank you. What about minimizing? Is this regarded as modifying?
Yes, I use NPM. I like idea to make such a folder structure! &gt; And if you're using NPM, it should be included in your package.json file and your node_modules directory. Basically what you mean is as long as at least developers see the license it is ok? Showing license in the client side is not necessary?
css?
I wouldn't expect so. This is standard practice. I wouldn't expect to be told by my tire manufacturer that I voided my warranty by driving. Again, Ianal.
thanks, appreciate the answer! A reason I ask is because a good friend of mine has been a frontend developer for 9 years. He's been a lead at several teams and is quite proficient at his skillset. He had an interview at Facebook and after talking through the problem and whiteboarding it, at the end, the interviewer said "you used a Map instead of implementing your own hash table so that's not great but it is what it is". 
No it was silly smooth for me.
CSS Modules is useful for scoping your CSS. I also prefer my CSS to be, well, CSS. All the CSS Modules do is provide a JS mechanism for tying CSS code to specific components.
I've never had QA go that far, since indivual styles don't really matter (or shouldn't). Usually it's just a visual validation based on screenshots, which is a feature of Selenium I believe. I'm honestly not too familiar with the specifics.
Yeah when I worked QA screenshot comparisons was something that was kicked around a lot, but they weren't very reliable, and some of our products were white label and they didn't work at all.
The app I started doing this on was whitelabel too. I think they had a lot of false positives and had to manually confirm them, but they didn't really complain.
I use CSS Modules and couldn't be happier. I'm also willing to try JSS(it's used by react material-ui library) in my next project.
There's some useful links explaining CSS modules in the rest of this thread, but the gist of it is that you can import separate CSS files in your JS (thanks to webpack) which are locally scoped by default. This means you can have a CSS file scoped to a single react component file that lives alongside it. I have never used styled components, your experience is my worst fear. I can barely trust myself to write good code, let alone other people. I use postcss through webpack for the autoprefixer, but thats about it. Did you stick with styled components in the end or rip it out entirely?
Anyone else feel like this reminds them of a more sophisticated version of Meteor?
That's fitting! I wrote this approximately ten years ago for commission because it was requested of me. The original website is no longer online, so I am just copying my old publications to Medium not unlike an archive. As mentioned in the title, it is a beginner tutorial. It is simply to help with syntax and basic programming logic concepts, not to teach JavaScript developers anything they don't already know.
where were you a month or 2 ago when i needed an effect like this for a client site?!? ;-) this is awesome!
it might be an extreme example, but it's valid. Not to mention one framework might be easier to find talent for. One framework might work fine for smaller apps but have performance issues in larger ones. One framework might have bugs and not be as well tested and if bugs are encountered they might not get fixed as fast. It's really short sighted and dumb to think it has no impact.
Wat. Why would I post something like this for karma? I knew from the get go this was gonna get downvoted to oblivion by all the Vue-zealots here on reddit.
It literally says on the frontpage of Vue: "The Progressive JavaScript Framework" React is a library sure, but I guess you wanted to argue semantics even though you understood exactly what I meant :).
If you do use Yarn, the recommended way is to: \- check in the version of yarn you want everyone to use in your repository \- at the root of your repository, add a \`.yarnrc\` file with \`yarn-path "./third-party/yarn-1.9.4.js"\` By doing this, any developer using Yarn will automatically use the local one above any global one. It's especially handy when you have multiple projects that might rely on multiple different versions, or when you want to be sure you can upgrade your whole team at once.
r/thanosdidnothingwrong
This is a meaningless comment. Even though they aren't technically frameworks, they are generally used as such once they are coupled with additional related packages. And that is why they should be thought of as frameworks, because once you are in their ecosystem you're doing things the react way or the Vue way, and that has consequences for your app.
I like the way TypeScript did it.
Not gonna lie‚Äîthis is pretty cool. 
\&gt; Semicolons are totally useless For machines yeah, but as a person I find they help with code legibility- like a period at the end of a sentence.
&gt; This is pretty much due to people being on different versions of NPM Well, there is your problem. Don't let people be on different versions of npm. We use nvm and every project has a .nvmrc file. Works like a charm.
...and you put it behind the paywall version of medium. No thanks
.then() .resolve
Its actually not that difficult. You're seeing everything at once which is making you overwhelmed. Think about it, if you really start with basics and keep on adding to it you can pretty much build this yourself. - First create a button. Create a canvas overlay. Create some rectangles on the canvas and render it. - Next just move all the rectangles on the canvas in same direction. That shouldn't be hard. Basically you just change the 'x' value in x,y co-ordinate system. - Then you move them in some random direction. Then you can change its opacity on basis of how much they have travelled. - Then add a condition where if they travelled more than x pixels, don't render them or make the opacity 0. That'll get you almost half way there. The rest is just polishing the animations. All of this happens in a loop. So you basically recalculate positions of each particle on each loop/frame and then render them. How you calculate the positions is totally up to you. You could use super simple increment on each frame, or it could contain complex logic. But you can always start small and keep adding on top of it to get the results.
Cool stuff, but make web components for stuff you want to share. Then users of React, Vue, Ember and what have you can use your stuff, not only React. 