It really depends what you're trying to do with it. If there's a JavaScript part in AHK, then you probably can paste it there (again, I have no idea what the program is).
I might be a minority, but I cannot stand tools that try and hook into my git workflow. 
Thank you! Very helpful.
That’s just marketing. Firefox Quantum has nothing to do with js performance.
I feel like the article doesn't do a very good job of explaining why bots would use Edge. That seems surprising to me - when I automate browsers, I've usually used Chrome. Why are bots so commonly using Edge?
I think you have a point, but removing the hooks is as easy as `yarn remove husky`.
Webpack 4 stable is still a ways off and shouldn't bring too much in the way of breaking changes. This was [the Roadmap](https://medium.com/webpack/road-to-webpack-4-week-20-21-1641d03ce06e). The highlights are basically - A bunch of WebAssembly stuff - Performance improvements. If you're looking for some details about what is being looked at, take a look at [this issue about webpack performance at AirBnB](https://github.com/webpack/webpack/issues/5718). - The ability to natively output CSS, instead of needing something like extract-text-webpack-plugin. As far the configuration changes I haven't seen anything relating to that so far.
[removed]
Though in my current position we use chromium or Firefox, when I worked at a Microsoft shop edge was actually not a bad choice. The memory usage was (and still is) significantly lower. That would be my only real guess...
there actually have been a lot of js perf improvements lately. they just don't fall under the Quantum marketing umbrella. https://jandemooij.nl/blog/2017/12/06/some-spidermonkey-optimizations-in-firefox-quantum/
So has Edge and so has Chrome...
Im a firefox and a chrome user and this is still bad. I want microsoft to succeed with it, even more i want firefox to succeed, because chrome is taking over the market and the others need to do something about it.
Like during the Azure presentation where the guy has to download Chrome, and the link in Edge is the 'visited' color? lol
So the question is react vs angular. Having used both I like react better because its smaller, uses jsx, its relatively simple and quick to learn and virtual dom making dom manipulation fast. I've only used ang 4 for couple weeks but I guess pros are using typescript, popular in enterprise apps and scalability. Knowing one u can kinda hop over quick so u should try like a getting started tutorial and see which u like better. 
While I've only used the MERN before, I would think to look at it more in terms of the experience you (&amp; other team members if applicable) have with each, rather than looking at it in terms of functionality, because both can definitely do the same things
It’s really a matter of React vs Angular. There’s loads of good articles out there comparing the two. [This](https://hackernoon.com/angular-vs-react-the-deal-breaker-7d76c04496bc) article does a decent job and also covers Vue if you want to try a MEVN stack. Personally, I started with React as I was initially building a very simple app and appreciated the freedom afforded by how unopinionated it is. If I’d been planning a more ambitious app I might have gone with Angular.
But what about brunch?
Just kill it already 
definitely not... if they could get code fencing I'd be so happy.
&gt; 15ms?! Wow, that’s blazing fast indeed! Bragging about a 15ms build time in an app that literally only has a single line of JS! Wow, that's blazing stupidity indeed!
Yep.... wrote my own in PHP, most of it over about 2 afternoons. It's not pretty and I won't be putting it up on GitHub anytime soon, but it does about 95% of the heavy lifting without a load of stuff I don't need. :) 
Please no. JavaScript is based on prototypal inheritance. I don't think it's a good idea to apply OOP ideas to it. In my opinion, at least, JavaScript is a language people should use functional programming with, not OOP.
Oh, fuck me! you a straight up dumb shit. 
Hi mithril author here. The project started without semicolons. We started getting PRs that happened to have them. Then someone noticed the inconsistency when reading the code. That's the context when I said semicolons lead to inconsistencies. If you have your own project, you're free to decide your own lint rules. Or just use prettier and call it a day. That's what we do for the framework I'm working on in my day job. That works OK too.
reddit's markdown is a pretty small subset of full markdown
I've never seen or heard about someone having this problem. I'd at least have a reference point if the author was talking about jQuery or X framework. Learning about a state library almost always comes after learning intermediate JavaScript.
You are pushing your bundler a bit too hard. It’s on every js related subreddit. And always with the silly comments about dethroning webpack. Makes me think this is just a PR trick. Show some actual proof then if it’s so good. Not just the simplest example. No one needs a bundler for for one line of code. 
It's MDN docs. They're gonna cover the whole language and ecosystem. That's what MDN is for
It's not my bundler, I just cover new topics.
They're using constructor functions. I prefer ES6 classes instead. 
I googled you. You should probably not be telling other people what they need to learn. 
Yup, did some clean-up to remove "pre open-source" code fragments.. fortunately I rotate my keys frequently so wasn't an issue.
Thanks for feedback I changed to a sans-serif based font and it indeed looks much better.
The reason is CORS. When your api isn't on the same host/port as your frontend, you pretty much have to send preflight requests. If you know that the final site _is_ going to be on the same origin, using a proxy during development greatly simplifies your life.
Re. configuration changes I actually found this video demo by Sean Larkin: https://clips.twitch.tv/SleepyHeartlessClamPastaThat
Thank you for your reply, Yes, like not jquery based for example.
I use D3 extensively at work, and it is an amazing a versatile library. I highly recommend it!
Thank you for your reply, Strange, working for me. I've meant when you load 12 months for example and scroll down through each month. (it's for mobile theme) 
Fair enough. I don't think people should use it as a starting point for the language though.
It's older than a month, so it's due for a replacement to keep the JS hipster churn alive. 
I don't get why people don't understand how prototypes work lol. They are not hard to understand, imo most ressources out there about the topic just don't explain it well, because in concept they are faster and easier than classes really. And once you get it down, the big “aaah that's how it works, nice“ sentence just feels too awesome :)
Prototypal inheritance is OOP though. Also JS isn't an FP language, it's just good at it but it doesn't force any opinions or paradigms on devs. FP is just popular these days for UI programming in JS.
Sounds like you don't understand Webpack. What hacks are you talking about?
The benchmark in the link is useless. It provides zero useful information about the benchmarks themselves in how they were performed. It's also from a clearly biased source.
&gt;If I’d been planning a more ambitious app I might have gone with Angular. I'm kind of confused at this part of your comment? Care to expand?
You can use typescript with React :) Why do you say angular4 scales better??
I do a lot of JS work, its hard for me to quantify what 'uncommon' is. However, I grew up with assembly, C &amp; BASIC, went on to Java and C# so when I see stuff in JavaScript none of it feels particularly foreign or unusual. Closures are like anonymous functions in Java, prototypical inheritance is 'kinda but not really' like classical inheritance - then you read about how the language is designed and the difference makes sense. I feel any 'hatred' to the language is borne of a fear of something different and a lack of desire to understand that difference. The one thing I do understand is if its someone new to programming then JavaScript can be overwhelming to really get to grips with due to the lack of discipline it requires to use. In those cases learning a more structured language like Java/Swift/Go/C# first makes more sense first. 
Most languages aren't inherently functional or object oriented. It's mainly about how you use them. You can write perfectly functional JavaScript even though it isn't a pure functional language like Haskell. But overall I'd say it is far more functional than OOP.
I think he's pushing his medium post. Nice post btw.
A react application by Google? :D
Can't get this to work, keeps getting stuck after making a second change, or refuses to reload when changing css. Seems very interesting but can't use it as of now.
Why would you say it's far more functional than OOP? All primitives inherit from `Object` and even primitives under the hood at some level are instances of an object that inherits from `Object` too making it so everything is an object to an extent. That's why you can run `.toString()` on every, if not almost every value in JS.
From the code it looks like it’s just hijacking/monkeypatching any other module loaders (you can see the `previousRequire` and `currentRequire` stuff in there).
That would be great...
Because the OOP concepts are not as flushed out at functional ones. Look at how JavaScript treats functions as first class citizens, how you can curry functions and call them with multiple parens like multiply(3)(5)(9), along with the concept of prototypal inheritance. Just because JavaScript has inheritance doesn't mean it is OOP based. OOP is classical inheritance, and JavaScript doesn't have classes. The class keyword is just syntactic sugar for prototypes. Can you create a private or protected attribute in JavaScript? Classical inheritance has a rigid hierarchical structure. That's the point of it: to lock you in in various ways. JavaScript does none of that. It's more like water. You can use whatever you want whenever you want. The only thing restricting your access is scope. Because of this you aren't confined to a structural hierarchy of accessibility.
Product management drives requirements for both. But clients do not need to be particularly thick and interactive to validate the market. Hell, when I was a UX designer I would do user testing with paper prototypes. Rich front ends are something you build when you know your market and want to shape the conversion funnel, or you are specifically building a thick client app e.g. an in browser media editor.
"Disclaimer: This is not an official Google product."
Look closely. It's not a .css file, it's a .scss file. Browser doesn't know what to do with it. By importing it to our JS file, we allow parcel to bundle it to a .css file which the browser understands
Good bot 
I was building a dead simple app quickly, and given my quick poke through Angular, felt that the features and framework would have slowed me down more than React. My impression of Angular is that its benefits (for people who aren’t already proficient with it) revolve around big projects or projects that have to scale quickly. For a small project that really just needs a simple view layer with a bit of state management, React is quick to learn and implement. Maybe not implement well, per the accepted best practices, but that can be tweaked later.
Did you write this article? If yes: `touch` accepts multiple arguments so you don't need to call it twice just to create two files.
Hi /u/Ravi1012, For javascript help, please visit /r/LearnJavascript. Thank you!
It confuses me why non-official repos get created in the `google` organisation.
The tone of your reply just makes me want to use this technology all the less. It is staggeringly arrogant to claim that - Redux developers are "the community" of client side JavaScript developers - Redux was the first popular library to introduce immutable state (Immutable.js predates Redux quite a long way) or functional-reactive programming (look at Knockout's computeds - RX style maps and folds implemented way back in 2012) - that Redux established the notion of UI state as a reduction over user inputs (this is much older than even web development, also Elm / React-Cycle anyone?) - that the only reason someone could choose a framework with proprietary features would be irrationality and force of habit I heard exactly the same hectoring, ivory tower tone from the Angularites back in 2013/14. Their rhetoric was exactly the same as your own - that Angular was breathing new patterns into web development (IoC/DI, MVVM, two way bindings), that it represented the leading edge of a mythical community (NG-CONF), that the only persons opposed to the NG-Monolith were stubborn old jQuery developers frightened of change. We'll see if history repreats itself. Or you will, as I've decided to enter a different industry, for other reasons. But I will be interested to at least spectate.
Yes, I know. 
The answer I usually find is to just not engage. If I'm productive and getting shit done in JavaScript or any other language that people hate on (see - PHP), then that's all that matters to me. People on tech boards on Reddit are so damn focused on proving that their way is "the one, true way" and the rest of us are just unenlightened heathens bashing away at our keyboards. And quite frankly, I don't have the time, energy or desire to argue about, what at the end of the day is pointless, inane bullshit. Take all those blog posts and comments with a grain of salt, 90% of them are people looking to boost their own profile for personal gain and have very little interest in actually helping the community.
I use D3, C3 and Chart.js but for where you just want to add data and easily embed a chart sans programming, [Google Charts](https://developers.google.com/chart/) is pretty easy.
When I interview senior developers I don’t bother asking questions about language specifics or about generic CS knowledge. I ask about how you handle projects. What do you do when requirements change? How do you remove ambiguity? How do you communicate when a project isn’t going well? How do you collaborate with others? How do you coordinate work? If I feel the need to ask probe how well you know the language or your general CS knowledge then I have almost certainly excluded you from a senior position already.
True, but if another package tries to do feature detection (like `typeof require !== 'undefined'`), the use of a high-profile function name like `require` is likely to lead to incorrect behavior. Webpack doesn't drop any global variables unless you tell it to as long as you don't use any code splits, and if you are using a code split, the name of the `webpackJsonp` function is configurable and contains the word "webpack." My overall point is that polluting the global scope is avoidable, and if the bundler needs to do it, it should at least use a name unique to its boilerplate code.
Important to know what it desugars to.
Parcel itself looks great, and I'm willing to try it out. It's the "THIS WILL DEFINITELY REPLACE WEBPACK" crowd, however, that's really making me drag my feet on it.
Please don't ever suggest a package to install globally, especially when there's absolutely no need for it. Parcel can easily be dev dependency, and work like a charm. There's no need for it to be global, and it'll be anti-pattern.
While I somewhat agree, [the docs suggested otherwise](https://parceljs.org/getting_started.html) 
First, even if their docs says that, that's anti-pattern, and they must avoid that. Second the command you had in your npm script, they ask to run directly in console, and thus needing global installation. It's both stupid, and unnecessary, especially for your example.
It does what webpack is designed to do, but without the configuration. This will work very well for simple cases, but for complex cases with large code bases, it's better to have more configurability, which this does not have. Plus it doesn't have support for typescript, so it's useless for me and my team at the moment.
I want to talk more about this! Can we talk about all of the people who were quick to talk about how "micro-optimizations" were pointless when we're talking about 10k+ rows and there is clearly a 70% difference in those two operations in Chrome? Yeah, browser optimizations are transient, but that doesn't mean we should rely on code we know to be inherently slower, even if that slowness is not the end-all-be-all state.
it does support typescript. there's a blog post about it.
Look closely
&gt; Chrome is fine. I have no reason to look elsewhere. But Chrome *is* looking elsewhere - Edge is the default on Windows. 
It'd be good if you could configure the socket URL.
"So we can't use it at the moment" would be nicer and still accurate.
Cook losely.
I've used this and poi. I've found poi easier to get from 0-60 and egghead.io has a nice tutorial on it covering how to use it to create Vue and react apps. Parcel is cool and I hope they flesh out the docs with scenarios that are wideley used to make it easier to use. For just getting from start to finish on a typical web app these tools are what JavaScript needs.
Mongo isn't a real thing. Don't learn it. 
Also 15ms is actually hilariously slow, considering we have multi-gigahertz, multi-core machines. 
Chill tightly.
You were so goddamned concerned with whether you goddamned could, you goddamned didn't stop to think whether you goddamned should.
I agree, especially if it isn't intended as a globally used tool. That said, I didn't even bother reading it and I have no idea.
A few counterpoints on the currying thing: http://2ality.com/2017/11/currying-in-js.html
Module bundlers need an "entry point" from which they get all the filenames they process. That's usually a JS file, and if you want to bundle CSS/SCSS files as well you just formally import them from there - but that doesn't necessarily mean the stylesheet is actually imported into the JS bundle. Parcel seems to just take the filename from the import statement and creates a separate CSS file for stylesheet imports. 
Trill rightly 
I like poi, but am not sure how to go from a local dev environment to the server (heroku or aws) with it.
Or if your backend is Node you can use webpack-dev-middleware to just serve it from the same place.
It needs the flexibility of Webpack and a half-decent ecosystem before I'd be willing to try it.
Think you are missing a comma after parseInt( subargs[ 6 ] ) 
Maybe not as important these days. A while back, I was using Python. Python has classes and inheritance, and at first I just assumed they were Java/C++ style classes. Later I found out Python classes could be monkey patched, and that already existing instances would immediately reflect the new behavior of the patch. How could that be? Turns out Python's class and inheritance mechanics match what we JavaScripters would call prototypes. Python has been around longer than even Java, and all this time its inheritance has been objects linked to other objects. If we can be blissfully ignorant of the mechanics underneath, that means we made a good abstraction. I could use Python's classes just fine before I discovered how they worked under the hood, and even after I knew, I still use their classes just the same. And now the same is also true of JavaScript. Just like Python's classes, the mechanics that underlie JavaScript's classes become an implementation detail that we don't need to know to use them.
It's the only browser that can play Netflix at full resolution. That's the only reason I've used it.
I mean, sure, if you're just writing some service singletons to help wire up a web application, you don't really need to know about the implementation, but if you ever need to write something performant... it sure helps a lot to understand how prototypes work "under the hood." My number one interview question for JS devs is "what is a hidden class." Not that I expect people to be able to recite to me the spec or explain in depth how v8 works, but it's a very impotant litmus test.
Does it need to? What's wrong with webpack?
&gt; It does what webpack is designed to do, but without the configuration. Webpack 4.0 can be ran with literally no configuration whatsoever.
Sleep nightly 
Eat rightly
Move slightly.
Dress scantly.
Nice article mate. Would love to see the code snippets in syntax highlighted text, as opposed to screenshots. Definitely help the reader work alongside you.
I have been developing for about a year and spent most of it learning React. It’s fairly easy to use and not that hard to learn. I recommend it for any new developer building apps. There are plenty of easy to understand tutorials out there that will help you along the way. 
No. 
PyCharm Professional (paid version) includes all of WebStorm.
Does it still have value once I do need some configuration?
I think you're projecting. I never said redux is the community and what was first and what wasn't, it wasn't the point i was trying to make. I referred to redux because it was directly mentioned in the opening topic, and i am of the strong opinion that "the community," javascript developers in general, is actively fixing lots of problems that you observed before in that we're learning patterns instead of frameworks. There's obviously more than redux, but the knowledge you've attained is neither wasted nor useless once something else makes it better, same with react. And that just wasn't the case before. If you learned Angular in the past you couldn't use that knowledge even from one version to another.
Yeah it’s quite new. They’re very active on their Slack channel. 
What about cars? Is one perfekt Model not enough for our world? How dare you that you think we are smart to don't reinventing the wheel all the time. i'm just kidding ( ͡° ͜ʖ ͡°)
Parcel isn’t supposed to have “no plugins”. It’s actually built to support plugins, so that you can extend Parcel. They’re aiming for the plugins to be zero config though also. You install the plugin via npm and that’s it.
&gt; I'm unfamiliar with any framework, though I gather Angular and jQ do not play well together. What do you recommend? Even though you most certainly could, you would not want use JQ with any framework, they're different paradigms. JQ inflates layout imperatively, frameworks are often of a declarative nature, that makes handling UI, state and data-flow easier and JQ can move out completely. I wold recommend egghead as a starting point: https://egghead.io/courses/react-fundamentals Their React course shows you all the basics you'll bump into, like npm, webpack, babel, modules before going into React itself, which is probably the easiest to get into but at the same time the one that is used by most.
Well, to be fair, it's not even said they do use Edge. Seeing how they're bots, it's quite likely they're merely using Edge's UA string. So why choose their UA string over Chrome's? I don't know, but the only thing that came to mind was maybe they're exploiting reward schemes, seeing how MS is (was?) providing monetary compensation to get people to use Edge and Bing.
Definitely not to the point of something like webpack. The point of Parcel is if you don’t need/want to do any custom configuration.... if you find that your project requires more than what Parcel offers, then you probably need something more than Parcel (or need to write a Parcel Plugin) 
we are still in 2017 , and this guy is already in the future :thumbsup:
Sounds like you don't know what you are talking about. Just a simple example here: https://github.com/webpack/webpack/issues/1315 Brightest minds using webpack trying to get consistent vendor hashes for caching working (one of the simplest things a packer should be able to do) **for the last 3 years**. If you haven't followed this discussion in full, your long term caching is broken and you don't know it. Even if you followed it in full, it probably is broken. It takes 2-3 magic plugins to make it (kind of) work for some cases and those plugins changed over the years. This is the simplest thing, yet so hard to do because the way webpack is configured is completely bonkers. We are all programmers but the config does not make sense for a programmer, it is all magic and convention that you have to ask around (or search around) and learn over time. There is a huge gap between your *intent* and the way you express it. If you don't find it ugly, hacky and full of gotchas, I wouldn't know what to tell you.
I'd say Mongo has some uses, but it's really over-hyped, especially with node tutorials (and the MEAN moniker doesn't help). For the vast majority of uses on the web, especially crud apps, then you'd be far better off with a relational database like postgres or mysql.
The only features missing from Reddit's markdown are inline HTML, inline images, and automatic links (which it just does differently). Many websites (GitHub for example) are actually using extended versions of markdown. [See here](https://daringfireball.net/projects/markdown/syntax)
angular 1.6.x &lt;3 best frontend framework..
There's no official standard for markdown, so just about every implementation is going to have different features and output. Compared to [the original](https://daringfireball.net/projects/markdown/syntax) Reddit is missing inline HTML and images, and does automatic links differently. Reddit also has superscript, strikethrough and tables, so it actually has *more* features than the original.
But sagas are so much more powerful and easy to test ...
my problem with edge is that they make the same mistakes they did with ie - incorrect or non-standard conform implementation of js api, dom management and cleanup stuff. just one of many examples: every "normal" browser encodes urls from it's API. try to call "location.href" on a url with special characters. you'll get a URIencoded result. not so on IE and EDGE. this is just one example, but there are tons of them that make microsoft browsers simply terrible (at least for developers). they didn't learn from their mistakes and there's no reason to give them yet another chance.
Because it's getting tiresome seeing people develop new frameworks to solve the issues they have with old ones. I can understand in some cases it improves the original one (e.g. yarn package locks -&gt; npm), but seeing webpack 4.0 doesn't require configuration either, I don't see the point of this one. And praising its speed by testing it with a few lines of code doesn't lend much credibility to your post either sadly.
Not really a problem unique to Poi. You could either: 1. Checkout your build/dist folder into git 2. Use an npm script to tell your hosting service to build it after deploying Neither of these are particularly attractive solutions, though. You could probably find a better one searching around enough.
Buy ADA
&gt; two way dataflow &gt; current year No it's not, Angular 5 is though
That's pretty awesome!
Thank you for the kind words. I do like the idea of adding snippets but also I do like the idea of forcing the reader to type out the commands/code so he/she will learn more, which one wins?
MS just does the wrong thing to change the current direction. Adding a nag directly into the OS to use Edge is not helpful for their cause. Then to do the OneDrive ad also really hurts them. Saw over 300 million left MS browsers and we will get new numbers shortly and suspect it will be even more. "Microsoft has lost over 300 million browser users in 2016, mostly to Chrome, tracking site shows" http://www.businessinsider.com/300-million-users-ditched-microsoft-browsers-2016-11
 This is an extremely narrow definition of OOP. &gt; OOP is classical inheritance, and JavaScript doesn't have classes. Self, a descendant of Smalltalk, is widely regarded to be object-oriented, and it uses prototypal inheritance. &gt; Can you create a private or protected attribute in JavaScript? Simula, the first object-oriented language, did not implement information-hiding. That was introduced by Smalltalk.
My big issue is MS adding a nag directly into the OS is just not something I would reward. Same with the OneDrive ad.
yep, that seems to be it! I'll respond later if that fixes the issue. ...can't believe I missed that for a solid day...
Yeah, it looks fine for small projects, but Webpack is supposed to be massively configurable. That’s part of its allure - not part of its downfall.
Removed your "I googled you comment" did you? Did you find the project where I glued together several open-source/Tcl projects with about 100 lines of code to come up with a rough prototype of Adobe AIR? Without googling "trout fucker" I'm pretty sure you've never accomplished anything close to that
&gt; The project started without semicolons That was your first mistake
"Make Security a requirement", "Talk at Meet-ups", "Adopt a Style-Guide", etc... All of these seem really generic and would apply to any language in any year. Seems pretty clickbait-ish to me. 
Isn't JavaScript mostly object-orientated anyway?
The direct assignment case isn't doing the same thing as the others. The others are adding to the end of the array each iteration, direct assignment is overwriting the first set of elements. Author doesn't seem to have realized that the setup code runs only once, outside the test loop, not before each test. So sure, making the array longer each time is slower than just overwriting the first set of elements. Having benched this recently, 2 things to say: - direct assignment and push are equal except for one case: if you know the size of the array in advance, you can pre-allocate it when doing direct assignment by using Array(count). This *may* be an advantage, depending on the size of the array. For small arrays (&lt;1000), pre-alloc can be slower. For medium arrays (1-10k), it can be faster, sometimes considerably so, like 3x. For very large arrays, it may get slower again, as the browsers will ignore the pre-alloc and go to hash table mode. - In almost all code, this is unlikely to be your bottleneck. The code I was testing was the inner loop of a game engine, where it did indeed matter.
I did. It was a low blow. I was talking about how you had a poor grasp on some very basic concepts. &gt;Without googling "trout fucker" I'm pretty sure you've never accomplished anything close to that Riiiiiiight. Because I put my real projects under my joke Reddit account's name. *Holy* shit, dude. 
How to become a better {{ keywords }} in 2018
That's like saying using Word is looking elsewhere, because Windows has Wordpad. That's not what we are talking about. We're talking about choosing to use one browser over another. 
I understand the sentiment, but competition is a good thing. Your example of yarn coming out of npm’s issues lead to npm adopting package lock. Even if it takes a bit more effort to decide what frameworks to use, having options is one of the best parts of the JavaScript ecosystem. If you aren’t inclined to agree, think of the alternative: having only one option. Sure, you can try to contribute or open an issue but without competition, it is much harder to justify change.
&gt; Have you noticed this trend that many JavaScript developers don’t know how to solve pretty basic tasks in their web apps without using Redux? For real?
Edge is looking somewhere else because he's already used to Chrome. That's his default. Edge is what's new around the block and he'd need to adjust to it. Import bookmarks, search and add his extensions, get used to the new UI, etc.
Woah, nice. Are you a webpack contributor? Is the `next` branch === 4.0? Would be interested in seeing some docs.
Keep in mind that if you ever use ES6 default exports in a CommonJS context, or bundle into a UMD module, you'll end up with something like `someModule.default()`, unless you use a plugin that compensates for that. 
Quick reply because I found this earlier today, Tobias is posting on medium about webpack 4, here is an [article](https://medium.com/webpack/webpack-4-changes-part-1-week-24-25-fd4d77674e55)
Great work! This makes Strapi v3 usable to us ! 
Grand poobah master of web animation is Sarah Drasner. For example: https://www.youtube.com/watch?v=wc8ovZZ78SY
Ok - thanks for the perspective. Can you say more about imperative vs declarative? I take it that React (and compatible dependencies) can also offer the sort of functionality that the jQ UI offers, like draggable &amp; resizable?
Thanks for the suggestion. I'm building a very lightweight design app, so much of the jQ UI is useful. (See my response to to drcmda).
They had been, when I say Angular v1, that one IS a framework. And at one point there was requirejs, then came Webpack, and only after all these, there was the TS version 2 of Angular. So, I'm guessing you didn't have any need of bundlers before A2 forced Webpack down our throats 😃
I thought this article would highlight specific things a _NodeJs_ developer could do to improve. Async/Await was really the only reasonable suggestion
Interesting idea to apply React thinking to a browser turn-based game. I wonder how well it scales or how many users it handles. It just begs for a Risk or DiceWars clone. 
Firstly sorry for being initially condescending. You do seem to know what your'e talking about but your initial post's brashness put me a little off guard but that's no excuse for me being a dick. With a project the size of Webpack that has all sorts of third party plugins, incompatibilities are going to arise. It seems to be an incompatibility between `webpack.optimize.CommonChunksPlugin` and `webpack-md5-hash` which according to it's readme is a: &gt; Plugin to replace a standard webpack chunkhash with md5. I didn't read the issue or article too deeply so sorry if I'm not catching things within them but I've been able to get Webpack to perform code splitting with proper chunk hashes just fine. I totally agree that configuring Webpack can all too often feel like rocket science but I've yet to find a tool as powerful as it. Webpack also doesn't **need** to be this complicated. I feel like the community in general has the incorrect understanding that Webpack is an alternative / replacement for Gulp or Grunt. If you're not gaining anything from running your Sass, or static assets through Webpack, don't. Keep it simple at first and just use it to introduce the concept of modules to your JavaScript code. A config doesn't need to be any longer than a few lines (and a few lines more for `babel-loader`) for something simple. I think even in these situations it's still not as easy to use as something like Browserify, but I've been unable to find something that does the powerful things Webpack is capable of yet. If you don't need that power, don't use it.
what is with this demo gif? seems legit https://cdn-images-1.medium.com/max/2000/1*KHATEDXNqL5fshf3S0B5Zw.gif
In JQ you have a html page, pick a dom node and you inject a piece of state, like so `$( ".inner" ).append( "&lt;p&gt;" + Math.random() + "&lt;/p&gt;" )`. In a declarative framework you'd map out the structure straight away: &lt;div className="inner"&gt; &lt;p&gt;{Math.random()}&lt;/p&gt; &lt;/div&gt; The syntax might differ, you you'd do this in all or most frameworks. You don't blow stuff into the dom from outside, you're literally defining it instead. &gt; can also offer the sort of functionality that the jQ UI offers, like draggable &amp; resizable? JQ is quite old and i'm sure it doesn't do the slightest fraction of what modern framework eco systems offer. From full blown UI kits to everything else that you need. The only difference is that everything is a component. 
Dude, it was the 90s. There wasn't even jQuery. 
Not him and I already saw it answered elsewhere, but: Webpack's configuration is seriously bad. And I really don't understand why, because it has all the parts it needs to be good. When I came in contact with Webpack for the first time a few months ago, I was seriously upset about how hard to grasp its configuration was. Around ten or so webpack.config.js files later I understand the core concepts, but basically all my configs look the same: from src/ to dist/, separate vendors file, with preprocessors, minified and gzipped. These are basically 90% of the usecase of webpack, but it needs something like ~30 lines of JSON for that to work, when it could totally do that by default. I think that's what most of these webpack replacements aim to solve and I'd love to see them succeed. IMHO webpack needs a serious frontend overhaul.
Hi /u/elpassion, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `blog.elpassion.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.elpassion.com](/search?q=%28and+site%3A%27blog.elpassion.com%27+author%3A%27elpassion%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|31|91% [self.learnprogramming](/r/learnprogramming/search?q=%28and+author%3A%27elpassion%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|1|3% [blog.elpassion.pl](/search?q=%28and+site%3A%27blog.elpassion.pl%27+author%3A%27elpassion%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|1|3%
Funny, I always thought turn-based games were the **perfect** example of a non-trivial Redux app. Whenever novices ask me what to build to practice, I say "find a turn-base multiplayer game ([Nikoli's got a bunch](https://en.wikipedia.org/wiki/Nikoli_(publisher\))) and build it".
Hi /u/thickoat, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `medium.com/@wesharehoodies`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [medium.com](/search?q=%28and+site%3A%27medium.com%27+author%3A%27thickoat%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|61|80%
Not to mention that the second item, _"Graceful shutdown for your applications"_, is just a shameless plug... 
i don't think they listed those pros for Angular as being exclusive to Angular
Interesting. Any spam-detection features planned?
only 5 comments and they're all hating on it yet it has 109 upvotes. good bot work, gergely nemeth?
&gt; Webpack was around the time of Angular (before version 2 and up) dude, I'm talking about the time before Angular version 2 and not in the past century, but at the time of Angular version 1 and Webpack. Are you telling me you did some JS in the 90s and didn't do anything until Angular 2?
If u want to use input you will need a database to save their input. Unless you change the data manually. What is your goal? To impress, To visualize, To inspire If it is visually challenging i'd say invest time in 3d.js If not my go to is a angular html css website but only because I'm familiar with it In short; it really depends on what want to do with it.
No, thank you. I already ate.
Which I would recommend just using Grunt/Gulp for that, since it's (imo) lighter and easier to figure out.
I think it's not pushed / accessible without magic yet, but do checkout this hilight from Tobias stream - https://clips.twitch.tv/SleepyHeartlessClamPastaThat
Default behaves just like any other named exports (it is exported as "default"). Only thing special about it is there is dedicated language-level syntax supporting it. So you can do: import { default as MyClass } from 'MyClass'; import * as AllExports from 'MyClass'; const obj = new AllExports.default(); Your colleagues might curse at you for it, but that's a different story. 
You need to setup [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) on `obs.domain` to do this cross-domain request. There is the concept of "simple request" which doesn't have CORS preflight requirement, but you are using Basic Auth, which is not a simple request. 
Plenty of projects use no-semicolon style, even some lint standards, and it's one of the few configurable things in prettier. I've worked on over a hundred projects over the years, with teams of different sizes, with and without linters, and honestly, semicolons haven't really been an issue. The argument for using linters is well known: it helps avoid silly bugs, but nobody ever talks about the cons, e.g. wasted time on team-wide bike shedding. Something you learn once you have enough experience is *everything* has pros and cons, and that you ought to pick your battles. Religious wars like semicolon-vs-no-semicolons and spaces-vs-tabs are just not worth the time. Neither is wrong, and there's especially no need to be rude or abrasive over this stuff. Cheers
So far, I haven't found usage for mongo that is not some kind of cache or key-value store (so cache again).
Yeah, I mean, I agree -- Mongo has some extremely specific uses that only exist in application architectures that a learner certainly aren't working. Especially as all these RDBMS get really good JSON support, I would almost prefer to run a secondary Postgres node exclusively for JSON (if write performance to the primary was an issue) than run Mongo.
That's wonderful! I had no idea, thank you for pointing that out.
Not sure whether what I want is "visually challenging". I just want it to look like a currency chart ie http://www.xe.com/currencycharts/?from=XBT&amp;to=GBP + have the option of displaying in a bar chart too maybe.
And `async`/`await` is something I already used in 2016… why is this "2018"?
⬆️ How to be a better Reddit commenter in 2019.
Reddit prioritizes content that can be judged by its title. The commenters are usually people that **don't** judge stuff by its title. The upvoters are usually people that **do** judge stuff by its title.
Not really new to Reddit, just a new account, but thanks for the welcome! Oh yes, I create OC. Is OC not allowed?
Does it pickup tsconfig ? That's a major part of typescript
Not everyone wants to learn webpack. Its way to much effort for most users. Especially for new programmers.
It's not planned yet, but you could add an express middleware for now. 
Let's keep it civilized please :)
See https://www.vis4.net/blog/2017/10/hello-schnack/#how-schnack-is-protecting-against-spam
function monitorCrash() { for (var i = 0; i &lt; 999999; i++) { var colourr = Randomizer.nextColor(); var midW = getWidth()/2; var midH = getHeight()/2; var rect = new Rectangle(250, 300); rect.setPosition(midW-125, midH-150) rect.setColor(colourr); add(rect); } here ya go.
Aye thanks 
Is it accessible?
I use default exports for views/components. It's almost always the only export from the file.
You are welcome, not sure where or if it works except for a little pile of shite I like to call codehs, any where else you might have to do some importing of libraries to make it work
I am almost suffered an aneurism with his remarks. – Your framework is a blessing to JavaScript, it truly is a piece of poetry and thank you for what you've done + the contributors. Love from Amsterdam. 
Correct. So in an ES6 context, the import code will be more concise. In the other contexts that I mentioned, it will be just as long, and IMO ugly. 
&lt;3
If you do it right, yeah, it could certainly make it a lot faster. However, most of your actual content would still be coming from AJAX, so you'd end up seeing a partial page while it waits for the data in MPA-land, whereas you could have the SPA just put up a loading screen or keep the old info while you wait for the new stuff. There are ways around it, of course, but I think you'll find that you'll put a lot of work into your MPA to get it to the same level of fluidness that a decent SPA framework has out of the box.
Nice!
It certainly does close the gap somewhat, but you can only do so much to approximate the feeling of an SPA when you still have to refresh the page all the time. Having an SPA allows you to really retain control over the whole experience. &gt;I'm building an app now, initially started with MPA but went into SPA territory. Struggling with browser history, scroll position, saving state, etc. It feels like I have to re-create so many browser features, and I'm just creating a new web browser within a web browser. I suppose that's what SPA frameworks are for! I think you've just discovered the reason basically everyone uses frontend frameworks for non-trivial apps.
Thanks, I'll try fixing that and see if it works.
&gt; The pipeline operator is already available in JavaScript I couldn't get it to work in Chrome 65.x in a jsfiddle. https://jsfiddle.net/m049fxe4/
How about "use the right tool for the job"? - `import WellDefinedThing from 'atomic-module';` - `import {thing, another, oneMore} from 'some-collection';` - `import MainThing, {optionalHelper} from 'complex-library';` - `import {notSureIfTheresGoingToBeMoreSiblingExports} from 'evolving-module'` - `import fs from 'fs'; // esm-proofing` Take special note of the last one. If the argument for `import {foo} from 'foo'` is that it's consistent, well, it's also not future-proof. Likewise, if you want consistency with `import foo from 'foo'` syntax, consider cases like `export const SOME_CONSTANT = 1;`. The 3rd sample shows what a down-the-road scenario might look like if you started with default exports and later needed to expose more things. The 4th sample shows what the opposite would look like (i.e. you assumed potential extra exports upfront, but they never came to exist). My recommendation: ignore superficial beauty, and think more about what each type of export is better at, and play to the strengths of whichever works best for each given use case.
&gt; "Glue together" seemed to be a pretty strong theme You know the concept of ["glue code"](https://en.wikipedia.org/wiki/Glue_code) is a thing, right? Am I perfect: no. Am I open to learning to get better, yes. That's why my SO account has about 2/3 as many questions, as answers. You know who I tend to *not* trust: those who do nothing but answer questions, and ask none. Can you pick one recent thing where I am way off mark maybe as an example, I request recent specifically because I think everybody gets better over time, so if it's recent, well then that's a problem I need to address. But I've accomplished a lot IMO, not just the Adobe-AIR-like prototype. I once contracted briefly for a company that does IVR, not web development, so a completely different paradigm for me, which I've done for 17 of my 19 total years. Within weeks of starting they mentioned an ongoing problem they had, and I mulled it over for a couple of days and came up with a patentable solution. Patentable in that, IBM came along two years *later* and applied for a patent for the concept. Also a 60-line PHP microframework that I was approved to use on an embedded project for Cisco. Also a sub-50-line pure Javascript solution for US-phone masking that I've just been developing this month. I think you should consider all the above before you insinuate that I'm some sort of shitty programmer. I'm obviously pretty versatile for one. Shitty person on the otherhand, sure if you want to think that, I'll even concede that. &gt; Riiiiiiight. Because I would put my real projects under my joke Reddit account's name. You took that seriously?
Neat trick, lol. Unfortunately doesn't work for numbers. 1.ᐅ (double) Uncaught SyntaxError: Invalid or unexpected token
You have to use the ᐅ symbol.
Settle down there Mr. Dunning–Kruger.
not mentioned but relevant: the XBone also reports as edge.
Cool, don't. Use a boilerplate that provides webpack configuration for you. There are hundreds.
I have avoided React/Angular/Vue while I learn how to just simply use JS proper. I don't wanna learn JS with a crutch. This is pulling at that logic.
Competition is sort of a good thing, but the constant churn of . We benefit much more from intelligent corporation 
I don't disagree that cooperation can be better than competition, but I don't think they are mutually exclusive
I made a webapp version of codenames that's playable on the TV, laptop and mobile devices and updates in real-time as tiles are flipped. Built it as a way to learn how to use websockets with Vue.js. You can check it out at http://codenames.codecaffeinated.com and read about it at https://secdevops.ai!
what as dumb argument lol. sorry but what is easier: setting up webpack, sifting through hundreds of configurations or just install parcel. I don't get why people get so mad about new stuff. If you don't wanna use it, don't fucking use it. It's not rocket science.
You done now? Nice. &gt; setting up webpack, sifting through hundreds of configurations or just install parcel Probably parcel. But setting webpack to "just work with minimal config set" is literally creating one file with ~10 lines in it. You can do it once, commit it to your favorite "dotenv" repo and clone it whenever next time you need it. Webpack 4.0 will also introduce a "0 configuration" mode, so if that's your only problem, you can use webpack just fine.
Duuh, you obvsly never coded angular 1.x.. 
ok sir. setting up webpack to work with assets tho is another story. and why are you comparing something that's available with something that's planned
I believe this is an example of hoisting: https://www.w3schools.com/js/js_hoisting.asp
https://codepen.io/anon/pen/EoPGdd an updated Pen that prints results to body as well. you can see the log shows modified results while the body shows original response. 
&gt; Can you pick one recent thing where I am way off mark maybe as an example, I request recent specifically because I think everybody gets better over time, so if it's recent, well then that's a problem I need to address. I think the theme of this thread is that the code style used internally on a project probably shouldn't be much of a concern when evaluating it as a potential dependency, when that aspect of code style isn't considered a big deal even when you are a contributor to that project. &gt; I think you should consider all the above before you insinuate that I'm some sort of shitty programmer. I'm obviously pretty versatile for one. Shitty person on the otherhand, sure if you want to think that, I'll even concede that. To be fair, you were the one making insinuations towards me first. I mean, no hard feelings or anything, we're all grown-ups here. Since you expressed interest in self-improvement, it should probably be said that "be civil", "reap what you sow" and some of the comments in this thread are really all just trying to say the same thing, albeit with varying degrees of politeness. I'm sure everyone here is smart and capable, and it's probably safe to assume any nastiness here is just a case of of people having a bad day or xkcd.com/386 or whatever, so let's all just drop it. 
The UX is still fucking shit.
Yeah the GitHub issues I read includes the usage of a tsconfig
Still not working: https://jsfiddle.net/m049fxe4/1/ 
you gotta define it yourself. when they say it's already available they mean it's super easy to implement
You are right. It's like another 2-3 lines. If you want to use parcel - by all means do so. If you want to have a higher control over what actually happens to your bundle, you will want something that can be finetuned to the very core.
That's only a trickery of Dev Tools - try `console.log(JSON.stringify(data.results[0]));` instead and you will see expected result. If `console.log` gets an object it will update logged result after any change because it actually gets reference to that object.
Thanks, and I do see this. is this because of a delay? I get the object reference but there's gotta be a delay causing this some how. meaning if I modified the object after the log actually happens it won't chage. 
Without the space, the parser greedily grabs the dot as part of the number (yes, `1.` is a valid number). Numbers can't contain spaces, thus the greedy parser can't go beyond that, and the dot is then seen as regular property access.
You know there's something wrong when you're asking questions about CAPTCHAs and headless browsers.
$('obj').html('val') is not dynamic, you need a polling timeout that sets the it every n seconds for that. https://codepen.io/anon/pen/GyozKq 
I created another modified pen: https://codepen.io/anon/pen/vpLbEL strangely enough, if you open the object preview in console before the delay ends, you won't see happy, if you wait for the delay then open it, you will
I hope not, I don't want to learn a new module/asset packing system after learning grunt &gt; gulp &gt; browserify &gt; web pack I just don't want to waste anymore time reading boring docs to just get set up. 
Oh awesome! I always wished web pack had commonly used defaults that could be turned off. 
Yep, it kinda works like that - https://i.imgur.com/2Gycprr.gif
If it makes money who am I to say anything xD
I found it in about 10 seconds by just commenting lines out until I stopped getting the error - whatever works :)
Ah, I was just going off of what I saw in a quick glance at the README.
Please read the links I provided.
I actually meant that in a positive way toward webpack. I think the fact that Parcel doesn't have configuration is a bit of a negative. I like that webpack has all of the configuration options. But I do think that being able to bundle a fairly complex app with no configuration whatsoever is pretty cool, and it's actually the feeling I got from webpack when it was first released. I don't have to tell it what files to include because my module dependencies speak for themselves. Webpack 4, based on what I've seen, is taking a step in the right direction to reduce a lot of the configuration that feels unnecessary.
While mostly unrelated to the main intent of the article, the allusion to ∘ as the symbol for function composition and the mention of "the compose function" are wrong; _piping_ and _composition_ are different operations.
[removed]
https://auto-tube.com AutoTube is the all in one youtube player that you never knew you needed. Made with Vue. Ever wondered why youtube hasn't implemented certain features like being able to make a playlist of your subscriptions newest videos in a click of a button? Me too, that's why I created AutoTube. Spend less time making playlists and more on your work! Build a playlist of your subscriptions newest videos with a click https://github.com/AhadCove/AutoTube
Another mail in Angular's coffin
Parentheses would do the trick too: (1).ᐅ (double) Something that doesn't in fact work is `await` though. 
Note that this is just someone's fun hack. It hopefully goes without saying that naming a method ᐅ is crazy town!
I'd be also keen to know how to deploy. Here's what I've found.
&gt; another mail Sigh. Take your upvote.
&gt; Are you telling me you did some JS in the 90s and didn't do anything until Angular 2? Right.
Disqus is so bloated with shit and trackers 
It's the reader's responsibility to learn, not your responsibility to force it. Also, snippets allow for copy paste if your article comes up as a result of a Google.
 Please support our new Kickstarter campaign - #JavaScript #Rhino https://www.kickstarter.com/projects/1604791210/javascript-rhino-toy
Yea. I've been doing vanilla JS/Go/SQL since day 1, and loving the learning. I don't feel ready to learn a framework on top of that. In the front-end, after setting up a router and A/B view toggle, I see there's still a lot more 'hill' to climb ie dealing with states, scrollbar position, all that stuff. On the flipside, my original MPA pages are all rendering just fine, and there's nothing to figure out. I can spend my time tweaking CSS instead. I have one major area of my app which users will spend the majority of their time in (searching and browsing info), which uses AJAX and JSON, but no routing. With a service worker cache setup, and because I've been doing bare minimum bottom-up scripting, everything is snappy. I think I'll do my initial release as MPA, keep focusing on backend and primary business value, then make transition to full SPA as a phase 2. If I can avoid doing a native mobile builds, that would be the ultimate goal. In any case, if I were to do SPA now, or soon, Vue is top of my list.
Great. This is a very clear explanation. These are all things which I have heard alluded to before, but the way you explain it, it makes sense. Thank you!
That it is!
This is extremely useful. Thank you 
Some things I have found that made me a better Node developer: * Provide a custom error reporting utility. It is nice to have specific error messaging anything something fails or improper user input is detected. If you have recursive logic intermixed with a bunch of asynchronous things the default stack trace is insufficient and should be extended with your custom error reporting. * Even if your app is just a command line app apply some basic design skills to keep the information each to read. Make use of ANSI colors, detailed instructions, and keep everything short. Provide advanced longer descriptions of things as supplement information hidden behind an option. * Bless your application with supplemental tools the user might find helpful. I added a performance tool to a parser framework I wrote so that a user can see how their code performs. If your application modifies the file system then expose the copy, delete, and make utilities you are using behind the scenes. * Reduce your number of dependencies. Dependencies are great, but too many unnecessary dependencies make for unnecessarily heavy applications. Great dependencies are the things you absolutely don't want to maintain. If you find you are having to maintain or extend functionality provided by a dependency you might be better off writing your own logic and dropping that dependency. * Keep the build time short. I have been playing with TypeScript for the past several months which requires a build. I try to keep this minimal. I have seen, at past jobs, builds that include everything plus the kitchen sink and take forever. If validation tasks and other checks take more than a quarter second then put them into a separate build task.
You devil you.
Cool, I've been struggling to find a comment system for my homepage that I like. I'll give this a shot when I find some free time to update my site.
Then i can say 3d.js is way to much powerrr
good point ;) I should have mentioned that you need to approve every comment.
I can't believe how unintuitive it still it is.
how does adopting async / await make you a better developer? it's just sugar over something that already exists. this article doesn't say how, just that you're supposed to use async / await. why? in a lot of non trivial cases it almost always does things people used to using promises dont expect.
[Aurelia](http://aurelia.io) is pretty good. It'll be most like writing vanilla HTML + JS/TS.
That sounds like a nightmare depending on the scale of the site it's brought into. I don't have a horse in this race but I would highly suggest some form of spam detection and filtering. 
JavaScript is not an OO language.
You could have worded that with a bit more tact but I think you're onto something. I think it has to do with the explosion of JS in the past ~5 years drawing people from C#, Java, etc. 
How to become a better {{ keywords }} in {{ year }}. I swear there are a lot of similar posts around this time every year.
Do people really forget how terrible JS was? I basically did the same thing. Though I picked it up with Aurelia vs Angular 2. 
You should put it on Github. :)
Chat != Docs
The article is a bit roundabout but I think the point it's trying to make is one about ownership. He mentions lodash being a good example of a library that is both useful and self-sufficient, but ironically, it is one of the things that contributes to code duplication in his own example. The problem is that somewhere in the dependency tree, someone thought "eh, I'll just add some convenience for myself", and when every library author does this, you end up with a messy node_modules. The interesting thing about it is that it's a recursive problem: the author ran into a messy node_modules by picking angular-cli, but he could've just as well had done a bit more research and picked one of the various frameworks out there that prize simplicity (e.g. mithri, hyperapp, etc). The author could immediately re-clutter his node_modules by saying "eh, I'll just add some convenience for myself" and running `npm install babel-cli`. Or he could decide whether support for ES6 syntax is a problem he wants to own (or, to be more specific, whether it is a problem at all to begin with), and he could choose to incur no installation overhead whatsoever. And recursively, the authors of angular-cli could have made choices about what dependencies to take in. Maybe they could have simply have written a helper function for `console.log('\x1b[33m%s\x1b[0m', stringToMakeYellow);` instead of importing chalk. Similarly, babel could write their own helpers for the various things it needs. And so on. This way, you wouldn't end up with thousands of files handling edge cases that never happen. At every step, there are perfectly good arguments for why a dependency is being used, yet from a 10,000 mile point of view, the author sees this as a tragedy of commons. At the same time, at every step, there is the possibility of taking a seemingly suboptimal option (e.g. hard coding console coloring incantations, foregoing ES6, etc), and yet, these steps aren't necessarily showstoppers and can satisfy a desire for overall simplicity. To me this seems similar to the difference between mass produced food vs artisanal food: you can use generic pasta and tomato sauce anyone can buy at the supermarket and end up with something anyone can do, or you can do everything yourself from scratch, and with the right experience, end with a final product that truly outclasses the rest. TL;DR: imho, "use lodash" is the exact opposite of understanding when _not_ to use something.
Back when we called it DHTML! It's pretty bewildering to come back to it now, especially when you're only doing some front end stuff as part of a bigger project.
&gt;To me this seems similar to the difference between mass produced food vs artisanal food: you can use generic pasta and tomato sauce from the supermarket and end up with something anyone can do, or you can do everything yourself from scratch, and with the right experience, end with a final product that truly outclasses the rest. I think the whole point of the article is that in any other language you would still NOT reinvent the wheel by writing everything from scratch. The point is that most languages have an official/standard library filled with common, stable functions that are used often enough to make them available to everyone without adding additional dependencies. I would strongly argue against rewriting dozens or even several common utility functions if you can just use a popular utility library with a stable API like lodash. It's not going to make your pasta taste better, it's just going to make you wait longer to eat.
It would probably be better for me to write an article on the approach I used - that way anyone else could do the same on any other non-node stack. I wrote it in PHP &amp; Javascript because that was quick and easy for me, also so it'd work &amp; deploy easily on cheap, typical LAMP web hosting. But you could do the same thing in Python, Ruby, or any other back-end language. 
I fucking hate Outlook to the point where I don't check email anymore.
so what do you suggest?
And we begrudgingly accepted it.
Why not both?
There's actually _many_ options for async behavior with Redux. My [Redux addons catalog](https://github.com/markerikson/redux-ecosystem-links) lists all the useful-looking Redux-related libs I've seen. In this case, see these sections: - [Side Effects - Functions](https://github.com/markerikson/redux-ecosystem-links/blob/master/side-effects-functions.md) - [Side Effects - Generators](https://github.com/markerikson/redux-ecosystem-links/blob/master/side-effects-generators.md) - [Side Effects - Observables](https://github.com/markerikson/redux-ecosystem-links/blob/master/side-effects-observables.md) - [Side Effects - Other](https://github.com/markerikson/redux-ecosystem-links/blob/master/side-effects-other.md) - [Middleware - Async](https://github.com/markerikson/redux-ecosystem-links/blob/master/middleware-async.md) My [ReactBoston presentation on the Redux ecosystem](http://blog.isquaredsoftware.com/2017/09/presentation-might-need-redux-ecosystem/) also has a section of slides that [gives examples of the most popular side effects middleware and their use cases](http://blog.isquaredsoftware.com/presentations/2017-09-might-need-redux-ecosystem/#/57). 
There is no variable declaration to be hoisted here.
Nothing about that answer is the least bit relevant.
This image should help clarify what happens: https://imgur.com/AGOf7Pt First let me clarify that this indeed has nothing to do with Ajax or any kind of Async stuff. This is just Console specs. Now, let's quickly go through what happens in the image. First, I create an object just to have something to log. Then, I log the object. After the log, I alter the object by both adding a new property, and editing an existing property. When running the code, you'll see the object pop up in the console. Most browsers, including Chrome, will also give you a preview of what is inside of that object. To do so, a snapshot of that object is made at the moment of logging. Try and figure out why this is the only possible time to make a snapshot for the preview. Next, I opened the object in the console. By the time I do this, the code has long finished running. It's as if my action of opening the object, is an asynchronous operation. When you open the object, the browser takes *a fresh snapshot* of the object, because it now has to show you way more than it did with the preview. So what happened should now be obvious: When the object is logged, it will show a preview of current properties, for which the browser takes a snapshot of the object, which must occur before the edits. When you open the object for inspection, a new snapshot is taken fof the object in order to show the full contents. This happens at a time long after the code finished running, and thus also after the edits were made.
It also works with a double dot 1..ᐅ - one dot to signal it's a number, one to signal the operator
&gt; I would strongly argue against rewriting dozens or even several common utility functions if you can just use a popular utility library with a stable API like lodash I agree insofar as we talk about developers that aren't interested in craftsmanship or how their tools work. But caring about craftsmanship doesn't necessarily preclude reusability. You might, for example, follow something like [just](https://github.com/angus-c/just) - one can evaluate the correctness of the code based on experience and reviewing github issue history, etc, and one can also appreciate the obvious impact on treeshaking/bundle size, given that there isn't an complex web of `import`s as is the case in lodash. That's sort of my point: if one settles with Lodash, they might see Just and shrug. Their code works, life goes on. But if they are on the lookout for when not to use something, then reading Just code might make its benefits apparent, and that could ultimately translate into a better experience for the end user.
&gt; And from a quick glimpse into the code, one can also appreciate the obvious impact on treeshaking/bundle size, given that there isn't an complex web of imports as is the case in lodash. The point of tree shaking is that a module bundler can detect through static analysis what imports are not used and then eliminate that dead code. If you use a library that uses ES6 modules like `lodash-es` then it doesn't matter that there is a "complex web of `import`s" because Webpack et al can still remove the dead code from the bundle. &gt; You might, for example, follow something like just - one can evaluate the correctness of the code based on experience and reviewing github issue history, etc. I can use github's tools to look at comments, commits, and issues about specific files within lodash's code. I don't need each function to be its own module to see that. 
It's outlook, that's probably part of the spec.
The people avoiding prototypes are probably the people that know them already and are simply choosing not to deal with them. P.S. Your "length" is wrong in your example Person function object. It should be 2, not 0 (maybe not so self explanotory? ;)
Wouldn’t that be the same as Redux-Saga then?
&gt; it doesn't matter that there is a "complex web of imports" because Webpack et al can still remove the dead code from the bundle. That's only true of dead exports, and there's a bunch of caveats to boot. If the web of dependencies is statically required [like here](https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L1-L22), treeshaking can't pull it out. When I say that the impact on treeshaking is obvious, I mean it in the sense of it not even coming into play. &gt; I can use github's tools to look at comments, commits, and issues about specific files within lodash's code. I don't need each function to be its own module to see that. Sure, but by your own account, you already trust Lodash, presumably because you know it's widely deployed elsewhere. You wouldn't just blindly trust `just` or any other library you just heard about without doing at least some due diligence. The one-thing-per-file thing certainly does help understanding what it does, FWIW.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lodash/lodash/.../**baseClone.js#L1-L22** (master → b2ea6b1)](https://github.com/lodash/lodash/blob/b2ea6b1cd251796dcb5f9700c4911a7b6223920b/.internal/baseClone.js#L1-L22) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drg6ux2.)^.
First time kayak is passed, then aya, then just y. When you have one letter left you return true
I really hate how disqus won't let you collapse whole threads. On popular sites the top comment can have thousands of replies making it impossible to see the next top comment
ohh okay that makes sense thank you 
Sorry for my ignorance, but what is an anti-pattern and what makes a global install of Parcel an anti-pattern?
And recursion is cool but you can also do a palindrome check by doing: str === str.split(‘’).reverse().join(‘’)
I guess i read the question wrong. It was early. The console refreshes with the current state of the js object so it can be somewhat useful for debug. I thought they were asking why it updated and the html didnt. It does make the html update in synch with the console though. ;) 
Would somebody recommend this even if you don't need the admin dashboard? Are there any limitations?
Not really. If you're using sagas correctly, any given saga doesn't really actually do anything. It doesn't have any side-effects. The saga helper functions (call, select, put, etc.) yield objects which the saga runtime--when the saga is wired into the runtime--can ingest and perform those side effects. Asynchronous behavior is achieved by the runtime yielding control back the your saga upon completion/failure of an asynchronous side-effect. Maybe that's a subtle difference, but I think it's an important one. Sagas are kinda, sorta pure functions (if you allow a bit of handwaving around the statefulness of the `next` method) while async generators as shown here are directly executing side-effects. It's maybe a subtle point, but I think it's an important one.
Outlook is a burning pile of shit. Feel blessed to be joining in on this hate train.
When our company replaced all the develop images with linux (formerly windows, 'twas a .net shop) one of the first things that happened was developers stopped checking email. Outlook web access is really that bad.
Hi /u/SeanTasdemir, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
"Use lodash". Would that be lodash, or lodash-fp? And I can think of some ramda users who might take offense.
Even though I do not give a shit about this topic, your answer seems well thought. Have an upvote
Entirely true, and may seem simpler at first. I did a quick speed test on chrome though, and the recursion version was infact faster, so atleast there's that ;)
A bunch of generic and open ended list items. This dude really is desperate to seem knowledgeable but can't pull it off.
-_- coinClicked++;
Oh my God thank you! I know that was kind of a dumb question, but like I said my class hadn't gotten to this yet so I didn't know how to do it. Thanks again.
Do you see these same issues on safari?
Nice post! For my action types, I prefer a pattern introduced by Luis Rodrigues [here](https://youtu.be/H2hMHgx-OUA). In this pattern, he ties the action type string to the shape of the payload. This allows us to do things like: function myReducer(s, a) { if(isActionType(a, POSTS_LOADING)){ // a.posts is *not* available here return {loading: true}; } else if(isActionType (a, POSTS_LOADED)){ // a.posts is available here return { loading: false, posts: a.posts } } } Also, if (actionTypeEndsInInProgress(action.type)){ Isn't there a high likelihood there will be other actions that end in `INPROGRESS`?
That's really heavy. Disqus is popular because they market to people that don't want to have to think about comments.
Outlook.com has its issues but it is still more intuitive than Gmail's mail, contacts, and calendar management. Outlook: change between email, contacts, and calendar with the big app launcher button in the top left of the screen. Create a new record whether it is email, contact, or calendar item: use the New button at the top of the screen. Gmail: change between email and contacts using a dropdown on the email page and change to calendar using the big app launcher button in the top right. Send a new email: hit the Compose button in the upper left. Add a contact: hunt all over for the add button to find it in the bottom right of the screen (exactly the last place the eye naturally goes). The brand new calendar -- replicates the add button in the bottom right. The only think Gmail does better than Outlook imo is tag management (better than Outlook categories).
As someone who is looking into taking a full stack JavaScript boot camp in the next few months, I can’t thank you enough for sharing this.
Let’s throw money at the problem. Have a bug bounty that pays out if you manage to keep all existing functionality but package size is reduced. Pays out more for bigger reductions. Doesn’t even need to pay that much. Should pay less than sec bounty
Nowadays I don't think it's so much that there aren't any niceties that come with jQuery, it's that the arguments for adding a 100kb + dependency to your application should be a little bit better than a fluent API. It made more sense back when browser's didn't commonly support fully fleshed out API's but today you can skip shipping jquery and use native browser APIs (and the LOC count is not so different. See http://youmightnotneedjquery.com/). Then for older browsers you can ship a couple KB's of polyfills.
This would prioritize code golf over maintainability. I have these arguments with developers at work, sometimes... "I refactored this. It's smaller!" *"But it doesn't do the same thing."* "None of the tests broke." *"Here are two new unit tests your code breaks."*
I think the biggest obstacle to understanding prototypes is the bizarre 'constructor' syntax that javascript uses. Maybe its based on some old language I've never heard of but it looks to me like the Mr. Eich just didn't want to create new syntax so he reused functions and added a 'new' trick. If you forget about all that, and use the new Object.getPrototypeOf() method it makes a lot more sense, you just don't get the OO looking sugar with 'new' and capitalized constructor functions. let obj = {} let objProto = Object.getPrototypeOf(obj) objProto.sayHello = () =&gt; console.log('hello') obj.sayHello() //=&gt; hello 
If anyone has any actionable feedback, please let me know. I'm going this team in 2 weeks. 
I actually prefer web Outlook over Mac Mail’s integration with Exchange server.
I'm new here, so I might be misunderstanding the problem, but doesn't yarn mitigate this to some extent? It's my understanding that it installs things in a flat structure and symlinks dependencies to maintain functionality, so you don't end up with three versions of the same package. Further, to my knowledge it also attempts to resolve the different required versions of the same package. Admittedly I really don't know the nuts and bolts of the tech. I may be way off base, but couldn't this also just be a npm/package manager problem and not strictly a framework problem. Obviously there is work that could be done by package maintainers to mitigate project overhead, but right now there are ways to reduce footprint without changing every package out there. 
If everyone had it installed globally, it would be very likely that people would be using different versions. So when I clone your project it works for you, but not for me. If it is in your package.json instead, then we all run the same version. And an anti-pattern is just a pattern that goes against the best practices.
This statement is also easier if you think of what can it's doing. value = value + 1;
Which is easier to understand at first glance?
Same thing when our ops blocked imap access to the exchange servers and forced the devs onto owa.
Huge Microsoft fanboy here, and total hater of Amazon and Google. Seriously, you can check my post history. But I gotta say that Outlook.com is an ugly, piece of burning ass. It's like a toy app or something. No one takes Microsoft's web apps seriously, and no one ever will! I know, Outlook has like 400 million accounts, but I'm sure that most of those accounts are dead or haven't been signed into in years. I literally don't know anyone who uses Outlook.com for anything. In all cloud areas, Microsoft is getting totally murdered by Amazon and Google in terms of all the stuff that matters today. Azure is a joke. I mean 10% share ain't nothing, but it might as well be. They're not even second in the market. They're what, dead last maybe? We're already looking for ways to get away from Windows because we can see the writing on the wall. The constant changes to Windows and the loss of stability in the platform actually make Microsoft's desperation to get people to stick with Windows pretty clear. So yeah, we're definitely hedging our bets as quickly as we can. It's a company to get away from, except maybe for dev tools. I can't live without Visual Studio.
 if (now.isDecember()) { post.article(`How to become a better ${keywords} in ${year.next()}`) }
A more simplistic and clear configuration would be dandy. Thank you, and good luck. 
Because nobody wants to read about 2016, it's all about 2018 now man, I mean seriouslly, where have you been, just look around yourself man, everyone's looking at the future, standing out from the crowd, y'know? Gotta follow up with them best practices and try to stand on top...!!
While I agree that there is is truth in this, 100+ upvotes so quickly on such a small and relatively inactive subreddit indeed seems like a work of bots or an organized click-farm.
&gt; If you're using sagas correctly, any given saga doesn't really actually do anything huh. yeah i'm using saga's wrong
I don't think that the problem is literally the size of the node_modules folder. For most people even a fee hundred megabytes will download in minutes or less and I'm pretty sure npm and yarn both cache downloads for future use. It's more about the huge numbers of different packages. Every time you use someone else's package you introduce some liability or risk into your project. Their code could be buggy, or slow, or they might stop maintaining the library, or it might even get pulled from npm. If this happens, you need to find a new library or fork the old one and start maintaining it yourself. This includes dependencies of dependencies and all that. Often this risk is worthwhile. I'm never going to be able to write a faster, less buggy, declarative front end up framework than React, so using it is a good idea if a need such a framework. Also React isn't going anywhere. On the other hand, when you have 8 libraries to sort arrays plus the built-in array.sort function, you've introduced all the risk for practically no benefit. JavaScript should have a built in function that handles all the likely ways to manipulate arrays (which it does IMO, not sure why people need libraries to do that). So while Yarn is a great tool, it doesn't really replace a standard library or fix the risk your project has acrued from having tons of dependencies.
Good. They deserve it. Mail all the nails!!!
I'd imagine the non-recursive way is going to be easier to understand at first glance, partly due to it being shorter and simpler.
As someone who has used all versions of Angular (currently Angular 5 daily) I can’t wait to see it die. React is so much more enjoyable to work with.
Looks like it would be just like redux-saga, but without the annoying limitation of not being able to await in the generator. In redux-saga, you can instead yield promises. And the async generators won’t “directly execute side-effects”. They yield actions just like redux-saga. The main difference would be that a generator is started manually, like an action, while a saga listens for an action to trigger them. 
So just for comparison's sake, here's the code from the article: // redux-iterate export const signIn = async function* (payload) { const { username, password } = payload; let state = yield; yield signInStart(); try { const response = await axios.post(API_SIGN_IN, { username, password }); yield signInEnd(); yield signInSuccess(response.data); } catch (e) { yield signInEnd(); yield signInError(e); } }; and here's what it would look like with `redux-thunk` // redux-thunk export const signIn = payload =&gt; async (dispatch, getState) =&gt; { const { username, password } = payload; let state = getState(); dispatch(signInStart()); try { const response = await axios.post(API_SIGN_IN, { username, password }); dispatch(signInEnd()); dispatch(signInSuccess(response.data)); } catch (e) { dispatch(signInEnd()); dispatch(signInError(e)); } }; tbh I don't think there's enough difference to justify another library, plus I think it starts running into a situation where `yield` becomes the new `this` – overloaded to the point of becoming confusing (because you never know quite what the supporting framework will do with `yield`). At least with `redux-saga` you're yielding its own API calls, so the self-documentation is preserved. The other nice thing about thunks is that they can be composed as Promises (bad example, but you get the idea): // redux-thunk export const signIn = payload =&gt; async (dispatch, getState) =&gt; { const { username, password } = payload; let state = getState(); dispatch(signInStart()); let response; try { response = await axios.post(API_SIGN_IN, { username, password }); dispatch(signInEnd()); dispatch(signInSuccess(response.data)); } catch (e) { dispatch(signInEnd()); dispatch(signInError(e)); // rethrow for higher-level actions throw e; } // return for higher-level actions return response; }; export const initMainPage = payload =&gt; async (dispatch, getState) =&gt; { try { const response = await dispatch(signIn(payload)); dispatch(showWelcomeScreen(response.motd)); } catch (e) { dispatch(showLoginScreen()); } }; 
Yeah replace the m with mariadb and your good to go.
IMHO searching something in a static code is harder than just using javascript console. If you just open a console and run this document.querySelectorAll('defs') I am sure you will find what you are looking for in a minute. 
Wow that worked, I love you. Thank you for that, such an incredibly useful technique. I am really grateful for your help.
I am really confused on all the hate. I find that the beta makes it a pleasant experience. I like it more than Gmail 
In defense of your colleagues, you were _missing_ tests. Can’t blame someone for not maintaining undefined behavior.
Of course! I would recommend to use it. You could use the official syntax now since it's supported in Babel 7.
Good point. I know the concept are different but can't find a way to explain it. Composition is `f ∘ g = f(g())` while piping piping `x f = f x`.
Totally agree. The savings in verbosity add confusion.
If the end result is that you now have broader test coverage for cases that weren't previously tested, that's still a good result. It should be possible to rewrite any code as long as the tests still pass and have the program work at least as well as it did before.
I would argue the code didn’t do the same thing then
I didn’t argue it does. I argued they’re are very new, hence both the bundler and docs not being superb yet. 
As a full-stack .net developer, I disagree. React is too much "magic" and "it just works". Reminds me of complaints against ruby on rails. To be fair to you though, Angular 2+ wasn't ready for anything outside of Todo apps until v4. Regardless, it's all a matter of opinion.
10% market share is pretty huge dude
I'd personally use js css html sql and angular. However years ago for simplicity i'd use jquery to manipulate css to graphs 
Parcel has lots of neat ideas. I hope Parecel, Webpack, Rollup can combine ideas and learn from each other. Competition is good, but churn isn't. I don't think Webpack is in any danger of losing mindshare. I do wish webpack config had been easier, there are a ton of options and a ton of blog posts/confusion about it, which is why Parcel seems so appealing.
Their UI elements are definitely worth looking at: https://developer.microsoft.com/en-us/fabric
I agree with u
Can you explain what you mean by correctly? If you're running from a background script, alert will not work. Are you expecting these to run in order? These functions are async, it will not run in the order you think it will.
A fanboy and a hater, what a life to live. And what are talking about writings on he wall and windows stability? You remind me of my old manager, not flexible by any means and seeying technology as a religion. Take it easy chief.
Stop doing this; it’s cringey and often doesn’t make sense 
!RemindMe 1 year
I will be messaging you on [**2018-12-19 08:51:43 UTC**](http://www.wolframalpha.com/input/?i=2018-12-19 08:51:43 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/7kin9y/nodejs_best_practices_how_to_become_a_better/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/7kin9y/nodejs_best_practices_how_to_become_a_better/]%0A%0ARemindMe! 1 year) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
React is pretty simple to understand. There are even frameworks that implement a similar DOM renderer in 1 KiB (see hyperapp or preact). On top of that, there's only your state manager of choice.
Ah, yeah that makes sense, thank you for explaining!
Change the version number for the package you want to update to "*" in your package.json and run npm update again. You can't force it via the command line afaik. This is a good thing, as with semver major version numbers mean breaking changes can be introduced, and you really want to check changelogs before updating.
Not exactly. Function composition is _creating a new function_, and this is important, so it should be stated as: `f ∘ g = (x) =&gt; f(g(x))`. It's an operation on functions that creates a new function, nothing more. Piping, on the other hand, is two things. There's the operation that functional programming defines as _pipe_. This one _is_ very close to composition; it is in fact composition but with the order reversed. That is: `pipe(f,g) = (x) =&gt; g(f(x))`. But then, there's the _pipe operator_ as presented in your article, which has an important difference: It's not an operation over _functions_ but an operation over _function calls_. As such, it doesn't create a new function. It only allows a different syntax for _function calls_. In that sense... "hello" |&gt; doubleSay // or .ᐅ( doubleSay ) |&gt; capitalize // or .ᐅ( capitalize ) |&gt; exclaim; // or .ᐅ( exclaim ); is equivalent to... exclaim(capitalize(doubleSay("hello"))); That is, the equivalence is between _function calls_. The operator doesn't create a new function from `exclaim`, `capitalize` and `doubleSay`. Using composition, what you'd have is that... let panic = pipe( doubleSay, capitalize, exclaim ); // Or let panic = exclaim ∘ capitalize ∘ doubleSay; ...does create a new function which you then call or do whatever you want to with it. I think this is the important distinction. They operate at different levels, one on functions, the other on _function calls_.
Hi, Please be aware that r/LearnJavascript exists for this type of question, which is much more appropriate there than here.
burtgummer45 yes: the only thing you have to do is to create a new Strapi project and remove the `admin` folder. At this point, you will have only a lightweight framework.
https://www.npmjs.com/package/npm-check-updates
The only issue I really see is that we don't have a conclusive standard library just like C++ std, C# .NET, ... But with the current state of JS you could just consider, lodash, ramda, rxjs, babel, express, .. as our de facto standard library. These and a few others are usually the core building blocks of our applications, I don't think they're going away soon, that they'll break or that nobody is going to maintain them for the next 10 years. Considerations on other packages are the same as with any other language, if you're making your .NET code dependent on nuget packages, you also have to consider dealing with them becoming unmaintained at some point. Good coding practices and modular code make it possible to isolate the potential impact. node_modules size, to me is a complete non issue. Sure it looks crazy, but have you looked at the size of other standard libraries? These are usually installed system wide and then we build tools around the global installations like Python's virtualenv. node_modules is ideally for a world where we package an application together with it's dependencies. The only size it really takes is during development, it might be wise to clean up your no_modules of inactive dev projects. Couple that to tools like yarn that add better npm caching and you can instantly rebuild the node_modules folder if you wish. During deployment, whether it's frontend or backend, I hope for you you're doing tree-shaking and minification with webpack. 
I actually remember hsving the choice of JScript or VBScript on browser. Then forgetting an alert() inside for cycle... Remember what jQuery did when I was struggling with the likes of Prototype.js and especially... I remember the hate towards the language I went though during the turn of the decade... Out of that hate, a deeper understandibg was born... You see, it wasn't the fault of the language (it DID have problems, of course) but of how I was beng thought I should create software. Then a love of the more functional, less non-sense, more clear etc. working with JS set in... and was wonderful ! Until the likes of big corporations decided they want to bastardize it just like the other languages and frameworks from which schackles I had already freed myself... And here I am, deep into the crapof Angular/TypeScript/Webpack just because some1 has started a monstroucity like that out of habbit (can't blame them personally, they've been institutionalized😛)
Any information about the rest of the stack? Are the using plain React for state management, Redux like most projects seems to do, or have they choosen somehting less known like MobX? Are they using TypeScript?
I didn't say React is hard, because it isn't. It just lacks that structure that you are used to when coming from a .net background. Plus, JSX is odd in my opinion. I personally feel more comfortable writing templates.
Sean Larkin [wrote on twitter](https://twitter.com/TheLarkInn/status/938845748136886272) they use [satchelJs](https://github.com/Microsoft/satcheljs), looks like a redux-like state manager. 
gotta love having to wait 10 seconds to open the first mail after loading the interface
It's the Hate Microsoft circlejerk. It's much like the Hate Google circlejerk but just in a single color. More circlejerks you find on this page: * The Angular FTW circlejerk * The React FTW circlejerk * The I read 3 posts on medium i'm a UX/UI export now circlejerk Upcoming circlejerks: * The I hate when people circlejerk circlejerk * The I hate people that hate people that circlejerk circlejerk
*mission accomplished. you're welcome!*
https://xkcd.com/927/
[Image](https://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927) **Title**: Standards **Title-text**: Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Explanation](https://www.explainxkcd.com/wiki/index.php/927) **Stats**: This comic has previously been referenced 20 times, 1.3556 standard deviations different from the mean ______ [xkcd.com](https://xkcd.com) | [xkcd sub](https://np.reddit.com/r/xkcd) | [Problems/Suggestions](https://github.com/benreid24/xkcd_bot/issues) | [The stats!](http://xkcdredditstats.com) 
I agree, JSX is odd. You can just use `h()` directly instead or use something like `hyperx`.
Do you know if they use react at all in native app (or have plans to)?
Please be less shit than the old Outlook.com. Pleasepleaseplease. It's just such a horrible user experience. Even after the revamp it was just weird. I'm not hugely invested in it, I have one email address there, but it's one that I do use so I end up on their site more than I would like :(
&gt; actionable feedback What exactly did you want to accomplish with this rant? This dude is one of us: enjoys some good BBQ chips and got a job coding javascript (which happens to be at MS). Did you want him to shit in a box and deliver it to Nadella's office? 
*knock knock* Excuse me sir? Do you have time to talk about our Lord and savior parcel?
Hahaha....
The difference is that parcel will be forgotten soon.
Thanks! It looks like Satchel takes inspiration from Redux and MobX, uses MobX behind the scenes, and it's written in TypeScript, so it's type safe out of the box. To me, that sounds like Satches has a lot of good things going for it.
Except plain generators only allow yielding actions, while redux saga allows yielding a ton of other different effects - including state retrieval, forking, waiting for events, etc.
I’ve always seen Babel as a stop gap for the day that all browsers support es2016+. I’m not saying Babel will die out, but for most users, once the “good bits” of JS are solid, that should be enough for most needs. You could always continue with Babel to get the latest features. Transpilation will always be a thing no doubt, but it will always change and JS will remain under it. As long as our native API’s get better and more sophisticated, the less we’ll need to lean on them just because. Where’s CoffeeScript at?
Everyone is focusing on how fast it is, but what I'd like to know is that if it is as efficient ? In other terms does the output match webpack's output in term of code size and optimization but apparently all those articles only care about 'oh, look how fast it is !' I really dont care about a build lasting a few seconds less, it's a build, I can go to the toilets or go eat and when I come back it will be done.
Lol. What is if prod when in of good is response in of what is 
Except that you'll need a router, turn to the community to hopefully build one and maintain it, you'll need animations, community again, rince, repeat. I like both react and angular, I use them both every week, the framework guerilla is so funny to watch.
Is CORS enabled on the service you’re accessing? Look at this: https://stackoverflow.com/questions/35553500/xmlhttprequest-cannot-load-https-www-website-com
Edge is actually decent, people appear to associate it too closely with IE and automatically drop it.
&gt; And the async generators won’t “directly execute side-effects”. They definitely will. If you directly invoke this saga (i.e. call it directly, outside of the sagas runtime): function* makeRequest(){ const response = yield call(http.get, 'www.example.com'); // etc. } You'll get back something like `{ type:CALL, fn: axios.get, args: ['www.example.com'] }`. That's it. No side-effects, no actual network requests made, just a plain object. If you were to do the same with an async generator, it \*would\* make a network request, i.e. directly perform some side-effect. You can see right in the example that they're calling axios directly.
At work we are in the process of starting a new project. The stack we're looking at is: Frontend: * React * Redux * Typescript Backend: * KoaJS, with TypeORM * Typescript * PostgrSQL The project itself will be a fairly large webapp. After the research we've done this looks to be a good stack. We use Visual Studio Code as an Editor/IDE and it works really well, especially with Typescript (Both from MS).
AFAIK, the web app and the mobile app are completely different. Though I do know an interesting React Native like solution is being worked on all up (and that's all I can say). 
They let anybody say anything on Medium, don't they? It's almost as bad as reddit.
As far as i know you can only use them for micro soft products like sharepoint/office addins. 
I agree that bundle size is an even more important metric. I will update the post later today with my own findings. I made a test on my existing code base. On that code base I have spent a significantly amount of time optimizing. WHen I used parcel with *no work optimizing* I got roughly the same bundle size. 
Just because people are using Babel, doesn't mean they aren't using JavaScript. If you are using Babel for polyfilling, syntax compatibility, or even JSX, then I think distinction between *raw* JavaScript and what people are writing is fairly unimportant. Sure, some people are using typescript, elm etc. but how much of the industry is that really? I'm not convinced web assembly will replace JavaScript as the default development platform for the web, at least not in the short term. It's not being designed for that purpose (though lord knows that's never stopped web devs in the past). It's a massive piece of overhead to put in your build pipeline, you'd have to be getting some actual decent benefits out of it, I don't think *mystery optimisations* really covers it. What actually happens when you give web devs a massive choice of using any language they want, nodeJS, that's what. Which tells you as much as you need to know about whether, in the future, people will default to compiling C++ to web assembly to make an app. 
Cool. With enough online users, the blockchain could be stored completely in the users browsers. Eventually this could be used to create a cryptocurrency where all that was needed to start mining, was to simply visit a web page.
Many people have difficulties getting started because they get overwhelmed with webpack config. I think it's interesting that we have a new library that addresses this problem by thinking newly about the problem. This hype of zero-config has forced webpack to improve also : https://twitter.com/TheLarkInn/status/941431327890358272 I don't think that parcel will "save" us. But I think Parcel will help us as a community to move forward!
Because the value of the variable `mapname` is a string. Essentially it is like comparing: "test".innerHTML += and test.innerHTML += In the first case you have a string which doesn't have an `innerHTML` property. The second one would work because probably the `test` variable holds a reference to a DOM element.
Thanks! So, if I want to update to the latest versions and then freeze these versions, I need to do the following: - Set all versions to `*` in my package.json - Do `npm update` - Do `npm shrinkwrap` My primary use case is having project templates which specify the packages to use, but the latest versions of this packages should be frozen for each project where I use this template. Is this the ususal way to do this?
&gt;They let anybody say anything on Medium, don't they? Well, they don't exactly make you interview to post an article. &gt;It's almost as bad as reddit. I have a feeling I've asked you this before, but why are you even here if you hate it so much?
how could i make it so my first string gets a innerHTML property? 
It doesn't really help that people litter so much shit in their packages. Unit tests and dotfiles and other support files don't belong in the distributed package.
That make sense, thanks for the explanation.
document.getElementById("demo").innerHTML found it. ty for the help
The tests created when a function is built do not necessarily cover all the cases after a time. How we intend a function and how it is used sometimes diverge. Tests are *defensive* but aren't a guarantee of proper function. They are a good guide to expected behavior, but identifying all the behaviors can be a challenge. Most test suites I have encountered outside of popular public libraries are lacking in *breadth* and failure cases. --- Parsing numbers? `parseInt(numStr);` No, decimals. `parseFloat(numStr);` What about commas? `parseFloat(numStr.replace(',', ''));` What about *big* numbers? `parseFloat(numStr.replace(/,/g, ''));` *Really* big numbers! `// See IEEE-754 for floating point precision limits` I need to pass a currency. `parseFloat(numStr.replace('$', '').replace(/,/g, ''));` No, Euros. `parseFloat(numStr.replace(/[^\d\.]/g, ''));` **Negative Numbers don't work, now.** "Why are you getting negative currencies?!" "Account Balances." `parseFloat(numStr.replace(/[^\-\d\.]/g, ''));` I use Spanish formatting: `1.234.567,89` `// Doesn't support Spanish formatting` I use accounting style for negatives: `(20.00)` `// Doesn't support accounting style negatives` --- The only one of those conditions I have not encountered at work is the last one. The original function wasn't built or tested to do all these things, and you can't tell from the codebase that it is used all these ways. Test coverage is a matter of perspective, too. I've had to inform developers that exchange rates can exceed 1000:1, so you do need to check for that comma. No, *all* commas. For reference, **1 Bitcoin = 2,036,230.97¥** right now. --- I maintain a few small open-source libraries, several with 100% coverage. Writing unit tests helped me identify problems, but I still find problems I never expected. My uuid conversion library incorrectly handled capital letters until four months ago. `uuid` and `node-uuid` use lowercase hex characters, so all my test data was fine. I am totally in favor of unit tests. But they can't always save us from ourselves.
Yeah, I think the popularity of Node is the basically the perfect counterargument to this notion that people only use JS on the frontend because they have to. If everyone was so desperate to run as far away from JS as possible, Node wouldn't enjoy a fraction of the popularity it has today. Also, a lot of these articles seem to use the popularity of Babel to bolster their argument, which is just silly at best and dishonest at worst. There's nothing about ES6 that makes it "not JavaScript", and the lack of browser support is the only reason Babel is necessary at all. Is transpilation on the web only going to get more popular going forward? Absolutely, but let's not make things up here. Java didn't die because Scala and Kotlin were invented, and neither will JavaScript. 
Cool thx for sharing. Please encourage the team to do a blog post in the future about it and enjoy the new gig!
I get what TS/Redux is trying to do. But it's getting to the point where you have to touch about 5-6 different files before you can make a basic component. Models, Interfaces, Modules, Actions, Reducers, ...... That is pure bloat. Also I probably have the same library reused countless times by other libraries in my node_modules folder. We need a kind of JQuery that has customizable tables, tags, comments, messaging, the basic stuff a site needs, all in one, no node_module bloat. Web Components, Polymer -&gt; Right Direction TS, Redux -&gt; MS trying to make web dev a living hell
Redux? Are you maybe thinking of Reason, not Redux?
Ah. I though you meant side effects as in manipulating the state. In redux-saga you can yield promises, so side effect are certainly possible there as well. 
Correct ''' Microsoft grants to Developer, a non - exclusive, revocable, worldwide, non - assignable, non - transferable, royalty - free license to use the Fabric Assets (defined below) or a s ubset of them (e.g. the ‘Toolkit’) exclusively for the following purposes: • In connection with the use of a Microsoft API within the development of a software application, website, or product you create or a service you offer designed to provide access or interact with a Microsoft service or ap plication (“Application”) • To illustrate that Application integrates with one or more Microsoft products and services. '''
&gt;Also I probably have the same library reused countless times by other libraries in my node_modules folder If you're concerned with duplication in node_modules, npm actually has a command called `dedupe` which moves shared dependencies higher up the node_modules tree. Think it's been there since v3. &gt; We need a kind of JQuery that has customizable tables, tags, comments, messaging, the basic stuff a site needs, all in one, no node_module bloat. I'm not sure everyone would agree with this - "bloat" implies waste, which is what you're likely to get if you try to write a library/framework that solves all these problems for everyone and undoes the last few years of the javascript ecosystem.
Hype is the difference.
If you're using `call` (which you really should be), you're not actually yielding a promise, you're yielding an object containing a function which returns a promise, which the runtime will call on your behalf.
I imagine it'll be public. You should check out Office UI Fabric React if you're interested in seeing the shared React components betwee Microsoft web properties (OWA, OneDrive, SharePoint, VSO to name a few who contribute). 
Not sure why you were downvoted for trying to clarify, and it's worth clarifying that neither Redux _or_ Reason are made by Microsoft.
And pay the overhead cost for every framework? Because freedom? This is just about the least maintainable approach. 
I think he's referring to Redux's requirement for making reducers, stores, dispatchers... etc before writing a simple component. Of course, if a component is simple enough you probably don't need Redux. 
I think he's referring to Redux's requirement for making reducers, stores, dispatchers... etc before writing a simple component. Of course, if a component is simple enough you probably don't need Redux. 
&gt; Where’s CoffeeScript at? [v2.1.0](http://coffeescript.org/#changelog) - came out 9 days ago.
Right now at work we're dealing with four larger projects, 1. React + Redux, still untyped but soon either Flow or TS 2. Angular + Redux + Typescript 3. Vue + Redux + Typescript 4. Node + Redux + Flow My colleagues all use different editors. Some Webstom, some Atom, some VSC. Editor integration seems to be fine in all of them.
Yeah, for a simple component, redux is bloat. For a page that has 10+ tabs, each with 30-40 fields and complex validation rules across the tabs, redux means you are writing like half the code of without it, especially for something that needs to show the last time it changed and by who, etc. The bloat is in the initial setup, and redux really shouldn't be used all the way down to the most simple component, but on save or cancel actions. So I'd say, no, you don't understand what it is trying to do.
Apparently, most frameworks don't take care of this stuff out of the box. Vue, for example: https://dzone.com/articles/dont-forget-browser-button-ux-in-your-vuejs-app Similarly, React has libraries/middleware for these things too. A lot to chew on.
The webpack documentation is pretty straight forward... For basic projects you don't need to configure anything with webpack. I should also say I think the criticism about having multiple places for configuration is a bit of a cop-out, as webpack just gives you one more option, one which is very useful (as you can change Babel settings for different build targets, for example). I get it - it's nice, but it's far from a webpack replacement. To do what you can with webpack you're going to need configuration one way or another.
What did you spend your time on when optimising your webpack config? This is a topic I find very interesting :)
No you don't understand.
It's more of a feature driven approach. Each team manages their own frontend rather than having a massive project that everyone hacks on 
I've answered that question many times in the past. One last time: I come here looking for links of technical value. Too often I let myself get sucked into reading or commenting in a thread. It is my weakness. Sometimes I can get myself not to do that for a period of time but it comes back to haunt me. I can't help but try to fix the internet but reddit is reddit. As a NPR reporter once said, "Reddit is a Frankenstein's monster they can't control." 
And then your users pay the cost for developer freedom to create technical debt. Gotcha. 
This wouldn't be a problem if npm blocked package.json without a valid `files` entry
The point of this is to solve technical debt by moving away from legacy systems and create isolated systems that are more maintainable. For instance if a product module was necessary, you will most likely have a team dealing with the implementation of that project (if you are following agile that is). Who best to maintain the entire thing? Have another web focused team develop all the FE for the product module? Or have the team that knows about all of the business rules do this and maintain it? Also PR's... 
Afaik it's also mostly because of the font and icons. Both could theoretically be stripped from the project but who wants to do that. I looked at fabric when for something that's an office/sharepoint addin as well as a web app but i ended up not using fabric because of the licensing issues.
Wow you really showed him.
Quite the counter argument 😂
Check out `routing-controllers` for your backend. Awesome TS decorators for express/koa routes.
None of that is a legitimate reason to introduce both the resource cost and maintenance burden of multiple massive piles of code that you don't control. What you're building here isn't an application, first it's a library built to multiplex applications around different dependent frameworks. Now that you've built that library, and accepted that it is a maintenance burden until the end of time, you get to start writing your many different applications in a way that promotes the least amount of re-use and the most amount of boilerplate and overhead. It's crazy to think about how this would perform on mobile devices with less than optimal network conditions. In a world that is moving towards progressive web apps and trying to make the web more simple, smaller, less reliant on app land, it seems crazy to double down and say 'I'm going to make a system of environment management for application land so that I don't have to choose just one front end framework. 
&gt; redux means you are writing like half the code of without it, especially for something that needs to show the last time it changed and by who, etc. that level of cognitive dissonance especially going all edgelord with the snark at the end, im just happy noone at my office is like that. 
We’re using the following stack for a pretty big hybrid app: Front end - Vue / Vuex, Webpack / Babel, Phonegap, currently no type system Back end - Python / Flask, Custom ORM, MongoDB Deployments - Git / Docker Server - Mostly Debian containers but a few Ubuntu, NGinx Editors - Atom, VSCode, vim occasionally 
If you're an aspiring dev, rather than a professional one, it seems to me you have a huge luxury: you don't have to support ancient browsers. Because of this, you can use fancy new job features like fetch, which will be much more important to know than jQuery in the future.
IMHO a router is a state manager that handles URL state. You also don't *need* to have one, and they're actually pretty trivial to write on your own.
&gt; strictly typed Did you mean _statically typed_?
&gt; How to make headlines on reddit for karma in 2018
Like I said in the article, this is a solution to get rid of your legacy apps in order to build progressive web applications. This is about the migration of said legacy system that is holding your application/business back. You don't have to continue using micro frontends. This allows you to migrate your system in parallel and not all at once, which has much less risk than just turning on your rewrite at once. As linked in the article there are several ways to use the micro frontend approach, you could use a javascript "metaframework" that combines all of these frameworks and lazy loads them, to reduce load time, render your application on the server side, isolate the micro apps and so on. 
Consensus driven state? Let the network decide what your app's state should be!
You shouldn't talk about TS and Redux as though they are related, or a similar thing. They are not, typescript should have little influence over the structure of your applications. Also, I am not the greatest fan of Redux (although I appreciate what it tries to do - simplify application state) but I vastly enjoy working with Redux more than with a huge mess of a JQuery codebase. And once again I don't see why the size of node_modules has an effect on your experience developing with typescript/redux. It's not a folder you spend lots of time in. Maybe you should check out Redux and its concepts before comparing it to A. a superset of a language and B. to the component based libraries (React or in this case Polymer) that it's supposed to complement. I don't mean to come across as rude or anything here, but it seems you should research these things more before drawing conclusions. Personally I've found TypeScript a great tool, and I think Redux or similar state management libraries are useful for building complex applications.
All I get is a blank page on Firefox
So go to new and downvote and explain why something is poor content then move on. Waiting for articles to reach the top and then being upset that you can't arbitrarily make them go away doesn't "fix the internet" anymore than showing off that you read NPR.
Sorry man I just don’t agree. “You don’t have to keep using” is practically the definitive precursor to technical debt. Your “meta framework” is the library I’m saying you’ll have to write and maintain... and how would you propose that server side rendering would work with a lazy loaded multi SPA? This idea is just so half baked. 
&gt; Welke technieken zijn er om een grote hoeveelheid data, in één actie, efficiënt op te slaan in de database? Thanks will definitely take a look at it! 
i think statically strictly and strongly typed all refer to the same thing but i might be wrong. Ultimately, i'm referring to the type checking mechanism.
[removed]
"that day" is unfortunately plenty of years ahead. IE needs to die first
Thanks for your response i will remove now
google tag manager was removed
Oh, no, they are most definitely [not the same thing](https://en.wikipedia.org/wiki/Type_system). If you meant "checking types before running the code", then you meant _static typing_ :)
people commonly refer to as rxjs/ngrx/store as redux. also in case you werent aware TS/ngrx/angular is a really popular stack right now. maybe you should check it out someday. thanks for letting me know that typescript and redux aren't the same thing, i was having more difficulty with that then the fact that i have to edit god knows how many files to make a simple component. this shit reminds me of programming in java. its not good, its not conducive to web development.
but ... why?!
Yeah the link doesn’t work. It’s still pretty unclear what you want 
Thanks, strongly is indeed a different thing, i forgot all about it over the years heh.
I'd say lots of people use TypeScript by now, pretty all relevant packages in NPM either include types or have them provided through the @types repository. But I'd argue it's still pretty much just JavaScript, just with added type information so the code is less prone to runtime errors and developer experience is improved through better tooling.
It's really not. I use Office 365 daily.
The problem isn't GTM, it's probably some logic after it that needs tweaking. I'm quite sure you could keep GTM without impacting your react app. I don't have the GTM warning anymore but I still have a blank page with the [following output](https://imgur.com/a/KtVmM) in my console.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/6IVaQE4.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
I wouldn't call it bloat, but it's certainly forcing a not always suitable or preferable development pattern. That said, I'm the kind of guy to pick up a framework and find it suitable for just about everything until someone comes along and tells me otherwise, so I might be my own worst enemy.
That's a sweeping generalization about NPM packages.
I'll keep laughing at the dev who think performance is the biggest problem in software. Ease of development and maintenance well always be number 1. I don't care if Bob can make code that is twice as fast as Alice. Alice's code takes 20% less time to write and maintain. The salary I saved from Alice's can be used to by additional servers that cost less. Devs get too tunnel visioned on what they think effeciency means. There is more than performance effecieny in the world of software development.
Outside of editing package.json, npm provides no way to do this automatically from the command line. `npm-check-outdated` is a global package that does have that functionality, though.
Have you run through [this](https://devcenter.heroku.com/articles/getting-started-with-nodejs#introduction)? If so, what was giving you trouble?
Haven't seen this 'til now. I'll give it a shot and get back to you on it. Thanks!
Well, maybe popular packages is a better way to phrase it. `npm install pkg @types/pkg --save` just tends to work and increasingly even notifies you of the separate typings becoming redundant. I think in the last half a year I've run into one package that didn't provide either, but already had an issue with couple of comments. I also think now either flow or TS is plain good practice for public library you intend to release.
Thanks for reminding me to check my email lol
Internet Edgeplorer
`var y = ..` code is absolutely wrong. RTFM on how `get` function works. It gives an array of key-value pairs from storage as parameter to the callback function, not as its own return value. Also you set the value and immediately try to read it but who can guarantee that it's set already? Use either onChanged listener or Promises/async-await to chain those functions.
Ironic you use the phrase tunnel vision when you seem to have forgotten about the other side of performance - the speed on the client side. It doesn't matter if your code is the most maintainable thing in the world and was developed in a couple of days; if your app is slow for your user then they are less likely to use it. Point is, there's a balance here. Presumably once WASM starts to be supported in browsers there will be frameworks and packages that improve dev time.
And all the users trapped in legacy codebases were overjoyed!
The article talks about C++ but is there anything stopping WASM being compiled from JavaScript? Seems like that would be the most natural route.
.innerHTML exists only on a DOM element. You were trying to access something that did not exist on a string.
They can be kind of confusing. Static vs dynamic is pretty easy to determine but strong vs weak is a bit more abstract. I always like to compare python to js to describe it because they are both dynamically typed but js is considered weakly typed
thx a lot! i will check it
Use Lotus notes fo two yea s then come back to me...
Hi /u/Pwanty, For javascript help, please visit /r/LearnJavascript. Thank you!
I think many people use node because they are web devs and already use js, so it's a world they already understand. In my personal opinion I've yet to see a true backend Dev flip to node from Java/go/etc.
It can be confusing - even the tutorials. I prefer using Heroku through the browser, not the command line. If that's the case for you too: **You have your code on Github:** - Create a new app in your Heroku dashboard - Go to the "deploy" tab and "connect to Github". - If your deploys are failing (you can see deploy logs in your dashboard), here's the main things you want in your package.json: "scripts": { "start": "node myapp.js", "heroku-postbuild": "compile-if-needed" } Heroku will basically do the following commands after you deploy: - npm install - npm run heroku-postbuild - npm start **"start"** would be whatever you run locally to get it running (but production setup, so make sure you don't watch any files for changes etc) **"heroku-postbuild"** is only needed if you need to do any compilation or other build steps *after* npm install. Otherwise you should be good to go. I also wrote a guide how to connect your repo to Heroku so it deploys automatically when you push your code to Github/Gitlab/Bitbucket: [https://www.myfrontendtips.com/deploy-node-apps-to-heroku-automatically/](https://www.myfrontendtips.com/deploy-node-apps-to-heroku-automatically/) Pro tip: Heroku will not look in "devDependencies", so make sure all dependencies in "heroku-postbuild" and "start" is listed in "dependencies". 
That was a great write-up, thanks! Some comments regarding the contents: &gt; Although I can't find any sources, I heard that Polymer 3 would supply an auto converter from (normal) Polymer 2 syntax. Yes, this tool is in development and available at https://github.com/polymer/polymer-modulizer RE: Polymer 2 and types. We are actually working on this as we speak. You can check the progress at https://github.com/Polymer/polymer/pull/4928 Additionally, there is a Polymer decorators project to have decorators for the properties defined in a Polymer element: https://github.com/Polymer/polymer-decorators Please try out these projects if you can and let us know how this improves your workflow :)
&gt; Although some people complained about the size of jQuery it was mostly irrelevant as it was often loaded from CDN — so the for 90% of time it was already present on user’s computer. **[citation needed]** So, the author is blindly just making up statistics to fit their arguments, and this assertion regarding jQuery is likely wildly inaccurate. This article is over 4 years old: [HTTP Archive: jQuery](https://www.stevesouders.com/blog/2013/03/18/http-archive-jquery/), and completely contradicts the theory that users are likely to have a cached copy of _your specific version of jQuery_. Granted, due to age, the problem may have lessened -- but I believe the opposite is much more likely.
Irrelevant, but nice try at a karma grab. About the only thing _"standard libraries"_ and _"technical standards"_ share is the 8 letters that form the word "standard", but which has a completely different meaning in each context. You might as well throw in a _standard transmission_ and a _battle standard_ at this point.
Performance is important if you are company like Google. The whole reason they developed Chrome/V8 was to push JavaScript engine so they can leapfrog desktop apps and capture the market with webapps. If you are one of the smaller companies, it is probably closer to what you said. 
My team would gladly flip to Node from a Java container if our company allowed it. Or at least we'd incorporate Node as a business layer for our apps.
TypeScript is beautiful
Field declarations (line 2) aren't part of JavaScript yet. https://github.com/tc39/proposals https://tc39.github.io/proposal-class-fields/
how often do people reply /r/iamverysmart to you
I'm not saying people don't or won't, just my completely anecdotal observation is that while there's some interesting things going on it's mainly a web server frontend tier used by web devs.
Click on Javascript settings in the top right of the Javascript textarea: - Language: Typescript - Frameworks &amp; extensions: React Rerun and you should see what you want if you open the developer tools console. 
Maybe this will help if you're looking to attach it visually later? (Googled jsfiddle react example) [https://jsfiddle.net/reactjs/69z2wepo/](https://jsfiddle.net/reactjs/69z2wepo/)
Just run npm install package@latest
Could you please tell us the experience of ts vs flow? Pro and cons?
I use Node, Koa, React, Redux, and Flow generally for my apps. I use Atom with the `ide-flowtype` package which works pretty well.
I believe JavaScript is a problem right now, as WASM is strongly typed. There is a typescript compiler though. There's quite a few other compilers out there, though most are fairly immature. The C/C++ compilers are mentioned a lot because that's what was developed along side the standard being produced.
&gt; There's nothing about ES6 that makes it "not JavaScript" I've been coding Javascript for 21 years, and there is plenty I abhor about ES6. Not all of it, but a lot of it is overcomplicated and makes the code more difficult to follow. Can I do it? Yes, sure - if I have to. But I don't chase new and shiny things, I'm just too busy writing clean easy to follow code to care much about everything in ES6. Maybe it will grow on me, maybe not. But I'll still be coding ES5 and making awesome things no matter what 'feature' they try to shoe-horn into javascript next. 
That's all well and good, but it's still literally JavaScript, and to imply otherwise is factually incorrect.
There are two kind of people: - the makers/hackers/not invented here syndrome, they love to do stuff for the sake of figure out things, for the love of hacking. if there's a new JavaScript framework this week, they will dig into the code, and will try to figure out how to build their own, even if they don't use it, but they have to hack it. If there's a new cool technology, they will try to build their own version, because that's what a hacker do! - the users, they build stuff, too, but they use tools already built, because "...why re-invent the wheel?" and it's a total fair statement.
Thanks that is what I was looking for. So annoying that javascript syntax is so fragmented. Some libraries use older syntax.
There's also a third, which is like a balance between the two. They'll jump right into digging into new technology and trying to build their own, or figuring out how the tech works, but at the end of the day they'll usually go with the tested and proven tool that has already been built. There's a lot of value in OSS, and because they've figured out how the tools that they're using work, they'll submit their own contributions to help make them better for everyone else while also improving their own experience.
What's the premise of the article? Are they saying Javascript is going the way of WordPress and it's not a good career choice?
Relevant username.
&gt; We need a kind of JQuery that has customizable tables, tags, comments, messaging, the basic stuff a site needs, all in one, no node_module bloat. ...so use jQuery. If that’s what you need. 
Yeah, I mentioned a bit of that too. &gt; will try to figure out how to build their own, even if they don't use it But you are totally right. 
Redux loop has always been the easiest for me. We use it at work. It's the closest you can get to the elm architecture with redux
Well, JSX for starters. Technically you *can* use JSX in Vue, but I haven't seen any recommendations of such. Check https://vuejs.org/v2/guide/comparison.html - React is right at the top.
It wasn't javascript until very recently. How about we also shoe-horn async/await, generators and type coercion into C and keep calling it C, and python, lisp, and cobol. I'm sure everyone that's been coding those for many years will be perfectly fine with adding some new/shiny to their workflow. Of course I'm making an exreme example, but you can't keep adding every fad-feature from every other language and expect to still have a programming language that is easy to learn and use. Javascript finally got Promises, oh but that's the old new/shiny, the new way is async/await. Tomorrow let's pile on another way to do it that came from language xyz. Where javascript ESx is headed isn't the programming utopia some might think it will be. You end up with a language too convoluted to make anyone happy.
The other thing I see a lot is poor performance being falsly attributed to something. "jS runs slow on this list". No it doesn't, you're just making an ajax call for every single item in the list. Batch them up and stop worry about JS.
Okay, but that still has nothing to do with the point I was making. 
Sounds like you've got some things to work out with yourself. Blaming the sun is like a spouse blaming a partner for their own infedelity.
The article talks about this in the "Templating vs JSX" section. I think saying one can use JSX in Vue is disingenuous. You can also technically use hyperscript in React, but if you did that in a job interview, the interviewer would definitely raise an eyebrow.
I see the roadmap has some tough targets on it, too. I have a million questions. Will function level type inference mean concise lambdas are possible? How about closure support? Does wasm make multithreading cross-platform easy? Will shared memory be possible? Any thoughts on base libraries? (Array, List, some reflection maybe?) Are these a good idea in this context? Cool stuff!
Most of the world is served by the big players, not the small players, and this is true on everything, down to Walmart.
&gt; There's nothing about ES6 that makes it "not JavaScript" ^^^ as far as i'm concerned this is the crux of your argument. Javascript isn't every language, it doesn't really need things invented in other languages, and the language bloat is not a good thing. The original scope/intent of Javascript was for it to be a language similar to C/Java but far easier and lightweight. It's now recently ballooning outside of that scope. I have no problems writing easy to read and maintain as well as performant code in ES5. There is very little I gain in ES6. I've been working with a team that is all up on the new/shiny and they cause themselves headaches by using Babel and being *far too clever* with ES6 features. Javascript has been forced out of its original scope by language fetishists. It started with coffeescript. There is no end in sight now. And I'm sure it's going to get brought up - so I'll address it first... "you don't have to use all those new features". This is only relevant if you program in a bubble, and don't rely on javascript for your income. I work on various teams on various projects, so I get to see a lot of different ideas of how people think they should be using javascript, and the ones riding the new/shiny horse are the absolute worst to work with. 
Amazing that you're getting so downvoted for telling the truth. I'm also stuck in the bloat since working on a Redux/React project. There are 6 different files an click event has to pass through just to do anything with the event. It's completely and absurdly broken design, but over-abstraction seems to be the norm these days. 
wait, I seriously just have to add those lines to my package.json? The issue was that my deployment would fail, and everything is on GitHub. I'll give it a go!
All this is still completely irrelevant to his point though. ES6 is JavaScript, it's in the standard. If it's in the standard, it's JavaScript. End of. You not liking the standard is a completely different subject that changes nothing about what is or isn't JavaScript.
Well yes. What I like about Vue is templating. I was just stating the fact that it *is* possible to use JSX in Vue. And, in my so very humble opinion, JSX is just weird :) HTML inside JS just feels wrong. But as the comparison says, the user doesn't need to learn anything. Which is one of the reasons it might attract a lot of developers. That said, coming from Polymer that also use a sonewhat similar templating system, I find Vue less complicated to work with. That also goes vs React and Angular. But we all have different tastes, and when it comes to next-gen JS libraries (and even programming languages), it's an ever raging war about "which is best".
Async/await uses promises though. It's just syntactical sugar to make promises easier to use. Promises are the way you implement async/await in JavaScript because it's single cored and functional. You can't have async/await without promises and promises are ugly to use without async/await. Therefore it makes sense to have both.
All the time. And I've talked about that, too. Interestingly, I just found my Mensa admission results while cleaning up the basement over the weekend.
If you still have issues, feel free to link your github repo, will be much easier to find the problem that way
Honestly, I still code like an old granny too with ES5. But hearing you moaning about Javascript evolving to add new toys that are really beneficial to the language? Come on grandad. The one thing I agree with is your dislike all of these transpilers. I too find it pretty frustrating to be told that to be a "good" developer you need to write in Yuckelscript which transpiles to Typescript via Coffeescript, then Babelify it through Webpack. Sure, there are benefits, but it really is exhausting to keep up with. 
ah, so it's a joke. right on. good joke.
Alert seemed to work but said undefined, is that what you mean? I’m running the script with a chrome extension manifest if that helps you understand at all.
So, how does WebAssembly handle accessibility concerns? Right there is a dealbreaker for an enormous amount of ecommerce and education.
Most dev teams I've worked with started converting themselves from CoffeeScript to ES6+ around a year ago.
I never said all of ES6 was bad. Thanks for getting that wrong.
Wow, almost like gaussian or bimodal distributions are two great way to model most human populations and we can stop classifying people in rigid, well-defined labels like script-kiddy or hacker. I think tying redux to blockchain is really stupid, and often, great things come from ideas that I think are really stupid. Nice job for trying something different, OP, keep doing you.
Also anecdotal, but I've come across people who have jumped from Java or .NET to Node.js. I'm guessing some because it was trending, some because of functionality, and some because - unbelieveable as it may sound - they actually like JavaScript as a language.
&gt; Async/await uses promises though. It's just syntactical sugar to make promises easier to use. It's difficult to follow. It's all questionably better or worse than callbacks. I'm fine with using all of it but callbacks are easy enough. Promises and async/await are fads. Next week the next fad will begin. yawn. rinse and repeat. It seems like language fetishists love chasing their tail. 
&gt; If it's in the standard, it's JavaScript. End of. ES5 was the standard. Take your "End of" and shove it. 
&gt; ES5 **was** the standard. I'll be holding on to my "End of", thanks.
on top of approving individual comments with schnack you can also whitelist users, so all their future comments are auto-approved. another thing I did was to whitelist all people I follow on twitter, which you can do by adding a bunch of twitter ids to the config file. aside from that, I must say that the amount of spam I had to deal with since I launched was almost zero. the biggest source of spam comments are spambots, and maybe it's because they can't authenticate through oauth or they haven't deemed schnack worthy of targeting for attacks, but so far there have been zero spambots.
It is annoying, but it's also interesting that so many users are excited by the tool. Unless it's all just spam and bot posts, of course.
we only recently added threaded comments to schnack, but collapsing threads should be really easy to add in the future. each comment threads is stored in its own &lt;div&gt; container, which makes it easy to show/hide them with very little JS/CSS
From a quick scan it's saying "Raw JavaScript" will become more and more a compilation target rather than the language that is written.
Agreed, to me TypeScript is still JS in my eyes 
in a way it's more accessible than disqus because schnack doesn't use iframes. so the comments appear just as html embedded under your site. I guess it could be made more accessible by baking existing comments into the HTML on the server, but that would require a far more complicated integration to existing websites. not sure how accessible the oauth signin is. never tried it in a text browser / screen reader setup.
I will be using babel for a long time, mainly for performance reasons since doing things like the rest operator `{price, text, ...other} = anObject` will be more guess work for the browser. 
Somebody a few months ago shared a CoffeeScript to readable JS transpiler
They are all callbacks. Promises are just a sensible way to deal with callbacks. If you've got a better way to manage complex callback chains, fine, go for it. The rest of us will probably stick to the standardised, native way of doing it.
In a way, browsers already do something similar to your JS code compiling it to maximize performance based on observations. CPP compiled to wasm still uses the same JS runtime and resources, but just without all of the hidden classes and extra work needed. 
Angular is the magic, React is extremely straight forward and very little black boxing going on. 
Proof that javascript sucks and people just use it because they have no other choice
Never _interviewed_ for a senior Node dev role, but some questions off the top of my head: - What experience do you have working with microservices? What challenges and benefits do they provide compared to monoliths? - When would I write a web service in Node.js? When would I not? - What's your approach to software quality? - Explain to me what happens when I point my client to your webserver and request a resource. - What are the limitations of REST? - How do you balance handling technical debt with continuously delivering value? As the other poster says, if I were interviewing a senior Node dev I'd be asking questions about architecture and technology choices, not the basics of how JavaScript works. Those are things I would ask at the _start_ of a midweight interview to merely qualify the candidate.
That goes in all directions though: a JS dev wouldn't want to pick up Java, a c# dev wouldn't want to do c++, and a c++ dev wouldn't want to do python. People tend to stick with what they're familiar with. 
whoosh.. that went right over your head, didn't it. Keep chasing your tail, noob.
&gt; They are all callbacks. Promises are just a sensible way to deal with callbacks. If you've got a better way to manage complex callback chains, fine, go for it. Keep inventing more ways to catch that mouse. One of them will stick, eventually. Bloat totally isn't a thing. &gt;The rest of us will probably stick to the standardised, native way of doing it. So you mean callbacks. 
Right now (as far as I'm aware) WASM has no native way of displaying anything. It's pretty much just functions you can call from JS. I'd presume any displaying that WASM does will through some interaction with the DOM.
Oh sorry, I must of misread when you droned on about ES6 bloat. My bad. Sigh
I'm not sure why yet. I have some ideas. With some more tinkering I want to build a serverless consensus model that I can use for ... things. As I mentioned, so far this is playful exploration :)
You use callbacks to manage complex callback chains? I'd love to see your techniques, please share.
Actually yes. This is the direction I'm going with this. Good example for where this could be useful: A distributed chat app. Or really anything where a lot of people have to agree on a common state.
Exactly! Serverless distributed crypto something. What more could you want? Whether you can build anything useful with this, I don't know yet. More tinkering required.
Clearly, you'd best explain it for me.
A pretty even treatment. I think that react forces some architectural considerations (especially with redux) that are annoying at first and quite good in the long run. Obviously, you can still make those choices (immutable state and one directional data flow) with vue if you want.
That's what non-programmers say, yes.
I'm excited for the day we can write full stack on something like goLang. 
Nothing like some fresh news.
Yeah, added those lines and still getting issues. https://github.com/Pixelstyx/dangan-monobot
That, and the fact that javascript isn't the bottleneck at all. It's the dom, the document primitives, that are in need for drastic overhaul. I'd even say javascript is a great language for frontend and if i have the choice, nowadays i'd use javascript for mobile and desktop frontend as well, driving otherwise native UI, simply because C#, swift and C++ don't have the same turnaround, eco systems, communities and because it would take ten times the time, effort, money spent and people working in the team.
create-react-app-ts
It's mostly the same. Flow is easier to set up and get going, it doesn't crash the build system and behaves like any other modular tool. Typescript on the other hand has a bigger community, more 3rd party types and some people say editor support is better. 
They've got frameworks nobody has even heard about but no Vue? How can I take this seriously?
Nice hackery mate! Keep going!
Parallel discussions over at HN have indicated strongly that WebGL-optimized applications are likely to be a thing, and therefore there would be no DOM to entangle with necessarily. Not to say plenty wouldn't construct an internal DOM representation, but plenty likely won't, either.
I don't see you instantiating your Search class anywhere. It should probably happen in your jQuery load handler.
First of all you don't want to commit node_modules, it should be gitignored, and let people install it with npm install. Add file: *.gitignore* node_modules/ Second, you need to adapt the script to what you have. Your main file is called bot.js so you need to write "node bot.js", and you don't seem to do any extra build steps, so remove heroku-postbuild? like this: "scripts": { "start": "node bot.js" } How do you run your projects yourself? How do you get it started? You need to let heroku know how to run it too. I tried to run it but it stopped - without errors though. I'm not sure what it is supposed to do. Try that as a start
Well, C was updated with features in 2011 and will most likely keep getting them. And considering the latest changes were threading related, async/await might actually make sense. Which dialect of lisp are you talking about? Because some are indeed getting updates. Cobol was 2012? Maybe 2014? They went object oriented and have a bunch of new features in recent years. Language designers pick and choose features because the people using it want it. And the rate that Javascript actually adopts features and you can use it in browsers natively is pretty slow. C#/Java would annoy the hell out of you with the cadence they have been moving at lately.
We used Vue at my last job and there were some situations where we opted to use JSX in a Vue component. We ran into the rare situation where a template couldn't cut it, and had to use the render method of Vue components. We found the syntax of Vue's render functions to be a little offsetting and hard to use, but luckily most of the team had experience using JSX from side-projects or previous jobs, so we opted in. It really helped since it was not hard to pickup, and it utilized skills and knowledge most of us had already learned from our limited experience using React. This situation was very limited and only affected a small amount of our components, but it served it's purpose for our team.
Vue: ES5&amp;ES6 / Library Size / SFC's / Reactivity Model / Computed Properties / Watchers / Directives / Mixins / Built-in event emitter. Vue is more optimized out of the box, and doesn't require much boilerplate. Performance is pretty close since React 16 came out. I use Vue at work, but I'm a React guy. I prefer JSX and JavaScript for my rendering logic. Although I'm biased, I enjoy using both. Vue does a lot of things under the hood that inexperienced devs take for granted. I suggest that you dive into the source code.. Vue is much easier to read.. Here's a pretty cool repo I found that will hand-hold you through the important parts of the source code: https://github.com/numbbbbb/read-vue-source-code
two years ago nobody heard about vue and look where are we now :) I'll include vue in the next round since it has been just finished https://github.com/gothinkster/realworld/issues/7
Java 8 did a smart move, they looked at what's good with scala and inserted functional programming. That killed scala overnight basically. The same will happen with javascript if you like it or not. Go ahead downvote me. Corporate is sick of all the frameworks and 6 months what's hot and what's not anymore with javascript. The moment webassemly lets big corporate write Java for the frontend is the moment javascript will be dead. Just like scala is. 
Care to go more into detail on how templates were limited?
it's not going to happen, it's going to be the other way around. the moment that Webassembly lets java manipulate the dom on the frontend is the moment big corpo will stop javascript and they will be all writing java for FE just like the BE is doing. End of story. 
I don't believe it. 
Correct.
You actually got a point right here. Don't forget to include Choo too in the next round! It has miracluous amount of stars in github etc but first benchmarks shown it was slow and also for production ready separate component development it's not ready too (since it always linked to routing), but... Well, we need to know what's going on in Choo world right now
I don't really think that would be helpful. Browsers have been making JS faster since long before wasm was dreamt of, so while C++ in wasm is faster than JS, JS in V8 is probably faster than in wasm.
I started this from scratch a week ago with zero knowledge of javascript, heroku, or github, so I'm sorry about my lack of experience. I'll try this out.
Looking forward to Vue and Ember. The LOC metric is especially important to me. I hope the Vue app will be using vuex.
So it deployed successfully; but my discord bot is still offline!
I would go with "taking a deep dive into advanced React + Redux", because you work in consulting and React/Redux is a common stack. I wouldn't worry too much about the whole functional programming thing. You'll pick stuff up along the way... it's not like you need to be a Haskell programmer to do a little redux. 
&gt; lack of browser support Obligatory - 99% ES6 is available in 98% of browsers today. Only ones missing are oldie (11 and below) and oldsafari (for mobile).
FML my clients love IE11.
"Functional programming" is the new buzzword insecure front-end devs use to sound smart. It's definitely a thing, but it's importance is vastly overstated by internet-pedant types. I'd focus on learning Advanced React with Redux because it's an incredibly popular stack. Along the way, you'll learn about immutability and pure functions, which will help you wrap your head around functional programming. I think this is the better approach, instead of doing it backwards, learning functional programming and somehow expecting that to "teach" you a javascript framework.
At every point you described a change to the requirements that needed to be implemented, it should have been accompanied by unit tests to verify that the new requirements have been adequately met.
Dan Abramov put a lot of work into helping make the comparison docs for Vue vs React as unbiased as possible - see the discussion here https://github.com/vuejs/vuejs.org/issues/364
I'm so sorry :(
__tldr__ - Don't use hype/popularity to choose a language/framework but take a few days to learn about the technology by building a prototype.
A number of products are beginning to stop supporting IE. Depending on the product, the market share often isn't worth the extra development time
Is this available in Node? 
I’m a former C# back end dev who went full node. At a new job and back in C# and I regret the switch.
Totally agree that you shouldn't be learning FP to somehow help you learn frameworks. However just to play devil's advocate, FP is a more generally applicable skill overall. In five years when React goes the way of jquery/backbone/knockout/angular/etc, FP will still be a useful skill whereas react + redux may not be. 
or rather, take the time to learn what problem the new language/framework is solving and decide rationally if that's a problem you have/will have
Learn how to take advantage of rxjs. It will make a lot of hard things easy and is already integrated with angular. And on top of that it is functional in nature so you'll learn more about that as well.
"Older" syntax still works in ES6+... Just because there are new features doesn't mean you can no longer write ES5.
By then browsers will have a lot to catch up to, isn't that right?
Some of us have to support IE11 :(
It makes no difference if Alice's code is fast enough. But if Alice makes code that takes 6 seconds to load and Bob makes it 3, go with Bob and you'll lose way fewer impatient visitors.
I agree, it's great. But there's this weird obsession right now where it seems to attract gatekeeping sociopaths. I only brought it up so OP isn't led astray.
React embraces proven techniques like functional programming, immutable data, reusable components, one-way day flow, and comprehensive state management. Vue on the other hand seems like an Angular clone with slightly different syntax 
&gt; The initial release in version 5.9 provided coverage at function granularity (showing which functions have been executed), which was later extended to support coverage at block granularity in 6.2 Looks like Node 8 LTS has the 'initial release' - Node 9 has the extended version.
Good question, I'll add my two cents. Go with Angular for business applications. I write apps using whichever one suits me the best, but I find that Angular is far more preferred for serious business applications. And you don't have to give up Redux, @ngrx/store is Redux-4-Angular, if you will. React has advantages over Angular in some areas. It's smaller and more concise. You can bring your own *everything* (router, HTTP client, beer, etc.) I find that React is better for Internet-facing website for that and a few other reasons. waitwhatwhy's answer about functional programming is pretty accurate. Utilize the best practices from whichever framework/library you choose and you'll go 10x farther than simply trying to keep up with the buzz-words du jour.
You mention ecommerce and education will be hit by accessibility. I live in the UK, by law all our sites must be accessible. Many other countries have similar laws that demand it of all services or either a defined few important ones. So if someone decides to implement views with WebGL, people will quickly realise there is no big market for that until accessibility is built into it. As a business, you are really shooting yourself in the foot by tying yourself to an ecosystem that cuts you out of the much of the global market. Therefore, either people will continue to use the DOM, or we will have accessible WebGL. I think the former is far more likely to dictate the near future of web dev, since the HTML has such a huge ecosystem (even outside of accessibility) and replacing it needs to have considerable advantages. I don't think WASM is going to magic up those advantages straight away, it'll probably be performance increases for specific purposes for the time being.
In reality what you want is a compromise. Laughing at either of these issues is foolish.
test("board.***palce***RandomTile()", t =&gt; { 
heh - thanks!
So you are creating a 2d array of arrays that represent a board and you want to populate it with randomly until it's full while avoiding setting the tiles twice ? Am I right ?
In this test case, yes. I guess the question I should be asking is, is it ok to be using these types of assertions (from within a loop)? t.equal(b.placeRandomTile(), i &lt; b.width * b.width); and t.equal(numberOfOccupiedTiles, Math.min(i + 1, b.width * b.width));
Wow, that's really awesome. It feels like the direction typescript will eventually end up at.
I realize this is entirely superficial, but I *really* love the single-file component syntax for Vue. It just feels right to me. template in a `&lt;template&gt;`, script in a `&lt;script&gt;`, styles in a `&lt;style&gt;`. I feel like I'm writing webpages the way webpages were supposed to be written. JSX has always looked and felt like an ugly hack to me.
I don't pretend to be the best in js, I tried to figure where that equal method from t comes from... Without success. Could you feed my curiosity ?
You can use functional components in vue. Almost every framework has reusable components, vue certainly does. Vue has one way data flow. Redux has nothing to do with react and is library agnostic, it can be used with vue or you can use vuex which is almost identical. So I'm not sure where you get your information. Almost everything you wrote is wrong. Vue does have mutable state for performance reasons, that one was correct.
Not to get meta, but pointing out that the current trend is somehow a buzzword. Functional programming really is a fantastic way to organize code. It is easily testable, easy to read, compositable, and much more! It also allows for code parallelization, which makes sense on modern many-core systems, but won't be a realized benefit in JavaScript. The latest frameworks (redux, rxjs) use functional paradigms (originating from the flow architecture proposed by Facebook), so naturally, knowing functional concepts will make it easier to learn them. I would take a few days to experiment with redux and rxjs. These are powerful concepts that utilize functional programming and can be used fullstack (not just by insecure front-end devs)
&gt; It doesn't matter if your code is the most maintainable thing in the world and was developed in a couple of days; if your app is slow for your user then they are less likely to use it. Sure, but most of the things programmers consider "slow" aren't slow enough for the average person to even care about. The way programmers talk about Slack you'd think it was slower than booting Windows 98 on a Pentium. The reality is most non-programmers who use it don't even notice. I'm a programmer and I don't notice. You guys need to understand that there's such a thing as "fast enough" and you can get there way before you throw WASM in the mix.
It comes from the testing library `tape` (https://www.npmjs.com/package/tape). The `t` object is getting passed into my callback functions (second parameter in the `test()` calls). 
JavaScript still, internally, represents its values as specific types. Generally, values in scripting environments are described by a single 32 or 64 bit section of memory and some type flag. The memory can be converted to an integer, boolean, floating point number, or pointer to a more complex object. So it should be entirely feasible to compile JS to WASM, you just need to translate the internal representations to WASM commands
&gt; Ease of development and maintenance well always be number 1. An unpopular opinion but I totally agree. My theory is that for programmers, "My thing performs better than your thing" = "I'm a better programmer than you". They forget that if the other guy's application looks great, and feels great, and does more, and is cheaper, and available sooner, and updated frequently, people are going to use their thing. They don't care that your program uses 5% the RAM and 10% the CPU! Once the program is fast enough to be used in real time they don't give a damn, every other factor now matters way more. Stop optimizing for the wrong variable!
Is it only me or the sound is horrible? 
Yeah JSX looks really odd to me and I've been deving for years and it looks like alien language to me half the time. I can't imagine how new comers might feel with it. 
I've noticed that happens when any of the more "computer sciency" topics start coming into the lime light. With the functional stuff you have the elitist few that start acting like they've been doing Haskell and lisp since birth, now with rust getting more attention you've got the type system gatekeepers that want you to know just how hip they are with what CS has to say about theoretical proofs as it relates to advanced type systems. At the end of the day I just try to get shot done and glean what's useful from the high brow hipsters when it makes me a better developer.
It's outrageous! It's unfair!
&gt; but if you did that in a job interview, the interviewer would definitely raise an eyebrow. I would be impressed if someone did this.
WebAssembly *does* have access to the WebAPI and DOM, so you should be able to use ARIA tags, populate element bodies, and such. [WebAssembly FAQ](http://webassembly.org/docs/faq/) (The relevant point is at the VERY bottom)
It may not answer your question nor fit the requirement of your exercise, but I was wondering if it would not be simpler to treat the board as a single array. Having a 2d array and an array for empty tiles seems to be overkill. You could try to turn this : for (let i = 0; i &lt; b.width * b.width + 1; i += 1) { t.equal(b.placeRandomTile(), i &lt; b.width * b.width);} to : let boardWidth = b.width; let len = boardWidth + 1; let boardSize = boardWidth*boardWidth; for (let i = 0; i &lt; len; i += 1) t.equal(b.placeRandomTile(), i &lt; boardWidth); It's clearer, and probably faster, though I don't really master the optimization on js. 
??
They are also running the Angular 4 app in development mode - kinda dropped the ball there.
I heard about an up-and-coming technology called Node.
Personally I like Vue &gt; React because of the simplicity and the code tends to look cleaner so I usually use it for most of my personal projects. However for my job we ended up deciding on React mostly because the community was much bigger which meant a lot more packages and functionality were already built, that we could build on top of. It also seems to be a bit more secure in terms of longevity as it backed up by one of the largest tech companies out there. Also when hiring , it’s a lot easier to find React devs than Vue devs. Although honestly, anyone who knows JavaScript should be able to learn Vue within a few days, React is more of a buzz word than Vue when it comes to attracting talent. 
This is a great point... I've also just realised that I can use the `board.getEmptyTilePositions()` function to calculate the `numberOfOccupiedTiles`. Check the OP for updated test code!
&gt;The fewer lines of code you have the smaller probability of an error and smaller code base to maintain. I notice that elm is the highest, and yet 'no runtime errors' is one of the biggest selling points of the lang/framework. Obviously you can manufacture corner scenarios where that is not true, but its not something that seems to be prevalent. The languaged is designed such that you can even encode your domain logic to enforce your business rules with types such that it is a compile error to even attempt to do something incorrectly. Which is obviously impossible with javascript or most languages. This result seems to run counter the implied reasoning behind this metric. I'm already in love with the syntax, but these numbers (and others I've seen elsewhere) are really selling me on it further. I just wish there were more jobs with the language.
I don't get what you're trying to say
1000% I read Evan You’d comments several places that you can use JSX and it’s render method. I spent 3 days trying to get it to work in my typescript project. There was no doc no working example anywhere. It’s very disingenuous. Just because you have compositional render method under the hood does not mean it’s comparable to JSX that everyone expects if you’re comparing it to react.
And to think, some of us came to javascript to get the hell away from bloated build systems.
&gt; for serious business applications I can't stand when people make baseless buzzwordy statements like that. 
oh man, that reminds me when I was learning about the difference between classical and prototypical inheritance and I was using playing around with Python and JS to see how it differed. And I can still remember how confused I was trying to identifying the differences not knowing Python is also prototype-oriented. 
Sorry you're getting all the down votes. web components seem like a standard sane way of moving forward on the web. Redux/TS and all the rest.. It reminds me of the bad java over-abstraction days. To be fair, redux, typescript and react do solve problems, they unfortunately create 10 others at the same time they solve 1. :( Seems to be lost on most people.
People who don't know how to code generally prefer functional programming, which is not angular.
a naive way might be something like: let someArr = [] dataSet.forEach(obj) =&gt; someArr.push(obj.Y)
That's probably one of the dumbest things I have ever heard 
Try: for (var x in myObject) { var y = myObject[x]; // do something with x and y } 
How have you found TypeORM? I used it in a recent project and the luster wore off very quickly for me. 
Sounds like a job for RxJS: http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-merge
Use [Array.map](var dataSet = [ { X:1, Y:2, Z:3 }, { X:4, Y:5, Z:6 }, { X:7, Y:8, Z:9 } ]): https://codepen.io/anon/pen/dJMEGx?editors=0011
Then we started using Grunt 🤔
Says the guy who doesn't know how to code...
Because we can. 
Nope not just you, sound is horrible. Soft garbled noise is all I get, at least on mobile. Maybe different in another platform but being YouTube I am doubting that is the case.
so yeah.. I can't build the whole app for you so my advice for you is - get it working on localhost before you think about deploying. If it's not working locally there's no point deploying. My guess is that you're missing an actual server since this looks like just a script that will run and then that's it. Something like var http = require('http'); var port = process.env.PORT || 3000; http.listen(port, function () { console.log('My server is now running on http://localhost:' + port); }); Google for some node tutorials, find how to start a node server etc. That's it from me, good luck
[`Object.entries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)
And anyone who reads up on WASM can see the point of it all: making browser apps that run as fast as native apps. For a lot of websites, they're already running this fast because they're simple. They've reached "fast enough". But for games or editing suites or very large data visualizers, WASM will open up some really cool new doors.
Ya I think a lot of people misunderstood the main draw of modern frameworks is that the shadow DOM lowered the amount of DOM re-renders to only what was absolutely necessary. The DOM is the problem, and even ballooning your code quite a bit is just fine if it lowers your # of DOM manipulations.
Is this Angular 4+ with AOT or without AOT? 
You're looking for [Observable.withLatestFrom()](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-withLatestFrom). The idea would be that your two sockets would each produce an `Observable` of some sort (likely a `ReplaySubject`), which you would then consume like this: let channel1 = // Get your socket 1 observable somehow let channel2 = // Get your socket 2 observable somehow this.channel2 .withLatestFrom(channel1) .subscribe(([ch2, ch1]) =&gt; { // this will be called every time channel2 // updates, along with the most recent // value from the channel1 socket });
Yes that looks perfect. Thanks for the link!
Thanks for the link, this library is 10/10
The shadow dom will make it even worse. It doesn't lower the amount of re-draws, it wasn't made for perf reasons. It will proliferate the use of many frameworks in a single project because each shadow wraps a naked dom that needs driving in the same way the document dom needed driving. 10 web components could mean 5 polymers with varying versions, two preacts, one react, one vue, one stencil. The performance implications of this will be a nightmare.
That isn't a functional component, it just exposes the internal render function. JSX in Vue is a side-effect, not a feature. Do this in Vue, functional component B referring to component A: const A = () =&gt; &lt;div&gt;hi&lt;/div&gt; const B = () =&gt; &lt;A/&gt; Or this, component C refers to objects in its scope: import range from 'lodash/range' const C = ({ params }) =&gt; ( &lt;ul&gt; {range(...params).map(index =&gt; &lt;li&gt;{index}&lt;/li&gt;} &lt;/ul&gt; ) &lt;C params={[0, 20, 5]} /&gt; You can't do neither because Vue doesn't know scope, nor does it have components. You register a directive, render function or not, then declare references via dependency injection. 
Not sure how you'd get around latency issues, plus crdt algorithm seems to solve that problem pretty well.
crdt might be able to give you want you want without the latency inherent in a block chain based consensus.
Well we have only build some prototypes with it so we haven't extensively used it, but so far it's pretty good. What made it loose it's luster for you?
Who cares about karma? Its relevant because one part of the article proposet exactly the same, to make one standard "standard library".
TypeScript is very much not JavaScript, unlike something like Flow where all type annotation is through comments. You can't run TypeScript code in even the latest of JavaScript interpreters.
Noone said JS doesn't have types. It's weakly _and_ dynamically typed though, which pretty much rules out AOT compilation
Literally no-one who knows anything they're talking about refers to RxJS or Ngrx as Redux. They're all state management libraries yes but you might as well say "people commonly refer to React/Vue/Ember as Angular". It makes absolutely no sense, and still doesn't address the fact that none of them have anything to do with Microsoft.
Pretty fair comparison. I find Vue is easier to learn
Then you're working on a React/Redux project with terrible design, sorry. Don't blame the tools for the wielder's poor choices.
No, but the entire purpose of TypeScript is to be JavaScript with added syntax for types. It's not trying to branch off into a completely separate language, but rather follows latest ECMAScript specifications closely. Flow opts to use comments for interpreter compatibility, but both exist for the same reason of adding type safety to JS.
why?
How about... const test = require("tape"); const Board = require("../src/board"); test("board.placeRandomTile()", t =&gt; { const BOARD_WIDTH = 4; const TOTAL_CELLS = BOARD_WIDTH*BOARD_WIDTH; const b = new Board(BOARD_WIDTH); for (let i = TOTAL_CELLS; i&gt;0; i--) { t.equal(b.placeRandomTile(), true); t.equal(b.getEmptyTilePositions().length, i - 1); } t.equal(b.placeRandomTile(), false); t.equal(b.getEmptyTilePositions().length, 0); t.end(); }); Why the changes? 1. Calculate the total number of cells from the test constants, **not** from the board properties. Why? Because that way if for whatever reason the board properties are not correct, the test will fail as it should. 2. Separate the final test. Tests should be "as stupid as possible" to ensure they don't introduce errors themselves. So, while your logic was not wrong _per se_, this makes it much more explicit. We now know that we test TOTAL_CELL times for `true` and one extra time for `false`. 3. Test against explicit fixed values, not against calculated ones. That is, we now test against `true` and `false` explicitly, against `0` in the final test for empty positions. As much as we can, it is good to test against such values. Calculating values and testing against them is again, open to introducing errors in the logic of the test itself. Of course we could go and make it absolutely stupid and unroll the loop. I know some people that might advice doing that. I... well, I think it is a fair compromise in this case. Unrolling the loop may be just too much. As presented above, I know the test still contains some logic (like testing against `i-1`), but well, you have to keep a balance. I'm pondering this variation... for (let i = TOTAL_CELLS; i&gt;0; i--) { t.equal(b.getEmptyTilePositions().length, i); t.equal(b.placeRandomTile(), true); } t.equal(b.getEmptyTilePositions().length, 0); t.equal(b.placeRandomTile(), false); t.equal(b.getEmptyTilePositions().length, 0); ...which is not very different, but simplifies the `-1` in the test for empty positions.
As an inexperienced dev working on my first thicc-app with backbonejs, I certainly do not take gruntwork stuff for granted. When I see a sensible design pattern or a bold decision baked into a framework, I know there is a whole history of design and reason to back it up and to learn from. I just sit there, marveling at an actualized best practice, and I visualize the weeks of trial and error and suffering I dodged by merely observing this one "good" choice. Now when I read (quoted from BackboneJS.org): &gt; In an ecosystem where overarching, decides-everything-for-you frameworks are commonplace, and many libraries require your site to be reorganized to suit their look, feel, and default behavior — Backbone should continue to be a tool that gives you the freedom to design the full experience of your web application. I say, fuuuuuck that. It's no effort at all to adapt to the ideals of a proven methodology. Both React and Vue look awesome, but I honestly don't know which one I want to pick first for my next pet project.
The reason a language exists does not make any difference to what it actually is. C++'s purpose was to be C with classes but no one in their right mind would claim that C++ is C. Same with preprocessors like SCSS. TypeScript is a separate language by virtue of being, well, not JavaScript. It - cannot run in any modern, standard JavaScript interpreter - has an optional but entirely different typing discipline (properly written TypeScript should be strongly, statically typed) Type safety is not a fancy little bit of syntactic sugar like spread operators or arrow functions. The way a language handles types is a core part of its design.
Thank you for your response Tim. I'm very honored :) Your suggestions are very valuable, I will definitely look into them. See you maybe at frontendlove in February!
Probably without.
the datetimes will actually be in the following format: "2017-12-20 08:48:54"
Aaand thats the exact difference that matters. For me, JSX and React have the feeling, that the app was supposed to be written and modelled in them. So, whatever you use, use the thning, which can well express your mind of what you want to achieve. Everything else are only technical details. 
Do you happen to have a resource for the "hand-hold" but for React's source code?
How is that unbelievable? Everyday I watch colleagues jump trough gigantic generics and interface hoops to build 'modular' and composable software in C#, all because they are stuck in this classical OOP/Static mindset. If I had to fight with a language that much I would stop being a developer pretty fast.
The GitHub itself says inspired by Redux. If anyone doesn't know what they are talking about is you. Try getting out more.
serious question when do you need to use generators?
I wouldn't recommend having a key be named "Date". Assuming you had an array of objects like this: ``` const arr = [ {x:1, ts: '2017-12-20 08:48:54'}, {x:2, ts: '2017-12-20 08:48:54'}, {x:3, ts: '2017-12-20 08:48:54'} ] ``` You can run the following to convert it to ISO-8601 and get an array where each number of milliseconds since January 1, 1970, 00:00:00 UTC. Then you can just compare the appropriate values. `arr.map(({ts}) =&gt; Date.parse(ts.replace(' ', 'T')))`
I've mainly developed with React, but chose Vue for a small internal project. And you're very right; Could pick it up in a day or two. Some googling, a couple of stackoverflow questions and I was there. Really pleasant to use. And the implementation with VueX+Vue-router was 100x more human than Redux + React-router, damn. 
 const a = {x:1, y:2, z:3}; Object.keys(a).forEach((key) =&gt; { console.log(key, a[key]); });
Nice read, thanks. The author focused on TypeScript. I wonder what about other transpiling languages like ELM and PureScript. Where are those in in 2017 and where there will be in 2018?
One interesting example is the [`ember-concurrency`](https://ember-concurrency.com/#/docs/introduction) library, which uses them to model asynchronous tasks that can have multiple steps. The ability to cancel the task during some async action or restart it can be really helpful in avoiding some cases where a promise resolved that you don’t care about anymore. 
Lmao what? How does a library being inspired by another mean they're the same thing and everyone calls then the same name? The fact that it's _inspired by_ clearly shows they're different! Also are you ever going to address the fact that neither Redux (by someone at Facebook), RxJS (by Reactive Elements) nor ngrx (by a couple of individuals) have _anything at all_ to do with Microsoft?
I'd concentrate on the functional aspects of Angular and React, learn rxjs which is a major part of Angular then confirm what you've learnt by incorporating it into a React project via redux-observable. Also can be done vice versa with Redux and ngrx. This will give you a great understanding of functional technologies and the advanced workings of Angular/ React. 
Yeah, agreed. FP isn't a magic pill. It's just a nice tool to use when it suits the job. Just today I had to filter out a bunch of garbage from some RDS instance another company had set up, and pipe the filtered/cleaned data into another DB. Knowing a bit about FP really helped out with that, but I think people generally just have the attitude that whatever they're currently in to is **the only way**. &gt; The hardest problem in computer science is not being an opinionated jerk about everything.
&gt; Not to say plenty wouldn't construct an internal DOM representation Let's hope Microsoft doesn't port WPF to WebAssembly 
Sure, but there's also sites that don't have products but still needs to support it, i.e. goverments
aysnc await feels easier in most situations... though where would it be good idea to use generator and yield
Interesting, would you mind sharing your use case for this?
Just like you can use TypeScript with React yet it's much more common to use TypeScript with Angular.
I know that’s not completely what you are looking for, but we collect language-only news here (and reddit is one of my sources): * Twitter (everything): https://twitter.com/esnextnews * Weekly email newsletter (5 links): http://esnextnews.com The advantage is indeed that the volume is much easier to handle than if you included everything related to JavaScript.
If you want my honest opinion- I prefer React due to its explicitness (more typing) over Vue. Verbosity with React is a good thing.. the way it forces you to manually wire everything together makes the data flow more readable, predictable, and easier to maintain in the long run-- especially for complex apps. Complex Apps with Vue becomes a pain when you are NOT using a store library; e.g. Vuex. This of course is true for React as well.. but I find that React is more durable/easier to maintain before the need of a store library.
If you browse around in that same repo, he also made a "hand-hold" one for React!
I suppose in time browsers will be better optimising es2016 et al. Some of it may end up being faster than es5. 
No Backbone either.
I suppose it depends on what features you were after. Most of es2015 is supported now but modules are still in a painful area. Webpack is going to be pretty essential for a long while. 
I know, right? Facebook is one of the biggest apps out there in terms of sheer size (of users, data, state, you name it). If it's good enough for Facebook to use in production it's far, _far_ more than good enough for your little app.
This is not JavaScript, it's Java, a whole different language. Validating Bitcoin should be handled server side, but maybe there's a way to validate it on the browser.
Is there a possibility to make this work via PHP? I'm using the CURL "normal" way to get the images, but that needs an OAUTH. function rudr_instagram_api_curl_connect( $api_url ){ $connection_c = curl_init(); // initializing curl_setopt( $connection_c, CURLOPT_URL, $api_url ); // API URL to connect curl_setopt( $connection_c, CURLOPT_RETURNTRANSFER, 1 ); // return the result, do not print curl_setopt( $connection_c, CURLOPT_TIMEOUT, 20 ); $json_return = curl_exec( $connection_c ); // connect and get json data curl_close( $connection_c ); // close connection return json_decode( $json_return ); // decode and return } Or can I only do this via javascript?
graphql clients can offer state management in place of redux already
not sure what you did but it's working fine now
Redux sagas are a pretty good use case; https://redux-saga.js.org/docs/basics/UsingSagaHelpers.html. Its quite a logical way of making requests that then tie in to state updates in the application.
https://arstechnica.com/gaming/2016/04/analysis-the-division-may-need-complete-rewrite-to-fix-hacking-problems/ inspired by this article a long time, i was pondering if a trusted client network model could work the aim is to off load as much work from the server to the client as possible perhaps for a turn based browser game where speed isnt a concern, a block-chain like method for client to report in-game events and for other clients to verify can work
As previously said, Object.entries. If this is for some reason not available to you, say, browser compat, you could also do the following: Object.keys(object).map(function(key) { return [key, object[key]]; });
Dude you are just plain wrong at this point. https://www.hanselman.com/blog/ReactiveExtensionsRxIsNowOpenSource.aspx Stop embarrassing yourself.
With the provided middleware (redux-iterate) everything you yield will be dispatched (except `undefined`) and you always get a new state
Watching this should give you a good intro to Sagas. https://youtu.be/xDuwrtwYHu8 They are an incredibly powerful concept. 
Here you go, from the State of JS 2017 survey: http://stateofjs.com/2017/flavors/results/
does it make more sense to use generator there instead of async await?
Explicitly send no cache headers from server, however this bad practice. What you are doing with the version is correct, but you should get it automated.
If you are using a server-side language like php or C# then you can write those times using the server-side language. Set up a config somewhere that holds the latest date value, and then you only have to change it in one place. If you are using a client side build process like nodejs, you could add a task in the build process to update that value on every build. 
No experience in js ML/AI, but why not just take this chance to learn python? The ML learning libraries there are industry standard and once you know how to code, switching languages is quite simple.
Very informative and surprisingly hilarious. I wish I could write stuff like that. "Fatty boomsticks". Haven't heard that in years.
I like that idea too but, for now I wanna stick with js and since it has got better than before. Why not js? And I need more practice with js. I am neither that good with js. So switching to Python will be a bit difficult for me right now
You could also use HTML5 manifest (or service workers), where cache get updated when manifest file is updated (which will leave you only 1 file to actually modify) https://www.html5rocks.com/en/tutorials/appcache/beginner/ But as others say, i would go with automated process of adding timestamps or versions to files.
I figured I might be pushing my luck with the help I could get. Strange that the bot tutorials I watched didn't mention the server part.
If I were in your shoes, I'd use a UserScript to filter the posts based on keyword(s). If I'm not mistaken, Reddit RES has that feature. Otherwise look in /r/greasemonkey or /r/userscripts.
&gt; I notice that elm is the highest This is mostly because the Elm community prefers [large amounts of vertical space](https://github.com/elm-lang/html/blob/master/src/Html/Events.elm) so a sizeable fraction of those lines are going to be shorter than in other languages. Elm isn't the most concise language since it's focus on simplicity means more boilerplate and less magic but if the comparison was source bytes instead of source lines I expect it'd be on-par with the js solutions.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [elm-lang/html/.../**Events.elm** (master → 76b8876)](https://github.com/elm-lang/html/blob/76b88764512b0469182717609406fa9a224d253d/src/Html/Events.elm) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drip4d4.)^.
Does Vue work well with typescript? Is hyperscript/JSX/template code well typed compared to React?
Your “JSX is great” examples are always so contrived, and fail to show how awful it gets at scale. Every time I see you come in to trash Vue you throw around crap buzzwords, and include unrealistic and overly simple JSX snippets that no one would actually use in an application. Your arguments are tired. All your gushing about functional paradigms, immutable data, one-way flow, etc are a means to an end that React practically forces on you because it has no out-of-the-box optimizations or dependency tracking. You can post all the little examples in the world on Reddit, but I have real-world experience writing large apps with both Vue and React, and the more I have to scale a React app the more it became clear that React does not have developer happiness in mind, and just wants to appeal to functional purists who like to write overly-verbose and complicated code. 
 myObject.map(obj =&gt; obj.Y); Returns `[ 2, 5, 8 ]` Your expected output `[ Y:2, Y:5, Y:8 ]` doesn't really make sense. You can't have an object where every index is `Y`.
&gt; unrealistic and overly simple JSX snippets that no one would actually use in an application Basic composition and referring to objects is unrealistic. I got you. &gt; are a means to an end that React practically forces on you Um, nope, that's how javascript works. The whole point of React is not making you adhere to arbitrary rules set by a framework. &gt; but I have real-world experience writing large apps with both Vue and React Good for you. So do i, working with Vue since its inception and with React at least long enough to know its benefits. Real world applications out on both. The difference seems to be, whenever someone makes an actual argument, showing real world examples and explaining why, as opposed to "this is better/easier/... because i say so", your type gets offended or personal. 
@azium or maybe this one https://stackoverflow.com/questions/47877343/socket-io-with-express-js-routes
You can write fully type-checked JS with Typescript types in comments by using `// @ts-check` Typescript is pretty much JS with types, just like Flow. The few extra bits of language like namespaces and enums are fairly trivial sugar.
One core concern that will have impact in your layout is having or not a fullstack. Something ilke this I am playing with this approach in my latest project: @project |--domain | |--clients | |--app/browser | |--app/backend | |--src/ |--app |-- browser 
myObject.map( obj =&gt; ({ Y : obj.Y }) )
Anyone here using the new version of Flash?
Using some new features object deconstruction and new notations in ECMAScript 2015 var myObject = [ {X:1, Y:2, Z:3}, {X:4, Y:5, Z:6}, {X:7, Y:8, Z:9}] var filtered = myObject .reduce((acc, {Y}) =&gt; acc.concat([{Y}]), []);
I think there's a difference between pure and practical functional programming. Taking a deep dive into functional programming with Haskell, studying category theory and knowing all the jargon probably won't yield you much practical skills in most real-world work environments. It ends up being theoretical computer science that has little to do with 99% of the software development jobs. However, I firmly believe everyone who works with JavaScript should learn how to take advantage of first-class functions, because they are one of the most powerful features of the language. It takes less than half an hour to wrap your head around the idea of currying and function composition, but you can use them to write very readable, declarative and reusable code. Of course you can go over the top and I've looked at some Ramda chains for 15 minutes without understanding what the hell is going on, but overall people shouldn't be afraid to use functions as return type beyond callbacks.
I think in those cases the barriers are more economic than technical. JS is plenty fast enough to build some pretty amazing games. Not on the level of current console/PC games, but enough that you wouldn't be able to fund its development due to lack of web game profitability.
New here- love jsx I think since I don’t have the history to gnash against it easier for me to just see the utility and not be turned off by it. Had a pretty good discussion with some experienced devs last night about it and I seem to be the only one who likes jsx, their concerns were more aesthetic than anything, but even with cue templating you’re running into putting JavaScript into html/html looking things. I don’t see a meaningful difference.
Why use reduce and concat over map? 
&gt; Basic composition and referring to objects is unrealistic. I got you. No, showing a snippet of mapping over an array containing `[1,2,3]` and spitting out some list items. Yes, you are showing the fundamentals of JSX, but what your failing to show is how it gets harder and harder to reason about at scale. &gt; showing real world examples and explaining why But you don't do this — you post contrived examples and say "this is better". If you do provide a reason, you throw in some buzzwords like "functional", "declarative", or "immutable" which hold no real weight because you don't compare it to Vue's more pragmatic, and less verbose ways of doing the same thing.
map would work. It would be cleaner as well. 
There are sooooo many blog posts just like this one. What does this one contribute with that makes it stand out from the myriad of other ones? 
&gt; Complex Apps with Vue becomes a pain when you are NOT using a store library Why though? Both libraries can pass data up and down. Also, technically as soon you you start to feel the "I wish I was using a store" pain...you should be using a store. ;)
Actually, Angular 2+ is almost exclusively based on [observables](https://en.wikipedia.org/wiki/Functional_reactive_programming).
Great talking point in selling the framework though.
Using @ts-check is not the same thing as writing TypeScript IMO And writing TypeScript is very much not like writing Flow. One of the cornerstones of determining that a piece of code is valid X-language is that it is compilable/runnable by any full implementation of X-language's spec. No _JavaScript_ VM, even the ones that have the latest of latest of latest ES2018+ proposals, can run this very basic line of TypeScript: declare var foo: any; When they can, then you can tell me that they're the same language.
OP should do the exact opposite: send correct cache headers. Cache-Control: public, max-age=604800, must-revalidate This way the result will be cached by the browser, but it'll always ask for a 304 or new content, without the need to append a version to the URL.
Thanks!
Fair enough - I didn't know that, mostly because the [maintainers](https://github.com/ReactiveX) of the current active RxJS line don't have/mention any Microsoft affiliation
it works yes, would I use it, not really...
Look into date-fns. Great library for stuff like this.
100% agree, I actually enjoy Vuex. Redux was the most complicated thing to get my head around, not even mentioning the complexity when you involve React router, authentication, and persistent data. 
This is not recommended. It will iterate over all inherited properties. You can put a check in using hasOwnProperty but there are better answers in the other comments.
I despise Redux. I opt for MobX whenever I can, when using React. Redux is massively overkill for anything I've seen so far. Everything is more clear and transparent when using MobX... Though I'm sure some will say otherwise. 
What annoys me is that, while most React articles explore new React approaches, most Vue articles are "hi, please switch from React to Vue!". I have nothing against Vue, but Vue article writers remind of those guys knocking at my door and "Excuse Me Sir, Do You Have a Moment to Talk About Jesus Christ?".
How stable is this? I tried AirConsole quite some time ago, but honestly it just worked terribly.
I expected comments to be a lot more controversial, then I remembered back then JavaScript was new and interesting... Basically the web assembly of the 90s. 
Currently I am using a straight html with JavaScript.
Make sure $.ajax ‘dataType’ matches response from server. Eg if expecting json from server use $.ajax({ url: ‘/path’, dataType: ‘json’...
&gt; Not on the level of current console/PC games And there you have it. WASM programmers want Star Wars Battlefront III in the browser. Again, the speed of JS isn't often an issue (though it can be) it's the speed of the DOM. The DOM is way too slow.
Gone are the days, where you could access an OS subsystem from the browser easily, so you can write and run files with out user interaction.
The best way is to enable caching of your JS files as long as possible for better performance results and modify your build system to create unique filenames for the scripts and update them in HTML file. i.e.: scripts/foo-42.js - the web browser will fetch the new script and cache it for later. The new build retrigger these actions.
I like React more.
Or even myObject.map( {Y} =&gt; ({Y}) ); 
Using ts-check is using types in comments like with Flow. Similarly, this line of Flow code: `var foo: any` will not run in a browser.
squarespace.com 
lol. Well, yeah, good luck funding a Battlefront for the browser even with fully-operational WASM. You could certainly do a Monument Valley in the browser now, but even that would be difficult to justify economically.
You can checkout code academy for a very good introduction to html, css and JavaScript. They let you work through different features and examples. Also, I would be happy to help with project too. Just PM with the details of features and details you have in mind and we can take it from there
Trends between the two years would be nice - also percentages in the charts. I went ahead and compared some of the frameworks in a Google Sheets. https://docs.google.com/spreadsheets/d/1dISJMPWi23xwAatCyRGS-VJTPqU-V3w6IFl0YBJfqXY/edit?usp=sharing Some interesting trends in awareness.
I mean... did you look at the library I linked to? The whole concept of a task that can be cancelled or restarted without finishing the entire task can’t be built using just async/await along. You need some mechanism to consume steps in the task until completion or cancellation, in which case you actually don’t want to go through all the steps. 
Do you mean the elapsed time from the earliest time in the array to the latest? If so, parse the dates as another commenter has said, find the latest and the earliest, and subtract them. If you meant the total time elapsed by the items combined, they are moments in time, not durations - they cannot be summed.
I could help you create the website. I am currently on christmas vacation from my bachelor in computer science. Would love to have a project to work on.
Sony and Microsoft and Valve wouldn't be happy, but do you think EA enjoys sharing their profits with them? That's why they sunk a ton of money trying to build Origin. And what about programming for cross-compatibility, which is a huge pain? If game developers can circumvent having to pay the publishing platforms, or only have to build their game once, instead of four times; if engine developers like Unreal or Naughty Dog can become publishers because suddenly publishing is super easy ... I expect these companies could suddenly carve a much larger piece of the cake for themselves. Not to mention, smart phones have proven that gaming is super popular, it's just the buy-in on a console or a gaming PC is too high for most people. But throw a game on a phone or in a browser, and suddenly the audience is an order of magnitude larger. And yes you can make a lot of money now, but gaming is always in an arms race. Anyway, that's the dream for WASM, as I understand it. The first dream, anyway. There will be others.
Battlefront maybe not, but WebGL has already proven you can put some graphics intensive things in the browser. https://developer.mozilla.org/en-US/docs/Web/Demos_of_open_web_technologies
Hi /u/feature_creep, please refrain from personal attacks. Thank you.
Hey, I wrote a small tool that helps developers to use the Speech Recognition API and support an external fallback like AWS Lex or Google cloud speech. In that way you can save money and use native recognition when it's possible https://github.com/puemos/speechless
&gt;Honestly, I still code like an old granny too with ES5. But hearing you moaning about Javascript evolving to add new toys that are really beneficial to the language? Come on grandad. So, where were you when I WAS GETTING PERSONALLY ATTACKED?!?! WTF??? You're singling me out here, and that's just not right. 
can i test?
They are not exactly the same. XKCD refers to this: https://en.wikipedia.org/wiki/Technical_standard The article from OP refers to this: https://en.wikipedia.org/wiki/Standard_library They have as much in common as "Firefox" and "foxhole".
It's not feasible for us to read every comment on every post. If you feel a comment is out-of-line, please report it.
Hi /u/garrehsponges, please refrain from personal attacks. Thank you.
Are observables now a first class javascript concept? Is rxjs still useful, or does the native implementation do the trick?
Thanks, thats a super clear explanation!
So far as I'm aware, there are no plans to add it to the core spec, so you need to use the `rxjs` library, as you mention. Really though, Observables are more of a pattern, where `rxjs` is just the most popular implementation. And it comes out of the box with a ton of utility methods, like `withLatestFrom()`, so that's what I personally recommend.
BTW, you can (and should) use portions of lodash. So for example, if you just need `_.pick(obj, 'key')` you'd put `import pick from 'lodash/pick'` into your app, then webpack will only include that one lodash function in your bundle. It is NOT recommended to include the whole thing in your app.
Appropriate username.
The title of this talk is actually "WebAssembly and the Future Of Javascript". It's also not even primarily about web development. It's about WASM in node. The click bait title is doing a disservice because it perpetuates the biggest point of confusion I've seen regarding WASM. **WASM is not a JavaScript replacement**. I can think of three reasons to use WASM: 1. For performance-critical code that is too inefficient, or is affecting UX in pure JS. 2. To avoid porting code that is already written in a compiled language. 3. To avoid a post-install build step in node for packages using native modules (ex. sqlite3 or uws). It should be noted that in this case there's a performance *loss* instead of a gain. If your code doesn't fit into one of those categories, then there's a pretty good chance using WASM is just adding complexity with no actual benefit.
To be fair, it's just the syntax aesthetic that I don't care for. Even regular handlebars templating can look pretty janky to me, as well as Angulars NG attributes and declarations all over the templating. 
Oh, I didn't click your link, sorry. I got excited and didn't realize you were pointing to rxjs
Hi /u/feature_creep, please don't report comments just because they disagree with you. That is report abuse and can get you banned site-wide from reddit. If you need clarification on what a "personal attack" is, I'll gladly provide some links, but none of your recent reports are personal attacks, and it's a drain on moderator resources. Thank you.
Okay, "Adolf".
So something like gulp to slam the js files together and minify them. I am a C/SQL guy that is teaching myself front-end work so my knowledge of javascript and the supporting tools is a a mess of bits and bobs. 
Thanks. It made for a nice read over lunch. It was a begeinner's look at something that was written for beginners.
Is that considered kosher using the must-revalidate? This is not a slammed server. Our company is less than 5000 employees and less than half even use the system for anything other than time clocks. This means that IIS has a very low load. On the other side. I don't want to learn a bad habit just to make it easier for me to not have to manually put a suffix on the end of the script tag. I always work towards the Bus Principal. If I get hit by a bus tomorrow how easy is it for the next person to pick up my work.
trying to gauge interest as I have seen a few Parcel posts recently ... how well does it work with React ? 
It doesn't need an oauth, it's just denying requests from unknown referrers. You can just fork the repo and switch the referer check flag off and then it should work for you. 
What I've done when attempting to solve this is having the bundler emit a build hash for each build, which makes it entirely painless. Whatever approach you choose should at least have the ability to automate this task, build time.
Based on the link it appears to be very react (react banner 3/4ths the size of my screen) specific, is that the case?
ya .. most articles I have seen have React + Parcel .. I have to juggle a weekend to play with Parcel + Angular before proceeding further...
[removed]
Erm, I did not mean to offend or attack anyone, I was merely expressing an outdated view by saying "grandad" - if that's what your referring to. Giving a warning over that seems a bit dramatic when it was clearly meant in a tongue in cheek way, especially as I referred to myself as a "granny" - hardly an attack. Jeez, what has Javascript subreddit become where you get warned over such trivial expressions like that. :/
I'm recoding [Habbo](https://habbo.com) from Flash to WebGL with a Node.js, Socket.io server, aswell as their CMS to React instead of Angular. I'll switch to PostreSQL later on, just using MySQL for now because the Workbench makes life easier in terms of development. Also migrating to [redux-saga](https://github.com/redux-saga/redux-saga) and maybe [redux-first-router](https://github.com/faceyspacey/redux-first-router) https://gitlab.com/marcus-sa/stormcms-engine
It was great at doing single table things. But the moment I needed it to reason about joins/relations it just fell apart. I would have to specify in the models themselves to query the relations eagerly, which I didn’t always want to do, or write the join sql myself which kinda defeats the purpose of an orm. And all the docs I read seemed to be constantly out of date. 
&gt; Noone said JS doesn't have types I get that. I was talking about compiling the VM's internal representations of the types to WASM, though it was extremely short sighted regardless: &gt; It's weakly and dynamically typed though You got me there. It's still possible, just implausible. There would be a large overhead to porting all / most of the VM's dynamic functionality that I overlooked and oversimplified above. Plus you miss out on many JIT dynamic optimizations. My fault, totally impractical
I am, in fact, stupid. Thanks!
Is this 2012? How about you don’t use jQuery to check the value of a checkbox???
If you want to easily control your content and don't want or need anything too fancy like messaging boards or any other web application (calendar, user inactive image gallery) this is your best option. Squarespace may even offer these solutions now for a price.
I’d love to work on something like this. Let me know if you’d like to collaborate.
Downvoting because StandardJS
There are a lot of frameworks and dependencies that already either include the entire thing or a large portion of it. While it’s good practice to only import what you need, you are likely not saving any room in your app right now.
I put my js files in an AWS bucket, and in a folder name equal to that commit sha1 of the build. I then update my index.html to look at the latest version and cache it for only 300s. This way people can only have an old version for max 5 minutes.
It probably doesn’t matter if youre using react or not 
Probably cannot get away with AWS, this company is very 'everything in house and on premise', but I might be able to duplicate the idea.
From your experience (if you touched React), what are some of the things that Vue.js does better than React? Just out of curiousity 
Aws works for small shops, but if your company is big enough to have its own infrastructure I’m sure you have a cdn to upload js files.
Never thought about my own cdn. I am new to the front end thing without the full framework of ASP.Net - back-end and embedded developer. Being a one-person developer shop if it does pop on my radar I don't really have and direct peers to bang ideas off.
You are if you're selective of what dependencies you include. Most decent libraries don't include ALL of lodash.
I remember seeing this here a couple of months ago. It won't probably get much attention this time either, but judging by the source code, it looks like a lot of fun was had writing this :)
Hmmm that's unfortunate... Although I think it's still in pretty early development so I hope things will be added often. Have you found any alternatives for TypeORM, that I could look into?
It should be like this setInterval(withdot, 1000); Or setInterval(function() { withdot(); }, 1000); I can see that you are going to have other problems though - you're probably going to want to have something more like toggleDot() - instead of having 2 timers that (basically) start at the same time and execute at the same time. 
*Blinking text is frowned upon by several accessibility standards*
What's wrong with StandardJS? (I know nothing about it.)
Hi everyone, I jammed last night on an alternative approach to Redux (for React apps) I'd love some feedback on. The API is heavily borrowed from redux, react-redux, and redux-observable. This is just an experiment; just playing around with some ideas and getting a feel for how all of these libraries work under the hood and with each other. You can find a very simple example app using it here: https://codesandbox.io/s/1wnzn6623j Source code here: https://github.com/neezer/quinn Big difference from redux, redux-react, &amp; redux-observable: - No HOCs: using render props (vs redux-react) ... still using context, though - Action "redispatches" operate per-action and not on the action stream itself: this means you don't have to context switch between state updates and action redispatches. Observables are still the expected return value. (vs redux-observable) - State updates are an array of functions using Ramda lenses. There's no top-level grouping per-se (like you'd use combineReducers with), but you can still shape state however you want, or extract the handlers. (vs redux) - The store in context knows how to make an action, so you can dispatch an actionName with optional payload directly on the store. You control this function (my current implementation was modelled after FSA). This also largely negates the need for action creators as far as I can tell. Things missing - no middleware (though I don't imagine it would be very hard to add) - ???
Vue as an Angular clone is a valid criticism, however I think there are a few important points you are missing. First is that it preserved the popular Angular 1.x syntax, while fixing a lot of the problems under the hood (such as performance). With Angular now on the radically different 4.x, there is some comfort in the familiarity Vue offers. Plus I personally find this syntax to be very simple, straightforward, and easier to work with.
Um.. when you are expecting a `null` or `undefined` as a possible value you have to catch. When you are dealing expecting objects, its easiest to do something like this: const there = document.querySelector("#ThisDoesn'tExist"); if (!there) { alert("What did you expect?"); } https://www.sitepoint.com/javascript-truthy-falsy/
This was on hacker news last week and I believe the top comment had something to do with how terribly naive and sales brochure-y all of these quotes are. Indeed, read them. They’re ridiculous. 
&gt; Have you found any alternatives for TypeORM, that I could look into? Nothing TS specific. To the point where I've considered writing my own, though I'm sure it would just end up in the Pile of Forgotten Projects after a month or so :)
TL;DR: Use `value != null`. It checks for both `null` and `undefined` in one step. In my mind, there are different levels of checking whether something exists: 0) `'property' in object` - Returns true if the property exists at all, even if it's undefined or null. 1) `object.property !== undefined` - Returns true if the property exists and is not undefined. Still returns true for null. 2) `object.property != null` - Return true if the property exists and is not undefined or null. Still returns true for empty strings. 3) `!!object.property` - Returns true if the property exists and is "truthy", so even 0 and empty strings will return false. From my experience, level 2 is usually the sweet spot. Oftentimes, things like empty strings or 0 will be valid values, so level 3 is too strict. On the other hand, levels 0 and 1 are usually too loose (you don't want nulls or undefineds in your program).
Check for it if you ever think a certain function might be passed undefined or null. If you have a text input component, your submit event handler should check for edge cases. If you have a a click handler on a button to close a dropdown, checking for edge cases on the event doesn’t really add anything. You could also check for all three at once because all are falsy values. func(val) { if(val) console.log(val)}
I don't need JS. CSS animation would be sufficient.
I think your problem is using "setInterval" instead of "setTimeout". Surely you want the "switch" to the other state to happen once right?
Semicolons
The great thing about JavaScript is that in the end, when it’s all packaged/bundled/uplifted/minified down, it’s just a JavaScript file! You just need to put it somewhere for people to access :)
Streaming market data, specifically volume across 2 equities :) ... However I have ran into this issue in the past with IOT devices and have always wanted to know the best way to go about it.
Popular [Quara answer] (https://www.quora.com/Where-can-I-learn-artificial-intelligence-in-JavaScript) Large Mooc lists: https://github.com/ossu/computer-science https://github.com/ossu/data-science
I think I prefer Angular (at least for the projects I'm working on), but there's no question that Angular has more magic than React. DI? Hell, the whole angular-cli, while great, is basically Webpack + Magic.
Are you performing this check because some library or API returns both null and undefined as possible values or are you writing code that returns these two values? The majority of the time an API would return one or the other but not both and for those cases you should check the one you need. If you’re writing code you should strive, similarly, to only use one or the other unless you really need both values because otherwise that code is more difficult to use and understand.
That is some terrible advice to be spouting off in an advice thread. It's fine if it works for you, but you shouldn't encourage newbies to keep things flat and avoid hierarchy. Architecture is about hierarchy and abstraction, and it's best if that architecture is roughly captured in the source code organization. At the very least, it's by far the most standard approach, is important when architecture affects how teams integrate.
There is a reason there is no &lt;blink&gt; tag.
Well - there was - it was deprecated I know why there isn't one - so manually creating blinking text seems, I don't know, rude
I want to use it in my next project. I stopped doing small projects because it took to long to setup front end developing. I hope parcel will fix this for me. 
btw, examples are here: https://enkimute.github.io/ganja.js/examples/coffeeshop.html
DI is only magic if you have no idea how it works.
I liked Vue due to its simplicity. I’m sure React will be simple too after you learned it. But Vue was simple (and powerful) from the beginning, the learning curve is much smaller. When I analysed the ecosystem, I knew that Vue is smaller and does not have a big company behind it, but at the end of the day it was still our option. The context of the decision was: we have to develop this product and we don’t have time. So the technology that made us more efficient in less time was chosen. Regarding the nitty gritty of what Vue does better than React, there are better sources for that then me (including Vue website). When comparing both one will do better in few cases and other in others. But I don’t think is a showstopper nor big differences. We are very happy with Vue.
If you encode it as a string into the JSON to begin with, it'll come back out as a string, and then you can put it in a float, double, or whatever other type you need.
This is a json string returned from a 3rd party so I don't have control over that. Is there any type of formatting param I can pass into JSON.parse() to achieve a long decimal display? Alternatively, is there an ng2+ view binding that I can use to display the number as a long decimal, like {{ toLongDecimal(myExponentialNumber }}
I'm fairly sure this is a JavaScript thing, not a JSON thing. If you just open up you dev tools and try assigning some long decimals to variables, you'll notice they get rounded or exponentised too. If you just want to display all the 0s, you want to use [`toFixed()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed), which will give you a string with up to 20 decimal places. 
Sorry, needs more Aurelia. 
I don't think Parcel will help if you're too lazy to clone a configuration for Webpack/Gulp/Grunt.
Would be interesting to see you take this all the way and implement it into something simple like a chat page or something like that. Good hacking my friend.
Those gifs... Maaan
Here's a really horrible solution: Accept the JSON as a string, not JSON directly. Do a regex search and change the values to a string instead of float by manually adding quotes around each one. Parse the new string with JSON.parse(). This is wrong and fragile for so many reasons, but if you need that precision, you're going to have to do some kind of craziness. Another bad solution? Use emscripten to turn a C JSON parser into Javascript that either does the above, or uses a large number library of some sort to keep the precision you require. I'm not even sure the large number library thing would possible from emscripten, for that matter. Third bad solution? A server-side JSON pre-processor that does the float-to-string conversion for you and acts as an intermediary between your client and their API.
I believe it's better to use `typeof value !== 'undefined'` because if value is not actually defined comparison with it will cause errors. Otherwise what u/s_tec said is the proper way.
I believe it's better to use `typeof value !== 'undefined'` because if `value` is not actually defined any comparison using it will cause errors. Otherwise what u/s_tec said is the proper way.
Is it just me on mobile, or is that code very hard to read?
That's a good point, since the `typeof` operator will not throw an error for non-existent variables. If you are are checking for properties (like `x.y`), then either way will work. Missing properties don't throw errors the way missing variables do.
I would just say if (value) { // do stuff } because '' || false // false null || false // false undefined || false //false
Honestly, you should never get yourself into a scenario where you're checking for a variable that you never actually declared (or declared in a different scope). Just use a linter.
Count me in :)
I am also new in Web Dev. Seriously speaking, I worked a lot in meteor (blaze). It uses a templating solution like Handlebars and that looks really ugly to me. I love JSX more with every passing day.
I agree! Linters solve all the most common problems. However, there are cases where you need to check for certain global variables like `window`, which exist on some platforms (browsers) but not others (node.js).
Using it in an internal application and loving it thus far, my big gripe is that the documentation is too simplified and not enough information is given on extra configuration, leading to looking through the source to learn what you can do 
Pretty similar to Lodash's [isNil](https://github.com/lodash/lodash/blob/master/isNil.js#L20), just the opposite using `value == null`.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lodash/lodash/.../**isNil.js#L20** (master → b2ea6b1)](https://github.com/lodash/lodash/blob/b2ea6b1cd251796dcb5f9700c4911a7b6223920b/isNil.js#L20) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
what instead?
https://github.com/MikeMcl/decimal.js/
Yeah your browser is crashing. This code sets infinite methods. Intervals that set intervals that set intervals ..... 
nice share
I would not call it it pretty early development, its two years active development and already quite close to 1.0.0. Its feature-complete and there are only few features left in the backlog. Also Im not sure when @rco8786 last time used it, but docs are up to date.
Its designed to work better then anything else with multiple table things. There are multiple ways working with relations and joins other exist ORMs cannot even dream about. Did you create a github issue for the question you had? Im afraid you have such feelings because of lack of time and efforts spending working with typeorm.
I created a course that compared react / vue/ angular, which created the same project in all 3. React was by far the worst experience.
As usually, it's mostly about what you and your team are used to. For example, Angular's official styleguide encourages flat architecture because tweaking logic and making changes to components does not require moving files around just to keep the "architecture". The whole idea is that you _can_ keep your architecture clean and organized without using _folders_. Hierarchy can be expressed via filename as well. For exampe, compare he following to strucures. /app /components /reservation /canceled /styles.css /template.html /index.js /complete /styles.css /template.html /index.js /draft /styles.css /template.html /index.js /app /canceled-reservation.styles.css /canceled-reservation.template.html /canceled-reservation.component.js /complete-reservation.styles.css /complete-reservation.template.html /complete-reseravtion.component.js /draft-reservation.styles.css /draft-reservation.template.html /draft-reservation.component.js 
The focus is meant to be on AppRun, ignore everything else. 
I like it better because I basically don't have to touch HTML. JSX is basically putting HTML into your js, which is great.
https://github.com/josdejong/lossless-json
This is my go-to pattern.
Start small, plan, and grow. These libraries have hundreds (thousands?) of hours of work. They didn't just create it in a couple of days. I mean, I guess they could sometimes, but generally they have experience. You need to set your focus, build something small, and figure out the direction from there. Thinking of programming an entire library without knowing how to create a tiny function is not a great idea.
This is indeed a very open ended question. One thing I'd like to point out is that the JS skill of the developer in your example isn't what makes that library advanced or noteworthy. What makes it stand out is that the developer combined an in-depth knowledge of raster image formats with JavaScript. That is, the project is impressive because the developer applied deep domain knowledge from a particular topic. JavaScript is just a vessel for that knowledge to materialize. So if you want to write advanced software, I suggest you pick a topic you'd like to dive into. Graphics? Networking? Finance? Something else? Once you have a goal and some programming fundamentals, you would be amazed how well you can move forward with a healthy dose of determination and a learning mindset
a weak point of mine i’ve been trying to get better at. Read 1/3 on mobile, bookmarked for tomorrow and upvoted. thanks 
no its not your mobile, my theory is that op is a lizard
Gulp isn’t necessary. Just make a shellscript. Or better yet since you’re a C guy just make a makefile :D
This isn't so much a question about JS as it is a general question about how do you solve difficult problems. The person that wrote the image processing lib you referenced probably knew a lot about image processing to begin with. It's easy enough to find books for difficult subject matter. If you understand your problem enough to know that it can be solved with math, then software is a viable solution. From there, you can probably do the math in any programming language, though some may be better suited than others. JS isn't likely to be the best choice for image processing if speed is a factor. And Jimp as an example seems to be one of the slower JS image processing libs available (http://sharp.dimens.io/en/stable/performance/). However, I understand that JS does have access to computer on the GPU via WebGL (http://gpu.rocks/), so maybe it's plenty capable. I'm not an authority on that subject. Once you know the theory and the math, you'll need to be familiar with the programming language to find the most efficient solution. If you are just getting started in programming, your question is akin to asking a surgeon how he knows how to remove a tumor without killing the patient. Years of learning across multiple disciplines in a persistent effort to achieve that objective. But he probably started by reading about it. So my advice to you is to start Googling about your subject matter. The more you learn, the more you'll know to search for. Don't expect to be able to achieve the equivalent of an image processing library anytime soon. It takes lots of patients and persistence. And keep looking to people more knowledgeable than you for guidance. There will be lots of course correction and frustration along the way. Good luck!
The long story short is you research and study, like you would for any CS specialization. Image processing involves topics like DSP, matrix algebra, file format specs, etc. Having a CS background can probably help with figuring out what to research, but given the amount of information available online, it isn't really as mandatory as having the drive and discipline to jump on the deep end of the learning pool. Having a strong math foundation will give you a big head-start with many "advanced" CS fields, but which part of mathematics is used depends on the field. Again, not mandatory, but learning the math as you go can be challenging. The "doing X in JS with no dependencies" isn't really relevant. In fact, don't even think about JS. Learning JS is child's play compared to the amount of research you need to do to obtain a working understanding of a specialized field. In fact, learning a language other than JS might be the easiest way to get a foothold on a topic, simply because the field might have a more mature ecosystem there (e.g. a lot of ML work happens in Python, and in DSP, languages like matlab are commonly used, etc). &gt; Are there books Yes. Check your local university/college bookstore. Chances are they have courses for the field you want, and that the book for that course will be available for purchase. You can even search for books on amazon. (and, no, they're not cheap.) Other material exists too, and there may even be some learning material geared towards newbies, but for the most part, when you're working towards a specialization, it's all on you to go hunt things down and keep at it until all the hard work bears fruit.
Can you show a usage example? Also, can you show how this compares to other approaches for avoiding callback hell (which is what I understand to be the overall goal that lead us to async/await)? Consider an approach like [async waterfall](https://caolan.github.io/async/docs.html#waterfall), which allows you to declare callback functions in the order they are executed.
This would make a great blog post. 
Shit is like minified or something, that's wild
Probably your best best: https://web.chemdoodle.com/about/ Some other related: https://arpitnarechania.github.io/d3-molecule/ https://github.com/robertvunabandi/shape-lewis https://github.com/3dmol/3Dmol.js A commercial product with similar capabilities: https://www.chemaxon.com/products/marvin-js 
This is just a proof that we can archive nearly zero overhead when implement async/await feature. This is not a library nor a compiler yet. So you cann't use it directly. Gopherjs currently use closure and state manchine to implement golang's async. If it switched to this approach, it's performance will improve largely.
Nice content... Can you tell me something.. How did you highlighted some particular words on website.. Like in the beginning.. Let and const.. Those were in some different style than other text.. Can you tell me how to get that on website?! 
I wonder how this might improve the Typescript compiler. I tried the original example on https://www.typescriptlang.org/play/ and the results sucked.
It was a problem on the demo. I used an old version of the library.
&gt; I would not call it it pretty early development, its two years active development and already quite close to 1.0.0. Figured as it was not yet at V1.0 that it wasn't in development for long. Should have looked through it's history before making such statements.
Good to know it does indeed work great with multiple tables!
This might not improve Typescript compiler. It isn't compatible with ES spec which requires async function call return a Promise.
You jump from something that is written in less than 50 lines of code and that can stand on my mobile phone screen to something I need to scroll. So one huge thing you did not take into account is code readability which is lot better with async/await. 80% of my time is reading code so I prefer readable code over code that has good performances. One other note is that chrome javascript engine improved a lot recently to support async/await syntax. The new engine shipped in recent release has some optimisations about try/catch syntax which was a huge performance killer before. My point is that these two pieces of code don't aim to be run on the same environment. So comparing timings on the same environment is pointless in my mind.
 code { padding: 2px 4px; color: #d14; background-color: #f7f7f9; border: 1px solid #e1e1e8; }
Thanks
Not only would it be sufficient, it's the perfect use case for CSS animation. Here, OP, I made a quick demo for you. https://codepen.io/anon/pen/wpWNpg
That's very useful. Thanks heaps for those links. esnextnews especially!
Yeah I considered keyword filtering, but the problem there is that you'd filter posts that are anti-framework simply because they mentioned the name of a framework as something they are against.
Your function parameter shouldn't be a string. 
A wordpress plugin called "Crayon Syntax Highlighter" takes care of the highlighting. It generates CSS like the one below, and you have nothing to do with it. Sometimes it's a bit off, and the weakness of this syntax highlighter is that it assumes all code blocks are in JavaScript.
Yes, I agree readability is important, too. But we can get both readability and performance because we have compiler. Try-catch in older chrome is an optimize killer. But there is work-around, we can split block in try-catch into separated functions. I pointed that other approaches doesn't perform well when call async function that actually doesn't do any async things. Include the native implementation of browsers. Consider this case: If you want to write a parser for async stream which has a interface `{next_char(): number}`, and there is a always sync implementation. So I don't know what last paragraph of your comment says.
To see if onclick works you can do alert('hi'). To make your code work: 1 the function parameter shouldn't be between quotes (it should not be a string) 2 your getElementById parameter should be a string (between quotes)
I know it's a bit overwhelming. Already working on a better UX for browsing recordings.
Nice collection! saved for later :)
Also the parameter for getElementByID() needs to be a string.
an empty string not usually semantically equivalent to null. Often an empty string is a perfectly valid value.
I'm not a networking expert, but I deal with HTTP a lot (professionally), and I can't see any reason why must-revalidate should be bad practice in this case or in general. I'm using it in my personal projects whenever required and the companies I've worked for do the same. There's really no other way around caching. Either you change the URL like you did or by going the webpack-way and putting a hash in the filename, or you send a Cache-Control header that tells the client what you want it to do (or not want it to do). It's certainly not a bad habit, although of course it's not the best solution either. But I'd say it's the best in your case, unless you can easily manipulate the filenames; then I'd go for hash in filename. As long as that's not an option, must-revalidate or no-cache will be your best solution. Speaking of getting hit by a bus: what do you consider more likely? People looking at caching headers or people realizing they need to change the URL manually?
Maybe a missing piece of the puzzle is that it's not client-side Javascript, which works in a browser's DOM, it's Node.js code, which works more like a traditional programming language and can open and read binary files?
You might look up how data-sets in HTML5 work as an alternative way to pass data to a function, since you may run into an issue of "why does my onclick function always execute immediately?"
Thank you.
Sigh. Talk about looking for a new solution when an old friend can provide just as well.
Thanks man! 
There are two important qualities that help me write large software quickly: * predictability - You should have some idea of what the code is doing by simply reading the code. If you cannot achieve this your code design principles are wrong. Don't be clever. * simplicity - This is the principle most people get wrong. Simplicity is a fancy word that means the fewest code instructions possible. It doesn't mean hiding behind a bunch of abstractions and tech debt. When performed correctly simplicity always reinforces predictability. You should think of software and software features as a form of debt. You own 100% of that debt in your application including all dependencies and all their defects. As far as getting started I follow these steps: 1. Produce a minimum viable interface. At first the most immediately available is `console.log()`. 2. Produce a minimum viable concept. Prove a single feature of your code works in a single way one library at a time. 3. Improve upon your interface so that the application is easier to work with whether it is a web tool or a command line tool. 4. Gradually work out your requirements one by one. 5. As you work out each requirement include copious amounts of tests. The goal of testing is to identify defects and prevent regression later on. Don't waste time hoping to get more out of testing. 6. Once the application is built it is probably riddled with bugs. Stress the hell out of it with and try to make it fail. Invite other people to use it and see if they can make it fail. Your biggest enemies and allies in this are time and practice. Put fingers on keyboard and start figuring it out. You just have to solve the problems as you encounter them. Everything takes time, but you will get much faster at this before the application is complete.
Where's your Developer Tools/Console? You've got a browser which wants to help you but you're not letting it. Hit F12. The answer to your immediate problem is, you're looking for an element called &lt;whatever's in the variable called 'work'&gt; and that variable doesn't exist. Presumably you wanted to change the colour of an element which is actually called 'work'. So just use 'work'.
In addition to other comments here, find out how to use your browser's Developer tools, or at least find the Javascript Console. They *will* contain errors that will help you identify your mistakes and this help you learn :)
JS in the browser and JS in node are the exact same language, just with different native APIs available. You can work with binary data just fine in either.
How do you open a jpeg file in client-side javascript?
Using the [File API](https://developer.mozilla.org/en-US/docs/Web/API/File)
When will this land on normal Safari? Any educated guesses?
Nice work! I'm not working on flow-based programming, but more tree-based configuration. I'm very interested in how to create a UI like that -- so I am going to peek once in a while.
Anders already figured this out for Typescript. I'd just see how he did it.
macOS 10.14 (the next major release) is when Apple likes to roll out new major features; then again, this isn't user-facing, so they may do it sooner.
We use. https://github.com/MikeMcl/bignumber.js/
You might be interested in [Advent of Code](http://adventofcode.com/).
Rough.js was really a new and interesting thing for me, that's why I shared it with everyone!
&gt; Without being a programmer and being willing to spend hours reading code, the only way is through trial-and-error. And that'll be quicker anyhow. Good stuff, thanks!
Code wars is pretty neat too
I just added a typescript version to compare. https://github.com/hackwaly/blog/issues/3#issuecomment-353363399
Thank you. Glad you like it
This question is not really about JavaScript... it's about any programming language. Really broad question. No JS article will tell you this. The answer, in some way, is the practices we find in Software Engineering. Specifically on your case: start with [software requirements](https://en.wikipedia.org/wiki/Software_requirements) (what do you want your software do to?), then [interface design](https://en.wikipedia.org/wiki/User_interface_design) (how can you software can expose it to the user?), and then [software architecture](https://en.wikipedia.org/wiki/Software_architecture) (how do we break the functionalities into parts?). After answering these three questions, then you will start writing code.
I meant that while browsers are catching up to ES2016, Babel will already support ES2019 or something like it.
Is there a way that I'm unaware of to do joins that doesn't involve dropping into `createQueryBuilder`? Every example/doc/etc does that.
It's done through a [babel plugin](https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage). Found on this [JSX section](https://vuejs.org/v2/guide/render-function.html#JSX) in the vue docs. Can't say how long this has existed in the docs though
 &lt;html&gt; &lt;head&gt; &lt;script&gt; function changeColor(colorValue) { document.getElementById('work').style.color = colorValue; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p id="work"&gt;Something&lt;/p&gt; &lt;button onclick="changeColor('red')"&gt;RED&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
I also came from jQuery world into the mess they made JavaScript development to become. I suffered a lot. Yes, Angular is very restrictive, but this is good for large teams or corporative software. React is much more open, and JSX ain't that bad once you "get the feel" of it. Vue is pretty much React with Angular templates, and other structural differences, you may like it or not. I suggest you to make a small project with each one, and try to make some stuff in all of them. Eventually you'll like one more than the others, but let it be *your personal decision*... not what someone else says.
Just fyi - /u/pleerock is the maintainer of TypeORM. I 100% applaud his efforts, but may want to take his over the top praise of his own lib with a grain of salt.
/r/dailyprogrammer codewars.com hackerearth.com codeabbey.com
The Promise implementation seems like quite acceptable overhead for operations that are typically async and bottlenecked by network or disk I/O. Five million iterations took 650 milliseconds? Or did I misread that? 
If you don't want to use `createQueryBuilder` it means you use `find` methods, e.g. `repository.find`, if you use those methods and what to know how to load relations so you seek answer in [find options documentation](http://typeorm.io/#/find-options). The way of working with relations incomparable with any other javascript/typescript ORMs. With TypeORM its easy and it provides lot of flexibility to users. Example: create many-to-many relation is extremely easy and working with it as well. Another example? Eager relations, lazy relations, "relation id functionality" lot of customization you can apply, etc. Another example? How you can create powerful queries with relations using QueryBuilder. TypeORM allows you to perform cross-databases, cross-schema squeries with cross-joins and cross-table requests in a single connection, which is really complex functionality I don't know what other complete ORM provides you such functionality. You can tell me that Im putting salt again, but its a fact that TypeORM provides lot of serious features you cannot find in other JavaScript/TypeScript ORMs.
RE: JSX You don't _have_ to use JSX with React. It translates to API calls you can use instead of the JSX syntax. See: [React Without JSX](https://reactjs.org/docs/react-without-jsx.html)
So PWAs will be fully supported once it is released? 
&gt; repository.find It looks like the find options have received a major overhaul since I last used TORM (maybe 6-8 months ago?). That does seem like a better way to do things, thanks for pointing it out. I would still love to see the querying mechanisms take advantage of type safety the same way that the create mechanisms do. Something like `userRepository.join(Profile).findWhere(...)`. That's contrived, but you get the gist. &gt; lazy relations This is what I had the most problems with. If I did something like `user = userRepository.find({id: 1})` then `user.profile` would just be undefined and AFAIK there was no way to load it lazily at this point without doing `user.profile = profileRepository.find(...)`. 
This breaks if 0 is a valid value
Something wrong? I own a platform in which an individual can input an email address and discover if any dating network accounts are attached to the submitted address. I'm trying to add a few dating networks which protect their sign up/forgot password with captcha. Anyways, I switched to SlimerJS/Firefox and Google Recaptcha is rendering. I'm still interested to figure out why I'm unable to render using CapserJS/PhantomJS though as I have more experience with these.
One possible explanation for this is that Youtube has an event handler attached to these types of links (is TSL an actual youtube term?) and it's not attached dynamically. So when you manually duplicate the element, the event that normally grabs the link, stops execution, and jumps the video forward instead of treating it like a normal link doesn't exist and therefore the browser treats it like just that, a normal link. If this is the case, then you probably can't do what you're thinking of, unless you can somehow dig through all of youtube's minified code and figure out how to reattach the same event handler. Or go work for youtube ;)
CAPTCHA: Completely Automated Test for Telling Computers and Humans Apart. The whole point of a CAPTCHA is to prevent bots from accessing the resource.
They have a version without standardJS listed at the top of the page (ESLint + airbnb only) https://www.npmjs.com/package/eslint-config-airbnb-bundle 
Anything on the process object? Http requests? Also, run strict to cut access to global through the this keyword...
You really notice the difference on a big project. If something is hard to do in Angular or React, odds on you need to find the idiomatic way to do it and your code will benefit from doing so. Angular is more of a learning curve because it's a complete framework whereas React is just a view library. &gt; I was trying to generating some code in the component.ts but I couldnt use the method outside angular and you can't use script in angular Not 100% sure what you're trying to do here. If the code needs to be used in more than one component, put it in a service. If your component needs to call 'up' to a containing component, pass a handler in. Pseudocode-ish / Angular 1-ish example: class TodoList { } class Todo { remove() { this.onRemove(); } } angular.component('Todo', { controller: Todo, bindings: { onRemove: '&amp;' } }); // inside TodoList's template... &lt;Todo ng-repeat="todo in todos" on-remove="this.remove(todo)" /&gt;
Why do you use a while loop instead of a for loop ? And why do your counter start at 10 ? :) 1) You are trying to increment a list (animals ++) which should explain why you have an error. You can only increment a number and in your example, you want to increment a "counter" which is a number that gives the index of the element you want to retrieve (to access the first animal, then the second ...) 2) The alert method take one parameters that will be shown on the alert box. You don't need to update your "animals" list, just to give alert the string you want to show. Example with while : var i=0 while(i &lt; 4) { alert("Awesome " + animal[i]); i += 1; } Example with for : for(var i=0; i&lt;animals.length; i++) { alert("Awesome " + animals[i]); } Example with forEach method : animals.forEach(function(animal) { alert("Awesome " + animal); } 
Fantastic, never thought that I'd live to see the day! That makes it slightly less painful that Apple doesn't allow for other browser engines on iOS.
Missing a semicolon on alert (animals[0] = "Awesome" + animals[0]); This gives me an alert: var animals = ["Cat", "Fish", "Dog", "Dinosaur"]; var Numbers = 10 while (Numbers &lt; 14) { alert (animals[0] = "Awesome" + animals[0]); Numbers++; animals++; }
also if you want to display awesomecat, then awesomfish and so on, the index in animal[0] needs to a variable.
Totally agree. 
spend 5 years programming every day in javascript. right now you don't even know what you don't know. only experience changes that.
I miss some things like operator overloading and types, but I use typescript so it's a bit better :) but JavaScript is quite nice nowadays, especially with node and electron.
I've heard arguments on both sides of the coin, ultimately I agree with you, but I may be a little biased since I use JS.
But... but... the bad parts! Type coercion! And... and... weeeeird inheritance model.... And... and... this! My favorite: JavaScript sucks! No, I don't care about ES6. You can't even call that JavaScript anymore. You can't just add new features to a language and call it the same language!
Hi /u/D14RAP, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/ClayArcher23, For javascript help, please visit /r/LearnJavascript. Thank you!
C# and Java are similar and comparable. Python is not. I'm really puzzled by your listing that as a language that requires "2-3x times as much" code as equivalent in Javascript. Python has a reputation of being terse and expressive. Javascript can be written elegantly, but it requires a very particular coding style to do so. Elegant Javascript is accomplished using as much functional coding style as is practical. That style isn't always practical though and avoiding callback hell, nested scope pyramid-of-doom, and lots and lots of superfluous punctuation is a constant challenge with JS.
http://codewars.com
If you want to compare javascript and python - then you better be talking about async python, because that's the only functional comparison. Async python doesn't hold a candle to javascript and is even less expressive
Yes, if you only use async/await to deal with big IO. But what about my example? A async char stream is very efficient
Yeah defo. But as we saw, es2015 was by far the biggest changes. I think es2016 had 2 new things? Maybe 3?? As we move on, there’ll be fewer core things to cover. But Babel will be around for a long time yet I agree. 
&gt;Facebook put to rest developers’ last major hangup this year by getting rid of their license’s patent clause. TIL. that's surprising.
I think a lot of the anti-Javascript crowd are paranoid about JS encroaching onto their turf. The most common complaint seems to be that if you coerce an integer into a string it behaves like a string. It's just a wilful misunderstanding of the syntax.
interesting...
In essence a program language is just a way to express logic in a human comprehensible way and any modern language does the job. But since JS is the only option on the client, is blazing fast and has a excellent server environment, supports modules and types, allows for any programming style (OO, functional, imperative). Why go elsewhere?
Agree, JS specially ES6 JS is so powerful, it has so many interesting patterns. 
&gt;As usually, it's mostly about what you and your team are used to. Totally right :) It's interesting you invoke the Angular styleguide, because that's where I get my approach too. The Angular style guide does *not* discourage using folders. They do encourage having descriptive file names (of which I'm a huge fan), but they also recommend keeping them in feature folders. &gt;Why? Names of folders and files should clearly convey their intent. For example, `app/heroes/hero-list.component.ts` may contain a component that manages a list of heroes. &gt;Do make locating code intuitive, simple and fast. &gt;Why? To work efficiently you must be able to find files quickly, especially when you do not know (or do not remember) the file names. Keeping related files near each other in an intuitive location saves time. A descriptive folder structure makes a world of difference to you and the people who come after you. [Selected quotes from the Angular styleguide](https://angular.io/guide/styleguide) So, applying the styleguide to your example we'd get: /app /canceled-reservation /canceled-reservation.styles.css /canceled-reservation.template.html /canceled-reservation.component.js /complete-reservation /complete-reservation.styles.css /complete-reservation.template.html /complete-reseravtion.component.js /draft-reservation /draft-reservation.styles.css /draft-reservation.template.html /draft-reservation.component.js
Short response : It depends There is no absolute answer. It will depend on your project, your personal preferences, ... The question alone doesn't make a lot of sense :)
For those of us that feel taxed by learning new tools and techniques i can see it being a burden -- but for the rest of us, having options when a framework, tool, or technique falls short feels great. The shit they complain about are what i love about the platform. 
&gt;DI is only magic if you have no idea how it works. Isn't that true of all magic? It ceases being magic once you understand all the moving parts. Or are you saying that React has some qualitatively different "magic"? Things that, even if you understand how they work still retain the appearance of magic? If so, interested in hearing what you'd say, always like hearing new perspectives.
"But since JS is the only option on the client" Er, are you sure about that statement Sir?
If we're talking web client yes. And JS is the only language with viable cross-client options.
Yeah, I realised it probably meant web-client. My bad.
Javascript is a language well suited for writing applications that's not well suited for maintaining old application code. The reason Java and C# are so verbose is not for you, it's for the next engineer that inherits your project after you've left for another job.
Joy is a strong word. Javascript mostly gets out of your way and lets you bang out slopping prototypes really quickly. Working with JSON APIs is obviously simple and straightforward which is nice. However the language itself is a complete mess. ES6's new features are useful, but the new syntax options are a trainwreck, IMO. Going from one project with a certain set of syntax conventions to another can look like an entirely different language. A lot of the generally accepted conventions make code harder to read (removing parens, removing semicolons, fat arrow abuse). Slap Typescript or something on top of it to get some basic build time type safety checks adds another layer of syntax gore to an already syntactically messy language. So I guess I'd sum up my opinion of JS as such. Making prototypes is awesome in JS. Making production software is hard.
Here's a few pointers for getting started on nodejs production setups: * `pm2` package: https://www.npmjs.com/package/pm2 * learn to use `nginx` If your react app is all static assets (an index.html and a minified js file), you should not use nodejs to serve it. Instead consider install and setup nginx (useful even you do have a nodejs server running). For example, a guide can be found here: https://www.nginx.com/resources/admin-guide/serving-static-content/ If your application utilizes client-side routing like react-router, you may need specific rewrite configurations on nginx to rewrite requests to any uri to index.html and handle over routing to your js scripts (one possible solution: https://stackoverflow.com/questions/7027636/nginx-send-all-requests-to-a-single-html-page)
There are several usable to-JS languages and Wasm is now supported by all evergreen browsers (Edge, Firefox, Chrome, and Safari).
What's wrong with hanging out bro? Sipping on a brewski and chillaxing? Gimmie 5 right? 
&gt; A lot of the generally accepted conventions these days make code way harder to read (removing parens, removing semicolons, fat arrow abuse). Since when are these generally accepted? It seems like Prettier is by far the most-used style guide / code formatter, and it defaults to using semicolons. Not sure what you're getting at with removing parens either. Maybe parens in single-arg arrow functions? On that note, who says "fat arrow functions"? That has no meaning outside of CoffeeScript. There are no "skinny arrow functions" in JavaScript. They are just "arrow functions". It seems like you're arguing against CoffeeScript, not ES6 ¯\_(ツ)_/¯
The amount of free time contributed making the language more enjoyable to use / more powerful is huge.
&gt; wilful misunderstanding of the syntax. TROOOTH If you're American in England, you don't complain about people driving on the wrong side. You either figure out how it works, or you go the hell back home. Either learn how type coercion works, or why `NaN != NaN` and use it to your advantage, or stop complaining about it and just stick with your Java.
What's the problem with hangouts? IMO it does what it needs to do... I text my fambly, ocassionally call them, from pc or phone. If you're talking about relative features, I dunno how much thats worth as I'm not sure it was ever billed as the be-all end-all everything chat. discord/slack are better, sure, but that's certainly comparing the offroad capability of a Kia Rio vs a Humvee
LOL!!! same shit got said about php LOL!!!
But... Php bad
Try debugging a javascript product written by someone else using some wizbang technique to encapsulate their JS in some strange way using their own _ global declaration or overriding your standard prototypes, yeah.. JS can get you in some harry places depending on how old the source you're dealing with, it can leave you with that horrible hang-nail experience you don't want to ever forget.. Even the new`ish JS stuff.. NPM's package.lock is a very recent thing.. it was not always turned on by default, and not everyone knew to even use npm shrink-wrap. Long story shot.. their is a lot of fix, and JS is honestly now turning into a transpiled language. So much of what people love about new JS still needs to support older browsers, and only way that is done is via transpilation. Until the browsers &amp; node support this stuff 100% out of the box through &amp; through like css3 to a large degree is now.. it's the wild-wild-west.
I recall Anders discussing all of the edge cases their work handles. I assume that explains the complexity. 
Well, they transpile to JS. And ES6 async, types and modules needs bundling and transpilinig also, but aren't we splitting hairs here? Yes, it will be interesting to see where Wasm goes. Maybe it will fuel up the client war again and JS will again be the only one standing when the smoke dissipate :-)
Making a product which can survive refactoring in JS is a very complicated situation w/o typescript, it's why a lot of large projects are ditching ES6 like crazy and moving to typescript, if they stay strict, the JS can be refactored later with the right tooling w/o ginormous ego implosions at midnight when you realize you totally bombed your code trying to refactor it and don't know wtf you did wrong. Typescript kinda eliminates this frustration. I hate typescript.. but.. it has it's strengths..
you're invoking changeColor and assigning the result to 'onclick'. ``` &lt;button onclick="()=&gt;changeColor('red')"&gt;RED&lt;/button&gt; ```