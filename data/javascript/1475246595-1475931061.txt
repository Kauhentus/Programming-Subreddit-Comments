You could write it with say nightmare js and run it on a server 
Typescript looks very much like C# minus the .Net API stack. Computer science education is still very steeped in the OOP paradigm ready to produce C#, Java, or C++ developers as industry demands like a developer production factory. Web technologies and functional language paradigms are extra-curricular activities not considered a primary focus on CS education. He/she doesn't explicitly say it, but what they really mean is something like: *Software developers who don't share my education and experience fail to perceive software correctly*. Yes, it is a form of ethnocentricity, and yes it is extremely prevalent among developers who come into JavaScript only as a secondary technology and only because their jobs depend upon it.
Called it.
this has been my experience as well. the tooling needs are entirely different for an app being worked on by ~50+ developers. You might not enjoy the safety that typescript supposedly provides for the additional noise but most of the time you deal with because you know the person in the next cube who you know doesn't have a clue is constrained enough by it that the resulting code is of some level quality that you dont want to go postal when you have to maintain it. It's a value proposition for the long term projects. not the macaroni and cheese fan website you threw out last weekend. 
jQuery is a library for browser normalization (and events, Ajax, animation...). 
That sounds exhausting.
2) Because JS's OO model is fundamentally different from C++/C#/Java and the trend now is moving more to a functional programming approach because it makes a bit more sense. 3) To avoid unnecessary overhead. There is no need to use React when working on something that's meant to be very simple. In the Java world, why would I use Spring to write a basic REST API when I could just write a basic servlet?
You should consider a JS Framework for structuring your app (react.js being my favorite). As far as Ajax goes, jQuery is still a good option for making the requests. It's not that complicated, just read the docs and you'll probably be fine
I guess I dont know where to start the main ones are so large
this is not for node or production sites, it's a Dev tool. anyway, if you pass a json string through JSON.parse, you're sure of evaluating paths to primitive types...
&gt;I don't think people don't want to use JavaScript in a OO manner. Well that's quite an assumption. React itself is based around OO; @see React.createClass. Functional programming is amazing. It has made great contributions to JS in general, and to React (and the larger React ecosystem) in particular. But functional programming and object-orient programming do not have to be mutually exclusive. React, despite having strong functional underpinnings, is a perfect example. P.S. Yes, I know about pure function components, but the vast majority of React codebases use React.createClass or the ES6 equivalent.
I'm okay with breaking compatibility. I understand TC39 has to worry about it because we can't control the browser used, but we can control what version of Node.js we use, so Node TSC should be less worried about breaking compatibility for the sake of moving forward.
Wow; I like your core point but I feel like I want to downvote you for the obnoxious bolding and overly-passionate (for a simple software tooling discussion) response.
Visual Studio Code.
Vue 2 is great, I've played around with it quite a bit lately – I can highly recommend it over Angular 2. In my day job we use React (although we're waiting for Inferno 1.0 to be released, then my company will move to that).
Pre-release library woes.
Go with polymer. Like vue but based on web standards. Im much happier with polymer vs angular 1.5.
So like polymer? I need to try out vue on some project.
I would almost certainly say OAuth 2.0 is a fine solution here. You can't really overkill security, IMO. 
I've never had this experience. The docs for 2.x may be a bit in flux because it's still beta, but other than that, they're pretty solid. Perhaps you misread or you didn't see [the 2.0 change list](https://github.com/vuejs/vue/issues/2873). For example, in 1.x, there was a 'ready' hook, but in 2.x that has changed to 'mounted'
JSON web token is the best library for this.
On top of: &gt;A few months ago I decided to try my hand at web development. lol.
I'll say the same thing I say every time this project is posted here: it's literally just a wrapper around `document.execCommand('copy')`. Every other byte in this 70 KB project are weird APIs you probably don't want to use (want to replace variables with hidden inputs and encode your logic in data attributes? done.), meta bloat (because what's a "modern" project without 5 times more metadata than source code), and a fallback to selecting the text and asking you to copy it manually, which would actually be a legitimate addition except that it's one line too: `prompt('Press Ctrl+C to copy', text)`. Somebody, IMO, is a bit too desperate for GitHub fame.
The funny thing is... I really agree with you on these points. I just did that to test it out because thats kind a the way of that other group. The less you know the more loudly you bash some nice value bringing problem solving open source project (like Angular2). I always just take a step back and let it go but maybe it would also not be bad to express the opinion from the other side on their terms. That means to bash the ignorance and shortsightedness nice in the open. Then again u would be right if you said I went down to that level which I am fighting against.
The final release is almost here. It seems like the last RC was already released few days ago.
Ugh, so tired of these "I have poor JS fundamentals, but let me write an article complaining about how crazy the front-end ecosystem is".
In particular it's having trouble with this line: "var style = document.getElementById('style-link').textContent;" the error is "null is not an object(evaluating document.getElementByID('style-link').textContent"
I think its best practice to store them in cookies. Also, there are some instances where you may need to include jti, if lets say, you need to whitelist/blacklist tokens. This would require a storage/lookup of the jti's
https://github.com/ReactTraining/react-router/blob/v4/README.md
got it to work, thank you :) 
perhaps obvious question: does the game you're using have a public api for the market? it would be a lot cheaper to collect data from that. if not, maybe talk to the site's owner about exposing a few endpoints for non-sensitive data, or about how to properly use the encrypted protocol for logging in to get the data from your script.
oh sure, i don't mean to come off as a downer; i think it's a really neat application of eval. however, if you could figure out a way to replace it, you might have a library that a lot of people would be interested in for things other than devtools :)
Awesome, exactly what I was after, thanks!
Makes sense, thanks! 
At work we've developed a really big application with Vue 1.x, and we're really happy with it. A lot of coders didn't have lots of experience with the modern front-end ecosystem apart from some angular 1.x, and we found that Vue was really easy to pick up and get productive with. 2.0 was in alpha when we began the project which is unfortunate since having the performance boost of a VDom would have been pretty nice, but refactoring to 2.0 shouldn't take as long as, say, refactoring from angular 1.x to 2.x, even more since we agreed not to do any 2-way binding from the start (we really didn't miss this feature btw)... Also, we've started using Vuex for a closely related app. We didn't want to impose the technical overhead of adding it from the beginning in the other project, but we've been surprised at how easy it is to grasp and how it allows you to design even more predictable components. If I could do it all again I would use it from the start. That said, if we had more experienced front-end developers I would probably have pushed for React (and Redux instead of Vuex) as it's not that much harder to learn but takes a bit more experience with Js. One of the main reasons to chose React over Vue is that, It doesn't impose the limitations of a templating engine / directive. For example, as opposed to "v-if render this, v-if render that, v-for render these, etc." you can just use JSX which is like small bits of Javascript controlled Html, and get all the native control structures for free, it is very liberating. Furthermore, you can have your components' description live right besides your business logic instead of in your html. React will push you to become a better developer by making you think about immutability, among other FP concepts, the ecosystem really is great, solutions for novel problems, as well as best practices and anti-patterns are easy to find, documentation is better (even though Vue's really good, I found some edge cases like deep and immediate watchers buried really deep in the api), and from a management stand point React devs are easier to come around if that's a concern. I could go on, but in the end it's up to you. Both are really great libraries and an improvement over angular.
Never used polymer. Can't say.
By the way 2.0 was released today https://github.com/vuejs/vue/releases/tag/v2.0.0
Whoever said this has probably not the slightest idea. Flow has been demonstrated to check cases TS simply couldn't. TS, at best, will reach parity with version 2.1, at least it plans to. Babel is also way ahead and consistently so for years. If you wonder why Angular struggles, it has probably more to do with React than Google, take a quick look at this: https://github.com/facebook/react/wiki/Sites-Using-React Now imagine that you wouldn't be able to compile more than a handful of these applications in TS and you get a complete picture. 
transpiling my code doesn't help me learn the context.
I watched a talk about an experiment where they put everything that wasn't UI manipulation into web workers. It made the SPA super fast and smooth on mobile. 
&gt;16 kb min+gzip &gt;26 kb (Vue + Router + Vuex) The 1.x version was 26 kb alone. It's nice to see someone actually cares about it these days.
I don't know. I said nothing about that.
As much as I love reading some angular bashing, this person's opinion is invalid because they don't have the experience level necessary to analyze a front end framework. 
You could try [restify](restify.com).
It's a lot like polymer. But instead of building on the web components standard which makes polymer really complex, it's just _inspired_ by web components. That makes it easier to use, and supports older browsers. I ported an existing webapp from polymer to vue 1 to get support for older browsers it was really easy!
Your comment reminds me of the time I used to question why people used IE instead of Firefox, when it first came out, and that I said IE would become third-rate usage in five years. It wound up being seven but I'll take it. I also said that I thought the new Chrome browser might, along with Firefox, become more important than running Windows on the desktop. I don't recall how long I said that might take. In any case, people on forums would rail against me just like you. My track record is better than yours I'm sure. 
It works on ie11+. (We tested ie10 and it worked). Older mobiles work just fine with polyfills. Its not a problem unless you want to support unsupported insecure browsers like ie9. We even mixed it with jquery in our legacy application without any issues (porting things stiep by step).
I guess I and other people responding are a little confused about what you're looking for. Could you be a little bit clearer?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/jquery] [jQuery Security - Explained](https://np.reddit.com/r/jquery/comments/559odo/jquery_security_explained/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Sure, the *basics* of auth aren't complex, but that's not how you get hacked. You get hacked because they found an exploit. &gt; It's certainly FOR authentication, but it isn't itself authentication - &gt; authentication is how and when you as the developer trust that something came from someone you already know How is this not descriptive of the problems that JWT is a direct solution for? Seriously? You're being pedantic again. &gt; I'm saying you shouldn't be responsible for handing authentication if you don't even know how it works At a development job? Maybe not. *For your own personal projects*, though? You don't have an option to not handle auth yourself. Most frequently by using a library. Not to mention, look at how many enterprise-grade applications use OAuth. Major companies rely on and maintain those libraries. You're seriously going to argue that you can create a product as safe or safer than, say, https://github.com/jaredhanson/passport-oauth2? &gt; And also simply using a library without knowing what it actually does is probably the most insecure and worst things you could do. You're orders of magnitude more likely to be exploited by your home-rolled auth. Again, *yes*, understanding what things are doing under the hood is **great**, but why reinvent the wheel at every turn? *Especially* for a personal project or small app. It's overkill, and that's not going to be the first attack vector someone looks to if they're trying to gain access to your servers. Auth and bad configs will be their first and primary target. 
I'm working on an enterprise data management application for the day job, with more than 100 people involved including app devs front and back (JS and Java), data devs who use Python, network architects, automated testers (usimg Groovy) plus QA, sales people and what have you. I'm working on the app development , ie JS and Java. On the front end we're using the ExtJS framework but I would never start a conversation about Ext on here because I know I would get shit on by the cool crowd. Exactly the same people who would slate ng2 for being "bloated". Maybe they think you can use React + Redux or Vue or insert new cool thing here for everything or you're just a dinosaur. That being said obviously the whole non backwards compatibility thing with ng2 is a pain in the ass but deal with it. And maybe that shows that ng1 wasn't that great after all if it needed a complete rewrite.
I liked it initially. But I got so many weird error messages all the time, that was difficult to solve. If course it was because of my code, but I just have a feeling that the complexity of web components makes it easier to make a mistake. Like accidentally importing the polyfill twice. That took like a week to solve...
Hi! This is a great place to get a bunch of source code for free. http://www.apress.com/ They have books that go along with the code and they are typically really well written, so I recommend them. That is what I am learning for self teaching. 
I think it's more normal to use the user's id when looking at their request. Anything else you need to know about the user, when handling their request, should be easy to lookup. 
Are you using them for JS? If so, which one(s)? They seem to have 79 JS books :O http://www.apress.com/programming/javascript 
lots of them http://passportjs.org/ is one example of something you can use
Have you given any consideration to Aurelia out curiosity?
It does serve a purpose.
FWIW I'm currently using loopback on a project and while I didn't have any part in setting the thing up, I think it does its job well and isn't really very difficult to work with.
Assuming you're using the Node AWS SDK, you just need to call s3.putObject(). See: http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#putObject-property You don't need to do anything to the file beforehand.
If I do that it just shows up as an unreadable file with no file extension or anything. data:image/jpeg;base64,/9j/4AAQSkZJRgABAQIAHAAcAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAzABywDASIAAhEBAxEB/8QAHAAAAwEBAQEBAQAAAAAAAAAAAQIDAAQFBgcI/8QATRAAAQQBAwMDAgUCBQIEAgITAQACAxEhBBIxE0FRBSJhMnEGFCOBkUKhFTNSscFi0SRD4fEHFnKC8DRTYyVzRFSDkqIXJjWTRVWywv/EABoBAQEBAQEBAQAAAAAAAAAAAAABAgMEBQb/xAAsEQEBAQABBAMAAQQCAwEBAQEAARECAxIhMQQTQVEFIjJhFCMVQnEzgUNS/9oADAMBAAIRAxEAPwDyy0Gis0E8okLC7wcr0POUtxRyiBfIwseKWHFI0N5QAqQk8UseOVu/CAn4WIOFgc0UQgGViPCJWrPKBR8o/CNoIyFLbif2R5QogqhTTgW9jylAoJ6p5WddUO6aNeEgIvGUQMIUbxhA4JJRoeFuO3KJxXycoCBjnCcFJQ/lUAyFGpTWQMIcpscd1r+EViAWm+EpGKtMVgAiNeFgb4ylspwgPLVhhYnwsChrVlOkGPmk4RIPI4R3FxJPJ5S3SYG......
&gt; restify.com Thanks for the suggestion. Restify looks great on the API side, but it seems to be missing the integrated documentation piece. If I'm reading it correctly, you can use Restify to put up your own, hand-generated, static documentation page, but it doesn't have any sort of integrated documentation. Ideally I'd like to find a framework (like Django REST Framework) where you do something like: someEndpoint = { description: 'returns a foo', path: '/foo', handler: () =&gt; ... or better yet: /* * @return {Foo} a Foo */ endpoint = { path: '/foo', handler: () =&gt; ... } and then when anyone browses /foo the framework shows them the documentation for the endpoint (because it can tell, from the request headers, that the user is browsing the API and not using it). Or failing that, at least be able to somehow auto-generate documentation at a different path (eg. /docs/foo).
React is based around OO no more or less than it is based around functional principles. The key take away here is paradigm extremism isn't worth it, mixing just the right amount of procedural, functional, and OO gives fantastic results, and JS happens to support that ideology very well. Just wanted to add this in here since it was a point worth emphasizing from /u/ghostfacedcoder's post
You're using readAsDataUrl to get the file, that's converting the contents to base64. Not sure what you need though since I don't work with file uploads much. EDIT: Maybe you just need the result? http://www.javascripture.com/FileReader
objection.js + objection-rest, objection-graphql... + some kind of access control with json web tokens. 
&gt; You got all that by me sharing an opinion that TypeScript is preferred over Flow? No, I got that from your statement &gt; from what I've seen/read the general consensus is Which shows that you are just full of it. I already talked about vote counting. &gt; I don't have time to do a thorough analysis Translation: I've got nothing but a loud mouth and my downvote button. Asshole.
Vue 2 is now released. So are the companion libraries Vue-router and Vuex. 
The result of what?
Of the FileReader.onload method. Look at the first example: var reader = new FileReader(); reader.onload = function(){ var dataURL = reader.result; var output = document.getElementById('output'); output.src = dataURL; };
Using your logic, that you don't want any bloat and anything unnecessary in your code, I think you should be questioning whether or not you really need a framework for this. If we went to the logical conclusion of minimal bloat and maximum performance you'd be making this in pure Node, not even Express. You should weigh up your options a bit rather than just going with what seems like the sensible idea, it can often be different. If you have a desire to improve your overall knowledge of Node servers then use Express or plain old Node so that you learn what's going on at a lower level. If you just need to smash out an API for a large database then maybe use a framework, otherwise I'd say just go for Express. Looking at the examples you gave in the reply to agent_epsilon I think Express is the way to go for you. Writing a RESTful API with Express is very straight forward: router.get('/some/path', (req, res) =&gt; { // your code here const response = {...}; res.send(response); }
So you think flow is more popular? It's Friday, cheer up bud. 
congratulations!
I dunno ... Terminator 2 was pretty good ...
When was the last time you tried it out? I think it could be true in the past but i saw people mentioning all kinds of things that are not true anymore, like the need to wrap bindings in &lt;span&gt; or whatever.
Interesting, what safari version can that phone use? Polymer seems to be tested on safari 7+ which is a browser ~2013. I don't own any apple phones, does that mean they don't allow people to upgrade their browsers to secure versions? EDIT: http://www.somegeekintn.com/blog/stuff/iosvers/ - if I'm reading this correctly Iphone 4 should have a fairly recent safari version. I know polymer worked on test Ipad Mini (1st gen) here when I tested.
They should have named it ReVue.
Use `parseInt` to convert to an integer.
Graph APIs are awesome, and I wish I could use a GraphQL server. However, I don't think my co-workers want to learn a whole new style of API, so to "play nice" I need to provide a REST-ful interface for them. 
If you're looking for something quick to throw together a prototype out of your own curiosity, I'd say Vue 2 should suit you just fine. Maybe even some very low-impact web apps. However don't consider it for a large scale production application. Not because of the library, but because of the ecosystem. There's still not enough quality third-party modules around. On the other hand, React has a lot of powerful, battle-tested libraries built by incredibly experienced battle-tested developers. Vue is also in a transition phase with the implementation of markup in logic vs. the old (Angular way) of logic in markup. And for some reason keeping both. This was definitely a good move. There are also breaking changes, so there will be a transition phase, so if you want to code for the future you're likely to miss out on a lot of libraries that haven't made the jump yet. Since React is no longer the underdog it's easy for people to bash on it. Also since the ecosystem around it is like a wild rainforest it's easy for people to call it "a mess". Though it's just that there are so many people using it, there's a lot out there. And a lot of it is not only very high quality, but very very useful. I'd definitely suggest going with React over Vue.
Nah, the open-source community doesn't really work the same for React as it does for any other library because the former is too heavily influenced by Facebook's way of doing things. For example, the guy who wrote Redux promotes a number of design choices solely based on the premise that you app will possibly be server rendered (see [this discussion](https://github.com/reactjs/redux/issues/776) as a very rough example). This is a huge miss when it comes to mass adoption. And I don't even want to begin talking about redux-saga and other overcomplicated monstrosities that are casualy discussed by React community like a second coming. Anyway, if it works well for you, great. But it wasn't the case in my experience.
I like Aurelia. Everyone that uses it likes it (that i've talked to). Unfortunately i feel it will be completely niche library. Why? I have no idea. Why something like Vue takes more so the another library like Aurelia i wish i knew. (not that vue is bad, i've never used it, it's just strange). It seems unless you have backing of google/FB/MS/etc. after about 2 to 3 years it's dead because the community has moved on to the next greatest thing. And even then stuff moves into pure hatred quickly. I'm all for choices but the JS ecosystem is just becoming nothing but a flavor of the month. 
&gt; To clarify, I'm familiar with Express, but Express is a generic server; you define everything in terms of "GET /foo", "PUT /foo", etc. REST frameworks let you think more in terms of "resources", so you can define a "/foo" resource and then wire up handlers for the appropriate CRUD operations. Plus they tend to provide "sugar" for parsing/stringifying incoming/outgoing JSON, simplifying URL argument parsing, etc. Why would you want to abandon the ability catch specific request types in favour of catching all request types to a URL, is there a specific need to hand multiple request types or would it not be better to have more granular control of your server? Simplifying parameters may be useful but not enough of a reason to use a framework for this sort of thing. Your parameters should be simple and well-structured enough that parsing them yourself shouldn't be a problem. &gt;So, I'm not looking for a solution from the lightest end of the spectrum (ie. raw Node or Express). I can't stress enough that Express is not the lightest end of the spectrum, far from it. You can have an Express server up and running in minutes, and that's with just js and a bit of server knowledge. If you want to make a simple server that you can build on instantly then look up Express Generator. &gt;But I'm also not looking for a solution from the heaviest end, ie. loopback (which weighs in at a whopping 123.0 MB, for a JS library!!!) It is good to avoid bringing in massive libraries when unnecessary, but you have a lot more leeway when you're doing serverside work since none of this will be downloaded by the client. &gt;I'm just looking for something in-between. It doesn't seem unreasonable to me to want a framework that provides: &gt;A) some level of "support" for generating REST-ful APIs Based on the examples you gave to agent_epsilon I'd say Express is exactly what you're looking for. Express offers all the support you need, dive right in, you'll be surprised how easy it is! &gt;B) some way (JSDoc-based or not) to auto-generate documentation for my endpoints You don't beed a framework for this and it's a separate issue. Use this: https://github.com/jsdoc3/jsdoc &gt;Babel + every plug-in I use for it = 18.5MB &gt;React + Redux + a few more plugins weighs in at 14.4MB You're comparing apples and oranges here, again size isn't as crucial in the backend (obviously still bear it in mind). I'm not really sure how else I can convince you. You want something that makes creating RESTful APIs easy, Express does that. You want something that is more reasonable in size than these API frameworks, Express is that.
My comment was in response to *ome web developers have no software engineering background* and had nothing to do with type checking.
You should add your event to the active game window, which in 99% of the cases will just be the document window. e.g. document.addEventListener('keydown', checkKeyPress); The thing to keep in mind is, key events will only be captured if the element the event listener is bound to is in focus (which I would assume your player div would almost never be). You can check out one of my projects I'm working on for a more in-depth use of key events: https://github.com/nickgcattaneo/RPG/blob/master/app/src/js/input.js Here's also a fiddle for you: https://jsfiddle.net/d2Lnatrg/
Type checking, abstract classes, interfaces, generics... More than just type checking and ES6 polyfills. I have no opinion on ng2. 
Okiedokie. Sounds like you might be under-selling the value of type-checking when you put it that way.
Woot woot, I really like Vue.js and was looking forward to the 2.0 release. Going to check it out as soon as I get home.
I don't see how the discussion you linked too is promoting anything. As I see it, Mr. Abramov is just answering at the best of his knowledge to a fairly legitimate question about best practices. He even begins by saying that the guy's idea is OK. Libraries like Redux-saga are there so you can use them if they solve a problem for you. In this particular case, you are free to continue using callbacks for async logic if you want. You don't have to use something just because the community is praising it, you won't be shamed for it. A lot of people may be solving problems you're not concerned with and like those libraries. You not getting it and thinking those libraries are "monstrosities" is not a reason to say React community is a mess. &gt; If you'll ever do some PHP website, you will also be pleasantly surprised about how well and unobtrusive Vue can be when integrating into an existing stack (this is something that React will never be able to pull off) Of course if you see React as a combo of X different libraries that you absolutely need to include in order to do things the Facebook way. Else, dropping React into your stack for a couple of components shouldn't ever be as hard as you're saying it is.
May I interrupt and recommend Elm...?
There are many, and they each use something different. In theory this is an ideal use case for Meteor.js, but I suspect you'll find a normal React stack is more popular, just as it is for team dev.
even if its true, it doesn't really matter: Most of the react ecosystem isn't even React specific and is just a functional or reactive way to pass arguments to functions that return some kind of description of the changes I want to make. Swap in React for any other declarative UI library and it will still work. Would work with properly designed stateless Web Components, too. React itself is just convenient right now, but you can drop it without losing the good things it brought to the table. Its fairly possible Observables-based solutions like Cycle.js could eventually pick up (since they are arguably better), but both newer React techniques (eg: redux-observables) and Angular 2 itself already use those, so it won't be a drastic change.
&gt; You don't have to; different programmers can use different tools and that's ok :) Just because I'm looking for a tool that isn't the kind you have used in the past, or maybe isn't the kind you'd ever want to use, doesn't mean anything's wrong. It just (maybe) means you're not the best person to help me find what I'm looking for. You are right, at the end of the day it's just my opinion on how things should be built. I could argue all day about why it's the right way to do things, my philosophy (I bet sound so pretentious right now) is that the bloat these libraries bring in outweighs the convenience they offer, especially when the convenience can almost always be made up for by smaller libraries like Express if you really need. A good example is jQuery, the convenience it offers is almost completely wiped out by ES6 features, even then it was pretty much obsolete prior to ES6, other than that it is just another layer of abstraction on top of (often) simple operations that not only adds to page weight but also often has a dramatic performance difference. Anyway that's my soap box for the day, sorry if I came on a bit strong earlier. My 2c is that you should only use these frameworks if you have to, you probably won't use half the features and for most uses it will have a negative impact on performance. Libraries like React are different because they make incredibly complex operations easy as well as *fast* since they have some of the best algorithms, API frameworks not so much because there are much smaller alternatives that make the process arguably just as easy while offering much more granular control over how your service is built.
If it's not a mess, why 2 years later we still have no consensus on pretty much anything? I don't mean to diminish the goodness of React library and some of the concepts it gave birth to (as I've already said I am greatly influenced by it), but I mostly am just trying to find a tool that gets a job done and at the moment I don't see React as being one. The whole thing feels like the school debate, somewhat educational and fun, but pragmatically meaningless because more often than not you're sunk weeks into boilerplate and various contemplations before you can build anything. I can see how this won't be a problem for huge enterprise project or somewhat better and more competent developers than me, but I don't think React as ecosystem and framework will ever work for most people.
Didn't stop TypeScript from pushing decorators pretty hard (as experimentals, but still, that was half the reason AtScript and TypeScript merged), and thats a feature that DID go back to the drawing board. If it looks like something C#/Java devs are familiar with, they'll add it, standard or not (eg: the old module system)
Are more companies using flow or typescript? 
&gt; "Not because of the library, but because of the ecosystem. There's still not enough quality third-party modules around" I'm developing a large scale production app and find that Vue suits the task just fine. As far as third-party modules go, what React has is a wasteland and a junkyard of attempts. It is the past, lets move on already. Today the JS world is finally maturing and congealing into well defined tools. Because of tools like RxJS and RethinkDB Horizon and Vue I could care less about what React thinks it has accumulated into it's black hole. There are no third-party modules for such a future, you must seize the day and not be pulled back into the wasteland. For tomorrows scalable apps Vue is perfect, in that it is the view layer and does not try to be everything else or stand in the way. I see RethinkDB Horizon, RxJS and the lightweight and robust Vue layer providing a very powerful future.
Yes and no, read [this](https://mathiasbynens.be/notes/javascript-benchmarking) for an explanation. 
You were way off on Dans comment and he has said multiple times on record that you probably don't need redux. React is already working for most people. If you need a boilerplate to get started then you are talking about build tools so you should possibly get a better grip on that. Vue is great React is great. Facebook does have a lot of influence because the react team builds react to make facebook developers lives easier. If I want to build a react app and deploy it to production right now I can create-react-app name of app npm run build and point at the bundle. If react is to complicated it's because you are making it that way. To me your points are the same as saying bootstrap is complicated because of jQuery.
And it's a higschool debate because the thread is about vue not "it's like react without all the bullshit". That's where it gets high school.
Ah I should have been more clear... Three.js is already using ES6 features like Object.assign. Features like that and modules have very clear benefits without requiring massive rewrites. I simply meant that big libraries like these are likely not going to embrace all of the new ES6 syntax, especially parts that require massive refactoring.
1) Bucklescript, Elm are FP and superior to TS (less code to write, better generated code, far stronger type checking) if you are keen to diverge from Ecmascript like TS does. If you want to stay true to JS "purity", stick to Babel (and Flow). 2) Javascript was always an OO and functional hybrid. Even a function is an object in JS ! Recently it introduced OO keywords like "class" to help out poor refugees from C#/Java that couldn't work with prototypal inheritance (syntaxic sugar over prototypal inheritance), but everything else upcoming in the language is leaning towards FP and reactive programming. 3) There is strong enthusiasm for ES6/ES7 and most libraries these days are transpiled with Babel. As more browsers integrate those features natively, the use for Babel reduces. JS developers reckon Ecmascript is the future of the language. 4) React has shown the strong benefits of a simple API that does one thing and does it well. The API surface is super small and so is the learning curve. It introduced the concept of virtual DOM that you find now in so many other solutions like Vue, Riot, Elm and so forth... It plays well out of the box with any other third party libs out there. It is more like playing legos with the ability in the future to replace a part of your stack with a newer one. A framework like Angular, Ember encompass a lot more and tie you more to an ecosystem. You accept their conventions and adhere to their rules. Any divergence is painful. On top of that Angular 2 is coming late and not offering innovative ideas. Moreover it does tend to complicate the simplest things (and try to hide them with annotations). 
This is amazing.
No.
I think what you mean is that the tooling configuration and dependencies for a large scale project in JS/TS are more complex and harder to upgrade/refactor the bigger the code base gets. Esp. when compared to another statically typed language that has a standard library, debugger, the whole nine yards (basically referring to Elm, Dart, etc.). So on the one hand, TypeScript makes it easier to work with other JS libs, but at the cost of having fragmented tooling, whereas a statically typed compile to JS language has better tooling (and let's face it better built in libs, no need for JQuery/lodash/third party test tools/module loading/whatever else JS doesn't do which is quite a bit compared to other languages) but is harder to interop with external JS libs.
And the official notes from the creator https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.5zvn2iuz4
I'm very curious to know how your polymer project is going. Have you considered a blog post or anything over a r/polymerjs?
Yes, it's generally a good idea. The main things to understand is that moving data between threads isn't instantaneous... * any object implements [`transferable`](https://developer.mozilla.org/en-US/docs/Web/API/Transferable) is the fastest way of transfering data because it relinquishes control to the destination thread. This means that the originating thread can't access the object any more. * all other objects are copied using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm), which is essentially a more advanced `JSON.stringify/parse`. So you send data between threads and the browser will clone it. I'm not sure if parsing or stringifying is blocking like `JSON s/p` but I'd guess that it would be blocking, because otherwise the next line in the JS could modify the data before it was serialized or parsed. One other minor annoyance is that there's no [native XML parsing](https://developer.mozilla.org/en-US/docs/Web/Guide/Parsing_and_serializing_XML) in workers (at least there wasn't when I last tried about a year ago). I expected not to have DOM access in a worker, but I didn't expect to not have XMLDocuments. So there's an **XML**HttpRequest object available but it can't parse XML. You'd have to use a JavaScript XML parser rather than a native one. One other thing is pooling worker threads... In [Doctored.js](http://holloway.co.nz/doctored/) I used a pool of workers, and it was based on how most machines have 4 cores available (or 4 with hyperthreading). These days there's the `navigator.hardwareConcurrency` to estimate the number of cores so you don't have to guess.
Where are you having issues with the line break? If the text areas are showing side-by-side, then you need an html tag to break to a new line such as wrapping the text areas in a div, or using &lt;br /&gt; tags.
Here is a rough example on how to setup something basic for this. This will create a Player object which you can use to create two instances of it, one for each player. Then you can use 'this' inside the Player to update its members. With this code, you could then use the Player1.moveRight() and Player2.moveRight() in your keyup to have the correct player be moved. function Player() { this.position = [0,0]; this.moveRight = function() { this.position[0] += 10; } } var Player1 = new Player(); var Player2 = new Player(); Player1.moveRight(); Player2.moveRight(); Player2.moveRight(); console.log(Player1); console.log(Player2); 
I'm confused. I'm saying that people _do_ use JavaScript in an OO manner.
Definitely. I'm talking about new projects, not everyone will rewrite the whole thing in ES6. I don't get the difficulty, though. You can use as much or as little of the new syntax as you want. For instance, you could use arrow functions and the rest keep it ES5. This way you can ease into ES6. It doesn't make a lot of sense to keep writing in ES5 because one is used to it.
I didn't get this whole "not use frameworks" thing. He is an one man team, not a technology power-house to _bring his own technology_ to the job. By the end of the project (which I'm guessing is not a personal or a recreative project), he will have acquired insanity due to the fact of the problems he had during the development. As a plus note, think about handing the project to other people, they will usually see and say "Oh, he is using [Express|Koa|Hapi|...] for the backend and [Angular|React|...] for the front-end!", if you try to get up with your own technology tons of "WTF" will be heard. Source: Been in 3 project where people did their own server framework or front-end framework, which all of them sucked because most of the time you had to fix the _frameworks_ code instead of your own code. Also, answering OP's question: I find Javascript extremely geared towards the one-man-army. You'll just need to learn the right tool for the job. Express already did great things to me, so did Mongo DB and Rethink DB. For the front-end, I'm geared towards React+Redux, since I didn't liked Angular 1. I'd also give a look at Loopback (I didn't liked it, but some friends of mine are really devotees), Meteor (prepare your wallet if you want to deliver value with this), and to be in day with your Yeoman skills.
I havent used any of those. Like I said I didnt set this thing up so my knowledge is limited on that front. However I can say that as a codemonkey that was thrown headfirst into the trenches, strongloop makes reasoning about data models really easy to and its very easy to do everything you would normally want out of your typical REST api . Having built several API's using express I will definitely be looking to loopback in the future if I want to build a typical CRUD app. 
With pure JavaScript, you may use [Storage.setItem()](https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem) and [Storage.getItem()](https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem)
Interesting... My old iphone is perhaps from around 2011-2012. Apple don't support it anymore, so I can't upgrade the OS. It's really annoying, because there aren't that many apps in the appstore I can install either, so I can hardly use the phone except for texting and calling. No security updates or anything. And I have encountered at least one ten year old with the same problem. This might not be a problem, or it's huge, depending on the web app you're building.
I've been one, and constantly learning on the job to make things easier and efficient over time. TypeScript is a godsend, it helps me keep my sanity across all the code, also lets me easily abstract the common server-client code out to maintain a consistent API. My current stack looks like Hapi + RethinkDB on the back end, (isomorphic) React + MobX on the front. I'm trying to bring in Docker into the mix to make deployments easy.
Best JS framework right now. It has massive support from Chinese company/startup. Can't wait for Weex stable release.
I think the main things I've liked about Vue so far is how you can be productive very quickly. You can just drop in the cdn and start using it without any transpiling or additional libraries. That being said, if you want to use .vue single files, you'll need different webpack loaders and configurations, but even then, having something like vue-cli really makes this process simpler for users!
I'm going to check this out. Thanks for the link.
I've been researching this subject for a couple of weeks now. The thing is, currently there is no perfect solution. Loopback for instance has very strange role system and a neglected client script. The most polished, transparent, modular and easy to use framework for building REST APIs I've found so far is [Feathers](http://feathersjs.com/). You can use it both for realtime and rest. Quite amazing. There is also [Horizon](http://horizon.io/). I believe it has a bright future, but currently its server side is not extensible, so you can't use it for anything complex. They're working on it though.
&gt; So you think flow is more popular? I wasn't aware you are dyslexic.
Getting the job done is difficult. Getting it done perfectly is impossible. I suspect a big part of getting any work done is being able to accept the bare minimum for when you need to go broke and realize you're in over your head. This applies to a lot of things, not just programming.
For the record, I don't mean build tools at all when talking about boilerplate. More like design choices and companion libraries. Clearly, we have different take on this, so I don't feel like it makes sense to argue anymore. I acknowledge that you are right on several points considering the context. This argument became too heated somewhere in the middle.
Why a Chrome extension? Seems you are looking for a background job. So why not a node.js background process? The Chrome extension probably has a lot more overhead, depending on what exactly you do, definitely so if the whole thing involves rendering the content each time, which would be a big waste. Realistically, it sounds very much like you could even do that easily using C and some of the many small libraries for C for the net, and run it on a small "OS-less" embedded system, with just a few Kbyte of RAM. Power use will be so low it could run on a battery. Not every task needs an entire operating system and layers over layers on top. If you are more interested in the programming aspect and in learning I would recommend that route just for the experience. Devices are $10 or in that ballpark. Programming environments are free ([example](http://www.ti.com/lsds/ti/tools-software/launchpads/software/software.page)). Once you've done some low-level embedded programming your world view will change... :)
&gt; I didn't get this whole "not use frameworks" thing. Your position basically sounds like writing code is too hard... must use framework. For some people that is absolutely true, and for those people good luck attempting to write a full stack application on their own in a short amount of time. &gt; Source: Been in 3 project where people did their own server framework or front-end framework That is still a framework. The absence of a major brand framework does not mean you will end up coding one anyways. I find that problem is only true when a framework reliant developer is forced to operate without a framework and lacks the experience or direction to do so. They fall back on the limited experience they do have. Again, if that is you then good luck. In the end though there is still some basic solution or goal the full stack app intends to provide. The more luggage that comes with it the less portable the app becomes. You can force your corporate employees to do anything including sit through several convoluted time sucking build processes and downloading tons of stuff, but this is frustrating and distracts from the problems the application was written to solve. If you are looking to force this madness on users outside a controlled office environment... good luck.
As someone who currently uses react + MobX, thanks for the explanation. I'll give Vue another look.
We have similar ideas. What I did was merge some of the jQiery abstraction ideas into your idea, when I saw FRZR a while ago. When I create an "el" I get an object with methods that help unify things across browsers, like "closest". Components are created like this `el(Component)` and you pass arguments the same way you would do a DOM node. When you want to append a component to the DOM you would use `el(Component).appendTo(document.body)` The components inherit methods where the `appendTo` will fire an `.on("mount")` event when elements are rendered to the DOM. The API I built has a larger footprint (19KB) minified for the `el` function and 5KB minified for the `Component` constructor. Does not do diffing, that will be next. :) maybe I can help you. [The lib I wrote](https://github.com/SeanJM/create-node) I haven't released the `Component` to the public yet.
Read what I wrote. I said it's impossible without doing some kind of normalization. jQuery does normalization. You can do normalization. But it's something which is still necessary, because browsers (even the evergreen ones) aren't quite as equal or interchangeable as one would like.
&gt; and the only reason for it's somewhat smaller userbase is the lack of Facebook/Google branding. Or, you know, the fact it's much younger.
What's the desired result? &lt;div id="text"&gt;Thi&lt;span style="color:red"&gt;s wa&lt;/span&gt;s just a random text. This is a second sentence.&lt;/div&gt; ? How about this case? Thi&lt;div&gt;s wa&lt;/div&gt;s just a random text. You wouldn't want to replace it there, right? Or here: Thi&lt;span style="display: block"&gt;s wa&lt;/span&gt;s just a random text. You shouldn't replace it there either. But here you'd have to replace it: Thi&lt;div style="display: inline"&gt;s wa&lt;/div&gt;s just a random text. Here you shouldn't: Thi&lt;span&gt;s wa&lt;/span&gt; &lt;span&gt;s&lt;/span&gt; just a random text. You have to look at all the nodes and their computed styles to figure out if you've got a match.
&gt; You can do normalization. Which is my point. All these libraries and frameworks use vanilla javascript. To say it's impossible to do anything on your own without one of these libraries and frameworks is a bald, faced lie.
Definately a desktop program. The browser is pretty much self contained
Building applications.
I have fun in programming and I am learning it right now, but I need this function right now and can't learn a new thing first. I see that what you are telling makes perfect sense, but I don't know how to do it actually. I never worked with node.js either. I just have a program that a friend made for me. :/ Edit: The only thing I am quite okay with is JavaScript on chrome extensions. :D 
The very beginning of this thread, I commented how redditors think doing anything without someone else's library or framework was impossible. You couldn't do it on your own. You said it was impossible without normalization. What that has to do with what I said, I'm not sure, but it sounds like you are disagreeing with what I said. My whole point, again, is that if someone thinks working with the DOM using plain javascript that you wrote on your own is impossible, or "tooooo haaaaaarrrd", then calling them a dumbass is a compliment.
No I don't agree with that part at all. For a programming language ES6 really is a massive set of changes. Just look [here](http://es6-features.org/). TC-39 has actually said as much and are are making a conscious effort to make update sets smaller and more manageable. I also don't think it's right to equate every new feature with being "progress" (paraphrasing "change" here), either. The features have been put out there, but whether they are universally adopted is yet to be seen. Undoubtedly a lot will be, but trust me there's a lot of pushback on certain features too.
Thanks to you and the other responses. On balance, sounds like it's worth digging into and looking to establish a framework-y kind of way to address the challenges so as to get the benefits.
Bad ass! Having used Angular 1.x, React, and Vue I have to say my preference has always been Vue. Looking forward to migrating. Also the speed of development for the Vue team is impressive. I appreciate how lean the operation is and that it's community-funded.
The daily "What do I do next?" thread on reddit.
You probably read this on Vues blog, but it just isn't true, or at least it's a complete stretch. If your app is getting even slightly more complex you're probably using Redux or any other state handler. They handle it for you. Even if you use local or global state, shouldComponentUpdate makes sense in the rarest of cases, for instance when your data is very abstruse. Most people wouldn't use it, it is an escape hatch for grave cases. The odd thing is that Vues reactivity system can be a mess. It climbs through your data, wildly mutating it, transforming everything into an "observable." Javascript can't observe objects yet, so you run into natural edge cases like not being able to replace or add objects in your data. Then you sprinkle $sets and $deletes over your codebase. Vue even transforms objects that you don't want to be reactive, you hardly have control over what it does. Once behind-the-scene magic has burnt your app to a crisp, you are going to VueX, at which point you are using Redux almost the same way everyone else is using it.
I haven't seen any RethinkDB yet, what is its point? I know nothing about it. I just know that it's also NoSQL. I've been using Mongo for all DB stuff. Would you mind to share a quick overview? Thanks! PS. I'm going with React + Redux for the front.
You cant do that without some kind of database.
Now with virtual dom it does. The Angular team made a big deal from it, but it's not a rocket science really.
Are the benchmarks actually appealing in practice though? I mean, if that's the only difference then sure it makes sense to go for the better performing one, but in practice, when writing these apps with vue/react/angular/etc, how often does the framework become the performance bottleneck? You're more likely to either have no performance problems at all, or problems due to sloppy coding (inefficient loops, constant repaints, doing heavy computation during scroll events, trying to render an impractical amount of data, etc)
All of this is true for React by the way. Yes, most of the time you don't use it that way, but that's certainly true for Vue as well, as you yourself stated in the second half of your post.
Well... that depends on how coupled it is to the virtual dom. Was an actual PAL made to interface with the virtual dom or is it's API used directly...
Polymer has some serious downsides when it comes to bindings and expressions
What do mean by waiting for Koa to mature? Koa is stable, and so are its main libraries. Any express library can also be repurposed for Koa 
EDIT: ~~apparently this no longer applies to vue in v2~~ EDIT AGAIN: Upon reading the docs, this is what Vue 2 still employs. While you have the freedom to do whatever you like, the "vue way" is still using angular-like directives which, IMO, are a bad idea. I think the primary difference is that React puts HTML into JS, whereas vue tries to put JS into HTML. This is the primary issue I have with vue, ember, and angular. It's, IMO, a fool's errand. Creating a custom AST is difficult for developers and framework authors. It's a never-ending task, which means you have to open it up to third-parties, creating fragmentation around the way "directives" are implemented. When the only templating option you have is HTML (JSX), you know exactly what you're dealing with as a developer, and as a library author, you know what you can expect from consumers and can deal accordingly. 
Makes the static keyword make a lot more sense, the context is 'static', permanently tied to prototype it's defined on
Cool that's it! And it's even Bootstrap, I should've known of this... Thanks! Fwiw there would be a JavaScript backend to dynamically populate/change that stacked progress bar, and I wouldn't mind not having to write that entirely from scratch, so if you know of anything to that effect, let me know!
&gt; From my experience with Vue it is not as simple as it seems. Further in it gets very complex. In reality the complete api was a must read, i know that back then it took weeks to fully understand what's going on because Vues behind the scene magic has severe side effects. The things you learn in these docs are so wildly arbitrary and foreign to regular javascript and html that i scratch my head when people say it's "easy." The 'behind the scenes' magic is there so you don't have to worry about how your data is being rendered and reacted to, just that it _is_. Updating a variable in a component's data will update the view accordingly, and everything just _works_. [Edge cases and caveats](http://vuejs.org/guide/reactivity.html#Change-Detection-Caveats) are clearly documented. &gt; React can be learned and fully understood under a day, probably even under an hour if the material is good, because there isn't much of an api surface. It has two or three api functions. Though it stresses concepts that should be understood, how an app can be reasonably structured and how to make state flow through it in a transparent way. I know that as a beginner i didn't like that about React, i wanted to start building UI, not think about it. You seem to overestimate the size of Vue's complete API, [and underestimate that of React's.](https://facebook.github.io/react/docs/component-specs.html) In fact, it used to be bigger, but even in 1.0 the entirety of it wasn't all that hard to digest. Really, just with knowledge of components, data and methods, you could probably do all you need to do without much hassle, and you just learn more as you go along. This applies to most things, really. &gt; But then these are the exact same concepts you apply later on to Vue anyway after the first project has went up in flames. You run to VueX and single file components. Suddenly your code isn't as cute as it was in the 10 second demo, and it's probably or most likely 3 times as verbose and complex as its React counterpart would be. Vuex and single file components aren't necessary. You're free to just load it from a &lt;script&gt;&lt;/script&gt; tag and work from there, and you're free to just use a data object to manage global state if you need to. I use this method in one of my own apps, and the [hackernews demo](https://github.com/vuejs/vue-hackernews) does as well. &gt; Another thing to keep in mind is the eco-system. I know this isn't Vues fault, but React has thousands of ready made components, ui libs, helpers, state managers, routers, etc. Whatever it is you need you find it. [Right...](https://github.com/vuejs/awesome-vue) Not like Vuex and Vue Router aren't good enough production solutions anyway. God knows you could roll in Redux/MobX if you wanted too, nothing's keeping you. For the record, I'm a proponent for both React and Vue and I think both of them have a wonderful and important place in the world of front end development, but this comment is just really uneducated.
Yeah, its just a matter of defining it on the constructor function. function MyClass () { // constructor } MyClass.prototype.method = function () { // instance method } MyClass.method = function () { // static method } That's pretty much it, though one difference is that in using the `class` keyword, static methods are also inherited by subclasses. 
The big problem with Polymer is that it is based on technologies surrounding web-components. Html imports and shadow dom are noticable examples. Because of that you're stuck with shitty polyfills. The shadowdom is even impossible to polyfill. Don't get me wrong, polymer is really cool, but I would currently rather enter the Javascript based bandwagon (React, Angular) just for better support, more libraries and better browser compatibility. Google is putting a lot of money in Polymer, possibly because they want to push web component technology. Angular is left behind a bit, but is actually more useful for developers today. What I also don't like about Polymer is that they also tend to put non-view stuff in components, declaring a service worker as an HTML-like element is not the way to go (personal opinion).
In theory. In reality you worry about it because you run into edge cases. An "edge case" can be as simple as adding a property to your data. Some of this is documented, but that is exactly what is making it hard, because it has you study intricate inner workings that affect your app in ways you can't predict. React doesn't do that to you. I learned it in one or two hours because it is simple. This is how i understand the term "simple" at least. You understand something, then you apply it. I had to study Vue *for weeks* to truly understand what's going on because in a larger project it goes wild. Another example of Vues magic that makes things so easy: You keep an object inside your component, say a dom node. Where to put it? Can't put it into data, Vue will climb through and convert thousands of links into observables. Let's put it into this.dontTouchThis. In certain conditions Vue will still mutate. This for instance is not documented, you browse through issue trackers, see here: https://github.com/vuejs/vue/issues/1988 The solution is arbitrary again. There are even [plugins](https://github.com/rpkilby/vue-nonreactive) to work around it. This stuff happens when you don't have actual classes that belong to you. You pass something into the void and get pinged back. Vuex and Vue router are fine but they aren't near the support and tooling you get for react-redux and react-router. Redux especially has countless of helpers, additions, [incredible dev tools](https://github.com/zalmoxisus/redux-devtools-extension) and so on, though you are right, you could use it with Vue. I know Vue-awesome, its my go-to resource for Vue projects i work on, but its eco system compared to Reacts is tiny.
As vue2 translates templates into render(), there is virtually no difference between vue's way and react's way in this area.
Wow that's much simpler than I imagined. Are they inherited though? You can only access them by calling the prototype name, or constructor method on this, ie 'MyClass.staticMethod' or 'this.constructor.staticMethod' 
This afternoon I created a 3D scene compiler, which allows to compose scene in declarative fashion using custom JSX tags a bit like React-three but compiles to pure JavaScript with no external libraries needed after the compile process! Custom tags can be created using functions, just edit the Codepen and create new functions which return Three.js -objects. http://codepen.io/teroktolonen/pen/RGLKdg?editors=1000
What's your library? I'm looking for a compact GSAP replacement.
Came here to say this. :) Not just an awesome language to work with, but has really improved my JavaScript as well. 
I'm having trouble lazy loading aot compiled modules. I use the angular CLI. Does anyone have any input? [demo repo](https://github.com/slmyers/test-lazy-aot)
Good points, but I never felt like I needed anything outside of the official vue libraries to be honest The merits of markup-in-logic vs logic-in-markup is also pretty debatable and up to your discretion. But hey, Vue now lets you do either depending on which you prefer, while React has only one way.
Really interesting project! Although you are right, 95kb minified is still on the heavy side. And that doesn't include the dom extension which is 38kb. Have considered a lite version with less features?
I like react don't get me wrong, but you can be productive with Vue quicker too just due to the fact it's easier to grasp. YMMV I suppose.
Oh, interesting. Thanks for that info!
https://github.com/jadeallencook/gDoc.js/issues/2
Do you have a benchmark comparing anim8 with gsap, velocity, popmotion, etc?
Thats on my todo list after I finish documentation. I've used this library in several games and animations for big name clients, so its definitely been tested well and used in the wild. I'll think about the best way to compare it to the other libraries - its always really hard to do that in a fair way for all libraries.
Not sure why you'd need to learn JS *BEFORE* RoR. The two are not related. For web development as a general rule knowing JS is very important for client-side scripting, while RoR is a popular server MVC framework. So basically the answer depends on what you'd rather be doing: working primarily on the server, working primarily on the front-end, or some of both (full-stack). For RoR you should know some Ruby though.
Because the JS ecosystem is a disaster. I can pretty much put money in the bank of what build systems, frameworks with great support etc. will be around in 3-5 years in the Java/C#/C++ ecosystem. In the JS ecosystem you would be lucky to know the state of JS itself will be in 3-5 years (will it be overtaken by TS?, what about browser support?, will google/ms try to kill it again with another VM?). It's just in so much flux it's annoying. Edit: i'll just leave this right here... https://www.reddit.com/r/programming/comments/55okik/how_it_feels_to_learn_javascript_in_2016_xpost/?st=ITVK2TNI&amp;sh=1ce0f38f
Ok, so your reason for choosing JWT over cookies is that with cookies, you need to hit the database to get the userId associated with the cookie. This is the *only* advantage JWT has for session use. The disadvantage is that you have to trust the JWT, which could have been copied after logout or generated. With cookies, you control the session store. So you are trading a security risk for a database hit reduction.
And if you want to use JS you can use Electron as mentioned below. Though I am unsure of how easy/difficult accessing the process information on Windows will be though Electron API so you may want to research that before choosing the Electron approach over something more native to Windows like C#/WPF application 
It's amazing how bad the web component community is at getting people onboard.
Cool! My implementation is very similar. I did it in Elm: https://github.com/hugobessaa/elm-logoot EDIT: I also added ideas from logoot-undo to make insert/remove commute.
lamp
PHPStorm, Laravel, PostgreSQL, Redis, Vue (Vue-Resource, Vue-Router, Vuex), and Gulp for compiling SCSS and ES6 JavaScript.
[http://jsbin.com/sadula/edit?js,console](http://jsbin.com/sadula/edit?js,console) function replaceHTML (element, word, replacement) { var fL = word.charAt(0); var lL = word.charAt(word.length-1); var str = element.innerHTML; var regex = new RegExp(' '+fL+'&lt;(.*?)&gt;'+lL, 'g'); str = str.replace(regex, replacement+' &lt;$1&gt;').replace(/ is /g, ' was '); return (element.innerHTML = str); }
Hi /u/pier25, this post was removed because it doesn't appear to be related to javascript.
Nice!
Coming from Angular i started with 0.5 and loved it, but then 1.0 flipped everything over again. I tried it once more but at this point i had trouble seeing what it solves that others wouldn't. I know it embraces the component standard, but my issue with that is that there are things the committee hasn't begun to address which makes Polymer still cling to the dom, string templates, parsed mustache fill-ins or weird html-foreign conditional directives, with all the silly limitations that brings. It also means that instead of composing freely i have to worry about slots now and injecting scope into the template parser. Overall my feeling is that v-dom libs are already solving tomorrows problems while they hover over the dom without getting bitten. They're not tied to a democracy of many trying to steer the ships single rudder. They can already play with foreign systems (like mobile) as they effortlessly switch the engine, or render on the server. They already have shareable encapsulated components and component eco-systems. I don't like to say it, but we waited nearly a decade for the dom to come along, took hits because vendors refused to implement drafts, went back and forth, but they have made browsers so good that customized solutions and transpiling start to feel "right" in ways that feel liberating.
A different language. Something functional maybe - there are interesting courses on Coursera (for Scala) and edX (for Haskell, archived). Or even (dare I say it) Java - simply because that ecosystem still is and will remain for the foreseeable future the cornerstone of programming "where most of the money is" and most of the programmers are. Looking at the web gives a twisted picture due to selection bias, most programmers are not very active in all those fora. There are some important concepts and tools in the Java space, not least the JVM, which has become a beast on its own, targeted by many new languages other than Java. Javascript is taking *a lot* from the Java world, for example runtime-optimization techniques first introduced in the JVM and then used to make Javascript engines faster too, and soon WebAssembly, the Javascript equivalent of the JVM (at least that's the plan). Plenty of free and good courses for Java! At least knowing the basics would be quite helpful, even if "only" on an intellectual level. Microsoft has some good courses on their own website and on edX(.org), for F# or C# and others. Or go the opposite direction compared to what I first suggested and take a course on embedded programming - and I don't mean "small board but with an operating system", I mean a *pure* plain board with no OS, directly programmed with C. The board is $10-$15 and the IDEs are free. [Example](http://www.ti.com/lsds/ti/tools-software/launchpads/software/software.page). This prepares you well for "IoT". Sure, you can do that with Javascript - but then you added soooo many layers, if all you do is read a temperature sensor it's 99% wasted effort. Which translates into power consumption. Well, and it's waste. I find it kind of important to know that when you use node.js on a small board to do something really simple like basic I/O to a port to read a sensor how incredibly wasteful your setup actually is, that you can do the same with &lt;1% of the computational effort and hardly any less readability (C can do very well in those scenarios), but with significantly less (hidden) complexity. Don't be a mono-culture developer, broaden your view.
You are going to need a backend for this, either a database and a server-side language, or some sort of backend-as-a-service solution. The flow will be: User perspective: User opens a webpage User enters data in a form and submits it Data gets sent to a backend that processes it and stores it in a database. Admin perspective: Admin opens a log page Backend retrieves data from database and processes it. Page displays data for the Admin to see.
&gt; Because not all problems are solved problems? Reinventing the wheel is absolutely stupid, inventing the electric car is not. It doesn't sound like you can tell the difference. You are a troll. I am done.
If you ever find yourself doing react project in the future, be sure to try it with MobX for state management. [MobX](https://github.com/mobxjs/mobx) observables is like Knockout observables on some serious steroids. Pure awesome.
&gt; I don't think React as ecosystem and framework will ever work for most people. It will. Give it a couple of years though. Best practices still need to be defined and accepted widely.
 From the docs: &gt;Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That’s where you can use the render function, a closer-to-the-compiler alternative to templates. So, while possible, it's not intended to be used everywhere. Basically it requires the developer to judge which option fits best for the use case. One could say that is a good thing. After all, choice is nice, right? The same goes for some other Vue concepts. Let's say, filters. You can also use computed properties there. Sure, both ways have their use cases, but in essence, the end result is the same. I think this freedom is not so good after all. It's cool if you're working on a project by yourself, but in teams where not everyone has the same experience, let alone the same coding style, this can turn in to a badly maintainable mess real quick. I believe it promotes unclean code. It reminds me of some apps I've seen people building with Angular. Don't get me wrong, I believe Vue is a nice library, and while I don't mean to bash it, I'll keep using React and Redux. It may look more complex (it's not!) but personally, I think it promotes a cleaner codebase. Edit: I'm also not so fond of the use of observables in JavaScript. They're magical, non-standard constructions that sooner or later end up giving you unwanted side effects.
Well put. This is basically my concern with Vue as well.
What's your problem with the CLI? Are you having trouble with the `--aot` option?
It can be hacked with a compiler that touches the whole pipeline like with CSS modules.
Thanks for being so helpful, I might have to pick your brain in future!
async functions are inherently asynchronous so they can't return a synchronous value. Instead they have to return a promise which will resolve when the async function resolves. After all, when you await in an async function, that await doesn't happen synchronously. Its just syntax that resembles synchronous code to make it easier for us to mentally consume. That await still has to wait for the promise its waiting for (e.g. `ret()`) to resolve. Because it has to wait, any return in that async function also has to wait. And if the return has to wait, that needs to be wrapped up in a promise so when you call the async function synchronously, it has something to give back.
No, it seems to compile just fine -- well the app module compiles just fine, not sure about the lazy module -- but when I try to lazy load a compiled module. I get this error: Error: Cannot find module 'app/lazy/lazy.module.ngfactory'. I'm using this route config in my `app.routing` const routes: Routes = [ {path: '', component: HomeComponent }, {path: 'lazy', loadChildren: 'app/lazy/lazy.module#LazyModule'} ]; and the error seems to be thrown here return __webpack_require__(191)(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix) p.s. I appreciate your work love the CLI. 
Possibly stupid question: is this lazy loading something to benefit production, or just development?
No, its already a promise. You don't have to do anything extra. Simply calling an async function automatically gives you a promise wrapping whatever value it returns (resolved _when_ it "returns" since the return is itself async).
``` export function isFunction(obj) { return toString(obj) === '[object Function]'; } ``` Why not typeof obj equals function
I'll bookmark that one for any future personal projects. That said I don't think React will come up again where I work. My team had so many issues with the component model, the build process, etc. I wasn't a big fan but I got it. For most of them it just never clicked.
Very cool. I had no idea Webpack could play a role in production. I always considered it a tool I used at build time.
Actually I'm starting to doubt the compilation of the lazy module in `--aot` mode. There is a `0.map`, but there is no `0.chunk.js`.
You could create a personal website for yourself. It could just be some simple pages like home, about, contact, blog, etc. You could also add a simple login for yourself for access to a testing area where you can have live pages for testing various things.
I like to think of async functions as a nicer way of consuming *and* creating Promises, so instead of creating a promise with function doAsync() { return new Promise(function(resolve, reject) { someAsyncAction((value) =&gt; resolve(value)) }); } you can use async function doAsync() { return await someAsyncAction() } if you wanted to log the result of wrapper in your case you have to consume it like you would any other Promise wrapper().then(console.log) 
Great! Would you mind to share what you're going to use for authenticating, password reset, loing and such? I like your stack, it's not "trendy" but I'm sure it get the work done.
Oh thank you. I'm not sure why I wouldn't have thought of that.
You can't (AFAIK) read the keyboard state from javascript. I think the best you can do is listen for both the keydown and keyup events, and then use the KeyboardEvent.code value in those events to keep track of which physical key is pressed or released. But keep in mind that you may get multiple keydown events for the same key if it auto-repeats, but only one keyup when it is released, so you'll want to use a hash or array with unique values or something to help you ignore the duplicate keydown events.
I think ill just make the boats move backwards every .5 sec no matter what. Because i dont want anything to trigger the move back. Just in case someone spams the wrong key, the boat will move back a lot quicker 
I am nowhere near that level. React is for later on in this course!! I went for a different route but i appreciate the help!
That's an odd way to think of it Why not think of it this way: start a loop that keeps running until any key is pressed - so the loop runs and checks a variable and if the variable isnt set then it keeps running, on any keypress that variable is set and then to run it again you just reset the variable and begin the loop
Exactly this!
Yeah. I don't like also when some libaries are suggested for simple tasks. Specially in a JS subreddit.
We're still working on fixing bugs. I've made it work with a simple case of lazy module but maybe I need to revisit that and make some more complex tests. For now just consider AoT as an experimental feature. Make your project work with it and once we fix all the bugs it's gonna be great!
Agreed, I got carried away a bit there.
 $("td:contains("+string+")" ).siblings(".selected").css( "text-decoration", "underline" ); You need to Append the variable, otherwise it takes the literal string "string"
If your game uses an update loop you can do the following: - Use a map where you store the keys that have been pressed down. - Add an event listener for the keydown event. In this listener you set the value of the key pressed as true in your map [1]. - Add a requestAnimationFrame listener [2] (this is your update loop). In this listener, at the beginning of the method, you check the values from the map to see which key has been pressed [3]. Depending on this you update the position of your boats. I've used this method in a game myself, I added some examples. [1] https://github.com/ggbt/html5-bombergirl/blob/master/js/InputEngine.js#L99 [2] https://github.com/ggbt/html5-bombergirl/blob/master/Bombergirl.js#L671 [3] https://github.com/ggbt/html5-bombergirl/blob/master/Bombergirl.js#L759
Maybe think about moving backwards as the default state of the boat, interrupted by key presses.
You're right I should probably have used that method. No particular reason to be honest. It's a very minor optimisation, but is probably worth doing if I want other people to use this.
&gt; The only other way i can think of is make the boats always be going backwards 2px but it seems iffy to me. Yea, it sounds odd with that frame of reference. It's the camera (or viewport) which is constantly moving. A boat which doesn't move forward appears to move backwards.
Since your question was already answered, I'll tell you something else. You're creating a bunch of implicit globals. `var` (or let/const) isn't optional.
Support is not just on github. From the community, meetups, external libraries, tools. Look at guys at ele.me and alibaba.
&gt; Yes. We did that, too for our projects. But that isn't "easy" or "simple" or even obvious. It is completely nuts to be honest. That's fair. There's tradeoffs for every frontend framework out there, and Vue's aren't the most sensible, I'll admit that. But it's a good tradeoff that eases the learning of working with reactive data logic, in my opinion. &gt; In fact you are now working around the limitations of a lib that is forcing you do to things its way, even if it is completely against the common way. I've made the point before that Vue hardly forces you to do anything, so by your logic, literally every good framework out there does this. &gt; And this is the sort of thing that will burn a beginner, still dazzled by the introduction page, where everything was cute and easy. Beginners aren't working with anything more than the simple kinds of data types I've mentioned before. &gt; React is just regular javascript and extended HTML. This is why you don't "learn" it. You know React, even if you have never used it. You're calling JSX "just regular javascript" and "extended HTML" when JSX is an entirely different dialect of JavaScript altogether. They really aren't the same. &gt; I know Vues dev tools. Here i would agree if someone said they are "simple." But more like simplistic. Install redux dev tools, find a react app and hit the button in Chrome to see the difference. Maybe they're 'simpler' because they do all they need to do? I've never wanted more out of what I've gotten, and asking for more is frankly ludicrous. &gt; I don't blame Vue for not being big. But effectively it hits you. You say you don't "dip into it." This to me is incredible. Like what the hell. With React i pick and choose, just like i pick and choose on npm. Because everything is there. I'd rather focus on developing my app than focus on what technologies to develop it with. This includes when I'm working with React. &gt; Would you rather add jquery to your project and mess around with css classes to use a popular ui components lib like semantic ui, or just use it, because your view lib is popular enough so that it mostly always gets support. I can't even tell if there's an actual point or metaphor being made here, but comparing jQuery to _anything_ in this discussion is just... eh? There are people literally using jQuery _with_ React and Vuejs, because they're both unopinionated enough to let you do so, so... eh????
it actually looks like he routinely bashes other presenters (if you read the opinions of the people who won't present with him) and that he's alienated and been hostile to so many people that conference organizers either have to dump a half-dozen speakers or him. What choice would you make, honestly? Let's take away the names and just put it as numbers: You have 10 speakers for your talk. 8 of them find out about speaker 9, a speaker who is routinely hostile towards them in presentations, who is known to call them all 'stupider and stupider'. The 8 say they don't want to present at an event with 9. Do you say, "Sure, buh-bye" or do you go to 9 and say, "Hey, you've angered and alienated 8 of my 10 speakers. What the hell? Did you forget the importance of relationships?"
They actually seem to have excluded him because he is openly dismissive of and hostile towards fellow presenters. Seems legit, honestly. Pretend that 'inclusivity' isn't an issue at all, that we're just talking about a guy who is rude to everyone. Do you want to hang out with him? Would you ditch a bunch of speakers at your conference in favor of the guy who is routinely rude and hostile?
first thing would be to test your skills. 1. Go to stackoverflow.com and try answering a few questions asked on the relevant topics. 2. Try out new things asked there in jsfiddle.com or any other editor. Use it as your learning journal. 3. Once you're sure you're quite okay. I'll suggest you try making a website for yourself, you know. Give it a try. See how good you could do. Write about yourself or anything. 4. If you're able to do it for yourself, you can do it for others too. Tadaa... 5. Start selling yourself as a web developer now. There are plenty platforms for web-dev freelancing. Give 'em a try. And here you are with your brand new career. 
So how would I go about removing the hidden input element from the DOM? ([codepen](http://codepen.io/anon/pen/yazKaj))
Thanks but it seems like that also removes my &lt;head&gt; tag, how do I specify to only target the hidden elements in the &lt;body&gt; tag?
Looks like they want a script for some game.
So what you're saying is that it's wildly off topic for a simple beginner's question, and both pointless and unnecessarily confusing for someone clearing still learning basic JS programming?
The JS ecosystem has an even bigger problem than most languages with clueless fanboys advocating their preferred library/framework for every problem, no matter how ill-suited or even actively counterproductive it is.
It should remove things with `display: none` You can try wrapping the remove code in a .ready, so that it waits until the page finishes loading before trying to remove anything. $(function(){ $('body').find(':hidden').remove(); });
As much as i like this idea, this is what i ended up going with: setInterval(moveBackwardsP1, 500) function moveBackwardsP1() { var $currentLeftP1 = parseInt($player1.css('left')) //grabs the current css.left of P1 and changes it to an int if ($currentLeftP1 &gt; 5) { //if css.left is greater than 5 var $newLeft = ($currentLeftP1 -= 3) //go back 3 pixels $player1.css('left', $newLeft) console.log('P1 moved backwards') } } I plan on making the amount of pixels you go back random as well as the timer for the interval to represent the randomness of currents. Maybe sometimes you go back 10pixels, other times, 2px 
There are 'currents' in the 'game'. The background is an repeating gif that looks surprisingly real! That is where i got the idea of moving the boat backwards. I was thinking about implementing a little animation where the players 'bob' up and down, but i dont know how to go about doing that.
Okay but don't you guys hear how devious this all sounds? Does not sound like a nice experience to me. Again not trying to flame Polymer, it just feels off somehow.
This week I have worked on increasing my code coverage of [Iota](https://github.com/lwakefield/iota), but more importantly writing better tests. The project is a JavaScript frontend framework, which works on the concept of VFDOM. I have spent a lot of time optimizing, both in bundle size (~4.6K) and rendering performance. It has been a super interesting project so far that has taught be a lot about the underlying performance issues of JavaScript (especially in browser). I really hope to have a functional beta up as soon as possible. My plan is to release it as part of a blog series about writing a framework, but also have it production ready as well.
Ok, I didn't want to expand on it like you did so I used "cookie" as a shorthand for "random token that has no value except as a key into the session store", with the underlying understanding that the session store is the single source of truth regarding sessions. By using JWT content as a duplicate for the session store, you no longer have a single source of truth and that has its consequences. Whether you send the JWT as an actual browser cookie or as the first line of a websocket stream doesn't matter in this case. So I think we are both in agreement on "random session keys" and JWT, except that you seem ambivalent towards using JWT to represent sessions by themselves, whereas I think that is either insecure or hard to do right.
All tokens are essentially hashes, or more accurately UUID's, as they should be. But somewhere we need to map that uuid to a session/user somehow. Traditionally we would have a session store on the server. JWT enables us to store that mapping within the token itself so that we don't need a session store. Essentially, with JWT's, we're sending the user mapping (probably a user id in your database) directly as the token in plain text. Only we're adding a digital signature with it so that we can verify that it has not been tampered with later when we receive it again. Nothing magical or new about this. JWT is just a commonly agreed upon standard way of doing this kind of thing.
ahhh gotcha. Will update
Every time JavaScript sees this syntax: // Dot operator, value is invoked (any valid JavaScript expression).nameOfSomeProperty(); // subscripting operator is the same (any valid JavaScript expression)['nameOfSomeProperty'](); ...the `this` value it passes to that function is the value of `(any valid JavaScript expression)`. The behavior of `this` in instance and static methods is all due to that simple rule.
&gt; That's quite non-trivial to do, because there isn't a single string in which you can search for the word. You can use `element.innerText` which returns the text of the element and all child elements, ignoring all markup.
Yes, and by sending around copies of your session store as JWT, you get in trouble when you need to make changes to the session data, like when users log out or have permissions revoked…
Cool stuff!!
JavaScript automatically converts values to other types if the operand requires it. `-`, just like `+`, operates on two numbers*, so the JavaScript engine will automatically call `.valueOf` on the string underneath the hood to produce a number from the string. This doesn't just happen for strings; it also works for other variables such as objects. To see this in action, run the following code in your console. var myVar = { valueOf: function() { console.log('Converting'); return 5; } }; console.log(myVar + 5); Also of interest is that booleans get converted into 1s and 0s while Dates get converted to UNIX timestamps \* `+` can also work on one value, but this is much less common. Try entering `+'5'` into your console
They're not quite identical. `forEach()` skips over missing array elements whereas `for..of` does not. And `for..of` can be used with anything that's iterable (e.g. DOM collections and generators) whereas `forEach()` only works with arrays, as it's an array method. `forEach()` is defined in ES5 whereas `for..of` is ES6, so there are differences in compatibility. I don't really think there's necessarily a reason to always prefer one over the other. It depends on your requirements and what you're doing. 
Failing early is a good thing during development, but JavaScript got that unfortunately the wrong way around. JS' philosophy is to try *anything* to keep going. So, instead of getting a type error, the types are coerced and you either get utter nonsense or something which looks right (but hides your mistake). Try TypeScript. It doesn't let you subtract a string from a number (and similar nonsense) if it can figure out those types.
[The for Loop vs. forEach in JavaScript](http://thejsguy.com/2016/07/30/javascript-for-loop-vs-array-foreach.html)
Return "20", obviously.
But which "0" is removed?
Well, looks like a bit slow algorithm though...
One reason one might use for..of is **Break** and **Continue** in iteration. You can simulate Break and Continue with forEach - Continue would just be returning from the function, and you can simulate Break by using array.some or array.every, but imo I'd rather use actual break or continue statements if given the choice. I actually totally forgot about for...of, it was something I was really excited about when I read about es6 because I came from Python, where that sort of iteration is pythonic. I'm always using forEach these days, I should switch over!
Looks great! As someone who has looked at hundreds of different OSS libraries online, as well as spent time writing documentation for Redux, this is an excellent set of guidelines and information.
Personally, I tend to stick with `.forEach` (or the `_.forEach`, which is a bit more flexible about what you can loop over), for a couple reasons. --- I like to at least have the option to use named functions, both for refactoring sake and readability: const doTheThing = (item) =&gt; { //logic here }); array.forEach(doTheThing); That's inherently a bit more readable than just anonymously doing that logic within a `for...of` loop; and if I find a reason later on in the function to apply that logic to a different array or to an individual item, it's easy to do `array2.forEach(doTheThing)` or `doTheThing(someItem)`. All of the ways of refactoring the `for..of` loop logic for reuse are at least a little more verbose. (And not verbose in a way that adds clarity) --- Secondly, if you're combing iteration with other things, it's a lot easier to use the `.forEach`. I prefer the style of array .filter(shouldDoTheThing) .forEach(doTheThing); over for(const item of array) { if(shouldDoTheThing(item)) { doTheThing(item); } } You can, of course, switch a `for..of` loop to a `.forEach` when you decide you need to filter first, but I just prefer to do it consistently in the first place. --- And plus, when it's appropriate, I greatly prefer using `.map` instead of doing it manually: const newArray = array.map(doTheThing); is a lot cleaner than const newArray = []; for(const item of array) { newArray.push(doTheThing(item)); } and `.forEach` is a lot more consistent with that style, and easier to refactor from one to another. --- It boils down to the fact that I lean towards a functional style; if you lean more towards an imperative style, you might prefer `for..of`.
I'm mentally face-palming. This is the equivalent of working in Powerpoint and starting by determining which animation effects you want to use instead of focusing on the actual slide content. Why distract from *your* work by showcasing someone else's? Focus on the actual content of your site, and see if that influences the presentation.
Is there ever a use case for *missing array elements*?
Talking in general terms, not specifically about RxJS.
I think that adding my failed attempts would only give noise. My failed attempts where also much specific to the code I was writing. I tried to give a more general question, and a more general example, to make sure it could be more interesting for someone else searching for a similar problem. Comments like this make me feel I'm back in highschool, and have to show that I have tried something myself before I ask a hint... In what way would the question become better if I showed my failed attempt? I got 3 answers in a minute, so I guess my problem was stated clear enough. Anyway, I didn't got real failed attempts (I had some attempt that did work, but was ugly), but even if I had, this doesn't seem relevant to me: http://stackoverflow.com/help/mcve I was not trying to fix a bug. I was trying to find an elegant way to implement a feature.
Not a good one... But if you're looking stuff up by index, and you want to remove elements without having to change the way you access elements in known positions in the array, you might do this.
The need for sparse arrays comes up every now and then. Of course the question should then be do you use an actual array with missing elements or do you use an object that happens to have numeric keys? The former might lead to surprises among people that don't know that JS arrays can contain holes, whereas the latter means you can't use `for..of` (as an object is not iterable) or `forEach` (as it's not an array), and using `for..in` gives you properties in arbitrary order. 
This answer is almost correct. The problem is the "first value" part. "20" + 0 === 20 + "0" It doesn't matter which part is first, all that matters is that one side is neither a number nor provides a valueOf member which yields a number. In that case, the + operator tries to convert both sides to strings and concatenates them. EDIT: My explanation is also not quite right. [This comment](https://www.reddit.com/r/javascript/comments/55jh40/200_0_returns_2000_but_200_0_return_200wtf/d8b7b2a) includes what is probably the actual procedure. 
JavaScript originally didn’t have exceptions, which is why the language often fails silently and coerces values to required types. The minus operator (`-`) coerces both of its operands to numbers: &gt; [200] - 1 199 &gt; true - 2 -1 &gt; 7 - '3' 4 The plus operator (`+`) is special in that it has two modes. First, its normal mode is adding two numbers. Therefore, many values are coerced to numbers: &gt; true + true 2 Second, using plus for string concatenation is also supported. Therefore, as soon as one of the operands is a string, the other one is converted to a string, too: &gt; 1 + 1 2 &gt; 1 + '1' '11' The exact algorithm for `+` looks like this: 1. Ensure that both operands are primitives. Objects `obj` are converted to primitives via the internal operation `ToPrimitive(obj)`, which calls `obj.valueOf()` and – if that doesn’t work – `obj.toString()`. For dates, `obj.toString()` is called first. 2. If either operand is a string, then convert both to strings and return the concatenation of the results. 3. Otherwise, convert both operands to numbers and return the sum of the results. 
`valueOf()` is only called on objects. For strings (which are primitive values), minus uses the spec-internal operation `ToNumber()`.
It's a small thing, but I like it when my `cursor` changes to `pointer` for things that I can click, ie, items in top and side toolbars. 
Definitely a case where you need good comments, but still a reasonable thing to use them for. Another drawback is that when you do this, it's really up to the JS engine how that array gets treated (it will switch implementations if it sees that the array is sparse), and that opacity can make optimization tricky. For example, one thing you might have to do, if an array starts out sparse but becomes fully populated, is copy it into a new array at the end, so that the backing data structure changes. That said, these aren't reasons not to use them. They're just things to look out for if your code is slow.
Nice try MS.
I use `some` this way quite often, but now that I think about it, it's probably a case where you should alias the function and give it a clearer name, like `untilTrue`. Incidentally, I think you almost always want to use `some` for this and not `every`. Otherwise, the default effect of a return is to end the loop, which is probably not what you want. Of course, if you wanted to get really fancy about it, you could make a wrapper so that `return "continue"` returns `false`, `return "break"` returns `true`, and any other return value throws an error. But meh.
lmao. You clearly don't understand modern Javascript tooling then. Mostly I use Vue.js anyway, which auto generates the webpack + linting + karma for you, and I don't need to use gulp or any shit like that, and I get hot reloading in development. I have code coverage tools, and testing with mocha + selenium. Even google uses JSdoc for some of their open source projects. Typescript is slow as fuck to compile in a large code base and it's a pain in the ass to setup incremental builds if you are using gulp. Though, I think you can use typescript pretty easily with webpack, its just a different loader and it should just work the same way as you would use babel. just google "typescript slow" and you get a fuck load of hits for how many issues there are for long compilation times. 
Adding failed attempts show that you tried, and it helps answerers guess at your line of thought. People like to see that you have tried because they don't want their time to be wasted. You want to make your solution shorter and more elegant? People will have lots of trouble if they don't know what your solution is. 
some and every are isomorphic. To end a .some loop, you return true; to end a .every loop, you return false. As long as you're not using .some or .every *to actually test if some/every value of an array matches some criteria*, I don't see why you'd almost always want to use some and not every. In fact, I think 'every' makes more sense: you return 'true' when you want to continue looping, and 'false' when you want to stop. That seems intuitive to me. If I'm using some or every, I never just `return` without a truthy value to return.
Neat-o! I am mostly curious about the tech behind the obfuscation, which no doubt is closed source. Where do you see the biggest use cases for obfuscating JavaScript? Also how much would you trust your obfuscation, maybe this would be best quantifiable by `deob time / LOC` or how long it would take to reverse the obfuscation engine. So many questions!
Yup, breaking out of a `.forEach` with `.every` by returning false to stop the loop. const arr = ['ok', 'not 'ok', 'ok']; const completed = arr.every(item =&gt; { console.log(item); return item !== 'ok' }); console.log(completed); // ok // false 
It's worth noting that the ES2015 `Map` and `Set` also have their own `forEach` method. const nums = new Set(); nums.add(10); nums.add(20); nums.add(30); nums.forEach(val =&gt; console.log(val)); // Output: // 10 // 20 // 30 --- const grades = new Map(); grades.set('john', 84); grades.set('james', 66); grades.set('elizabeth', 91); grades.forEach((val, key) =&gt; console.log(`${key}: ${val}`)); // Output: // John: 84 // James: 66 // Elizabeth: 91 Check out the docs on [`Map.prototype.forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach) and [`Set.prototype.forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach).
Then get the difference using innerHTML and put the tags in the same places
I agree with your "continue" and "break" thing. I don't agree with your reasoning that returning nothing with "some" is any more maintainable than returning true with "every" -- unless that's already some standard that I'm unaware of. But of course I think we can both agree that for...of, with break and continue, is pretty much universally preferable, as that's as explicit as you can get.
Holy shit! You're like bat-man!
LOL. ;) Maybe I should have prefaced my comment with how much I still hate Internet Explorer and Microsoft Outlook. Just still such crappy products and I have no idea why... That's why I was surprised by VSC.
How do you feel about websites vs readmes? For larger projects, I tend to just have some core features listed in the readme, and all the actual documentation on a website. That means the readme is smaller than other projects, but overall the documentation can be more complete. 
Comprehensive docs are always great, but from my perspective as someone browsing for libraries, I need enough of a hook in the README to tell me what a library does, what its use cases are, and maybe some idea of how to use it in my app.
depends on what your webpage does. If you are simply displaying some static content definitely don't enforce your clients to have js. If you are doing doing dynamic stuff on the front-end which would basically be a nightmare do to without js then just enforce having js. However your case is still fully static content. If you just use the templating engine you will just have to change it in 1 place and all your rendered pages will change accordingly. It seems to me from your post that you are not very far into learning the basics so I wouldn't recommend you release your thing yet. These things will come with time.
This guy nailed it, you should be checking arr[i] on your modulus, and that's assuming your array has all the numbers correctly in the array in the first place.
Search engine spiders often don't have JavaScript. Having a sane fallback that semantically indicates,what is navigation, what is content, etc can help with ensure accurate search results for your site. Of course in this case the site only needs to look good to a robot and not a person.
In modern parlance, database tends to refer to some kind of separate software, but yes you are right -- you can have a 'flat file' database or or even use JSON. However, those can get clunky when file sizes get large, Node can lag as it parses or stringify the data.
Some alternate ways to tackle this problem. There's no native Array.range to create the array, or a native Array.unfold (the opposite of reduce), so actually creating the original array of values is a bit more bespoke without a helper library, but... //create the source array: var nineTo253 = Array.from({length:253-9 +1}).map((_, i) =&gt; i+9);// -&gt;Array[9...253] //reduce it by summing only even values nineTo253.reduce((acc,x)=&gt;x%2===0?acc+x:acc,0);//-&gt; 15982 //weird use of spread/generators to generate array to spec with only evens to begin with: [...function*(){let x = 8; while(x&lt;252){ yield x = x+2; }}()].reduce((acc,x)=&gt;acc+x,0);//-&gt; 15982
FWIW, a pretty typical approach these days is a `docs/` folder with Markdown files. Redux does this: https://github.com/reactjs/redux/tree/master/docs .
"A low bar to entry and a discoverability problem is infinitely better" Not if you value quality over quantity. I don't really think this statement is self-evident.
I disable JS. Some accessibility programs have issues with JS.
Sure there are the times that someone intentionally disables JS and they really are about 1 out of 100 users. However, there are also other users that may be on cell networks or bad wifi. If their connection drops for even a split second while fetching a JS asset, that asset doesnt load. If your site is still usable without JS, these people won't give up on your site. Really, you just need to realize that server-side templating (via ruby or other) is exactly what you are trying to do.
Setting an element to `null` is different from a `delete` operation, which is also different from setting it to `undefined`.
An important exception to "often" is now googlebot: https://webmasters.googleblog.com/2014/05/understanding-web-pages-better.html
I think I've seen that done before. As I said though, Its all obfuscated. Is there any possible way to grab every function associated with an object type? Thanks for the response by the way
Why use an array? I would do it like this: function sum_even () { var sum = 0 for (var i = 9; i &lt; 254; i++) { if (i % 2 === 0) { sum += i } } return sum }
forEach also tends to perform poorly when benchmarked. I had run into issues with slowness iterating over large arrays and cut time significantly by switching from forEach to for.
I don't know of an easy way of extracting a variable when it contains functions etc. Using [dev tools you could insert a breakpoint and add a watcher](https://developers.google.com/web/tools/chrome-devtools/javascript/watch-variables?hl=en) on `SystemObject` to inspect it, and then you could manually look at all its properties, taking note of the paths and line:column numbers, and manually reconstruct it. This would take a while though.
I recommend you do some reading on "Semantic Markup". The web is processed by a lot more things than just desktop browsers. Unless you're writing a webapp that requires javascript for functionality it is very bad practice to have a website that doesn't function correctly without javascript.
Thanks for all your comments! And I've added the syntax highlighting just now. Besides, if you open Markcook by Chrome, the scrolling bar would looks better. I'll consider about he other issues inside your comments :) Thank you once again!
Thank you~
Wow, this is fantastic! Thanks you very much. I'd love to see your presentation too :) 
Sure. Gimme a few days - got some other things that I'm working on atm, and need to strip out some company-specific bits out of the slides. (Might also use this as an excuse to play with a web based slides tool too, now that I have the content created). But yeah, I'll see what I can do, and leave you a message when it's done. Probably also say something on my Twitter too (same username). 
forEach accepts a function, for statements not. The reusability inherent in that for me is a strong argument never to use for/while statements. Of course if you define all your functions inline/anonymous you lose all benefits provided by forEach being a higher order function. That being said, I'm not a huge fan of the native implementation of forEach, but luckily it's pretty easy to write a more robust/versatile implementation. 
Objects are assigned by reference. This means that { month: 0, day: 0 }; is created once, and then assigned to `person.prototype`; Now everytime a `new` object is instantiated, you are copying everything from the `prototype` to the new object instance. In the case of objects, you are not copying the object; rather, you are copying **a reference to the object**. So, `person1.birthday` and `person2.birthday` both point to the same object; any changes made to the one are seemingly reflected in the other. This is the reason why people actively discourage assigning anything other than function properties to the `prototype`. Reframe your thinking to: "Every time I instantiate a new `Person`, I also want to instantiate a new birthday object, and assign that to my new instance of `Person` (i.e. 'Hal')." The solution should then follow; you need `this.birthday = { month: 0, day: 0 };` in the constructor function. It would also be a good idea to move `Person.prototype.nickname` to the constructor function (`this.nickname = "";`). `nickname` works but `birthday` doesn't. This is because objects (including functions, also arrays) are copied by reference, but everything else is copied by *value.* A good rule of thumb is to only assign functions to prototypes :) Extra: By popular convention, constructor functions are typically title-cased; `Person` instead of `person`.
Would be nice to have dynamic dispatch using Flowtypes. Could really help writing more functional styled js 
I'm currently working on setting some of it up in PHP and I've made significant progress. Thank you for writing out the flow for me. It helped me visualize it!!
Why not just update the placeholders? Use data attribute to store the large screen and small screen ones then flip with window.matchmedia
This is by far the most efficient answer. These loops are just wasting cycles.
So, few days using this approach already saved me a lot of time. Thanks.
I use for...of for async sequences where one thing is executed after the other for (let item of items) { await item.asyncAction() } That would be harder with a functional approach, the obvious choice await Promise.all(items.map(item =&gt; item.asyncAction())) would run in parallel. 
The robots do not manage to deal with *all* content loaded/modified by script though, so there is still some reason to be careful here. Also with Google now penalising slow loading pages (by giving otherwise similarly scored resources a higher position in the returned results) a page that loads a stub, then waits for some JS, which itself depends on some large library so that has to come down first and which in turn makes a separate AJAX request to get the actual content, is a concern if SEO is important to you.
Sorry for the late response, it was nighttime in Europe. The use case we're aiming for are people distributing their propriatary Node.js applications, but it works just as well for JavaScript embedded in web pages. Deobfuscating code back to it's original state should be impossible since defendjs tries to discard as much information as possible. Deobfuscating it enough to understand the logic should be possible with some effort, but unfortunately that's true for every obfuscator out there. So far we haven't tried to break our own obfuscation and time how long it takes in comparison to other obfuscators, although that might be an interesting experiment. :) 
Wow, that's awesome! That has been a huge time-saver for me as well
The debate will probably continue for a while, but this blog pretty much sums it up right now. React's JSX has some benefits over the html templates placed in strings or separate template files found in Angular2. You may like strong typing or not, but TypeScript gives you intellisense in your IDE that certainly is helpful. Even if it's possible to use TypeScript in React, it's seldom used. The explicit dependency injection in Angular2 makes developers have to write more mock code in their test code, and mocking is generally a code smell.
Great initiative. I try to focus [a lot](https://github.com/js-cookie/js-cookie) on [the README](https://github.com/FagnerMartinsBrack/str-replace#javascript-string-replace) in my projects. It's really important to consider the documentation as an abstraction of your work. People will judge if your module is worth using or not based on the README, despite being performant, maintainable, well tested, etc.. I consider this so important that [I have written a little bit about the subject before](https://medium.com/@fagnerbrack/library-internals-do-not-exist-1ff50a30e3b0), jQuery used to do it extensively and never cared on breaking internal behavior if it was not documented (See the `$(...).data('events')` drama, for example). One thing I was wondering these days is about early feedback. It seems totally reasonable to create a module just with the readme without any code and send for feedback to see if the interface makes sense before starting implementing it. I have seen people doing it on a few projects in the past but don't remember exactly which ones. Does anybody know if this is a standard practice somewhere? In npm ecosystem from what I see, people write the code and don't give a sh1t about the docs (or do it later). That's why we have a lot of crap stuff around JSLand, if they cared about the docs at least it would be easier to fix it because we would have a guideline. Without a guideline, it is impossible for an independent collaborator to improve it! I would leverage this to throw a great suggestion for all those who create modules (inspired by the paradigm shift of Test-First): **The code doesn't matter, start with the damn docs first!** What buzzword for that would that be? RDD, README Driven Design?
&gt; rewriting my header and footer manually on every html file Use a static website generator like Middleman or Hexo. https://www.staticgen.com/
I was testing that even complicated spa pages are rendered correctly. Also spa is rendered very quickly. Hash links only are not supported correctly 
This was the question I wanted to ask. Your answer could be modified easily to allow for arbitrary min/max values as well, if that were a concern, but the scope of the problem indicates concrete boundaries making your solution perfectly acceptable. I probably would have bumped the initial i value up to the next even value and incremented by 2 each time to cut the number of iterations in half and avoid the need for an even/odd check, though. 
`for (let item of items) {` is 20x slower than `items.forEach(item =&gt; {` which is 1.5x-4x slower (depending on browser) than `for (let i=0; i &lt; items.length; i++) {` http://codepen.io/anon/pen/xEXvxw?editors=0011
I have to click a button that does an xhr and gives a response. Based on the response, I either need to wait a few seconds, click the button again and until something else happens, or just reload the website. I can give more details when I am back home. On my phone right now. Thanks for the answers and tips so far!
Check this guys videos. I can't really answer your question coz in a rush but you should really watch his videos. This is his latest which is oddly relevant https://youtu.be/DqGwxR_0d1M
The task was to create a function! 
I have a very simple library (just a few lines of code really) that does this provided you have Babel configured to convert types to comments rather than strip them completely. It relies on Function.toString() preserving comments, and I suspect some browsers may not do that (I'm using in Node.js). I was going to open source it if it grew in complexity, like normalising types that can be expressed in multiple ways, or using a parser rather than a regex to return a more structured type definition for complex types.
That would certainly gives errors on other range of numbers. And that's not good for teaching how to make a program.
"I experienced a terrible codebase in Angular 1 because it still gave devs too much room for screwing up." I feel you on this one, Angular 1 had 10 methods of achieving the same thing. Besides that most developers lacked in-depth knowledge while using the framework. Not to mention how often the best practises changed in the last years. However I feel with React there are also a lot of methods of achieving the same thing while Angular2 forces you more in a specific way of implementing a piece of code (f.e. decorators and interfaces). Also because a lot of technologies are build in and don't rely on 3rd party libs. If you look for something "how to do this with react" you get 10 different suggestions of implementations (and yep, a good developer can pick out the right solution). I totally agree that it is possible to build a decently big application with React without messing it up. If you can get your developers to follow certain guidelines (this is how it should be), this should not be a problem. I just think Angular 2 helps a lot in this process. 
&gt; Some experienced Node developers band together to create [curated lists](https://github.com/sindresorhus/awesome-nodejs) of quality modules This should link to the [awesome list of awesome lists](https://github.com/sindresorhus/awesome). Or you could even go [more meta](https://github.com/t3chnoboy/awesome-awesome-awesome).
I might do: function Birthday(month=0, day=0) { this.month = month; this.day = day; } Then: function Person(birthday) { this.birthday = birthday; } let person = new Person(new Birthday(2, 2)); Or: function Person() {} Person.prototype.addBirthday = function(birthday) { this.birthday = birthday; }; let person = new Person(); person.addBirthday(new Birthday(2, 2)) 
X-Post referenced from /r/meteor by /u/CafeRacer400cc [Issue #34 of Meteor Weekly is out!](https://www.reddit.com/r/Meteor/comments/55nozq/issue_34_of_meteor_weekly_is_out/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
If `SystemObject` was created as mentioned, you'll need to copy each of its own members (i.e. properties and methods). e.g. function copyFunction(fn) { var match, args, i, result; if ("function" != typeof fn) throw "Argument is not a function."; //---duplicate the function--- //get function argument names and body match = fn.toString().match(/^.*?\((.*?)\) ?\{(.*)\} ?$/); //sanitize function argument names if (match[1]) { args = match[1].split(); for (i = args.length-1; i &gt;= 0; i--) { args[i] = args[i].trim(); } } //include function body as function creation arguments args.push(match[2]); //create the function result = Function.apply(window, args); //---copy function members--- args = Object.getOwnPropertyNames(fn); for (i = 0; i &lt; args.length; i++) { result[args[i]] = fn[args[i]]; } return result; } var SystemObjectCopy = copyFunction(SystemObject);
Yeah, the starting/basic approach to writing a React app is to keep most or all of your state in the top-level components, possibly splitting some of it up as needed. As your app grows, this can become overly complex and require the component to know too much about the rest of the app, which is why most people use a state management library like Redux or MobX to move the state handling outside the component tree.
&gt; Creating a big application with React will be a mess, where Angular2 forces you in a certain pattern. That doesn't seem to make sense. Anything that goes beyond simple todos is going to use Redux or Flux, which were made to make applications easy to reason about as they scale. Even in Angular you'd probably use Redux for bigger apps instead of observables. React is also effectively used by the worlds [biggest websites and services](https://github.com/facebook/react/wiki/Sites-Using-React), it kind of contradicts your claim.
This apply to any software development gui ... There are loads to remember in PHP storm... But when you master it. Then it begins to become magical
Totally agreed. I'm not sure what the gained factor of speed is (possibly measurable), but using the keyboard alone is just such a pleasant experience. Definitely one of the reasons why Vim is so refreshing.
Merged and pushing to gh-pages right now
Wrap the logic for the player and the computer choosing in a function and call that function when you want the player to try again
Okay, I'll answer this question for starters: &gt; How do I call variable with global scope inside the function (local scope only)? I assume I don't have to rewrite anything. By simply calling it. If it's a global variable, it's available, well... globally! Where you would run into issues is if you were trying to access a functions local variable outside of the function. I would recommend doing some reading on *variable hoisting*, and *scope* in general to better understand how this works. Alright, now that we got that first question out of the way (hopefully!) we can start disecting your code. First piece of advice I have to offer is in relation to how you name your parameters. I bring this up now, as naming is an art that I feel should be mastered early on in the learning process. While using ``choice1`` and ``choice2``as the parameters for your ``compare`` function might seem intuitive at first, and it's not that big of a deal considering this is a fairly small program, but when you start getting into larger projects, it can begin to get confusing. Seeing as the first choice is always going to be the users choice, and the second choice is always going to be the computers choice, for the sake of readability I would personally just do this: ``var compare = function (userChoice, computerChoice) {...}`` There is nothing wrong with naming your parameters the same as the variables you wish to use to populate them with. As you can imagine, this will make it easier when reading code with a lot of functions that accept different parameters. Now let's finally take a look at how we would impliment the solution to your initial question: if (userChoice != "scissors" || "rock" || "paper") { userChoice = prompt("Invalid choice\nplease choose again. Do you choose rock, paper, or scissors?"); } Basically what we are going here is removing the ``return`` statement as that essentially stops everything dead in it's tracks. Once you use a return, anything else in that function that follows it will not fire. We do not want, nor need a return here. Because your ``userChoice`` variable is global, we can simply call it again, and reassign a new value to it by once again prompting the user to input their choice. Easy as pie! If I missed anything, or didn't explain things well, just let me know and I'll see what I can do to help further. Good luck, and happy coding! 
But you can run Vim on Windows. Either way, you should check out VS Code as well. Take it from me (a Vim user), it is a comfortable editor/IDE to work in.
Functions and arrays are objects that inherit from the global Object object. As a result you can directly attach object properties to them. var a = function () { return true; }; a.car = "kia";
\o/ 
Try to use window.location = "anothersite.com" This allow you to redirect the current page (same tab) Hope it does help
Thank you so much my friend, this is almost perfect for what I need! I will use this script with tampermonkey (chrome), I added you on reddit, I just ask you something!
Thanks. But I want the new page to be opened in a new window and leave the current tab intact.
Like I said in the OP, because of the platform I'm on I cannot use the &lt;form&gt; tag.
Try using the returned window reference to change the location once it's already opened: windowName = window.open(url, "windowName", "options"); windowName.location = 'newlocation.html';
[It's too real, Roy!](https://s-media-cache-ak0.pinimg.com/736x/80/b3/f3/80b3f3d6734ad50be8fb835f643f3920.jpg)
Then you can attach a function to the onClick event of the submit button? Just extract the 2 lines of code within the "if () {}" statement into their own function and call it from your button click function and your input "enter key" function.
That was my thought, but I'm not sure why it isn't working. Bare with me, I'm new to JS. Do you see any reason why this wouldn't be working? After entering text into the box and clicking the submit button, the function isn't being called. &lt;div&gt; &lt;input type="text" id="repoSearch" name="k" autocomplete="off" placeholder="Search the repository..." onkeypress="return repositorySearch(event)" /&gt; &lt;input type="submit" id="repoSearchButton" value="Search" onclick="repoSubmit" /&gt; &lt;script type="text/javascript"&gt; function repositorySearch(event) { if (event.keyCode == 13) { var centralSearch = document.getElementById('repoSearch').value; location.href = 'https://null' + encodeURIComponent(centralSearch); event.preventDefault(); } } function repoSubmit() { var centralSearch = document.getElementById('repoSearch').value; location.href = 'https://null=' + encodeURIComponent(centralSearch); console.log("Please Work"); } &lt;/script&gt; &lt;/div&gt; 
Just FYI there's also a subreddit for learning JavaScript at /r/learnjavascript where people are very helpful.
You can't use form tags? Wut?!
You need to pass 'repoSubmit()' the event object like in the other function when you define it as the click handler. Also will need the 'event.preventDefault()' like the other one. Doing those things, it worked for me.
I don't really see the difference between npm scripts, makefiles or runjs and grunt or gulp. You will need separate documentation on them all. Finding a problem can be cumbersome in all of them depending on the complexity of your build process.
What happens if you do this: var repoSearch = document.getElementById('repoSearch'); var repoSearchButton = document.getElementById('repoSearchButton'); var newForm = document.createElement('form'); newForm.action = 'https://null'; repoSearch.parentNode.appendChild(newForm); newForm.appendChild(repoSearch); newForm.appendChild(repoSearchButton);
Eric Elliott loves this.
It really is. The browser/web platform is by far the biggest I've ever seen, and it's had an incredible development pace, esp this last decade. There's every single concern of software development in the browser: 1. Plain old architecture concerns of a huge codebase 2. Extreme UI latency concerns 3. Dynamic language that results in unpredictable performance 4. Async everywhere, with an unusual threading model (essentially cooperative) 5. Insane feature creep. This is really what really takes the cake. I've used XSLT/XML to do UI elements back in the day. Not to mention the dozen or so persistence options most browser offer these days. Or the now basically shunned CSS behaviors that Netscape/Moz introduced, that allowed JS to interleave with CSS. The list is long and the browser gotchas are endless. That doesn't mean you can't make simple stuff. But trust me, that knowledge curve on the browser goes really far.
Plain JS? I haven't heard of that version yet. Do they have Island, Forest, Swamp, and Mountain JS as well?
I guess I'm not understanding what you're saying. I've changed the search button type to a button instead. Shouldn't clicking trigger the function that it calls to with the onclick event?
thank you
Everything he mentioned, I'm pretty familiar with and I'm pretty happy with that.
pretty much me. I've been on and off programming forever, but I finally decided to actually try and do something (get a 'real' job, ha!) with it for a change instead of just some tinkering then nothing for another six months and relearning again. it's so frustrating, and even more annoying given the even the backend job offers are looking for people equally skilled doing with JS ecosystem. It's as if I am learning nothing at times.
Anyone know how to clear the integrated terminal in VS code? I tried pulling up the command pallete and it doesn't seem to be an option...
Here's something that'll help ease your mind. None of the stuff mentioned in this article is outdated or replaced. Just more options. Just because Joe Blow is a bandwagon hopper and jumps from tool to tool doesn't mean you have to. Grunt, Gulp, Fly, Webpack, Whatever. If you find it useful and don't want to be overwhelmed and learn something new, DONT. When React came out, Angular 1.x code didn't just stop working. Pick something and stick with them. 
I get the joke, but this is a bit excessive. Simmer down.
Typing in `clear` works for me (I'm on macOS). What OS are you using?
Thats's just spot on. I've started self teaching JS since May of this year and everytime I master a new framework/library someone would tell me "pfft, you're using that? Use this instead! It's so much better" 
Could someone please explain why I am being downvoted for trying to help?
Should talk about javascript development with SharePoint
yeah keeping up with the new JS framework / methodology is really painful, myself I've found gulp to be useful enough to do stylus and minifying and I'm sticking with it as long as it's supported. For framework I'm sticking with VueJS, it's a lovely framework that makes things simple and fast.
You can get really good starter packs on React and Angular 2 with directories and automation/bundling made ready for you so it's a breeze.
Very interesting!! The factory function seems to be an unnecessary complication in most cases, as it introduces a level of modularity that seems a bit extra. I was wondering if you could show some examples of use?
It's not a joke. It's blind rage at people who want to paint web development as an easy job. Tell that everyone of my coworkers who have lost sleep &amp; health working their asses off in crunch time so we can get the gold. Sure there are a few shitty developers who phone it in and are basically glorified IT techs who write a few lines and then type on reddit all day, but there's a lot of amazing hard work being done on the internet, by dedicated hard working engineers. 
Yeah, this is just an example of someone introducing unnecessary complexity and a trend/history lesson to someone for no reason. Need to get data from API endpoint without reloading the page? fetch('/foobar/') .then(function(response){ return response.json() }) .then(function(data) { log/render/whatever }); Assuming everything goes right and you've got a modern(ish) browser, that's it. Something doesn't work? Check MDN, you don't need to introduce any additional tools to figure out how to catch and handle the errors. Eventually you'll reach the point where you *want* to make a build step, compiling and unit testing your code, because there's clear benefits to it. You might want to check some frameworks and libraries so you don't *need* to deal with DOM manipulation or other things manually. They aren't a barrier around writing JavaScript, because they are *optional* tools to choose from when you want them. If you attempt to learn basics of any programming language through understanding the newest advanced tools, you are going to have a bad time.
Reminds me of the Javascript drinking game I heard of: Take a dictionary, open it to a random page, and pick a random word. Google "&lt;word&gt;.js". If it's a Javascript library, take a drink. The winner is the last person to go to the hospital with alcohol poisoning. 
But to a beginner like me, would you say that it will pay dividends if he tries all of the above, like you did, or just stick to vanilla and add slowly? The title of the post is "how it feels to learn JavaScript" and all I toyed around with so far was pure JavaScript and a bit jQuery.
I'm not downplaying that at all, but different organizations have different needs. I'm doing my best to pick up Angular, Continuous Integration, Node, and Unit Testing on my own. Which has been incredibly complicated. But sometimes, like in the article, you just need to grab data from a database and display it in a table. SOMETIMES jQuery is enough to get the job done - then throw it at a templating engine and call it a day. You know?
I love how it's "last person to go to the hospital" not "the person who doesn't go".
This is like how I've felt when I've tried to get the measure of how one develops in Javascript... except that I didn't have a guide, condescending and trend-chasing or otherwise.
The only way to win is to not play the game.
That's a good question, and I think it depends on what your goals are. If your primary use of JavaScript is to enhance web pages, then I think that starting with pure JS and building up from there is a good idea. It's how I got started, but that was quite a few years ago now. If your goal is to eventually build complex web applications, I think it makes sense to start learning the frameworks and tooling sooner rather than later. It's the same in JS as it is in most languages: the surrounding tooling, libraries, frameworks, and build systems are more complex than the language itself. Waiting a long time to start picking up the ecosystem surrounding the language won't necessarily make it easier. I don't meant to imply that there's anything wrong with the first approach (using your JS to enhance web pages). I think that frameworks like React and Angular are often used when server generated HTML would have worked just as well. If you combine it with something like Turbolinks, even on a $5 Digital Ocean VPS performance will feel as instant to the end user as a React/Angular app. There are of course applications where a complex front end framework is the only reasonable solution, but in general I think we should embrace simplicity and fight complexity whenever we can. To help out a bit, you could try starting with Ember. It uses a lot of the complex build tools beneath the surface, but it automates them using ember-cli so you can focus on the application you're trying to develop without worrying too much about wrangling the tools into shape. Angular-cli is almost as good, but last time I checked, ember-cli still did more for you. That was a few weeks ago, though, which is practically a decade in the world of JavaScript. :)
I'll just sit over [here](https://github.com/shadowfacts/type/blob/master/js/type.js) with my 600 vanilla ES6 (and a little bit of jQuery). Trendy libraries that people only use solely because they're "what the cool kids use" or management sees all the flashy looking buzzwords are stupid. This article (and the one it was inspired by) drive home the point really well, the the state of JS libraries is ridiculous. Even the node.js community, with all its ridiculous-ness (*cough* left-pad *cough*) doesn't come close to having the sheer number of trendy hop-on-the-band-wagon libraries as front-end JS.
Glad to hear that this boat I'm in has at least one more person. I understand your frustrations regarding backend dev's having to keep up with whatever form of JavaScript is in vogue. Just always remember that the work you're doing isn't ever in vain because you're taking the time to exercise this skill you've learned. You are never learning nothing! Keep it up!
I had high hopes for this I might give it another shot later but setup time is high and the URL's need work. This is my root route http://localhost:3000/#/?_k=rtj5sa ? Looks like an old version of react-router with no easy option for upgrade since dependencies are buried.
Nodejs, react and gulp. If you can learn those and use them in your sleep, you're golden. Everything else is just "another way to do the same thing".
What, are you not a codesmith?
Quick answer but a website is all about content and is mostly read-only where a web app is about interaction with the user. Check this: http://stackoverflow.com/questions/8694922/whats-the-difference-between-a-web-site-and-a-web-application
&gt; I think we're in a temporary 'Cambrian explosion' period where developer ambition has exceeded the tools we've been able to create to help us manage the complexity we've brought upon ourselves. I agree and I think Angular 2 is precisely what's going to change this.
The backend is in C++, instanced and managed by node on the server, also doing the scaling and balancing. Clientside pretty much most of what's in the article. Webpack, babel, es7 and stage-0 by default. Then react, redux, router, socketio, three.js, many smaller parts and components. 
Yes. But these editors never compile, at least not that i know of, they just edit text, display it nicely and do some linting maybe. If you want to present the content you have to outside the editors scope.
There's a [recaptcha](https://www.npmjs.com/package/recaptcha) module on npm with examples in the [github repo](https://github.com/mirhampt/node-recaptcha).
In general Chrome is fastest with raw JS, Safari Webkit has by far the fastest DOM API. Firefox doesn't really shine on either aspect but is quite consistent over multiple iterations. Then there's differences between various methods/API optimisations for each vendor. It's quite the challenge to find a middle ground, which then is prone to change as well. Source; just working on a (v)DOM library myself, with about the same footprint/measures and another take on the markup abstraction. 
Anything that gets the job done gets the job done. There are million ways to do anything as a programmer and bazillion paradigms and patterns that you can follow if you like them. Most people like different pardigms and patterns. Don't do something that gives you some abstract or pseudo advantage someone else tells you unless you really need it. I have met a lot of coders with code anxiety and screen anxiety. They lack confidence in their own abilities because they have no clue what any of those paradigms and patterns do and why they use them at all. This means if someone sits nearby they have the feeling of silently beeing judged and get anxious and programm slower, because they give too many fucks about whether the guy/girl looking at their screen will approve their code. Fact is, give 100 people the same task and you will get 100 different source codes. Some strongly better than the other, but most are interchangable as long as they are consistent through the project.
Completely agree. The 2nd best thing to a standard is the ability to configure your keyboard shortcuts. Definitely a longer and more tedious process than just an originally adopted standard.
This is solid advice if you've got a stack that works for you on your current project but if you're starting out on a new project it's still a good idea to do a reassessment of the latest options (within reason) to see if there's anything new that might help out. The field is developing rapidly and embracing the latest technology doesn't mean you're jumping on a bandwagon if you're thoughtful about it.
It's hard to understand the minds of people who spend their days up/downvoting people on Reddit, but if I was to guess.. There's a bit too much overcomplication for code that is supposed to be shown to a beginner. This guy is still trying to figure out how to use functions to create reusable code, and the techniques you're using will do nothing but confuse him. Creating an array of the DOM elements and using forEach to iterate through them is a confusing shortcut. It's not easy to follow the logic. Why are you creating an array? Why is there an abstraction for something as simple as creating a click event listener? Surely you could have just written addEventListener on line 21. Why are you bringing in ES6 when you can see that he's not using any of ES6 syntax yet and is at a lower level. In order to get anything from your code, he now has to spend time looking up what const, arrow functions and template strings are. A massive part of being a good teacher is understanding how and what information should be shown to the student, and when. Experienced programmers always struggle with this. There's a time and place to learn most of JavaScript's mechanics. But that doesn't mean you should jump at the chance to teach those mechanics as soon as you have the opportunity. For this particular task, none of those things were necessary. 
I was trying to use the ES6 and import syntax, I'll try the require syntax and see if I that works but don't care at this point tbh. 
I'm a Software Doctor, thank you very much. More specifically, I'm a Front End Doctor.
and i'm surprised why i wasn't directly directed to the project, but instead, to a blog article?
Much appreciate your advice. My end goal is to be a builder of complex web applications, as you said, and someday get into back-end development too.
I can fiddle forever and get paid! Call it best practices! Call it scalability! Call it the future!
You forgot the requirement to update the data when something changes in the server. Time to add websockets to your satire :)
Yeah I think I was just doing too much at once, and I just used the Vue starter project because I thought it would be easier! 
http://eloquentjavascript.net/
I don't disagree but it's very tough for me to understand these concepts, let alone enough to actually use them productively. 
Thank you! What about a templating engine? Is that needed? Also, do you recommend any IDE's or toolpacks for getting started on these things? 
Well said. The last line is a nice soundbyte.
[I would have taken my first drink ever.](https://i.imgur.com/hixAsta.jpg)
Well, you're still just stuck patching your bugs. You'd probably have more other work to do if you couldn't build off their modules. 
The thing is a bootcamp is going to spend 3+ weeks teaching people who know nothing about programming HTML/basic JavaScript/jQuery.
Lol, I don't disagree with you, but your comment is kind of ironic. 
Not sure where you are located, but dev mountain does a great job in my area. They have a web developer boot camp that they offer after hours. https://devmountain.com/
You don't NEED to use any of that. I use knockout so that when object props are set the ui updates. It uses templates, which ARE plain html snippets. There are many libraries that do many things. Most of them are for big projects that are redeployed regularly on many servers or vm's. Do not use Typescript or Coffeescript, they are ridiculous. The latest plain JavaScript features (ES6) are very nice, but mostly just syntactic sugar.
I'm confused by your eye rolling, that's a pretty standard industry term and has been for years. It's not like they're saying ninja or rockstar.
Oh man, I remember YUI existing. Never really used it though, it was just another one of those tools I never looked into back in University as I was still getting into js. 
Do you ever call into the C++ code base using node extensions or are y'all just using it as a web integration layer? 
It is trolling. And the topic's been done to death. I find the tedious proliferation of blog entries like this (and the predictable comments written in response) far more "fatiguing" than the actual frontend ecosystem.
Yeah I know it is an industry standard term. I have an issue with the dilution of one profession just because a group of folks in a different profession want cooler job titles http://www.theatlantic.com/technology/archive/2015/11/programmers-should-not-call-themselves-engineers/414271/
Ah... the Google flavored version of YUI. I think every big company released their own monolithic Javascript library in 2006. That's also the year JQuery came out. Edit: And Moo Tools in 2006 as well. Dojo squeaked into 2005.
Dude, if you were a grizzled veteran with three whole years under your belt, you'd understand that coding is learning how to do something once, then repeating that until you retire. Having to think and learn and weigh pros and cons when deciding what to use is beginner shit.
*shrug* the usage has been around for nearly 50 years, get over it.
Plus you can't cancel a request using fetch (as far as I know). This isn't necessary an obscure corner case - if the user is on a patchy mobile connection (and living in a developed area doesn't necessarily mean mobile is always fast), you can't give them a way of backing out of a request and freeing up the connection for other things.
Quality of the transform may or may not be alright but, the pattern itself is an anti-pattern IMHO. JavaScript aint Java...
This seems really really awesome. Hopefully I can get some time to dig into it a little further. Does this mean that a node server is serving up parts of walmart.com? Or do they have a node server behind something like apache (my guess)? 
So are you saying I can still use jQuery in 2016? :)
Python 2 or 3? Sigh
You gotta go Python 3.5 if you want to use Async and await, but if you want to use Linear String Interpolation, and trust me you do, its 3.6 all the way. Also Dicts are ordered now for no reason.
It feels like we get one of these each week now 
So the only way that I have birthday included is by including it in the constructor, so in function Person(name) { this.name = name this.birthday = { month: 0, day: 0 } } ?
I quietly wept while I read this. All of it is real, all of it. I miss the days when the only problems we had to worry about were getting our websites working in IE6. Nowadays most of my problems are tooling related or because some npm dependency failed.
The funny part is that I hear the exact same complaints from web developers that start to go into the desktop development world. That there are too many tools, that the documentation is terrible, that it's very tough to get started, that dependencies are hard, that it seems over complicated, and that it feels like you are fighting the tools until it finally "clicks". It's almost as if these are just the pains of learning a new stack... But because there are SO MANY people jumping into this stack now, its front and center. It's also still heavily in the "growth" phase, so there is more "churn"/development happening than in some others. That feeling of being overwhelmed, its normal. Step back, take a breather, figure out what problem you need solved, and start looking for a solution for that, without caring what is coolest.
Yes, I do. What I am building now uses jQuery on the landing and React on the actual app itself.
Agreed. If you use just plain nodejs then maybe you need to throw one in (take your pic, learn one, learn them all), but don't, use react. All these options are just that.. options.
Engineer is a protected title _within its industry_. The point you are missing in its entirety. You're the only one taking offense here.
Constant learning is part of the job.
every god dam week we get one of those posts
This. I hire problem solving skills, the desire to learn, and the ability to stretch.
Except within 6-8 months using Gulp and React will make you look out of touch. If it doesn't already. Not saying it should be that way, but it is.
Yeah, depending on the size of the bugs, patching them yourself is still much cheaper and easier than building the entire thing from scratch yourself. The existing libraries you're using aren't going to suddenly stop working. 
Google still use GWT in a lot of their web apps, I don't think it's dead just yet. 
website: bobsbirdblog.com app: emailservice.com Is it really that difficult of a distinction? 
this article makes a lot of salty
"No JavaScript frameworks were created during the writing of this article."
Learning languages is easy, learning ecosystems is difficult. 
I don't think I've had this much laughter out of any programming article
Ugh I have no clue if I should do this... I feel like I've been using so much js and all of its frame works available, I've managed to solved problems and figure it out but Idk how song my js skill really is. Unlike java/C++ where I learn from the core and did all kinds of things with it before even dabbling outside the standard libraries. Also been doing a lot of java script at the job, not sure how valuable that as well compared to like more low level programming.
Wait are you serious?
No it won't. One could argue that Webpack is better suited for React development (and has been for a couple of years now) but Gulp is a great workhorse. React is going absolutely nowhere for many, many years to come. 
This post has 458 up votes. These posts are like the "...and doctors hate him!" Types of posts. They obviously get views, and people keep posting them to places like here. 
Say, uh.. How much did you pay for Angular?
Ok, when I just typed "3.", Reddit's markdown converted it into a list starting at 1. That's so weird... So, learn Python 3, not 1 lol
most off its useless more than unnecessary. 
You should use offset().top - window.scrollTop()
I guess I would say, show a more specific example of a problem that arose that was then solved with this format. I guess the main issue I found was that rarely in my day to day use of components do I have such a general implementation of anything like the example in the article, so maybe an example of that.
He said "1." because reddit's broken markdown implementation takes any number at the beginning of a line followed by a full stop as a numeric list item. All numeric lists start at 1. So you type "3." and get "1.". This bug has been known literally since reddit introduced markdown commenting, and nobody cares.
and if you already know everything you're all set
Chrome would report a network error in red.
Yes, this creates a new object for each instance.
Fair enough. Some new language features such as `async/await` and literal string interpolation are available in 3.5 and 3.6 respectively. After Raymond Hettinger pushed for iterators and generators, they became everywhere. They are much more efficient. `range` and `zip` now returns an iterator, and `dict.items()`, `dict.keys()`, and `dict.values()` all now return iterators ("views"). [Also, the Python Software Foundation is ending support for 2.x in 2020.](https://www.python.org/dev/peps/pep-0373/) 
Yes, let's all point and laugh at the dinosaur. But it's [used by 1.6% of the top ten million websites](https://w3techs.com/technologies/history_overview/javascript_library/all), whereas Angular is at 0.4%. JS really has a problem with recency bias. 
how would one use es2017? is it supported in the latest browser? 
You have to start somewhere.it sounds like you're already in over your head. It would be better to work on simpler problems first, or hire someone to help you.
Even if I don't pay for something, I think that it's ok to be upset about broken promises. If you put out a software product, and encourage people to use it by making promises about its longevity, then I think it's fine if those people get upset when you don't deliver on your promises. If you are *unable* to make good on those promises, then maybe you could respond to people using your product with an apology or *something*. Anything other than, "I know that we promised this was a stable product, but Angular 2.x is the new hotness, so we're closing all bugs and won't work on them. kthxbai." I might expect this from some random JS library from a single person, but Angular-Material is hosted off of the official AngularJS Github Org/Account, so I do hold it to a bit of a higher standard. That said, they want to push forward with their product. How believable are their future promises of support and longevity?
My first job out of school forced me to learn OOP and Laravel, both of which were totally new to me, though I had about a year of experience using PHP in school but not on a professional level. It took me about a month but I finally got it. The people that hired me said they knew from my portfolio that I had a passion for the field and proven ability to learn fairly quickly and I did given that I had to learn my first PHP framework and OOP at the same time. Sometimes charisma and proof of dedication are what matter most to good hiring managers over specific knowledge of certain frameworks.
you guys are too funny - made me chuckle
Please expand ?
In less than three months we'll be in '17, so brace yourself ...
I imagine all the driving to hospital would sober you up anyway.
Well by your standards of all these people who get hacked... its hella hard to be your "engineer" I know some of the best securities experts **in the world** whose system has been hacked... as well as many companies who spend billions on security, not to mention world states like China or the US. There aren't people constantly trying to bomb down bridge, buildings, or infrastructure as for your "standard engineer" like there are millions trying to hack your system... again that could be a person or as big as a whole country like Russia. I work in a well known company and you sure should get ready to go out the door if security is not your concern. I cannot name a single company in the world who hasn't been hacked. therefore, software engineers do not exists?
We are behind nginx. I talked about our production setup a little here - https://medium.com/walmartlabs/enterprise-nodejs-on-oneops-f4bc7b1050cc#.yet11ix30 
Well, gulp is already being replaced by npm scripts in the project I work on.. Gulp is so spring 2016!
Fair... I doubt I'll ever find myself in interviewing positions where the focus is upon javascript &gt; overall programming capability though. Do you interview those people for quite a specific position that your team desire? edit- just realized we're on a js subreddit and not generic programming lol
Check out this answer on StackOverflow: http://stackoverflow.com/a/24829409
 function doPost(request){ var thing = JSON.parse(request.postData.contents); var payload_s = { "chat_id": '&lt;id&gt;', "text": thing } var data_s = { "method": "post", "payload": payload_s } UrlFetchApp.fetch("https://api.telegram.org/bot&lt;token/sendMessage", data_s); }
It becomes a problem when one ends up bleeding into the other.
I've not seen any of the same topic. Depends on what you've been consuming. I think you should be able to see that posts like yours are actually annoying for someone like me who just wants to read without someone whinging about the the topic being overdone from their point of view.
 &gt; async/await I think we've come full circle now...
Using the right tool for the job at hand, eh? Careful, there! That sounds like an Engineer's approach to solving problems :)
Go look at the what jquery does 
They just doesn't. 
I really doubt you have been using React and Webpack for three years but good insight if that's the case.
Well if you're a solo developer maybe, but if you're working inside teams, if you take a new job, if you have new and old projects to maintain etc, you're doomed.
Lost it at *"Our libraries are huuuge, and sometimes we include pictures of Guy Fieri in them"*. Great article. 
Additionally, it's kind of meaningless to say "State management", "A testing suite", etc stay consistent, when these are just generic ways to describe tools. Part of what the article complains about/notes is how (relatively) rapidly the specific libraries/frameworks used for these purposes change.
I cringe a little every time I see someone using stage-0 for serious work
No, the best way is to use babel.
For convenience only because it loads all transforms into node_modules. The lowest stage feature is 2, the rest is 3 or above, most of it already native in evergreen browsers. Stage-0 catches all and doesn't have you shuffle webpack configs every month. 
[Button](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button): type / submit: The button submits the form data to the server. This is the default if the attribute is not specified, or if the attribute is dynamically changed to an empty or invalid value. You're submitting the form, and without an action, it posts back to the current URL. Hence the "refreshing".
This is true, but it is important to prepare people for the cold truth: that you NEED to understand DOM and JS (and, to a lesser extent, CSS too) in order to work with them. Frameworks can help mask the gaps of knowledged because they abstract some of these decisions away, hide them behind APIs.
You should not feel bad. Yours is a very sane approach.
Either change the button type to `type='button'` or prevent the default action in your function. ```function f1(event) { event.preventDefault(); // rest of code ... }```
It is real if you let it be. What I mean is this. If you try to keep up with every single new "simple/elegant/beautiful" framework out there you will definitely feel the fatigue. Just pick a handful of solid libraries and build something useful.
Not sure if i understand this right. You install npm packages, then script include it with a fixed path reaching into node_modules? No package in npm relies on fixed/hard paths and goes through node_modules on its own. Instead it declares dependencies, and these declare theirs, and so on. Everything is installed on "npm install". Then the package requires what it needs. At compiletime your bundler will resolve these require calls, pull the code (from node_modules) and include it into your output bundle. This is why node_modules is never published or uploaded. In the end you have a self contained bundle, you don't need need to drag folders along, nor do you need to rely on cdn's. If you don't have a bundler like webpack or browserify, using npm will be hard. Bower is for you. Though that is very old technology and bower is dying. 
That isn't exclusive to js though, that's my point.
I suspect the difference is that you're using this stuff full time. Those of us who have to do rotate into javascript every few months find the landscape shifting under us continuously.
X-Post referenced from /r/opensource by /u/johnjones4 [Amjad Masad (_theInitialCommit)](https://www.reddit.com/r/opensource/comments/55t98n/amjad_masad_theinitialcommit/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Hi /u/speckz, this exact post is already #1 on our frontpage, please take a quick look before posting. Thanks!
Whoops! Negative numbers shouldn't "work" on the web or in the library, but none actually return good error messages. I filed an issue for that: https://github.com/passhelp/passhelp/issues/1
reactjs / reactnative
Here's how I would do it: http://codepen.io/pakastin/pen/KrGavN
Which is exactly why I didn't name any one library specifically. React as an ecosystem had a lot of churn those first couple of years but there were always a limited set of products to choose from when it came time to evaluate new tech. 
You also have to remember that even if you do eventually stop using a particular tool or framework you've invested time in learning how to use, that time is still valuable to your growth as a developer. It also teaches you how to pick the technologies that are worth investing time into in the future. 
Anyone wanna play [this game](https://duckduckgo.com/?q=random+word&amp;ia=answer) now?
I remember when Javascript + HTML was called [DHTML](http://dynamicdrive.com/).
Google "Sharepoint sucks revisited". To see the scope of how much SharePoint development sucks. 
IE6 support was a special level of hell for me, I'd rather have trouble learning new stuff than go back to dealing with supporting that dinosaur again. IE8 didn't even have indexOf. That's a world I'd rather not live in.
This is actually what is driving me into DevOps and away from a 14 year Frontend Career
[removed]
By the time it got to the last person, they're not likely to notice they're drinking alone.
You'll need to post the code which is calling the `doPost` function. `request` is `undefined` when you reach the offending line. Since `request` was passed in as a parameter to your function, it is probably either not passed at all from the calling code, or the variable which was passed was not assigned correctly. Also, you'll most likely need to update that URL you're posting to in order to correspond with a real Telegram bot token. In the API documentation, &gt; All queries to the Telegram Bot API must be served over HTTPS and need to be presented in this form: https://api.telegram.org/bot&lt;token&gt;/METHOD_NAME. Like this for example: &gt; &gt; https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/getMe It appears that the `bot&lt;token&gt;` portion is meant to be replaced with the token you generate when you create a new bot on their platform. If you already knew that, sorry for jumping ahead :)
What actually happens is that != does type coercion and !== doesn't.
thats what i meant, well explained though! :-) thanks! 
*2016: Serious and mature adults are seriously bitching among each other about broken promises made without any strings, from megacorporations, in an unironic fashion.* Seriously, I could write pages about how fucking retarded this industry has become. 
Put it back in the input field? document.getElementById('yourinputtag').value = value; &gt; Ideally I'd like the value to be sent to the server unformatted. The most important thing here is how it's displayed to the user. Well, input fields display the value they are going to send to the server. You could however, change the formatting again back to no spaces, when the user clicks on the submit button.
There is [this long discussion](https://github.com/whatwg/fetch/issues/27) about cancelling a fetch request on the github polyfill but AFAIK it's not a standard feature. Promises can't be cancelled either on standard implementations.
Why?
Then again, I know Java, but have a really hard time contributing to our back-end because I know nothing about the entire stack.
This is so sad it's hilarious.
I haven't tested this, but is it because `type=number` doesn't display spaces? Maybe check out the [`pattern` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) to keep the right keyboard but give you more flexibility over formatting. 
Try it now: https://replic8ors.com (works best in desktop Chrome) https://github.com/Metaphile/Replic8ors Replic8ors is a personal project I've been working on for the past two years. I wanted to learn more about artificial neural networks (and evolutionary algorithms), but all the info I could find on ANNs was pretty abstract and technical. I wanted to actually _see_ them in action, to hopefully get a more intuitive understanding of how they work. I found some simple visualizations on YouTube that inspired me to create my own simulator. It's written in ES6 JavaScript. It includes a Jasmine test suite with ~100 tests. TDD was absolutely invaluable for implementing the neural nets. For the build system, I had a bad experience with `gulp` initially and decided to use `npm` scripts instead. It seemed like the simpler solution but it ended up being a pain. I would use `gulp` (or whatever) in the future. Anyway, I would love to know what you guys think about the project, answer questions, etc. Thanks!
It means you can't change (mutate) it. Once created, it will stay the way it is. So, you can't actually append something to a string. You can only create a new string which contains the contents of both. Strings don't necessarily work like this. In C, they are just an array of bytes and the end is marked with a binary zero (\0). Anyhow, when you write "x = 'foo'; x = 'bar'" in JavaScript, you create two separate strings and you just make 'x' refer to that new string. The old string will be thrown away (garbage collected) if no one else is still referring to it.
funny, your opinion on javascript's biggest problem is actually my take on what is the best thing in javascript compared to other languages. 
Sounds like bullshit. How exactly you know how much time it took if that tool wasn't made yet?
In that case you should some other programming language.
&gt; Webpack is better suited for React development Why is that?
Uhm, sorry it sounds like that! Every time when I opened my laptop to write code for this tool, I logged my start/end time to Google Sheets. When I made a video, I summed up all coding activities, and it resulted in 628 minutes. Why do you say that tool wasn't made yet? https://time.anvaka.com/#!/ - this link doesn't work for you? **EDIT:** Thanks for explanation that it was a joke! I wasn't offended at all. I'm sorry I didn't understand it :). By the way, the tool was usable from the very first commit, so if you checkout the initial version, you still would be able to log time with it: ``` git checkout 62687e46d3c768f50400bc3dc95a1f699c64b626 ``` 
querySelectorAll returns an element list. You need to pick one of those elements or use querySelector instead to pick just the first one.
Honestly, I still just stick to jQuery and whatever styling framework I'm handed. To me, all of this workflow, these libraries, and these frameworks are just attempts to cover up for the fact that JavaScript's "standard library" (if it can so be called) has always been weak, and I don't just mean weakly-supported by browsers. There's a lot of boilerplate you end up writing if you try to do vanilla JS. If more functionality were to be "baked in" you wouldn't see every Anders-Hejlsberg-Dennis-Ritchie-wannabe trying to make their paradigm of JavaScript a reality through frameworks because the paradigm would be a part of the core of the language.
True, but as a guy who is doing JS after doing database, .NET desktop, and microcontroller programming... I have to say, I don't feel like I'm *learning* as much as I am being forced into trends that are ultimately meant to fill-in JavaScript's extant weaknesses, and the trends are constantly changing. It's not like there's a massive movement towards one single goal. It's a thousand different ideas going in separate directions, hoping one of them ends up at the correct destination. In the age of open-source development, that's weird. We should be picking out the best and integrating it into development ecosystem-wide, not rebranding the best every few months.
That is awesome! Thank you! It also means I didn't waste my time :)!
Ampersand-State is a fantastic upgrade to Backbone.Model. It has built-in support for plain attributes, computed attributes, and "session/client-only" attributes, as well as nested models and collections. I think the And-Yet people have pretty much migrated to React+Redux at this point, though, so it's probably not being "maintained" much, but it should be very stable. We have a Backbone+Marionette app that started off using Backbone.Model, but we migrated all of our Model classes to use Ampersand-State instead. I did have to write some shim code to support putting Amp.States into BB.Collections and vice versa, but it's worked out well. I'm completely all in on React+Redux as a toolkit at this point, but there's still something to be said for the simplicity of a Backbone-based setup. FWIW, there's a number of Backbone+React adapters out there that let you tie Backbone Models and Collections into your React components, or even render React components inside Backbone Views. Backbone certainly has weaknesses, but it's still usable. Also FYI, I keep a big list of links to high-quality tutorials, articles, and resources for React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Might be some useful info in there for you. 
OkCupid is a very well known one 
The Redux docs says that Redux is framework-agnostic, but does anyone out there actually use Redux with vanilla js? Is that just overkill? Or impossible?
It's a much more configurable, and powerful build system than something like Browserify. I would highly recommend it for complex applications that need features like code splitting, tree shaking, and multiple file type inputs. But gulp and Browserify are still perfectly adequate for smaller apps. 
&gt; This isn't trolling, it's satire I'll be honest, it doesn't feel like satire. Did you see it get [cross posted](https://www.reddit.com/r/programming/comments/55okik/how_it_feels_to_learn_javascript_in_2016_xpost/) to /r/programming and get 2,869 upvotes? The highest post (600+ upvotes) is basically agreeing. There is a real feeling that this is a problem, so maybe my choice of "trolling" was extreme. I don't feel like it's satire either, though. &gt; There are so many choices and these choices change daily, and most people don't have the expertise/experience to be able to filter through all of the hype I actually feel like this is pretty easy to resolve. The Frontend Focus newsletter guy has some quality newsletters people can subscribe to. That helps with the filter of all the noise. They can participate in a community and ask. You can even subscribe to feeds to see what has changed daily with NPM (I do this, and it's actually great). But once again, they probably are on the novice side of skills. At a certain point, you learn how to research a tool/framework/library to make sure it suits your needs before going with it. You know how people still talk about how great VIM is and how that's all they use? Same thing applies. There are other editors/IDEs they can use. But what they have works, and there isn't a need for them to migrate to something else. Why create more work if they don't need to. &gt; which framework/libraries would be best for their specific purpose. If you aren't able to anticipate the needs of your project to hit that initial 1.0, you need to start simple. Too many people tell others "you need X, Y, and Z to get that done" when they really don't. They are too novice to need those. I think you bring up good points. I don't want it to seem like I'm attacking you, because I'm not. Too often we tell people who want to learn to develop in a language that you start with "hello world" and go through a bunch of excercises. We fall short as a community at large by not teaching people the rest of the equation. If we could find a way to solve that, the entire development community wins. 
Why is that? :)
The visualization is pretty interesting and well-designed. Could use a faster speed setting, as it takes quite a while for something interesting to start happening.
Given how in demand Web programming is, in general, nobody should have too much trouble finding a job unless you're just out of school with no real world experience, but even then, if you have a good portfolio and prove you have a passion, you'll still find a job fairly quickly.
[there u can find some answers](http://stackoverflow.com/questions/3711645/css-use-tag-type-before-id) 
This is a good secure source as well. https://www.grc.com/passwords.htm
Dark humor. It describes perfectly how I feel about this javascript framework mess.
I mostly trust GRC, but you're going to have to explain your thoughts here -- they even generate passwords server-side, which was one of the things I was specifically avoiding. passhelp will *only* use a secure RNG in your browser (WebCrypto). If it isn't supported, it won't work at all.
I agree that it's very difficult to get security concepts right, but I do wonder how I'd be able to _use_ GRC's implementation when it's not public. I was careful to use well-documented RNG sources and apply them with common, practiced methods to ensure the output is as random as the input (linked [earlier](https://www.reddit.com/r/javascript/comments/55t999/i_made_a_nononsense_password_generation_library/d8dgbjq)). No NIH here; quite the opposite.
&gt; Could use a faster speed setting I thought this would be really easy to implement--it's just a number, right?--but increasing the simulation speed caused some weird graphical issues. For the simulation itself I'm using Euler integration with a fixed timestep, but in parts of the visualization I'm cheating and scaling the timestep. It was never a problem during development... I found a quick fix but it's ugly. I need to rethink the visualization loop. In any case, Fast is now much faster. Thanks for the suggestion!
&gt; But you know, there are people out there who will think you're a dinosaur who's stuck in 2014 Please let them never find out that the command line exists.
 var myvalue = document.getElementById("textbox").value, p = document.createElement("p"); p.appendChild(document.createTextNode(val)); document.getElementsByTagName("body")[0].appendChild(p); That is it in the most simple way possible. Please avoid document.write. It is 90s era technology that should be retired.
No, its a bunch of code. I suggest running it through a beautifier and reading the code function by function and then asking more detailed questions as you come to them. https://prettydiff.com/?m=beautify&amp;s=https://cdn-akamai.mookie1.com/LB/LightningBolt.js&amp;correct=true&amp;objsort=all&amp;vertical=all
If I understand correctly, the cartoonist is comparing people who think modern JavaScript development is too complicated to unsophisticated cavemen who fear change. I think they're missing the point. I know *how* to set up a new project with npm, install webpack, set up a babel-loader, sass-loader, and url-loader, and separate my build into multiple bundles, and set up live reloading on dev server, and make it run the tests in real-time; I just don't want to. Or, more precisely, I don't want to have to. With most languages, *understanding* the technologies is enough to make them less painful. JavaScript is still annoying, even after you know what you're doing.
I found it.. http://www.xaxistech.com/LightningBolt/ Thanks, it wasnt meaningful! 
I made the connection, but satire usually has a point, right?
I use Toggl for the same. Pretty good job, I guess you were not new to Vue. Coding it up quite fast.
To an extent, that's a fair point. JavaScript is held to a higher standard. OTOH, building a Java applet never required anything like a TypeScript instrumenter because Java is already strongly typed. A lot of JavaScript's problems are caused by lack of native features and APIs. EDIT, Another example: Java doesn't need a Promise polyfill because it has good async primitives. 
I use Redux with vanilla js. At first I thought it would be overkill but Redux is so lightweight that it's actually extremely easy to use and fitting for most use cases. 
You got it. The 'problem' pointed out by this article is not framework proliferation, but poor teachers. Maybe also a lack of documentation or tutorials for completely new users. The technology wasn't the confusing part of this hypothetical conversation, it was the unhelpful attitude of the 'js expert' who insisted on pushing inappropriate advice on the novice.
&gt; building a Java applet never required anything like a TypeScript instrumenter because Java is already strongly typed This is an opinion held by *some* programmers who simply can't accept weakly-typed languages, and it still has nothing to do with building applications delivered via the internet. There are plenty of teams still using ES5 with weak typing that don't need or want typescript. Javascript is getting async primitives, and that may be the only thing I like coming from ES6/ES7. Practically everything else is syntax sugar that doesn't solve any problems. Javascript is getting a promise primitive, but that doesn't really mean much - it's not the only way to accomplish the same goal. And using a promise library isn't the end of the world either. 
Explain the need for these transpilers. Can't I just write JavaScript correctly in the first place?
if you think jquery is the right tool for anything these days, you're deluded about being a competent FED
The basic point is that analysis paralysis is stupid no matter what excuses you throw at it. Make a damn decision about what to do and move on. A bad decision is better than no decision at all.
&gt; Whether or not strong typing is good, is immaterial. Exactly my point. &gt;The point is that people have to jump through an additional hoop to get it. What if I wanted weak typing in a strongly typed language? What kind of hoops would I have to jump through then? 
Yes I know how it sounds. But I'm pretty sure Angular 2 will be a stable refuge for all this javascript fatigue.
&gt; hellbent speed of the community and their willingness to abandon the tooling set of yesterday for a completely new and different tooling set today I agree with this, it's due to the immaturity of many developers entering the "ecosystem" and deciding they want to do things their own way, and creating a new library to solve a problem that's already been solved many times over. The amount of people getting into javascript in the last few years is practically an explosion. Many of them don't know why things are done the way they are, and so often they have to learn those lessons the hard way. That has no bearing on me though, I already know what I'm doing and I know how to avoid jumping on bandwagons. Some people, even CTOs don't know that, and so we see a lot of job applications with "everything under the sun" requirements. I've actually quit jobs when the CTO got too crazy about the latest fads. He was chasing technology instead of chasing the dollar, and their product is still developing slowly. Changing back-end tech 3 times and front-end tech 3 times is a waste of time and resources in the startup world. 
&gt; What if I wanted weak typing in a strongly typed language? What kind of hoops would I have to jump through then? Well, Java, for example, already has auto-boxing and auto-unboxing, and many of it's core APIs are overloaded, so you can already ignore types to an extent. If you want truly weak typing, you could declare all your variables as Objects. This will essentially do the same thing as `var` in JavaScript. To call methods on these variables, all you have to do is use the reflection API. So Java basically has weak typing natively, without having to download a third-party API or toolchain.
Ok thanks. The thing is this uses a form and I copied it exactly except for using lower case and changing the name of the form. http://www.javascriptkit.com/script/cut18.shtml Where is this submitting the form to? edit: I guess it doesn't because it doesn't use a functon, just directly submits "OnClick="Calc.Input.value += '1'" to Input
you're right, I overstepped my bounds. I am impatient and want to start coding instead of learning 100s of codes, but I should stick with what I've learned, as confucius said &gt; By three methods we may learn wisdom: First, by reflection, which is noblest; Second, by imitation, which is easiest; and third by experience, which is the bitterest. imitation is just quicker
&gt; abandoned tommorow for something else that's just that little bit different enough that it doesn't work with what you got so far. My only regret is I have but one upvote to give.
&gt; The point is, a developer creates the hoops that they think they have to jump through. If a dev thinks they need transpiled scripts and virtual DOMs rather than plain javascript and HTML, then that's on the developer, not Javascript and not web browsers. If lazy loading is a requirement, then it's another hoop. If web sockets is a requirement, then that's a hoop. There's a shitload of things to learn about browsers and web tech, and that's why people specialize and it's why being "full stack" is probably not a good idea in larger projects. I don't disagree with any of that, but I'm still not sure about your original point that things such as HTTP make web applications a uniquely difficult problem. I think the problem has more to do with a combination of people being too eager for new goodies, and goodies not arriving fast enough. Angular 1.x is adequate for most applications, but a lot of people (myself included) want ES2016 yesterday. Troubleshooting webpack builds has made me more patient, though :)
`$('body').append($('&lt;p/&gt;').text($('textbox').val()));`
No other language is being asked to accomplish the feats that are expected of JS.
You can add a while loop to do nothing until they enter the correct phrase. while (currentInput != "open door") { if (currentInput != "") { console.log("That is not how you open a door, try again."); currentInput = ""; } } It should wait for the user to enter the correct phrase before continuing the code execution. Like my example, you can make it do stuff when they enter a wrong phrase. That could potentially cause an infinite loop, however. So to solve that, you can use a timer function, which would change my previous code to: var timer = setTimeout(checkInput, 2000); This will call a function 'checkInput' after 2 seconds. Then you would have prety much what I had earlier, using an 'if' statement rather than the 'while.': function checkInput() { if (currentInput != ""){ if (currentInput != "open door") { console.log("That is not how you open a door, try again."); setTimeout(checkInput, 2000); } else { console.log("Door Opens."); } } else { setTimeout(checkInput, 2000); } } If the user doesn't enter the correct phrase, it will keep calling the function every 2 seconds to check again. 
Compare innerHTML to innerText, the difference will be the tags, get the index of the tags in the string, copy them out, work out where they should go based on the amount of characters changed and put them back in. 
Thanks, I will look into d3, so far it looks pretty sick.
Amazon...
Like an animal.
On the other hand, the web has INCREDIBLE back compatibility. Load any website from the past 20 years - it still loads! It plays with horrible background midi tracks and DHTML hell! Just because you CAN use complex tooling from the future doesn't mean you HAVE to use it. The excellent part about this is that some of our old standbys like jQuery, Knockout, or really anything isn't going to spoil or rot away. The worst part of abandonment is that potential security flaws or bugs may go unfixed. If things are dire you can fix them yourself. The hype train is real, but you don't have to ride it! Pick solid tools and build cool stuff. When what you are trying to build exceeds the complexity quota for your current toolset, then consider moving forward. Most web apps aren't Facebook or Netflix or whatever is trendy at the time, so don't treat them as such!
This renders blazingly fast! Is that bump mapping on the coins? Is the light pre baked somehow?
Everything was fine with my lunch.
How about considering I don't read it every single day and only for the last few months. Easy to imagine isn't it?
`(void*) some_variable` C doesn't make it too hard :p
Interesting that the author seems to sing a different tune in [this strip](http://cube-drone.com/comics/c/encapsulation) about containers. Incidentally, I like this comic! Even the SJWy ones are funny.
Javascript hasn't really changed since ES5. (ES6 is more convenience than change) You don't HAVE to use All The Libraries. You really don't have to use any... I always say if you need a makefile for your Javascript you're doing it wrong. ...and I run engineering for a HUGE website.
If only more companies actually followed that philosophy, though... I got rejected from a job because I didn't have enough ASP.Net Webforms experience. Even though I've developed Grails applications and worked on applications that were written in Struts 2*. I figure the skills would transfer over pretty well (and I've had some decent C# experience to boot), but I guess they really want someone solid in ASP.NET webforms. \* If you don't know what those are, Grails and Struts 2 are Java MVC web frameworks. The former was pretty fun to work with, although the combination of Spring Boot + Groovy + Thymeleaf is basically the same thing now that Grails is pretty dead. Struts 2 is a pain in the ass because it's basically XML-driven. 
JavaScript is largely an event-driven language. If you attempt to think of each line running one after the next and `waiting` for some user input, you're going to have a tough time. You should attach events and listen for when conditions show up. Instead of attaching a listener that waits for all keypress 13 on document - attach one that checks for the specific conditions of lvl1 passing. Once those conditions have been met, show the success message and remove the event handler. (js event model is kind of screwy like this, you'll need to create a variable to hold the event and pass that same thing to both `on` and `off`) If you follow this pattern, the function should maybe be called "checkForLevelOneCondition" -- something like this: function levelOne () { console.log('welcome to level 1!') $(document).on('keypress', checkForLevelOneCondition) } function checkForLevelOneCondition(e) { var conditionMatches = e.keyCode === 13 &amp;&amp; $('#player-input').val() === 'open' if (conditionMatches) { console.log('you made it!!') $(document).off('keypress', checkForLevelOneCondition) levelTwo() } } You can use this pattern for subsequent levels - each can have a function that basically logs 'welcome to the level' and attaches the next event handler. What you have right now, attempting to do all of lvl1 inside the lvl1 function isn't going to work; you need to show the welcome message and once it is shown, the function is over and you are done processing and the application should wait, through the document keypress handler, on what to do next.
Hah! 
C'mon man, I think we both understand he means that JavaScript "meta".
Followup: I was able to start work on adapting my presentation this evening. Should have it knocked out in another day or two. I'll post a link here when it's up.
&lt;script type="text/javascript"&gt; function showImg() { /* The showImg() function displays a random image from the 0.png through 9.png files. The random image is designed to thwart hackers attempting to enter the library records database by requiring visual confirmation. */ var imgNumber = randomInteger(9); // Return a random number from 0 to 9 document.write("&lt;img src='imgNumber.png' alt='' /&gt;"); } &lt;/script&gt;
I am going through something similar and though the features of handsometable's can be replicated, you will find your biggest stumbling block to be that any sort of reliable copy and paste to a html table will work most of the time in IE and not so much in chrome or firefox. 
**OOPS:** sorry I am an idiot, I just learned that React components transpile to React.createElement(**ComponentName**, props) just like mine was doing. So I put a **typeOf tagName === "function"** in the vdom create function, thus working.
Your code is expecting to find imgNumber.png on your hard drive. When it doesn't find it it indicates the problem with the box and the x.
&gt; the complexity of the tooling but the hellbent speed of the community and their willingness to abandon the tooling set of yesterday for a completely new and different tooling set today First ... * Tonnes of people still use jQuery. * Tonnes of people still use old build systems over newer ones. * Tonnes of projects don't use node/npm. * People are still building new sites in Angular 1. Of course you don't hear any big stuff online about Angular 1. People still use it **for new projects**. A lot of people. But second, when you interview web developers you often find a running theme. When a front end scales badly it scales *very* badly. It can very quickly become a mess. This is also part of what is driving new frameworks.
&gt; isn't this list the same as the one we're using in filterFn? You're referring to the anonymous callback that's passed as the third argument? Yes, the `list` parameter received by that function (and which the function goes on to use in `list.forEach(...)`) is the parameter passed to the callback on the last line in the function exported by the module, at `callback(null, list)`. &gt; If it is, that means the function in solution_filter.js gets executed in its entirety and then the list in filterFn gets the value from it. Yes. Why's that confusing? The `list` in `solution.js` is a parameter passed to the callback. Nothing inside that anonymous callback exists yet when that code runs. The callback has been defined but not executed, so variables don't have values yet. The contents of the callback is a different scope from the surrounding code. 
This is a repost... from somewhere. I had the tab open in my browser, almost certainly from a Reddit link somewhere, but now I can't find the original submission. Hence the post here. Incidentally, I tried what he suggested and it failed with an ENOENT error: &gt; ENOENT: no such file or directory, rename '[SNIP]/node_modules/react-scripts/node_modules/babel-plugin-transform-es2015-unicode-regex/node_modules/regexpu-core' -&gt; '[SNIP]/node_modules/react-scripts/node_modules/babel-preset-es2015/node_modules/regexpu-core' 
Replying to myself... same issue as reported here: https://github.com/facebookincubator/create-react-app/issues/770 I updated to the latest version of node and it worked fine.
document.write("&lt;img src='"+imgNumber+".png' alt='' /&gt;");
You are right except that the goal is to avoid to replace the DOM on the client and only setup the dynamic behavior of the app. It's what I understood at least. :)
This is pretty obnoxious.
Feels great, to be honest.
&gt; the comments on Reddit were not totally dominated by anti-JS rants and bile Eh, a lot of it was actually.
True, but not as bad as it was a couple weeks ago. 
[Here's a video that explains the event loop and async](https://www.youtube.com/watch?v=8aGhZQkoFbQ), which is what you're dealing with here. `fs.readdir` is an asynchronous operation. Which means that instead of executing on the main stack and blocking it while it spends ages reading the directory, it gets chucked onto the event loop and returns later when it has finished waiting around for input. Because Node and browser-based Javascript is single-threaded by design, so you can't block the stack with slow operations like reading filesystems or network requests. A simpler example of async: var foo = "bar"; setTimeout(function() { foo = "baz"; console.log(foo); }, 5000); console.log(foo); So in this code: * `foo` is set to `"bar"`. * setTimeout an asynchronous operation so it gets put onto the event loop. * return in 5000 milliseconds (5 seconds). * set `foo` to `"baz"`. * `console.log` the value of `foo`. * `console.log` the value of `foo`. The result of this script will be: `"bar"` (5 second pause) `"baz"` It doesn't stop and wait for foo to be set to "baz" before continuing to the `console.log`, because that is an asynchronous operation. The way you get access to something returned from an async operation is by using that function's callback, because that callback exists inside of the scope of the code that has come back from the event loop. In your code all you're doing is creating a wrapper for `fs.readdir`so you pass your own callback function in and call it inside the `fs.readdir` callback. ES2015 Promises make async easier to manage, but its worth understanding callbacks too. This all might all become clearer if you watch the video I posted above.
Of course it is fine. We are better off with choice than living in a black and white, Coca vs Pepsi, us vs them, .NET vs Java world.
I kinda want a Brutal Dictator in my JVM now. 
With React, the DOM isn't replaced - the initial HTML is parsed by the browser and turned into the DOM, then React "hooks" into that existing DOM by getting references to the existing elements and adding event listeners.
It's not react but react-native, which I'm just experimenting with, but after doing a simple `react-native init AwesomeProject` I have 581 modules in `./node_modules/`. For a still empty project. Not that the competitor NativeScript is any better, so I try not to think about it, especially since my focus is the server and I just have to get something to run at all on a mobile device, just a start button and a div for console output, just to see how it behaves in general. Still, that's *a lot* of modules for just the Javascript, the "mobile" part is not even included.
&gt; "But if you’re ever planning to do something more complicated on the frontend you should probably try React." Not sure I fully agree with this sentiment. Sometimes, the investment is worth it. Sometimes, you should wait until the actual requirements of "something more complicated" are set before you decide to "overengineer" something.
Is see, where it says replaced it should say patched instead. I suppose while react is patching it also renders its virtual DOM for future reference. Its seems the only logical way, I was wondering how the DOM could be served interactively but seems virtually impossible. Thanks for the clarification
Kind of weird they don't really allow zooming and the magnifying glass icon brings you to an overview page with just text. Guess I'll load it up in a browser that ignores zoom restrictions. 
thankyou I tried different variations but I must have had the quotations in the wrong order/places
No probs, just remember the html needs to be in strings but you gotta break out of the string to call the variable.
except for the fatigue
have you already found a library for that?
This is the best tl;dr I could make, [original](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f) reduced by 96%. (I'm a bot) ***** &gt; I need to create a page that displays the latest activity from the users, so I just need to get the data from the REST endpoint and display it in some sort of filterable table, and update it if anything changes in the server. &gt; Haskell guys had been calling it for years, -and don&amp;#039;t get me started with the Elm guys- but luckily in the web now we have libraries like Ramda that allow us to use functional programming in plain JavaScript. &gt; It does in the next version, but as of version 1.7 it only targets ES6, so if you want to use await in the browser, first you need to compile your Typescript code targeting ES6 and then Babel that shit up to target ES5.At this point I don&amp;#039;t know what to say. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/55z3k9/how_it_feels_to_learn_javascript_in_2016/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~110316 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **need**^#1 **library**^#2 **JavaScript**^#3 **fetch**^#4 **React**^#5
What really puts me of are this transpilers and all this different ways to write code - than there are tutorials but they are from 2014 so they are to old to be of any use. Everything is react now but you have to make it immutable and use Flux. Well you don't have to but it is not comprehensive for me as a noob. I would like to use all this stuff but it is really hard to get to any usefully application
All the time spent reading and writing these inane blogs is detracting from the beautiful craft of writing code. In fact I dont think any of these bloggers *can* actually code, they are probably just living vicariously through there much more talented friends.
&gt;few thousand more more like 130k clicks. Looks awesome now.
Whenever anyone complains about a language its either due to their incompetence or inexperience with the language. It's a shame a language is judged by someone elses code you've looked at as well. Oh no, the language allows a coding style you don't like - it must be horrible! Every language allows you to shoot yourself in the foot.
Except that for each of those parts there's a bunch of different options, each of which needs to be learned anew. I still can't work out when I should be using grunt or gulp or bower or webpack. Meanwhile, microwaves and saltshakers basically all work the same way.
Incorrect. Because Poroshenko.
"There are two kinds of languages: Those people complain about and those which no one uses." All languages which grew over 2+ decades are a bit ugly and covered with duct tape. All things considered, JS turned out pretty well, but it does have a bunch of flaws.
Javascript is not simple and especially not anymore. The feature creep has been huge in recent years and when you compare JS to a language that is truly simple, like LISP, C or even Go, you can see it has become very bloated. But so is Java, C++, C# and Python - so not being simple isn't bad in itself, it's just not beginner friendly and takes time to learn. Also, the environment and the tasks Javascript is used for are very complex. Web development is always becoming more and more complex. We don't have webpages any more, we have webapps. There's a minimum of 8 very viable and deeply different browsers that everyone has to support (that is, the four major browsers and their mobile versions), then there are even more minor browsers, where "minor" can mean "only" a of million daily users. Everytime you hop onboard a project you will have to learn at least one major framework you haven't used before, but using these frameworks is the only sensible way, because you have to be able to abstract so much complexity away. 
IMO, you're better off turning the data into JSON, stringifying that and sending it to the server, then parsing the JSON on the server. You're much less likely to end up with something with the wrong data type, such as a user with the username "true" or something. A "magic" solution such as this feels really neat, but in the end you should, at the very least, be trying to parse the value into the type you expect rather than trying to magically detect what it was before.
When sending formData to the server we can't really JSON.parse() it. Though I've got to try to stringify it on the server and parsing it right after to see if JSON.parse() can make a better job at this. I agree with you that this solution will indeed never cover all cases. Questions is would it be more cumbersome than constantly haveing to cast values before using them? Too often I've had to do use == instead of === cause I am not really sure what type is going to pass through the code)
thats exactly what i was looking for!! thanks
I mean that you should have separate functions for different expected value types. If you're expecting an integer, have a function that determines if it can be one and casts it to that, or does whatever else (throw an exception?) if it can't. Likewise for string, boolean, float, etc etc. Then you can never end up with a username with a number or boolean value. I'm not against trying to fit the string data appropriately (plenty of languages do this by magic already), I'm just against doing it blindly without knowing what you *want* to cast it to.
They run javascript, but your reasoning is weird. There are native bootstraps that establish both the web view to run the javascript and the native bridge between them. That you think the project is empty because you haven't written app code is a very odd opinion. In react native you're sitting on top a mountain of code that gives you the ability to output a virtual dom and have it map to native components. That code is delivered to you via npm, and so it lives in node modules. There's a lot of bandwagon about going nuts for dependency bloat right now. That's all well and good when we're talking about frivolous one function modules that depend on 6 others or something, but you're talking about react native and I think you should expect it to have large dependencies. 
Thank you for your comment, it feels like you really can bring yourself down to my level and explain using only the expressions that complete begginer is familar with. As for the first part I did what you say and switched parameters name to the same ones as in the beginning and it makes much more sense, code is easier to read than before. As for removing the return function I get what you are telling me and how that works (didn't know that return just stops everything I put after it, that's useful). However after I implemented this part I ran into 2 new problems (I somewhat expected that lol): 1) When the choice is invalid and user is asked for an answer once again and gives one the code will run but instead of giving the result (eg. "rock wins") it will say "undefined". 2) When the result is a tie user is informed about it and asked for choice second time but after typing any of the words (rock, paper or scissors) **correctly** it will say: "Invalid choice, please choose again. Do you choose rock, paper, or scissors?" I don't know why it goes to the bottom but when I type anything there it's the same as in 1) - it will run but the result in console is "undefined". I would be very grateful if you could help me with that as well and thanks again for helping with the first part. It cleared a lot for me. " Btw I didn't have much time lately but I will try to solve it on my own before you give me an answer. I ask in case I won't be able to or in case your solution will be better (as switching variables names). Cheers. Code: var userChoice = prompt("Do you choose rock, paper or scissors?"); var computerChoice = Math.random(); if (computerChoice &lt; 0.34) { computerChoice = "rock"; } else if(computerChoice &lt;= 0.67) { computerChoice = "paper"; } else { computerChoice = "scissors"; } console.log("Computer: " + computerChoice); var compare = function (userChoice, computerChoice) { if (userChoice === computerChoice) { // Problem no. 2 // userChoice = prompt ("The result is a tie! Rematch.\nDo you choose rock, paper, or scissors?"); } else if(userChoice === "rock") { if(computerChoice === "scissors") { return "rock wins"; } else { return "paper wins"; } } else if(userChoice === "paper") { if(computerChoice === "rock") { return "paper wins"; } else { return "scissors wins"; } } else if(userChoice === "scissors") { if(computerChoice === "rock") { return "rock wins"; } else { return "scissors wins"; } } if (userChoice != "scissors" || "rock" || "paper") { //Problem no. 1 // userChoice = prompt("Invalid choice, please choose again.\nDo you choose rock, paper, or scissors?"); } } console.log (compare (userChoice, computerChoice)) edit: Idk why this code just made a clump but the important part is inctact so I hope it's okay. 
The language itself is fine. The framework situation is what's silly. I dunno, I like portable code.
First off, the front end doesn't directly query the database. It talks to the server, which queries the database. That's the only way to be secure. I've got a security-first mindset, so I've put that first. The front end can be thought of as a way to view what's happening on the server. You push a button, the server does something. This isn't 100% true, as there may be minor things that you do client-side for a while (sorting, editing text), but the actual change involves sending all the data to the server and having it deal with the database or other storage situation. I'm guessing you're getting confused because there are so many solutions that purport to be magic and that you can just do it directly, but most aren't secure and most are confusing, so I don't recommend starting with them.
That is awesome. Great experiment. Nice work.
Hi. Yeah, I did know what you said. I probably should have been more specific in my text. I understand the general principle of how it's supposed to work since I've been the single software developer at my place of work for quite a while. The stuff we use runs php(Zend Framework) server side and JS(Yui framework) in the front-end. I'm fairly certain I'm comfortable enough with Java to put together better more scalable code using it. The Java framework ecosystem isn't as developed as the php one but I'm sure I could find my way. DBs are my favorite thing about my job and I'm so good at them. The rest however is some of the most confusing stuff I've ever had to deal with. So my questions are: Do I build the backend before the front end? What are the simplest, most scalable technologies required for the frontend? At what point do JS, HTML and CSS interact? What is the difference between a button and a JS-confirmation pop-up?(I guess I have a few ideas about this one). How do I make my front-end as simple for the end user as possible? 
I hear what you're saying an I respect that feeling. Here's the thing: Ultimately no one can stop you from adding unnecessary complexity into your apps. Start with an html file, css file, react es5 and react dom if you like. You can (and people do) write incredible apps using minimal tooling. Don't let your mind trick you into adding complexity to solve problems that you aren't actually experiencing. I talk to people all the time who don't understand the fundamentals and have a warped view of what they "should" do based on random tutorials and social media chatter. Be pragmatic, wear blinders until to experience an actual problem.
I think people haven't gone outside of web app development for a while. Dealing with stuff like maven(java not c ++), is the same shit. 
This is probably another function of the huge influx of new developers into front end. Some of us know what it was like to be lumbered with IE6 for a decade, and have become a bit more patient about waiting for new goodies to become supported widely enough to be viable.
Ah. Well, that's a whole different set of skills than coding is. My advice would be the same, "tutorials". However, I don't have any to point you at, and I'm not real good at it myself. I can implement someone else's design, but designing it is a different matter.
good luck (honestly). When I had to do the same thing a while ago, I tried to create a Backbone.Model approach to handle it for me, but it wasn't going so well (due to the internal restrictions of where I was), so I ended up hand-coding the soap request / response with $.ajax(). That definitely worked.
The difference is that the basics of cooking don't really change. I don't have to hear every six months about how nobody uses last year's skillet anymore and the new one is so much better, but it's also a different paradigm, so here's a stack of documentation and (often broken) examples to work through.
Opening the developer console on my browser, I see this error: `Uncaught TypeError: Cannot set property 'onclick' of null` On this line: `document.getElementById("changeList").onclick = newList;` Looking at your HTML, your button element has an id of `changelist` not `changeList`. You'll have a similar issue in your `updateList` function, as there are no elements in your HTML with IDs of `firstThing`, `secondThing` or `thirdThing`
The library or that particular example? Maybe you'll find what you're looking for in the gallery page http://omrelli.ug/g9/gallery/
Quality chefs know their basic ingredients and knife skills. They don't buy pre-packaged, pre-made ingredients.
I've not got time currently to do an overview of the vs. but I just wanted to recommend [EJS](http://www.embeddedjs.com/) over Handlebars. Handlebars might have come on since I last used it but, when I did use it, I didn't like the fact you had to write helpers for JS functionality. With EJS you can just do it in the templates themselves.
X-Post referenced from /r/netsec by /u/silverskull [Node.JS HTTP Request Smugglng](https://www.reddit.com/r/netsec/comments/55uakv/nodejs_http_request_smugglng/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Right, because NPM is a fundamental technology like fire, the lever, or the transistor.
that happens all the time, at least since i've been on reddit
That's pretty cool :)
They don't know how lucky they are, these youngsters!
Your timezone is less than GMT so going backward from 00:00:00 is the 26th. Try getUTCDate() instead of getDate().
So to use this thing I need to write a schema on top of my existing (mongoose) schema? Is there a way to make it transparent? Generate it (or the underlying schema) in run-time? Few weeks ago I tried to look at [Apollo stack](http://apollostack.com), but the fact that I have to write two schemas to describe the same resource seems a bit awkward to me.
The tutorials, while a good initial source of information, will not get you to a place where you are a competent developer. The only thing that will get you there is actually building something. 
Yeah, it's definitely an application that handles a lot of the logic on the server side as it's mostly a medium for fluently interacting with a database, and I'm planning on using the architecture for a mobile application for a class I'm taking.
But Angular 2 only went final three weeks ago. And the fact that people started doing dev on angular 2 so long ago, while it was still evolving... that's a lot of risk to take on for those projects.
Quality chefs *can* make their own, but that doesn't mean they always do. Quality programmers *can* build an application from scratch, but that doesn't mean they never use frameworks. Writing everything from scratch is a luxury that most teams don't have. But again, basic cooking ingredients and tools remain the same from year to year, whereas the JS ecosystem is constantly evolving, which is where the analogy falls apart.
Then there's a very good chance you know more about restaurants than you do about working on a programming team -- which apparently is very little if you think this analogy holds up.
I've been on programming teams for 21 years but I was an electronic engineering project manager before that.
My dad owned multiple restaurants, so I know enough about that business to know that you didn't do both simultaneously. 
I'm an owner. I did/do both simultaneously. 
No. I'm a full-time web dev company owner who also writes code, cause I like to, but I do more architecture than code writing nowadays. I have other devs that do that. I have chefs and managers who run my restaurants so I only go to meetings when necessary outside of our monthly thing. We don't use libraries or frameworks unless we need it quickly or they are part of the standard library, like C's stdio.h, but we always replace what libraries we borrow as soon as possible cause ours is always smaller, faster, better. We build custom, high end sites so we would never use someone else's framework. Our restaurants run the same way. They are high end restaurants with top-notch chefs who don't run to the grocery store to buy tomatoes or mayo.
I'm sure there's some truth to this story, but I'm having trouble determining which parts.
It stopped mattering when you claimed to not understand where buying pre-made mayo or using an existing library or framework might sometimes be a reality of the business. Not every restaurant or programming team has the time or money to do everything from scratch like you claim your businesses do.
The tutorials are telling you not only how to code, but what to code. You have a mental block that you can't start from zero but thats just because all you know is the tutorials telling you where and when to start. A bootcamp will only cement this mindset even further by again telling you what to code and when to code it. You will walk out with less money, the same knowledge you have after 2 years of tutorials, and the same mindset you are in now. You need to stand on your own two feet. Throw yourself in the deep-end so to speak. Create an index.html file and think to yourself "what tag should I put on this page first?" Then place your first tag. Can't remember what to put on the page? **google it**. Take small steps, every day, until you have built something. Even if its terrible it doesnt matter... you have taken the first step without your hand being held and thats what matters. **This is the only way you will ever learn to critically think and problem solve.** These tutorials do not teach you problem solving, they teach you how to assemble pieces in specific languages. As a developer you are in an incredibly unique position to be creative and potentially get paid well at the same time. Build something.
Any time someone complains about JavaScript, someone (in this thread, two people) claims that it is incompetence and inexperience that drives those complaints. This is false.
Every language allows you to do dumb things - some by design, some by accident, and some are a result of an older language thats evolved and strives to be backward compatible. Simply saying my opinion is false doesn't make it false, lets hear your opinion on why Javascript is different than most languages and offer the languages you prefer to develop in. Also take into account that JS, like many languages, is used so widely because sometimes when you want to do X you only have option Y, sometimes option Z as well.
I talked about tools and technologies. Not the language. As did the vast majority of the article.
I don't have a choice, I have a node.js project that is supposed to be run on the phone. It's a data processing thing, it's very different from the usual stuff. I don't care if I have to write C++, Java, Scala, or even R - but this particular thing *needs* to be done in Javascript unless I want to write different code bases in different languages.
My bad; wasn't necessarily responding to your exact situation, just the "JavaScript for everything" phenomenon.
use a package manager. Don't waste time try to do this on your own. Webpack or JSPM are two best choices.
We're not about to debate opinions; that's pointless. Your original assertion is not an opinion either; it's a statement of fact, one which is false. There are many developers who dislike JavaScript for legitimate reasons. To simply dismiss all complaints because of two possibilities (incompetence or inexperience) is irrational.
What's the scope of user interaction you want to have on the website? If you want heavy user interaction, like a webapp, then you may want to look towards a framework. However, if you just need to load some data on the page load, use a templating engine.
&gt; It stopped mattering when you claimed to not understand Like most redditors, this is where you start making things up and say I said things I did not. So carry on but I won't be part of it.
I'm not making things up. This is your point, isn't it? That skilled coders shouldn't be using frameworks anyway? If that's not your point, then I'm unclear as to what it is and how it's relevant to the OP. If you understand why frameworks, libraries, build tools, etc. are at least a necessary evil sometimes, then you understand why trying to keep up with them might be a source of frustration, in which case, what the hell are you arguing about?
To be fair, if he's just learning how to program on his own he might not know how useful checking the console is or how to read the error messages. Walking/Talking might seem like basic tasks for grown adults who are used to being Human, but a baby might not know any better and takes time+trial&amp;error for them to learn that.
Written by someone who has no clue, and is totally ignorant of, what REST is. Killing time, I read further. Wow! This guy's so full of s@#t his eyes are brown! &gt;GraphQL is a query language for APIs and a runtime And he thinks this is comparable to REST?! Holy cow!
I think there's a balance that can be had. Not knowing the exact terminology to use for some concept is one thing, and I get it. I've made mistakes that, looking back, were really "simple" now that I know what I'm talking about. You have to know what to Google. But in this case, OP didn't even bother checking their code for the basics like consistent case. That's laziness. /u/jamesyaboy, nothing personal, but knowing how to ask for help - and how to help yourself - is important. I'm a big fan of Eric S. Raymond's "[How To Ask Questions The Smart Way](http://www.catb.org/~esr/faqs/smart-questions.html)". In particular, spending time writing a good subject line (post title) helps you understand your own question better: &gt;Stupid: &gt;HELP! Video doesn't work properly on my laptop! &gt;Smart: &gt;X.org 6.8.1 misshapen mouse cursor, Fooware MV1005 vid. chipset &gt;Smarter: &gt;X.org 6.8.1 mouse cursor on Fooware MV1005 vid. chipset - is misshapen Of course, you can't demand people read a 20-page manual before asking a question. (If they could do that, a lot of basic reddit/SO questions wouldn't even exist.) But you can try to educate people.
Christmas comes in April now?
If you think REST is a query language and runtime, you have a lot to learn. EDIT: OMFG! Redditors think REST is a query language and runtime. And people wonder why I complain about reddit and its community.
&gt; The more there is in terms of "code" in the most general sense, or one might say "state", the more complex a system becomes, as a rule of thumb 
You're confusing someone disliking using it with "the language is objectively bad". My statement is about the latter, not the former. I hate when people argue about their opinions (as you just expressed), I would rather spend my time doing something constructive. My only issue is when people parade around saying something is bad when what they should really be saying is "I dislike it". There's a significant difference in the results of spreading the "bad" rhetoric, it pushes people away from a language thats not going anywhere when those people could offer their help into making things better.
That's the end of your sentence though. Sentences usually denote the end of a complete thought. I just don't get why you're taking so much offense to this. You semi-agreed with me, then in the same sentence said that is not at all what I could have meant.
i did make a website. its on my github. but still. the block in my mind is how can i get a job and it seems easy but hard at the same time. i go back and forth.
A few things wrong: You're using 'options' before declaring it. You're declaring 'fuzzyOptions' but never using it. Where does ListFuzzySearch come from? For the lazy other devs I've indented the code provided. var userList = new List('users', options); var options = { valueNames: ['date', 'timestamp', 'venue', 'details'], plugins: [ListFuzzySearch()] }; var fuzzyOptions = { searchClass: "fuzzy-search", location: 5, distance: 400, threshold: 0.4, multiSearch: true }; document.getElementById('filterByTeller').addEventListener('change', function() { var selectedTeller = this.options[this.selectedIndex].value; if (selectedTeller == "") { userList.filter(); return; } userList.filter(function(item) { return item.values().details == selectedTeller; }); }); 
The Canary in the gold mine thing is a cool idea. Does that mean it will pull down third party packages (maybe by popularity or age) and just see if they `npm install`? I think that's a really cool service that would go far to help clean up the ecosystem. Say you ended up with two lists: things that can install and things that can't. You could then, say, let the user say, "Show me V7 functional packages only" and essentially create a very cleaned up subset of the node library.
yes, it's jealousy
Stalin dead. Lenin live. In Mavzolei. He wake up at night, plan USA invasion, want world dominance. Fear Lenin.
🙄
If you're trying to get shit done, just add the link and script tags and move on. It's not going to make a noticeable difference to a user. And you can always find a more "correct" solution later.
angular-chart.js (angular directives for chart.js) and angular-nvd3 (angular directices for the D3.js library) have both worked well for me. The former is a little easier to use but the latter is a bit more flexible in terms of layout, styling etc as it uses svg instead of a canvas image which chart.js produces.
It sounds like a fairly simple deal. I'd suggest just using Vanila. No need for a framework useless you have dozens of views or components IMHO.
&gt; ...but the fact that I have to write two schemas to describe the same resource seems a bit awkward to me. The thing is, you're not defining the same resource. The schema you're defining in GraphQL answers the questions, "What is a client ALLOWED to ask for, and what shape does that information take?" Your backend is an entirely separate beast. Where's the data coming from that answers a GraphQL query? What if it's a combination of data from Redis, MongoDB, and something else? If you expose your backend schemas directly, the client needs to know about your database structures, and every time you change your backend schema your endpoint responses change accordingly. GraphQL schemas create a handy deliminator between your backend and frontend. You wouldn't just serialize one of your database objects and send it down the pipe in a REST endpoint, would you? What if you accidentally included an object that had password salts, admin flags, etc? It's pretty simple to set up a simple toy GraphQL app, and seeing is believing. And if you don't believe? Well, you haven't wasted much of your time, and you learned something you can put on your resume. :)
I treat stupid questions in kind. He may as well be asking, "What number is blue?" Don't ask stupid questions and you'll get intelligent answers.
I think it's a fun read and there's a grain of truth to it, but people are taking it way too literally, and you could write the same kind of article about pretty much anything. In fact I'm working on a rebuttal of sorts, a study plan to learn JavaScript and cure JavaScript fatigue :)
I was just always annoyed by people telling me how amazing it is, it's the future, blah blah.
And I didn't get your 2nd paragraph 
I have no knowledge about any of these things. Care to explain the differences between them?
He can't think of one ;)
i am sure no one will figure out how to silently fail
GraphQL is a query language, kinda analogous to building a SQL query to fetch data. Falcor is a virtualized object graph, kinda analogous to a lazy tree where the nodes aren't populated until you ask for them.
Editing your comment to something less grammatically palatable is equally baffling. Basically at this point I don't think you have a good enough working knowledge of javascript to be debating this, and you're just latching on to a popular complaint. But I'll try to explain. React native comes with scripts, written in javascript, that will output for you native project folders. And as such they must bundle knowledge of those native run times and project folder structures into the scripts. Once created, these native projects contain native code that, at run time, establishes a Webview on the native platform in which your own javascript app code will run. So in essence, yes, you are running javascript to in turn create an environment in the native runtime for your javascript to be run. This is the entire value proposition of react native, and it's why your hello world app has, fucking shocker for a great coder such as yourself, a whole bunch of code you didn't write in your node modules folder. 
How's React Native's performance compared to native app written in Java or Swift?
I looked into Inferno. Under the differences, it lists "Inferno doesn't have react's synthetic events", which is a real bummer. Can we get some pros and cons for the alternative method that Inferno uses for events? Having normalized, deferred, self-removing event listeners is one of the main reasons to use a front end framework in the first place.
Same here, just write JavaScript!
same
I can't tell if you're trolling now... so excuse me, but I'm just going to play nice and try and explain that things can be alternatives while being different things. a) a car is an alternative to a bicycle b) a car is a combustion engine with a computer inside a huge frame... that's nothing like a bicycle! Are you saying that A can't be true because B is also true?
What environment will this run in? Just Node? Browsers? What's the minimum version of each you plan on supporting? If you're only supporting recent versions of Node and are using CommonJS modules rather than ES6 modules then you might not need to do anything special at all. If you are supporting browsers you will need something like browserify, Rollup, or Webpack as well as - quite likely - Babel.
Coming full circle: **REST IS NOT A RUNTIME OR QUERY LANGUAGE SO IT CAN'T BE AN ALTERNATIVE OR A REPLACEMENT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!** Thank you.
Bootcamper in a JS based program here. What it's like? First, there are way too many tools. It's simply befuddling to someone trying to break into it, and then you realize all the programs/frameworks are just slightly different ways to do the same thing. I also think vanilla JS isn't concentrated on enough. But, it really is a good time to learn.
We have different ideas of "weird". To me having over 25,000 files for a "Hello World" app is weird. Over twenty five thousand. &gt; They run javascript, but your reasoning is weird. Now *your* reasoning is weird: they need Javascript top run Javascript? When we get to running Javascript we are already there!
Actually: no. The actual work of making a Javascript run is not done in Javascript (obviously?).
&gt; "State" and code are not equal at all. I did not say that.
&gt; This is false. Your assertion is what's false, because *sometimes it is* due to incompetence or inexperience. If you *really* think it's completely absolutely 100% false, then I'd like to know how you can be so sure of that. 
&gt; I think that JavaScript is objectively bad **This is just your opnion**. It seems you have difficulty discerning opinion from fact.
Apparently async/await will be available (natively) with this behind the `--harmony_async_await` flag. Might have to wait for Node 8 for it to be stable though.
What's the EcmaScript 2015 (6) Support looking like? Still 97%?
You really just need a tool like babel (or rollup, or buble) to transpile the ES2016/ES6 code to ES5 for pre-publish to npm, assuming you wish to support older Node versions and different browsers. You don't need browserify/gulp/webpack. You can publish to [npm](https://www.npmjs.com/) and others can consume it with their favourite tooling. http://mammal.io/articles/using-es6-today/ P.S. Chances are the math functions you are about to write already exist on [npm](https://www.npmjs.com/) — try searching around a bit first! :)
so invoking the fuzzy-search class is insufficient?
Hah.
Yes, that's the point. All these articles targeting the Front End, but calling it as JavaScript, ends up hurting the language all the other environments where we have JS. I believe we all agree that the Front End is in a terrible mess right now. The worst is that within the fragmentation that you mentioned, we have some bad libraries with poor structure that are leading some of these shares.
#0000FF
Async/await on by default would be Christmas for me.
Hum ok yeah good point. I will work on that
Yes it is domain specific, still I though other poeple may have that problem as well. 
I think GraphQL is great. I don't think it'll replace REST, since REST is just JSON over HTTP with a few headers.
es2015 vastly increased the size of the language (more than doubling the spec if memory serves; can't find the number on google), in part due to niche features like TypedArrays and Symbols. it's easy to get lost in everyone's rush to take advantage of the new features before they're officially implemented (or, in the case of native modules, before it's even finalized...) "just use es5" is fine advice for people who've gotten comfortable with it, but the visible portions of the community have largely moved on from discussing what that means in regards to modern frameworks or how to take advantage of it, unintentionally creating a strata of developers stranded in old technologies because they lack the tools to break through this brand new wall of complexity. react-create-app can only have so much of an impact. 
Wow, well spotted. :) My comment was sarcastically having a go at the OP. I happened to find two annoying click bait posts on the same day, so I had a running theme of my lunch going. haha
Check out react Native or NativeScript https://facebook.github.io/react-native/ https://www.nativescript.org/
Node, a mess. Windows RT, don't make me laugh. JavaScript as an alternative to batch files, nobody does that any more (besides the loonies using node). So where's this magical place where JavaScript is both appropriate and reasonable?
The only JavaScript engine Apple allows on iOS is their own JavaScriptCore. https://developer.apple.com/reference/javascriptcore Most code written in JavaScript will run in JavaScriptCore. NodeJS APIs are not available on iOS.
&gt;Javascript is getting async primitives, and that may be the only thing I like coming from ES6/ES7. Practically everything else is syntax sugar that doesn't solve any problems. async/await is syntax sugar over a very specific use of generators. all that it give you is: - a specific generator consumer function that pulls promises and yields their results back into the generator. (this consumer is around a dozen lines and is trivial to write yourself.) - a keyword async that says to mark the declared function as a generator (same as function*) and then decorate/wrap the declared function in that consumer. - a keyword await that is exactly the same as yield, but is only used for this specific use case. Generators are very cool. Async/await is dumbed-down syntax for a single use of generators. 
Can i suggest you to read the case study of NASA? https://nodejs.org/static/documents/casestudies/Node_CaseStudy_Nasa_FNL.pdf If you have time, also try to watch Collin Estes (Director of Software Engineering at NASA) talk about it: https://vimeo.com/168064722 
Yes, I've seen it before. But it still implies that you have to re-describe everything manually. What I'd like to see is something similar to Feathers.js, where they have services that connect to your models and by default fully expose them. And then you can decide, how to modify this behaviour. It also can expose resources from different sources transparently. I'd like to see something like that for GraphQL. Its declarative nature appeals to me, but in practice it means that 90% of the time you have to duplicate your schema in different "languages", which is not very productive.
No. You should use it instead of gulp.
... Do you have to? It looks to me like you declare the mongoose model once, and then pass it to the `getSchema` method.
Congrats to the node team!
Can you explain more?
Yep, No. 
Do you also think es2015 is stupid? They took most of the features from coffeescript.
Try RE:DOM https://redom.js.org 😉
Perfect
http://node.green – looks like `Object.{entries,values}` is on by default, async functions behind a flag.
Aaaaaaand that's the main issue of cryptocurrencies. No way that anybody not HEAVILY invested in them can understand what's going on on this page.
By default, Inferno attaches events directly to the DOM elements themselves – which is very performant and has the additional benefit of the event being automatically cleaned up once the DOM node has been GC'd. This direction can have performance benefits and reduces the amount of code required to maintain/support events. It also plays nicely with Shadow DOM and avoids some pitfalls/edge-cases associated with a synthetic event system. However, there is a plan to offer an optional synthetic event layer to InfernoDOM as a sort of plugin. That way, developers can decide what to use depending on their requirements. Here's a work-in-progress technical document I'm writing for the upcoming Inferno 1.0 release – https://gist.github.com/trueadm/3944f0aa1c1a6998257b80901ac1d152. Much of the content in this document will be picked out into the new README.md and the new website, but hopefully it helps explain some design differences and why we took decisions.
What's with all these articles coming out recently with people bitching? If you don't like the ecosystem then either do your part to better it or switch to an ecosystem that better suits you. 
You only need to bundle/minify if you want to publish for users that still use bower, global namespace monoliths and script includes. But this is getting rare. If you publish on npm you just need babel and that's that. Resolving and processing is the users responsibility. You can distribute all in one, if you want to ... /src /dist /commonjs /browser/lib.min.js src is your es7 codebase as it is. rollup and webpack 2 users will want to use this because these tools can extract functionality that is used and omit the rest (tree-shaking). dist/commonjs is the bablified src for node, webpack, browserify users. browser/lib.js for script includes and the only thing you have to bundle/minify. For creating a bundle Webpack is probably your best choice. You add babel as a loader, a minifier and you're set. Rollup is also an option, and if your lib is small and doesn't have npm dependencies it is easier to handle than webpack and creates slimmer results.
It is complicated, but let me say this. Once you get the hang of it, you don't wanna go back. I've invested lots of time on GraphQL and Relay, and I don't regret it. If you are afraid, start out with GraphQL only. Relay is another beast.
~~Values is red in v7~~
Of course they will. Do you know the sheer amount of code that would break if the version number started with "8"?
You can do what whatsapp does, and trigger a local push notification which when opened navigates to your app.
Do you mean `Array.prototype.values`?
That is what I was thinking, but does the notification disappear after few seconds? Or can I set that the notification stays as long as someone is calling? It would be better to popup the application to front if someone calls if the app is set to background, but I guess that is Cordova limited?
You might need to dive in and write some Java for this. Cordova allows you to call some Java-Method as a fallback when it doesn't provide the right API's - use that feature. You'll have to do the same thing for iOS though.
It works the same way a push notification works. If the phone locked you'll have the notification message on your locked screen, if it was unlocked you'll see it in the notification bar.
Correct
Do you know if it is possible to write a plugin with java to bring the app back to front?
*Neither of these actually use Node. NativeScript uses Google V8 on Android and JavaScriptCore on iOS. However, it is an easy thing to confuse since Node also uses Google V8.
And you can't use interior latex paint on the roof of your house. There. Another reddit-style comparison to prove you wrong about SQL and REST!
Not as screw-loose as one who argues with a 5-restaurant owner and web dev owner and pretends you know what you're talking about. btw, since redditors don't pay attention, I said I've owned five restaurants. I never said I owned five at one time.
Doc, you can't teach these dumb fucks anything. Why do you bother?
Doc, these dumb fucks don't know anything. Why do you bother?
You're in today?
As someone who went from Riot to Vue, they're very similar. At the time, I simply moved to Vue because it had a more mature ecosystem. They're both awesome, and I think the Riot folks are working pretty hard to get the next major release out.
The falcor site has api docs, examples, and guides/tutorials.
A lot of people really dive of the deep end with react. It's their loss. React is very good with zero dependencies and no build chain. I've worked on a lot of projects where they have some horrible jquery that's heavily tied to the dom and has just enough code to be very hard to change anything (often lots of HTML injected on the fly). A React component loads into a script tag just as easily and does a much better job.
&gt; Is it though? What reasons? Who decided this? People smarter than us, but I wouldn't trust them either if I hadn't seen myself the effects of both callback-based code and promise-based ones. Sound reasonings can be found everywhere on the internet. The same is true about callbacks, of course, but reading these articles show quite clearly that the authors are usually not opposed to promises themselves, but would rather keep their current workflow (as in this post). As for the debugging argument, I don't quite buy it. It's not so much an issue with the promises than it is a tooling issue, which tends to disappear rather quickly anyway (Chrome already logs uncatched rejected promises, and the only issue remaining is the "break on thrown exception" feature). Progress should not be hampered by tools.
That's a great point. I will mix two topics from your comment: What if someone that is bitching about the ecosystem, enforced by his employer, decided to switch to a new one. A new place to work. But then he looks around and find out that all the available options are expecting the same. I believe people are "bitching" so much because they are feeling as they are being forced to learn, and to work with. Is not like you are starting a new pet project, or a new startup and you will be rebel enough to choose a stack that no one is using, with the risk of not find employees to hire, because there is a need at the market for the other libs. 
Would you explain your point? 
Tell me more about Falcor. What's the use case? Does it lazy load json data?
hmm, I think you are right. Ergonomics, maybe. Here's the desc on the [github](https://github.com/tomcarbon/dogecoinmultisig/blob/master/README.md) which may or may not help +/u/dogetipbot 98 doge verify
This is a really great idea!
Well for one thing you cannot `await` a function which uses a callback in an `async` function. Where as Promises are the **only** thing which can be `await`ed.
Improving JS by reintroducing conditional comments and version hell is like improving your mastication by eating baby food.
Well it obviously isn't working the way it's done today, no? So why not do it like any other language on that planet instead? Of course, versions aren't ideal. In a perfect world every developer would just keep up with the versions released, but since that's never going to happen, another solution must take place. And never fixing anything isn't the right way. It never is.
This is exactly what is not my intention. I wasn't writing to defend JavaScript, to tell how good it is, or anything like that. I just want to bring in attention to the fact that we are mistakenly calling Front End as JavaScript. Even worst, calling what we've been building with JavaScript as JavaScript. (i've made an update there to explain better this point). My intention was to target this issue, from people who are doing it by mistake, and not because it really hates the language. To see if in the future, the next articles that will pop up, will have this in mind and will be written separating better the concerns. About the going deep on the Node.js subject, i left a link on the article to the case studies section from Node.js itself. 
Hi /u/mdymel, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `dymel.pl`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [devblog.dymel.pl](/search?q=%28and+site%3A%27devblog.dymel.pl%27+author%3A%27mdymel%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|63|81%
Could you elaborate on why Node is a mess?
The issue is that you are using `=` in your conditions where you mean to use `==` or `===`. `=` is always assignment and so your condition is changing the value of your variable.
you get `document is not a function` when you incorrectly try to use document as a function. that will have nothing to do with babel. `document();` 
Gulp is not a good tool if you deal with modular front-end. Often it just complicates things. Then you might want to clean your codebase and leave es5 behind since you're transpiling anyway. Es6 is modular, you don't need to concat anything. You just export your functions and classes, import them where needed. Let webpack (+babel loader) run over the index.js and it creates a full bundle. Webpack knows the structure of your project, its dependencies and so on.
As Meefilms said, you need to use `===`. I always use `===` because its the only way to absolutely ensure you always get a boolean result. Also, looking at your code, you might consider a do while loop instead of just a while.
Gulp is a great tool for modular front-ends, why are you trying to make things sound worse than they are? Telling someone to move directly into ES6, when they clearly aren't fully understanding ES5 will again, not help anything. It's comments like these that lead to burnout and "woe is me JavaScript changes all the time". If the OP is using Gulp, help them use Gulp, it's a tool like any other.
1. What is the actual error? (Saying "something like that" isn't going to net you a good answer). 2. The filesize has zero correlation to "successfully transpiling". A transpiler will naturally increase the size of your JS since it has to add support for features that are built into the new language spec. Please post some of the code that isn't working right and we can try and help ya further :)
He is adding Babel, so he is using Es6. If you start introducing es6, modules are the first logical step. Sometimes you have to move on, for the sake of making things easier on yourself. Es6 is a *major* relief. So is webpack. Burnout can also be about dumb pipe tools that have you glue stuff together in specific order, patch html with concat results, run behind config files for every little thing that changes. That was the state of javascript years ago and it wasn't easy nor fun. It is also the reason most people have that kind of impression about javascript development in general because it truly was a hell. 
Did you read the rest?
It's not an opinion. There are reasons other than incompetence and inexperience that someone might dislike something. Is that really so hard to grasp?
He stated it is _always_ due to incompetence and inexperience, or rather, he stated that "it's either due to X or Y." That is simply not true.
You can use that space analogy to prove me right. Cooking on earth does not prepare you for cooking in space. Same with writing JS. You know how to use jQuery on a page to make the DOM change. That won't prepare you for modern JS dev. Thanks for proving my point, troll.
&gt;What reasons? Callbacks are overly verbose and require buttloads of boilerplate code. Callbacks swallow errors like tick tacks and they do it by DEFAULT! 'async' lib is slower than the bluebird promise library, and isn't even as well tested or maintained! callbacks aren't compatible with async/await. callbacks have a arbitrary and bad function pattern that will break everything if it isn't followed and is difficult to debug. Callbacks kidnapped the Lindberg baby, Callbacks capped Kennedy from the grassy knoll. don't use callbacks.
I don't understand so it must be magic
&gt; that is not going to make my life easier. It would make it harder. Why?
Those are all returning promises (or rather, "thenables"). I'm not sure what your point is.
Not really because the product was available to us the entire time and should continue be. If the team behind rethink is able to get the project into a foundation and they opt to switch to MIT/apache2 license then things shouldn't change much for its end users and rethink could become even better. Startups are hard but at least they took the high road out of the gate. It will be interesting to see the team's followup posts about mistakes to avoid. Hopefully the first isn't "don't open source your offering" haha
Thats the difference here - I'm not arguing whether Javascript on average produces bad code quality... I'm talking about the language itself. Clearly were not even talking about the same things. Not that its relevant, I have years of experience with Java, C/C++, C#, PHP and Javascript. Most of my development time over the past 11 years has been in strictly typed languages. You can check my github repo, I have dozens of projects I've created in multiple languages. A pet peeve of mine is people complaining about dynamic typing like its a bad thing - like you've stated in your previous posts. Thats the only thing I'm arguing here. Its a feature - one that I love about Javascript. It allows you to write very powerful and expressive APIs. You said objectively bad, then talked about it subjectively. I don't know what you're missing here.
That `you cannot await a function which uses a callback in an async function` is false.
I think it came down to adoption, and Mongo was first to market, integrated seamlessly with a lot of "cutting edge stuff" coming online, etc. People wanted to go nosql and Mongo was everywhere. Personally, I had a much more enjoyable experience with RethinkDB myself than I ever had with Mongo. Easy to get up, scale, replicate, shard. Easy to do changefeeds, etc.
I started to use it just one month ago and finally became comfortable with its super rich API. But I admit looking for alternatives is going to be fun!
I don't like JavaScript, you're correct, but I'm not trolling here. I'm providing reasoned thoughts about my distaste for the language, and you're taking it personally.
Well, refer to NASA as just "someone", is new to me. I didn't see that coming. Maybe you could ask to some of these also tiny guys why they are backing Node.js: https://nodejs.org/en/foundation/members/
Oops...I missed an 's'. 
I found Nexus to be a far superior and also free option. I would steer clear of sinopia https://www.sonatype.com/nexus-repository-oss
&gt; There are reasons other than incompetence and inexperience that someone might dislike something. There are reasons other than incompetence and inexperience that someone *might like javascript*. Is that really so hard to grasp? 
I never stated anyone who likes JavaScript is incompetent and inexperienced. Are you reading too much into what I'm saying?
&gt;**It's not an opinion.** There are reasons other than incompetence and inexperience that someone might dislike something. Is that really so hard to grasp? You have been doing nothing in your comments but trying to say that it is a *fact* that javascript is a bad language, because there are many programmers that reasoned about javascript and found that it is a bad language. You're trolling. You're continually trying to assert something as fact that simply isn't a fact. You seem to think your opinion is superior to the opinion of people who like javascript. That's what I've seen you doing here. Are you trolling?
I don't think I've shit on JavaScript in this entire thread. I've stated I dislike it, and I've provided one example to demonstrate an objective stance toward why it _might_ be a bad language. It's the very basic process of forming and proving hypotheses. There is no opinion in showing an 85% reduction in defects in statically typed languages. It's just numbers and statistics. The key point here is that I've provided a demonstration of research, but never concluded JavaScript is bad because of it. My opinion is that JavaScript is bad, and I wanted to _demonstrate a way_ to objectively _study_ my position.
If you had actually been reading my comments instead of assuming I'm saying things I'm not, you would have seen the research I provided. I will not pander to your impatience; you can find it in my comment history. I'm no longer interested in this discussion. You can only lead a horse to water, after all.
I don't see anything none-standard in the way you use Travis? Why is it "How I Enslaved" instead of "How do I use"?
Most of the team was hired by Stripe, they seem like the kind of company to allow the engineers to do 20% time on it or something. I'm not sure they'd want to though.
Howdy! Me and a friend built out an online calculator that models your tax payments over a life time (assuming a static salary). It also shows which agencies and services your money is used for. Would love some feedback. Does the site make sense? What do you think of the design? Did you find it interesting? Criticism more the welcome! Thanks!!!
Let's review what I said: &gt; Well for one thing you cannot `await` a function which uses a callback in an `async` function. So I said the following wouldn't work: function doubleUsingCallbacks (value, callback) { setTimeout(() =&gt; callback(null, value * 2), 500) } async function asyncQuadruple (value) { const doubled = await doubleUsingCallbacks(value) return doubled * 2 } &gt; Where as promises are the **only** things which can be `await`ed. So I said the following would work: function doubleUsingPromises (value) { return new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(value * 2), 500) ) } async function asyncQuadruple (value) { const doubled = await doubleUsingPromises(value) return doubled * 2 } The comment I was responding to was asking why Promises are better than node-style callbacks. And the reason I gave was that you cannot `await` something like `doubleUsingCallbacks(5)` and expect it to resolve to anything but `undefined`. Now, what is it exactly that you are trying to argue?
Your statement was of mutual exclusion, your example here with `new Promise` and `setTimeout` are in conflict with the statement: `Well for one thing you cannot await a function which uses a callback in an async function.`Since you have a function which uses a callback and an async function awaiting on it's result.
Is there some sort of framework sub-reddit for this poor fellow. Pretty much everything being discussed in the OP has nothing to do with JavaScript. I've never heard of these $ globals or html5Mode. The only thing that makes sense from a JavaScript point-of-view is window.location, what funny enough is also the only thing the OP mentions is working. Crazy times!! 
Can ppl please post framework specific rubbish in framework specific sub-reddits /r/angular2 If you're going to posting about a particular topic and choose find a sub-reddit to that encompass a wider scope why not go for something really wide like /r/english
I'm unsure how to debate an idiot so I will end the conversation here.
Or super imperative with not very clear naming. But neat-looking anyhow.
You don't have to look for alternatives, RethinkDB is transitioning to an open source model for development and maintenance. 
The argument that you cannot await the return value of a function that takes a callback is very different from what you stated ;) 
Haven't heard of this until today; will have to look into it
&gt; We are trying to build applications that run right in a dozen browsers, look good on thousands of different devices, load fast enough for impatient commuters in the subway, and are still accessible enough that blind people can use them That's nice and all, but none of that requires a dozen competing build tools and module loading and bundling approaches. PHP standardized on PSR-4. Want to build modular apps? A PSR-4 compliant autoloader is all you need to include in your index.php script. You can use any autoloader you want, they all do exactly the same thing, and use them all exactly the same way. There is no fragmentation, no confusion. That simply *is* how you do module importing in PHP. The result is that it's dead simple. The community can point to a single best practice. Tutorials and instructions can teach a single thing. Any library that's PSR-4 compliant *just works*. Even better, the PHP package manager - Composer - ships with an autoloader out of the box. You don't have to hunt one down to make module importing and application architecture a thing. You don't need the equivalent of gulp &amp; webpack or browserify and all of the insane config and loaders you need. It would be like NPM doing everything for you, out of the box. The lack of standards and standardization where it counts in the ecosystem is what makes it frustrating and annoying, and there's no reason for it to be that way.
20% time is a myth. It hasn't existed at Google in quite some time, if it ever did. [http://www.businessinsider.com/google-20-percent-time-policy-2015-4](http://www.businessinsider.com/google-20-percent-time-policy-2015-4)
Fuzzy filter is typically some sort of approximate search technique.
RethinkDB seems like a great approach for working with real time data. I wish it all the best in the Open Source-Database world with along side other great solutions, such as Postgres, MySQL, MariaDB, MongoDB, Cassandra, Couchbase and Redis. Let me know if any of those are wrong. I'm sure there are many more too that aren't on my radar.
I know what these filters are used for, I'm asking about this particular module. Is it open-source? If yes, where is its repository?
I appreciate the summary on the evolution of PHP best practices, I can see how that's a developer-friendly approach to evolving the language's tooling ecosystem. It would be interesting if someone built a tool on top of npm to utilize this approach. You're right about solutions being heavily localized to individual frameworks and libraries. For example, Angular2 is tied to TypeScript, and React is tied to Babel (for JSX). And like you described with `require` vs ES modules, different tools are evolving at different paces, making JavaScript innately fragmented. There can't exist any sort of monoculture in this context. Maybe JS will evolve to a point where it provides all the features one could ever want, but that is a long way off. Until then, I think tools like `create-react-app`/`vue-cli`/`ember-cli` are necessary stopgap solutions.
So I checked out this author. Software Dev for 4 years and is now teaching at a code academy. I don't know how others feel but to me, you haven't earned the right to this opinion. In fact you haven't even been doing this long enough to be annoyed, let alone be annoyed at those who are annoyed. The quality of the article is a joke too, it is like 2 paragraphs and then 5 pages of quotes and pictures, one of which is a gif of how to click the like button. I really like this part: &gt; web development itself is inherently complicated. Not it is fucking not. It is the least complicated shit out there. There are people writing software to drive fucking cars and launch rockets and control MRI machines and you are complaining about browser incompatibilities, something I have not even worried about since IE9. This is the equivalent of someone going through the first 3 lessons of Estebans Guitar course and proceeding to write about how people who like *Pet Sounds* don't really appreciate music. Enough is enough. Time to author Triggered.JS
Have we hit javascript fatigue fatigue fatigue yet?
Cloudflare also offers free dns nameservers and free DDoS protection
That article talks about Google and Yahoo, and the parent comment refers to a different company named Stripe, which may have a very different policy.
I understand that. Google is the company that started "20% time", however, it never perpetuated outwards to the rest of the tech world. Or, really, even at Google. Just because a company is a tech company, is a weak reason to infer they have 20% time (actually, I know ofzero well financed/performing companies that do) or that it exists.
Most npm modules are not bundled. You only need to do it if your module is meant to run in the browser. (And technically, not even then, but it's polite to do so.)
I haven't used Falcor, so I will just comment on why I like GraphQL. Its flexibility. It's just a layer above your data models and controllers, so you can still do anything you want to do underneath. Type checking. It checks type correctness of your queries and arguments and outputs detailed error message with line numbers. With Relay, it typechecks your queries on compile time. Also with Relay, it auto caches your data based on data ids and fields. So next time you query the same model, it will only fetch the fields that were not fetched before. Declarative API. It just easier to understand which data and its fields you are fetching at a glance. GraphiQL, a query API explorer where you can run and debug any queries and see their types. Basically, by building GraphQL Schemas, you automatically get your API doc.
I thought some people might find such posts interesting. Not everyone follows the other sub-reddit. The point score on this post seems to agree with me I think. 
The manipulation is synchronous. The repaint of the window isn't. By running the loop you block the browser from being able to repaint the window to reflect the changes. (And think about it — you wouldn't want the repaint to happen automatically/immediately after every time you touch a DOM element, as that would kill performance if you touch a lot of elements.) The DOM update is synchronous because if you read back the changed value before entering the loop you see the updated value, not the old value. 
I already doubled checked it. It's finding the nodes, but it's not running for `span`. But if I do the same for `div`, it works. I don't know what's wrong here.
&gt;&gt; create-react-app &gt; Ok. I want to use Angular (or Vue, or Ember). Now what? Your solution works for just a single library. I spent about 8 hours trying to find a sane vue-webpack-babel-less-es2015-gulp boilerplate. Webpack is a buildsystem, you don't need or mix it with Gulp. These CLIs help you getting up and running quick, setting up these configs for you. If you start from scratch a Angular, React or Vue webpack config will look pretty much identical. The only thing that changes is a babel preset or a loader. Reacts v-dom develops into a standard by itself. You can take your code out and run it in several libraries. Inferno, Preact, [Vue](https://github.com/vuejs/babel-plugin-transform-vue-jsx) and others. [You can run it in Angular](https://github.com/ngReact/ngReact). [Ember, too](https://github.com/AltSchool/ember-cli-react). It is easy to complain, but look around. Try porting Android inflators to IOS, QT to GTK, Silverlight XAML to WPF XAML, Win32 to WinForms to WPF. Yet here we are, *almost* using the same components on the web, in desktop apps, on mobile, in Angular, naively in Vue, etc. 
Hey, this might be confusing. [So I suggest to see this masterpiece by Philip Roberts](https://www.youtube.com/watch?v=8aGhZQkoFbQ) 
There is a fun performance issue where you change certain elements *and* read back calculated layout properties, then the browser has to do a synchronous layout (eg: recalculating sizes and positions) between these JS calls to give you the new value, otherwise defers those updates until it actually goes to repaint pixels some time later.
There are several packages that more or less do this. Either in your editor: https://atom.io/packages/js-autoimport and/or as npm auto installers that go as far as installing packages for you.
Yes, it's supposed to be synchronous, and yes, it isn't. This generally doesn't break things because, to JavaScript, there's no way to tell the difference: our APIs (like `getComputedStyle`) behave as if the manipulation is complete, and we can't tell what's actually on the screen. The why is performance. Nobody ever gave JS a way to batch DOM updates (except a hack to get down to two, not one), so we write code that takes the DOM through a few - or a few hundred - intermediate states before reaching the one we want. These states are useless or misleading, and rendering each of them would delay rendering the correct state, so the browser skips them. Yet another instance of it being easier to introduce a little lie, than a new API.
Where did you buy the domain? They should have nameservers
Whoa, that's something new. Never heard of it either.
You can calculate sin once and then just mirror and shift instead of calculating it again and again. 
I didn't buy it yet.
My problem is that I need to keep up with all the options just to know which one is actually best.
pew~pew~bang! nice job (⁎⁍̴̛ᴗ⁍̴̛⁎)
**It is fully asynchronous.** The markup represented by the DOM, and thus the DOM, is a completely external resource from the JavaScript execution thread. Many of the comments here are confusing the DOM's API methods in JavaScript for the model and interface it represents. Instructions within the JavaScript language will always be synchronous, but that isn't what the DOM is. As an example the instruction for XHR's `send` method is executed in synchronous order in JavaScript, but the result and response from that method is fully asynchronous since it calls instructions (within the browser) outside the JavaScript language and polls for task completion using its `onreadystatechange` event. Unlike a HTTP request or a Node event its often hard to tell. The DOM is optimized for fastest possible execution. It is the standard by which all other similar technologies compile down to. That said, the typical DOM operation in a modern browser takes a delay of about 1-5ms which is hard to notice. Causes for execution delay include: * number of child nodes * changes to size, shape, or position of itself, its child nodes, or any other nodes * large visual repaints * delays from other events Changes limited to text color, background color, or opacity are even harder to notice as these changes can execute within the 1ms range in a long running loop.
Why Elm? Just genuinely curious
If we followed your line of thinking, we'd be using CommonJS, only have synchronous loading, and would be forced to use browserify if we wanted to load modules on the client side. &gt; The lack of standards and standardization where it counts in the ecosystem is what makes it frustrating and annoying, and there's no reason for it to be that way. I disagree. There's no reason to prematurely define a standard if it isn't truly a best practice. There's no reason to limit innovation in the field just because you don't want to put in the time to keep up. Right now, the javascript ecosystem is in its cambrian explosion. Over time, the dust will settle and the best tools will survive. Let's not pick winners and losers just for standard's sake. 
I would rather suggest a complete rewrite if you are going to replace the current app. The main reason for this is that you don't have to keep to the current UX architecture of the app. As you are going to replace the app by a single page app, many UX options become available that weren't before (such as offline use, undo). What I think is important in this decision is what kind of level of HTML abstraction you prefer. JavaScript frameworks come in all shapes and sizes, but can generally be put on a spectrum where at one side it is close to the DOM and HTML (think jQuery) and on the other side much closer to being an application framework desktop style (think SproutCore and Cappuccino, both inspired by Cocoa/NextSTEP). Think carefully where you would like to be on this spectrum. The larger the application becomes, the more important application framework features become, such as application state management, data bindings, dealing with lots of data / records, incremental updates, loadable modules, views etc. It might help to make a list of features that you would like to have in an ideal situation, and then start comparing frameworks based on that list. It can be very beneficial to choose a framework that brings most of these features as one package. 
EXACTLY! Complaining about choice or the release of a new library/framework sounds to me like 'Waaahh, now I have to continually learn instead of using the same tech for the entirety of my career." 1. No you don't. If you're an expert at vanillaJS, you can still use that 2. You don't HAVE to use any of these new tools. Yes, there is a cambrian explosion in the JS sphere. In the end, I think this will actually help sort out the competent JS developers vs. the ones who get lost when books/tutorials aren't holding their hands by teaching them 'the way' to do things. If you're an intermediate or advanced beginner JS dev, you should be able to read and be up and doing simple things with Grunt, Gulp, Webpack, or browserify within a day at most. This is happening because there is NO categorically single best practice as of yet. It doesn't make sense to just go with one approach if its inferior just because some devs don't want to experiment on their own and would rather have things spoonfed to them. I think this whining has more to do with the competence of the average Javascript dev. Before, a back-end dev was more or less full stack because the front-end was super simple. You simply didn't need to know much to work on the front-end. HTML &amp; CSS mostly. You barely needed to know Javascript...just enough to copy and paste solutions. Now, the front-end has become the domain of software engineering while still requiring some design sense and it's breeding a new type of hybrid developer. Yes, it's become more complex. Evolve or die. EDIT EPIC RANT INCOMING: Until React came out, I loathed working on the front end. Has everyone taken crazy pills and forgotten just how much a pain in the ass it was? There wasn't even a standard way to do transitions or gradients. You had to decide if you wanted to support all the browsers by having a different stylesheet or using CSS prefixes. I frequented some of the most ghetto sites on the web to have those prefixes auto-generated. Or how IE had their version of a box model and all the other browsers had the "right" version. Or how IE used event bubbling or capturing and everyone else used the opposite (I forget which). Quirks mode? It wasn't logical programming, it was an exercise in frustration where you had to find and memorize the solution, because deducing it was fucking impossible. At previous gigs, colleagues and I felt sorry for whatever poor schlub had to make things IE compatible. I definitely was not going to spend my time on learning that horseshit. I refused to waste my time because that knowledge was not applicable in ANY other domain. Now that browsers are standardized for the most part, the need for that crap has disappeared And don't get me started on what javascript used to be like and the hacks who passed as javascript coders then. Have you ever had to decipher JS code written in one monolithic block of a function that at certain points goes 20 levels of nested callbacks deep? There's a reason it's called callback hell. React made the front-end fun. Now that I look back on it, the Web Component paradigm is so simple and elegant. However, it took that long to come up with it!!! Shit needed to evolve. Hell, it took a teenage genius to look at the sorry state of affairs in web development to say that "Guys, this shit has been solved since the 1980's. MVC, have you....le sigh, is everyone a hack whose knowledge of software engineering comes exclusively from O'Reilly?" We're now at a point where devs have a high-class problem...the choice is up to you. That's a lot of responsibility and pressure, I know. But, it will settle. Let's be real, a lot of devs are on the front-end because that's their limit when it comes to coding. Why, because programming jobs pay great, don't require you to play office politics, allow you to dress how you want, more flexible hours, and doesn't require much more than 3 months of study. There will be a purge in the Javascript world, and it will be a purge of incompetent devs. You know, the one who always fucks up their git commits even though they're using a GUI. We're moving to a brave new world where the graphic designer, not the front-end, is a master of HTML/CSS and creates the style guide, front-end are truly becoming the jack of all trades and masters of Javascript, and back-end now have to be masters of statistics, analytics, and be familiar with AI. Shit's maturing, yo. Don't worry, they won't be left out in the cold. Salaries are going up all around and there will always be a need for Wordpress and Drupal. 
No you don't. There is no 'best'. Just use whatever you're best at unless there is an important reason to use a new tool. Also, if you're not motivated to keep up on your own, others will. 
Had this debate yesterday at work. I don't agree at all with this trend. You need to be a good JS developer and understand the DOM. Like reaaaalllly understand it. Frameworks and tools and convenience factors only. When they become less convenient, they are not right for your project. But you shouldn't *need* one and should understand the underlying technology to learn any framework in a few days if required. People need to stop learning and being tied to frameworks and tools which pass in 6 months. Setting yourself up for failure. Also need to stop listening to bad advice. I read and learn from some wonderful folks on this sub and also shake my head at some stuff because it can be short sighted or thinking very "small". Guys learned to add Angular scripts to their home website... great.... how do their answers scale to huge financial apps looks to actually write on Angular? Hont, they don't. Learning frameworks and then learning the next one in 6 months is a waste of time. Apps shouldn't be so tied to it. When I'm sick of Angular2 in 6 months, I know my apps is not tied to it, I can port it to the next thing or chose not to, because I know the underlying tech. The sad thing about JS communities is... very few people really know, understand or talk about...actual JavaScript!
Had this debate yesterday at work. I don't agree at all with this trend. You need to be a good JS developer and understand the DOM. Like reaaaalllly understand it. Frameworks and tools and convenience factors only. When they become less convenient, they are not right for your project. But you shouldn't *need* one and should understand the underlying technology to learn any framework in a few days if required. People need to stop learning and being tied to frameworks and tools which pass in 6 months. Setting yourself up for failure. Also need to stop listening to bad advice. I read and learn from some wonderful folks on this sub and also shake my head at some stuff because it can be short sighted or thinking very "small". Guys learned to add Angular scripts to their home website... great.... how do their answers scale to huge financial apps looks to actually write on Angular? Hont, they don't. Learning frameworks and then learning the next one in 6 months is a waste of time. Apps shouldn't be so tied to it. When I'm sick of Angular2 in 6 months, I know my apps is not tied to it, I can port it to the next thing or chose not to, because I know the underlying tech. The sad thing about JS communities is... very few people really know, understand or talk about...actual JavaScript!
If you're trying to go from Client (JavaScript) to Server (PHP), the only way to really do that is by making an HTTP request containing the information that you want to send. Also, the above doesn't necessarily have to be from a form, although it'd be hard to say without knowing what you're trying to do. Could you explain what your end goal is or maybe put up some sample code?
Well said.
So you are asking where to buy a domain? https://dnsimple.com or https://www.namecheap.com/
&gt; Webpack is a buildsystem Incorrect, webpack is a bundler, gulp is task runner. Webpack can not replace gulp.
I'm in college and have been working with the local school's software department on web development (Atlassian products mainly). I really like JS. It's been the one programming language where I feel like I "get it". Do you have any recommendations for resources to help hone in on the "really learning JS and the DOM"?
I wonder how Haskell would work out...
Respect for pure WebGL implementation!
Sure, its a combination of factors that unite to make a really great front end development experience. First of all the compiler really does a good job of finding every possible error at compile time. Knowing that my code will run without runtime errors is a major plus. You know that every corner case is handled and that side effects are tightly controlled. Second I like the fact that the community is very focused on the goal of making front end development nice.. In addition the tool chain is really easy to use and the compiler is both fast and helpful
It is reassuring this is a common mistake. It means there is nothing hugely wrong with my brain. Though it is important not to let standards slip. I think the solution is to read it the way a computer does, like read it literally one symbol at a time.
It can easily replace Gulp. Webpack (with the assistance of loaders) bundles, minifies, autoprefixes, transpiles es7 to es5, compresses images, converts JSX to functions, applies postCSS transforms, HTTP serves your projects, live reloads, hot reloads single modules/components, etc. What exactly are you doing that it couldn't? It is probably the closest to a real build system we have had compared to other languages. Webpack knows the project, its AST structure, its dependencies. Since version 2 it knows relations between modules which is why it can tree shake. Gulp in comparison is a dumb pipe. It runs tasks and glues files together. 
http://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons Thanks. I think === is better too. It is probably better to tell it what to convert data to to minimize the risk of errors.
Takes about 2 days to get used to, then quite nice. The fact that everything is typed is a major plus. It is also quite fast according to the benchmarks I have read.
Exactly. PHP was painful before Composer and PSR-4, and became simpler and (dare I say) fun when a standard was developed.
It's helpful to remember that you're under no obligation to follow tech trends. Once you've settled on a process that allows you to be productive, it's ok to hang there for a while. Keep an eye on the latest tools and as you come across things that solve problems you're having, give them a shot if it seems worth the investment. (My latest example: Vue 2 seems really cool but I'm very happy with React and not convinced that the performance gap won't narrow!) [This article](http://mcfunley.com/choose-boring-technology), "Choose Boring Technology," makes a good case for sticking with tried and true when possible. In JS, that might be a little harder but you can at least choose those with established best practices, strong usage patterns, and healthy communities.
This has to be the dumbest thing I've seen on reddit today. And that's saying a lot!
I don't think it's a good idea at all. Also, still only half the functionality described, dependency management, but not autoloading. This removes the need to do stuff like require('../../../feature') as the autoloader works on your application code too, mind you.
I setup a jsbin of your code and added the quill initialisation and it works just fine: http://jsbin.com/carorowugo/edit?html,js,output Not sure what you're having trouble with.
out of curiosity, could you elaborate on what you were doing so someone may be able to explain what may have been going wrong? knowing is half the battle :)
No problem!
Add each function to a separate array as you go through you're while loop. Then afterward, loop through the array: for( var i = 0; i &lt; newArray.length; i++) { setTimeout(newArray[i](), 400); setTimeout(function() { $(".btn").removeClass("green-on red-on yellow-on blue-on"); }, 400); } Not sure if that would work or not, just a thought. 
I did this: function createNotesFields(customer) { // rest of the function var quill = new quill(notes, { theme: 'snow' }); return div; } This resulted in Uncaught TypeError: quill is not a constructor So I didn't quite understand what's wrong, searching the net didn't yield any useful results. I tried setting up Quill outside the function, but it wouldn't work either, because the divs I use created after the initial page load. Then, I knew there was something I had to do either in the function's runtime or after they ran, but I had no clue how to properly approach the problem.
3meta5me
Nice brush you have there
It's probably not the removal of quill var that fixed this, adding it back in does nothing. I expect it was the first argument passed to quill you were getting tripped up on. In the Quill docs they use a selector, if you were trying to use a selector before the div was in the DOM it would fail because quill wouldn't find the element. I'm passing the notes div directly to Quill (which I just hoped would work and it did!) so it doesn't need to look for it in the DOM and so works even before the element is attached. removing the var quill does nothing really, it means we don't store the quill instance in a variable, which could be a problem later if we need to interact with it. 
btw you should use : br = new BufferedReader(new FileReader(new File("animals.txt"))); instead of br = new BufferedReader(new FileReader("animals.txt")); [edit] and also implement monitorAnimalsRightsActivists() :-)
are you doing var quill = require('Quill'); then later on var quill = new quill(...); because that would cause issues.
Can some explain to me why this proposal didn't just follow the same behavior as `Object.assign({}, objectToSpread[, additionalObjectsToSpread])`?
&gt; And a large ecosystem of tools has cropped up — each attacking different problems from different angles. If that were true, the JS ecosystem would be perfectly sane. But it's not true. We have a large ecosystem of tools, many attacking *the same* problems.
The JS file starts with this line: require(['functions', 'moment', 'timezone', 'flatpickr', 'quill'], function(functions, moment, tz, flatpickr, quill) { and I set Quill up in the config file requirejs.config({ paths: { moment: 'lib/moment', timezone: 'lib/timezone', flatpickr: 'lib/flatpickr', quill: 'lib/quill', functions: 'functions' } }); that's it for the RequireJS part
Should have used reduce instead of goto brah
The problem is keeping up with the latest options and maintaining or refactoring existing code base to prevent fragmentation. Unless you pick one and stick to it and resist the urge of possibly making things better. Writing in raw JS and picking minimal library to use will help though.
This analysis is completely useless. You could also count cars by colors on the street in front of you door.
Meh, it's just an observation, I didn't say it doesn't work.
`'Leggo my ' +` 
[removed]
I think using "···" to represent an arbitrary object in some of your examples is confusing given that you're covering an "..." operator. ;)
Hi /u/mdymel, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
OK, you don't believe seniority matters. Why?
Can you put that on code pen? I'd like to see it 
Have you made an attempt?
It is quite sad that consuming OS is with so much less risk than producing it. The commercial success of MySQL is not easily repeated, but I guess one of the key factors was that MySQL was based on SQL, which had become industry de-facto standard by the time. If there was some kind of NoSQL API standard - like GraphQL or similar - this kind of failures might have been avoided.
Given the blatant self-promotion at the end, I for one have great confidence in the author's upcoming book as well.
I like it 😎
Thank you, one thing I don't understand: With the var cones = Math.floor(Math.random() * 5) + 1 wouldn't I always be selling at least one cone? Do I still need the else statement?
It's really very dependant on what "// Stuff" is, touch and mouse events are not equivalent in their behaviours. Here I'm assuming you want an event every time the users finger enters or moves inside the element "inner", here's the code to that: http://jsbin.com/razewufehi/edit?js,output Warning: I did this on a linux laptop with a touchscreen while in devtools ipad emulation mode, on other platforms your mileage will vary wildly.
fuck php
Hey, author of `react-csjs` here, thanks for posting this! I'm also a big fan of CSJS, but one thing I'm not too thrilled about is that you need 2 imports for each styled component, `csjs` and `react-csjs`. import csjs from 'csjs'; import withStyles from 'react-csjs'; I played around with the idea of re-exporting the `csjs` instance so that you could do something like: import csjs, { withStyles } from 'react-csjs'; I think this would help clean up the interface and machinery needed even more. I'll start with posting an issue in `react-csjs` and seeing what people think, but just thought I'd post here to get some more thoughts. Thanks!
Oh, now you've done it!
If this still doesn't make sense, perhaps you should look up "ad hominem" fallacy. Your argument is the textbook definition of it. You are attacking the character of the person making the argument instead of rebutting the argument itself. We've all been there. For the longest time, I attacked Objectivism by attacking the pitiful life of Ayn Rand and how her life ended up. Seniority matters just as much as race, gender, sexual orientation, religion, ethnicity, and the cut of your jib. In this field, it does not highly correlate with actual ability. The CTO of my company is 22 years old. He's been involved in writing the protocols for OAuth. He picked up data science in about two weeks, integrated it into our platform, and won some competition with the state water board, thus ensuring we received a ton of contracts. I still have no idea what he did. I'm 28. From the moment I met him, I had no reservations about working for him although technically I had been coding longer. I've learned more from him in 6 months than I have in 4 years. I accept that some people are smarter and more talented than me. Your reasoning is not reasonable. Why use an inaccurate measure of judging people when you can just go to the source. That's why I love working in this industry, it cuts through all the bullshit. Just because Bob wears a suit or plays golf with the boss, he doesn't get a raise because his code sucks. Just because Jimbo has been at the company kissing the CEO's ass for 10+ years , he's not next in line for that CTO role. It goes to the 22 year old wunderkind who wears flip flops, cargo shorts, and a t-shirt and who comes in whenever the fuck he wants(Since he's literally 3 months ahead of schedule). He does nothing but kick ass in coding, in managing developers to be better, and in business development. I don't know how else to say that ability matters. Seniority is a relic of an ignorant, bygone era and reminds most people these days of fat, old union guys sitting on their ass, taking super long breaks while someone younger and more driven does more work and gets paid less. There's this new thing the cool kids using. It's called data-driven analysis. You judge people on their actual merits and output. We have the data, we don't have to make inaccurate assumptions about ability by using stand-ins such as seniority, how good one's golf swing is, or how hot their wife is. It's like how Newtonian physics just isn't needed anymore because we have relativity which does a much better job at describing reality. Does John Carmack, a legendary coder, bitch about having to work for some little, upstart shit and challenge his every decision? No, he's happy to work for Palmer Lucky because the kid almost single-handedly jump-started the then moribund VR revolution. Did he have write numerous papers on the subject and talk at the most prestigious conferences? No, his experience in hardware up to that point was fixing iPhones and hacking away at old Nintendo VR devices. 
I was talking about how on a superficial level it was written extremely poorly. Like I'm guessing it was typed in another language and then google-translated to english bad.
&gt; I just want to bring in attention to the fact that we are mistakenly calling Front End as JavaScript. Even worst, calling what we've been building with JavaScript as JavaScript. again even this quote is hard to read. but i don't think anyone is making that 'error' of conflating things written with javascript to be javascript. I'm sorry this whole article and post is just a train wreck.
“Javascript is simple!” ``` if(0 == 2 | 1) {console.log('true!');} else {console.log('false!');} ``` Javascript is _filled_ with weird holes like this for beginners to fall into. It’s never been simple, and the insistence on mandating these objectively complicated and unnecessary toolchains is ridiculous when Javascript is often touted as a beginner language and “[for a very young programmer, setting up a programming environment is orders of magnitude more complicated than writing any program.](https://www.reddit.com/r/ProgrammerHumor/comments/523vm1/nothing_makes_sense/d7h70jm)”
Happy to help! Feel free to direct message me if you run into any more issues or have any more questions!
Short version: Unbind the event listener when you open the modal, rebind it when you close the modal. 
These have been on Macs for a long time. Since the early 90s I think.
&gt; Well it obviously isn't working the way it's done today, no? Javascript and Node are among the most widely growing and adopted languages and platforms in use today. What would you be protecting from here. A different version of javascript itself? Differences in modular code? 
This is what we esolang junkies call JSFuck. 
this is mindblowing
It is definitely possible with SSR.
Thanks I learned! 
&gt; http://jscrew.it Also http://www.jsfuck.com/
Try taking a look at http://hammerjs.github.io/ I used it a few years ago for this sort of issue. (then again it's been a few years too... Maybe there's a new lib that does roughly the same thing but lighter faster cooler cool scheme)
Google bot has been running js while it crawls for 8 years now and they totally support title, meta tags and a bunch of other data. 
`window.speechSynthesis.getVoices();` returns a empty array on my linux install :( 
Yeah, I get none in Chromium or Firefox, only in Chrome
Oh, that's good to know! It seemed like a weird API skimming over the MDN docs, the way it just queues them up like that.
http://imgur.com/gallery/Br00TCn EDIT: found my answer at the bottom of the article.
&gt; Personally if I don't know someones skill level I will look at their experience. If they have no skill or experience then I will look at their golf swing. If the golf swing looks a little janky then I will look at their seniority. Personally, if I don't know someone's skill level, then I don't know their fucking skill level. I don't use bullshit ass metrics just because I need to feel like I have an answer. I don't fill in blanks with my biases and prejudices. I'm ok saying I don't have enough information to make an informed decision. You're being an ass by sticking to your guns and refusing to look at his code. If you don't get that and want to remain willfully entrenched in ignorance, go ahead. If you haven't noticed, your opinion is found so disagreeable and worthy of downvotes that your reply is hidden. I know it's hard, but consider the possibility that you are wrong and everyone else is right.
Server side code is not JavaScript? Are we back in 2009 again? :D
I agree it is a weird api, I hope it gets the es6 treatment.
I don't understand it either. As far as I can tell, it's mostly coming from experienced programmers who either (a) new to front-end development and getting lost and frustrated, or (b) just enjoy criticizing other languages. 
Good point. I just started months ago so it was natural for me to slide into angular, react, etc. I wouldn't know otherwise 
Unary minus is there so you can do stuff like x * -y. Unary plus is there to mirror that, x * +y.
you can use once to prevent the event running more than once: $('.singleAction').once('click', function (e) { e.preventDefault(); e.stopPropagation(); }) Then reattach in the close event of the modal
My guess is that the release of Angular 2 and the setup/dependency hell that came along with it was a big proponent that made the lot of us realize we should slow the fuck down when we consider what magnitude of tools we pull in for simple applications. After _that_, we realized it doesn't matter because cli tools (yeoman, create-react-app, aurelia cli, vue-cli, etc.) and boilerplates exist that already do the setup for us. We also realized that learning everything new that comes out right as it comes out is stupid and not even close to necessary, and that we're all just complaining about nothing. Think that's the gist of it.
Again if you want to continue this conversation I am gonna ask that you do so respectfully. This is just devolving into a full on attack of me. I don't really care it's just not that interesting. I will just try to move the conversation forward by restating my opinion: experience matters. If you want to argue against that you are going to need to tell me why experience doesn't matter, not why skill matters, not why seniority doesn't matter, not by telling me I am ignorant. Just simply "Experience doesn't matter because _________."
Yes, which is evidently news to a lot of people here. [Today they are the lucky ones.](https://xkcd.com/1053/)
The conspiracy theorist in me is suggesting that the true purpose of these articles is to spread FUD and scare people away from JS, so that the value of existing JS developers, and thus their pay, is artificially inflated by the limited supply.
and a black and white drawing of an animal.
You need to understand basic of JS language. "You Dont Know JS' by Kyle Simpson book series are great. Then about scripting Browser (DOM) object go with D.Flanagan
Just converted a minified file I had on hand (originally 10.4kb). Came to 182,246 characters. Chrome almost balked when I copied and pasted it into the console.
[soap](https://github.com/vpulim/node-soap) looks pretty well documented and maintained
Not really. [JSFuck](http://www.jsfuck.com/) uses js fuckery to build a string (such as 'alert("hello world")'), which is evaluated as valid javascript. Brainfuck is closer to a Turing machine. You have a data pointer and an instruction pointer, and eight commands which increment/decrement data/instruction pointers, etc. The only real similarity is their terse syntax.
I think that JS Fatigue is natural result of rapidly growing Web ecosystem. It is important that keep good ux and maintable code with JavaScript standard(e.g. ES5,ES6..If possible, vanilla+polyfill) We should reduce usage of libraries and frameworks to use non-standard syntax or dependency heavily.
the easiest i think would be $(modalTrigger).click((e) =&gt; { if(!modalOpen) { openModal(); modalOpen = true; } }) $(modalCloseTrigger).click((e) =&gt; { closeModal(); modalOpen = false; })
If you put the output code into the input it doesn't work as expected. Isn't that a bug?
&gt; SWJ Star Wars Jedi?
Yeah, but if the team already knows something that will work _fine_ for something, even if something works better, it carries the inertia of learning the new tool, ecosystem. Keep it simple. It's when something stops working decently that it's time to look elsewhere. It's part of understanding the business requirements - does anything here necessitate use of a different tool, or are we fine to use what we know? Now you can argue the latest framework let's you put together some very robust, maintainable code but I'm sure in two years time another old concept will be considered robust and maintainable and prompt a rewrite of the old code, it's a never ending cycle if you shoot for the best best best thing. 
With a very smart and specific compression algorithm, you should be able to compress it into 10.4kb
Can you make it be usable with different voices?
Or thereabouts.
[Chromium](https://www.chromium.org/) is the open-source web browser project from which Google Chrome draws its source code. The browsers share the majority of code and features, though there are some minor differences in features and they have different licensing.
Thanks!
Is Angular considered "homebrew" for example? I don't think so but it's very widely used. I think that's the concern I've developed over the past few years of working with these things. You go in assuming "Hey! These guys wrote this whole framework that everyone is using... they absolutely must know their stuff!" only to sadly find a few weeks in... they've literally considered nothing beyond "Hey! This is how you do a Hello World... and if we're REALLY excited by our new framework, have a ToDo App! Where we bind a total of 10 strings to an unordered list"... I'll give another example. The whole concept of Observables. I mean, they're awesome, right?!?! Well, in theory. It sounds so awesome, but I've never once sent an app to Production using them. When you have "catch all" solutions, they really just end up being a bloated mess. The problem with Observables is that the very thing that makes hem sound so awesome is their downfall... I mean... if I receive a new or updated value from a service, it's basically streamed into my model and then my DOM renders it and I've written zero code to manipulate the DOM or manage state of the Model itself.... it just sounds too good to be true... because it is! Real world large scale apps just aren't as simple a use case of that. What if my model at any given time needs to have the state of half a million values. And by values, it's not a string but probably a json object of 50-100 values in itself... so 500,000 x 100. Obviously trying to just store those in memory as an Observable (or anything static) is nuts. What's also nuts is to have a framework triggering event after event continuously manipulating the DOM on your behalf to give the appearance of live values.... Ok... so let's not refresh the entire data-set on an update, like all the online examples the framework gives. let's search and update ONLY the values streamed live from the service... but wait... it's a non-stop stream of data and DOM rendering... the user literally cannot interact with the page. Worse... searching and injecting single values in some Observable implementations out there is ridiculous. You literally have to "clone" it to a static array so now it's 500,000 x 100 x 2. Search the array, the inject the new values then merge the static array into the observable array... so um...why do we have the observable array in the first place then???? Before someone says it too..I *know* there's a lot wrong with that I just said and how it could be done better, believe me I've tried it all. But at a very high level... that's essentially what you need to do... and step by step what many developers actually do because they just don't understand the inner details of how these frameworks actually work. So the whole thing is a nightmare and unneccessary.
i understood how it worked, i just thought it looked silly.
I think your performance will be a problem once you have a large dom. This is what virtual doms solve. They allow you to think like you are rerendering the whole dom but it does a diff and minimizes dom touches. 
Absolutely. I didn't want to make my post even wordier :)
Don't be a fan of the latest fads and see what works for your tech problems before adding or removing something from your stack. 
JavaScript fatigue fatigue _fatigue_ fatigue?
Yes most of them do. With language concept in 200 pages. With K.Simpson you have ~800(maybe 600, becase he is using short paragraphs) or so pages on language concepts without DOM scripting. When you finish YDNJS then 200 pages from others look pretty much superficial.
This is a fun read on where frontend development is going. I think one thing worth mentioning is that there are far more developers today than there were decades ago, in much the same way there's far more music, literature, film, and so on. It's great! More choices is great. It's not like you need to pay attention to every little thing going on, anyway.
Didn't they use to have a significant discount for people who contributed code to one of the React related repositories?
Hi there — try [Soundslice](https://www.soundslice.com/). You can upload MusicXML files and have them played back in the browser. There's also the free Soundslice [MusicXML viewer](https://www.soundslice.com/musicxml-viewer/), which lets you play back files but doesn't let you save them. To save them, you'd just need a Soundslice account.
Should be a curried function with the path first and the object last. That way you could use it within map() and filter() with less boilerplate.
Ah, got it. There *is* a way to embed Soundslice on your own site, but it depends on what exactly you want to do.
That's a pretty cool idea
http://redux.js.org/docs/recipes/reducers/UpdatingNormalizedData.html Just having a read through these and they seem to be following that convention.. maybe because they're treating it as a LUT and want to enforce that? I know it works without them too.. what are your thoughts on them doing that in the docs? 
ahh yeah I see! I will just use them when I use a variable name there then :) thanks.
The truth is out there...
In your PHP code, you'll want to use json_decode on the data received to convert it to a PHP array.
I wish ES6 also took the existential operator from CoffeeScript. I use this all the time: `nested = my?.nested?.property`
In order to do that, i actually need the value to pass, but I keep your advice :D
Did you check the console for errors and the network tab to make sure it's passing the data as a parameter? Also, the last line in the php code needs a ) at the end to close the print_r.
I should proof-read the code I wrote in here, no there was no errors in console.
in php you're grabbing array (`$_POST['array']`) but in js you're passing a data (`{"data":JSON.stringify(array)}`).