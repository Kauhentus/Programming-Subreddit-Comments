learn the concepts behind the frameworks. it is much more useful, especially in JS world where mainstream is changing rapidly 
Useful for handling complex DOM events. A single button click connected to a method doesn't scale well to handling streams of events like mouse drag, key entry, etc. Being able to filter, debounce, scan and such on an event stream before making it to a method handler is the benefit.
[removed]
I only write code in binary. It's pure. Amateurs.
It is never unwise to learn anything.
Can't agree more :). Since I am new to frameworks, I chose vue.js as I read that it's closer to vanilla javascript than React or in that matter angular. I would love to take inputs from this sub, as I know there are experienced devs here. Anyway, thanks for the encouragement.
A lot of people will use the term soft-realtime. I'd be fine as long as these "realtime" companies just not try to write out the proper term *real-time* in their ad copy. 
I wouldn't use Matlab as a benchmark for anything :) I may work in optics, but the vast majority of the software work I do is in C# or JS. I know I made a median filter algorithm with C# and exposed it through a DLL for matlab, and what took ~100ms in native .net code took over 40s (!) running the code from matlab. I don't think JS is very slow - it's fairly comparable to C# except for some edge cases, which makes it ~4x slower than C++ from what I've seen. For this sort of thing, I'm very spoiled by C#'s `Parallel.For` syntax, which lets you turn any `for (i = 0; i &lt; condition; i++) {` into `Parallel.For (i=0, i &lt; condition, =&gt;` or something very similar. It's been a few months since I've actually written .net code. I'm sure there is overhead in that, but it does allow for use of multiple cores without concern for how many the user's machine has and uses them fully - 98%+ usage vs e.g. when nodeJS apps boot and have ~80% utilization from spawning child processes. Image processing is a bit of a fringe case since you perform often quite heavy operations on multi-million element arrays. It is a textbook example of a case for sharing resources between threads.
Srsly, looks and feels good! Awesome job!
I use React (redux + react router) alongside Firebase for my real time JS apps. It's awesome, and use Create React App for your starter kit, and Heroku as your hosting provider, they have a CRA buildpack that deploys the production application. I usually hook it up to my repo for easy deployments.
You can do it the same way but not mess with undefined or need to loop through again. Just push only values that aren't in the new array into the new array.
This is great. The beauty of it, is how the whole thing is packaged in to a single component: &lt;ReactPlanner catalog={MyCatalog} width={800} height={600} plugins={plugins} stateExtractor={state =&gt; state.get('react-planner')} /&gt;
Ehh you probably shouldn't mutate the prototypes of native objects unless you are polyfilling something that *should* be there. You could just as easily `[].forEach.call(nodeList, ...args)` or whatever function you are after. If it's not for code inside a library, I guess you can do whatever you like though. I personally wouldn't, but that's me and it's a dynamic language so whatever... do what'cha want.
Hi /u/rShadoWalker, can you expand on exactly what you're trying to accomplish? This sounds an awful lot like homework.
What would you expect this API to look like? One form would be (`$` is the lib): $.parent($('p')) Or... $.chain($('p')).parent(); Another, arguably dirty, method: HTMLElement.prototype.parent = function() { return this.parentElement; }; $('p').parent();
So, in code, something like: var myArray = []; var myObject = { "name": "John", "accountNumber": "1234", "initialBalance": "0" } myArray.push(myObject);
Yeah just use a functional library. Underscore, lodash, or ramda.
Long, long ago there was a library called Prototype. It did this, basically. It was a bad thing. There are plenty of posts online that talk about why. I highly recommend looking into them, it's interesting stuff. 
No, but a systems science degree.
Interestingly, MooTools added an Array.prototype.contains method which wasn't compatible when it was attempted to be added to ES6. The committee was forced to use Array.prototype.includes instead to not Break The Web™ https://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible
B.S.C.S
Modern ways to use array methods are `Array.from()` or `...` spread operator. If you support old browsers, just use Babel.
Dropped out of high school. 5 years of experience as a software developer. Passed the triple digit salary milestone a few years ago. Zero student debt, and it seems to send a message to my clients that I'm self-driven. Overall a much better outcome than if I had gone to school. I've worked with some incredibly intelligent people who held degrees, and others who didn't. It really doesn't matter whether you have one or not. I think if circumstances were different at that point in my life I would have really enjoyed continuing school and getting a degree!
No degree at all (dropped university after 2 years). Always liked computers and programming since high school, but learned specific skills for my first frontend job in ~3 weeks. It was just HTML+CSS coding, and later I have learned JS just by myself while doing some tasks. To the moment I'm working on full-time jobs as a web-developer (mostly in JS) for over 9 years.
I screw this up on average once a week. I'll always have a moment where I sit at my desk thinking 'OK, which one is it? Includes or contains?', and invariably I am wrong.
That is wrong, since it only includes first occurence of every present element :) eg de-duplication. You need to construct helper object in advance pass to know future values :) your input is [1, 2, 3, 4, 5] but desired is [2,3,5] ;)
I know this comment is facetious and riddled in sarcasm, but it really hits home.
Just a heads up, this is the javascript sub not r/java. Either way this is a very simple way of how to do it in Java: (I'm assuming you haven't declared your array yet) `CustomerAccount[] customerAccounts = new CustomerAccount[10]; //here you've created an array of CustomerAccount objects but trying to do anything with this will give you a null pointer as you've not assigned anything yet, the JVM only knows you want an array of size 10 that will be of type CustomerAccount.` Then you can simply assign them as so: `customerAccounts[0] = new CustomerAccount(arg1, arg2, arg3);` Etc. Ideally you'd be doing this in some sort of loop, I'll leave you to look that up yourself. You could also do the above in a one liner: `CustomerAccount[] customerAccounts = {new CustomerAccount(arg1, arg2, arg3), new CustomerAccount(arg1, arg2, arg3)};` Here you've created a new array of size 2 which has a type customer account and two valid assignments made. 
I have been writing JS fulltime since 2008 and I do not have a computer science education. I am self-taught and prefer to avoid inheritance where possible.
[Vanilla JS Version](https://github.com/gijsroge/tilt.js/issues/1#issuecomment-275838911)
I'll take `Array.from` any thay over the spread. The intention is much clearer. `dragula(Array.from(nodeList))` `dragula([...nodeList])`
This is definitely the best/most concise way to avoid checking browser support IMO
True, got lots of feedback on that one, I'll be updating the examples later today that clears this up! Thanks for the feedback dude!
Art Degree
As a side note, i know company who would rather hire and educate someone with degree in humanities than junior programmer withnout soft skills but with IT degree. (its a specific example, not general behavior though)
Made a reactive view library with a very small (2kb) footprint that favours composition and provides an immutable store. It started as a proof of concept and it (to me at least) turned out really well. It is very much alpha though, preliminary benchmarks do indicate that speed is on par with Inferno. [Demo on JSFiddle](https://jsfiddle.net/s110ax9g/) [Readme on GitHub](https://github.com/nathanuphoff/x) To try it at home run ‘npm install’ and ‘npm start’, then open [http://localhost:10001/example/](http://localhost:10001/example/) (I do believe [Rollup](http://rollupjs.org/) is a global dependency, sorry). Feedback is very much appreciated. 
I wrote a little television noise simulation using Canvas and the Web Audio API to determine whether I'll use ES5 or ES6 for this year's JS1k contest. [Demo](https://jamesseanwright.github.io/es5-es6-minification/) [Source](https://github.com/jamesseanwright/es5-es6-minification) (README coming shortly)
Depending on country and school, CS (informatics) is often lacking programming courses over all. There's a lot of math, often assembly, semantic technologies, more math... If you do IT instead of CS, you'll likely to have less of the aforementioned courses, and more handson coding instead. 
Thanks!
I had a simular issue. You should look at the complete URL if it is generating a correct one. Eg localhost// is not the same as localhost:80// even though it is going to the same port. Maybe you think it is.
I went to college for a non-CS program. For programming, I'm self-taught. In the past, I've spent a lot of my free time learning about career-relevant programming skills, academic topics (algorithms, data structures), and "horizontal" skills (other languages, things like OpenGL, JVM bytecode format, basically stuff that might be useful if I were to work in a different specialization). Normally at a new job, people quickly realize that I have a relatively high level of knowledge of web technologies (compared to other co-workers). I credit that to the freedom of choosing learning topics that self-teaching affords (and of course, following through and actually putting effort into self-study for several years). I do believe that a CS degree would have helped expanding my horizons for academic and horizontal topics more quickly early on, but I don't think it would have the same impact for career relevant skills. Regarding impostor syndrome: if you don't feel like you're the smartest guy in the room, then maybe it's not impostor syndrome and you gotta put more effort in your self-study (remember there are many people in the industry who have already passed the 10,000 hours threshold). Don't put the blame on a lack of a CS degree though.
Awesome stuff. Going to use it in a photo portfolio for a colleague.
Not sure if this comment helps a lot. Our time is limited, whenever we choose to learn something, we also choose to not learn a million other things we could have learned instead.
I think Haxe is better than CS, because it's so much closer, symtax-wise. To this day, I can't understand CoffeeScript. It's add this weird point where it's not so different that you'd have a real issue, but it is different enough to notice. DCE isn't unique to Haxe. JS does have some issues, but if you run into them then, IMO, you're doing stuff wrong. You can easily avoid them with a linter. Anyways, we're not gonna change each other's minds, but I will say this: if I was going to use a C2JS language, I would probably use ClojureScript or PureScript. I think Haxe is great, but it's kinda in limbo. Too close, but too far.
Ya hashmaps sets stacks .. ended up creating custom classes for these hope more support in addition to maps are added
Agreed. Operator trickery will always be harder to read than clearly named methods that describe the author's intent. I also prefer functional loops like forEach, map, reduce, etc over for loops because it describes the intent of the loop in addition to saying "this is a loop" and ends in a clearly defined variable that describes the expected result of the loop. These kinds of shortcuts should only be used in cases where the shortcuts are dramatically more performant and your iterations are high enough to cause real world performance issues
I'd recommend taking a look at Auth0: https://auth0.com/
Very nice demo, well documented source, and cleanly formatted source. I like this! The only thing that bugs me is that I don't see any tests.
No way I was putting any blame on anything. My impostor syndrome is more irrational than anything and most likely surfaces in accordance with my mood swings 
Just a personal opinion but people throw around the term "imposter syndrome" too much. Sometimes they just suck.
Your both right in your criticism. Hoping to refactor to native JavaScript with no dependencies soon! Feel free to contribute if you like.
App and backend developer for a startup, using javascript for everything. I'm self-taught, but currently studying computer science.
But wäää it's ugly and I don't understand it therefore it must suck
as your lib, domvm 1.x used JSONML templates (see 1.x-dev branch). the performance was okay, but in 2.x i switched it to hyperscript and the difference was pretty dramatic. i recommend doing and tracking the perf benchmarks early, the space is pretty crowded with good options. being on par with inferno or kivi is a big claim that needs strong proof. nice work :) https://github.com/leeoniya/domvm https://github.com/krausest/js-framework-benchmark https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html
I have a fine arts degree in Photography. I'm a software engineer now because it's something I've always been interested in, self taught. However, having a fine arts degree has definitely helped me since I primarily work in frontend / UI and I often work and collaborate with the visual designers. I've come to JavaScript from other OOP languages, stayed for the tasty ES2015+. One of my brothers has a degree in computer science but he wouldn't even be able to write a for loop to save his life. He's now a career firefighter in a major metropolitan city. Also, this **[classic post on Stack Overflow](http://softwareengineering.stackexchange.com/questions/43528/im-graduating-with-a-computer-science-degree-but-i-dont-feel-like-i-know-how-t)** is a pretty good indication of how useless a computer science degree (or any degree, for that matter) can be on its own without interest or drive.
This doesn't work either: const paths = { ROOT: "./rootFolder", PUBLIC: `${paths.ROOT}/publicFolder`, PRIVATE: `${paths.ROOT}/privateFolder` }
I'm the author of the repo. It still is something in pre-alpha lets call it that way but I would like to have some feedback.
simply running create is insufficient, there is a lot of expensive reconciliation that incurs most of the overhead for any followup operations. is your implementation keyed? because kivi's is, and this makes a huge difference. sorry im on mobile, but will check later. those numbers are suspicious. even vanillajs is not twice as fast, it's only very slightly faster than kivi. make sure you're using "scripting time" in chrome's timeline view to measure and not the console.time timings. the latter will be innacurate in case of async operations, etc.
Unless you get a really good paying job :P
Yeah, OP should read up about licenses. 
yes! javascript is the "english" of programminglanguages (Disclaimer: I work fulltime with js)
Yeah, it wasn't easy but I believe it was worth the effort in the end
Yeah, I know. I will probably end up just doing that, but a **canvas.fromDataUrl()** would be such a useful bit of code for me. Especially for a list of images (that all need to be post-processed)...
Darn it, this was going to be my weekend project haha.
nope, not required.
Learning one popular language is a good start, yes. You should also learn at least one or two other languages, though. JavaScript can't be used for everything and it also doesn't scale very well. Anyhow, the good news is that JS uses C-like syntax which is very popular. So, learning something like C# will be much easier if you already know JS.
can someone explain the significance of node list VS array? Node lists have never created problems (in my limited experience). 
https://www.reddit.com/.json
Glad you liked it!
Nice work! Keyboard navigation would be a huge plus.
The first point means you can only extend from things you can call *new* on. function A() {} class B {} var C = { foo: 'bar' }; class X extends A {} // this is allowed class Y extends B {} // also allowed class Z extends C {} // not allowed The last line isn't allowed as we can't do *new C()*, but we can do *new A()* and *new B()*. The second point means you must call the parent constructor if your child class defines it's own constructor. class Foo { constructor(foo) { this.foo = foo; } } class Bar extends Foo { constructor() { super('foo'); } }
[removed]
Meh. I don't think the MVC pattern applies here. You may want to separate the communication channel (the socket) from the presentation logic, and group the presentation logic into a class, so that when the socket receives a message it calls the relevant method on the class passing the message to it, and that class method will draw the message on the screen and update the message position. 
I'm not sure exactly how to expand on this, I need to take any number "x" and divide (separately) by a list of numbers "[a, b, c, d, e]" so as to have multiple answers "x/a=n" "x/b=n" "x/c=n" "x/d=n" "x/e=n" without having the trouble of making many more functions to return those numbers as a true/false for any whole but non-one "n" values.
Looks neat UX note: The first thing I did to remove one from the right side was to click the greyed out one on the left. Could be nice if that also worked to remove it. Though I did quickly figure out that I needed to clock the right side to do it so it's not too bad
If you are asking what this is meant to achieve, let me just write here telling you what it would be useful for and as what I would want it to do not in js terms. (I'm not going to correct errors because it's needless to explain) Take a function: function randomName(Value) { var exampleArray = [2, 3, 4, 5, 6] var Total = 0 var Total = Value/exampleArray &lt;- This is what I need return Total }} And then also there I would need a way to check all of the "Total" values for whole numbers != 1 I believe this checks a value for being whole, but it doesnt exclude one. It also isn't able to check multiple values. function allCheck(n) {; return n % 1 === 0; } So, in summary, I need a way to divide any input number by an array and get a quotient that is also an array of the values that the division statement gives. Then, I need to check the second (Quotient Array) for any whole numbers != 1
Should have put that code up earlier. Thanks for writing it out! I think this will help address some of the concern a few have posted about: This is part of a larger system of progressive transpillation which ships ES2015 to browsers that support the syntax. Unfortunately, browsers lie about their abilities (or rather, lie about what browser they are) so this is a parse-time check of if the browser can support the syntax at all. A recording of my talk on Progressive Transpillation and shipping ES2015 in production is here: https://youtu.be/M1qm-AWWu-M My part starts around 25:20. Slides here: https://speakerdeck.com/betaorbust/progressive-transpilation-at-netflix-and-the-road-to-running-native-es2015-in-production
No forEach or map functions available on NodeLists. Recent browsers have added them though. Safer just to wrap any querySelectorAll etc in a Array.from for consistency imo
started a [browser ONLY Reddit API wrapper](https://github.com/SamSlate/getReddit). contributions/critiques welcome. This is an exercise in abstraction for the mess of code in [my own reddit webapp](http://redditairplane.com) The goal is to have a single .js file that provides all the functionality of a reddit app with an easy to use syntax. Reddit's URI structure and API can be... inconsistent- in a way that you can really only learn by trial and error. I'm hoping to save some devs a lot of headache.
Here is one you can host yourself or run locally. Without any coding on your part, it handles GET, POST, PUT, PATCH and DELETE. You just drop a JSON document into a folder and that is the schema you will be working with: https://github.com/typicode/json-server
I mean it's a pretty poorly designed language that is not a whole lot of fun to work with. But it's popular and ubiquitous so it's not the worst language to start off with. 
The variable one is bad naming, it doesn't give any clue what it's referring to. As an object property it would be fine though.
That's really in depth. Nice! Just a bit of advice, a little pet peeve of mine. When you do: socket.on('updateUserList', function (users) { // checking for errors? No need? Ok updateUsers(users); }); It creat es a whole new function for no reason. You can just do: socket.on('updateUserList', updateUsers); I can understand you were just trying to be more explicit in you explanation though 😊 
I have found that a person's handedness is a useful indicator. Left handed programmers are usually naturally better programmers regardless of college qualifications. 
You should be able to make Bezier's approximate any function over a finite range. You may have to break your function into regions and then use a Bezier for each region, making sure they are continuous at the boundaries. A fundamental theorem of analysis states any continuous function can be approximated with a polynomial over a finite range.
Agreed. Also, once you learn one... Most follow similar patterns. It's just a matter of learning the syntax at that point. JavaScript is a good starting point.
[JSON Blob](https://jsonblob.com/) 
I use Mr. Data Converter to transpose excel data into JSON. It work great.
I did the exact same thing
https://www.programmableweb.com
&gt; I'm an IT recruiter Username checks out.
just pick a convention and stick with it. one such convention -- it's common for js variables to be prefixed with an underscore _, like _userIsValid, especially if the intention is the variable should be "private" (even though javascript has no such notion) functions then have no special prefix and can be differentiated 
That's terrible advice for a beginner. JavaScript is and will remain relevant for the foreseeable future. By the time it is irrelevant they would be experienced enough to know on there own where to go next.
Google's stuff is written in GWT and CC. Some of the new stuff (e.g. Adsense) is written in Dart. Inbox was around 70% GWT and 30% CC, for example. Most big "JavaScript" applications aren't actually written in JavaScript.
I don't understand why you think you would get truly an unbias answer by going to a javascript subreddit....
I've written some live templates to help make developing in es6 more enjoyable. My favorite snippet is the import snippet because it first jumps to the module you want to import then to the functionality of module. This helps intelli-sense when importing the specific part of the module.
Push it in.
It's going to land enabled by default in chrome 57 and all the other major browsers are working on it as well. It's too soon to say what will happen sure, but my point is that it's coming and who knows what change that might bring.
I'm using it with Koa 2. I hope that the future of JavaScript starts moving (even more) into this direction, with this and a typing library like flow, , everything feels like it simply 'fits'. I'm tempted to use Typescript though. Edit: wording.
I always suggest JavaScript or php or better yet both!
avoid the first one if you can. isValid is a perfectly fine function name. even 'valid' would be fine as long as context is indicated there's no reason not to do if (isValid(blah)) doStuff(); and skip the boolean altogether
Sooo. . . . if you're doing some white boarding and you see the candidate pick up the marker with their right hand do you shout "NEXT!"?
Post a complete but minimal testcase on codepen or jsfiddle. 
I don't know buddy, I believe the expected behaviour is the one you click on the right to undo the selection. Imagine if you can add multiple times the same item from left to right
Yes, that's how it works socket.on( eventString, myFunction ) Basically it socket.on is a function that expects a string as first parameter and a function as second. When there's eventString, myFunction will be called with whatever arguments socket usually passes. You can define myFunction inline as an annonymous function or define it somewhere else.
saving this for later
Web Assembly is going to be a compliment to JS. It's going to be used in modules where it's required. Have a online game? The "surrounding" site around the game will be html/css/js. The game itself might be Web Assembly. I would be incredibly surprised if Web Assembly overtook JS, especially since the debugging environment isn't going to be great for a long time.
Its separate from the normal prototype behavior, yeah. I have never seen anyone do this prior to ES6. Basically its an additional [[prototype]] assignment (in addition to the normal stuff set up for the prototype properties) that happens with the use of extends in es6 classes. Instead of this one targeting instances, this affects the classes (constructors) themselves. As constructor inheritance, it affects static properties. ES5 syntax is effectively: function Superclass(){} function Subclass(){} Subclass.__proto__ = Superclass; And what this does is let the subclass constructor inherit directly from the superclass constructor. In doing this, statics from superclasses are inherited by subclasses. Superclass.myStatic = 1; console.log(Subclass.myStatic); //-&gt; 1 Constructors are objects just like most everything else, and as such have their own inheritance chains too. Normally they go straight to Function.prototype, but here by extending Superclass, the proto chain for Subclassing becomes Subclassing -&gt; Superclass -&gt; Function.prototype -&gt; Object.prototype. So an extended class is still a function with function methods, but it also inherits Superclass members in between. This static inheritance really isn't all that important. Instance inheritance is the more important part in all this. If you need static properties, its not so hard to just reference them from the original source if you know where they're defined, e.g. Superclass.myStatic somewhere within the Subclass definition. But if you don't know, or just want to make it easier on yourself by referencing statics from the current class, this behavior makes that possible. Does that clear things up? I'm not sure I'm hitting on everything you're confused about. I'm glad that other thread was useful :) I've explained this stuff a number of times in different ways. Never know which one works best or makes it all click.
Run your own httpparrot instance on a server
I give coupons out sporadically, so not this time. But FWIW, it is free to read online: https://leanpub.com/javascriptallongesix/read
I give coupons out sporadically, so not this time. But FWIW, it is free to read online: https://leanpub.com/javascriptallongesix/read
Don't know why the downvotes. Key point here is reading. One requires you to think, the other is crystal clear. I personally prefer to preserve my thinking capacity for times when it's actually needed. 
Try rest.learncodeacdamey.com
So Chrome was doing this revalidation because they thought it would be good for their users. Then they decided to change this process- not because they found that it didn't help users, but because Facebook wanted them to. Does anyone else see a problem with this?
Thank you for looking at my code. I really appreciate it. &gt; It would benefit readability of the code if you separated these out entirely. I was thinking of this last night too! I'm so glad I was on the right track with my thoughts. After brekkie, I'll have a go at editing and refactoring some of that code. Cool! &gt;You would be better suited by not redrawing to the backbuffer and instead just keeping around as the buffered array. Further to this - if I pass two flags - one for RDS and one for negating the image to the worker I could keep the strip of data in the worker for the full cycle, rather then ping pong it back and forward. =D ----------------------------- I was thinking..... am I losing FPS due to the way I'm handling requestAnimationFrame? I call the start of the animation loop using requestAnimationFrame once the threads have returned with their data. The function that is called spins up some threads and then it ends... so I'm thinking Chrome probably updates the canvas at that point - mistakenly? 
I can't wait for wasm but it's not going to kill js. You'll still need to know about the runtime and garbage collection. It's like working with clojure. You still have the jvm and the ecosystem that comes with it. 
I think they found it didn't help their users. If neither Firefox nor IE nor Safari do a revalidation after a POST request, no developer will rely on it. This doesn't only save a lot of requests for facebook, but also for the user. So, no, I don't see a problem with it.
Same here. First instinct was to click on the greyed out item to remove it. Looks great otherwise though
I use VS Code, it's like Sublime but with some extra features (intellisense (code completion), git, debug for node, etc), but I'm not sure if it's an IDE. I've heard some people use webstorm or intellij for something even more robust 
Well I thought Chrome was doing that revalidation on the premise that other browsers were leaving users stuck with stale content. If that premise was false, fine, but it would be a shame if they were just giving in like that. Your explanation probably makes more sense, this is just what popped into my mind when reading the article.
Don't forget WebVR!
Totally appreciate it! 👍
why not atom?
As a reddit engineer, TIL.
the debugger integration is atrocious. The plugins are similar to what you get from wordpress. 1000s of stale unmaintained broken plugins with a handful that work (but who knows for how long).. ..but the *real* reason I don't use atom is because both VS and WS support the "cmd+click" on a function call to jump to its definition. I've increased my performance by a factor of 10 just by using that shortcut. Atom+Sublime have some overly complicated repetitive strain injury keyboard combination that sort of does the same thing but not really. The only cool thing to come out of Atom is Electron.
Good one. Especially https://github.com/facebookincubator/react-vr
For an IDE that builds the internets, WebStorm's website sucks on my mobile.
well coding in general sucks on mobile so i'm not surprised.
Looks a lot like http://surge.sh/
salute! 
VS Code is using Atom as base
i don't use node for my backends so can't really recommend any. i'd just search for oauth on npmjs and go with the first one that supports your usecase.
In other words, you're talking out of your ass? Apparently the three things you've managed to conjure up are enough to make Atom "crap". And what are those amazing reasons you've come up with? Debugger integration? What percentage of people would even look for that? I don't even know what it does. There are plenty of good extensions to get anything done. I've never had a problem with unmaintained broken plugins in the year and a half that I've used this program. Bring a few specific examples of such broken plugins, or stop spouting bullshit (and please no random trash with 0 downloads, obviously you have to have some level of brain capacity to filter out plugins that obviously aren't mature enough to be used) Missing jump to function declaration is a problem, indeed. That's why we have those wonderful plugins. But I guess it only makes sense that you wouldn't know about that, given that you've dismissed them as "similar to what you get from wordpress". Nuclide provides jump to definition with cmd+click (rebindable of course), or if you want something more lightweight, ternjs seems to do that exact thing as well. Ok, perhaps my post wasn't as composed as would be appropriate, but damn does it piss me off when people give these hyperbolic statements about things and then when it comes to justifying that statement, they've got nothing. But now some beginner is gonna come along and see your post with 7 points, and they're gonna dismiss a perfectly capable editor, because surely the top rated post in a thread on /r/javascript knows better than him.
&gt; In other words, you're talking out of your ass? you don't even know how to debug your code
oh yeah. it has one good theme though! forgot to mention *THAT* which we all know makes you write better code and a more efficient programmer. webstorm has that same search functionality. integrates easily with a lot of plugins as well (except they work) -- most of the ones I've used have become official jetbrains plugins. another reason i like WS is the git conflict editor is much easier to use.
I am slowly coming around to VS Code as it is more stable on my Windows box than Atom. Atom will highlight changes to files/directories by coloring them in the project view (file list) when such are modified from the prior git commit. I don't get this with VS Code (at least not without some kind of unknown plugin) and it is wildly helpful in Atom.
Chrome does that, better than any ide could. I know vscodes ability to mock some of it and in the first moment it feels neat, it still doesn't do a fraction of what Chrome+devtools do. Having an editor that is light while allowing you to code comfortably (ternjs, nuclide) while node and chrome do the heavy lifting, I consider that a virtue.
smh. yes. i would say you should continue to program html in atom. lol
Yes and no. I love JS. It is my primary programming language and I have done well for myself by focusing on web technologies or Node when I need to do systems/automation work. I work for a major .com that is primarily a web based business. I got my annual review on Friday where I discovered I am a weak programmer because my Java skills aren't developed. I don't care. I am not wasting my time with that antiquated bullshit, but this personal decision certainly seems like it will harm my career. Strangely enough... I have gone through this before (shitty annual review because the skills are underappreciated compared to other things). At the end of the day though when lay-offs come around I am untouchable, because its still a web-based company and I have web technology skills Java developers don't have. It was weird when this last happened (2008-2009 time frame when the economy collapsed). They (prior employer that was purchased by the current employer) were laying droves of people off (some of which were remarkable) immediately after I got my shit review.
I totally agree! Will refactor soon to get rid of the dependency.
I'm glad you like it! Create an issue on Github if you run into any problems.
Probably not! I was inspired by a brilliant Wordpress plugin called ACF which implements a similar component. I always found it to be really convenient when dealing with a large amount of options.
I prefer fixed sized components. Anything that jumps, changes shape, length, color, etc. puts additional mental strain on me when interacting with the content. In this aspect, I prefer multi.js. Furthermore, the fact that it displays a list of options at the start makes it feel more inviting, e.g. if I was building a flat rent website, I'd prefer multi.js because I could populate area list with areas around user IP, this way triggering connection of familiarity with the user.
Hi! I'm a huge fan of chosen (and select2) and use them in basically every project. They are both great and mature projects. multi.js is mostly aimed at the use case where the user needs to select and manage a large amount of selections from a large amount of alternatives. Both chosen and select2 tend to become quite cumbersome with 10+ selected options. Hope you can find a use for it!
Thanks a lot! Clearing the search after a selection might be a good idea. Going to think about it!
Got a PR yesterday for this! Going to check it out and then merge so keyboard support is coming soon.
&gt; Content that Facebook serves with cache-control: immutable; will change or be removed, ... Surely, yes. &gt; ... which will create problems, and when that happens a simple refresh won't fix it because they've convinced browsers to replace the slower, reliable refresh algorithm with one based on faith and optimism. Well, as long as that content is then no longer referenced, a reload will surely fix it in the very unlikely event it even causes a problem.
Static content is served with a URL based on a hash that changes when the contents change. HTML is never cached. If the cached resources are somehow messed up then Facebook can bump a counter in their code and force new URLs for all the resources. 
use `.bind()` if you want to pass extra parameters. This creates a new wrapper function, running in scrope of the first parameter. function p1LoseLife(param1, param2) {...} ... $("#" + gContainerId).animate({right: '80%'}, 10000, p1LoseLife.bind(this, param1, param2)); http://stackoverflow.com/questions/15455009/javascript-call-apply-vs-bind 
And https://netlify.com
Didn't service-workers already solve this?
The hash in the URL change downloading a totally new file.
http://myjson.com/
For static sites, I mostly use GitHub pages and then use Cloudflare to enable HTTPS for custom domains. You can also go with GitLab in case you want to keep your repo private. I am using https://netlify.com too and find it to offer a bit more advanced toolset such as Continuous Deployment, auto SSL, pretty URLs for SPAs, redirect rules etc. in the free plan itself.
It is only honoured on https.
writing code is harder than setting a header. You can turn it on and off easily
Don't you mean the each callback is _synchronous_? Irrespective of the SQL query's timing, your problem is that you don't want to play each song as you get them from the database - which is effectively right away. You only want to play the first song immediately, then each additional song only after the song before it has completed. The asynchronous operation to be concerned about is song playback and completion. So what you need is to set up playback of the next song to correlate with the complete event of the current song. You can do this with a generator, but its not exactly a magic bullet solution. It would help you keep track of position by having next methods with a done check to identify completion. But you could also do it with a destructive array pop and a length check on a song list. The second code snippet you posted shows the general idea of how this could work with a generator, but its synchronous. It suffers from the same problem as the db query - all songs would play at once. So I'm wondering if you think generators can make things asynchronous? This is not the case. Generators simply provide a mechanism for iteration with a special yield behavior that allows you to exit a code block with a value and return to that position and execution context again later when retrieving the next. Generators themselves are synchronous. Maybe you're getting it confused with implementations from libraries like co, which uses the yield behavior for async/await-like syntax, but the asynchronous behavior there is driven by promises. So the real question is, what is your song playback API like? 
One last question: $("#" + gContainerId).animate({right: '80%', top: 35 - randHeight + "%"}, 10000, p1LoseLife.bind(this, gId)); I get an error called "Strict Violation" when I do this. However if I ignore this error the code runs fine. Is this something I should be worried about?
 isNaN(Infinity) // false Infinity === NaN // false Infinity === Infinity // true, thus can't be NaN Idk what you were saying, but Infinity is very much considered a number in JS. Besides, it's the operation performed in OP's sample code that's causing NaN, not the use of Infinity itself.
Yea it's surprising to me too that people are downvoting an argument for the more readable code, but maybe I'm just in the minority on this sub
I enjoyed atom a lot but had to stop using it because it would routinely choke on larger files. I was working a lot with an api that sends and receives xml, and I'd find myself opening XML files that ground atom to a halt. At first I used other editors like code and gedit to look through and modify them. But then realized it's faster to use one editor for all my text files. I assume that'll be fixed in atom eventually. Once it is I look forward to trying it again.
Why not set the age to a very large number?
There are boilerplate service-workers that do exactly what Facebook got browser's to change their code for. I just think it's a bit silly for Chrome to change the way their reload button works to please Facebook, instead of Facebook just using service-workers which were invented to take the web forward... and now we have a new header which only Firefox respects.
Cool, so they fixed it for everyone, nice one Facebook.
Looks useful. Could you add a summary of all the snippets to the README? Would be helpful to see what entries are included.
Doesn't SystemJS already do this, including support for loading any type of module? var System = require('systemjs'); System.import('./app.js').then(function (m) { console.log(m); }); I understand it needs to be included, but what else?
Most modern browsers have already started with implementing those ES2017 features, Safari (99%), Firefox(97%), Chrome(80%) and Edge (58%): http://kangax.github.io/compat-table/es2016plus/
I use postman all the time! Does this let you serve dummy JSON though? I believe postman is more for GETing/POSTing/(etc) data from "real" endpoints. (I've never wanted to be proven wrong more than right now)
Shared array buffers seems interesting. Finally something added to the web platform that can't be easily done by transpilers as well, and should result in performance increases
&gt; And if you're going to college might as well get a CS degree. this... exactly! :D
Excited for async/await to become official now, feels so fast and clean for writing code.
Shared array buffers will be fantastic for my multi-layer painting tool! Without them, I couldn't use webworkers to accelerate drawing, because the overhead of copying array buffers between workers and the main thread was way too high. 
&gt; cluding As you said, for first you avoid including SystemJS but can steel use the Sytem.import() Promise based syntax and conditionally load modules using if statements. This has more benefits on isomorphic apps where you use CommonJS bundling on the server but still want to use dynamic module loading (requireJS or wepback2) on the browser. 
It's not a one or the other situation. Async await uses promises under the hood but it lets you `.then` by using the await keyword. I find myself using a pattern like `const results = await Promise.all ([...])` quite frequently. You can think of async await as a tool for working with promises.
An other point is that you can avoid using any Browserify/Webpack/RequireJS code on your sources and use the just the ES6 &amp; System.import() styles. Keep in mind that System.import() was part of the first draft of ES6 and will probably make a come back in a future version to fill the current gap of the spec for conditional/runtime module loading. So this will probably be an investment.
Why do you need private properties? That is the fundamental question to ask here because the language doesn't make it easy to have them and added code complexity makes code more difficult to understand and maintain. If you can get away with simpler code, you should. Assuming you want to have them anyway, the first method isn't a good method because all instances of the class will have the same value for the property. The second method is better but isn't truly private in the face of [Object.getOwnPropertySymbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols). If you're willing to assume code won't try to derive which symbol matches which property then you're probably safe to assume that that code won't try to access private data created by even simpler means.
The only way to get true private instance properties is to use a WeakMap.
Oh hey look microsoft's browser is well behind the rest of the market and will force us to write worse code because people use it anyway...
&gt; PJS (codenamed River Trail): the plan of this ultimately abandoned project was to bring high-level data parallelism (think map-reduce via pure functions) to JavaScript. That is unfortunate. It looks like a considerable effort to convert the existing parallel arrays in my parsers to the shared array buffer objects in order to achieve proper data parallelism at execution time. I just wonder what kind of speed up I could get for the investment of effort.
It also helps alot when you reuse the result from one part of the promise chain later on. Compare const {entitiesOnPage, totalCountOnServer} = await fetchEntities(currentPage); const entitiesWithStatusData = await enrichEntitiesWithStatus(entitiesOnPage); return {entities: entitiesWithStatusData, totalCountOnServer}; to return fetchEntities(currentPage) .then({entitiesOnPage, totalCountOnServer} =&gt; { return enrichEntitiesWithStatus(entitiesOnPage) .then(entitiesWithStatusData =&gt; { return { entities: entitiesWithStatusData, totalCountOnServer }; }); } })
Thanks, I was just about to reply and you did it perfectly!
Oh really? I've mostly been using it server-side for API data fetching...
Agreed. Maybe the content hashing won't change, but at some point they'll have a misbehaving server or a bug in their server code, end up serving the wrong content, and everyone will need to clear cache instead of just reload to get it fixed. People who are arguing this can't happen haven't thought through all the possible scenarios.
Yep I'm talking about modern JS. Throwing features at it is doing nothing to stop its horrible quirks and "fail never, just guess what to do" "type" system. 
There is nothing wrong being a bit conservative in this (imo too fast) changing landscape. Microsoft does implement new standards fairly quickly, and be honest, once you have the requirement to support IE you can forget ES6+
 const MyClass = (() =&gt; { const $ = new WeakMap() class MyClass { constructor (speed) { $.set(this, { // private properties speed: speed }) } getSpeed () { return $.get(this).speed // access private } setSpeed (speed) { return $.get(this).speed = speed // modify private } } return MyClass })() I think you're misunderstanding that WeakMap feature. The whole point of using the WeakMap is that instances of MyClass are automatically added to the WeakMap instance. If we were to use a normal Map then we would end up with a memory leak since the Map would have a reference to each instance of MyClass and therefore would never let that memory get GCed. A WeakMap will not stop GC from collecting its keys (which is exactly what we want). So as soon as a MyClass instance goes out of scope, it will get GCed correctly.
If you're not using a transpiler to write modern JavaScript you're the only one forcing yourself to write "worse" code.
Absolutely. BTW, in this case I'd probably avoid nested calls by storing *totalCountOnServer* in a local variable in the parent scope.
Yup, both are valid options. But I really dislike declaring a variable before assigning something to it.
Thank you very much. Bookmarked. I will take a look at it soon.
I am curious why you want private properties if you're just going to expose a setter for `speed` anyways.
I don't care for it to be actually seen or not, the point is I want to force my logic into getting and setting it. This can be done in many ways, I'm kind of just exploring.
We have a winner!
Revised version: return fetchEntities(currentPage) .then({entitiesOnPage, totalCountOnServer} =&gt; { return { entitiesWithStatusData: enrichEntitiesWithStatus(entitiesOnPage), totalCountOnServer }; }) .then({entitiesWithStatusData, totalCountOnServer} =&gt; { return { entities: entitiesWithStatusData, totalCountOnServer }; });
The best git integration and sql client also if those are important. I have used jetbrains products for years, since version 8 of intellij, but I am currently have not been doing back end work, so I use mostly vscode, it is more performant and has an awesome rest client extension, so it best suites my needs, and I don't like the latest jetbrains licensing change so I don't think I will be renewing. Another potential jetbrains downside is that if you are multilingual, it is a different product for each language and you are limited to what they offer(java, js, php, python, ruby, c++) where as if you want rust, go, c# etc., you can do it more easily in vscode. If you are certain you are going to do nothing but javascript, you will not be disappointed with webstorm.
I don’t know any material about design patterns, but I’ve written two things that come close: * Moving from ES5 to ES6 (several examples, each time the functionality is first shown in ES5, then in ES6): http://exploringjs.com/es6/ch_core-features.html * Techniques that make life easier and only exist in ES6: http://www.2ality.com/2016/05/six-nifty-es6-tricks.html
Thank you very much. I think this will help me out a lot!
Some features (proxies come to mind) cannot be transpiled.
I am really impressed that you consider emacs to be a good (or even the best) editor for working with the Web platform: I’ve tried it several times, but always struggled. I could almost use vim; am most comfortable with Atom, but no matter what I do I can’t return to emacs, although it was the very first editor I ventured into coding with. Could you perhaps share your emacs settings?
OP- 1. First hold a job. then don't get fired. then be able to teach a few people. 2. Its so simple. get a job. do what they ask. maybe mess around on the side. 
Can someone give /u/rauschma their mobile stylesheet?
I would just use Unicode to do this: var madness = function (string) { var arr = string.split(""), output = []; arr.forEach(function (value) { var numb = value.charCodeAt(0) + ""; if (numb.length === 3) { output.push("\\u8" + numb); } else { output.push("\\u88" + numb); } }); return output.join(""); };
This one is the bomb because you can easily come back and update it later as long as you keep the uuid. 
+1 Yup. Plus its good for the lower echelon to cower in our splendor. 
Not that this directly answers your question, but could be a good starting point: https://github.com/mazzur/awesome-javascript-design-patterns
What's wrong with Symbol approach? Unless someone uses `Object.getOwnPropertySymbol` or similar to get a list of symbols, I think symbols are private enough. In Java you could use reflection to get private variables, I think symbols give a similar private functionality.
Like most people, I'd give it to VS Code and Webstorm. VS Code is free and exceptionally good. I hate VS and expected to be unimpressed by VS Code, but it has surprised me. Webstorm I haven't used a lot but I **have** used PHPStorm a ton, and it's a superset of that functionality. IMO if there's a non-JS language you use extensively, such as PHP, Ruby, Python, etc, the Jetbrains solution for that will have an overall edge. For JS only, you'd be happy with either. The free-ness of Visual Studio Code might seduce some people, but I honestly think the amount paid for Jetbrains IDEs is chicken feed for a professional tool.
JavaScript objects are essentially hashmaps (aka hashes, aka associative arrays, aka dicts), although an implementation is certainly able to use a more specialized representation when it makes sense (e.g. a dense array when all properties are numeric and contiguous.) I can't say how common it is to refer to JS objects as maps, but it's not exactly obscure. There is no need for explicit get/set methods in order for something to be a map. A map just means that it consists of associative pairs, in this case string properties mapping to arbitrary values. Note that ES6 added two new types, `Map` and `Set`, which remove the restriction of string keys and allow arbitrary objects as keys. That doesn't mean that plain objects aren't also hashmaps. 
The Map object is a relatively new feature in JS that came with ES6. In the past, it has been very common to use a plain object as a form of hash map, and there's still a lot of code that does that. Just don't expect everyone to use the correct terminology all the time.
So... all the modern browsers already have 80+% coverage?
&gt; IE11 with 4% Why is it not 0%, though?
https://www.reddit.com/r/javascript/comments/5qrbja/browser_tweak_saved_60_of_requests_to_facebook/dd30jf2/
Because it's not 0%, it's 4% 
But that just confuses me more. Is Microsoft adding new features to IE or not? Why have they bothered to add 4% of the 2017 standard, but won't add more?
&gt; or Safari from two weeks ago Latest Safari has 100% ES6 support, though.
Oh shoot I missed that we were talking about 4% of support of ES2017 in IE 11 and not the percentage of people using it. Idk, good question which I don't have an answer for other than that it's just harder to write cutting edge Javascript features into an old browser that wasn't build in a way to easily integrate newer ES versions. People who use IE11 aren't concerned or probably even know how to update so seems like a lost cause to me.
Don't use classes, use a factory function. It's actually fairly simple to have private member's using closures. This function will return an object with a private member (priv) and a public one (pub) function foo(){ var priv = 1; return { function pub(){ priv++; console.log(priv); } } } Sorry for any formatting issues, on mobile
Edge also has all of async functions behind a flag, if the table included that flag being turned on it'd probably be 70%+.
Once you do docker run -e FOO="hello world!" test that var is in your docker env (try testing it by having "CMD env") once you confirm the var is in your env, try running your app without docker and make sure it picks up the vars in your system (i think this is where your problem is)
Yeah both those reasons. It's for a homework assignment, OP wouldn't learn anything without an explanation of what was happening and the syntax would be half the explanation. Same reason detailed SO answers get more votes.
&gt; but when you want to find a string you can search every open doc and the search results is a list that FOLDS by file Not sure what if I understand you correctly, but Atom and Sublime do this too... [Atom Screenshot](http://i.imgur.com/z82s0ZR.png). [Sublime Screenshot](http://i.imgur.com/VDd9bVw.png). You can choose if you want to search the entire project, just from open files, or have custom includes/excludes.
I've never seen that screen before. Is that what pulls up when you hit ctrl+f?? for comparison: [here's notepad++](https://i.imgur.com/czz0pUZ.png), what I love is that you don't even need to leave your current line to copy and paste code from another file or line. I wish VS Code had a similar search window. 
PHP is literally one of [the worst programming languages in existence](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/). It's not at all a good language to start with.
Every day I strive to become better at the craft of programming, primarily through JavaScript. It's been a very rewarding journey that I know will never end (programming, that is). 1) Pretty tough to say, but something makes me think it's probably just knowing the language semantics well along with some popular APIs that are commonly used alongside (DOM, node, ajax, canvas etc). I can think of a lot people that I consider to be amazing at JavaScript and they all meet the above criteria though vary greatly as skilled programmers. 2) Read. Build. Fail. Debug. Fix. Learn. Deploy. Document. Communicate / Help / Teach. Work on Open Source. Repeat. edit: also.. you don't suddenly become amazing at JS and you certainly don't stay amazing forever. JS changes fast so you have to keep up (to *stay* amazing.. not generally)
: nods : I'll have to go and research. My understanding was the repaint happens if canvas gets updated, and at the end of the function called in getAnimationFrame... but it's vague.
[removed]
Currently using moch, but we might switch to jest.
We use a mix of mocha and tape. Highly recommend trying out tape
 console.log('hahaa!'.split('a').join('e')) // hehee!
Web component tester. Stray clear of Polymer/web components in the short term if you want to do proper testing :/ Mocha is not the only one that's popular though. Similarly popular are [Jasmine](https://jasmine.github.io/), [Jest](https://facebook.github.io/jest/), [Tape](https://github.com/substack/tape), [Ava](https://github.com/avajs/ava) and I'm probably forgetting a few. Jest, although it started a bit bumpy, is pretty good now, IMHO. It's main distinguishing feature is snapshot testing, which makes sense for some use cases (especially when you use a virtual DOM library), and which has the advantage if you're using React that a lot of docs and tutorials use it.
At least Edge is automatically updated and users can (and do) install other browsers.
By the way, if you use a string as pattern for replace, it will only replace the first occurrence. If you want to use replace for this, you've to use a regex and a callback as I did.
Mostly mocha, but now starting to use AVA! It's been quick and easy so far. 
Would it be viable to use Shared Arrays in conjunction with the recent vDOM trend to just have the vDOM read in from those arrays and have all of your logic in a web worker to keep everything but UI in a single UI process? I'm a React guy, so to give an example: Run redux, sagas/thunks, etc in a web worker(s) and have those write to a central shared construct, which the vDOM subscribes too (whether it be React, Inferno, whatever). Is this overkill?
what about private class methods? 
Yup, you can't transpile it to efficient code but here's my take on it: [babel-plugin-proxy](https://github.com/krzkaczor/babel-plugin-proxy) 
I really want to consider something like this: vDOM/UI &lt;-(State)&lt;- State Manager &lt;-(Events)&lt;- Web Worker(s) With this setup, you get a few benefits. You can have N processes running and submitting events to your state (you would probably need to timestamp at that point or something). Then in your state, you can throttle the rate it sends updates as needed, or to certain parts. I know there have been many cases where I have passive data (the user doesnt interact with it) that does not need to be updated IMMEDIATELY. In cases where you are reading in tons of data from the server for real-time use, I can see a lot of value in something like this. Obviously it probably isn't for everyone, but my job has some usecases we need to tackle one day that could really benefit from this.
Not the biggest fan of the await / async pattern. It essentially turns asynchronous code into synchronous but without the side effect of running everything synchronous. I think by itself is fine but when you're going to have to use it with libraries that don't have a good way to support async / await you're going to end up with a mixture of code styles. At least this has been my experience seeing people use them through babel. Code ends up a bit confusing when mixing with older code. Excited about the shared arrays!
Mocha for js unit tests, JUnit for java
1. Just like in any other language, it means you can use all its quirks and qualities to express your ideas cleanly and clearly. It also means you understand the science and the different ways of solving problems using the language. Remember, we're humans working on human problems! 2. I thought I was okay at programming until I got stumped by an interview question involving graphs. Turns out that knowing the ins and outs of a language isn't all that useful if it doesn't help you solve a real problem. What does help you solve problems, though, is getting experience by thinking about and creating a lot of stuff and **stackoverflow**. You're not going to be able to know and understand everything so accept this fact of life early on so that you can focus on the important thing which is *taking the stuff that's in your brain and bringing it into the material world*. Whether it helps people, improve lives, or is for your own learning and enjoyment, whatever... The point is that you are improving your own value in life by creating something that didn't once exist with a side effect of doing something useful for society.
Hasn't `System.import()` been replaced with just `import()`?
If you can sit down, think about something, and figure out a procedure to get from start to end, you're already 90% finished. The problem with trying to memorize built in methods and whatnot is that you might not even be aware of the uses of that particular language feature. For instance, if you want to build an abstract data structure like a heap, you may want to use a class and the push and pop methods. But why would you ever need a heap? Well, maybe you need a priority queue. But why would you ever need a priority queue? Well, maybe you need to create a graph. Well, why would you ever need to create a graph? Because I want to figure out the shortest redirect path for a list of misspelled domain names so I can properly price and package them for wholesale buyers. It's stuff like this that actually matters. 
It won't matter. No one will ever look at it.
LOL
Recently started using [Cypress](https://www.cypress.io), which is built on Mocha. Loving it. 
[removed]
It should be quite trivial to wrap code that uses a callbacks to promises and bluebird can promisify for you if you don't mind adding a dependency. Or am I missing your issue here? 
This a joke? Angular is practically dead in the scene. Just about every company is looking to get rid of their current Angular 1 implementation in favour of either ES6/ReactJS/VueJS.
Yeah, I don't get it either. Vue is coming up and [for a good reason](http://blog.debugme.eu/why-vue-js/).
https://developer.apple.com/library/content/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html
Jsbin has a console. 
I'm not sure how different from your eval method this is but I have personally used this website to debug some javascript on an ipad: https://jsconsole.com/ You won't be able to print out object trees with this though; if that's what you need you will probably need an OSX device.
Thanks. Jsbin seems good. Safari developer guide operation seems like a faff. Connect ipad to desktop!
Thanks , something new, never seen that jsconsole.com before.
Jest
There's a lot of similarity in this code. You can break it down to what's common and provide a variable replacement for what's different. That effectively gives you: if (!angular.isUndefined(newVal)) { if(!angular.isUndefined(newVal[prop])){ $scope.dataPoints[prop] = newVal[prop]; } } Where `prop` is the name (as a string) of the property changing. Now you said that the user can only change one of these at a time, so if you know what's changing and can set `prop` to that, the above code is all you need. But if you need to perform a check for all properties every time, then you'd need to iterate through each of those, assigning them each to `prop`. if (!angular.isUndefined(newVal)) { var props = ['min','max','yellowRangeMin','yellowRangeMax','redRangeMin','redRangeMax']; _.each(props, function (prop) { if(!angular.isUndefined(newVal[prop])){ $scope.dataPoints[prop] = newVal[prop]; } }); } 
Karma chai mocha 
Ava has snapshots as well, iirc
;-) Working on it, but I have along to-do list ATM.
Jest should have no issues with this. It uses babel-jest as default to transpile your files on-the-fly.
Right, but we don't know if OP knows what regex is which is why I split the string so you're only replacing a single char at a time. 
Ah, [you're right](https://github.com/avajs/ava#snapshot-testing). Together with parallel test execution, that makes Ava and Jest about equal, I guess.
We push to production and see who complains. :(
It was also relatively straightforward to set it up to use TypeScript to transpile. I was pleasantly surprised with that :)
Thanks! This is really helpful. I have been reading a lot about how class inheritance [is a bad pattern](https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.9ifbhc2jk), but it seems to get widespread use, for instance in React, so it's helpful for me to understand it. 
I just checked this because I didn't believe you, but it's true. This is sort of amazing to me given the amount of trouble I have developing for Safari now. It's way worse than IE, generally.
On a side note, I prefer VueJS out of all of them.
Ava is nice, I love it's API. So simple, yet powerful. Even though Jest is faster at runtime for react projects.
Caniuse.com is pretty useful, too. Googling "caniuse fetch" will find it.
Hi /u/mr_patrick_js, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
if they won;t google their problems and figure it out, they aren't going to read a sidebar or sticky
Karma, mocha, chai, sinon and inject-loader: makes for a wonderful combination of every tool I need 😄
This is the unfortunate truth. However, /u/BlakeyD, you should now be able to edit the [FAQ](https://www.reddit.com/r/javascript/wiki/faq) if you'd like to try it out -- let me know if you update it and I'll re-add it back to our sidebar!
Ava is great! Only thing I miss from Mocha is the ability to have nested test scopes using multiple describe() levels.
You are a truly vile, disgusting piece of shit. Assholes like you are what allow sexism to run rampant in our industry. Fuck you.
I think you're almost correct, but OP specified 12 bits per color channel. This would probably mean that it's `12 * 3` in bitrate per pixel. Bitrate/Second: (12b * 3 colors) * 3840 px (width) * 2160 px (height) * 24 fps = 7166361600b/s Bitrate in an hour: 7166361600b/s * (60 * 60)s = 2,579890176×10^13 Or roughly 23,46 TiB
Take time to read code. Look at other people's source. Fastest way to learn, imo.
But others could still point at the resource...
Brb - telling my female friends that by calling themselves 'programista' (male noun) they are sexist towards themselves. 
Cheers for this, I was giving this as a theory at university, something to think about after a lecture buy honestly could not find any properties formulas for this type of work. This was mixed in with javascript so I didn't really know anywhere else to ask. 
Not OP but, like him, I feel I'm ready to jump into the frameworks world. You said "react as second framework". Were you assuming OP was going to learn Vue first? If not, what would you recommend as a first framework? Cheers!
i am totally watching this project. great idea. 
It would have been more interesting if the author conducted other tests such as brace formatting, whether people add new lines in certain expressions etc. Nonetheless, nice share!
TAPE | TAP | NYC
I'm not a huge fan of vue. When compared directly to react I find it really lacking. It is a little closer looking to html though, so I understand why people think of it as a beginner framework. IMO: React is the much better framework and easy enough to learn if your javascript is good. Now if you're just starting out and you are comfortable with html/css but maybe no so great as javascript, then learn vue first.
Great! Little question. How can I make the pathname of the current route available in my view? I want to do something like this: const BasicExample = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li className={classNames({active: pathname === '/'})}&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li className={classNames({active: pathname === '/about'})}&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li className={classNames({active: pathname === '/topics'})}&gt;&lt;Link to="/topics"&gt;Topics&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr/&gt; &lt;Route exact path="/" component={Home}/&gt; &lt;Route path="/about" component={About}/&gt; &lt;Route path="/topics" component={Topics}/&gt; &lt;/div&gt; &lt;/Router&gt; )
I'm not sure how to access the path (I'm pretty sure it's exposed somewhere, just console.log the router and check), but what you are trying to do is explained in the react router tutorial here: https://github.com/reactjs/react-router-tutorial/tree/master/lessons/05-active-links
I wasn’t sure whether Jest would work well with plain node/browser JS. I went with Ava in this particular case because its API is simple and it uses babel to test ES6 modules, which is all I need.
Its simplicity is why I chose it, no React though, but the internals of [this](https://github.com/nathanuphoff/x).
what a cool idea
I will definitely give jest a try in my next freetime project :)
I'm impressed with Jest too. Before I loved mocha. What I'm surprised though is that `it` functions don't support the `done` argument for async testing. I know with promises you can just return them, but sometimes we're working with good old callbacks.
You see this in my local sub all the time. "Where's a good &lt;insert here&gt;?" with every other answer being "See the sidebar". And you have to insert an arrow-------&gt; or they still won't find it.
JEST!
Bastards.
nice job for v1
Check out their docs on the README. https://github.com/ReactTraining/react-router/tree/v4 
`window.location.pathname` ??
&gt; If you take the fourier transform of the kernel and image, multiply them, and take the inverse fourier transform This is the point for me when subject starts to be too complex for understanding. Though using webworkers is a great idea)
This is a list of free books on JavaScript: http://jsbooks.revolunet.com/
You have some large image, and the kernel is your 2D matrix. To do this by spatial convolution (pixel summing), you do something like this: for () { for () { for () { for () { something += something } } } } This creates a lot of operations. A mathematical property of convolution is that this spatial operation is equivalent to a multiplication in the frequency domain. The Fourier Transform maps spatial information (your pixels) into frequency information. The pseudocode to do this is something like this: ftImg = fft(img); ftKernel = fft(kernel); ftResult = ftImg * ftKernel; result = ifft(ftResult);
Might want to post some code here. Hard to tell what you're expecting to happen.
Use Github Gist to post the code or Codepen. 
thanks! :)
Nothing yet. We'll have more of that stuff once we're out of beta here in the next few weeks.
 JSON.parse(sessionStorage.getItem('money'));
That's a totally reasonable request. I'll get on it. Thanks!
Hey thanks, there's at least already something about the motivation behind the new version which is pretty interesting :)
Whoops. Found the link. https://github.com/tandemcode/tandem Looks like a cool idea.
I'm really surprised that 2 space indentation has become so popular. It's literally the worst of the 3 options. I prefer tabs, and can live with 4 spaces. But 2 is just awful.
Its two ways to address the same underlying memory. A function does not allocate two separate memory chunks for arguments, its all the same one.
Careful, this is slightly misleading. The Fetch specification recently changed, and only Edge "properly" supports it at the moment. That being said, Edge had some bugs with it's implementation but has since seemed to fixed them. https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7773267/ in particular was an issue for us for awhile. If Chrome/Firefox have since updated, please correct me.
Same reason this happens: var test = {attr:1}; test2 = test; test2.attr = 2; console.log(test) // { attr: 2 } console.log(test2) // { attr: 2 }
this library above all else gives me serious JS fatigue
It also works the other way around (reassigning indexes of `arguments` to mutate the named argument. Fun! There's a fairly informative blog post by Angus Croll here: https://javascriptweblog.wordpress.com/2011/01/18/javascripts-arguments-object-and-beyond/ Quote from the spec: &gt; For non-strict mode functions the array index […] named data properties of an arguments object whose numeric name values are less than the number of formal parameters of the corresponding function object initially share their values with the corresponding argument bindings in the function’s execution context. This means that changing the property changes the corresponding value of the argument binding and vice-versa
I actually haven't tried Jest so can't comment. It's worth trying out on a small project - it doesn't take long to get started :)
This can be useful for on-screen logging: https://github.com/jonbri/ticker-log
Anyone really good with react router wanna give us some highlights that should make us excited about the update? 
Thank you !
In summary he is stressing a declarative approach, as in make the code more meaningful with fewer choices (or branches of flow control). This is excellent guidance to a point (an irrationally short point). Here is the key premise: &gt; When it comes to coding in JavaScript, I’ve noticed a pattern. The more indentation in my code, the more complicated it is. I disagree. Sometimes this is completely true, because the code is all over the place and confused as to its own purpose. In many other cases, indentation denotes structure. In well written code structures denote flow control. I would rather know exactly how I got to a certain point in the code simply by reading the damn code. Declarative programming won't get you this. Fortunately, lexical scope is an inescapable phenomenon in JavaScript, which means the visual structure of how the code is organized may very well perfectly mirror its flow control at execution time (or at least be a close descriptor of). You don't get this visionary power from most other languages and certainly not from inheritance (inheritance is an inversion of flow control compared to a purely lexical structure). The article does distinguish between simplicity and ease, which I absolutely agree with. I find writing hundreds of disconnected isolated fragments that extend something else to be not simple, but likely easy (according to the article's definition). I call that madness the 1000 island problem. Nobody is required to write code like this, at least not in this language.
it's crazy since there is no other way in JS to achieve this effect. There is no C like reference variable. 
Run your code through a beautifier and indent it however you want. Don't like semicolons then don't add them. Want to force semicolons then use a beautifier that adds in the missing semicolons. This is all stuff that can be automated.
It's a link you have to click through instead of just telling you the answer.f
Man, where's your syntax highlighting in those screenshots? How can you LIVE like that?! :P
I'm with you here, it so easy to automate it doesn't make any difference. Do whatever takes fewer key presses or make your eyes happy or is what the company you work for does. Don't sweat it and be flexible.
If money is a global variable, you can do the following to access it: window["money"] Another method that would work regardless of whether money is a global variable or not is to use an object approach. I personally recommend this method. For example, you can have the following: var obj = {} obj["money"] = cookie1 ... obj["money"] += cookie2 ... A third option would be to use the eval() function which takes in a string and evaluates it as if it were JavaScript code. In this case, the following will give you what you want: eval("money") //returns the money variable However, use of the eval() function is usually discouraged. There's some performance issues with it and also can be a problem when it comes to security. For example, if someone found a way to pass in their own value into the eval() in your code, they could potentially run any JavaScript code they wanted to cheat in your game or do other malicious activities.
My eyesight isn't even bad and I still feel strained trying to read 2 space indentation. 
https://github.com/topdude15/icecreamscooper/tree/master
I'm a bit new. But what does cat example = () mean?
Huh? 
Good job! Thanks for the time and work, @lhorie, @Tivac, and the all the contributors! 
"space, minus, space and then"??? Who could possibly look at this and think that typing that is a good idea? I love the idea of the tokens: `yyyy`, `email`, etc. but the rest... The complete regex should be: `dd/MM/yyyy - email`, possibly with token wrappers: `{yyyy}`
Honest question, but why is that? Coming from years of Backbone/Marionette use (and vanilla JS before that), React router was a *delight* to use once I learned it, which didn't take very long when you're already "thinking in React". Gone are the days of the redundancy in route declarations mapped to methods which fire some other application-specific event that some other part of the application then hears, calls another method, which instantiates some views which load a template (all separate files, of course, despite their strict coupling) before finally rendering itself in some other view elsewhere in the application. Each application I encountered had a slightly different way of tying this all together, and it never felt straight-forward and foll-proof beyond the most simple static routes. I used to hate reading people tossing around the terms "reasoning about" and "declarative" when describing things since they're so subjective (and, indeed, I groaned when encountering these terms in docs/writing about React Router), but man it all really clicked once I learned how to use it.
I've been following RE:DOM since you made it and been taking a similar approach myself since earlier, I figure I'll finally write up some thoughts. The most useful thing a DOM library can accomplish is encapsulation. DOM libs make a lot of noise about what amounts to syntax sugar, but the only *real* (true and limiting) problem with the vanilla DOM is that it lacks encapsulation (until we get performant, reliable Web Components). Look at every popular DOM lib - React, Angular, Backbone, etc - no matter how much they talk about it, all implement encapsulation. RE:DOM's needs to improve. Consider a DOM manipulation `this.el.firstChild.textContent = value;`. If `this.el.firstChild` is controlled by a sub-component, this line breaks encapsulation. If `this.el.firstChild` may or may not be a sub-component, then the bug isn't even on this line. One possible solution is a prototype method, name of `this.$` seems good to me, that implements a component-aware query algorithm. So the above example is rewritten `this.$('firstItem').textContent = value;`. Then introduce the soft law, "though shalt not obtain Node references except using `$`". Making `$` very fast should be possible, as not needing to enter sub-components puts a pretty decent cap on the search set size within well-architected apps. Saving references to Nodes manually during construction is beautiful in its ability to eliminate overhead and lib code, but not a good strategy for the user because it is manual bookkeeping, it breaks DRY. Every time a referenced Node is swapped for another or removed, the modification must be manually synced to two data structures, the DOM and `this`. Either automate the syncing, or eliminate the only one of those data structures that's optional, references on `this`. DOM mutation strategy improvement should be a todo, I don't have any good suggestions for you. "The only bug-free code is code that doesn't exist"; React and friends eliminate the need to write DOM mutation code; this is a *real* advantage for them. (Bought at a price.) To some extent it's fine as long as you achieve encapsulation, in which case the complexity of your DOM mutation code is capped therefore one can reasonably expect its quality to be excellent. But it would be better not to regress from the status quo in any way - actually, and moreso for PR. Not a complete analysis of your work, just comments on the parts that I've already iterated on quite a bit.
true that ;)
v4 is an amazing improvement. Saying words like this discourages authors and passes on your unwillingness to learn and grow. It makes people sad. As with all of this amazing kit that we are given for free, the choice is to simply not use it. Fatigue avoided! 👍
As far as I know, Elm html is based on [virtual-dom](https://github.com/Matt-Esch/virtual-dom) (which first came out around the same time as Mithril), and virtual-dom took inspiration from [hyperscript](https://github.com/hyperhype/hyperscript). Mithril took inspiration from [domo.js](https://jed.github.io/domo/)
It sure looks like a good improvement. But fatigue is fair, especially with react router. they've promised to not break the API at least twice before this. 
Codecademy gives you basic understanding. Frankly speaking, codecademy is a quick introduction to new stuff. It gives you an overview and backbone of something. You could hardly handle a real task if you depend on what codecademy gives you only. To understand how to use a piece of knowledge, you should read a lot of example. You need front-end and back-end knowledge to build a website. In reality, companies put a lot of work in security, stability, traffic handling etc. Therefore, the website structure is much more complicated than that of self-practicing site. You may even need networking knowledge to build an effective, powerful site. Being a developer, you have to stay hungry. Learning is never too late. Always keep learning.
Hi /u/techbuk-com, you just submitted a post an hour ago. Please wait a little while before posting again. Thank you.
If you're overwhelmed right now as a beginner, prepare yourself for the longest trip of your life. &gt; How can I learn how to program effectively and learn all I need to know to get where I want to be? Program a few apps, apply for a job, and convince them to bring you aboard. Want to cut the time down on building an app while maintaining high quality code? Learn a framework. Too hard? Pick up more javascript, then go back to the framework. Choosing a framework is the easiest part of front end development. In the process of creating anything, there are going to be hundreds of decisions to make. Just decide. &gt; It's frustrating. Programming is an exercise in patience and taxing mental work. It takes resolve and perseverance to follow through and complete a project, especially at a stage where you don't know what you're doing and no one is paying you. A career is a noble goal. You have to demonstrate competency because in a job, if you're not making money, you're losing money. That's all that you need to think about, really. There's no need for JS mastery like becoming Douglas Crawford or a javascript "ninja". That takes years. Focus on what a newcomer can do, like being creative and creating novel things from the tools available. I don't know what that is for you and you just got to have some imagination. &gt; I pretty much don't know which path to take from here. If you want to understand bare bones web development, learn [Express](http://expressjs.com/) and jQuery in addition to what you already know about HTML and CSS. You'll learn a lot about how websites tie everything together. &gt; All the jobs are using React/Angular/Backbone/Ember You can try your hands at those. However, you'll be stuck learning and not actually making because each have their own design patterns that you have to first digest. If you're really insistent, you can easily create some apps using React and webpack. You can hit the ground running that way.
Candidly: If you need to simplify regex, you shouldn't be writing regex. I get the desire to "simplify" it, but pattern matching strings is inherently complex and regex is a beautifully crafted solution that mirrors that complexity.
This is crazy dude. I think some of your ideas are interesting... I like how the update events pub/sub thing is used as a framework construct. Unfortunately it seems impossible to really compose or abstract components (or views or however your not thinking about em). Right? Anyways cool side project pal. EDIT: I guess you can! Probably need better examples on the website. But the OP posted some examples in this thread.
Thanks. Well, a view is a function of the model, therefore you can create a view/function that takes a model or part of a model and exposes the behavior you need as well as conform to a subset of your message API. Then, import that into your application, season lightly with salt and serve hot. 
[removed]
[removed]
That’s exactly what Prettier is trying to do.
I took the example from their documentation and fired a simple XHR call on codepen. XMLHttpRequest cannot load https://en.wikipedia.org/w/api.php?action=query&amp;list=search&amp;srsearch=Albert%20Einstein&amp;format=json. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://s.codepen.io' is therefore not allowed access. Maybe check your console output.
So... don't migrate to it? They're maintaining older versions. The new version is a great improvement, but it's not *that great* to warrant upgrading older apps if nothings broken.
Hiding complexity is not avoiding it!
I'm glad you looked at the history and found out. And, yes, your observation is correct!
Is this production ready?
Honest question, why the need for an ORM? I mean, I can see its purpose as you pretty much always have to convert MySQL into an object structure (unless you're fine with only using multi-dim arrays).
We need to come up with better examples, but is this what you mean? const model = require("./model") const view = require("./view") const update = require("./update") app({ model, view, update })
Awesome! Thank you!
Sure, you're welcome. Try to include the console into your regular workflow.
This isn't the problem, the problem is when you're working in a team. The only important thing is that everyone follows it. Tabs, spaces, semicolons doesn't matter. Consistency does
Ah, right. Here's how you'd do that. const TodoItem = item =&gt; html`&lt;li&gt;{item.text}&lt;/li&gt;` const TodoList = items =&gt; html`&lt;ul&gt;${items.map(item =&gt; TodoItem(item))}&lt;/ul&gt;` Btw, HyperApp exports a Hyperscript-style `h` function, allowing you to use JSX too if you include the [jsx pragma](https://babeljs.io/docs/plugins/transform-react-jsx/). /** @jsx h */ I don't have a live example of this, but it's in the TODO to publish one.
Huh?
I haven't used it for `async` testing myself, (mostly UI components) have you looked there: https://facebook.github.io/jest/docs/tutorial-async.html?
well jquery did this, no?
Absolutely. I didn't even know it was a thing but now I clearly see its importance.
Well, you are in a minority
yea, seen that. just wanted to show what can be the components approach. i'm playing now with hyperapp and will try create todomvc with the component approach.
/u/tunnckoCore Thanks! Until you brought this up, I really hadn't realized HyperApp could be used like that. 
I got https://zealdocs.org/
[could be working](https://medium.com/@joshblack/-f9798f8b992d)
That's why there are so many of them.
document.getElementById("p_img") element.classList.add("mynewclass") simple example: https://jsfiddle.net/qgd6wz20/2/
that my comment was in wrong place and I even before your comment ;d
I still disagree. The team leader should define a standard and use automation to enforce/convert code to that standard. When you, the individual, go to work on code beautify it however you want. If there is automation in place for the team standard then it doesn't matter.
Almost every day, someone comes running here with their explanation pointed release announcement as if we're all excited about this thing as if we have a clue what it is, what it does or have any use for it.
I can't say I understand the point of this. The dev tools shown will show the information on the live code, which is cool. But the raw source code? That seems like it'd only work when everything was hard-coded in the first place, a situation that I've almost never seen. Sure, maybe you'd write 3 * 60 * 60 to get 3 hours worth of seconds, but that *is* the human-readable version of it. Calculating that out doesn't actually provide me useful info. If you use this tool on code that isn't hard-coded, you'll end up with a value in the comment that doesn't have anything to do with reality.
The thing is, the game recieves the save as a string. Therefore, if I click to earn money after loading my save, it just adds a 1 to the end of the string, so it goes from $7 to $71 to $711 and so on.
Better you are at sucking, better you are at js. Life wisdom. 
Concrete skills? Same as any other language I suppose: reasoning, logic, algos, etc And sucking, as previously mentioned. It'd actually really important to be able to grok the weirdities of js sometimes edit: http://eloquentjavascript.net/
@NoddysShardblade you can easily use JSX with Mithril, which will make the html look more like html, but will make writing *dynamic* html cleaner than plain html. Keep in mind that Mithril is for writing single-page-applications, not static html pages. Hope that helps. Cheers.
&gt; probably because strings "quack like an array" Spread and for-of work with any iterable. This includes things like strings and NodeLists.
Reddit bringing new meaning to "You suck at JavaScript"
I think this example is for this: https://reacttraining.com/react-router/examples/custom-link
nope.
[removed]
... is spread op , is comma op My understanding prob was that the ',' caused something I didn't understand - namely: returning the last operand. It just feels like it doesn't actually do anything, this comma, that is. It doesn't seem to operate on anything - how does it cause something to return? (rhetorical question)
downvoted
&gt; Lol noob Hi /u/FairJuliet, please don't do this. Thanks.
Those are functionally equivalent. However, they I don't think they are exactly the same. In your example, I could just do: const cachedProfile = cacheService.Get("someKey"); // cachedProfile is "any" data type. In my case, I can't do that. I think the generic approach expresses the intent pretty clearly. Also, the article isn't about writing a good cache, more about showing a use case for generics that is easy to grasp. I'm updating the blog post to link to this discussion and thanks for making the point.
Oh hey, I know you! You're the one wrote the original JSON-P code. I put you on the credits page since you were the original champion for it http://mithril.js.org/credits.html :)
looks good. Can I ask why you removed http-proxy? 
&gt; as if we have a clue what it is You know, if you had bothered reading the very first sentence on the page, maybe you could have made your contribution to this thread a bit more intelligent. Just sayin'
, is not a comma operator while within an Array literal. Otherwise, `[1,2]` would become `[2]`.
Very interesting. Do you have any examples w/ XHR?
I hadn't removed http-proxy. There is an example usage in server.js for proxy api calls 
I don't think you understand, the comma used here is a delimiter between array elements, the following may help. [ ...'@:', ';~' ] === [ ...['@', ':'], ';~' ] === [ '@', ':', ';~' ] [ ...'@:', ...';~' ] === [ ...['@', ':'], ...[ ';', '~' ] ] === [ '@', ':', ';', '~' ] [ ...'@:;~' ] === [ ...[ '@', ':', ';', '~' ] ] === [ '@', ':', ';', '~' ] This is expected behaviour because, as already discussed, strings act as iterables, ie. they have a length are indexed with ints.
Yes. • [Live](https://hyperapp.gomix.me/fetch) • [Source](https://gomix.com/#!/project/hyperapp) (Look under `examples/fetch/index.js`)
Awesome, thanks!
/u/lhorie The new home page looks fantastic. I'll miss the old [mithril](https://en.wikipedia.org/wiki/Mithril) background a little.
If you have an option for free (non-monetary) rides, that would be fantastic, since then regulations wouldn't apply. It would be a great way for friends and communities to help people who drive cars help their friends and neighbors out. My state has (free) ride share website program, but it's clunky, and mostly only popular with old people. This could be more useful for the younger crowd.
Strictly speaking, telling you what parts of math apply to programming isn't very useful because they are mostly advanced and niche parts of math (e.g. lambda calculus). The thing though, is that you can get pretty far in programming without knowing all the math theory behind it (basically it's the difference between engineering and sciences). With that being said, for generic programming, it's helpful to know boolean logic. If you're specifically working with canvas/games, you'll also need to be strong with geometry and trigonometry.
ESlint does this to a degree : http://eslint.org/docs/rules/#stylistic-issues For other things such as HTML / CSS i use other plugins in my editor (sublime).
But making code "ugly" usually* automatically makes it bad *performance is generally the only excuse for ugly code
ahh ok, thanks for sharing :)
&gt; *performance is generally the only excuse for ugly code And performance being a pretty damn good reason.
Agreed. This saves a few lines and characters, but I'd always go for explicit property assignments to `this`.
Math skills are not required. The computer will do all the math for you. You just have to tell the computer what math you want it to do.
It's there! Maybe it's not super-convinient, but you can type 0 when it's asking for price (it even suggests you to do this). I think I just need to make it easier to use. From which state are you from if I can ask? Do you have a link to this website and program?
I was browsing around *Data Structures and Algorithms with JavaScript*, and stumbled across the dictionary structure, which reminded me of Map from Java. Now I know JS has Map (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), but it's not fully supported, and this was just a fun little project to do. Nothing serious. That said, it's fully tested and has actually made my life a little easier. At any rate, figured I'd toss it out to the community, who knows! PDF: http://cdn.tsq.me/ebook/Data%20Structures%20and%20Algorithms%20with%20JavaScript.pdf
Looks good to me just be careful with nested objects; .assign does not do deep comparison and/or merge.
I'd assume browsers have optimized since then, but at a time, default parameters in ES6 were slower (See: http://www.incaseofstairs.com/2015/06/es6-feature-performance/). Performance aside, the code is readable IMO.
Check out the spread operator console.log(...[1, 2, 3]) // 1 2 3 console.log(...['a', 'b', 'c']) // a b c console.log(...'@:;~') // @ : ; ~ 
Not my point. My point is, the OP makes it sound like we should jump for joy that such a thing has happened but I'm betting 99.9% of everyone has never even heard of it before.
Thanks, where would you suggest look at examples? Just pulling up source code from webpages?
eh, just a holdover from when `class` wasn't a thing. I have a lot of JS patterns from ye olden days.
It is a very expressive exclamation point, loaded with meaning.
Yeah this sounds like something editor specific not something you'd run as an automated tool. For starters most editors have refactor tools to begin with so it should be something like applying regex to that. Furthermore it becomes even easier if you're the one starting the project from scratch, because as long as you get it right the first time and your editor has fuzzy search intellisense / codeintel should pick it up and autocomplete the rest of the time.
Thanks for your advice. I do enjoy programming and learning about it, I'm just frustrated trying to take everything in. Mainly all the stuff I don't know much about yet, like using frameworks and more technical jargon that is uncharted territory for me. I don't have any problem understanding the concepts, except for applying the basics on JavaScript, I learn from source like codecademy, to real situations. There is a lot and I don't know what I should be learning about now that I have the basic concepts down. I wanted to start programming to make video Games and mobile apps, but I recently found I like creating websites. I have played around creating single page sites with HTML and CSS but I haven't added Javascript yet. I'm going to take your advice and learn how to manipulate HTML with JS. 
&gt; but pattern matching strings is inherently complex and regex is a beautifully crafted solution that mirrors that complexity. Perl6 have gone greats length to modanize the regex syntax, see https://docs.perl6.org/language/regexes.html for more.
Very nice work!
Thanks for the downvote. I'll be sure to rethink contributing to this community in the future.
Either provide a reference attribute/id that you can match against the OL or traverse up the DOM tree on button click and delete parent OL.
Damn. I have a front end developer interview next week and half of this is alien to me, I'm brushing up on my HTML5 understanding and JavaScript. I'll pick up on the interview questions and cram hard. 
x-post from /r/webdev, wanted to see how the web community is adopting NPM after all these years.
Really cool. I love how it's not a 'all or nothing' type thing as well - only need to include the components that you need. 
What is it? Yarn alternative? 
Fair enough. In that case I can agree :) Dogmatically clinging to any approach to coding is going to give you subpar results compared to someone who can be flexible in thinking about the correct approach and tools for the job. Edit: although I do think that OO isn't necessary for complexity (I know that's probably not what you were trying to say). I've written OO most of my career but I'm mostly a convert to the church of functional now. I much prefer the separation of state and logic. ... but if everyone around you is writing OO and the codebase is OO then running off and doing a load of amazing functional stuff is going to be wrong, unless you want to be the sole guy supporting you code. 
I wish the look of it wasn't based on Material Design (ugh), but there are some useful UI elements, which is nice.
I'm looking forward to seeing more of this. I intend to use this in a project of mine How does routing work given there are multiple apps? Could I specify something like this? var Todo = (state) =&gt; app({ mode: state, view: { "/todo": (model, msg) =&gt; {} // access todo } }) var TodoItem = app({ view: { "/add": (model, msg) =&gt; {}, // add (/todo/add/) "/:slug/delete": (model, msg) =&gt; {}, // delete (/todo/slug/delete/) "/:slug": (model, msg, params) =&gt; {} // view (/todo/slug/) } }) 
Thanks, I'm drifting between being cool as a cucumber and freaking out. I appreciate the voice of reason
`!!ctx` is the boolean representation of `ctx`. There are times when you want a true/false value rather than dealing with truthy/falsey values in Javascript, and the `!!` trick is how you do this.
I don't know how, but it seems to work now. Thanks for that. I can now save and load the game, and since now I know how to do it I can save other stuff too. Big thanks.
I guess that's a good question. Maybe something more generic (Bootstrap-ish) without some of the quirkiness of Material Design, but leaving open the ability to customize the look with CSS.
wtf is an ARIA role? Is that the crap bootstrap puts in their examples, so you have to remove the excessive markup?
That example is kind of crap because the same thing could be accomplished via: let canvas = document.querySelector('canvas'); let ctx = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); if (!ctx) { console.log('your browser does not support WebGL'); } There's no need for an explicit conversion to a boolean, but I guess they were trying to be extra explicit. Maybe they were assuming that you'd need `isWebGL2` later for something else. 
Could make a huge difference in SEO in few years as semantic and accessibility become more and more important to search engines
it's called 2017 because by the time you finish to read it, it will nearly be 2018. edit: great work thou. I don't know where you find the time to put all that together.
Knowing the JS community half of this will be obsolete within 2 months
As one of a few developers whose sole purpose for a couple of months in 2016 it was to make sure our product was accessible for people: * with low-vision (so high-contrast modes, large fonts, etc) * can only use keyboard input * who are blind (screen reader support) as well as everyone else and doing my research into how to best accommodate/develop for those users, I started to understand the difficulties accessible users go through and I feel like, as developers, we need to be inclusive to all persons that may use our software. So, maybe, don't just blow it off as "crap" and "excessive markup" that you think has no purpose. Expand your horizons and learn about what it is. It can/will help you to become a better developer.
Hey /u/kenman, thanks for that access! I'll see what I can do to help spruce it up.
Thank you for your work. How did you fall into that position?
You should read about hoisting and arrow functions 
!!(x) is the same as Boolean(x), but shorter. It is a widely nderstood shortcut to boolean conversion.
Oh. My manager at the time had suggested that I take on the task for the team. I didn't actually know a lot about accessibility so I agreed to do it and ran with it learning a lot. Not that I know everything there is about it but I do know more than I did.
Developers hate him!
Cool, I'll make note of that.
Code formatting was really busted in your example, I think you need to indent the start of code at 4 spaces. You don't need to use `shim` for any of the modules you're importing, they already work out-of-the-box with RequireJS. Maybe try this? require.config({ paths: { dragula: 'lib/dragula.min', jquery: 'lib/jquery', underscore: 'lib/underscore', backbone: 'lib/backbone-min', 'backbone.localStorage': 'lib/backbone.localStorage', myapp: 'myapp.min' }, deps: ['dragula', 'backbone', 'jquery'] }); require(['myapp', 'dragula'], function(myapp, dragula) { console.log(myapp, dragula); }); 
That looks very interesting, super cool.
As someone who's gotten into JavaScript in the last 6 months and have gotten pretty into react, It sorta feels like this, I understand that you shouldn't be jumping from one framework to the next hottest one but it does feel pretty confusing for someone who's just trying to land some work. Everyday it feels like there's some sort of revolutionary new thing out that's blowing people away. Reading this and only understanding a little bit more than half of what they're even talking about doesn't instill confidence in myself. I now read that react is basically changing into something else just as I believe I have a good understanding of it. Maybe I'm just getting inside of my own head but it's sorta overwhelming.
[removed]
Add the button Delete function immediately after you create it. This should work and tested! buttonDelete.onclick = function (e) { this.parentNode.remove(); };
A verbose way to do it: return { ...state, myArray: [...myArray.slice(idx), variableToInsert, ...myArray.slice(,myArray.length)], }; Via array.splice(), delete: return { ...state, myArray: myArray.splice(idx, 1), } Via array.splice(), insert: return { ...state, myArray: myArray.splice(idx, 0, variableToInsert), } ##[array.splice MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) If `variableToInsert` contains nested objects, you can write a helper function that recursively enumerates over its properties and destructures each node it finds that contains only primitives. All of these fit on one line and a fairly pleasant.
Thanks! I've been tinkering with it a bit and managed to get it down near 2 KB gzipped while fixing a few edge case bugs. 
[removed]
The [Mostly Adequate Guide to Functional Programming](https://github.com/MostlyAdequate/mostly-adequate-guide) is probably the best book you can have for learning functional programming in JavaScript. [JavaScript Allonge](https://leanpub.com/javascriptallongesix/read) is another great book that goes over FP stuff. You can do pretty functional JavaScript with libraries like lodash or ramda. But my recommendation to really understand FP is to learn Haskell. I think its hard to learn with JavaScript because you always have a way out with procedures and objects.
And I'll just continue using plain HTML5, JS, CSS3 and a bit of jQuery. I'll even use the new ES6 features when they're supported in Firefox and Chrome. That just gets things done. There's no need for 90% of the guff the JS community is churning out and changing far too often. Imagine trying to build a stable product on that. Reeks of immature junior developers. The foundation will move out from under you every month. You'd need a dedicated team just to keep track of the framework changes. No thanks. I'd rather have stability.
I feel like we have finally worked through the flurry since IE6 went off the market and that its all going to be pretty boring for the next fifteen years.
I'm a total beginner with React also, but it does seem to me that React's ecosystem and features are a bit more hefty than Vue's. But I think it's only a matter of months before Vue develops to be an actual alternative to React. But it might just be that single file components make too much sense to me :p 
My [React/Redux links list](https://github.com/markerikson/react-redux-links) has a section on [Functional Programming](https://github.com/markerikson/react-redux-links/blob/master/functional-programming.md). I've made a point to list articles that try to explain concepts in easy to understand terms, rather than dense jargon and syntax. Most of the articles are JS-oriented. The section on [Immutable Data](https://github.com/markerikson/react-redux-links/blob/master/immutable-data.md) is relevant as well. The links from /u/marjongimpley are also excellent.
Webpack. Just because it has code-split.
Webpack seems to be the winner lately. Browserify has run its course and I've never heard of rollup.
Not very responsive friendly tho...
[removed]
Yarn relies on npm repository.
Thanks you! This second case is the case I need to do. I have to check all the properties every time. Now I need to go through this carefully to fully understand. I am amazed. UPDATE: ok I asked how to again rewrite this, and now I have this: if (!angular.isUndefined(newVal.radialGaugeDp)) { const props = ['min','max','yellowRangeMin','yellowRangeMax','redRangeMin','redRangeMax']; $scope.dataPoints = _(props) .filter(prop =&gt; newVal.radialGaugeDp[prop]) .reduce(prop =&gt; newVal.radialGaugeDp[prop], {}); } I think this is pretty good. Except it doesn't work. :: D
Ah, you're absolutely right. I did check what `String[Symbol.iterator]` resolves to (`undefined`, of course) and never realised my mistake (the correct form is `String.prototype[Symbol.iterator]`).
I agree on every single word of your comment.
Totally unconstructive comment
him who?
If this is done by front end masters then it's probably really good. Going to give it a read.
I based one of my homebrew projects on [react-diagrams](https://github.com/projectstorm/react-diagrams), which is not a lib per se, but a demo. Still, it is very cool and easy to start with. Before that, I considered [JointJS (the opensource part)](http://www.jointjs.com/opensource), which is a full-blown lib, but didn't like its dependency on JQuery and Backbone.
Its missing aurelia
Thanks for the feedback. I am not sure how the example you posted can be similar because it produces the error "TypeError: Array.prototype.map called on null or undefined" that is actually thrown when the Array.prototype.map function is called with "this" is set to null. It's the same as invoking Array.prototype.map.call(null) In the original example though "ff" is not even called because it's not a function, JS says. These are 2 completely different scenarios from my point of view. Am I missing something?
Nice, but why compose from right to left? 
That was my impression as well. I'm not sure how you can follow the Javascript trends and keep maintainable projects. Sure, 6 months one-man projects are no problem but if you're working on something for a few years and you have to look back at it several years later you'll probably have a lot less fun. The sheer amount of knowledge required to understand even the currently proposed stacks is staggering.
Its missing riotJs as a vue component, mix meteor with angular and react which are all pretty different.. This is content for content
Exactly. And so, following the logic that every JavaScript function call is actually made with .call, you get the following in regards to the original example: Function.prototype.call.call(null); You've set your ff variable to a prototype function, and thus is no longer executing it in its proper context, which is why although it's technically a function, as even .call has the prototypal properties of a function, it reports as not being a function, because the .call method it not called with any this variable, however just like Array, this results in it attempting to access its this and failing, providing you with the TypeError that null in this case is not a function. EDIT: To clarify, the "not a function" does not pertain to .call, but rather, to the null you're passing. 
Any reason to use Slack instead of e.g. Gitter? Slack has the most painful login/signup system I have ever seen. And Gitter, among other advantages, doesn't even ask me to sign again or allows for single-click social signup. 
&gt; To clarify, the "not a function" does not pertain to .call, but rather, to the null you're passing. Actually the example passes argument to ff : ff(5)
&gt; And so, following the logic that every JavaScript function call is actually made with .call That's not true. Every JS function call is actually made with the internal [[Call]] method. 
Your code examples need to be on multiple lines to be readable :)
oh hell nah
Nope, books and articles are welcome!
I misread for a second, bear with me, but then you're doing Function.prototype.call.call(5) Which will still, very obviously, give the error you're seeing
okay, finally got it
Hi /u/php03, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Because compose is supposed to go from right to left, to use compose left to right, you can use pipe. This follows the same standards seen from lodash/fp and ramda.
The OP is asking how to implement promises from scratch, not how to use the already existing API. Why do you wrap one-off parameters in parentheses? It's unnecessary. const isBig = x =&gt; x &gt; 3;
having two separate prod/dev configs isn't such a bad idea as, depending upon how an application's configuration complexity can become, a single file can quickly turn into an unreadable mess. Having worked in both paradigms, I can tell you your mileage may vary :) Another method of splitting logic is via composition, [Electode's webpack configuration](https://github.com/electrode-io/electrode/tree/master/packages/electrode-archetype-react-app-dev/config/webpack/partial) does a pretty good job with it.
Which is why full stack developers make the big bucks, right?
Under "Front-End Interview Questions", there's a link to: **[10 Interview Questions Every JavaScript Developer Should Know](https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95#.9y58i2pht)**. It's not clear if the author is being purposefully biased for dramatic effect, or if he's just blissfully unaware of his blatant hypocrisy while writing things like: &gt; I advise people to hire based on whether or not a developer believes in class inheritance. Why? Because people who love it are obstinately stubborn about it. They will go to their graves clutching to it. ... followed by: &gt; When is classical inheritance an appropriate choice? &gt; &gt; This is a trick question. The answer is never. &gt; &gt; Good to hear: Rarely, almost never, or never. &gt; &gt; Red flags: Any other response. I think that linking to his article, and therefore validating this author's narrow minded *opinions* of what it means to be a valuable JavaScript engineer in 2017, particularly when it comes to using ECMAScript 2015 features, is a great disservice to this handbook.
Yes /u/pomlife, you are right, I am trying to implement from scratch. And thanks /u/hyphnKnight for your answer, you helped me in understanding promises, Thanks!
I'm on it right now, thanks for help! Seems exactly what I am searching for!!
That's a lot of hype for one comment. 
Why are you using a semi-colon? It's unnecessary.
I _know_ the Webpack team welcomes PRs to improve anything.... :)
Eh, Eric Elliott is known for having extremely strong opinions regarding inheritance and FP, but his articles and resources are pretty good overall. I'm not saying that a new learner would be expected to know about Eric's opinions and reverse-filter things to compensate, just that I wouldn't throw out all of his info as a response. There's still plenty of value in his material.
Please let me know if you'd like to see other countries listed!
I don't use Webpack, so sorry but no PRs for me. GL though!
How would it know the structure of your REST API to make calls to? This would generally be done with a test framework in order to unit test the API.
Dam it, I thought it was the board game...
You can advance a library and not break the API every semver. jQuery, underscore, React.... 
Which is why you read the [migration guide](https://webpack.js.org/guides/migrating/#uglifyjsplugin-sourcemap) from v1 to v2.
Differences from Webpack 1 are covered quite thoroughly in the migration guide, including this one: https://webpack.js.org/guides/migrating/#uglifyjsplugin-sourcemap
So, why not just use something properly tested like co? If your intent was to show how async/await works, you could have just linked to the spec: http://tc39.github.io/ecmascript-asyncawait/#desugaring
I wouldn't say better or worse but different. As /u/gearvOsh mentioned, `for-in` will iterate over enumerable properties in the prototype chain.
"has run its course"?
Right, but for that purpose you might be setting people up for failure by not linking or showing a more robust async function. (like the one in the spec) edit: I see that you linked to the spec, but the desugaring function is all the way at the bottom of it
Thank you reddit community for always challenging webpack and the status quo for build tools. If you guys have any concerns of questions, never hesitate to reach out. ~@TheLarkInn on twitter and github.
Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
I tend to avoid for-in, because for-of is really common in ES6, and it's really easy to get them confused. We actually have a lint rule preventing for-in. 
It is easy to get them backwards and it necessitates a lot of trips to MDN. 
I actually find the opposite is true more times than not, calling for a .bind(this) to make the loop work as expected... 
Also, you shouldn't worry about performance unless you notice the drop. Compiler makes a lot of undercover work for you.
no ... should work in any modern browser
It supports a more functional way of programming, as Object.keys returns an array and enables you to use map, reduce, filter etc.
You are totally right, my bad! Cheers.
This gets brought up a lot, but I feel like most of the times I need to iterate over an object, it's basically some sort of hash table that I have full control over, and I know it's not doing any inheritance. 
Perhaps it's worth pointing out that you can easily `break` out of a for-in loop, which you can't do using the array functions.
Ah, great! You have hidden that quite well though, I never saw it. Cheers!
I like your analogy. Learning as you go and figure out one problem at a time. Thank you for the motivation. I've heard it's better learning with out frameworks as well. 
hi thanks for your help, but when I get rid of the shim I get a bunch of errors like: ReferenceError: jQuery is not defined ReferenceError: Backbone is not defined
habit from using type signatures. const isBig = x: number =&gt; x &gt; 3; // Broken const isBig = ( x: number ) =&gt; x &gt; 3;
Fun fact: second argument to `.map`, `.forEach`, `.filter` is `this` context, so you don't have to `.bind`. Anyway, you probably want to use arrow functions.
We'll make a hacker out of you yet
I disagree with the premise that lodash's `pluck` is somehow more intuitive or semantic to human readers. Anyone who finds him/herself maintaining that JS code is going to know at a glance exactly what that for loop does. But not every maintainer is going to know every method of every lodash-like library. That maintainer either has to guess or assume the details of 'pluck', or waste time going to the lodash docs to check for gotchas. I know that it's a simple example, and that something like `_.map` _is_ be intuitive, but it seems like code clarity should mean 'clear to people who know js', not 'mimics english for the sake of those who don't know much about js'. I do agree that simplicity takes hard, thoughtful work. Random thought: I think it would've been worth mentioning how important variable and function naming are to increasing code clarity for your future self. 
Wow, I agree with all of his points but the tone of that article is so awful. I hate that he calls the wrong/incomplete responses "Red Flags", as if they were some kind of personality trait and not something that can be learned.
Well this issue keeps going back to the days of downloading "Game of Life" off the BBS's back in the 80's and being disappointed each time. =P
Can't take this seriously with all the emojis man.
If a dependency is adding properties to the Object prototype, I think I have bigger problems than enumeration.
I tried that and I still get an error. The full function is `knex.schema.map(messages, function (message) {...});`
Thank you all for the hard work! The new website and documentation alone, you've really come through. Without Webpack i feel like i wouldn't enjoy Javascript as much as i do. 
Nah, web is not that well paid
It's quite different :) This gist includes an `async` function which takes a generator function as argument and allows code to yield Promises from it to emulate the synchronous control flow. ES2017's native async/await is syntax sugar on top of the same logic. As the author notes in the gist this `async` function is similar to co, task.js and a few other libraries. The gist is very well documented (hats off to the author!) and the _Background reading_ has some really good links. Async generators are one level up on the ladder of abstraction. They will allow to create asynchronous iterables where the stop-iteration condition isn't known synchronously. Suppose you have an API which returns paginated results, 20 items per page together with a `has_more` flag. It takes `offset` as an argument. With async generators you will be able to write: async function* all_items() { let offset = 0; do { var [items, has_more] = await call_api(offset); yield items; offset += 20; } while (has_more); } for await (const items of all_items()) { console.log(items); } It's currently not possible to write this in JS in a similar fashion. Currently it is only possible to build a generator which returns Promises. Such a generator wouldn't know when to stop the iteration depending on the value of `has_more` which is requested asynchronously. It would return `{ value: Promise, done: bool }` objects (which are used by for-of loops), and we don't know if we're done before the `value` Promise resolves.
Two things are possible then. 1) You're on old versions of these dependencies 2) You are trying to doing something incorrectly in your myapp source code. Add shims back in for the deps that don't work. But don't go overboard with it, it's an escape hatch for simple code, not meant to specify dependencies for your application.
If what is true? That `import {PropTypes} from 'react'` will break?
Imports are inferior to the power of require()
But they are not statically analyzable, that is a disadvantage.
Do you mean Node/Webpack, the general ecosystem or the language specification? 
Hi /u/yudoit, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Webpack and rollup, depends on project needs
`vm.runInNewContext()` is very expensive just in case anyone was considering using this in production.
Practice shows otherwise. Dozens of popular tools can do an acceptable job parsing a module graph out of `require()` calls.
As far as I'm concerned this is all personal preference as long as you use tab characters (which is coincidentally the only argument I have for tabs &gt; spaces). And as /u/cjbprime said, a lot of people like 2 space tabs because of the proclivity for javascript code to produce heavily nested blocks (callback hell). With the arrival of async/await this may be alleviated a bit, but there might not be much of a problem to alleviate IMO. Just use tab characters and change it at will.
Fake news.
https://github.com/airbnb/babel-plugin-dynamic-import-webpack/pull/14#issuecomment-275159815 not what those guys are sayin!
It's the only way to ensure your code looks the same everywhere — i.e. in the editor, on Github, in the inspector, etc... — since some visualization tools interpret 4 spaces as a tab.
You can't always set the tab size in Github and other places where teams put code.
Sorry man, I've been watching too much Fox News the past couple of weeks 🤗. I know there's been some complaints levied against the new release. I waited and switched over at the end of the RC phase and have had an experience I wouldn't describe as "broken", so that's what mostly I was speaking towards. Sorry for coming across harsh!
Should this be inside robots.txt? Won't they just ignore robots.txt?
It's not pointless to learn the pros and cons of tabs vs. spaces, it's a perfectly valid question for a programmer to want to understand. Sure, there are tools to enforce style; but what if you're the one creating the config in the first place? How do you make an informed decision?
The author also wrote an interesting article about why Bucklescript: http://blog.overminddl1.com/posts/why-use-bucklescript/
If it's so hard how did Typescript pull it off?
Add query string param "?ts=2" where 2 is tab length. 
With` styled-components`. [this progress arc component is a pretty good example](https://github.com/szastupov/progress-arc-component)
Here is how you change it in github for the default. https://taylorhakes.com/posts/Github-Tab-Formatting/
&gt; Anyway, I suggested to him using ReactJS for the pages because I thought that their bots/crawlers wouldn't be able to handle them. Funny enough, it worked, a week and a half passed and none of his pages have been copied. Yes but now you've also sacrificed SEO, Bing for example doesnt execute JS before it indexes. &gt; TL;DR: Is there a way to block bad crawlers? Is there a script to send fake information to crawlers? Thanks! You shouldnt be aiming to stop them (because there is no surefire way) just make it as tedious / difficult as possible and this starts with logging to try and identify the offender. If they're careless it'll be a pattern i.e. same useragent from the same IP at frequently consistent intervals. There are a few things you can do. 1 - Eliminate all usages of CSS id's in regards to your main content blocks on pages, on top of it being bad for specificity it's the easiest thing ever to create rules / parsers based on them. 2 - Assuming you do the above then just nest your content in a random amount of empty containers to make it more difficult for them to do something based on counting elements / nth-child. If you do this (either manually or dynamically via server-side) frequently, in theory the only way they'll be able to scrape the info is by manually visiting / copy pasting the content and you can take other measures against that. If you're really evil and discover a pattern behind the bots, set your robots.txt to disallow all search engine indexing to a specific URL (which the offenders scraper will ignore) and just throw a bunch of beastiality porn or something up there for an hour or two and hide an internal link to it. Assuming everythings automated on their end the parser will go and explore all links and auto-generate pages based on your content. At which point you take it down and submit a complaint to their hosting provider (because most hosts have restrictions on such things within their TOS).
No, I doubt it. I feel at the time a version of NodeJs comes out which breaks this import syntax, web-pack will probably update a fix for transpiling it. Webpack does more than just commonJS style imports, its often core to the whole development flow of a project. I've used browserify and webpack 2 on large React projects. Theres no comparison, webpack is easier on developers.
If you can't remember the difference between for in and for of after 3 trips to MDN you may want to see a doctor about your developing Alzheimers...
Two spaces is the minimum sufficient spacing for me to instantly recognize that there's a new scope in play. Combine them with the visual guide lines that are now common in text editors and IDEs, and I have a lot of real estate on my widescreen monitors to view multiple files on the same monitor, freeing up the second and third for a variety of applications.
First of all, for of Object.keys addresses the problem with for in. Besides, having actual loop control like break and continue is much clearer than map/return/filter imo. I wish we had comprehension syntax like python, the anon func inside a map is an eyesore.
I like using 4 space for this reason, it discourages nesting. I think a lot of the deeply nested callback hell code is vomit inducing, so reducing the spaces to fit more levels in seems like a counterproductive idea.
O god, tabs vs spaces, where's my pitchfork???
As far as I understand, they didn't. (disclaimer: i don't use TS, so i might be off) My understanding is that TypeScript code is in for a breaking change along with babel and webpack 2/rollup/etc users once node ships modules.
Perhaps I'm misunderstanding what node is doing... Are they trying to take everything out and put it on NPM? Typescript allows me to import normal npm modules with import * as _ from 'lodash'; or import * as x from 'somepackage'; I can even just do x = require('somepackage') and it still works.
I generally agree that tabs are better than spaces for indentation. But the problem with different developers changing their size from 4 to 2 is that it affects the line length. So if a project's coding style mandates lines no longer than 80 or 100 characters, different developers will count them differently.
Seems like there's an "easy" fix here - If the react guys add an `es` directory with es exports, so one would be able to do: `import React, {PropTypes} from 'react/es'` This is similar to how react-router, does it, they have an `es` directory you can import from to get static imports. Granted react-router is a considerably smaller code-base.... and of course, react would need to update theirs to use import/export syntax over require... a cursory glance reveals most of it still uses require and module.exports Still, it seems this is the way of the future. To throw away all of webpack 2 seems silly -- we're in a weird transitional period from cjs to import syntax... there's bound to be some growing pains where open source projects haven't updated from cjs yet.
### What each term refers to More often than not, when JavaScript folks say classical inheritance, they mean Java or C++ style inheritance, where a class is something that exists only at compile-time, and inheritance happens statically at compile-time. And when they say prototypal inheritance, they mean JavaScript's implementation where one object can delegate property accesses to another object via a pointer/reference, and that second object itself can delegate to yet another object, on and on across a "chain" of objects. ### An example of each In C++, we might write: class A { char x = 'x'; }; class B : public A { char y = 'y'; }; class C : public B { char z = 'z'; }; C instance; At compile-time, before the program runs, the accumulated members of A and B and C are combined and flattened, such that "instance" is a single, flat, 3-byte block of memory (1 byte per character). The classes themselves have no runtime presence and consume no memory at all. When we write `instance.y`, that's translated at compile-time to the address of the "instance" object plus an offset of 1 byte. In JavaScript, on the other hand, we might write: A = { x: 'x' }; B = Object.create(A, {y: {value: 'y'}}); C = Object.create(B, {z: {value: 'z'}}); instance = Object.create(C); At runtime, as our program is running, we'll make an object A, then make an object B with a delegation pointer (the [[Prototype]] link) pointing to A, then make an object C with a delegation pointer to B, and finally make an instance with a delegation pointer to C. The values "x", "y", and "z" are spread across three different objects. When we write `instance.y`, then the JavaScript engine checks if a key with the name "y" exists on the "instance" object, discovers that it doesn't, and so follows the [[Prototype]] link to object "C", where it again checks if a key with the name "y" exists, discovers that it doesn't, so follows the link to object "B", where it again checks if a key with the name "y" exists, sees that it *does* exist there, and returns its value. ### Differences (with code!) of the varying styles, that will yield different results when executed In JavaScript, since everything is created and looked up at runtime, that means we can change, on the fly, what an object inherits. instance = Object.create(C); instance.hello; // undefined A.hello = 'hello'; instance.hello; // "hello" We used to take advantage of this trick a lot, back in the days of libraries like Mootools, when we would add new features to the built-in Object or Array. But we learned the hard way that this is actually a bad idea. Today we derogatorily call it monkey patching and consider it a bad practice. Though, when we choose to restrain ourselves in that way, then I'm not sure there's any advantages left. ### Ill-defined definitions Though, the answers to "what is a class" and "what is classical inheritance" is somewhat debatable, since not all languages implement classes and inheritance the same way that Java or C++ do. We don't debate that Python and Ruby, for example, have classes and classical inheritance, yet it turns out their implementation is strikingly similar to JavaScript. In Python and Ruby, a class is itself a runtime object (a building, not a blueprint), and inheritance happens at runtime by following delegation pointers across a chain of objects... just like in JavaScript. Though, in Python and Ruby, that "prototype chain" machinery is largely hidden. We could easily use Python classes even if we didn't know how they worked under the hood. But until recently, JavaScript hardly hid its machinery at all. We considered it essential for JavaScript programmers to know the details of the prototype chain, because each of us were responsible for getting all the pieces linked together in the right way. I think ES6 classes change that. Now, like in Python, we can easily use classes without caring so much about how they work under the hood.
You sound like you're talking out of your Trump.
It's 'broken' in that it doesn't yet do tree-shaking properly in all circumstances, and tree-shaken builds can actually be larger than non-tree shook builds. For me, I've just stopped trying to tree-shake via Uglfiy, and use rollup.
&gt; it's good to exercise "self defense" in your code in case any other JS code on the page is polyfilling or otherwise altering the prototypes of Object, Array, and so on I strongly disagree. If a native prototype is modified, then that's a bug in the code that modifies it. Fixing bugs by patching their every effect is (a) error-prone - you're going to miss a case, (b) slow - multitudes of little penalties add up, and (c) an exponential amount of work and code. Fix the bug where it's written. The only exception I can see is if you work in some hell-spawned environment where your boss actually mandates that certain bugs remain.
Thanks!
I dropped support for IE 10 last year. I still support 11 though, but that is like 15% and dropping. With 8, 9 and 10 making up a combined less than 1% of my traffic, it was a no-brainer. Also people can download chrome or firefox if needed.
https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9
The ruby convention is 2 spaces and also a common default for sass. If you're noticing 2 space indentation in JS, I feel its probably from sass/scss influence.
Since your function relies on an asynchronous action your function needs to be asynchronous itself. Most basically, something like function createPlayer(width, height, onload){ // ... image.onload = () =&gt; onload(new Player(image)); } createPlayer(10, 10, startGame); but more realistically you'll want to return a promise or something. In the code you posted, the `return` is only returning from the arrow function you've assigned to `image.onload`.
Right, but Typescript's interop there isn't compatible with what babel (and thus most of the ecosystem) is already doing, nor with what node will eventually be doing. If you use `require()`, as with everything else, you're always going to be just fine.
I don't use Typescript either, but they must be doing something similar to Babel or Webpack: They are ignoring the requirement that ES6 module exports must be statically analyzable. Instead, they are simply converting them to require calls with some fancy wrappers (Babel) that normalize the differences in syntax (e.g. `default`). So your imports are working because they're not really imports. TS is treating them like fancy `require` calls. It's just syntactic sugar for CJS, not true ES6 modules. Why am I so sure? Because ES6 modules *must* be statically analyzable, and Babel, TypeScript, and Webpack can all `import` CJS, which is not guaranteed to be statically analyzable. So unless there's something really magical going on, TS will break. And I doubt there's anything magical because Babel and Webpack would use this magic, too, and I'm familiar enough with their code to know that they are not.
This is true but it's not like it's THAT different to have `import` vs `require` syntax from an authoring perspective. Also, if you do weird shit with `require()` I think it's reasonable to expect that maybe that won't work everywhere. Anyways, browserify will support whatever node decides to do to some degree.
ah ah brilliant
I'm not sure if I totally got your point, but your analogy was amusing :)
It's a sad state when we can't drop support for a browser when the company themselves no longer support or maintain it.
Absolutely, it is indeed the "minimum" hourly rate as well. Minimum sounds a bit pessimistic and "best" sounds too optimistic. I'll try to find something in between :) You are again right regarding the pocket money(which I was thinking of renaming to "savings"), it's monthly and it's not specified anywhere. Unfortunately the tool [workly] didn't seem to raise much interest(I posted on a few places), probably due to too much info and non-intuituve UI/UX :S I appreciate your feedback, thanks. 
I see the word "never" in the post title, but I don't see the word "never" in that guy's post. Unneeded click-baity title :/
less typing + less bytes &gt; visual gains? I honestly am slowly preferring tabs to allow each user to define how big they want their spacing to be. Because why not?
Not clickbait, you're just late to the party and reddit doesn't allow editing of titles. https://www.reddit.com/r/javascript/comments/5rikrz/why_airbnb_will_never_use_webpack_2/dd7s7en/
https://support.microsoft.com/en-us/help/17454/lifecycle-support-policy-faq-internet-explorer Yup, at least for now no information on EOL on that. Yes, Internet Explorer 11 is the last major version of Internet Explorer. Internet Explorer 11 will continue receiving security updates and technical support for the support lifecycle of the version of Windows on which it is installed. Anything older than 11 is essentially unsupported (not taking into account server versions of windows here).
You can use .editorconfig file. &gt;When you have a .editorconfig in your repository it will respect it when viewing code on GitHub. &gt;indent_style = tab and indent_size = 4 shows tabs with 4 columns instead of 8 https://github.com/isaacs/github/issues/170#issuecomment-150489692 
Thanks, didn't see this. I stand corrected.
Install the Stylish extension, set * { tab-size: 4; }
It's not less typing since you should only press tab key and your editor will insert the required number of spaces. Less bytes is also irrelevant since code on the web is usually minified. Even when it isn't, the difference after gzip is near zero. 
Hello, would you elaborate more on this sample: ``` function readFile(filename) { asyncReadFile(filename, function (error, result) { if (err) { return Promise.reject(error); } return Promise.resolve(result); }); } ``` Is the purpose of `readFile()` to return a promise and if that is the case then how is that accomplished without a `return`?
"isomorphic nut sack" is the best thing I've read thus far this year.
It's true, you can't polish a turd (which is probably the reason for Edge), but my point still stands that you shouldn't drop support for a browser that is still being maintained and is used by &gt; 10% of users just because it's shit.
calm down beryl
I didn't know there was any opposition to Webpack 2, the title was a direct quote from the thread before he edited his post. I don't know what qualifies as actual reason to you. I am not angry, but why do you care about that? Proof: [ljharb talking about editing the post](https://www.reddit.com/r/javascript/comments/5rikrz/why_airbnb_will_never_use_webpack_2/dd7s7en/)
Nice explanantion. Just a reminder: default access for class types are private in C++.
Probably because they still get a significant portion of their traffic from IE9 users. My company also supports IE9 and it was a major battle to drop support for IE6, 7, 8. (Really big money companies have really slow and REALLY crappy IT who dictate things like "everyone uses IE6"... I wish I was joking). If &gt; 5% of your users are on IE9, then it makes sense that you support IE9. After MS did the "no more security updates for IE8" thing, for over a year we still had something like 20% of our users with IE &lt;= 8... We basically had to say "fuck it" and used google as our waterline "Google dropped support for IE8, so what can you do with IE8? nothing. So we are dropping support". IE9 has been "good enough" for now that we haven't been looking at dropping support for it.
Tab isn't going to help you here either, as it will move to the next field. If it annoys you that much then get Reddit Enhancement Suite, it adds a code button to the editor. 
I want to think a large part of it is related to creating web-friendly code. A smaller indention makes it more compact and easier to display within a smaller area. Plus tab-size in browsers tends to default at 8 which is massively indented. Using 2 spaces addresses this. I used to be a tab (4) guy all the way. But standards where I work have largely moved to 2 spaces, so by habit, that's where I am now. I find it harder to read, and navigating through spaces has its problems, but sticking to the existing code standards is more important than my own preferences.
&gt; will never use webpack 2 &gt; will likely not use webpack 2 This is not the same thing. Module loading is abstracted away from the end user, anyway. By the time node conforms, I'm sure webpack will have an option to disable, the same way you can do so in babel right now. 
The comment was edited, you can even see that on Github beside the timestamp... Proof: https://www.reddit.com/r/javascript/comments/5rikrz/why_airbnb_will_never_use_webpack_2/dd7s7en/
But, don't you have source mapping enabled? That let's you drop break points in the code you actually wrote. I struggle to see how people struggle with this. The only thing I have issues with is debugging in Node. The browser is not a problem here. 
A bit late to the party, but it's interesting reading the responses. I used to use an indentation level of 4, but switched to 2 mainly because I felt it required slightly too big a jump in eye movement, and it was catching me out; like waking up a flight of stairs where the height of each stair is that tiny bit too high. To hear that code amasses into one block if your indentation level is too low, I can definitely agree with. I tend to space out my code by introducing empty lines around block-level constructs, and after defining my variables. In many respects, it's like the same with paragraphs in written text: some people use indentation to help tell them apart, while others will use no indentation but introduce vertical whitespace. Each to his own.
I agree and said nothing to the contrary.
You mean, like, the libraries that are written in JavaScript? How is abstracting code into modules, and not re-inventing the wheel not writing JavaScript? Your first comment makes it seem like redditors don't know how JavaScript works. Your second one makes redditors sound like JavaScript purists. 
Thanks for pointing that out, I have updated examples. Thanks again!
Derp, thanks!
https://www.jwz.org/doc/tabs-vs-spaces.html
I have come across https://github.com/saff1989/Quackjs, it does not track ids but could be near enough? Quack
For the most part, web development is a business. People don't necessarily need somebody who knows how everything about a language, they need people who understand the technology their sites are built on and who will create value in the form of workable web apps. Why are you so salty? 
OP deceives by not adding their Java yawp requirement.
Yeah if you do things for general audience you can ignore anything older than IE11. I know that when media agences get asked to support older stuff than IE11 then often inform that they will charge more, that helps :-)
Thanks very much for your reply. Sorry, I've only had time to test this now. When I inserted your code, the page returned a console error of: Uncaught ReferenceError: element is not defined at test.js:6 Thoughts? Here is the [page in-question](http://kabultec.org/dev/blog/womens-rights/mar-sept-2003-report/).
Maybe it's not the right workplace for you then 
In the case of an error, you will invoke both `reject` and `resolve` in the callback to `asyncReadFile`. function readFile(filename) { return new Promise(function (resolve, reject) { asyncReadFile(filename, function (error, result) { if (err) { reject(error); // reject is invoked on error } resolve(result); // and resolve also, since execution falls through }); }); } This is harmless, since a promise can only change state once, but it's still bad form imo. Add `return` before `reject` (and `resolve` for symmetry) or add an `else` branch around the `resolve`.
Thanks very much for your reply. Sorry, I've only had time to test this now. When I inserted your code, the page returned a console error of: test.js?ver=4.7.2:3 Uncaught TypeError: Cannot read property parentNode' of null at test.js?ver=4.7.2:3 Thoughts? Here is the [page in-question](http://kabultec.org/dev/blog/womens-rights/mar-sept-2003-report/). Other parts of the same JS script are firing. Specifically, I wrote a test message to the screen with: document.write("OK"); and this message prints to the screen as expected. A similar line of code *after* your suggested code does not print.
Best intro to Promises I've read
One reason (an opinion of course) that was pointed out to me is that if you use tabs you now have 2 different types of white space in your document and unless your editor shows whitespace characters it can get confusing. 
Yeah, you're right. Just didn't want to make things complicated 🙂
Damn, I knew I should have stuck with IE5 (or 5.5) but I thought they had upgraded to IE6. Took a chance.
You also wouldn't have a field empty, you would have a method on the mug checking to see if the liquid level was below an acceptable level needsRefill(). Also, you would have human who would have a method drink which would take the mug.
&gt; ...it's very similar and some call it multiple inheritance but composition... It's usually me saying that. ;-) https://www.reddit.com/r/programming/comments/5dxq6i/composition_over_inheritance/da8bplv/
Sorry that you're having this experience using webpack so far. I spent the weekend with the Chome team, and the top three items we addressed, handling sourcemaps and ensuring they work is one of them. So, any feedback or details on your problems with them in our github is greatly appreciated. 
Hi /u/marcosmartini, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Well I understand what this version is. Makes for pretty blinking lights.
So you have to have a workaround for Github. And one for Gitlab. And one for the Firefox console. And one for the Chrome console. And... Or you could just use spaces and forget all this madness.
It existed well before SASS
Since nothing has a reference to that promise, I believe it will be garbage collected. 
Saved
If you're going to be pedantic about written language, then what you said isn't correct either (in terms of intent). The implication is completely different. You are confounding mastery of a language with nativity - one isn't a mandate for the other. &gt; ~~I can tell you're not Native English. I have some edits ;)~~ &gt; I can tell English is not your first language. &gt; I can tell English is not your mother tongue. &gt; I can tell you're not a native speaker of English. Because lots of non-English folks can write and speak perfectly good English and would go unnoticed if scrutinized for ethnicity. That aside, great suggestions nonetheless. 👍
One of the worst features of ES6, by far. Makes for an unreadable mess of over-abstraction.
Thank you!
Wow this is really interesting... I must say, being unfamiliar with Apple's Auto Layout system, I find the syntax a little strange at first glance, but I am excited to try it.
I love you. Sidenote (rage rant): That when you google "prototypal inheritance vs class inheritance javascript" the first THREE results are by this schmohawk Eric Elliot who manages to say nothing across various blog posts (in a condescending tone - ["If you can’t answer this question, you’re a junior developer. I don’t care how long you’ve been coding."](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.mufn8cqyp) ), in a thinly veiled attempt at self promotion.
Debugging with sourcemaps is essentially useless. Between variable names getting lost (Babel recently did work to enable this, as sourcemaps actually can do it, but i don't think webpack push it through....I could be wrong), semantics drastically changing (eg: generators), and minor bugs in browsers and devtools, it's hell for anything but the most basic of debugging scenario (and while debugging an issue, wondering if the sourcemaps are okay or if its your bug, is counterproductive). in webpack, the only useful devtool mode is "eval" (show the transpiled source, but splits it in the original "file structure").
Intuitively, there should be no difference between calling `then` once and calling `then` zero times since you can call `then` on a Promise an arbitrary number of times. The JavaScript engine doesn't "know" if `then` will ever be called; it only needs to keep it around while there are still references to it.
Yeah, true that, so in this case I'd prefer if 2 spaces were used to denote code or at least use the back ticks like in markdown. Even then, when they force the tab to go to the next field, I would still prefer spacing twice rather than 4 times for the sake of speed. In the editor, I prefer using tabs for convenience of each user's preference. They can make the tab spaced out for 2 or 4 or 10 spaces if they wish.
i did send you an jsfiddle example, you did not define a variable namend element yet(chose a better name than element anyway please), you need to define a variable: var myelementname and set it to your ID you want to target var myelementname = document.getElementById(myidname); //now you can target it with myelementname.anyfunction() than you can call functions you like on your new var named myelementname like: myelementname.classList.toggle("any_css_classname"); if you feel the need you can skip to define the var and write in one line: document.getElementById("image").classList.toggle("myclass");
Official support is, as always, utterly irrelevant. We need to support "things users use", and users don't know or care about official support policies.
You can use canvas element to get a screen shot, but only the things that are on the canvas itself. Another approach, which is pretty clicky but not as hard as the phantom route, is to let them use some kind of screen capture function (like windows 10 standard Snipping Tool). From there, they can paste the image into your app and you can do further processing with that. There may be other clever approaches.
Right. No doubt it does. As does Babel, and Webpack. All of the above problems still exist because `require` is not statically analyzable. So all of these systems are gonna have problems when node switches over, for the reasons above.
That's on GitHub, setting tab width is a single line of css.
OK sorry, I see the jfiddle has the full code. My script now looks like: function myFnc() { var element = document.getElementById("image"); element.classList.toggle("with-img"); console.log("click"); } myFnc() But this is giving a console error of: Uncaught TypeError: Cannot read property 'classList' of null There seems to be an issue with defining my element with *document.getElementById("image")*. I'm certainly having trouble understanding that function--specifically, how do you know what parameter to insert into this function? The function name leads me to believe that I need to insert the name of an ID selector for a particular HTML element. If that is true, my issue is that the particular element I want to target does not have an ID assigned. In fact, the motivation for this exercise is because the element in-question has no class or ID, so I cannot target it with CSS. Thanks! edit: Looking back to your jfiddle, I do indeed see that the element in-question already has an ID applied. That's not the case for me. 
google
https://github.com/electrode-io/electrode/tree/master/samples/universal-react-node#progressive-web-app-pwa-features-supported-by-the-electrode-framework It explains how you can use it with the `Electrode` framework, but you can get a good idea about PWA. With the electrode framework, its really easy to build PWAs. 
http://www.electrode.io/docs/service_workers.html
1. agreed not fundamentally needed yet 2. make the x/y/z values for a vector inputs ( no need to create floats to connect to them one-by-one when they are constant values ) 3. not sure what you mean by not needed as nothing is needed 4. not sure if that's actually that much work. I've built tons of these things and a dirt simple transform: scale(scaleFactor) works very well for simple zooming of whole regions. 
In Node.js buffer is a data type, an array of fixed length containing binary segments of a certain signature. This data type is an abstraction of the data type Uint8Array from the JavaScript language. * https://nodejs.org/api/buffer.html * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array 
1. - 2. ah yeah, like uiFloat, but uiVec3, right? 3. haha yes, but nothing in the system uses vec2 or mat4, so there would be nothing to use them on...? I tried to keep the "contact surface" as small as possible by design, I think it's easier to use if there are only two types, ideally I would have only one if possible, then anything can connect to anything 4. yeah, scale works, but then to connect things I would have to do more calculations, but if you want to tackle that, then repo is here: https://github.com/szymonkaliski/SDF-UI :) What kind of things have you built like that? Curious :)
You had me at "isomorphic nut sack" 
This is a great article. I was wondering how to accomplish what Promise.all and Promise.race do for us. Thank you.
That doesn't solve the endless churn and ton of upgrading and testing every month at all.
A fun issue that I discovered is that sometimes the sourcemaps are out by one line... so infuriating. I haven't yet identified what circumstances lead to this (because I have a lot of work to do) so for the last week I've just been dealing with it. When they work it's great though
Same kind of thing. Its an in-memory cache. Just like a video buffer caches video frames downloaded from the video source and holds them in memory until they're needed for rendering, an array buffer may be used to cache the contents of a file on disk allowing you to quickly make edits to it without disk I/O overhead.
The crazy thing about promises is how insanely verbose it is... async/await can't come soon enough. readFile('some_file.txt') .then(function(result) { return getFirstParagraph(result); }) .then(function(result) { return getFirstSentence(result); }) .then(function(result) { console.log(result); }); Really, all of that is to do this: var result = readFile('some_file.txt'); result = getFirstParagraph(result); result = getFirstSentence(result); console.log(result); Promises literally double the lines of code needed, create 8 extra variables in memory (the Promise returned in each step, plus the functions and params), mess with normal formatting (it's all one 'line' of code chained together) and all to prevent callback hell. From experience having to catch errors in each step, this can get even more crazy easily. Promises are nice, but they definitely have issues.
Isn't object.keys rather slow by itself because it basically has to ‘reduce’ object keys to an array?
Thanks for not understanding me. Why don't you try typing code in this comment?
not sure why you can't just use the plugin you linked? looking at the example you can take your results variable and do whatever you need to it client side?
I agree! Being able to inform old browser users that they need a new browser, however, requires *supporting* that old browser :-)
I swore I had read that before somewhere, but must have been mistaken. Oh well. Still hoping for a null safe traversal operator. Looks like it's only in stage 1 currently.
same here(chrome and chrome canary)
I've been using Mithril.js on multiple projects both personal and professional. I'll vouch for its ease of use and reliability.
You say it as if it's a checkbox to check somewhere. It's not. Sure, having source maps in dev mode is usually basic in pretty much all bundlers/setups, but I often find getting sourcemaps to production, where it counts, is less trivial. The multitude of ways of processing the files, especially for production, usually leaves me with broken source maps, or whatever. 
Node and jquery are so so different. You'll struggle to write server-side code without node. VanillaJS is a joke. People wouldn't even think of using C++ without stdlib. It just so happens that we crowd source our standard libraries. 
As someone who was looking at rewriting a bunch of old React mixins to make them more type-safe, the "Improved support for mixins and composable classes" feature is a big win. My love for TypeScript intensifies.
I used Mithril.js on a project however there where some issues with code manageability on large projects and we ultimately switched to React. It is an amazing library that I would highly recommend for small to medium sized apps. There are a lot of cool new features that I like about the new version. It looks like it now has better support for JSX. Once it gets more stable I look forward to using it on possibly large projects. 
Thanks, by memory you mean actual RAM?
Cryptography is not significantly expensive (for this).
That completely depends on what hashing function you use to **sign** your resource/document ID. For example, here's a very simple implementation: secretKey = "too many secrets" docId = "1" signature = sha1(concat(docId, secretKey)) And the URL would look like this: http://example.com/?docId=1&amp;signature=1c8588078064318fcfdf09537174b242bd794952 As long as "signature" in the URL matches what you calculate internally, then the URL is likely authentic. In this case, concatenating the document ID with a secret key and hashing them with SHA-1 is very inexpensive because the x86 Instruction Set has hardware acceleration for performing SHA-1.
I don't think he's being pedantic, he simply wants to help the author frame these words in a colloquial fashion so it will "feel right" to most US/UK/AU/CA English speakers.
I guess if you don't need to worry about which variable actually is the one you think it is, and breakpoint positions don't really matter to you, they're useful. I'll stick to Eval sourcemaps.
 const colleagues = employees.filter((employee) =&gt; {return employee.name != "Jane Smith";}); ?
async/await will still create the promises and stuff. Though even then, you could use arrow function one lines to clean this up a bit. eg: .then(result =&gt; getFirstParagraph(result)) Still, some sugar over it is nice, but it doesn't change much to whats under the hood...async flow is async flow at the end of the day. Even after async/await, I'd take the verbosity so I can use observables instead of promises (observables wouldn't work with async/await) any day.
Yes. Though I guess technically it doesn't _have_ to be. Generally, though, that's the idea. But really, anything that is acting as a temporary store, usually as data is being moved from one place to another, or as its being edited and being saved back into its original location. Compare them to streams, which involves working with data as its being read/written in small chunks. Video playback can be "streamed" but usually also includes a buffer to store some of the future video in case an inconsistent stream download can't keep up with the playback. Non-streaming video downloads everything into a buffer and plays that back from the buffer. This is when you have full video history without having to re-connect and resume downloading when skipping backwards in the playback. I guess the video use case is a little complicated :P
If you've ever played a fighting game (ie. Street Fighter, Mortal Kombat), you might've noticed a buffer being used to register input from the player's controller. If you press, say, Medium Kick quickly followed by Medium Punch, the game will "buffer" your actions; they are put in an ordered queue, and as your character's animation for one of the moves finishes, the next one in the queue is executed. This allows you to input commands faster than your character can animate them, and makes the game feel more responsive than if you had to wait for the animation to finish. A data buffer is much the same concept, but instead of "saving" player input, it is used to "save" results of an IO operation into RAM (because accessing RAM is much, much faster than repeating an IO operation, which can involve accessing the disk or a network).
&gt;Unfortunately the tool [workly] didn't seem to raise much interest(I posted on a few places), probably due to too much info and non-intuituve UI/UX :S Just improve it a little bit and then let it stew. Unless the hosting costs are astronomical, don't take it down! Is the code hosted on github or something? Because I might have some ideas to extend it, if you don't mind.
I think the main advantage of having all of your dependencies at the top of the file is exactly that, an easy and quick overview of everything your file needs to function properly. Also, I see no advantages to having anything global if you can easily import it, and the size gain is so small it's not worth doing it just for that reason.
I struggle with it. In some cases, [you need something like `node-source-map-support` to get source maps working](https://github.com/petkaantonov/bluebird/issues/363). This leads to a variety of problems, like performance issues and bugs due to interactions with other libraries. It's really shitty.
I've used it on a couple projects and it was almost a nice intro into React and other component-based tools. I would recommend using [JSX with it](http://mithril.js.org/jsx.html), since its standard DOM syntax is pretty ugly. It's definitely nice for smaller projects where something like React would be overkill. You can drop in mithril and write a few components very quickly.
The main reason is avoiding increased complexity. Explicitly stated dependency is always better than global magic with dragons and state. I try to Write code to be read by people, only accidentally to be executed by computers.
Besides monkey patching, is there anything else you just can't do in classical inheritance you can do in prototypal? Or vice versa? For example, is multiple inheritance at all possible in classical inheritance?
Which is exactly what I'm pointing out.
Hey, thanks for that suggestion, it IS cleaner!! I might have to update the article,
I first ran into Twelve-Factor Apps when I started working with deploying apps to [Heroku](https://www.heroku.com/). It's been a while since I've last used Heroku, but the effectiveness of following those guidelines stuck with me.
So don't upgrade your dependencies every month?
&gt; because you would need to retrieve the resource in order to sign/verify &gt; The distinction is that they're not signing a payload, they're signing an identifier. This is a misunderstanding between us. A "payload" in crypto is the thing you're signing, or encrypting. I'm referring to the request URL here as the payload (or the relevant parts of it, like resource **id**, not the resource **content**). This is why I said we're signing the "request payload", and not "response payload".
[works pretty well](https://i.imgur.com/EQakffV.png) but yea, looks like cubes have only three faces, which makes it hard yo build in three of the six directions of a cube.
awesome..was just suggesting something like this for an embeddable unit..cool to see my idea validated within 2 hours of typing this pretty much to my CTO in slack
Recently I've been importing libraries at the top of my files when developing locally, but using a CDN for as much as possible when in production. The advantages being a) a CDN can usually serve a file faster than you can, and b) you don't necessarily need an Internet connection while developing. Might be a nice compromise for you.
I think importing is really annoying, perhaps you think differently. It's easy, but it can cause me to lose focus. As for dependencies, the global variables are the dependencies for every file in your application. If you update a library like React, you'll probably have to check your entire application to make sure it still works.
I'm kind of confused why "Front-End Engineer" is also considered "Full-Stack JavaScript developer". Front-end implies the opposite of full-stack, at least to me. Is it different because they have to write things that access the back-end?
What do you mean by increased complexity? The complexity is the same, you just have one fewer line of code for each global variable that is no longer imported. &gt; Explicitly stated dependency is always better than global magic with dragons and state. What's your reasoning for this? I think having explicit dependencies is ideal, but we should also take development time and effort into consideration.
My main issue with importing libraries is having to type about `import .. from ...` so many times. It's annoying and it ruins the flow of my work.
&gt; Also Mithril AJAX requests by default blocked the render function being called until the request completes Wait, _what?_ How is this not a jaw-droppingly bad idea on the part of the framework? Am I misunderstanding something?
You don't really need a boilerplate. Follow this, from top to bottom: https://webpack.js.org/guides/hmr-react/ 
That actually looks perfect, thanks!
So is there no way to get around it? That kind of sucks..
So basically I'm out of luck xc
https://en.wikipedia.org/wiki/Feature_creep &gt;Feature creep, creeping featurism or featuritis is the *ongoing expansion or addition of new features* in a product, such as in computer software. These extra features go beyond the basic function of the product and can result in software bloat and over-complication *rather than simple design*. ES6 *is* feature creep. There's no talking around it or trying to spin it - you can't deny that it's feature creep without losing credibility. 
Signing is also one way... before you reply, spend a moment to think about it reeeeeaaaaaly well. :-)
It's literally just a variable insertion. `${a}B` === a + 'B'
Then add a snippet already. If you need React then you can even include the export default () =&gt; part.
Is there ever really a reason to have SQL in your client JS? I would think..... no.
Will do once I'm on my computer but I guess what I'm asking is if you had 3 separate arrays with objects in them and each object contained a username : 'name' key value pair , and you wanted to make a new array with that says [{ username: 'someuser', isUserInArray1 : true, isUserInArray2: False, isUserInArray3: true}] (True or false depending on if that user is in the array or not) Keep in mind that some users may be in all three arrays or even just one AND they will have the same username if one 2 or more arrays 
I don't agree with setting global vars but its really easy to configure your linter to recognize defined global vars
Electron has full access to node js so why not just use that bridge?
`babel-register` is likely what you're looking for, but it's not recommended for production use, per the babel handbook: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/user-handbook.md#toc-babel-register
GSS, yeah. Didn't the makers of that site also create cassowary.js?
Fair point! Just trying to come up with suggestions
Storing a local cache of data in a sql database? WebSQL was a thing for a while.
[removed]
Actually, I think (if I'm not mistaken), you have it the wrong way around. The problem exists when you have an active cache. My understanding from this article is that a passive cache is when you have a cache that is actively being updated by the backend when needed and thus the cache is always fresh and authoritative. You basically architected a way to make sure that the cache is always accurate and you never need to fall back to the backend due to a cache miss. I architected a similar solution for a big telecom recently, because their requirements was to have a zero downtime CMS driving their web properties and the only way to make that feasible was to have a pub-sub model for publishing content from a headless CMS in a way where, if that CMS died for whatever reason, subscribers still had access to content because their only dependency was the cache - minimizing the amount of points of failure that could lead to catastrophe. Conversely, an active cache is one where a query will ask the cache if it has the data requested and, if not (cache miss), it then is forced to pass it on to the backend to get the data and then store it in the cache and return it. This is where the problem arises. An attacker can DOS your backend by deliberately querying stuff he/she knows will cause a cache miss and be forced to query the backend - which is more expensive. My understanding of what the author is saying is that, should you be reliant on an active cache, one way of preventing a DOS (or minimizing the threat of it) is by signing your requests to prevent your backend from doing too much work and reject an invalid request as early as possible, so it doesn't have to spend additional resources on your backend systems (such as querying your database or whatever for something that isn't there). 
Thank you all very much! It's clearer now
I would recommend you to use Vangrant, Docker or just a Virtualbox Ubuntu. Sqlite might only be your first and not last problem with JS on Windows, many peeps test their libs by default under Unix based systems. Edit: and I know I didnt answer his question directly, but the next question would just be: which alternative for "x" exists for Windows... 
React is bulky, so I agree it might be overkill, but why is it better for big projects? Smaller often means faster (lighter), and less buggy (=more secure) I'd say the bigger your project, the smaller you should keep your libraries.
I'm not your friend, buddy. 
I built a package for exactly this called trilogy. [GitHub repo](https://github.com/citycide/trilogy). It uses a more document store style API but you can build queries using the knex query builder and run them as raws. It supports SQL.js so it needs no build step at all. You could also just use SQL.js by itself by reading the file as a buffer and such, and if you want query building there are a couple libraries like knex that let you do that. Trilogy does all that for you though. 
Create a Map(). Iterate over each and check if the map has the username as an existing key. If it does, set the applicable property. Otherwise, create a new object with the username and applicable properties. Add the new object to the map with the username as the key.
[It's much easier to query, especially for complicated queries](http://imgur.com/JDqfuIs) compared to a key/value store. Also client heavy apps are a thing now, especially for end-to-end encrypted apps which can have a local encrypted cache of messages, photos, documents etc. Also think about a local database that can be used while offline or remote.
&gt; minimizing the amount of points of failure that could lead to catastrophe. Adding a key-value cache server in front of an RDBMS is not minimizing the points of failure – you are increasing the points of failure by introducing an additional layer of data abstraction. You could have easily solved this using non-writable slave replications of the RDBMS.
Dead link
&gt; Actually, I think (if I'm not mistaken), you have it the wrong way around. The problem exists when you have an active cache. Actually: both. 
Thank you!
&gt; NOTE 2: The outcome of creating these instances using literal form or using new operator is very much the same. Not _exactly_. There are some differences that should be made known to help prevent confusion. For example, the Array constructor has different behavior compared to its literal counterpart depending on how many arguments you pass in. If just one is given to `new Array`, it will create an empty array with a length equaling the numeric value you provided. Any other number of arguments means they become the array elements. []; // empty, 0-length array [5]; // [5] (length = 1) [5,10,15]; // [5,10,15] (length = 3) new Array(); // empty, 0-length array new Array(5); // [,,,,] (empty array, length = 5) new Array(5,10,15); // [5,10,15] (length = 3) Functions created with new and the Function constructor similarly behave differently; namely, they can't be closures. While function declarations and function expressions (and even functions created in an eval) can access variables in a higher scope, functions created with the Function constructor cannot. var a = 1; function f(){ console.log(a); } f(); // 1 var f2 = new Function('console.log(a);'); f2(); // Error The Object constructor also works as a conversion function when passing it a value. When you do this, if the value provided is already an object, that value is returned rather than a new object being created. var obj = {}; var newObj = new Object(obj); obj === newObj; // true, no new object was created var prim = 1; var newPrim = new Object(prim); prim === newPrim; // false, new object created of prim type That comparison failure is actually a good reason to avoid primitive objects as well (which I don't think you've yet to cover). You also need to be careful about escaping characters within a RegExp constructor because with that you're using a string rather than a direct reg ex character sequence like you are in the literal (your example actually shows this) // regexp literal form let reg1 = /\d+/g // instantiating RegExp reference type let reg2 = new RegExp('\\d+', 'g'); // &lt;- escaping backslash 
I didn't read the whole program, but tell me about the .html file? What is it and who hosts it? What is the key about? There are other ways around this depending on what you can influence. [JSONP](https://en.wikipedia.org/wiki/JSONP) for example. Or whatever is generating the key, pull the logic out and host it locally. 
I actually had a chance to read through it, these high-level principles are quite interesting, especially since architecture is one my newer obsessions and I'm still pretty ignorant. A few ideas I hadn't considered either!
I created a simple tutorial to deploy a simple static site (html and js) to Heroku using a Node server. I think is a good solution to host our personal project for free 
Awesome, thanks for sharing! Speaking of Chrome extensions enhancing GitHub I highly recommend those ones: * [npm-hub](https://chrome.google.com/webstore/detail/npm-hub/kbbbjimdjbjclaebffknlabpogocablj) * [Refined GitHub](https://github.com/sindresorhus/refined-github) * [OctoLinker](https://octolinker.github.io/) * [GitHub Hovercard](https://chrome.google.com/webstore/detail/github-hovercard/mmoahbbnojgkclgceahhakhnccimnplk) * [Awesome Autocomplete for GitHub](https://chrome.google.com/webstore/detail/awesome-autocomplete-for/djkfdjpoelphhdclfjhnffmnlnoknfnd)
Different guy here, but here is a scenario that may give you ideas. The basic gist is that if you can unify your service arrays under a parent, then you can iterate through them with their identities in tact. You can do it with array but it adds a step. I did it under object called "myServices". /** Lower order programming =D **/ myServices={}; myServices.service1=[{'username':'Ross','otherstuff':{}},{'username':'Joey','otherstuff':{}},{'username':'Rachel','otherstuff':{}}]; myServices.service2=[{'username':'Ross','otherstuff':{}}]; myServices.service3=[{'username':'Ross','otherstuf':{}},{'username':'Rachel','otherstuff':{}}]; function parseServicesUsedByUsername(s){ var i,l,n,a=[],names={}, s=(typeof s=="object")?s:{}; for(i in s){ /* iter through services */ for(n=0;n&lt;s[i].length;n++){ /* iter through names */ username=s[i][n].username; names[username]=names[username]||{}; names[username][i]=true; } } /* At this point I would return "names" object, since I think it is more useful. But you wanted an array of objects, so here is one more transformation: */ for(u in names){a.push(Object.assign({'username':u}, names[u]));} return a; } var newUserCollection=parseServicesUsedByUsername(myServices); 
I think `reduce()` would be best for this. Using only one callback function, call `reduce()` one each array.
Any idea what the code for this might look like?
The first one you linked is the same as the one OP linked
Fun fact: if you're familiar with Category Theory, Promise.all is actually very similar to an Array.sequence method with Promises baked in as the inner type to be flipped outside. And Promise.race is similar to a parallelized version of .alt or .concat for Promises (combine two, take the one that resolves first, same for an entire list of Promises).
It wasn't about weight. More about LOC. You're right that the important metric isn't LOC, but LOC/eyes on them. Maybe React is superior in that metric. I looked around at React and felt disgusted years ago. So I'm guininely curious what people are looking for.
While the first function passed to then in this case is unlikely to throw an error, note that if it did, the second function would NOT catch it, and you'd be left with a big fat unhandled error again. That's because only one of those functions ever runs at a time.
It's not fair as its the same operator :P
NSFW ahead: [...(‿ˠ‿)]
Can you show me the entire file ?
Hi /u/vitomd, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `vitomd.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [vitomd.com](/search?q=%28and+site%3A%27vitomd.com%27+author%3A%27vitomd%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|18|82%
also https://google-webfonts-helper.herokuapp.com/
Yes, we changed that in v1.0. This release was mostly about fixing early design decisions that turned out to be not so great in practice after a few years in the wild.
React is 5X larger, has no router, http request or streams lib, doesn't include JSX or hyperscript helpers out of the box, plus you need some state management lib just to get redraws working with your app state. I don't think it does more.
JSX aesthetics is definitely in the eye of the beholder. I don't see how writing JS as XML is less ugly than writing JS as JS.
There are a few good JSON stores: try NeDB, or LowDB. These require no native build step.
Nancy from accounting can access the website on her smart phone. It's modern and responsive. She can also access it when she gets home. As an accountant for a shitty company who doesn't upgrade their computers, Nancy hates going to work every day and is thinking about working elsewhere if Carl from sales makes one more crack about her hair.
Hi /u/tomslavkovsky, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
How exactly is this a "mess"? Its a well documented and widely supported feature. "This is not JavaScript" what...
I think Mithril 0.2.x had a good run, and it definitely gave us some very valuable feedback regarding design issues that had to be fixed for v1.0. We're using v1.0 in production already, and I know some other folks are too (e.g. Guild Wars 2).
Then I probably wouldn't work for you
I think there's a lot of situations where it does a better job describing intent. For example, let's say there's two plans you could choose from: 'basic' and 'premium': let basicList = ['thing1', 'thing2', 'thing3']; let premiumList = [...basicList, 'thing4', 'thing5']; let premiumList2 = basicList.concat(['thing4', 'thing5']); Both options get the same result, but I think using the spread operator here makes it immediately clear that the premium list is the basic list plus something extra.
This is feature creep, and it was never needed in the 20+ years before javascript started to add features from every other language. It doesn't even look like javascript anymore. What you end up with is a clusterfuck of conflicting syntaxes all crammed into a language that *was supposed to be simple*. It's not simple anymore, it is getting more complex, more bloated, and that isn't going to make a lot of people happy except people with a fetish for syntax. Let's throw in 10 more kitchen sinks while we're at it. 
And you'll be shipping it slower than him, because you'll write more verbose, less readable code. You can feel free to dislike this syntax, but stop pretending like it's because it's bad. Makes you come across as an ignorant cunt. It's just personally not appealing to you. There is not an ounce of rational thought behind your argument. Surely you can see this? That you're talking absolute bullshit, and it's all completely subjective? Do you honestly, taking a step back and reading through your 2 posts, think, that you made any valid argument whatsoever, other than crying like a useless kid?
The only ignorance here is that you're spouting buzzwords with nothing constructive behind them. "Feature creep" is not an argument. It's just a phrase you're blurting out because you've got nothing.
React has setState for redraw. It can even be used in a Redux-like pattern: https://twitter.com/dan_abramov/status/824308413559668744 Router can wildly differ, some prefer hoc's, some declarative routes. HTTP, there's fetch. Reacts re-pools/re-uses events and abstracts their browser differences, which is a sizeable chunk of the lib but worth it as it makes events safer across all browsers, faster and saves GC cycles.
can't tell if obvious troll is obvious or... :P
There is something you may have misunderstood. We are talking about an API here. There is no additional layer of data abstraction.
I'm not following...
You think I'm afraid to learn new things? hah. That's really rich. You have no idea what I'm learning, every day. Keep dreaming.
I love assembly language. I actually write quite a bit of it these days when I'm not writing Javascript. You don't? Or you can't?
The simplest change would be to change `number &lt; 5` to `number &lt; 3`. Whichever value you use will be the value returned if `number` is less than that value. So changing it to `9`, for example, would always return `9` for any `number` less than `9`.
Yeah, you have to explicitly setState or add something like redux. Mithril's auto-redraw on events/requests eliminates a lot of hand-wiring. Mithril also normalizes browser events, and its bundled http lib is probably the best I've used - can be as simple as fetch or with the full power of XHR when you need it.
I'm gonna be honest with you, denormalized events have never been an issue for me since IE8 fell off the radar (and ironically event normalization gave me more problems than raw events when dealing w/ multi-touch events...) Event attachment never came up as a perf issue either. I'm not really sure why people keep bringing that up. The thing that is especially confusing is that some react-like libraries say they don't do event normalization for perf reasons. Would be great to see where people are pulling their perf numbers from.
Look, it's a preference. But to me it's a good thing it doesn't dictate a model. I would personally never write a large app with observers/autoredraw again. Have burned my hands too often. But if you can handle it more power to you.
I don't understand how either would be "less maintainable" than the other being that here they yield the same result. In fact, seems like the spread method would be more "maintainable" because it's more flexible (ability to specify positioning). I suppose it might be less readable at first glance if the reader isn't familiar with the operator, but the same could be said about any language syntax feature ever ...
I think it makes more sense to opt out when needed rather than dictating that you must handle granularity everywhere when you don't need it. But even with tens of thousands of nodes in a mithril app, I haven't needed to opt out yet.
Do they? Inferno claims better perf as well as Facebook. Google cites wrong or superfluous event attachment as one of the biggest source for jank. I believe Paul Lewis had some articles about it. Debounce and delegation also play a big factor, which i believe is also built in. Either way, i appreciate not having to switch case events for browser abstraction.
I don't get it
Oh I bet you just love [... new Set(state)]
Because the while loop will add to the number until its conditions are met 
There is a line where new features stop being new features and turn into becoming bloat. What's subjective, however, is where that line is. Case in point: this discussion.
Chrome's not raising any red flags for me...
ES6 is a 'Frankenstein' language. 
No
https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub Channel is awesome btw. but you will see that yourself.
Since React also dropped IE8 support the only reason i can see React still having synthetic events is because it supports multiple render targets outside of the DOM(React Native) that may not have events.
Without putting in a decent amount of work, yes. If you're dedicated I'd go with the proxy solution.
No, I spend my days writing Javascript and various other languages. C#, assembly, some PHP when I have to, C++ for a few things. When I see a post on my front page about ES6 feature creep, I add my comment in full expectation that the echo chamber of syntax whores will call me stupid and downvote me. You did not disappoint!
Javascript was meant to be simple, ES6 is not. You can call out "subjective" until you're blue in the face, but the reality is that javascript used to be easier and ES6 is bloating the language.
JavaScript (like any language) has quite a few (more than other languages generally) quirks. That being said, any language you write in will be driven in part by how types are defined in the language. A type can be general (like object or function) to something more specific (like date or string). Understanding these types and how to use them is one of the first building blocks to understanding how to properly instantiate and invoke "classes" in JS. Regarding your questions, there is no way anyone with little to no programming background would step in to any language, let alone JS, and have even a firm command of the base concepts within a few months, let alone weeks. My advice is to take your time and read some beginning JS guides (google is your friend), setup a good dev environment (again, google), and then just start to understand how HTML, CSS, JS and the DOM all work together. You'll need to practice a lot and read a ton of resources before you really start to get the whole scope of it. If you're still focused on understanding classes/objects/etc, read these two resources (my advice is to always utilize the actual development spec documents to get a true understanding of how these concepts work): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype.
I never called you stupid. If I really cared enough to call you something it would probably be "attention whore"
- The Secrets of the JavaScript Ninja - 2nd edition. Great book! - Functional Programming in JavaScript. - JavaScript Allonge "Six edition".
[removed]
Here's another take on describing Isomorphic javascript within the confines of the JAM stack https://www.heavybit.com/library/podcasts/jamstack-radio/ep-8-isomorphic-rendering-in-the-jamstack/
Did you try `npm install --global --production windows-build-tools`? EDIT: make sure to run the above command from an elevated (admin) console.
You are more than welcome to write your app in ES3. Its still supported, even you old buddy IE6, on life support will breathe!
[removed]
Your CV is 4 pages long for frontend work, or dev work in general? What you should highlight depends completely on what you know and what kind of role you want.
It might help you to use console.log(number) within the while loop, to see it run multiple times. 
The **[You Don't Know JS](https://github.com/getify/You-Dont-Know-JS)** series should help you. Book #3 is titled **[this &amp; Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)**
I am actually a full stack developer like I said with inclination to the backend. but my frontend skills or let us just say JavaScript was only waken up a year ago. I am close to 7 years in the field. I have been doing some fair amount of JS before but it is unlike today. so if it would be for a frontend role then I don't think it would land me a job if I just put in a year of experience without demonstrating my aptitude and flexibility by showing the work I have been through.
I'm not concerned at all with F#, unless it tries to insert itself into javascript. You can keep your fad languages. 
I wasn't thinking about it specifically to prevent DDos attacks, but to generate a secure API key to limit access for a paid account upgrade...would like to roll my own just because people are paying for the service and wouldn't want to use a commonly available package for this means.. When a user is created, I create a uuid that is never exposed to the public, but use it as a hash/salt value... Was thinking of a method where I could use the users uuid hash + the resource url + some other fancy parameter to generate a signed ID, so i can tell if the script loads from this location it's this user... We don't really have open endpoints in our app besides read endpoints right now, and they need to all be accompanied with an api_key...and the rate limit should essentially throttle any api request, but aren't pushing the data yet to even come close to seeing if the limits work... 
People have posted links to some very good resources. Hopefully this brief crash course is also helpful: ## Objects Entities that have their own local variables (properties) and functions (methods): let obj = { property1: 3, method1: function() { return this.property1 * 3; } } In the above example, `this` refers to the object `obj`. So: console.log(obj.property1); // 3 console.log(obj.method1()); // 9 obj.property1 = 5 // We can still change these properties console.log(obj.property1); // 5 console.log(obj.method1()); // 15 ## Constructors Functions that generate objects of a given data type (class). class User { constructor(fname, lname) { this.fname = fname; this.lname = lname; } } In this example, `this` refers to the instance of the `User` class that we create. Instances are created using the `new` keyword: let user = new User("John", "Doe"); // Parameters are given to the constructor console.log(user.fname); // "John" console.log(user.lname); // "Doe" ## Prototypes A schema that dictates the properties and methods that should exist on *all* instances of a given data type (this schema is itself an object). After a class is declared, the prototype can be modified to add more properties/methods to a data type. User.prototype.fullname = function() { return this.fname + " " + this.lname; } console.log(user.fullname()); // "John Doe" 
Is it the functional programming book by Luis Atencio?
1 page. Online. Layout done using HTML + CSS. While sending to HR folks, manually convert the HTML page to PDF and email (along with a link back to my online resume).
I try to keep mine short (as short as possible). Basically, I spend just enough time mentioning my corporate employment to show the number of years I have been in the corporate world and who I worked for. A software developer is basically a software developer and a candidate either hops around frequently or they don't... not interesting stuff. I spend more time describing my military experiences, because not everybody gets to stand up from their corporate cubicle and go have little adventures in exotic locales for a year. I also spend some time describing my open source (hobby) software, because it is generally more impressive than anything I get paid to write. I do all this in about 2-2.5 pages. If people want to read the more interesting stuff they can, but the generally required stuff is up front and tiny.
Hi /u/codingthesmartway, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `codingthesmartway.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [codingthesmartway.com](/search?q=%28and+site%3A%27codingthesmartway.com%27+author%3A%27codingthesmartway%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|14|100%
Both of these are interesting points. I agree that good architecture will prevent nesting hell. But saying you prefer 2 space indents _because_ it is hard to read says a lot about 2 space indents...
I almost mentioned Ruby in my post but I don't work in it so I wasn't sure if it was the standard or just what I happened to come across in the few source files I've seen.
This^^ Luckily, where I work we agreed on 4 spaces as the standard. As a heavy backend PHP/Laravel developer with a Python background, it's just always been 4 spaces for me. The problem is when I have to work with WordPress starter themes such as Sage (which is awesome btw). Sage's front end files are all 2-spaces and so when you're working with something like that, it's a pain to convert everything every time.
[removed]
https://en.wikipedia.org/wiki/Syntactic_sugar &gt; In computer science, syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express. It makes the language "sweeter" for human use: things can be expressed more clearly, more concisely, or in an alternative style that some may prefer.
Same, can't find anything about it 
In the case you're looking specifically for the existance of users in each of the services, much like how you described here, then below code may be what you're looking for. You can call the function, passing in any number of services with the same type of structure like your example services have. It'll then return an array with one object per user, and keys 'service1' and onwards indicating whether this user is part of that service. Note that I'm assuming the username to exist under the property 'user', and not 'username' (mentioning this since you've been inconsistent here between your OP and this post). function getUsersInServices(...services) { // Collect all usernames per service in a more useful data structure (allows O(1) lookups later) const usersPerService = services.map(function (service) { let serviceUsers = {}; service.forEach(function (props) { serviceUsers[props.user] = true; }); return serviceUsers; }); // Combines the above lists of usernames per service into one username array so we can map over it let allUsers = usersPerService.reduce(function(acc, service) { acc.push(...Object.keys(service)); return acc; }, []); // Abuse Set's value uniqueness to remove duplicate usernames // * You could instead add an indexOf check above but I think this is faster (and I just like this more) allUsers = Array.from(new Set(allUsers)); // Main loop over users const usersInServices = allUsers.map(function (user) { let obj = { user: user }; // Check for this user's existance within each service usersPerService.map(function (service, id) { const serviceName = 'service' + (id + 1); // +1 since you used 1-based indexing obj[serviceName] = service[user] === true; // O(1) lookup useful here! }); return obj; }); return usersInServices; } // Test console.log(getUsersInServices(service1, service2, service3));
I keep 3 resumes: * One tailored to the job I'm applying for * A 1-page short-form resume for meetups and hiring entities with no attention span * A long 3-page resume that elaborates on my entire work history A lot of the advice in this thread is solid. Say on point, but don't make it looks like a mad-libs for technologies and roles.
Let them go out of date for a few months and there might be large breaking changes and even more work.
[This book](https://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/1617292850/ref=sr_1_fkmr0_1?ie=UTF8&amp;qid=1486169621&amp;sr=8-1-fkmr0&amp;keywords=secrets+to+the+javascript+2) is worth its weight in gold. It's partially written by John Resig the creator of JQuery and has a large section (possibly a chapter, I forgot) dedicated to es6 Promises
Thank you, I will look farther into this book series!
I have only been doing JS for a few weeks now and I know enough html and CSS to make a functional, decent looking site. I just feel like I should be getting it faster than I am but JS is WAY more complex than html and css could possibly be. I've never really pursued a skill that takes such a deep understanding, so this is frustrating to a degree. Thank you for the advice, I'll try to be a little easier on myself and do some more reading and practice.
I have had a few people, but I usually get an engineers answer and not a childs answer... if that makes sense. I'm going to watch some youtube videos and do some practice, hopefully I'll at least be able to grasp the concept by the end of the night. Thank you.
FWIW there are some other benefits to Google-hosted web fonts. Allowing Google to generate the stylesheet offloads advanced optimizations like subsetting, browser compatibility, cache configuration, and update management. If you're using a common font like Roboto, there's a good chance that users will already have the resources in cache and the network cost wouldn't be an issue. The performance tests linked from [this post](https://github.com/reactiflux/reactiflux.com/pull/21) do show a tangible benefit: https://www.webpagetest.org/video/compare.php?tests=170125_GR_GDCE-l:Before,170125_VD_GFA5-l:After . The version with the self-hosted fonts is significantly faster by 500ms. However, there are a few caveats. * The tests are on different web servers. * The tests were only run once, contrary to the recommendation to let WPT run the test 9 times and pick the median to account for any variance. May not make a difference, but worth noting. * The test page uses 5 fonts. YMMV depending on how many fonts your site uses. * The repeat view is actually slower: https://www.webpagetest.org/video/compare.php?tests=170125_GR_GDCE-l:Before-c:1,170125_VD_GFA5-l:After-c:1 . The cache headers are probably different.
I suggest you look inwards and reevaluate your attitude. Having deep knowledge of JS fundamentals is great. Good for you. But it is only one piece of the puzzle. Companies use these frameworks because they solve problems &amp; allow for productive development of complex apps. It is no surprise that they seek to hire people who understand how to best apply said framework. You aren't an expert in React just because you're an expert in JavaScript - just as the inverse is true. Does being good at JS give you an edge? Sure, but it sure as hell doesn't get you all the way there.
In call stack when debugging you will see the function name for the named function but the other will be an anonymous function. 
no, it's feature creep.
I'm not your buddy, mate.
One important difference is how the function is hoisted. With `function foo()`, the entire function is hoisted to the top of the surrounding scope. This means that you can call and reference a function before it's declared. With `let foo = function()`, only the variable _declaration_ is hoisted. This means that before the specific line, the function doesn't actually exist. Instead, `foo` is `undefined` until that point. Another key difference is that you shouldn't ever create a named function within an `if` block, because that function is hoisted. Assigning an anonymous function within a block works fine. Generally, there isn't a lot of good reasons left for named functions. If I'm creating a large library, I might declare all the public functions as named functions, using the revealing module pattern to expose them, but I tend to use anonymous and arrow functions almost everywhere else. _(Please forgive and correct any errors above, I'm trying to fall asleep with a bad cold.)_ _Edit:_ Thanks for all the corrections and improvements below! Please read further for more details, including changes specific to ES6.
But you can say that about any feature added to anything. Why are features added in ES6 unnecessary but those added earlier ok? ES6 didn't come out of a vacuum, features in TC39 are voted on by actual users, so by definition its what the majority of JS users want. And you don't need to use any of this if you don't want.
Would you mind giving me an example of how that would work in this situation? Thanks!
So, I can use both else statements, but I also need a return for the x&lt;0 loop option. That makes sense. Thanks a lot!
You're right, you need to remove all references. With one thing in mind: JS garbage collector knows about circular references and checks if the object has links from outside. So, in most cases, your object will be removed easily. The only case you need to worry – DOM event handlers with closures. Well, and closures in general. I mean, if you have an object reference inside a closure which is used anywhere, it will not be removed by GC.
Just to add, the temporal dead zone applies to `const` variable declarations as well.
If you set an object to null after you have no use of it, the garbage collection will remove it from memory, thus all references to it.
I wouldn't call this a package manager. It's more of just a download manager TBH. It doesn't seem to have dependency resolution or anything.
You *can* do it, like everybody is saying you'll need to remove all references and any closures/scopes that it'll be used in. Generally it's not needed, and if you tried to do it for **every** object you use, you'll have to write your code in a very deliberate and unintuitive way. Also if you're using any large framework it would be incredibly difficult to do effectively. Another important note is that there's a reason the objects wouldn't be garbage collected, and ultimately it comes down to improving performance. So it's a trade off - one that would rarely be worth the effort. My suggestion would be to write your code in a maintainable fashion, and make performance tweaks when it starts to become an issue.
Please fix your grammar. It makes it harder to read than it should be; poor grammar on an already technical document makes for very difficult reading. English probably isn't your first language and you seem to struggle with sentence structure, plurals, participles, and determiners the most. It would be worth your time to read through your article and take note of words that are misplaced. Read the sentences out loud to ensure that they sound correct; as many of the incorrect lines will sound wrong to your ears. A few examples: &gt; When are are dealings with a loop where one string have the possibility to be shorter than the other string and we do not know which string is the larger or shorter in length. What can we rely on? Should be When we are dealing with a loop where one string has the possibility to be shorter than the other string, and we do not know which is longer and which is shorter, what can we rely on? &gt; This sound simple enough, however other procedures we have to give consider to when adding a single digit together. Should be This sounds simple enough, however other procedures should be given consideration when adding single digits together.
&gt; A copy of the whole database is kept in memory. This is not much on the expected kind of datasets (20MB for 10,000 2KB documents). What if I want to deal with multigigabyte-sized data on the client side, without loading everything into RAM? What should I use, except SQLite?
That sounds like something out of ST:VOY...
[removed]
I prefer to use function declarations for declaring my functions. It's true that you could accidentally redeclare a function, but this is caught by TypeScript's compiler and linters (e.g. ESLint's no-redeclare rule). So, worrying about that is pretty pointless. It's simply not something which could happen in your codebase.
Arrow functions maintain 'this' scope, so this.persons works as expected. The normal function variety creates a new scope for 'this', so you need to bind the correct scope: https://jsfiddle.net/Lsjrad3n/
[Account seized by the NSA.]
See my edit above. Personally I would stick with the arrow function. 
[Account seized by the NSA.]
No, this isn't correct. The first code sample only examines the first contact in the array. If that contact doesn't match, it returns "No such contact". The second code sample works correctly - it doesn't return "No such contact" unless it has checked the entire array.
use regex to detect the use of the @ symbol
You should use JWT, with a admin True or false and depending on the value hide/show some buttons and being able to use them or make an admin page only available for them
Thanks!
Can you give some more examples of the nested email/properties?
Maybe you can use jsonlint ?
I really don't like this new trend with everything being a variable. It adds a slight but noticeable mental overhead which gets more obvious as your code base grows. IMO Functions should be functions, consts be constants and variables.. well variables.
The full valid/actual response is linked as the Pastebin, I'm not sure what other examples there could be.
Good and comprehensive answer! Just a minor correction—ES6 standardised function declarations in blocks. They use let bindings, and work mostly as you'd expect, but can't be referenced outside the block!
Yep, it's es6, but support is pretty good now http://caniuse.com/#feat=arrow-functions so depending on your audience you may not need to transpile. That said, vue is a modern framework, and there are lots of benefits to using es6 with it, so if you use webpack and Babel you'll be able to take advantage of all of those benefits 
Are you needing specific values or do you just not like the way it looks?
Can you give some small code example? 
I'm trying to take that JS object and create a new two-dimensional array from it -- so I need *every* value. The issue is that the desired keys aren't keys to their desired values in the JS. For example, from the linked example, I want to produce: [ ["stream_display_type", "grid"], ["email", "name@example.com"], ["href", "/users/323195"], ["status", "success"] ] But all of those values are represented in different ways inside the JS response. So it has { "_": "grid", "name": ["stream_display_type"] } So okay, if I want to add `["stream_display_type", "grid"]` to my CSV output, I need to grab `name[0]` and `_` from that object. Then I want the email, that's represented as "email": [{ "_": "name@example.com" }] So okay, to fetch *some* values you reach in and grab `name[0]` and `_`, but other times you grab the string key, then that key's `[0]._`. Then I want the link, *that's* represented as `"href": ["/users/id/323195"]`. So *some* values you grab `name[0]` and `_`, some you grab the string key and `[0]._`, and some you grab the string key and that key's `[0]`. And so on. And I can't just grab every element directly, I'm trying to implement a function that can turn any call from this API into a flat CSV file. I'm having a lot of trouble figuring out how I can build a CSV from such a structure.
I don't think JSONLint is relevant... I'm not creating this JSON and I already know it's valid, I'm trying to create a new structure by iterating over it.
Is this a well-known format for representing typed information as JSON? If so: a parser may already exist. 
It was the first full week for [Remote Jobs EU](https://remotejobseu.com/). It's a job board/aggregator with hand-picked (and formatted) offers for developers working remotely in European time zones.
Well put.
It annoys me that you're here. A wiki page is not the same as a beginner tutorial
yes! Those books require previous knowledge of JavaScript though.
The Github wiki is better place than medium for following reasons 1. It will still be online in many years 2. The community can maintain the guide and ensure it doesn't go stale 3. The document can be ported 4. The document will be correctly indexed and added to a structured guide
&gt; If it's got a length and that length is 1, it's one of those arrays just containing an object where the key and value are siblings called name and $, so return a 'tuple' of those So first of all, your pastebin does not contain any 1-length arrays. There's only one array, but it has many objects inside. Thus this case will never happen. To have a proper look at the problem, let's divide it up into smaller bits first by going over each of the different substructures contained in the pastebin, and how we were to parse them: --- "status": "success", // return [ key, value ] This has to be the simplest case, a straight up key/value pair. Nothing to say here really. --- "average_message_rating": { "type": "float", "$": 0.0 } // return [ key, value.$ ] Here we have one of the two major rewrites you were looking for. The value is an object which represents the actual value of the key. We have to kind of look ahead into the value to find the proper `$` key. --- "user": { // ... } // return [ key, parse(value) ] This is one of the few objects that does *not* contain a `$` key, and is thus not intended as a structure like the previous case. Here we need to actually recurse. The key thing to note is that we'll have to add proper checks to differentiate this case from the previous case. --- { "name": "accept_private_notes_consent_agreement", "type": "string", "$": "false" } // return [ value.name, value.$ ] Here's the second of your two major cases. This is the alternative key/value structure when it's contained within an array, and we have to get both the key and value from inside the object. --- "profile": [ // ... ] // return [ key, parse(value) ] This is the container structure which will be containing instances of the above case. But since we're already handling that case, all we have to do here is properly recurse. This is simple once you think about it though, since an array is just another object you can use `Object.keys()` on it just fine. --- Next we'd have to add proper case checks for each of the cases. What parts of the structure are specific to only that one case? It should be fairly easy with some trial and error as you can easily test this. When that's done you'll want to add all the case handling, basically combine everything together into one nice function. One thing to note in particular, regarding the case checks, is to keep them separate just like how I treated each case separately. Your example contains multiple nested conditionals and this can make it very unclear which checks belong to which cases. Even worse, some conditions are used by multiple cases, so if you'd want to then change the condition for one of those cases, you can't since you'd be changing it for all cases. So handle the checks case by case, it'll make your life a lot easier.
Seems like a pretty shitty API
You dont seem to know what the difference between an article and a wiki is. While there might be nothing wrong with beginner tutorials in the wiki, it look like this guy isnt someone from the threejs team. So whats your problem? Should the team merge all tutorials from the web into their wiki?
This seems interesting thanks for sharing. I have never messed around with something like this.
We recently decided that the wiki would be used as a developer reference actually, the correct place would be the docs. Admittedly the manual section is very sparse at the moment, but it does already have an equivalent to this article. Feel free to improve it if you like - there's an "edit" button on the top right of the page. http://threejs.org/docs/#Manual/Getting_Started/Creating_a_scene
Another small thing I haven't seen mentioned is how they each handle "this" in the new babel/ES2015 class standards. With a function declaration you have to bind the function to "this" when called, whereas fat arrow functions (and fat arrow functions only) inherit "this" from the class and is lexically bound no matter where it's called. Makes object oriented programming much easier in JS. Maybe not the same thing but still worth knowing about. 
For the triangle case, its fine that the object would have already been created. As long as you don't leak out references to that object to the caller, none will exist and the object will automatically be deleted from memory. class Triangle { constructor(sideA, sideB, sideC) { if (!this.isValidSides(sideA, sideB, sideC)) { throw new Error('Invalid triangle sides'); } // ... } // ... } Here, an error is thrown in the constructor which prevents the object from being returned from the instantiation. Even though the object was created, the only reference that existed was in the constructor and nowhere else. Because no other code would be able to access it, it gets automatically cleaned up and deleted. Additionally, as /u/norlin mentioned, circular references are handled by the garbage collector, meaning you don't have to get rid of _all_ references to delete an object. You would only have to get rid of accessible references. For example: var container = { obj1: { ref: null }, obj2: { ref: null } }; container.obj1.ref = container.obj2; container.obj2.ref = container.obj1; Here we have two objects in a container object, each which have a `ref` (reference) property. Each object then has its `ref` set to reference the other object. Want to know how to delete these objects? container = null; Even though `obj1` and `obj2` still have references to them (2, in fact, 1 in the other object's `ref` and one in the `container` object), they are completely inaccessible to code because the only variable reference we had to get to them - via `container` - was set to `null`. So its not just keeping track of references, something GCs do called _reference counting_. They're smart enough to go beyond that and perform additional checks such as doing _mark and sweep_ passes, traversing the accessible variables within your application to see whats still valid. Now I haven't kept up with my GC tech, so they're probably doing a lot more fancy things now, but those two approaches used to be pretty standard, and at least give you a core guideline for determining if you need to do any more to "delete" an object: _make sure nothing else in running code can access it_. As long as you keep things together and self-contained, this isn't much of a problem. But as soon as you reach out into other objects such as globals or associations then you can create references in those other objects, even if not completely obvious - again, as norlin was saying, a common source for this is DOM event handlers. class Triangle { constructor(sideA, sideB, sideC) { document.addEventListener('click', event =&gt; { //&lt;-- eek! reference added to document listeners! console.log(this.getSize()); }); if (!this.isValidSides(sideA, sideB, sideC)) { throw new Error('Invalid triangle sides'); } // ... } // ... } Here, even if there's an error thrown from the `isValidSides` check, a Triangle instance reference will remain in memory because it is accessible from the document object's listeners. If someone clicks anywhere in the document, that event handler will run and the `this` reference inside of it will be used to access the otherwise-would-be-deleted Triangle instance. In cases like this, its always good to make sure you have cleanup steps to remove listeners like this (as long as they're not persistent, for the lifetime of your app listeners, which you don't have to worry about) so you don't leak objects that should have been deleted but can't because they're still accessible through listener lists.
Add error handling for each element you try to retrieve.
If you are still interested I just pushed a new version of multi.js which is no longer dependent upon jQuery. :) Available on Github! [https://github.com/Fabianlindfors/multi.js](https://github.com/Fabianlindfors/multi.js)
Nah people should just stop using medium and linking to it.
`document.documentElement`, which is the `&lt;html&gt;` tag. See `document.body.parentNode.nodeName`.
ES6 made it so that assigning a function to a named variable also sets its name to that name, so you should not see the difference in a stack trace.
I document the type via type annotations (or doc comments if there is no other option) and if you pass something wrong it's your fault. It's the caller's responsibility to pass the right kind and amount of arguments. Also, guarding against any kind of incorrect usage would add an unholy amount of boilerplate and it most likely won't be 100% idiot-proof anyways. So, following this strategy is apparently not feasible.
I will keep this in mind for the future- in my case, you're right, it probably wouldn't be worth the effort to try to maintain for performance. This is a small assignment for my coding bootcamp. There's no validation required, but it bugs me that I could create a Triangle object that is not Euclidean (ex: sides are 4,5,2000). I wanted to create validation that would not allow the creation. So basically, when I declare a new triangle and feed in the arguments for the size of the sides (let's say set it to X), my fear was that it would create the object and have X refer to it. Even though performance wont take a hit that it exists, I don't want a user to be able to call for X and see the non-valid triangle. So I was trying to figure out if I could either disrupt the construction of the object in the first place, or run a check after creation and have it destroy itself whether getting rid of the object outright or deleting the variable X's reference to it. Thank you very much.
The line between editor and IDE is pretty well blurred at this point. Atom is more than capable of running 99% of you average IDEs features.
Not to sound like I'm trolling, but I literally had to spend a few minutes looking through the PDF to figure out of this is satire or an actual case study.
It's hosted at a private repo for now, cause I was hoping to maybe sometime place some pre-curated job ads and potentially gain a bit of money ( I'm currently not employed ). The code needs some refactoring, I will try to find some time and improve it and maybe open it, will let you know! ps. In case you are interested, the stack is: preactjs, mobx, webpack, ramda and recharts for the plots(quite heavy but convenient at the time).
That is an accurate description. I have so far ignored dependency resolution deliberately, because I get really frustrated with dependency hell nonsense that breaks applications for my users. I need to do more to assist with dependency management. I will think on this in such a way that does not give rise to a spiral of absurdity. What ever solution I take it will be there to assist application publishers and not consumers. The end goal will remain to get a complete application from a single download (not counting the hash file).
Also, remember that the document object can refer to other types of documents than HTML documents such as, for example, XML documents. The document object is an instance of the [Document interface (MDN)](https://developer.mozilla.org/en/docs/Web/API/Document). So document is the entrance point for you to be able to interface with your HTML (or XML). I would suggest that you (and anyone really) read over the MDN article linked above to gain more of an understanding.
I had not realized that, but that is a great feature
I'm confused. I thought the spread operator only worked on iterables as noted on [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)
I mean, it's not a very _helpful_ comment, but they certainly aren't wrong. I think I actually pity OP for having to work with this. This is awful.
This is a great introduction to Three.js and I wish it had been around when I had to dive in a couple of months ago. We use three to display both a realtime visualization of a hardware device's movements in space and to present some data about past movements. If I wrote a blog about my experience with it, I'd add a few points that I think are very important. In no order: Three's TypeScript definitions via DefinitelyTyped are mostly fantastic and make the learning experience significantly easier. There are a ton of concepts and vocabulary you must learn and figuring out what arguments to give and how different instances of objects work together can feel extremely overwhelming. Even after you know how it works, it can be a lot to keep track of. TypeScript cuts out an entire layer of guesswork and things to keep in your head. It doesn't mean that you'll end up with what you want on the screen, but it does mean that you'll immediately know whether you're putting things together in a way that is technically correct. This article omits light sources, which are a big part of making your scene look right. If nothing else, realize that an ambient light will let you see everything but a spotlight is necessary for depth. Suspending a spotlight over whatever you're presenting is often a quick way to add crucial definition. I've found it very helpful to create wrapper classes around my Three.js code. It usually takes a lot of code to make changes to your view, so isolating it from your components (if you're using React like me) and breaking it down into digestible methods is crucial for maintaining clarity and sanity. Finally, pay close attention to the posting date of anything you read online. The library has changed a lot over the years and you'll find old posts that have no bearing on its current status. This is another area where TypeScript helps _a lot_. I've found it extremely enjoyable to get into Three. 3D graphics always seemed like the domain of other people and it's great to be proven wrong. I'm not doing anything too advanced but its contributions to my work app are crucial and the learning curve wasn't too steep, especially thanks to TypeScript. Kudos to everyone involved. I just wish they'd change their style guide to avoid all the extra spaces around parenthesis. This shit kills me sometimes.
I can't say anything like that without further context from OP. The two json samples linked so far are different enough that it's hard to imagine they're just two different endpoints on a single API. Rather, it seems like OP is trying to combine multiple similar APIs or something like that. Ofcourse, having to combine all these different json data structures seems a ridiculous requirement. But you can't blame any of the parties without more context. Who knows OP is infact trying to solve the exact problem of combining data of different APIs to provide a single combined data structure (his intended CSV). Regardless though, merely commenting here just to say 'Seems like a pretty shitty API', isn't going to help OP one bit.
Looks pretty slick. Personal site, even more so. Good job.
If you back out of the "main site" then your cover letter text is corrupted. [image](http://imgur.com/a/f8PgO)
What browser are you using? I didn't see that happen on any of the browsers I tested on. Thanks for the feedback!
In the order of hoisting function declarations are hoisted first and then references declared with `var`. var happyDance = function () { //anonymous function function happyDance() { //named function var happyDance = function happyDance () { //named assigned function The first example is anonymous. That function cannot be identified in stack traces or profilers. There internal reference to the function is not immediately known and is available less efficiently as a closure. This function is hoisted with all other references declared by *var*. The second example is a named function. The function's name is internally known to the function as a local reference. The function is identifiable by name in stack traces and profilers. This function is hoisted and there is nothing you can do about it. The third function has an internally known reference and that name shows on stack traces and profilers just like the second example. The function is hoisted with other *var* declarations in the current scope just like the first example. I tend to use that third example's form when writing my own code.
https://www.cyberciti.biz/faq/authentication-vs-authorization/
Further: This is ultimately for stating an expectation that all of a list of targets are present in the subject list (under the above criteria). Currently doing that with an `expect` inside a loop over each target. eg: [{a: 1, b: 100}, {a: 2, b: 250}].forEach(function(properties){ expect(data).to.?include?(properties); }); but that doesn't feel particularly idiomatic either. Is there a more terse/idiomatic way to express this all together?
Guy. Come on. 4+ seconds is not "in milliseconds".
http://jsbin.com/teminunuyi/edit?js,console
Thanks for it. Many thanks!
use Array.prototype.some and `satisfy` for checking one there's a package for checking this type of stuff. https://www.npmjs.com/package/chai-things expect(ar).should.all.have.property('a', 2) expect(ar).should.all.have.property('b', 250) 
Looking at Ityped, cloning will do nothing because all the factory does is spit out an object with a reference to the init function, which uses a bunch of closures. 1. Whoever wrote ityped did not seem to architect it with this use case in mind. 2. If you are going to deep clone objects you can just use Object.assign({}, objToBeCloned)
Glad I could help!
This is why I like node.js. I can use language features without worrying about old browsers.
If the list of fields that you want to produce is fairly limited, you could just map it yourself: var arr = [ [ "href", response.user.href ]. [ "email", response.user.email.$ } ]. [ "name", response.use.name._[4].$.end.Nudes ]. [ "status", response.status], ... ] &gt;&gt; arr Even if there are a lot of fields, you can generate arraylines with some helper-functions
I mean if we're honest, this: &gt; static site engine ... in 2017 is just as weird as a selling point. 
The problem was never the lack of native functionality.
Babel is your friend.
&gt; Why do you want to remove the body tag? I often do quick tests by opening a new tab in Chrome and use the console in Chrome DevTools. Writing `document.body.innerHTML = "";` may remove the body tag content but it doesn't clear any of the styles or other attributes.
You could map the data to drop the junk properties before checking `includes`: const compare = data.map(item =&gt; ({ a: item.a, b: item.b })); expect(compare).to.include({ a: 2, b: 250 });a: 2, b: 250 }); 
Love it. This is beautiful. 
maybe something like in addInput(), give the new div an id like addInputDivX, where X is a unique number. Keep track of the latest x and increment it every run, then create another button with a removeInput method attached, that can document.querySelector('#addInputDivX') to find the last one added and then simply .remove() it codepen.io/zenador/pen/QdxdGr not ideal to use a global variable to track index, but it does work 
If (this.DEBUG) console.log('why dont you use this one')
It may not have been the primary problem with JavaScript dependency management, but it was one of the causes. If JavaScript had as many APIs as Java for example, node_module folders would be a lot smaller, and it would have taken a lot longer for something like the left pad fiasco to happen.
Because JavaScript doesn't really have types. In addition to that `+` already does far too much. It's used for string concatenation, addition and converting to numbers. Not ideal if you ask me.
[My hyperapp reducers](https://github.com/Max-Moolato/pizza/blob/25b5cd56dbf8fe38bf6229cd4566de85a787045a/source/client/actions.js) basically only consist of `...`.
Cool, thanks!
You have it backwards. this.DEBUG ?: console.info('Important stuff.'); is equivalent to this.DEBUG || console.info('Important stuff.'); not this.DEBUG &amp;&amp; console.info('Important stuff.'); The elvis operator is shorthand for this.DEBUG ? this.DEBUG : console.info('Important stuff.'); which is shorthand for if this.DEBUG this.DEBUG else console.info('Important stuff.'); 
Fucking PDFs.
Webpack doesn't implement import/export the same way that they are &lt;i&gt;likely&lt;/&gt; to be implemented. Edit: Check out /u/TheIncredibleWalrus' [comment](https://www.reddit.com/r/javascript/comments/5s5h9s/eli5_the_airbnb_rage_over_webpack_2/ddcsbez/) for better information.
 document.body.parentNode.removeChild(document.body); For what it seems like you want to do, this will probably be your best bet: document.body.replaceWith(document.createElement('body'));
Likely to be implemented in the next ecmascript*** Reddit's mobile site doesn't have the greatest modal for editing comments. Sorry for the double post.
They typically correspond to whatever version is released to npm at the time of update. [This file](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/three/index.d.ts) states it was built for 0.83.
I noticed a post on Medium today that linked to the PDF, they went a little overboard with the puns, but it's still one of the coolest fringe uses of Node.js i've seen. The Tessel is probably my favorite from a hacker perspective. 
 function foo (obj) { const { c = [] } = obj; console.log(c); } foo(obj); // [1,2,3] foo({}) // [] I think this is what you're looking for? 
Sounds interesting. Care to elaborate? :D
Ya know Buddy, how it is so hard for us to park at night now, and why sometimes there are loud parties that keep you awake next door hours after you've gotten into your jammies and crawled into bed, and why the neighbors trash is always overflowing and has lots of flies? That's because that nice young couple who moved in three months ago, the ones with no kids, started renting out three of their bedrooms and a den and a large closet and even their garage through AirBNB. It is rumored that webpack 2 will let home owners keep their homes safe from bad people in the neighborhood who break the law and abuse their neighbors and destroy a neighborhood and hurt the housing market by turning their homes into fleabag motels. So we hope webpack 2 will be the hero we need and deserve, which is why bad ole AirBnb hates them.
Would presumably have to be something &gt;ES7
I had no idea
yo bro you forgot to &lt;/i&gt;
You probably want to do something similar to this: http://stackoverflow.com/questions/4912092/using-html5-canvas-javascript-to-take-screenshots/6678156#6678156 It's not an exact screenshot, but it should be a fairly accurate representation of what the user sees on the screen.
looks amazing! what's the non-decorator HOC api?
Thanks, man. I'd tried this, but if I still wanted to keep 'c' a part of 'obj', I'd have to reassign like this: const { c = [] } = obj; obj.c = c; That feels really janky. Was hoping from something a little more elegant. It works though, and is readable enough.
Lots of (accidental?) globals
good luck with that.
This year's release was finalised, it's not in it. So likely ES2018
&gt; Recursive algorithms can almost always be rewritten with a loop, Isn't that *always* ? I believe it is *always* ...
I would just do function foo(obj) { obj.c = obj.c || []; // ... } Or if you wanted `c` as a variable function foo(obj) { const c = obj.c = obj.c || []; // ... } 
Modules are part of ES2015. Loader spec is WHATWG business not ECMA. Read my other comment for clarification. 
[removed]
Because Medium is more popular now. It's easier to promote your ideas there.
I published on npm the code that I use to transverse files recursively. https://www.npmjs.com/package/rfc-walk I managed to reduce the number of lines over time, now the code is just a couple of lines. I was using promises before, but I think a generator fits the task better.
I guess it just took a while for a combination of: * insignificant trademark infringement of an unpopular package * package author's other pages were used significantly * package author's reaction was removing said packages
A little fiddle thrown together to show the naming behavior of ES6. Tested on a Mac with Chrome 55.0.2883.95 &amp; 56.0.2924.87, Safari 10.0.2, and Firefox 50.0.1 &amp; 51.0.1. Chrome and Safari support ES6 naming anonymous functions. Anonymous functions are not currently named in FF 51. EDIT: To clarify, the anonymous function is named if it is assigned to a variable when it is created, and it keeps that name. If a new anonymous function is returned by another function, there is no name.
Great idea! Suggestions: * I’d create a completely separate helper function `displayFunctionName()` that displays the name of a function. Rationale: makes source code more self-descriptive. * I’d use more descriptive names for the functions: `assignedFunctionExpression`, `assignedFunctionExpressionWithParens`, `boundFunction`, etc. You can implement `displayFunctionName()` as follows: function displayFunctionName(funcObj) { Object.keys(funcObj).forEach(function (label) { var func = funcObj[label]; output(label + ' : ' + (typeof func) + ' - "' + func.name + '"'); }); } Then you can go from: fn3('fn3', fn3); // 3. Bound version of fn2 to: displayFunctionName({boundFunction}); Disadvantage: I’m using an ES6 feature here, where: {boundFunction} is an abbreviation for: {boundFunction: boundFunction} 
I'd never write any remotely critical code without types. Having somewhat important data show up as "NaN" or "undefined" can be a big problem. A couple of months ago, I was over in some other city at a larger bus station and the display which showed the upcoming departures only displayed some "undefined" garbage. I missed my bus, because I only had a minute to figure out where to go, and had to wait half an hour for the next one. This most likely wouldn't have happened if they'd used TypeScript.
Or `document.body.remove()` in recent browsers.
You mean the next nodejs, right?
Dude, my sentiments exactly!
&gt; [...] it reifies more strongly incorrect ES module semantics that will definitely break [...] ELI5 plz? For sufficiently large values of 5?
You want to "do Stuff." Presumably that means: cause some side effect. But the problem is, doing that stuff depends on something that takes time, and Javascript is synchronously executed line by line. That means that you'd have to pause the entire js thread to wait until your request completes before things could proceed. The answer to this problem is scope. Your "doStuff" stuff CANNOT be in the same, synchronous scope as any function that kicks off an async request without blocking things in that scope. Because that scope and everything else that might happen in it happens in the past, while "doStuff" will happen in the future. So whatever solution you find _must_ in some way involve working in a new scope. The solution is to turn doStuff into a function, rather than trying to do everything in mutable values and conditionals in the current scope. Once it's a function, it can be hooked up as a callback, chained onto a promise using .then, etc. doStuff can, if you want, inherit things via closure from the original scope (though that's usually a bad idea), it just can't BE something in the original scope. Promises are sort of a tricky way around this scope problem btw, because they are designed to act like first-class synchronous values (that happen to statefully execute functional handlers later on). In that way, they solve the scope problem, but still sort of indulge people in the vice of wanting to do everything with values sitting around in the same level of scope. Async/await indulges this even further btw, allowing people to write code that _looks_ like it's all in the same execution scope, but is, in reality, a generator churning out new execution scopes, each closing over the last.
The current es6 thing to do is Object.assign. You can use it in almost the same way, just with a bit more typing in some places, and a bit less in others. If you have an array of objects to merge, you can even use the array spread operator to spread it into Object.assign. That is, these are equivalent: Object.assign ({}, {key:value},{otherkey:othervalue}) Object.assign({}, ...[{key:value},{otherkey:othervalue}])
Nice! The project looks super dope. I have a couple of questions: Did you do the animations / art as well? I've never heard of pixi.js - what exactly did you use that for? Would you recommend it?
My friend (http://anumation.ca) did the illustrations separated into Photoshop layers, which I then imported to Spine (http://esotericsoftware.com). I was initially going to use GSAP, but trying to animate with code turned out be super overwhelming and spine offered an actual UI interface. The 2.5d animations that people have done with the software are amazing. Everything is also programmatic so 10/10 would recommend. Pixi.js is the webgl renderer used to actually display all the content. http://www.pixijs.com/