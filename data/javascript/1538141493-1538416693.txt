Are you a racist or something?
I've had senior developers fail at sorting integers. Yes, like "given an array of integers, how would you sort them? Any code, or pseudo code is fine." `[1,2,5,4,3].sort()` is valid. A loop of some kind would have been valid. Just talking about comparing the numbers would have been valid. This dude, a senior developer for a major bank, a lead of a team (according to the resume) - couldn't figure it out. It is such an easy, throw away question, just to get the candidate to relax and recognize we weren't going to be asking about performant loops or algorithms or extremely technical questions, and I've seen so many developers trip up on it, even after explaining that it's just an ice breaker question to talk about code.
Mobile only web dev? You can still use remote dev tools and even emulate slower CPUS to check that if you want.
It's a pretty bad question. It's basically looking for someone who memorized a specific MDN page instead of someone who understands why loose comparison causes bugs. You'd be better off asking what the difference between === and == is, or perhaps the difference between `if (foo)`, `if (foo != null)`, and `if (foo !== null)` if you feel like asking something more difficult. Maybe find an example in your code base where loose comparison caused a bug and ask them to figure it out. You really don't want to make the candidate nervous because they forgot about document.all. Give them a pragmatic question that they'll know the answer to if they've written JavaScript before, not something they'd have to study flash cards for.
Same thing but ask them to reverse the array. 
Because no one uses jquery anymore. ;)
what
I don't think Babel lets someone get away with knowing less. In my experience, programmers get into trouble by mixing programming styles and then not being able to understand the implications. For example, they start off using arguments and apply in a regular function, but then switch over to an arrow function to get the lexical this. Half-baked javascript knowledge can really bite people with ES6.
I sure hope you didn't get denied the job because you couldn't answer that question. That would be a pretty dumb reason to not give someone a job (considering you'll rarely use that knowledge, it's subject to change, and it can be easily googled)
I usually just point the interviewer to https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition when I get asked that. 
&gt; ADD is bullshit Maybe yours is. Mine's a pretty massive part of my life, and if I didn't have adderall, I would not at all be able to realize my full career potential. Even with medicine, it's still something I have to manage and be mindful of
I think so, yeah. Plenty of anecdotes. Something that would normally take me 3 to 4 hours suddenly took two developers 2 full work days to finish. It was just an endless stream of annoying TS requirements needing to be typed out. A shitload of interfaces for no apparent reason. We were not allowed to not use TS for an API that never changes and we still had to strong type every single bit in it. It was a pain in the ass...
Also, there's uglifying and gzip, so I mean, a slightly longer script isn't going to harm you nearly as much as a possibly difficult-to-read script just because you wanted to make it short
`function` is still preferred to arrow functions in many cases
That's not a senior developer
&gt; I would fail to write fizz buzz because I have no idea what it is. I'm assuming they would have told the candidate what it was if they were unfamiliar i.e. given them requirements. It's pretty simple at that point.
I am not sure I would ever do that. The purpose of the question isn't to give the best possible solution. It is to rather demonstrate understanding of async nature of javascript. I would thus stick with my `setInterval` solution, but explain how it is not a perfect solution. 
I agree with all this, except being early. Arrive exactly on time.
Not only that, but it's quite possibly the easiest spec to understand of all the new es additions
That would be useful to mention during the interview if you don't already do so. Not many new developers know jQuery.
And that's fine. There are other great developers that can come to the interview without smelling like their clothes sat in the washer for two days.
If you read the last line of my comment, I did say that the solution with `setInterval` is the most appropriate one. I am all for "If it ain't broke..." ideology, but I do believe that in an interview, stating that `setInterval` doesn't guarantee execution after timeout goes for showing that you have some understanding of asynchronicity in javascript. 
That's enforced arbitrarily by browsers. It's not a JavaScript question.
Oh golly, your like the person who thinks they can look at how clean a persons car is, and divine their prowess as a developer. So flimsy.
Show me one influential and successful figure in the developer world that doesn't dress nicely. People who don't do those things will stay at the bottom. Sure, you can get a job, but don't expect to be managing anyone any time soon.
and tits!
&gt; The general feeling of most people involved was always: "Gosh this was a mistake". - https://insights.stackoverflow.com/survey/2018#most-loved-dreaded-and-wanted - https://www.npmtrends.com/typescript-vs-vue-vs-react 
That sounds like a good problem for you to solve. Get to it!
I would recommend Immer as the best immutability solution at this point. 
They're just referring to a general problem of people using JS features without understanding why I inherited a project once that used Bootstrap modals and navs. It was a React Redux app. No reactstrap or anything, just a script tag in index.html. They were manipulating state in a modal controlled by jQuery and did not understand at all why that was bad. It happens a lot.
is it still relevant?
My point is: this seems like a standard interview question, meaning people spending time researching interview questions are in the advantage. Usually these are people with below average interest in actual development.
He was referring to JSX as react I think. React is perfectly usable with pure ES5 too. It's just a library.
It's a bad interview question because it doesn't test for actual JavaScript knowledge, just if you've studied your flash cards. Your job as an interviewer is to see if the candidate understands the core concepts and can apply them in the field, not to give them the programming equivalent of a 4th grade vocabulary test.
There's plenty of people who simply have bad breath, and nobody would tell them anything. It's not just about brushing you teeth.
I'm assuming he assumed this was a trick question &amp; .sort() was not allowed. Probably trying to remember the different types of sorts that he learnt in college
If you're not early, you're late.
No problem, any time :)
really nice to read your code! congrats!
Well, if that's what they think, I'd be a bad fit, since my worldview is not founded in nonsensical cliches.
We use it at work to solve some very specific problems we had that could not be solved by any other tool.
Reminds me of that Forrest Gump scene. Sorts are the fruit of software engineering. You can selection sort. You can insertion sort. You can bubble sort. You can heap sort. You can quick sort. Your can merge sort. You can randomize until you get the right order sort. You can use built in methods of arrays to sort. You can use third party libraries to sort. You can search pi until you find your array in sorted order sort. You can sort with a binary tree. You can library sort. You can cube sort. You can shell sort. You can block sort. You can cocktail sort. You can gnome sort. You can comb sort. You can patience sort. You can cycle sort. You can bucket sort. You can radix sort.You can wait until cosmic rays change your data into the proper order sort. That's... About it.
There's not really much to "vanilla js" though. If you are talking about Web APIs then I disagree. OP appears to be a high school kid or something. It's more important to start with fun and engaging projects that make you want to learn more. Whether you are reading the API docs for some DOM thing or for a library, you are essentially doing the same thing. Trying to comprehend what you are reading, trying to apply that knowledge, fixing bugs along the way. The advantage with using something like Phaser to make a game vs starting from scratch with a `&lt;canvas&gt;` and MDN docs in that setting is that you'll be able to produce something cool a lot quicker with the former. 
https://github.com/LeeCheneler/mr-yarn/
I don't understand your question. If your serverside is in Java, why do you want to learn JavaScript?
Many developers at all levels suffer from a sinking feeling that they are not good enough. Just remind yourself that at each step everyone who is more knowledgeable than you stood where you’re standing. Getting better at problem solving comes with practicing your craft and studying. I would combine hands on practice with either reading or watching educational videos. Try to solve easier problems but don’t stop. After you finish a problem look at other people solutions. Try to understand what it is they did. If they used a method you are unfamiliar with search for it on YouTube. If you spend just 1-2 hours a night learning new things in three months you will be much better. Honestly there are some days where I learn a concept and think to myself wow I am immediately better at my job for knowing this. TLDR: study and practice it’s a long unending road but you will get better 
"Fizz buzz is a group word game for children to teach them about division.[1] Players take turns to count incrementally, replacing any number divisible by three with the word "fizz", and any number divisible by five with the word "buzz"."[1](https://en.wikipedia.org/wiki/Fizz_buzz]) You would really fail this in an interview?
&gt;Show me one influential and successful figure in the developer world that doesn't dress nicely. RMS, Gabe Newell.
Unlock all answers for 9.99
Only in some circumstances. 1. Where `doThat` is not already bound to `something` (by another bind call, by some autobind call, by internal `self = this` usage etc) 2. Where `doThat` uses `something` as a `this`-object. If `doThat` doesn't touch `this` at all (e.g. because it's a class method) it won't need to be bound. 3. Where `doThat` isn't expected to be rebound to something else inside the callback. If you're dealing with jQuery-based code, it's often assumed that `doThat` will get called internally with a different context, and sometimes that's the desired outcome. (Although in this case the first-class function and the callback versions would technically have different effects.) (1) is the main one here - there's no point rebinding an already bound call (in fact, I've got a feeling that's an error, isn't it?), hence why you need to be careful about who's responsibility it is to bind methods in cases where it becomes relevant.
Because you, sir, are a man of culture and taste.
Usually these tiny things aren't make or break, but they tend to add up. If the person scores well in all areas, just their breath stinks, there shouldn't be marks against them. But it tends to indicate other underlying issues. Similar to how we have code smells, we have people smells. 
How to do shit without frameworks
This is kinda funny. Okay, so say the job requires C++, and an advanced understanding of the language itself. Sometimes datastructures, they're important, but leveraging STL, and other commonly used libraries is just as important, but also understanding how to use the debugger to figure out why something broke. Programming is not 100% about writing complex algorithms, there is just as much technical skill in debugging &amp; language acquirement as there is in algorithms. I posit that if anything, the other stuff is easy to pick up, it's the workflows that someone uses to work on code are more important. Lot of academics out there write code that turns into a horrible rats nest of garbage, but damn can they code themselves outside of a paper bag, but nothing they produce can be used in production as they couldn't give 2 flying F's about naming conventions or idiomatic worklfows within the language.
Really? Any one who developer who’s studied even a bit of CS in university will likely know atleast some typed language as well like Java or C++... I didn’t learn any JS in university actually and I know a lot of other great JS devs who are the same
My recommendation is practice, practice, practice. There are a lot of websites out there that will give you programming exercises and validate your responses. Start with the really easy ones and work your way up. Really try to solve each one, even if it takes you multiple days for a single problem. Some times it’s beneficial to stop thinking about a problem and do something else for a while. Your brain will continue working on it in the background in a different mode. This type of struggling, followed by the “aha” moment when you figure out the solution, is where growth happens. If you really cannot solve a problem, don’t be afraid to look up the answer. But if you do, make sure you spend the time to fully understand it, assuming you have the tools and you didn’t pick a problem far beyond your current level. Each new problem you solve will both increase your ability and add to your tool belt for solving new, novel problems. You just have to be willing to put in the work.
I obviously have no idea about you and who you are but just like everything else I'd like proof. Something supposedly so prevalent, especially in America should have a lot more detailed diagnoses than, "they dont pay attention". Also, I've done a quick Google search and ADD is not in the DSM-5 so it is definitively not accepted by that globally recognized body of "knowledge", but I also cringe to see ADHD is there but has no mention of chemical or physical changes are causing said disturbance. So it is, in my view at least... pseudo-science. "Oh a kid doesnt want to sit in his chair for 8 hours a day 5 days a week, yup he's fucked." ever thought you cant realize your career potential because it is dictated by the same environment that puts kids through such torment. Don't fool yourself we are a very very very small group of humans that have had to sit through that.
Good rule of thumb, when inside of a file, probably best to consider using a function, when in the scope of a class (object) or method / function, use an arrow function instead.
Jumping in here, have any recommendations for easy solvable problems online? I struggle time to time and feel my brain gets fried just from trying easy problems on coderbyte for JS, and want to try something new to build up my confidence in problem solving again..
Yeah I would love to do exactly this. Get someone to debug a real problem we had Never got around to saving a condition like that for a future hire I think it would say a lot about an applicant, if we can avoid the bias of preferring someone who solves the problem the same way that I do
Technically and truthfully, you are an ape with a keyboard. Keep solving problems.. over and over.. and reading other's solutions.
I'd start with Profiler
Yeah, but I don't even know what these are doing. I know a bit of JQuery I suppose. But I want a good understanding to code without any frameworks or libraries. 
&gt; while your first example is not Which example, and in what way?
IMO the best "challenges" are real world projects that you want to do something with. One recent interviewee had a family member with a business that they were writing a web app to help them with customer orders. That's probably a little ambitious for them because real orders need really robust code, but it's a great practice project even if they never actually launch it. Does Google have a new web API for some cool thing like text-to-speech or image-to-description or something? Try writing a page that uses it. Does the new Chrome have a new function like accepting speech input? Use it for something. Write a game. Clone a game. Especially something that hasn't already been made into a computer game. For instance, my family loves playing CodeNames and I wrote a version of it with an Express backend with Google Cast support. Then I rewrote it in Unity, also with Cast support. Then I rewrote it in React and Firebase. Sadly, the last version didn't have Cast support. Friends playing poker? Write a tournament schedule. Or a virtual bet handler. Just be sure to test it pretty well before playing a real round with it. ;)
Your example is correct (ish) but not necessarily sane depending on what's going on. Specifically you should only be catching when you can do something sane with the error. You aren't actually doing anything with the error, just calling `handleFormResponse` with an `undefined` response, but more generally some errors should actually be thrown (or rethrown) up to a level that can do something about them (and for some errors there is no sane way to deal with them). So you could, for instance, check the error and optionally rethrow it if you can't deal with it here. At the very least you'll want to `log.error` the error so that it doesn't just disappear during debugging. More likely you'll want to trigger some sort of error state for to inform the user that whatever they tried to just do didn't work. 
I'm curious, what's stopping you from migrating to a more modern stack?
Javascript is trivially easy for an experienced programmer - among the simplest major progamming languages that exist. Honestly, if you ignore the feeps and their helpful libraries, you can probably just jump right in. I'm going to assume you already understand HTML and HTTP. You can think of it like follows. ---- # Server `Node.js` is effectively your runtime, sort of like the `JRE`. Go install it. With it will come a package management tool, `npm` (node package manager.) . # Setting up the project Once node is installed, go make a project directory. Inside it, type `npm init` This will put you through a 9-question CLI questionnaire. Your project name must be lower case. Fill out the rest common sense. Hit return to skip things you don't know, like what the test command should be (none of these except license and project name are required. MIT &gt; GPL.) At the end, it will create a single file, `package.json`, which represents your project to `npm`. Node doesn't care even a little bit; it just runs javascript. View the `package.json`. The sections that matter early on are `scripts` and `dependencies`. Those list, respectively, the things you're going to teach it to do, and the libraries on which this project depends. For this example, there will be exactly one. The webserver. . # The webserver You'll need a webserver (think `Tomcat`.) I'd recommend `express` - it's simple, it's common, it's reliable, and there's very little bullshit. The mechanism for this project will be: 1. you create an object representing the server; 1. you attach "routes" one by one; 1. a "route" is 1. a string pattern match to see if that's what they asked for, and 1. a function that gives the response async 1. you're fucking done The API labor is just saying "i need to be able to do these three things, so, I'll need these three addresses to respond on the server." Since you only said you wanted one thing, I'm gonna attach two routes. ## Installing express Go back to the console, in your project directory, and type `npm install express --save-dev` What that says: 1. `npm` invokes node's package manager scripts 1. `install` tells node "go get the module named this and put it in this project" 1. `express` is the thing we want 1. `--save-dev` means "save this for developers," or, "when a developer installs my project, get `express` automatically" We'll clarify that fourth one later. Be reasonably careful when you install things from `npm`. There are bad actors name-aliking popular libraries with attack code in `npm`. It's rare, but it does happen. Don't accidentally go for a project with some similar name, like `express.js` or whatever. Look it up on `npm.com` first if you aren't sure. You now have a webserver installed. (There's actually one already in node, but, `express` is easier when you're new.) Look in the directory again. You'll now see there's a new subdirectory, `node_modules`. This is where `node` will stuff all the code it fetches for you. You'll notice there's a whole lot more than just `express` in there. Those are the things `express` requires. It's heirarchal. Holy shit do the turtles go a long way down. Node culture sure does like subdivision of modules; it's not uncommon for modest libraries to have dozens, or occasionally hundreds, of dependencies. . ## Making express do shit Let's hello world. This one is going to be needlessly verbose, to make it easy to understand every step. Later ones will pare that back somewhat. I'm going to write this code using Java terminology, rather than JS terminology, to make this easier for onboarding. Don't be too worried if the JS people hiss at the "wrong" words being used here. ```javascript const serverFactory = require('express'); ``` This loads the `express` module from disk and attaches it, according to some conventions you don't care about right now, to `serverModule`. What actually gets attached there is up to the module author, but, it's usually an object, or occasionally a function. For `express`, it's what Java people would call a factory function. We are going to just make a default server with no configuration. ```javascript const server = serverFactory(); ``` Hooray! We now have a webserver that isn't doing anything. Let's make it respond to `GET` requests on the root route. `express`, like a lot of node stuff, is written with asynchronous code in mind. It wants to pass you two objects, one representing the request that was made by the end user, and one which represents your hook for making responses, and then to just go on with its day and ignore you. Then later, when you're done hitting the database and amazon and reading tea leaves and whatever the fuck you're doing, you can call the hook and say "I'm ready," and the webserver wasn't blocked waiting on your slow ass the whole time. It's pretty convenient. . ### The handler First, let's make the function that would handle a response In this case, it's hello world, so we don't give a shit about the request and we can respond immediately. We'll send a `200 ok` and a trivial webpage response. ```javascript function ResponseHook(request, response) = { response.send('&lt;html&gt;&lt;head&gt;&lt;title&gt;Yarp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello, world&lt;/body&gt;&lt;/html&gt;'); } ``` Express will fill in the blanks with sensible defaults. Since we didn't specify MIME type, it assumes `text/html`. Since we didn't specify response code, it assumes `200 ok`. . ### Getting the server to use the handler Next, let's attach that function to the server we made. `express` thinks in terms of routes, so, what we'll say is roughly "when someone asks for the route `/`, use this function to respond." ```javascript server.get('/', ResponseHook); ``` Et voila. . ### Getting the server to listen Also we'll need to tell the server to go actually pay attention. It doesn't by default. ``` server.listen(8812); ``` Finally, you'll need to run your code. Save this to your project directory, possibly as `server.js`, and then ``` node ./server.js ``` And now, if you hit [http://localhost:8812/](http://localhost:8812/), you should see your hello world. You have a programmatic webserver running. You can bail with `ctrl-c`. . ## Full code That code, in Java-ish style: ```javascript const serverFactory = require('express'); const server = serverFactory(); function ResponseHook(request, response) = { response.send('&lt;html&gt;&lt;head&gt;&lt;title&gt;Yarp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello, world&lt;/body&gt;&lt;/html&gt;'); } server.get('/', ResponseHook); server.listen(8812); ``` Or, if you cleaned it up to be idiomatic: ```javascript const server = require('express')(); // server factory is called implicitly then discarded const ResponseHook = (req, res) =&gt; // handler function is declared as an arrow; shorter arg names res.send('&lt;html&gt;&lt;head&gt;&lt;title&gt;Yarp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello, world&lt;/body&gt;&lt;/html&gt;'); server.get('/', ResponseHook); server.listen(8812); ``` . # So let's make your actual thing This is really very easy. ```javascript const fs = require('fs'), // load the filesystem module server = require('express')(); // load express, make server const theFile = fs.readFileSync('bobIsYour.uncle', {encoding: string}); function doYourParsingOn(theFile) { const lineCount = theFile.split('\n').length(), fileLength = theFile.length; return { lineCount, fileLength, file: theFile }; } const fileParsed = doYourParsingOn(theFile), rootHandler = (req, res) =&gt; res.send( `&lt;!doctype html&gt; &lt;html&gt;&lt;head&gt;&lt;title&gt;Welp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;Line Count&lt;/td&gt;&lt;td&gt;${theFile.lineCount}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File Length&lt;/td&gt;&lt;td&gt;${theFile.fileLength}&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;` ); server.get('/', rootHandler); server.listen(8812); ``` # Convenience Of course, we don't want to have to know how to run this damn thing. Everything should start roughly the same way. So, go into your `package.json`, while you still remember how this works, and add a row to `scripts` ``` "start": "node ./server.js" ``` And now you can just type `npm run start` and it'll do its thing, like every well-written (ie, none of them) node project. And there. You're done. Except, you know, replace `doYourParsingOn` with the thing you actually want to do.
You smoking too much jokes. It's should not be transpiled like that
Javascript is trivially easy for an experienced programmer - among the simplest major progamming languages that exist. Honestly, if you ignore the feeps and their helpful libraries, you can probably just jump right in. I'm going to assume you already understand HTML and HTTP. You can think of it like follows. ---- # Server `Node.js` is effectively your runtime, sort of like the `JRE`. Go install it. With it will come a package management tool, `npm` (node package manager.) . # Setting up the project Once node is installed, go make a project directory. Inside it, type `npm init` This will put you through a 9-question CLI questionnaire. Your project name must be lower case. Fill out the rest common sense. Hit return to skip things you don't know, like what the test command should be (none of these except license and project name are required. MIT &gt; GPL.) At the end, it will create a single file, `package.json`, which represents your project to `npm`. Node doesn't care even a little bit; it just runs javascript. View the `package.json`. The sections that matter early on are `scripts` and `dependencies`. Those list, respectively, the things you're going to teach it to do, and the libraries on which this project depends. For this example, there will be exactly one. The webserver. . # The webserver You'll need a webserver (think `Tomcat`.) I'd recommend `express` - it's simple, it's common, it's reliable, and there's very little bullshit. The mechanism for this project will be: 1. you create an object representing the server; 1. you attach "routes" one by one; 1. a "route" is 1. a string pattern match to see if that's what they asked for, and 1. a function that gives the response async 1. you're fucking done The API labor is just saying "i need to be able to do these three things, so, I'll need these three addresses to respond on the server." Since you only said you wanted one thing, I'm gonna attach two routes. ## Installing express Go back to the console, in your project directory, and type `npm install express --save-dev` What that says: 1. `npm` invokes node's package manager scripts 1. `install` tells node "go get the module named this and put it in this project" 1. `express` is the thing we want 1. `--save-dev` means "save this for developers," or, "when a developer installs my project, get `express` automatically" We'll clarify that fourth one later. Be reasonably careful when you install things from `npm`. There are bad actors name-aliking popular libraries with attack code in `npm`. It's rare, but it does happen. Don't accidentally go for a project with some similar name, like `express.js` or whatever. Look it up on `npm.com` first if you aren't sure. You now have a webserver installed. (There's actually one already in node, but, `express` is easier when you're new.) Look in the directory again. You'll now see there's a new subdirectory, `node_modules`. This is where `node` will stuff all the code it fetches for you. You'll notice there's a whole lot more than just `express` in there. Those are the things `express` requires. It's heirarchal. Holy shit do the turtles go a long way down. Node culture sure does like subdivision of modules; it's not uncommon for modest libraries to have dozens, or occasionally hundreds, of dependencies. . ## Making express do shit Let's hello world. This one is going to be needlessly verbose, to make it easy to understand every step. Later ones will pare that back somewhat. I'm going to write this code using Java terminology, rather than JS terminology, to make this easier for onboarding. Don't be too worried if the JS people hiss at the "wrong" words being used here. const serverFactory = require('express'); This loads the `express` module from disk and attaches it, according to some conventions you don't care about right now, to `serverModule`. What actually gets attached there is up to the module author, but, it's usually an object, or occasionally a function. For `express`, it's what Java people would call a factory function. We are going to just make a default server with no configuration. const server = serverFactory(); Hooray! We now have a webserver that isn't doing anything. Let's make it respond to `GET` requests on the root route. `express`, like a lot of node stuff, is written with asynchronous code in mind. It wants to pass you two objects, one representing the request that was made by the end user, and one which represents your hook for making responses, and then to just go on with its day and ignore you. Then later, when you're done hitting the database and amazon and reading tea leaves and whatever the fuck you're doing, you can call the hook and say "I'm ready," and the webserver wasn't blocked waiting on your slow ass the whole time. It's pretty convenient. . ### The handler First, let's make the function that would handle a response In this case, it's hello world, so we don't give a shit about the request and we can respond immediately. We'll send a `200 ok` and a trivial webpage response. function ResponseHook(request, response) = { response.send('&lt;html&gt;&lt;head&gt;&lt;title&gt;Yarp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello, world&lt;/body&gt;&lt;/html&gt;'); } Express will fill in the blanks with sensible defaults. Since we didn't specify MIME type, it assumes `text/html`. Since we didn't specify response code, it assumes `200 ok`. . ### Getting the server to use the handler Next, let's attach that function to the server we made. `express` thinks in terms of routes, so, what we'll say is roughly "when someone asks for the route `/`, use this function to respond." server.get('/', ResponseHook); Et voila. . ### Getting the server to listen Also we'll need to tell the server to go actually pay attention. It doesn't by default. server.listen(8812); Finally, you'll need to run your code. Save this to your project directory, possibly as `server.js`, and then node ./server.js And now, if you hit [http://localhost:8812/](http://localhost:8812/), you should see your hello world. You have a programmatic webserver running. You can bail with `ctrl-c`. . ## Full code That code, in Java-ish style: const serverFactory = require('express'); const server = serverFactory(); function ResponseHook(request, response) = { response.send('&lt;html&gt;&lt;head&gt;&lt;title&gt;Yarp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello, world&lt;/body&gt;&lt;/html&gt;'); } server.get('/', ResponseHook); server.listen(8812); Or, if you cleaned it up to be idiomatic: const server = require('express')(); // server factory is called implicitly then discarded const ResponseHook = (req, res) =&gt; // handler function is declared as an arrow; shorter arg names res.send('&lt;html&gt;&lt;head&gt;&lt;title&gt;Yarp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello, world&lt;/body&gt;&lt;/html&gt;'); server.get('/', ResponseHook); server.listen(8812); . # So let's make your actual thing This is really very easy. const fs = require('fs'), // load the filesystem module server = require('express')(); // load express, make server const theFile = fs.readFileSync('bobIsYour.uncle', {encoding: string}); function doYourParsingOn(theFile) { const lineCount = theFile.split('\n').length(), fileLength = theFile.length; return { lineCount, fileLength, file: theFile }; } const fileParsed = doYourParsingOn(theFile), rootHandler = (req, res) =&gt; res.send( `&lt;!doctype html&gt; &lt;html&gt;&lt;head&gt;&lt;title&gt;Welp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;Line Count&lt;/td&gt;&lt;td&gt;${theFile.lineCount}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File Length&lt;/td&gt;&lt;td&gt;${theFile.fileLength}&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;` ); server.get('/', rootHandler); server.listen(8812); # Convenience Of course, we don't want to have to know how to run this damn thing. Everything should start roughly the same way. So, go into your `package.json`, while you still remember how this works, and add a row to `scripts` "start": "node ./server.js", And now you can just type `npm run start` and it'll do its thing, like every well-written (ie, none of them) node project. And there. You're done. Except, you know, replace `doYourParsingOn` with the thing you actually want to do.
I'm not sure what kind of problems you can find on coderbyte, but in general, I'd recommend working on real-life problems. Can be a simple game, a simple app, simple website, etc. Don't frustrate yourself on some algorithmic challenges (or at least, not only on them). In most real-life projects you won't need to solve any of them. To find a job a basic knowledge of some popular framework or ecosystem will be enough. And when you start your first job, you'll both see what else you need to learn, what kind of problems you need to solve and that you're actually doing really well. PS. I wrote my answers assuming that you're killing yourself with algorithmic puzzles cause it happened in my case. In my highschool I thought I can't code cause many other guys were so much smarter and better at this than I was. But then I got into frontend, was hired and suddenly I was doing great. Then I actually got back to coding and I'm a lead developer of a pretty complex project for many years now.
I code review any code submitted by junior or intermediate developers and if they pull shit like that I'll not merge it period. I also found that having a sufficiently complicated setup with Typescript, gulp, SCSS etc. is often enough to force them to learn the basics because otherwise their code just doesn't work. I also have numerous pre commit hooks in place that reject any code that doesn't pass eslint and conforms to our editorconfig setup. Code also automatically gets rejected if they don't stick 100% to our git flow workflow.
Minor point, but this will sleep an extra second at the end.
I also came from a Java background and the number 1 advice I can give you is to not force Java principles and design patterns into JS, it doesn't work. Also Typescript is your friend, you'll feel much more at home using it over vanilla Javascript. Organizing a big project is a pita in js so stick to batteries included frameworks that already provide you some sort of structure. Personal recommendations: Angular, NestJS
I'll take a stab in a different direction here. Here's my attempt at a way to practice and increase the skill. Next time you have a problem, a bug is a good example, stop and slow down before jumping in. Make a list and write down everything you've seen so far about the bug on a sheet of paper. Then write out what you could test around each of those observations - such as "the error happens when I click XX button, now let me try that when it's in YY state". Then methodically do each test and note the results. This is slowly narrowing and exposing the bugs' true source by testing all around what you currently know. At some point you'll have an 'aha moment' as one of the tests will logically reveal the area where the bug must be logically. This is problem solving to me - the natural ability to track many pieces of info and combine them to make logical deductions, until finally the right answer reveals itself, or at least a new direction to test. Personally I've found people are unable to track too many things in their head. Or they can't follow complicated logical trains of if A, B, and C, therefore D. Writing it down slowly might give you the practice to increase your skill of doing it in your head, and on the fly.
That's my question as well; what would this offer over bundling.
From what I've gathered from my doctor, psychologist (who diagnosed me), and therapists, "ADD" is actually no longer used and has essentially been replace with "ADHD". The H (hyperactivity) doesn't necessarily insinuate hyperactivity of the body, but rather of the mind (it is very common for people to correlate ADHD with just a kid who can't sit still). I don't think you're too far off in calling it pseudo-science because of the fact that brain disorders are still just very misunderstood. Human brains are an interwoven mess of millions of years of evolutionary changes competing with each other. You're also very correct in saying that the way our society views "success" (in both school and the workplace) is generally unfriendly to people with brains like mine (I'd say "people with ADHD" as a shorthand, but I can't say where the line is drawn between brain disorders). This obviously isn't the case in every school or workplace, but it's definitely in the majority. I will say, though, that it's not *only* societal structure that I have trouble with; it's even basic things that I'd imagine anyone in any society would recognize as "how people should behave". Things like having a social life, cleaning my apartment, renewing my driver's license on time. I actually was intending to explain some ways that my personal life suffers, even on medication, but I'm running very late to work and need to go get a shower (not even kidding)
**o**bject, **k**ey. It's about as obvious as writing `for (let i = 0; i &lt; foo.length; ++i) {...`
Be formal. Treat your code like you treat your mathematics. Make sure everything is well defined, not just the code, but also the problem. And note that an ill defined code plays games with the mind. And do not approximate, and do not assume. A consequence of the above is that you will also avoid many features from a technology that you are using because of its ill definition. The point is, when I say everything, I mean everything.
In my experience interviewing a ton of companies throw you out of the running for simple things that you can look up online. I got thrown out of one interview because like a dummy I forgot to put const in front of my react component during a white boarding interview. That’s not only something you can look up online but something that your code editor would let you know pretty much immediately.
&gt; async/await is not part of a widely supported JS spec yet. async/await is supported in every major browser and the last 3 major versions of Node, including versions under LTS, and is formalised in a completed standard. How much more widely supported can something be? 
I'm actually willing to say 100%. The correct answer to any interview question involving setInterval is \*why you should never use it\* - [https://www.zcfy.cc/original/why-i-consider-setinterval-to-be-harmful-zetafleet](https://www.zcfy.cc/original/why-i-consider-setinterval-to-be-harmful-zetafleet)
This is in the context of job interviews. "Invert a tree" and "sort this list" kind of problems. I've seen a candidate who reallllllyyyyy wanted to show off that they knew what call/apply/bind was, so would write out, fully, on a whiteboard, `myobject.mymethod.apply(myobject, [arg1, arg2])`
I mostly use Jest as I tend to work with React projects that require accompanying snapshot testing. I have also used Mocha, and it isn't too bad. I would say Jest is my favorite.
Interesting. Keeping an eye on these projects :)
Really, you think I didn't know that they were supposed to be abbreviations for those words? 
I work with React mostly as well. Would you say that Jest is the best for the main front end libraries (React, Angular, Vue)? 
Yup that's definitely silly (and reminds me of the sort of thing I see "clever" programmers do on a regular basis). But even in interviews, people can get marked down for coding a working, but not elegantly simple, solution. My general approach is make it work, *then* make it better.
Realized I made a mistake and have edited. In the catch block, it now uses error instead of response. 
That sounds fun too! I suppose writing a chess game is on my list! Or something like Space invader! You think this is also a good portfolio item though?
I've thought this might be the best option. Is it generally acceptable to mix promises and async/await. I understand that they are both promises, but stylistically is it accepted?
`e ` is a variable that hold the value of key you want to delete, yes? i.e. `e = "user_id"` `delete users[i].e` will delete the thing `e` from `users[i]` i.e. if `users[i]` looked like this `{e: "I'm going to get deleted", user_id: "I'm not going to get deleted" }` you are deleting `e`, not `user_id`. To delete the *value* of `e` use square bracket `[]` access: `delete users[i][e]`
Due to clock drift it is possible every one of those would execute one after another, which is probably not the intended approach.
Mocha. It's simple, it works with async, and has watch that finally works as expected.
IMO, this reads like a print version of the MDN website. I'd recommend MDN instead because it'll be kept up to date and is thoroughly reviewed by professionals constantly. Seems like some of the later content could be helpful, but probably not much moreso than a Google search and stack overflow.
This answer was collapsed, and I just knew before expanding that rms will be mentioned.
It's up to both the interviewer and the candidate. If you use the question verbatim, get a robotic response, and move on to the next question, then it's a bad question. You can use it well though. As an interviewer, you can ask, how might this cause a bug in production code? An answer might be: you want to capture a numeric value from a text input or regex group and do numbery things with it. "0" as a string is truthy. As a candidate, you can say "I know the string "0" is truthy because I ran into bug xyz, so I looked it up and the other falsy values are a, b, c."
In general, mocha + chai React - Jest (+ Enzyme) Angular - Karma + Jasmine Although you can use other frameworks, these are installed by default. They all are pretty much same. So start with mocha + chai maybe. You will learn how to set up any test frameworks that way by not sticking to the default ones. But what's important is to know what and when to test. And how to write a testable code. Nobody gives a shit if you know syntax or how to use Jest/mocha/chai.
Absolutely. A chess AI is way more complicated than you think, but a 2-player chess game would make a great portfolio piece even without an AI. Space Invaders also presents some nice opportunities to show off your skill. Just be sure not to violate any copyrights.
&gt;Would you say that Jest is the best for the main front end libraries (React, Angular, Vue)? It's hard for me to comment as I have yet to use Jest with Angular and Vue.
Stylistically, JavaScript is the wild west. We can't even agree on semicolons But I use eslint with a pretty draconian ruleset and it doesn't complain about this pattern.
Unfortunately most of our projects must be ready to going live within a few days to weeks. Our customers don't care how we did it. Pros are that we can involve most juniors into any project as they can code it how they want. For smaller or simple tasks it doesn't matter how dirty their code is. But now take these low standards into any serious project of ours. Without any review everything get's more chaotic and buggy the larger the project becomes. It get's almost impossible to maintain and every developer joining the project has two choices: Either invest more time than the Project Managenent planned to fix stuff or make it even worse with dirty workarounds that have a heavy impact on the applications performance.
Gotcha. Thanks for the great information anyway!
so would I fail if I pointed out that three out of these four examples will have the same result? ;) 
I’m would assume he was given instructions.
Here is why I think it's probably not a great solution: [https://www.reddit.com/r/javascript/comments/9jg5du/what\_are\_some\_basic\_things\_that\_javascript/e6szwg9/](https://www.reddit.com/r/javascript/comments/9jg5du/what_are_some_basic_things_that_javascript/e6szwg9/)
Thanks for this, that's my homework for the weekend. I work with is everyday, and my code is tidy and on par with almost everyone in my office, so it's hard to see where I'm going wrong! And finding areas of improvement can be tough. Thanks! 
You left out God sort! Any array you get passed, well, someone or something made that array. And theres no way it was made in a random fashion, therefore an ordering already exists, and as such, the array is already sorted, even if you're not capable of understanding how. Just have faith that its sorted. Never forget the famous sleep sort! https://www.geeksforgeeks.org/sleep-sort-king-laziness-sorting-sleeping/
It's basically just a backend for rollup.js at this point.
I'm not seeing what value this provides over functions and `new Promise`: const timeout = promback((ms, cb) =&gt; setTimeout(cb, ms)); const resolveFive = promback(() =&gt; Promise.resolve(5)); Could be written without a library as: const timeout = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms)); const resolveFive = async () =&gt; 5; 
or "what equates to false"... why are we using the word 'falsy'?
The whole point of fizzbuzz is that research doesn't matter. It's not about testing whether you can explain promises vs. callbacks or something, it's literally can you write basic code.
LOL that's great.
it's kind of like rejecting all developers that don't code in their free time. like... some people have lives outside of coding
Agreed, although in a way it's not, because engineering expertise is very difficult to quantify. That's why I &lt;3 fizzbuzz: even though it's the absolute most simple test of it, it actually tests "can you write code", something with endless questions about big O notation won't.
shouldn't it be `...` `let e="user_id";` `...` `delete users[i][e];` if you use the dot syntax you are referring to the literal key as noted by the property name after the dot. If you want to refer to the keys dynamically (via a variable holding the key's name) you have to use the brackets syntax. In your case the "e" in delete users\[i\].e is looking for a property named "e" not "user\_id". &amp;#x200B;
... there are ES5 lambda functions?
Fizzbuzz is a problem written specifically designed to only require the most basic understanding of programming. Its not an algorithm, it's just a very basic list of requirements. Like, legit, if you can't go from hearing fizzbuzz to solving in 5 minutes, you can't write code. There's no tricky gotchas, there's no analysis, there's no esoteric knowledge required. It's just straight up, can you use a loop, and can you use conditionals. The question became famous because it's so easy to solve. It really is just an absolute bare minimum for being able to write code.
Nice. Hope they are as good as syntax.fm and shop talk.
I don't think anyone else has mentioned this yet, but have you tried delete users[i][e]; ...?
Thanks! Appreciate the answer
I use them, but not to weed people out, but to help* differentiate whether or not the candidate is eligible for a "senior" position. If someone claims on their resume that they're a JS 'master', then I will posit questions that will determine if that is true or not. If they don't claim to have advanced knowledge, then I won't even offer the questions up. Also, for the exceptional candidate that undersells themself (happens a lot with the brighter set of candidates), I'll often ask a few of these as 'bonus points' just to tease out exactly how humble they are and how much they may know beyond our standard assessment. \* this is not the sole criterion
&gt; It means they haven’t learned competing patterns or have any formal language theory. IMO, who gives a shit? Your front end devs are generally going to be using a framework with most complexities abstracted away. I'm much more interested in their ability to write working maintainable code than how many fractions of a fraction of a second they can shave off my render time. 
Hi /u/FlandersFlannigan, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/xynaxia, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
`delete users[i][e];`
I usually ask what a closure is. Every js interview guide everywhere has something about closures. Only about 50% of people can explain what a closure is. Don't people prepare for interviews anymore?
Ok, first off in case you were thinking I made them do this on paper or something I didn't, I handed them my laptop with a professional IDE (WebStorm) opened. Maybe my keyboard was slightly different from what they were used to, and *absolutely* interviews stress people out and make them take longer. But again, we're talking one `for` loop and 3-4 `if` statements. If you truly can't write that in &lt; 10 minutes while under some stress, I really think our company would be better off picking a candidate who can.
Don't be an asshole. They're debating in good-faith while you attack spelling.
Turning a hot cpu bound loop that blocks UI into cooler one that frees up rendering (async, event loop, basic perf)
It's being called literally once a second. 
Agreed, this is how I write JS now and I like a lot more. The only hassle is converting old stuff from callbacks to promises but it is well worth it. I can never remember how to do it off hand though, my answer above is based on what I can write from memory into the console. 
My best advice is that you should set aside what you know about Java's OOP and learn how JavaScript deals with OOP. Because if you keep trying to work with JavaScript as if you would on Java it's going to limit your learning of the language (mostly its idioms).
Sure, but if it's not necessary, it's not necessary, and historically there have been performance issues associated with calling bind, especially if it's used at every callsite. Understanding these tradeoffs I think was what the person was getting at with the overuse of arrow functions.
The parameters for the iteration function are "previous" and "next" so using "o" and "k" doesn't make the intent very clear until you read the rest of it. Agreed with cortekkk on this.
Codewars is a really good start. https://app.codility.com/programmers/lessons/ is also pretty good. First you read some basic material on the topic, then you try to solve tasks. The good thing about it is that you can find solutions with explanations for all of these tasks online. Solving difficult problems is incredibly challenging at first. There are 2 things I've learned that really help me: 1. Read the task description carefully, visualize what's happening. For example [here](https://codility.com/media/train/3-PrefixSums.pdf) is the reading material for the "Prefix sums" topic. Read through it and scroll down to the Exercise, which is "Mushroom Picker'. They even give you a solution. Well I can tell you, that I've spent hours trying to understand it and wondering how this problem could even be solved. Then I realized that the problem was about someone, who picks mushrooms. That means he can't pick them up twice. And I assumed it was possible and that you just had to go one way and then the other and add those numbers again. Wasted so much time because I didn't read the problem carefully. 2. After failing to solve a few of those and finding solutions with explanations for them on the internet you'll see 1 common theme. And it's hidden in these words "Looking at this task we can make an observation...". Most of explanations for the solutions start with these words. It means that you can't solve most of those problems head on efficiently(which is required). In order to come up with an efficient algorithm you have to see something about the data and domain you're given. See some pattern or an opportunity to make a guess which would help you solve this if it turns out to be true. Don't beat yourself up if you don't see those at first. Once you learn them you'll start to recognize those patterns or parts or combinations of them. I've also started studying [this book](https://cses.fi/book/book.pdf) on competitive programming which seems to be pretty awesome. I think there are lots of techniques and knowledge in it that can help improve ones problem solving skills.
Given the task, the reasoning you've given actually makes it a better solution. If the task required &gt;1s intervals then yes you'd be correct, but for a 10 second counter you'd want the final tick to occur as close to 10s after the initialisation as possible.
I stumbled across JSPM again the other day, it was years since I last saw that, and apparently that's still somewhat relevant. I think it's trying to reinvent itself as an ES module-aware version of unpkg.
Let's make JSX a part of JavaScript.
I see, that makes sense. At first I was wondering why'd you need a loader for a bundle, since those are loaded with `&lt;script&gt;`, but then I realized that the bundles can be inter-dependent.
I'm also in an agency with similar time problems. Trust me it's worth it and once you've implemented it once you can just copy and paste the solutions across projects.
[removed]
It's being called literally once a second. 
CTO: "Let's see, I need 50 hours of developer time over the next 4 weeks to remove jQuery from our entire webapp." Boss: "Okay, why?" CTO: "Because someone on the internet told me to." [Removing jQuery from a large, functional, webapp is not a task to be taken lightly.](https://githubengineering.com/removing-jquery-from-github-frontend/)
testcafe is kind of amazing. You can learn it in an hour or two.
A few months ago I started a project where I wanted to use bootstrap, then I wanted to add navs and modals, seeing the dependency on jquery I wondered how to get rid of it when using react, I checked reacstrap to give me an idea of how to do it. While I was looking for documentation I found several examples of using jquery with react, I'm not an expert on react but I know that is a no-no.
&gt; That's because immutability is a concept with niche utility in state management, which is not ubiquitous. I'd posit it's the other way around; shared mutable state is only adequate in advanced, niche contexts, like when doing updates in a tight loop where persistent data structures are not efficient enough. Most programming is not that, though, and benefits from the reduced complexity of being able to reason about state independently of other parts of the program which might change it. Unintended changes and sharing are a major category of errors.
&gt; You know that Typescript does not force you to use types everywhere, right? I know ;) &gt; If you mark something as any you can use it as simple javascript. You can be as analytical as you want. Yeah and I've seen *that* happen, too. People get rushed and suddenly everything is an `any` and then the question becomes: why have it around to begin with? &gt; Writing model code that is going to be called from a ton of controllers? Make sure you be as analytical as possible. Writing a simple function that exists only for organizing existing code (refactoring), don't be analytical, write simple javascript. I agree with you 100%. I think there is a perfect setup for TS: not too strict, but certainly not too loose. Personally I think it should be an always-optional progressive-enhancement tech. Certainly not an always-on feature. &gt; Having the power to make important code strongly typed is a big pro! I still haven't seen any real use-case in favor of it, sorry...
I read a book, cracking the coding interview, which contains a bunch of example problems. Doing the problems then reading the answers was most helpful. Regular practice is key, I find it is like math. 
This doesn’t work either, but when I ran it in a for loop it worked fine.
Falsy is a pretty widely used term. And equates to false doesn’t really distinguish between is false or evaluates to false to me. E.g. Which of these equates to false !someInput -or- someInput === false 
&gt; doThis('foo', function () { something.doThat(); }); Honestly, I write code like this, but I have a reason. I would probably write it as a fat arrow, but the idea is the same. - - code clarity. &gt; doThis('foo', something.doThat) Will of course work, but at a quick glance, doThis looks like a synchronous function with two parameters. By using a lambda it is more clear that the second parameter is a callback. 
To be fair, I haven't touched jquery in years and might need 25 minutes
I just normally prefix google searches with "mdn"; I even had set up a keyword for that so it'd use "I'm feeling lucky" to go directly to mdn, but I keep forgetting to use it. I also have a [devdocs.io](https://devdocs.io/) open in one screen permanently. Then there's the code intelligence in vscode, which let you see function signatures as you type.
Totally. The `class`, `this`, and `new` keywords (in particular) have wildly different behavior from their counterparts in Java.
"I saw 'Black Panther' in the theater, but I waited for 'Selma' to come out in blu-ray?" 
[removed]
This story seems implausible to me. 
We have this same problem. We use Jest and ts-mocks, which pulls in Jasmine. So Jest and Jasmine's globals (describe, it, etc) collide. We worked around it by adding `skipLibCheck: true`.
What a great answer. I'll just add that solving non-software problems in an unrelated hobby is also very helpful. If problem solving is not related to a specific domain, then any domain can teach you how to solve problems through experiences. I think just focusing on one domain limits the total pool of potential problems to solve, why not solve ALL THE PROBLEMS! Anyway that's just my anecdotal experience, and I think I'm a decent problem solver. My problem solving hobbies include woodworking, home improvements, playing guitar, playing pool and video games, and photography. I also watch very little commercial-free TV, focusing instead on instructional YouTube videos (usually related to my hobbies), which I find more interesting anyway.
Any function not bound to an identifier is a lambda function. doThis('foo', function () { something.doThat(); }); That secondary argument in `doThis` is a lambda. ES6 lambdas (what the JS community also calls "fat arrow functions") are more terse than ES5 lambdas, and have different lexical scoping rules.
Good catch. 
So tangled up.
ReactJS is a framework built on JavaScript. Look it up. I'm talking about writing pieces of jquery inside a ReactJS app or using part es6 features with es5 globals elsehwere, and on, to the point it doesnt show they understand any of them deeply. But then again, this is Reddit so you either you have no idea what you're talking about or else you realize I'm making a point in 1 paragraph and not writing a dissertation on various flavors and frameworks and you're being a fucking smartass, in which case, thanks, this thread has really benefited from your input and I will reconsider the whole future of my career based on your infinite wisdom.
If you couldn't explain *why*, then yes. You would fail.
I'd never heard of fizzbuzz before and it took me 2 minutes. And 90 seconds of that second guessing whether I'd misread the question cos it seemed too easy.
I'd fire you for not putting the increment in the for loop where it belongs :)
Third argument of `addField()` is a 0-based index of page number. If `q` is equal to the total number of pages, the field would be added into a non existing page.
My man
Hi /u/Proxy9000, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
Hi /u/Collaba, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Look at all of that extra code. By that point, why are you even using async anymore? Just use the promise.
Hi /u/Javaguru128, this post was removed. Please see our rules, and do know that 'Java' !== 'JavaScript'. Thanks for your understanding.
Wouldn’t instanceof work for the errors ?
Is that really a workaround? Don't you just basically turn off type checking for all files that require a declaration file by setting that? I believe that vscode ignores that and gives you warnings/errors anyway, but if you have someone using a different editor then I think you could end up in situations where they push code with type errors. I think it's wiser to explicitly specify what types you're using, and then use skipLibCheck as a last resort. Do correct me if I'm wrong though, I'm not even close to an expert on TypeScript. :)
Well I started into card magic and cardistry a couple months ago, so one of my hobbies is already kinda solving problems (or puzzles?) so... yes, I hope that helps haha
Come up with a small project that's just a *little* beyond your current comfort zone. Break it down into a handful of major tasks, and scribble down a *brief, high level* description of what each of those parts needs to do. For each part in turn break it out into smaller parts that combine to solve the problem the larger part was solving. Now for each of *those* parts do the same thing again, and again, into eventually you'll be solving problems that are about as complex as a line of code or two. Now start writing all those classes and functions, and by the time you've finished (making a few more decisions/doing a bit more task-decomposition that you missed the first time along the way) you'll basically have a working program that solves the problem. # Tips: Don't go too in-depth at any stage - any time a part seems to be too complex, pull back and consider it in *less* detail, not more. You're shooting for a lot of layers with very little detail in each one, not a small number of layers where each one is very complex. Try to describe *what* each part needs to do, and don't worry too much about *how*. By the time you get down to individual problems like "connect to a database" or "order the items in the list by date" or "output the to-do item to the screen" you'll naturally be working at such a low level that "what" *becomes* "how" automatically. If you have no idea how to solve a particular step *and* you can't step back a bit and express the solution in a simpler, higher-level, less-detailed way, it's possible the project is just to complicated for you at this stage. There's nothing wrong with that, but consider shelving it and coming back to it later when you're more experienced, or try asking for advice from more experienced devs.
I see many people make the argument: 'You need to know how promises work and the underlying logic behind async/await', and yet I have never met a developer, online or in person, who uses async/await without a full understanding of promises and async paradigms. I think async/await is appealing to those that have used promises and like the cleaner looking code. I imagine it's difficult to grasp the functionality of async/await without first grasping the core functionality of promises.
Oh -- I meant my computer is dead and that I'm stuck using my mobile for development, lol. Only working on CLI apps &amp; libraries (NodeJS, Bash, Command/PowerShell), but these kinds of projects were also my favorite while the PC was running. I learned about the remote dev tools while trying to figure out how to access the Chrome browser dev tools on mobile, but yeah it's of no use without a PC unfortunately. Thank you very much for trying :) Sorry for the confusion, lol.
Pardon me, but what is AMP? And why is it such a problem? I am a noob, sorry.
It turns off type checking for third party modules. I don't know of any other way to accomplish this other than not using ts-mocks. The error doesn't occur in the editor, it occurs when running tests. The compiler complains that `describe` and the like are already defined. Since we have type checking turned on in ts-jest, this prevents the tests from running.
Problem solving is a transferable skill. Think in a methodical way even when not coding. Think about how systems work and where the points of contact are, attempt to figure out solutions for even mundane things by thinking like an engineer. Learn how things work and always be curious about how you could do something better and reform it. 
This. Move "data-goto=2" to its own attribute, so the resulting HTML would look like this: &lt;button class="btn-inline results__btn--next" data-goto="2"&gt;…&lt;/button&gt; The second issue is trying to access the attribute; your first attempt accessing the `.dataset` property was the correct way to do this. With `data-*` attributes, accessing from `.dataset` you remove the "data-" prefix, so in your case the accessing JavaScript would be: document.querySelector('.btn-inline').dataset.goto Just to note, JS does not recognize hyphens as valid identifiers, so the second access to dataset `.dataset.data-goto` actually was trying to *subtract* `goto` from the value of `(...).dataset.data`. Notice how the first failed attempt returned `undefined`, and the second threw an error. More information on the dataset API can be found on [this MDN article](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset)
Thank you for the feedback. Yeah it's maybe poor examples, they are more on api of the library, than use cases (part on a use case follows the usage part). The point of the library is to be used as part of some api, where an async (i.e. callback-calling or promise-returning) function is expected, to wrap it and turn into a promise-returning one. This simplifies implimenting the api, and you know that after wrapping the async function in promback, users of the api may use callback (passed by promback along with the api-dependend params) or return a promise to their liking and convenience and simultaneously, on the api part you only work with promises.
I've had candidates coming from a C# background that know async/await since that's been part of that language for a while, and thus that's how they write their JS. But they absolutely fumble promise chains or promise.all() etc. They sort of skipped over the "legacy" stuff, even though that stuff is still very much a reality in our production code.
Worked for a year with TypeScript, now probably like a month with Flow (hard to measure, I work on more projects). I strongly prefer TypeScript. It has for most part more/better features (only slightly worse inference) and so much more and up-to-date type definition files, often packaged in packages directly. Compared to flow, where I have issues even with very popular libraries (e.g. redux or even the built-in react types), it is simply incomparable.
Also, having opinions. Whether or not I agree with them, I'd like to know if they've thought about why certain practices are good or bad.
How on god's green earth is this so highly upvoted? Do people not know what FizzBuzz is? It's one on from Hello World. If a candidate fails this, you throw them out the window.
I meant that even if you set skipLibCheck to true, you'll still get Type Errors in the editor for everything else, but not when you compile your code. It turns off type checking for everything that isn't a .ts file, so if you have any .js files in your project that you've added a .ts.d file for, it will turn it off for that as well. Not a problem if your project is 100% TS, but if you're migrating from js it can be a pain. My problem with skipLibCheck is that you lose type safety for every third party library with it turned on, which it part of the strength of TypeScript.
Yeah that’s true, though in my experience these are not issues that I care about since I’m catching them right away during unit/manual tests.
&gt; mostly due to it having string literal types long before TS did Can't use string constants though, which does severly limit anyone who uses Redux (or something similar). I've used both Flow and Typescript and I would recommend Flow if you work for Facebook, Typescript for everyone else. Flow lack documentation (The very usefull $ReadonlyArray literally isn't mentioned on the website, only way you can find it is by checking Github issues), there hasn't been any communication over the official Twitter or from the official Blog since May and you would be lucky to get a response from someone from the Facebook team on an Github issue. HOC's have been broken for us for months, I'm sure it has to do with something that we/the community is doing wrong but withouth documentation or a response from someone from Facebook it's very, very hard to debug. Add to that the fact that they guy who maintains the VSCode Flow plugin has switched to TS 1.5 years ago (props for him for still mantaining it!) and I think we have a clear winner. Seriously, go with TS. I serverly regret our choise to go with Flow for this project. TS has won the battle. 
Point taken.
I don't see why you wouldn't be able to do it. It would just require a decent amount of manual wiring. There is always some event some action that triggers removing things, and you'd need to go down the tree releasing stuff. It's a bit much to ask a developer if it is a very nested tree. I've written conventions around this before, with Knockout for example can have the same issue and it would trace through nested objects where the thing being subscribed to outlives the view. This was actually one of the biggest thing that attracted me to Adam Haile's S.js which gives an easy way to register release handling as you develop. That's the core underlying change management library behind both Solid and Surplus which are both sitting near the top of the list in performance. So if I was looking at Stage0 or DomC I'd definitely consider using with something like webcomponents. I think that is still true of something like Solid or Surplus as well because even with easy memory management mechanism the change dependency can get too wrapped up at too many levels of nesting if you aren't careful. Having clearly defined boundary API really benefits libraries which have the ability to go right down to the metal. It gives you gradual learning curve as you keep things small and also on the other end lets you encapsulate easily when you go down to the metal. Especially when you are dealing with DOM node specific manipulation. It is true in these cases you end up having to atleast think a bit about your components lifecycle since it isn't prescribed, but it gives the flexibility to scale out your library code independent of these modular concerns as you get started is nice because it doesn't necessarily trap into some pattern that is necessary for modular code maintenance that is more expensive later as things grow. I think Stage0 particularly is a good fit with webcomponents. When dealing with something at such a modular contained way that level of power fits really well in keeping things simple and very very performant. At which point encapsulating the close./open api in a resuable component doesn't seem terrible. Without webcomponents you can do this too, but atleast when considering my team I'd want to develop a few tools to prevent handing them footguns. I mean not every junior dev is conscious of their memory leaks, and I don't think you need Webcomponents to do this. But with this sort of library definitely would consider some additional helper functions maybe make a base class for them to build off of etc to take these types of considerations off their hands. If I didn't feel comfortable with that, I'd probably just pick a React or whatnot anyway. I'm saying this too as the author of Solid. I'm a big fan of stage0 and have shamelessly lifted a few approaches from Freak\_613's libraries to improve performance in my own. It's all a matter of comfortable abstraction, from the aptly named stage0, through to something like Surplus, then Solid, then some of the lighter Virtual DOM libraries, and so on. I think the hardest thing to see from the results themselves is how the objectives in terms of dev experience and abstraction changes. Like when you consider that something like ivi is a Virtual DOM library and it is that performant, it's incredible. It is not apples to apples comparison. Most of the things that people can ignore or take for granted in a library like React that you can't with say Stage0, ivi handles. When I look at the top 6 libraries I see: * DomC the most performant declarative data bind library * Stage0 the most performant core DOM binding library (jQuery X) * Solid the most performant State driven JSX library (React-ish) * Surplus the most performant fine grained library * Ivi the most performant Virtual DOM library * Inferno, the most performant React replacement library All of them have their own claim to make and all the authors have done an incredible job tuning and optimizing their performance and building towards their desired experience. I like that this benchmark gives an opportunity for these sort of libraries to get attention.
When formed as an open-ended question, some of these questions are great for gauging a candidate's seniority. Here are my picks, based on the post: * ~~Q1: What is Coercion in JavaScript?~~ * ~~Q2: What is Scope in JavaScript?~~ * Q3 (modified): What is the difference between `===` and `==`? * Q4 (modified): What is a callback? * ~~Q5: What does "use strict" do?~~ * ~~Q6: Explain Null and Undefined in JavaScript~~ * ~~Q7: Write a function that would allow you to do this.~~ * ~~Q8: Explain Values and Types in JavaScript~~ * Q9 (modified): What is event bubbling? * Q10 (modified): What is the difference between var, let, and const? (Follow-up: when would you use each one?) * ~~Q11: How would you check if a number is an integer?~~ * ~~Q12: What is IIFEs (Immediately Invoked Function Expressions)?~~ * ~~Q13: How to compare two objects in JavaScript?~~ * Q14 (modified, if the candidate has experience in multiple languages): What is your favorite feature of the JavaScript language? * ~~Q15: Explain the difference between "undefined" and "not defined" in JavaScript~~ * ~~Q16: What is the difference between anonymous and named functions?~~ * Q17 (modified): What does the term "closure" refer to? * ~~Q18: How would you create a private variable in JavaScript?~~ * Q19 (modified): What does the term "prototype" refer to? (Follow-up, if candidate clearly explains "prototype," and has experience with OOP-centric languages: what makes prototypal inheritance different from classical inheritance?) * ~~Q20: Check if a given string is a isomorphic~~ * ~~Q21: What does the term "Transpiling" stand for?~~ * Q22 (modified): What does the `this` keyword do? (Follow-up: what are `.bind`, `.call`, and `.apply` used for?) * Q23 (modified): What are the downsides of modifying `Array.prototype`? * ~~Q24: What is Hoisting in JavaScript?~~ * ~~Q25: What will the following code output?~~ * ~~Q26: Describe the Revealing Module Pattern design pattern~~ A lot of the removed questions will be answered while the candidate is doing a coding exercise, I don't feel they are valuable on their own. But it's good to be prepared for an interviewer to ask those types of questions.
As it's written it looks like your suggesting to use await outside the async function to call count with different arguments. &gt; . . . &gt;await count(5) &gt;await count() &gt;await count(1) &gt;await count(-1) &gt;await count(0) Not sure what the intent here is as far as us running it or integrating it with your async function (swap out sleep?, step through function?)
I was once interviewing a team lead with 13 years of experience and leading a 25 member team. I asked him to create an object. He used Typescript to create one. I asked him if his code will work in the browser and was very confident about it. He was actually not aware that he was using Typescript. He later sent us an email asking us to learn Javascript before interviewing because apparently he tried creating an object using TS syntax and it worked on his machine.
Sort of agree. In all frameworks I've used I ended up installing their sass partials and simply commenting out all imports minus their grid system and form/button utility helpers. Imo the advantage of using css frameworks is mostly so you can on-board new developers faster, since they will often already be familiar with the basic classes. 
I totally agree. We are lucky in that our entire app is written in TS. But honestly, other than not using ts-mocks or switching to Jasmine, I don't know of a solution. I'd love a better solution. When I get some down time, I'll switch us away from ts-mocks. Oh and we only turn on `skipLibCheck` for ts-jest, not our actual app. It's a compromise we are begrudgingly ok with.
Ah, ok. That makes sense. I'll look into that, thanks :)
I've actually started a Web Development podcast, definitely slight inspired by Syntax (They are awesome). If anyone has some time to check it out and give some feedback I'd definitely appreciate it! [https://podcast.htmlallthethings.com/](https://podcast.htmlallthethings.com/)
Nice start 
Hard to tell from an index and a couple pages of preview. It doesnt look bad at all though, especially since its free I guess right? It mentions ES6 topics it looks like, so its not outdated. Theres no one perfect learning resource. This book seems to cover a very decent chunk of technical JS concepts. Will reading a book make you a JS wizard? Absolutely not. Could you learn a good deal from it? Thats up to you. But I think the information presented in the preview pages on that site is fundamentally accurate, if thats what you’re asking. 
you can't polyfill that, so i assume anything that would work would be doing what babel does except in the browser. at that point, might as well just use babel or update the offending code. 
Anyhow is *hard* if you haven't learnt it properly.
I'm looking for any avenues I can to grow and hone my web development skills. You'll have my sword.
Definitely interested
I've tried multiple times over the last 10 years to use them, hoping that every new iteration might be the one which balances the line between freedom and power. When bootstrap was first released I used it for about 2 years because it found that balance, but apart from that is been my own combination of a reset, flexbox, custom typography and a base stylesheet which gives me best bang for my buck.
How can I learn? Seriously, I’m a dev who can write html+js all day, but my sites look like bootyhole with my wood tier css skills. I’ve tried to read up and look at tutorials but I can never get it. 
"The right tool for the job" **Need to create an app and you do not care at all about the design and uniqueness ?** Regular CSS framework: Bootstrap, Foundation etc. **Need to create a project with base styling that can be worked on later ?** Tailwind, Bulma etc. **You want to create an entirely new design system ?** Go for it. Bootstrap did at one point. Foundation, Bulma, Tailwind... But you soon come to realize your time is better spent doing actual work instead of reinventing the wheel. The problem with most CSS frameworks is that they are bloated and you only ever use maybe 5%. **Solution** ? Simply require only what you need...
The best way to learn is to find designers who will give you honest feedback on your work. You’ll never learn good design from reading a book. You’ve got to make attempts and be willing to have your feelings hurt.
Not JavaScript 
We would love to have you!
Join up on slack!
Exactly, so take the time. Run through flexbox froggy. CSS is much easier than it used to be. All the browsers are pretty much the same now, and we have caniuse.com if you're not sure.
You are overreacting (no pun intended) - you are not required to understand how everything works under the hood in any branch of computer science really, not unless there is something specific you want to optimise or you are actually a part of the team that works on the library. It's simply impossible. You have to learn to deal with abstractions. You are not alone in your frustration with the wild west of front end dev, and you are not the first one to raise those concerns, but you have to understand that it's a relatively new market that's why it's so rapidly developing. It is evolving along with the browsers, mobile devices and so on. Of course so it's going to be chaotic until it matures. &amp;#x200B;
\&gt; After a couple hours on Codewars I feel like a monkey with a keyboard. Yeah, get used to it. If you're doing anything worthwhile, you will undoubtedly struggle at times. And yeah, you can learn. Experience is a great equalizer. 
You can make that modal yourself with a couple of lines of css animation, some dropshadows, and a little border radius. 
Or just don't spend time learning the framework. Learn the CSS instead.
I may just do that and maintain CSS purity!
I will when i get home! 
I, too, am interested! 
Because they come from other languages. I was a backend java developer before a one year mission as a frontend developper. I was totally lost for weeks and I worked hard to catch up how javascript works. Some people work just to put food on the table and when we make them switch their habits that's a total disaster, sadly.
It kinda makes sense though. The repo is for their cli package, so using npm to `npm install` in the source code for `npm` would be a chicken and egg problem.
Called [bootstrapping in computer lingo](https://en.wikipedia.org/wiki/Bootstrapping_(compilers)) and often done. You need to prepare the very first node_modules by hand, then you can use the current npm to build the next npm.
Teach a man to fish and he will never be hungry. Teach a man to use an automated multi-string robotic fishing pole that catches 10 fish a minute and he'll be even better off... Time is still the single most valuable resource. I do not need to start from the ground up, somebody has done it for me. I mean what is this answer really? Does it actually mean anything or are you just saying that for the sake of it? First thing first if you plan on using any type of CSS Framework, you probably already learned CSS... Next, with that way of thinking then : Why use React instead of plain JS ? Why use Lodash instead of plain JS ? Why use PostCSS instead of plain CSS ? These libraries and framework are on the market because there is a demand for it, as I said, the right tool for the job is all that matters. Simply stating "learn css" because you feel like there is an overuse of frameworks is solving nothing and is quite a fallacy honestly. Last (more biased and personal note), you don't actually need to learn CSS. I mean you do, once in your life, for about a week. That's about the maximum amount of time "learning" css takes, it's all about the patterns and the practices. You never need to "learn" anything in programming, you simply need to understand it or at least understand how to use it, then there's this little thing called a Reference or Stack Overflow that you can use instead of trying to "learn" every single method and parameters the thing can possibly have...
Java != Javascript
I couldn’t get through this all but I need to access a hidden input’s value in HubSpot but the form isn’t accessible via the loaded dom so their template’s using jquery has no knowledge of any “input” (Landing page with form) let alone the one I need. 
Yes.
we got rid of bootstrap js in from our code and in the process i only left used only grid part of bootstrap sass then replaced it with a simpler responsive css grid too. now one of biggest dependencies is out the door. we still use popper.js(which bootstrap itself uses too) for our custom dropdowns, selects and tooltips though. we still have modals and datepickers kind of stuff but without bootstrap. since everything is customised/simplified to match our needs our markup is lighter and simpler and not a mess because of the nested bootstrap stuff. I actually started to like working with html. it was an ugly mess before. It all depends on your project but we just needed about 300 lines of sass(our custom mixins and variables that we were already using is not counted but includes all the stuff for grids dropdowns datepckers modals etc.) and about 1500 lines(half of it being a detailed datepicker) of js + popper.js to remove bootstrap dependency. Not to mention our markup is smaller and cleaner now. we already had datefns(replaced moment) so i am not counting it for bootstrap removal. components' js is in vue so you might need a lot more js if you are going vanilla though.
Sounds awesome. Love the idea and exactly what I’m looking for at the moment.
Go to codepen and search for some cool designs on there. Play with them and try to understand what is going on. Look up dribbble and try and mimic some mockups via css. Wireframes can be great a great starting point and they’re plentiful on both sites. Check out Chris Coyers csstricks regularly for clarification on some of the muckier stuff such as grid, flex box and transforms. Css is particularly easy to grasp compared to js or another programming language as everything has a clear definite hook to a node in the DOM. Using the dev tools to help decipher what everything is doing is a great way to sharpen your skills as well! Good luck!
My personal experience is, it's almost impossible to explain to someone who's used jQuery but nothing else how bad that paradigm really is. You have to feel it first. You think the painful process you go through right now is normal: manually informing views of updates, dumping state into dom nodes and classes. You have to at least try using something newer and you will understand. For instance here: https://egghead.io/courses/react-fundamentals It'll cost you an hour and you know the framework in and out, you will also understand *why* people prefer it. Webpack and build tools have nothing to do with it, they are your first step to modern web development period, everything and everyone is using these tools. And again, you ignore your current state, how much work you put into manual chores and concat tools to get anywhere near a serviceable production build. As for why React, it is a simple (perhaps the simplest) and elegant framework with a clear vision. It is almost interchangeable with leaner variants like preact, mithril, etc., but the majority will prefer React, because it still innovates in ways nothing else does. It isn't 70kb min+gzip, it's more like 30 and can shrink to 3-4 (you can alias to preact in production for instance). React carries maybe 1/100th of the api surface and complexity that older-paradigm frameworks like Angular and Vue carry, the current weight was mainly Facebook dumping too many polyfills and safeguards into it, which they'll finally move away from in the upcoming revision.
Here you go. Here's an example of an alert at 5 seconds into the count. When dispelled, the count continues to 10: function countToTen() { let count = 0 function increment() { ++count console.log(count) if (count &gt; 9) { clearInterval(timer) } } const timer = setInterval(increment, 1000) } countToTen() setTimeout(function() { alert('hello') }, 5000)
Im definitely trying to grow my skill set, and I love a good challenge :)
&gt;string constants What is a string constant vs string literal?
Well if you refuse to learn CSS then yes...
I'm going to tell you something that will shock people but w3school has an excellent section on css, just practice, learn how to make widgets in css. It's not going to turn you a designer, but you will be able to create nice layouts without this or that frameworks.
damn this sounds cool! ill be joining 
They didn't care- I actually ended up getting the job
Reflection afterwards is huge for me. Once I've solved something I loop back and reassess the problem and how I could have gotten to the answer much sooner/easier, and things I missed when I solved the problem the first time. It's amazing how many times this has been visiblly able to help in future problem solving. 
that should work, push is a native function so it won’t interact with gtm.
&gt; function curry&lt;T, U, V&gt;(f: (t: T, u: U) =&gt; V, a:T): (b:U) =&gt; V { return b =&gt; f(a, b); } &gt; I can't understand that. None of it. I don't even want to. This... is trivial. There are three type params, because the curried function potentially takes two different types, and its return value might be another type e tirely (e.g. `number, boolean =&gt; string`). The second parameter to curry must have the same type as the curried function's first argument, because... that's what currying entails. `Curry` is _basic functional programming_. Just what have you been doing for seventeen years?
If yall take on a GNAR stack (GraphQL, Node, Apollo, React) let me know. I have some boilerplates and that can be helpful! Love the idea
I know what currying is, I was discussing the confusing mess of letters being an unintuitive mess. It serves no purpose whatsoever, other than wasting time writing something that should be simple.
ES6 is meant to be a superset of ES5. Using globals is legal in ES6 even though it is frowned upon. Also react is just a library. You can write a react app in pure ES5 and it's fine. React provides you with the ability to use JSX. Don't try to bullshit me. I can't believe someone without that much JavaScript experience is trying to diss other people. It's hilarious. You could have just commented about how less experienced react developers use CSS selectors in react apps as opposed to creating components and Id just move on lmao
Interested!
that happens to me on most of the questions
Cool thanks. I've researched this every way I could and I can't see a problem with it but I still wanted a second opinion since this is kind of important.
Thank you. I proved that you are right by putting this code at the end: setTimeout(() =&gt; console.log(perform), 7000) 
I strictly code in machine code. Pleb.
Catch, then rethrow any errors you don't know how to handle. 
definitely interested as a new Web Developer myself.
Just examples of how you might call it. Try them out, see how it works. For example, copy the entire code snippet I have and paste it into a chrome console (which has top-level \`await\` support). 
Thanks. I was running it with Node and wasn't aware there even was top-level await support.
Ah, got you. Sorry. I was writing that example in chrome and just pasting it over here, so I just went with the top-level chrome await instead of wrapping it. 
Nope, the first reason on that list is reason enough in every instance, correct or otherwise. setInterval continuing to run ad infinity, no matter what happens, what error is thrown, or whether it's handleable or not, is just adding bug conditions that otherwise have no need to exist with a recursive setTimeout. JavaScript is a dynamic language that allows for writing wonderfully declarative abstractions... but the flip side of that is we need as much safety as we can get. This is the answer I'm looking for if I ask a candidate about tasking repeating jobs/events.
css is relatively simple. it doesn't mean it's easy. there aren't very many good tutorials out there so it's hard to learn in a structured way. it's very very difficult to maintain effectively when the number of people working on it approaches `n &gt; 1`. what makes css hard isn't that it's difficult to position a widget and make it look nice. what makes it hard is that it's difficult to position many widgets that are just slightly different from each other across an application in a way that doesn't produce basically bespoke css files for custom look. css frameworks aren't about making it easier to position things the way you want. they're about making it easier for a team of people to change presentation code in the future. it's about making it less scary to change a selector that looks like this: .container .primary-container .flexible-container .flexbox-container .text, .container .primary-container .flexible-container .flexbox-container p { display: inline-flex; position: relative; width: auto; }
We just have a simple gulp file that concats and babelfys everything into a single file. After we did it the first time, we really never had to look at it again. Totally worth the time, I copy that file into every project. 
this comment is a really really great visual explanation of the bullshit asymmetry principle. it took this guy that many words to debunk two bullshit platitude sentences
Oh nice. I will look into this. The bulk of this project (which is large) is mostly backbone, require, jquery, handlebars....there really isn't much ES6 at this point but the goal is to ultimately move toward it.
I guess all the major tech companies need to rethink their hiring processes then based on the opinion of a redditor. I'll let them know
Fetch means requesting stuff from a network, which is a large part of programming for the web for obvious reasons. In the browser 90% of what you do will probably be fetching stuff from the network. with Node though you'll also probably be doing other slow things such as requesting stuff from the filesystem and generating cryptographically secure random numbers, both of which also are async operations. Unless you use `fs.readFileSync()` like some kind of monster. But even if you're not doing a lot of async stuff, I'd recommend becoming familiar with Javascript's concurrency model and the event loop. Because if you do something that is slow without it being async then you will potentially be blocking every other operation until it completes... Which is bad. https://www.youtube.com/watch?v=8aGhZQkoFbQ
after 2h of working on it, i figured how to solve that problem. but still have new discoveries that bother me. &lt;body&gt; &lt;button id="testButton"&gt;Click Me!&lt;/button&gt; &lt;script&gt; function Button() { this.name = null; this.count = 0; this.clicked = false; this.click = function () { this.clicked = true; this.count++; console.log(this, 'has been run!'); }; } const perform = new Button(); perform.name = 'PERFORM'; const testButton = document.getElementById('testButton'); function f(){perform.click()} // this is my solution testButton.addEventListener('click', () =&gt; {f()}); // same as below testButton.addEventListener('click', f); // same as above //testButton.addEventListener('click', f()); // Not Working, WHY? // checks if 'perform' object was changed setTimeout(() =&gt; console.log('perform: ',perform), 4000); //setTimeout(() =&gt; console.log('testButton.clicked: ', testButton.clicked), 4000) &lt;/script&gt; &lt;/body&gt; now I don't understand why testButton.addEventListener('click', f) without parentheses work and with parentheses don't. especially when it works here - testButton.addEventListener('click', () =&gt; {f()}); And I could not solve it with ether apply nor call. Please could you give me solution with those methods? I tried things like: testButton.addEventListener('click', Button.call(perform, this.click()) but couldn't find a solution.
Hey, I'll try and give the best answer I can, and teach you some tricks that might save some time so don't take any of this condescendingly The first rule of development that will save you time when you have such an issue : Search it. In this case, the first thing I did is go to https://github.com/C2FO/fast-csv/issues which is the issues of the package you are mentioning. Keyword "browser" give us https://github.com/C2FO/fast-csv/issues?utf8=✓&amp;q=browser and first result https://github.com/C2FO/fast-csv/issues/226 tells us that apparently the devs were not aware there is such a thing as "browsers" in the world in your library uses Node.js exclusive APIs that are not in your browser poor Javascript runtime. He does recommend trying https://www.papaparse.com so I guess check that out. Tell me if you need any more help :) 
site poisoned by cloudflare. shitlisted
According to the post, the candidate succeeded. The issue was with the *duration* that it took.
I just finished updating it if you have already forked it or something.
You know that JSLint is like 15+ years old and lacks a lot of the customizability and extendability of ESLint (or even JSHint) right? Why are you posting this here exactly?
Me too!
When it fails haha, I'm using VSCode maybe there's an extension
Oh man I've heard of those Focaline XRs baby haha. Well shit man, if you're killing it with life... I almost got a prescription myself but had to do these like "tests" like "look at these puzzles" but needed to do like 5 of them and ran out of insurance. I think if I do get medicated that way my life would be solid idk... otherwise it seems operating on a little bit of sleep deprivation seems best for me personally. Sorry rambling haha
no, I did not know that. i thought it was a decent tool. i guess the downvotes are well deserved.
Check out FileReader, it will parse csv values to a variable. 
&gt;If you learn css and flexbox you'll have a transferable skill that'll last forever. I meet so many devs who think css is hard, but it really isn't. CSS isn't hard, until it is... It's not that CSS is hard, in fact if anything it's super *easy* if you learn SASS with it, it's that humans like me are lazy fuckwits that never put their properties in order, nest mix-ins where we're not supposed to, and forget the variables we were using and just hardcode the same damn positioning and sizing properties again, and again, and again. And some old school guys haven't bothered to learn about Flexbox (whereas we newbies rely on it) and are still fucking with floats and clears and shit. The problem with CSS isn't CSS, it's human error.
OMG I love this 
Used jQuery, prototype, mootools for over 12 years. Still use jQuery. However, 99% of the time modern paradigms are waaaaayyy better. First time you look at your jQuery code and think, wow, I want to kill myself, you'll get the new school.
Your original code works fine with this.click as an arrow function, as this' context doesn't get bound by the event listener. Alternatively you could add this.click = this.click.bind(this) in your button constructor
FreeCodeCamp is great, we recommend it to our brand spanking new developers. It will give you the foundation to start contributing at skillcamp. Skillcamp would be the next step after you have started to get comfortable with programming concepts. It allows you to build and discuss projects with other developers, receive feedback on your code, and develop real-world team skills that you would use as a professional developer. We definitely aware of stack-overflow syndrome (SOS ?), and kind of built the idea around solving that problem for developers. Being able to learn, ask questions, make mistakes and grow as a developer comes before the projects themselves. I personally am not the best developer in the world, and have learned a ton from the people in the group. Everyone is super down to earth and has been more than happy to help out and answer questions. If we see anyone discourage other developers, we will absolutely address it, and ban users if necessary. As far as bot, I haven't seen any! (but we are planning some slack-bot projects!!) Hope to see you on slack! :)
Also I feel like CSS problems can be hard to diagnose sometimes by just eyeballing it. I'm still in school learning it, so I'm no expert. But sometimes while building a page, it can load up and I just think "ok what the hell is going on here". The viruals might be doing such weird stuff that it's hard to see what the problem is. So I've been learning to check the page frequently, after each add. Making a bunch of CSS changes then checking makes diagnosis hard. Also usually my page runs anyway even if I typo something. It's a lot different from C++, that freaks out and refuses to run if you miss a semicolon. For anyone new to CSS, it's a great tool so don't be scared. Just remember, check changes frequently. Watch some tutorials. It just takes a little practice. Grid is especially awesome.
There's a serious problem with this code: by binding the value of `i` to each callback synchronously, all potential mutations to the counter that occur between each 1s interval will be ignored. In this sense, I dont think you're actually "incrementing" so much as printing out sequential values. 
Thank you! That moved the needle forward, but now I'm getting error 24 **p[i].charAt is not a function** I think i;m using it in the right way? https://www.w3schools.com/jsref/jsref_charat.asp
Use console.log to see what the value of p[i] is
You mean toString is defined on the prototype? I meant explicitly using it. As in defining my own values and functions on an object's prototype
`= "*"` is trying to set the return value from `charAt(0)`, and IDK if that works but assignment returns what's assigned and strings are "truthy" (similar to true, in the eyes of JS) values so if that line is always true that's likely why. `==` or "loose equals" will test if the left hand side is equal to the right hand side, but **will convert** between types so that expressions like `'5' == 5` will be true. `===` or "strict equals" will test if the left hand side is equal to the right hand side, and **will not convert** between types so that expressions like `'5' === 5` will be false. ---- A RegExp may be easier and possibly faster. Just randomly managed something similar while messing with one of my own projects a few days ago, and I think you could replace the loop with something like this: `everything = everything.concat(p.join('\n').match/^\*.*/g)` * `Array.concat` creates a new Array with the contents of the one it's called on and appends the contents of the Array it's called with as an arg. * `Array.join` joins the elements of an Array with the string it's called with as an argument, `\n` for "newline" in this case, and returns that as a string. * `String.match` tests a string against a RegExp and returns an Array of the results. * The RegExp * `^` matches the beginning of a line * `\` is used to escape things so they're not interpreted (so `\*` will be a literal `*`). * `.*` -- the `.` matches any character *except* newline (`\n`), and the `*` makes it try to find 0 or more occurrences of the previous pattern (`.` in this case). This should run extremely fast and only find lines there the first character is `*`. It is creating larger temporary variables with the extra copy of the Array + another as a string than your implementation seems to be though, so if memory is a concern while running this you may want to skip the RegExp.
Developer tools of the browser are priceless. Learning css can be slotted easier if you inspect elements with dev tools on other websites. Also if you want to practice, one of my favorite methods is to recreate a static web page you find interesting or like the design of. Building something that you think looks good helps with sticking with it and coding through. Plus recreating a web page using dev tools will help you learn a ton of what’s AVAILABLE to use in terms of css properties. Good luck and stick with it. It will get easier if you put in the time. 
Relational DB all the way, this is literally what they are for.
Just not having to double check what kind of parameters/types one function accepts is already a big benefit. Efficiency is key and time is money, if you switch files to check something you are wasting time and losing money. Main benefit of typescript isn't the typescript itself, but rather the advantages your editor/IDE can give you because of it. There's also the whole "preventing mistakes" too, it's overrated yes, but it also has its merits. Overall, I don't see any reason to not include typescript in a medium-sized project. The only ONE argument that is somewhat plausible is being against any kind of code transpiling because of larger bundle sizes. If you are already using webpack/babel for polyfills or something like that, there's just no valid reason to not include typescript imo. The learning curve is somewhat small, you just need to be open minded.
&gt; but there is literally no comparison between the productivity of a good visual programming platform (like Ab Initio Software) and a text-based programming paradigm. Sorry, can you clarify please? There is no comparison because you think the visual programming paradigm is better or worse? 
What? How the hell next n previous makes sense in this context. For the context it's object and key. 
Thank you! This is a quite a bit over my head, but I'm trying to work it out – I follow some of this and I'm reading up on RegExp now. So, before I had p being the top line of the document, then I looped through by incrementing i to scan through the whole document one line at a time. You say this RegExp should replace my loop, so do I need to make p = my whole document? The examples [over here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) use the term RegExp at the start of its lines. Do I need to do something similar?
I missed that. Thanks a lot. I got it working after replacing `q` with `i` i.e current page. `var f = this.addField(String("Page"+q),"text",i,r);` Also, I would like to know, how should I figure such small things out in future, the way you did. All your suggestions are welcome. &amp;#x200B;
When the task is writing a for loop with three conditionals, I think duration is an acceptable metric. Else defenestration.
Sorry I didn't get your comment 
The best way to handle this is to get a server-side language involved, and an upload form on your website. So you write a form in HTML, and the form has a special type of field which accepts a local file location. The action of the form will be a server-side script, which uploads to a writeable area on the website. The script can be perl, PHP, python or whatever, but presumably node.js will suit you, as you're already working in that. Just google for a tutorial on how to get a file uploaded to a server and be careful about security.
You don't have to use single-letter type variable names, any more than JavaScript forces you to use single-letter value variable names. It's just a convention that can aid readability when you mix type and non-type bars. But this would be obvious if you'd had even a few months' exposure to typed languages before. So let me ask again: _what have you been doing for seventeen years?_
The site opens with a modal telling me to flush my cache or it might not work right. It's the first time I've been there. There are weird font color issues. Confusing languages is only half their problem. 
Interestingly, you can't feature test for it either. Even if you wrap it with a try/catch, "let x = 1" will produce a parsing error and stop execution in IE10.
&gt; The problem with CSS isn't CSS, it's human error. I think this is also the case for all coding. Any piece of code turns into a mudball if a bunch of different people work on it without proper code reviews. 
Shit god damn use IDs that looks horribly slow
What is it specifically about CSS that baffles you??
Agreed. Working with this data in memory with node could work. But using a relational dB for example shows that you know the limitations and benefits of different technologies.
I ended up setting up our app at work with webpack. Now we have hot reload and ES6, and it actually improved our coding time instead of decreasing it like I initially expected. Instead of save / switch windows / reload / wait, it's now usually just save / switch windows / wait less time because it started reloading before we switched windows. We were going to webpack anyhow to improve our method for combining everything into 1 file. In addition, I was able to set up chunk splitting and now the app only loads what it needs when it needs it, in large chunks. It has massively improved the responsiveness of our app.
No problem :) Wish I could explain it better, but the MDN docs should do so. The part `p.join('\n')` assumes p is an array where each element is a single line of the data, as it seemed to be in your original example. As long as you got that part fixed (saw the other comment thread) it will join the lines together into a single string using `\n` to separate lines (which is important for the regex to work as the pattern `.*` will match anything except a newline). That's most likely my fault unless you caught it and fixed it yourself -- it was missing the parentheses around the call to match so it was probably trying to evaluate the regex as an expression and apparently considered `^` a variable for the moment. I edited above to fix the parentheses; I'm sorry for the confusion. The world of regex is an amazing thing, and often cross-language compatible so it can be very well worth learning at least the basics. JS does not support everything that regex can do (some advanced stuff), but I have read about one trick to achieve the same functionality as one missing part with what is provided, and so there's likely others because it is JS after all + regex on top of that = a whole new level of "What?!"
If you are the only dev you can invent how many wheels you want. If you work in a team with coworkers of varying levels of skill and experience, the better documented a framework is, the more productive it will be. 
&gt;Using the dev tools to help decipher what everything is doing is a great way to sharpen your skills as well! I know far too many devs who completely ignore the inspector in dev tools. They have no idea what it does or how to use it and it makes me so sad :( 
**This works:** {thisPost: string} **This doesn't:** const upVoteString= 'upvote' {thisPost: upVoteString} Sounds reasonable, right? But how do we type redux actions (or reducers or creators)? The official Flow documentation recommends: type FooAction = { type: "FOO", foo: number }; type BarAction = { type: "BAR", bar: boolean }; type Action = | FooAction | BarAction; That's great but the Redux documentation recommendations that we define FOO and BAR as constants in a seperate file so we can import them and save ourselves from typos. However there's no way to do that in Flow. Workarounds are possible (using $Keys of $Values) but it's a small annoyance that everyone keeps running into. 
this might sound silly but i worked with react/redux and vuejs for almost 3 years without knowing what immutability is. i was using without knowing terminology.
In projects larger than a couple developers, tools like Tachyons are really awesome. If you can create linting rules that enforce flat specificity, such that CSS is only ever applied to classes and classes are never nested, you might create easily modifiable, future-proof CSS. That’s pretty hard to do, though. There’s something great to be said about knowing with absolute certainty that the code you’re modifying won’t have negative effects elsewhere in your codebase or application. Try running your code through CSS Stats and see how many nearly-identical colors, margins, paddings, and font sizes you have. Check the specificity graph. Check the total number of rules! If you’re working on a reasonably large codebase, I bet it’s not going to be pretty. 
His point is that it's not necessary when you're in a perfectly envisioned team with crisp wireframes and a styleguide that actually gets followed (roughly)... I think 99% of people think bootstrap is a template UI... It's not, it's a framework... I haven't seen a single person / shop / team using it like a framework, who set all the bootstrap variables to make the buttons look like their buttons, form fields, etc... It's treated like a strawman UI to override and ignore when the default UI isn't whta you want... If you actually use it like a framework though, to implement your styleguide then it can be super effective... Not to mention it incudes a responsive grid that has zilch to do with the brand treatment in the UI... There's no not using a framework... You can build your own framework and use it, or you can pick a framework and use it. There's going to be issues either way, I believe the second though is gonna be less work and less headache overall most of the time because even with rough edges and a little bloat... it's still gonna be better overall than what you'll build for yourself.
Talking about interoperability with other frameworks: I don't see a reason why consumable API wouldn't be possible, at best as it's possible with today browser technologies or with JS. stage0 works with DOM nodes and produce self-contained DOM nodes to the output. So you will either write some glue code(if it's a JS-function) or wrap it in webcomponents if you need it to be automatically handled by the browser or it can be done by component library author. And you don't need to instantiate some framework infrastructure for that like, for example, React does. It's not in the library because it doesn't have to. Small predictable functions do only one job and focus on doing it good.
Should have used the headline from the article, this is more of an intro to koa than it is a tutorial on building a sentiment analysis whatever.
&gt; This ended in a myriad of assets that you now have to "webpack" and whatnot before you can start writing any actual features but that's merely a side effect of these frameworks and how they work. Package management is something every development platform needs. Pre-NPM management of dependencies was a nightmare, and maintaining a Webpack config is a small price to pay for `npm install` and `npm update`, trust me. As for your overall message, I disagree. There is a very valid reason for this apparent over-engineering, and it's because JS has transitioned into an eco-system for “real” app development. The browser env is no longer just a presentation layer with static info and maybe some cool animation or CSS effects. Sure, most of the web still use it for this – in which case jQuery works fine – but that's not why we now have NPM, Webpack, React, etc. These are tools for app development. &gt; getting fed up of having to learn new paradigms every other day, and that these "paradigms" feel more like a marketing ploy than anything meaningful or valuable. The transition I described above is a paradigm shift. New frameworks with different approaches to app development are not paradigm shifts. You should focus on finding a development strategy that works for you, independent of frameworks or tools. Our company is maintaining an app we first built in AS3, then migrated to JS and Backbone, and then to React. None of these steps changed our fundamental app architecture.
Maybe a [Shotgun-Axe](https://streamable.com/b59ft) combination of some sort.
Definitely, I agree that yours is easier to glance over and know more quickly what’s happening. But maybe the compactness is a bigger priority. 
[removed]
I'd say it mostly depends on internal code style guidelines. Both versions are fine, the first one is more explicit but at the same time a bit more verbose.
It’s called “early return” and it’s a great way to clean up your code functions. You can go through all of the validation logic or simple cases and return from the method, then once you are ready the bulk of them method is after the returns. This also has the added benefit of reducing indentation. It’s a great way to simplify methods.
I personally prefer the refactor also. I don’t like else blocks if not needed. 
I think jQuery and libs/frameworks like react, vue, angular server different purposes. I wouldn‘t use react to extend my website with some limited additional interactivity - there jQuery may shine or normally, nowadays I only use the native JS browser APIs for it and skip jQuery altogether. But I love to write more complex applications with react, as soon as more state comes into play and in this cases libs/frameworks like react, angular, vue may help a lot. So of course: If you do the same ‚simple‘ stuff you normally could do easily with jQuery or the native JS browser API with something like react it definitely feels bloated. But then you may not really need libs like react and it would be better to first understand why they were made. They were made for web-applications. But if you only make a traditional website you may not need it. I think it is not so complicated: We just make it complicated by using wrong tools for simple things. :) And yes: I enjoy coding with it a lot more then before without them. 
You're trying to show your skills. What kind of job is this? Are you expected to use SQL there? The simplest option is to do everything in-memory with Node. It seems that you only need to loop over the rows once and aggregate some data. Converting input to JSON or using Redis seems complete wrong approach here. Some things to consider: - Produce correct results - Write good and readable code - Document how to run your code - Make your code easy to run. Using a SQL database probably makes this harder. - Handling errors like invalid CSV is not necessary but great addition
I prefer the 2nd way as it's less code but still clear. However, I'd spend 0 political capital in trying to force the company to change. I'd match what's in the codebase today and move on.
Refector is cleaner and less code my eyes have to consume assuming the if = true.
The refactor is the way to go - especially as the "IF" fills in with code the else become harder to pair visually with the "correct" IF statement... Basically, the refactoring cleans up tracing curly braces backward. 
Fwiw, there’s an Eslint rule defining this exact thing https://eslint.org/docs/rules/no-else-return. I think the idea is that the code is simpler without the extra else block and that they are functionally the same That said, I tend to write if/else blocks and then prettier/Eslint just fixes my code and I don’t have to worry about it
Mind posting a sample of the json you want to convert? Would it make sense as a spreadsheet? Also, where will this be run? Will the server have Excel on it? If so, you could import the Excel interop SDK and use that (it’s a bit annoying to work with). However if you do decide to use a library (and I’m curious as to why you don’t want to use one), check out ClosedXML. It’s free, easy to use, and can generate xslx files.
 A little twist on the 2nd one: if you do !bar, then you can have a fast return before all the logic- this makes the code even more readable.
There are some factors that make me like the early return style more than the if-else one: - the condition that terminates the function execution is explicit, specially useful if you have more than one - the else branch contains the main logic for the code (the one the function is named after), so removing the extra indentation level makes that clearer - you don't have to scan the whole else body to understand what the if is doing, it's just an early return I think I first read about this pattern on the Refactoring book, by Martin Fowler. I was wondering if you can elaborate on your preference to the if-else style. What makes it more readable to you?
I personally prefer the first style, with explicit else, but you should not base code style decisions on opinions of strangers from internet. It’s better to settle on a single code style even if you don’t like it, then letting disagreements about it poison the team.
I like the refactor as well. I see it like this: I expect the function to return ... value. If something unexpected/expected happened I return a other value. 
it is in his example
I don’t think it’s just stylistic. The if-else method of writing makes the return function conditional on the if conditions. The second way of writing shows the default return value for the whole function. If you remove the if statement, the second method would still return a value. 
I like, and use, the second style. Just a matter of preference: I think your team needs to decide on one way and stick with it. The best style is the one a team is comfortable with.
I actually disagree, negative checks in the IF complicate it more than just checking if something is true. Sometimes it’s necessary but I would prefer to avoid it.
The second, dude. Don't have unnecessary braces. It'll just lead to a jungle of braces if you later need to add more code below the second else later.
Readability counts, said my senior dev few years ago. I wrote just like yours then. Refactored one is more readable when someone else is going through it, or even on the day when you will be skimming through the code.
It sounds like you have never worked on a big team or a large codebase. Inconsistent code styles make code harder to read and harder to maintain. It's a cognitive tax. Code style should be enforced by a linter though, not a code review. It a waste of time for the code reviewer.
Refactored. It does the sake thing with less lines of code. 
Yup...I too would prefer the second one. Clean code with out too much nesting is also important for maintenance
100% this. We use Prettier to auto format all code. Get together with the most senior folks, decide on which style for everything, and let it do its magic. Do I agree with all auto formatted style changes? Nope. But I stopped worrying about it, cause now at least it's consistent across the entire codebase. It's liberating, I don't have to worry about stupid code style! I can just care about actual code and review comments that matter. Try it.
Makes sense. Writing to a file using just client facing JS is tricky, but look into the Blob and URL.createObjectUrl APIs for building the file and making a download link. As far as json to csv, you can get your column headers by looking at the object’s keys as you iterate over it. There are a few hints for you :) If you want to toss something in github, I can check it out and give you some suggestions.
so what is the actual code he use? I mean if it just a plain object I don't know what is the typescript way to create one.
I use css libraries more to standardize things like focus styles, clicked, etc boilerplate. Nothing stopping you from pulling in the base framework today then gradually removing what isnt needed. 
you disagree with the majority of the programming community FYI https://softwareengineering.stackexchange.com/questions/18454/should-i-return-from-a-function-early-or-use-an-if-statement
Sounds like the person doing code review is in charge of keeping the company codebase up to some standard. 
I use the second one. Less code to write, and more aesthetic.
Yeah. Talking about stylistic stuff is a waste of everyone's time. I personally prefer the refactor (this is a simplistic case, but the early-return style can make a big difference to readability in more complex situations) but I'd take the first one over having to argue about it.
I have to concur with your colleague I'm afraid. You're already returning control to the caller with the `return` keyword when the `if` statement's block is entered, thus the `else` block serves no purpose. There are arguments for having a single return statement per function, but I'm not keen on that practice.
I like to think of it like this: Person1 flips a coin Person2: "Is it heads?" Person1: "No" Person2: "Hmmmmm........is it tails?" Person1: "Yes" You wouldn't ask redundant question in real life for binary results you can extrapolate so you shouldn't check for redundant binary results you can extrapolate in your code. Person1 flips a coin Person2: "Is it heads?" Person1: "No" Person2: "Gotcha"
I also use prettier and it's great, but it won't refactor code like this.
I prefer neither. If it's one line like that: function foo() { return bar ? something : somethingElse; }
I also prefer the refactored version, but more than that I crave consistency. Just agree on how you will do it and then be consistent. I don’t know if linters would find this one?
&gt; If you remove the if statement, the second method would still return a value. Well, then you're changing the functionality of the code and that's a completely different matter. That's not a code style or refactoring issue.
Poor guy. Should be replaced by a linter.
Three rules to live by: * Return early * Return often * Reduce cyclomatic complexity
You should not optimize prematurely either.
To add on this if you had something like ``` if (foo){ } else { return (bar) } // something farther down the method if (foo){ } else { return (bar) } ``` It would be easy to change one of the returns and miss the other because it’s hidden in the code. And as a result you end up with a bug. That’s is the other reason the mentioned style type is used. 
I agree with this, it it's short and just returning something then we normally use this in my company.
Yup!
Prettier ftw 
There are more than 356 people in the programming community. This isn't Mumps.
My preference, only have one exit point from a function, from my experience it makes it easier to debug when things go wrong. If you do that, the two statements do different things, the else is only executed when the if is false, however with no else statement, the code underneath is always executed regardless of the if statement. So having one exit point should reduce the code smell of multiple returns.
I would say this should be defined by the whole team or the tech lead. Personally I prefer the 2nd way, especially when your else-block becomes complicated, additional indentation will make it more difficult to read.
Like [this one](https://eslint.org/docs/rules/no-else-return].
I prefer the refactor and often use that style in my own code.
https://eslint.org/docs/rules/no-else-return
Of course and there are probably thousands of articles explaining why return early is beneficial when it comes to readability. 
Bravo to everyone in this thread. Glad there is such consensus on this.
Yep, that’s right. But that would be how I read and interpret the code if given both. So if I’m a coder looking at refactoring it 2 years after it’s first written I’d assume the second return value is the default for the function. That’s something the CTO in an organisation needs to consider when choosing the style.
Eslint with Airbnb style guide
It depends on how long is "something" and "somethingElse"
https://eslint.org/docs/rules/no-else-return
a simple little game I made [http://manishkapur.com/game](http://manishkapur.com/game)
Really bums me out that people bikeshed this type of stuff when you can have a computer take care of it and work on important things with your valuable human time.
Pretty much. Fuck planning ahead, fuck cascade and especially use !important whenever you can, that'll never bite you in the ass.
[removed]
The else block is unnecessary, I’d agree with the changes. What’s more important though, is the codebase written in his or your style? Consistency is key.
This is wrong. The two pieces of code are logically equivalent.
That's not what happens in the two examples given. The two pieces of code given are logically equivalent. They will always behave exactly the same.
&gt;the code underneath is always executed regardless of the if statement. It's not. It will never be executed when the \`if\` condition is true. The early return will prevent it from being executed.
This is personal preference and makes little impact on the overall project. Don’t be a dick-tater; let people have their preferences if its to the point of arguing. It’s the little arguments that can kill joy, which is something you should be promoting in your workplace. I can make your life MiSERABLE if I force you to use the English language the way I think is correct, but that’s also a joy killer. So be like Elsa and just... ... let it go
Yes, I wasn't saying that. Read my original comment and I say with my suggestion of preferring a single exit point, you'd need to modify the code. 
Paraphrased because from memory but "Junior devs add code, senior devs improve existing code, gurus delete code". The 2nd style is better. Also, the most important answers here are "just use a linter and stop bikeshedding". While the other dev's intentions might be good, the fact that he's wasting time doing this in code reviews is a sign that he also could use some mentoring. 
Another point I’d bring up is this: If the conditional blocks becomes no longer necessary, removing it is quick and simple And requires no changes to the default code. 
Why stop there? You can also use object literals, like so: function foo( return ({ "true": "something", "false": "somethingElse" })[bar]; } Or do the *"Wannabe-Lisp"* parenthesis-heavy *"React-style"* and use ternary operators: function foo(bar) { return (bar ? ( "something" ) : ( "somethingElse" )); } For your particular examples, though, I think that the best answer is *"it depends"*. There are some cases *(usually in an overly-complex function)* where it's nice to have the clarity of being explicitly reminded that certain code in a function will be run only if a condition hasn't been met. But most of the time, if functions are kept as short and focused as I believe they should be, the second style wins. This is especially true given that the initial conditional statement within a Javascript function often deals with what *essentially* boils down to error-checking, and so the behavior within that block is often only tangentially related to the function's purpose.
The second one is more readable, if you ask. Also, it doesn’t make sense to have else statement when your if statement already has a return in it which mean that if it true then it would end the function call and if not then just execute the next one and return. It’s also more efficient to not have else. Imagine all of your function return has unnecessary else and you have like 1000 in your application. Just imagine.
2nd obviously
Centering sucks. I always do margin: auto, but it works half the time. That’s a concrete example. I feel like there’s so many little corner cases 
This is really cool. I like the visualization in the middle. I think the most difficult thing for people to learn is the shape of their data structures and control structures. 
I think every comment up there has sort of covered why they like second version, which I agree too. I think the reason why you think the else is necessary is that both of them are return command. If it is a different code ie if a condition is met then do something else before execute the rest of the code, you probably won’t find it such an eye sore. Just my 2cts.
I think I better understand the point you were trying to make now. But multiple returns on their own are not a code smell. Early returns are best practice. Avoiding early returns in order to try to achieve a single exit point makes code less readable. The consensus on this is very high. [https://softwareengineering.stackexchange.com/questions/18454/should-i-return-from-a-function-early-or-use-an-if-statement](https://softwareengineering.stackexchange.com/questions/18454/should-i-return-from-a-function-early-or-use-an-if-statement)
Fuck with him and return a ternary.
Why even make it that long? ```const foo = () =&gt; bar ? something : somethingElse;```
I use both in my code, depending on the logic of the method. If the two branches are on equal logical footing (e.g. if \`bar\` differentiates between two different operations to perform), I express that with the explicit \`else\`. On the other hand if one of the branches is the "main" flow through the logic and the other is an early return if some condition is/isn't met, I leave off the "else" block so the main flow is more obvious to the reader.
It’s not a code style, bro. lol Implement SOLID principle and you’ll know why having else just to return something that doesn’t require else is a really bad idea.
Agree on a linter and a style, let machine do this work for you. This is a waste of time for both code reviewer and reviewee. Code review should be focus on the logic not styles. 
Thanks! I wish I had more visualizing and debugging as a beginner. I've also thought of building a visual language on top. Maybe code itself is a bit scary compared to the "usual" drag and drop tools.
I didnt even click. 
We tried prettier but man it produces some unreadable outputs especially if the line length is longer than their default. Would probably reconsider it if they added an option to make collapsing arrays into a single line optional, but between that and clashing with eslint I'm just not into it.
Both examples do an early return.
Second all the way, use a linter 
This was SUPER helpful. Thanks so much man, yesterday I've learned some javascript basics, today thanks to your post I've managed to setup the hole server, now I just need to implement my API logic and I'm done! Also your humor reminds me of a certain chess grandmaster, I chuckled several times
Done something similar, can tell you this much - if you are not going to use any library, you should probably forget about .xls or .xlsx - way too much headache. .csv on the other hand is very straightforward. Since it's just comma-separated values it's pretty simple to convert JSON -&gt; string -&gt; file blob -&gt; download file. Tip: default delimiter for .csv files is usually a comma, but that can vary between operating systems and may depend on Excel settings. Couple links from quick search on google that look good enough to help you get started: [first (mostly how csv files look)](https://www.computerhope.com/issues/ch001356.htm), [second (with actual JS code)](https://medium.com/@danny.pule/export-json-to-csv-file-using-javascript-a0b7bc5b00d2) [third (with actual JS code)](https://halistechnology.com/2015/05/28/use-javascript-to-export-your-data-as-csv/) Hope this helps.
Yeah we use esLint with a whole bunch of rules. The refactor is more concise, and if someone is looking at source code they typically (should?) know what they’re reading. My team lead is a stickler for this too OP, it’s just one of those things homie.
Generally: less code == better code It may seem stupid, but think how much faster you can read through that code by skipping over the else lines and interpreting them. 
There is a plugin for eslint which runs prettier and then eslint fix. It means you can override certain additives of prettier like the one you describe.
&gt; Both examples return from within the if-block. They didn't claim it didn't, they're just explaining what early return was. 
Agreed. this becomes particularly clear if there are multiple if's with returns
 I mostly agree but here are the tried-and-tested rules I've found work best: * Return *errors/exceptions* early * Return *results* only once (if possible) &amp;#8203; function foo( bar ) { if (bar is bad) { // early returns return someError; } // complex nested functional logic // if { for( while() ) } else { someResult = someFunction() } return someResult; // return valid results only once } Here's why: * Early returns make clear what the valid pre-conditions for the function are and avoid further processing. These returns should happen within the first 10 to 20 lines of code of the function/method. * Once those "pre-flight checks" have cleared, the rest of the function/method should work toward a single result, returned at the end of the function/method. Bottom-line: Lots of experience shows that the worst kind of function to refactor, extend or debug is one with multiple returns nested deep in their logic. Following the "early exit, single return" rule avoids all that.
Cool I'll check it out, do you have a link?
I agree with early exist. I am still go back and forth on single return. Over the years I have been gravitating to multiple returns as soon as you can just from the readability aspect. I don’t need to be concerned if the value is getting manipulated later on. But I do see both sides of it. 
I think this is what I used before https://github.com/prettier/prettier-eslint/blob/master/README.md
What if your team does use a linter that was configured by your cto and then you adhere to the linter’s rules but your cto then makes you break the linter’s rules and write multiple nested if else blocks because he can’t read ternaries? 
&gt; Something that is evangelized in Clean Code. It is a natural side-effect of many of the *other* pieces of advice, but I don't recall seeing this specifically. A brief glance at the Functions chapter and index didn't turn anything up, either. You may be thinking of [Code Complete](http://www.cc2e.com/). If not, do you remember what section this is in?
&gt;I love the simplicity of this but only agree with two out of three of your rules. I'd revise that to be "Return *errors/exceptions* early. Return *results* only *once* at the end." In my experience, the worst functions to debug are ones with multiple returns with some buried like rotten Easter eggs deep in nested logic. (See my detailed comment elsewhere in the thread.) &amp;#x200B;
Second one is more readable and clean More cleaner would be If (bar) return foo return bam
I prefer the second one. Not only you are typing less and it still remains clear, but you are avoiding a block and thus avoiding an indentation level. Suppose this is inside a class method, which calls a promise, and this code block is inside the `.then()`. We already have 3 indentation levels. And personally I feel like the less indentation, the simpler the code looks
Sorry man, I agree with the reviewer. Personally I’d implicitly return a ternary. 
These are also known as [guard clauses](https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html). I've been practicing this style for a really long time but only recently I got to know that there was a term for that.
I prefer a single return statement, so i guess neither.
Yes, but the difference between the two examples is that one has an unnecessary `else` block and the other doesn't. They are both doing the same early return (potentially - depending on what the if condition is).
This is a waste of time. There is no obvious winner and it doesn't actually make a difference. 
It always amazes me when people spend valuable working hours splitting hairs over stuff like this.
I try somethings next few days and post link here when I have something... 
The extra block is not only a distraction but could result in unreachable code added after the block. It definitely isn’t needed by the runtime. 
&gt;Debating about stuff like this wastes valuable engineering time Agreed. We use prettier (on top of eslint/tslint) internally. Although, there are times where I hate what prettier is doing to my code, I just accept it and move on. No wasted brain cycles.
I've done this on my teams as a CI step. One of the many tests that runs are that there are no violations of the style guide. If the code is not properly formatted, the build will fail and we don't review PRs that aren't green. We happen to start with the Airbnb style guide as a start and then override where appropriate for us. That way there is none of this "the reviewer hates my code" crap and instead it's "oh my build failed because I didn't follow the agreed style guide - better fix that so I can get a review." 
Everything should happen within the first 10-20 lines 😊
I wonder how much carry over there is from drag and drop to actual code. I think using code, then visualizing what the code means is a great start for anyone learning to program. 
That's not JSON, it's pure JS. Those are value:key pairs being pushed onto an stack. I realize it looks extremely similar to JSON, but it is not. If it was JSON, you are correct but the code would have to read: window.dataLayer.push({ '\"event\": \"new_subscriber\", \"formLocation\": "footer\"' }); And that's still not valid.
sure 'nuff
It could have been that. Tbh, I hadn't read the book but I was on a couple different teams early in my career where the leads made that out as the bible. I still disagree with most of it. One of the things that drove me nuts the worst was 1 return per function. 
Why not a third option? ```function foo() { return bar ? something : somethingElse; }``` Or a fourth? `const foo = () =&gt; bar ? something : somethingElse;` One of my biggest pet peeves in this industry is when you propose a question and the respondent decides to propose a different question and answer that instead of the one you proposed. So I figured I would give back to the commmunity. Enjoy! In all seriousness, I think the latter of the two options you proposed is more readable. Less code. The else statement isn't necessary. &amp;#x200B;
Some languages (like Elixir) have first class support for guards as part of the function definition. This is particularly useful when combined with polymorphic functions.
All professional programmers should listen to and heed this comment. I am one of the most opinionated coders ever, especially when it comes to style and looks. But everyone has opinions and consistency in a shared code base is more important than any style choice. 
No offense then but I consider that highly foolish. The problem would be someone writing highly error prone code in the setInterval, not that the interval itself doesn't play nicely with errors. setInterval has better performance than setTimeout. That is reason enough to use setInterval in some situations. It's the right tool for the right job and if you're creating axioms to avoid parts of a language just because you're prone to fuck up then I consider that the error on the developer's part.
This position does involve working with SQL, but not exclusively. I don't have enough experience to able to tell if this many entries is too much or too little for utilizing one approach or another. If converting data from CSV to JSON is a bad idea, then what's better for handling CSV in-memory without SQL? Thank you!
If this is happening at an office you're wasting your time and the business' money.
In the simple cases, I'd agree with you, however if the first part becomes large, I'd prever his first version. The return statement might be missed when reading through, so adding the "else" is clearer.
Not entirely true, when you work in a large team, readability is priority. A fancy one liner might be smart, but if it looks cryptic to the next person touching your code, it's going to slow stuff down.
His refractor. It's just cleaner.
Absolute positioning is your friend, also if your target browsers support it, use flexbox.
I think always having a return outside of an if block is good. It guarantees you return something. Maybe right now this doesn't matter and is clear, but after successive feature changes and refactors, maybe not so much. Anyway, of all the things to argue over on a PR, this would be at the bottom of my list.
&gt; like Elixir Or, ya know, Swift
[removed]
return (bar? something : something_else) Ya bish.
That’s not fuckery, that’s clean code, yo. Obviously depends on the length of something and somethingelse but a clean one liner is so much sexier than a bloated if-else statement.
What about the single point of return principle? And fuck that if else condition man.
Single-Return works much better in expression based languages. Functional programming languages tend to work this way and it feels a lot more natural there. In statement based languages, "single return" is awkward as you say because it requires additional variables to track state. Which is error prone and harder to follow. Single-Return is good practice in languages with manual memory management such as C, which I think is where the mantra comes from. 
I almost always do the if-only early return. BUT if it is a very short function and the if-else is symmetric, like, uhm, both just two variants of something to do, I think the logic is clearer if the codehas if-else. Something like if CONDITION return x else return -x. I think it looks weird if a symmetric branching like that is unbalanced with one thing looking like the default thing and the other more like an early exit check for something exceptional.
I'm strongly in favour of early returns and avoid else case like plague. &amp;#x200B; If you can do early returns do it!
I don't understand why lines of code is still a way to measure something.
To play devils advocate here, I would personally suggest refactoring so that there's only a single return statement. That means you might need the `else` clause after all - depending on if `somethingElse` is computed or just a constant. But it means that the entire function has only got a single happy path out, and you don't need to read the whole function (which might be a lot longer than this one) to see if there are any special cases that can return. It also means that you have a single code path after your if block where you have the result value. This lets you do things like inserting code that needs to react to the return value, or logging it out, or debugging, or anything like that. The end result here would be: ``` function foo() { let result; if (bar) { result = something; } else { result = somethingElse; } return result; } ```
Yes, exactly how I think. It is a bit subjective, but I almost always do the refactored if-only, but sometimes things feel too similar and like they belong on the same level in two different branches (equally indented). Just makes it more obvious that they are two equally valid branches.
&gt;Single-Return works much better in expression based languages. Functional programming languages tend to work this way and it feels a lot more natural there. In functional languages? It's really common to see pattern matching code where each pattern matched returns a different result. &gt; Single-Return is good practice in languages with manual memory management such as C, which I think is where the mantra comes from. That was my understanding too. I've seen people blindly try to apply this as a "best practice" without weighing up the pros and cons. It doesn't make sense in modern imperative languages in my opinion but it does in C.
The problem I have with the refactor is that it doesn't make it explicit that the else block should only happen if the first block doesn't. "Clearly it can't execute if there's a return statement in the first block" seems to be a common argument. Checkmate atheists! What happens when a junior developer goes and refactors it so the first block is now in a Lambda function? The return is now only returning from the lambda. (In fact - are you 100% certain that's not the case in OPs example? Without going back to double check, are you absolutely 100% certain you didn't miss it?) Now the execution falls through to the second block. The entire meaning of the function has changed due to a change that's really easy to slip through on code review. An explicit "else" means the intention is explicit. It means the next developer to come along and work on that code knows that, and it means a refactor is far less likely to inadvertently change that behaviour. And before you say "I wouldn't make that mistake". Yes you fucking would. I've seen this exact mistake happen, along with countless others. Code defensively. Make intended behaviour explicit. Don't make things slightly ambiguous just to save 2 fucking bytes. 
If I were building a production system, I would certainly use some kind of database. And as already said, it wouldn't hurt to demonstrate your SQL skills. But this is an assignment for a junior position so I would be happy with a simple solution that solves the problem. I believe that you don't need to store all rows in memory or database because presumably you're generating some kind of static report. For example to calculate total of a column, you read the CSV line by line and add a value to the total sum. So your program reads in the data and extracts the interesting information. Disclaimer: I don't know all the requirements and your recruiter/reviewer might disagree with me. In the end, you should do what feels good with the skills you have. Good luck.
Eh, I can go either way on it
But if you have to introduce a state variable to hold a return value that you might assign to in more than one place, then it’s necessarily mutable because you have to declare the variable with let or var, not const.
If the if-part becomes large while the else part is short, it's often better to instead reverse the condition. F.ex. if(foo) { lots of junk lots of junk lots of junk } return justSomeShortStuff(); We can swap them around: if(!foo) { return justSomeShortStuff(); } lots of junk lots of junk lots of junk
Great explanation. It basically boils down to syntactic clutter. The more syntactic clutter, the higher the cognitive load when reading it. That the word "else" makes it clearer is a fallacy unless your code is expected to be read by non-programmers. Also, kudos for dropping the else down to the next line in your extended example of the first function. A lot of programmers write with their code condensed over fewer lines but I prefer to write mine with clear visible separation between blocks and other code. I also write code in blocks like paragraphs, grouping related statements and separating them with an extra line break for clarity.
I think you missed the point.
I agree with most of the other commenters here that the 2nd is the way to go. Consider a longer example: function foo() { if (bar) { return something1; } else if (baz) { return something2; } else if (beans) { return something3; } else if (fizz) { return something4; } else if (buzz) { return something5; } else { return somethingElse; } } compared to: function foo() { if (bar) { return something1; } if (baz) { return something2; } if (beans) { return something3; } if (fizz) { return something4; } if (buzz) { return something5; } // still here? return somethingElse; } The primary difference is readability, of course. We don't need *any* else statements. From a logic standpoint, we recognize that at any one of those points, we return early. A more realistic example is something like the following: function registerUser(user) { if (user["name"] == "") { return "Name required" } if (userExists(user)) { return "User already exists" } user = mergeDefaults(user) err = save(user) if err { return "Oops, something went wrong!" } return "Success!" } To do the above with your version, it would look kinda gnarly with a few levels of nested-ness: function registerUser(user) { if (user["name"] == "") { return "Name required" } else if (userExists(user)) { return "User already exists" } else { user = mergeDefaults(user) err = save(user) if err { return "Oops, something went wrong!" } else { return "Success!" } } } Hopefully it's clearer that the else-less one is cleaner and easier to read. (That said, I think this is kind of semantics and not a particularly useful distinction to make, so you should definitely use Prettier or some other linter/formatter to automatically make these decisions for you. It really eases the cognitive load of writing code and lets you focus on functionality over style.)
Ultimately I still think it's comfortable level of abstraction. If the question is simply can a library like stage0 or domc create components like that the answer is yes. Can they be easy to use? Also yes. Would I use it to do such a task? Maybe. But it's a lot more subjective. I personally like a higher level of abstraction for most things, but it doesn't detract from its ability to accomplish the task or the specific value it provides. I will say for the purpose of these benchmark stage0 especially on the edge of what a "framework" is. There is intentionally no jQuery implementation and stage0 is barely different in that it is basically some helper functions built on top of DOM selectors. All that being said in terms of subjective I like when libraries "automatically" schedule rendering on data changes rather than explicitly calling an update or render function, it's a small thing and can be approximated other ways and that is something that can vary greatly between libraries here. It is completely unnecessary but I place value in it. So for me I'm picky so I want to pick and choose what I like, but there are many many other reasons to base decisions.
I prefer this over if statements always. 
I'm strongly for his refactor. Code is generally much better without "else".
If he wants you to change your behavior then just enable [eslint's no-else-return](https://eslint.org/docs/rules/no-else-return) rule. It's much easier to get someone on board with the pattern if there's a rule that complains each time you break the rule.
&gt;In functional languages? It's really common to see pattern matching code where each pattern matched returns a different result. Kind of. In functional languages a "switch" or pattern match is usually an expression, not a statement. This essentially means you don't actually use a return statement - the pattern match just evaluates to the value of whichever condition matches. There's usually no return statement involved anywhere in functional code. It's an implicit Single-Return. 
Agreed, this basically comes down to the "early return" technique everyone is talking about in this thread, which I agree is much more readable than a bunch of if/else
The refactor is better. I believe it also has a technical reason about it, I remember reading about it in eloquent javascript or javascript patterns but I can't remember. 
While both are fine, let's say you needed to put more logic inside the else statement, say, another if-else statement. Nesting these makes your code pyramid-shaped, which is harder to scale, harder to to debug, and flirts with [Callback Hell](http://callbackhell.com/). 
Thanks. I am working on some of my ideas of my own in this space. I hadn't seen Ab Initio before and its good to get some perspective.
Single return every time where applicable
Thanks! The assignment is pretty open ended, all they require is to produce some graphs and explain the process. 
Since you show the logic being in the `if` branch, I prefer to refactor the if to a guard clause (ie in this case the else branch. Then early return from the guard branch. I prefer guard clauses so that the actual logic goes in the function body, unindented.
This is a very good side note of the example. Extremely relevant for your javascript code. Not necessarily because of the optimization, but for both readabity and explicit null testing.
Which principle do you believe states this? :)
Yep. Unless someone tries nested ternaries. Idgaf what Eric Elliot thinks. Those are an abomination
A lot of senior devs also have the habit of overengineering code and being clever. I really don't like this mantra at all. Sometimes being verbose is better than being terse but ambiguous
I follow my own coding standard which is based on semantics. Assuming "logic" is empty then, - If the 'if' block is a "guard block" unit/statement, then the refactor is correct. Coincidentally, Swift has a similar language construct with a very similar name. Check that. - If the 'if and else' are a "return block" unit/statement, then yours is correct. Assuming "logic" is not empty, then only yours **might** be correct. It depends on the semantic of "logic". In the end, you should have a single return unit/statement that is that of the most factored form of the function.
The second function with the early return looks more like a guard clause to me. I'd make a case-by-case judgement call depending on the actual logic of the method. If the `if` and `else` blocks have "equal weight", i.e. they are about equally likely to execute, I'd leave it as your original version so it's clear to the reader that an either/or decision is being made. If the `if` block is returning early because the function can do no more meaningful work (e.g. some argument was null), I'd go with the second one. I would not leave this decision up to a linter.
You lost me in your last paragraph: \&gt; No developer should be expected to know this. but \&gt; Any good developer should know why it’s true Is a bit of a self-contradiction :-) Of course I would expect a developer to explain *why* it’s true (frankly, off the top of my head, I do not remember the explanation of how floats are represented in memory and how floating-point precision works, but I think there are languages/environments for which this particular behavior is different (see [https://0.30000000000000004.com/](https://0.30000000000000004.com/))
&gt; There's usually no return statement involved anywhere in functional code. It's an implicit Single-Return. That sounds like using different words for the same concept though. A switch statement with returns for each case in an imperative language is very similar conceptually in terms of how you would read and understand it to pattern matching code with a final result for each case in a functional language.
I might be missing something but this seems supported to me so long as you set the type when you define the constant: [http://www.typescriptlang.org/play/#src=const%20upvoteString%3A%20'upvote'%20%3D%20'upvote'%0D%0A%0D%0Atype%20Post%20%3D%20%7B%20thisPost%3A%20'upvote'%20%7D%0D%0A%0D%0Alet%20p%3A%20Post%20%3D%20%7B%20thisPost%3A%20upvoteString%20%7D](http://www.typescriptlang.org/play/#src=const%20upvoteString%3A%20'upvote'%20%3D%20'upvote'%0D%0A%0D%0Atype%20Post%20%3D%20%7B%20thisPost%3A%20'upvote'%20%7D%0D%0A%0D%0Alet%20p%3A%20Post%20%3D%20%7B%20thisPost%3A%20upvoteString%20%7D)
You're right, I think I'll focus on making the visualization better.
A scaleable way to showcase all of your Github projects. Can be fully set up in a few minutes. Built with Create-React-App [Github Link](https://github.com/simondiep/github-project-showcase) [Live Demo](https://simondiep.github.io/github-project-showcase/)
Wait, linters can solve this kind of complex case? Like re-arranging if/else statements? Or only when they are as simple as the example provided?
Use an opinionated linter.
Pretty nifty project! I think I'll still probably use the pythontutor website to help people visualize how their Javascript code is working, since having someone learn a *"new language"* just to bring it back to a *"real language"* is added complexity. But given that your primary purpose was to put together a language, this is a pretty nifty little way to tie it back to Javascript.
Neither. It should be function foo() { if (!bar) { return somethingElse; } // logic return something; } It's called a guard clause and prevents having to write a bunch of nested logic inside of an if statement. https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html
Build web apps with native os functions - neutralino.js.org
There's a way to do this in functional programming without the magic - By using currying, function composition and "lifting" a function into a promise-aware function. It's a different mindset though, so I can understand the preference for a proxy-based approach. function compose2(fn1, fn2) { return (...args) =&gt; fn1(fn2(...args)); } function pipe(...fns) { return fns.reduceRight(compose2); } function liftP(fn, ...args) { return promise =&gt; Promise.resolve(promise).then(value =&gt; fn(...args)(value)); } function text() { return value =&gt; value.text(); } function split(sep) { return value =&gt; value.split(sep); } var fn = pipe( liftP(text), liftP(split, ',') ); var promise = Promise.resolve({ text() { return Promise.resolve('one,two,three') } }); fn(promise).then(value =&gt; console.log(value)) &amp;#x200B;
Yup. Whenever I see a codebase where one Dev touched every file because they decided to enforce tabs over spaces (or vice versa) it makes me cringe. Establish a standard. Stick to it. Especially when it’s little more than semantics or opinions about “what looks better.”
Thanks! I didn't like pythontutor that much because it got messy when I added a more complex heap structure like in my example. Visualizing the heap gets tricky fast, though. pythontutor also has does requests back and forth to the backend and that makes it slow and it gets frustrating quickly for some people. But, I see your point, probably the better approach is to have the visualization work well for a subset of a real language ( if not the whole ) instead of forcing beginners to learn a toy language.
The concept being discussed is not early returns. Sheesh.
When they are like op. Eslint has a rule about returning from else in if else. There are possibly other rules that cover what you might want though. I know for example jetbrains ides can invert if else and stuff so it’s probably not impossible for linters to recognize some unwanted use of conditionals and rearrange them
Choose a styleguide with your team, like airbnb's eslint conf and let the linter deal with it. It's not a huge issue either way, so just deciding on a standard allows you to spend more time on harder problems. 
Not sure why this is not getting more upvotes. 
Yes there are existing algorithms that do just this. [Heap's algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm) is meant to find all possible permutations of a group of objects. You should be able to use this pretty easily by calling split() on the string you want to find permutations of.
I agree, the first way is clearer, you should be writing it because it makes your intent specific. If someone goes and edits the code 10 years from now, will they know this is intended behavior? Don't write your code for you, write it for someone else. This is a semantic error waiting to happen. Someone throws a logging statement after the if and the logic silently fails. I have dealt woth too many bugs that came about as a result of this type of coding. 
Isn't this just doing the same thing as const copy = { ...rivenStats }; Alternatively, const copy = Object.assign({}, rivenStats); &amp;#x200B;
Node REM - NodeJS Rest Express MongoDB and more: passport, JWT, [socket.io](https://socket.io), HTTPS, HTTP2, async/await, etc. - [https://github.com/ngduc/node-rem](https://github.com/ngduc/node-rem)
&gt; What happens when a junior developer goes and refactors it...? code review?
The better middle ground option is the following... return bar ? callTrueLogicThatReturnsSomething() : callFalseLogicThatReturnsSomethingElse();
To me it’s tomato tomáto. It’s one of those things where I feel like developers learn a “newer” way to do something and then advertise they know it by pushing it on anyone else, where possibly. It’s **literally** about priority. If the priority is fewest lines of code possible, the option missing the else wins. If priority is code readability (like if you have a lot of juniors on the team), I might go for the one with the else. At the end of the day, it doesn’t really matter at this scale. If you had an app with 100 methods all written in the same way as the example, I’m inclined to vote for the one without the else just to keep it as simple as possible. Others will have other lines of thinking... like I said the two are virtually identical from a practicality standpoint. 
Babel actually does have a [browser version](https://github.com/babel/babel-standalone/) 
You should probably break that complex nested functional logic in to multiple functions, which would then return this to having no else statements
The null check should be fine. [comparing-nulls-to-undefineds](https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch4.md#comparing-nulls-to-undefineds)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**ch4.md#comparing-nulls-to-undefineds** (master → 0cc17c5)](https://github.com/getify/You-Dont-Know-JS/blob/0cc17c53ff772e20dfd6a7072c965df2486116e8/types%20%26%20grammar/ch4.md#comparing-nulls-to-undefineds) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e6v6yau.)
The issue here is that `var num` is only going to be evaluated when the page loads. You are not changing the value of it as the user submits input. I would suggest changing the var num to a function that can be reused and then when you verify that the input matches the number you can just check the html added for the last number (this avoids using a global which is generally considered good practice as the global namespace is already fairly cluttered). &amp;#x200B; I would do something like: window.onload = randWord; function num() { return Math.floor(Math.random() * 2); } function randWord(){ document.getElementById("word").innerHTML = num(); } function ver(){ var i = document.getElementById("i").value, value = document.getElementById("word").innerHTML; if (i==value){ randWord(); } else { document.getElementById("test").innerHTML="1"; } }
It would be fine except that ```throw "Parameter bar is null"``` clearly demonstrates a misunderstanding of what's happening. ```bar``` could be ```undefined```, in which case the error message here would be reporting misinformation.
I read that reply and thought this. First 10-20 lines? implying there's more than 10-20 lines per method? Sounds like either very complex stuff or spaghetti coding going on...
You can do it with following algorithm idea: \- to solve task for 3 elements, we extract 1 element and solve task for 2 elements (making task simplier) \- trivial task with 1 element will return itself (as array of 1 element --- 1 permutation) So it comes to next code: function f (a) { if (a.length === 1) { return [ a[0] ]; } var r = []; for (var i = 0; i &lt; a.length; ++i) { var b = Array.from(a); var c = b.splice(i, 1)[0]; f(b).forEach(e =&gt; r.push([c].concat(e).join(''))); } return r; } console.log(f([ 'a', 'b', 'c', 'd' ])); so basically, a --- our initial array (4 or 3 or 2 or 1 element, depends on input; each call to the function solves its tasks by breaking it to smaller pieces), b --- clone of a (we need it because we are about to splice element from it), c --- the element we are removing from the array to make initial array smaller and overall task simplier, r --- result array of permutations for current input a. &amp;#x200B; f(b).forEach(e =&gt; r.push([c].concat(e).join(''))); this line might seem hard to read, but all it does is: we call ourself again with smaller task (b), the result will be array of possible permutations for b, so we iterate each result and add c before each result; we also store result in r.
I personally prefer having a single return statement per function overall. Makes the code more readable and less prone to bugs while refactoring. However, that being said, in certain cases returning early makes sense too. I think Code Complete has an opinion about this as well along the lines of having less number of return statements per routine.
Yep that's what I was getting at. You might also use it in React and Angular without realizing it: class Foo extends React.Component { render() { return '123'; } } Is really just shorthand for: function Foo() { React.Component.apply(this, arguments); }; // instance property inheritance Foo.prototype = Object.create(React.Component.prototype); // class (static) property inheritance Object.setPrototypeOf(Foo, React.Component); Foo.prototype.render = function render() { return '123'; }; Also in Angular 1 (not sure if still the case in Angular 2+) the `$scope` variable used prototypical inheritance for accessing parent `$scope` variables. 
I prefer the refactored code. It scales better. With his style you have the early-exit pattern. Meaning as soon as you have an answer you return it. With the style he uses you can add another if without having extra nesting and elses. function foo() { if(a) { return answer; } if(b) { return answer; } // etc return fail; } 
I guess it depends what you call a senior dev. Making clever code is a very junior move to me. In fact, a very senior dev thing to do is to "improve existing code" by taking clever stuff and re-writing it to be easier to read. I can understand where you are coming from though. The quote is not meant to be a celebration of terse clever code. It's meant to point out differences in thinking. Junior devs think the solution is always adding more code. Make more sense now?
I strongly disagree. Multiple returns also introduce "state" and "room for error" for every scattered/buried return statement that transitions the function to the "returned" state. A common return variable is a benefit because it gives you a single thing to put a conditional breakpoint on. Besides readability and debuggability, my strongest argument for single point of return (after early exit returns) is extensibility. If you ever need to add garbage-collection, logging or any common post-processing before the function's return, you can easily add that in a single place. If your function started with multiple returns you'd be forced to add redundant post-processing code before every return or refactor your function to be single-return anyway. 
I bet if that page had comments there would be many.
HTML is already fast and developers already know how to make fast websites. It's the stuff thats put on the page, usually ads and media from business and marketing teams, that makes it slow. AMP is a random fork of HTML that creates more work for publishers to maintain a second version of their site instead of working on the main one which is universally accessible to everyone on the web. The fact that AMP is also cached on a separate domain owned by Google leads to privacy issues and a general loss of control. AMP caches can technically be operated other companies but the only other public one is from Cloudflare and its use is basically non-existent so Google is effectively hosting the entire AMP internet. AMP's entire claim is about page speed, but Google already measures speed and can therefore use those in search rankings as a big signal. If it did, sites would automatically become faster very quickly as they optimize toward search rankings. Everything AMP does is a solved problem. It's an interesting experiment to try out new ways to make pages faster but it should be used to make browsers and HTML standards better, not create a different internet UX owned and managed by a single company.
Shorter functions are pretty much always more readable than longer ones. There's no point making all your functions longer for the rare case where you might need the things you mentioned.
Nope, there's no real difference in functionality between these two approaches.
The refactor is much better! They might be few cases where the \`else\` block is welcome for readability, but generally I prefer to avoid it.
These are not two types of inheritance. `Object.create` just provides a nicer way of creating new objects than the `new` keyword. In the first case, an object `o` is created which delegates property lookup (or "inherits") to the object `f.prototype` (which is an object which is created on all function definitions by default in javascript for questionable reasons). In the second case, an object `p` is created which delegates property lookup to the object `o`. Completely the same thing going on in both cases: prototypal inheritance, the only difference is how you created the objects. The constructor in the first case is not affected by invoking it with the `new` keyword. There is no constructor in the second case.
I enjoy posts like this; I like code reviews. 
You spelt if(!b) wrong.
I frequently touch nearly every file in an attempt to bring us back to the company’s established standard...
I find the latter to be more clear and readable.
I don't know man, it might seem little now but you have to remember that beginners read this stuff and think that this is THE way or they simply give up being overwhelmed by the complexity. We have to set the right example... Even in the little things :)
``` return bar ? something : somethingelse; ```
A bit nit picky but his refactor is best practice. 
The refactor is better as it reduces cyclomatic complexity. The else case is going to happen regardless if statement doesn’t meet the criteria. It is less cluttered and much easier to read that way. 
I personally prefer the first one. eslint likes the second one. I like to defer style discussions to whatever eslint does. Then I get to say to the team that’s not personal, we win some and lose some, but overall at least we’re following the most popular linting tool defaults.
I think adding a break before the return is clear and concise enough: function foo() { if (bar) { // logic return something; } return somethingElse; } 
What do you excatly mean with 'shortcuts'?
I prefer the latter. Acts like a default return value in my opinion. You can check for errors and if all the ifs passed then you return something positive or something like that
Neither. Ternary ``` return (bar) ? something : somethingElse ``` But regarding those two items I prefer the second. Remove any control flow that isn't needed.
While it's not a catch all, I'm assuming the `// logic` is, well, a placeholder for all of the logic of the function.
I think yours is more readable but the most important thing is that you are consistent.
I prefer your version because it feels more easy to read but thats my opinion.
I like: function foo() { let result = somethingElse; if (bar) { .... result = something; } return result; } 
I'm 100% on board with his change. IMO, code should be indented as far left as possible. It's not "if A, then if not A." It's "if exception, handle and stop. Then, actual method."
Fair enough. I was just commenting on the previous poster’s claim that it was about mutable state when to have one variable holding a return value set in more than one place, that variable needs to be mutable.
Everyone has chimed in perfect answers already. I will add that if you add an extra line after the close if, it will help with your readability. If(){ //something } Method2(); It splits up the eye and allows easy reading.
The ECMA writes the standards. It's up to the browsers and Node team to implement those standards. So, there isn't just 1 group that creates "javascript". Which, is why every browser implements certain things differently. 
The early return pattern is far superior as it shows intent, and is explicit. You write clean code for the people after you who have to touch it, not for any other reason
What is the company's standard? That's what you should be using. If there is no standard just tell him to fuck off, and start looking for a new job.
so in the web app we would have to find a player then click buy now then click yes but there was a google chrome extension that would do all that with a binder key
This is personal preference and not an objective improvement to code quality. This kind of thing should NEVER come up in a code review. 
so the browser engines implement the standards set out by ecma? then i assume the javascript syntax and ecmascript syntax are the same?
Basically. It's also why the latest version of Javascript is ES6, which is short for ECMAscript 6. 
It’s worth noting that ESLint prefers your coworker’s style. 
This is the way to go
&gt; In electron and NWjs you have to install NodeJs and hundreds of dependency libraries. Embedded Chromium and Node creates large overhead and makes even simple apps like “hello world” considerable in size. Neutralino offers a solution for this issue. I agree this is a big issue, glad this exists :) Maybe LoL will replace their bloated electron client with this...
Early exit single return is just one of those patterns I think everybody should be aware of.
&gt; One other problem I'm facing is that on one route i need to query multiple different apis and i don't know how to do this considering you can only send one res.send(). So on one route, your proxy server makes a request to several APIs? The solution here is just to not send a response back to the client until you've collected all the data you need from the APIs (you're likely going to do a Promise.all somewhere in the code ;)) You'll probably want the client to hit your proxy server rather than hitting Zendesk yourself; dunno if their API is even CORS enabled.
&gt; there was a google chrome extension that would do all that with a binded key What happened to it?
I want the key '1529ee5f-7a45-40fc-ab11-740d1188e122' with all the key value pairs inside it. Your snippets just ouputs the json inside 'notes'. In order to go deeper I will still have to use hardcoded keys.
Nobody here are mentioned this yet, but Ava is really becoming popular: https://github.com/avajs/ava From the README, &gt; Even though JavaScript is single-threaded, IO in Node.js can happen in parallel due to its async nature. AVA takes advantage of this and runs your tests concurrently, which is especially beneficial for IO heavy tests. In addition, test files are run in parallel as separate processes, giving you even better performance and an isolated environment for each test file. Switching from Mocha to AVA in Pageres brought the test time down from 31 to 11 seconds. Having tests run concurrently forces you to write atomic tests, meaning tests don't depend on global state or the state of other tests, which is a great thing!
Definitely the refactor, reduces surface area for bugs. You might also consider using ternaries in place of the example provided
You just have to be careful when you code. Of course, mistakes happens once in a while, even for experienced developers. But as you gain experience such as this, you'd be forced to be more careful when passing arguments to a function. You might remember how you made the mistake, then you'd think that you won't make the same mistake again. The more experience you get, the less mistakes you'll make in the future. In case a different mistake happens, instead of asking for help, try to retrace/debug your own code. By doing that, it will give you experience on how to solve a problem. Getting more experience on this matter will give you quicker response on solving a problem. i.e. you'll pointpoint the source of the problem more quickly. IMO, asking for help should be done as a last resort only. When you're stuck on solving a problem, try finding the answer yourself by searching the net for a similar problem. I can guarantee you that you'll learn something new in the way, unless you're already an expert and your problem is already one of the top most difficult problems in the world; or you're making something entirely new.
Sure thing. Ab Initio is kinda obscure. They don’t advertise or market themselves basically at all. Many of the biggest companies in the wold have big deployments of it tho. Similar products are IBM Datastage and Informatica
I made a tiny library for algebraic data types: [https://github.com/masaeedu/adt](https://github.com/masaeedu/adt) Also comes in gist form for easy copy pasting if you don't want a dependency: [https://gist.github.com/masaeedu/448889432b72440b156837c3806c2ba7](https://gist.github.com/masaeedu/448889432b72440b156837c3806c2ba7)
Kinda reminds me of https://github.com/okwolf/hyperapp-fx Obviously you can't use hyperapp-fx for Node.js, but similar concepts.
I agree. Why write an else block if you really don't need it. Saves time and space.
FTFY const arr = [] const notes = snapshot.val()['notes'] for (const outer in notes) { for (const inner in notes[outer]) { const obj = {} obj[inner] = notes[outer][inner] arr.push(obj) } }
Second of course. Less verbose and less likely to get turned into some condition and regress.
Not a big deal, is pretty random/not much context. When you have that external webworker file(that's just a counter) and you initiate this from another file(main file) that starts the webworker... I think it's a thing where it doesn't work locally in a dev environment/has to be on a live server... unless it's just about localhost. Anyway nothing important just rambling on my part.
Just wanted to correct a few things. &gt; When you create an object with new, its __proto__ is set so that it refers to the constructor function's prototype property. `__proto__` is [nonstandard](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) and shouldn't be used, even if some JS engines still support it. &gt; The second method (using Object.create) requires that you access __proto__ directly if you want to walk the prototype chain. If you want to walk the prototype chain in either case, you'd use the `Object.getPrototypeOf`method. For the example you provided: ``` console.log(duperman instanceof Superman); // Uncaught TypeError: Right-hand side of 'instanceof' is not callable ``` This amounts to a misunderstanding of how `instanceof` works. The `instanceof` binary infixed operator follows the type signature: `[object] instanceof [function]`. If you pass in `[object] instanceof [object]` as you've done above, it will (and should) throw. If you wanted to check if one object exists in the prototype chain of a second object you'd use: `Superman.isPrototypeOf(duperman)` &gt; `Object.create(null)` might save you a tiny bit of memory if you're working with billions of objects, since it's missing all properties by default, but it has some quirky behaviors as a result of these missing properties. This isn't actually true, the properties you're "missing" in this case still exist in memory on `Object.prototype` which is exactly where they exist whether an object is created using object literals, or `Object.create(null)`. This is one of the defining features of prototypal inheritance that, at its core, it's simply a method of defining property lookup delegation, properties on the prototype are not "copied" over to all objects lower in the prototype chain. &gt; Essentially, `Object.create` is the method you use when you've got extreme performance issues to consider or when you're trying to build a fundamental, paradigm-shaping library I see the point you're trying to make, but it's an opinion and it's one I think a lot of developers would disagree with.
The refactor is more efficient and easier to change when you figure out later that you need to add another `if` statement with its own return.
I'd rather just write code that wasn't brittle to begin with. 
Hi /u/Andrew9768, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
Hi /u/subrat_msr, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
the second is not only more readable, it highlights the expected path. when you put guard / early return statements at the top of the function, you can be sure that everything after the `if condition, return` is the function as it's supposed to be run. with the first form, the main logic of the function is indented in an `else` block, which makes it seem like an afterthought.
+1 refactor for all the reasons mentioned by others. I think one of the reasons is because the else is rarely that trivial and you'll probably have a bunch of code, and therefore whitespace. I tend to look at whitespace as a layman's cognitive complexity indicator because generally speaking more nesting equals less clarity because you are compounding execution branches which equate to compound test scenarios.
How can you establish a standard to stick to without going back and fixing the broken files?...
&gt; " &gt; *This amounts to a misunderstanding of how ```instanceof``` works.* &gt; " I'm fully aware of that ```instanceof``` is meant to operate against a constructor function *(and if I weren't already aware, this expectation is laid out almost in plain English right there in the error message lol)*. The point is simply that this is one of the areas where the two methods do not behave identically. Even if you do ```child instanceof parent.constructor```, ```instanceof``` won't behave the way you'd *"expect"* without manually fiddling around with things. The basic idea is that ```Object.create``` is a much more *"raw"* approach for creating objects that [sometimes leads to headaches](https://stackoverflow.com/a/12705137).
Hmm, I can kinda see the situation you pointed out, but let's see if I got it right: * Junior developer refactors first block into a function, and the return gets taken out as well, instead of return the result of the function * The final block executes when it shouldn't While I agree that the else block approach would surely avoid the execution of the else block, it would **still return the wrong value**. And this could be a potentially harder to track bug. If you have logging in both segments, if you have the else block your logging will look "right", since it is executing what should be executed, while in the other case it will be pretty clear that both segments executed.
Nothing worth arguing about, it is up for debate. Just change it. If that is the only issue with your code, then your doing a good job, keep it up.
I am working in a company in a giant codebase. We use a linter for consistency but not so far that we dictate on how to write an if else construction. 
I usually point people to this talk https://youtu.be/XDqZemwVXUk I tend to avoid else's when possible due to this.
Not at all. No one should know if any specific floating point calculation will result in a loss of accuracy, but if it happens you should be able to explain why. The question basically asks “what is 0.1 + 0.2”. Knowing that it doesn’t equal 0.3 *in this exact case* is absurd since this breaks randomly with about 20% of all calculations like this.
Did you establish the company's standard? ;) 
I had to scroll down to damn far to find this.
In a specific case like this I think both are OK although your way might be slightly more readable if both cases occur frequently. In a lot of cases I would prefer the other but it depends.
Use setInterval or a recursive requestAnimationFrame that updates the enemy's location. To make him closer to the player, subtract from his x or y coordinates if they are greater than the player's or add to those coordinates if they are less than the player's.
Well, I have seen a “concert tabs to spaces” and then “convert spaces to tabs” - I do feel it depends on the team and the codebase. Sometimes one person can hit everything. But in my (anecdotal) experience, update as you go. This depends on how monolithic your code base is, and if you can update pieces as you move forward, unless it’s like earlier code bases I have worked in where they’re thousands of lines handling complex logic that was never broken out into modules. Really, I feel like updating ties into communication, and making sure people keep pulling in master. 
 const x = { "notes" : { "1DirZQovvSQjURmLH6FmSEIAeE52" : { "1529ee5f-7a45-40fc-ab11-740d1188e122" : { "color" : -2937041, "description" : "{\"note\":[{\"format\":\"HEADING\",\"text\":\"Jjk\"},{\"format\":\"TEXT\",\"text\":\"Z\"}]}", "folder" : "", "locked" : false, "pinned" : false, "state" : "TRASH", "tags" : "", "timestamp" : 1538123875034, "updateTimestamp" : 1538141384917, "uuid" : "1529ee5f-7a45-40fc-ab11-740d1188e122" } } } }; /* if you know the names of the keys in advance, you can use this aproach */ const lookup = (x, key) =&gt; typeof x === "object" ? x[key] : x; const getPath = (keys, obj) =&gt; keys.reduce(lookup, obj); getPath([ "notes", "1DirZQovvSQjURmLH6FmSEIAeE52", "1529ee5f-7a45-40fc-ab11-740d1188e122" ], x); /* However if you don't know the key names, and instead just want to assume the strucure of the object...use this approach */ const firstProp = obj =&gt; Object.keys(obj).shift(); const getDepth = (d, obj) =&gt; d &gt; 0 ? (typeof obj === "object" ? getDepth(d - 1, obj[firstProp(obj)]) : obj) : obj; console.log(getDepth(3, x)); 
just to the browsers. the node team uses v8, which is google chrome
There will still be times when a bulk update is necessary. Say you update what version of Prettier you are running and have linting in your pipeline. Would you rather move every file to a lintignore file, or let prettier do it’s thing? I’m not saying that large updates are *always* the solution, but sometimes they’re the right way to go and aren’t always an indicator of something bad. Just someone caring about code quality. - That Guy who does the big updates at his workplace. :)
i made a template language that uses javascript strings in a very simple way to build DOM nodes. github: [https://github.com/ahmedyoussef70/butterfly-template](https://github.com/ahmedyoussef70/butterfly-template) &amp;#x200B;
You should be discussing this with your coworker
But if they started with ES6, why were they using apply? The latest standards aren't just for more features, IMO they simplify development for everything, newbie to expert. I think babel lets you know less =P
I totally agree. The more you know about programming overall, the better you can avoid buggy code! The thing is, you need to COMPLETELY know the thing. So having a half baked knowledge of the concepts phpdevster mentioned is worst than having no knowledge of them, IMO. If you sorta know something, don't use it, or consider it, until you fully understand it. Once you fully understand it, it can only do you good.
I'm sorry.
Precisely. It's an ambiguous concept based on context, so best to avoid it.
ummm because you don't need them if you transpile your code using babel. You don't need them. (at least I can't think of a case at the top of my head and I know I haven't needed to touch them for the last few years of my career [not including TRUE this... like in a React class])
Yes. like /u/notAnotherJSDev said. Here's a little more insane history - some of which is in the wiki, so apologies When JavaScript was created in 1995. It was originally called Mocha then LiveScript. However, due to the popularity of Java, they decided to piggyback on that bandwagon and called it JavaScript because of Netscape and Sun working together. This seemed like a good idea, however led to the confusion of everyone for the next 23 years (see Rule #4 in the sidebar). Given trademarks and the massive competition of the late 90s, Microsoft's IE (which also supported VBScript) called their implementation of the language JScript. MS also had their own JVM and trademark / licensing issues with Java during this time as well leading MS to abandoning their JVM at the time. JScript as a name never took off and I don't recall anyone calling it that outside of MS documentation. ECMA comes in to play in 1997 / 1998 creating an international standard for the language. However it took nearly a decade and a half+ to really have all of the major browsers in sync. Hell, there was a brief time when you could put the version of JS in the `&lt;script&gt;` tag via something like `&lt;script type="javascript1.2"&gt;` IIRC. Google has taken on MS' old role of just doing things they think is best regardless of consequence. But to be fair, MS introduced XMLHttpRequest in \~1999 and nobody really did anything with it for 3-4 years.
Even with a longer you still get some stylist differences I usually just follow whatever they already use. If it is different then what I am used to, I keel up with it. What is better to decide a style than to try all of them for an extended period of time at a professional level. 
If the ternary got long I’d break it into a conditional section. I don’t want to process value A **and** value B when I’ll only need one of them. 
Have you written any code in a Lisp? It’s different from what you’re describing. 
The refactored version. The else after a return is pointless.
This feels like an [XY Problem](https://en.wikipedia.org/wiki/XY_problem) to me. Are you just trying to grab the data from Firebase? As a Google product, it follows the *"reactive"* paradigm *(like RxJS)*, and something like this would do the trick: let notes = {}; var rootRef = firebase.database().ref(); var notesRef = rootRef.child("notes"); notesRef.on("child_added", function(snapshot) { notes = {...notes, ...snapshot.val()}; console.log(notes); // Will be {"1529ee5f-7a45-40fc-ab11-740d1188e122": ...} });
I am really lost, could you kindly explain. &amp;#x200B;
My preference is for the sake of readability (and even that is relative and debatable). I completely agree with you that a `reduce` is more performant.
Fuck that. We use an auto formatter.
Only because of readability. If performance is needed, a reduce is probably better.
This is not a “silly subjective thing”. One of these is objectively better. It is fewer code blocks, fewer code paths, fewer lines of code, more easily readable, and has a lower cyclomatic complexity. This is why you **have** code review and PRs.
Components should be isolated from each other so that they can be used standalone and the order in which you load them does not matter. As you mentioned though, in order for them to be useful, they also need to be able to modify things outside of themselves. In frameworks like Vue using Vuex, this is accomplished by having a global object that all components get a reference to. The component notifies this global object that it wants something to happen, and the global object carries out the change. You can think of it like the old-school stock market: https://qph.fs.quoracdn.net/main-qimg-a6844e970985327d56587138aa8b8ce0.webp There's one person who's responsible for updating the blackboard. Other people tell him to update the blackboard, but he's the one that actually does so. Once he updates it, anyone interested in the updated info will act accordingly. Vuex handles this by changing data in its global store. Because the data is reactive, any component that uses that data will automatically run anything that depends on that data and re-render itself. My opinion is that, in the end, everything is just JS. Unless you have limitations as to which libraries you can use, I would seriously look into either using Vue's [single file components](https://vuejs.org/v2/guide/single-file-components.html) with Webpack (the preferred route), or if you need to integrate it with an existing system and using Webpack is not an option, Vue works just like any other standard library as well: https://jsfiddle.net/yyx990803/4dr2fLb7/?utm_source=website&amp;utm_medium=embed&amp;utm_campaign=4dr2fLb7 It's a very easy library to pick up, doesn't force you to learn a huge API with weird data types, and has a lot of features out of the box that would otherwise be a real pain to write from scratch.
I am sorry if someone already pointed this out, I didn’t go over all the comments (there are too many), but your version and his do not behave the same. In yours somethingElse is onlu executed if bar is false, in your reviewer version, somethingElse always gets executed. Be carefuk with this.
To me the first one is just unnecessary, why bother writing extra characters. The less characters the easier it is to read, the less you write the more time you gain. Style is not an issue here it's what are you doing to improve how you write code. If I can gain a bit of speed and improve readability then I'm going to do it I don't care how much someone else don't like the look of it, you gotta ask yourself am I improving if I write code like the refactor shows, for me yup.
You’re very angry over this else block. 
You're pushing number[i] when you should be pushing nums. number.push(nums);
The complexity score of the first set of code is higher than the second. I'd do this: function foo() { return bar ? something : somethingElse; } That has the lowest complexity score.
I made a Windows 10 metro component. It's a pretty close replica. Check it out. [https://github.com/yuanfux/vue-metro-tile](https://github.com/yuanfux/vue-metro-tile)
You're still wrong. ES2016 has only two features, and is supported everywhere except IE11 and the Android 4 browser. ES2017 is also supported almost everywhere, except for shared array buffers, because of Spectre/Meltdown. http://kangax.github.io/compat-table/es2016plus/
I think that both are acceptable and not worth arguing about, but there is another option to only have one `return` in a function that might help: function foo() { var finalReturnValue = 'foo'; if (bar) { // logic finalReturnValue = 'bar'; } return finalReturnValue ; } 
He’s just trying to tell you to code defensively, there is no real arguments for the snippet you gave though. That being said, his methodology makes sense and I would follow his refacto. 
If we start leaving out else blocks, then what's next? The dead rising from the grave? Human Sacrifice? Dogs and cats living together? Mass Hysteria!
This is the answer plastered all over the internet, but nobody seems willing to address the "both versions exist in the codebase" issue. IE: what do you do when the existence (or lack thereof) of a certain style in the codebase _can't_ be used as an argument?
While I agree that the 2nd version is better, it is just barely. When you factor in the delays introduced (time until the writer sees that the PR has been rejected, rebuild and CI checks, time until the reviewer sees that the PR has been updated), the tradeoff for that 1% better written code is not worth it. In an international company with developers in different timezones, those delays can sometimes be 1-2 days. Delaying a piece of code over such a minor improvement is silly. Especially if they can have the working code deployed and useable, and refactor it for a future release.
You bring up a lot of points, and a lot of them are valid, especially for people just getting into JS or older folks who see the the entire community move to new frameworks and development paradigms every 2-3 years. It might help to get an understanding of the history of JS development to explain the state of JS development nowadays. Back in the day, browsers implemented their features differently using different API's, and the code you wrote for one browser was very likely not to work for another. Thus, jQuery arose as a way to standardize things across all browsers, where it serves as a common API that abstracts away each browser's own implementation. It also adds a bunch of convenience things, like being able to do method chaining and condensing down multi-step workflows into a single API call (for example, `$.ajax`). However, that's also the limit of what jQuery does: it wraps native API's into a common one, but doesn't provide a whole lot else. This was great back in the day because you really didn't want to do much else when most of the code was handled by the server and you only used JS for very simple things in the browser. In recent years, browsers have made major strides in standardization, using the same API's that work consistently across all of them. As a result, jQuery's usefulness has really waned; it served a great purpose back in the day, but nowadays there's almost no point in using it aside from sentimental or legacy reasons, because the problem that it used to solve no longer exists. As browsers became more powerful and more useful API's started to become available, we had the first major shift in JS development with the rise of client-side MVC frameworks. The idea behind them was to put the code that traditionally ran on the server and push it into the browser instead. This not only saved server resources because it no longer had to handle the rendering of pages for each client, but it also sped up the user's browsing experience because they no longer had to wait for a full network request for each link click. This gave rise to frameworks such as Angular, Backbone, and Ember, and introduced the idea of a single-page app, where an entire app would run inside the browser and only needed to hit the server for new data. This was great for a time, but after a while people started to realize that the MVC pattern still followed the idea of a single whole page that transitions to other whole pages, which worked great when pages were mostly static, but felt limiting when you wanted more flexibility. Web development was rapidly progressing into having multiple widgets, where each widget was self-contained and wasn't constrained to an idea of a page. This gave rise to React and Vue and the idea of the component system. Rather than break things up into pages, the UI is now broken up in multiple pieces that when combined together, forms the complete UI. This shifted the design of single-page apps from looking like websites, to looking like full-fledged desktop applications. In parallel with all this, tools were created to simplify development. Because the browser only parses script tags one after another, you had to write them in the right order so that if B depended on A, you had to load A first before B. This was fine when there's only a few scripts, but in modern webapps there can be hundreds of script tags with multiple dependencies that all need to be added in the correct order. Thus, script bundlers such as Browserify were invented to solve this problem. Also, people wanted to use other languages that aid in development, such as TypeScript for its type checking or templating languages such as Pug for its cleaner syntax. This gave rise to the idea of a build system that would handle all of these things, and thus Webpack was invented. Reactive data is another concept that arose out of all of this development. In jQuery, if you receive new data, it's up to you to write the code that will change out the old data and replace it with the new data. This was fine back in the day when you only needed to update one or two things in one or two places, but with the rise of single-page apps that resemble full-fledged desktop applications, it's no longer feasible to do this by hand. When you have multiple pieces of data that need to be updated across several interface pieces, it becomes a nightmare to not only write the code that handles this, but also maintain and debug it as well. To address you more directly, from what you said, it sounds like you find jQuery to be very elegant and that the current state of JS development to be messy and over-engineered. If I could put things frankly, and you do admit this point, I feel that this is due to your lack of experience and understanding of modern web development and that you're stuck in the past. Although there are parts that do feel over-engineered and and are poorly documented, on the whole the state of development has improved considerably since the jQuery days. Things that would be a nightmare to write in jQuery, taking upwards of several weeks to get even the basic implementation done, can now be written and polished in a matter of days. jQuery might seem like a very elegant solution for very small projects and personal demos, and setting up a complete build system just to display Hello World on the screen might seem like overkill, but for real apps of a decent size, you trade off a long initial setup time for vast speed improvements for the rest of the development. It's the difference between grabbing 5 sheets of sheet metal and building a shack in your back yard in 2 hours, versus months of planning out the foundation that you plan to build a skyscraper on.
Here’s one: view page source to see the code. Did this many years ago so don’t judge. http://subterrane.com/files/permutation_table_generator.html
Which one? Does it play well with multiple IDEs?
spaghetti probably 
I totally agree. It also enforces the "default" behavior of the method. Another thing I like is seeing this: function Work(SomeObject obj) { if(!Authorization.Valid) return BadUser(); } if (obj == null) { return null; } if(obj.Value == 0) return new SimpleObject(); } //Now get complex if(obj.SomeList.length &gt; 0) //logic on SomeList } if(obj.ChildObj != null) //complex operation with child object, distinct in need from the fate of SomeList } } If the "if"s returns a new object, basic type, or different implementation of a interface. For example, if the logic in this case is the the input is null, has no value, or fails basic criteria. Imagine if an API call can either fail to validate the requesters permissions, it has a flag attached to the request, or there is a basic response available. For example, you can't create an invoice in the system that is charged $0.00. It automatically produces an instance that never requires any configuration, like an Invoice object stamped with "Invalid". I like this look because it emphasis that the logic can produce 3 different results in 3 totally distinct way. Authorization at a security level, invalid input in the technical manner, and some instance that the work can so easily return a specific response that a easily understood result is in order. 
Interesting article, but I'd say only #5 and #6 can really be called "coercion". #1 is just an ironic side-effect of how the `typeof` operator works; #2 and #3 have to do with how IEEE 754 double-precision floats work (JS is far and away not the only language with these problems); and #4 is a cool look into how `Math.max()` and `Math.min()` operate internally. I'm also not sure what the "Explanations" section for #5 is trying to say. You mention that `{}` is coerced to `0` and `[]` to `1`, and if this were true, it makes sense that `{} + []` would equal `1`—but the previous code block had already declared `{} + []` to be `0`. By contrast, the "NOTE:" section does a very good job of explaining the unusual results. I'd suggest removing the "explanation" entirely and replacing it with your current "notes".
Single return is much much less performant than early return. Even on very simple methods. http://jsbench.github.io/#55e7177e0e297a19b619175705cbda3e
Just use a simple pub/sub implementation. Your components will be able to subscribe or emit events. 
This is why linters should be part of the continuous integration pipeline. Establish a standard, use a linter. And be done with it.
So, two returns?
2nd version. If `bar` is not `true`, you can skip the entire section and you wouldn't have nested `else` statements. Its more obvious if you have more stuff to do in the `else` condition. ``` if (!valid) { // do stuff return fail } else { // 10 more lines of stuffs here, possibly more if/else's return success } ``` vs ``` if (!valid) { // do stuff return fail } // 10 more lines of stuffs here, possibly more if's return success ``` I do realise some people prefer verbose and explicit code vs concise and implicit code so it really depends on the team's direction.
Will you always be looking at **/notes/1DirZQovvSQjURmLH6FmSEIAeE52**? Or will you be iterating through multiple keys under **/notes**?
Then the PR process and communication is the problem. And it’s not 1% better. That’s a silly argument to make. It’s about adherence to coding standards and best practice. It’s about learning and communicating team expectations. Honestly most of these issues could be preempted by establishing standards such as eslint. But given the nature of PRs I think it’s important (even or especially in a distributed team) that feedback is given. These sorts of things are important learning opportunities. Especially for more junior devs. 
Have you heard of our lord and savior, `Prettier`?
Thanks for help but I already solved it.
You're both wrong. Ternary operators and arrow functions FTW. var result = () =&gt; { return bar ? something : somethingElse }; 
Coming from a C background, more than one return statement per function can lead to resource leaks if you're not careful. In languages with automatic garbage collection it's usually not an issue. It's also irrelevant in a trivial example like this. It's more important to have a single set of style so the codebase doesn't end up looking like it was written by monkeys.
The more practical way to handle early returns is to throw an exception so the problem can be fixed in the calling code - where the problem started.
eslint, precommit hooks, pull requests + code reviews, documentation, and education. 
Regardless of language always prefer the second format. Short circuit out of a function as quickly as possible. 
If you have to do that, you have written bad code and you should feel bad. Variables VARY, that's what they're for. So you assign a default value when you declare the return variable and, then you decide, based on the function arguments, what the final return value will be. Just once. If you can't do that, you need to rethink what you're trying to do in that function.
The second is objectively superior. Let me be clear, you didn't do anything "wrong", just not "optimal" for readability. I know it may seem subtle but over a large codebase, it can be important. One issue is cosmetic, the other is psychological. Neither issue effect the "end result", which is to say the functioning of the program. But both affect the "users" of the code (a.k.a. other coders and yourself later on). The cosmetic issue is that as code blocks grow and include other branches (inside your else you have another if, which inside that has other iffs, etc. etc. ad infinitum). You get what is called the "Christmas tree effect". if (x) { if { if { if { etc. etc. all reaching that-away ---&gt; } else { } } } else { } } That's cosmetic but is a rather important cosmetic vice so good to avoid. Especially if you set line length limits (either soft or hard). However, the second reason is the far more important of the two and, in truth, it did take me a while to switch to the suggested style above (as I started out like you). The human mind has limits in its ability to keep things "in mind" or "in context". This is the capacity to keep little things in mind so you don't have to go back and recheck manually. Little things like what data type is x again? Is y false at this point? In psychology, this is known as "cognitive load". The mind automatically follows certain patterns when reading English, for instance. It automatically keeps track while reading paragraphs, sentences, and words... reading code is no different (just the patterns are). If a paragraph goes on and on - and covers more than one "topic", it can be very difficult for the mind to comprehend. This is because until a paragraph end is reached the mind is, naturally, thinking that a single "clause" or "idea" is being digested. It's just natural. So it continues to try and keep all those little details in short-term memory. The character Bob has blond hair, but Sally is brunette. The sun was high in the sky. Dust was kicked up from their feet as the two walked along. Keep in mind that the mind does this whether the hair colors are important or not, whether the sun is important or not. All of it. Short-term memory is limited and it has no idea what details are important. The longer the paragraph and the more intricate the sentences the greater the cognitive load. With code, as we read we are keeping lots of little things in our mind. Like, ok... at this point the value of this variable is 10 and this other variable is true and we are in the "else" block of that other thing over there. Too much of that and again we start putting strain on the capacity of the reader's cognitive load. However, when a block ends: if (x) { bunch o' stuff... } other stuff... We automatically "forget" or "exclude" all the "bunch o' stuff" as we read on to "other stuff". We can safely ignore what was inside the if clause because we have already passed that paragraph and are clearly on a "new" paragraph. If inside the if clause a variable was introduced (say z) we can ignore it because it is literally out of scope. We know, due to the structure of code, that the "bunch o' stuff" is "past" and "other stuff" is "current". It may seem small but in truth, it isn't. If instead, "other stuff" is in an else block we psychically feel like we are still in the "if (x)" paragraph. Add on top of that the "Christmas tree" phenomena and even when we are 4 levels deep we still "feel" like we are connected to that "if (x)". Chiefly because we might be. We should always try and make our code "readable". The stats indicate that you spend 70% of your time reading code and only 30% writing it. So any extra "work" we can do while writing it to make it easier to read **and comprehend** the better. Favorite old quote: You should write your code as though the person who is going to maintain it 6 months in the future is a psychotic killer who knows where you live. And you'd be surprised how often that psychotic killer will wind up being you.
True... but it doesn't contain the "why" and that is what is so important. You can read my comment here for why: https://www.reddit.com/r/javascript/comments/9jw5iw/one_of_the_devs_that_does_code_review_for_my_code/e6w9c57 
20 lines just for pre-conditions? I think it's time to slit up that function.
This is slower. You have several extra and unnecessary instructions here. 
&gt; Use setInterval or a recursive requestAnimationFrame Just to clarify for the record: setInterval` is okaaaaayyyyish for illustrating the point, for animations a real app should use `requestAnimationFrame` though. 
Thanks for that explanation. It is pretty cool that you can just include it. Maybe it is inevitable to commit to Laravel/Vue for me since that's the "stack" I use at least LAMP(but work as full stack). Ahh man, yeah they're docs are great, have to get used to that data/return/props thing but yeah it's certain component-ized and at the time I got stuck on that communication between components aspect. Ahh damn, gotta catch up
It's inarguable and totally preferential. The exception, IMO, would be when you are breaking tradition in a codebase that already prefers omission.
Someone has to commit those hunks
Dude, I just discovered EsLint’s auto fix all on save feature
I think the whole argument is trivial beyond belief. Just do whatever is going to help everyone get along best and then spend your mental energy of things that actually matter. 
Nice.... &amp;#x200B;
There are similar replies to this, but a function I've made use of in my former project and that handled traversing an object easy is (sorry about bad name of function, naming is hard =P ): `` export function getObjectValue(obj: any, prop: string, ...props: string[]): any { let property = prop; let currentObj = obj; while (currentObj[property] &amp;&amp; props.length &gt; 0) { const temp = currentObj[property]; property = props.shift(); currentObj = temp; } if (props.length &gt; 0) { return undefined; } return currentObj[property]; } `` In your case you would write `getObjectValue(snapshot.val(), 'notes', '1DirZQovvSQjURmLH6FmSEIAeE52', '1529ee5f-7a45-40fc-ab11-740d1188e122', 'color')` and if at any point there is a property missing on an object whilst traversing, it will return undefined. This is written with Flow, so remove the parts you don't need if you want plain JavaScript.
in: nums = 3 out: [4, 5, 6, 7, 8] for (let i = 0; i &lt; 5; i++) { number.push(i + nums + 1) } or const number = Array.from(Array(5), (v, k) =&gt; k + nums + 1) should better fix naming. nums -&gt; n, num, start number -&gt; n, numbers
&gt; I personally find the first to be more readable. and his reason is probably that he finds the second to be more readable. what is your real, technical reason for your preference? what is his real, technical reason for his preference? sit down and talk about it for five minutes, you might find a consensus after hearing eachother.
Refactor is good.
which Linus?
[removed]
I believe both styles are acceptable, and trying to enforce a standardisation to either, is a waste of time. As long as both styles are readable and do not cause misconceptions, it is fine. &amp;#x200B; Ask your reviewer for his comments. Are there strong justifications for his preference? What is the effort / benefit ratio of doing this conversion? Is it a one-off effort or a standarisation exercise? Is it a massive undertaking? &amp;#x200B; When you have gathered the answers, you will know what decision to make.
Not if the compiler can optimize for it, that's the point. With optimization you have to profile. I'm not sure this will increase performance significantly enough to even measure unfortunately. 
This was the answer I was scrolling for. Thanks.
Thanks i will look into it. I only started to learn JS 3 weeks ago, not very confortable at all 
 i updated the post, the last pic shows how to get virtual dom instead of normal dom nodes. 
`let x = 2` `setTimeout(()=&gt;{ x = 3; }, 10000)` `console.log(x) // 2`
Very cool idea. It doesn't solve all the problems that electron sets out to solve, but would simplify tools like running the kubernetes dashboard, which currently requires a local web server to run. 
i edited my answer to give you an example :) hope it helps. general idea: * keep things simple by splitting the batch and a single request * have both the batch and the single request function return a promise so we can wait for them to be finished and then handle the outcome (response/s) * implement the timeout in the batch, since this is not interesting to our single request function its not perfect but the best I could think of for now :) 
It essentially rewrites the function, and the new function calls the original function but also allows you to log anything it is currently processing! Would provide an example but on phone and weird formatting :c
It's all over the Internet, it's called teamwork: Ask other people. Listen to what they're saying. If you disagree, bring up your disagreements and reasoning. Listen to their response. Assume they mean the most positive version of what came out of their mouths. Based on all the information brought forward, weighed against the passion and rigor of each idea portrayed, come to consensus. Write a doc and ask everyone to review it. If you cannot move forward in this way about code style, you're screwed when the team must build a product.
Let's go crazy party tonight, because we just made a PATCH RELEASEEEEEEE YEAAAH! Omg.
Got it that is very helpful. How would I go about changing the arguments so I can parse different arguments to a POST request?
Amazing! Thank you very much!
Thanks..Yeah electron creates a window but this one runs in browser. but it supports things that electron offers like file management, running commands etc..
Haha .. but this version contains good fixes :)
A community member created a task viewer [https://github.com/neutralinojs/neutralinojs-desktop-samples/tree/master/taskviewer](https://github.com/neutralinojs/neutralinojs-desktop-samples/tree/master/taskviewer)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [neutralinojs/neutralinojs-desktop-samples/.../**taskviewer** (master → e9b1ce5)](https://github.com/neutralinojs/neutralinojs-desktop-samples/tree/e9b1ce51004253a410543bc73643455b68995b06/taskviewer) ---- 
[https://github.com/ReactiveX/rxjs/pull/4208#issuecomment-425711532](https://github.com/ReactiveX/rxjs/pull/4208#issuecomment-425711532)
The latter. The *else* is redundant, and redundant code is a code smell. 
I'd go with the guard clauses, aka the second one. 
Txn it worked!!!
I tend to use the 2nd, but I think your way is technically more correct and easier to follow.
If you want an offline reference, I'd look at: - [devdocs.io](https://devdocs.io/) *(a PWA documentation website where you can [download docsets for offline use](https://devdocs.io/offline))*. - [Dash](https://kapeli.com/dash) on Mac OS or Dash-compatible clones for others *([Zeal](https://zealdocs.org/) for Linux/Windows or [Velocity](https://velocity.silverlakesoftware.com/) for Windows)*. This group of tools comes with [protocol handlers](https://kapeli.com/dash_guide#dashURLScheme) that extension developers leverage to integrate doc search into popular IDEs/editors *(usually contextual search by filetype of whatever's under the cursor via ```Ctrl+Shift+D```)*.
[removed]
It's especially bad with CSS though. Bad code can still be fixed, and so can bad CSS, but no one wants to fix bad CSS. It feels like a chore, and not an intellectually challenging puzzle, which I'm sure is part of what drives coders to be able to work as hard and as long as they do. The problem is that since CSS is a very nonlinear way of doing things - whereas with most coding you can follow a somewhat linear progression of code execution - it just lends itself to messy coding. With CSS the tendency is "if it ain't broke, don't fix it", especially if UX designers and artists are constantly editing the layout in all different directions. It's really hard to maintain a consistent pattern without discipline, and CSS edits are like, the last thing any programmer really wants to do. But obviously, human error applies to everything in life.
Also i loved the commenting style, thanks! u rock
Prepare to fail some interviews then, because at my place we definitely check that you can deal with `this`, and that includes `.bind()`, `.call()` and `.apply()`. It's not that we care particularly much about them, or that you will use them a lot. But `this` is a fundamental mechanic in JavaScript. Knowing about `this` is not optional for any medium/senior job. If you are familiar with this topic then going through it should be a quick "let's check this point so we can say we did it" part of the interview (which is what I expect from a good candidate). But being caught out by any of these functions is a huge red flag. A person who knows all the fundamentals of JavaScript by heart can pick up any framework in a couple of weeks, and I know I have a person who can pick up *any* framework. A person who only knows React, well, only knows React, and if we use something else on the next project I have no idea if they'll be able to learn another framework and how fast, plus I know for a fact they *don't* know vanilla JavaScript. So yeah, I'll take the first person over the second any day.
Your sort function and the comparator you're using are not right. Right now, what you have is this... Array.prototype.stableSort = function(cmp) { let stabilizedThis = this.map((el, index) =&gt; [el, index]); let stableCmp = (a, b) =&gt; { let order = cmp(a[0], b[0]); if (order != 0) return order; return a[1] - b[1]; } stabilizedThis.sort(stableCmp); for (let i=0; i&lt;this.length; i++) { this[i] = stabilizedThis[i][0]; } return this; } Which you use like this... faces.stableSort((a,b) =&gt; (avgZ(a) &gt; avgZ(b))); The thing is your comparator `(a,b) =&gt; (avgZ(a) &gt; avgZ(b))` returns a `Boolean`, `true` or `false`. If the comparator returns `true`, then `stableCmp` will return that `true` to `sort`. If the comparator returns `false`, then `stableCmp` will return an integer (the difference in indexes in the original array). This in itself is bad. A comparator is [expected](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) to always return a number, less than, equal or greater than 0. Returning `true` or `false` is bound to produce undefined behaviour. It is also pretty bad to _sometimes_ return booleans and _sometimes_ numbers. So, you need to change your comparator to... faces.stableSort((a,b) =&gt; (avgZ(a) - avgZ(b))); This, apparently, fixes the problem. Still, I have some doubts about the whole necessity to make the sort _stable_. When you're managing float numbers, the case where they are equal is very infrequent. Once the above fix is in place, putting a breakpoint on the `return a[1] - b[1];` will show you that this only happens for a couple of faces and only in _two_ of the positions for the kettle (at, what I guess is 0 and 180 degrees). Removing this, and using the standard sort (`faces.sort((a,b) =&gt; (avgZ(a) - avgZ(b)));`), I haven't noticed the flicker you mention, which is what makes me doubt it is required. Maybe I'm wrong, of course, but this is my impression.
Wrong sub
So is this like nativescript for desktop development?
Congratulations on getting it adopted at some big companies
Well, that was a simple, stupid and retrospectively obvious fix, thank you so much! And indeed, the sort doesn't need to be stable, I was under that impression because I read that spidermonkey's Array.sort() is stable while V8's isn't, switching to a stable sorting algorithm did improve the chrome situation quite a bit, but now it seems it was because my comparison function was buggy. Again, thank you!
:-)
You’d likely get more adoption if you included documentation explaining the rules you set and why. Especially considering you’re on major version number 13 after 3 years. That’s a lot of breaking changes to keep up with without any documentation. Look at the Airbnb guide for a solid example. 
Noobie question: "declarative side-effects"?
Nice one, thanks
Every new rule added is a breaking change, as it should be. Documenting a style guide is tricky – the ruleset itself is self-documenting. The only thing you can help as a ruleset author is enable smoother linking to the examples in the original documentation. The only thing that I would consider valuable as a documentation is a comparison table with other rulesets, such as airbnb. This can be done at a relative ease and I think thats a good suggestion! https://github.com/gajus/eslint-config-canonical/issues/15
Sorry, I missed the part where you said "and why". I agree with the need for explanation as to why a rule exists. Once again, in most cases (at least in the case of the core ESLint rules), boolean rules include explanation as to the reason for their existence. Rules that are multivariate could indeed benefit from documentation. It shouldn't be too hard to do this. https://github.com/gajus/eslint-config-canonical/issues/16
You haven't really given enough detail for anyone to help you.
Excited about fragment support. Ported a project to Vue a while back and the lack of fragment support made it extremely difficult.
Cross-Origin request issues can really only be fixed with a server side change. This feature was put in place to prevent people pulling data using credentials they shouldn't have access to. You should read up on CORS on MDN.
you'll either want to cancel the last interval on click or check if there interval is already running and not start it again (simple way would be assign a global variable "running" ok couch and only do the onclick code if that's false)
Don't worry! I struggled with the imperative vs declarative distinction for years. The best way to explain it is by example. Have you used react? React is a dearative view library. When you use jsx to build your view, the functions that you write in isolation do not do anything to the dom. The react runtime mutates the dom. Similarly with cofx, all of the code that end developers write do not make http requests, they return json. The cofx runtime handles making the actual http requests. This makes debugging, composing, and testing much easier for side effects. Instead of mocking or intercepting http requests in your tests, you simply make sure your functions return the right json. Feel free to ask follow up questions!
I mean, you could cancel the interval loop, but why even do this?
Hi /u/senhor_guarfa, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/gotti_san, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Linus_The_Idiot, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/lcukerd, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/thelynched, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/MatthewPerkinsDM, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Casuel_, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/panxkuba, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Swastik496, this post was removed. Please see our rules, and do know that 'Java' !== 'JavaScript'. Thanks for your understanding.
Hi /u/Justhereforthechicks, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
somewhat similar approach. But there is no source to target mapping or something. It is calling REST like end endpoints for native calls :)
Entirely in TypeScript!! &lt;3
The correct way to organise css is in isolated components. That way you're only ever looking at the CSS for the component you're currently working on. Standard CSS is just coding with globals. There are dozens of ways to isolate css. Nested SASS, styled components, sass modules, even BEM. 
Are you trying to do all of this from the client side javascript? Meaning no work done on the server? If so, the way I would do it is to take your JSON data and render the report in HTML format with tables and graphs (using [highcharts](https://www.highcharts.com/)). You can print the rendered HTML to PDF with something like [api2pdf](https://www.api2pdf.com/convert-html-to-pdf-with-client-side-javascript-and-jquery/). But printing to CSV from client side only, that I don't know.
Meanwhile I just removed all rules from my eslint except `no-restricted-globals` on confusing global variables, requiring them to be used like `window.name` instead of `name`. `no-undef` to make sure you don't use any undefined variables. `no-unused-vars` to make sure you didn't typo a variable and makes one defined be unused or something. Then uses `plugin:prettier/recommended` in the main and then `plugin:react/recommended` in the react extension of it. Outside of that, I feel prettier handles most stylistic stuff that people used eslint for, and eslint gets in the way with other stuff. https://github.com/aniftyco/eslint-config-nifty
You're clearly not the type of person for whom this package is intended.
Agree to disagree. I don't find the original code any more difficult to understand than the refactor. And there is no tangible performance gained in the refactor. So that makes it a silly reason to introduce delays to delivery to me.
You should cancel the interval using `cancelInterval`: cancelInterval(passed); 
IIRC, rollup.js's experimental code splitting/dynamic import feature only supports ESM and AMD modules at the moment.
Math.floor(Math.random()*50)
Add table of comparison between Airbnb and Canonical. https://github.com/gajus/eslint-config-canonical#table-of-comparison Will use Airbnb's explanation for when configuration matches and add my own explanation when configuration does not match. Thank you for the tips.
You need to look into the math.random and math.floor methods to generate a random number. It generates a value between 0 and .9999 so you'll have to do a bit of math to increase it to 50. . If you save this to a variable you can then call it in a function. In the function you can create a prompt method saved to another variable to hold your guess. You can then use a while loop to say while the 2 variables don't match, call your guess variable You'll need an additional variable to collect the amount of guesses, adding 1 each time. Then print this variable via an alert when the computer number and your guess match.
Thank you for the information and will do.
If you look at your whole question. Ill give you hints of what you will need to use. You will have to use the Math object methods. You will have to use prompt(); You will have to use if else statements. Now try to break down the problem into simple steps such as. I need to create a random number generator. And so on. Hope it helps. 
&gt; " &gt; Better coverage of code style? Definitely. &gt; " No, not *"better"* at all. Just *more*.
There’s plenty of times where you can either clutter up your DOM with another unnecessary div vs. using the slightly more performance-friendly React.Fragment
[https://codepen.io/donfear/pen/GYJKqZ](https://codepen.io/donfear/pen/GYJKqZ)
Right, I get it, but if it's an unnecessary div, maybe it doesn't need to be a component.
Shorter functions are desirable but not always possible. And chopping single-use bits of code into multiple functions often leads to worse spaghetti code typified by vague and oddly specific named functions taken out of the code flow that kill readability. If you see function Foo(bar) call functions like ValidateFooBarArgument() and then CleanupFooBarFields() where those functions will never be used outside of Foo() then often you’d do future developers a favor leaving the code in context with appropriate comments. 
No doubt, SASS is a godsend. It makes CSS really, really easy. And for sure, the lead coder on the projects I've worked on has enforced isolation of components. You can't merge code safely if you don't do that. The problem is deadlines, and the creatives. Because of one reason or another, unique styles have to be placed everywhere, and constantly adjusted. So even if you plan out component styles and build in good mix-ins, you end up having to make exceptions to the rule, which is CSS's achilles heel. Creatives often want the result to be pixel-perfect when compared to their photoshop mockups, but don't account for responsive design, or if they do they simply mockup screens of different resolutions without bothering to think about what should happen in between those breakpoints. Obviously CSS becomes an afterthought in any environment where functionality is favoured over form, but for say, advertising agencies, web developers often encounter nightmare CSS problems, especially if the project is constantly being steered by input from clients. I imagine most startups would be happy to just boot up bootstrap and be on their way, but when you're creating bespoke aesthetics the devil is really in the details.
I needed to target a specific HTML structure for output which involved looping over collections that would generate 0 or more sibling elements of an arbitrary type. Fragments would have made it easier to keep those elements all siblings. Instead I think I ended up using render functions to manage that.
Not necessarily. A section of the UI that would make sense as a component doesn’t always map 1-to-1 with how the DOM is/should be shaped. Using an “extra div” in a decision of making a component is mixing concerns.
I was hoping to handle the work of the report on the client, if possible. Server just compiles the data. Thanks for the tips.
amazing. proxy-based reactivity is going to look like magic. anyone have an idea of how that might shape vuex or other state management libraries?
wouldn't it become Vue.ts?
This is probably too specific of a problem, and the solution is far below O(n). I don't know why you keep writing O(n)=1 - do you mean O(n) or O(1)? O(1) is not possible for this problem - unless you do additional preprocessing to find the perfect hash function or table size... With such a large dataset though you won't get O(1) in a realistic (memory wise) scenario.
Eh, im not gonna shave my beard and play dress up just to impress someone, not because im a filthy being, but because it says something about their attitude. I dont give a fuck how you look, if you give a fuck then i dont think i want to work there (were talking about normal people, not obvious hobbos)
Don’t worry, it’s only the vue codebase that’s been rewritten in typescript. You still write your app in vanilla js, the way god intended. 
They just expect you to arrive at work earlier and leave later. Fuck that
Fragments and Portals sounds interesting - where can I learn more about how they work and what use-cases they solve?
Then again if I dont want to work in php and they you somehow expect me to work in php were gonna have a problem.
Oops
Right, just trying to think of a situation in which that would be the case. I feel like most Fragment cases can be replaced by: &lt;ParentComponent&gt;{this.props.children}&lt;/ParentComponent&gt;
Seems like ts is where we are headed
TypeScript is a superset of native ECMAScript, that's what makes it awesome. The transpiled code with TypeScript looks almost exactly like the one you wrote with type-information. It's self-documenting, you get nice auto-completion for your IDE and you can avoid many common errors that occur through wrongly named variables or wrongly passed arguments just by using it and adding _some_ type information.
Thanks,I started to think we need to add more libs to /awesome-react-components
I don’t understand this point of view
Let’s say I have this function: renderInfo = () =&gt; { return ( &lt;p&gt;{username}&lt;/p&gt;&lt;p&gt;{date}&lt;/p&gt; } And then I call it somewhere in my main render function. I may not want a div to wrap that in.
What are you taking about? We’re in a JS subreddit talking about JS. There is no “assign only once” semantics. I was merely pointing out that storing a return value in a variable that you can assign to at multiple places in order to avoid multiple return statements necessarily makes it mutable state, so the original commenters point about mutable state being the issue was moot. let state = “default value”; // state is now mutable if (someCase) { state = “some value”; } else if (someOtherCase) { state = “some other value”; } The state variable is mutable through because you cannot declare it const and subsequently change its value. This is basic JS ...
Point of what?
I guess it was a mix of sarcasm, liking to code as close to vanilla as possible, and also being a teacher who LOVES the simplicity and progressive nature of vue. Vue still has “hello world” that takes 20 seconds and is accessible to complete noobs. I’ll be bummed if they ever make typescript, and all the complexity comes with it, mandatory. 
Absolutely! But not because libraries are written in it (you can still use them from JavaScript without it feeling weird), but because it makes your own code better.
You should have used an array, there's no reason to create an [object with every value hardcoded as 1](https://github.com/RahulShaw/leaked/blob/master/commons.js). Or you could go even further and use a plain text file to get rid of useless quotes and commas.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [RahulShaw/leaked/.../**commons.js** (master → 6ddf7bc)](https://github.com/RahulShaw/leaked/blob/6ddf7bc92ebbabc60998f745e2235d765d2b2225/commons.js) ---- 
&lt;10kb base size and a 2x performance boost? That's fucking madness. Decoupling the renderer, scheduler and observer will facilitate some crazy stuff down the road Think coding WebAssembly components in Go with a full Vue lifecycle or making desktop GUI apps through Vue's templating system without Electron.
Thanks for reading thw article and suggesting me. I made the changes 👍
That's coming :)
Don't you think that looking for an element in an array of over 6000 elements be a dent on performance ?
I don't know about portals, but as I understand it a fragment is something like this &lt;template&gt; &lt;p&gt;some text&lt;/p&gt; &lt;p&gt;some more text&lt;/p&gt; &lt;/template&gt; This doesn't work because there are two root level components -- the p tags. The current solution is to wrap both of those in a div so the div is the single root level component. 
The solution we used was to isolate css files to be pertinent only to a single page, and then use SASS to bring it all together into one file that worked for the whole site. There was definitely lots of repeated code (not that it matters, CSS is so lightweight) but it was definitely worth it for manageability. I think one css file per page is a pretty good rule of thumb, but I guess it also depends on the project's parameters. An additional safety measure that my team lead introduced to me was to simply aggressively nest class properties in their container classes, to minimise specificity errors. Of course, the real enemy is sleep deprivation.
I used that a couple years ago, but I couldn't get the org as a whole to jump on board with it. It may be time to revisit. 🤔
Ignore that guy, you're good 👍
cmon man... All i see is just a huge js file filled with names which weighs 84 kb, I know you can do better than this! Anyway, good luck with future releases
Use a `Set` instead
What if I do use those but still have them in a separate render function called renderInfo as opposed to directly within the main render function? I’d still need a parent container around them.
lol
Hey, I was just giving an advice, there's no need to be rude.
Yep, I think that would be the best solution
Right the parent would nest them with {this.props.children}, that’s why I don’t see the point.
Calling you names would've been rude or saying something mean - but I didn't. It's a worthwhile skill knowing when and when not to give advice. 
I'm sorry then. English isn't my native language, sometimes I get confused whether someone is trying to sound rude or not.
The docs for the React versions explain them well: [Fragments](https://reactjs.org/docs/fragments.html) [Portals](https://reactjs.org/docs/portals.html)
All good. Sets are slightly more efficient than using a plain object, but aren't supported for older browsers. Using a Set is good advice as long as older browsers aren't a concern.
&gt;If you're only starting to see performance improvements around the 10,000 item mark (and they become obvious around the 100,000 item mark), I think that the use-case is specific enough that you won't get a ton of excitement over your proposed feature, especially given that the standard min/max seem to be significantly faster in "normal-sized" observable data streams. &gt; &gt;I appreciate the effort and the niche use case though, so I starred/forked your GitHub project. I was tested with 10 &lt;= n &lt;= 100000000, with n &lt; \~ 5000 min lose in performance, in n &lt; \~5000, min have best performance. But these operators were created for another purpose, combing using min / max is rather an additional property that can be applied to large arrays.
|| is your friend.
I hope, to the extent possible, the class-based API aligns with Web Components specifications.
This obviously isn't a very secure login system, but add a variable named pass2, and the add an if statement to go with it
Is typescript the future of javascript?
mate, he is helping you the "||" operator is "or" so `&lt;!--hide var password; var pass1="Admin"; password=prompt('Please enter your Access Code to access this course!',' '); if (password==pass1) alert('Password Correct! Click OK to enter the course!'); else { window.location="buy-courses.html"; } //--&gt;` if you want to add the other passwords "root" and "sudo" you would do `&lt;!--hide` `let password;` `let pass0="Admin";` `let pass1 = "root";` `let pass2 = "sudo";` `password=prompt('Please enter your Access Code to access this course!',' ');` `if (password==pass0 || password == pass1 || password == pass2) {` `alert('Password Correct! Click OK to enter the course!');` `} else {` `window.location="buy-courses.html";` `}` `//--&gt;` ok?
If you're not willing to put in effort to try understand other people's attempts to help, or ask for an explanation, what's the point in posting a question? They're right though; `||` (logical or) would help.
Surely you mean 2-_characters_ indentation? It's pretty standard in JS.
What are the benefits of typescript over flow? Both seem like great options
I like Typescript's syntax better, but basically they're both accomplishing similar things. The main reason to go with Typescript is industry support.
Seems more like a Java-related question than JS, but a few years ago I *tried to use* JavaFX [something like this](https://docs.oracle.com/javase/8/javafx/embedded-browser-tutorial/js-commands.htm) to create a "minimally awkward webapp wrapper" (MAWW, it was going to be called) that could call Java from JS or JS from Java (for FS access, etc). I say "tried" because I gave up after discovering a bug in JavaFX that causes `_` to not be rendered properly when it's part of the text of an `&lt;option&gt;` in a `&lt;select&gt;` as the app I was building MAWW for needed to display _ properly in lists of data. I did try some hacks to fix it, but nothing worked at the time. [JavaFX's WebView apparently uses](https://stackoverflow.com/q/30104124/7665043) (used?) JavaScriptCore (WebKit) underneath, so it may have ES6 support. If not you may be able to use a JS transpiler, but IDK about how to even begin going about that aside from looking into [Babel](https://babeljs.io).
var passwords = ['Admin','Password2']; var password = prompt('Please enter your access code to enter the site.'); if(passwords.indexOf(password) &gt; -1){ alert('Password Correct! Click OK to enter the course'); } else { window.location = 'buy-courses.html'; } 
Maybe, is C++ the future of C? 
This response actually started out pretty small. Over the past few hours, I've rolled out additions and improvements in short iterations. You should know how feature creep works.
Yes and no. Yes because it feels and acts like an improved version of JavaScript that introduced types and many more features. It thus allows for much better code completion and helps to catch simple mistakes. No because no browser supports TypeScript. You have to compile TypeScript code to JavaScript to be able to run it in browsers.
Badum.ts
I'm willing to see where it goes, but Typescript seems to have such a head start - including with support for React - that I'm not entirely sure Flow can gain traction. That said, if it does... Great! Both work really well, and if Flow starts eating Typescript's lunch, I'm fine with that.
Written in TypeScript? https://i.imgur.com/uu9pmDP.gif
Ah, crap; I'm sorry. I'm guessing that means it's not even finished, but maybe I'm wrong -- does this just mean it's not documented? There may be another option, even if it's only for classes, but then you'd be left needing to handle the spread operator, arrow functions, and etc with some other polyfill or transpiler. Babel will most likely be the best chance.
vuex has you separate logic into actions, mutations, getters and state. partially because it’s a way to separate and organize concerns. but also because it allows vuex to track where something went wrong and allows it to capture changes to the state. with proxies it seems none of that would be necessary as it can track where the state was changed, even when assigned natively, and update anything accordingly. i think it can lead to some really simple but powerful state management. you may not even need state management for some larger apps at all, as stated in the article. 
Also, I bet we see ES start implementing TS features. 
Hi /u/Maelyia, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/sumitrajguru, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
I suppose I could always make my own. The program in question happens to do a lot of text parsing, so it wouldn’t be all that new to me.
Hi /u/BossAbhay108, there is no need for such hostility here.
&gt; superset Except for all the modern features, like `Array.includes`.
Ah, when have they ever done that? ^^^^^^^^^^coffescript
What's the use case for this? I mean, I could see some motivation for a _filter_ that only produces a value in the stream if it is "bigger" than the previous ones. But why produce the previous maximum? In which cases have you found this to be useful? I _can_ see a use for something like [this](https://rxviz.com/v/rOWZkeBo), where it only emits a new value if it's larger than the last largest value. But with your operator the largest value gets emitted every time and I can't really think that would be useful. The difference is this: // With your operator: of(1, 1, 2, 2, 2, 0, 1, 2, 3, -1, 4).pipe( maxStream(), ) .subscribe(x =&gt; console.log(x)); // 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 4 // Filtering the stream: of(1, 1, 2, 2, 2, 0, 1, 2, 3, -1, 4).pipe( maxSeen ) .subscribe(x =&gt; console.log(x)); // 1, 2, 3, 4 
you have to set your lib to es2017 in tsconfig.json so that it recognizes new features
If anything, it is the present. TS is super popular. WebAssembly might be the future of JavaScript.
I am not a java user but why don't you try [J2V8](https://github.com/eclipsesource/J2V8)? It seems it works with node 7.4.0 which should work with `class`.
In general, the ideas of these operators root rest can be expressed through them. `.pipe(` `minStream(),` `last()` `) // equal min()` `.pipe(` `minStream(),` `distinctUntilChanged(),` `) // equal what you write in message`
&gt;No because no browser supports TypeScript. You have to compile TypeScript code to JavaScript to be able to run it in browsers. If it gets real big, some web browsers and standard bodies might start to think of supporting it natively.
I love it, where can I read more about it? Best practices in Commenting. People say that good code doesn't need Commets but I don't agree. I'm very afraid of looking into big amounts when there are zero comments, it takes ages to understand a single function that is calling another function and is calling another function.... Also it's hard to understand what inputs the functions expect. Maybe I should try typescript. 
But when would you want your operator alone? What is it useful for on its own? Is there a situation where you would use your operator alone and _not in conjunction with `distinctUntilChanged`_?
Yes there are quite a few but by far the best is animejs.com but there’s also quite a few. Common areas such as animation you will be hard to find a unique opportunity as JS is so hot right now and people have been doing it for years etc. Enthusiasm = great. Not saying don’t do it. Worth doing even for a learning exercise :)
What do you like to do in your spare time? Maybe build an app around that? If you like beer? Build an app where you can review different beers. Or maybe an app that allows you review local restaurants and see them on a map? Basically, make an app about something you like.
Oh, yeah, I remember coming across that one... at the time I wasn't looking for something like that, it kinda just popped up in a google search or something.. Thanks for the vote of confidence! I'm thinking I'll build it regardless if not for any reason other than to put it in a portfolio. 
I'm not even going to with you, lol. "Prepare to fail some interviews then, because at my place" You have no idea my skill level, and "fail some interviews" followed by "because at my place" did you know there are more organisations, than where you work? Realize that there is more in the world than whatever codebase you've working on for the last decade.
“””(That said, usage of TypeScript in an application is still entirely optional.)””” Oh thank god! It will things simple and avoid the overhead of transpilling. 
I use webpack, rollup and systemjs-cli on a daily basis and they serve very different purposes. Saying one is better than the other is just the old phallacy of the golden hammer (or silver bullet). &amp;#x200B; Webpack is well suited for development (live reloading and stuff), Rollup is miles ahead for bundling and doesn't break separation of concerns. SystemJS has allowed us to use features that browser have released last year since 2014, and some of them are still not massive. &amp;#x200B; So, will webpack be relevant once every browser supports modules? will bundling be relevant when everything is served through http2? Will even Babel and their 200 plugins be needed? I don't know, dudes, but I know people behind these projects are leet developers, so I wouldn't go as far as pretending I know better.
While trying to replace the other libraries may be difficult there's no good reason you can't do this project *at least* as a learning exercise. Personally, I've gotten pretty sick of some of the popular bloated NodeJS modules and I've started building my own, although they're not as mature or powerful they've worked well for me so far. A commandline parser that's only missing support for `-opARG` (like --optionVAL or -oVAL), a debug module very similar to the popular visionmedia/debug, a JSDoc-like documentation parser with an example markdown generator (and plugin support for other generators), a Mocha-like test framework (fully async, but will be trying to make it handle both sync &amp; async properly), and last and most insane an expect-based assertion library that supports usage like `expect ('a').to.not.loosely.equal('b')` (where loosely uses `==` rather than `===` [strictly] which is the default), and so far the only non-dev dependency through all of these projects will be the expect library to the test framework. Most likely these will continue to be toys, but while building them I've learned to use most of the "new" Array-based functions (map, filter, reduce, etc), most of the new ES5/6 syntax except classes, and with the expect library I'm finally beginning to understand how to use .bind, .call, and .apply after trying for **years**. And finally, along with most importantly, welcome to the party! :) Also pretty new to this sub, but it's been good -- there's lots of great information constantly flowing in comment sections, and some cool projects well worth starring on GitHub and using as reading material.
It’s only magic until you bother to open the source code and see how it works.
I love the downvote followed by a rhetorical comment with no explanation. What purpose does your comment serve?
&gt; Flow is maintained by Facebook, so if you are in the react ecosystem, it makes sense. FYI React has excellent typings available for TypeScript.
Lol, I love the couple of ppl who don't want their job to be obsolete, downvoting our comments. It's possible I've missed something, but I'm fairly certain the arrow syntax makes binding "this" unnecessary.
Isn't it the other way round? TS implements things that's in the Stage 3 final of ES specifications, and tries to stay compatible to future ES spec.
Is it a team that develops it, or just Evan You?
It's a team now, has been for at least a year.
Yes, that's true. I also think that could be bidirectional.
If you use react, [react-easy-state](https://github.com/solkimicreb) is a great implementation of of a state management using proxies.
That is promising.
They're like a first-party implementation of this, I'd imagine: https://github.com/LinusBorg/portal-vue
Array elements can be any type, including other arrays: var data = [[1,2], [3,4]];
I assume you are using p5js. Check out the [color](https://p5js.org/examples/color-color-variables.html) function. You might want to use something like ``` dropColors = [color(100,200,100),...] ``` I’m trying not to just give the solution. Hope this helps. 
interesting
Nobody ever liked JS because the language, they liked it’s power. So imo you should not compile a whole other language unless you get some serious benefits. Type checking is not enough for me, but if it’s webassembly you have my attention. 
var colors = ["green", "blue", "green", "green", "green", "green", "green"];
Typescript adds lots more than just typing.
Cool! it's fun but hard to get used to the orientation even with the back view. Not sure if anything can be done about that though
Yeah there are few other benefits, sure, but not nearly as significant as type and the things that come along with type. If you think I’m missing something that warrants an unremovable dependency into the stack let me know though
Agreed, &amp; I do have an approach in mind for that, though i'm not really sure whether it'll work out. Currently I keep a reference point grid which is static &amp; orient the object using 2 rotations one after another, which results in this non-intuitive interaction. The improvement i'm thinking of is to update the reference grid with the current orientation after every release &amp; perform orientation based on just one angle (determined by cursor vector length) &amp; one axis (normal to the cursor vector in the plane of the screen)
Yup. Day 1 at a new company, I write if(x) function(); They insisted on if(x) { function(); } I thought my code was fine but who cares? It’s not about me, it’s about the code base. Changed it with zero issue and would change it again even if I came in as some principal whatever the fuck engineer.
In Round 8, [Elm](https://elm-lang.org) seems to have jumped way ahead of the other compile-to-JS languages in the benchmark, especially in the "startup metrics" section. The [table](https://stefankrause.net/js-frameworks-benchmark8/table.html) shows [Elm 0.19](https://elm-lang.org/blog/small-assets-without-the-headache) at 1.1x vanilla JS in terms of both byte weight and time to consistently interactive! 🚀
So a big thing that would help is learning MV* architecture of design. Secondly design your code so that it is *testable*, you almost certainly want automated tests for as close to 100% of your code as you can. If you're not familiar with MV* design basically the idea is that you seperate your Model (M) from your View (V) with something (*) in between. Typically a model will contain some state + some actions that can transform that state. In the case of your chess game your state will probably look something like this: state -&gt; playing currentPlayer -&gt; name -&gt; Bob whitePlayer -&gt; name -&gt; Bob blackPlayer -&gt; name -&gt; Alice piecePositions -&gt; white -&gt; queen -&gt; (3, 7) king -&gt; (2, 9) // etc black -&gt; // ditto In addition to some state your model should also include some operations that act upon the state. This could be very varied depending on how you structure your code but you might have some operations like: takeTurn: Player, PiecePositions -&gt; NewPiecePositions makeMove: PlayerAction, PiecePositions -&gt; NewPiecePositions | NotAllowed endIfWinner: WhitePiecePositions, BlackPiecePositions -&gt; HasWon Now in actual code there's a bunch of different ways of implementing these things for example we could do a class-mutation based approach: class ChessGame { constructor(whitePlayer, blackPlayer) { this._whitePlayer = whitePlayer this._blackPlayer = blackPlayer this._currentTurn = 'white' this._piecePositions = initialChessPositions() } playMove(piece, newPosition) { // if newPosition would be invalid, throw error, etc } validMoves(piece) { // give a list of valid places a given piece can be moved // to in the current turn } piecePositions() { // get a snapshot of the current positions } } There's plenty of other approaches as well like functional style that's a bit difficult to concisely demonstrate here so I won't but this is the sort've thing that Redux uses. --- Now that we have our model of the world which knows nothing of HTML, DOM, etc, we can have a ViewModel that displays the current state of the model e.g.: function runChessGame(htmlElement, chessGame) { htmlElement.innerHTML = createInitialBoard() htmlElement.addEventListener('click', event =&gt; { const clickedEl = event.target if (clickedEl.matches(".chess-piece")) { // use your model here to highlight cells on the board // where the piece can move etc } }) } Note that this is nowhere enough information to actually implement such a design, this where I think frameworks are probably a better option for beginners than learning bare-bones HTML/JS in that they actually give clear separation of parts. Consider trying out something like React, Angular, Vue.js, Hyperapp, etc as they tend to abstract these design choices away from day 1.
Add a boolean variable initialised to false. Wrap setInterval in an if statement that checks !boolean. On the first invocation of the interval, set boolean to true. Boom, only a single interval invoked.
I continue to be impressed by Vue. I am waiting on the right project to use it as all my existing leverage Angular. If anyone needs some help on one, hit me up. 
It’s the now. 
How does fragment help in these cases? I don’t know what the current problem is and what improvements fragment will bring.
In what way would fragment support help with the project you ported?
How would webassembly be the future, you mean like a replacement?
I’m assuming that zip is your serverless package. Are you serving a React all from a lambda and hosting static assets like your spa bundle from s3? If so the wrong stuff is being sent to s3, as it shouldn’t be the sls package. But I’m making lots of assumptions. 
Just a heads up if your goal to is to write a plugin that observes/debugs js comms with a backend, you should also handle the whatwg fetch standard, which does not use xmlhttprequest. My app uses fetch and I have found in multiple cases libraries and products assuming all comms use xmlhttprequest just because the devs who wrote it didn't know/think about fetch.
Now I understand what you were saying. I think multiple return statements can work if you need to short circuit a loop. But assigning a value to a return variable is also fine. Neither of these styles will make or break a startup. It’s not worth arguing about further.
Not op, but I can easily envisage a future where "js" ceases to exist and *all* code, js or another language, gets compiled to web assembly. Then browser makers would only focus on performance and features of 1 language runtime, web assembly. There are a lot of difficult problems to overcome making this a reality. It might end up with something that sounds funky like V8 compiled into web assembly. And I'm not saying it's **definitely** going to happen. But it could.
Evan kinda leads it, but there’s a very good core team and a ton of contributors. 
the real drama will start when such apps will be exposed to the real world and black hats find a way to run arbitrary commands :)
* Native browser scrolling * Native scrollbars on mobile devices * Fully customizable * `requestAnimationFrame` for 60fps * No extra stylesheets necessary * Cross-browser &gt;**IMPORTANT:** default component styles uses [grid layout](https://developer.mozilla.org/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout) for proper scrollbars display. &gt;But you can change it by passing `gridless` parameter on initialisation. ##### Installation ```bash npm i --save react-scrollbars-custom ``` ##### Usage Minimal configuration ```javascript import React, { Component } from 'react'; import Scrollbar from 'react-scrollbars-custom'; class App extends Component { render() { return ( &lt;Scrollbar style={ {width: '100%', minHeight: 300} } &gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/Scrollbar&gt; ); } } ```
Technically, a page should be a component, so if you apply styles specifically to a page component rather than a page itself, you should be fine. Also, making use of transclusion / props.children can help with isolation. For an example, when I joined my company, they were using a Header component. They had made it once, thinking it would be the be-ann-and-end-all Header for the entire site. OF course it wasn't, the desngers made each page have a slightly different header. Different spacing, fonts, numbers of subheadings, different image positioning, etc. The Header has so many props and if statements, it was impossible to understand. Each small change affected every page on the site. The solution was to simplify and refactor. THere is now a header component that simply renders its children: ``` &lt;header&gt;{children}&lt;/header&gt; ``` It has it's own isolated styling: ``` header { height: 200px; } ``` Then we just pass in the page specific content ``` &lt;Header&gt; &lt;HomepageHeader /&gt; &lt;Header&gt; ``` HomepageHeader looks something like this: ``` &lt;h1&gt;Welcome to our site&lt;/h1&gt; &lt;p&gt;Have a look around&lt;/p&gt; ``` Then we can style it thusly, again making sure to isolate the styles: ``` h1, p { text-align:center } ``` So HomepageHeader gets it's own isolated styling. Do you see how clean that is? Everything is associated with the thing that owns it. I don't need a million classes. It's always super-simple to find the style rule I need.
Tried the demo... On Android, it shows two scrollbars. What's the intention of a custom scrollbar? Can't we already style and toggle scrollbars?
Maybe, is C++ the future of C? 
Also Flow still haven't figured out some pretty fundamental stuff properly yet. Obviously it's an inevitability when using files with an extension that's already used for something else, but the fact you have to turn off VSCode's built-in error validator to use Flow Types in JS files is a pretty huge turn-off IMO. 
Dude it's definitely not niche anymore (even if it doesn't seem super popular where you are)
He was rude though. Not calling you names doesn't mean he wasn't rude.
Compared to Javascript and ES6, yes TS is niche. 
For scroll-related stuff you might want to not use event listeners since they don't run in sync with rendering. Also, for scroll events which are passive by default in Chrome you don't need \`requestAnimationFrame\` since they are throttled by default. The self-promotion title is also a bit overzealous IMO.
You're correct. Some people just don't want to adapt to the times.
Google "javascript dynamic import" and start from there.
&gt;Tried the demo... On Android, it shows two scrollbars. Actually known bug, closest time i'll try to make a fix for mobiles (worst thing about scrolling on mobiles - it is impossible to determine the scrollbar's width and hide it) &amp;#x200B; &gt;What's the intention of a custom scrollbar? It's the only way to make them look the same on any browser (except the mobiles yet) &amp;#x200B; &gt;Can't we already style and toggle scrollbars? Nope %) At least it's not cross-browser, for now only chromium-driven browsers support scrollbars customisation (and it's very sad cause i'd prefer to use simple css instead of JS walkarounds) &amp;#x200B;
&gt; It has to sync with rendering to redraw the thumbs during the scrolling. But you'll never get scroll events to work in sync with rendering. At least not in &gt;Chrome 54, &gt;Firefox Quantum and Edge. Not sure about Safari. &gt; There are "a bit" more browsers than single Chrome. Yep, I know :) Chrome was beside the point. What I was trying to say was that since you're already using passive listeners, you dont need RAF. &gt; I just wondering what you've ment with "not to use event listeners" if not them - what to use? Just observe scrollTop on a RAF loop, if you go with that route. The property is cached so it takes basically no computing power, and you're 100% sure that it will trigger on each frame. This is what https://github.com/electerious/basicScroll does. See https://mobile.twitter.com/_baxuz/status/1026913627952095232 I'm currently forking react-window to use a similar approach. A minimal proof-of-concept is already performing better: https://codesandbox.io/s/y3o3wr7n59
Welcome :)
Well the pitfall was always the con-argue of it. About loop-observing - i've been thinking about that but has no time yet to check the performance impacts. But looks like basicScroll made it for me %) (didn't know about that lib)
So I skimmed through the changes and it's shocking how they still haven't added a lifecycle hook that can return a promise before resolving the component. In Vue2 they have a 'beforeRouteEnter' hook but it's dreadful. It doesn't work with promises and also you don't have access to 'this' inside the hook. Really disappointing.
With NodeJS you can just export a single function from a module, require into your app as a variable, and call the var-function just like you would your default function. You could do something like the following for each plugin: if (plugin !== null) { // use default func defaultFn() } else { plugin() } If you want to allow many plugins and to keep from copy-pasting that for each you'll likely need a "registry" (hash, dictionary, etc) for them in your app so it can easily keep track of e.g. the plugin name, the function it's replacing, and the plugins function. With that you could do something like the following to check for a plugin function if (typeof plugins[ 'someName' ] !== 'undefined') { // use the plugin function plugins[ 'someName' ].func() } else { defaultFn() } This should also work in regular ol' JS &amp; etc, though of course will require figuring out how to include the functions from the files. It could work to have the plugins wrapped in a variable, but then that needs to be standardized such as being the plugin name + the same as the file name, and only allowing one of each name to exist and throwing an error if there's multiple.
Cool concept. The few boilerplatey niggles with the context API can be annoying to deal with, so a shim over it which can handle update edge cases makes sense!
Sure. It may work for trivial methods, but how would it work for code that interacts with frameworks such as angular or react? How do you ensure that the mutations are valid markers? If the answer is that the mutations are just a guideline, then you should be no more dogmatic in your pursuit of mutation coverage than in that of code coverage. May want to blog about some of these things to show the viability of this approach in Real World apps.
/r/web_design ...
Indeed, I \*hated\* Typescript, found it was unnecessary - that the types were too rigid to be of any use, and more trouble than it was worth. Then I figured out that it's actually quite brilliant, allowing you to basically catch your code problems \*as you type\* (thanks to VSCode tooling) - rather than as you compile and run. It's basically the revolution that happened when MS Word went from Word 6.0 to Word 95, and they added the little red squiggly line that pointed out misspelled words. (Now that squiggly line is everywhere - even in this browser window!) It also cuts down on the amount of documentation you have to write and the amount of time you have to spend unit testing for edge cases like: What if I'm getting "154.398" passed in instead of 154.398 here? What if I'm looking for obj.child.grandchild and obj.child isn't defined? Are all my exceptions handled? To be fair, some advanced aspects of typescript are intimidating (Public, Private, Protected? I don't care.) but for the most part, whenever I have a choice, I'll choose Typescript\*. &amp;#x200B; \*flow is good too
hi, I think I might have found myself in the same situation. I couldn't find anything that did what I needed so wrote this... [https://github.com/DevSnicket/plugin-discovery](https://github.com/DevSnicket/plugin-discovery)
The page source (right-click &gt; view source) only shows the original, unaltered HTML source of the page. It is what the downloaded html file actually looked like. Any JavaScript changes can be viewed in the DOM elements section of the developer tools, but not in the source.
Are there no other script tags? Even just tags referencing a URL?
I highly recommend the stuff by Steve Schroger and his refactoring UI stuff.
public, private and protected is really useful for library authors to hide parts of their API for you not to accidentally use them. This happens a lot in JavaScript. Now you're ignoring them, maybe, but ECMAScript is currently implementing them natively (As e.g. #x, #y properties) so you probably won't get around them (or you do, that's the point of privates, depending on if you're authoring libraries yourself) I believe, in the foreseeable future, with languages like PHP getting native typing, too, TypeScript will slowly (further) flow into ECMAScript and at some point you get strict typing, maybe even at runtime, in ECMAScript, too. I mean, it's obvious the community would rather use an (optionally) strictly typed language based on TypeScript's and Flow's popularity.
Applying CSS in JS means changing the `style` attribute of the element. `style` attribute always overrides any external CSS so you don’t need to do anything special. element.style = 'position: absolute; top: 50%;' or: element.style.position = 'absolute; element.style.top = '50%';
Anyone that says your "structure is trash" without offering actual pointers to make it better isn't actually helping you. They're just helping their own ego. It's likely that they've read a book and think they know what they're talking about, but probably don't actually code very well. Looking at your code, I noticed you started to make a class, then just make a bunch of functions. You might be better served by continue to make that class. Also, you've got a ton of security problems. By creating the html in text and just adding the names/etc to it, you open yourself up to XSS and other vulnerabilities. At the very least you should be escaping the user-entered text, but it'd be a lot safer to just use the DOM createElement function and add the elements that way. For performance, you can add all the nodes to a Document Fragment and then add that fragment to the DOM. I would probably also have something that simplifies creating tasks' elements with a single function so that you're not duplicating that code all over the place. (And to be honest, I'd probably use React instead of coding it all the DOM stuff myself, but this seems like it's a learning exercise and so it's probably a good way for you to do it.)
There are no other script tags. Here's what the complete page Source shows : [https://imgur.com/b8zYDPf](https://imgur.com/b8zYDPf) &amp;#x200B;
Find a good designer and learn from him. Work with him, do some projects with him, ask why he does things the way he does. Take a look at color theory and typography (Wikipedia is a good start!). Settle for a program (you will mostly choose between Adobe Illustrator and Adobe Photoshop, personally I love Illustrator) and learn how to use it, design some websites or single elements with it. Copy from successful examples! Really, try to re-build successful or nice examples of design elements, look for websites you find visually appealing and try to re-create them from scratch. Design them yourself, code them yourself. If you want to be a full-fledged programmer at some point, keep in mind, your design will probably always be mediocre and real work should still be done by a full-time dedicated designer. Choose to make more design and creative work, and you might end up not being a full-fledged programmer. Since it all depends on how much time you're willing (and able) to put into each of those two (really completely different) fields of IT.
It must be the `location.replace`, I guess. That would have the effect of reloading the page for all Javascript-enabled browsers. So it gets an http request, then reloads it and the second time you get the full page with the javascript? And the fact that it's a `replace` means the browser doesn't update with the new source code? Bit of a head-scratcher.
Anyone else feel like web development skills are getting spread a little thin? Expected to be skilled in front end, back end, and design
That does refresh the page. But I don't get how another page refresh would automagically inject scripts tags which still don't show on the page source. ¯\\\_(ツ)\_/¯
Read books about design, follow the work of pro designers, use designs of pros, practise etc.
This is not what I'm seeing at all. I see this: https://imgur.com/vrrK7cq I think yours is the code *before* the redirect that location.replace would perform
I think the industry tend to understand that developers are not designers and with stuff like bootstrap it’s easier to start building stuff without design knowledge. However, I guess front or fullstack dev like myself fells irritating to build basic UI. I like animation and user interface design but I always make the worst choices. Maybe it’s just developers being frustrated to be able to create great app with awesome features but poor design..
Absolutely! I feel like there's so much to learn, I'm not going to be particularly good at any one thing. Design in particular I feel might be a bridge too far for me.
The code you linked is twitter's homepage when you're not logged in. 
You can also check out Refactoring UI. It has great examples of applying design principles and ideas to existing, functional pages. https://www.youtube.com/channel/UCxqiDtkXtOCNJdckODHk9YA 
Go to https://dribbble.com regularly and look at the designs there. What's good about them? Look how they use space.
I'm with /u/FiveYearsAgoOnReddit here. The code that I originally linked as source code (the source for non-logged-in users) is exactly what is downloaded by the javascript redirect (see \`/?lang=en\` in the network tab). The Javascript Location API made a lot of changes, like the ability to change the current page URL in place (instead of having to actually load a new page fresh), which is how a lot of Single Page Apps work. I'm assuming that this is how Chrome now displays this logic. I was aware that the location API allowed you to change the browser URL, but didn't realize that it could allow you to show the initial source code, then redirect to a page with new source code, and that view-source would still show the old source code. One thing is true, however: view-source cannot run JavaScript, so it would not run any redirects (as seen by the non-redirected source-code)
Autoinjecting via annotations with type safety: This reminds me of something... Considering that React, Typescript, and the complex build tools, NPM repositories, and now annotations are now hardly distinguishable from a Java, Spring, &amp; Maven project from 10 years ago, I can't help think that we've basically just reinvented the whole gigantic wheel here - poorly. I honestly think that we'd be 10 years ahead technologically and would have saved a massive amount of energy and mistakes had Firefox, Microsoft, and Google just agreed to fix the various performance and security issues that plagued Java Applets.
&gt; Not op, but I can easily envisage a future where "js" ceases to exist and all code, js or another language, gets compiled to web assembly. Then browser makers would only focus on performance and features of 1 language runtime, web assembly. You can probably do something almost the same by using F#/elmish to compile F# to javascript and blazor to compile F# to web assembly.
That's nice, but when I use parts of an API that the developer didn't intend for me to use, I do it *on purpose.*
&gt; Compared to Javascript and ES6, yes TS is niche Compared to that what isn't a niche? What do you think is used more? typescript or some of the following: PHP, Ruby, Go, Rust, Swift, Perl, Kotlin, Scala. 
oh sh#t, that was lame. thank you! :) 
Great resource, thanks for mentioning it 
why do you need to convert it to jQuery out of curiosity all jQuery is, is a wrapper for vanilla js &amp;#x200B;
Search the web for websites that are well designed - maybe they won an award. You can find tons of sites that list off what they think are well designed sites. I just searched for 'css websites' and this was the first hit: https://www.awwwards.com/websites/css3/ You can inspect any of those sites to see how they accomplish their designs, and as they say, imitation is the sincerest form of flattery. Read up on 'Page Layout Design' if you want to understand the principles of a clean looking page. Here's some tips I've learned off the top of my head: - alignment - you should use a framework like Bootstrap, Foundation, yada yada to help you design your site in rows and columns so elements have consistent spacing. - Hierarchy - Top menu items should be bigger and/or bolder than sub-menu items. - Consistency - use a 'style guide' (google "html/css style guides"). You want your styles to represent specific elements on your pages, and you want that to be consistent across your site, e.g. &lt;h2&gt; tags are always used for the 'title' of a page; the text on each page is styled the same, the spacing after a paragraph is always the same, etc. - minimize 'trapped white space' - read up on that too. Basically if you have empty space on your page, and it's surrounded on 3 or more sides by content, that's considered trapped white space, and usually detracts from a clean look on a page. - don't use straight up 'black', 'red', etc. Use a 'dirty' colors instead. instead of #000000 use #1002112 - just a couple hex numbers off. The eye actually notices even 1 or 2 hex numbers off, and the colors look more natural. Otherwise the colors end up looking like Windows 95. - choose a basic color scheme and design around it. Choose 3 colors, ideally colors that are in the logo/header, and use them fairly exclusively throughout the site. Look up '3 color palette'. - one I hear a lot lately is don't use font-size to specify hierarchy, instead use colors - darker for more primary text, lighter for secondary. - trust your instinct and spend the time. It's not going to come overnight. You will need to spend a lot of time experimenting, tweaking things, pushing pixels. You need to develop a an eye for it. You'll start to know if something is looking better or not. - some basic UX stuff - 'progressive disclosure' - only show the user what's pertinent to what they're doing. Don't clutter the page. - feeding on the last point, keep it simple stupid - people are distracted easily and don't want to look at your site if it's complicated. - take advantage of vertical scrolling. You don't need to fit everything 'above the fold'. People know how to use a scrollbar/mouse wheel. - since every site is responsive now, try the 'progressive enhancement' technique, where you build the site for mobile first, then add features as you scale up the screen size. I highly recommend this. Mobile is much simpler to design and you can get a basic site out quickly. Most complicated UIs don't work on mobile anyway. You can get a basic design out, then spend time adding features at different screen size break points. 
Correct. I missed this distinction in your original post. I have since tested again logged in and commented above on the thread regarding the redirect.
its*
I also always make the worst choices. Karen please come back...
Just put it in debug and you'll see what's wrong. In JQuery, you have to use "#" if you want to find something via id. i.e. $("#creditcard-country") but the parameter you passed is just "creditcard-country". 
Open your network tab in the dev tools and reload the page. There is, indeed, a first request for `/` which returns the response you mention in a comment. That does cause a _reload_, but that second request, has an additional `Referer: https://twitter.com/` header. So, they identify it as _the reload_, and on that reload, they do return the whole page. When you right-click and ask to view the source. The browser actually requests page again (without referrer) and so, they return the _mostly empty_ response.
I worked for a primarily graphics agency early on in my career and I took opportunity to sit down and discuss the “framework” of design. Although hard for me to pass on what I learned. By speaking to them using photoshop and illustrator my UI/UX came on leaps and bounds. I would suggest watching videos on the concept of design and user interface and methods and tricks that goes into them. It will engage your brain to do better. 
Imitate first, innovate second. 
maybe interviewer was just messing with me with such qts
Users will take a hot shit on your million dollar, world-changing app if they don’t like your UI. To most users, the UI *is* the app. Everything else is just expected to work and they’ll raise hell if, and when it doesn’t, call you incompetent, accuse you of being a nefarious crook out to steal their money, everything short of calling you Satan himself. That’s why it irritates me whenever devs call the FE “trivial.” Design ain’t trivial when all of it puts your job on the line. It’s a skill and craft in and of itself. 
Thank you so much! Network &gt; Checking Preserve log helps confirm this. 
#dailyui
Sounds like your interviewer didn't understand the question either, so you probably got a lucky escape
I wonder if the answer is nginx the question isn't very clear
That depends what kind of design you're talking about. Do you want to make things look neat and coherent? Do you want to make them look pretty and stylish? Or are you looking for something more like information architecture?
Maybe typical RH interviewer, has the answer writen in their notes, so even if your answers is right, they have no idea, unless you say what they want, you will always be wrong lol
Indian interviews bro, half of them don't know what they're talking about.
dribbble is also my go to spot for inspiration. Sometimes when the inspiration is needed for broader things than just UI I have a look at [https://niice.co/](https://niice.co/).
I just don't really have any aptitude for it, I've got (apparently) bad taste so even armed with a bit of knowledge I still don't make anything that nice by myself. I much prefer to work with a designer collaboratively
What exactly are you talking about? I see plenty of JS code that is getting loaded into the page after you log in. I count literally 9 script tags... 1 - google analytics 6 - nonces 2 - from abs.twimg.com The last 2 are the source code for twitter, one of which says "common" and the other which is for "home_page"
&gt;him them
&gt;Plans for the Next Iteration of Vue.js I would bet that's what the interviewer wanted for an answer. But even with that answer, the question doesn't make any sense.
Just keep yoinking the designs until you become good enough that someone will yoink yours. 
Look for inspiration from other well designed applications. Use something like dribbble or behance to find good designs. Hobestly, I'd recommend just getting good at wire framing and designing good experiences. If you have a good UX understanding the aesthetics will follow. Be consistent, think about hierarchy when building a screen (what's most important?), have a clear call to action, more padding almost always, consistent grids, etc. More times than not, less is better. Most importantly, observe your customers. Either hop on calls with them or use something like Hotjar to see how your customers use the app. 
Thank you so much for your answer ! Sadly the div is still constraint by its parent. Basically I have a series of div, one per project I want to showcase, those div are referred by the class "stack:nth-child(n)" individually and by the class "card top" as a whole. Those cards are contained in a "cards" div and the grid is created by the display:grid property applied to this "cards" div. A transform property is also applied to it to create the 3D perspective effect. I made another div with an id since everything is in class (as I said i use nth-child to modify some cards and keep some others), and put all the stuff relating to this specific card inside, as I don't know how to use the line you gave me with a class and not and Id. I'm sorry for my questions but I just don't know how to use Js most of the time. It works but the card I want to modify is still constraint by its parent... Is there a way to override every position property which affects a certain div, even thoses inherited ? In this case thoses under the class "stack:nth-child(n)" ? Here's my codepen if you want to check but it's quite a mess as I'm not a professionnal developper sadly. https://codepen.io/Goo_m_Ba/pen/zJmopr/ Also a more detailed post with some snippets and all I made last week, unanswered sadly. https://stackoverflow.com/questions/52444633/how-to-make-a-child-div-override-its-parent-position-in-a-grid Thank you again for helping me out and sorry for the grammar and syntax mistakes, english is not my native language. 
No that isn\`t the problem. I have like 30 variables but they are all domains and in my autocomplet code I said once you typed atleast 2 letters and a dot all the domains will show up. so for example if I type "nu" ([nu.nl](https://nu.nl), [nu.com](https://nu.com), [nu.net](https://nu.net) etc etc) But once I type more than the dot(.) so for example I want to type .com myself without clicking on the .com variable, I get this: (nu.comnl, nu.comcom, nu.comnet) so the thing I will type in after the dot will appear in front of all the variables. So what I want is when the person that doesn\`t choose a domain but just types after the dot that all the variables will just dissapear.
How else did you get an education in graphic design?
Not information architecture, but yes all the other stuff you mentioned. Any ideas?
Any specific books you recommend other than the one you mentioned? Any courses on there worth checking out?
How can I learn this?
You can still do that, with reflection. But keep in mind, these details not intended for you to use are subject to be changed, all the time. You never know when the next update of their library will break _your_ application. The only one you're hurting with it is yourself.
Well, it’s a different and interesting topic. When you write unit tests, you usually focus on logic and units - function which receive x and returns y. When react/angular are involved, it’s usually when UI automation / integration testing are involved- and code coverage is obviously less relevant.
Study what the top websites (Uber, Google, etc.) are doing, and try and think through why they made those decisions. &amp;#x200B; Also maybe look at design agencies/design-specific companies and how they do it. &amp;#x200B;
Good design is really just about alignment and padding plus nice colors and fonts. Simple is usually better. Luckily for you, there is an assload of examples of great design templates out there. I recommend starting a Pinterest board of designs you like before starting any project. Copy the colors and layouts you like and just change the content. You can also check out UI8 if you have photoshop or Sketch. Sketch is an absolutely amazing UI design program if you have some extra $$ Just as a rule of thumb, desktop design always uses spacing divisible by 10, 20, 100 pixels, etc Phones and tablets tend to use spacing of 8, 16, 32, 48, 64 (anything divisible by 8) Typically you need at least 48x48 for any press-able buttons or elements 
Both of these use special parent to child relationships. So adding a div in there between a parent and a child can really mess things up. For example, if your component is returning an array that will go into a flex table with rules applied to the whole table, they won't apply to the component array if there is a div between them.
This is the key
Is it just me or the website won't open?
Build some thing and ask others to use it. preferably newbies...(parents,uncles will be better) All their experiences with your UI will manifest as though the next time you build an other UI
I'd recommend reading https://practicaltypography.com
Use material design, there’s even a lightweight implementation : mdl, that’s framework agnostic. Look at how the UI is structured for popular apps. Think about how people are going to use your app. You have to think in UI and UX to design a good frontend. And: practice. 
I can't give any specific recommendations but I was looking at the paths just now. Honestly I have not read much past that book. Just to kind of give you an idea of what Plural Site has. Two that I would start with would be the graphic design path, its has 21 courses and is about 30 hours of videos. They also have a Adobe InDesign path which is 10 courses and 29 hours. Each path also have test you can take to see how well your retaining the material. They also have thousands of individual courses that people make that are not part of their main learning paths. The biggest down fall is a lot of these use the adobe suite which can be expensive.
I do a couple things that I think help me out a ton: I have a "mood board" on Pinterest that I add nice UI design examples to. You can literally find hundreds of thousands of wed design posts by just searching "web design" and then go from there. I also spend time scrolling through Dribbble. I usually base my designs off of something on there. Sometimes when I need something extra to do, I will find something on Dribbble like a menu layout or a contact form to replicate without any CSS frameworks. I don't consider myself a designer at all, and I'm never gonna be the guy who can sit down on Sketch and build something without looking at Dribbble or Pinterest mockup a thousand times. I'm never gonna be the guy who will sit and make SVG graphics and so on, but I can be the guy who pulls inspiration from someone who's already done it! Which is what I suspect most designers do anyway. 
Yeah it's a learning exercise for sure and I understand it's not the easiest way to do it and frameworks will help a lot. Thank you for all of your critiques and when I get the time I will go back to this project and make it better :) .
Thank you for this comment, it means so much and I will be looking back at it throughout my development of the chess app. I can't express in words how much I appreciate this, thank you!
i dont get the question, but i'm taking a bachelors degree in visual communication :)
I'm pulling this out of my ass, but I would bet that ~90% of all successful startups have a dedicated designer on their dev team. 
Anecdotal, huh? Here's some objective hard data for you: https://insights.stackoverflow.com/survey/2018#technology Sure, ES6/7 is the mainstream, but you can't dismiss TS as being "a niche at best". Many important projects are already written or being rewritten in TS (Vue, Inferno, MobX, etc).
I thought i wasn’t good at designing the web because I’m more backend oriented. Well, it’s just excuses of mine. Just like anything else, it’s just a skill so put more time into it will make you good at it. It’s about commitment but I got to agree that I don’t like design either. I like Vue and bootstrap because 10 of the time, it will make my website look unique.
Don’t do it. Better to spend your time to sharp your dev’s skills. If you need a design just buy it. It will be more efficient. There is a lot beginners who would work for portfolio or low price. 
const masochist = process.env.USER
Express wasn’t mentioned here... that’s the only thing I can think of that might be what they were looking for? Horribly framed question. lol
no, i thought i would google it afterinterview
Node.js is a valid answer, because Node.js can work as a HTTP server (and that's the most usual scenario). It's not like PHP where you'd need an interface in between the server and php interpreter/compiler/w.e. It's doable that way but it's non-standard (this doesn't mean there's a spec for it, it's just uncommon) and you are taking away the concurrency model that node.js offers by doing that.
Are you loading JQuery with your TamperMonkey script, or trying to use the JQuery that loads with the site?
Watch this playlist: [https://www.youtube.com/watch?v=aWf1LpUnYmU&amp;list=PLpQQipWcxwt9U7qgyYkvNH3Mp8XHXCMmQ](https://www.youtube.com/watch?v=aWf1LpUnYmU&amp;list=PLpQQipWcxwt9U7qgyYkvNH3Mp8XHXCMmQ) It will get you going but to really get good at design you need to absorb all sorts of things. From arts, to cultures, literature, everything "with taste" is useful. A good rule of thumb: follow other people with good taste.
Sorry I thought the pic was enough....idk what I’m doing wrong.... I can’t start this app that I cloned..
Check out [Refactoring UI](https://refactoringui.com/). They take a very logical approach to what makes design “good” or “bad” that goes far beyond, “it looks right.” The way they work is they take a user interface and revamp it using their design principles. They really helped me up my design skills. They have a YouTube channel as well.
Trying to use the JQuery that loads with the site. 
If you're looking for some quick and dirty inspiration, Dribbble and Pinterest are pretty reliable. If you'd like some deeper appeal than the superficial "make this suck less" kind of inspiration, you're not going to find that by skimming website design showcase blogs. I don't what kind of person you are, but you can begin by studying analog mediums. You'd be surprised at how the newest trends in auto design, product design, retail design, interior design, and pretty all the rest of the designs parallel each other. Various visual languages all use the same vocabulary, whether it be contract, palette, bright, dark, hard, soft, sharp, rounded, abrasive, or gentle. You can find inspiration for a layout in a quilt. Once you've found a vein to tap into, surround yourself with it. I've never met a good designer with a boring house.
that's lovely! there used to be one written by David Byrden at http://byrden.com/puzzles/ it's in Java. Been looking for a js version! great work. Wish there's a dodecahedron one.
Great question. I think about this a lot as well. As someone who was previously really bad at design and has gradually gotten a little bit better: 1. The book that really got me into this was Information Dashboard Design by Stephen Few: https://www.amazon.com/Information-Dashboard-Design-Effective-Communication/dp/0596100167. Tufte has some really great work as well. 2. Any time I find a design that I like, I take a full-page screenshot and save it to a folder in my notes system. I have about 40 full-page screenshots that I turn to. 3. Five Interface Laws Every Software Designer Should Know: https://speakerdeck.com/roundedbygravity/5-interface-laws-every-software-designer-should-know 4. This great Quora Post on color science: https://www.quora.com/Is-there-a-science-to-picking-colors-that-work-well-together-or-is-it-just-subjective/answer/Colm-Tuite 5. Ian Storm Taylor - Never Use Black: https://ianstormtaylor.com/design-tip-never-use-black/
- Microsoft after copy pasting java
I don't think a developer absolutely *needs* to be great at design, but it will make them a better developer. Just like a designer who has at least some fundamental knowledge of front-end technologies on the web will be a better designer for it, a developer who knows some of the basics of design will be a better developer. They'll be quicker and more accurate at translating wireframes or specs from a full-time designer to a working UI, they'll be better at spotting the little details, and they'll be better at filling in the gaps if a design is missing little things like different UI states, transitions, etc. I think design is a really valuable skill for a front-end dev to learn.
In one line: a little padding and line-height goes a *long* way to looking professional.
You have to create, amd use other tools and software's, and get pissed. If something is way harder than it needs to be, get fucking pissed about it and say "how could this shitty, horribly designed system be better?" Also, play videogames and see how good interfaces can be. Some of the most beautiful, complex AND easy to use interfaces are in videogames. For example, "our groceries" is a grocery app. Its good, but it has 2 major problems: it doesnt have the "add to list" button on both the top and bottom of the list while also starting at the top of the list after each entry (forcing you to scroll down to the bottom just to add another item like a complete fucking Neanderthal) and it doesnt auto ask what category (dairy, meat, produce, etc) to assign a brand new item it has never seen before. No joke, I will have to do 4 to 5 fucking button clicks to put "2% Milk" in the dairy category because I only buy almond milk and I haven't added 2% milk before. That is completely fucking unacceptable. There are at least 2 ways that would work better. See? If you get pissed about minor inconvenience, it helps you be a better designer. Also theres an assload of UX (NOT UI, UI is for artistry, not functionality) websites nowadays too. Source: got an MFA and had 1 on 1 tutoring from a UX professional
I also got asked to setup Linux servers ¯\_(ツ)_/¯ 
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
Nevermind, I just realized the event was on when the image was clicked not the A tag. Thank your for trying to help though. Sending click() to the img instead of the A tag caused the JQuery to execute. 
He has a book coming out, looking forward to that.
Heh ... when I still worked with websites, I always ised to tell our customers that as long as they have good content, any amount of SEO is truly a snake-oil -business they truly should not bother themselves with. The ones that believed me back then have (mostly) gone on with very nice websites and steady influx of users. The ones that didn’t, have (with very few exceptions) disappeared from the interwebs a long time ago.
I posted a screenshot in /r/javascript (1) a little while ago and people were curious about how it was implemented, so I wrote a little something about it. Hope you enjoy! 1. https://www.reddit.com/r/javascript/comments/9d6r41/water_dynamics_in_my_evolution_simulator_built_in/
I would appreciate the PM. Still wondering how I could do what I asked if it wasn't as simple as clicking the img. 
Use vanilla JS.
Actually, it *is* working. You've only put it on 1 of the options. Set both dropdowns to a country and then set the first one to the blank and you'll see that it blanks the second one.
I suppose it is a dependency. Did you ran `npm install` before you ran `npm start`?
"For the sixth year in a row, JavaScript is the most commonly used programming language." Pretty weak giving a stackOverflow link that supposes that the number of respondents to a stackOverflow survey reflects the actual use of these languages. That's some pretty dubious thinking. Surveys like these are notoriously bad at giving any real numbers - they are microcosm of the users of a specific service, not the world at large. Your "Many important projects" claim is also anecdotal and no justification for your "super popular" claim. Maybe it's popular/important in your little bubble, but not actually in the real world, where ES6/Javascript is actually the "super popular" language. 
Haha :D .. Neutralino cloud mode has a blacklist where some functions can be restricted :). 
I did a quick search and don't see that anybody has mentioned this book before, but a UI designer friend of mine recommended this one to me when I was considering stepping from technical writing to UI design. [Don't Make Me Think: A Common Sense Approach to Web Usability](https://www.amazon.com/Dont-Make-Me-Think-Usability/dp/0321344758). It's a short-ish book (206 pages) and well written. 
I just want to say THANK YOU! Because this was the only code that worked. Keep up the amazing work!
It's far more specialized now IMO. When I started out you needed to do absolutely every part of it, from setting up the servers, creating the databases, writing all HTML from scratch, creating all of the graphics, etc. Without any frameworks and with competing standards and needing to make it work across a number of incompatible browsers. But this is probably just me being all "Get of my lawn"-y.
Here's the reason why Twitter now do this, https://blog.twitter.com/engineering/en_us/topics/insights/2018/twitter_silhouette.html
Click on the first dropdown. Change it to a country. Click on the second dropdown. Change it to a country. Click on the first dropdown. Change it to the first entry, the blank one. Notice that the second dropdown changes to the blank entry, as it should.
No I cannot replicate this. Baffling me
Dribbble is good inspiration for aesthetics but don't take it as a Bible because plenty of good rules of functional design are sacrified for dem sexy pixels.
I graduated from Oregon State University this year with my CS degree (just to give a credentials background). Last year I took a course on Usability Engineering and the textbook was actually pretty nice. I have it in my office as a reference should I need it. It's called "Interaction Design: Beyond Human Computer Interaction" by Preece, Roger's. And Sharpe. That has some solid, practical advice :-) HCI is a pretty well-studied field in CS, try researching that for design patterns and improving your overall UX. Some quick advice though - you'll need to talk to your intended users and use their feedback in your design. The users know very quickly when something isnt working.
\&gt;&gt;him \&gt;them the entity
I've really enjoyed Erik Kennedy's blog: https://learnui.design/blog/ He has a full blown online course that looks promising, but I have't tried it. It's little pricey (but less then going to a class at a school) 
Is [this](https://jsfiddle.net/pgscasado/qjku3w6r/3/) what you want?
_In theory_, tabs allow each person to set the indentation level to their own preference. _In practice_, when we do alignment, then tabs need to be carefully mixed with spaces, and few people get that mixture right. So the end result is that source with tabs still only looks right at one particular indentation level, which defeats the entire point of tabs.
I've been using spaces for something 20 years and every place I've worked at as a programmer decided on spaces.
&gt; IMO, tabs are easier to type You don't press space-space-space-space, do you? We still just press the tab key.
You have to know about that just to be able to defend yourself these days because every website has a flock of 'digital marketing' vultures circling it at all times, where someone with an english degree who read 3 blogposts once puts your URL into a free online scanner and then tries to tell you how to make websites. 
I am a designer (formally trained) who works in front-end land writing code, so I’m going to probably tell you something that is going to get downvoted all to hell, but when I reflect on my nearly 2 decades of working making stuff for the web, this is the skill that is at the heart of all my layout and even usability choices: take some life drawing classes and learn to draw. Not because you will then draw a bunch of stuff that ends up in your work but because drawing teaches you how to look at things and break them down into the basic shapes that make up their form, and I find myself applying that way of looking at things ALL THE TIME in my front end work. Find a class at a local community college or rec/community center where you sit in a room for 2 hours at a time and just draw what the instructor has arranged for you for that session. After a few months you’ll start to see the bones of good UI designs and you’ll be able to start applying them to your own work. 
I think when it comes to something like a resume / portfolio though even other developers are going to be bias towards seeing thinks that are nice to look at. Humans are just very visual creatures and theres no way around that. I would encourage developers building a portfolio to even maybe try hiring a designer (hopefully you can find someone with a similar experience level i.e. don't pay $9000) to design a nice branded look for some of their projects. When asked about it saying "I hired a designer" would never make you look bad and building someones design would show you can work within other peoples requirements and not just your own. 
I've learned that sometimes, it depends totally on the codebase you're working on... Where I'm working right now, the indication is to indent using tabs that consist on four spaces. And specifically to use the tab key instead of adding four spaces manually
Are you missing developers with depth of knowledge in certain disciplines? 
&gt;I also check out https://www.awwwards.com/ from time to time. The thing im always most impressed with on the site that win there is like, how did they get the client to let them make something so nice. 90% of the time most of the ugliness in most sites comes from business stakeholders all needing to get their say in about something. Ive ruined a lot of sites because a CFO decided they're also a UI/UX expert. 
You're right about major browsers. However, many people don't have the latest versions of major browsers. You may be surprised to know that for many organizations and individuals, the last browser update was over five years ago.
I deal with this a lot at the job I am at currently. I collabed with out designer on this site recently http://thevanakendistrict.com/ The client gave us an idea of the feel they wanted and an example site and we picked and chose parts and made them our own. Not all clients are like that though sadly. The best way is to ask questions. Ask about colors. Ask about some sites they like. Look at their competition and pull stuff you think is cool from them and combine them into a good experience. Most clients will be pretty open if you can back your ideas up and such. I still deal with clients who think they are UX/UI experts though as well. Just gotta gently nudge them!
As stated in the output - ```Local package.json exists, but node_modules missing, did you mean to install?``` did you install?